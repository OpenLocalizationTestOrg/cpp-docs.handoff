{"nodes":[{"pos":[12,46],"content":"Prolog and Epilog | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Prolog and Epilog | Microsoft Docs","pos":[0,34]}]},{"content":"Prolog and Epilog","pos":[526,543]},{"content":"Every function that allocates stack space, calls other functions, saves nonvolatile registers, or uses exception handling must have a prolog whose address limits are described in the unwind data associated with the respective function table entry (see <bpt id=\"p1\">[</bpt>Exception Handling (x64)<ept id=\"p1\">](../build/exception-handling-x64.md)</ept>).","pos":[544,860],"source":"Every function that allocates stack space, calls other functions, saves nonvolatile registers, or uses exception handling must have a prolog whose address limits are described in the unwind data associated with the respective function table entry (see [Exception Handling (x64)](../build/exception-handling-x64.md))."},{"content":"The prolog saves argument registers in their home addresses if required, pushes nonvolatile registers on the stack, allocates the fixed part of the stack for locals and temporaries, and optionally establishes a frame pointer.","pos":[861,1086]},{"content":"The associated unwind data must describe the action of the prolog and must provide the information necessary to undo the effect of the prolog code.","pos":[1087,1234]},{"content":"If the fixed allocation in the stack is more than one page (that is, greater than 4096 bytes), then it is possible that the stack allocation could span more than one virtual memory page and, therefore, the allocation must be checked before it is actually allocated.","pos":[1241,1506]},{"content":"A special routine that is callable from the prolog and which does not destroy any of the argument registers is provided for this purpose.","pos":[1507,1644]},{"content":"The preferred method for saving nonvolatile registers is to move them onto the stack before the fixed stack allocation.","pos":[1651,1770]},{"content":"If the fixed stack allocation were performed before the nonvolatile registers were saved, then most probably a 32-bit displacement would be required to address the saved register area (reportedly, pushes of registers are just as fast as moves and should remain so for the foreseeable future in spite of the implied dependency between pushes).","pos":[1771,2113]},{"content":"Nonvolatile registers can be saved in any order.","pos":[2114,2162]},{"content":"However, the first use of a nonvolatile register in the prolog must be to save it.","pos":[2163,2245]},{"content":"The code for a typical prolog might be:","pos":[2252,2291]},{"content":"This prolog stores the argument register RCX in its home location, saves nonvolatile registers R13-R15, allocates the fixed part of the stack frame, and establishes a frame pointer that points 128 bytes into the fixed allocation area.","pos":[2448,2682]},{"content":"Using an offset allows more of the fixed allocation area to be addressed with one-byte offsets.","pos":[2683,2778]},{"content":"If the fixed allocation size is greater than or equal to one page of memory, then a helper function must be called before modifying RSP.","pos":[2785,2921]},{"content":"This helper, __chkstk, is responsible for probing the to-be-allocated stack range, to ensure that the stack is extended properly.","pos":[2922,3051]},{"content":"In that case, the previous prolog example would instead be:","pos":[3052,3111]},{"content":"The __chkstk helper will not modify any registers other than R10, R11, and the condition codes.","pos":[3307,3402]},{"content":"In particular, it will return RAX unchanged and leave all nonvolatile registers and argument-passing registers unmodified.","pos":[3403,3525]},{"content":"Epilog code exists at each exit to a function.","pos":[3532,3578]},{"content":"Whereas there is normally only one prolog, there can be many epilogs.","pos":[3579,3648]},{"content":"Epilog code trims the stack to its fixed allocation size (if necessary), deallocates the fixed stack allocation, restores nonvolatile registers by popping their saved values from the stack, and returns.","pos":[3649,3851]},{"content":"The epilog code must follow a strict set of rules for the unwind code to reliably unwind through exceptions and interrupts.","pos":[3858,3981]},{"content":"This reduces the amount of unwind data required, because no extra data is needed to describe each epilog.","pos":[3982,4087]},{"content":"Instead, the unwind code can determine that an epilog is being executed by scanning forward through a code stream to identify an epilog.","pos":[4088,4224]},{"content":"If no frame pointer is used in the function, then the epilog must first deallocate the fixed part of the stack, the nonvolatile registers are popped, and control is returned to the calling function.","pos":[4231,4429]},{"content":"For example,","pos":[4430,4442]},{"content":"If a frame pointer is used in the function, then the stack must be trimmed to its fixed allocation prior to the execution of the epilog.","pos":[4553,4689]},{"content":"This is technically not part of the epilog.","pos":[4690,4733]},{"content":"For example, the following epilog could be used to undo the prolog previously used:","pos":[4734,4817]},{"content":"In practice, when a frame pointer is used, there is no good reason to adjust RSP in two steps, so the following epilog would be used instead:","pos":[4986,5127]},{"content":"These are the only legal forms for an epilog.","pos":[5249,5294]},{"content":"It must consist of either an <ph id=\"ph1\">`add RSP,constant`</ph> or <ph id=\"ph2\">`lea RSP,constant[FPReg]`</ph>, followed by a series of zero or more 8-byte register pops and a return or a jmp.","pos":[5295,5453],"source":" It must consist of either an `add RSP,constant` or `lea RSP,constant[FPReg]`, followed by a series of zero or more 8-byte register pops and a return or a jmp."},{"content":"(Only a subset of jmp statements are allowable in the epilog.","pos":[5454,5515]},{"content":"These are exclusively of the class of jmps with ModRM memory references where ModRM mod field value 00.","pos":[5516,5619]},{"content":"The use of jmps in the epilog with ModRM mod field value 01 or 10 is prohibited.","pos":[5620,5700]},{"content":"See Table A-15 in the AMD x86-64 Architecture Programmerâ€™s Manual Volume 3: General Purpose and System Instructions, for more info on the allowable ModRM references.).","pos":[5701,5868]},{"content":"No other code can appear.","pos":[5869,5894]},{"content":"In particular, nothing can be scheduled within an epilog, including loading of a return value.","pos":[5895,5989]},{"content":"Note that, when a frame pointer is not used, the epilog must use <ph id=\"ph1\">`add RSP,constant`</ph> to deallocate the fixed part of the stack.","pos":[5996,6122],"source":"Note that, when a frame pointer is not used, the epilog must use `add RSP,constant` to deallocate the fixed part of the stack."},{"content":"It may not use <ph id=\"ph1\">`lea RSP,constant[RSP]`</ph> instead.","pos":[6123,6170],"source":" It may not use `lea RSP,constant[RSP]` instead."},{"content":"This restriction exists so the unwind code has fewer patterns to recognize when searching for epilogs.","pos":[6171,6273]},{"content":"Following these rules allows the unwind code to determine that an epilog is currently being executed and to simulate execution of the remainder of the epilog to allow recreating the context of the calling function.","pos":[6280,6494]},{"content":"See Also","pos":[6503,6511]},{"content":"x64 Software Conventions","pos":[6516,6540]}],"content":"---\ntitle: \"Prolog and Epilog | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Prolog and Epilog\nEvery function that allocates stack space, calls other functions, saves nonvolatile registers, or uses exception handling must have a prolog whose address limits are described in the unwind data associated with the respective function table entry (see [Exception Handling (x64)](../build/exception-handling-x64.md)). The prolog saves argument registers in their home addresses if required, pushes nonvolatile registers on the stack, allocates the fixed part of the stack for locals and temporaries, and optionally establishes a frame pointer. The associated unwind data must describe the action of the prolog and must provide the information necessary to undo the effect of the prolog code.  \n  \n If the fixed allocation in the stack is more than one page (that is, greater than 4096 bytes), then it is possible that the stack allocation could span more than one virtual memory page and, therefore, the allocation must be checked before it is actually allocated. A special routine that is callable from the prolog and which does not destroy any of the argument registers is provided for this purpose.  \n  \n The preferred method for saving nonvolatile registers is to move them onto the stack before the fixed stack allocation. If the fixed stack allocation were performed before the nonvolatile registers were saved, then most probably a 32-bit displacement would be required to address the saved register area (reportedly, pushes of registers are just as fast as moves and should remain so for the foreseeable future in spite of the implied dependency between pushes). Nonvolatile registers can be saved in any order. However, the first use of a nonvolatile register in the prolog must be to save it.  \n  \n The code for a typical prolog might be:  \n  \n```  \nmov       [RSP + 8], RCX  \npush   R15  \npush   R14  \npush   R13  \nsub      RSP, fixed-allocation-size  \nlea      R13, 128[RSP]  \n...  \n```  \n  \n This prolog stores the argument register RCX in its home location, saves nonvolatile registers R13-R15, allocates the fixed part of the stack frame, and establishes a frame pointer that points 128 bytes into the fixed allocation area. Using an offset allows more of the fixed allocation area to be addressed with one-byte offsets.  \n  \n If the fixed allocation size is greater than or equal to one page of memory, then a helper function must be called before modifying RSP. This helper, __chkstk, is responsible for probing the to-be-allocated stack range, to ensure that the stack is extended properly. In that case, the previous prolog example would instead be:  \n  \n```  \nmov       [RSP + 8], RCX  \npush   R15  \npush   R14  \npush   R13  \nmov      RAX,  fixed-allocation-size  \ncall   __chkstk  \nsub      RSP, RAX  \nlea      R13, 128[RSP]  \n...  \n```  \n  \n The __chkstk helper will not modify any registers other than R10, R11, and the condition codes. In particular, it will return RAX unchanged and leave all nonvolatile registers and argument-passing registers unmodified.  \n  \n Epilog code exists at each exit to a function. Whereas there is normally only one prolog, there can be many epilogs. Epilog code trims the stack to its fixed allocation size (if necessary), deallocates the fixed stack allocation, restores nonvolatile registers by popping their saved values from the stack, and returns.  \n  \n The epilog code must follow a strict set of rules for the unwind code to reliably unwind through exceptions and interrupts. This reduces the amount of unwind data required, because no extra data is needed to describe each epilog. Instead, the unwind code can determine that an epilog is being executed by scanning forward through a code stream to identify an epilog.  \n  \n If no frame pointer is used in the function, then the epilog must first deallocate the fixed part of the stack, the nonvolatile registers are popped, and control is returned to the calling function. For example,  \n  \n```  \nadd      RSP, fixed-allocation-size  \npop      R13  \npop      R14  \npop      R15  \nret  \n```  \n  \n If a frame pointer is used in the function, then the stack must be trimmed to its fixed allocation prior to the execution of the epilog. This is technically not part of the epilog. For example, the following epilog could be used to undo the prolog previously used:  \n  \n```  \nlea      RSP, -128[R13]  \n; epilogue proper starts here  \nadd      RSP, fixed-allocation-size  \npop      R13  \npop      R14  \npop      R15  \nret  \n```  \n  \n In practice, when a frame pointer is used, there is no good reason to adjust RSP in two steps, so the following epilog would be used instead:  \n  \n```  \nlea      RSP, fixed-allocation-size â€“ 128[R13]  \npop      R13  \npop      R14  \npop      R15  \nret  \n```  \n  \n These are the only legal forms for an epilog. It must consist of either an `add RSP,constant` or `lea RSP,constant[FPReg]`, followed by a series of zero or more 8-byte register pops and a return or a jmp. (Only a subset of jmp statements are allowable in the epilog. These are exclusively of the class of jmps with ModRM memory references where ModRM mod field value 00. The use of jmps in the epilog with ModRM mod field value 01 or 10 is prohibited. See Table A-15 in the AMD x86-64 Architecture Programmerâ€™s Manual Volume 3: General Purpose and System Instructions, for more info on the allowable ModRM references.). No other code can appear. In particular, nothing can be scheduled within an epilog, including loading of a return value.  \n  \n Note that, when a frame pointer is not used, the epilog must use `add RSP,constant` to deallocate the fixed part of the stack. It may not use `lea RSP,constant[RSP]` instead. This restriction exists so the unwind code has fewer patterns to recognize when searching for epilogs.  \n  \n Following these rules allows the unwind code to determine that an epilog is currently being executed and to simulate execution of the remainder of the epilog to allow recreating the context of the calling function.  \n  \n## See Also  \n [x64 Software Conventions](../build/x64-software-conventions.md)"}