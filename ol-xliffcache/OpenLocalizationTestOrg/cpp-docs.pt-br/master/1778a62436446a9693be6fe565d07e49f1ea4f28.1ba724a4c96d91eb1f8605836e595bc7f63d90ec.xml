{"nodes":[{"pos":[12,52],"content":"Bitwise Shift Operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Bitwise Shift Operators | Microsoft Docs","pos":[0,40]}]},{"content":"Bitwise Shift Operators","pos":[684,707]},{"pos":[708,838],"content":"The shift operators shift their first operand left (<ph id=\"ph1\">`&lt;&lt;`</ph>) or right (<ph id=\"ph2\">`&gt;&gt;`</ph>) by the number of positions the second operand specifies.","source":"The shift operators shift their first operand left (`<<`) or right (`>>`) by the number of positions the second operand specifies."},{"content":"Syntax","pos":[847,853]},{"content":"<bpt id=\"p1\">*</bpt>shift-expression<ept id=\"p1\">*</ept>:","pos":[857,876],"source":"*shift-expression*:"},{"content":"additive-expression","pos":[881,900]},{"pos":[908,1001],"content":"<bpt id=\"p1\">*</bpt>shift-expression<ept id=\"p1\">*</ept>  <ph id=\"ph1\">`&lt;&lt;`</ph>  <bpt id=\"p2\">*</bpt>additive-expression shift-expression<ept id=\"p2\">*</ept>  <ph id=\"ph2\">`&gt;&gt;`</ph>  <bpt id=\"p3\">*</bpt>additive-expression<ept id=\"p3\">*</ept>","source":"*shift-expression*  `<<`  *additive-expression shift-expression*  `>>`  *additive-expression*"},{"content":"Both operands must be integral values.","pos":[1008,1046]},{"content":"These operators perform the usual arithmetic conversions; the type of the result is the type of the left operand after conversion.","pos":[1047,1177]},{"content":"For leftward shifts, the vacated right bits are set to 0.","pos":[1184,1241]},{"content":"For rightward shifts, the vacated left bits are filled based on the type of the first operand after conversion.","pos":[1242,1353]},{"content":"If the type is <ph id=\"ph1\">`unsigned`</ph>, they are set to 0.","pos":[1354,1399],"source":" If the type is `unsigned`, they are set to 0."},{"content":"Otherwise, they are filled with copies of the sign bit.","pos":[1400,1455]},{"content":"For left-shift operators without overflow, the statement","pos":[1456,1512]},{"content":"is equivalent to multiplication by 2<ph id=\"ph1\">&lt;sup&gt;</ph>expr2<ph id=\"ph2\">&lt;/sup&gt;</ph>.","pos":[1552,1605],"source":"is equivalent to multiplication by 2<sup>expr2</sup>."},{"content":"For right-shift operators,","pos":[1606,1632]},{"pos":[1672,1769],"content":"is equivalent to division by 2<ph id=\"ph1\">&lt;sup&gt;</ph>expr2<ph id=\"ph2\">&lt;/sup&gt;</ph> if <ph id=\"ph3\">`expr1`</ph> is unsigned or has a nonnegative value.","source":"is equivalent to division by 2<sup>expr2</sup> if `expr1` is unsigned or has a nonnegative value."},{"content":"The result of a shift operation is undefined if the second operand is negative, or if the right operand is greater than or equal to the width in bits of the promoted left operand.","pos":[1776,1955]},{"content":"Since the conversions performed by the shift operators do not provide for overflow or underflow conditions, information may be lost if the result of a shift operation cannot be represented in the type of the first operand after conversion.","pos":[1962,2201]},{"content":"In this example, <ph id=\"ph1\">`x`</ph> is shifted left eight positions and <ph id=\"ph2\">`y`</ph> is shifted right eight positions.","pos":[2312,2406],"source":"In this example, `x` is shifted left eight positions and `y` is shifted right eight positions."},{"content":"The shifted values are added, giving 0xAA55, and assigned to <ph id=\"ph1\">`z`</ph>.","pos":[2407,2472],"source":" The shifted values are added, giving 0xAA55, and assigned to `z`."},{"content":"Shifting a negative value to the right yields half the original value, rounded down.","pos":[2479,2563]},{"content":"For example, –253 (binary 11111111 00000011) shifted right one bit produces –127 (binary 11111111 10000001).","pos":[2564,2672]},{"content":"A positive 253 shifts right to produce +126.","pos":[2673,2717]},{"content":"Right shifts preserve the sign bit.","pos":[2724,2759]},{"content":"When a signed integer shifts right, the most-significant bit remains set.","pos":[2760,2833]},{"content":"When an unsigned integer shifts right, the most-significant bit is cleared.","pos":[2834,2909]},{"content":"See Also","pos":[2918,2926]},{"content":"Left Shift and Right Shift Operators (&gt;&gt; and &lt;&lt;)","pos":[2931,2979],"source":"Left Shift and Right Shift Operators (>> and <<)"}],"content":"---\ntitle: \"Bitwise Shift Operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"operators [C++], bitwise\"\n  - \"shift operators, bitwise\"\n  - \"bitwise-shift operators\"\n  - \"operators [C++], shift\"\nms.assetid: d0485785-5c72-47e1-a7c0-0adde03ade23\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Bitwise Shift Operators\nThe shift operators shift their first operand left (`<<`) or right (`>>`) by the number of positions the second operand specifies.  \n  \n## Syntax  \n *shift-expression*:  \n *additive-expression*  \n  \n *shift-expression*  `<<`  *additive-expression shift-expression*  `>>`  *additive-expression*  \n  \n Both operands must be integral values. These operators perform the usual arithmetic conversions; the type of the result is the type of the left operand after conversion.  \n  \n For leftward shifts, the vacated right bits are set to 0. For rightward shifts, the vacated left bits are filled based on the type of the first operand after conversion. If the type is `unsigned`, they are set to 0. Otherwise, they are filled with copies of the sign bit. For left-shift operators without overflow, the statement  \n  \n```  \nexpr1 << expr2   \n```  \n  \n is equivalent to multiplication by 2<sup>expr2</sup>. For right-shift operators,  \n  \n```  \nexpr1 >> expr2   \n```  \n  \n is equivalent to division by 2<sup>expr2</sup> if `expr1` is unsigned or has a nonnegative value.  \n  \n The result of a shift operation is undefined if the second operand is negative, or if the right operand is greater than or equal to the width in bits of the promoted left operand.  \n  \n Since the conversions performed by the shift operators do not provide for overflow or underflow conditions, information may be lost if the result of a shift operation cannot be represented in the type of the first operand after conversion.  \n  \n```  \nunsigned int x, y, z;  \n  \nx = 0x00AA;  \ny = 0x5500;  \n  \nz = ( x << 8 ) + ( y >> 8 );  \n```  \n  \n In this example, `x` is shifted left eight positions and `y` is shifted right eight positions. The shifted values are added, giving 0xAA55, and assigned to `z`.  \n  \n Shifting a negative value to the right yields half the original value, rounded down. For example, –253 (binary 11111111 00000011) shifted right one bit produces –127 (binary 11111111 10000001). A positive 253 shifts right to produce +126.  \n  \n Right shifts preserve the sign bit. When a signed integer shifts right, the most-significant bit remains set. When an unsigned integer shifts right, the most-significant bit is cleared.  \n  \n## See Also  \n [Left Shift and Right Shift Operators (>> and <<)](../cpp/left-shift-and-right-shift-operators-input-and-output.md)"}