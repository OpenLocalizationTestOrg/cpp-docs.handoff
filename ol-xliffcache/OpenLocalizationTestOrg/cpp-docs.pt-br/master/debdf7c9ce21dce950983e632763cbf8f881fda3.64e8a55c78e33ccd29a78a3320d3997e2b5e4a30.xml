{"nodes":[{"pos":[12,76],"content":"Classes and Structs  (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Classes and Structs  (C++ Component Extensions) | Microsoft Docs","pos":[0,64]}]},{"content":"Classes and Structs  (C++ Component Extensions)","pos":[915,962]},{"content":"Declares a class or struct whose <bpt id=\"p1\">*</bpt>object lifetime<ept id=\"p1\">*</ept> is administered automatically.","pos":[963,1044],"source":"Declares a class or struct whose *object lifetime* is administered automatically."},{"content":"When the object is no longer accessible or goes out of scope, Visual C++ automatically discards the memory that is allocated to the object.","pos":[1045,1184]},{"content":"All Runtimes","pos":[1193,1205]},{"content":"Syntax","pos":[1211,1217]},{"content":"Parameters","pos":[1556,1566]},{"content":"<bpt id=\"p1\">*</bpt>class_access<ept id=\"p1\">*</ept> (optional)","pos":[1575,1600],"source":"*class_access* (optional)"},{"content":"The accessibility of the class or struct outside the assembly.","pos":[1604,1666]},{"content":"Possible values are <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`private`</ph> (<ph id=\"ph2\">`private`</ph> is the default).","pos":[1667,1739],"source":" Possible values are **public** and `private` (`private` is the default)."},{"content":"Nested classes or structs cannot have a <bpt id=\"p1\">*</bpt>class_access<ept id=\"p1\">*</ept> specifier.","pos":[1740,1805],"source":" Nested classes or structs cannot have a *class_access* specifier."},{"content":"name","pos":[1813,1817]},{"content":"The name of the class or struct.","pos":[1822,1854]},{"content":"<bpt id=\"p1\">*</bpt>modifier<ept id=\"p1\">*</ept> (optional)","pos":[1861,1882],"source":"*modifier* (optional)"},{"content":"<bpt id=\"p1\"> [</bpt>abstract<ept id=\"p1\">](../windows/abstract-cpp-component-extensions.md)</ept> and <bpt id=\"p2\">[</bpt>sealed<ept id=\"p2\">](../windows/sealed-cpp-component-extensions.md)</ept> are valid modifiers.","pos":[1885,2026],"source":" [abstract](../windows/abstract-cpp-component-extensions.md) and [sealed](../windows/sealed-cpp-component-extensions.md) are valid modifiers."},{"content":"<bpt id=\"p1\">*</bpt>inherit_access<ept id=\"p1\">*</ept> (optional)","pos":[2033,2060],"source":"*inherit_access* (optional)"},{"content":"The accessibility of <ph id=\"ph1\">`base_type`</ph>.","pos":[2064,2097],"source":" The accessibility of `base_type`."},{"content":"The only permitted accessibility is <ph id=\"ph1\">`public`</ph> (<ph id=\"ph2\">`public`</ph> is the default).","pos":[2098,2169],"source":" The only permitted accessibility is `public` (`public` is the default)."},{"content":"<bpt id=\"p1\">*</bpt>base_type<ept id=\"p1\">*</ept> (optional)","pos":[2176,2198],"source":"*base_type* (optional)"},{"content":"A base type.","pos":[2202,2214]},{"content":"However, a value type cannot act as a base type.","pos":[2215,2263]},{"pos":[2270,2494],"content":"For more information, see the language-specific descriptions of this parameter in the <ph id=\"ph1\">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]</ph> sections.","source":"For more information, see the language-specific descriptions of this parameter in the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)] and [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)] sections."},{"content":"Remarks","pos":[2503,2510]},{"content":"The default member accessibility of an object declared with <bpt id=\"p1\">**</bpt>ref class<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>value class<ept id=\"p2\">**</ept> is <ph id=\"ph1\">`private`</ph>.","pos":[2519,2625],"source":"The default member accessibility of an object declared with **ref class** or **value class** is `private`."},{"content":"And the default member accessibility of an object declared with <bpt id=\"p1\">**</bpt>ref struct<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>value struct<ept id=\"p2\">**</ept> is <ph id=\"ph1\">`public`</ph>.","pos":[2626,2737],"source":" And the default member accessibility of an object declared with **ref struct** or **value struct** is `public`."},{"content":"When a reference type inherits from another reference type, virtual functions in the base class must explicitly be overridden (with <bpt id=\"p1\">[</bpt>override<ept id=\"p1\">](../windows/override-cpp-component-extensions.md)</ept>) or hidden (with <bpt id=\"p2\">[</bpt>new (new slot in vtable)<ept id=\"p2\">](../windows/new-new-slot-in-vtable-cpp-component-extensions.md)</ept>).","pos":[2744,3044],"source":"When a reference type inherits from another reference type, virtual functions in the base class must explicitly be overridden (with [override](../windows/override-cpp-component-extensions.md)) or hidden (with [new (new slot in vtable)](../windows/new-new-slot-in-vtable-cpp-component-extensions.md))."},{"content":"The derived class functions must also be explicitly marked as <ph id=\"ph1\">`virtual`</ph>.","pos":[3045,3117],"source":" The derived class functions must also be explicitly marked as `virtual`."},{"content":"To detect at compile time whether a type is a <ph id=\"ph1\">`ref class`</ph> or <ph id=\"ph2\">`ref struct`</ph>, or a <ph id=\"ph3\">`value class`</ph> or <ph id=\"ph4\">`value struct`</ph>, use <ph id=\"ph5\">`__is_ref_class (``type``)`</ph>, <ph id=\"ph6\">`__is_value_class (``type``)`</ph>, or <ph id=\"ph7\">`__is_simple_value_class (``type``)`</ph>.","pos":[3124,3341],"source":"To detect at compile time whether a type is a `ref class` or `ref struct`, or a `value class` or `value struct`, use `__is_ref_class (``type``)`, `__is_value_class (``type``)`, or `__is_simple_value_class (``type``)`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Compiler Support for Type Traits<ept id=\"p1\">](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)</ept>.","pos":[3342,3476],"source":" For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)."},{"content":"For more information on classes and structs, see","pos":[3483,3531]},{"content":"Instantiating Classes and Structs","pos":[3542,3575]},{"content":"C++ Stack Semantics for Reference Types","pos":[3660,3699]},{"content":"Classes, Structures, and Unions","pos":[3765,3796]},{"content":"Destructors and finalizers in How to: Define and consume classes and structs (C++/CLI)","pos":[3843,3929]},{"content":"User-Defined Operators (C++/CLI)","pos":[4041,4073]},{"content":"User-Defined Conversions (C++/CLI)","pos":[4130,4164]},{"content":"How to: Wrap Native Class for Use by C","pos":[4223,4261]},{"content":"Generic Classes (C++/CLI)","pos":[4331,4356]},{"content":"Remarks","pos":[4463,4470]},{"pos":[4479,4665],"content":"See <bpt id=\"p1\">[</bpt>Ref classes and structs<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/hh699870.aspx)</ept> and <bpt id=\"p2\">[</bpt>Value classes and structs<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/apps/hh699861.aspx)</ept>.","source":"See [Ref classes and structs](http://msdn.microsoft.com/library/windows/apps/hh699870.aspx) and [Value classes and structs](http://msdn.microsoft.com/library/windows/apps/hh699861.aspx)."},{"content":"Parameters","pos":[4674,4684]},{"content":"<bpt id=\"p1\">*</bpt>base_type<ept id=\"p1\">*</ept> (optional)","pos":[4693,4715],"source":"*base_type* (optional)"},{"content":"A base type.","pos":[4719,4731]},{"content":"A <ph id=\"ph1\">`ref class`</ph> or <ph id=\"ph2\">`ref struct`</ph> can inherit from zero or more interfaces and zero or one <ph id=\"ph3\">`ref`</ph> types.","pos":[4732,4831],"source":" A `ref class` or `ref struct` can inherit from zero or more interfaces and zero or one `ref` types."},{"content":"A <ph id=\"ph1\">`value class`</ph> or <ph id=\"ph2\">`value struct`</ph> can only inherit from zero or more interfaces.","pos":[4832,4912],"source":" A `value class` or `value struct` can only inherit from zero or more interfaces."},{"content":"When you declare an object by using the <ph id=\"ph1\">`ref class`</ph> or <ph id=\"ph2\">`ref struct`</ph> keywords, the object is accessed by a handle to an object; that is, a reference-counter pointer to the object.","pos":[4919,5097],"source":"When you declare an object by using the `ref class` or `ref struct` keywords, the object is accessed by a handle to an object; that is, a reference-counter pointer to the object."},{"content":"When the declared variable goes out of scope, the compiler automatically deletes the underlying object.","pos":[5098,5201]},{"content":"When the object is  used as a parameter in a call or is stored in a variable, a handle to the object is actually passed or stored.","pos":[5202,5332]},{"content":"When you declare an object by using the <ph id=\"ph1\">`value class`</ph> or <ph id=\"ph2\">`value struct`</ph> keywords, the object lifetime of the declared object is not supervised.","pos":[5339,5482],"source":"When you declare an object by using the `value class` or `value struct` keywords, the object lifetime of the declared object is not supervised."},{"content":"The object is like any other standard C++ class or struct.","pos":[5483,5541]},{"content":"Requirements","pos":[5551,5563]},{"pos":[5567,5591],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Remarks","pos":[5677,5684]},{"pos":[5693,5814],"content":"The following table lists differences from the syntax shown in the <bpt id=\"p1\">**</bpt>All Runtimes<ept id=\"p1\">**</ept> section that are specific to C++/CLI.","source":"The following table lists differences from the syntax shown in the **All Runtimes** section that are specific to C++/CLI."},{"content":"Parameters","pos":[5823,5833]},{"content":"<bpt id=\"p1\">*</bpt>base_type<ept id=\"p1\">*</ept> (optional)","pos":[5842,5864],"source":"*base_type* (optional)"},{"content":"A base type.","pos":[5868,5880]},{"content":"A <ph id=\"ph1\">`ref class`</ph> or <ph id=\"ph2\">`ref struct`</ph> can inherit from zero or more managed interfaces and zero or one ref types.","pos":[5881,5986],"source":" A `ref class` or `ref struct` can inherit from zero or more managed interfaces and zero or one ref types."},{"content":"A <ph id=\"ph1\">`value class`</ph> or <ph id=\"ph2\">`value struct`</ph> can only inherit from zero or more managed interfaces.","pos":[5987,6075],"source":" A `value class` or `value struct` can only inherit from zero or more managed interfaces."},{"content":"The <ph id=\"ph1\">`ref class`</ph> and <ph id=\"ph2\">`ref struct`</ph> keywords tell the compiler that the class or structure is to be allocated on the heap.","pos":[6082,6201],"source":"The `ref class` and `ref struct` keywords tell the compiler that the class or structure is to be allocated on the heap."},{"content":"When the object is  used as a parameter in a call or is stored in a variable, a reference to the object is actually passed or stored.","pos":[6202,6335]},{"pos":[6342,6502],"content":"The <ph id=\"ph1\">`value class`</ph> and <ph id=\"ph2\">`value struct`</ph> keywords tells the compiler that the value of the allocated class or structure is passed to functions or stored in members.","source":"The `value class` and `value struct` keywords tells the compiler that the value of the allocated class or structure is passed to functions or stored in members."},{"content":"Requirements","pos":[6512,6524]},{"pos":[6528,6553],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"See Also","pos":[6562,6570]},{"content":"Component Extensions for Runtime Platforms","pos":[6575,6617]}],"content":"---\ntitle: \"Classes and Structs  (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"public\"\n  - \"ref struct\"\n  - \"value_CPP\"\n  - \"ref class\"\n  - \"value struct\"\n  - \"ref struct_cpp\"\n  - \"ref class_cpp\"\n  - \"value class_cpp\"\n  - \"value struct_cpp\"\n  - \"value class\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"ref class keyword [C++]\"\n  - \"value class keyword [C++]\"\n  - \"value struct keyword [C++]\"\n  - \"ref struct keyword [C++]\"\nms.assetid: 5c360764-b229-49c6-9357-66213afbc372\ncaps.latest.revision: 32\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Classes and Structs  (C++ Component Extensions)\nDeclares a class or struct whose *object lifetime* is administered automatically. When the object is no longer accessible or goes out of scope, Visual C++ automatically discards the memory that is allocated to the object.  \n  \n## All Runtimes  \n **Syntax**  \n  \n```  \n  \n      class_access  \n      ref class  \n      name  \n      modifier :  inherit_accessbase_type {};  \nclass_accessref structnamemodifier :  inherit_accessbase_type {};  \nclass_accessvalue classnamemodifier :  inherit_accessbase_type {};  \nclass_accessvalue structnamemodifier :  inherit_accessbase_type {};  \n  \n```  \n  \n **Parameters**  \n  \n *class_access* (optional)  \n The accessibility of the class or struct outside the assembly. Possible values are **public** and `private` (`private` is the default). Nested classes or structs cannot have a *class_access* specifier.  \n  \n *name*  \n The name of the class or struct.  \n  \n *modifier* (optional)  \n [abstract](../windows/abstract-cpp-component-extensions.md) and [sealed](../windows/sealed-cpp-component-extensions.md) are valid modifiers.  \n  \n *inherit_access* (optional)  \n The accessibility of `base_type`. The only permitted accessibility is `public` (`public` is the default).  \n  \n *base_type* (optional)  \n A base type. However, a value type cannot act as a base type.  \n  \n For more information, see the language-specific descriptions of this parameter in the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)] and [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)] sections.  \n  \n **Remarks**  \n  \n The default member accessibility of an object declared with **ref class** or **value class** is `private`. And the default member accessibility of an object declared with **ref struct** or **value struct** is `public`.  \n  \n When a reference type inherits from another reference type, virtual functions in the base class must explicitly be overridden (with [override](../windows/override-cpp-component-extensions.md)) or hidden (with [new (new slot in vtable)](../windows/new-new-slot-in-vtable-cpp-component-extensions.md)). The derived class functions must also be explicitly marked as `virtual`.  \n  \n To detect at compile time whether a type is a `ref class` or `ref struct`, or a `value class` or `value struct`, use `__is_ref_class (``type``)`, `__is_value_class (``type``)`, or `__is_simple_value_class (``type``)`. For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md).  \n  \n For more information on classes and structs, see  \n  \n-   [Instantiating Classes and Structs](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md)  \n  \n \n  \n-   [C++ Stack Semantics for Reference Types](../dotnet/cpp-stack-semantics-for-reference-types.md)  \n  \n-   [Classes, Structures, and Unions](../cpp/classes-and-structs-cpp.md)  \n  \n-   [Destructors and finalizers in How to: Define and consume classes and structs (C++/CLI)](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers)  \n  \n-   [User-Defined Operators (C++/CLI)](../dotnet/user-defined-operators-cpp-cli.md)  \n  \n-   [User-Defined Conversions (C++/CLI)](../dotnet/user-defined-conversions-cpp-cli.md)  \n  \n-   [How to: Wrap Native Class for Use by C#](../dotnet/how-to-wrap-native-class-for-use-by-csharp.md)  \n  \n-   [Generic Classes (C++/CLI)](../windows/generic-classes-cpp-cli.md)  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n **Remarks**  \n  \n See [Ref classes and structs](http://msdn.microsoft.com/library/windows/apps/hh699870.aspx) and [Value classes and structs](http://msdn.microsoft.com/library/windows/apps/hh699861.aspx).  \n  \n **Parameters**  \n  \n *base_type* (optional)  \n A base type. A `ref class` or `ref struct` can inherit from zero or more interfaces and zero or one `ref` types. A `value class` or `value struct` can only inherit from zero or more interfaces.  \n  \n When you declare an object by using the `ref class` or `ref struct` keywords, the object is accessed by a handle to an object; that is, a reference-counter pointer to the object. When the declared variable goes out of scope, the compiler automatically deletes the underlying object. When the object is  used as a parameter in a call or is stored in a variable, a handle to the object is actually passed or stored.  \n  \n When you declare an object by using the `value class` or `value struct` keywords, the object lifetime of the declared object is not supervised. The object is like any other standard C++ class or struct.  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  \n **Remarks**  \n  \n The following table lists differences from the syntax shown in the **All Runtimes** section that are specific to C++/CLI.  \n  \n **Parameters**  \n  \n *base_type* (optional)  \n A base type. A `ref class` or `ref struct` can inherit from zero or more managed interfaces and zero or one ref types. A `value class` or `value struct` can only inherit from zero or more managed interfaces.  \n  \n The `ref class` and `ref struct` keywords tell the compiler that the class or structure is to be allocated on the heap. When the object is  used as a parameter in a call or is stored in a variable, a reference to the object is actually passed or stored.  \n  \n The `value class` and `value struct` keywords tells the compiler that the value of the allocated class or structure is passed to functions or stored in members.  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}