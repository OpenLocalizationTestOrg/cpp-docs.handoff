{"nodes":[{"pos":[12,50],"content":"Storage classes (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Storage classes (C++) | Microsoft Docs","pos":[0,38]}]},{"content":"Storage classes (C++)","pos":[675,696]},{"content":"A <bpt id=\"p1\">*</bpt>storage class<ept id=\"p1\">*</ept> in the context of C++ variable declarations is a type specifier that governs the lifetime, linkage, and memory location of objects and.","pos":[697,850],"source":"A *storage class* in the context of C++ variable declarations is a type specifier that governs the lifetime, linkage, and memory location of objects and."},{"content":"A given object can have only one storage class.","pos":[851,898]},{"content":"Variables defined within a block have automatic storage unless otherwise specified using the <ph id=\"ph1\">`extern`</ph>, <ph id=\"ph2\">`static`</ph>, or <ph id=\"ph3\">`thread_local`</ph> specifiers.","pos":[899,1041],"source":" Variables defined within a block have automatic storage unless otherwise specified using the `extern`, `static`, or `thread_local` specifiers."},{"content":"Automatic objects and variables have no linkage; they are not visible to code outside the block.","pos":[1042,1138]},{"content":"Notes","pos":[1147,1152]},{"content":"The <bpt id=\"p1\">[</bpt>mutable<ept id=\"p1\">](../cpp/mutable-data-members-cpp.md)</ept> keyword may be considered a storage class specifier.","pos":[1164,1266],"source":"The [mutable](../cpp/mutable-data-members-cpp.md) keyword may be considered a storage class specifier."},{"content":"However, it is only available in the member list of a class definition.","pos":[1267,1338]},{"pos":[1348,1534],"content":"Starting with <ph id=\"ph1\">[!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)]</ph>, the <ph id=\"ph2\">`auto`</ph> keyword is no longer a C++ storage-class specifier, and the <ph id=\"ph3\">`register`</ph> keyword is deprecated.","source":"Starting with [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)], the `auto` keyword is no longer a C++ storage-class specifier, and the `register` keyword is deprecated."},{"content":"static","pos":[1545,1551]},{"content":"extern","pos":[1572,1578]},{"content":"thread_local","pos":[1599,1611]},{"pos":[1659,1665],"content":"static"},{"content":"The <ph id=\"ph1\">`static`</ph> keyword can be used to declare variables and functions at global scope, namespace scope, and class scope.","pos":[1669,1787],"source":"The `static` keyword can be used to declare variables and functions at global scope, namespace scope, and class scope."},{"content":"Static variables can also be declared at local scope.","pos":[1788,1841]},{"content":"Static duration means that the object or variable is allocated when the program starts and is deallocated when the program ends.","pos":[1848,1976]},{"content":"External linkage means that the name of the variable is visible from outside the file in which the variable is declared.","pos":[1977,2097]},{"content":"Conversely, internal linkage means that the name is not visible outside the file in which the variable is declared.","pos":[2098,2213]},{"content":"By default, an object or variable that is defined in the global namespace has static duration and external linkage.","pos":[2214,2329]},{"content":"The <ph id=\"ph1\">`static`</ph> keyword can be used in the following situations.","pos":[2330,2391],"source":" The `static` keyword can be used in the following situations."},{"content":"When you declare a variable or function at file scope (global and/or namespace scope), the <ph id=\"ph1\">`static`</ph> keyword specifies that the variable or function has internal linkage.","pos":[2401,2570],"source":"When you declare a variable or function at file scope (global and/or namespace scope), the `static` keyword specifies that the variable or function has internal linkage."},{"content":"When you declare a variable, the variable has static duration and the compiler initializes it to 0 unless you specify another value.","pos":[2571,2703]},{"pos":[2713,2854],"content":"When you declare a variable in a function, the <ph id=\"ph1\">`static`</ph> keyword specifies that the variable retains its state between calls to that function.","source":"When you declare a variable in a function, the `static` keyword specifies that the variable retains its state between calls to that function."},{"content":"When you declare a data member in a class declaration, the <ph id=\"ph1\">`static`</ph> keyword specifies that one copy of the member is shared by all instances of the class.","pos":[2864,3018],"source":"When you declare a data member in a class declaration, the `static` keyword specifies that one copy of the member is shared by all instances of the class."},{"content":"A static data member must be defined at file scope.","pos":[3019,3070]},{"content":"An integral data member that you declare as <ph id=\"ph1\">`const``static`</ph> can have an initializer.","pos":[3071,3155],"source":" An integral data member that you declare as `const``static` can have an initializer."},{"content":"When you declare a member function in a class declaration, the <ph id=\"ph1\">`static`</ph> keyword specifies that the function is shared by all instances of the class.","pos":[3165,3313],"source":"When you declare a member function in a class declaration, the `static` keyword specifies that the function is shared by all instances of the class."},{"content":"A static member function cannot access an instance member because the function does not have an implicit <ph id=\"ph1\">`this`</ph> pointer.","pos":[3314,3434],"source":" A static member function cannot access an instance member because the function does not have an implicit `this` pointer."},{"content":"To access an instance member, declare the function with a parameter that is an instance pointer or reference.","pos":[3435,3544]},{"content":"You cannot declare the members of a union as static.","pos":[3554,3606]},{"content":"However, a globally declared anonymous union must be explicitly declared <ph id=\"ph1\">`static`</ph>.","pos":[3607,3689],"source":" However, a globally declared anonymous union must be explicitly declared `static`."},{"pos":[3696,3820],"content":"The following example shows how a variable declared <ph id=\"ph1\">`static`</ph> in a function retains its state between calls to that function.","source":"The following example shows how a variable declared `static` in a function retains its state between calls to that function."},{"pos":[4330,4389],"content":"The following example shows the use of <ph id=\"ph1\">`static`</ph> in a class.","source":"The following example shows the use of `static` in a class."},{"content":"The following example shows a local variable declared <ph id=\"ph1\">`static`</ph> in a member function.","pos":[5072,5156],"source":"The following example shows a local variable declared `static` in a member function."},{"content":"The static variable is available to the whole program; all instances of the type share the same copy of the static variable.","pos":[5157,5281]},{"content":"Starting in C++11, a static local variable initialization is guaranteed to be thread-safe.","pos":[5755,5845]},{"content":"This feature is sometimes called <bpt id=\"p1\">*</bpt>magic statics<ept id=\"p1\">*</ept>.","pos":[5846,5895],"source":" This feature is sometimes called *magic statics*."},{"content":"However, in a multithreaded application all subsequent assignments must be synchronized.","pos":[5896,5984]},{"content":"The thread-safe statics feature can be disabled by using the /Zc:threadSafeInit- flag to avoid taking a dependency on the CRT.","pos":[5985,6111]},{"pos":[6144,6150],"content":"extern"},{"pos":[6154,6311],"content":"Objects and variables declared as <ph id=\"ph1\">`extern`</ph> declare an object that is defined in another translation unit or in an enclosing scope as having external linkage.","source":"Objects and variables declared as `extern` declare an object that is defined in another translation unit or in an enclosing scope as having external linkage."},{"content":"Declaration of <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> variables with the <ph id=\"ph1\">`extern`</ph> storage class forces the variable to have external linkage.","pos":[6318,6430],"source":"Declaration of **const** variables with the `extern` storage class forces the variable to have external linkage."},{"content":"An initialization of an <bpt id=\"p1\">**</bpt>extern const<ept id=\"p1\">**</ept> variable is allowed in the defining translation unit.","pos":[6431,6525],"source":" An initialization of an **extern const** variable is allowed in the defining translation unit."},{"content":"Initializations in translation units other than the defining translation unit produce undefined results.","pos":[6526,6630]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using extern to Specify Linkage<ept id=\"p1\">](../cpp/using-extern-to-specify-linkage.md)</ept>","pos":[6631,6733],"source":" For more information, see [Using extern to Specify Linkage](../cpp/using-extern-to-specify-linkage.md)"},{"pos":[6740,6949],"content":"The following code shows two <ph id=\"ph1\">`extern`</ph> declarations, <ph id=\"ph2\">`DefinedElsewhere`</ph> (which refers to a name defined in a different translation unit) and <ph id=\"ph3\">`DefinedHere`</ph> (which refers to a name defined in an enclosing scope):","source":"The following code shows two `extern` declarations, `DefinedElsewhere` (which refers to a name defined in a different translation unit) and `DefinedHere` (which refers to a name defined in an enclosing scope):"},{"pos":[7241,7261],"content":"thread_local (C++11)"},{"content":"A variable declared with the <ph id=\"ph1\">`thread_local`</ph> specifier is accessible only on the thread on which it is created.","pos":[7265,7375],"source":"A variable declared with the `thread_local` specifier is accessible only on the thread on which it is created."},{"content":"The variable is created when the thread is created, and destroyed when the thread is destroyed.","pos":[7376,7471]},{"content":"Each thread has its own copy of the variable.","pos":[7472,7517]},{"content":"On Windows, <ph id=\"ph1\">`thread_local`</ph> is functionally equivalent to the Microsoft-specific <bpt id=\"p1\">[</bpt>__declspec( thread )<ept id=\"p1\">](../cpp/thread.md)</ept> attribute.","pos":[7518,7649],"source":" On Windows, `thread_local` is functionally equivalent to the Microsoft-specific [__declspec( thread )](../cpp/thread.md) attribute."},{"pos":[7970,8039],"content":"The thread_local specifier may be combined with <ph id=\"ph1\">`static`</ph> or <ph id=\"ph2\">`extern`</ph>.","source":"The thread_local specifier may be combined with `static` or `extern`."},{"pos":[8049,8193],"content":"You can apply <ph id=\"ph1\">`thread_local`</ph> only to data declarations and definitions; <bpt id=\"p1\">**</bpt>thread_local<ept id=\"p1\">**</ept> cannot be used on function declarations or definitions.","source":"You can apply `thread_local` only to data declarations and definitions; **thread_local** cannot be used on function declarations or definitions."},{"pos":[8203,8343],"content":"The use of <ph id=\"ph1\">`thread_local`</ph> may interfere with <bpt id=\"p1\">[</bpt>delay loading<ept id=\"p1\">](../build/reference/linker-support-for-delay-loaded-dlls.md)</ept> of DLL imports<bpt id=\"p2\">**</bpt>.<ept id=\"p2\">**</ept>","source":"The use of `thread_local` may interfere with [delay loading](../build/reference/linker-support-for-delay-loaded-dlls.md) of DLL imports**.**"},{"pos":[8353,8489],"content":"On XP systems, <ph id=\"ph1\">`thread_local`</ph> may not function correctly if a DLL uses <ph id=\"ph2\">`thread_local`</ph> data and it is loaded dynamically via LoadLibrary.","source":"On XP systems, `thread_local` may not function correctly if a DLL uses `thread_local` data and it is loaded dynamically via LoadLibrary."},{"content":"You can specify <ph id=\"ph1\">`thread_local`</ph> only on data items with static storage duration.","pos":[8499,8578],"source":"You can specify `thread_local` only on data items with static storage duration."},{"content":"This includes global data objects (both <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`extern`</ph>), local static objects, and static data members of classes.","pos":[8579,8702],"source":" This includes global data objects (both **static** and `extern`), local static objects, and static data members of classes."},{"content":"You cannot declare automatic data objects with <bpt id=\"p1\">**</bpt>thread_local<ept id=\"p1\">**</ept>.","pos":[8703,8767],"source":" You cannot declare automatic data objects with **thread_local**."},{"pos":[8777,8959],"content":"You must specify <ph id=\"ph1\">`thread_local`</ph> for both the declaration and the definition of a thread local object, whether the declaration and definition occur in the same file or separate files.","source":"You must specify `thread_local` for both the declaration and the definition of a thread local object, whether the declaration and definition occur in the same file or separate files."},{"content":"On Windows, <ph id=\"ph1\">`thread_local`</ph> is functionally equivalent to  <bpt id=\"p1\">[</bpt>__declspec(thread)<ept id=\"p1\">](../cpp/thread.md)</ept> except that __declspec(thread) can be applied to a type definition and is valid in C code.","pos":[8966,9153],"source":"On Windows, `thread_local` is functionally equivalent to  [__declspec(thread)](../cpp/thread.md) except that __declspec(thread) can be applied to a type definition and is valid in C code."},{"content":"Whenever possible, use <ph id=\"ph1\">`thread_local`</ph> because it is part of the C++ standard and is therefore more portable.","pos":[9154,9262],"source":" Whenever possible, use `thread_local` because it is part of the C++ standard and is therefore more portable."},{"pos":[9269,9365],"content":"For more information, see <bpt id=\"p1\">[</bpt>Thread Local Storage (TLS)<ept id=\"p1\">](../parallel/thread-local-storage-tls.md)</ept>.","source":"For more information, see [Thread Local Storage (TLS)](../parallel/thread-local-storage-tls.md)."},{"pos":[9400,9408],"content":"register"},{"content":"In C++11, the <bpt id=\"p1\">**</bpt>register<ept id=\"p1\">**</ept> keyword is deprecated.","pos":[9412,9461],"source":"In C++11, the **register** keyword is deprecated."},{"content":"It specifies that the variable is to be stored in a machine register, if possible.","pos":[9462,9544]},{"content":"Only function arguments and local variables can be declared with the register storage class.","pos":[9545,9637]},{"content":"Like automatic variables, register variables persist only until the end of the block in which they are declared.","pos":[9679,9791]},{"content":"The compiler does not honor user requests for register variables; instead, it makes its own register choices when global optimizations are on.","pos":[9798,9940]},{"content":"However, all other semantics associated with the <bpt id=\"p1\">[</bpt>register<ept id=\"p1\">](http://msdn.microsoft.com/en-us/5b66905a-2f7f-4918-bb55-5e66d4bc50f9)</ept> keyword are honored by the compiler.","pos":[9941,10107],"source":" However, all other semantics associated with the [register](http://msdn.microsoft.com/en-us/5b66905a-2f7f-4918-bb55-5e66d4bc50f9) keyword are honored by the compiler."},{"pos":[10114,10268],"content":"If the address-of operator (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p1\">**</ept>) is used on an object that is declared with register, the compiler must put the object in memory rather than a register.","source":"If the address-of operator (**&**) is used on an object that is declared with register, the compiler must put the object in memory rather than a register."},{"content":"Example: automatic vs. static initialization","pos":[10277,10321]},{"content":"A local automatic object or variable is initialized every time the flow of control reaches its definition.","pos":[10325,10431]},{"content":"A local static object or variable is initialized the first time the flow of control reaches its definition.","pos":[10432,10539]},{"pos":[10546,10705],"content":"Consider the following example, which defines a class that logs initialization and destruction of objects and then defines three objects, <ph id=\"ph1\">`I1`</ph>, <ph id=\"ph2\">`I2`</ph>, and <ph id=\"ph3\">`I3`</ph>:","source":"Consider the following example, which defines a class that logs initialization and destruction of objects and then defines three objects, `I1`, `I2`, and `I3`:"},{"pos":[12232,12354],"content":"The preceding code demonstrates how and when the objects <ph id=\"ph1\">`I1`</ph>, <ph id=\"ph2\">`I2`</ph>, and <ph id=\"ph3\">`I3`</ph> are initialized and when they are destroyed.","source":"The preceding code demonstrates how and when the objects `I1`, `I2`, and `I3` are initialized and when they are destroyed."},{"content":"There are several points to note about the program.","pos":[12361,12412]},{"pos":[12419,12535],"content":"First, <ph id=\"ph1\">`I1`</ph> and <ph id=\"ph2\">`I2`</ph> are automatically destroyed when the flow of control exits the block in which they are defined.","source":"First, `I1` and `I2` are automatically destroyed when the flow of control exits the block in which they are defined."},{"content":"Second, in C++, it is not necessary to declare objects or variables at the beginning of a block.","pos":[12542,12638]},{"content":"Furthermore, these objects are initialized only when the flow of control reaches their definitions.","pos":[12639,12738]},{"content":"(<ph id=\"ph1\">`I2`</ph> and <ph id=\"ph2\">`I3`</ph> are examples of such definitions.) The output shows exactly when they are initialized.","pos":[12739,12840],"source":" (`I2` and `I3` are examples of such definitions.) The output shows exactly when they are initialized."},{"pos":[12847,12989],"content":"Finally, static local variables such as <ph id=\"ph1\">`I3`</ph> retain their values for the duration of the program, but are destroyed as the program terminates.","source":"Finally, static local variables such as `I3` retain their values for the duration of the program, but are destroyed as the program terminates."},{"content":"See Also","pos":[12998,13006]},{"content":"Declarations and Definitions","pos":[13011,13039]}],"content":"---\ntitle: \"Storage classes (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"thread_local_cpp\"\n  - \"external_cpp\"\n  - \"static_cpp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"storage classes, basic concepts\"\nms.assetid: f10e1c56-6249-4eb6-b08f-09ab1eef1992\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Storage classes (C++)\nA *storage class* in the context of C++ variable declarations is a type specifier that governs the lifetime, linkage, and memory location of objects and. A given object can have only one storage class. Variables defined within a block have automatic storage unless otherwise specified using the `extern`, `static`, or `thread_local` specifiers. Automatic objects and variables have no linkage; they are not visible to code outside the block.  \n  \n **Notes**  \n  \n1.  The [mutable](../cpp/mutable-data-members-cpp.md) keyword may be considered a storage class specifier. However, it is only available in the member list of a class definition.  \n  \n2.  Starting with [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)], the `auto` keyword is no longer a C++ storage-class specifier, and the `register` keyword is deprecated.  \n  \n-   [static](#static)  \n  \n-   [extern](#extern)  \n  \n-   [thread_local](#thread_local)  \n  \n## <a name=\"static\"></a>  static  \n The `static` keyword can be used to declare variables and functions at global scope, namespace scope, and class scope. Static variables can also be declared at local scope.  \n  \n Static duration means that the object or variable is allocated when the program starts and is deallocated when the program ends. External linkage means that the name of the variable is visible from outside the file in which the variable is declared. Conversely, internal linkage means that the name is not visible outside the file in which the variable is declared. By default, an object or variable that is defined in the global namespace has static duration and external linkage. The `static` keyword can be used in the following situations.  \n  \n1.  When you declare a variable or function at file scope (global and/or namespace scope), the `static` keyword specifies that the variable or function has internal linkage. When you declare a variable, the variable has static duration and the compiler initializes it to 0 unless you specify another value.  \n  \n2.  When you declare a variable in a function, the `static` keyword specifies that the variable retains its state between calls to that function.  \n  \n3.  When you declare a data member in a class declaration, the `static` keyword specifies that one copy of the member is shared by all instances of the class. A static data member must be defined at file scope. An integral data member that you declare as `const``static` can have an initializer.  \n  \n4.  When you declare a member function in a class declaration, the `static` keyword specifies that the function is shared by all instances of the class. A static member function cannot access an instance member because the function does not have an implicit `this` pointer. To access an instance member, declare the function with a parameter that is an instance pointer or reference.  \n  \n5.  You cannot declare the members of a union as static. However, a globally declared anonymous union must be explicitly declared `static`.  \n  \n The following example shows how a variable declared `static` in a function retains its state between calls to that function.  \n  \n```  \n// static1.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nusing namespace std;  \nvoid showstat( int curr ) {  \n   static int nStatic;    // Value of nStatic is retained  \n                          // between each function call  \n   nStatic += curr;  \n   cout << \"nStatic is \" << nStatic << endl;  \n}  \n  \nint main() {  \n   for ( int i = 0; i < 5; i++ )  \n      showstat( i );  \n}  \n```  \n  \n```Output  \nnStatic is 0  \nnStatic is 1  \nnStatic is 3  \nnStatic is 6  \nnStatic is 10  \n```  \n  \n The following example shows the use of `static` in a class.  \n  \n```  \n// static2.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nusing namespace std;  \nclass CMyClass {  \npublic:  \n   static int m_i;  \n};  \n  \nint CMyClass::m_i = 0;  \nCMyClass myObject1;  \nCMyClass myObject2;  \n  \nint main() {  \n   cout << myObject1.m_i << endl;  \n   cout << myObject2.m_i << endl;  \n  \n   myObject1.m_i = 1;  \n   cout << myObject1.m_i << endl;  \n   cout << myObject2.m_i << endl;  \n  \n   myObject2.m_i = 2;  \n   cout << myObject1.m_i << endl;  \n   cout << myObject2.m_i << endl;  \n  \n   CMyClass::m_i = 3;  \n   cout << myObject1.m_i << endl;  \n   cout << myObject2.m_i << endl;  \n}  \n```  \n  \n```Output  \n0  \n0  \n1  \n1  \n2  \n2  \n3  \n3  \n```  \n  \n The following example shows a local variable declared `static` in a member function. The static variable is available to the whole program; all instances of the type share the same copy of the static variable.  \n  \n```  \n// static3.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \nstruct C {  \n   void Test(int value) {  \n      static int var = 0;  \n      if (var == value)   \n         cout << \"var == value\" << endl;  \n      else  \n         cout << \"var != value\" << endl;  \n  \n      var = value;  \n   }  \n};   \n  \nint main() {  \n   C c1;  \n   C c2;  \n   c1.Test(100);  \n   c2.Test(100);  \n}  \n```  \n  \n```Output  \nvar != value  \nvar == value  \n```  \n  \n Starting in C++11, a static local variable initialization is guaranteed to be thread-safe. This feature is sometimes called *magic statics*. However, in a multithreaded application all subsequent assignments must be synchronized. The thread-safe statics feature can be disabled by using the /Zc:threadSafeInit- flag to avoid taking a dependency on the CRT.  \n  \n##  <a name=\"extern\"></a>  extern  \n Objects and variables declared as `extern` declare an object that is defined in another translation unit or in an enclosing scope as having external linkage.  \n  \n Declaration of **const** variables with the `extern` storage class forces the variable to have external linkage. An initialization of an **extern const** variable is allowed in the defining translation unit. Initializations in translation units other than the defining translation unit produce undefined results. For more information, see [Using extern to Specify Linkage](../cpp/using-extern-to-specify-linkage.md)  \n  \n The following code shows two `extern` declarations, `DefinedElsewhere` (which refers to a name defined in a different translation unit) and `DefinedHere` (which refers to a name defined in an enclosing scope):  \n  \n```  \n// external.cpp  \n// defined in another translation unit  \nextern int DefinedElsewhere;     \nint main() {  \n   int DefinedHere;   \n   {  \n      // refers to DefinedHere in the enclosing scope  \n      extern int DefinedHere;  \n    }  \n}  \n```  \n  \n##  <a name=\"thread_local\"></a>  thread_local (C++11)  \n A variable declared with the `thread_local` specifier is accessible only on the thread on which it is created. The variable is created when the thread is created, and destroyed when the thread is destroyed. Each thread has its own copy of the variable. On Windows, `thread_local` is functionally equivalent to the Microsoft-specific [__declspec( thread )](../cpp/thread.md) attribute.  \n  \n```  \nthread_local float f = 42.0; //global namespace  \n  \nstruct C // cannot be applied to type definition  \n{  \nthread_local int i; //local  \nthread_local static char buf[10]; // local and static  \n};  \n  \nvoid DoSomething()  \n{  \nthread_local C my_struct; // Apply  thread_local to a variable  \n}  \n```  \n  \n1.  The thread_local specifier may be combined with `static` or `extern`.  \n  \n2.  You can apply `thread_local` only to data declarations and definitions; **thread_local** cannot be used on function declarations or definitions.  \n  \n3.  The use of `thread_local` may interfere with [delay loading](../build/reference/linker-support-for-delay-loaded-dlls.md) of DLL imports**.**  \n  \n4.  On XP systems, `thread_local` may not function correctly if a DLL uses `thread_local` data and it is loaded dynamically via LoadLibrary.  \n  \n5.  You can specify `thread_local` only on data items with static storage duration. This includes global data objects (both **static** and `extern`), local static objects, and static data members of classes. You cannot declare automatic data objects with **thread_local**.  \n  \n6.  You must specify `thread_local` for both the declaration and the definition of a thread local object, whether the declaration and definition occur in the same file or separate files.  \n  \n On Windows, `thread_local` is functionally equivalent to  [__declspec(thread)](../cpp/thread.md) except that __declspec(thread) can be applied to a type definition and is valid in C code. Whenever possible, use `thread_local` because it is part of the C++ standard and is therefore more portable.  \n  \n For more information, see [Thread Local Storage (TLS)](../parallel/thread-local-storage-tls.md).  \n  \n##  <a name=\"register\"></a>  register  \n In C++11, the **register** keyword is deprecated. It specifies that the variable is to be stored in a machine register, if possible. Only function arguments and local variables can be declared with the register storage class.  \n  \n```  \nregister int num;  \n```  \n  \n Like automatic variables, register variables persist only until the end of the block in which they are declared.  \n  \n The compiler does not honor user requests for register variables; instead, it makes its own register choices when global optimizations are on. However, all other semantics associated with the [register](http://msdn.microsoft.com/en-us/5b66905a-2f7f-4918-bb55-5e66d4bc50f9) keyword are honored by the compiler.  \n  \n If the address-of operator (**&**) is used on an object that is declared with register, the compiler must put the object in memory rather than a register.  \n  \n## Example: automatic vs. static initialization  \n A local automatic object or variable is initialized every time the flow of control reaches its definition. A local static object or variable is initialized the first time the flow of control reaches its definition.  \n  \n Consider the following example, which defines a class that logs initialization and destruction of objects and then defines three objects, `I1`, `I2`, and `I3`:  \n  \n```  \n// initialization_of_objects.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <string.h>  \nusing namespace std;  \n  \n// Define a class that logs initializations and destructions.  \nclass InitDemo {  \npublic:  \n   InitDemo( const char *szWhat );  \n   ~InitDemo();  \n  \nprivate:  \n   char *szObjName;  \n   size_t sizeofObjName;  \n};  \n  \n// Constructor for class InitDemo  \nInitDemo::InitDemo( const char *szWhat ) :  \n   szObjName(NULL), sizeofObjName(0) {  \n   if( szWhat != 0 && strlen( szWhat ) > 0 ) {  \n      // Allocate storage for szObjName, then copy  \n      // initializer szWhat into szObjName, using  \n      // secured CRT functions.  \n      sizeofObjName = strlen( szWhat ) + 1;  \n  \n      szObjName = new char[ sizeofObjName ];  \n      strcpy_s( szObjName, sizeofObjName, szWhat );  \n  \n      cout << \"Initializing: \" << szObjName << \"\\n\";  \n   }  \n   else  \n      szObjName = 0;  \n}  \n  \n// Destructor for InitDemo  \nInitDemo::~InitDemo() {  \n   if( szObjName != 0 ) {  \n      cout << \"Destroying: \" << szObjName << \"\\n\";  \n      delete szObjName;  \n   }  \n}  \n  \n// Enter main function  \nint main() {  \n   InitDemo I1( \"Auto I1\" ); {  \n      cout << \"In block.\\n\";  \n      InitDemo I2( \"Auto I2\" );  \n      static InitDemo I3( \"Static I3\" );  \n   }  \n   cout << \"Exited block.\\n\";  \n}  \n```  \n  \n```Output  \nInitializing: Auto I1  \nIn block.  \nInitializing: Auto I2  \nInitializing: Static I3  \nDestroying: Auto I2  \nExited block.  \nDestroying: Auto I1  \nDestroying: Static I3  \n```  \n  \n The preceding code demonstrates how and when the objects `I1`, `I2`, and `I3` are initialized and when they are destroyed.  \n  \n There are several points to note about the program.  \n  \n First, `I1` and `I2` are automatically destroyed when the flow of control exits the block in which they are defined.  \n  \n Second, in C++, it is not necessary to declare objects or variables at the beginning of a block. Furthermore, these objects are initialized only when the flow of control reaches their definitions. (`I2` and `I3` are examples of such definitions.) The output shows exactly when they are initialized.  \n  \n Finally, static local variables such as `I3` retain their values for the duration of the program, but are destroyed as the program terminates.  \n  \n## See Also  \n [Declarations and Definitions](../cpp/declarations-and-definitions-cpp.md)"}