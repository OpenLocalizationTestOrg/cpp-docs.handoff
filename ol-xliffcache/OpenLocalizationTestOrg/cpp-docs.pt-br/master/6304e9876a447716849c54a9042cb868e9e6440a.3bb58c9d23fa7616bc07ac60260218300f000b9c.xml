{"nodes":[{"pos":[12,62],"content":"Consumer Wizard-Generated Classes | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Consumer Wizard-Generated Classes | Microsoft Docs","pos":[0,50]}]},{"content":"Consumer Wizard-Generated Classes","pos":[905,938]},{"content":"When you use the ATL OLE DB Consumer Wizard to generate a consumer, you have the choice of using OLE DB Templates or OLE DB attributes.","pos":[939,1074]},{"content":"In both cases, the wizard generates a command class and a user record class.","pos":[1075,1151]},{"content":"The command class contains code to open the data source and rowset you specified in the wizard.","pos":[1152,1247]},{"content":"The user record class contains a column map for the database table you selected.","pos":[1248,1328]},{"content":"However, the generated code differs in each case:","pos":[1329,1378]},{"content":"If you select a templated consumer, the wizard generates a command class and a user record class.","pos":[1388,1485]},{"content":"The command class will have the name that you enter in the Class box in the wizard (for example, <ph id=\"ph1\">`CProducts`</ph>), and the user record class will have a name of the form \"<bpt id=\"p1\">*</bpt>ClassName<ept id=\"p1\">*</ept>Accessor\" (for example, <ph id=\"ph2\">`CProductsAccessor`</ph>).","pos":[1486,1709],"source":" The command class will have the name that you enter in the Class box in the wizard (for example, `CProducts`), and the user record class will have a name of the form \"*ClassName*Accessor\" (for example, `CProductsAccessor`)."},{"content":"Both classes are placed in the consumer's header file.","pos":[1710,1764]},{"content":"If you select an attributed consumer, the user record class will have a name of the form \"_<bpt id=\"p1\">*</bpt>ClassName<ept id=\"p1\">*</ept>Accessor\" and will be injected.","pos":[1774,1907],"source":"If you select an attributed consumer, the user record class will have a name of the form \"_*ClassName*Accessor\" and will be injected."},{"content":"That is, you will be able to view only the command class in the text editor; you can only view the user record class as injected code.","pos":[1908,2042]},{"content":"For information about viewing injected code, see <bpt id=\"p1\">[</bpt>Debugging Injected Code<ept id=\"p1\">](http://msdn.microsoft.com/library/a1b4104d-d49e-451f-a91e-e39ceaf35875)</ept>.","pos":[2043,2190],"source":" For information about viewing injected code, see [Debugging Injected Code](http://msdn.microsoft.com/library/a1b4104d-d49e-451f-a91e-e39ceaf35875)."},{"content":"The following examples use a command class created on the Products table of the Northwind database to demonstrate the wizard-generated consumer code for the command class and user record class.","pos":[2197,2390]},{"content":"Templated User Record Classes","pos":[2399,2428]},{"content":"If you create an OLE DB consumer using the OLE DB Templates (rather than the OLE DB attributes), the wizard generates code as described in this section.","pos":[2432,2584]},{"content":"Column Data Members","pos":[2594,2613]},{"content":"The first part of the user record class includes the data member declarations and the status and length data members for each data-bound column.","pos":[2617,2761]},{"content":"For information about these data members, see <bpt id=\"p1\">[</bpt>Field Status Data Members in Wizard-Generated Accessors<ept id=\"p1\">](../../data/oledb/field-status-data-members-in-wizard-generated-accessors.md)</ept>.","pos":[2762,2943],"source":" For information about these data members, see [Field Status Data Members in Wizard-Generated Accessors](../../data/oledb/field-status-data-members-in-wizard-generated-accessors.md)."},{"pos":[2951,3094],"content":"[!NOTE]\n If you modify the user record class or write your own consumer, the data variables must come before the status and length variables.","leadings":["","> "],"nodes":[{"content":"If you modify the user record class or write your own consumer, the data variables must come before the status and length variables.","pos":[9,141]}]},{"pos":[3102,3415],"content":"[!NOTE]\n The ATL OLE DB Consumer Wizard uses the **DB_NUMERIC** type to bind numeric data types. It formerly used **DBTYPE_VARNUMERIC** (the format of which is described by the **DB_VARNUMERIC** type; see Oledb.h). If you do not use the wizard to create consumers, it is recommended that you use **DB_NUMERIC**.","leadings":["","> "],"nodes":[{"content":" The ATL OLE DB Consumer Wizard uses the **DB_NUMERIC** type to bind numeric data types. It formerly used **DBTYPE_VARNUMERIC** (the format of which is described by the **DB_VARNUMERIC** type; see Oledb.h). If you do not use the wizard to create consumers, it is recommended that you use **DB_NUMERIC**.","pos":[8,311],"nodes":[{"content":"The ATL OLE DB Consumer Wizard uses the <bpt id=\"p1\">**</bpt>DB_NUMERIC<ept id=\"p1\">**</ept> type to bind numeric data types.","pos":[1,88],"source":" The ATL OLE DB Consumer Wizard uses the **DB_NUMERIC** type to bind numeric data types."},{"content":"It formerly used <bpt id=\"p1\">**</bpt>DBTYPE_VARNUMERIC<ept id=\"p1\">**</ept> (the format of which is described by the <bpt id=\"p2\">**</bpt>DB_VARNUMERIC<ept id=\"p2\">**</ept> type; see Oledb.h).","pos":[89,206],"source":" It formerly used **DBTYPE_VARNUMERIC** (the format of which is described by the **DB_VARNUMERIC** type; see Oledb.h)."},{"content":"If you do not use the wizard to create consumers, it is recommended that you use <bpt id=\"p1\">**</bpt>DB_NUMERIC<ept id=\"p1\">**</ept>.","pos":[207,303],"source":" If you do not use the wizard to create consumers, it is recommended that you use **DB_NUMERIC**."}]}]},{"content":"Rowset Properties","pos":[4664,4681]},{"content":"Next, the wizard sets rowset properties.","pos":[4685,4725]},{"content":"If you selected <bpt id=\"p1\">**</bpt>Change<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Insert<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>Delete<ept id=\"p3\">**</ept> in the ATL OLE DB Consumer Wizard, the appropriate properties are set here (DBPROP_IRowsetChange is always set, then one or more of DBPROPVAL_UP_CHANGE, DBPROPVAL_UP_INSERT, and/or DBPROPVAL_UP_DELETE, respectively).","pos":[4726,4996],"source":" If you selected **Change**, **Insert**, or **Delete** in the ATL OLE DB Consumer Wizard, the appropriate properties are set here (DBPROP_IRowsetChange is always set, then one or more of DBPROPVAL_UP_CHANGE, DBPROPVAL_UP_INSERT, and/or DBPROPVAL_UP_DELETE, respectively)."},{"content":"Command or Table Class","pos":[5441,5463]},{"content":"If you specify a command class, the wizard declares the command class; for templated code, the command looks like this:","pos":[5467,5586]},{"content":"Column Map","pos":[5892,5902]},{"content":"The wizard then generates the column bindings or column map.","pos":[5906,5966]},{"content":"To fix several issues with some providers, the following code might bind columns in a different order than that reported by the provider.","pos":[5967,6104]},{"content":"Class Declaration","pos":[7333,7350]},{"content":"Finally, the wizard generates a command class declaration such as the following:","pos":[7354,7434]},{"content":"Attribute-Injected User Record Classes","pos":[7525,7563]},{"content":"If you create an OLE DB consumer using the database attributes (<bpt id=\"p1\">[</bpt>db_command<ept id=\"p1\">](../../windows/db-command.md)</ept> or <bpt id=\"p2\">[</bpt>db_table<ept id=\"p2\">](../../windows/db-table.md)</ept>), the attributes inject a user record class with a name of the form \"_<bpt id=\"p3\">*</bpt>ClassName<ept id=\"p3\">*</ept>Accessor.\"","pos":[7567,7805],"source":"If you create an OLE DB consumer using the database attributes ([db_command](../../windows/db-command.md) or [db_table](../../windows/db-table.md)), the attributes inject a user record class with a name of the form \"_*ClassName*Accessor.\""},{"content":"For example, if you named your command class <ph id=\"ph1\">`COrders`</ph>, the user record class will be <ph id=\"ph2\">`_COrdersAccessor`</ph>.","pos":[7806,7911],"source":" For example, if you named your command class `COrders`, the user record class will be `_COrdersAccessor`."},{"content":"Although the user record class appears in Class View, double-clicking it navigates to the command or table class in the header file instead.","pos":[7912,8052]},{"content":"In these cases, you can only view the actual declaration of the user record class by viewing the attribute-injected code.","pos":[8053,8174]},{"content":"There can be potential complications if you add or override methods in attributed consumers.","pos":[8181,8273]},{"content":"For example, you could add a <ph id=\"ph1\">`_COrdersAccessor`</ph> constructor to the <ph id=\"ph2\">`COrders`</ph> declaration, but note that in reality this adds a constructor to the injected <ph id=\"ph3\">`COrdersAccessor`</ph> class.","pos":[8274,8453],"source":" For example, you could add a `_COrdersAccessor` constructor to the `COrders` declaration, but note that in reality this adds a constructor to the injected `COrdersAccessor` class."},{"content":"Such a constructor can initialize the columns/parameters, but you cannot create a copy constructor this way, because it cannot directly instantiate the <ph id=\"ph1\">`COrdersAccessor`</ph> object.","pos":[8454,8631],"source":" Such a constructor can initialize the columns/parameters, but you cannot create a copy constructor this way, because it cannot directly instantiate the `COrdersAccessor` object."},{"content":"If you need a constructor (or other method) directly on the <ph id=\"ph1\">`COrders`</ph> class, it is recommended that you define a new class deriving from <ph id=\"ph2\">`COrders`</ph> and add the necessary methods there.","pos":[8632,8815],"source":" If you need a constructor (or other method) directly on the `COrders` class, it is recommended that you define a new class deriving from `COrders` and add the necessary methods there."},{"pos":[8822,9002],"content":"In the following example, the wizard generates a declaration for the class <ph id=\"ph1\">`COrders`</ph>, but the user record class <ph id=\"ph2\">`COrdersAccessor`</ph> does not appear, because the attributes inject it.","source":"In the following example, the wizard generates a declaration for the class `COrders`, but the user record class `COrdersAccessor` does not appear, because the attributes inject it."},{"content":"The injected command class declaration looks like this:","pos":[9414,9469]},{"content":"Most of the injected code is the same as or similar to the templated version.","pos":[9559,9636]},{"content":"The main differences are in the injected methods, which are described in <bpt id=\"p1\">[</bpt>Consumer Wizard-Generated Methods<ept id=\"p1\">](../../data/oledb/consumer-wizard-generated-methods.md)</ept>.","pos":[9637,9801],"source":" The main differences are in the injected methods, which are described in [Consumer Wizard-Generated Methods](../../data/oledb/consumer-wizard-generated-methods.md)."},{"pos":[9808,9955],"content":"For information about viewing injected code, see <bpt id=\"p1\">[</bpt>Debugging Injected Code<ept id=\"p1\">](http://msdn.microsoft.com/library/a1b4104d-d49e-451f-a91e-e39ceaf35875)</ept>.","source":"For information about viewing injected code, see [Debugging Injected Code](http://msdn.microsoft.com/library/a1b4104d-d49e-451f-a91e-e39ceaf35875)."},{"content":"See Also","pos":[9964,9972]},{"content":"Creating an OLE DB Consumer Using a Wizard","pos":[9977,10019]}],"content":"---\ntitle: \"Consumer Wizard-Generated Classes | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"attribute-injected classes and methods\"\n  - \"wizard-generated classes and methods\"\n  - \"OLE DB consumers, wizard-generated classes and methods\"\n  - \"command classes in OLE DB consumer\"\n  - \"classes [C++], OLE DB Consumer Wizard-generated\"\n  - \"consumer wizard-generated classes and methods\"\n  - \"user record classes in OLE DB consumer\"\nms.assetid: dba0538f-2afe-4354-8cbb-f202ea8ade5a\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Consumer Wizard-Generated Classes\nWhen you use the ATL OLE DB Consumer Wizard to generate a consumer, you have the choice of using OLE DB Templates or OLE DB attributes. In both cases, the wizard generates a command class and a user record class. The command class contains code to open the data source and rowset you specified in the wizard. The user record class contains a column map for the database table you selected. However, the generated code differs in each case:  \n  \n-   If you select a templated consumer, the wizard generates a command class and a user record class. The command class will have the name that you enter in the Class box in the wizard (for example, `CProducts`), and the user record class will have a name of the form \"*ClassName*Accessor\" (for example, `CProductsAccessor`). Both classes are placed in the consumer's header file.  \n  \n-   If you select an attributed consumer, the user record class will have a name of the form \"_*ClassName*Accessor\" and will be injected. That is, you will be able to view only the command class in the text editor; you can only view the user record class as injected code. For information about viewing injected code, see [Debugging Injected Code](http://msdn.microsoft.com/library/a1b4104d-d49e-451f-a91e-e39ceaf35875).  \n  \n The following examples use a command class created on the Products table of the Northwind database to demonstrate the wizard-generated consumer code for the command class and user record class.  \n  \n## Templated User Record Classes  \n If you create an OLE DB consumer using the OLE DB Templates (rather than the OLE DB attributes), the wizard generates code as described in this section.  \n  \n### Column Data Members  \n The first part of the user record class includes the data member declarations and the status and length data members for each data-bound column. For information about these data members, see [Field Status Data Members in Wizard-Generated Accessors](../../data/oledb/field-status-data-members-in-wizard-generated-accessors.md).  \n  \n> [!NOTE]\n>  If you modify the user record class or write your own consumer, the data variables must come before the status and length variables.  \n  \n> [!NOTE]\n>  The ATL OLE DB Consumer Wizard uses the **DB_NUMERIC** type to bind numeric data types. It formerly used **DBTYPE_VARNUMERIC** (the format of which is described by the **DB_VARNUMERIC** type; see Oledb.h). If you do not use the wizard to create consumers, it is recommended that you use **DB_NUMERIC**.  \n  \n```  \n// Products.H : Declaration of the CProducts class  \n  \nclass CProductsAccessor  \n{  \npublic:  \n   // Column data members:  \n   LONG m_ProductID;  \n   TCHAR m_ProductName[41];  \n   LONG m_SupplierID;  \n   LONG m_CategoryID;  \n   TCHAR m_QuantityPerUnit[21];  \n   CURRENCY m_UnitPrice;  \n   SHORT m_UnitsInStock;  \n   SHORT m_UnitsOnOrder;  \n   SHORT m_ReorderLevel;  \n   VARIANT_BOOL m_Discontinued;  \n  \n   // Column status data members:  \n   DBSTATUS m_dwProductIDStatus;  \n   DBSTATUS m_dwProductNameStatus;  \n   DBSTATUS m_dwSupplierIDStatus;  \n   DBSTATUS m_dwCategoryIDStatus;  \n   DBSTATUS m_dwQuantityPerUnitStatus;  \n   DBSTATUS m_dwUnitPriceStatus;  \n   DBSTATUS m_dwUnitsInStockStatus;  \n   DBSTATUS m_dwUnitsOnOrderStatus;  \n   DBSTATUS m_dwReorderLevelStatus;  \n   DBSTATUS m_dwDiscontinuedStatus;  \n  \n   // Column length data members:  \n   DBLENGTH m_dwProductIDLength;  \n   DBLENGTH m_dwProductNameLength;  \n   DBLENGTH m_dwSupplierIDLength;  \n   DBLENGTH m_dwCategoryIDLength;  \n   DBLENGTH m_dwQuantityPerUnitLength;  \n   DBLENGTH m_dwUnitPriceLength;  \n   DBLENGTH m_dwUnitsInStockLength;  \n   DBLENGTH m_dwUnitsOnOrderLength;  \n   DBLENGTH m_dwReorderLevelLength;  \n   DBLENGTH m_dwDiscontinuedLength;  \n```  \n  \n### Rowset Properties  \n Next, the wizard sets rowset properties. If you selected **Change**, **Insert**, or **Delete** in the ATL OLE DB Consumer Wizard, the appropriate properties are set here (DBPROP_IRowsetChange is always set, then one or more of DBPROPVAL_UP_CHANGE, DBPROPVAL_UP_INSERT, and/or DBPROPVAL_UP_DELETE, respectively).  \n  \n```  \nvoid GetRowsetProperties(CDBPropSet* pPropSet)  \n{  \n   pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);  \n   pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);  \n   pPropSet->AddProperty(DBPROP_IRowsetChange, true, DBPROPOPTIONS_OPTIONAL);  \n   pPropSet->AddProperty(DBPROP_UPDATABILITY, DBPROPVAL_UP_CHANGE | DBPROPVAL_UP_INSERT | DBPROPVAL_UP_DELETE);  \n}  \n```  \n  \n### Command or Table Class  \n If you specify a command class, the wizard declares the command class; for templated code, the command looks like this:  \n  \n```  \nDEFINE_COMMAND_EX(CProductsAccessor, L\" \\  \nSELECT \\  \n   ProductID, \\  \n   ProductName, \\  \n   SupplierID, \\  \n   CategoryID, \\  \n   QuantityPerUnit, \\  \n   UnitPrice, \\  \n   UnitsInStock, \\  \n   UnitsOnOrder, \\  \n   ReorderLevel, \\  \n   Discontinued \\  \n   FROM dbo.Products\")  \n```  \n  \n### Column Map  \n The wizard then generates the column bindings or column map. To fix several issues with some providers, the following code might bind columns in a different order than that reported by the provider.  \n  \n```  \n   BEGIN_COLUMN_MAP(CProductsAccessor)  \n      COLUMN_ENTRY_LENGTH_STATUS(1, m_ProductID, m_dwProductIDLength, m_dwProductIDStatus)  \n      COLUMN_ENTRY_LENGTH_STATUS(2, m_ProductName, m_dwProductNameLength, m_dwProductNameStatus)  \n      COLUMN_ENTRY_LENGTH_STATUS(3, m_SupplierID, m_dwSupplierIDLength, m_dwSupplierIDStatus)  \n      COLUMN_ENTRY_LENGTH_STATUS(4, m_CategoryID, m_dwCategoryIDLength, m_dwCategoryIDStatus)  \n      COLUMN_ENTRY_LENGTH_STATUS(5, m_QuantityPerUnit, m_dwQuantityPerUnitLength, m_dwQuantityPerUnitStatus)  \n      _COLUMN_ENTRY_CODE(6, DBTYPE_CY, _SIZE_TYPE(m_UnitPrice), 0, 0, offsetbuf(m_UnitPrice), offsetbuf(m_dwUnitPriceLength), offsetbuf(m_dwUnitPriceStatus))  \n      COLUMN_ENTRY_LENGTH_STATUS(7, m_UnitsInStock, m_dwUnitsInStockLength, m_dwUnitsInStockStatus)  \n      COLUMN_ENTRY_LENGTH_STATUS(8, m_UnitsOnOrder, m_dwUnitsOnOrderLength, m_dwUnitsOnOrderStatus)  \n      COLUMN_ENTRY_LENGTH_STATUS(9, m_ReorderLevel, m_dwReorderLevelLength, m_dwReorderLevelStatus)  \n      _COLUMN_ENTRY_CODE(10, DBTYPE_BOOL, _SIZE_TYPE(m_Discontinued), 0, 0, offsetbuf(m_Discontinued), offsetbuf(m_dwDiscontinuedLength), offsetbuf(m_dwDiscontinuedStatus))  \n   END_COLUMN_MAP()  \n};  \n```  \n  \n### Class Declaration  \n Finally, the wizard generates a command class declaration such as the following:  \n  \n```  \nclass CProducts : public CCommand<CAccessor<CProductsAccessor> >  \n```  \n  \n## Attribute-Injected User Record Classes  \n If you create an OLE DB consumer using the database attributes ([db_command](../../windows/db-command.md) or [db_table](../../windows/db-table.md)), the attributes inject a user record class with a name of the form \"_*ClassName*Accessor.\" For example, if you named your command class `COrders`, the user record class will be `_COrdersAccessor`. Although the user record class appears in Class View, double-clicking it navigates to the command or table class in the header file instead. In these cases, you can only view the actual declaration of the user record class by viewing the attribute-injected code.  \n  \n There can be potential complications if you add or override methods in attributed consumers. For example, you could add a `_COrdersAccessor` constructor to the `COrders` declaration, but note that in reality this adds a constructor to the injected `COrdersAccessor` class. Such a constructor can initialize the columns/parameters, but you cannot create a copy constructor this way, because it cannot directly instantiate the `COrdersAccessor` object. If you need a constructor (or other method) directly on the `COrders` class, it is recommended that you define a new class deriving from `COrders` and add the necessary methods there.  \n  \n In the following example, the wizard generates a declaration for the class `COrders`, but the user record class `COrdersAccessor` does not appear, because the attributes inject it.  \n  \n```  \n#define _ATL_ATTRIBUTES  \n#include <atlbase.h>  \n#include <atldbcli.h>  \n[  \n   db_source(L\"your connection string\"),  \n   db_command(L\"Select ShipName from Orders;\")  \n]  \nclass COrders  \n{  \npublic:  \n  \n   // COrders()            // incorrect constructor name  \n   _COrdersAccessor()      // correct constructor name  \n   {  \n   }  \n      [db_column(1) ] TCHAR m_ShipName[41];  \n   };  \n```  \n  \n The injected command class declaration looks like this:  \n  \n```  \nclass CProducts : public CCommand<CAccessor<_CProductsAccessor> >  \n```  \n  \n Most of the injected code is the same as or similar to the templated version. The main differences are in the injected methods, which are described in [Consumer Wizard-Generated Methods](../../data/oledb/consumer-wizard-generated-methods.md).  \n  \n For information about viewing injected code, see [Debugging Injected Code](http://msdn.microsoft.com/library/a1b4104d-d49e-451f-a91e-e39ceaf35875).  \n  \n## See Also  \n [Creating an OLE DB Consumer Using a Wizard](../../data/oledb/creating-an-ole-db-consumer-using-a-wizard.md)"}