{"nodes":[{"pos":[12,72],"content":"interface class  (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"interface class  (C++ Component Extensions) | Microsoft Docs","pos":[0,60]}]},{"content":"interface class  (C++ Component Extensions)","pos":[681,724]},{"content":"Declares an interface.","pos":[725,747]},{"content":"For information on native interfaces, see <bpt id=\"p1\">[</bpt>__interface<ept id=\"p1\">](../cpp/interface.md)</ept>.","pos":[749,826],"source":"  For information on native interfaces, see [__interface](../cpp/interface.md)."},{"content":"All Runtimes","pos":[835,847]},{"content":"Syntax","pos":[853,859]},{"content":"Parameters","pos":[1039,1049]},{"content":"interface_access","pos":[1059,1075]},{"content":"The accessibility of an interface outside the assembly.","pos":[1080,1135]},{"content":"Possible values are <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`private`</ph>.","pos":[1137,1182],"source":"  Possible values are **public** and `private`."},{"content":"is the default.","pos":[1194,1209]},{"content":"Nested interfaces cannot have an <bpt id=\"p1\">*</bpt>interface_access<ept id=\"p1\">*</ept> specifier.","pos":[1211,1273],"source":"  Nested interfaces cannot have an *interface_access* specifier."},{"content":"name","pos":[1281,1285]},{"content":"The name of the interface.","pos":[1290,1316]},{"content":"inherit_access","pos":[1324,1338]},{"content":"The accessibility of <bpt id=\"p1\">*</bpt>base_interface<ept id=\"p1\">*</ept>.","pos":[1343,1381],"source":" The accessibility of *base_interface*."},{"content":"The only permitted accessibility for a base interface is <ph id=\"ph1\">`public`</ph> (the default).","pos":[1383,1463],"source":"  The only permitted accessibility for a base interface is `public` (the default)."},{"content":"<bpt id=\"p1\">*</bpt>base_interface<ept id=\"p1\">*</ept> (optional)","pos":[1470,1497],"source":"*base_interface* (optional)"},{"content":"A base interface for interface <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept>.","pos":[1501,1539],"source":" A base interface for interface *name*."},{"content":"Remarks","pos":[1548,1555]},{"pos":[1564,1622],"content":"<bpt id=\"p1\">**</bpt>interface struct<ept id=\"p1\">**</ept> is equivalent to <bpt id=\"p2\">**</bpt>interface class<ept id=\"p2\">**</ept>.","source":"**interface struct** is equivalent to **interface class**."},{"content":"An interface can contain declarations for functions, events, and properties.","pos":[1629,1705]},{"content":"All interface members have public accessibility.","pos":[1707,1755]},{"content":"An interface can also contain static data members, functions, events, and properties, and these static members must be defined in the interface.","pos":[1756,1900]},{"content":"An interface defines how a class may be implemented.","pos":[1907,1959]},{"content":"An interface is not a class and classes can only implement interfaces.","pos":[1960,2030]},{"content":"When a class defines a function declared in an interface, the function is implemented, not overridden.","pos":[2031,2133]},{"content":"Therefore, name lookup does not include interface members.","pos":[2134,2192]},{"content":"A class or struct that derives from an interface must implement all members of the interface.","pos":[2199,2292]},{"content":"When implementing interface <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> you must also implement the interfaces in the <ph id=\"ph1\">`base_interface`</ph> list.","pos":[2293,2396],"source":" When implementing interface *name* you must also implement the interfaces in the `base_interface` list."},{"content":"For more information, see:","pos":[2403,2429]},{"content":"Interface Static Constructor","pos":[2440,2468]},{"content":"Generic Interfaces (Visual C++)","pos":[2548,2579]},{"pos":[2632,2754],"content":"For information on other CLR types, see <bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](../windows/classes-and-structs-cpp-component-extensions.md)</ept>.","source":"For information on other CLR types, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)."},{"content":"You can detect at compile time if a type is an interface with <ph id=\"ph1\">`__is_interface_class(``type``)`</ph>.","pos":[2761,2856],"source":"You can detect at compile time if a type is an interface with `__is_interface_class(``type``)`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Compiler Support for Type Traits<ept id=\"p1\">](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)</ept>.","pos":[2857,2991],"source":" For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)."},{"pos":[2998,3146],"content":"In the development environment, you can get F1 help on these keywords by highlighting the keyword, (<ph id=\"ph1\">`interface class`</ph>, for example) and pressing F1.","source":"In the development environment, you can get F1 help on these keywords by highlighting the keyword, (`interface class`, for example) and pressing F1."},{"content":"Remarks","pos":[3213,3220]},{"content":"(There are no remarks for this language feature that apply to only the Windows Runtime.)","pos":[3229,3317]},{"content":"Requirements","pos":[3327,3339]},{"pos":[3343,3367],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Remarks","pos":[3453,3460]},{"content":"(There are no remarks for this language feature that apply to only the common language runtime.)","pos":[3469,3565]},{"content":"Requirements","pos":[3575,3587]},{"pos":[3591,3616],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[3626,3634]},{"content":"Example","pos":[3640,3647]},{"content":"The following code example demonstrates how an interface can define the behavior of a clock function.","pos":[3656,3757]},{"content":"Output","pos":[6214,6220]},{"content":"Example","pos":[6357,6364]},{"content":"The following code sample shows two ways to implement functions with the same signature declared in multiple interfaces and where those interfaces are used by a class.","pos":[6373,6540]},{"content":"See Also","pos":[7033,7041]},{"content":"Component Extensions for Runtime Platforms","pos":[7046,7088]}],"content":"---\ntitle: \"interface class  (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"interface_CPP\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"interface class keyword\"\n  - \"interface struct keyword\"\nms.assetid: 3ccea701-f50b-4da7-ad6b-f0ee1203e2b9\ncaps.latest.revision: 30\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# interface class  (C++ Component Extensions)\nDeclares an interface.  For information on native interfaces, see [__interface](../cpp/interface.md).  \n  \n## All Runtimes  \n **Syntax**  \n  \n```  \n  \ninterface_access  \ninterface class  \n name :  inherit_accessbase_interface{};interface_accessinterface structname :  inherit_accessbase_interface{};  \n```  \n  \n **Parameters**  \n  \n *interface_access*  \n The accessibility of an interface outside the assembly.  Possible values are **public** and `private`.  `private` is the default.  Nested interfaces cannot have an *interface_access* specifier.  \n  \n *name*  \n The name of the interface.  \n  \n *inherit_access*  \n The accessibility of *base_interface*.  The only permitted accessibility for a base interface is `public` (the default).  \n  \n *base_interface* (optional)  \n A base interface for interface *name*.  \n  \n **Remarks**  \n  \n **interface struct** is equivalent to **interface class**.  \n  \n An interface can contain declarations for functions, events, and properties.  All interface members have public accessibility. An interface can also contain static data members, functions, events, and properties, and these static members must be defined in the interface.  \n  \n An interface defines how a class may be implemented. An interface is not a class and classes can only implement interfaces. When a class defines a function declared in an interface, the function is implemented, not overridden. Therefore, name lookup does not include interface members.  \n  \n A class or struct that derives from an interface must implement all members of the interface. When implementing interface *name* you must also implement the interfaces in the `base_interface` list.  \n  \n For more information, see:  \n  \n-   [Interface Static Constructor](../dotnet/how-to-define-an-interface-static-constructor-cpp-cli.md)  \n  \n-   [Generic Interfaces (Visual C++)](../windows/generic-interfaces-visual-cpp.md)  \n  \n For information on other CLR types, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md).  \n  \n You can detect at compile time if a type is an interface with `__is_interface_class(``type``)`. For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md).  \n  \n In the development environment, you can get F1 help on these keywords by highlighting the keyword, (`interface class`, for example) and pressing F1.  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n **Remarks**  \n  \n (There are no remarks for this language feature that apply to only the Windows Runtime.)  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  \n **Remarks**  \n  \n (There are no remarks for this language feature that apply to only the common language runtime.)  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n The following code example demonstrates how an interface can define the behavior of a clock function.  \n  \n```  \n// mcppv2_interface_class.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \npublic delegate void ClickEventHandler(int, double);  \n  \n// define interface with nested interface  \npublic interface class Interface_A {  \n   void Function_1();  \n  \n   interface class Interface_Nested_A {  \n      void Function_2();  \n   };  \n};  \n  \n// interface with a base interface  \npublic interface class Interface_B : Interface_A {  \n   property int Property_Block;  \n   event ClickEventHandler^ OnClick;     \n   static void Function_3() { Console::WriteLine(\"in Function_3\"); }  \n};  \n  \n// implement nested interface  \npublic ref class MyClass : public Interface_A::Interface_Nested_A {  \npublic:  \n   virtual void Function_2() { Console::WriteLine(\"in Function_2\"); }  \n};  \n  \n// implement interface and base interface  \npublic ref class MyClass2 : public Interface_B {  \nprivate:  \n   int MyInt;  \n  \npublic:  \n   // implement non-static function  \n   virtual void Function_1() { Console::WriteLine(\"in Function_1\"); }  \n  \n   // implement property  \n   property int Property_Block {  \n      virtual int get() { return MyInt; }  \n      virtual void set(int value) { MyInt = value; }  \n   }  \n   // implement event  \n   virtual event ClickEventHandler^ OnClick;  \n  \n   void FireEvents() {  \n      OnClick(7, 3.14159);  \n   }  \n};  \n  \n// class that defines method called when event occurs  \nref class EventReceiver {  \npublic:  \n   void OnMyClick(int i, double d) {  \n      Console::WriteLine(\"OnClick: {0}, {1}\", i, d);  \n   }  \n};  \n  \nint main() {  \n   // call static function in an interface  \n   Interface_B::Function_3();  \n  \n   // instantiate class that implements nested interface  \n   MyClass ^ x = gcnew MyClass;  \n   x->Function_2();  \n  \n   // instantiate class that implements interface with base interface  \n   MyClass2 ^ y = gcnew MyClass2;  \n   y->Function_1();  \n   y->Property_Block = 8;  \n   Console::WriteLine(y->Property_Block);  \n  \n   EventReceiver^ MyEventReceiver = gcnew EventReceiver();  \n  \n   // hook handler to event  \n   y->OnClick += gcnew ClickEventHandler(MyEventReceiver, &EventReceiver::OnMyClick);  \n  \n   // invoke events  \n   y->FireEvents();  \n  \n   // unhook handler to event  \n   y->OnClick -= gcnew ClickEventHandler(MyEventReceiver, &EventReceiver::OnMyClick);  \n  \n   // call implemented function via interface handle  \n   Interface_A^ hi = gcnew MyClass2();  \n   hi->Function_1();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nin Function_3  \n  \nin Function_2  \n  \nin Function_1  \n  \n8  \n  \nOnClick: 7, 3.14159  \n  \nin Function_1  \n```  \n  \n **Example**  \n  \n The following code sample shows two ways to implement functions with the same signature declared in multiple interfaces and where those interfaces are used by a class.  \n  \n```  \n// mcppv2_interface_class_2.cpp  \n// compile with: /clr /c  \ninterface class I {  \n   void Test();  \n   void Test2();  \n};  \n  \ninterface class J : I {  \n   void Test();  \n   void Test2();  \n};  \n  \nref struct R : I, J {  \n   // satisfies the requirement to implement Test in both interfaces  \n   virtual void Test() {}  \n  \n   // implement both interface functions with explicit overrides  \n   virtual void A() = I::Test2 {}  \n   virtual void B() = J::Test2 {}  \n};  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}