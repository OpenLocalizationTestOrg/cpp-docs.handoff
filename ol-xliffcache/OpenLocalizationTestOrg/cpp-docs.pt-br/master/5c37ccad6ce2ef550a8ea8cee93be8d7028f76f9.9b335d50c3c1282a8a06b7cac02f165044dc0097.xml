{"nodes":[{"pos":[12,52],"content":"Friend Assemblies (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Friend Assemblies (C++) | Microsoft Docs","pos":[0,40]}]},{"content":"Friend Assemblies (C++)","pos":[617,640]},{"pos":[641,847],"content":"For applicable runtimes, the <bpt id=\"p1\">*</bpt>friend assemblies<ept id=\"p1\">*</ept> language feature makes types that are at namespace scope or global scope in an assembly component accessible to one or more client assemblies or .netmodules.","source":"For applicable runtimes, the *friend assemblies* language feature makes types that are at namespace scope or global scope in an assembly component accessible to one or more client assemblies or .netmodules."},{"content":"All Runtimes","pos":[856,868]},{"content":"Remarks","pos":[874,881]},{"content":"(This language feature is not supported in all runtimes.)","pos":[890,947]},{"content":"Remarks","pos":[1014,1021]},{"pos":[1030,1131],"content":"(This language feature is not supported in the <ph id=\"ph1\">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph>.)","source":"(This language feature is not supported in the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)].)"},{"content":"Requirements","pos":[1141,1153]},{"pos":[1157,1181],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Remarks","pos":[1267,1274]},{"content":"To make types at namespace scope or global scope in an assembly component accessible to a client assembly or .netmodule","pos":[1287,1406]},{"content":"In the component, specify an assembly attribute &lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt;, and pass the name of the client assembly or .netmodule that will access types at namespace scope or global scope in the component.","pos":[1416,1662],"source":"In the component, specify an assembly attribute <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute>, and pass the name of the client assembly or .netmodule that will access types at namespace scope or global scope in the component."},{"content":"You can specify multiple client assemblies or .netmodules by specifying additional attributes.","pos":[1664,1758]},{"content":"In the client assembly or .netmodule, when you reference the component assembly by using <ph id=\"ph1\">`#using`</ph>, pass the <ph id=\"ph2\">`as_friend`</ph> attribute.","pos":[1768,1898],"source":"In the client assembly or .netmodule, when you reference the component assembly by using `#using`, pass the `as_friend` attribute."},{"content":"If you specify the <ph id=\"ph1\">`as_friend`</ph> attribute for an assembly that does not specify <ph id=\"ph2\">`InternalsVisibleToAttribute`</ph>, a runtime exception will be thrown if you try to access a type at namespace scope or global scope in the component.","pos":[1900,2125],"source":"  If you specify the `as_friend` attribute for an assembly that does not specify `InternalsVisibleToAttribute`, a runtime exception will be thrown if you try to access a type at namespace scope or global scope in the component."},{"pos":[2132,2362],"content":"A build error will result if the assembly that contains the &lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt; attribute does not have a strong name but the client assembly that uses the <ph id=\"ph1\">`as_friend`</ph> attribute does.","source":"A build error will result if the assembly that contains the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute does not have a strong name but the client assembly that uses the `as_friend` attribute does."},{"content":"Although types at namespace scope and global scope can be known to a client assembly or .netmodule, member accessibility is still in effect.","pos":[2369,2509]},{"content":"For example, you cannot access a private member.","pos":[2511,2559]},{"content":"Access to all types in an assembly must be explicitly granted.","pos":[2566,2628]},{"content":"For example, assembly C does not have access to all types in assembly A if assembly C references assembly B and assembly B has access to all types in assembly A.","pos":[2630,2791]},{"pos":[2798,3050],"content":"For information about how to sign—that is, how to give a strong name to—an assembly that is built by using the Visual C++ compiler, see <bpt id=\"p1\">[</bpt>Strong Name Assemblies (Assembly Signing) (C++/CLI)<ept id=\"p1\">](../dotnet/strong-name-assemblies-assembly-signing-cpp-cli.md)</ept>.","source":"For information about how to sign—that is, how to give a strong name to—an assembly that is built by using the Visual C++ compiler, see [Strong Name Assemblies (Assembly Signing) (C++/CLI)](../dotnet/strong-name-assemblies-assembly-signing-cpp-cli.md)."},{"content":"As an alternative to using the friend assemblies feature, you can use &lt;xref:System.Security.Permissions.StrongNameIdentityPermission&gt; to restrict access to individual types.","pos":[3057,3230],"source":"As an alternative to using the friend assemblies feature, you can use <xref:System.Security.Permissions.StrongNameIdentityPermission> to restrict access to individual types."},{"content":"Requirements","pos":[3240,3252]},{"pos":[3256,3281],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[3291,3299]},{"content":"The following code example defines a component that specifies a client assembly that has access to the types in the component.","pos":[3303,3429]},{"content":"The next code example accesses a private type in the component.","pos":[3825,3888]},{"content":"Output","pos":[4089,4095]},{"content":"The next code example defines a component but does not specify a client assembly that will have access to the types in the component.","pos":[4132,4265]},{"content":"Notice that the component is linked by using <bpt id=\"p1\">**</bpt>/opt:noref<ept id=\"p1\">**</ept>.","pos":[4272,4332],"source":"Notice that the component is linked by using **/opt:noref**."},{"content":"This ensures that private types are emitted in the component's metadata, which is not required when the <ph id=\"ph1\">`InternalsVisibleTo`</ph> attribute is present.","pos":[4333,4479],"source":" This ensures that private types are emitted in the component's metadata, which is not required when the `InternalsVisibleTo` attribute is present."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>/OPT (Optimizations)<ept id=\"p1\">](../build/reference/opt-optimizations.md)</ept>.","pos":[4480,4570],"source":" For more information, see [/OPT (Optimizations)](../build/reference/opt-optimizations.md)."},{"content":"The following code example defines a client that tries to access a private type in a component that does not give access to its private types.","pos":[4819,4961]},{"content":"Because of the behavior of the runtime, if you want to catch the exception, you must attempt to access a private type in a helper function.","pos":[4962,5101]},{"content":"Output","pos":[5528,5534]},{"content":"The next code example shows how to create a strong-name component that specifies a client assembly that will have access to the types in the component.","pos":[5571,5722]},{"content":"Notice that the component must specify its public key.","pos":[6491,6545]},{"content":"We suggest that you run the following commands sequentially at a command prompt to create a key pair and get the public key:","pos":[6546,6670]},{"content":"sn -d friend_assemblies.snk","pos":[6679,6706]},{"content":"sn -k friend_assemblies.snk","pos":[6717,6744]},{"content":"sn -i friend_assemblies.snk friend_assemblies.snk","pos":[6755,6804]},{"content":"sn -pc friend_assemblies.snk key.publickey","pos":[6815,6857]},{"content":"sn -tp key.publickey","pos":[6868,6888]},{"content":"The next code example accesses a private type in the strong-name component.","pos":[6897,6972]},{"content":"Output","pos":[7212,7218]},{"content":"See Also","pos":[7257,7265]},{"content":"Component Extensions for Runtime Platforms","pos":[7270,7312]}],"content":"---\ntitle: \"Friend Assemblies (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"friend assemblies, Visual C++\"\nms.assetid: 8d55fee0-b7c2-4fbe-a23b-dfe424dc71cd\ncaps.latest.revision: 27\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Friend Assemblies (C++)\nFor applicable runtimes, the *friend assemblies* language feature makes types that are at namespace scope or global scope in an assembly component accessible to one or more client assemblies or .netmodules.  \n  \n## All Runtimes  \n **Remarks**  \n  \n (This language feature is not supported in all runtimes.)  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n **Remarks**  \n  \n (This language feature is not supported in the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)].)  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  \n **Remarks**  \n  \n#### To make types at namespace scope or global scope in an assembly component accessible to a client assembly or .netmodule  \n  \n1.  In the component, specify an assembly attribute <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute>, and pass the name of the client assembly or .netmodule that will access types at namespace scope or global scope in the component.  You can specify multiple client assemblies or .netmodules by specifying additional attributes.  \n  \n2.  In the client assembly or .netmodule, when you reference the component assembly by using `#using`, pass the `as_friend` attribute.  If you specify the `as_friend` attribute for an assembly that does not specify `InternalsVisibleToAttribute`, a runtime exception will be thrown if you try to access a type at namespace scope or global scope in the component.  \n  \n A build error will result if the assembly that contains the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute does not have a strong name but the client assembly that uses the `as_friend` attribute does.  \n  \n Although types at namespace scope and global scope can be known to a client assembly or .netmodule, member accessibility is still in effect.  For example, you cannot access a private member.  \n  \n Access to all types in an assembly must be explicitly granted.  For example, assembly C does not have access to all types in assembly A if assembly C references assembly B and assembly B has access to all types in assembly A.  \n  \n For information about how to sign—that is, how to give a strong name to—an assembly that is built by using the Visual C++ compiler, see [Strong Name Assemblies (Assembly Signing) (C++/CLI)](../dotnet/strong-name-assemblies-assembly-signing-cpp-cli.md).  \n  \n As an alternative to using the friend assemblies feature, you can use <xref:System.Security.Permissions.StrongNameIdentityPermission> to restrict access to individual types.  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n The following code example defines a component that specifies a client assembly that has access to the types in the component.  \n  \n```  \n  \n      // friend_assemblies.cpp  \n// compile by using: /clr /LD  \nusing namespace System::Runtime::CompilerServices;  \nusing namespace System;  \n// an assembly attribute, not bound to a type  \n[assembly:InternalsVisibleTo(\"friend_assemblies_2\")];  \n  \nref class Class1 {  \npublic:  \n   void Test_Public() {  \n      Console::WriteLine(\"Class1::Test_Public\");  \n   }  \n};  \n```  \n  \n The next code example accesses a private type in the component.  \n  \n```  \n// friend_assemblies_2.cpp  \n// compile by using: /clr  \n#using \"friend_assemblies.dll\" as_friend  \n  \nint main() {  \n   Class1 ^ a = gcnew Class1;  \n   a->Test_Public();  \n}  \n```  \n  \n **Output**  \n  \n `Class1::Test_Public`  \n  \n The next code example defines a component but does not specify a client assembly that will have access to the types in the component.  \n  \n Notice that the component is linked by using **/opt:noref**. This ensures that private types are emitted in the component's metadata, which is not required when the `InternalsVisibleTo` attribute is present. For more information, see [/OPT (Optimizations)](../build/reference/opt-optimizations.md).  \n  \n```  \n// friend_assemblies_3.cpp  \n// compile by using: /clr /LD /link /opt:noref  \nusing namespace System;  \n  \nref class Class1 {  \npublic:  \n   void Test_Public() {  \n      Console::WriteLine(\"Class1::Test_Public\");  \n   }  \n};  \n```  \n  \n The following code example defines a client that tries to access a private type in a component that does not give access to its private types. Because of the behavior of the runtime, if you want to catch the exception, you must attempt to access a private type in a helper function.  \n  \n```  \n// friend_assemblies_4.cpp  \n// compile by using: /clr  \n#using \"friend_assemblies_3.dll\" as_friend  \nusing namespace System;  \n  \nvoid Test() {  \n   Class1 ^ a = gcnew Class1;  \n}  \n  \nint main() {  \n   // to catch this kind of exception, use a helper function  \n   try {  \n      Test();     \n   }  \n   catch(MethodAccessException ^ e) {  \n      Console::WriteLine(\"caught an exception\");  \n   }  \n}  \n```  \n  \n **Output**  \n  \n `caught an exception`  \n  \n The next code example shows how to create a strong-name component that specifies a client assembly that will have access to the types in the component.  \n  \n```  \n// friend_assemblies_5.cpp  \n// compile by using: /clr /LD /link /keyfile:friend_assemblies.snk  \nusing namespace System::Runtime::CompilerServices;  \nusing namespace System;  \n// an assembly attribute, not bound to a type  \n  \n[assembly:InternalsVisibleTo(\"friend_assemblies_6, PublicKey=00240000048000009400000006020000002400005253413100040000010001000bf45d77fd991f3bff0ef51af48a12d35699e04616f27ba561195a69ebd3449c345389dc9603d65be8cd1987bc7ea48bdda35ac7d57d3d82c666b7fc1a5b79836d139ef0ac8c4e715434211660f481612771a9f7059b9b742c3d8af00e01716ed4b872e6f1be0e94863eb5745224f0deaba5b137624d7049b6f2d87fba639fc5\")];  \n  \nprivate ref class Class1 {  \npublic:  \n   void Test_Public() {  \n      Console::WriteLine(\"Class1::Test_Public\");  \n   }  \n};  \n```  \n  \n Notice that the component must specify its public key. We suggest that you run the following commands sequentially at a command prompt to create a key pair and get the public key:  \n  \n **sn -d friend_assemblies.snk**  \n  \n **sn -k friend_assemblies.snk**  \n  \n **sn -i friend_assemblies.snk friend_assemblies.snk**  \n  \n **sn -pc friend_assemblies.snk key.publickey**  \n  \n **sn -tp key.publickey**  \n  \n The next code example accesses a private type in the strong-name component.  \n  \n```  \n// friend_assemblies_6.cpp  \n// compile by using: /clr /link /keyfile:friend_assemblies.snk  \n#using \"friend_assemblies_5.dll\" as_friend  \n  \nint main() {  \n   Class1 ^ a = gcnew Class1;  \n   a->Test_Public();  \n}  \n```  \n  \n **Output**  \n  \n `Class1::Test_Public`  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}