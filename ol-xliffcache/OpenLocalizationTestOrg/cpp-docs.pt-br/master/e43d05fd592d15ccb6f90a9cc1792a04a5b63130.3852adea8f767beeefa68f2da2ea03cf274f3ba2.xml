{"nodes":[{"pos":[12,44],"content":"typeid Operator | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"typeid Operator | Microsoft Docs","pos":[0,32]}]},{"content":"typeid Operator","pos":[580,595]},{"content":"Syntax","pos":[599,605]},{"content":"Remarks","pos":[699,706]},{"pos":[710,790],"content":"The <ph id=\"ph1\">`typeid`</ph> operator allows the type of an object to be determined at run time.","source":"The `typeid` operator allows the type of an object to be determined at run time."},{"content":"The result of <ph id=\"ph1\">`typeid`</ph> is a <bpt id=\"p1\">**</bpt>const type_info&amp;<ept id=\"p1\">**</ept>.","pos":[797,846],"source":"The result of `typeid` is a **const type_info&**."},{"content":"The value is a reference to a <bpt id=\"p1\">**</bpt>type_info<ept id=\"p1\">**</ept> object that represents either the <bpt id=\"p2\">*</bpt>type-id<ept id=\"p2\">*</ept> or the type of the <bpt id=\"p3\">*</bpt>expression<ept id=\"p3\">*</ept>, depending on which form of <ph id=\"ph1\">`typeid`</ph> is used.","pos":[847,1012],"source":" The value is a reference to a **type_info** object that represents either the *type-id* or the type of the *expression*, depending on which form of `typeid` is used."},{"content":"See <bpt id=\"p1\">[</bpt>type_info Class<ept id=\"p1\">](../cpp/type-info-class.md)</ept> for more information.","pos":[1013,1083],"source":" See [type_info Class](../cpp/type-info-class.md) for more information."},{"pos":[1090,1313],"content":"The <ph id=\"ph1\">`typeid`</ph> operator  does not work with managed types (abstract declarators or instances), see <bpt id=\"p1\">[</bpt>typeid<ept id=\"p1\">](../windows/typeid-cpp-component-extensions.md)</ept> for information on getting the &lt;xref:System.Type&gt; of a specified type.","source":"The `typeid` operator  does not work with managed types (abstract declarators or instances), see [typeid](../windows/typeid-cpp-component-extensions.md) for information on getting the <xref:System.Type> of a specified type."},{"content":"The <ph id=\"ph1\">`typeid`</ph> operator does a run-time check when applied to an l-value of a polymorphic class type, where the true type of the object cannot be determined by the static information provided.","pos":[1320,1510],"source":"The `typeid` operator does a run-time check when applied to an l-value of a polymorphic class type, where the true type of the object cannot be determined by the static information provided."},{"content":"Such cases are:","pos":[1511,1526]},{"content":"A reference to a class","pos":[1536,1558]},{"content":"A pointer, dereferenced with *","pos":[1568,1598]},{"content":"A subscripted pointer (i.e. [ ]).","pos":[1608,1641]},{"content":"(Note that it is generally not safe to use a subscript with a pointer to a polymorphic type.)","pos":[1642,1735]},{"content":"If the <bpt id=\"p1\">*</bpt>expression<ept id=\"p1\">*</ept> points to a base class type, yet the object is actually of a type derived from that base class, a <bpt id=\"p2\">**</bpt>type_info<ept id=\"p2\">**</ept> reference for the derived class is the result.","pos":[1742,1920],"source":"If the *expression* points to a base class type, yet the object is actually of a type derived from that base class, a **type_info** reference for the derived class is the result."},{"content":"The <bpt id=\"p1\">*</bpt>expression<ept id=\"p1\">*</ept> must point to a polymorphic type (a class with virtual functions).","pos":[1921,2004],"source":" The *expression* must point to a polymorphic type (a class with virtual functions)."},{"content":"Otherwise, the result is the <bpt id=\"p1\">**</bpt>type_info<ept id=\"p1\">**</ept> for the static class referred to in the <bpt id=\"p2\">*</bpt>expression<ept id=\"p2\">*</ept>.","pos":[2005,2101],"source":" Otherwise, the result is the **type_info** for the static class referred to in the *expression*."},{"content":"Further, the pointer must be dereferenced so that the object it points to is used.","pos":[2102,2184]},{"content":"Without dereferencing the pointer, the result will be the <bpt id=\"p1\">**</bpt>type_info<ept id=\"p1\">**</ept> for the pointer, not what it points to.","pos":[2185,2296],"source":" Without dereferencing the pointer, the result will be the **type_info** for the pointer, not what it points to."},{"content":"For example:","pos":[2297,2309]},{"content":"If the <bpt id=\"p1\">*</bpt>expression<ept id=\"p1\">*</ept> is dereferencing a pointer, and that pointer's value is zero, <bpt id=\"p2\">**</bpt>typeid<ept id=\"p2\">**</ept> throws a <bpt id=\"p3\">[</bpt>bad_typeid exception<ept id=\"p3\">](../cpp/bad-typeid-exception.md)</ept>.","pos":[2929,3086],"source":"If the *expression* is dereferencing a pointer, and that pointer's value is zero, **typeid** throws a [bad_typeid exception](../cpp/bad-typeid-exception.md)."},{"content":"If the pointer does not point to a valid object, a <ph id=\"ph1\">`__non_rtti_object`</ph> exception is thrown, indicating an attempt to analyze the RTTI that triggered a fault (like access violation), because the object is somehow invalid (bad pointer or the code wasn't compiled with <bpt id=\"p1\">[</bpt>/GR<ept id=\"p1\">](../build/reference/gr-enable-run-time-type-information.md)</ept>).","pos":[3087,3419],"source":" If the pointer does not point to a valid object, a `__non_rtti_object` exception is thrown, indicating an attempt to analyze the RTTI that triggered a fault (like access violation), because the object is somehow invalid (bad pointer or the code wasn't compiled with [/GR](../build/reference/gr-enable-run-time-type-information.md))."},{"content":"If the <bpt id=\"p1\">*</bpt>expression<ept id=\"p1\">*</ept> is neither a pointer nor a reference to a base class of the object, the result is a <bpt id=\"p2\">**</bpt>type_info<ept id=\"p2\">**</ept> reference representing the static type of the <bpt id=\"p3\">*</bpt>expression<ept id=\"p3\">*</ept>.","pos":[3426,3603],"source":"If the *expression* is neither a pointer nor a reference to a base class of the object, the result is a **type_info** reference representing the static type of the *expression*."},{"content":"The <bpt id=\"p1\">*</bpt>static type<ept id=\"p1\">*</ept> of an expression refers to the type of an expression as it is known at compile time.","pos":[3604,3706],"source":" The *static type* of an expression refers to the type of an expression as it is known at compile time."},{"content":"Execution semantics are ignored when evaluating the static type of an expression.","pos":[3707,3788]},{"content":"Furthermore, references are ignored when possible when determining the static type of an expression:","pos":[3789,3889]},{"pos":[4045,4132],"content":"<bpt id=\"p1\">**</bpt>typeid<ept id=\"p1\">**</ept> can also be used in templates to determine the type of a template parameter:","source":"**typeid** can also be used in templates to determine the type of a template parameter:"},{"content":"See Also","pos":[4393,4401]},{"content":"Run-Time Type Information","pos":[4406,4431]},{"content":"Keywords","pos":[4475,4483]}],"content":"---\ntitle: \"typeid Operator | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"typeid operator\"\nms.assetid: 8871cee6-d6b9-4301-a5cb-bf3dc9798d61\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# typeid Operator\n## Syntax  \n  \n```  \n  \n      typeid(   \n      type-id  \n       )  \ntypeid( expression )  \n```  \n  \n## Remarks  \n The `typeid` operator allows the type of an object to be determined at run time.  \n  \n The result of `typeid` is a **const type_info&**. The value is a reference to a **type_info** object that represents either the *type-id* or the type of the *expression*, depending on which form of `typeid` is used. See [type_info Class](../cpp/type-info-class.md) for more information.  \n  \n The `typeid` operator  does not work with managed types (abstract declarators or instances), see [typeid](../windows/typeid-cpp-component-extensions.md) for information on getting the <xref:System.Type> of a specified type.  \n  \n The `typeid` operator does a run-time check when applied to an l-value of a polymorphic class type, where the true type of the object cannot be determined by the static information provided. Such cases are:  \n  \n-   A reference to a class  \n  \n-   A pointer, dereferenced with *  \n  \n-   A subscripted pointer (i.e. [ ]). (Note that it is generally not safe to use a subscript with a pointer to a polymorphic type.)  \n  \n If the *expression* points to a base class type, yet the object is actually of a type derived from that base class, a **type_info** reference for the derived class is the result. The *expression* must point to a polymorphic type (a class with virtual functions). Otherwise, the result is the **type_info** for the static class referred to in the *expression*. Further, the pointer must be dereferenced so that the object it points to is used. Without dereferencing the pointer, the result will be the **type_info** for the pointer, not what it points to. For example:  \n  \n```  \n// expre_typeid_Operator.cpp  \n// compile with: /GR /EHsc  \n#include <iostream>  \n#include <typeinfo.h>  \n  \nclass Base {  \npublic:  \n   virtual void vvfunc() {}  \n};  \n  \nclass Derived : public Base {};  \n  \nusing namespace std;  \nint main() {  \n   Derived* pd = new Derived;  \n   Base* pb = pd;  \n   cout << typeid( pb ).name() << endl;   //prints \"class Base *\"  \n   cout << typeid( *pb ).name() << endl;   //prints \"class Derived\"  \n   cout << typeid( pd ).name() << endl;   //prints \"class Derived *\"  \n   cout << typeid( *pd ).name() << endl;   //prints \"class Derived\"  \n   delete pd;  \n}  \n```  \n  \n If the *expression* is dereferencing a pointer, and that pointer's value is zero, **typeid** throws a [bad_typeid exception](../cpp/bad-typeid-exception.md). If the pointer does not point to a valid object, a `__non_rtti_object` exception is thrown, indicating an attempt to analyze the RTTI that triggered a fault (like access violation), because the object is somehow invalid (bad pointer or the code wasn't compiled with [/GR](../build/reference/gr-enable-run-time-type-information.md)).  \n  \n If the *expression* is neither a pointer nor a reference to a base class of the object, the result is a **type_info** reference representing the static type of the *expression*. The *static type* of an expression refers to the type of an expression as it is known at compile time. Execution semantics are ignored when evaluating the static type of an expression. Furthermore, references are ignored when possible when determining the static type of an expression:  \n  \n```  \n// expre_typeid_Operator_2.cpp  \n#include <typeinfo>  \n  \nint main()  \n{  \n   typeid(int) == typeid(int&); // evaluates to true  \n}  \n```  \n  \n **typeid** can also be used in templates to determine the type of a template parameter:  \n  \n```  \n// expre_typeid_Operator_3.cpp  \n// compile with: /c  \n#include <typeinfo>  \ntemplate < typename T >   \nT max( T arg1, T arg2 ) {  \n   cout << typeid( T ).name() << \"s compared.\" << endl;  \n   return ( arg1 > arg2 ? arg1 : arg2 );  \n}  \n```  \n  \n## See Also  \n [Run-Time Type Information](../cpp/run-time-type-information.md)   \n [Keywords](../cpp/keywords-cpp.md)"}