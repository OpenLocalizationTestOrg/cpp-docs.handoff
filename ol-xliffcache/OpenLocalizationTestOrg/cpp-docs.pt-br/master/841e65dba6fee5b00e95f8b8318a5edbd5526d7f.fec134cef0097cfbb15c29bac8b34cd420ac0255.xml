{"nodes":[{"pos":[12,54],"content":"#define Directive (C-C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"define Directive (C-C++) | Microsoft Doc","pos":[1,41]}]},{"content":"define Directive (C/C++)","pos":[755,779]},{"content":"The <ph id=\"ph1\">`#define`</ph> creates a <bpt id=\"p1\">*</bpt>macro<ept id=\"p1\">*</ept>, which is the association of an identifier or parameterized identifier with a token string.","pos":[780,903],"source":"The `#define` creates a *macro*, which is the association of an identifier or parameterized identifier with a token string."},{"content":"After the macro is defined, the compiler can substitute the token string for each occurrence of the identifier in the source file.","pos":[904,1034]},{"content":"Syntax","pos":[1043,1049]},{"pos":[1063,1093],"content":"<bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> <bpt id=\"p2\">*</bpt>token-string<ept id=\"p2\">*</ept>opt","source":"*identifier* *token-string*opt"},{"pos":[1110,1188],"content":"<bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> <ph id=\"ph1\">`(`</ph> <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept>opt<ph id=\"ph2\">`,`</ph><bpt id=\"p3\">*</bpt>...<ept id=\"p3\">*</ept><ph id=\"ph3\">`,`</ph><bpt id=\"p4\">*</bpt>identifier<ept id=\"p4\">*</ept>opt<ph id=\"ph4\">`)`</ph><bpt id=\"p5\">*</bpt>token-string<ept id=\"p5\">*</ept>opt","source":"*identifier* `(` *identifier*opt`,`*...*`,`*identifier*opt`)`*token-string*opt"},{"content":"Remarks","pos":[1197,1204]},{"content":"The <ph id=\"ph1\">`#define`</ph> directive causes the compiler to substitute <bpt id=\"p1\">*</bpt>token-string<ept id=\"p1\">*</ept> for each occurrence of <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept> in the source file.","pos":[1208,1336],"source":"The `#define` directive causes the compiler to substitute *token-string* for each occurrence of *identifier* in the source file."},{"content":"The <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> is replaced only when it forms a token.","pos":[1337,1393],"source":" The *identifier* is replaced only when it forms a token."},{"content":"That is, <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> is not replaced if it appears in a comment, in a string, or as part of a longer identifier.","pos":[1394,1507],"source":" That is, *identifier* is not replaced if it appears in a comment, in a string, or as part of a longer identifier."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Tokens<ept id=\"p1\">](../cpp/tokens-cpp.md)</ept>.","pos":[1508,1565],"source":" For more information, see [Tokens](../cpp/tokens-cpp.md)."},{"content":"The <bpt id=\"p1\">*</bpt>token-string<ept id=\"p1\">*</ept> argument consists of a series of tokens, such as keywords, constants, or complete statements.","pos":[1572,1684],"source":"The *token-string* argument consists of a series of tokens, such as keywords, constants, or complete statements."},{"content":"One or more white-space characters must separate <bpt id=\"p1\">*</bpt>token-string<ept id=\"p1\">*</ept> from <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept>.","pos":[1685,1767],"source":" One or more white-space characters must separate *token-string* from *identifier*."},{"content":"This white space is not considered part of the substituted text, nor is any white space that follows the last token of the text.","pos":[1768,1896]},{"content":"A <ph id=\"ph1\">`#define`</ph> without a <bpt id=\"p1\">*</bpt>token-string<ept id=\"p1\">*</ept> removes occurrences of <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept> from the source file.","pos":[1903,1997],"source":"A `#define` without a *token-string* removes occurrences of *identifier* from the source file."},{"content":"The <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> remains defined and can be tested by using the <ph id=\"ph1\">`#if defined`</ph> and <ph id=\"ph2\">`#ifdef`</ph> directives.","pos":[1998,2100],"source":" The *identifier* remains defined and can be tested by using the `#if defined` and `#ifdef` directives."},{"content":"The second syntax form defines a function-like macro with parameters.","pos":[2107,2176]},{"content":"This form accepts an optional list of parameters that must appear in parentheses.","pos":[2177,2258]},{"content":"After the macro is defined, each subsequent occurrence of <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept>( <bpt id=\"p2\">*</bpt>identifier<ept id=\"p2\">*</ept>opt, ..., <bpt id=\"p3\">*</bpt>identifier<ept id=\"p3\">*</ept>opt ) is replaced with a version of the <bpt id=\"p4\">*</bpt>token-string<ept id=\"p4\">*</ept> argument that has actual arguments substituted for formal parameters.","pos":[2259,2489],"source":" After the macro is defined, each subsequent occurrence of *identifier*( *identifier*opt, ..., *identifier*opt ) is replaced with a version of the *token-string* argument that has actual arguments substituted for formal parameters."},{"content":"Formal parameter names appear in <bpt id=\"p1\">*</bpt>token-string<ept id=\"p1\">*</ept> to mark the locations where actual values are substituted.","pos":[2496,2602],"source":"Formal parameter names appear in *token-string* to mark the locations where actual values are substituted."},{"content":"Each parameter name can appear multiple times in <bpt id=\"p1\">*</bpt>token-string<ept id=\"p1\">*</ept>, and the names can appear in any order.","pos":[2603,2706],"source":" Each parameter name can appear multiple times in *token-string*, and the names can appear in any order."},{"content":"The number of arguments in the call must match the number of parameters in the macro definition.","pos":[2707,2803]},{"content":"Liberal use of parentheses guarantees that complex actual arguments are interpreted correctly.","pos":[2804,2898]},{"content":"The formal parameters in the list are separated by commas.","pos":[2905,2963]},{"content":"Each name in the list must be unique, and the list must be enclosed in parentheses.","pos":[2964,3047]},{"content":"No spaces can separate <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> and the opening parenthesis.","pos":[3048,3112],"source":" No spaces can separate *identifier* and the opening parenthesis."},{"content":"Use line concatenation — place a backslash (<ph id=\"ph1\">`\\`</ph>) immediately before the newline character — for long directives on multiple source lines.","pos":[3113,3250],"source":" Use line concatenation — place a backslash (`\\`) immediately before the newline character — for long directives on multiple source lines."},{"content":"The scope of a formal parameter name extends to the new line that ends <bpt id=\"p1\">*</bpt>token-string<ept id=\"p1\">*</ept>.","pos":[3251,3337],"source":" The scope of a formal parameter name extends to the new line that ends *token-string*."},{"content":"When a macro has been defined in the second syntax form, subsequent textual instances followed by an argument list indicate a macro call.","pos":[3344,3481]},{"content":"The actual arguments that follows an instance of <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept> in the source file are matched to the corresponding formal parameters in the macro definition.","pos":[3482,3638],"source":" The actual arguments that follows an instance of *identifier* in the source file are matched to the corresponding formal parameters in the macro definition."},{"content":"Each formal parameter in <bpt id=\"p1\">*</bpt>token-string<ept id=\"p1\">*</ept> that is not preceded by a stringizing (<ph id=\"ph1\">`#`</ph>), charizing (<ph id=\"ph2\">`#@`</ph>), or token-pasting (<ph id=\"ph3\">`##`</ph>) operator, or not followed by a <ph id=\"ph4\">`##`</ph> operator, is replaced by the corresponding actual argument.","pos":[3639,3861],"source":" Each formal parameter in *token-string* that is not preceded by a stringizing (`#`), charizing (`#@`), or token-pasting (`##`) operator, or not followed by a `##` operator, is replaced by the corresponding actual argument."},{"content":"Any macros in the actual argument are expanded before the directive replaces the formal parameter.","pos":[3862,3960]},{"content":"(The operators are described in <bpt id=\"p1\">[</bpt>Preprocessor Operators<ept id=\"p1\">](../preprocessor/preprocessor-operators.md)</ept>.)","pos":[3961,4062],"source":" (The operators are described in [Preprocessor Operators](../preprocessor/preprocessor-operators.md).)"},{"pos":[4069,4168],"content":"The following examples of macros with arguments illustrate the second form of the <ph id=\"ph1\">`#define`</ph> syntax:","source":"The following examples of macros with arguments illustrate the second form of the `#define` syntax:"},{"content":"Arguments with side effects sometimes cause macros to produce unexpected results.","pos":[4424,4505]},{"content":"A given formal parameter may appear more than one time in <bpt id=\"p1\">*</bpt>token-string<ept id=\"p1\">*</ept>.","pos":[4506,4579],"source":" A given formal parameter may appear more than one time in *token-string*."},{"content":"If that formal parameter is replaced by an expression with side effects, the expression, with its side effects, may be evaluated more than one time.","pos":[4580,4728]},{"content":"(See the examples under <bpt id=\"p1\">[</bpt>Token-Pasting Operator (##)<ept id=\"p1\">](../preprocessor/token-pasting-operator-hash-hash.md)</ept>.)","pos":[4729,4837],"source":" (See the examples under [Token-Pasting Operator (##)](../preprocessor/token-pasting-operator-hash-hash.md).)"},{"content":"The <ph id=\"ph1\">`#undef`</ph> directive causes an identifier's preprocessor definition to be forgotten.","pos":[4844,4930],"source":"The `#undef` directive causes an identifier's preprocessor definition to be forgotten."},{"content":"See <bpt id=\"p1\">[</bpt>The #undef Directive<ept id=\"p1\">](../preprocessor/hash-undef-directive-c-cpp.md)</ept> for more information.","pos":[4931,5026],"source":" See [The #undef Directive](../preprocessor/hash-undef-directive-c-cpp.md) for more information."},{"pos":[5033,5163],"content":"If the name of the macro being defined occurs in <bpt id=\"p1\">*</bpt>token-string<ept id=\"p1\">*</ept> (even as a result of another macro expansion), it is not expanded.","source":"If the name of the macro being defined occurs in *token-string* (even as a result of another macro expansion), it is not expanded."},{"pos":[5170,5299],"content":"A second <ph id=\"ph1\">`#define`</ph> for a macro with the same name generates a warning unless the second token sequence is identical to the first.","source":"A second `#define` for a macro with the same name generates a warning unless the second token sequence is identical to the first."},{"content":"Microsoft Specific","pos":[5308,5326]},{"content":"Microsoft C/C++ lets you redefine a macro if the new definition is syntactically identical to the original definition.","pos":[5335,5453]},{"content":"In other words, the two definitions can have different parameter names.","pos":[5454,5525]},{"content":"This behavior differs from <ph id=\"ph1\">[!INCLUDE[vcpransi](../atl-mfc-shared/reference/includes/vcpransi_md.md)]</ph> C, which requires that the two definitions be lexically identical.","pos":[5526,5693],"source":" This behavior differs from [!INCLUDE[vcpransi](../atl-mfc-shared/reference/includes/vcpransi_md.md)] C, which requires that the two definitions be lexically identical."},{"content":"For example, the following two macros are identical except for the parameter names.","pos":[5700,5783]},{"content":"C does not allow such a redefinition, but Microsoft C/C++ compiles it without error.","pos":[5858,5942]},{"content":"On the other hand, the following two macros are not identical and will generate a warning in Microsoft C/C++.","pos":[6046,6155]},{"content":"END Microsoft Specific","pos":[6261,6283]},{"pos":[6292,6341],"content":"This example illustrates the <ph id=\"ph1\">`#define`</ph> directive:","source":"This example illustrates the `#define` directive:"},{"content":"The first statement defines the identifier <ph id=\"ph1\">`WIDTH`</ph> as the integer constant 80 and defines <ph id=\"ph2\">`LENGTH`</ph> in terms of <ph id=\"ph3\">`WIDTH`</ph> and the integer constant 10.","pos":[6425,6572],"source":"The first statement defines the identifier `WIDTH` as the integer constant 80 and defines `LENGTH` in terms of `WIDTH` and the integer constant 10."},{"content":"Each occurrence of <ph id=\"ph1\">`LENGTH`</ph> is replaced by (<ph id=\"ph2\">`WIDTH + 10`</ph>).","pos":[6573,6631],"source":" Each occurrence of `LENGTH` is replaced by (`WIDTH + 10`)."},{"content":"In turn, each occurrence of <ph id=\"ph1\">`WIDTH + 10`</ph> is replaced by the expression (<ph id=\"ph2\">`80 + 10`</ph>).","pos":[6632,6715],"source":" In turn, each occurrence of `WIDTH + 10` is replaced by the expression (`80 + 10`)."},{"content":"The parentheses around <ph id=\"ph1\">`WIDTH + 10`</ph> are important because they control the interpretation in statements such as the following:","pos":[6716,6842],"source":" The parentheses around `WIDTH + 10` are important because they control the interpretation in statements such as the following:"},{"content":"After the preprocessing stage the statement becomes:","pos":[6885,6937]},{"content":"which evaluates to 1800.","pos":[6985,7009]},{"content":"Without parentheses, the result is:","pos":[7010,7045]},{"content":"which evaluates to 280.","pos":[7089,7112]},{"content":"Microsoft Specific","pos":[7121,7139]},{"content":"Defining macros and constants with the <bpt id=\"p1\">[</bpt>/D<ept id=\"p1\">](../build/reference/d-preprocessor-definitions.md)</ept> compiler option has the same effect as using a <ph id=\"ph1\">`#define`</ph> preprocessing directive at the start of your file.","pos":[7148,7349],"source":"Defining macros and constants with the [/D](../build/reference/d-preprocessor-definitions.md) compiler option has the same effect as using a `#define` preprocessing directive at the start of your file."},{"content":"Up to 30 macros can be defined by using the /D option.","pos":[7350,7404]},{"content":"END Microsoft Specific","pos":[7413,7435]},{"content":"See Also","pos":[7446,7454]},{"content":"Preprocessor Directives","pos":[7459,7482]}],"content":"---\ntitle: \"#define Directive (C-C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"#define\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"define directive (#define), syntax\"\n  - \"preprocessor, directives\"\n  - \"define directive (#define)\"\n  - \"#define directive, syntax\"\n  - \"#define directive\"\nms.assetid: 33cf25c6-b24e-40bf-ab30-9008f0391710\ncaps.latest.revision: 13\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# #define Directive (C/C++)\nThe `#define` creates a *macro*, which is the association of an identifier or parameterized identifier with a token string. After the macro is defined, the compiler can substitute the token string for each occurrence of the identifier in the source file.  \n  \n## Syntax  \n `#define` *identifier* *token-string*opt  \n  \n `#define` *identifier* `(` *identifier*opt`,`*...*`,`*identifier*opt`)`*token-string*opt  \n  \n## Remarks  \n The `#define` directive causes the compiler to substitute *token-string* for each occurrence of *identifier* in the source file. The *identifier* is replaced only when it forms a token. That is, *identifier* is not replaced if it appears in a comment, in a string, or as part of a longer identifier. For more information, see [Tokens](../cpp/tokens-cpp.md).  \n  \n The *token-string* argument consists of a series of tokens, such as keywords, constants, or complete statements. One or more white-space characters must separate *token-string* from *identifier*. This white space is not considered part of the substituted text, nor is any white space that follows the last token of the text.  \n  \n A `#define` without a *token-string* removes occurrences of *identifier* from the source file. The *identifier* remains defined and can be tested by using the `#if defined` and `#ifdef` directives.  \n  \n The second syntax form defines a function-like macro with parameters. This form accepts an optional list of parameters that must appear in parentheses. After the macro is defined, each subsequent occurrence of *identifier*( *identifier*opt, ..., *identifier*opt ) is replaced with a version of the *token-string* argument that has actual arguments substituted for formal parameters.  \n  \n Formal parameter names appear in *token-string* to mark the locations where actual values are substituted. Each parameter name can appear multiple times in *token-string*, and the names can appear in any order. The number of arguments in the call must match the number of parameters in the macro definition. Liberal use of parentheses guarantees that complex actual arguments are interpreted correctly.  \n  \n The formal parameters in the list are separated by commas. Each name in the list must be unique, and the list must be enclosed in parentheses. No spaces can separate *identifier* and the opening parenthesis. Use line concatenation — place a backslash (`\\`) immediately before the newline character — for long directives on multiple source lines. The scope of a formal parameter name extends to the new line that ends *token-string*.  \n  \n When a macro has been defined in the second syntax form, subsequent textual instances followed by an argument list indicate a macro call. The actual arguments that follows an instance of *identifier* in the source file are matched to the corresponding formal parameters in the macro definition. Each formal parameter in *token-string* that is not preceded by a stringizing (`#`), charizing (`#@`), or token-pasting (`##`) operator, or not followed by a `##` operator, is replaced by the corresponding actual argument. Any macros in the actual argument are expanded before the directive replaces the formal parameter. (The operators are described in [Preprocessor Operators](../preprocessor/preprocessor-operators.md).)  \n  \n The following examples of macros with arguments illustrate the second form of the `#define` syntax:  \n  \n```  \n// Macro to define cursor lines   \n#define CURSOR(top, bottom) (((top) << 8) | (bottom))  \n  \n// Macro to get a random integer with a specified range   \n#define getrandom(min, max) \\  \n    ((rand()%(int)(((max) + 1)-(min)))+ (min))  \n```  \n  \n Arguments with side effects sometimes cause macros to produce unexpected results. A given formal parameter may appear more than one time in *token-string*. If that formal parameter is replaced by an expression with side effects, the expression, with its side effects, may be evaluated more than one time. (See the examples under [Token-Pasting Operator (##)](../preprocessor/token-pasting-operator-hash-hash.md).)  \n  \n The `#undef` directive causes an identifier's preprocessor definition to be forgotten. See [The #undef Directive](../preprocessor/hash-undef-directive-c-cpp.md) for more information.  \n  \n If the name of the macro being defined occurs in *token-string* (even as a result of another macro expansion), it is not expanded.  \n  \n A second `#define` for a macro with the same name generates a warning unless the second token sequence is identical to the first.  \n  \n **Microsoft Specific**  \n  \n Microsoft C/C++ lets you redefine a macro if the new definition is syntactically identical to the original definition. In other words, the two definitions can have different parameter names. This behavior differs from [!INCLUDE[vcpransi](../atl-mfc-shared/reference/includes/vcpransi_md.md)] C, which requires that the two definitions be lexically identical.  \n  \n For example, the following two macros are identical except for the parameter names. [!INCLUDE[vcpransi](../atl-mfc-shared/reference/includes/vcpransi_md.md)] C does not allow such a redefinition, but Microsoft C/C++ compiles it without error.  \n  \n```  \n#define multiply( f1, f2 ) ( f1 * f2 )  \n#define multiply( a1, a2 ) ( a1 * a2 )  \n```  \n  \n On the other hand, the following two macros are not identical and will generate a warning in Microsoft C/C++.  \n  \n```  \n#define multiply( f1, f2 ) ( f1 * f2 )  \n#define multiply( a1, a2 ) ( b1 * b2 )  \n```  \n  \n **END Microsoft Specific**  \n  \n This example illustrates the `#define` directive:  \n  \n```  \n#define WIDTH       80  \n#define LENGTH      ( WIDTH + 10 )  \n```  \n  \n The first statement defines the identifier `WIDTH` as the integer constant 80 and defines `LENGTH` in terms of `WIDTH` and the integer constant 10. Each occurrence of `LENGTH` is replaced by (`WIDTH + 10`). In turn, each occurrence of `WIDTH + 10` is replaced by the expression (`80 + 10`). The parentheses around `WIDTH + 10` are important because they control the interpretation in statements such as the following:  \n  \n```  \nvar = LENGTH * 20;  \n```  \n  \n After the preprocessing stage the statement becomes:  \n  \n```  \nvar = ( 80 + 10 ) * 20;  \n```  \n  \n which evaluates to 1800. Without parentheses, the result is:  \n  \n```  \nvar = 80 + 10 * 20;  \n```  \n  \n which evaluates to 280.  \n  \n **Microsoft Specific**  \n  \n Defining macros and constants with the [/D](../build/reference/d-preprocessor-definitions.md) compiler option has the same effect as using a `#define` preprocessing directive at the start of your file. Up to 30 macros can be defined by using the /D option.  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [Preprocessor Directives](../preprocessor/preprocessor-directives.md)"}