{"nodes":[{"pos":[12,61],"content":"__popcnt16, __popcnt, __popcnt64 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"__popcnt16, __popcnt, __popcnt64 | Microsoft Docs","pos":[0,49]}]},{"content":"__popcnt16, __popcnt, __popcnt64","pos":[727,759]},{"content":"Microsoft Specific","pos":[762,780]},{"content":"Counts the number of one bits (population count) in a 16-, 32-, or 64-byte unsigned integer.","pos":[789,881]},{"content":"Syntax","pos":[890,896]},{"content":"Parameters","pos":[1100,1110]},{"content":"[in]","pos":[1114,1118]},{"content":"The 16-, 32-, or 64-bit unsigned integer for which we want the population count.","pos":[1130,1210]},{"content":"Return Value","pos":[1219,1231]},{"pos":[1235,1283],"content":"The number of one bits in the <ph id=\"ph1\">`value`</ph> parameter.","source":"The number of one bits in the `value` parameter."},{"content":"Requirements","pos":[1292,1304]},{"content":"Intrinsic","pos":[1311,1320]},{"content":"Architecture","pos":[1321,1333]},{"content":"Advanced Bit Manipulation","pos":[1390,1415]},{"content":"Advanced Bit Manipulation","pos":[1431,1456]},{"content":"Advanced Bit Manipulation in 64-bit mode.","pos":[1474,1515]},{"pos":[1523,1550],"content":"<bpt id=\"p1\">**</bpt>Header file<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>intrin.h&gt;","source":"**Header file** \\<intrin.h>"},{"content":"Remarks","pos":[1559,1566]},{"content":"Each of these intrinsics generates the <ph id=\"ph1\">`popcnt`</ph> instruction.","pos":[1570,1630],"source":"Each of these intrinsics generates the `popcnt` instruction."},{"content":"The size of the value that the <ph id=\"ph1\">`popcnt`</ph> instruction returns is the same as the size of its argument.","pos":[1632,1732],"source":"  The size of the value that the `popcnt` instruction returns is the same as the size of its argument."},{"content":"In 32-bit mode there are no 64-bit general-purpose registers, hence no 64-bit <ph id=\"ph1\">`popcnt`</ph>.","pos":[1734,1821],"source":"  In 32-bit mode there are no 64-bit general-purpose registers, hence no 64-bit `popcnt`."},{"content":"To determine hardware support for the <ph id=\"ph1\">`popcnt`</ph> instruction, call the <ph id=\"ph2\">`__cpuid`</ph> intrinsic with <ph id=\"ph3\">`InfoType=0x00000001`</ph> and check bit 23 of <ph id=\"ph4\">`CPUInfo[2] (ECX)`</ph>.","pos":[1828,1983],"source":"To determine hardware support for the `popcnt` instruction, call the `__cpuid` intrinsic with `InfoType=0x00000001` and check bit 23 of `CPUInfo[2] (ECX)`."},{"content":"This bit is 1 if the instruction is supported, and 0 otherwise.","pos":[1984,2047]},{"content":"If you run code that uses this intrinsic on hardware that does not support the <ph id=\"ph1\">`popcnt`</ph> instruction, the results are unpredictable.","pos":[2048,2179],"source":" If you run code that uses this intrinsic on hardware that does not support the `popcnt` instruction, the results are unpredictable."},{"content":"Example","pos":[2188,2195]},{"content":"END Microsoft Specific","pos":[2948,2970]},{"content":"Copyright 2007 by Advanced Micro Devices, Inc. All rights reserved.","pos":[2974,3041]},{"content":"Reproduced with permission from Advanced Micro Devices, Inc.","pos":[3042,3102]},{"content":"See Also","pos":[3111,3119]},{"content":"Compiler Intrinsics","pos":[3124,3143]}],"content":"---\ntitle: \"__popcnt16, __popcnt, __popcnt64 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"__popcnt64\"\n  - \"__popcnt\"\n  - \"__popcnt16\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"popcnt instruction\"\n  - \"__popcnt16\"\n  - \"__popcnt64\"\n  - \"__popcnt\"\nms.assetid: e525b236-adc8-42df-9b9b-8b7d8c245d3b\ncaps.latest.revision: 15\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# __popcnt16, __popcnt, __popcnt64\n**Microsoft Specific**  \n  \n Counts the number of one bits (population count) in a 16-, 32-, or 64-byte unsigned integer.  \n  \n## Syntax  \n  \n```  \nunsigned short __popcnt16(  \n   unsigned short value  \n);  \nunsigned int __popcnt(  \n   unsigned int value  \n);  \nunsigned __int64 __popcnt64(  \n   unsigned __int64 value  \n);  \n```  \n  \n#### Parameters  \n [in] `value`  \n The 16-, 32-, or 64-bit unsigned integer for which we want the population count.  \n  \n## Return Value  \n The number of one bits in the `value` parameter.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|  \n|---------------|------------------|  \n|`__popcnt16`|Advanced Bit Manipulation|  \n|`__popcnt`|Advanced Bit Manipulation|  \n|`__popcnt64`|Advanced Bit Manipulation in 64-bit mode.|  \n  \n **Header file** \\<intrin.h>  \n  \n## Remarks  \n Each of these intrinsics generates the `popcnt` instruction.  The size of the value that the `popcnt` instruction returns is the same as the size of its argument.  In 32-bit mode there are no 64-bit general-purpose registers, hence no 64-bit `popcnt`.  \n  \n To determine hardware support for the `popcnt` instruction, call the `__cpuid` intrinsic with `InfoType=0x00000001` and check bit 23 of `CPUInfo[2] (ECX)`. This bit is 1 if the instruction is supported, and 0 otherwise. If you run code that uses this intrinsic on hardware that does not support the `popcnt` instruction, the results are unpredictable.  \n  \n## Example  \n  \n```  \n#include <iostream>   \n#include <intrin.h>   \nusing namespace std;   \n  \nint main()   \n{  \n  unsigned short us[3] = {0, 0xFF, 0xFFFF};  \n  unsigned short usr;  \n  unsigned int   ui[4] = {0, 0xFF, 0xFFFF, 0xFFFFFFFF};  \n  unsigned int   uir;  \n  \n  for (int i=0; i<3; i++) {  \n    usr = __popcnt16(us[i]);  \n    cout << \"__popcnt16(0x\" << hex << us[i] << \") = \" << dec << usr << endl;  \n  }  \n  \n  for (int i=0; i<4; i++) {  \n    uir = __popcnt(ui[i]);  \n    cout << \"__popcnt(0x\" << hex << ui[i] << \") = \" << dec << uir << endl;  \n  }  \n}  \n  \n```  \n  \n```Output  \n__popcnt16(0x0) = 0  \n__popcnt16(0xff) = 8  \n__popcnt16(0xffff) = 16  \n__popcnt(0x0) = 0  \n__popcnt(0xff) = 8  \n__oopcnt(0xffff) = 16  \n__popcnt(0xffffffff) = 32  \n```  \n  \n## END Microsoft Specific  \n Copyright 2007 by Advanced Micro Devices, Inc. All rights reserved. Reproduced with permission from Advanced Micro Devices, Inc.  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)"}