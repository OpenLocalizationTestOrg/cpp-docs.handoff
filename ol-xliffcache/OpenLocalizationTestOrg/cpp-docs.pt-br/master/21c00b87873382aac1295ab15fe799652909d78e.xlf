<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">21c00b87873382aac1295ab15fe799652909d78e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\dotnet\initialization-of-mixed-assemblies.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9c18b41377f2c7f69aec83d7fb7a18bf3230b8b1</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">62559f36c31e4a4e218f3a07e33c14d6336decfb</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Initialization of Mixed Assemblies | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Initialization of Mixed Assemblies</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>In Visual C++ .NET and Visual C++ 2003, DLLs compiled with the <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> compiler option could non-deterministically deadlock when loaded; this issue was called the mixed DLL loading or loader lock issue.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Almost all non-determinism has been removed from the mixed DLL loading process.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>However, there are a few remaining scenarios for which loader lock can (deterministically) occur.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For more information about this issue, see "Mixed DLL Loading Problem" in the <bpt id="p1">[</bpt>MSDN Library<ept id="p1">](http://go.microsoft.com/fwlink/?linkid=556)</ept>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Code within <bpt id="p1">[</bpt>DllMain<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682583)</ept> must not access the CLR.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This means that <ph id="ph1">`DllMain`</ph> should make no calls to managed functions, directly or indirectly; no managed code should be declared or implemented in <ph id="ph2">`DllMain`</ph>; and no garbage collection or automatic library loading should take place within <ph id="ph3">`DllMain`</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Visual C++ 2003 provided _vcclrit.h to facilitate DLL initialization while minimizing opportunity for deadlock.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Using _vcclrit.h is no longer necessary, and causes deprecation warnings to be produced during compilation.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The recommended strategy is to remove dependencies on this file using the steps in <bpt id="p1">[</bpt>Removing Deprecated Header File _vcclrit.h<ept id="p1">](http://msdn.microsoft.com/en-us/7881993e-431d-43e9-8c6d-0d2285a4882d)</ept>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Less ideal solutions include suppressing the warnings by defining <ph id="ph1">`_CRT_VCCLRIT_NO_DEPRECATE`</ph> prior to including _vcclrit.h, or merely ignoring the deprecation warnings.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Causes of Loader Lock</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>With the introduction of the .NET platform there are two distinct mechanisms for loading an execution module (EXE or DLL): one for Windows, which is used for unmanaged modules, and one for the .NET Common Language Runtime (CLR) which loads .NET assemblies.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The mixed DLL loading problem centers around the Microsoft Windows OS loader.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>When an assembly containing only .NET constructs is loaded into a process, the CLR loader can perform all of the necessary loading and initialization tasks itself.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>However, for mixed assemblies, because they can contain native code and data, the Windows loader must be used as well.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The Windows loader guarantees that no code can access code or data in that DLL before it has been initialized, and that no code can redundantly load the DLL while it is partially initialized.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To do this, the Windows loader uses a process-global critical section (often called the "loader lock") that prevents unsafe access during module initialization.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>As a result, the loading process is vulnerable to many classic deadlock scenarios.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For mixed assemblies, the following two scenarios increase the risk of deadlock:</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>First, if users attempt to execute functions compiled to Microsoft intermediate language (MSIL) when the loader lock is held (from <ph id="ph1">`DllMain`</ph> or in static initializers, for example), this can cause deadlock.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consider the case in which the MSIL function references a type in an assembly that has not been loaded.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The CLR will attempt to automatically load that assembly, which may require the Windows loader to block on the loader lock.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Since the loader lock is already held by code earlier in the call sequence, a deadlock results.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>However, executing MSIL under loader lock does not guarantee that a deadlock will occur, making this scenario difficult to diagnose and fix.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In some circumstances, such as where the DLL of the referenced type contains no native constructs and all of its dependencies contain no native constructs, the Windows loader is not required to load the .NET assembly of the referenced type.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Additionally, the required assembly or its mixed native/.NET dependencies may have already been loaded by other code.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Consequently, the deadlocking can be difficult to predict, and can vary depending on the configuration of the target machine.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Second, when loading DLLs in versions 1.0 and 1.1 of the .NET Framework, the CLR assumed that the loader lock was not held and performed several actions that are invalid under loader lock.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Assuming the loader lock is not held is a valid assumption for purely .NET DLLs, but, because mixed DLLs execute native initialization routines, they require the native Windows loader and therefore the loader lock.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Consequently, even if the developer was not attempting to execute any MSIL functions during DLL initialization, there was still a small possibility of nondeterministic deadlock with versions 1.0 and 1.1 of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>All non-determinism has been removed from the mixed DLL loading process.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This was accomplished with these changes:</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The CLR no longer makes false assumptions when loading mixed DLLs.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Unmanaged and managed initialization is performed in two separate and distinct stages.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Unmanaged initialization takes place first (via DllMain), and managed initialization takes place afterwards, through a .NET-supported construct called a <bpt id="p1">*</bpt>.cctor<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The latter is completely transparent to the user unless <bpt id="p1">**</bpt>/Zl<ept id="p1">**</ept> or <bpt id="p2">**</bpt>/NODEFAULTLIB<ept id="p2">**</ept> are used.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>See<bpt id="p1">[</bpt>/NODEFAULTLIB (Ignore Libraries)<ept id="p1">](../build/reference/nodefaultlib-ignore-libraries.md)</ept> and <bpt id="p2">[</bpt>/Zl (Omit Default Library Name)<ept id="p2">](../build/reference/zl-omit-default-library-name.md)</ept> for more information.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Loader lock can still occur, but now it occurs reproducibly, and is detected.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If DllMain contains MSIL instructions, the compiler will generate warning <bpt id="p1">[</bpt>Compiler Warning (level 1) C4747<ept id="p1">](../error-messages/compiler-warnings/compiler-warning-level-1-c4747.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Furthermore, either the CRT or the CLR will try to detect and report attempts to execute MSIL under loader lock.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>CRT detection results in runtime diagnostic C Run-Time Error R6033.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The remainder of this document describes the remaining scenarios for which MSIL can execute under the loader lock, resolutions for the issue under each of those scenarios, and debugging techniques.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Scenarios and Workarounds</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>There are several different situations under which user code can execute MSIL under loader lock.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The developer must ensure that the user code implementation does not attempt to execute MSIL instructions under each of these circumstances.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The following subsections describe all possibilities with a discussion of how to resolve issues in the most common cases.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Static Initializers</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>User-Supplied Functions Affecting Startup</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Custom Locales</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>DllMain</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`DllMain`</ph> function is a user defined entry point for a DLL.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Unless the user specifies otherwise, <ph id="ph1">`DllMain`</ph> is invoked every time a process or thread attaches to or detaches from the containing DLL.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Since this invocation can occur while the loader lock is held, no user-supplied <ph id="ph1">`DllMain`</ph> function should be compiled to MSIL.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Furthermore, no function in the call tree rooted at <ph id="ph1">`DllMain`</ph> can be compiled to MSIL.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To resolve issues here, the code block that defines <ph id="ph1">`DllMain`</ph> should be modified with #pragma <ph id="ph2">`unmanaged`</ph>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The same should be done for every function that <ph id="ph1">`DllMain`</ph> calls.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In cases where these functions must call a function that requires an MSIL implementation for other calling contexts, a duplication strategy can be used where both a .NET and a native version of the same function are created.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Alternatively, if <ph id="ph1">`DllMain`</ph> is not required or if it does not need to be executed under loader lock, the user-provided <ph id="ph2">`DllMain`</ph> implementation can be removed, which will eliminate the problem.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If DllMain attempts to execute MSIL directly, <bpt id="p1">[</bpt>Compiler Warning (level 1) C4747<ept id="p1">](../error-messages/compiler-warnings/compiler-warning-level-1-c4747.md)</ept> will result.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>However, the compiler cannot detect cases where DllMain calls a function in another module that in turn attempts to execute MSIL.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Please see "Impediments to Diagnosis" for more information on this scenario.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Initializing Static Objects</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Initializing static objects can result in deadlock if a dynamic initializer is required.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For simple cases, such as when a static variable is simply assigned to a value known at compile time, no dynamic initialization is required, so there is no risk of deadlock.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>However, static variables initialized by function calls, constructor invocations, or expressions that cannot be evaluated at compile time all require code to execute during module initialization.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The code below shows examples of static initializers that require dynamic initialization: a function call, object construction, and a pointer initialization.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>(These examples aren't static, but are assumed to be defined in the global scope, which has the same effect.)</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>This risk of deadlock depends on whether the containing module is compiled with <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> and whether MSIL will be executed.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Specifically, if the static variable is compiled without <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> (or resides in a #pragma <ph id="ph1">`unmanaged`</ph> block), and the dynamic initializer required to initialize it results in the execution of MSIL instructions, deadlock may occur.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This is because, for modules compiled without <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept>, the initialization of static variables is performed by DllMain.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In contrast, static variables compiled with <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> are initialized by the .cctor, after the unmanaged initialization stage has completed and the loader lock has been released.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>There are a number of solutions to deadlock caused by the dynamic initialization of static variables (arranged roughly in order of time required to fix the problem):</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The source file containing the static variable can be compiled with <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>All functions called by the static variable can be compiled to native code using the #pragma <ph id="ph1">`unmanaged`</ph> directive.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Manually clone the code that the static variable depends upon, providing both a .NET and a native version with different names.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Developers can then call the native version from native static initializers and call the .NET version elsewhere.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>User-Supplied Functions Affecting Startup</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>There are several user-supplied functions on which libraries depend for initialization during startup.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For example, when globally overloading operators in C++ such as the <ph id="ph1">`new`</ph> and <ph id="ph2">`delete`</ph> operators, the user-provided versions are used everywhere, including in STL initialization and destruction.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>As a result, STL and user-provided static initializers will invoke any user-provided versions of these operators.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If the user-provided versions are compiled to MSIL, then these initializers will be attempting to execute MSIL instructions while the loader lock is held.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>A user-supplied malloc has the same consequences.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>To resolve this problem, any of these overloads or user-supplied definitions must be implemented as native code using the #pragma <ph id="ph1">`unmanaged`</ph> directive.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Please see "Impediments to Diagnosis" for more information on this scenario.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Custom Locales</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If the user provides a custom global locale, this locale will be used for initializing all future I/O streams, including those that are statically initialized.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If this global locale object is compiled to MSIL, then locale-object member functions compiled to MSIL may be invoked while the loader lock is held.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>There are three options for solving this problem:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The source files containing all global I/O stream definitions can be compiled using the <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> option.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>This will prevent their static initializers from being executed under loader lock.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The custom locale function definitions can be compiled to native code by using the #pragma <ph id="ph1">`unmanaged`</ph> directive.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Refrain from setting the custom locale as the global locale until after the loader lock is released.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Then explicitly configure I/O streams created during initialization with the custom locale.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Impediments to Diagnosis</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>In some cases it is difficult to detect the source of deadlocks.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The following subsections discuss these scenarios and ways to work around these issues.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Implementation in Headers</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>In select cases, function implementations inside header files can complicate diagnosis.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Inline functions and template code both require that functions be specified in a header file.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The C++ language specifies the One Definition Rule, which forces all implementations of functions with the same name to be semantically equivalent.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Consequently, the C++ linker need not make any special considerations when merging object files that have duplicate implementations of a given function.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In Visual C++ .NET and Visual C++ .NET 2003, the linker simply chooses the largest of these semantically equivalent definitions, to accommodate forward declarations and scenarios when different optimization options are used for different source files.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>This creates a problem for mixed native/.NET DLLs.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Because the same header may be included both by a CPP files with <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> enabled and disabled, or a #include can be wrapped inside a #pragma <ph id="ph1">`unmanaged`</ph> block, it is possible to have both MSIL and native versions of functions that provide implementations in headers.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>MSIL and native implementations have different semantics with respect to initialization under the loader lock, which effectively violates the one definition rule.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Consequently, when the linker chooses the largest implementation, it may choose the MSIL version of a function, even if it was explicitly compiled to native code elsewhere using the #pragma unmanaged directive.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>To ensure that an MSIL version of a template or inline function is never called under loader lock, every definition of every such function called under loader lock must be modified with the #pragma <ph id="ph1">`unmanaged`</ph> directive.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>If the header file is from a third party, the easiest way to achieve this is to push and pop the #pragma unmanaged directive around the #include directive for the offending header file.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>managed, unmanaged<ept id="p1">](../preprocessor/managed-unmanaged.md)</ept> for an example.) However, this strategy will not work for headers that contain other code that must directly call .NET APIs.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>As a convenience for users dealing with loader lock, the linker will choose the native implementation over the managed when presented with both.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>This avoids the above issues.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>However, there are two exceptions to this rule in this release due to two unresolved issues with the compiler:</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The call is to an inline function is through a global static function pointer.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This scenario is particularly notable because virtual functions are called through global function pointers.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For example,</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>With Itanium-targeted compilation, there is a bug in the implementation of all function pointers.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In the preceding example, if myObject_p were defined locally inside during_loaderlock(), the call might also resolve to a managed implementation.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Diagnosing in Debug Mode</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>All diagnoses of loader lock problems should be done with Debug builds.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Release builds may not produce diagnostics, and the optimizations performed in Release mode may mask some of the MSIL under loader lock scenarios.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>How to Debug Loader Lock Issues</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The diagnostic that the CLR generates when an MSIL function is invoked causes the CLR to suspend execution.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>In turn, this causes the Visual C++ mixed-mode debugger to be suspended as well when running the debuggee in-process.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>However, when attaching to the process, it is not possible to obtain a managed callstack for the debuggee using the mixed debugger.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>To identify the specific MSIL function that was called under loader lock, developers should complete the following steps:</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Ensure that symbols for mscoree.dll and mscorwks.dll are available.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>This can be done in two ways.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>First, the PDBs for mscoree.dll and mscorwks.dll can be added to the symbol search path.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>To do this, open the symbol search path options dialog.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>(From the Tools menu, click Options.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>In the left pane of the Options dialog box, Open the Debugging node and click Symbols.) Add the path to the mscoree.dll and mscorwks.dll PDB files to the search list.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>These PDBs are installed to the %VSINSTALLDIR%\SDK\v2.0\symbols.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Click OK.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Second, the PDBs for mscoree.dll and mscorwks.dll can be downloaded from the Microsoft Symbol Server.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>To configure Symbol Server, open the symbol search path options dialog.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>(From the Tools menu, click Options.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>In the left pane of the Options dialog box, Open the Debugging node and click Symbols.) Add the following search path to the search list: http://msdl.microsoft.com/download/symbols.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Add a symbol cache directory to the symbol server cache text box.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Click OK.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Set debugger mode to native-only mode.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>To do this, open the Properties grid for the startup project in the solution.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Under the Configuration Properties subtree, select the Debugging Node.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Set the Debugger Type Field to Native-Only.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Start the Debugger (F5).</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>When the <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> diagnostic is generated, click Retry and then click Break.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Open the call stack window.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>(From the Debug menu, click Windows, then Call Stack.) If the offending <ph id="ph1">`DllMain`</ph> or static initializer is identified with a green arrow.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>If the offending function is not identified, the following steps must be taken to find it.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Open the immediate window (From the Debug menu, click Windows, then Immediate.)</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Type .load sos.dll into the immediate window to load the SOS debugging service.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Type !dumpstack into the immediate window to obtain a complete listing of the internal <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept> stack.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Look for the first instance (closest to the bottom of the stack) of either _CorDllMain (if <ph id="ph1">`DllMain`</ph> causes issue) or _VTableBootstrapThunkInitHelperStub or GetTargetForVTableEntry (if static initializer causes issue).</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The stack entry just below this call is the invocation of the MSIL implemented function that attempted to execute under loader lock.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Go to the source file and line number identified in Step 9 and correct the problem using the scenarios and solutions described in the Scenarios section.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The following sample shows how to avoid loader lock by moving code from DllMain into the constructor of a global object.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>In this sample, there is a global managed object whose constructor contains the managed object that was originally in DllMain.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The second part of this sample references the assembly, creating an instance of the managed object to invoke the module constructor which does the initialization.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Code</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Code</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Mixed (Native and Managed) Assemblies</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>