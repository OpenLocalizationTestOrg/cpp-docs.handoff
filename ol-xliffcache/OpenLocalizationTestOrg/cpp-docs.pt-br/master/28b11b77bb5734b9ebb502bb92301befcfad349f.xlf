<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">28b11b77bb5734b9ebb502bb92301befcfad349f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\build\arm-exception-handling.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5587ba470e4fdedff4e404620e12a5b45adb6d5d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ced04941b48e303c690b644033ab9f56dbe39db3</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>ARM Exception Handling | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>ARM Exception Handling</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Windows on ARM uses the same structured exception handling mechanism for asynchronous hardware-generated exceptions and synchronous software-generated exceptions.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Language-specific exception handlers are built on top of Windows structured exception handling by using language helper functions.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This document describes exception handling in Windows on ARM, and the language helpers used by code that's generated by MASM and the Visual C++ compiler.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>ARM Exception Handling</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Windows on ARM uses <bpt id="p1">*</bpt>unwind codes<ept id="p1">*</ept> to control stack unwinding during <bpt id="p2">[</bpt>structured exception handling<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms680657)</ept> (SEH).</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Unwind codes are a sequence of bytes stored in the .xdata section of the executable image.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>They describe the operation of function prologue and epilogue code in an abstract way, so that the effects of a function’s prologue can be undone in preparation for unwinding to the caller’s stack frame.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The ARM EABI (embedded application binary interface) specifies an exception unwinding model that uses unwind codes, but it's not sufficient for SEH unwinding in Windows, which must handle asynchronous cases where the processor is in the middle of the prologue or epilogue of a function.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Windows also separates unwinding control into function-level unwinding and language-specific scope unwinding, which is unified in the ARM EABI.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For these reasons, Windows on ARM specifies more details for the unwinding data and procedure.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Assumptions</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Executable images for Windows on ARM use the Portable Executable (PE) format.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Microsoft PE and COFF Specification<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=84140)</ept>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Exception handling information is stored in the .pdata and .xdata sections of the image.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The exception handling mechanism makes certain assumptions about code that follows the ABI for Windows on ARM:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>When an exception occurs within the body of a function, it does not matter whether the prologue’s operations are undone, or the epilogue’s operations are performed in a forward manner.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Both should produce identical results.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Prologues and epilogues tend to mirror each other.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This can be used to reduce the size of the metadata needed to describe unwinding.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Functions tend to be relatively small.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Several optimizations rely on this for efficient packing of data.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If a condition is placed on an epilogue, it applies equally to each instruction in the epilogue.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If the stack pointer (SP) is saved in another register in the prologue, that register must remain unchanged throughout the function, so that the original SP may be recovered at any time.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Unless the SP is saved in another register, all manipulation of it must occur strictly within the prologue and epilogue.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To unwind any stack frame, these operations are required:</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Adjust r13 (SP) in 4-byte increments.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Pop one or more integer registers.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Pop one or more VFP (virtual floating-point) registers.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Copy an arbitrary register value to r13 (SP).</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Load SP from the stack by using a small post-decrement operation.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Parse one of a few well-defined frame types.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>.pdata Records</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The .pdata records in a PE-format image are an ordered array of fixed-length items that describe every stack-manipulating function.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Leaf functions, which are functions that do not call other functions, don't require .pdata records when they don't manipulate the stack.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>(That is, they don't require any local storage and don't have to save or restore non-volatile registers.).</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Records for these functions can be omitted from the .pdata section to save space.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>An unwind operation from one of these functions can just copy the return address from the Link Register (LR) to the program counter (PC) to move up to the caller.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Every .pdata record for ARM is 8 bytes long.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The general format of a record places the relative virtual address (RVA) of the function start in the first 32-bit word, followed by a second word that contains either a pointer to a variable-length .xdata block, or a packed word that describes a canonical function unwinding sequence, as shown in this table:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Word Offset</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Bits</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Purpose</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>0-31</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>is the 32-bit RVA of the start of the function.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If the function contains thumb code, the low bit of this address must be set.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>0-1</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>is a 2-bit field that indicates how to interpret the remaining 30 bits of the second .pdata word.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Flag`</ph> is 0, then the remaining bits form an <ph id="ph2">`Exception Information RVA`</ph> (with the low two bits implicitly 0).</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Flag`</ph> is non-zero, then the remaining bits form a <ph id="ph2">`Packed Unwind Data`</ph> structure.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>2-31</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>or <ph id="ph1">`Packed Unwind Data`</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>is the address of the variable-length exception information structure, stored in the .xdata section.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This data must be 4-byte aligned.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>is a compressed description of the operations required to unwind from a function, assuming a canonical form.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In this case, no .xdata record is required.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Packed Unwind Data</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For functions whose prologues and epilogues follow the canonical form described below, packed unwind data can be used.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This eliminates the need for an .xdata record and significantly reduces the space required to provide unwind data.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The canonical prologues and epilogues are designed to meet the common requirements of a simple function that does not require an exception handler, and performs its setup and teardown operations in a standard order.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This table shows the format of a .pdata record that has packed unwind data:</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Word Offset</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Bits</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Purpose</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>0-31</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>is the 32-bit RVA of the start of the function.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If the function contains thumb code, the low bit of this address must be set.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>0-1</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>is a 2-bit field that has these meanings:</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>-   00 = packed unwind data not used; remaining bits point to .xdata record.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>-   01 = packed unwind data.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>-   10 = packed unwind data where the function is assumed to have no prologue.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This is useful for describing function fragments that are discontiguous with the start of the function.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>-   11 = reserved.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>2-12</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>is an 11-bit field that provides the length of the entire function in bytes divided by 2.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If the function is larger than 4K bytes, a full .xdata record must be used instead.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>13-14</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>is a 2-bit field that indicates how the function returns:</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>-   00 = return via pop {pc} (the <ph id="ph1">`L`</ph> flag bit must be set to 1 in this case).</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>-   01 = return by using a 16-bit branch.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>-   10 = return by using a 32-bit branch.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>-   11 = no epilogue at all.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>This is useful for describing a discontiguous function fragment that may only contain a prologue, but whose epilogue is elsewhere.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>15</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>is a 1-bit flag that indicates whether the function "homes" the integer parameter registers (r0-r3) by pushing them at the start of the function, and deallocates the 16 bytes of stack before returning.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>(0 = does not home registers, 1 = homes registers.)</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>16-18</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>is a 3-bit field that indicates the index of the last saved non-volatile register.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`R`</ph> bit is 0, then only integer registers are being saved, and are assumed to be in the range of r4-rN, where N is equal to 4 + <ph id="ph2">`Reg`</ph>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`R`</ph> bit is 1, then only floating-point registers are being saved, and are assumed to be in the range of d8-dN, where N is equal to 8 + <ph id="ph2">`Reg`</ph>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The special combination of <ph id="ph1">`R`</ph> = 1 and <ph id="ph2">`Reg`</ph> = 7 indicates that no registers are saved.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>19</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>is a 1-bit flag that indicates whether the saved non-volatile registers are integer registers (0) or floating-point registers (1).</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`R`</ph> is set to 1 and the <ph id="ph2">`Reg`</ph> field is set to 7, no non-volatile registers were pushed.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>20</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>is a 1-bit flag that indicates whether the function saves/restores LR, along with other registers indicated by the <ph id="ph1">`Reg`</ph> field.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>(0 = does not save/restore, 1 = does save/restore.)</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>21</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>is a 1-bit flag that indicates whether the function includes extra instructions to set up a frame chain for fast stack walking (1) or not (0).</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>If this bit is set, r11 is implicitly added to the list of integer non-volatile registers saved.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>(See restrictions below if the <ph id="ph1">`C`</ph> flag is used.)</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>22-31</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>is a 10-bit field that indicates the number of bytes of stack that are allocated for this function, divided by 4.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>However, only values between 0x000-0x3F3 can be directly encoded.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Functions that allocate more than 4044 bytes of stack must use a full .xdata record.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Stack Adjust`</ph> field is 0x3F4 or larger, then the low 4 bits have special meaning:</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>-   Bits 0-1 indicate the number of words of stack adjustment (1-4) minus 1.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>-   Bit 2 is set to 1 if the prologue combined this adjustment into its push operation.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>-   Bit 3 is set to 1 if the epilogue combined this adjustment into its pop operation.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Due to possible redundancies in the encodings above, these restrictions apply:</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`C`</ph> flag is set to 1:</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`L`</ph> flag must also be set to 1, because frame chaining required both r11 and LR.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>r11 must not be included in the set of registers described by <ph id="ph1">`Reg`</ph>.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>That is, if r4-r11 are pushed, <ph id="ph1">`Reg`</ph> should only describe r4-r10, because the <ph id="ph2">`C`</ph> flag implies r11.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Ret`</ph> field is set to 0, the <ph id="ph2">`L`</ph> flag must be set to 1.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Violating these restrictions causes an unsupported sequence.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>For purposes of the discussion below, two pseudo-flags are derived from <ph id="ph1">`Stack Adjust`</ph>:</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>or "prologue folding" indicates that <ph id="ph1">`Stack Adjust`</ph> is 0x3F4 or larger and bit 2 is set.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>or "epilogue folding" indicates that <ph id="ph1">`Stack Adjust`</ph> is 0x3F4 or larger and bit 3 is set.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Prologues for canonical functions may have up to 5 instructions (notice that 3a and 3b are mutually exclusive):</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Instruction</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Opcode is assumed present if:</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Size</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Opcode</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Unwind Codes</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>==1</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>04</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>2</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>==1 or <ph id="ph1">`L`</ph>==1 or <ph id="ph2">`R`</ph>==0 or PF==1</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>16/32</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>80-BF/D0-DF/EC-ED</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>3a</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>==1 and (<ph id="ph1">`L`</ph>==0 and <ph id="ph2">`R`</ph>==1 and PF==0)</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>C0-CF/FB</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>3b</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>==1 and (<ph id="ph1">`L`</ph>==1 or <ph id="ph2">`R`</ph>==0 or PF==1)</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>FC</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>4</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>==1 and <ph id="ph1">`Reg`</ph> != 7</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>E0-E7</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>5</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>!= 0 and <ph id="ph1">`PF`</ph>==0</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>16/32</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>00-7F/E8-EB</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Instruction 1 is always present if the <ph id="ph1">`H`</ph> bit is set to 1.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>To set up the frame chaining, either instruction 3a or 3b is present if the <ph id="ph1">`C`</ph> bit is set.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>It is a 16-bit <ph id="ph1">`mov`</ph> if no registers other than r11 and LR are pushed; otherwise, it is a 32-bit <ph id="ph2">`add`</ph>.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>If a non-folded adjustment is specified, instruction 5 is the explicit stack adjustment.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Instructions 2 and 4 are set based on whether a push is required.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>This table summarizes which registers are saved based on the <ph id="ph1">`C`</ph>, <ph id="ph2">`L`</ph>, <ph id="ph3">`R`</ph>, and <ph id="ph4">`PF`</ph> fields.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>In all cases, <ph id="ph1">`N`</ph> is equal to <ph id="ph2">`Reg`</ph> + 4, <ph id="ph3">`E`</ph> is equal to <ph id="ph4">`Reg`</ph> + 8, and <ph id="ph5">`S`</ph> is equal to (~<ph id="ph6">`Stack Adjust`</ph>) &amp; 3.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>C</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>L</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>R</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>PF</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Integer Registers Pushed</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>VFP Registers pushed</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>r4-r</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>none</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>r<ph id="ph1">`S`</ph>-r</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>none</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>none</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>d8-d</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>r<ph id="ph1">`S`</ph>-r3</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>d8-d</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>r4-r<ph id="ph1">`N`</ph>, LR</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>none</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>r<ph id="ph1">`S`</ph>-r<ph id="ph2">`N`</ph>, LR</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>none</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>LR</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>d8-d</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>r<ph id="ph1">`S`</ph>-r3, LR</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>d8-d</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>r4-r<ph id="ph1">`N`</ph>, r11</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>none</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>r<ph id="ph1">`S`</ph>-r<ph id="ph2">`N`</ph>, r11</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>none</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>r11</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>d8-d</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>r<ph id="ph1">`S`</ph>-r3, r11</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>d8-d</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>r4-r<ph id="ph1">`N`</ph>, r11, LR</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>none</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>r<ph id="ph1">`S`</ph>-r<ph id="ph2">`N`</ph>, r11, LR</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>none</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>r11, LR</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>d8-d</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>r<ph id="ph1">`S`</ph>-r3, r11, LR</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>d8-d</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The epilogues for canonical functions follow a similar form, but in reverse and with some additional options.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>The epilogue may be up to 5 instructions long, and its form is strictly dictated by the form of the prologue.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Instruction</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Opcode is assumed present if:</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Size</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Opcode</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>6</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>!=0 and <ph id="ph1">`EF`</ph>==0</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>16/32</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>7</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>==1 and <ph id="ph1">`Reg`</ph>!=7</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>8</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>==1 or (<ph id="ph1">`L`</ph>==1 and <ph id="ph2">`H`</ph>==0) or <ph id="ph3">`R`</ph>==0 or <ph id="ph4">`EF`</ph>==1</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>16/32</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>9a</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>==1 and <ph id="ph1">`L`</ph>==0</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>9b</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>==1 and <ph id="ph1">`L`</ph>==1</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>10a</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>==1</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>10b</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>==2</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Instruction 6 is the explicit stack adjustment if a non-folded adjustment is specified.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`PF`</ph> is independent of <ph id="ph2">`EF`</ph>, it is possible to have instruction 5 present without instruction 6, or vice-versa.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Instructions 7 and 8 use the same logic as the prologue to determine which registers are restored from the stack, but with these two changes: first, <ph id="ph1">`EF`</ph> is used in place of <ph id="ph2">`PF`</ph>; second, if <ph id="ph3">`Ret`</ph> = 0, then LR is replaced with PC in the register list and the epilogue ends immediately.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`H`</ph> is set, then either instruction 9a or 9b is present.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Instruction 9a is used when <ph id="ph1">`L`</ph> is 0, to indicate that the LR is not on the stack.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>In this case, the stack is manually adjusted and <ph id="ph1">`Ret`</ph> must be 1 or 2 to specify an explicit return.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Instruction 9b is used when <ph id="ph1">`L`</ph> is 1, to indicate an early end to the epilogue, and to return and adjust the stack at the same time.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>If the epilogue has not already ended, then either instruction 10a or 10b is present, to indicate a 16-bit or 32-bit branch, based on the value of <ph id="ph1">`Ret`</ph>.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>.xdata Records</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>When the packed unwind format is insufficient to describe the unwinding of a function, a variable-length .xdata record must be created.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>The address of this record is stored in the second word of the .pdata record.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>The format of the .xdata is a packed variable-length set of words that has four sections:</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>A 1 or 2-word header that describes the overall size of the .xdata structure and provides key function data.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>The second word is only present if the <ph id="ph1">`Epilogue Count`</ph> and <ph id="ph2">`Code Words`</ph> fields are both set to 0.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>The fields are broken out in this table:</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>Word</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Bits</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Purpose</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>0-17</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>is an 18-bit field that indicates the total length of the function in bytes, divided by 2.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>If a function is larger than 512 KB, then multiple .pdata and .xdata records must be used to describe the function.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>For details, see the Large Functions section in this document.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>18-19</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>is a 2-bit field that describes the version of the remaining xdata.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Only version 0 is currently defined; values of 1-3 are reserved.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>20</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>is a 1-bit field that indicates the presence (1) or absence (0) of exception data.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>21</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>is a 1-bit field that indicates that information that describes a single epilogue is packed into the header (1) rather than requiring additional scope words later (0).</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>22</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>is a 1-bit field that indicates that this record describes a function fragment (1) or a full function (0).</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>A fragment implies that there is no prologue and that all prologue processing should be ignored.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>23-27</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>is a 5-bit field that has two meanings, depending on the state of the <ph id="ph1">`E`</ph> bit:</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>-   If <ph id="ph1">`E`</ph> is 0, this field is a count of the total number of exception scopes described in section 3.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>If more than 31 scopes exist in the function, then this field and the <ph id="ph1">`Code Words`</ph> field must both be set to 0 to indicate that an extension word is required.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>-   If <ph id="ph1">`E`</ph> is 1, this field specifies the index of the first unwind code that describes the only epilogue.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>28-31</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>is a 4-bit field that specifies the number of 32-bit words required to contain all of the unwind codes in section 4.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>If more than 15 words are required for more than 63 unwind code bytes, this field and the <ph id="ph1">`Epilogue Count`</ph> field must both be set to 0 to indicate that an extension word is required.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>0-15</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>is a 16-bit field that provides more space for encoding an unusually large number of epilogues.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The extension word that contains this field is only present if the <ph id="ph1">`Epilogue Count`</ph> and <ph id="ph2">`Code Words`</ph> fields in the first header word are both set to 0.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>16-23</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>is an 8-bit field that provides more space for encoding an unusually large number of unwind code words.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>The extension word that contains this field is only present if the <ph id="ph1">`Epilogue Count`</ph> and <ph id="ph2">`Code Words`</ph> fields in the first header word are both set to 0.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>24-31</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>Reserved</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>After the exception data—if the <ph id="ph1">`E`</ph> bit in the header was set to 0—is a list of information about epilogue scopes, which are packed one to a word and stored in order of increasing starting offset.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Each scope contains these fields:</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>Bits</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Purpose</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>0-17</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>is an 18-bit field that describes the offset of the epilogue, in bytes divided by 2, relative to the start of the function.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>18-19</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>is a 2-bit field reserved for future expansion.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Its value must be 0.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>20-23</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>is a 4-bit field that gives the condition under which the epilogue is executed.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>For unconditional epilogues, it should be set to 0xE, which indicates "always".</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>(An epilogue must be entirely conditional or entirely unconditional, and in Thumb-2 mode, the epilogue begins with the first instruction after the IT opcode.)</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>24-31</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>is an 8-bit field that indicates the byte index of the first unwind code that describes this epilogue.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>After the list of epilogue scopes comes an array of bytes that contain unwind codes, which are described in detail in the Unwind Codes section in this article.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>This array is padded at the end to the nearest full word boundary.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>The bytes are stored in little-endian order so that they can be directly fetched in little-endian mode.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`X`</ph> field in the header is 1, the unwind code bytes are followed by the exception handler information.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>This consists of one <ph id="ph1">`Exception Handler RVA`</ph> that contains the address of the exception handler, followed immediately by the (variable-length) amount of data required by the exception handler.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>The .xdata record is designed so that it is possible to fetch the first 8 bytes and compute the full size of the record, not including the length of the variable-sized exception data that follows.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>This code snippet computes the record size:</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Athough the prologue and each epilogue has an index into the unwind codes, the table is shared between them.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>It is not uncommon that they can all share the same unwind codes.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>We recommend that compiler writers optimize for this case, because the largest index that can be specified is 255, and that limits the total number of unwind codes possible for a particular function.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Unwind Codes</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>The array of unwind codes is a pool of instruction sequences that describe exactly how to undo the effects of the prologue, in the order in which the operations must be undone.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The unwind codes are a mini instruction set, encoded as a string of bytes.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>When execution is complete, the return address to the calling function is in the LR register, and all non-volatile registers are restored to their values at the time the function was called.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>If exceptions were guaranteed to only ever occur within a function body, and never within a prologue or epilogue, then only one unwind sequence would be necessary.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>However, the Windows unwinding model requires an ability to unwind from within a partially executed prologue or epilogue.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>To accommodate this requirement, the unwind codes have been carefully designed to have an unambiguous one-to-one mapping to each relevant opcode in the prologue and epilogue.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>This has several implications:</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>It is possible to compute the length of the prologue and epilogue by counting the number of unwind codes.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>This is possible even with variable-length Thumb-2 instructions because there are distinct mappings for 16-bit and 32-bit opcodes.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>By counting the number of instructions past the start of an epilogue scope, it is possible to skip the equivalent number of unwind codes, and execute the rest of a sequence to complete the partially-executed unwind that the epilogue was performing.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>By counting the number of instructions before the end of the prologue, it is possible to skip the equivalent number of unwind codes, and execute the rest of the sequence to undo only those parts of the prologue that have completed execution.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>The following table shows the mapping from unwind codes to opcodes.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>The most common codes are just one byte, while less common ones require two, three, or even four bytes.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>Each code is stored from most significant byte to least significant byte.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>The unwind code structure differs from the encoding described in the ARM EABI, because these unwind codes are designed to have a one-to-one mapping to the opcodes in the prologue and epilogue to allow for unwinding of partially executed prologues and epilogues.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>Byte 1</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>Byte 2</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>Byte 3</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Byte 4</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>Opsize</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>Explanation</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>00-7F</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>where X is (Code &amp; 0x7F) * 4</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>80-BF</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>where LR is popped if Code &amp; 0x2000 and r0-r12 are popped if the corresponding bit is set in Code &amp; 0x1FFF</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>C0-CF</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>where X is Code &amp; 0x0F</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>D0-D7</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>where X is (Code &amp; 0x03) + 4 and LR is popped if Code &amp; 0x04</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>D8-DF</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>where X is (Code &amp; 0x03) + 8 and LR is popped if Code &amp; 0x04</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>E0-E7</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>where X is (Code &amp; 0x07) + 8</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>E8-EB</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>where X is (Code &amp; 0x03FF) * 4</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>EC-ED</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>where LR is popped if Code &amp; 0x0100 and r0-r7 are popped if the corresponding bit is set in Code &amp; 0x00FF</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>EE</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>00-0F</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>Microsoft-specific</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>EE</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>10-FF</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>Available</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>EF</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>00-0F</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>where X is (Code &amp; 0x000F) * 4</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>EF</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>10-FF</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>Available</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>F0-F4</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>Available</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>F5</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>where S is (Code &amp; 0x00F0) &gt;&gt; 4 and E is Code &amp; 0x000F</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>F6</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>where S is ((Code &amp; 0x00F0) &gt;&gt; 4) + 16 and E is (Code &amp; 0x000F) + 16</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>F7</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>where X is (Code &amp; 0x00FFFF) * 4</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>F8</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>where X is (Code &amp; 0x00FFFFFF) * 4</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>F9</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>where X is (Code &amp; 0x00FFFF) * 4</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>FA</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>00-FF</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>where X is (Code &amp; 0x00FFFFFF) * 4</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>FB</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>nop (16-bit)</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>FC</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>nop (32-bit)</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>FD</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>end + 16-bit nop in epilogue</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>FE</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>end + 32-bit nop in epilogue</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>FF</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>end</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>This shows the range of hexadecimal values for each byte in an unwind code <ph id="ph1">`Code`</ph>, along with the opcode size <ph id="ph2">`Opsize`</ph> and the corresponding original instruction interpretation.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>Empty cells indicate shorter unwind codes.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>In instructions that have large values covering multiple bytes, the most significant bits are stored first.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Opsize`</ph> field shows the implicit opcode size associated with each Thumb-2 operation.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>The apparent duplicate entries in the table with different encodings are used to distinguish between different opcode sizes.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>The unwind codes are designed so that the first byte of the code tells both the total size in bytes of the code and the size of the corresponding opcode in the instruction stream.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>To compute the size of the prologue or epilogue, walk the unwind codes from the start of the sequence to the end, and use a lookup table or similar method to determine how long the corresponding opcode is.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>Unwind codes 0xFD and 0xFE are equivalent to the regular end code 0xFF, but account for one extra nop opcode in the epilogue case, either 16-bit or 32-bit.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>For prologues, codes 0xFD, 0xFE and 0xFF are exactly equivalent.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>This accounts for the common epilogue endings <ph id="ph1">`bx lr`</ph> or <ph id="ph2">`b &lt;tailcall-target&gt;`</ph>, which don’t have an equivalent prologue instruction.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>This increases the chance that unwind sequences can be shared between the prologue and the epilogues.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>In many cases, it should be possible to use the same set of unwind codes for the prologue and all epilogues.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>However, to handle the unwinding of partially executed prologues and epilogues, you might have to have multiple unwind code sequences that vary in ordering or behavior.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>This is why each epilogue has its own index into the unwind array to show where to begin executing.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>Unwinding Partial Prologues and Epilogues</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The most common unwinding case is when the exception occurs in the body of the function, away from the prologue and all epilogues.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>In this case, the unwinder executes the codes in the unwind array beginning at index 0 and continues until an end opcode is detected.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>When an exception occurs while a prologue or epilogue is executing, the stack frame is only partially constructed, and the unwinder must determine exactly what has been done in order to correctly undo it.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>For example, consider this prologue and epilogue sequence:</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Next to each opcode is the appropriate unwind code to describe this operation.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>The sequence of unwind codes for the prologue is a mirror image of the unwind codes for the epilogue, not counting the final instruction.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>This case is common, and is the reason the unwind codes for the prologue are always assumed to be stored in reverse order from the prologue’s execution order.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>This gives us a common set of unwind codes:</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>The 0xFD code is a special code for the end of the sequence that means that the epilogue is one 16-bit instruction longer than the prologue.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>This makes greater sharing of unwind codes possible.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>In the example, if an exception occurs while the function body between the prologue and epilogue is executing, unwinding starts with the epilogue case, at offset 0 within the epilogue code.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>This corresponds to offset 0x140 in the example.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>The unwinder executes the full unwind sequence, because no cleanup has been done.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>If instead the exception occurs one instruction after the beginning of the epilogue code, the unwinder can successfully unwind by skipping the first unwind code.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>Given a one-to-one mapping between opcodes and unwind codes, if unwinding from instruction <bpt id="p1">*</bpt>n<ept id="p1">*</ept> in the epilogue, the unwinder should skip the first <bpt id="p2">*</bpt>n<ept id="p2">*</ept> unwind codes.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>Similar logic works in reverse for the prologue.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>If unwinding from offset 0 in the prologue, nothing has to be executed.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>If unwinding from one instruction in, the unwind sequence should start one unwind code from the end because prologue unwind codes are stored in reverse order.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>In the general case, if unwinding from instruction <bpt id="p1">*</bpt>n<ept id="p1">*</ept> in the prologue, unwinding should start executing at <bpt id="p2">*</bpt>n<ept id="p2">*</ept> unwind codes from the end of the list of codes.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>Prologue and epilogue unwind codes do not always match exactly.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>In that case, the unwind code array may have to contain several sequences of codes.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>To determine the offset to begin processing codes, use this logic:</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>If unwinding from within the body of the function, begin executing unwind codes at index 0 and continue until an end opcode is reached.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>If unwinding from within an epilogue, use the epilogue-specific starting index provided by the epilogue scope.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>Calculate how many bytes the PC is from the start of the epilogue.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>Skip forward through the unwind codes until all of the already-executed instructions are accounted for.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>Execute the unwind sequence starting at that point.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>If unwinding from within the prologue, start from index 0 in the unwind codes.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>Calculate the length of the prologue code from the sequence, and then calculate how many bytes the PC is from the end of the prologue.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>Skip forward through the unwind codes until all of the unexecuted instructions are accounted for.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>Execute the unwind sequence starting at that point.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>The unwind codes for the prologue must always be the first in the array.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>They are also the codes used to unwind in the general case of unwinding from within the body.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>Any epilogue-specific code sequences should follow immediately after the prologue code sequence.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>Function Fragments</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>For code optimization, it may be useful to split a function into discontiguous parts.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>When this is done, each function fragment requires its own separate .pdata—and possibly .xdata—record.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>Assuming that the function prologue is at the beginning of the function and can't be split, there are four function fragment cases:</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>Prologue only; all epilogues in other fragments.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>Prologue and one or more epilogues; additional epilogues in other fragments.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>No prologue or epilogues; prologue and one or more epilogues in other fragments.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>Epilogues only; prologue and possibly additional epilogues in other fragments.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>In the first case, only the prologue must be described.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>This can be done in compact .pdata form by describing the prologue normally and specifying a <ph id="ph1">`Ret`</ph> value of 3 to indicate no epilogue.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>In the full .xdata form, this can be done by providing the prologue unwind codes at index 0 as usual, and specifying an epilogue count of 0.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>The second case is just like a normal function.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>If there’s only one epilogue in the fragment, and it is at the end of the fragment, then a compact .pdata record can be used.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>Otherwise, a full .xdata record must be used.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Keep in mind that the offsets specified for the epilogue start are relative to the start of the fragment, not the original start of the function.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>The third and fourth cases are variants of the first and second cases, respectively, except they don’t contain a prologue.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>In these situations, it is assumed that there is code before the start of the epilogue and it is considered part of the body of the function, which would normally be unwound by undoing the effects of the prologue.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>These cases must therefore be encoded with a pseudo-prologue, which describes how to unwind from within the body, but which is treated as 0-length when determining whether to perform a partial unwind at the start of the fragment.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Alternatively, this pseudo-prologue may be described by using the same unwind codes as the epilogue because they presumably perform equivalent operations.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>In the third and fourth cases, the presence of a pseudo-prologue is specified either by setting the <ph id="ph1">`Flag`</ph> field of the compact .pdata record to 2, or by setting the <ph id="ph2">`F`</ph> flag in the .xdata header to 1.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>In either case, the check for a partial prologue unwind is ignored, and all non-epilogue unwinds are considered to be full.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>Large Functions</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>Fragments can be used to describe functions larger than the 512 KB limit imposed by the bit fields in the .xdata header.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>To describe a very large function, just break it into fragments smaller than 512 KB.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>Each fragment should be adjusted so that it does not split an epilogue into multiple pieces.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Only the first fragment of the function contains a prologue; all other fragments are marked as having no prologue.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>Depending on the number of epilogues, each fragment may contain zero or more epilogues.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Keep in mind that each epilogue scope in a fragment specifies its starting offset relative to the start of the fragment, not the start of the function.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>If a fragment has no prologue and no epilogue, it still requires its own .pdata—and possibly .xdata—record to describe how to unwind from within the body of the function.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>Shrink-wrapping</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>A more complex special case of function fragments is <bpt id="p1">*</bpt>shrink-wrapping<ept id="p1">*</ept>, a technique for deferring register saves from the start of the function to later in the function, to optimize for simple cases that don’t require register saving.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>This can be described as an outer region that allocates the stack space but saves a minimal set of registers, and an inner region that saves and restores additional registers.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Shrink-wrapped functions are typically expected to pre-allocate the space for the extra register saves in the regular prologue, and then perform the register saves by using <ph id="ph1">`str`</ph> or <ph id="ph2">`stm`</ph> instead of <ph id="ph3">`push`</ph>.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>This keeps all stack-pointer manipulation in the function’s original prologue.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>The example shrink-wrapped function must be broken into three regions, which are marked as A, B, and C in the comments.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>The first A region covers the start of the function through the end of the additional non-volatile saves.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>A .pdata or .xdata record must be constructed to describe this fragment as having a prologue and no epilogues.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>The middle B region gets its own .pdata or .xdata record that describes a fragment that has no prologue and no epilogue.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>However, the unwind codes for this region must still be present because it's considered a function body.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>The codes must describe a composite prologue that represents both the original registers saved in the region-A prologue and the additional registers saved before entering region B, as if they were produced by one sequence of operations.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>The register saves for region B can't be considered as an "inner prologue" because the composite prologue described for region B must describe both the region-A prologue and the additional registers saved.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>If fragment B were described as having a prologue, the unwind codes would also imply the size of that prologue, and there is no way to describe the composite prologue in a way that maps one-to-one with the opcodes that only save the additional registers.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>The additional register saves must be considered part of region A, because until they are complete, the composite prologue does not accurately describe the state of the stack.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>The last C region gets its own .pdata or .xdata record, describing a fragment that has no prologue but does have an epilogue.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>An alternative approach can also work if the stack manipulation done before entering region B can be reduced to one instruction:</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>The key here is that on each instruction boundary, the stack is fully consistent with the unwind codes for the region.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>If an unwind occurs before the inner push in this example, it is considered part of region A, and only the region A prologue is unwound.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>If the unwind occurs after the inner push, it is considered part of region B, which has no prologue, but has unwind codes that describe both the inner push and the original prologue from region A. Similar logic holds for the inner pop.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>Encoding Optimizations</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>Due to the richness of the unwind codes and the ability to leverage compact and expanded forms of data, there are many opportunities to optimize the encoding to further reduce space.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>With aggressive use of these techniques, the net overhead of describing functions and fragments by using unwind codes can be quite minimal.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>The most important optimization is to be careful not to confuse prologue/epilogue boundaries for unwinding purposes with logical prologue/epilogue boundaries from a compiler perspective.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>The unwinding boundaries can be shrunk and made tighter to improve efficiency.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>For example, a prologue may contain code after the stack setup to perform additional verification checks.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>But once all the stack manipulation is complete, there is no need to encode further operations, and anything beyond that can be removed from the unwinding prologue.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>This same rule applies to the function length.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>If there is data—for example, a literal pool—that follows an epilogue in a function, it should not be included as part of the function length.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>By shrinking the function to just the code that is part of the function, the chances are much greater that the epilogue will be at the very end and a compact.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>pdata record can be used.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>In a prologue, once the stack pointer is saved to another register, there is typically no need to record any further opcodes.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>To unwind the function, the first thing that's done is to recover SP from the saved register, and so further operations do not have any impact on the unwind.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>Single-instruction epilogues do not have to be encoded at all, either as scopes or as unwind codes.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>If an unwind takes place before that instruction is executed, then it can be assumed to be from within the body of the function, and just executing the prologue unwind codes is sufficient.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>If the unwind takes place after the single instruction is executed, then by definition it takes place in another region.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>Multi-instruction epilogues do not have to encode the first instruction of the epilogue, for the same reason as the previous point: if the unwind takes place before that instruction executes, a full prologue unwind is sufficient.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>If the unwind takes place after that instruction, then only the subsequent operations have to be considered.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>Unwind code re-use should be aggressive.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>The index specified by each epilogue scope points to an arbitrary starting point in the array of unwind codes.</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>It does not have to point to the start of a previous sequence; it can point in the middle.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>The best approach here is to generate the desired code sequence and then scan for an exact byte match in the already-encoded pool of sequences and use any perfect match as a starting point for re-use.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>If, after single-instruction epilogues are ignored, there are no remaining epilogues, consider using a compact .pdata form; it becomes much more likely in the absence of an epilogue.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>Examples</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>In these examples, the image base is at 0x00400000.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>Example 1: Leaf Function, No Locals</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>.pdata (fixed, 2 words):</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>Word 0</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>= 0x000535F8 (= 0x004535F8–0x00400000)</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>Word 1</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>= 1, indicating canonical prologue and epilogue formats</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>= 0x31 (= 0x62/2)</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>= 1, indicating a 16-bit branch return</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>= 0, indicating the parameters were not homed</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>=0 and <ph id="ph1">`Reg`</ph> = 1, indicating push/pop of r4-r5</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>= 0, indicating no LR save/restore</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>= 0, indicating no frame chaining</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>= 0, indicating no stack adjustment</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>Example 2: Nested Function with Local Allocation</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>.pdata (fixed, 2 words):</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>Word 0</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>= 0x000533AC (= 0x004533AC –0x00400000)</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>Word 1</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>= 1, indicating canonical prologue and epilogue formats</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>= 0x35 (= 0x6A/2)</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>= 0, indicating a pop {pc} return</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>= 0, indicating the parameters were not homed</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>=0 and <ph id="ph1">`Reg`</ph> = 3, indicating push/pop of r4-r7</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>= 1, indicating LR was saved/restored</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>= 0, indicating no frame chaining</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>= 3 (= 0x0C/4)</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>Example 3: Nested Variadic Function</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>.pdata (fixed, 2 words):</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>Word 0</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>= 0x00053988 (= 0x00453988–0x00400000)</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>Word 1</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>= 1, indicating canonical prologue and epilogue formats</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>= 0x2A (= 0x54/2)</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>= 0, indicating a pop {pc}-style return (in this case an ldr pc,[sp],#0x14 return)</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>= 1, indicating the parameters were homed</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>=0 and <ph id="ph1">`Reg`</ph> = 2, indicating push/pop of r4-r6</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>= 1, indicating LR was saved/restored</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>= 0, indicating no frame chaining</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>= 0, indicating no stack adjustment</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>Example 4: Function with Multiple Epilogues</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>.pdata (fixed, 2 words):</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>Word 0</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>= 0x000592F4 (= 0x004592F4–0x00400000)</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>Word 1</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>= 0, indicating .xdata record present (required due to multiple epilogues)</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>- 0x00400000</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>.xdata (variable, 6 words):</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>Word 0</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>= 0x0001A3 (= 0x000346/2)</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>= 0, indicating the first version of xdata</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>= 0, indicating no exception data</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>= 0, indicating a list of epilogue scopes</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>= 0, indicating a full function description, including prologue</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>= 0x04, indicating the 4 total epilogue scopes</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>= 0x01, indicating one 32-bit word of unwind codes</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>Words 1-4, describing 4 epilogue scopes at 4 locations.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>Each scope has a common set of unwind codes, shared with the prologue, at offset 0x00, and is unconditional, specifying condition 0x0E (always).</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>Unwind codes, starting at Word 5: (shared between prologue/epilogue)</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>Unwind code 0 = 0x06: sp += (6 &lt;&lt; 2)</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>Unwind code 1 = 0xDE: pop {r4-r10, lr}</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>Unwind code 2 = 0xFF: end</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>Example 5: Function with Dynamic Stack and Inner Epilogue</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>.pdata (fixed, 2 words):</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>Word 0</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>= 0x00085A20 (= 0x00485A20–0x00400000)</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>Word 1</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>= 0, indicating .xdata record present (needed due to multiple epilogues)</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>- 0x00400000</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>.xdata (variable, 3 words):</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>Word 0</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>= 0x0001A3 (= 0x000346/2)</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>= 0, indicating the first version of xdata</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>= 0, indicating no exception data</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>= 0, indicating a list of epilogue scopes</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>= 0, indicating a full function description, including prologue</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>= 0x001, indicating the 1 total epilogue scope</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>= 0x01, indicating one 32-bit word of unwind codes</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>Word 1: Epilogue scope at offset 0xC6 (= 0x18C/2), starting unwind code index at 0x00, and with a condition of 0x0E (always)</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>Unwind codes, starting at Word 2: (shared between prologue/epilogue)</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Unwind code 0 = 0xC6: sp = r6</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>Unwind code 1 = 0xDC: pop {r4-r8, lr}</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>Unwind code 2 = 0x04: sp += (4 &lt;&lt; 2)</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>Unwind code 3 = 0xFD: end, counts as 16-bit instruction for epilogue</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>Example 6: Function with Exception Handler</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>.pdata (fixed, 2 words):</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>Word 0</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>= 0x00088C24 (= 0x00488C24–0x00400000)</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>Word 1</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>= 0, indicating .xdata record present (needed due to multiple epilogues)</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>- 0x00400000</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>.xdata (variable, 5 words):</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source>Word 0</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>=0x000027 (= 0x00004E/2)</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>= 0, indicating the first version of xdata</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>= 1, indicating exception data present</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>= 1, indicating a single epilogue</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>= 0, indicating a full function description, including prologue</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>= 0x00, indicating epilogue unwind codes start at offset 0x00</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>= 0x02, indicating two 32-bit words of unwind codes</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>Unwind codes, starting at Word 1:</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>Unwind code 0 = 0xC7: sp = r7</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>Unwind code 1 = 0x05: sp += (5 &lt;&lt; 2)</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>Unwind code 2 = 0xED/0x90: pop {r4, r7, lr}</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>Unwind code 4 = 0xFF: end</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>Word 3 specifies an exception handler  = 0x0019A7ED (= 0x0059A7ED – 0x00400000)</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Words 4 and beyond are inlined exception data</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>Example 7: Funclet</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>.pdata (fixed, 2 words):</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>Word 0</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>= 0x00088C72 (= 0x00488C72–0x00400000)</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>Word 1</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>= 1, indicating canonical prologue and epilogue formats</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>= 0x0B (= 0x16/2)</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>= 0, indicating a pop {pc} return</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>= 0, indicating the parameters were not homed</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>=0 and <ph id="ph1">`Reg`</ph> = 7, indicating no registers were saved/restored</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>= 1, indicating LR was saved/restored</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>= 0, indicating no frame chaining</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>= 1, indicating a 1 × 4 byte stack adjustment</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>Overview of ARM ABI Conventions</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>Common Visual C++ ARM Migration Issues</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>