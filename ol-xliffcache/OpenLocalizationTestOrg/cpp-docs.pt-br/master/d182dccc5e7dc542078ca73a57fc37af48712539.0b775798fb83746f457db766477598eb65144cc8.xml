{"nodes":[{"pos":[12,81],"content":"Object Lifetime And Resource Management (Modern C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Object Lifetime And Resource Management (Modern C++) | Microsoft Docs","pos":[0,69]}]},{"content":"Object Lifetime And Resource Management (Modern C++)","pos":[562,614]},{"content":"Unlike managed languages, C++ doesn’t have garbage collection (GC), which automatically releases no-longer-used memory resources as a program runs.","pos":[615,762]},{"content":"In C++, resource management is directly related to object lifetime.","pos":[763,830]},{"content":"This document describes the factors that affect object lifetime in C++ and how to manage it.","pos":[831,923]},{"content":"C++ doesn’t have GC primarily because it doesn't handle non-memory resources.","pos":[930,1007]},{"content":"Only deterministic destructors like those in C++ can handle memory and non-memory resources equally.","pos":[1008,1108]},{"content":"GC also has other problems, like higher overhead in memory and CPU consumption, and locality.","pos":[1109,1202]},{"content":"But universality is a fundamental problem that can't be mitigated through clever optimizations.","pos":[1203,1298]},{"content":"Concepts","pos":[1307,1315]},{"content":"An important thing in object-lifetime management is the encapsulation—whoever's using an object doesn't have to know what resources that object owns, or how to get rid of them, or even whether it owns any resources at all.","pos":[1319,1541]},{"content":"It just has to destroy the object.","pos":[1542,1576]},{"content":"The C++ core language is designed to ensure that objects are destroyed at the correct times, that is, as blocks are exited, in reverse order of construction.","pos":[1577,1734]},{"content":"When an object is destroyed, its bases and members are destroyed in a particular order.","pos":[1735,1822]},{"content":"The language automatically destroys objects, unless you do special things like heap allocation or placement new.","pos":[1824,1936]},{"content":"For example, <bpt id=\"p1\">[</bpt>smart pointers<ept id=\"p1\">](../cpp/smart-pointers-modern-cpp.md)</ept> like <ph id=\"ph1\">`unique_ptr`</ph> and <ph id=\"ph2\">`shared_ptr`</ph>, and Standard Template Library (STL) containers like <ph id=\"ph3\">`vector`</ph>, encapsulate <ph id=\"ph4\">`new`/`delete`</ph> and <ph id=\"ph5\">`new[]`/`delete[]`</ph> in objects, which have destructors.","pos":[1938,2188],"source":"  For example, [smart pointers](../cpp/smart-pointers-modern-cpp.md) like `unique_ptr` and `shared_ptr`, and Standard Template Library (STL) containers like `vector`, encapsulate `new`/`delete` and `new[]`/`delete[]` in objects, which have destructors."},{"content":"That's why it's so important to use smart pointers and STL containers.","pos":[2189,2259]},{"content":"Another important concept in lifetime management: destructors.","pos":[2266,2328]},{"content":"Destructors encapsulate resource release.","pos":[2329,2370]},{"content":"(The commonly used mnemonic is RRID, Resource Release Is Destruction.)  A resource is something that you get from \"the system\" and have to give back later.","pos":[2372,2527]},{"content":"Memory is the most common resource, but there are also files, sockets, textures, and other non-memory resources.","pos":[2529,2641]},{"content":"\"Owning\" a resource means you can use it when you need it but you also have to release it when you're finished with it.","pos":[2642,2761]},{"content":"When an object is destroyed, its destructor releases the resources that it owned.","pos":[2763,2844]},{"content":"The final concept is the DAG (Directed Acyclic Graph).","pos":[2851,2905]},{"content":"The structure of ownership in a program forms a DAG.","pos":[2907,2959]},{"content":"No object can own itself—that's not only impossible but also inherently meaningless.","pos":[2960,3044]},{"content":"But two objects can share ownership of a third object.","pos":[3045,3099]},{"content":"Several kinds of links are possible in a DAG like this: A is a member of B (B owns A), C stores a <ph id=\"ph1\">`vector&lt;D&gt;`</ph> (C owns each D element), E stores a <ph id=\"ph2\">`shared_ptr&lt;F&gt;`</ph> (E shares ownership of F, possibly with other objects), and so forth.","pos":[3101,3332],"source":"  Several kinds of links are possible in a DAG like this: A is a member of B (B owns A), C stores a `vector<D>` (C owns each D element), E stores a `shared_ptr<F>` (E shares ownership of F, possibly with other objects), and so forth."},{"content":"As long as there are no cycles and every link in the DAG is represented by an object that has a destructor (instead of a raw pointer, handle, or other mechanism), then resource leaks are impossible because the language prevents them.","pos":[3334,3567]},{"content":"Resources are released immediately after they're no longer needed, without a garbage collector running.","pos":[3568,3671]},{"content":"The lifetime tracking is overhead-free for stack scope, bases, members, and related cases, and inexpensive for <ph id=\"ph1\">`shared_ptr`</ph>.","pos":[3672,3796],"source":" The lifetime tracking is overhead-free for stack scope, bases, members, and related cases, and inexpensive for `shared_ptr`."},{"content":"Heap-based lifetime","pos":[3806,3825]},{"content":"For heap object lifetime, use <bpt id=\"p1\">[</bpt>smart pointers<ept id=\"p1\">](../cpp/smart-pointers-modern-cpp.md)</ept>.","pos":[3829,3913],"source":"For heap object lifetime, use [smart pointers](../cpp/smart-pointers-modern-cpp.md)."},{"content":"Use <ph id=\"ph1\">`shared_ptr`</ph> and <ph id=\"ph2\">`make_shared`</ph> as the default pointer and allocator.","pos":[3914,3986],"source":" Use `shared_ptr` and `make_shared` as the default pointer and allocator."},{"content":"Use <ph id=\"ph1\">`weak_ptr`</ph> to break cycles, do caching, and observe objects without affecting or assuming anything about their lifetimes.","pos":[3987,4112],"source":" Use `weak_ptr` to break cycles, do caching, and observe objects without affecting or assuming anything about their lifetimes."},{"content":"Use <ph id=\"ph1\">`unique_ptr`</ph> for unique ownership, for example, in the <bpt id=\"p1\">*</bpt>pimpl<ept id=\"p1\">*</ept> idiom.","pos":[4321,4394],"source":"Use `unique_ptr` for unique ownership, for example, in the *pimpl* idiom."},{"content":"(See <bpt id=\"p1\">[</bpt>Pimpl For Compile-Time Encapsulation<ept id=\"p1\">](../cpp/pimpl-for-compile-time-encapsulation-modern-cpp.md)</ept>.) Make a <ph id=\"ph1\">`unique_ptr`</ph> the primary target of all explicit <ph id=\"ph2\">`new`</ph> expressions.","pos":[4395,4573],"source":" (See [Pimpl For Compile-Time Encapsulation](../cpp/pimpl-for-compile-time-encapsulation-modern-cpp.md).) Make a `unique_ptr` the primary target of all explicit `new` expressions."},{"content":"You can use raw pointers for non-ownership and observation.","pos":[4636,4695]},{"content":"A non-owning pointer may dangle, but it can’t leak.","pos":[4696,4747]},{"content":"When performance optimization is required, you might have to use <bpt id=\"p1\">*</bpt>well-encapsulated<ept id=\"p1\">*</ept> owning pointers and explicit calls to delete.","pos":[5010,5140],"source":"When performance optimization is required, you might have to use *well-encapsulated* owning pointers and explicit calls to delete."},{"content":"An example is when you implement your own low-level data structure.","pos":[5141,5208]},{"content":"Stack-based lifetime","pos":[5218,5238]},{"content":"In modern C++, <bpt id=\"p1\">*</bpt>stack-based scope<ept id=\"p1\">*</ept> is a powerful way to write robust code because it combines automatic <bpt id=\"p2\">*</bpt>stack lifetime<ept id=\"p2\">*</ept> and <bpt id=\"p3\">*</bpt>data member lifetime<ept id=\"p3\">*</ept> with high efficiency—lifetime tracking is essentially free of overhead.","pos":[5242,5461],"source":"In modern C++, *stack-based scope* is a powerful way to write robust code because it combines automatic *stack lifetime* and *data member lifetime* with high efficiency—lifetime tracking is essentially free of overhead."},{"content":"Heap object lifetime requires diligent manual management and can be the source of resource leaks and inefficiencies, especially when you are working with raw pointers.","pos":[5462,5629]},{"content":"Consider this code, which demonstrates stack-based scope:","pos":[5630,5687]},{"content":"Use static lifetime sparingly (global static, function local static) because problems can arise.","pos":[6185,6281]},{"content":"What happens when the constructor of a global object throws an exception?","pos":[6282,6355]},{"content":"Typically, the app faults in a way that can be difficult to debug.","pos":[6356,6422]},{"content":"Construction order is problematic for static lifetime objects, and is not concurrency-safe.","pos":[6423,6514]},{"content":"Not only is object construction a problem, destruction order can be complex, especially where polymorphism is involved.","pos":[6515,6634]},{"content":"Even if your object or variable isn’t polymorphic and doesn't have complex construction/destruction ordering, there’s still the issue of thread-safe concurrency.","pos":[6635,6796]},{"content":"A multithreaded app can’t safely modify the data in static objects without having thread-local storage, resource locks, and other special precautions.","pos":[6797,6947]},{"content":"See Also","pos":[6956,6964]},{"content":"Welcome Back to C++","pos":[6969,6988]},{"content":"C++ Language Reference","pos":[7037,7059]},{"content":"C++ Standard Library","pos":[7100,7120]}],"content":"---\ntitle: \"Object Lifetime And Resource Management (Modern C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 8aa0e1a1-e04d-46b1-acca-1d548490700f\ncaps.latest.revision: 18\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Object Lifetime And Resource Management (Modern C++)\nUnlike managed languages, C++ doesn’t have garbage collection (GC), which automatically releases no-longer-used memory resources as a program runs. In C++, resource management is directly related to object lifetime. This document describes the factors that affect object lifetime in C++ and how to manage it.  \n  \n C++ doesn’t have GC primarily because it doesn't handle non-memory resources. Only deterministic destructors like those in C++ can handle memory and non-memory resources equally. GC also has other problems, like higher overhead in memory and CPU consumption, and locality. But universality is a fundamental problem that can't be mitigated through clever optimizations.  \n  \n## Concepts  \n An important thing in object-lifetime management is the encapsulation—whoever's using an object doesn't have to know what resources that object owns, or how to get rid of them, or even whether it owns any resources at all. It just has to destroy the object. The C++ core language is designed to ensure that objects are destroyed at the correct times, that is, as blocks are exited, in reverse order of construction. When an object is destroyed, its bases and members are destroyed in a particular order.  The language automatically destroys objects, unless you do special things like heap allocation or placement new.  For example, [smart pointers](../cpp/smart-pointers-modern-cpp.md) like `unique_ptr` and `shared_ptr`, and Standard Template Library (STL) containers like `vector`, encapsulate `new`/`delete` and `new[]`/`delete[]` in objects, which have destructors. That's why it's so important to use smart pointers and STL containers.  \n  \n Another important concept in lifetime management: destructors. Destructors encapsulate resource release.  (The commonly used mnemonic is RRID, Resource Release Is Destruction.)  A resource is something that you get from \"the system\" and have to give back later.  Memory is the most common resource, but there are also files, sockets, textures, and other non-memory resources. \"Owning\" a resource means you can use it when you need it but you also have to release it when you're finished with it.  When an object is destroyed, its destructor releases the resources that it owned.  \n  \n The final concept is the DAG (Directed Acyclic Graph).  The structure of ownership in a program forms a DAG. No object can own itself—that's not only impossible but also inherently meaningless. But two objects can share ownership of a third object.  Several kinds of links are possible in a DAG like this: A is a member of B (B owns A), C stores a `vector<D>` (C owns each D element), E stores a `shared_ptr<F>` (E shares ownership of F, possibly with other objects), and so forth.  As long as there are no cycles and every link in the DAG is represented by an object that has a destructor (instead of a raw pointer, handle, or other mechanism), then resource leaks are impossible because the language prevents them. Resources are released immediately after they're no longer needed, without a garbage collector running. The lifetime tracking is overhead-free for stack scope, bases, members, and related cases, and inexpensive for `shared_ptr`.  \n  \n### Heap-based lifetime  \n For heap object lifetime, use [smart pointers](../cpp/smart-pointers-modern-cpp.md). Use `shared_ptr` and `make_shared` as the default pointer and allocator. Use `weak_ptr` to break cycles, do caching, and observe objects without affecting or assuming anything about their lifetimes.  \n  \n```cpp  \nvoid func() {  \n  \nauto p = make_shared<widget>(); // no leak, and exception safe  \n...  \np->draw();   \n  \n} // no delete required, out-of-scope triggers smart pointer destructor  \n  \n```  \n  \n Use `unique_ptr` for unique ownership, for example, in the *pimpl* idiom. (See [Pimpl For Compile-Time Encapsulation](../cpp/pimpl-for-compile-time-encapsulation-modern-cpp.md).) Make a `unique_ptr` the primary target of all explicit `new` expressions.  \n  \n```cpp  \nunique_ptr<widget> p(new widget());  \n```  \n  \n You can use raw pointers for non-ownership and observation. A non-owning pointer may dangle, but it can’t leak.  \n  \n```cpp  \nclass node {  \n  ...  \n  vector<unique_ptr<node>> children; // node owns children  \n  node* parent; // node observes parent, which is not a concern  \n  ...  \n};  \nnode::node() : parent(...) { children.emplace_back(new node(...) ); }  \n  \n```  \n  \n When performance optimization is required, you might have to use *well-encapsulated* owning pointers and explicit calls to delete. An example is when you implement your own low-level data structure.  \n  \n### Stack-based lifetime  \n In modern C++, *stack-based scope* is a powerful way to write robust code because it combines automatic *stack lifetime* and *data member lifetime* with high efficiency—lifetime tracking is essentially free of overhead. Heap object lifetime requires diligent manual management and can be the source of resource leaks and inefficiencies, especially when you are working with raw pointers. Consider this code, which demonstrates stack-based scope:  \n  \n```cpp  \nclass widget {  \nprivate:  \n  gadget g;   // lifetime automatically tied to enclosing object  \npublic:  \n  void draw();  \n};  \n  \nvoid functionUsingWidget () {  \n  widget w;   // lifetime automatically tied to enclosing scope  \n              // constructs w, including the w.g gadget member  \n  …  \n  w.draw();  \n  …  \n} // automatic destruction and deallocation for w and w.g  \n  // automatic exception safety,   \n  // as if \"finally { w.dispose(); w.g.dispose(); }\"  \n  \n```  \n  \n Use static lifetime sparingly (global static, function local static) because problems can arise. What happens when the constructor of a global object throws an exception? Typically, the app faults in a way that can be difficult to debug. Construction order is problematic for static lifetime objects, and is not concurrency-safe. Not only is object construction a problem, destruction order can be complex, especially where polymorphism is involved. Even if your object or variable isn’t polymorphic and doesn't have complex construction/destruction ordering, there’s still the issue of thread-safe concurrency. A multithreaded app can’t safely modify the data in static objects without having thread-local storage, resource locks, and other special precautions.  \n  \n## See Also  \n [Welcome Back to C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   \n [C++ Language Reference](../cpp/cpp-language-reference.md)   \n [C++ Standard Library](../standard-library/cpp-standard-library-reference.md)"}