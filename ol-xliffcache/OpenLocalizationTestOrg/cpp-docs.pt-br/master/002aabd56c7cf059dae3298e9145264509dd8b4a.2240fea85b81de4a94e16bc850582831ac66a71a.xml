{"nodes":[{"pos":[12,45],"content":"shared_ptr Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"shared_ptr Class | Microsoft Docs","pos":[0,33]}]},{"content":"shared_ptr Class","pos":[760,776]},{"content":"Wraps a reference-counted smart pointer around a dynamically allocated object.","pos":[777,855]},{"content":"Syntax","pos":[864,870]},{"content":"Remarks","pos":[927,934]},{"content":"The shared_ptr class describes an object that uses reference counting to manage resources.","pos":[938,1028]},{"content":"A <ph id=\"ph1\">`shared_ptr`</ph> object effectively holds a pointer to the resource that it owns or holds a null pointer.","pos":[1029,1132],"source":" A `shared_ptr` object effectively holds a pointer to the resource that it owns or holds a null pointer."},{"content":"A resource can be owned by more than one <ph id=\"ph1\">`shared_ptr`</ph> object; when the last <ph id=\"ph2\">`shared_ptr`</ph> object that owns a particular resource is destroyed, the resource is freed.","pos":[1133,1297],"source":" A resource can be owned by more than one `shared_ptr` object; when the last `shared_ptr` object that owns a particular resource is destroyed, the resource is freed."},{"pos":[1304,1374],"content":"A <ph id=\"ph1\">`shared_ptr`</ph> stops owning a resource when it is reassigned or reset.","source":"A `shared_ptr` stops owning a resource when it is reassigned or reset."},{"pos":[1381,1480],"content":"The template argument <ph id=\"ph1\">`T`</ph> might be an incomplete type except as noted for certain member functions.","source":"The template argument `T` might be an incomplete type except as noted for certain member functions."},{"content":"When a <ph id=\"ph1\">`shared_ptr&lt;T&gt;`</ph> object is constructed from a resource pointer of type <ph id=\"ph2\">`G*`</ph> or from a <ph id=\"ph3\">`shared_ptr&lt;G&gt;`</ph>, the pointer type <ph id=\"ph4\">`G*`</ph> must be convertible to <ph id=\"ph5\">`T*`</ph>.","pos":[1487,1646],"source":"When a `shared_ptr<T>` object is constructed from a resource pointer of type `G*` or from a `shared_ptr<G>`, the pointer type `G*` must be convertible to `T*`."},{"content":"If it is not, the code will not compile.","pos":[1647,1687]},{"content":"For example:","pos":[1688,1700]},{"content":"class F {};","pos":[1706,1717]},{"pos":[2348,2386],"content":"A <ph id=\"ph1\">`shared_ptr`</ph> object owns a resource:","source":"A `shared_ptr` object owns a resource:"},{"content":"if it was constructed with a pointer to that resource,","pos":[2396,2450]},{"pos":[2460,2533],"content":"if it was constructed from a <ph id=\"ph1\">`shared_ptr`</ph> object that owns that resource,","source":"if it was constructed from a `shared_ptr` object that owns that resource,"},{"pos":[2543,2667],"content":"if it was constructed from a <bpt id=\"p1\">[</bpt>weak_ptr Class<ept id=\"p1\">](../standard-library/weak-ptr-class.md)</ept> object that points to that resource, or","source":"if it was constructed from a [weak_ptr Class](../standard-library/weak-ptr-class.md) object that points to that resource, or"},{"pos":[2677,2863],"content":"if ownership of that resource was assigned to it, either with <bpt id=\"p1\">[</bpt>shared_ptr::operator=<ept id=\"p1\">](#shared_ptr__operator_eq)</ept> or by calling the member function <bpt id=\"p2\">[</bpt>shared_ptr::reset<ept id=\"p2\">](#shared_ptr__reset)</ept>.","source":"if ownership of that resource was assigned to it, either with [shared_ptr::operator=](#shared_ptr__operator_eq) or by calling the member function [shared_ptr::reset](#shared_ptr__reset)."},{"content":"The <ph id=\"ph1\">`shared_ptr`</ph> objects that own a resource share a control block.","pos":[2870,2937],"source":"The `shared_ptr` objects that own a resource share a control block."},{"content":"The control block holds:","pos":[2938,2962]},{"pos":[2972,3029],"content":"the number of <ph id=\"ph1\">`shared_ptr`</ph> objects that own the resource,","source":"the number of `shared_ptr` objects that own the resource,"},{"pos":[3039,3099],"content":"the number of <ph id=\"ph1\">`weak_ptr`</ph> objects that point to the resource,","source":"the number of `weak_ptr` objects that point to the resource,"},{"content":"the deleter for that resource if it has one,","pos":[3109,3153]},{"content":"the custom allocator for the control block if it has one.","pos":[3163,3220]},{"content":"A <ph id=\"ph1\">`shared_ptr`</ph> object that is initialized by using a null pointer has a control block and is not empty.","pos":[3227,3330],"source":"A `shared_ptr` object that is initialized by using a null pointer has a control block and is not empty."},{"content":"After a <ph id=\"ph1\">`shared_ptr`</ph> object releases a resource, it no longer owns that resource.","pos":[3331,3412],"source":" After a `shared_ptr` object releases a resource, it no longer owns that resource."},{"content":"After a <ph id=\"ph1\">`weak_ptr`</ph> object releases a resource, it no longer points to that resource.","pos":[3413,3497],"source":" After a `weak_ptr` object releases a resource, it no longer points to that resource."},{"content":"When the number of <ph id=\"ph1\">`shared_ptr`</ph> objects that own a resource becomes zero, the resource is freed, either by deleting it or by passing its address to a deleter, depending on how ownership of the resource was originally created.","pos":[3504,3729],"source":"When the number of `shared_ptr` objects that own a resource becomes zero, the resource is freed, either by deleting it or by passing its address to a deleter, depending on how ownership of the resource was originally created."},{"content":"When the number of <ph id=\"ph1\">`shared_ptr`</ph> objects that own a resource is zero, and the number of <ph id=\"ph2\">`weak_ptr`</ph> objects that point to that resource is zero, the control block is freed, using the custom allocator for the control block if it has one.","pos":[3730,3964],"source":" When the number of `shared_ptr` objects that own a resource is zero, and the number of `weak_ptr` objects that point to that resource is zero, the control block is freed, using the custom allocator for the control block if it has one."},{"pos":[3971,4052],"content":"An empty <ph id=\"ph1\">`shared_ptr`</ph> object does not own any resources and has no control block.","source":"An empty `shared_ptr` object does not own any resources and has no control block."},{"content":"A deleter is a function object that has a member function <ph id=\"ph1\">`operator()`</ph>.","pos":[4059,4130],"source":"A deleter is a function object that has a member function `operator()`."},{"content":"Its type must be copy constructible, and its copy constructor and destructor must not throw exceptions.","pos":[4131,4234]},{"content":"It accepts one parameter, the object to be deleted.","pos":[4235,4286]},{"content":"Some functions take an argument list that defines properties of the resulting <ph id=\"ph1\">`shared_ptr&lt;T&gt;`</ph> or <ph id=\"ph2\">`weak_ptr&lt;T&gt;`</ph> object.","pos":[4293,4411],"source":"Some functions take an argument list that defines properties of the resulting `shared_ptr<T>` or `weak_ptr<T>` object."},{"content":"You can specify such an argument list in several ways:","pos":[4412,4466]},{"pos":[4473,4572],"content":"no arguments -- the resulting object is an empty <ph id=\"ph1\">`shared_ptr`</ph> object or an empty <ph id=\"ph2\">`weak_ptr`</ph> object.","source":"no arguments -- the resulting object is an empty `shared_ptr` object or an empty `weak_ptr` object."},{"content":"-- a pointer of type <ph id=\"ph1\">`Other*`</ph> to the resource to be managed.","pos":[4585,4645],"source":" -- a pointer of type `Other*` to the resource to be managed."},{"content":"must be a complete type.","pos":[4650,4674]},{"content":"If the function fails (because the control block cannot be allocated) it evaluates the expression <ph id=\"ph1\">`delete ptr`</ph>.","pos":[4675,4786],"source":" If the function fails (because the control block cannot be allocated) it evaluates the expression `delete ptr`."},{"content":"-- a pointer of type <ph id=\"ph1\">`Other*`</ph> to the resource to be managed and a deleter for that resource.","pos":[4805,4897],"source":" -- a pointer of type `Other*` to the resource to be managed and a deleter for that resource."},{"content":"If the function fails (because the control block cannot be allocated), it calls <ph id=\"ph1\">`dtor(ptr)`</ph>, which must be well defined.","pos":[4898,5018],"source":" If the function fails (because the control block cannot be allocated), it calls `dtor(ptr)`, which must be well defined."},{"content":"-- a pointer of type <ph id=\"ph1\">`Other*`</ph> to the resource to be managed, a deleter for that resource, and an allocator to manage any storage that must be allocated and freed.","pos":[5044,5206],"source":" -- a pointer of type `Other*` to the resource to be managed, a deleter for that resource, and an allocator to manage any storage that must be allocated and freed."},{"content":"If the function fails (because the control block can't be allocated) it calls <ph id=\"ph1\">`dtor(ptr)`</ph>, which must be well defined.","pos":[5207,5325],"source":" If the function fails (because the control block can't be allocated) it calls `dtor(ptr)`, which must be well defined."},{"pos":[5337,5406],"content":"-- a <ph id=\"ph1\">`shared_ptr&lt;Other&gt;`</ph> object that owns the resource to be managed.","source":" -- a `shared_ptr<Other>` object that owns the resource to be managed."},{"pos":[5418,5490],"content":"-- a <ph id=\"ph1\">`weak_ptr&lt;Other&gt;`</ph> object that points to the resource to be managed.","source":" -- a `weak_ptr<Other>` object that points to the resource to be managed."},{"content":"-- an <ph id=\"ph1\">`auto_ptr&lt;Other&gt;`</ph> object that holds a pointer to the resource to be managed.","pos":[5502,5584],"source":" -- an `auto_ptr<Other>` object that holds a pointer to the resource to be managed."},{"content":"If the function succeeds it calls <ph id=\"ph1\">`ap.release()`</ph>; otherwise it leaves <ph id=\"ph2\">`ap`</ph> unchanged.","pos":[5585,5670],"source":" If the function succeeds it calls `ap.release()`; otherwise it leaves `ap` unchanged."},{"pos":[5677,5745],"content":"In all cases, the pointer type <ph id=\"ph1\">`Other*`</ph> must be convertible to <ph id=\"ph2\">`T*`</ph>.","source":"In all cases, the pointer type `Other*` must be convertible to `T*`."},{"content":"Thread Safety","pos":[5754,5767]},{"pos":[5771,5910],"content":"Multiple threads can read and write different <ph id=\"ph1\">`shared_ptr`</ph> objects at the same time, even when the objects are copies that share ownership.","source":"Multiple threads can read and write different `shared_ptr` objects at the same time, even when the objects are copies that share ownership."},{"content":"Members","pos":[5919,5926]},{"content":"Constructors","pos":[5936,5948]},{"content":"shared_ptr::shared_ptr","pos":[5970,5992]},{"pos":[6019,6045],"content":"Constructs a <ph id=\"ph1\">`shared_ptr`</ph>.","source":"Constructs a `shared_ptr`."},{"content":"shared_ptr::~shared_ptr","pos":[6051,6074]},{"pos":[6106,6130],"content":"Destroys a <ph id=\"ph1\">`shared_ptr`</ph>.","source":"Destroys a `shared_ptr`."},{"content":"Methods","pos":[6141,6148]},{"content":"shared_ptr::element_type","pos":[6170,6194]},{"content":"The type of an element.","pos":[6223,6246]},{"content":"shared_ptr::get","pos":[6252,6267]},{"content":"Gets address of owned resource.","pos":[6287,6318]},{"content":"shared_ptr::owner_before","pos":[6324,6348]},{"pos":[6377,6465],"content":"Returns true if this <ph id=\"ph1\">`shared_ptr`</ph> is ordered before (or less than) the provided pointer.","source":"Returns true if this `shared_ptr` is ordered before (or less than) the provided pointer."},{"content":"shared_ptr::reset","pos":[6471,6488]},{"content":"Replace owned resource.","pos":[6510,6533]},{"content":"shared_ptr::swap","pos":[6539,6555]},{"pos":[6576,6607],"content":"Swaps two <ph id=\"ph1\">`shared_ptr`</ph> objects.","source":"Swaps two `shared_ptr` objects."},{"content":"shared_ptr::unique","pos":[6613,6631]},{"content":"Tests if owned resource is unique.","pos":[6654,6688]},{"content":"shared_ptr::use_count","pos":[6694,6715]},{"content":"Counts numbers of resource owners.","pos":[6741,6775]},{"content":"Operators","pos":[6786,6795]},{"content":"shared_ptr::operator boolean-type","pos":[6817,6850]},{"content":"Tests if an owned resource exists.","pos":[6888,6922]},{"content":"shared_ptr::operator*","pos":[6928,6949]},{"content":"Gets the designated value.","pos":[6979,7005]},{"content":"shared_ptr::operator=","pos":[7011,7032]},{"content":"Replaces the owned resource.","pos":[7060,7088]},{"content":"shared_ptr::operator-","pos":[7094,7115]},{"content":"Gets a pointer to the designated value.","pos":[7149,7188]},{"content":"Requirements","pos":[7198,7210]},{"pos":[7214,7233],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> &lt;memory","source":"**Header:** <memory"},{"pos":[7242,7260],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[7311,7335],"content":"shared_ptr::element_type"},{"content":"The type of an element.","pos":[7339,7362]},{"content":"Remarks","pos":[7413,7420]},{"pos":[7424,7477],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`T`</ph>.","source":"The type is a synonym for the template parameter `T`."},{"content":"Example","pos":[7487,7494]},{"pos":[7887,7902],"content":"shared_ptr::get"},{"content":"Gets address of owned resource.","pos":[7906,7937]},{"content":"Remarks","pos":[7978,7985]},{"content":"The member function returns the address of the owned resource.","pos":[7989,8051]},{"content":"If the object does not own a resource it returns 0.","pos":[8052,8103]},{"content":"Example","pos":[8113,8120]},{"pos":[8643,8676],"content":"shared_ptr::operator boolean-type"},{"content":"Tests if an owned resource exists.","pos":[8680,8714]},{"content":"Remarks","pos":[8770,8777]},{"content":"The operator returns a value of a type that is convertible to <ph id=\"ph1\">`bool`</ph>.","pos":[8781,8850],"source":"The operator returns a value of a type that is convertible to `bool`."},{"content":"The result of the conversion to <ph id=\"ph1\">`bool`</ph> is <ph id=\"ph2\">`true`</ph> when <ph id=\"ph3\">`get() != 0`</ph>, otherwise <ph id=\"ph4\">`false`</ph>.","pos":[8851,8937],"source":" The result of the conversion to `bool` is `true` when `get() != 0`, otherwise `false`."},{"content":"Example","pos":[8947,8954]},{"pos":[9487,9508],"content":"shared_ptr::operator*"},{"content":"Gets the designated value.","pos":[9512,9538]},{"content":"Remarks","pos":[9585,9592]},{"content":"The indirection operator returns <ph id=\"ph1\">`*get()`</ph>.","pos":[9596,9638],"source":"The indirection operator returns `*get()`."},{"content":"Hence, the stored pointer must not be null.","pos":[9639,9682]},{"content":"Example","pos":[9692,9699]},{"pos":[10049,10070],"content":"shared_ptr::operator="},{"content":"Replaces the owned resource.","pos":[10074,10102]},{"content":"Parameters","pos":[10558,10568]},{"content":"The shared pointer to copy.","pos":[10580,10607]},{"content":"The auto pointer to copy.","pos":[10622,10647]},{"content":"Remarks","pos":[10657,10664]},{"content":"The operators all decrement the reference count for the resource currently owned by <ph id=\"ph1\">`*this`</ph> and assign ownership of the resource named by the operand sequence to <ph id=\"ph2\">`*this`</ph>.","pos":[10668,10838],"source":"The operators all decrement the reference count for the resource currently owned by `*this` and assign ownership of the resource named by the operand sequence to `*this`."},{"content":"If the reference count falls to zero, the resource is released.","pos":[10839,10902]},{"content":"If an operator fails it leaves <ph id=\"ph1\">`*this`</ph> unchanged.","pos":[10903,10952],"source":" If an operator fails it leaves `*this` unchanged."},{"content":"Example","pos":[10962,10969]},{"pos":[11484,11505],"content":"shared_ptr::operator-"},{"content":"Gets a pointer to the designated value.","pos":[11513,11552]},{"content":"Remarks","pos":[11601,11608]},{"content":"The selection operator returns <ph id=\"ph1\">`get()`</ph>, so that the expression <ph id=\"ph2\">`sp-&gt;member`</ph> behaves the same as <ph id=\"ph3\">`(sp.get())-&gt;member`</ph> where <ph id=\"ph4\">`sp`</ph> is an object of class <ph id=\"ph5\">`shared_ptr&lt;T&gt;`</ph>.","pos":[11612,11778],"source":"The selection operator returns `get()`, so that the expression `sp->member` behaves the same as `(sp.get())->member` where `sp` is an object of class `shared_ptr<T>`."},{"content":"Hence, the stored pointer must not be null, and <ph id=\"ph1\">`T`</ph> must be a class, structure, or union type with a member <ph id=\"ph2\">`member`</ph>.","pos":[11779,11896],"source":" Hence, the stored pointer must not be null, and `T` must be a class, structure, or union type with a member `member`."},{"content":"Example","pos":[11906,11913]},{"pos":[12412,12436],"content":"shared_ptr::owner_before"},{"pos":[12440,12528],"content":"Returns true if this <ph id=\"ph1\">`shared_ptr`</ph> is ordered before (or less than) the provided pointer.","source":"Returns true if this `shared_ptr` is ordered before (or less than) the provided pointer."},{"content":"Parameters","pos":[12700,12710]},{"content":"An <ph id=\"ph1\">`lvalue`</ph> reference to either a <ph id=\"ph2\">`shared_ptr`</ph> or a <ph id=\"ph3\">`weak_ptr`</ph>.","pos":[12723,12786],"source":" An `lvalue` reference to either a `shared_ptr` or a `weak_ptr`."},{"content":"Remarks","pos":[12796,12803]},{"pos":[12807,12885],"content":"The template member function returns true if <ph id=\"ph1\">`*this`</ph> is <ph id=\"ph2\">`ordered before``ptr`</ph>.","source":"The template member function returns true if `*this` is `ordered before``ptr`."},{"pos":[12929,12946],"content":"shared_ptr::reset"},{"content":"Replace owned resource.","pos":[12950,12973]},{"content":"Parameters","pos":[13215,13225]},{"content":"The type controlled by the argument pointer.","pos":[13240,13284]},{"content":"The type of the deleter.","pos":[13298,13322]},{"content":"The pointer to copy.","pos":[13338,13358]},{"content":"The deleter to copy.","pos":[13375,13395]},{"content":"The type of the allocator.","pos":[13409,13435]},{"content":"The allocator to copy.","pos":[13453,13475]},{"content":"Remarks","pos":[13485,13492]},{"content":"The operators all decrement the reference count for the resource currently owned by <ph id=\"ph1\">`*this`</ph> and assign ownership of the resource named by the operand sequence to <ph id=\"ph2\">`*this`</ph>.","pos":[13496,13666],"source":"The operators all decrement the reference count for the resource currently owned by `*this` and assign ownership of the resource named by the operand sequence to `*this`."},{"content":"If the reference count falls to zero, the resource is released.","pos":[13667,13730]},{"content":"If an operator fails it leaves <ph id=\"ph1\">`*this`</ph> unchanged.","pos":[13731,13780],"source":" If an operator fails it leaves `*this` unchanged."},{"content":"Example","pos":[13790,13797]},{"pos":[14607,14629],"content":"shared_ptr::shared_ptr"},{"pos":[14633,14659],"content":"Constructs a <ph id=\"ph1\">`shared_ptr`</ph>.","source":"Constructs a `shared_ptr`."},{"content":"Parameters","pos":[15623,15633]},{"content":"The type controlled by the argument pointer.","pos":[15648,15692]},{"content":"The pointer to copy.","pos":[15708,15728]},{"content":"The type of the deleter.","pos":[15742,15766]},{"content":"The type of the allocator.","pos":[15780,15806]},{"content":"The deleter.","pos":[15823,15835]},{"content":"The allocator.","pos":[15852,15866]},{"content":"The smart pointer to copy.","pos":[15881,15907]},{"content":"The weak pointer.","pos":[15922,15939]},{"content":"The auto pointer to copy.","pos":[15954,15979]},{"content":"Remarks","pos":[15989,15996]},{"content":"The constructors each construct an object that owns the resource named by the operand sequence.","pos":[16000,16095]},{"content":"The constructor <ph id=\"ph1\">`shared_ptr(const weak_ptr&lt;Other&gt;&amp; wp)`</ph> throws an exception object of type <bpt id=\"p1\">[</bpt>bad_weak_ptr Class<ept id=\"p1\">](../standard-library/bad-weak-ptr-class.md)</ept> if <ph id=\"ph2\">`wp.expired()`</ph>.","pos":[16096,16269],"source":" The constructor `shared_ptr(const weak_ptr<Other>& wp)` throws an exception object of type [bad_weak_ptr Class](../standard-library/bad-weak-ptr-class.md) if `wp.expired()`."},{"content":"Example","pos":[16279,16286]},{"pos":[17341,17364],"content":"shared_ptr::~shared_ptr"},{"pos":[17368,17392],"content":"Destroys a <ph id=\"ph1\">`shared_ptr`</ph>.","source":"Destroys a `shared_ptr`."},{"content":"Remarks","pos":[17432,17439]},{"content":"The destructor decrements the reference count for the resource currently owned by <ph id=\"ph1\">`*this`</ph>.","pos":[17443,17533],"source":"The destructor decrements the reference count for the resource currently owned by `*this`."},{"content":"If the reference count falls to zero, the resource is released.","pos":[17534,17597]},{"content":"Example","pos":[17607,17614]},{"pos":[18454,18470],"content":"shared_ptr::swap"},{"pos":[18474,18505],"content":"Swaps two <ph id=\"ph1\">`shared_ptr`</ph> objects.","source":"Swaps two `shared_ptr` objects."},{"content":"Parameters","pos":[18557,18567]},{"content":"The shared pointer to swap with.","pos":[18579,18611]},{"content":"Remarks","pos":[18621,18628]},{"content":"The member function leaves the resource originally owned by <ph id=\"ph1\">`*this`</ph> subsequently owned by <ph id=\"ph2\">`sp`</ph>, and the resource originally owned by <ph id=\"ph3\">`sp`</ph> subsequently owned by <ph id=\"ph4\">`*this`</ph>.","pos":[18632,18800],"source":"The member function leaves the resource originally owned by `*this` subsequently owned by `sp`, and the resource originally owned by `sp` subsequently owned by `*this`."},{"content":"The function does not change the reference counts for the two resources and it does not throw any exceptions.","pos":[18801,18910]},{"content":"Example","pos":[18920,18927]},{"pos":[19901,19919],"content":"shared_ptr::unique"},{"content":"Tests if owned resource is unique.","pos":[19923,19957]},{"content":"Remarks","pos":[20003,20010]},{"pos":[20014,20143],"content":"The member function returns <ph id=\"ph1\">`true`</ph> if no other <ph id=\"ph2\">`shared_ptr`</ph> object owns the resource that is owned by <ph id=\"ph3\">`*this`</ph>, otherwise <ph id=\"ph4\">`false`</ph>.","source":"The member function returns `true` if no other `shared_ptr` object owns the resource that is owned by `*this`, otherwise `false`."},{"content":"Example","pos":[20153,20160]},{"pos":[20786,20807],"content":"shared_ptr::use_count"},{"content":"Counts numbers of resource owners.","pos":[20811,20845]},{"content":"Remarks","pos":[20894,20901]},{"pos":[20905,21015],"content":"The member function returns the number of <ph id=\"ph1\">`shared_ptr`</ph> objects that own the resource that is owned by <ph id=\"ph2\">`*this`</ph>.","source":"The member function returns the number of `shared_ptr` objects that own the resource that is owned by `*this`."},{"content":"Example","pos":[21025,21032]},{"content":"See Also","pos":[21518,21526]},{"content":"weak_ptr Class","pos":[21531,21545]},{"content":"Thread Safety in the C++ Standard Library","pos":[21591,21632]}],"content":"---\ntitle: \"shared_ptr Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"shared_ptr\"\n  - \"tr1::shared_ptr\"\n  - \"memory/std::tr1::shared_ptr\"\n  - \"std::tr1::shared_ptr\"\n  - \"std.tr1.shared_ptr\"\n  - \"tr1.shared_ptr\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"shared_ptr class [TR1]\"\n  - \"shared_ptr class\"\nms.assetid: 1469fc51-c658-43f1-886c-f4530dd84860\ncaps.latest.revision: 28\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# shared_ptr Class\nWraps a reference-counted smart pointer around a dynamically allocated object.  \n  \n## Syntax  \n```\ntemplate <class T>\nclass shared_ptr; \n```  \n  \n## Remarks  \n The shared_ptr class describes an object that uses reference counting to manage resources. A `shared_ptr` object effectively holds a pointer to the resource that it owns or holds a null pointer. A resource can be owned by more than one `shared_ptr` object; when the last `shared_ptr` object that owns a particular resource is destroyed, the resource is freed.  \n  \n A `shared_ptr` stops owning a resource when it is reassigned or reset.  \n  \n The template argument `T` might be an incomplete type except as noted for certain member functions.  \n  \n When a `shared_ptr<T>` object is constructed from a resource pointer of type `G*` or from a `shared_ptr<G>`, the pointer type `G*` must be convertible to `T*`. If it is not, the code will not compile. For example:  \n  \nclass F {};  \n  \n```cpp  \n  \n#include <memory>  \n  \nusing namespace std;  \n  \nshared_ptr<G> sp0(new G);   // okay, template parameter G and argument G*  \nshared_ptr<G> sp1(sp0);     // okay, template parameter G and argument shared_ptr<G>  \nshared_ptr<F> sp2(new G);   // okay, G* convertible to F*  \nshared_ptr<F> sp3(sp0);     // okay, template parameter F and argument shared_ptr<G>  \nshared_ptr<F> sp4(sp2);     // okay, template parameter F and argument shared_ptr<F>  \nshared_ptr<int> sp5(new G); // error, G* not convertible to int*  \nshared_ptr<int> sp6(sp2);   // error, template parameter int and argument shared_ptr<F>  \n```  \n  \n A `shared_ptr` object owns a resource:  \n  \n-   if it was constructed with a pointer to that resource,  \n  \n-   if it was constructed from a `shared_ptr` object that owns that resource,  \n  \n-   if it was constructed from a [weak_ptr Class](../standard-library/weak-ptr-class.md) object that points to that resource, or  \n  \n-   if ownership of that resource was assigned to it, either with [shared_ptr::operator=](#shared_ptr__operator_eq) or by calling the member function [shared_ptr::reset](#shared_ptr__reset).  \n  \n The `shared_ptr` objects that own a resource share a control block. The control block holds:  \n  \n-   the number of `shared_ptr` objects that own the resource,  \n  \n-   the number of `weak_ptr` objects that point to the resource,  \n  \n-   the deleter for that resource if it has one,  \n  \n-   the custom allocator for the control block if it has one.  \n  \n A `shared_ptr` object that is initialized by using a null pointer has a control block and is not empty. After a `shared_ptr` object releases a resource, it no longer owns that resource. After a `weak_ptr` object releases a resource, it no longer points to that resource.  \n  \n When the number of `shared_ptr` objects that own a resource becomes zero, the resource is freed, either by deleting it or by passing its address to a deleter, depending on how ownership of the resource was originally created. When the number of `shared_ptr` objects that own a resource is zero, and the number of `weak_ptr` objects that point to that resource is zero, the control block is freed, using the custom allocator for the control block if it has one.  \n  \n An empty `shared_ptr` object does not own any resources and has no control block.  \n  \n A deleter is a function object that has a member function `operator()`. Its type must be copy constructible, and its copy constructor and destructor must not throw exceptions. It accepts one parameter, the object to be deleted.  \n  \n Some functions take an argument list that defines properties of the resulting `shared_ptr<T>` or `weak_ptr<T>` object. You can specify such an argument list in several ways:  \n  \n no arguments -- the resulting object is an empty `shared_ptr` object or an empty `weak_ptr` object.  \n  \n `ptr` -- a pointer of type `Other*` to the resource to be managed. `T` must be a complete type. If the function fails (because the control block cannot be allocated) it evaluates the expression `delete ptr`.  \n  \n `ptr, dtor` -- a pointer of type `Other*` to the resource to be managed and a deleter for that resource. If the function fails (because the control block cannot be allocated), it calls `dtor(ptr)`, which must be well defined.  \n  \n `ptr, dtor, alloc` -- a pointer of type `Other*` to the resource to be managed, a deleter for that resource, and an allocator to manage any storage that must be allocated and freed. If the function fails (because the control block can't be allocated) it calls `dtor(ptr)`, which must be well defined.  \n  \n `sp` -- a `shared_ptr<Other>` object that owns the resource to be managed.  \n  \n `wp` -- a `weak_ptr<Other>` object that points to the resource to be managed.  \n  \n `ap` -- an `auto_ptr<Other>` object that holds a pointer to the resource to be managed. If the function succeeds it calls `ap.release()`; otherwise it leaves `ap` unchanged.  \n  \n In all cases, the pointer type `Other*` must be convertible to `T*`.  \n  \n## Thread Safety  \n Multiple threads can read and write different `shared_ptr` objects at the same time, even when the objects are copies that share ownership.  \n  \n## Members  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[shared_ptr::shared_ptr](#shared_ptr__shared_ptr)|Constructs a `shared_ptr`.|  \n|[shared_ptr::~shared_ptr](#shared_ptr___dtorshared_ptr)|Destroys a `shared_ptr`.|  \n  \n### Methods  \n  \n|||  \n|-|-|  \n|[shared_ptr::element_type](#shared_ptr__element_type)|The type of an element.|  \n|[shared_ptr::get](#shared_ptr__get)|Gets address of owned resource.|  \n|[shared_ptr::owner_before](#shared_ptr__owner_before)|Returns true if this `shared_ptr` is ordered before (or less than) the provided pointer.|  \n|[shared_ptr::reset](#shared_ptr__reset)|Replace owned resource.|  \n|[shared_ptr::swap](#shared_ptr__swap)|Swaps two `shared_ptr` objects.|  \n|[shared_ptr::unique](#shared_ptr__unique)|Tests if owned resource is unique.|  \n|[shared_ptr::use_count](#shared_ptr__use_count)|Counts numbers of resource owners.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|[shared_ptr::operator boolean-type](#shared_ptr__operator_boolean-type)|Tests if an owned resource exists.|  \n|[shared_ptr::operator*](#shared_ptr__operator_star)|Gets the designated value.|  \n|[shared_ptr::operator=](#shared_ptr__operator_eq)|Replaces the owned resource.|  \n|[shared_ptr::operator-&gt;](#shared_ptr__operator-_gt_)|Gets a pointer to the designated value.|  \n  \n## Requirements  \n **Header:** <memory\\>  \n  \n **Namespace:** std  \n  \n##  <a name=\"shared_ptr__element_type\"></a>  shared_ptr::element_type  \n The type of an element.  \n  \n```  \ntypedef T element_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `T`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_element_type.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nint main()\n{\n    std::shared_ptr<int> sp0(new int(5));\n    std::shared_ptr<int>::element_type val = *sp0;\n\n    std::cout << \"*sp0 == \" << val << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \n*sp0 == 5  \n```  \n  \n##  <a name=\"shared_ptr__get\"></a>  shared_ptr::get  \n Gets address of owned resource.  \n  \n```  \nT *get() const;\n```  \n  \n### Remarks  \n The member function returns the address of the owned resource. If the object does not own a resource it returns 0.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_get.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nint main()\n{\n    std::shared_ptr<int> sp0;\n    std::shared_ptr<int> sp1(new int(5));\n\n    std::cout << \"sp0.get() == 0 == \" << std::boolalpha\n        << (sp0.get() == 0) << std::endl;\n    std::cout << \"*sp1.get() == \" << *sp1.get() << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \nsp0.get() == 0 == true  \n*sp1.get() == 5  \n```  \n  \n##  <a name=\"shared_ptr__operator_boolean-type\"></a>  shared_ptr::operator boolean-type  \n Tests if an owned resource exists.  \n  \n```  \noperator boolean-type() const;\n```  \n  \n### Remarks  \n The operator returns a value of a type that is convertible to `bool`. The result of the conversion to `bool` is `true` when `get() != 0`, otherwise `false`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_operator_bool.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n\nint main()\n{\n    std::shared_ptr<int> sp0;\n    std::shared_ptr<int> sp1(new int(5));\n\n    std::cout << \"(bool)sp0 == \" << std::boolalpha\n        << (bool)sp0 << std::endl;\n    std::cout << \"(bool)sp1 == \" << std::boolalpha\n        << (bool)sp1 << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \n(bool)sp0 == false  \n(bool)sp1 == true  \n```  \n  \n##  <a name=\"shared_ptr__operator_star\"></a>  shared_ptr::operator*  \n Gets the designated value.  \n  \n```  \nT& operator*() const;\n```  \n  \n### Remarks  \n The indirection operator returns `*get()`. Hence, the stored pointer must not be null.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_operator_st.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nint main()\n{\n    std::shared_ptr<int> sp0(new int(5));\n\n    std::cout << \"*sp0 == \" << *sp0 << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \n*sp0 == 5  \n```  \n  \n##  <a name=\"shared_ptr__operator_eq\"></a>  shared_ptr::operator=  \n Replaces the owned resource.  \n  \n```  \nshared_ptr& operator=(const shared_ptr& sp);\n\ntemplate <class Other>  \nshared_ptr& operator=(const shared_ptr<Other>& sp);\n\ntemplate <class Other>  \nshared_ptr& operator=(auto_ptr<Other>& ap);\n\ntemplate <class Other>  \nshared_ptr& operator=(auto_ptr<Other>& ap);\n\ntemplate <class Other>  \nshared_ptr& operator=(auto_ptr<Other>&& ap);\n\ntemplate <class Other, class Deletor>  \nshared_ptr& operator=(unique_ptr<Other, Deletor>&& ap);\n```  \n  \n### Parameters  \n `sp`  \n The shared pointer to copy.  \n  \n `ap`  \n The auto pointer to copy.  \n  \n### Remarks  \n The operators all decrement the reference count for the resource currently owned by `*this` and assign ownership of the resource named by the operand sequence to `*this`. If the reference count falls to zero, the resource is released. If an operator fails it leaves `*this` unchanged.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_operator_as.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nint main()\n{\n    std::shared_ptr<int> sp0;\n    std::shared_ptr<int> sp1(new int(5));\n    std::auto_ptr<int> ap(new int(10));\n\n    sp0 = sp1;\n    std::cout << \"*sp0 == \" << *sp0 << std::endl;\n\n    sp0 = ap;\n    std::cout << \"*sp0 == \" << *sp0 << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \n*sp0 == 5  \n*sp0 == 10  \n```  \n  \n##  <a name=\"shared_ptr__operator-_gt_\"></a>  shared_ptr::operator-&gt;  \n Gets a pointer to the designated value.  \n  \n```  \nT * operator->() const;\n```  \n  \n### Remarks  \n The selection operator returns `get()`, so that the expression `sp->member` behaves the same as `(sp.get())->member` where `sp` is an object of class `shared_ptr<T>`. Hence, the stored pointer must not be null, and `T` must be a class, structure, or union type with a member `member`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_operator_ar.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \ntypedef std::pair<int, int> Mypair;\nint main()\n{\n    std::shared_ptr<Mypair> sp0(new Mypair(1, 2));\n\n    std::cout << \"sp0->first == \" << sp0->first << std::endl;\n    std::cout << \"sp0->second == \" << sp0->second << std::endl;\n\n    return (0);\n}\n  \n```  \n  \n```Output  \nsp0->first == 1  \nsp0->second == 2  \n```  \n  \n##  <a name=\"shared_ptr__owner_before\"></a>  shared_ptr::owner_before  \n Returns true if this `shared_ptr` is ordered before (or less than) the provided pointer.  \n  \n```  \ntemplate <class Other>  \nbool owner_before(const shared_ptr<Other>& ptr);\n\ntemplate <class Other>  \nbool owner_before(const weak_ptr<Other>& ptr);\n```  \n  \n### Parameters  \n `ptr`  \n An `lvalue` reference to either a `shared_ptr` or a `weak_ptr`.  \n  \n### Remarks  \n The template member function returns true if `*this` is `ordered before``ptr`.  \n  \n##  <a name=\"shared_ptr__reset\"></a>  shared_ptr::reset  \n Replace owned resource.  \n  \n```  \nvoid reset();\n\ntemplate <class Other>  \nvoid reset(Other *ptr;);\n\ntemplate <class Other, class D>  \nvoid reset(Other *ptr, D dtor);\n\ntemplate <class Other, class D, class A>  \nvoid reset(Other *ptr, D dtor, A alloc);\n```  \n  \n### Parameters  \n `Other`  \n The type controlled by the argument pointer.  \n  \n `D`  \n The type of the deleter.  \n  \n `ptr`  \n The pointer to copy.  \n  \n `dtor`  \n The deleter to copy.  \n  \n `A`  \n The type of the allocator.  \n  \n `alloc`  \n The allocator to copy.  \n  \n### Remarks  \n The operators all decrement the reference count for the resource currently owned by `*this` and assign ownership of the resource named by the operand sequence to `*this`. If the reference count falls to zero, the resource is released. If an operator fails it leaves `*this` unchanged.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_reset.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nstruct deleter\n{\n    void operator()(int *p)\n    {\n        delete p;\n    }\n};  \n  \nint main()\n{\n    std::shared_ptr<int> sp(new int(5));\n\n    std::cout << \"*sp == \" << std::boolalpha\n        << *sp << std::endl;\n\n    sp.reset();\n    std::cout << \"(bool)sp == \" << std::boolalpha\n        << (bool)sp << std::endl;\n\n    sp.reset(new int(10));\n    std::cout << \"*sp == \" << std::boolalpha\n        << *sp << std::endl;\n\n    sp.reset(new int(15), deleter());\n    std::cout << \"*sp == \" << std::boolalpha\n        << *sp << std::endl;\n\n    return (0);\n}\n  \n```  \n  \n```Output  \n*sp == 5  \n(bool)sp == false  \n*sp == 10  \n*sp == 15  \n```  \n  \n##  <a name=\"shared_ptr__shared_ptr\"></a>  shared_ptr::shared_ptr  \n Constructs a `shared_ptr`.  \n  \n```  \nshared_ptr();\n\nshared_ptr(nullptr_t);\n\nshared_ptr(const shared_ptr& sp);\n\nshared_ptr(shared_ptr&& sp);\n\ntemplate <class Other>  \nexplicit shared_ptr(Other* ptr);\n\ntemplate <class Other, class D>  \nshared_ptr(Other* ptr, D dtor);\n\ntemplate <class D>  \nshared_ptr(nullptr_t ptr, D dtor);\n\ntemplate <class Other, class D, class A>  \nshared_ptr(Other* ptr, D dtor, A  alloc);\n\ntemplate <class D, class A>  \nshared_ptr(nullptr_t ptr, D dtor, A alloc);\n\ntemplate <class Other>  \nshared_ptr(const shared_ptr<Other>& sp);\n\ntemplate <class Other>  \nshared_ptr(const weak_ptr<Other>& wp);\n\ntemplate <class &>  \nshared_ptr(std::auto_ptr<Other>& ap);\n\ntemplate <class &>  \nshared_ptr(std::auto_ptr<Other>&& ap);\n\ntemplate <class Other, class D>  \nshared_ptr(unique_ptr<Other, D>&& up);\n\ntemplate <class Other>  \nshared_ptr(const shared_ptr<Other>& sp, T* ptr);\n\ntemplate <class Other, class D>  \nshared_ptr(const unique_ptr<Other, D>& up) = delete;  \n```  \n  \n### Parameters  \n `Other`  \n The type controlled by the argument pointer.  \n  \n `ptr`  \n The pointer to copy.  \n  \n `D`  \n The type of the deleter.  \n  \n `A`  \n The type of the allocator.  \n  \n `dtor`  \n The deleter.  \n  \n `ator`  \n The allocator.  \n  \n `sp`  \n The smart pointer to copy.  \n  \n `wp`  \n The weak pointer.  \n  \n `ap`  \n The auto pointer to copy.  \n  \n### Remarks  \n The constructors each construct an object that owns the resource named by the operand sequence. The constructor `shared_ptr(const weak_ptr<Other>& wp)` throws an exception object of type [bad_weak_ptr Class](../standard-library/bad-weak-ptr-class.md) if `wp.expired()`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_construct.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nstruct deleter\n{\n    void operator()(int *p)\n    {\n        delete p;\n    }\n};\n  \nint main()\n{\n    std::shared_ptr<int> sp0;\n    std::cout << \"(bool)sp0 == \" << std::boolalpha\n        << (bool)sp0 << std::endl;\n\n    std::shared_ptr<int> sp1(new int(5));\n    std::cout << \"*sp1 == \" << *sp1 << std::endl;\n\n    std::shared_ptr<int> sp2(new int(10), deleter());\n    std::cout << \"*sp2 == \" << *sp2 << std::endl;\n\n    std::shared_ptr<int> sp3(sp2);\n    std::cout << \"*sp3 == \" << *sp3 << std::endl;\n\n    std::weak_ptr<int> wp(sp3);\n    std::shared_ptr<int> sp4(wp);\n    std::cout << \"*sp4 == \" << *sp4 << std::endl;\n\n    std::auto_ptr<int> ap(new int(15));\n    std::shared_ptr<int> sp5(ap);\n    std::cout << \"*sp5 == \" << *sp5 << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \n(bool)sp0 == false  \n*sp1 == 5  \n*sp2 == 10  \n*sp3 == 10  \n*sp4 == 10  \n*sp5 == 15  \n```  \n  \n##  <a name=\"shared_ptr___dtorshared_ptr\"></a>  shared_ptr::~shared_ptr  \n Destroys a `shared_ptr`.  \n  \n```  \n~shared_ptr();\n```  \n  \n### Remarks  \n The destructor decrements the reference count for the resource currently owned by `*this`. If the reference count falls to zero, the resource is released.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_destroy.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nstruct deleter\n{\n    void operator()(int *p)\n    {\n        delete p;\n    }\n};\n\nint main()\n{\n    std::shared_ptr<int> sp1(new int(5));\n    std::cout << \"*sp1 == \" << *sp1 << std::endl;\n    std::cout << \"use count == \" << sp1.use_count() << std::endl;\n\n    {\n        std::shared_ptr<int> sp2(sp1);\n        std::cout << \"*sp2 == \" << *sp2 << std::endl;\n        std::cout << \"use count == \" << sp1.use_count() << std::endl;\n    }\n\n    // check use count after sp2 is destroyed   \n    std::cout << \"use count == \" << sp1.use_count() << std::endl;\n\n    return (0);\n}\n  \n```  \n  \n```Output  \n*sp1 == 5  \nuse count == 1  \n*sp2 == 5  \nuse count == 2  \nuse count == 1  \n```  \n  \n##  <a name=\"shared_ptr__swap\"></a>  shared_ptr::swap  \n Swaps two `shared_ptr` objects.  \n  \n```  \nvoid swap(shared_ptr& sp);\n```  \n  \n### Parameters  \n `sp`  \n The shared pointer to swap with.  \n  \n### Remarks  \n The member function leaves the resource originally owned by `*this` subsequently owned by `sp`, and the resource originally owned by `sp` subsequently owned by `*this`. The function does not change the reference counts for the two resources and it does not throw any exceptions.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_swap.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nstruct deleter\n{\n    void operator()(int *p)\n    {\n        delete p;\n    }\n};\n\nint main()\n{\n    std::shared_ptr<int> sp1(new int(5));\n    std::shared_ptr<int> sp2(new int(10));\n    std::cout << \"*sp1 == \" << *sp1 << std::endl;\n\n    sp1.swap(sp2);\n    std::cout << \"*sp1 == \" << *sp1 << std::endl;\n\n    swap(sp1, sp2);\n    std::cout << \"*sp1 == \" << *sp1 << std::endl;\n    std::cout << std::endl;\n\n    std::weak_ptr<int> wp1(sp1);\n    std::weak_ptr<int> wp2(sp2);\n    std::cout << \"*wp1 == \" << *wp1.lock() << std::endl;\n\n    wp1.swap(wp2);\n    std::cout << \"*wp1 == \" << *wp1.lock() << std::endl;\n\n    swap(wp1, wp2);\n    std::cout << \"*wp1 == \" << *wp1.lock() << std::endl;\n\n    return (0);\n}\n  \n```  \n  \n```Output  \n*sp1 == 5  \n*sp1 == 10  \n*sp1 == 5  \n  \n*wp1 == 5  \n*wp1 == 10  \n*wp1 == 5  \n```  \n  \n##  <a name=\"shared_ptr__unique\"></a>  shared_ptr::unique  \n Tests if owned resource is unique.  \n  \n```  \nbool unique() const;\n```  \n  \n### Remarks  \n The member function returns `true` if no other `shared_ptr` object owns the resource that is owned by `*this`, otherwise `false`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_unique.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nstruct deleter\n{\n    void operator()(int *p)\n    {\n        delete p;\n    }\n};\n\nint main()\n{\n    std::shared_ptr<int> sp1(new int(5));\n    std::cout << \"sp1.unique() == \" << std::boolalpha\n        << sp1.unique() << std::endl;\n\n    std::shared_ptr<int> sp2(sp1);\n    std::cout << \"sp1.unique() == \" << std::boolalpha\n        << sp1.unique() << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \nsp1.unique() == true  \nsp1.unique() == false  \n```  \n  \n##  <a name=\"shared_ptr__use_count\"></a>  shared_ptr::use_count  \n Counts numbers of resource owners.  \n  \n```  \nlong use_count() const;\n```  \n  \n### Remarks  \n The member function returns the number of `shared_ptr` objects that own the resource that is owned by `*this`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__shared_ptr_use_count.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nint main()\n{\n    std::shared_ptr<int> sp1(new int(5));\n    std::cout << \"sp1.use_count() == \"\n        << sp1.use_count() << std::endl;\n\n    std::shared_ptr<int> sp2(sp1);\n    std::cout << \"sp1.use_count() == \"\n        << sp1.use_count() << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \nsp1.use_count() == 1  \nsp1.use_count() == 2  \n```  \n  \n## See Also  \n [weak_ptr Class](../standard-library/weak-ptr-class.md)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)\n\n\n\n\n"}