{"nodes":[{"pos":[12,51],"content":"2.6.4 atomic Construct | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"2.6.4 atomic Construct | Microsoft Docs","pos":[0,39]}]},{"content":"2.6.4 atomic Construct","pos":[531,553]},{"content":"The <ph id=\"ph1\">`atomic`</ph> directive ensures that a specific memory location is updated atomically, rather than exposing it to the possibility of multiple, simultaneous writing threads.","pos":[554,725],"source":"The `atomic` directive ensures that a specific memory location is updated atomically, rather than exposing it to the possibility of multiple, simultaneous writing threads."},{"content":"The syntax of the <ph id=\"ph1\">`atomic`</ph> directive is as follows:","pos":[726,777],"source":" The syntax of the `atomic` directive is as follows:"},{"content":"The expression statement must have one of the following forms:","pos":[844,906]},{"pos":[913,930],"content":"<bpt id=\"p1\">*</bpt>x binop<ept id=\"p1\">*</ept><ph id=\"ph1\">= </ph><bpt id=\"p2\">*</bpt>expr<ept id=\"p2\">*</ept>","source":"*x binop*= *expr*"},{"content":"x++","pos":[937,940]},{"content":"++x","pos":[947,950]},{"content":"x--","pos":[957,960]},{"content":"--x","pos":[967,970]},{"content":"In the preceding expressions:","pos":[977,1006]},{"pos":[1016,1061],"content":"<bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> is an lvalue expression with scalar type.","source":"*x* is an lvalue expression with scalar type."},{"pos":[1071,1168],"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an expression with scalar type, and it does not reference the object designated by <bpt id=\"p2\">*</bpt>x<ept id=\"p2\">*</ept>.","source":"*expr* is an expression with scalar type, and it does not reference the object designated by *x*."},{"pos":[1186,1270],"content":"is not an overloaded operator and is one of  +, *, -, /, &amp;, ^, &amp;#124;, &lt;<ph id=\"ph1\">\\&lt;</ph>, or   &gt;&gt;.","source":" is not an overloaded operator and is one of  +, *, -, /, &, ^, &#124;, <\\<, or   >>."},{"content":"Although it is implementation-defined whether an implementation replaces all <ph id=\"ph1\">`atomic`</ph> directives with <bpt id=\"p1\">**</bpt>critical<ept id=\"p1\">**</ept> directives that have the same unique <bpt id=\"p2\">*</bpt>name<ept id=\"p2\">*</ept>, the <ph id=\"ph2\">`atomic`</ph> directive permits better optimization.","pos":[1277,1488],"source":"Although it is implementation-defined whether an implementation replaces all `atomic` directives with **critical** directives that have the same unique *name*, the `atomic` directive permits better optimization."},{"content":"Often hardware instructions are available that can perform the atomic update with the least overhead.","pos":[1489,1590]},{"content":"Only the load and store of the object designated by <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> are atomic; the evaluation of <bpt id=\"p2\">*</bpt>expr<ept id=\"p2\">*</ept> is not atomic.","pos":[1597,1704],"source":"Only the load and store of the object designated by *x* are atomic; the evaluation of *expr* is not atomic."},{"content":"To avoid race conditions, all updates of the location in parallel should be protected with the <ph id=\"ph1\">`atomic`</ph> directive, except those that are known to be free of race conditions.","pos":[1705,1878],"source":" To avoid race conditions, all updates of the location in parallel should be protected with the `atomic` directive, except those that are known to be free of race conditions."},{"pos":[1885,1939],"content":"Restrictions to the <ph id=\"ph1\">`atomic`</ph> directive are as follows:","source":"Restrictions to the `atomic` directive are as follows:"},{"content":"All atomic references to the storage location x throughout the program are required to have a compatible type.","pos":[1949,2059]},{"content":"Examples:","pos":[2068,2077]}],"content":"---\ntitle: \"2.6.4 atomic Construct | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: e4232ef1-4058-42ce-9de0-0ca788312aba\ncaps.latest.revision: 6\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# 2.6.4 atomic Construct\nThe `atomic` directive ensures that a specific memory location is updated atomically, rather than exposing it to the possibility of multiple, simultaneous writing threads. The syntax of the `atomic` directive is as follows:  \n  \n```  \n#pragma omp atomic new-lineexpression-stmt  \n```  \n  \n The expression statement must have one of the following forms:  \n  \n *x binop*= *expr*  \n  \n x++  \n  \n ++x  \n  \n x--  \n  \n --x  \n  \n In the preceding expressions:  \n  \n-   *x* is an lvalue expression with scalar type.  \n  \n-   *expr* is an expression with scalar type, and it does not reference the object designated by *x*.  \n  \n-   `binop` is not an overloaded operator and is one of  +, *, -, /, &, ^, &#124;, <\\<, or   >>.  \n  \n Although it is implementation-defined whether an implementation replaces all `atomic` directives with **critical** directives that have the same unique *name*, the `atomic` directive permits better optimization. Often hardware instructions are available that can perform the atomic update with the least overhead.  \n  \n Only the load and store of the object designated by *x* are atomic; the evaluation of *expr* is not atomic. To avoid race conditions, all updates of the location in parallel should be protected with the `atomic` directive, except those that are known to be free of race conditions.  \n  \n Restrictions to the `atomic` directive are as follows:  \n  \n-   All atomic references to the storage location x throughout the program are required to have a compatible type.  \n  \n## Examples:  \n  \n```  \nextern float a[], *p = a, b;  \n/* Protect against races among multiple updates. */  \n#pragma omp atomic  \na[index[i]] += b;  \n/* Protect against races with updates through a. */  \n#pragma omp atomic  \np[i] -= 1.0f;  \n  \nextern union {int n; float x;} u;  \n/* ERROR - References through incompatible types. */  \n#pragma omp atomic  \nu.n++;  \n#pragma omp atomic  \nu.x -= 1.0f;  \n```"}