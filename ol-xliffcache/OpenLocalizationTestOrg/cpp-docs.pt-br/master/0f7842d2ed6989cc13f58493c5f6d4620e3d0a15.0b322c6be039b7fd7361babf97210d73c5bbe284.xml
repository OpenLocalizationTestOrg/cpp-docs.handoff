{"nodes":[{"pos":[12,44],"content":"constexpr (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"constexpr (C++) | Microsoft Docs","pos":[0,32]}]},{"content":"constexpr (C++)","pos":[585,600]},{"content":"The keyword <ph id=\"ph1\">`constexpr`</ph> was introduced in C++11 and improved in C++14.","pos":[601,671],"source":"The keyword `constexpr` was introduced in C++11 and improved in C++14."},{"content":"It means <bpt id=\"p1\">*</bpt>constant expression<ept id=\"p1\">*</ept>.","pos":[672,703],"source":" It means *constant expression*."},{"content":"Like <ph id=\"ph1\">`const`</ph>, it can be applied to variables so that a compiler error will be raised if any code attempts to modify the value.","pos":[704,830],"source":" Like `const`, it can be applied to variables so that a compiler error will be raised if any code attempts to modify the value."},{"content":"Unlike <ph id=\"ph1\">`const`</ph>, <ph id=\"ph2\">`constexpr`</ph> can also be applied to functions and class constructors.","pos":[831,915],"source":" Unlike `const`, `constexpr` can also be applied to functions and class constructors."},{"content":"indicates that the value, or return value, is constant and, if possible, will be computed at compile time.","pos":[928,1034]},{"content":"A <ph id=\"ph1\">`constexpr`</ph> integral value can be used wherever a const integer is required, such as in template arguments and array declarations.","pos":[1036,1168],"source":"  A `constexpr` integral value can be used wherever a const integer is required, such as in template arguments and array declarations."},{"content":"And when a value can be computed at compile time instead of run time, it can help your program can run faster and use less memory.","pos":[1169,1299]},{"content":"Syntax","pos":[1308,1314]},{"content":"Parameters","pos":[1531,1541]},{"content":"One or more parameters which must be a literal type (as listed below) and must itself be a constant expression.","pos":[1557,1668]},{"content":"Return Value","pos":[1677,1689]},{"content":"A constexpr variable or function must return one of the literal types, as listed below.","pos":[1693,1780]},{"content":"Literal types","pos":[1789,1802]},{"content":"To limit the complexity of computing compile time constants, and their potential impacts of compilation time, the C++14 standard requires that the types involved in constant expressions be restricted to literal types.","pos":[1806,2023]},{"content":"A literal type is one whose layout can be determined at compile time.","pos":[2024,2093]},{"content":"The following are the literal types:","pos":[2094,2130]},{"content":"void","pos":[2140,2144]},{"content":"scalar types","pos":[2154,2166]},{"content":"references","pos":[2176,2186]},{"content":"Arrays of void, scalar types or references","pos":[2196,2238]},{"content":"A class that has a trivial destructor, and one or more constexpr constructors that are not move or copy constructors.","pos":[2248,2365]},{"content":"Additionally, all its non-static data members and base classes must be literal types and not volatile.","pos":[2366,2468]},{"content":"constexpr variables","pos":[2477,2496]},{"content":"The primary difference between const and constexpr variables is that the initialization of a const variable can be deferred until run time whereas a constexpr variable must be initialized at compile time.","pos":[2500,2704]},{"content":"All constexpr variables are const.","pos":[2706,2740]},{"content":"constexpr functions","pos":[2973,2992]},{"content":"A <ph id=\"ph1\">`constexpr`</ph> function is one whose return value can be computed at compile when consuming code requires it.","pos":[2996,3104],"source":"A `constexpr` function is one whose return value can be computed at compile when consuming code requires it."},{"content":"A <ph id=\"ph1\">`constexpr`</ph> function must accept and return only literal types.","pos":[3106,3171],"source":"  A `constexpr` function must accept and return only literal types."},{"content":"When its arguments are <ph id=\"ph1\">`constexpr`</ph> values, and consuming code requires the return value at compile time, for example to initialize a <ph id=\"ph2\">`constexpr`</ph> variable or provide a non-type template argument, it produces a compile-time constant.","pos":[3172,3403],"source":" When its arguments are `constexpr` values, and consuming code requires the return value at compile time, for example to initialize a `constexpr` variable or provide a non-type template argument, it produces a compile-time constant."},{"content":"When called with non-<ph id=\"ph1\">`constexpr`</ph> arguments, or when its value is not required at compile-time, it produces a value at run time like a regular function.","pos":[3404,3555],"source":" When called with non-`constexpr` arguments, or when its value is not required at compile-time, it produces a value at run time like a regular function."},{"content":"(This dual behavior saves you from having to write <ph id=\"ph1\">`constexpr`</ph> and non-<ph id=\"ph2\">`constexpr`</ph> versions of the same function.)","pos":[3557,3671],"source":"  (This dual behavior saves you from having to write `constexpr` and non-`constexpr` versions of the same function.)"},{"pos":[3849,4127],"content":"[!TIP]\n Note: In the Visual Studio debugger, you can tell whether a `constexpr` function is being evaluated at compile time by putting a breakpoint inside it. If the breakpoint is hit, the function was called at run-time.  If not, then the function was called at compile time.","leadings":["","> "],"nodes":[{"content":" Note: In the Visual Studio debugger, you can tell whether a `constexpr` function is being evaluated at compile time by putting a breakpoint inside it. If the breakpoint is hit, the function was called at run-time.  If not, then the function was called at compile time.","pos":[7,276],"nodes":[{"content":"Note: In the Visual Studio debugger, you can tell whether a <ph id=\"ph1\">`constexpr`</ph> function is being evaluated at compile time by putting a breakpoint inside it.","pos":[1,151],"source":" Note: In the Visual Studio debugger, you can tell whether a `constexpr` function is being evaluated at compile time by putting a breakpoint inside it."},{"content":"If the breakpoint is hit, the function was called at run-time.","pos":[152,214]},{"content":"If not, then the function was called at compile time.","pos":[216,269]}]}]},{"content":"General constexpr rules","pos":[4136,4159]},{"pos":[4163,4287],"content":"For a function, variable, constructor or static data member to be defined as <ph id=\"ph1\">`constexpr`</ph>, it must meet certain requirements:","source":"For a function, variable, constructor or static data member to be defined as `constexpr`, it must meet certain requirements:"},{"content":"A <ph id=\"ph1\">`constexpr`</ph> function can be recursive.","pos":[4297,4337],"source":"A `constexpr` function can be recursive."},{"content":"It cannot be <bpt id=\"p1\">[</bpt>virtual<ept id=\"p1\">](../cpp/virtual-cpp.md)</ept>, and its return type and parameter types must all be literal types.","pos":[4338,4451],"source":" It cannot be [virtual](../cpp/virtual-cpp.md), and its return type and parameter types must all be literal types."},{"content":"The body can be defined as <ph id=\"ph1\">`= default`</ph> or <ph id=\"ph2\">`= delete`</ph>.","pos":[4452,4505],"source":" The body can be defined as `= default` or `= delete`."},{"content":"Otherwise it must follow these rules: it contains no <ph id=\"ph1\">`goto`</ph> statements, try blocks, unitialized variables, or variable definitions that are not literal types, or that are static or thread-local.","pos":[4506,4700],"source":" Otherwise it must follow these rules: it contains no `goto` statements, try blocks, unitialized variables, or variable definitions that are not literal types, or that are static or thread-local."},{"content":"Additionally, a constructor cannot be defined as constexpr if the enclosing class has any virtual base classes.","pos":[4701,4812]},{"content":"A variable can be declared with <ph id=\"ph1\">`constexpr`</ph>, if it has a literal type and is initialized.","pos":[4822,4911],"source":"A variable can be declared with `constexpr`, if it has a literal type and is initialized."},{"content":"If the initialization is performed by a constructor, the constructor must be declared as <ph id=\"ph1\">`constexpr`</ph>.","pos":[4912,5013],"source":" If the initialization is performed by a constructor, the constructor must be declared as `constexpr`."},{"content":"A reference may be declared as constexpr if the object that it references has been initialized by a constant expression and any implicit conversions that are invoked during initialization are also constant expressions.","pos":[5023,5241]},{"pos":[5251,5342],"content":"All declarations of a <ph id=\"ph1\">`constexpr`</ph> variable or function must have the <ph id=\"ph2\">`constexpr`</ph> specifier.","source":"All declarations of a `constexpr` variable or function must have the `constexpr` specifier."},{"pos":[5352,5438],"content":"An explicit specialization of a non-constexpr template can be declared as <ph id=\"ph1\">`constexpr`</ph>:","source":"An explicit specialization of a non-constexpr template can be declared as `constexpr`:"},{"pos":[5448,5538],"content":"An explicit specialization of a <ph id=\"ph1\">`constexpr`</ph> template does not have to also be <ph id=\"ph2\">`constexpr`</ph>:","source":"An explicit specialization of a `constexpr` template does not have to also be `constexpr`:"},{"pos":[5548,5609],"content":"A <ph id=\"ph1\">`constexpr`</ph> function or constructor is implicitly <ph id=\"ph2\">`inline`</ph>.","source":"A `constexpr` function or constructor is implicitly `inline`."},{"content":"Example","pos":[5618,5625]},{"content":"The following example shows <ph id=\"ph1\">`constexpr`</ph> variables, functions and a user-defined type.","pos":[5629,5714],"source":"The following example shows `constexpr` variables, functions and a user-defined type."},{"content":"Note that in the last statement in main(), the <ph id=\"ph1\">`constexpr`</ph> member function GetValue() is a run-time call because the value is not required to be known at compile time.","pos":[5715,5882],"source":" Note that in the last statement in main(), the `constexpr` member function GetValue() is a run-time call because the value is not required to be known at compile time."},{"content":"Requirements","pos":[7274,7286]},{"content":"Visual Studio 2015","pos":[7290,7308]},{"content":"See Also","pos":[7317,7325]},{"content":"Declarations and Definitions","pos":[7330,7358]},{"content":"const","pos":[7409,7414]}],"content":"---\ntitle: \"constexpr (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"constexpr\"\n  - \"constexpr_cpp\"\ndev_langs: \n  - \"C++\"\nms.assetid: c6458ccb-51c6-4a16-aa61-f69e6f4e04f7\ncaps.latest.revision: 3\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# constexpr (C++)\nThe keyword `constexpr` was introduced in C++11 and improved in C++14. It means *constant expression*. Like `const`, it can be applied to variables so that a compiler error will be raised if any code attempts to modify the value. Unlike `const`, `constexpr` can also be applied to functions and class constructors. `constexpr` indicates that the value, or return value, is constant and, if possible, will be computed at compile time.  A `constexpr` integral value can be used wherever a const integer is required, such as in template arguments and array declarations. And when a value can be computed at compile time instead of run time, it can help your program can run faster and use less memory.  \n  \n## Syntax  \n  \n```cpp  \nconstexpr  literal-type  identifier = constant-expression;constexpr  literal-type  identifier { constant-expression };constexpr literal-type identifier(params );constexpr ctor (params);  \n```  \n  \n#### Parameters  \n `params`  \n One or more parameters which must be a literal type (as listed below) and must itself be a constant expression.  \n  \n## Return Value  \n A constexpr variable or function must return one of the literal types, as listed below.  \n  \n## Literal types  \n To limit the complexity of computing compile time constants, and their potential impacts of compilation time, the C++14 standard requires that the types involved in constant expressions be restricted to literal types. A literal type is one whose layout can be determined at compile time. The following are the literal types:  \n  \n1.  void  \n  \n2.  scalar types  \n  \n3.  references  \n  \n4.  Arrays of void, scalar types or references  \n  \n5.  A class that has a trivial destructor, and one or more constexpr constructors that are not move or copy constructors. Additionally, all its non-static data members and base classes must be literal types and not volatile.  \n  \n## constexpr variables  \n The primary difference between const and constexpr variables is that the initialization of a const variable can be deferred until run time whereas a constexpr variable must be initialized at compile time.  All constexpr variables are const.  \n  \n```  \nconstexpr float x = 42.0;  \nconstexpr float y{108};  \nconstexpr float z = exp(5, 3);  \nconstexpr int i; // Error! Not initialized  \nint j = 0;  \nconstexpr int k = j + 1; //Error! j not a constant expression  \n```  \n  \n## constexpr functions  \n A `constexpr` function is one whose return value can be computed at compile when consuming code requires it.  A `constexpr` function must accept and return only literal types. When its arguments are `constexpr` values, and consuming code requires the return value at compile time, for example to initialize a `constexpr` variable or provide a non-type template argument, it produces a compile-time constant. When called with non-`constexpr` arguments, or when its value is not required at compile-time, it produces a value at run time like a regular function.  (This dual behavior saves you from having to write `constexpr` and non-`constexpr` versions of the same function.)  \n  \n```  \nconstexpr float exp(float x, int n)  \n{  \n    return n == 0 ? 1 :  \n        n % 2 == 0 ? exp(x * x, n / 2) :  \n        exp(x * x, (n - 1) / 2) * x;  \n};  \n```  \n  \n> [!TIP]\n>  Note: In the Visual Studio debugger, you can tell whether a `constexpr` function is being evaluated at compile time by putting a breakpoint inside it. If the breakpoint is hit, the function was called at run-time.  If not, then the function was called at compile time.  \n  \n## General constexpr rules  \n For a function, variable, constructor or static data member to be defined as `constexpr`, it must meet certain requirements:  \n  \n-   A `constexpr` function can be recursive. It cannot be [virtual](../cpp/virtual-cpp.md), and its return type and parameter types must all be literal types. The body can be defined as `= default` or `= delete`. Otherwise it must follow these rules: it contains no `goto` statements, try blocks, unitialized variables, or variable definitions that are not literal types, or that are static or thread-local. Additionally, a constructor cannot be defined as constexpr if the enclosing class has any virtual base classes.  \n  \n-   A variable can be declared with `constexpr`, if it has a literal type and is initialized. If the initialization is performed by a constructor, the constructor must be declared as `constexpr`.  \n  \n-   A reference may be declared as constexpr if the object that it references has been initialized by a constant expression and any implicit conversions that are invoked during initialization are also constant expressions.  \n  \n-   All declarations of a `constexpr` variable or function must have the `constexpr` specifier.  \n  \n-   An explicit specialization of a non-constexpr template can be declared as `constexpr`:  \n  \n-   An explicit specialization of a `constexpr` template does not have to also be `constexpr`:  \n  \n-   A `constexpr` function or constructor is implicitly `inline`.  \n  \n## Example  \n The following example shows `constexpr` variables, functions and a user-defined type. Note that in the last statement in main(), the `constexpr` member function GetValue() is a run-time call because the value is not required to be known at compile time.  \n  \n```  \n#include <iostream>  \n  \nusing namespace std;  \n  \n// Pass by value   \nconstexpr float exp(float x, int n)  \n{  \n    return n == 0 ? 1 :  \n        n % 2 == 0 ? exp(x * x, n / 2) :  \n        exp(x * x, (n - 1) / 2) * x;  \n};  \n  \n// Pass by reference  \nconstexpr float exp2(const float& x, const int& n)  \n{  \n    return n == 0 ? 1 :  \n        n % 2 == 0 ? exp2(x * x, n / 2) :  \n        exp2(x * x, (n - 1) / 2) * x;  \n};  \n  \n// Compile time computation of array length  \ntemplate<typename T, int N>  \nconstexpr int length(const T(&ary)[N])   \n{   \n    return N;   \n}   \n  \n// Recursive constexpr function  \nconstexpr int fac(int n)  \n{   \n    return n == 1 ? 1 : n*fac(n - 1);   \n}  \n  \n// User-defined type  \nclass Foo  \n{  \npublic:  \n    constexpr explicit Foo(int i) : _i(i) {}  \n    constexpr int GetValue()  \n    {  \n        return _i;  \n    }  \nprivate:  \n    int _i;  \n};  \n  \nint main()  \n{  \n    //foo is const:  \n    constexpr Foo foo(5);   \n    // foo = Foo(6); //Error!  \n  \n    //Compile time:  \n    constexpr float x = exp(5, 3);   \n    constexpr float y { exp(2, 5) };  \n    constexpr int val = foo.GetValue();   \n    constexpr int f5 = fac(5);  \n    const int nums[] { 1, 2, 3, 4 };  \n    const int nums2[length(nums) * 2] { 1, 2, 3, 4, 5, 6, 7, 8 };  \n  \n    //Run time:   \n    cout << \"The value of foo is \" << foo.GetValue() << endl;   \n  \n}  \n  \n```  \n  \n## Requirements  \n Visual Studio 2015  \n  \n## See Also  \n [Declarations and Definitions](../cpp/declarations-and-definitions-cpp.md)   \n [const](../cpp/constexpr-cpp.md)"}