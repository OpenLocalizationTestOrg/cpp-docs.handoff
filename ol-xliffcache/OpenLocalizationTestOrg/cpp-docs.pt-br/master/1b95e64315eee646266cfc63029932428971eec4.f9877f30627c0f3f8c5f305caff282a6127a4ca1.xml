{"nodes":[{"pos":[12,71],"content":"Name Resolution for Locally Declared Names | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Name Resolution for Locally Declared Names | Microsoft Docs","pos":[0,59]}]},{"content":"Name Resolution for Locally Declared Names","pos":[563,605]},{"content":"The template's name itself can be referred to with or without the template arguments.","pos":[606,691]},{"content":"In the scope of a class template, the name itself refers to the template.","pos":[692,765]},{"content":"In the scope of a template specialization or partial specialization, the name alone refers to the specialization or partial specialization.","pos":[766,905]},{"content":"Other specializations or partial specializations of the template can also be referenced, with the appropriate template arguments.","pos":[906,1035]},{"content":"Example","pos":[1044,1051]},{"content":"The following code shows that the class template's name A is interpreted differently in the scope of a specialization or partial specialization.","pos":[1055,1199]},{"content":"Example","pos":[1630,1637]},{"content":"In the case of a name conflict between a template parameter and another object, the template parameter can or cannot be hidden.","pos":[1641,1768]},{"content":"The following rules will help determine precedence.","pos":[1769,1820]},{"content":"The template parameter is in scope from the point where it first appears until the end of the class or function template.","pos":[1827,1948]},{"content":"If the name appears again in the template argument list or in the list of base classes, it refers to the same type.","pos":[1949,2064]},{"content":"In standard C++, no other name that is identical to the template parameter can be declared in the same scope.","pos":[2065,2174]},{"content":"A Microsoft extension allows the template parameter to be redefined in the scope of the template.","pos":[2175,2272]},{"content":"The following example shows using the template parameter in the base specification of a class template.","pos":[2273,2376]},{"content":"Example","pos":[2602,2609]},{"content":"When defining a template's member functions outside the class template, a different template parameter name can be used.","pos":[2613,2733]},{"content":"If the template member function definition uses a different name for the template parameter than the declaration does, and the name used in the definition conflicts with another member of the declaration, the member in the template declaration takes precedence.","pos":[2734,2995]},{"content":"Example","pos":[3513,3520]},{"content":"When defining a template function or member function outside the namespace in which the template was declared, the template argument takes precedence over the names of other members of the namespace.","pos":[3524,3723]},{"content":"Example","pos":[4200,4207]},{"content":"In definitions that are outside of the template class declaration, if a template class has a base class that does not depend on a template argument and if the base class or one of its members has the same name as a template argument, then the base class or member name hides the template argument.","pos":[4211,4508]},{"content":"See Also","pos":[5064,5072]},{"content":"Name Resolution","pos":[5077,5092]}],"content":"---\ntitle: \"Name Resolution for Locally Declared Names | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nms.assetid: 743b88f3-de11-48f4-ae83-931449ea3886\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Name Resolution for Locally Declared Names\nThe template's name itself can be referred to with or without the template arguments. In the scope of a class template, the name itself refers to the template. In the scope of a template specialization or partial specialization, the name alone refers to the specialization or partial specialization. Other specializations or partial specializations of the template can also be referenced, with the appropriate template arguments.  \n  \n## Example  \n The following code shows that the class template's name A is interpreted differently in the scope of a specialization or partial specialization.  \n  \n```  \n// template_name_resolution3.cpp  \n// compile with: /c  \ntemplate <class T> class A {  \n   A* a1;   // A refers to A<T>  \n   A<int>* a2;  // A<int> refers to a specialization of A.  \n   A<T*>* a3;   // A<T*> refers to the partial specialization A<T*>.  \n};  \n  \ntemplate <class T> class A<T*> {  \n   A* a4; // A refers to A<T*>.  \n};  \n  \ntemplate<> class A<int> {  \n   A* a5; // A refers to A<int>.  \n};  \n```  \n  \n## Example  \n In the case of a name conflict between a template parameter and another object, the template parameter can or cannot be hidden. The following rules will help determine precedence.  \n  \n The template parameter is in scope from the point where it first appears until the end of the class or function template. If the name appears again in the template argument list or in the list of base classes, it refers to the same type. In standard C++, no other name that is identical to the template parameter can be declared in the same scope. A Microsoft extension allows the template parameter to be redefined in the scope of the template. The following example shows using the template parameter in the base specification of a class template.  \n  \n```  \n// template_name_resolution4.cpp  \n// compile with: /EHsc  \ntemplate <class T>  \nclass Base1 {};  \n  \ntemplate <class T>  \nclass Derived1 : Base1<T> {};  \n  \nint main() {  \n   // Derived1<int> d;  \n}  \n```  \n  \n## Example  \n When defining a template's member functions outside the class template, a different template parameter name can be used. If the template member function definition uses a different name for the template parameter than the declaration does, and the name used in the definition conflicts with another member of the declaration, the member in the template declaration takes precedence.  \n  \n```  \n// template_name_resolution5.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \ntemplate <class T> class C {  \npublic:  \n   struct Z {  \n      Z() { cout << \"Z::Z()\" << endl; }  \n   };  \n   void f();  \n};  \n  \ntemplate <class Z>  \nvoid C<Z>::f() {  \n   // Z refers to the struct Z, not to the template arg;  \n   // Therefore, the constructor for struct Z will be called.  \n   Z z;  \n}  \n  \nint main() {  \n   C<int> c;  \n   c.f();  \n}  \n```  \n  \n```Output  \nZ::Z()  \n```  \n  \n## Example  \n When defining a template function or member function outside the namespace in which the template was declared, the template argument takes precedence over the names of other members of the namespace.  \n  \n```  \n// template_name_resolution6.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \nnamespace NS {  \n   void g() { cout << \"NS::g\" << endl; }  \n  \n   template <class T> struct C {  \n      void f();  \n      void g() { cout << \"C<T>::g\" << endl; }  \n   };  \n};  \n  \ntemplate <class T>  \nvoid NS::C<T>::f() {  \n   g(); // C<T>::g, not NS::g  \n};  \n  \nint main() {  \n   NS::C<int> c;  \n   c.f();  \n}  \n```  \n  \n```Output  \nC<T>::g  \n```  \n  \n## Example  \n In definitions that are outside of the template class declaration, if a template class has a base class that does not depend on a template argument and if the base class or one of its members has the same name as a template argument, then the base class or member name hides the template argument.  \n  \n```  \n// template_name_resolution7.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \nstruct B {  \n   int i;  \n   void print() { cout << \"Base\" << endl; }  \n};  \n  \ntemplate <class T, int i> struct C : public B {  \n   void f();  \n};  \n  \ntemplate <class B, int i>  \nvoid C<B, i>::f() {  \n   B b;   // Base class b, not template argument.  \n   b.print();  \n   i = 1; // Set base class's i to 1.  \n}  \n  \nint main() {  \n   C<int, 1> c;  \n   c.f();  \n   cout << c.i << endl;  \n}  \n```  \n  \n```Output  \nBase  \n1  \n```  \n  \n## See Also  \n [Name Resolution](../cpp/templates-and-name-resolution.md)"}