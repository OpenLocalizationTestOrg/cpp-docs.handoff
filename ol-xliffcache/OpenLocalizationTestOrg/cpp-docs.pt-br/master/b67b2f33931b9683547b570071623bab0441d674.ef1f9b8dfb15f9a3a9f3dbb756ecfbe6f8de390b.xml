{"nodes":[{"pos":[12,67],"content":"How to: Migrate to -clr:pure (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Migrate to -clr:pure (C++-CLI) | Microsoft Docs","pos":[0,55]}]},{"content":"How to: Migrate to /clr:pure (C++/CLI)","pos":[694,732]},{"content":"This topic discusses issues likely to arise when migrating to pure MSIL using <bpt id=\"p1\">**</bpt>/clr:pure<ept id=\"p1\">**</ept> (see <bpt id=\"p2\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p2\">](../build/reference/clr-common-language-runtime-compilation.md)</ept> for more information).","pos":[733,960],"source":"This topic discusses issues likely to arise when migrating to pure MSIL using **/clr:pure** (see [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md) for more information)."},{"content":"This topic assumes that the code being migrated is currently complied as mixed assembly using the <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> option, as the migration path from unmanaged code to pure MSIL is not a direct one.","pos":[961,1151],"source":" This topic assumes that the code being migrated is currently complied as mixed assembly using the **/clr** option, as the migration path from unmanaged code to pure MSIL is not a direct one."},{"content":"For unmanaged code, see <bpt id=\"p1\">[</bpt>How to: Migrate to /clr<ept id=\"p1\">](../dotnet/how-to-migrate-to-clr.md)</ept> before attempting to migrate to pure MSIL.","pos":[1152,1280],"source":" For unmanaged code, see [How to: Migrate to /clr](../dotnet/how-to-migrate-to-clr.md) before attempting to migrate to pure MSIL."},{"content":"Basic Changes","pos":[1289,1302]},{"content":"Pure MSIL is comprised of MSIL instructions, so code containing functions that cannot be expressed in MSIL will prevent compilation.","pos":[1306,1438]},{"content":"This includes functions defined as using calling conventions other than <bpt id=\"p1\">[</bpt>__clrcall<ept id=\"p1\">](../cpp/clrcall.md)</ept>.","pos":[1439,1542],"source":" This includes functions defined as using calling conventions other than [__clrcall](../cpp/clrcall.md)."},{"content":"(Non __clrcall functions can be invoked in a pure MSIL component, but not defined.)","pos":[1543,1626]},{"content":"To ensure no runtime errors, you should enable the C4412 warning.","pos":[1633,1698]},{"content":"Enable C4412 by adding <ph id=\"ph1\">`#pragma warning (default : 4412)`</ph> to each compiland that you compile with <bpt id=\"p1\">**</bpt>/clr:pure<ept id=\"p1\">**</ept> and that passes C++ types to and from IJW (<bpt id=\"p2\">**</bpt>/clr)<ept id=\"p2\">**</ept> or native code.","pos":[1699,1879],"source":" Enable C4412 by adding `#pragma warning (default : 4412)` to each compiland that you compile with **/clr:pure** and that passes C++ types to and from IJW (**/clr)** or native code."},{"content":"See <bpt id=\"p1\">[</bpt>Compiler Warning (level 2) C4412<ept id=\"p1\">](../error-messages/compiler-warnings/compiler-warning-level-2-c4412.md)</ept> for more information.","pos":[1880,2011],"source":" See [Compiler Warning (level 2) C4412](../error-messages/compiler-warnings/compiler-warning-level-2-c4412.md) for more information."},{"content":"Architectural Considerations","pos":[2020,2048]},{"content":"Some of the limitations of pure MSIL assemblies listed in <bpt id=\"p1\">[</bpt>Pure and Verifiable Code (C++/CLI)<ept id=\"p1\">](../dotnet/pure-and-verifiable-code-cpp-cli.md)</ept> have high-level implications for application design and migration strategy.","pos":[2052,2269],"source":"Some of the limitations of pure MSIL assemblies listed in [Pure and Verifiable Code (C++/CLI)](../dotnet/pure-and-verifiable-code-cpp-cli.md) have high-level implications for application design and migration strategy."},{"content":"Most notably, unlike mixed assemblies, pure MSIL assemblies don't enjoy full compatibility with unmanaged modules.","pos":[2270,2384]},{"content":"Pure MSIL assemblies can call unmanaged functions, but cannot be called by unmanaged functions.","pos":[2391,2486]},{"content":"As a result, pure MSIL is a better candidate for client code that uses unmanaged functions than it is for server code that is used by unmanaged functions.","pos":[2487,2641]},{"content":"If functionality contained in a pure MSIL assembly is to be used by unmanaged functions, a mixed assembly must be used as an interface layer.","pos":[2642,2783]},{"content":"Applications that use ATL or MFC are not good candidates for migration to pure MSIL, as these libraries are not supported in this release.","pos":[2790,2928]},{"content":"Likewise, the <ph id=\"ph1\">[!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]</ph> contains header files that do not compile under <bpt id=\"p1\">**</bpt>/clr:pure<ept id=\"p1\">**</ept>.","pos":[2929,3085],"source":" Likewise, the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)] contains header files that do not compile under **/clr:pure**."},{"content":"While pure MSIL assemblies can call unmanaged functions, this ability is limited to simple C-style functions.","pos":[3092,3201]},{"content":"The use of more complex unmanaged APIs is likely to require the unmanaged functionality to be exposed in the form of a COM interface, or a mixed assembly that can act as an interface between the pure MSIL and unmanaged components.","pos":[3202,3432]},{"content":"Using a mixed assembly layer is the only way to use unmanaged functions that take callback functions, for example, as a pure assembly is unable to provide a native callable function for use as a callback.","pos":[3433,3637]},{"content":"Application Domains and Calling Conventions","pos":[3646,3689]},{"content":"Although it is possible for pure MSIL assemblies use unmanaged functionality, functions and static data are handled differently.","pos":[3693,3821]},{"content":"In pure assemblies, functions are implemented with the <bpt id=\"p1\">[</bpt>__clrcall<ept id=\"p1\">](../cpp/clrcall.md)</ept> calling convention, and static data is stored per-application domain.","pos":[3822,3977],"source":" In pure assemblies, functions are implemented with the [__clrcall](../cpp/clrcall.md) calling convention, and static data is stored per-application domain."},{"content":"This differs from the default for unmanaged and mixed assemblies, which use the <bpt id=\"p1\">[</bpt>__cdecl<ept id=\"p1\">](../cpp/cdecl.md)</ept> calling convention for functions and store static data on a per-process basis.","pos":[3978,4163],"source":" This differs from the default for unmanaged and mixed assemblies, which use the [__cdecl](../cpp/cdecl.md) calling convention for functions and store static data on a per-process basis."},{"content":"Within the context of pure MSIL (and verifiable code compiled with /clr:safe) these defaults are transparent, as <bpt id=\"p1\">[</bpt>__clrcall<ept id=\"p1\">](../cpp/clrcall.md)</ept> is the default calling convention of the CLR, and application domains are the native scope for static and global data in .NET applications.","pos":[4170,4453],"source":"Within the context of pure MSIL (and verifiable code compiled with /clr:safe) these defaults are transparent, as [__clrcall](../cpp/clrcall.md) is the default calling convention of the CLR, and application domains are the native scope for static and global data in .NET applications."},{"content":"However, when interfacing with unmanaged or mixed components, the differing treatment of functions and global data can cause problems.","pos":[4454,4588]},{"content":"For example, if a pure MSIL component is to call functions in an unmanaged or mixed DLL, a header file for the DLL will be used to compile the pure assembly.","pos":[4595,4752]},{"content":"However, unless the calling convention for each function in the header is indicated explicitly, they will all be assumed to be <bpt id=\"p1\">[</bpt>__clrcall<ept id=\"p1\">](../cpp/clrcall.md)</ept>.","pos":[4753,4911],"source":" However, unless the calling convention for each function in the header is indicated explicitly, they will all be assumed to be [__clrcall](../cpp/clrcall.md)."},{"content":"This will later cause runtime failures, as these functions are likely implemented with the <bpt id=\"p1\">[</bpt>__cdecl<ept id=\"p1\">](../cpp/cdecl.md)</ept> convention.","pos":[4912,5041],"source":" This will later cause runtime failures, as these functions are likely implemented with the [__cdecl](../cpp/cdecl.md) convention."},{"content":"The functions in the unmanaged header file can be explicitly marked as <bpt id=\"p1\">[</bpt>__cdecl<ept id=\"p1\">](../cpp/cdecl.md)</ept>, or the entire DLL source code must be recompiled under <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept>.","pos":[5042,5210],"source":" The functions in the unmanaged header file can be explicitly marked as [__cdecl](../cpp/cdecl.md), or the entire DLL source code must be recompiled under **/clr:pure**."},{"content":"Similarly, function pointers are assumed to point to <bpt id=\"p1\">[</bpt>__clrcall<ept id=\"p1\">](../cpp/clrcall.md)</ept> functions under <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept> compilation.","pos":[5217,5343],"source":"Similarly, function pointers are assumed to point to [__clrcall](../cpp/clrcall.md) functions under **/clr:pure** compilation."},{"content":"These too must be explicitly annotated with the correct calling convention.","pos":[5344,5419]},{"pos":[5426,5538],"content":"For more information, see <bpt id=\"p1\">[</bpt>Application Domains and Visual C++<ept id=\"p1\">](../dotnet/application-domains-and-visual-cpp.md)</ept>.","source":"For more information, see [Application Domains and Visual C++](../dotnet/application-domains-and-visual-cpp.md)."},{"content":"Linking Limitations","pos":[5547,5566]},{"content":"The Visual C++ linker will not attempt to link mixed and pure OBJ files, as the storage scope and calling conventions are different.","pos":[5570,5702]},{"content":"See Also","pos":[5711,5719]},{"content":"Pure and Verifiable Code (C++/CLI)","pos":[5724,5758]}],"content":"---\ntitle: \"How to: Migrate to -clr:pure (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"/clr compiler option [C++], migrating to /clr:pure\"\n  - \"migration [C++], pure MSIL\"\n  - \"pure MSIL [C++], porting to\"\nms.assetid: 5ffb1184-2095-4ade-84aa-4fa6324bc764\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Migrate to /clr:pure (C++/CLI)\nThis topic discusses issues likely to arise when migrating to pure MSIL using **/clr:pure** (see [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md) for more information). This topic assumes that the code being migrated is currently complied as mixed assembly using the **/clr** option, as the migration path from unmanaged code to pure MSIL is not a direct one. For unmanaged code, see [How to: Migrate to /clr](../dotnet/how-to-migrate-to-clr.md) before attempting to migrate to pure MSIL.  \n  \n## Basic Changes  \n Pure MSIL is comprised of MSIL instructions, so code containing functions that cannot be expressed in MSIL will prevent compilation. This includes functions defined as using calling conventions other than [__clrcall](../cpp/clrcall.md). (Non __clrcall functions can be invoked in a pure MSIL component, but not defined.)  \n  \n To ensure no runtime errors, you should enable the C4412 warning. Enable C4412 by adding `#pragma warning (default : 4412)` to each compiland that you compile with **/clr:pure** and that passes C++ types to and from IJW (**/clr)** or native code. See [Compiler Warning (level 2) C4412](../error-messages/compiler-warnings/compiler-warning-level-2-c4412.md) for more information.  \n  \n## Architectural Considerations  \n Some of the limitations of pure MSIL assemblies listed in [Pure and Verifiable Code (C++/CLI)](../dotnet/pure-and-verifiable-code-cpp-cli.md) have high-level implications for application design and migration strategy. Most notably, unlike mixed assemblies, pure MSIL assemblies don't enjoy full compatibility with unmanaged modules.  \n  \n Pure MSIL assemblies can call unmanaged functions, but cannot be called by unmanaged functions. As a result, pure MSIL is a better candidate for client code that uses unmanaged functions than it is for server code that is used by unmanaged functions. If functionality contained in a pure MSIL assembly is to be used by unmanaged functions, a mixed assembly must be used as an interface layer.  \n  \n Applications that use ATL or MFC are not good candidates for migration to pure MSIL, as these libraries are not supported in this release. Likewise, the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)] contains header files that do not compile under **/clr:pure**.  \n  \n While pure MSIL assemblies can call unmanaged functions, this ability is limited to simple C-style functions. The use of more complex unmanaged APIs is likely to require the unmanaged functionality to be exposed in the form of a COM interface, or a mixed assembly that can act as an interface between the pure MSIL and unmanaged components. Using a mixed assembly layer is the only way to use unmanaged functions that take callback functions, for example, as a pure assembly is unable to provide a native callable function for use as a callback.  \n  \n## Application Domains and Calling Conventions  \n Although it is possible for pure MSIL assemblies use unmanaged functionality, functions and static data are handled differently. In pure assemblies, functions are implemented with the [__clrcall](../cpp/clrcall.md) calling convention, and static data is stored per-application domain. This differs from the default for unmanaged and mixed assemblies, which use the [__cdecl](../cpp/cdecl.md) calling convention for functions and store static data on a per-process basis.  \n  \n Within the context of pure MSIL (and verifiable code compiled with /clr:safe) these defaults are transparent, as [__clrcall](../cpp/clrcall.md) is the default calling convention of the CLR, and application domains are the native scope for static and global data in .NET applications. However, when interfacing with unmanaged or mixed components, the differing treatment of functions and global data can cause problems.  \n  \n For example, if a pure MSIL component is to call functions in an unmanaged or mixed DLL, a header file for the DLL will be used to compile the pure assembly. However, unless the calling convention for each function in the header is indicated explicitly, they will all be assumed to be [__clrcall](../cpp/clrcall.md). This will later cause runtime failures, as these functions are likely implemented with the [__cdecl](../cpp/cdecl.md) convention. The functions in the unmanaged header file can be explicitly marked as [__cdecl](../cpp/cdecl.md), or the entire DLL source code must be recompiled under **/clr:pure**.  \n  \n Similarly, function pointers are assumed to point to [__clrcall](../cpp/clrcall.md) functions under **/clr:pure** compilation. These too must be explicitly annotated with the correct calling convention.  \n  \n For more information, see [Application Domains and Visual C++](../dotnet/application-domains-and-visual-cpp.md).  \n  \n## Linking Limitations  \n The Visual C++ linker will not attempt to link mixed and pure OBJ files, as the storage scope and calling conventions are different.  \n  \n## See Also  \n [Pure and Verifiable Code (C++/CLI)](../dotnet/pure-and-verifiable-code-cpp-cli.md)"}