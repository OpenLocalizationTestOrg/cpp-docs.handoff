{"nodes":[{"pos":[12,49],"content":"Operator Overloading | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Operator Overloading | Microsoft Docs","pos":[0,37]}]},{"content":"Operator Overloading","pos":[762,782]},{"content":"The <ph id=\"ph1\">`operator`</ph> keyword declares a function specifying what <ph id=\"ph2\">`operator-symbol`</ph> means when applied to instances of a class.","pos":[783,903],"source":"The `operator` keyword declares a function specifying what `operator-symbol` means when applied to instances of a class."},{"content":"This gives the operator more than one meaning, or \"overloads\" it.","pos":[904,969]},{"content":"The compiler distinguishes between the different meanings of an operator by examining the types of its operands.","pos":[970,1082]},{"content":"Syntax","pos":[1091,1097]},{"content":"Remarks","pos":[1175,1182]},{"content":"You can redefine the function of most built-in operators globally or on a class-by-class basis.","pos":[1186,1281]},{"content":"Overloaded operators are implemented as functions.","pos":[1282,1332]},{"content":"The name of an overloaded operator is <ph id=\"ph1\">`operator``x`</ph>, where <ph id=\"ph2\">`x`</ph> is the operator as it appears in the following table.","pos":[1339,1455],"source":"The name of an overloaded operator is `operator``x`, where `x` is the operator as it appears in the following table."},{"content":"For example, to overload the addition operator, you define a function called <ph id=\"ph1\">`operator+`</ph>.","pos":[1456,1545],"source":" For example, to overload the addition operator, you define a function called `operator+`."},{"content":"Similarly, to overload the addition/assignment operator, <ph id=\"ph1\">`+=`</ph>, define a function called <ph id=\"ph2\">`operator+=`</ph>.","pos":[1546,1647],"source":" Similarly, to overload the addition/assignment operator, `+=`, define a function called `operator+=`."},{"content":"Redefinable Operators","pos":[1657,1678]},{"content":"Operator","pos":[1685,1693]},{"content":"Name","pos":[1694,1698]},{"content":"Type","pos":[1699,1703]},{"content":"Comma","pos":[1753,1758]},{"content":"Binary","pos":[1759,1765]},{"content":"Logical NOT","pos":[1774,1785]},{"content":"Unary","pos":[1786,1791]},{"content":"Inequality","pos":[1801,1811]},{"content":"Binary","pos":[1812,1818]},{"content":"Modulus","pos":[1827,1834]},{"content":"Binary","pos":[1835,1841]},{"content":"Modulus assignment","pos":[1851,1869]},{"content":"Binary","pos":[1870,1876]},{"content":"Bitwise AND","pos":[1885,1896]},{"content":"Binary","pos":[1897,1903]},{"content":"Address-of","pos":[1912,1922]},{"content":"Unary","pos":[1923,1928]},{"content":"Logical AND","pos":[1938,1949]},{"content":"Binary","pos":[1950,1956]},{"content":"Bitwise AND assignment","pos":[1966,1988]},{"content":"Binary","pos":[1989,1995]},{"content":"Function call","pos":[2006,2019]},{"content":"—","pos":[2020,2021]},{"content":"Cast Operator","pos":[2032,2045]},{"content":"Unary","pos":[2046,2051]},{"content":"Multiplication","pos":[2060,2074]},{"content":"Binary","pos":[2075,2081]},{"content":"Pointer dereference","pos":[2090,2109]},{"content":"Unary","pos":[2110,2115]},{"content":"Multiplication assignment","pos":[2125,2150]},{"content":"Binary","pos":[2151,2157]},{"content":"Addition","pos":[2166,2174]},{"content":"Binary","pos":[2175,2181]},{"content":"Unary Plus","pos":[2190,2200]},{"content":"Unary","pos":[2201,2206]},{"pos":[2216,2232],"content":"Increment <ph id=\"ph1\">&lt;sup&gt;</ph>1","source":"Increment <sup>1"},{"content":"Unary","pos":[2239,2244]},{"content":"Addition assignment","pos":[2254,2273]},{"content":"Binary","pos":[2274,2280]},{"content":"Subtraction","pos":[2289,2300]},{"content":"Binary","pos":[2301,2307]},{"content":"Unary negation","pos":[2316,2330]},{"content":"Unary","pos":[2331,2336]},{"pos":[2346,2362],"content":"Decrement <ph id=\"ph1\">&lt;sup&gt;</ph>1","source":"Decrement <sup>1"},{"content":"Unary","pos":[2369,2374]},{"content":"Subtraction assignment","pos":[2384,2406]},{"content":"Binary","pos":[2407,2413]},{"content":"Member selection","pos":[2423,2439]},{"content":"Binary","pos":[2440,2446]},{"content":"Pointer-to-member selection","pos":[2457,2484]},{"content":"Binary","pos":[2485,2491]},{"content":"Division","pos":[2500,2508]},{"content":"Binary","pos":[2509,2515]},{"content":"Division assignment","pos":[2525,2544]},{"content":"Binary","pos":[2545,2551]},{"content":"Less than","pos":[2560,2569]},{"content":"Binary","pos":[2570,2576]},{"content":"Left shift","pos":[2586,2596]},{"content":"Binary","pos":[2597,2603]},{"content":"Left shift assignment","pos":[2614,2635]},{"content":"Binary","pos":[2636,2642]},{"content":"Less than or equal to","pos":[2652,2673]},{"content":"Binary","pos":[2674,2680]},{"content":"Assignment","pos":[2689,2699]},{"content":"Binary","pos":[2700,2706]},{"content":"Equality","pos":[2716,2724]},{"content":"Binary","pos":[2725,2731]},{"content":"Greater than","pos":[2740,2752]},{"content":"Binary","pos":[2753,2759]},{"content":"Greater than or equal to","pos":[2769,2793]},{"content":"Binary","pos":[2794,2800]},{"content":"Right shift","pos":[2810,2821]},{"content":"Binary","pos":[2822,2828]},{"content":"Right shift assignment","pos":[2839,2861]},{"content":"Binary","pos":[2862,2868]},{"content":"Array subscript","pos":[2879,2894]},{"content":"—","pos":[2895,2896]},{"content":"Exclusive OR","pos":[2905,2917]},{"content":"Binary","pos":[2918,2924]},{"content":"Exclusive OR assignment","pos":[2934,2957]},{"content":"Binary","pos":[2958,2964]},{"content":"Bitwise inclusive OR","pos":[2978,2998]},{"content":"Binary","pos":[2999,3005]},{"content":"Bitwise inclusive OR assignment","pos":[3020,3051]},{"content":"Binary","pos":[3052,3058]},{"content":"Logical OR","pos":[3078,3088]},{"content":"Binary","pos":[3089,3095]},{"content":"One's complement","pos":[3104,3120]},{"content":"Unary","pos":[3121,3126]},{"content":"—","pos":[3149,3150]},{"content":"—","pos":[3167,3168]},{"content":"conversion operators","pos":[3196,3216]},{"content":"Unary","pos":[3217,3222]},{"content":"1   Two versions of the unary increment and decrement operators exist: preincrement and postincrement.","pos":[3230,3332]},{"content":"See <bpt id=\"p1\">[</bpt>General Rules for Operator Overloading<ept id=\"p1\">](../cpp/general-rules-for-operator-overloading.md)</ept> for more information.","pos":[3339,3455],"source":"See [General Rules for Operator Overloading](../cpp/general-rules-for-operator-overloading.md) for more information."},{"content":"The constraints on the various categories of overloaded operators are described in the following topics:","pos":[3456,3560]},{"content":"Unary Operators","pos":[3571,3586]},{"content":"Binary Operators","pos":[3637,3653]},{"content":"Assignment","pos":[3693,3703]},{"content":"Function Call","pos":[3737,3750]},{"content":"Subscripting","pos":[3791,3803]},{"content":"Class-Member Access","pos":[3839,3858]},{"pos":[3894,3980],"content":"<bpt id=\"p1\">[</bpt>Increment and Decrement<ept id=\"p1\">](../cpp/increment-and-decrement-operator-overloading-cpp.md)</ept>.","source":"[Increment and Decrement](../cpp/increment-and-decrement-operator-overloading-cpp.md)."},{"content":"User-Defined Type Conversions","pos":[3991,4020]},{"content":"The operators shown in the following table cannot be overloaded.","pos":[4073,4137]},{"content":"The table includes the preprocessor symbols <ph id=\"ph1\">`#`</ph> and <ph id=\"ph2\">`##`</ph>.","pos":[4138,4195],"source":" The table includes the preprocessor symbols `#` and `##`."},{"content":"Nonredefinable Operators","pos":[4205,4229]},{"content":"Member selection","pos":[4276,4292]},{"content":"Pointer-to-member selection","pos":[4302,4329]},{"content":"Scope resolution","pos":[4339,4355]},{"content":"Conditional","pos":[4366,4377]},{"content":"Preprocessor convert to string","pos":[4386,4416]},{"content":"Preprocessor concatenate","pos":[4426,4450]},{"content":"Although overloaded operators are usually called implicitly by the compiler when they are encountered in code, they can be invoked explicitly the same way as any member or nonmember function is called:","pos":[4458,4659]},{"content":"Example","pos":[4759,4766]},{"pos":[4770,4869],"content":"The following example overloads the <ph id=\"ph1\">`+`</ph> operator to add two complex numbers and returns the result.","source":"The following example overloads the `+` operator to add two complex numbers and returns the result."},{"content":"Output","pos":[5538,5544]},{"content":"In this section","pos":[5580,5595]},{"content":"General Rules for Operator Overloading","pos":[5606,5644]},{"content":"Overloading Unary Operators","pos":[5706,5733]},{"content":"Binary Operators","pos":[5784,5800]},{"content":"Assignment","pos":[5840,5850]},{"content":"Function Call","pos":[5884,5897]},{"content":"Subscripting","pos":[5938,5950]},{"content":"Member Access","pos":[5986,5999]},{"content":"See Also","pos":[6034,6042]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[6047,6099]},{"content":"Keywords","pos":[6169,6177]}],"content":"---\ntitle: \"Operator Overloading | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"operator_cpp\"\n  - \"operator\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"redefinable operators\"\n  - \"non-redefinable operators\"\n  - \"operator keyword [C++]\"\n  - \"operators [C++], overloading\"\n  - \"operator overloading\"\nms.assetid: 56ad4c4f-dd0c-45e0-adaa-08fe98cb1f8e\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Operator Overloading\nThe `operator` keyword declares a function specifying what `operator-symbol` means when applied to instances of a class. This gives the operator more than one meaning, or \"overloads\" it. The compiler distinguishes between the different meanings of an operator by examining the types of its operands.  \n  \n## Syntax  \n  \n```  \n  \ntype operator operator-symbol ( parameter-list )  \n```  \n  \n## Remarks  \n You can redefine the function of most built-in operators globally or on a class-by-class basis. Overloaded operators are implemented as functions.  \n  \n The name of an overloaded operator is `operator``x`, where `x` is the operator as it appears in the following table. For example, to overload the addition operator, you define a function called `operator+`. Similarly, to overload the addition/assignment operator, `+=`, define a function called `operator+=`.  \n  \n### Redefinable Operators  \n  \n|Operator|Name|Type|  \n|--------------|----------|----------|  \n|`,`|Comma|Binary|  \n|`!`|Logical NOT|Unary|  \n|`!=`|Inequality|Binary|  \n|`%`|Modulus|Binary|  \n|`%=`|Modulus assignment|Binary|  \n|`&`|Bitwise AND|Binary|  \n|`&`|Address-of|Unary|  \n|`&&`|Logical AND|Binary|  \n|`&=`|Bitwise AND assignment|Binary|  \n|`( )`|Function call|—|  \n|`( )`|Cast Operator|Unary|  \n|`*`|Multiplication|Binary|  \n|`*`|Pointer dereference|Unary|  \n|`*=`|Multiplication assignment|Binary|  \n|`+`|Addition|Binary|  \n|`+`|Unary Plus|Unary|  \n|`++`|Increment <sup>1</sup>|Unary|  \n|`+=`|Addition assignment|Binary|  \n|`–`|Subtraction|Binary|  \n|`–`|Unary negation|Unary|  \n|`––`|Decrement <sup>1</sup>|Unary|  \n|`–=`|Subtraction assignment|Binary|  \n|`–>`|Member selection|Binary|  \n|`–>*`|Pointer-to-member selection|Binary|  \n|`/`|Division|Binary|  \n|`/=`|Division assignment|Binary|  \n|`<`|Less than|Binary|  \n|`<<`|Left shift|Binary|  \n|`<<=`|Left shift assignment|Binary|  \n|`<=`|Less than or equal to|Binary|  \n|`=`|Assignment|Binary|  \n|`==`|Equality|Binary|  \n|`>`|Greater than|Binary|  \n|`>=`|Greater than or equal to|Binary|  \n|`>>`|Right shift|Binary|  \n|`>>=`|Right shift assignment|Binary|  \n|`[ ]`|Array subscript|—|  \n|`^`|Exclusive OR|Binary|  \n|`^=`|Exclusive OR assignment|Binary|  \n|`&#124;`|Bitwise inclusive OR|Binary|  \n|`&#124;=`|Bitwise inclusive OR assignment|Binary|  \n|`&#124;&#124;`|Logical OR|Binary|  \n|`~`|One's complement|Unary|  \n|`delete`|`Delete`|—|  \n|`new`|`New`|—|  \n|`conversion operators`|conversion operators|Unary|  \n  \n 1   Two versions of the unary increment and decrement operators exist: preincrement and postincrement.  \n  \n See [General Rules for Operator Overloading](../cpp/general-rules-for-operator-overloading.md) for more information. The constraints on the various categories of overloaded operators are described in the following topics:  \n  \n-   [Unary Operators](../cpp/overloading-unary-operators.md)  \n  \n-   [Binary Operators](../cpp/binary-operators.md)  \n  \n-   [Assignment](../cpp/assignment.md)  \n  \n-   [Function Call](../cpp/function-call-cpp.md)  \n  \n-   [Subscripting](../cpp/subscripting.md)  \n  \n-   [Class-Member Access](../cpp/member-access.md)  \n  \n-   [Increment and Decrement](../cpp/increment-and-decrement-operator-overloading-cpp.md).  \n  \n-   [User-Defined Type Conversions](../cpp/user-defined-type-conversions-cpp.md)  \n  \n The operators shown in the following table cannot be overloaded. The table includes the preprocessor symbols `#` and `##`.  \n  \n### Nonredefinable Operators  \n  \n|||  \n|-|-|  \n|`Operator`|`Name`|  \n|`.`|Member selection|  \n|`.*`|Pointer-to-member selection|  \n|`::`|Scope resolution|  \n|`? :`|Conditional|  \n|`#`|Preprocessor convert to string|  \n|`##`|Preprocessor concatenate|  \n  \n Although overloaded operators are usually called implicitly by the compiler when they are encountered in code, they can be invoked explicitly the same way as any member or nonmember function is called:  \n  \n```  \nPoint pt;  \npt.operator+( 3 );  // Call addition operator to add 3 to pt.  \n```  \n  \n## Example  \n The following example overloads the `+` operator to add two complex numbers and returns the result.  \n  \n```  \n// operator_overloading.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \nstruct Complex {  \n   Complex( double r, double i ) : re(r), im(i) {}  \n   Complex operator+( Complex &other );  \n   void Display( ) {   cout << re << \", \" << im << endl; }  \nprivate:  \n   double re, im;  \n};  \n  \n// Operator overloaded using a member function  \nComplex Complex::operator+( Complex &other ) {  \n   return Complex( re + other.re, im + other.im );  \n}  \n  \nint main() {  \n   Complex a = Complex( 1.2, 3.4 );  \n   Complex b = Complex( 5.6, 7.8 );  \n   Complex c = Complex( 0.0, 0.0 );  \n  \n   c = a + b;  \n   c.Display();  \n}  \n```  \n  \n## Output  \n  \n```  \n6.8, 11.2  \n```  \n  \n## In this section  \n  \n1.  [General Rules for Operator Overloading](../cpp/general-rules-for-operator-overloading.md)  \n  \n2.  [Overloading Unary Operators](../cpp/overloading-unary-operators.md)  \n  \n3.  [Binary Operators](../cpp/binary-operators.md)  \n  \n4.  [Assignment](../cpp/assignment.md)  \n  \n5.  [Function Call](../cpp/function-call-cpp.md)  \n  \n6.  [Subscripting](../cpp/subscripting.md)  \n  \n7.  [Member Access](../cpp/member-access.md)  \n  \n## See Also  \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   \n [Keywords](../cpp/keywords-cpp.md)"}