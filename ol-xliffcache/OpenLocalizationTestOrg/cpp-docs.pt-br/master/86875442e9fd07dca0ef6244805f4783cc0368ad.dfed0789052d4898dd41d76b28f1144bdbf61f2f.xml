{"nodes":[{"pos":[12,79],"content":"Windows Sockets: Example of Sockets Using Archives | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Windows Sockets: Example of Sockets Using Archives | Microsoft Docs","pos":[0,67]}]},{"content":"Windows Sockets: Example of Sockets Using Archives","pos":[698,748]},{"content":"This article presents an example of using class <bpt id=\"p1\">[</bpt>CSocket<ept id=\"p1\">](../mfc/reference/csocket-class.md)</ept>.","pos":[749,842],"source":"This article presents an example of using class [CSocket](../mfc/reference/csocket-class.md)."},{"content":"The example employs <ph id=\"ph1\">`CArchive`</ph> objects to serialize data through a socket.","pos":[843,917],"source":" The example employs `CArchive` objects to serialize data through a socket."},{"content":"Note that this is not document serialization to or from a file.","pos":[918,981]},{"content":"The following example illustrates how you use the archive to send and receive data through <ph id=\"ph1\">`CSocket`</ph> objects.","pos":[988,1097],"source":"The following example illustrates how you use the archive to send and receive data through `CSocket` objects."},{"content":"The example is designed so that two instances of the application (on the same machine or on different machines on the network) exchange data.","pos":[1098,1239]},{"content":"One instance sends data, which the other instance receives and acknowledges.","pos":[1240,1316]},{"content":"Either application can initiate an exchange, and either can act as server or as client to the other application.","pos":[1317,1429]},{"content":"The following function is defined in the application's view class:","pos":[1430,1496]},{"pos":[1514,1535],"content":"NVC_MFCSimpleSocket#1"},{"content":"The most important thing about this example is that its structure parallels that of an MFC <ph id=\"ph1\">`Serialize`</ph> function.","pos":[1624,1736],"source":"The most important thing about this example is that its structure parallels that of an MFC `Serialize` function."},{"content":"The <bpt id=\"p1\">**</bpt>PacketSerialize<ept id=\"p1\">**</ept> member function consists of an <bpt id=\"p2\">**</bpt>if<ept id=\"p2\">**</ept> statement with an <bpt id=\"p3\">**</bpt>else<ept id=\"p3\">**</ept> clause.","pos":[1737,1833],"source":" The **PacketSerialize** member function consists of an **if** statement with an **else** clause."},{"content":"The function receives two <bpt id=\"p1\">[</bpt>CArchive<ept id=\"p1\">](../mfc/reference/carchive-class.md)</ept> references as parameters: <ph id=\"ph1\">`arData`</ph> and <ph id=\"ph2\">`arAck`</ph>.","pos":[1834,1954],"source":" The function receives two [CArchive](../mfc/reference/carchive-class.md) references as parameters: `arData` and `arAck`."},{"content":"If the <ph id=\"ph1\">`arData`</ph> archive object is set for storing (sending), the <bpt id=\"p1\">**</bpt>if<ept id=\"p1\">**</ept> branch executes; otherwise, if <ph id=\"ph2\">`arData`</ph> is set for loading (receiving) the function takes the <bpt id=\"p2\">**</bpt>else<ept id=\"p2\">**</ept> branch.","pos":[1955,2137],"source":" If the `arData` archive object is set for storing (sending), the **if** branch executes; otherwise, if `arData` is set for loading (receiving) the function takes the **else** branch."},{"content":"For more information about serialization in MFC, see <bpt id=\"p1\">[</bpt>Serialization<ept id=\"p1\">](../mfc/how-to-make-a-type-safe-collection.md)</ept>.","pos":[2138,2253],"source":" For more information about serialization in MFC, see [Serialization](../mfc/how-to-make-a-type-safe-collection.md)."},{"pos":[2261,2413],"content":"[!NOTE]\n The `arAck` archive object is assumed to be the opposite of `arData`. If `arData` is for sending, `arAck` receives, and the converse is true.","leadings":["","> "],"nodes":[{"content":" The `arAck` archive object is assumed to be the opposite of `arData`. If `arData` is for sending, `arAck` receives, and the converse is true.","pos":[8,150],"nodes":[{"content":"The <ph id=\"ph1\">`arAck`</ph> archive object is assumed to be the opposite of <ph id=\"ph2\">`arData`</ph>.","pos":[1,70],"source":" The `arAck` archive object is assumed to be the opposite of `arData`."},{"content":"If <ph id=\"ph1\">`arData`</ph> is for sending, <ph id=\"ph2\">`arAck`</ph> receives, and the converse is true.","pos":[71,142],"source":" If `arData` is for sending, `arAck` receives, and the converse is true."}]}]},{"content":"For sending, the example function loops for a specified number of times, each time generating some random data for demonstration purposes.","pos":[2420,2558]},{"content":"Your application would obtain real data from some source, such as a file.","pos":[2559,2632]},{"content":"The <ph id=\"ph1\">`arData`</ph> archive's insertion operator (<bpt id=\"p1\">**</bpt><ph id=\"ph2\">&lt;&lt;</ph><ept id=\"p1\">**</ept>) is used to send a stream of three consecutive chunks of data:","pos":[2633,2745],"source":" The `arData` archive's insertion operator (**<<**) is used to send a stream of three consecutive chunks of data:"},{"pos":[2755,2888],"content":"A \"header\" that specifies the nature of the data (in this case, the value of the <ph id=\"ph1\">`bValue`</ph> variable and how many copies will be sent).","source":"A \"header\" that specifies the nature of the data (in this case, the value of the `bValue` variable and how many copies will be sent)."},{"content":"Both items are generated randomly for this example.","pos":[2899,2950]},{"content":"The specified number of copies of the data.","pos":[2960,3003]},{"pos":[3014,3082],"content":"The inner <bpt id=\"p1\">**</bpt>for<ept id=\"p1\">**</ept> loop sends <ph id=\"ph1\">`bValue`</ph> the specified number of times.","source":"The inner **for** loop sends `bValue` the specified number of times."},{"pos":[3092,3157],"content":"A string called <ph id=\"ph1\">`strText`</ph> that the receiver displays to its user.","source":"A string called `strText` that the receiver displays to its user."},{"content":"For receiving, the function operates similarly, except that it uses the archive's extraction operator (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">&gt;&gt;</ph><ept id=\"p1\">**</ept>) to get data from the archive.","pos":[3164,3304],"source":"For receiving, the function operates similarly, except that it uses the archive's extraction operator (**>>**) to get data from the archive."},{"content":"The receiving application verifies the data it receives, displays the final \"Received\" message, and then sends back a message that says \"Sent\" for the sending application to display.","pos":[3305,3487]},{"content":"In this communications model, the word \"Received\", the message sent in the <ph id=\"ph1\">`strText`</ph> variable, is for display at the other end of the communication, so it specifies to the receiving user that a certain number of packets of data have been received.","pos":[3494,3741],"source":"In this communications model, the word \"Received\", the message sent in the `strText` variable, is for display at the other end of the communication, so it specifies to the receiving user that a certain number of packets of data have been received."},{"content":"The receiver replies with a similar string that says \"Sent\", for display on the original sender's screen.","pos":[3742,3847]},{"content":"Receipt of both strings indicates that successful communication has occurred.","pos":[3848,3925]},{"pos":[3933,4373],"content":"[!CAUTION]\n If you are writing an MFC client program to communicate with established (non-MFC) servers, do not send C++ objects through the archive. Unless the server is an MFC application that understands the kinds of objects you want to send, it won't be able to receive and deserialize your objects. An example in the article [Windows Sockets: Byte Ordering](../mfc/windows-sockets-byte-ordering.md) shows a communication of this type.","leadings":["","> "],"nodes":[{"content":" If you are writing an MFC client program to communicate with established (non-MFC) servers, do not send C++ objects through the archive. Unless the server is an MFC application that understands the kinds of objects you want to send, it won't be able to receive and deserialize your objects. An example in the article [Windows Sockets: Byte Ordering](../mfc/windows-sockets-byte-ordering.md) shows a communication of this type.","pos":[11,438],"nodes":[{"content":"If you are writing an MFC client program to communicate with established (non-MFC) servers, do not send C++ objects through the archive.","pos":[1,137]},{"content":"Unless the server is an MFC application that understands the kinds of objects you want to send, it won't be able to receive and deserialize your objects.","pos":[138,291]},{"content":"An example in the article <bpt id=\"p1\">[</bpt>Windows Sockets: Byte Ordering<ept id=\"p1\">](../mfc/windows-sockets-byte-ordering.md)</ept> shows a communication of this type.","pos":[292,427],"source":" An example in the article [Windows Sockets: Byte Ordering](../mfc/windows-sockets-byte-ordering.md) shows a communication of this type."}]}]},{"content":"For more information, see Windows Sockets Specification: <bpt id=\"p1\">**</bpt>htonl<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>htons<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>ntohl<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>ntohs<ept id=\"p4\">**</ept>.","pos":[4380,4480],"source":"For more information, see Windows Sockets Specification: **htonl**, **htons**, **ntohl**, **ntohs**."},{"content":"Also, for more information, see:","pos":[4481,4513]},{"content":"Windows Sockets: Deriving from Socket Classes","pos":[4524,4569]},{"content":"Windows Sockets: How Sockets with Archives Work","pos":[4637,4684]},{"content":"Windows Sockets: Background","pos":[4754,4781]},{"content":"See Also","pos":[4829,4837]},{"content":"Windows Sockets in MFC","pos":[4842,4864]},{"content":"CArchive::IsStoring","pos":[4905,4924]},{"content":"CArchive::operator &lt;&lt;","pos":[4987,5008],"source":"CArchive::operator <<"},{"content":"CArchive::operator &gt;&gt;","pos":[5076,5097],"source":"CArchive::operator >>"},{"content":"CArchive::Flush","pos":[5165,5180]},{"content":"CObject::Serialize","pos":[5239,5257]}],"content":"---\ntitle: \"Windows Sockets: Example of Sockets Using Archives | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"sockets [C++], with archives\"\n  - \"examples [MFC], Windows Sockets\"\n  - \"Windows Sockets [C++], with archives\"\nms.assetid: 2e3c9bb2-7e7b-4f28-8dc5-6cb7a484edac\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Windows Sockets: Example of Sockets Using Archives\nThis article presents an example of using class [CSocket](../mfc/reference/csocket-class.md). The example employs `CArchive` objects to serialize data through a socket. Note that this is not document serialization to or from a file.  \n  \n The following example illustrates how you use the archive to send and receive data through `CSocket` objects. The example is designed so that two instances of the application (on the same machine or on different machines on the network) exchange data. One instance sends data, which the other instance receives and acknowledges. Either application can initiate an exchange, and either can act as server or as client to the other application. The following function is defined in the application's view class:  \n  \n [!code-cpp[NVC_MFCSimpleSocket#1](../mfc/codesnippet/cpp/windows-sockets-example-of-sockets-using-archives_1.cpp)]  \n  \n The most important thing about this example is that its structure parallels that of an MFC `Serialize` function. The **PacketSerialize** member function consists of an **if** statement with an **else** clause. The function receives two [CArchive](../mfc/reference/carchive-class.md) references as parameters: `arData` and `arAck`. If the `arData` archive object is set for storing (sending), the **if** branch executes; otherwise, if `arData` is set for loading (receiving) the function takes the **else** branch. For more information about serialization in MFC, see [Serialization](../mfc/how-to-make-a-type-safe-collection.md).  \n  \n> [!NOTE]\n>  The `arAck` archive object is assumed to be the opposite of `arData`. If `arData` is for sending, `arAck` receives, and the converse is true.  \n  \n For sending, the example function loops for a specified number of times, each time generating some random data for demonstration purposes. Your application would obtain real data from some source, such as a file. The `arData` archive's insertion operator (**<<**) is used to send a stream of three consecutive chunks of data:  \n  \n-   A \"header\" that specifies the nature of the data (in this case, the value of the `bValue` variable and how many copies will be sent).  \n  \n     Both items are generated randomly for this example.  \n  \n-   The specified number of copies of the data.  \n  \n     The inner **for** loop sends `bValue` the specified number of times.  \n  \n-   A string called `strText` that the receiver displays to its user.  \n  \n For receiving, the function operates similarly, except that it uses the archive's extraction operator (**>>**) to get data from the archive. The receiving application verifies the data it receives, displays the final \"Received\" message, and then sends back a message that says \"Sent\" for the sending application to display.  \n  \n In this communications model, the word \"Received\", the message sent in the `strText` variable, is for display at the other end of the communication, so it specifies to the receiving user that a certain number of packets of data have been received. The receiver replies with a similar string that says \"Sent\", for display on the original sender's screen. Receipt of both strings indicates that successful communication has occurred.  \n  \n> [!CAUTION]\n>  If you are writing an MFC client program to communicate with established (non-MFC) servers, do not send C++ objects through the archive. Unless the server is an MFC application that understands the kinds of objects you want to send, it won't be able to receive and deserialize your objects. An example in the article [Windows Sockets: Byte Ordering](../mfc/windows-sockets-byte-ordering.md) shows a communication of this type.  \n  \n For more information, see Windows Sockets Specification: **htonl**, **htons**, **ntohl**, **ntohs**. Also, for more information, see:  \n  \n-   [Windows Sockets: Deriving from Socket Classes](../mfc/windows-sockets-deriving-from-socket-classes.md)  \n  \n-   [Windows Sockets: How Sockets with Archives Work](../mfc/windows-sockets-how-sockets-with-archives-work.md)  \n  \n-   [Windows Sockets: Background](../mfc/windows-sockets-background.md)  \n  \n## See Also  \n [Windows Sockets in MFC](../mfc/windows-sockets-in-mfc.md)   \n [CArchive::IsStoring](../mfc/reference/carchive-class.md#carchive__isstoring)   \n [CArchive::operator <<](../mfc/reference/carchive-class.md#carchive__operator_lt_lt)   \n [CArchive::operator >>](../mfc/reference/carchive-class.md#carchive__operator_lt_lt)   \n [CArchive::Flush](../mfc/reference/carchive-class.md#carchive__flush)   \n [CObject::Serialize](../mfc/reference/cobject-class.md#cobject__serialize)\n\n"}