{"nodes":[{"pos":[12,69],"content":"Explicit Override of an Interface Member | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Explicit Override of an Interface Member | Microsoft Docs","pos":[0,57]}]},{"content":"Explicit Override of an Interface Member","pos":[764,804]},{"pos":[805,1008],"content":"The syntax for declaring an explicit override of an interface member within a class has changed from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"The syntax for declaring an explicit override of an interface member within a class has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"You often want to provide two instances of an interface member within a class that implements the interface – one that is used when class objects are manipulated through an interface handle, and one that is used when class objects are used through the class interface.","pos":[1015,1283]},{"content":"For example:","pos":[1284,1296]},{"content":"In Managed Extensions we do this by providing an explicit declaration of the interface method with the method's name qualified with the name of the interface.","pos":[1491,1649]},{"content":"The class-specific instance is unqualified.","pos":[1650,1693]},{"content":"This eliminates the need to downcast the return value of <ph id=\"ph1\">`Clone`</ph>, in this example, when explicit called through an instance of <ph id=\"ph2\">`R`</ph>.","pos":[1694,1825],"source":" This eliminates the need to downcast the return value of `Clone`, in this example, when explicit called through an instance of `R`."},{"content":"In the new syntax, a general overriding mechanism has been introduced that replaces the Managed Extensions syntax.","pos":[1832,1946]},{"content":"Our example would be rewritten as follows:","pos":[1947,1989]},{"content":"This revision requires that the interface member being explicitly overridden be given a unique name within the class.","pos":[2226,2343]},{"content":"Here, I've provided the awkward name of <ph id=\"ph1\">`InterfaceClone`</ph>.","pos":[2344,2401],"source":" Here, I've provided the awkward name of `InterfaceClone`."},{"content":"The behavior is still the same – an invocation through the <ph id=\"ph1\">`ICloneable`</ph> interface invokes the renamed <ph id=\"ph2\">`InterfaceClone,`</ph> while a call through an object of type <ph id=\"ph3\">`R`</ph> invokes the second <ph id=\"ph4\">`Clone`</ph> instance.","pos":[2402,2601],"source":" The behavior is still the same – an invocation through the `ICloneable` interface invokes the renamed `InterfaceClone,` while a call through an object of type `R` invokes the second `Clone` instance."},{"content":"See Also","pos":[2610,2618]},{"content":"Member Declarations within a Class or Interface (C++/CLI)","pos":[2623,2680]},{"content":"Explicit Overrides","pos":[2757,2775]}],"content":"---\ntitle: \"Explicit Override of an Interface Member | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"virtual functions, explicit overrides\"\n  - \"overriding functions\"\n  - \"interface members, explicit overrides\"\n  - \"functions [C++], overriding\"\n  - \"explicit override of virtual function\"\nms.assetid: 46f1f536-bf43-4311-9a17-ff2282e528a9\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Explicit Override of an Interface Member\nThe syntax for declaring an explicit override of an interface member within a class has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n You often want to provide two instances of an interface member within a class that implements the interface – one that is used when class objects are manipulated through an interface handle, and one that is used when class objects are used through the class interface. For example:  \n  \n```  \npublic __gc class R : public ICloneable {  \n   // to be used through ICloneable  \n   Object* ICloneable::Clone();  \n  \n   // to be used through an R  \n   R* Clone();  \n};  \n```  \n  \n In Managed Extensions we do this by providing an explicit declaration of the interface method with the method's name qualified with the name of the interface. The class-specific instance is unqualified. This eliminates the need to downcast the return value of `Clone`, in this example, when explicit called through an instance of `R`.  \n  \n In the new syntax, a general overriding mechanism has been introduced that replaces the Managed Extensions syntax. Our example would be rewritten as follows:  \n  \n```  \npublic ref class R : public ICloneable {  \npublic:  \n   // to be used through ICloneable  \n   virtual Object^ InterfaceClone() = ICloneable::Clone;  \n  \n   // to be used through an R  \n   virtual R^ Clone();  \n};  \n```  \n  \n This revision requires that the interface member being explicitly overridden be given a unique name within the class. Here, I've provided the awkward name of `InterfaceClone`. The behavior is still the same – an invocation through the `ICloneable` interface invokes the renamed `InterfaceClone,` while a call through an object of type `R` invokes the second `Clone` instance.  \n  \n## See Also  \n [Member Declarations within a Class or Interface (C++/CLI)](../dotnet/member-declarations-within-a-class-or-interface-cpp-cli.md)   \n [Explicit Overrides](../windows/explicit-overrides-cpp-component-extensions.md)"}