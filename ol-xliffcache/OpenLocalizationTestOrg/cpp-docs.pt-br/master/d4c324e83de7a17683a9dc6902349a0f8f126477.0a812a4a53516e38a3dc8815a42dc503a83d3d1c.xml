{"nodes":[{"pos":[12,51],"content":"#using Directive (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"using Directive (C++) | Microsoft Docs","pos":[1,39]}]},{"content":"using Directive (C++)","pos":[763,784]},{"pos":[785,901],"content":"Imports metadata into a program compiled with <bpt id=\"p1\">[</bpt>/clr<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>.","source":"Imports metadata into a program compiled with [/clr](../build/reference/clr-common-language-runtime-compilation.md)."},{"content":"Syntax","pos":[910,916]},{"content":"Parameters","pos":[968,978]},{"content":"An MSIL .dll, .exe, .netmodule, or .obj.","pos":[992,1032]},{"content":"For example,","pos":[1033,1045]},{"content":"as_friend","pos":[1085,1094]},{"content":"Specifies that all types in <ph id=\"ph1\">`file`</ph> are accessible.","pos":[1098,1148],"source":" Specifies that all types in `file` are accessible."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Friend Assemblies (C++)<ept id=\"p1\">](../dotnet/friend-assemblies-cpp.md)</ept>.","pos":[1150,1238],"source":"  For more information, see [Friend Assemblies (C++)](../dotnet/friend-assemblies-cpp.md)."},{"content":"Remarks","pos":[1247,1254]},{"content":"can be a Microsoft intermediate language (MSIL) file that you import for its managed data and managed constructs.","pos":[1265,1378]},{"content":"If a .dll file contains an assembly manifest, then all the .dlls referenced in the manifest are imported and the assembly you are building will list <bpt id=\"p1\">*</bpt>file<ept id=\"p1\">*</ept> in the metadata as an assembly reference.","pos":[1379,1576],"source":" If a .dll file contains an assembly manifest, then all the .dlls referenced in the manifest are imported and the assembly you are building will list *file* in the metadata as an assembly reference."},{"content":"If <ph id=\"ph1\">`file`</ph> does not contain an assembly (if <ph id=\"ph2\">`file`</ph> is a module) and if you do not intend to use type information from the module in the current (assembly) application, you have the option of just indicating that the module is part the assembly; use <bpt id=\"p1\">[</bpt>/ASSEMBLYMODULE<ept id=\"p1\">](../build/reference/assemblymodule-add-a-msil-module-to-the-assembly.md)</ept>.","pos":[1583,1921],"source":"If `file` does not contain an assembly (if `file` is a module) and if you do not intend to use type information from the module in the current (assembly) application, you have the option of just indicating that the module is part the assembly; use [/ASSEMBLYMODULE](../build/reference/assemblymodule-add-a-msil-module-to-the-assembly.md)."},{"content":"The types in the module would then be available to any application that referenced the assembly.","pos":[1922,2018]},{"pos":[2025,2139],"content":"An alternative to use <ph id=\"ph1\">`#using`</ph> is the <bpt id=\"p1\">[</bpt>/FU<ept id=\"p1\">](../build/reference/fu-name-forced-hash-using-file.md)</ept> compiler option.","source":"An alternative to use `#using` is the [/FU](../build/reference/fu-name-forced-hash-using-file.md) compiler option."},{"content":".exe assemblies passed to <ph id=\"ph1\">`#using`</ph> should be compiled with <bpt id=\"p1\">**</bpt>/clr:safe<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept>, or with any of the other Visual Studio compilers (Visual Basic or Visual C#, for example).","pos":[2146,2327],"source":".exe assemblies passed to `#using` should be compiled with **/clr:safe** or **/clr:pure**, or with any of the other Visual Studio compilers (Visual Basic or Visual C#, for example)."},{"content":"Attempting to import metadata from an .exe assembly compiled with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> will result in a file load exception.","pos":[2329,2441],"source":"  Attempting to import metadata from an .exe assembly compiled with **/clr** will result in a file load exception."},{"pos":[2449,2635],"content":"[!NOTE]\n A component that is referenced with `#using` can be run with a different version of the file imported at compile time, causing a client application to give unexpected results.","leadings":["","> "],"nodes":[{"content":"A component that is referenced with <ph id=\"ph1\">`#using`</ph> can be run with a different version of the file imported at compile time, causing a client application to give unexpected results.","pos":[9,184],"source":" A component that is referenced with `#using` can be run with a different version of the file imported at compile time, causing a client application to give unexpected results."}]},{"content":"In order for the compiler to recognize a type in an assembly (not a module), it needs to be forced to resolve the type, which you can do, for example, by defining an instance of the type.","pos":[2642,2829]},{"content":"There are other ways to resolve type names in an assembly for the compiler, for example, if you inherit from a type in an assembly, the type name will then become known to the compiler.","pos":[2830,3015]},{"content":"When importing metadata built from source code that used <bpt id=\"p1\">[</bpt>__declspec(thread)<ept id=\"p1\">](../cpp/thread.md)</ept>, the thread semantics are not persisted in metadata.","pos":[3022,3170],"source":"When importing metadata built from source code that used [__declspec(thread)](../cpp/thread.md), the thread semantics are not persisted in metadata."},{"content":"For example, a variable declared with <bpt id=\"p1\">**</bpt>__declspec(thread)<ept id=\"p1\">**</ept>, compiled in a program that is build for the .NET Framework common language runtime, and then imported via <ph id=\"ph1\">`#using`</ph>, will no longer have <bpt id=\"p2\">**</bpt>__declspec(thread)<ept id=\"p2\">**</ept> semantics on the variable.","pos":[3171,3418],"source":" For example, a variable declared with **__declspec(thread)**, compiled in a program that is build for the .NET Framework common language runtime, and then imported via `#using`, will no longer have **__declspec(thread)** semantics on the variable."},{"pos":[3425,3587],"content":"All imported types (both managed and native) in a file referenced by <ph id=\"ph1\">`#using`</ph> are available, but the compiler treats native types as declarations not definitions.","source":"All imported types (both managed and native) in a file referenced by `#using` are available, but the compiler treats native types as declarations not definitions."},{"pos":[3594,3664],"content":"mscorlib.dll is automatically referenced when compiling with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>.","source":"mscorlib.dll is automatically referenced when compiling with **/clr**."},{"pos":[3671,3817],"content":"The LIBPATH environment variable specifies the directories that will be searched when the compiler tries to resolve file names passed to <ph id=\"ph1\">`#using`</ph>.","source":"The LIBPATH environment variable specifies the directories that will be searched when the compiler tries to resolve file names passed to `#using`."},{"content":"The compiler will search for references along the following path:","pos":[3824,3889]},{"pos":[3899,3942],"content":"A path specified in the <ph id=\"ph1\">`#using`</ph> statement.","source":"A path specified in the `#using` statement."},{"content":"The current directory.","pos":[3952,3974]},{"content":"The .NET Framework system directory.","pos":[3984,4020]},{"pos":[4030,4134],"content":"Directories added with the <bpt id=\"p1\">[</bpt>/AI<ept id=\"p1\">](../build/reference/ai-specify-metadata-directories.md)</ept> compiler option.","source":"Directories added with the [/AI](../build/reference/ai-specify-metadata-directories.md) compiler option."},{"content":"Directories on LIBPATH environment variable.","pos":[4144,4188]},{"content":"Example","pos":[4197,4204]},{"content":"If you build an assembly (C) and reference an assembly (B) that itself references another assembly (A), you will not have to explicitly reference assembly A unless you explicitly use one of A's types in C.","pos":[4208,4413]},{"content":"Example","pos":[4516,4523]},{"content":"Example","pos":[4717,4724]},{"content":"In the following sample, there is no compiler error for not referencing using_assembly_A.dll because the program does not use any of the types defined in using_assembly_A.cpp.","pos":[4728,4903]},{"content":"See Also","pos":[5053,5061]},{"content":"Preprocessor Directives","pos":[5066,5089]}],"content":"---\ntitle: \"#using Directive (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"friend_as_cpp\"\n  - \"#using\"\n  - \"friend_as\"\n  - \"#using_cpp\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"using directive (#using)\"\n  - \"#using directive\"\n  - \"LIBPATH environment variable\"\n  - \"preprocessor, directives\"\nms.assetid: 870b15e5-f361-40a8-ba1c-c57d75c8809a\ncaps.latest.revision: 17\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# #using Directive (C++)\nImports metadata into a program compiled with [/clr](../build/reference/clr-common-language-runtime-compilation.md).  \n  \n## Syntax  \n  \n```  \n#using file [as_friend]  \n```  \n  \n#### Parameters  \n `file`  \n An MSIL .dll, .exe, .netmodule, or .obj. For example,  \n  \n `#using <MyComponent.dll>`  \n  \n as_friend  \n Specifies that all types in `file` are accessible.  For more information, see [Friend Assemblies (C++)](../dotnet/friend-assemblies-cpp.md).  \n  \n## Remarks  \n `file` can be a Microsoft intermediate language (MSIL) file that you import for its managed data and managed constructs. If a .dll file contains an assembly manifest, then all the .dlls referenced in the manifest are imported and the assembly you are building will list *file* in the metadata as an assembly reference.  \n  \n If `file` does not contain an assembly (if `file` is a module) and if you do not intend to use type information from the module in the current (assembly) application, you have the option of just indicating that the module is part the assembly; use [/ASSEMBLYMODULE](../build/reference/assemblymodule-add-a-msil-module-to-the-assembly.md). The types in the module would then be available to any application that referenced the assembly.  \n  \n An alternative to use `#using` is the [/FU](../build/reference/fu-name-forced-hash-using-file.md) compiler option.  \n  \n .exe assemblies passed to `#using` should be compiled with **/clr:safe** or **/clr:pure**, or with any of the other Visual Studio compilers (Visual Basic or Visual C#, for example).  Attempting to import metadata from an .exe assembly compiled with **/clr** will result in a file load exception.  \n  \n> [!NOTE]\n>  A component that is referenced with `#using` can be run with a different version of the file imported at compile time, causing a client application to give unexpected results.  \n  \n In order for the compiler to recognize a type in an assembly (not a module), it needs to be forced to resolve the type, which you can do, for example, by defining an instance of the type. There are other ways to resolve type names in an assembly for the compiler, for example, if you inherit from a type in an assembly, the type name will then become known to the compiler.  \n  \n When importing metadata built from source code that used [__declspec(thread)](../cpp/thread.md), the thread semantics are not persisted in metadata. For example, a variable declared with **__declspec(thread)**, compiled in a program that is build for the .NET Framework common language runtime, and then imported via `#using`, will no longer have **__declspec(thread)** semantics on the variable.  \n  \n All imported types (both managed and native) in a file referenced by `#using` are available, but the compiler treats native types as declarations not definitions.  \n  \n mscorlib.dll is automatically referenced when compiling with **/clr**.  \n  \n The LIBPATH environment variable specifies the directories that will be searched when the compiler tries to resolve file names passed to `#using`.  \n  \n The compiler will search for references along the following path:  \n  \n-   A path specified in the `#using` statement.  \n  \n-   The current directory.  \n  \n-   The .NET Framework system directory.  \n  \n-   Directories added with the [/AI](../build/reference/ai-specify-metadata-directories.md) compiler option.  \n  \n-   Directories on LIBPATH environment variable.  \n  \n## Example  \n If you build an assembly (C) and reference an assembly (B) that itself references another assembly (A), you will not have to explicitly reference assembly A unless you explicitly use one of A's types in C.  \n  \n```  \n// using_assembly_A.cpp  \n// compile with: /clr /LD  \npublic ref class A {};  \n```  \n  \n## Example  \n  \n```  \n// using_assembly_B.cpp  \n// compile with: /clr /LD  \n#using \"using_assembly_A.dll\"  \npublic ref class B {  \npublic:  \n   void Test(A a) {}  \n   void Test() {}  \n};  \n  \n```  \n  \n## Example  \n In the following sample, there is no compiler error for not referencing using_assembly_A.dll because the program does not use any of the types defined in using_assembly_A.cpp.  \n  \n```  \n// using_assembly_C.cpp  \n// compile with: /clr  \n#using \"using_assembly_B.dll\"  \nint main() {  \n   B b;  \n   b.Test();  \n}  \n```  \n  \n## See Also  \n [Preprocessor Directives](../preprocessor/preprocessor-directives.md)"}