{"nodes":[{"pos":[12,49],"content":"Value Type Semantics | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Value Type Semantics | Microsoft Docs","pos":[0,37]}]},{"content":"Value Type Semantics","pos":[724,744]},{"pos":[745,886],"content":"Value type semantics have changed from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"Value type semantics have changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"Here is the canonical simple value type used in the Managed Extensions for C++ spec:","pos":[893,977]},{"content":"In Managed Extensions, we can have four syntactic variants of a value type (where forms 2 and 3 are the same semantically):","pos":[1057,1180]},{"content":"Invoking Inherited Virtual Methods","pos":[1375,1409]},{"content":"is the canonical value object, and it is reasonably well understood, except when someone attempts to invoke an inherited virtual method such as <ph id=\"ph1\">`ToString()`</ph>.","pos":[1424,1581],"source":" is the canonical value object, and it is reasonably well understood, except when someone attempts to invoke an inherited virtual method such as `ToString()`."},{"content":"For example:","pos":[1582,1594]},{"content":"In order to invoke this method, because it is not overridden in <ph id=\"ph1\">`V`</ph>, the compiler must have access to the associated virtual table of the base class.","pos":[1642,1791],"source":"In order to invoke this method, because it is not overridden in `V`, the compiler must have access to the associated virtual table of the base class."},{"content":"Because value types are in-state storage without the associated pointer to its virtual table (vptr), this requires that <ph id=\"ph1\">`v`</ph> be boxed.","pos":[1792,1925],"source":" Because value types are in-state storage without the associated pointer to its virtual table (vptr), this requires that `v` be boxed."},{"content":"In the Managed Extensions language design, implicit boxing is not supported but must be explicitly specified by the programmer, as in","pos":[1926,2059]},{"content":"The primary motive behind this design is pedagogical: underlying mechanism needs to be visible to the programmer so that she will understand the 'cost' of not providing an instance within her value type.","pos":[2145,2348]},{"content":"Were <ph id=\"ph1\">`V`</ph> to contain an instance of <ph id=\"ph2\">`ToString`</ph>, the boxing would not be necessary.","pos":[2349,2430],"source":" Were `V` to contain an instance of `ToString`, the boxing would not be necessary."},{"content":"The lexical complexity of explicitly boxing the object, but not the underlying cost of the boxing itself, is removed in the new syntax:","pos":[2437,2572]},{"content":"but at the cost of possibly misleading the class designer as to the cost of not having provided an explicit instance of the <ph id=\"ph1\">`ToString`</ph> method within <ph id=\"ph2\">`V`</ph>.","pos":[2624,2777],"source":"but at the cost of possibly misleading the class designer as to the cost of not having provided an explicit instance of the `ToString` method within `V`."},{"content":"The reason for preferring the implicit boxing is that while there is usually just one class designer, there are an unlimited number of users, none of whom would have the freedom to modify <ph id=\"ph1\">`V`</ph> to eliminate the possibly onerous explicit box.","pos":[2778,3017],"source":" The reason for preferring the implicit boxing is that while there is usually just one class designer, there are an unlimited number of users, none of whom would have the freedom to modify `V` to eliminate the possibly onerous explicit box."},{"content":"The criteria by which to determine whether or not to provide an overriding instance of <ph id=\"ph1\">`ToString`</ph> within a value class should be the frequency and location of its uses.","pos":[3024,3192],"source":"The criteria by which to determine whether or not to provide an overriding instance of `ToString` within a value class should be the frequency and location of its uses."},{"content":"If it is called very rarely, there is of course little benefit in its definition.","pos":[3193,3274]},{"content":"Similarly, if it is called in non-performant areas of the application, adding it will also not measurably add to the general performance of the application.","pos":[3275,3431]},{"content":"Alternatively, one can keep a tracking handle to the boxed value, and calls through that handle would not require boxing.","pos":[3432,3553]},{"content":"There is No Longer a Value Class Default Constructor","pos":[3562,3614]},{"content":"Another difference with a value type between Managed Extensions and the new syntax is the removal of support for a default constructor.","pos":[3618,3753]},{"content":"This is because there are occasions during execution in which the CLR can create an instance of the value type without invoking the associated default constructor.","pos":[3754,3917]},{"content":"That is, the attempt under Managed Extensions to support a default constructor within a value type could not in practice be guaranteed.","pos":[3918,4053]},{"content":"Given that absence of guarantee, it was felt to be better to drop the support altogether rather than have it be non-deterministic in its application.","pos":[4054,4203]},{"content":"This is not as bad as it might initially seem.","pos":[4210,4256]},{"content":"This is because each object of a value type is zeroed out automatically (that is, each type is initialized to its default value).","pos":[4257,4386]},{"content":"As a result, the members of a local instance are never undefined.","pos":[4387,4452]},{"content":"In this sense, the loss of the ability to define a trivial default constructor is really not a loss at all â€“ and in fact is more efficient when performed by the CLR.","pos":[4453,4618]},{"content":"The problem is when a user of Managed Extensions defines a non-trivial default constructor.","pos":[4625,4716]},{"content":"This has no mapping to the new syntax.","pos":[4717,4755]},{"content":"The code within the constructor will need to be migrated into a named initialization method that would then need to be explicitly invoked by the user.","pos":[4756,4906]},{"content":"The declaration of a value type object within the new syntax is otherwise unchanged.","pos":[4913,4997]},{"content":"The down side of this is that value types are not satisfactory for the wrapping of native types for the following reasons:","pos":[4998,5120]},{"content":"There is no support for a destructor within a value type.","pos":[5130,5187]},{"content":"That is, there is no way to automate a set of actions triggered by the end of an object's lifetime.","pos":[5188,5287]},{"content":"A native class can be contained only within a managed type as a pointer which is then allocated on the native heap.","pos":[5297,5412]},{"content":"We would like to wrap a small native class in a value type rather than a reference type to avoid a double heap allocation: the native heap to hold the native type, and the CLR heap to hold the managed wrapper.","pos":[5419,5628]},{"content":"Wrapping a native class within a value type allows you to avoid the managed heap, but provides no way to automate the reclamation of the native heap memory.","pos":[5629,5785]},{"content":"Reference types are the only practicable managed type within which to wrap non-trivial native classes.","pos":[5786,5888]},{"content":"Interior Pointers","pos":[5897,5914]},{"content":"and <ph id=\"ph1\">`Form (3)`</ph> above can address nearly anything in this world or the next (that is, anything managed or native).","pos":[5929,6042],"source":" and `Form (3)` above can address nearly anything in this world or the next (that is, anything managed or native)."},{"content":"So, for example, all the following are permitted in Managed Extensions:","pos":[6043,6114]},{"pos":[6712,7147],"content":"So, a <ph id=\"ph1\">`V*`</ph> can address a location within a local block (and therefore can be dangling), at global scope, within the native heap (for example, if the object it addresses has already been deleted), within the CLR heap (and therefore will be tracked if it should be relocated during garbage collection), and within the interior of a reference object on the CLR heap (an interior pointer, as this is called, is also transparently tracked).","source":"So, a `V*` can address a location within a local block (and therefore can be dangling), at global scope, within the native heap (for example, if the object it addresses has already been deleted), within the CLR heap (and therefore will be tracked if it should be relocated during garbage collection), and within the interior of a reference object on the CLR heap (an interior pointer, as this is called, is also transparently tracked)."},{"pos":[7154,7370],"content":"In Managed Extensions, there is no way to separate out the native aspects of a <ph id=\"ph1\">`V*`</ph>; that is, it is treated at its inclusive, which handles the possibility of it addressing an object or subobject on the managed heap.","source":"In Managed Extensions, there is no way to separate out the native aspects of a `V*`; that is, it is treated at its inclusive, which handles the possibility of it addressing an object or subobject on the managed heap."},{"pos":[7377,7613],"content":"In the new syntax, a value type pointer is factored into two types: <ph id=\"ph1\">`V*`</ph>, which is limited to non-CLR heap locations, and the interior pointer, <ph id=\"ph2\">`interior_ptr&lt;V&gt;`</ph>, which allows for but does not require an address within the managed heap.","source":"In the new syntax, a value type pointer is factored into two types: `V*`, which is limited to non-CLR heap locations, and the interior pointer, `interior_ptr<V>`, which allows for but does not require an address within the managed heap."},{"content":"and <ph id=\"ph1\">`Form (3)`</ph> of Managed Extensions map into <ph id=\"ph2\">`interior_ptr&lt;V&gt;`</ph>.","pos":[7788,7852],"source":" and `Form (3)` of Managed Extensions map into `interior_ptr<V>`."},{"content":"is a tracking handle.","pos":[7864,7885]},{"content":"It addresses the whole object that has been boxed within the managed heap.","pos":[7886,7960]},{"content":"It is translated in the new syntax into a <ph id=\"ph1\">`V^`</ph>,","pos":[7961,8008],"source":" It is translated in the new syntax into a `V^`,"},{"content":"The following declarations in Managed Extensions all map to interior pointers in the new syntax.","pos":[8075,8171]},{"content":"(They are value types within the <ph id=\"ph1\">`System`</ph> namespace.)","pos":[8172,8225],"source":" (They are value types within the `System` namespace.)"},{"content":"The built-in types are not considered managed types, although they do serve as aliases to the types within the <ph id=\"ph1\">`System`</ph> namespace.","pos":[8395,8525],"source":"The built-in types are not considered managed types, although they do serve as aliases to the types within the `System` namespace."},{"content":"Thus the following mappings hold true between Managed Extensions and the new syntax:","pos":[8526,8610]},{"content":"When translating a <ph id=\"ph1\">`V*`</ph> in your existing program, the most conservative strategy is to always turn it to an <ph id=\"ph2\">`interior_ptr&lt;V&gt;`</ph>.","pos":[8710,8836],"source":"When translating a `V*` in your existing program, the most conservative strategy is to always turn it to an `interior_ptr<V>`."},{"content":"This is how it was treated under Managed Extensions.","pos":[8837,8889]},{"content":"In the new syntax, the programmer has the option of restricting a value type to non-managed heap addresses by specifying <ph id=\"ph1\">`V*`</ph> rather than an interior pointer.","pos":[8890,9048],"source":" In the new syntax, the programmer has the option of restricting a value type to non-managed heap addresses by specifying `V*` rather than an interior pointer."},{"content":"If, on translating your program, you can do a transitive closure of all its uses and be sure that no assigned address is within the managed heap, then leaving it as <ph id=\"ph1\">`V*`</ph> is fine.","pos":[9049,9227],"source":" If, on translating your program, you can do a transitive closure of all its uses and be sure that no assigned address is within the managed heap, then leaving it as `V*` is fine."},{"content":"Pinning Pointers","pos":[9236,9252]},{"content":"The garbage collector may optionally move objects that reside on the CLR heap to different locations within the heap, usually during a compaction phase.","pos":[9256,9408]},{"content":"This movement is not a problem to tracking handles, tracking references, and interior pointers which update these entities transparently.","pos":[9409,9546]},{"content":"This movement is a problem, however, if the user has passed the address of an object on the CLR heap outside of the runtime environment.","pos":[9547,9683]},{"content":"In this case, the volatile movement of the object is likely to cause a runtime failure.","pos":[9684,9771]},{"content":"To exempt objects such as these from being moved, we must locally pin them to their location for the extent of their outside use.","pos":[9772,9901]},{"content":"In Managed Extensions, a <bpt id=\"p1\">*</bpt>pinning pointer<ept id=\"p1\">*</ept> is declared by qualifying a pointer declaration with the <ph id=\"ph1\">`__pin`</ph> keyword.","pos":[9908,10024],"source":"In Managed Extensions, a *pinning pointer* is declared by qualifying a pointer declaration with the `__pin` keyword."},{"content":"Here is an example slightly modified from the Managed Extensions specification:","pos":[10025,10104]},{"content":"In the new language design, a pinning pointer is declared with syntax analogous to that of an interior pointer.","pos":[10244,10355]},{"content":"A pinning pointer under the new syntax is a special case of an interior pointer.","pos":[10510,10590]},{"content":"The original constraints on a pinning pointer remain.","pos":[10591,10644]},{"content":"For example, it cannot be used as a parameter or return type of a method; it can be declared only on a local object.","pos":[10645,10761]},{"content":"A number of additional constraints, however, have been added in the new syntax.","pos":[10762,10841]},{"content":"The default value of a pinning pointer is <ph id=\"ph1\">`nullptr`</ph>, not <ph id=\"ph2\">`0`</ph>.","pos":[10848,10909],"source":"The default value of a pinning pointer is `nullptr`, not `0`."},{"content":"A <ph id=\"ph1\">`pin_ptr&lt;&gt;`</ph> cannot be initialized or assigned <ph id=\"ph2\">`0`</ph>.","pos":[10910,10962],"source":" A `pin_ptr<>` cannot be initialized or assigned `0`."},{"content":"All assignments of <ph id=\"ph1\">`0`</ph> in existing code will need to be changed to <ph id=\"ph2\">`nullptr`</ph>.","pos":[10963,11040],"source":" All assignments of `0` in existing code will need to be changed to `nullptr`."},{"content":"A pinning pointer under Managed Extensions was permitted to address a whole object, as in the following example taken from the Managed Extensions specification:","pos":[11047,11207]},{"content":"In the new syntax, pinning the whole object returned by the <ph id=\"ph1\">`new`</ph> expression is not supported.","pos":[11409,11503],"source":"In the new syntax, pinning the whole object returned by the `new` expression is not supported."},{"content":"Rather, the address of the interior member needs to be pinned.","pos":[11504,11566]},{"content":"For example,","pos":[11567,11579]},{"content":"See Also","pos":[11860,11868]},{"content":"Value Types and Their Behaviors (C++/CLI)","pos":[11873,11914]},{"content":"Classes and Structs","pos":[11975,11994]},{"content":"interior_ptr (C++/CLI)","pos":[12061,12083]},{"content":"pin_ptr (C++/CLI)","pos":[12126,12143]}],"content":"---\ntitle: \"Value Type Semantics | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"interior_ptr keyword [C++]\"\n  - \"virtual functions, value types\"\n  - \"inheritance, value types\"\n  - \"pinning pointers\"\n  - \"pin_ptr keyword [C++]\"\n  - \"__pin keyword\"\nms.assetid: 7f065589-ad25-4850-baf1-985142e35e52\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Value Type Semantics\nValue type semantics have changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n Here is the canonical simple value type used in the Managed Extensions for C++ spec:  \n  \n```  \n__value struct V { int i; };  \n__gc struct R { V vr; };  \n```  \n  \n In Managed Extensions, we can have four syntactic variants of a value type (where forms 2 and 3 are the same semantically):  \n  \n```  \nV v = { 0 };       // Form (1)  \nV *pv = 0;         // Form (2) an implicit form of (3)  \nV __gc *pvgc = 0;  // Form (3)  \n__box V* pvbx = 0; // Form (4) must be local   \n```  \n  \n## Invoking Inherited Virtual Methods  \n `Form (1)` is the canonical value object, and it is reasonably well understood, except when someone attempts to invoke an inherited virtual method such as `ToString()`. For example:  \n  \n```  \nv.ToString(); // error!  \n```  \n  \n In order to invoke this method, because it is not overridden in `V`, the compiler must have access to the associated virtual table of the base class. Because value types are in-state storage without the associated pointer to its virtual table (vptr), this requires that `v` be boxed. In the Managed Extensions language design, implicit boxing is not supported but must be explicitly specified by the programmer, as in  \n  \n```  \n__box( v )->ToString(); // Managed Extensions: note the arrow  \n```  \n  \n The primary motive behind this design is pedagogical: underlying mechanism needs to be visible to the programmer so that she will understand the 'cost' of not providing an instance within her value type. Were `V` to contain an instance of `ToString`, the boxing would not be necessary.  \n  \n The lexical complexity of explicitly boxing the object, but not the underlying cost of the boxing itself, is removed in the new syntax:  \n  \n```  \nv.ToString(); // new syntax  \n```  \n  \n but at the cost of possibly misleading the class designer as to the cost of not having provided an explicit instance of the `ToString` method within `V`. The reason for preferring the implicit boxing is that while there is usually just one class designer, there are an unlimited number of users, none of whom would have the freedom to modify `V` to eliminate the possibly onerous explicit box.  \n  \n The criteria by which to determine whether or not to provide an overriding instance of `ToString` within a value class should be the frequency and location of its uses. If it is called very rarely, there is of course little benefit in its definition. Similarly, if it is called in non-performant areas of the application, adding it will also not measurably add to the general performance of the application. Alternatively, one can keep a tracking handle to the boxed value, and calls through that handle would not require boxing.  \n  \n## There is No Longer a Value Class Default Constructor  \n Another difference with a value type between Managed Extensions and the new syntax is the removal of support for a default constructor. This is because there are occasions during execution in which the CLR can create an instance of the value type without invoking the associated default constructor. That is, the attempt under Managed Extensions to support a default constructor within a value type could not in practice be guaranteed. Given that absence of guarantee, it was felt to be better to drop the support altogether rather than have it be non-deterministic in its application.  \n  \n This is not as bad as it might initially seem. This is because each object of a value type is zeroed out automatically (that is, each type is initialized to its default value). As a result, the members of a local instance are never undefined. In this sense, the loss of the ability to define a trivial default constructor is really not a loss at all â€“ and in fact is more efficient when performed by the CLR.  \n  \n The problem is when a user of Managed Extensions defines a non-trivial default constructor. This has no mapping to the new syntax. The code within the constructor will need to be migrated into a named initialization method that would then need to be explicitly invoked by the user.  \n  \n The declaration of a value type object within the new syntax is otherwise unchanged. The down side of this is that value types are not satisfactory for the wrapping of native types for the following reasons:  \n  \n-   There is no support for a destructor within a value type. That is, there is no way to automate a set of actions triggered by the end of an object's lifetime.  \n  \n-   A native class can be contained only within a managed type as a pointer which is then allocated on the native heap.  \n  \n We would like to wrap a small native class in a value type rather than a reference type to avoid a double heap allocation: the native heap to hold the native type, and the CLR heap to hold the managed wrapper. Wrapping a native class within a value type allows you to avoid the managed heap, but provides no way to automate the reclamation of the native heap memory. Reference types are the only practicable managed type within which to wrap non-trivial native classes.  \n  \n## Interior Pointers  \n `Form (2)` and `Form (3)` above can address nearly anything in this world or the next (that is, anything managed or native). So, for example, all the following are permitted in Managed Extensions:  \n  \n```  \n__value struct V { int i; };  \n__gc struct R { V vr; };  \n  \nV v = { 0 };  // Form (1)  \nV *pv = 0;  // Form (2)  \nV __gc *pvgc = 0;  // Form (3)  \n__box V* pvbx = 0;  // Form (4)  \n  \nR* r;  \n  \npv = &v;            // address a value type on the stack  \npv = __nogc new V;  // address a value type on native heap  \npv = pvgc;          // we are not sure what this addresses  \npv = pvbx;          // address a boxed value type on managed heap  \npv = &r->vr;        // an interior pointer to value type within a  \n                    //    reference type on the managed heap  \n```  \n  \n So, a `V*` can address a location within a local block (and therefore can be dangling), at global scope, within the native heap (for example, if the object it addresses has already been deleted), within the CLR heap (and therefore will be tracked if it should be relocated during garbage collection), and within the interior of a reference object on the CLR heap (an interior pointer, as this is called, is also transparently tracked).  \n  \n In Managed Extensions, there is no way to separate out the native aspects of a `V*`; that is, it is treated at its inclusive, which handles the possibility of it addressing an object or subobject on the managed heap.  \n  \n In the new syntax, a value type pointer is factored into two types: `V*`, which is limited to non-CLR heap locations, and the interior pointer, `interior_ptr<V>`, which allows for but does not require an address within the managed heap.  \n  \n```  \n// may not address within managed heap   \nV *pv = 0;   \n  \n// may or may not address within managed heap  \ninterior_ptr<V> pvgc = nullptr;   \n```  \n  \n `Form (2)` and `Form (3)` of Managed Extensions map into `interior_ptr<V>`. `Form (4)` is a tracking handle. It addresses the whole object that has been boxed within the managed heap. It is translated in the new syntax into a `V^`,  \n  \n```  \nV^ pvbx = nullptr; // __box V* pvbx = 0;    \n```  \n  \n The following declarations in Managed Extensions all map to interior pointers in the new syntax. (They are value types within the `System` namespace.)  \n  \n```  \nInt32 *pi;   // => interior_ptr<Int32> pi;  \nBoolean *pb; // => interior_ptr<Boolean> pb;  \nE *pe;       // => interior_ptr<E> pe; // Enumeration  \n```  \n  \n The built-in types are not considered managed types, although they do serve as aliases to the types within the `System` namespace. Thus the following mappings hold true between Managed Extensions and the new syntax:  \n  \n```  \nint * pi;     // => int* pi;  \nint __gc * pi2; // => interior_ptr<int> pi2;  \n```  \n  \n When translating a `V*` in your existing program, the most conservative strategy is to always turn it to an `interior_ptr<V>`. This is how it was treated under Managed Extensions. In the new syntax, the programmer has the option of restricting a value type to non-managed heap addresses by specifying `V*` rather than an interior pointer. If, on translating your program, you can do a transitive closure of all its uses and be sure that no assigned address is within the managed heap, then leaving it as `V*` is fine.  \n  \n## Pinning Pointers  \n The garbage collector may optionally move objects that reside on the CLR heap to different locations within the heap, usually during a compaction phase. This movement is not a problem to tracking handles, tracking references, and interior pointers which update these entities transparently. This movement is a problem, however, if the user has passed the address of an object on the CLR heap outside of the runtime environment. In this case, the volatile movement of the object is likely to cause a runtime failure. To exempt objects such as these from being moved, we must locally pin them to their location for the extent of their outside use.  \n  \n In Managed Extensions, a *pinning pointer* is declared by qualifying a pointer declaration with the `__pin` keyword. Here is an example slightly modified from the Managed Extensions specification:  \n  \n```  \n__gc struct H { int j; };  \n  \nint main()   \n{  \n   H * h = new H;  \n   int __pin * k = & h -> j;  \n  \n   // â€¦  \n};  \n```  \n  \n In the new language design, a pinning pointer is declared with syntax analogous to that of an interior pointer.  \n  \n```  \nref struct H  \n{  \npublic:  \n   int j;  \n};  \n  \nint main()  \n{  \n   H^ h = gcnew H;  \n   pin_ptr<int> k = &h->j;  \n  \n   // â€¦  \n}  \n```  \n  \n A pinning pointer under the new syntax is a special case of an interior pointer. The original constraints on a pinning pointer remain. For example, it cannot be used as a parameter or return type of a method; it can be declared only on a local object. A number of additional constraints, however, have been added in the new syntax.  \n  \n The default value of a pinning pointer is `nullptr`, not `0`. A `pin_ptr<>` cannot be initialized or assigned `0`. All assignments of `0` in existing code will need to be changed to `nullptr`.  \n  \n A pinning pointer under Managed Extensions was permitted to address a whole object, as in the following example taken from the Managed Extensions specification:  \n  \n```  \n__gc class G {  \npublic:  \n   void incr(int* pi) { pi += 1; }  \n};  \n__gc struct H { int j; };  \nvoid f( G * g ) {  \n   H __pin * pH = new H;     \n   g->incr(& pH -> j);     \n};  \n```  \n  \n In the new syntax, pinning the whole object returned by the `new` expression is not supported. Rather, the address of the interior member needs to be pinned. For example,  \n  \n```  \nref class G {  \npublic:  \n   void incr(int* pi) { *pi += 1; }  \n};  \nref struct H { int j; };  \nvoid f( G^ g ) {  \n   H ^ph = gcnew H;  \n   Console::WriteLine(ph->j);  \n   pin_ptr<int> pj = &ph->j;  \n   g->incr(  pj );  \n   Console::WriteLine(ph->j);  \n}  \n```  \n  \n## See Also  \n [Value Types and Their Behaviors (C++/CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)   \n [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)   \n [interior_ptr (C++/CLI)](../windows/interior-ptr-cpp-cli.md)   \n [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md)"}