{"nodes":[{"pos":[12,84],"content":"TN054: Calling DAO Directly While Using MFC DAO Classes | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN054: Calling DAO Directly While Using MFC DAO Classes | Microsoft Docs","pos":[0,72]}]},{"content":"TN054: Calling DAO Directly While Using MFC DAO Classes","pos":[870,925]},{"pos":[928,1306],"content":"[!NOTE]\n As of Visual C++ .NET, the Visual C++ environment and wizards no longer support DAO (although the DAO classes are included and you can still use them). Microsoft recommends that you use [OLE DB Templates](../data/oledb/ole-db-templates.md) or [ODBC and MFC](../data/odbc/odbc-and-mfc.md) for new projects. You should only use DAO in maintaining existing applications.","leadings":["","> "],"nodes":[{"content":" As of Visual C++ .NET, the Visual C++ environment and wizards no longer support DAO (although the DAO classes are included and you can still use them). Microsoft recommends that you use [OLE DB Templates](../data/oledb/ole-db-templates.md) or [ODBC and MFC](../data/odbc/odbc-and-mfc.md) for new projects. You should only use DAO in maintaining existing applications.","pos":[8,376],"nodes":[{"content":"As of Visual C++ .NET, the Visual C++ environment and wizards no longer support DAO (although the DAO classes are included and you can still use them).","pos":[1,152]},{"content":"Microsoft recommends that you use <bpt id=\"p1\">[</bpt>OLE DB Templates<ept id=\"p1\">](../data/oledb/ole-db-templates.md)</ept> or <bpt id=\"p2\">[</bpt>ODBC and MFC<ept id=\"p2\">](../data/odbc/odbc-and-mfc.md)</ept> for new projects.","pos":[153,306],"source":" Microsoft recommends that you use [OLE DB Templates](../data/oledb/ole-db-templates.md) or [ODBC and MFC](../data/odbc/odbc-and-mfc.md) for new projects."},{"content":"You should only use DAO in maintaining existing applications.","pos":[307,368]}]}]},{"content":"When using the MFC DAO database classes, there may be situations where it is necessary to use DAO directly.","pos":[1313,1420]},{"content":"Usually, this will not be the case, but MFC has provided some helper mechanisms to facilitate making direct DAO calls simple when combining the use of the MFC classes with direct DAO calls.","pos":[1421,1610]},{"content":"Making direct DAO calls to the methods of an MFC-managed DAO object should require only a few lines of code.","pos":[1611,1719]},{"content":"If you need to create and use DAO objects that are <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> managed by MFC, you will have to do a little more work by actually calling <bpt id=\"p2\">**</bpt>Release<ept id=\"p2\">**</ept> on the object.","pos":[1720,1878],"source":" If you need to create and use DAO objects that are *not* managed by MFC, you will have to do a little more work by actually calling **Release** on the object."},{"content":"This technical note explains when you might want to call DAO directly, what the MFC helpers can do to help you, and how to use the DAO OLE interfaces.","pos":[1879,2029]},{"content":"Finally, this note provides some sample functions showing how to call DAO directly for DAO security features.","pos":[2030,2139]},{"content":"When to Make Direct DAO Calls","pos":[2148,2177]},{"content":"The most common situations for making direct DAO calls occur when collections need to be refreshed or when you are implementing features not wrapped by MFC.","pos":[2181,2337]},{"content":"The most significant feature not exposed by MFC is security.","pos":[2338,2398]},{"content":"If you want to implement security features, you will need to use the DAO User(s) and Group(s) objects directly.","pos":[2399,2510]},{"content":"Besides security, there are only a few other DAO features not supported by MFC.","pos":[2511,2590]},{"content":"These include recordset cloning and database replication features as well as a few late additions to DAO.","pos":[2591,2696]},{"content":"A Brief Overview of DAO and MFC's Implementation","pos":[2705,2753]},{"content":"MFC's wrapping of DAO makes using DAO easier by handling many of the details so you do not have to worry about the little things.","pos":[2757,2886]},{"content":"This includes the initialization of OLE, the creation and management of the DAO objects (especially the collection objects), error checking, and providing a strongly typed, simpler interface (no <bpt id=\"p1\">**</bpt>VARIANT<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`BSTR`</ph> arguments).","pos":[2887,3115],"source":" This includes the initialization of OLE, the creation and management of the DAO objects (especially the collection objects), error checking, and providing a strongly typed, simpler interface (no **VARIANT** or `BSTR` arguments)."},{"content":"You can make direct DAO calls and still take advantage of these features.","pos":[3116,3189]},{"content":"All your code must do is call <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept> for any objects created by direct DAO calls and <bpt id=\"p2\">*</bpt>not<ept id=\"p2\">*</ept> modify any of the interface pointers that MFC may rely on internally.","pos":[3190,3355],"source":" All your code must do is call **Release** for any objects created by direct DAO calls and *not* modify any of the interface pointers that MFC may rely on internally."},{"content":"For example, do not modify the <bpt id=\"p1\">**</bpt>m_pDAORecordset<ept id=\"p1\">**</ept> member of an open <ph id=\"ph1\">`CDaoRecordset`</ph> object unless you understand <bpt id=\"p2\">*</bpt>all<ept id=\"p2\">*</ept> the internal ramifications.","pos":[3356,3503],"source":" For example, do not modify the **m_pDAORecordset** member of an open `CDaoRecordset` object unless you understand *all* the internal ramifications."},{"content":"You could, however, use the <bpt id=\"p1\">**</bpt>m_pDAORecordset<ept id=\"p1\">**</ept> interface to call DAO directly to get the Fields collection.","pos":[3504,3612],"source":" You could, however, use the **m_pDAORecordset** interface to call DAO directly to get the Fields collection."},{"content":"In this case the <bpt id=\"p1\">**</bpt>m_pDAORecordset<ept id=\"p1\">**</ept> member would not be modified.","pos":[3613,3679],"source":" In this case the **m_pDAORecordset** member would not be modified."},{"content":"You simply have to call <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept> on the Fields collection object when you are finished with the object.","pos":[3680,3786],"source":" You simply have to call **Release** on the Fields collection object when you are finished with the object."},{"content":"Description of Helpers to Make DAO Calls Easier","pos":[3795,3842]},{"content":"The helpers provided to make calling DAO easier are the same helpers that are used internally in the MFC DAO Database classes.","pos":[3846,3972]},{"content":"These helpers are used to check the return codes when making a direct DAO call, logging debug output, checking for expected errors, and throwing appropriate exceptions if necessary.","pos":[3973,4154]},{"content":"There are two underlying helper functions and four macros that map to one of these two helpers.","pos":[4155,4250]},{"content":"The best explanation would be to simply read the code.","pos":[4251,4305]},{"content":"See <bpt id=\"p1\">**</bpt>DAO_CHECK<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>DAO_CHECK_ERROR<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>DAO_CHECK_MEM<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>DAO_TRACE<ept id=\"p4\">**</ept> in AFXDAO.H to see the macros, and see <bpt id=\"p5\">**</bpt>AfxDaoCheck<ept id=\"p5\">**</ept> and <bpt id=\"p6\">**</bpt>AfxDaoTrace<ept id=\"p6\">**</ept> in DAOCORE.CPP.","pos":[4306,4473],"source":" See **DAO_CHECK**, **DAO_CHECK_ERROR**, **DAO_CHECK_MEM**, and **DAO_TRACE** in AFXDAO.H to see the macros, and see **AfxDaoCheck** and **AfxDaoTrace** in DAOCORE.CPP."},{"content":"Using the DAO OLE Interfaces","pos":[4482,4510]},{"content":"The OLE interfaces for each object in the DAO object hierarchy are defined in the header file DBDAOINT.H, which is found in the \\Program Files\\Microsoft Visual Studio .NET 2003\\VC7\\include directory.","pos":[4514,4713]},{"content":"These interfaces provide methods that allow you to manipulate the entire DAO hierarchy.","pos":[4714,4801]},{"content":"For many of the methods in the DAO interfaces, you will need to manipulate a <ph id=\"ph1\">`BSTR`</ph> object (a length-prefixed string used in OLE automation).","pos":[4808,4949],"source":"For many of the methods in the DAO interfaces, you will need to manipulate a `BSTR` object (a length-prefixed string used in OLE automation)."},{"content":"The <ph id=\"ph1\">`BSTR`</ph> object typically is encapsulated within the <bpt id=\"p1\">**</bpt>VARIANT<ept id=\"p1\">**</ept> data type.","pos":[4950,5027],"source":" The `BSTR` object typically is encapsulated within the **VARIANT** data type."},{"content":"The MFC class <ph id=\"ph1\">`COleVariant`</ph> itself inherits from the <bpt id=\"p1\">**</bpt>VARIANT<ept id=\"p1\">**</ept> data type.","pos":[5028,5103],"source":" The MFC class `COleVariant` itself inherits from the **VARIANT** data type."},{"content":"Depending on whether you build your project for ANSI or Unicode, the DAO interfaces will return ANSI or Unicode <ph id=\"ph1\">`BSTR`</ph>s.","pos":[5104,5224],"source":" Depending on whether you build your project for ANSI or Unicode, the DAO interfaces will return ANSI or Unicode `BSTR`s."},{"content":"Two macros, <bpt id=\"p1\">**</bpt>V_BSTR<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>V_BSTRT<ept id=\"p2\">**</ept>, are useful for assuring that the DAO interface gets the <ph id=\"ph1\">`BSTR`</ph> of the expected type.","pos":[5225,5349],"source":" Two macros, **V_BSTR** and **V_BSTRT**, are useful for assuring that the DAO interface gets the `BSTR` of the expected type."},{"content":"<bpt id=\"p1\">**</bpt>V_BSTR<ept id=\"p1\">**</ept> will extract the <bpt id=\"p2\">**</bpt>bstrVal<ept id=\"p2\">**</ept> member of a <ph id=\"ph1\">`COleVariant`</ph>.","pos":[5356,5422],"source":"**V_BSTR** will extract the **bstrVal** member of a `COleVariant`."},{"content":"This macro is typically used when you need to pass the contents of a <ph id=\"ph1\">`COleVariant`</ph> to a method of a DAO interface.","pos":[5423,5537],"source":" This macro is typically used when you need to pass the contents of a `COleVariant` to a method of a DAO interface."},{"content":"The following code fragment shows both the declarations and actual use for two methods of the DAO DAOUser interface that take advantage of the <bpt id=\"p1\">**</bpt>V_BSTR<ept id=\"p1\">**</ept> macro:","pos":[5538,5698],"source":" The following code fragment shows both the declarations and actual use for two methods of the DAO DAOUser interface that take advantage of the **V_BSTR** macro:"},{"content":"Note that the <ph id=\"ph1\">`VT_BSTRT`</ph> argument specified in the <ph id=\"ph2\">`COleVariant`</ph> constructor above ensures that there will be an ANSI <ph id=\"ph3\">`BSTR`</ph> in the <ph id=\"ph4\">`COleVariant`</ph> if you build an ANSI version of your application and a Unicode <ph id=\"ph5\">`BSTR`</ph> for a Unicode version of your application.","pos":[6142,6400],"source":"Note that the `VT_BSTRT` argument specified in the `COleVariant` constructor above ensures that there will be an ANSI `BSTR` in the `COleVariant` if you build an ANSI version of your application and a Unicode `BSTR` for a Unicode version of your application."},{"content":"This is what DAO expects.","pos":[6401,6426]},{"content":"The other macro, <bpt id=\"p1\">**</bpt>V_BSTRT<ept id=\"p1\">**</ept>, will extract either an ANSI or Unicode <bpt id=\"p2\">**</bpt>bstrVal<ept id=\"p2\">**</ept> member of <ph id=\"ph1\">`COleVariant`</ph> depending on the type of build (ANSI or Unicode).","pos":[6433,6587],"source":"The other macro, **V_BSTRT**, will extract either an ANSI or Unicode **bstrVal** member of `COleVariant` depending on the type of build (ANSI or Unicode)."},{"content":"The following code demonstrates how to extract the <ph id=\"ph1\">`BSTR`</ph> value from a <ph id=\"ph2\">`COleVariant`</ph> into a <ph id=\"ph3\">`CString`</ph>:","pos":[6588,6690],"source":" The following code demonstrates how to extract the `BSTR` value from a `COleVariant` into a `CString`:"},{"content":"The <bpt id=\"p1\">**</bpt>V_BSTRT<ept id=\"p1\">**</ept> macro, along with other techniques to open other types that are stored in <ph id=\"ph1\">`COleVariant`</ph>, is demonstrated in the DAOVIEW sample.","pos":[6791,6934],"source":"The **V_BSTRT** macro, along with other techniques to open other types that are stored in `COleVariant`, is demonstrated in the DAOVIEW sample."},{"content":"Specifically, this translation is performed in the <bpt id=\"p1\">**</bpt>CCrack::strVARIANT<ept id=\"p1\">**</ept> method.","pos":[6935,7016],"source":" Specifically, this translation is performed in the **CCrack::strVARIANT** method."},{"content":"This method, where possible, translates the value of a <ph id=\"ph1\">`COleVariant`</ph> into an instance of <ph id=\"ph2\">`CString`</ph>.","pos":[7017,7116],"source":" This method, where possible, translates the value of a `COleVariant` into an instance of `CString`."},{"content":"Simple Example of a Direct Call to DAO","pos":[7125,7163]},{"content":"Situations may arise when it is necessary to refresh the underlying DAO collection objects.","pos":[7167,7258]},{"content":"Normally, this should not be necessary, but it is a simple procedure if it is necessary.","pos":[7259,7347]},{"content":"An example of when a collection might need to be refreshed is when operating in a multiuser environment with multiple users creating new tabledefs.","pos":[7348,7495]},{"content":"In this case your tabledefs collection might become stale.","pos":[7496,7554]},{"content":"To refresh the collection, you simply need to call the <bpt id=\"p1\">**</bpt>Refresh<ept id=\"p1\">**</ept> method of the particular collection object and check for errors:","pos":[7555,7686],"source":" To refresh the collection, you simply need to call the **Refresh** method of the particular collection object and check for errors:"},{"content":"Note that currently all DAO collection object interfaces are undocumented implementation details of the MFC DAO database classes.","pos":[7770,7899]},{"content":"Using DAO Directly for DAO Security Features","pos":[7908,7952]},{"content":"The MFC DAO database classes do not wrap DAO security features.","pos":[7956,8019]},{"content":"You must call methods of DAO interfaces to use some DAO security features.","pos":[8020,8094]},{"content":"The following function sets the system database and then changes the user's password.","pos":[8095,8180]},{"content":"This function calls three other functions, which are subsequently defined.","pos":[8181,8255]},{"content":"The next four examples demonstrate how to:","pos":[9990,10032]},{"content":"Set the system DAO database (.MDW file).","pos":[10042,10082]},{"content":"Set the default user and password.","pos":[10092,10126]},{"content":"Change the password of a user.","pos":[10136,10166]},{"content":"Change the password of an .MDB file.","pos":[10176,10212]},{"content":"Setting the System Database","pos":[10222,10249]},{"content":"Below is a sample function to set the system database that will be used by an application.","pos":[10253,10343]},{"content":"This function must be called before any other DAO calls are made.","pos":[10344,10409]},{"content":"Setting the Default User and Password","pos":[10879,10916]},{"content":"To set the default user and password for a system database, use the following function:","pos":[10920,11007]},{"content":"Changing a User's Password","pos":[11489,11515]},{"content":"To change a user's password, use the following function:","pos":[11519,11575]},{"content":"Changing the Password of an .MDB File","pos":[13304,13341]},{"content":"To change the password of an .MDB file, use the following function:","pos":[13345,13412]},{"content":"See Also","pos":[13969,13977]},{"content":"Technical Notes by Number","pos":[13982,14007]},{"content":"Technical Notes by Category","pos":[14051,14078]}],"content":"---\ntitle: \"TN054: Calling DAO Directly While Using MFC DAO Classes | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mfc.dao\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"MFC [C++], DAO and\"\n  - \"passwords [C++], calling DAO\"\n  - \"security [MFC], DAO\"\n  - \"DAO (Data Access Objects), calling directly\"\n  - \"DAO (Data Access Objects), security\"\n  - \"security [MFC]\"\n  - \"TN054\"\n  - \"DAO (Data Access Objects), and MFC\"\nms.assetid: f7de7d85-8d6c-4426-aa05-2e617c0da957\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN054: Calling DAO Directly While Using MFC DAO Classes\n> [!NOTE]\n>  As of Visual C++ .NET, the Visual C++ environment and wizards no longer support DAO (although the DAO classes are included and you can still use them). Microsoft recommends that you use [OLE DB Templates](../data/oledb/ole-db-templates.md) or [ODBC and MFC](../data/odbc/odbc-and-mfc.md) for new projects. You should only use DAO in maintaining existing applications.  \n  \n When using the MFC DAO database classes, there may be situations where it is necessary to use DAO directly. Usually, this will not be the case, but MFC has provided some helper mechanisms to facilitate making direct DAO calls simple when combining the use of the MFC classes with direct DAO calls. Making direct DAO calls to the methods of an MFC-managed DAO object should require only a few lines of code. If you need to create and use DAO objects that are *not* managed by MFC, you will have to do a little more work by actually calling **Release** on the object. This technical note explains when you might want to call DAO directly, what the MFC helpers can do to help you, and how to use the DAO OLE interfaces. Finally, this note provides some sample functions showing how to call DAO directly for DAO security features.  \n  \n## When to Make Direct DAO Calls  \n The most common situations for making direct DAO calls occur when collections need to be refreshed or when you are implementing features not wrapped by MFC. The most significant feature not exposed by MFC is security. If you want to implement security features, you will need to use the DAO User(s) and Group(s) objects directly. Besides security, there are only a few other DAO features not supported by MFC. These include recordset cloning and database replication features as well as a few late additions to DAO.  \n  \n## A Brief Overview of DAO and MFC's Implementation  \n MFC's wrapping of DAO makes using DAO easier by handling many of the details so you do not have to worry about the little things. This includes the initialization of OLE, the creation and management of the DAO objects (especially the collection objects), error checking, and providing a strongly typed, simpler interface (no **VARIANT** or `BSTR` arguments). You can make direct DAO calls and still take advantage of these features. All your code must do is call **Release** for any objects created by direct DAO calls and *not* modify any of the interface pointers that MFC may rely on internally. For example, do not modify the **m_pDAORecordset** member of an open `CDaoRecordset` object unless you understand *all* the internal ramifications. You could, however, use the **m_pDAORecordset** interface to call DAO directly to get the Fields collection. In this case the **m_pDAORecordset** member would not be modified. You simply have to call **Release** on the Fields collection object when you are finished with the object.  \n  \n## Description of Helpers to Make DAO Calls Easier  \n The helpers provided to make calling DAO easier are the same helpers that are used internally in the MFC DAO Database classes. These helpers are used to check the return codes when making a direct DAO call, logging debug output, checking for expected errors, and throwing appropriate exceptions if necessary. There are two underlying helper functions and four macros that map to one of these two helpers. The best explanation would be to simply read the code. See **DAO_CHECK**, **DAO_CHECK_ERROR**, **DAO_CHECK_MEM**, and **DAO_TRACE** in AFXDAO.H to see the macros, and see **AfxDaoCheck** and **AfxDaoTrace** in DAOCORE.CPP.  \n  \n## Using the DAO OLE Interfaces  \n The OLE interfaces for each object in the DAO object hierarchy are defined in the header file DBDAOINT.H, which is found in the \\Program Files\\Microsoft Visual Studio .NET 2003\\VC7\\include directory. These interfaces provide methods that allow you to manipulate the entire DAO hierarchy.  \n  \n For many of the methods in the DAO interfaces, you will need to manipulate a `BSTR` object (a length-prefixed string used in OLE automation). The `BSTR` object typically is encapsulated within the **VARIANT** data type. The MFC class `COleVariant` itself inherits from the **VARIANT** data type. Depending on whether you build your project for ANSI or Unicode, the DAO interfaces will return ANSI or Unicode `BSTR`s. Two macros, **V_BSTR** and **V_BSTRT**, are useful for assuring that the DAO interface gets the `BSTR` of the expected type.  \n  \n **V_BSTR** will extract the **bstrVal** member of a `COleVariant`. This macro is typically used when you need to pass the contents of a `COleVariant` to a method of a DAO interface. The following code fragment shows both the declarations and actual use for two methods of the DAO DAOUser interface that take advantage of the **V_BSTR** macro:  \n  \n```  \nCOleVariant varOldName;  \nCOleVariant varNewName(_T(\"NewUser\"), VT_BSTRT);\n\n \n// Code to assign pUser to a valid value omitted  \nDAOUser *pUser = NULL;  \n \n// These method declarations were taken from DBDAOINT.H  \n// STDMETHOD(get_Name) (THIS_ BSTR FAR* pbstr) PURE;  \n// STDMETHOD(put_Name) (THIS_ BSTR bstr) PURE;  \n \nDAO_CHECK(pUser->get_Name(&V_BSTR (&varOldName)));\n\nDAO_CHECK(pUser->put_Name(V_BSTR (&varNewName)));\n```  \n  \n Note that the `VT_BSTRT` argument specified in the `COleVariant` constructor above ensures that there will be an ANSI `BSTR` in the `COleVariant` if you build an ANSI version of your application and a Unicode `BSTR` for a Unicode version of your application. This is what DAO expects.  \n  \n The other macro, **V_BSTRT**, will extract either an ANSI or Unicode **bstrVal** member of `COleVariant` depending on the type of build (ANSI or Unicode). The following code demonstrates how to extract the `BSTR` value from a `COleVariant` into a `CString`:  \n  \n```  \nCOleVariant varName(_T(\"MyName\"), VT_BSTRT);\n\nCString str = V_BSTRT(&varName);\n```  \n  \n The **V_BSTRT** macro, along with other techniques to open other types that are stored in `COleVariant`, is demonstrated in the DAOVIEW sample. Specifically, this translation is performed in the **CCrack::strVARIANT** method. This method, where possible, translates the value of a `COleVariant` into an instance of `CString`.  \n  \n## Simple Example of a Direct Call to DAO  \n Situations may arise when it is necessary to refresh the underlying DAO collection objects. Normally, this should not be necessary, but it is a simple procedure if it is necessary. An example of when a collection might need to be refreshed is when operating in a multiuser environment with multiple users creating new tabledefs. In this case your tabledefs collection might become stale. To refresh the collection, you simply need to call the **Refresh** method of the particular collection object and check for errors:  \n  \n```  \nDAO_CHECK(pMyDaoDatabase->  \n    m_pDAOTableDefs->Refresh());\n```  \n  \n Note that currently all DAO collection object interfaces are undocumented implementation details of the MFC DAO database classes.  \n  \n## Using DAO Directly for DAO Security Features  \n The MFC DAO database classes do not wrap DAO security features. You must call methods of DAO interfaces to use some DAO security features. The following function sets the system database and then changes the user's password. This function calls three other functions, which are subsequently defined.  \n  \n```  \nvoid ChangeUserPassword()  \n{ *// Specify path to the Microsoft Access *// system database  \n    CString strSystemDB = \n    _T(\"c:\\\\Program Files\\\\MSOffice\\\\access\\\\System.mdw\");\n\n *// Set system database before MFC initilizes DAO *// NOTE: An MFC module uses only one instance *// of a DAO database engine object. If you have *// called a DAO object in your application prior *// to calling the function below,\n    you must call *// AfxDaoTerm to destroy the existing database *// engine object. Otherwise,\n    the database engine *// object already in use will be reused,\n    and setting *// a system datbase will have no effect. *// *// If you have used a DAO object prior to calling *// this function it is important that DAO be *// terminated with AfxDaoTerm since an MFC *// module only gets one copy of the database engine *// and that engine will be reused if it hasn't been *// terminated. In other words,\n    if you do not call *// AfxDaoTerm and there is currently a database *// initialized,\n    setting the system database will *// have no affect.  \n \n    SetSystemDB(strSystemDB);\n\n *// User name and password manually added *// by using Microsoft Access  \n    CString strUserName = _T(\"NewUser\");\n\n    CString strOldPassword = _T(\"Password\");\n\n    CString strNewPassword = _T(\"NewPassword\");\n\n *// Set default user so that MFC will be able *// to log in by default using the user name and *// password from the system database  \n    SetDefaultUser(strUserName,\n    strOldPassword);\n\n *// Change the password. You should be able to *// call this function from anywhere in your *// MFC application  \n    ChangePassword(strUserName,\n    strOldPassword,   \n    strNewPassword);\n\n \n .  \n .  \n .  \n \n}  \n```  \n  \n The next four examples demonstrate how to:  \n  \n-   Set the system DAO database (.MDW file).  \n  \n-   Set the default user and password.  \n  \n-   Change the password of a user.  \n  \n-   Change the password of an .MDB file.  \n  \n### Setting the System Database  \n Below is a sample function to set the system database that will be used by an application. This function must be called before any other DAO calls are made.  \n  \n```  \n// Set the system database that the   \n// DAO database engine will use  \n \nvoid SetSystemDB(CString& strSystemMDB)  \n{  \n    COleVariant varSystemDB(strSystemMDB, VT_BSTRT);\n\n *// Initialize DAO for MFC  \n    AfxDaoInit();\nDAODBEngine* pDBEngine = AfxDaoGetEngine();\n\n \n    ASSERT(pDBEngine != NULL);\n\n *// Call put_SystemDB method to set the *// system database for DAO engine  \n    DAO_CHECK(pDBEngine->put_SystemDB(varSystemDB.bstrVal));\n\n} \n```  \n  \n### Setting the Default User and Password  \n To set the default user and password for a system database, use the following function:  \n  \n```  \nvoid SetDefaultUser(CString& strUserName,\n    CString& strPassword)  \n{  \n    COleVariant varUserName(strUserName,\n    VT_BSTRT);\n\n    COleVariant varPassword(strPassword,\n    VT_BSTRT);\n\n \n    DAODBEngine* pDBEngine = AfxDaoGetEngine();\nASSERT(pDBEngine != NULL);\n\n *// Set default user:  \n    DAO_CHECK(pDBEngine->put_DefaultUser(varUserName.bstrVal));\n\n *// Set default password:  \n    DAO_CHECK(pDBEngine->put_DefaultPassword(varPassword.bstrVal));\n\n} \n```  \n  \n### Changing a User's Password  \n To change a user's password, use the following function:  \n  \n```  \nvoid ChangePassword(CString &strUserName,   \n    CString &strOldPassword,   \n    CString &strNewPassword)  \n{ *// Create (open) a workspace  \n    CDaoWorkspace wsp;  \n    CString strWspName = _T(\"Temp Workspace\");\n\n \n    wsp.Create(strWspName, strUserName,  \n    strOldPassword);\n\n wsp.Append();\n\n *// Determine how many objects there are *// in the Users collection  \n    short nUserCount;  \n    short nCurrentUser;  \n    DAOUser *pUser = NULL;  \n    DAOUsers *pUsers = NULL;  \n *// Side-effect is implicit OLE AddRef() *// on DAOUser object:  \n    DAO_CHECK(wsp.m_pDAOWorkspace->get_Users(&pUsers));\n\n *// Side-effect is implicit OLE AddRef() *// on DAOUsers object  \n    DAO_CHECK(pUsers->getcount(&nUserCount));\n\n *// Traverse through the list of users *// and change password for the userid *// used to create/open the workspace  \n    for(nCurrentUser = 0; nCurrentUser <nUserCount;  \n    nCurrentUser++) \n {  \n    COleVariant varIndex(nCurrentUser, VT_I2);\n\n    COleVariant varName;  \n *// Retrieve information for user nCurrentUser  \n    DAO_CHECK(pUsers->get_Item(varIndex, &pUser));\n\n *// Retrieve name for user nCurrentUser  \n    DAO_CHECK(pUser->get_Name(&V_BSTR(&varName)));\n\n \n    CString strTemp = V_BSTRT(&varName);\n\n *// If there is a match, change the password  \n    if(strTemp == strUserName)  \n {  \n    COleVariant varOldPwd(strOldPassword,   \n    VT_BSTRT);\n\n COleVariant  varNewPwd(strNewPassword,   \n    VT_BSTRT);\n\n \n    DAO_CHECK(pUser->NewPassword(V_BSTR(&varOldPwd), \n    V_BSTR(&varNewPwd)));\n\n \n    TRACE(\"\\t Password is changed\\n\");\n\n }  \n }  \n *// Clean up: decrement the usage count *// on the OLE objects  \n    pUser->Release();\npUsers->Release();\n\n \n    wsp.Close();\n\n} \n```  \n  \n### Changing the Password of an .MDB File  \n To change the password of an .MDB file, use the following function:  \n  \n```  \nvoid SetDBPassword(LPCTSTR pDB,\n    LPCTSTR pszOldPassword,\n    LPCTSTR pszNewPassword)  \n{  \n    CDaoDatabase db;  \n    CString strConnect(_T(\";pwd=\"));\n\n *// the database must be opened as exclusive *// to set a password  \n    db.Open(pDB,\n    TRUE,\n    FALSE,   \n    strConnect + pszOldPassword);\n\n \n    COleVariant NewPassword(pszNewPassword,\n    VT_BSTRT),  \n    OldPassword(pszOldPassword,\n    VT_BSTRT);\n\n \n    DAO_CHECK(db.m_pDAODatabase->NewPassword(V_BSTR(&OldPassword), \n    V_BSTR(&NewPassword)));\n\n \n    db.Close();\n\n} \n```  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}