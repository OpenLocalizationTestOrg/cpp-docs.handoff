{"nodes":[{"pos":[12,53],"content":"Value Types (Modern C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Value Types (Modern C++) | Microsoft Docs","pos":[0,41]}]},{"content":"Value Types (Modern C++)","pos":[560,584]},{"content":"C++ classes are by default value types.","pos":[585,624]},{"content":"This topic provides an introductory overview of value types and issues relating to their use.","pos":[625,718]},{"content":"Value vs. reference types","pos":[727,752]},{"content":"As previously stated, C++ classes are by default value types.","pos":[756,817]},{"content":"They can be specified as reference types, which enable polymorphic behavior to support object-oriented programming.","pos":[818,933]},{"content":"Value types are sometimes viewed from the perspective of memory and layout control, whereas reference types are about base classes and virtual functions for polymorphic purposes.","pos":[934,1112]},{"content":"By default, value types are copyable, which means there is always a copy constructor and a copy assignment operator.","pos":[1113,1229]},{"content":"For reference types, you make the class non-copyable (disable the copy constructor and copy assignment operator) and use a virtual destructor, which supports their intended polymorphism.","pos":[1230,1416]},{"content":"Value types are also about the contents, which, when they are copied, always give you two independent values that can be modified separately.","pos":[1417,1558]},{"content":"Reference types are about identity – what kind of object is it?","pos":[1559,1622]},{"content":"For this reason, \"reference types\" are also referred to as \"polymorphic types\".","pos":[1623,1702]},{"pos":[1709,1879],"content":"If you really want a reference-like type (base class, virtual functions), you need to explicitly disable copying, as shown in the <ph id=\"ph1\">`MyRefType`</ph> class in the following code.","source":"If you really want a reference-like type (base class, virtual functions), you need to explicitly disable copying, as shown in the `MyRefType` class in the following code."},{"content":"Compiling the above code will result in the following error:","pos":[2176,2236]},{"content":"Value types and move efficiency","pos":[2506,2537]},{"content":"Copy allocation overhead is avoided due to new copy optimizations.","pos":[2541,2607]},{"content":"For example, when you insert a string in the middle of a vector of strings, there will be no copy re-allocation overhead, only a move- even if it results in a grow of the vector itself.","pos":[2608,2793]},{"content":"This also applies to other operations, for instance performing an add operation on two very large objects.","pos":[2794,2900]},{"content":"How do you enable these value operation optimizations?","pos":[2901,2955]},{"content":"In some C++ compilers, the compiler will enable this for you implicitly, much like copy constructors can be automatically generated by the compiler.","pos":[2956,3104]},{"content":"However, in Visual C++, your class will need to \"opt-in\" to move assignment and constructors by declaring it in your class definition.","pos":[3105,3239]},{"content":"This is accomplished by using the double ampersand (&amp;&amp;) rvalue reference in the appropriate member function declarations and defining move constructor and move assignment methods.","pos":[3240,3419],"source":" This is accomplished by using the double ampersand (&&) rvalue reference in the appropriate member function declarations and defining move constructor and move assignment methods."},{"content":"You also need to insert the correct code to \"steal the guts\" out of the source object.","pos":[3421,3507]},{"content":"How do you decide if you need move enabled?","pos":[3514,3557]},{"content":"If you already know you need copy construction enabled, you probably want move enabled if it can be cheaper than a deep copy.","pos":[3558,3683]},{"content":"However, if you know you need move support, it doesn't necessarily mean you want copy enabled.","pos":[3684,3778]},{"content":"This latter case would be called a \"move-only type\".","pos":[3779,3831]},{"content":"An example already in the standard library is <ph id=\"ph1\">`unique_ptr`</ph>.","pos":[3832,3891],"source":" An example already in the standard library is `unique_ptr`."},{"content":"As a side note, the old <ph id=\"ph1\">`auto_ptr`</ph> is deprecated, and was replaced by <ph id=\"ph2\">`unique_ptr`</ph> precisely due to the lack of move semantics support in the previous version of C++.","pos":[3892,4058],"source":" As a side note, the old `auto_ptr` is deprecated, and was replaced by `unique_ptr` precisely due to the lack of move semantics support in the previous version of C++."},{"content":"By using move semantics you can return-by-value or insert-in-middle.","pos":[4065,4133]},{"content":"Move is an optimization of copy.","pos":[4134,4166]},{"content":"There is need for heap allocation as a workaround.","pos":[4167,4217]},{"content":"Consider the following pseudocode:","pos":[4218,4252]},{"content":"Enabling move for appropriate value types","pos":[5107,5148]},{"content":"For a value-like class where move can be cheaper than a deep copy, enable move construction and move assignment for efficiency.","pos":[5152,5279]},{"content":"Consider the following pseudocode:","pos":[5280,5314]},{"content":"If you enable copy construction/assignment, also enable move construction/assignment if it can be cheaper than a deep copy.","pos":[5885,6008]},{"content":"Some <bpt id=\"p1\">*</bpt>non-value<ept id=\"p1\">*</ept> types are move-only, such as when you can’t clone a resource, only transfer ownership.","pos":[6015,6118],"source":"Some *non-value* types are move-only, such as when you can’t clone a resource, only transfer ownership."},{"content":"Example: <ph id=\"ph1\">`unique_ptr`</ph>.","pos":[6119,6141],"source":" Example: `unique_ptr`."},{"content":"Section","pos":[6150,6157]},{"content":"Content","pos":[6161,6168]},{"content":"See Also","pos":[6177,6185]},{"content":"C++ Type System","pos":[6190,6205]},{"content":"Welcome Back to C++","pos":[6250,6269]},{"content":"C++ Language Reference","pos":[6318,6340]},{"content":"C++ Standard Library","pos":[6381,6401]}],"content":"---\ntitle: \"Value Types (Modern C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: f63bb62c-60da-40d5-ac14-4366608fe260\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Value Types (Modern C++)\nC++ classes are by default value types. This topic provides an introductory overview of value types and issues relating to their use.  \n  \n## Value vs. reference types  \n As previously stated, C++ classes are by default value types. They can be specified as reference types, which enable polymorphic behavior to support object-oriented programming. Value types are sometimes viewed from the perspective of memory and layout control, whereas reference types are about base classes and virtual functions for polymorphic purposes. By default, value types are copyable, which means there is always a copy constructor and a copy assignment operator. For reference types, you make the class non-copyable (disable the copy constructor and copy assignment operator) and use a virtual destructor, which supports their intended polymorphism. Value types are also about the contents, which, when they are copied, always give you two independent values that can be modified separately. Reference types are about identity – what kind of object is it? For this reason, \"reference types\" are also referred to as \"polymorphic types\".  \n  \n If you really want a reference-like type (base class, virtual functions), you need to explicitly disable copying, as shown in the `MyRefType` class in the following code.  \n  \n```cpp  \n  \n// cl /EHsc /nologo /W4  \n  \nclass MyRefType {  \nprivate:  \n    MyRefType & operator=(const MyRefType &);  \n    MyRefType(const MyRefType &);  \npublic:  \n    MyRefType () {}  \n};  \n  \nint main()  \n{  \n    MyRefType Data1, Data2;  \n    // ...  \n    Data1 = Data2;  \n}  \n```  \n  \n Compiling the above code will result in the following error:  \n  \n```Output  \ntest.cpp(15) : error C2248: 'MyRefType::operator =' : cannot access private member declared in class 'MyRefType'  \n        meow.cpp(5) : see declaration of 'MyRefType::operator ='  \n        meow.cpp(3) : see declaration of 'MyRefType'  \n  \n```  \n  \n## Value types and move efficiency  \n Copy allocation overhead is avoided due to new copy optimizations. For example, when you insert a string in the middle of a vector of strings, there will be no copy re-allocation overhead, only a move- even if it results in a grow of the vector itself. This also applies to other operations, for instance performing an add operation on two very large objects. How do you enable these value operation optimizations? In some C++ compilers, the compiler will enable this for you implicitly, much like copy constructors can be automatically generated by the compiler. However, in Visual C++, your class will need to \"opt-in\" to move assignment and constructors by declaring it in your class definition. This is accomplished by using the double ampersand (&&) rvalue reference in the appropriate member function declarations and defining move constructor and move assignment methods.  You also need to insert the correct code to \"steal the guts\" out of the source object.  \n  \n How do you decide if you need move enabled? If you already know you need copy construction enabled, you probably want move enabled if it can be cheaper than a deep copy. However, if you know you need move support, it doesn't necessarily mean you want copy enabled. This latter case would be called a \"move-only type\". An example already in the standard library is `unique_ptr`. As a side note, the old `auto_ptr` is deprecated, and was replaced by `unique_ptr` precisely due to the lack of move semantics support in the previous version of C++.  \n  \n By using move semantics you can return-by-value or insert-in-middle. Move is an optimization of copy. There is need for heap allocation as a workaround. Consider the following pseudocode:  \n  \n```cpp  \n  \n#include <set>  \n#include <vector>  \n#include <string>  \nusing namespace std;  \n  \n//...  \nset<widget> LoadHugeData() {  \n    set<widget> ret;  \n    // ... load data from disk and populate ret  \n    return ret;  \n}  \n//...  \nwidgets = LoadHugeData();   // efficient, no deep copy  \n  \nvector<string> v = IfIHadAMillionStrings();  \nv.insert( begin(v)+v.size()/2, \"scott\" );   // efficient, no deep copy-shuffle  \nv.insert( begin(v)+v.size()/2, \"Andrei\" );  // (just 1M ptr/len assignments)  \n//...  \nHugeMatrix operator+(const HugeMatrix& , const HugeMatrix& );  \nHugeMatrix operator+(const HugeMatrix& ,       HugeMatrix&&);  \nHugeMatrix operator+(      HugeMatrix&&, const HugeMatrix& );  \nHugeMatrix operator+(      HugeMatrix&&,       HugeMatrix&&);  \n//...  \nhm5 = hm1+hm2+hm3+hm4+hm5;   // efficient, no extra copies  \n```  \n  \n### Enabling move for appropriate value types  \n For a value-like class where move can be cheaper than a deep copy, enable move construction and move assignment for efficiency. Consider the following pseudocode:  \n  \n```cpp  \n  \n#include <memory>  \n#include <stdexcept>  \nusing namespace std;  \n// ...  \nclass my_class {  \n    unique_ptr<BigHugeData> data;  \npublic:  \n    my_class( my_class&& other )   // move construction  \n        : data( move( other.data ) ) { }  \n    my_class& operator=( my_class&& other )   // move assignment  \n    { data = move( other.data ); return *this; }  \n    // ...  \n    void method() {   // check (if appropriate)  \n        if( !data )   \n            throw std::runtime_error(\"RUNTIME ERROR: Insufficient resources!\");  \n    }  \n};  \n  \n```  \n  \n If you enable copy construction/assignment, also enable move construction/assignment if it can be cheaper than a deep copy.  \n  \n Some *non-value* types are move-only, such as when you can’t clone a resource, only transfer ownership. Example: `unique_ptr`.  \n  \n## Section  \n Content  \n  \n## See Also  \n [C++ Type System](../cpp/cpp-type-system-modern-cpp.md)   \n [Welcome Back to C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   \n [C++ Language Reference](../cpp/cpp-language-reference.md)   \n [C++ Standard Library](../standard-library/cpp-standard-library-reference.md)"}