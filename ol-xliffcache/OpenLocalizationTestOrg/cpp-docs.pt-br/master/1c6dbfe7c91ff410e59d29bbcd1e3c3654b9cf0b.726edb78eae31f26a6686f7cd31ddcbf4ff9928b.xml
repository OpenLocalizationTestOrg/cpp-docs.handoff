{"nodes":[{"pos":[12,52],"content":"Sample Makefile for PCH | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Sample Makefile for PCH | Microsoft Docs","pos":[0,40]}]},{"content":"Sample Makefile for PCH","pos":[556,579]},{"content":"The following makefile uses macros and an !IF, !ELSE, !ENDIF flow-of-control command structure to simplify its adaptation to your project.","pos":[580,718]},{"content":"Aside from the STABLEHDRS, BOUNDRY, and UNSTABLEHDRS macros shown in the figure \"Structure of a Makefile That Uses a Precompiled Header File\" in <bpt id=\"p1\">[</bpt>PCH Files in the Build Process<ept id=\"p1\">](../../build/reference/pch-files-in-the-build-process.md)</ept>, this makefile provides a CLFLAGS macro and a LINKFLAGS macro.","pos":[2135,2432],"source":"Aside from the STABLEHDRS, BOUNDRY, and UNSTABLEHDRS macros shown in the figure \"Structure of a Makefile That Uses a Precompiled Header File\" in [PCH Files in the Build Process](../../build/reference/pch-files-in-the-build-process.md), this makefile provides a CLFLAGS macro and a LINKFLAGS macro."},{"content":"You must use these macros to list compiler and linker options that apply whether you build a debug or final version of the application's executable file.","pos":[2433,2586]},{"content":"There is also a LIBS macro where you list the libraries your project requires.","pos":[2587,2665]},{"content":"The makefile also uses !IF, !ELSE, !ENDIF to detect whether you define a DEBUG symbol on the NMAKE command line:","pos":[2672,2784]},{"content":"This feature makes it possible for you to use the same makefile during development and for the final versions of your program — use DEBUG=0 for the final versions.","pos":[2826,2989]},{"content":"The following command lines are equivalent:","pos":[2990,3033]},{"content":"For more information on makefiles, see <bpt id=\"p1\">[</bpt>NMAKE Reference<ept id=\"p1\">](../../build/nmake-reference.md)</ept>.","pos":[3080,3169],"source":"For more information on makefiles, see [NMAKE Reference](../../build/nmake-reference.md)."},{"content":"Also see <bpt id=\"p1\">[</bpt>Compiler Options<ept id=\"p1\">](../../build/reference/compiler-options.md)</ept> and the <bpt id=\"p2\">[</bpt>Linker Options<ept id=\"p2\">](../../build/reference/linker-options.md)</ept>.","pos":[3170,3307],"source":" Also see [Compiler Options](../../build/reference/compiler-options.md) and the [Linker Options](../../build/reference/linker-options.md)."},{"content":"See Also","pos":[3316,3324]},{"content":"Using Precompiled Headers in a Project","pos":[3329,3367]}],"content":"---\ntitle: \"Sample Makefile for PCH | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"pch\"\ndev_langs: \n  - \"C++\"\nms.assetid: daf68983-77dc-45db-8701-aa89ad18910d\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Sample Makefile for PCH\nThe following makefile uses macros and an !IF, !ELSE, !ENDIF flow-of-control command structure to simplify its adaptation to your project.  \n  \n```  \n# Makefile : Illustrates the effective use of precompiled  \n#            headers in a project  \n# Usage:     NMAKE option  \n# option:    DEBUG=[0|1]  \n#            (DEBUG not defined is equivalent to DEBUG=0)  \n#  \nOBJS = myapp.obj applib.obj  \n# List all stable header files in the STABLEHDRS macro.  \nSTABLEHDRS = stable.h another.h  \n# List the final header file to be precompiled here:  \nBOUNDRY = stable.h  \n# List header files under development here:  \nUNSTABLEHDRS = unstable.h  \n# List all compiler options common to both debug and final  \n# versions of your code here:  \nCLFLAGS = /c /W3  \n# List all linker options common to both debug and final  \n# versions of your code here:  \nLINKFLAGS = /NOD /ONERROR:NOEXE  \n!IF \"$(DEBUG)\" == \"1\"  \nCLFLAGS   = /D_DEBUG $(CLFLAGS) /Od /Zi /f  \nLINKFLAGS = $(LINKFLAGS) /COD  \nLIBS      = slibce  \n!ELSE  \nCLFLAGS   = $(CLFLAGS) /Oselg /Gs  \nLINKFLAGS = $(LINKFLAGS)  \nLIBS      = slibce  \n!ENDIF  \nmyapp.exe: $(OBJS)  \n    link $(LINKFLAGS) @<<  \n$(OBJS), myapp, NUL, $(LIBS), NUL;  \n<<  \n# Compile myapp  \nmyapp.obj  : myapp.cpp $(UNSTABLEHDRS)  stable.pch  \n    $(CPP) $(CLFLAGS) /Yu$(BOUNDRY)    myapp.cpp  \n# Compile applib  \napplib.obj : applib.cpp $(UNSTABLEHDRS) stable.pch  \n    $(CPP) $(CLFLAGS) /Yu$(BOUNDRY)    applib.cpp  \n# Compile headers  \nstable.pch : $(STABLEHDRS)  \n    $(CPP) $(CLFLAGS) /Yc$(BOUNDRY)    applib.cpp myapp.cpp  \n```  \n  \n Aside from the STABLEHDRS, BOUNDRY, and UNSTABLEHDRS macros shown in the figure \"Structure of a Makefile That Uses a Precompiled Header File\" in [PCH Files in the Build Process](../../build/reference/pch-files-in-the-build-process.md), this makefile provides a CLFLAGS macro and a LINKFLAGS macro. You must use these macros to list compiler and linker options that apply whether you build a debug or final version of the application's executable file. There is also a LIBS macro where you list the libraries your project requires.  \n  \n The makefile also uses !IF, !ELSE, !ENDIF to detect whether you define a DEBUG symbol on the NMAKE command line:  \n  \n```  \nNMAKE DEBUG=[1|0]  \n```  \n  \n This feature makes it possible for you to use the same makefile during development and for the final versions of your program — use DEBUG=0 for the final versions. The following command lines are equivalent:  \n  \n```  \nNMAKE   \nNMAKE DEBUG=0  \n```  \n  \n For more information on makefiles, see [NMAKE Reference](../../build/nmake-reference.md). Also see [Compiler Options](../../build/reference/compiler-options.md) and the [Linker Options](../../build/reference/linker-options.md).  \n  \n## See Also  \n [Using Precompiled Headers in a Project](../../build/reference/using-precompiled-headers-in-a-project.md)"}