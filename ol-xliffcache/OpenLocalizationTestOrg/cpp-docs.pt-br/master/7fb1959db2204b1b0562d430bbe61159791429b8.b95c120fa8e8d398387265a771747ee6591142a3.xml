{"nodes":[{"pos":[12,119],"content":"How to: Convert an OpenMP Loop that Uses Exception Handling to Use the Concurrency Runtime | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Convert an OpenMP Loop that Uses Exception Handling to Use the Concurrency Runtime | Microsoft Docs","pos":[0,107]}]},{"content":"How to: Convert an OpenMP Loop that Uses Exception Handling to Use the Concurrency Runtime","pos":[800,890]},{"pos":[891,1198],"content":"This example demonstrates how to convert an OpenMP <bpt id=\"p1\">[</bpt>parallel<ept id=\"p1\">](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md#parallel)</ept><bpt id=\"p2\">[</bpt>for<ept id=\"p2\">](../../parallel/openmp/reference/for-openmp.md)</ept> loop that performs exception handling to use the Concurrency Runtime exception handling mechanism.","source":"This example demonstrates how to convert an OpenMP [parallel](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md#parallel)[for](../../parallel/openmp/reference/for-openmp.md) loop that performs exception handling to use the Concurrency Runtime exception handling mechanism."},{"content":"In OpenMP, an exception that is thrown in a parallel region must be caught and handled in the same region by the same thread.","pos":[1205,1330]},{"content":"An exception that escapes the parallel region is caught by the unhandled exception handler, which terminates the process by default.","pos":[1331,1463]},{"content":"In the Concurrency Runtime, when you throw an exception in the body of a work function that you pass to a task group such as a <bpt id=\"p1\">[</bpt>concurrency::task_group<ept id=\"p1\">](reference/task-group-class.md)</ept> or <bpt id=\"p2\">[</bpt>concurrency::structured_task_group<ept id=\"p2\">](../../parallel/concrt/reference/structured-task-group-class.md)</ept> object, or to a parallel algorithm such as <bpt id=\"p3\">[</bpt>concurrency::parallel_for<ept id=\"p3\">](reference/concurrency-namespace-functions.md#parallel_for)</ept>, the runtime stores that exception and marshals it to the context that waits for the task group or algorithm to finish.","pos":[1471,2008],"source":"In the Concurrency Runtime, when you throw an exception in the body of a work function that you pass to a task group such as a [concurrency::task_group](reference/task-group-class.md) or [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) object, or to a parallel algorithm such as [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for), the runtime stores that exception and marshals it to the context that waits for the task group or algorithm to finish."},{"content":"For task groups, the waiting context is the context that calls <bpt id=\"p1\">[</bpt>concurrency::task_group::wait<ept id=\"p1\">](reference/task-group-class.md#wait)</ept>, <bpt id=\"p2\">[</bpt>concurrency::structured_task_group::wait<ept id=\"p2\">](reference/structured-task-group-class.md#wait)</ept>, <bpt id=\"p3\">[</bpt>concurrency::task_group::run_and_wait<ept id=\"p3\">](reference/task-group-class.md#run_and_wait)</ept>, or <bpt id=\"p4\">[</bpt>concurrency::structured_task_group::run_and_wait<ept id=\"p4\">](reference/structured-task-group-class.md#run_and_wait)</ept>.","pos":[2009,2426],"source":" For task groups, the waiting context is the context that calls [concurrency::task_group::wait](reference/task-group-class.md#wait), [concurrency::structured_task_group::wait](reference/structured-task-group-class.md#wait), [concurrency::task_group::run_and_wait](reference/task-group-class.md#run_and_wait), or [concurrency::structured_task_group::run_and_wait](reference/structured-task-group-class.md#run_and_wait)."},{"content":"For a parallel algorithm, the waiting context is the context that called that algorithm.","pos":[2427,2515]},{"content":"The runtime also stops all active tasks that are in the task group, including those in child task groups, and discards any tasks that have not yet started.","pos":[2516,2671]},{"content":"Example","pos":[2682,2689]},{"content":"This example demonstrates how to handle exceptions in an OpenMP <ph id=\"ph1\">`parallel`</ph> region and in a call to <ph id=\"ph2\">`parallel_for`</ph>.","pos":[2693,2807],"source":"This example demonstrates how to handle exceptions in an OpenMP `parallel` region and in a call to `parallel_for`."},{"content":"The <ph id=\"ph1\">`do_work`</ph> function performs a memory allocation request that does not succeed and therefore throws an exception of type <bpt id=\"p1\">[</bpt>std::bad_alloc<ept id=\"p1\">](../../standard-library/bad-alloc-class.md)</ept>.","pos":[2808,2992],"source":" The `do_work` function performs a memory allocation request that does not succeed and therefore throws an exception of type [std::bad_alloc](../../standard-library/bad-alloc-class.md)."},{"content":"In the version that uses OpenMP, the thread that throws the exception must also catch it.","pos":[2993,3082]},{"content":"In other words, each iteration of an OpenMP parallel loop must handle the exception.","pos":[3083,3167]},{"content":"In the version that uses the Concurrency Runtime, the main thread catches an exception that is thrown by another thread.","pos":[3168,3288]},{"pos":[3306,3321],"content":"concrt-openmp#3"},{"content":"This example produces the following output.","pos":[3427,3470]},{"content":"In the version of this example that uses OpenMP, the exception occurs in and is handled by each loop iteration.","pos":[4123,4234]},{"content":"In the version that uses the Concurrency Runtime, the runtime stores the exception, stops all active tasks, discards any tasks that have not yet started, and marshals the exception to the context that calls <ph id=\"ph1\">`parallel_for`</ph>.","pos":[4235,4457],"source":" In the version that uses the Concurrency Runtime, the runtime stores the exception, stops all active tasks, discards any tasks that have not yet started, and marshals the exception to the context that calls `parallel_for`."},{"content":"If you require that the version that uses OpenMP terminates after the exception occurs, you could use a Boolean flag to signal to other loop iterations that the error occurred.","pos":[4464,4640]},{"content":"As in the example in the topic <bpt id=\"p1\">[</bpt>How to: Convert an OpenMP Loop that Uses Cancellation to Use the Concurrency Runtime<ept id=\"p1\">](../../parallel/concrt/convert-an-openmp-loop-that-uses-cancellation.md)</ept>, subsequent loop iterations would do nothing if the flag is set.","pos":[4641,4895],"source":" As in the example in the topic [How to: Convert an OpenMP Loop that Uses Cancellation to Use the Concurrency Runtime](../../parallel/concrt/convert-an-openmp-loop-that-uses-cancellation.md), subsequent loop iterations would do nothing if the flag is set."},{"content":"Conversely, if you require that the loop that uses the Concurrency Runtime continues after the exception occurs, handle the exception in the parallel loop body itself.","pos":[4896,5063]},{"content":"Other components of the Concurrency Runtime, such as asynchronous agents and lightweight tasks, do not transport exceptions.","pos":[5070,5194]},{"content":"Instead, unhandled exceptions are caught by the unhandled exception handler, which terminates the process by default.","pos":[5195,5312]},{"content":"For more information about exception handling, see <bpt id=\"p1\">[</bpt>Exception Handling<ept id=\"p1\">](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)</ept>.","pos":[5313,5457],"source":" For more information about exception handling, see [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)."},{"pos":[5464,5609],"content":"For more information about <ph id=\"ph1\">`parallel_for`</ph> and other parallel algorithms, see <bpt id=\"p1\">[</bpt>Parallel Algorithms<ept id=\"p1\">](../../parallel/concrt/parallel-algorithms.md)</ept>.","source":"For more information about `parallel_for` and other parallel algorithms, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)."},{"content":"Compiling the Code","pos":[5618,5636]},{"pos":[5640,5843],"content":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named <ph id=\"ph1\">`concrt-omp-exceptions.cpp`</ph> and then run the following command in a Visual Studio Command Prompt window.","source":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `concrt-omp-exceptions.cpp` and then run the following command in a Visual Studio Command Prompt window."},{"content":"cl.exe /EHsc /openmp concrt-omp-exceptions.cpp","pos":[5852,5898]},{"content":"See Also","pos":[5909,5917]},{"content":"Migrating from OpenMP to the Concurrency Runtime","pos":[5922,5970]},{"content":"Exception Handling","pos":[6052,6070]},{"content":"Parallel Algorithms","pos":[6149,6168]}],"content":"---\ntitle: \"How to: Convert an OpenMP Loop that Uses Exception Handling to Use the Concurrency Runtime | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"exception handling, converting from OpenMP to the Concurrency Runtime\"\n  - \"converting from OpenMP to the Concurrency Runtime, exception handling\"\nms.assetid: 03c28196-21ba-439e-8641-afab1c283e1a\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# How to: Convert an OpenMP Loop that Uses Exception Handling to Use the Concurrency Runtime\nThis example demonstrates how to convert an OpenMP [parallel](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md#parallel)[for](../../parallel/openmp/reference/for-openmp.md) loop that performs exception handling to use the Concurrency Runtime exception handling mechanism.  \n  \n In OpenMP, an exception that is thrown in a parallel region must be caught and handled in the same region by the same thread. An exception that escapes the parallel region is caught by the unhandled exception handler, which terminates the process by default.  \n  \n\n In the Concurrency Runtime, when you throw an exception in the body of a work function that you pass to a task group such as a [concurrency::task_group](reference/task-group-class.md) or [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) object, or to a parallel algorithm such as [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for), the runtime stores that exception and marshals it to the context that waits for the task group or algorithm to finish. For task groups, the waiting context is the context that calls [concurrency::task_group::wait](reference/task-group-class.md#wait), [concurrency::structured_task_group::wait](reference/structured-task-group-class.md#wait), [concurrency::task_group::run_and_wait](reference/task-group-class.md#run_and_wait), or [concurrency::structured_task_group::run_and_wait](reference/structured-task-group-class.md#run_and_wait). For a parallel algorithm, the waiting context is the context that called that algorithm. The runtime also stops all active tasks that are in the task group, including those in child task groups, and discards any tasks that have not yet started.  \n\n\n  \n## Example  \n This example demonstrates how to handle exceptions in an OpenMP `parallel` region and in a call to `parallel_for`. The `do_work` function performs a memory allocation request that does not succeed and therefore throws an exception of type [std::bad_alloc](../../standard-library/bad-alloc-class.md). In the version that uses OpenMP, the thread that throws the exception must also catch it. In other words, each iteration of an OpenMP parallel loop must handle the exception. In the version that uses the Concurrency Runtime, the main thread catches an exception that is thrown by another thread.  \n  \n [!code-cpp[concrt-openmp#3](../../parallel/concrt/codesnippet/cpp/convert-an-openmp-loop-that uses-exception-handling_1.cpp)]  \n  \n This example produces the following output.  \n  \n```Output  \nUsing OpenMP...  \nAn error of type 'class std::bad_alloc' occurred.  \nAn error of type 'class std::bad_alloc' occurred.  \nAn error of type 'class std::bad_alloc' occurred.  \nAn error of type 'class std::bad_alloc' occurred.  \nAn error of type 'class std::bad_alloc' occurred.  \nAn error of type 'class std::bad_alloc' occurred.  \nAn error of type 'class std::bad_alloc' occurred.  \nAn error of type 'class std::bad_alloc' occurred.  \nAn error of type 'class std::bad_alloc' occurred.  \nAn error of type 'class std::bad_alloc' occurred.  \nUsing the Concurrency Runtime...  \nAn error of type 'class std::bad_alloc' occurred.  \n```  \n  \n In the version of this example that uses OpenMP, the exception occurs in and is handled by each loop iteration. In the version that uses the Concurrency Runtime, the runtime stores the exception, stops all active tasks, discards any tasks that have not yet started, and marshals the exception to the context that calls `parallel_for`.  \n  \n If you require that the version that uses OpenMP terminates after the exception occurs, you could use a Boolean flag to signal to other loop iterations that the error occurred. As in the example in the topic [How to: Convert an OpenMP Loop that Uses Cancellation to Use the Concurrency Runtime](../../parallel/concrt/convert-an-openmp-loop-that-uses-cancellation.md), subsequent loop iterations would do nothing if the flag is set. Conversely, if you require that the loop that uses the Concurrency Runtime continues after the exception occurs, handle the exception in the parallel loop body itself.  \n  \n Other components of the Concurrency Runtime, such as asynchronous agents and lightweight tasks, do not transport exceptions. Instead, unhandled exceptions are caught by the unhandled exception handler, which terminates the process by default. For more information about exception handling, see [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).  \n  \n For more information about `parallel_for` and other parallel algorithms, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md).  \n  \n## Compiling the Code  \n Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `concrt-omp-exceptions.cpp` and then run the following command in a Visual Studio Command Prompt window.  \n  \n **cl.exe /EHsc /openmp concrt-omp-exceptions.cpp**  \n  \n## See Also  \n [Migrating from OpenMP to the Concurrency Runtime](../../parallel/concrt/migrating-from-openmp-to-the-concurrency-runtime.md)   \n [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)   \n [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)\n\n"}