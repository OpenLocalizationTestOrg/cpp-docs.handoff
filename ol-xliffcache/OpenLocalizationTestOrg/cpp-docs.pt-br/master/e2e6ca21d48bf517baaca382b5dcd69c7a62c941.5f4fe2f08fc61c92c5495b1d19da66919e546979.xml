{"nodes":[{"pos":[12,53],"content":"&lt;memory&gt; operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"memory<ph id=\"ph1\">&amp;gt;</ph> operators | Microsoft Docs","pos":[4,41],"source":"memory&gt; operators | Microsoft Docs"}]},{"content":"memory<ph id=\"ph1\">&amp;gt;</ph> operators","pos":[260,280],"source":"memory&gt; operators"},{"content":"operator!=","pos":[300,310]},{"content":"operator","pos":[328,336]},{"content":"operator","pos":[358,366]},{"content":"operator","pos":[396,404]},{"content":"operator","pos":[426,434]},{"content":"operator","pos":[464,472]},{"content":"operator==","pos":[502,512]},{"pos":[570,580],"content":"operator!="},{"content":"Tests for inequality between objects.","pos":[584,621]},{"content":"Parameters","pos":[1052,1062]},{"content":"One of the objects to be tested for inequality.","pos":[1077,1124]},{"content":"One of the objects to be tested for inequality.","pos":[1143,1190]},{"content":"The type controlled by the left shared pointer.","pos":[1206,1253]},{"content":"The type controlled by the right shared pointer.","pos":[1269,1317]},{"content":"Return Value","pos":[1327,1339]},{"pos":[1343,1413],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the objects are not equal; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if objects are equal.","source":"**true** if the objects are not equal; **false** if objects are equal."},{"content":"Remarks","pos":[1423,1430]},{"content":"The first template operator returns false.","pos":[1434,1476]},{"content":"(All default allocators are equal.)","pos":[1477,1512]},{"pos":[1519,1595],"content":"The second and third template operators return <ph id=\"ph1\">`!(`` left`</ph> <ph id=\"ph2\">`==`</ph> <ph id=\"ph3\">` right``)`</ph>.","source":"The second and third template operators return `!(`` left` `==` ` right``)`."},{"content":"Example","pos":[1605,1612]},{"content":"Example","pos":[2172,2179]},{"pos":[2755,2765],"content":"operator=="},{"content":"Tests for equality between objects.","pos":[2769,2804]},{"content":"Parameters","pos":[3243,3253]},{"content":"One of the objects to be tested for equality.","pos":[3268,3313]},{"content":"One of the objects to be tested for equality.","pos":[3332,3377]},{"content":"The type controlled by the left shared pointer.","pos":[3393,3440]},{"content":"The type controlled by the right shared pointer.","pos":[3456,3504]},{"content":"Return Value","pos":[3514,3526]},{"pos":[3537,3596],"content":"if the objects are equal, <ph id=\"ph1\">`false`</ph> if objects are not equal.","source":" if the objects are equal, `false` if objects are not equal."},{"content":"Remarks","pos":[3606,3613]},{"content":"The first template operator returns true.","pos":[3617,3658]},{"content":"(All default allocators are equal.)","pos":[3659,3694]},{"pos":[3701,3778],"content":"The second and third template operators return <ph id=\"ph1\">` left.get() ==  right.get()`</ph>.","source":"The second and third template operators return ` left.get() ==  right.get()`."},{"content":"Example","pos":[3788,3795]},{"content":"Example","pos":[4714,4721]},{"pos":[5298,5306],"content":"operator"},{"content":"Tests for one object being greater than or equal to a second object.","pos":[5315,5383]},{"content":"Parameters","pos":[5679,5689]},{"content":"One of the objects to be compared.","pos":[5704,5738]},{"content":"One of the objects to be compared.","pos":[5757,5791]},{"content":"The type controlled by the left shared pointer.","pos":[5807,5854]},{"content":"The type controlled by the right shared pointer.","pos":[5870,5918]},{"content":"Remarks","pos":[5928,5935]},{"pos":[5939,6005],"content":"The template operators return <ph id=\"ph1\">` left``.get() &gt;=`</ph> <ph id=\"ph2\">` right``.get()`</ph>.","source":"The template operators return ` left``.get() >=` ` right``.get()`."},{"pos":[6044,6052],"content":"operator"},{"content":"Tests for one object being less than a second object.","pos":[6060,6113]},{"content":"Parameters","pos":[6408,6418]},{"content":"One of the objects to be compared.","pos":[6433,6467]},{"content":"One of the objects to be compared.","pos":[6486,6520]},{"content":"The type controlled by the left pointer.","pos":[6536,6576]},{"content":"The type controlled by the right pointer.","pos":[6592,6633]},{"pos":[6675,6683],"content":"operator"},{"content":"Tests for one object being less than or equal to a second object.","pos":[6692,6757]},{"content":"Parameters","pos":[7054,7064]},{"content":"One of the objects to be compared.","pos":[7079,7113]},{"content":"One of the objects to be compared.","pos":[7132,7166]},{"content":"The type controlled by the left shared pointer.","pos":[7182,7229]},{"content":"The type controlled by the right shared pointer.","pos":[7245,7293]},{"content":"Remarks","pos":[7303,7310]},{"pos":[7314,7343],"content":"The template operators return"},{"pos":[7418,7426],"content":"operator"},{"content":"Tests for one object being greater than a second object.","pos":[7434,7490]},{"content":"Parameters","pos":[7795,7805]},{"content":"One of the objects to be compared.","pos":[7820,7854]},{"content":"One of the objects to be compared.","pos":[7873,7907]},{"content":"The type controlled by the left shared pointer.","pos":[7923,7970]},{"content":"The type controlled by the right shared pointer.","pos":[7986,8034]},{"pos":[8077,8085],"content":"operator"},{"content":"shared_ptr inserter.","pos":[8097,8117]},{"content":"Parameters","pos":[8289,8299]},{"content":"The type of the stream element.","pos":[8313,8344]},{"content":"The type the stream element traits.","pos":[8359,8394]},{"content":"The type controlled by the shared pointer.","pos":[8409,8451]},{"content":"The output stream.","pos":[8467,8485]},{"content":"The shared pointer.","pos":[8500,8519]},{"content":"Remarks","pos":[8529,8536]},{"pos":[8540,8588],"content":"The template function returns <ph id=\"ph1\">`out &lt;&lt; sp.get()`</ph>.","source":"The template function returns `out << sp.get()`."},{"content":"Example","pos":[8598,8605]},{"content":"See Also","pos":[8960,8968]},{"content":"memory&gt;","pos":[8975,8982],"source":"memory>"}],"content":"---\ntitle: \"&lt;memory&gt; operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 257e3ba9-c4c2-4ae8-9b11-b156ba9c28de\ncaps.latest.revision: 13\nmanager: \"ghogen\"\n---\n# &lt;memory&gt; operators\n||||  \n|-|-|-|  \n|[operator!=](#operator_neq)|[operator&gt;](#operator_gt_)|[operator&gt;=](#operator_gt__eq)|  \n|[operator&lt;](#operator_lt_)|[operator&lt;&lt;](#operator_lt__lt_)|[operator&lt;=](#operator_lt__eq)|  \n|[operator==](#operator_eq_eq)|  \n  \n##  <a name=\"operator_neq\"></a>  operator!=  \n Tests for inequality between objects.  \n  \n```  \ntemplate <class Type, class Other>  \nbool operator!=(\n    const allocator<Type>& left,  \n    const allocator<Other>& right) throw();\n\ntemplate <class T, class Del1, class U, class Del2>  \nbool operator!=(\n    const unique_ptr<T, Del1>& left,  \n    const unique_ptr<U&, Del2>& right);\n\ntemplate <class Ty1, class Ty2>  \nbool operator!=(\n    const shared_ptr<Ty1>& left,  \n    const shared_ptr<Ty2>& right);\n```  \n  \n### Parameters  \n ` left`  \n One of the objects to be tested for inequality.  \n  \n ` right`  \n One of the objects to be tested for inequality.  \n  \n `Ty1`  \n The type controlled by the left shared pointer.  \n  \n `Ty2`  \n The type controlled by the right shared pointer.  \n  \n### Return Value  \n **true** if the objects are not equal; **false** if objects are equal.  \n  \n### Remarks  \n The first template operator returns false. (All default allocators are equal.)  \n  \n The second and third template operators return `!(`` left` `==` ` right``)`.  \n  \n### Example  \n  \n```cpp  \n// memory_op_me.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   allocator<double> Alloc;  \n   vector <char>:: allocator_type v1Alloc;  \n  \n   if ( Alloc != v1Alloc )  \n      cout << \"The allocator objects Alloc & v1Alloc not are equal.\"  \n           << endl;  \n   else  \n      cout << \"The allocator objects Alloc & v1Alloc are equal.\"  \n           << endl;  \n}  \n```  \n  \n```Output  \nThe allocator objects Alloc & v1Alloc are equal.  \n```  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__operator_ne.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::shared_ptr<int> sp0(new int(0));   \n    std::shared_ptr<int> sp1(new int(0));   \n  \n    std::cout << \"sp0 != sp0 == \" << std::boolalpha   \n        << (sp0 != sp0) << std::endl;   \n    std::cout << \"sp0 != sp1 == \" << std::boolalpha   \n        << (sp0 != sp1) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsp0 != sp0 == false  \nsp0 != sp1 == true  \n```  \n  \n##  <a name=\"operator_eq_eq\"></a>  operator==  \n Tests for equality between objects.  \n  \n```  \ntemplate <class Type, class Other>  \nbool operator==(\n    const allocator<Type>& left,  \n    const allocator<Other>& right) throw();\n\ntemplate <class Ty1, class Del1, class Ty2, class Del2>  \nbool operator==(\n    const unique_ptr<Ty1, Del1>& left,  \n    const unique_ptr<Ty2, Del2>& right);\n\ntemplate <class Ty1, class Ty2>  \nbool operator==(\n    const shared_ptr<Ty1>& left;,  \n    const shared_ptr<Ty2>& right);\n```  \n  \n### Parameters  \n ` left`  \n One of the objects to be tested for equality.  \n  \n ` right`  \n One of the objects to be tested for equality.  \n  \n `Ty1`  \n The type controlled by the left shared pointer.  \n  \n `Ty2`  \n The type controlled by the right shared pointer.  \n  \n### Return Value  \n `true` if the objects are equal, `false` if objects are not equal.  \n  \n### Remarks  \n The first template operator returns true. (All default allocators are equal.)  \n  \n The second and third template operators return ` left.get() ==  right.get()`.  \n  \n### Example  \n  \n```cpp  \n// memory_op_eq.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   allocator<char> Alloc;  \n   vector <int>:: allocator_type v1Alloc;  \n  \n   allocator<char> cAlloc(Alloc);   \n   allocator<int> cv1Alloc(v1Alloc);  \n  \n   if ( cv1Alloc == v1Alloc )  \n      cout << \"The allocator objects cv1Alloc & v1Alloc are equal.\"  \n           << endl;  \n   else  \n      cout << \"The allocator objects cv1Alloc & v1Alloc are not equal.\"  \n           << endl;  \n  \n   if ( cAlloc == Alloc )  \n      cout << \"The allocator objects cAlloc & Alloc are equal.\"  \n           << endl;  \n   else  \n      cout << \"The allocator objects cAlloc & Alloc are not equal.\"  \n           << endl;  \n}  \n```  \n  \n```Output  \nThe allocator objects cv1Alloc & v1Alloc are equal.  \nThe allocator objects cAlloc & Alloc are equal.  \n```  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__operator_eq.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::shared_ptr<int> sp0(new int(0));   \n    std::shared_ptr<int> sp1(new int(0));   \n  \n    std::cout << \"sp0 == sp0 == \" << std::boolalpha   \n        << (sp0 == sp0) << std::endl;   \n    std::cout << \"sp0 == sp1 == \" << std::boolalpha   \n        << (sp0 == sp1) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsp0 == sp0 == true  \nsp0 == sp1 == false  \n```  \n  \n##  <a name=\"operator_gt__eq\"></a>  operator&gt;=  \n Tests for one object being greater than or equal to a second object.  \n  \n```  \ntemplate <class T, class Del1, class U, class Del2>  \nbool operator>=(\n    const unique_ptr<T, Del1>& left,  \n    const unique_ptr<U, Del2>& right);\n\ntemplate <class Ty1, class Ty2>  \nbool operator>=(\n    const shared_ptr<Ty1>& left,  \n    const shared_ptr<Ty2>& right);\n```  \n  \n### Parameters  \n ` left`  \n One of the objects to be compared.  \n  \n ` right`  \n One of the objects to be compared.  \n  \n `Ty1`  \n The type controlled by the left shared pointer.  \n  \n `Ty2`  \n The type controlled by the right shared pointer.  \n  \n### Remarks  \n The template operators return ` left``.get() >=` ` right``.get()`.  \n  \n##  <a name=\"operator_lt_\"></a>  operator&lt;  \n Tests for one object being less than a second object.  \n  \n```  \ntemplate <class T, class Del1, class U, class Del2>  \nbool operator<(\n    const unique_ptr<T, Del1>& left,  \n    const unique_ptr<U&, Del2>& right);\n\ntemplate <class Ty1, class Ty2>  \nbool operator<(\n    const shared_ptr<Ty1>& left,  \n    const shared_ptr<Ty2>& right);\n```  \n  \n### Parameters  \n ` left`  \n One of the objects to be compared.  \n  \n ` right`  \n One of the objects to be compared.  \n  \n `Ty1`  \n The type controlled by the left pointer.  \n  \n `Ty2`  \n The type controlled by the right pointer.  \n  \n##  <a name=\"operator_lt__eq\"></a>  operator&lt;=  \n Tests for one object being less than or equal to a second object.  \n  \n```  \ntemplate <class T, class Del1, class U, class Del2>  \nbool operator<=(\n    const unique_ptr<T, Del1>& left,  \n    const unique_ptr<U&, Del2>& right);\n\ntemplate <class Ty1, class Ty2>  \nbool operator<=(\n    const shared_ptr<Ty1>& left,  \n    const shared_ptr<Ty2>& right);\n```  \n  \n### Parameters  \n ` left`  \n One of the objects to be compared.  \n  \n ` right`  \n One of the objects to be compared.  \n  \n `Ty1`  \n The type controlled by the left shared pointer.  \n  \n `Ty2`  \n The type controlled by the right shared pointer.  \n  \n### Remarks  \n The template operators return ` left``.get() <=` ` right``.get()`  \n  \n##  <a name=\"operator_gt_\"></a>  operator&gt;  \n Tests for one object being greater than a second object.  \n  \n```  \ntemplate <class Ty1, class Del1, class Ty2, class Del2>  \nbool operator>(\n    const unique_ptr<Ty1, Del1>& left,  \n    const unique_ptr<Ty2&, Del2gt;& right);\n\ntemplate <class Ty1, class Ty2>  \nbool operator>(\n    const shared_ptr<Ty1>& left,  \n    const shared_ptr<Ty2>& right);\n```  \n  \n### Parameters  \n ` left`  \n One of the objects to be compared.  \n  \n ` right`  \n One of the objects to be compared.  \n  \n `Ty1`  \n The type controlled by the left shared pointer.  \n  \n `Ty2`  \n The type controlled by the right shared pointer.  \n  \n##  <a name=\"operator_lt__lt_\"></a>  operator&lt;&lt;  \n shared_ptr inserter.  \n  \n```  \ntemplate <class Elem, class Tr, class Ty>  \nstd::basic_ostream<Elem, Tr>& operator<<(std::basic_ostream<Elem, Tr>& out,  \n    shared_ptr<Ty>& sp);\n```  \n  \n### Parameters  \n `Elem`  \n The type of the stream element.  \n  \n `Tr`  \n The type the stream element traits.  \n  \n `Ty`  \n The type controlled by the shared pointer.  \n  \n `out`  \n The output stream.  \n  \n `sp`  \n The shared pointer.  \n  \n### Remarks  \n The template function returns `out << sp.get()`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__operator_sl.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::shared_ptr<int> sp0(new int(5));   \n  \n    std::cout << \"sp0 == \" << sp0 << \" (varies)\" << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsp0 == 3f3040 (varies)  \n```  \n  \n## See Also  \n [\\<memory>](../standard-library/memory.md)\n\n"}