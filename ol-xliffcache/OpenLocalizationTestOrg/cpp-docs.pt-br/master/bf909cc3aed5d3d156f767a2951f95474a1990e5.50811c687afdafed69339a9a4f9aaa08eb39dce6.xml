{"nodes":[{"pos":[12,78],"content":"CFixedStringT: Example of a Custom String Manager | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CFixedStringT: Example of a Custom String Manager | Microsoft Docs","pos":[0,66]}]},{"content":"CFixedStringT: Example of a Custom String Manager","pos":[640,689]},{"content":"The ATL library implements one example of a custom string manager used by class <bpt id=\"p1\">[</bpt>CFixedStringT<ept id=\"p1\">](../atl-mfc-shared/reference/cfixedstringt-class.md)</ept>, called <bpt id=\"p2\">**</bpt>CFixedStringMgr<ept id=\"p2\">**</ept>.","pos":[690,866],"source":"The ATL library implements one example of a custom string manager used by class [CFixedStringT](../atl-mfc-shared/reference/cfixedstringt-class.md), called **CFixedStringMgr**."},{"content":"is derived from <bpt id=\"p1\">[</bpt>CStringT<ept id=\"p1\">](../atl-mfc-shared/reference/cstringt-class.md)</ept> and implements a string that allocates its character data as part of the <ph id=\"ph1\">`CFixedStringT`</ph> object itself as long as the string is less than the length specified by the <bpt id=\"p2\">**</bpt>t_nChars<ept id=\"p2\">**</ept> template parameter of <ph id=\"ph2\">`CFixedStringT`</ph>.","pos":[883,1174],"source":" is derived from [CStringT](../atl-mfc-shared/reference/cstringt-class.md) and implements a string that allocates its character data as part of the `CFixedStringT` object itself as long as the string is less than the length specified by the **t_nChars** template parameter of `CFixedStringT`."},{"content":"With this approach, the string does not need the heap at all, unless the length of the string grows beyond the size of the fixed buffer.","pos":[1175,1311]},{"content":"Because <ph id=\"ph1\">`CFixedStringT`</ph> does not always use a heap to allocate its string data, it cannot use <bpt id=\"p1\">**</bpt>CAtlStringMgr<ept id=\"p1\">**</ept> as its string manager.","pos":[1312,1446],"source":" Because `CFixedStringT` does not always use a heap to allocate its string data, it cannot use **CAtlStringMgr** as its string manager."},{"content":"It uses a custom string manager (<bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept>), implementing the <bpt id=\"p2\">[</bpt>IAtlStringMgr<ept id=\"p2\">](../atl-mfc-shared/reference/iatlstringmgr-class.md)</ept> interface.","pos":[1447,1597],"source":" It uses a custom string manager (**CFixedStringMgr**), implementing the [IAtlStringMgr](../atl-mfc-shared/reference/iatlstringmgr-class.md) interface."},{"content":"This interface is discussed in <bpt id=\"p1\">[</bpt>Implementation of a Custom String Manager (Advanced Method)<ept id=\"p1\">](../atl-mfc-shared/implementation-of-a-custom-string-manager-advanced-method.md)</ept>.","pos":[1598,1771],"source":" This interface is discussed in [Implementation of a Custom String Manager (Advanced Method)](../atl-mfc-shared/implementation-of-a-custom-string-manager-advanced-method.md)."},{"pos":[1778,1841],"content":"The constructor for <bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept> takes three parameters:","source":"The constructor for **CFixedStringMgr** takes three parameters:"},{"pos":[1851,1920],"content":"<bpt id=\"p1\">**</bpt>pData:<ept id=\"p1\">**</ept> A pointer to the fixed <ph id=\"ph1\">`CStringData`</ph> structure to be used.","source":"**pData:** A pointer to the fixed `CStringData` structure to be used."},{"pos":[1930,2012],"content":"<bpt id=\"p1\">**</bpt>nChars:<ept id=\"p1\">**</ept> The maximum number of characters the <ph id=\"ph1\">`CStringData`</ph> structure can hold.","source":"**nChars:** The maximum number of characters the `CStringData` structure can hold."},{"pos":[2022,2104],"content":"<bpt id=\"p1\">**</bpt>pMgr:<ept id=\"p1\">**</ept> A pointer to the <ph id=\"ph1\">`IAtlStringMgr`</ph> interface of a \"backup string manager.\"","source":"**pMgr:** A pointer to the `IAtlStringMgr` interface of a \"backup string manager.\""},{"content":"The constructor stores the values of <ph id=\"ph1\">`pData`</ph> and <bpt id=\"p1\">**</bpt>pMgr<ept id=\"p1\">**</ept> in their respective member variables (<ph id=\"ph2\">`m_pData`</ph> and <bpt id=\"p2\">**</bpt>m_pMgr<ept id=\"p2\">**</ept>).","pos":[2111,2233],"source":"The constructor stores the values of `pData` and **pMgr** in their respective member variables (`m_pData` and **m_pMgr**)."},{"content":"It then sets the length of the buffer to zero, the available length equal to the maximum size of the fixed buffer, and the reference count to –1.","pos":[2234,2379]},{"content":"The reference count value indicates the buffer is locked and to use this instance of <bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept> as the string manager.","pos":[2380,2507],"source":" The reference count value indicates the buffer is locked and to use this instance of **CFixedStringMgr** as the string manager."},{"content":"Marking the buffer as locked prevents other <ph id=\"ph1\">`CStringT`</ph> instances from holding a shared reference to the buffer.","pos":[2514,2625],"source":"Marking the buffer as locked prevents other `CStringT` instances from holding a shared reference to the buffer."},{"content":"If other <ph id=\"ph1\">`CStringT`</ph> instances were allowed to share the buffer it would be possible for the buffer contained by <ph id=\"ph2\">`CFixedStringT`</ph> to be deleted while other strings were still using the buffer.","pos":[2626,2816],"source":" If other `CStringT` instances were allowed to share the buffer it would be possible for the buffer contained by `CFixedStringT` to be deleted while other strings were still using the buffer."},{"content":"<bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept> is a full implementation of the <ph id=\"ph1\">`IAtlStringMgr`</ph> interface.","pos":[2823,2901],"source":"**CFixedStringMgr** is a full implementation of the `IAtlStringMgr` interface."},{"content":"The implementation of each method is discussed separately.","pos":[2902,2960]},{"content":"Implementation of CFixedStringMgr::Allocate","pos":[2969,3012]},{"content":"The implementation of <bpt id=\"p1\">**</bpt>CFixedStringMgr::Allocate<ept id=\"p1\">**</ept> first checks to see if the requested size of the string is less than or equal to the size of the fixed buffer (stored in the <ph id=\"ph1\">`m_pData`</ph> member).","pos":[3016,3211],"source":"The implementation of **CFixedStringMgr::Allocate** first checks to see if the requested size of the string is less than or equal to the size of the fixed buffer (stored in the `m_pData` member)."},{"content":"If the fixed buffer is large enough, <bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept> locks the fixed buffer with a length of zero.","pos":[3212,3314],"source":" If the fixed buffer is large enough, **CFixedStringMgr** locks the fixed buffer with a length of zero."},{"content":"As long as the string length does not grow beyond the size of the fixed buffer, <ph id=\"ph1\">`CStringT`</ph> will not have to reallocate the buffer.","pos":[3315,3445],"source":" As long as the string length does not grow beyond the size of the fixed buffer, `CStringT` will not have to reallocate the buffer."},{"content":"If the requested size of the string is greater than the fixed buffer <bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept> forwards the request to the backup string manager.","pos":[3452,3591],"source":"If the requested size of the string is greater than the fixed buffer **CFixedStringMgr** forwards the request to the backup string manager."},{"content":"The backup string manager is presumed to allocate the buffer from the heap.","pos":[3592,3667]},{"content":"However, before returning this buffer <bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept> locks the buffer and replaces the buffer's string manager pointer with a pointer to the <bpt id=\"p2\">**</bpt>CFixedStringMgr<ept id=\"p2\">**</ept> object.","pos":[3668,3841],"source":" However, before returning this buffer **CFixedStringMgr** locks the buffer and replaces the buffer's string manager pointer with a pointer to the **CFixedStringMgr** object."},{"content":"This ensures that attempts to reallocate or free the buffer by <ph id=\"ph1\">`CStringT`</ph> will call into <bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept>.","pos":[3842,3951],"source":" This ensures that attempts to reallocate or free the buffer by `CStringT` will call into **CFixedStringMgr**."},{"content":"Implementation of CFixedStringMgr::ReAllocate","pos":[3960,4005]},{"pos":[4009,4117],"content":"The implementation of <bpt id=\"p1\">**</bpt>CFixedStringMgr::ReAllocate<ept id=\"p1\">**</ept> is very similar to its implementation of <bpt id=\"p2\">**</bpt>Allocate<ept id=\"p2\">**</ept>.","source":"The implementation of **CFixedStringMgr::ReAllocate** is very similar to its implementation of **Allocate**."},{"content":"If the buffer being reallocated is the fixed buffer and the requested buffer size is smaller than the fixed buffer, no allocation is done.","pos":[4124,4262]},{"content":"However, if the buffer being reallocated is not the fixed buffer, it must be a buffer allocated with the backup manager.","pos":[4263,4383]},{"content":"In this case the backup manager is used to reallocate the buffer.","pos":[4384,4449]},{"content":"If the buffer being reallocated is the fixed buffer and the new buffer size is too large to fit within the fixed buffer, <bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept> allocates a new buffer using the backup manager.","pos":[4456,4645],"source":"If the buffer being reallocated is the fixed buffer and the new buffer size is too large to fit within the fixed buffer, **CFixedStringMgr** allocates a new buffer using the backup manager."},{"content":"The contents of the fixed buffer are then copied into the new buffer.","pos":[4646,4715]},{"content":"Implementation of CFixedStringMgr::Free","pos":[4724,4763]},{"content":"The implementation of <bpt id=\"p1\">**</bpt>CFixedStringMgr::Free<ept id=\"p1\">**</ept> follows the same pattern as <bpt id=\"p2\">**</bpt>Allocate<ept id=\"p2\">**</ept> and <ph id=\"ph1\">`ReAllocate`</ph>.","pos":[4767,4873],"source":"The implementation of **CFixedStringMgr::Free** follows the same pattern as **Allocate** and `ReAllocate`."},{"content":"If the buffer being freed is the fixed buffer, the method sets it to a zero-length locked buffer.","pos":[4874,4971]},{"content":"If the buffer being freed was allocated with the backup manager, <bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept> uses the backup manager to free it.","pos":[4972,5092],"source":" If the buffer being freed was allocated with the backup manager, **CFixedStringMgr** uses the backup manager to free it."},{"content":"Implementation of CFixedStringMgr::Clone","pos":[5101,5141]},{"content":"The implementation of <bpt id=\"p1\">**</bpt>CFixedStringMgr::Clone<ept id=\"p1\">**</ept> always returns a pointer to the backup manager rather than the <bpt id=\"p2\">**</bpt>CFixedStringMgr<ept id=\"p2\">**</ept> itself.","pos":[5145,5284],"source":"The implementation of **CFixedStringMgr::Clone** always returns a pointer to the backup manager rather than the **CFixedStringMgr** itself."},{"content":"This happens because every instance of <bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept> can only be associated with a single instance of <ph id=\"ph1\">`CStringT`</ph>.","pos":[5285,5404],"source":" This happens because every instance of **CFixedStringMgr** can only be associated with a single instance of `CStringT`."},{"content":"Any other instances of <ph id=\"ph1\">`CStringT`</ph> trying to clone the manager should get the backup manager instead.","pos":[5405,5505],"source":" Any other instances of `CStringT` trying to clone the manager should get the backup manager instead."},{"content":"This is because the backup manager supports being shared.","pos":[5506,5563]},{"content":"Implementation of CFixedStringMgr::GetNilString","pos":[5572,5619]},{"content":"The implementation of <bpt id=\"p1\">**</bpt>CFixedStringMgr::GetNilString<ept id=\"p1\">**</ept> returns the fixed buffer.","pos":[5623,5704],"source":"The implementation of **CFixedStringMgr::GetNilString** returns the fixed buffer."},{"content":"Because of the one-on-one correspondence of <bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`CStringT`</ph>, a given instance of <ph id=\"ph2\">`CStringT`</ph> never uses more than one buffer at a time.","pos":[5705,5858],"source":" Because of the one-on-one correspondence of **CFixedStringMgr** and `CStringT`, a given instance of `CStringT` never uses more than one buffer at a time."},{"content":"Therefore, a nil string and a real string buffer are never needed at the same time.","pos":[5859,5942]},{"content":"Whenever the fixed buffer is not in use, <bpt id=\"p1\">**</bpt>CFixedStringMgr<ept id=\"p1\">**</ept> ensures that it is initialized with a zero length.","pos":[5949,6060],"source":"Whenever the fixed buffer is not in use, **CFixedStringMgr** ensures that it is initialized with a zero length."},{"content":"This allows it to be used as the nil string.","pos":[6061,6105]},{"content":"As an added bonus, the <ph id=\"ph1\">`nAllocLength`</ph> member of the fixed buffer is always set to the full size of the fixed buffer.","pos":[6106,6222],"source":" As an added bonus, the `nAllocLength` member of the fixed buffer is always set to the full size of the fixed buffer."},{"content":"This means that <ph id=\"ph1\">`CStringT`</ph> can grow the string without calling <bpt id=\"p1\">[</bpt>IAtlStringMgr::Reallocate<ept id=\"p1\">](../atl-mfc-shared/reference/iatlstringmgr-class.md#iatlstringmgr__reallocate)</ept>, even for the nil string.","pos":[6223,6417],"source":" This means that `CStringT` can grow the string without calling [IAtlStringMgr::Reallocate](../atl-mfc-shared/reference/iatlstringmgr-class.md#iatlstringmgr__reallocate), even for the nil string."},{"content":"Requirements","pos":[6426,6438]},{"pos":[6442,6464],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> cstringt.h","source":"**Header:** cstringt.h"},{"content":"See Also","pos":[6473,6481]},{"content":"Memory Management with CStringT","pos":[6486,6517]}],"content":"---\ntitle: \"CFixedStringT: Example of a Custom String Manager | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CFixedStringT class, using a custom string manager\"\nms.assetid: 1cf11fd7-51b8-4b94-87af-02bc25f47dd6\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CFixedStringT: Example of a Custom String Manager\nThe ATL library implements one example of a custom string manager used by class [CFixedStringT](../atl-mfc-shared/reference/cfixedstringt-class.md), called **CFixedStringMgr**. `CFixedStringT` is derived from [CStringT](../atl-mfc-shared/reference/cstringt-class.md) and implements a string that allocates its character data as part of the `CFixedStringT` object itself as long as the string is less than the length specified by the **t_nChars** template parameter of `CFixedStringT`. With this approach, the string does not need the heap at all, unless the length of the string grows beyond the size of the fixed buffer. Because `CFixedStringT` does not always use a heap to allocate its string data, it cannot use **CAtlStringMgr** as its string manager. It uses a custom string manager (**CFixedStringMgr**), implementing the [IAtlStringMgr](../atl-mfc-shared/reference/iatlstringmgr-class.md) interface. This interface is discussed in [Implementation of a Custom String Manager (Advanced Method)](../atl-mfc-shared/implementation-of-a-custom-string-manager-advanced-method.md).  \n  \n The constructor for **CFixedStringMgr** takes three parameters:  \n  \n-   **pData:** A pointer to the fixed `CStringData` structure to be used.  \n  \n-   **nChars:** The maximum number of characters the `CStringData` structure can hold.  \n  \n-   **pMgr:** A pointer to the `IAtlStringMgr` interface of a \"backup string manager.\"  \n  \n The constructor stores the values of `pData` and **pMgr** in their respective member variables (`m_pData` and **m_pMgr**). It then sets the length of the buffer to zero, the available length equal to the maximum size of the fixed buffer, and the reference count to –1. The reference count value indicates the buffer is locked and to use this instance of **CFixedStringMgr** as the string manager.  \n  \n Marking the buffer as locked prevents other `CStringT` instances from holding a shared reference to the buffer. If other `CStringT` instances were allowed to share the buffer it would be possible for the buffer contained by `CFixedStringT` to be deleted while other strings were still using the buffer.  \n  \n **CFixedStringMgr** is a full implementation of the `IAtlStringMgr` interface. The implementation of each method is discussed separately.  \n  \n## Implementation of CFixedStringMgr::Allocate  \n The implementation of **CFixedStringMgr::Allocate** first checks to see if the requested size of the string is less than or equal to the size of the fixed buffer (stored in the `m_pData` member). If the fixed buffer is large enough, **CFixedStringMgr** locks the fixed buffer with a length of zero. As long as the string length does not grow beyond the size of the fixed buffer, `CStringT` will not have to reallocate the buffer.  \n  \n If the requested size of the string is greater than the fixed buffer **CFixedStringMgr** forwards the request to the backup string manager. The backup string manager is presumed to allocate the buffer from the heap. However, before returning this buffer **CFixedStringMgr** locks the buffer and replaces the buffer's string manager pointer with a pointer to the **CFixedStringMgr** object. This ensures that attempts to reallocate or free the buffer by `CStringT` will call into **CFixedStringMgr**.  \n  \n## Implementation of CFixedStringMgr::ReAllocate  \n The implementation of **CFixedStringMgr::ReAllocate** is very similar to its implementation of **Allocate**.  \n  \n If the buffer being reallocated is the fixed buffer and the requested buffer size is smaller than the fixed buffer, no allocation is done. However, if the buffer being reallocated is not the fixed buffer, it must be a buffer allocated with the backup manager. In this case the backup manager is used to reallocate the buffer.  \n  \n If the buffer being reallocated is the fixed buffer and the new buffer size is too large to fit within the fixed buffer, **CFixedStringMgr** allocates a new buffer using the backup manager. The contents of the fixed buffer are then copied into the new buffer.  \n  \n## Implementation of CFixedStringMgr::Free  \n The implementation of **CFixedStringMgr::Free** follows the same pattern as **Allocate** and `ReAllocate`. If the buffer being freed is the fixed buffer, the method sets it to a zero-length locked buffer. If the buffer being freed was allocated with the backup manager, **CFixedStringMgr** uses the backup manager to free it.  \n  \n## Implementation of CFixedStringMgr::Clone  \n The implementation of **CFixedStringMgr::Clone** always returns a pointer to the backup manager rather than the **CFixedStringMgr** itself. This happens because every instance of **CFixedStringMgr** can only be associated with a single instance of `CStringT`. Any other instances of `CStringT` trying to clone the manager should get the backup manager instead. This is because the backup manager supports being shared.  \n  \n## Implementation of CFixedStringMgr::GetNilString  \n The implementation of **CFixedStringMgr::GetNilString** returns the fixed buffer. Because of the one-on-one correspondence of **CFixedStringMgr** and `CStringT`, a given instance of `CStringT` never uses more than one buffer at a time. Therefore, a nil string and a real string buffer are never needed at the same time.  \n  \n Whenever the fixed buffer is not in use, **CFixedStringMgr** ensures that it is initialized with a zero length. This allows it to be used as the nil string. As an added bonus, the `nAllocLength` member of the fixed buffer is always set to the full size of the fixed buffer. This means that `CStringT` can grow the string without calling [IAtlStringMgr::Reallocate](../atl-mfc-shared/reference/iatlstringmgr-class.md#iatlstringmgr__reallocate), even for the nil string.  \n  \n## Requirements  \n **Header:** cstringt.h  \n  \n## See Also  \n [Memory Management with CStringT](../atl-mfc-shared/memory-management-with-cstringt.md)\n\n"}