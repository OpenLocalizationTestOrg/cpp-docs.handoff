{"nodes":[{"pos":[12,78],"content":"Multiplicative Operators and the Modulus Operator | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Multiplicative Operators and the Modulus Operator | Microsoft Docs","pos":[0,66]}]},{"content":"Multiplicative Operators and the Modulus Operator","pos":[952,1001]},{"content":"Syntax","pos":[1005,1011]},{"content":"Remarks","pos":[1115,1122]},{"content":"The multiplicative operators are:","pos":[1126,1159]},{"pos":[1169,1192],"content":"Multiplication (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept>)","source":"Multiplication (**\\***)"},{"pos":[1202,1218],"content":"Division (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">/</ph><ept id=\"p1\">**</ept>)","source":"Division (**/**)"},{"pos":[1228,1267],"content":"Modulus (remainder from division) (<ph id=\"ph1\">`%`</ph>)","source":"Modulus (remainder from division) (`%`)"},{"content":"These binary operators have left-to-right associativity.","pos":[1274,1330]},{"content":"The multiplicative operators take operands of arithmetic types.","pos":[1337,1400]},{"content":"The modulus operator (<ph id=\"ph1\">`%`</ph>) has a stricter requirement in that its operands must be of integral type.","pos":[1401,1501],"source":" The modulus operator (`%`) has a stricter requirement in that its operands must be of integral type."},{"content":"(To get the remainder of a floating-point division, use the run-time function, <bpt id=\"p1\">[</bpt>fmod<ept id=\"p1\">](../c-runtime-library/reference/fmod-fmodf.md)</ept>.) The conversions covered in <bpt id=\"p2\">[</bpt>Standard Conversions<ept id=\"p2\">](standard-conversions.md)</ept> are applied to the operands, and the result is of the converted type.","pos":[1502,1780],"source":" (To get the remainder of a floating-point division, use the run-time function, [fmod](../c-runtime-library/reference/fmod-fmodf.md).) The conversions covered in [Standard Conversions](standard-conversions.md) are applied to the operands, and the result is of the converted type."},{"content":"The multiplication operator yields the result of multiplying the first operand by the second.","pos":[1787,1880]},{"content":"The division operator yields the result of dividing the first operand by the second.","pos":[1887,1971]},{"pos":[1978,2183],"content":"The modulus operator yields the remainder given by the following expression, where <bpt id=\"p1\">*</bpt>e1<ept id=\"p1\">*</ept> is the first operand and <bpt id=\"p2\">*</bpt>e2<ept id=\"p2\">*</ept> is the second: <bpt id=\"p3\">*</bpt>e1<ept id=\"p3\">*</ept> – (<bpt id=\"p4\">*</bpt>e1<ept id=\"p4\">*</ept><ph id=\"ph1\"> / </ph><bpt id=\"p5\">*</bpt>e2<ept id=\"p5\">*</ept>) <ph id=\"ph2\">\\*</ph> <bpt id=\"p6\">*</bpt>e2<ept id=\"p6\">*</ept>, where both operands are of integral types.","source":"The modulus operator yields the remainder given by the following expression, where *e1* is the first operand and *e2* is the second: *e1* – (*e1* / *e2*) \\* *e2*, where both operands are of integral types."},{"content":"Division by 0 in either a division or a modulus expression is undefined and causes a run-time error.","pos":[2190,2290]},{"content":"Therefore, the following expressions generate undefined, erroneous results:","pos":[2291,2366]},{"content":"If both operands to a multiplication, division, or modulus expression have the same sign, the result is positive.","pos":[2406,2519]},{"content":"Otherwise, the result is negative.","pos":[2520,2554]},{"content":"The result of a modulus operation's sign is implementation-defined.","pos":[2555,2622]},{"pos":[2630,2893],"content":"[!NOTE]\n Since the conversions performed by the multiplicative operators do not provide for overflow or underflow conditions, information may be lost if the result of a multiplicative operation cannot be represented in the type of the operands after conversion.","leadings":["","> "],"nodes":[{"content":"Since the conversions performed by the multiplicative operators do not provide for overflow or underflow conditions, information may be lost if the result of a multiplicative operation cannot be represented in the type of the operands after conversion.","pos":[9,261]}]},{"content":"Microsoft Specific","pos":[2902,2920]},{"content":"In Microsoft C++, the result of a modulus expression is always the same as the sign of the first operand.","pos":[2924,3029]},{"content":"END Microsoft Specific","pos":[3038,3060]},{"content":"If the computed division of two integers is inexact and only one operand is negative, the result is the largest integer (in magnitude, disregarding the sign) that is less than the exact value the division operation would yield.","pos":[3064,3291]},{"content":"For example, the computed value of –11 / 3 is –3.666666666.","pos":[3292,3351]},{"content":"The result of that integral division is –3.","pos":[3352,3395]},{"pos":[3402,3525],"content":"The relationship between the multiplicative operators is given by the identity (<bpt id=\"p1\">*</bpt>e1<ept id=\"p1\">*</ept><ph id=\"ph1\"> / </ph><bpt id=\"p2\">*</bpt>e2<ept id=\"p2\">*</ept>) <ph id=\"ph2\">\\*</ph> <bpt id=\"p3\">*</bpt>e2<ept id=\"p3\">*</ept><ph id=\"ph3\"> + </ph><bpt id=\"p4\">*</bpt>e1<ept id=\"p4\">*</ept><ph id=\"ph4\"> % </ph><bpt id=\"p5\">*</bpt>e2<ept id=\"p5\">*</ept><ph id=\"ph5\"> == </ph><bpt id=\"p6\">*</bpt>e1<ept id=\"p6\">*</ept>.","source":"The relationship between the multiplicative operators is given by the identity (*e1* / *e2*) \\* *e2* + *e1* % *e2* == *e1*."},{"content":"Example","pos":[3534,3541]},{"content":"The following program demonstrates the multiplicative operators.","pos":[3545,3609]},{"content":"Note that either operand of <ph id=\"ph1\">`10 / 3`</ph> must be explicitly cast to type <ph id=\"ph2\">`float`</ph> to avoid truncation so that both operands are of type <ph id=\"ph3\">`float`</ph> before division.","pos":[3610,3765],"source":" Note that either operand of `10 / 3` must be explicitly cast to type `float` to avoid truncation so that both operands are of type `float` before division."},{"content":"See Also","pos":[4132,4140]},{"content":"Expressions with Binary Operators","pos":[4145,4178]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[4230,4282]},{"content":"C Multiplicative Operators","pos":[4352,4378]}],"content":"---\ntitle: \"Multiplicative Operators and the Modulus Operator | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"%\"\n  - \"/\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"operators [C++], multiplicative\"\n  - \"arithmetic operators [C++], multiplicative operators\"\n  - \"modulus operator, C+\"\n  - \"* operator\"\n  - \"division operator, multiplicative operators\"\n  - \"% operator\"\n  - \"multiplication operator [C++], multiplicative operators\"\n  - \"multiplicative operators [C++]\"\n  - \"division operator\"\nms.assetid: b53ea5da-d0b4-40dc-98f3-0aa52d548293\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Multiplicative Operators and the Modulus Operator\n## Syntax  \n  \n```  \nexpression * expression   \nexpression / expression   \nexpression % expression  \n```  \n  \n## Remarks  \n The multiplicative operators are:  \n  \n-   Multiplication (**\\***)  \n  \n-   Division (**/**)  \n  \n-   Modulus (remainder from division) (`%`)  \n  \n These binary operators have left-to-right associativity.  \n  \n The multiplicative operators take operands of arithmetic types. The modulus operator (`%`) has a stricter requirement in that its operands must be of integral type. (To get the remainder of a floating-point division, use the run-time function, [fmod](../c-runtime-library/reference/fmod-fmodf.md).) The conversions covered in [Standard Conversions](standard-conversions.md) are applied to the operands, and the result is of the converted type.  \n  \n The multiplication operator yields the result of multiplying the first operand by the second.  \n  \n The division operator yields the result of dividing the first operand by the second.  \n  \n The modulus operator yields the remainder given by the following expression, where *e1* is the first operand and *e2* is the second: *e1* – (*e1* / *e2*) \\* *e2*, where both operands are of integral types.  \n  \n Division by 0 in either a division or a modulus expression is undefined and causes a run-time error. Therefore, the following expressions generate undefined, erroneous results:  \n  \n```  \ni % 0  \nf / 0.0  \n```  \n  \n If both operands to a multiplication, division, or modulus expression have the same sign, the result is positive. Otherwise, the result is negative. The result of a modulus operation's sign is implementation-defined.  \n  \n> [!NOTE]\n>  Since the conversions performed by the multiplicative operators do not provide for overflow or underflow conditions, information may be lost if the result of a multiplicative operation cannot be represented in the type of the operands after conversion.  \n  \n## Microsoft Specific  \n In Microsoft C++, the result of a modulus expression is always the same as the sign of the first operand.  \n  \n## END Microsoft Specific  \n If the computed division of two integers is inexact and only one operand is negative, the result is the largest integer (in magnitude, disregarding the sign) that is less than the exact value the division operation would yield. For example, the computed value of –11 / 3 is –3.666666666. The result of that integral division is –3.  \n  \n The relationship between the multiplicative operators is given by the identity (*e1* / *e2*) \\* *e2* + *e1* % *e2* == *e1*.  \n  \n## Example  \n The following program demonstrates the multiplicative operators. Note that either operand of `10 / 3` must be explicitly cast to type `float` to avoid truncation so that both operands are of type `float` before division.  \n  \n```  \n// expre_Multiplicative_Operators.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \nint main() {  \n   int x = 3, y = 6, z = 10;  \n   cout  << \"3 * 6 is \" << x * y << endl  \n         << \"6 / 3 is \" << y / x << endl  \n         << \"10 % 3 is \" << z % x << endl  \n         << \"10 / 3 is \" << (float) z / x << endl;  \n}  \n```  \n  \n## See Also  \n [Expressions with Binary Operators](../cpp/expressions-with-binary-operators.md)   \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   \n [C Multiplicative Operators](../c-language/c-multiplicative-operators.md)"}