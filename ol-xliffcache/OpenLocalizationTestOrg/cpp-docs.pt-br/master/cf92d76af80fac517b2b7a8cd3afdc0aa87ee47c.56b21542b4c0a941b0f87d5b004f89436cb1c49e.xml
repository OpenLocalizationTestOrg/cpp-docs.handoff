{"nodes":[{"pos":[12,76],"content":"Windows Sockets: How Sockets with Archives Work | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Windows Sockets: How Sockets with Archives Work | Microsoft Docs","pos":[0,64]}]},{"content":"Windows Sockets: How Sockets with Archives Work","pos":[802,849]},{"pos":[850,1131],"content":"This article explains how a <bpt id=\"p1\">[</bpt>CSocket<ept id=\"p1\">](../mfc/reference/csocket-class.md)</ept> object, a <bpt id=\"p2\">[</bpt>CSocketFile<ept id=\"p2\">](../mfc/reference/csocketfile-class.md)</ept> object, and a <bpt id=\"p3\">[</bpt>CArchive<ept id=\"p3\">](../mfc/reference/carchive-class.md)</ept> object are combined to simplify sending and receiving data through a Windows Socket.","source":"This article explains how a [CSocket](../mfc/reference/csocket-class.md) object, a [CSocketFile](../mfc/reference/csocketfile-class.md) object, and a [CArchive](../mfc/reference/carchive-class.md) object are combined to simplify sending and receiving data through a Windows Socket."},{"content":"The article <bpt id=\"p1\">[</bpt>Windows Sockets: Example of Sockets Using Archives<ept id=\"p1\">](../mfc/windows-sockets-example-of-sockets-using-archives.md)</ept> presents the <bpt id=\"p2\">**</bpt>PacketSerialize<ept id=\"p2\">**</ept> function.","pos":[1138,1306],"source":"The article [Windows Sockets: Example of Sockets Using Archives](../mfc/windows-sockets-example-of-sockets-using-archives.md) presents the **PacketSerialize** function."},{"content":"The archive object in the <bpt id=\"p1\">**</bpt>PacketSerialize<ept id=\"p1\">**</ept> example works much like an archive object passed to an MFC <bpt id=\"p2\">[</bpt>Serialize<ept id=\"p2\">](../mfc/reference/cobject-class.md#cobject__serialize)</ept> function.","pos":[1307,1487],"source":" The archive object in the **PacketSerialize** example works much like an archive object passed to an MFC [Serialize](../mfc/reference/cobject-class.md#cobject__serialize) function."},{"content":"The essential difference is that for sockets, the archive is attached not to a standard <bpt id=\"p1\">[</bpt>CFile<ept id=\"p1\">](../mfc/reference/cfile-class.md)</ept> object (typically associated with a disk file) but to a <ph id=\"ph1\">`CSocketFile`</ph> object.","pos":[1488,1694],"source":" The essential difference is that for sockets, the archive is attached not to a standard [CFile](../mfc/reference/cfile-class.md) object (typically associated with a disk file) but to a `CSocketFile` object."},{"content":"Rather than connecting to a disk file, the <ph id=\"ph1\">`CSocketFile`</ph> object connects to a <ph id=\"ph2\">`CSocket`</ph> object.","pos":[1695,1790],"source":" Rather than connecting to a disk file, the `CSocketFile` object connects to a `CSocket` object."},{"content":"A <ph id=\"ph1\">`CArchive`</ph> object manages a buffer.","pos":[1797,1834],"source":"A `CArchive` object manages a buffer."},{"content":"When the buffer of a storing (sending) archive is full, an associated <ph id=\"ph1\">`CFile`</ph> object writes out the buffer's contents.","pos":[1835,1953],"source":" When the buffer of a storing (sending) archive is full, an associated `CFile` object writes out the buffer's contents."},{"content":"Flushing the buffer of an archive attached to a socket is equivalent to sending a message.","pos":[1954,2044]},{"content":"When the buffer of a loading (receiving) archive is full, the <ph id=\"ph1\">`CFile`</ph> object stops reading until the buffer is available again.","pos":[2045,2172],"source":" When the buffer of a loading (receiving) archive is full, the `CFile` object stops reading until the buffer is available again."},{"content":"Class <ph id=\"ph1\">`CSocketFile`</ph> derives from <ph id=\"ph2\">`CFile`</ph>, but it does not support <bpt id=\"p1\">[</bpt>CFile<ept id=\"p1\">](../mfc/reference/cfile-class.md)</ept> member functions such as the positioning functions (<ph id=\"ph3\">`Seek`</ph>, <ph id=\"ph4\">`GetLength`</ph>, <ph id=\"ph5\">`SetLength`</ph>, and so on), the locking functions (<ph id=\"ph6\">`LockRange`</ph>, <ph id=\"ph7\">`UnlockRange`</ph>), or the <ph id=\"ph8\">`GetPosition`</ph> function.","pos":[2179,2466],"source":"Class `CSocketFile` derives from `CFile`, but it does not support [CFile](../mfc/reference/cfile-class.md) member functions such as the positioning functions (`Seek`, `GetLength`, `SetLength`, and so on), the locking functions (`LockRange`, `UnlockRange`), or the `GetPosition` function."},{"content":"All the <bpt id=\"p1\">[</bpt>CSocketFile<ept id=\"p1\">](../mfc/reference/csocketfile-class.md)</ept> object must do is write or read sequences of bytes to or from the associated <ph id=\"ph1\">`CSocket`</ph> object.","pos":[2467,2622],"source":" All the [CSocketFile](../mfc/reference/csocketfile-class.md) object must do is write or read sequences of bytes to or from the associated `CSocket` object."},{"content":"Because a file is not involved, operations such as <ph id=\"ph1\">`Seek`</ph> and <ph id=\"ph2\">`GetPosition`</ph> make no sense.","pos":[2623,2713],"source":" Because a file is not involved, operations such as `Seek` and `GetPosition` make no sense."},{"content":"is derived from <ph id=\"ph1\">`CFile`</ph>, so it would normally inherit all of these member functions.","pos":[2728,2812],"source":" is derived from `CFile`, so it would normally inherit all of these member functions."},{"content":"To prevent this, the unsupported <ph id=\"ph1\">`CFile`</ph> member functions are overridden in <ph id=\"ph2\">`CSocketFile`</ph> to throw a <bpt id=\"p1\">[</bpt>CNotSupportedException<ept id=\"p1\">](../mfc/reference/cnotsupportedexception-class.md)</ept>.","pos":[2813,2989],"source":" To prevent this, the unsupported `CFile` member functions are overridden in `CSocketFile` to throw a [CNotSupportedException](../mfc/reference/cnotsupportedexception-class.md)."},{"pos":[2996,3092],"content":"The <ph id=\"ph1\">`CSocketFile`</ph> object calls member functions of its <ph id=\"ph2\">`CSocket`</ph> object to send or receive data.","source":"The `CSocketFile` object calls member functions of its `CSocket` object to send or receive data."},{"content":"The following figure shows the relationships among these objects on both sides of the communication.","pos":[3099,3199]},{"content":"CArchive, CSocketFile, and CSocket","pos":[3208,3242]},{"content":"CArchive, CSocketFile, and CSocket","pos":[3282,3316]},{"content":"The purpose of this apparent complexity is to shield you from the necessity of managing the details of the socket yourself.","pos":[3323,3446]},{"content":"You create the socket, the file, and the archive, and then begin sending or receiving data by inserting it to the archive or extracting it from the archive.","pos":[3447,3603]},{"content":"<bpt id=\"p1\">[</bpt>CArchive<ept id=\"p1\">](../mfc/reference/carchive-class.md)</ept>, <bpt id=\"p2\">[</bpt>CSocketFile<ept id=\"p2\">](../mfc/reference/csocketfile-class.md)</ept>, and <bpt id=\"p3\">[</bpt>CSocket<ept id=\"p3\">](../mfc/reference/csocket-class.md)</ept> manage the details behind the scenes.","pos":[3604,3792],"source":"[CArchive](../mfc/reference/carchive-class.md), [CSocketFile](../mfc/reference/csocketfile-class.md), and [CSocket](../mfc/reference/csocket-class.md) manage the details behind the scenes."},{"content":"A <ph id=\"ph1\">`CSocket`</ph> object is actually a two-state object: sometimes asynchronous (the usual state) and sometimes synchronous.","pos":[3799,3917],"source":"A `CSocket` object is actually a two-state object: sometimes asynchronous (the usual state) and sometimes synchronous."},{"content":"In its asynchronous state, a socket can receive asynchronous notifications from the framework.","pos":[3918,4012]},{"content":"However, during an operation such as receiving or sending data the socket becomes synchronous.","pos":[4013,4107]},{"content":"This means the socket will receive no further asynchronous notifications until the synchronous operation has completed.","pos":[4108,4227]},{"content":"Because it switches modes, you can, for example, do something like the following:","pos":[4228,4309]},{"pos":[4327,4348],"content":"NVC_MFCSimpleSocket#2"},{"content":"If <ph id=\"ph1\">`CSocket`</ph> were not implemented as a two-state object, it might be possible to receive additional notifications for the same kind of event while you were processing a previous notification.","pos":[4434,4625],"source":"If `CSocket` were not implemented as a two-state object, it might be possible to receive additional notifications for the same kind of event while you were processing a previous notification."},{"content":"For example, you might get an <ph id=\"ph1\">`OnReceive`</ph> notification while processing an <ph id=\"ph2\">`OnReceive`</ph>.","pos":[4626,4713],"source":" For example, you might get an `OnReceive` notification while processing an `OnReceive`."},{"content":"In the code fragment above, extracting <ph id=\"ph1\">`str`</ph> from the archive might lead to recursion.","pos":[4714,4800],"source":" In the code fragment above, extracting `str` from the archive might lead to recursion."},{"content":"By switching states, <ph id=\"ph1\">`CSocket`</ph> prevents recursion by preventing additional notifications.","pos":[4801,4890],"source":" By switching states, `CSocket` prevents recursion by preventing additional notifications."},{"content":"The general rule is no notifications within notifications.","pos":[4891,4949]},{"pos":[4957,5298],"content":"[!NOTE]\n A `CSocketFile` can also be used as a (limited) file without a `CArchive` object. By default, the `CSocketFile` constructor's `bArchiveCompatible` parameter is **TRUE**. This specifies that the file object is for use with an archive. To use the file object without an archive, pass **FALSE** in the `bArchiveCompatible` parameter.","leadings":["","> "],"nodes":[{"content":" A `CSocketFile` can also be used as a (limited) file without a `CArchive` object. By default, the `CSocketFile` constructor's `bArchiveCompatible` parameter is **TRUE**. This specifies that the file object is for use with an archive. To use the file object without an archive, pass **FALSE** in the `bArchiveCompatible` parameter.","pos":[8,339],"nodes":[{"content":"A <ph id=\"ph1\">`CSocketFile`</ph> can also be used as a (limited) file without a <ph id=\"ph2\">`CArchive`</ph> object.","pos":[1,82],"source":" A `CSocketFile` can also be used as a (limited) file without a `CArchive` object."},{"content":"By default, the <ph id=\"ph1\">`CSocketFile`</ph> constructor's <ph id=\"ph2\">`bArchiveCompatible`</ph> parameter is <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept>.","pos":[83,170],"source":" By default, the `CSocketFile` constructor's `bArchiveCompatible` parameter is **TRUE**."},{"content":"This specifies that the file object is for use with an archive.","pos":[171,234]},{"content":"To use the file object without an archive, pass <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept> in the <ph id=\"ph1\">`bArchiveCompatible`</ph> parameter.","pos":[235,331],"source":" To use the file object without an archive, pass **FALSE** in the `bArchiveCompatible` parameter."}]}]},{"content":"In its \"archive compatible\" mode, a <ph id=\"ph1\">`CSocketFile`</ph> object provides better performance and reduces the danger of a \"deadlock.\"","pos":[5305,5429],"source":"In its \"archive compatible\" mode, a `CSocketFile` object provides better performance and reduces the danger of a \"deadlock.\""},{"content":"A deadlock occurs when both the sending and receiving sockets are waiting on each other, or waiting for a common resource.","pos":[5430,5552]},{"content":"This situation might occur if the <ph id=\"ph1\">`CArchive`</ph> object worked with the <ph id=\"ph2\">`CSocketFile`</ph> the way it does with a <ph id=\"ph3\">`CFile`</ph> object.","pos":[5553,5673],"source":" This situation might occur if the `CArchive` object worked with the `CSocketFile` the way it does with a `CFile` object."},{"content":"With <ph id=\"ph1\">`CFile`</ph>, the archive can assume that if it receives fewer bytes than it requested, the end of file has been reached.","pos":[5674,5795],"source":" With `CFile`, the archive can assume that if it receives fewer bytes than it requested, the end of file has been reached."},{"content":"With <ph id=\"ph1\">`CSocketFile`</ph>, however, data is message based; the buffer can contain multiple messages, so receiving fewer than the number of bytes requested does not imply end of file.","pos":[5796,5971],"source":" With `CSocketFile`, however, data is message based; the buffer can contain multiple messages, so receiving fewer than the number of bytes requested does not imply end of file."},{"content":"The application does not block in this case as it might with <ph id=\"ph1\">`CFile`</ph>, and it can continue reading messages from the buffer until the buffer is empty.","pos":[5972,6121],"source":" The application does not block in this case as it might with `CFile`, and it can continue reading messages from the buffer until the buffer is empty."},{"content":"The <bpt id=\"p1\">[</bpt>IsBufferEmpty<ept id=\"p1\">](../mfc/reference/carchive-class.md#carchive__isbufferempty)</ept> function in <ph id=\"ph1\">`CArchive`</ph> is useful for monitoring the state of the archive's buffer in such a case.","pos":[6122,6299],"source":" The [IsBufferEmpty](../mfc/reference/carchive-class.md#carchive__isbufferempty) function in `CArchive` is useful for monitoring the state of the archive's buffer in such a case."},{"pos":[6306,6433],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p1\">](../mfc/windows-sockets-using-sockets-with-archives.md)</ept>","source":"For more information, see [Windows Sockets: Using Sockets with Archives](../mfc/windows-sockets-using-sockets-with-archives.md)"},{"content":"See Also","pos":[6442,6450]},{"content":"Windows Sockets in MFC","pos":[6455,6477]},{"content":"CObject::Serialize","pos":[6518,6536]}],"content":"---\ntitle: \"Windows Sockets: How Sockets with Archives Work | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"Windows Sockets [C++], synchronous\"\n  - \"sockets [C++], synchronous operation\"\n  - \"sockets [C++], with archives\"\n  - \"synchronous state socket\"\n  - \"Windows Sockets [C++], with archives\"\n  - \"two-state socket object\"\nms.assetid: d8ae4039-391d-44f0-a19b-558817affcbb\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Windows Sockets: How Sockets with Archives Work\nThis article explains how a [CSocket](../mfc/reference/csocket-class.md) object, a [CSocketFile](../mfc/reference/csocketfile-class.md) object, and a [CArchive](../mfc/reference/carchive-class.md) object are combined to simplify sending and receiving data through a Windows Socket.  \n  \n The article [Windows Sockets: Example of Sockets Using Archives](../mfc/windows-sockets-example-of-sockets-using-archives.md) presents the **PacketSerialize** function. The archive object in the **PacketSerialize** example works much like an archive object passed to an MFC [Serialize](../mfc/reference/cobject-class.md#cobject__serialize) function. The essential difference is that for sockets, the archive is attached not to a standard [CFile](../mfc/reference/cfile-class.md) object (typically associated with a disk file) but to a `CSocketFile` object. Rather than connecting to a disk file, the `CSocketFile` object connects to a `CSocket` object.  \n  \n A `CArchive` object manages a buffer. When the buffer of a storing (sending) archive is full, an associated `CFile` object writes out the buffer's contents. Flushing the buffer of an archive attached to a socket is equivalent to sending a message. When the buffer of a loading (receiving) archive is full, the `CFile` object stops reading until the buffer is available again.  \n  \n Class `CSocketFile` derives from `CFile`, but it does not support [CFile](../mfc/reference/cfile-class.md) member functions such as the positioning functions (`Seek`, `GetLength`, `SetLength`, and so on), the locking functions (`LockRange`, `UnlockRange`), or the `GetPosition` function. All the [CSocketFile](../mfc/reference/csocketfile-class.md) object must do is write or read sequences of bytes to or from the associated `CSocket` object. Because a file is not involved, operations such as `Seek` and `GetPosition` make no sense. `CSocketFile` is derived from `CFile`, so it would normally inherit all of these member functions. To prevent this, the unsupported `CFile` member functions are overridden in `CSocketFile` to throw a [CNotSupportedException](../mfc/reference/cnotsupportedexception-class.md).  \n  \n The `CSocketFile` object calls member functions of its `CSocket` object to send or receive data.  \n  \n The following figure shows the relationships among these objects on both sides of the communication.  \n  \n ![CArchive, CSocketFile, and CSocket](../mfc/media/vc38ia1.gif \"vc38ia1\")  \nCArchive, CSocketFile, and CSocket  \n  \n The purpose of this apparent complexity is to shield you from the necessity of managing the details of the socket yourself. You create the socket, the file, and the archive, and then begin sending or receiving data by inserting it to the archive or extracting it from the archive. [CArchive](../mfc/reference/carchive-class.md), [CSocketFile](../mfc/reference/csocketfile-class.md), and [CSocket](../mfc/reference/csocket-class.md) manage the details behind the scenes.  \n  \n A `CSocket` object is actually a two-state object: sometimes asynchronous (the usual state) and sometimes synchronous. In its asynchronous state, a socket can receive asynchronous notifications from the framework. However, during an operation such as receiving or sending data the socket becomes synchronous. This means the socket will receive no further asynchronous notifications until the synchronous operation has completed. Because it switches modes, you can, for example, do something like the following:  \n  \n [!code-cpp[NVC_MFCSimpleSocket#2](../mfc/codesnippet/cpp/windows-sockets-how-sockets-with-archives-work_1.cpp)]  \n  \n If `CSocket` were not implemented as a two-state object, it might be possible to receive additional notifications for the same kind of event while you were processing a previous notification. For example, you might get an `OnReceive` notification while processing an `OnReceive`. In the code fragment above, extracting `str` from the archive might lead to recursion. By switching states, `CSocket` prevents recursion by preventing additional notifications. The general rule is no notifications within notifications.  \n  \n> [!NOTE]\n>  A `CSocketFile` can also be used as a (limited) file without a `CArchive` object. By default, the `CSocketFile` constructor's `bArchiveCompatible` parameter is **TRUE**. This specifies that the file object is for use with an archive. To use the file object without an archive, pass **FALSE** in the `bArchiveCompatible` parameter.  \n  \n In its \"archive compatible\" mode, a `CSocketFile` object provides better performance and reduces the danger of a \"deadlock.\" A deadlock occurs when both the sending and receiving sockets are waiting on each other, or waiting for a common resource. This situation might occur if the `CArchive` object worked with the `CSocketFile` the way it does with a `CFile` object. With `CFile`, the archive can assume that if it receives fewer bytes than it requested, the end of file has been reached. With `CSocketFile`, however, data is message based; the buffer can contain multiple messages, so receiving fewer than the number of bytes requested does not imply end of file. The application does not block in this case as it might with `CFile`, and it can continue reading messages from the buffer until the buffer is empty. The [IsBufferEmpty](../mfc/reference/carchive-class.md#carchive__isbufferempty) function in `CArchive` is useful for monitoring the state of the archive's buffer in such a case.  \n  \n For more information, see [Windows Sockets: Using Sockets with Archives](../mfc/windows-sockets-using-sockets-with-archives.md)  \n  \n## See Also  \n [Windows Sockets in MFC](../mfc/windows-sockets-in-mfc.md)   \n [CObject::Serialize](../mfc/reference/cobject-class.md#cobject__serialize)\n\n"}