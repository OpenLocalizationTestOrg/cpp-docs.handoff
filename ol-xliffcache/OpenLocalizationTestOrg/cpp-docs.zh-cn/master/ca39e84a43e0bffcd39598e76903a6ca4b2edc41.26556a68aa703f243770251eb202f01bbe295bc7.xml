{"nodes":[{"pos":[12,73],"content":"Partial Ordering of Function Templates (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Partial Ordering of Function Templates (C++) | Microsoft Docs","pos":[0,61]}]},{"content":"Partial Ordering of Function Templates (C++)","pos":[631,675]},{"content":"Multiple function templates that match the argument list of a function call can be available.","pos":[676,769]},{"content":"C++ defines a partial ordering of function templates to specify which function should be called.","pos":[770,866]},{"content":"The ordering is partial because there can be some templates that are considered equally specialized.","pos":[867,967]},{"content":"The compiler chooses the most specialized template function available from the possible matches.","pos":[974,1070]},{"content":"For example, if a function template takes a type <bpt id=\"p1\">**</bpt>T<ept id=\"p1\">**</ept>, and another function template taking <bpt id=\"p2\">**</bpt>T<ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept> is available, the <bpt id=\"p3\">**</bpt>T<ph id=\"ph2\">\\*</ph><ept id=\"p3\">**</ept> version is said to be more specialized and is preferred over the generic <bpt id=\"p4\">**</bpt>T<ept id=\"p4\">**</ept> version whenever the argument is a pointer type, even though both would be allowable matches.","pos":[1071,1370],"source":" For example, if a function template takes a type **T**, and another function template taking **T\\*** is available, the **T\\*** version is said to be more specialized and is preferred over the generic **T** version whenever the argument is a pointer type, even though both would be allowable matches."},{"content":"Use the following process to determine if one function template candidate is more specialized:","pos":[1377,1471]},{"content":"Consider two function templates, T1 and T2.","pos":[1481,1524]},{"content":"Replace the parameters in T1 with a hypothetical unique type X.","pos":[1534,1597]},{"content":"With the parameter list in T1, see if T2 is a valid template for that parameter list.","pos":[1607,1692]},{"content":"Ignore any implicit conversions.","pos":[1693,1725]},{"content":"Repeat the same process with T1 and T2 reversed.","pos":[1735,1783]},{"content":"If one template is a valid template argument list for the other template, but the converse is not true, then that template is considered to be less specialized than the other template.","pos":[1793,1977]},{"content":"If both templates using the previous step form valid arguments for each other, then they are considered to be equally specialized, and an ambiguous call will result when attempting to use them.","pos":[1978,2171]},{"content":"Using these rules:","pos":[2181,2199]},{"content":"A template specialization for a specific type is more specialized than one taking a generic type argument.","pos":[2213,2319]},{"pos":[2333,2565],"content":"A template taking only <bpt id=\"p1\">**</bpt>T<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> is more specialized than one taking only <bpt id=\"p2\">**</bpt>T<ept id=\"p2\">**</ept>, because a hypothetical type <bpt id=\"p3\">**</bpt>X<ph id=\"ph2\">\\*</ph><ept id=\"p3\">**</ept> is a valid argument for a <bpt id=\"p4\">**</bpt>T<ept id=\"p4\">**</ept> template argument, but <bpt id=\"p5\">**</bpt>X<ept id=\"p5\">**</ept> is not a valid argument for a <bpt id=\"p6\">**</bpt>T<ph id=\"ph3\">\\*</ph><ept id=\"p6\">**</ept> template argument.","source":"A template taking only **T\\*** is more specialized than one taking only **T**, because a hypothetical type **X\\*** is a valid argument for a **T** template argument, but **X** is not a valid argument for a **T\\*** template argument."},{"pos":[2579,2764],"content":"<bpt id=\"p1\">**</bpt>const T<ept id=\"p1\">**</ept> is more specialized than <bpt id=\"p2\">**</bpt>T<ept id=\"p2\">**</ept>, because <bpt id=\"p3\">**</bpt>const X<ept id=\"p3\">**</ept> is a valid argument for a <bpt id=\"p4\">**</bpt>T<ept id=\"p4\">**</ept> template argument, but <bpt id=\"p5\">**</bpt>X<ept id=\"p5\">**</ept> is not a valid argument for a <bpt id=\"p6\">**</bpt>const T<ept id=\"p6\">**</ept> template argument.","source":"**const T** is more specialized than **T**, because **const X** is a valid argument for a **T** template argument, but **X** is not a valid argument for a **const T** template argument."},{"pos":[2778,2975],"content":"<bpt id=\"p1\">**</bpt>const T<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> is more specialized than <bpt id=\"p2\">**</bpt>T<ph id=\"ph2\">\\*</ph><ept id=\"p2\">**</ept>, because <bpt id=\"p3\">**</bpt>const X<ph id=\"ph3\">\\*</ph><ept id=\"p3\">**</ept> is a valid argument for a <bpt id=\"p4\">**</bpt>T<ph id=\"ph4\">\\*</ph><ept id=\"p4\">**</ept> template argument, but <bpt id=\"p5\">**</bpt>X<ph id=\"ph5\">\\*</ph><ept id=\"p5\">**</ept> is not a valid argument for a <bpt id=\"p6\">**</bpt>const T<ph id=\"ph6\">\\*</ph><ept id=\"p6\">**</ept> template argument.","source":"**const T\\*** is more specialized than **T\\***, because **const X\\*** is a valid argument for a **T\\*** template argument, but **X\\*** is not a valid argument for a **const T\\*** template argument."},{"content":"The following sample works in Visual C++ .NET 2003 as specified in the standard:","pos":[2985,3065]},{"content":"Output","pos":[3850,3856]},{"content":"See Also","pos":[3996,4004]},{"content":"Function Templates","pos":[4009,4027]}],"content":"---\ntitle: \"Partial Ordering of Function Templates (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"partial ordering of function templates\"\nms.assetid: 0c17347d-0e80-47ad-b5ac-046462d9dc73\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Partial Ordering of Function Templates (C++)\nMultiple function templates that match the argument list of a function call can be available. C++ defines a partial ordering of function templates to specify which function should be called. The ordering is partial because there can be some templates that are considered equally specialized.  \n  \n The compiler chooses the most specialized template function available from the possible matches. For example, if a function template takes a type **T**, and another function template taking **T\\*** is available, the **T\\*** version is said to be more specialized and is preferred over the generic **T** version whenever the argument is a pointer type, even though both would be allowable matches.  \n  \n Use the following process to determine if one function template candidate is more specialized:  \n  \n1.  Consider two function templates, T1 and T2.  \n  \n2.  Replace the parameters in T1 with a hypothetical unique type X.  \n  \n3.  With the parameter list in T1, see if T2 is a valid template for that parameter list. Ignore any implicit conversions.  \n  \n4.  Repeat the same process with T1 and T2 reversed.  \n  \n5.  If one template is a valid template argument list for the other template, but the converse is not true, then that template is considered to be less specialized than the other template. If both templates using the previous step form valid arguments for each other, then they are considered to be equally specialized, and an ambiguous call will result when attempting to use them.  \n  \n6.  Using these rules:  \n  \n    1.  A template specialization for a specific type is more specialized than one taking a generic type argument.  \n  \n    2.  A template taking only **T\\*** is more specialized than one taking only **T**, because a hypothetical type **X\\*** is a valid argument for a **T** template argument, but **X** is not a valid argument for a **T\\*** template argument.  \n  \n    3.  **const T** is more specialized than **T**, because **const X** is a valid argument for a **T** template argument, but **X** is not a valid argument for a **const T** template argument.  \n  \n    4.  **const T\\*** is more specialized than **T\\***, because **const X\\*** is a valid argument for a **T\\*** template argument, but **X\\*** is not a valid argument for a **const T\\*** template argument.  \n  \n7.  The following sample works in Visual C++ .NET 2003 as specified in the standard:  \n  \n```  \n// partial_ordering_of_function_templates.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nextern \"C\" int printf(const char*,...);  \ntemplate <class T> void f(T) {  \n   printf_s(\"Less specialized function called\\n\");  \n}  \n  \ntemplate <class T> void f(T*) {  \n   printf_s(\"More specialized function called\\n\");  \n}  \n  \ntemplate <class T> void f(const T*) {  \n   printf_s(\"Even more specialized function for const T*\\n\");  \n}  \n  \nint main() {  \n   int i =0;  \n   const int j = 0;  \n   int *pi = &i;  \n   const int *cpi = &j;  \n  \n   f(i);   // Calls less specialized function.  \n   f(pi);  // Calls more specialized function.  \n   f(cpi); // Calls even more specialized function.  \n   // Without partial ordering, these calls would be ambiguous.  \n}  \n```  \n  \n### Output  \n  \n```  \nLess specialized function called  \nMore specialized function called  \nEven more specialized function for const T*  \n```  \n  \n## See Also  \n [Function Templates](../cpp/function-templates.md)"}