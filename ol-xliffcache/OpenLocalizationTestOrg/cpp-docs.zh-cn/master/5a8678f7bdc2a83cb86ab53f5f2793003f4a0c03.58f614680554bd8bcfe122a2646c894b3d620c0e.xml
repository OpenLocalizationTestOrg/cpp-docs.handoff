{"nodes":[{"pos":[12,61],"content":"Compiler Warning (level 4) C4754 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Warning (level 4) C4754 | Microsoft Docs","pos":[0,49]}]},{"content":"Compiler Warning (level 4) C4754","pos":[635,667]},{"content":"Conversion rules for arithmetic operations in a comparison mean that one branch cannot be executed.","pos":[668,767]},{"content":"The C4754 warning is issued because the result of the comparison is always the same.","pos":[774,858]},{"content":"This indicates that one of the branches of the condition is never executed, most likely because the associated integer expression is incorrect.","pos":[859,1002]},{"content":"This code defect often occurs in incorrect integer overflow checks on 64-bit architectures.","pos":[1003,1094]},{"content":"Integer conversion rules are complex and there are many subtle pitfalls.","pos":[1101,1173]},{"content":"As an alternative to fixing each C4754 warning, you can update the code to use the <bpt id=\"p1\">[</bpt>SafeInt Library<ept id=\"p1\">](../../windows/safeint-library.md)</ept>.","pos":[1174,1309],"source":" As an alternative to fixing each C4754 warning, you can update the code to use the [SafeInt Library](../../windows/safeint-library.md)."},{"content":"Example","pos":[1318,1325]},{"content":"This sample generates C4754:","pos":[1329,1357]},{"content":"The addition <ph id=\"ph1\">`a + b`</ph> could cause an arithmetic overflow before the result is upcast to a 64-bit value and assigned to the 64-bit variable <ph id=\"ph2\">`x`</ph>.","pos":[1665,1807],"source":"The addition `a + b` could cause an arithmetic overflow before the result is upcast to a 64-bit value and assigned to the 64-bit variable `x`."},{"content":"This means that the check on <ph id=\"ph1\">`x`</ph> is redundant and will never catch an overflow.","pos":[1808,1887],"source":" This means that the check on `x` is redundant and will never catch an overflow."},{"content":"In this case, the compiler emits this warning:","pos":[1888,1934]},{"content":"To eliminate the warning, you can change the assignment statement to cast the operands to 8-byte values:","pos":[2159,2263]},{"content":"Example","pos":[2536,2543]},{"content":"The next sample also generates C4754.","pos":[2547,2584]},{"content":"The <ph id=\"ph1\">`sizeof()`</ph> operator returns a <ph id=\"ph2\">`size_t`</ph>, whose size is architecture-dependent.","pos":[2853,2934],"source":"The `sizeof()` operator returns a `size_t`, whose size is architecture-dependent."},{"content":"The example code works on 32-bit architectures where a <ph id=\"ph1\">`size_t`</ph> is a 32-bit type.","pos":[2935,3016],"source":" The example code works on 32-bit architectures where a `size_t` is a 32-bit type."},{"content":"However, on 64-bit architectures, <ph id=\"ph1\">`size_t`</ph> is a 64-bit type.","pos":[3017,3077],"source":" However, on 64-bit architectures, `size_t` is a 64-bit type."},{"content":"The conversion rules for integers mean that <ph id=\"ph1\">`a`</ph> is upcast to a 64-bit value in the expression <ph id=\"ph2\">`a + b &lt; a`</ph> as if it were written <ph id=\"ph3\">`(size_t)a + (size_t)b &lt; (size_t)a`</ph>.","pos":[3078,3242],"source":" The conversion rules for integers mean that `a` is upcast to a 64-bit value in the expression `a + b < a` as if it were written `(size_t)a + (size_t)b < (size_t)a`."},{"content":"When <ph id=\"ph1\">`a`</ph> and <ph id=\"ph2\">`b`</ph> are 32-bit integers, the 64-bit addition operation can never overflow, and the constraint never holds.","pos":[3243,3362],"source":" When `a` and `b` are 32-bit integers, the 64-bit addition operation can never overflow, and the constraint never holds."},{"content":"As a result, the code never detects an integer overflow condition on 64-bit architectures.","pos":[3363,3453]},{"content":"This example causes the compiler to emit this warning:","pos":[3454,3508]},{"content":"Notice that the warning message explicitly lists the constant value 4 instead of the original source string—by the time the warning analysis encounters the offending code, <ph id=\"ph1\">`sizeof(unsigned long)`</ph> has already been converted to a constant.","pos":[3723,3960],"source":"Notice that the warning message explicitly lists the constant value 4 instead of the original source string—by the time the warning analysis encounters the offending code, `sizeof(unsigned long)` has already been converted to a constant."},{"content":"Therefore, you may have to track down which expression in the source code is associated with the constant value in the warning message.","pos":[3961,4096]},{"content":"The most common sources of code resolved to constants in C4754 warning messages are expressions such as <ph id=\"ph1\">`sizeof(TYPE)`</ph> and <ph id=\"ph2\">`strlen(szConstantString)`</ph>.","pos":[4097,4247],"source":" The most common sources of code resolved to constants in C4754 warning messages are expressions such as `sizeof(TYPE)` and `strlen(szConstantString)`."},{"content":"In this case, the fixed code would resemble this:","pos":[4254,4303]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> The line number referred to in compiler warnings is the last line of a statement.","pos":[4540,4630],"source":"**Note** The line number referred to in compiler warnings is the last line of a statement."},{"content":"In a warning message about a complex conditional statement that's spread over multiple lines, the line that has the code defect may be several lines before the line that's reported.","pos":[4631,4812]},{"content":"For example:","pos":[4813,4825]}],"content":"---\ntitle: \"Compiler Warning (level 4) C4754 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C4754\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C4754\"\nms.assetid: e0e4606a-754a-4f42-a274-21a34978d21d\ncaps.latest.revision: 6\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Compiler Warning (level 4) C4754\nConversion rules for arithmetic operations in a comparison mean that one branch cannot be executed.  \n  \n The C4754 warning is issued because the result of the comparison is always the same. This indicates that one of the branches of the condition is never executed, most likely because the associated integer expression is incorrect. This code defect often occurs in incorrect integer overflow checks on 64-bit architectures.  \n  \n Integer conversion rules are complex and there are many subtle pitfalls. As an alternative to fixing each C4754 warning, you can update the code to use the [SafeInt Library](../../windows/safeint-library.md).  \n  \n## Example  \n This sample generates C4754:  \n  \n```cpp  \n// C4754a.cpp  \n// Compile with: /W4 /c  \n#include \"errno.h\"  \n  \nint sum_overflow(unsigned long a, unsigned long b)   \n{  \n   unsigned long long x = a + b; // C4754  \n  \n   if (x > 0xFFFFFFFF)   \n   {  \n      // never executes!  \n      return EOVERFLOW;  \n   }  \n   return 0;  \n}  \n```  \n  \n The addition `a + b` could cause an arithmetic overflow before the result is upcast to a 64-bit value and assigned to the 64-bit variable `x`. This means that the check on `x` is redundant and will never catch an overflow. In this case, the compiler emits this warning:  \n  \n```Output  \nWarning C4754: Conversion rules for arithmetic operations in the comparison at C4754a.cpp (7) mean that one branch cannot be executed. Cast '(a + ...)' to 'ULONG64' (or similar type of 8 bytes).  \n```  \n  \n To eliminate the warning, you can change the assignment statement to cast the operands to 8-byte values:  \n  \n```cpp  \n// Casting one operand is sufficient to force all the operands in   \n// the addition be upcast according to C/C++ conversion rules, but  \n// casting both is clearer.  \nunsigned long long x =   \n   (unsigned long long)a + (unsigned long long)b;  \n```  \n  \n## Example  \n The next sample also generates C4754.  \n  \n```cpp  \n// C4754b.cpp  \n// Compile with: /W4 /c  \n#include \"errno.h\"  \n  \nint wrap_overflow(unsigned long a)   \n{  \n   if (a + sizeof(unsigned long) < a) // C4754  \n   {   \n      // never executes!  \n      return EOVERFLOW;  \n   }  \n   return 0;  \n}  \n```  \n  \n The `sizeof()` operator returns a `size_t`, whose size is architecture-dependent. The example code works on 32-bit architectures where a `size_t` is a 32-bit type. However, on 64-bit architectures, `size_t` is a 64-bit type. The conversion rules for integers mean that `a` is upcast to a 64-bit value in the expression `a + b < a` as if it were written `(size_t)a + (size_t)b < (size_t)a`. When `a` and `b` are 32-bit integers, the 64-bit addition operation can never overflow, and the constraint never holds. As a result, the code never detects an integer overflow condition on 64-bit architectures. This example causes the compiler to emit this warning:  \n  \n```Output  \nWarning C4754: Conversion rules for arithmetic operations in the comparison at C4754b.cpp (7) mean that one branch cannot be executed. Cast '4' to 'ULONG' (or similar type of 4 bytes).  \n```  \n  \n Notice that the warning message explicitly lists the constant value 4 instead of the original source string—by the time the warning analysis encounters the offending code, `sizeof(unsigned long)` has already been converted to a constant. Therefore, you may have to track down which expression in the source code is associated with the constant value in the warning message. The most common sources of code resolved to constants in C4754 warning messages are expressions such as `sizeof(TYPE)` and `strlen(szConstantString)`.  \n  \n In this case, the fixed code would resemble this:  \n  \n```cpp  \n// Casting the result of sizeof() to unsigned long ensures  \n// that all the addition operands are 32-bit, so any overflow   \n// is detected by the check.  \nif (a + (unsigned long)sizeof(unsigned long) < a)  \n  \n```  \n  \n **Note** The line number referred to in compiler warnings is the last line of a statement. In a warning message about a complex conditional statement that's spread over multiple lines, the line that has the code defect may be several lines before the line that's reported. For example:  \n  \n```cpp  \nunsigned long a;  \n  \nif (a + sizeof(unsigned long) < a || // incorrect check  \n    condition1() ||   \n    a == 0) {    // C4754 warning reported on this line  \n         // never executes!  \n         return INVALID_PARAMETER;  \n}  \n```"}