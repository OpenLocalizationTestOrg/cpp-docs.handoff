{"nodes":[{"pos":[12,64],"content":"Overview of the Concurrency Runtime | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Overview of the Concurrency Runtime | Microsoft Docs","pos":[0,52]}]},{"content":"Overview of the Concurrency Runtime","pos":[729,764]},{"content":"This document provides an overview of the Concurrency Runtime.","pos":[765,827]},{"content":"It describes the benefits of the Concurrency Runtime, when to use it, and how its components interact with each other and with the operating system and applications.","pos":[828,993]},{"pos":[1001,1392],"content":"[!IMPORTANT]\n In Visual Studio 2015 and later, the Concurrency Runtime Task Scheduler is no longer the scheduler for the task class and related types in ppltasks.h. Those types now use the Windows ThreadPool for better performance and interoperability with Windows synchronization primitives. Parallel algorithms such as parallel_for continue to use the Concurrency Runtime Task Scheduler.","leadings":["","> "],"nodes":[{"content":" In Visual Studio 2015 and later, the Concurrency Runtime Task Scheduler is no longer the scheduler for the task class and related types in ppltasks.h. Those types now use the Windows ThreadPool for better performance and interoperability with Windows synchronization primitives. Parallel algorithms such as parallel_for continue to use the Concurrency Runtime Task Scheduler.","pos":[13,389],"nodes":[{"content":"In Visual Studio 2015 and later, the Concurrency Runtime Task Scheduler is no longer the scheduler for the task class and related types in ppltasks.h.","pos":[1,151]},{"content":"Those types now use the Windows ThreadPool for better performance and interoperability with Windows synchronization primitives.","pos":[152,279]},{"content":"Parallel algorithms such as parallel_for continue to use the Concurrency Runtime Task Scheduler.","pos":[280,376]}]}]},{"pos":[1421,1429],"content":"Sections"},{"content":"This document contains the following sections:","pos":[1433,1479]},{"content":"Why a Runtime for Concurrency is Important","pos":[1490,1532]},{"content":"Architecture","pos":[1554,1566]},{"content":"C++ Lambda Expressions","pos":[1593,1615]},{"content":"Requirements","pos":[1636,1648]},{"pos":[1697,1739],"content":"Why a Runtime for Concurrency is Important"},{"content":"A runtime for concurrency provides uniformity and predictability to applications and application components that run simultaneously.","pos":[1743,1875]},{"content":"Two examples of the benefits of the Concurrency Runtime are <bpt id=\"p1\">*</bpt>cooperative task scheduling<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>cooperative blocking<ept id=\"p2\">*</ept>.","pos":[1876,1993],"source":" Two examples of the benefits of the Concurrency Runtime are *cooperative task scheduling* and *cooperative blocking*."},{"content":"The Concurrency Runtime uses a cooperative task scheduler that implements a work-stealing algorithm to efficiently distribute work among computing resources.","pos":[2000,2157]},{"content":"For example, consider an application that has two threads that are both managed by the same runtime.","pos":[2158,2258]},{"content":"If one thread finishes its scheduled task, it can offload work from the other thread.","pos":[2259,2344]},{"content":"This mechanism balances the overall workload of the application.","pos":[2345,2409]},{"content":"The Concurrency Runtime also provides synchronization primitives that use cooperative blocking to synchronize access to resources.","pos":[2416,2546]},{"content":"For example, consider a task that must have exclusive access to a shared resource.","pos":[2547,2629]},{"content":"By blocking cooperatively, the runtime can use the remaining quantum to perform another task as the first task waits for the resource.","pos":[2630,2764]},{"content":"This mechanism promotes maximum usage of computing resources.","pos":[2765,2826]},{"pos":[2833,2846],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[2884,2896],"content":"Architecture"},{"content":"The Concurrency Runtime is divided into four components: the Parallel Patterns Library (PPL), the Asynchronous Agents Library, the Task Scheduler, and the Resource Manager.","pos":[2900,3072]},{"content":"These components reside between the operating system and applications.","pos":[3073,3143]},{"content":"The following illustration shows how the Concurrency Runtime components interact among the operating system and applications:","pos":[3144,3269]},{"content":"Concurrency Runtime Architecture","pos":[3278,3310]},{"content":"The Concurrency Runtime Architecture","pos":[3321,3357]},{"pos":[3431,3663],"content":"[!IMPORTANT]\n The Task Scheduler and Resource Manager components are not available from a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app or when you use the task class or other types in ppltasks.h.","leadings":["","> "],"nodes":[{"content":"The Task Scheduler and Resource Manager components are not available from a <ph id=\"ph1\">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app or when you use the task class or other types in ppltasks.h.","pos":[14,230],"source":" The Task Scheduler and Resource Manager components are not available from a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app or when you use the task class or other types in ppltasks.h."}]},{"content":"The Concurrency Runtime is highly <bpt id=\"p1\">*</bpt>composable<ept id=\"p1\">*</ept>, that is, you can combine existing functionality to do more.","pos":[3670,3777],"source":"The Concurrency Runtime is highly *composable*, that is, you can combine existing functionality to do more."},{"content":"The Concurrency Runtime composes many features, such as parallel algorithms, from lower-level components.","pos":[3778,3883]},{"content":"The Concurrency Runtime also provides synchronization primitives that use cooperative blocking to synchronize access to resources.","pos":[3890,4020]},{"content":"For more information about these synchronization primitives, see <bpt id=\"p1\">[</bpt>Synchronization Data Structures<ept id=\"p1\">](../../parallel/concrt/synchronization-data-structures.md)</ept>.","pos":[4021,4178],"source":" For more information about these synchronization primitives, see [Synchronization Data Structures](../../parallel/concrt/synchronization-data-structures.md)."},{"content":"The following sections provide a brief overview of what each component provides and when to use it.","pos":[4185,4284]},{"content":"Parallel Patterns Library","pos":[4294,4319]},{"content":"The Parallel Patterns Library (PPL) provides general-purpose containers and algorithms for performing fine-grained parallelism.","pos":[4323,4450]},{"content":"The PPL enables <bpt id=\"p1\">*</bpt>imperative data parallelism<ept id=\"p1\">*</ept> by providing parallel algorithms that distribute computations on collections or on sets of data across computing resources.","pos":[4451,4620],"source":" The PPL enables *imperative data parallelism* by providing parallel algorithms that distribute computations on collections or on sets of data across computing resources."},{"content":"It also enables <bpt id=\"p1\">*</bpt>task parallelism<ept id=\"p1\">*</ept> by providing task objects that distribute multiple independent operations across computing resources.","pos":[4621,4757],"source":" It also enables *task parallelism* by providing task objects that distribute multiple independent operations across computing resources."},{"content":"Use the Parallel Patterns Library when you have a local computation that can benefit from parallel execution.","pos":[4764,4873]},{"content":"For example, you can use the <bpt id=\"p1\">[</bpt>concurrency::parallel_for<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_for)</ept> algorithm to transform an existing <ph id=\"ph1\">`for`</ph> loop to act in parallel.","pos":[4874,5055],"source":" For example, you can use the [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for) algorithm to transform an existing `for` loop to act in parallel."},{"pos":[5062,5214],"content":"For more information about the Parallel Patterns Library, see <bpt id=\"p1\">[</bpt>Parallel Patterns Library (PPL)<ept id=\"p1\">](../../parallel/concrt/parallel-patterns-library-ppl.md)</ept>.","source":"For more information about the Parallel Patterns Library, see [Parallel Patterns Library (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)."},{"content":"Asynchronous Agents Library","pos":[5224,5251]},{"content":"The Asynchronous Agents Library (or just <bpt id=\"p1\">*</bpt>Agents Library<ept id=\"p1\">*</ept>) provides both an actor-based programming model and message passing interfaces for coarse-grained dataflow and pipelining tasks.","pos":[5255,5441],"source":"The Asynchronous Agents Library (or just *Agents Library*) provides both an actor-based programming model and message passing interfaces for coarse-grained dataflow and pipelining tasks."},{"content":"Asynchronous agents enable you to make productive use of latency by performing work as other components wait for data.","pos":[5442,5560]},{"content":"Use the Agents Library when you have multiple entities that communicate with each other asynchronously.","pos":[5567,5670]},{"content":"For example, you can create an agent that reads data from a file or network connection and then uses the message passing interfaces to send that data to another agent.","pos":[5671,5838]},{"pos":[5845,5980],"content":"For more information about the Agents Library, see <bpt id=\"p1\">[</bpt>Asynchronous Agents Library<ept id=\"p1\">](../../parallel/concrt/asynchronous-agents-library.md)</ept>.","source":"For more information about the Agents Library, see [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md)."},{"content":"Task Scheduler","pos":[5990,6004]},{"content":"The Task Scheduler schedules and coordinates tasks at run time.","pos":[6008,6071]},{"content":"The Task Scheduler is cooperative and uses a work-stealing algorithm to achieve maximum usage of processing resources.","pos":[6072,6190]},{"content":"The Concurrency Runtime provides a default scheduler so that you do not have to manage infrastructure details.","pos":[6197,6307]},{"content":"However, to meet the quality needs of your application, you can also provide your own scheduling policy or associate specific schedulers with specific tasks.","pos":[6308,6465]},{"pos":[6472,6601],"content":"For more information about the Task Scheduler, see <bpt id=\"p1\">[</bpt>Task Scheduler<ept id=\"p1\">](../../parallel/concrt/task-scheduler-concurrency-runtime.md)</ept>.","source":"For more information about the Task Scheduler, see [Task Scheduler](../../parallel/concrt/task-scheduler-concurrency-runtime.md)."},{"content":"Resource Manager","pos":[6611,6627]},{"content":"The role of the Resource Manager is to manage computing resources, such as processors and memory.","pos":[6631,6728]},{"content":"The Resource Manager responds to workloads as they change at run time by assigning resources to where they can be most effective.","pos":[6729,6858]},{"content":"The Resource Manager serves as an abstraction over computing resources and primarily interacts with the Task Scheduler.","pos":[6865,6984]},{"content":"Although you can use the Resource Manager to fine-tune the performance of your libraries and applications, you typically use the functionality that is provided by the Parallel Patterns Library, the Agents Library, and the Task Scheduler.","pos":[6985,7222]},{"content":"These libraries use the Resource Manager to dynamically rebalance resources as workloads change.","pos":[7223,7319]},{"pos":[7326,7339],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[7371,7393],"content":"C++ Lambda Expressions"},{"content":"Many of the types and algorithms that are defined by the Concurrency Runtime are implemented as C++ templates.","pos":[7397,7507]},{"content":"Some of these types and algorithms take as a parameter a routine that performs work.","pos":[7508,7592]},{"content":"This parameter can be a lambda function, a function object, or a function pointer.","pos":[7593,7675]},{"content":"These entities are also referred to as <bpt id=\"p1\">*</bpt>work functions<ept id=\"p1\">*</ept> or <bpt id=\"p2\">*</bpt>work routines<ept id=\"p2\">*</ept>.","pos":[7676,7751],"source":" These entities are also referred to as *work functions* or *work routines*."},{"content":"Lambda expressions are an important new Visual C++ language feature because they provide a succinct way to define work functions for parallel processing.","pos":[7758,7911]},{"content":"Function objects and function pointers enable you to use the Concurrency Runtime with your existing code.","pos":[7912,8017]},{"content":"However, we recommend that you use lambda expressions when you write new code because of the safety and productivity benefits that they provide.","pos":[8018,8162]},{"content":"The following example compares the syntax of lambda functions, function objects, and function pointers in multiple calls to the <bpt id=\"p1\">[</bpt>concurrency::parallel_for_each<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_for_each)</ept> algorithm.","pos":[8169,8404],"source":"The following example compares the syntax of lambda functions, function objects, and function pointers in multiple calls to the [concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) algorithm."},{"content":"Each call to <ph id=\"ph1\">`parallel_for_each`</ph> uses a different technique to compute the square of each element in a <bpt id=\"p1\">[</bpt>std::array<ept id=\"p1\">](../../standard-library/array-class-stl.md)</ept> object.","pos":[8405,8571],"source":" Each call to `parallel_for_each` uses a different technique to compute the square of each element in a [std::array](../../standard-library/array-class-stl.md) object."},{"pos":[8589,8622],"content":"concrt-comparing-work-functions#1"},{"content":"Output","pos":[8714,8720]},{"pos":[8784,8901],"content":"For more information about lambda functions in C++, see <bpt id=\"p1\">[</bpt>Lambda Expressions<ept id=\"p1\">](../../cpp/lambda-expressions-in-cpp.md)</ept>.","source":"For more information about lambda functions in C++, see [Lambda Expressions](../../cpp/lambda-expressions-in-cpp.md)."},{"pos":[8908,8921],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[8959,8971],"content":"Requirements"},{"content":"The following table shows the header files that are associated with each component of the Concurrency Runtime:","pos":[8975,9085]},{"content":"Component","pos":[9092,9101]},{"content":"Header Files","pos":[9102,9114]},{"content":"Parallel Patterns Library (PPL)","pos":[9158,9189]},{"content":"ppl.h","pos":[9190,9195]},{"content":"concurrent_queue.h","pos":[9208,9226]},{"content":"concurrent_vector.h","pos":[9239,9258]},{"content":"Asynchronous Agents Library","pos":[9263,9290]},{"content":"agents.h","pos":[9291,9299]},{"content":"Task Scheduler","pos":[9304,9318]},{"content":"concrt.h","pos":[9319,9327]},{"content":"Resource Manager","pos":[9332,9348]},{"content":"concrtrm.h","pos":[9349,9359]},{"content":"The Concurrency Runtime is declared in the <bpt id=\"p1\">[</bpt>Concurrency<ept id=\"p1\">](../../parallel/concrt/reference/concurrency-namespace.md)</ept> namespace.","pos":[9367,9492],"source":"The Concurrency Runtime is declared in the [Concurrency](../../parallel/concrt/reference/concurrency-namespace.md) namespace."},{"content":"(You can also use <bpt id=\"p1\">[</bpt>concurrency<ept id=\"p1\">](../../parallel/concrt/reference/concurrency-namespace.md)</ept>, which is an alias for this namespace.) The <ph id=\"ph1\">`concurrency::details`</ph> namespace supports the Concurrency Runtime framework, and is not intended to be used directly from your code.","pos":[9493,9759],"source":" (You can also use [concurrency](../../parallel/concrt/reference/concurrency-namespace.md), which is an alias for this namespace.) The `concurrency::details` namespace supports the Concurrency Runtime framework, and is not intended to be used directly from your code."},{"content":"The Concurrency Runtime is provided as part of the C Runtime Library (CRT).","pos":[9766,9841]},{"content":"For more information about how to build an application that uses the CRT, see <bpt id=\"p1\">[</bpt>CRT Library Features<ept id=\"p1\">](../../c-runtime-library/crt-library-features.md)</ept>.","pos":[9842,9992],"source":" For more information about how to build an application that uses the CRT, see [CRT Library Features](../../c-runtime-library/crt-library-features.md)."},{"pos":[9999,10012],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"}],"content":"---\ntitle: \"Overview of the Concurrency Runtime | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"Concurrency Runtime, requirements\"\n  - \"Concurrency Runtime, architecture\"\n  - \"Concurrency Runtime, overview\"\n  - \"Concurrency Runtime, lambda expressions\"\nms.assetid: 56237d96-10b0-494a-9cb4-f5c5090436c5\ncaps.latest.revision: 22\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Overview of the Concurrency Runtime\nThis document provides an overview of the Concurrency Runtime. It describes the benefits of the Concurrency Runtime, when to use it, and how its components interact with each other and with the operating system and applications.  \n  \n> [!IMPORTANT]\n>  In Visual Studio 2015 and later, the Concurrency Runtime Task Scheduler is no longer the scheduler for the task class and related types in ppltasks.h. Those types now use the Windows ThreadPool for better performance and interoperability with Windows synchronization primitives. Parallel algorithms such as parallel_for continue to use the Concurrency Runtime Task Scheduler.  \n  \n##  <a name=\"top\"></a> Sections  \n This document contains the following sections:  \n  \n-   [Why a Runtime for Concurrency is Important](#runtime)  \n  \n-   [Architecture](#architecture)  \n  \n-   [C++ Lambda Expressions](#lambda)  \n  \n-   [Requirements](#requirements)  \n  \n##  <a name=\"runtime\"></a> Why a Runtime for Concurrency is Important  \n A runtime for concurrency provides uniformity and predictability to applications and application components that run simultaneously. Two examples of the benefits of the Concurrency Runtime are *cooperative task scheduling* and *cooperative blocking*.  \n  \n The Concurrency Runtime uses a cooperative task scheduler that implements a work-stealing algorithm to efficiently distribute work among computing resources. For example, consider an application that has two threads that are both managed by the same runtime. If one thread finishes its scheduled task, it can offload work from the other thread. This mechanism balances the overall workload of the application.  \n  \n The Concurrency Runtime also provides synchronization primitives that use cooperative blocking to synchronize access to resources. For example, consider a task that must have exclusive access to a shared resource. By blocking cooperatively, the runtime can use the remaining quantum to perform another task as the first task waits for the resource. This mechanism promotes maximum usage of computing resources.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"architecture\"></a> Architecture  \n The Concurrency Runtime is divided into four components: the Parallel Patterns Library (PPL), the Asynchronous Agents Library, the Task Scheduler, and the Resource Manager. These components reside between the operating system and applications. The following illustration shows how the Concurrency Runtime components interact among the operating system and applications:  \n  \n **Concurrency Runtime Architecture**  \n  \n ![The Concurrency Runtime Architecture](../../parallel/concrt/media/concurrencyrun.png \"concurrencyrun\")  \n  \n> [!IMPORTANT]\n>  The Task Scheduler and Resource Manager components are not available from a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app or when you use the task class or other types in ppltasks.h.  \n  \n The Concurrency Runtime is highly *composable*, that is, you can combine existing functionality to do more. The Concurrency Runtime composes many features, such as parallel algorithms, from lower-level components.  \n  \n The Concurrency Runtime also provides synchronization primitives that use cooperative blocking to synchronize access to resources. For more information about these synchronization primitives, see [Synchronization Data Structures](../../parallel/concrt/synchronization-data-structures.md).  \n  \n The following sections provide a brief overview of what each component provides and when to use it.  \n  \n### Parallel Patterns Library  \n The Parallel Patterns Library (PPL) provides general-purpose containers and algorithms for performing fine-grained parallelism. The PPL enables *imperative data parallelism* by providing parallel algorithms that distribute computations on collections or on sets of data across computing resources. It also enables *task parallelism* by providing task objects that distribute multiple independent operations across computing resources.  \n  \n Use the Parallel Patterns Library when you have a local computation that can benefit from parallel execution. For example, you can use the [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for) algorithm to transform an existing `for` loop to act in parallel.  \n  \n For more information about the Parallel Patterns Library, see [Parallel Patterns Library (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md).  \n  \n### Asynchronous Agents Library  \n The Asynchronous Agents Library (or just *Agents Library*) provides both an actor-based programming model and message passing interfaces for coarse-grained dataflow and pipelining tasks. Asynchronous agents enable you to make productive use of latency by performing work as other components wait for data.  \n  \n Use the Agents Library when you have multiple entities that communicate with each other asynchronously. For example, you can create an agent that reads data from a file or network connection and then uses the message passing interfaces to send that data to another agent.  \n  \n For more information about the Agents Library, see [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md).  \n  \n### Task Scheduler  \n The Task Scheduler schedules and coordinates tasks at run time. The Task Scheduler is cooperative and uses a work-stealing algorithm to achieve maximum usage of processing resources.  \n  \n The Concurrency Runtime provides a default scheduler so that you do not have to manage infrastructure details. However, to meet the quality needs of your application, you can also provide your own scheduling policy or associate specific schedulers with specific tasks.  \n  \n For more information about the Task Scheduler, see [Task Scheduler](../../parallel/concrt/task-scheduler-concurrency-runtime.md).  \n  \n### Resource Manager  \n The role of the Resource Manager is to manage computing resources, such as processors and memory. The Resource Manager responds to workloads as they change at run time by assigning resources to where they can be most effective.  \n  \n The Resource Manager serves as an abstraction over computing resources and primarily interacts with the Task Scheduler. Although you can use the Resource Manager to fine-tune the performance of your libraries and applications, you typically use the functionality that is provided by the Parallel Patterns Library, the Agents Library, and the Task Scheduler. These libraries use the Resource Manager to dynamically rebalance resources as workloads change.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"lambda\"></a> C++ Lambda Expressions  \n Many of the types and algorithms that are defined by the Concurrency Runtime are implemented as C++ templates. Some of these types and algorithms take as a parameter a routine that performs work. This parameter can be a lambda function, a function object, or a function pointer. These entities are also referred to as *work functions* or *work routines*.  \n  \n Lambda expressions are an important new Visual C++ language feature because they provide a succinct way to define work functions for parallel processing. Function objects and function pointers enable you to use the Concurrency Runtime with your existing code. However, we recommend that you use lambda expressions when you write new code because of the safety and productivity benefits that they provide.  \n  \n The following example compares the syntax of lambda functions, function objects, and function pointers in multiple calls to the [concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) algorithm. Each call to `parallel_for_each` uses a different technique to compute the square of each element in a [std::array](../../standard-library/array-class-stl.md) object.  \n  \n [!code-cpp[concrt-comparing-work-functions#1](../../parallel/concrt/codesnippet/cpp/overview-of-the-concurrency-runtime_1.cpp)]  \n  \n **Output**  \n  \n```Output  \n1  \n256  \n6561  \n65536  \n390625  \n```  \n  \n For more information about lambda functions in C++, see [Lambda Expressions](../../cpp/lambda-expressions-in-cpp.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"requirements\"></a> Requirements  \n The following table shows the header files that are associated with each component of the Concurrency Runtime:  \n  \n|Component|Header Files|  \n|---------------|------------------|  \n|Parallel Patterns Library (PPL)|ppl.h<br /><br /> concurrent_queue.h<br /><br /> concurrent_vector.h|  \n|Asynchronous Agents Library|agents.h|  \n|Task Scheduler|concrt.h|  \n|Resource Manager|concrtrm.h|  \n  \n The Concurrency Runtime is declared in the [Concurrency](../../parallel/concrt/reference/concurrency-namespace.md) namespace. (You can also use [concurrency](../../parallel/concrt/reference/concurrency-namespace.md), which is an alias for this namespace.) The `concurrency::details` namespace supports the Concurrency Runtime framework, and is not intended to be used directly from your code.  \n  \n The Concurrency Runtime is provided as part of the C Runtime Library (CRT). For more information about how to build an application that uses the CRT, see [CRT Library Features](../../c-runtime-library/crt-library-features.md).  \n  \n [[Top](#top)]\n\n\n\n"}