{"nodes":[{"pos":[12,76],"content":"How to: Marshal Embedded Pointers Using PInvoke | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Marshal Embedded Pointers Using PInvoke | Microsoft Docs","pos":[0,64]}]},{"content":"How to: Marshal Embedded Pointers Using PInvoke","pos":[796,843]},{"content":"Functions that are implemented in unmanaged DLLs can be called from managed code using Platform Invoke (P/Invoke) functionality.","pos":[844,972]},{"content":"If the source code for the DLL is not available, P/Invoke is the only option for interoperating.","pos":[973,1069]},{"content":"However, unlike other .NET languages, Visual C++ provides an alternative to P/Invoke.","pos":[1070,1155]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using C++ Interop (Implicit PInvoke)<ept id=\"p1\">](../dotnet/using-cpp-interop-implicit-pinvoke.md)</ept> and <bpt id=\"p2\">[</bpt>How to: Marshal Embedded Pointers Using C++ Interop<ept id=\"p2\">](../dotnet/how-to-marshal-embedded-pointers-using-cpp-interop.md)</ept>.","pos":[1156,1393],"source":" For more information, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md) and [How to: Marshal Embedded Pointers Using C++ Interop](../dotnet/how-to-marshal-embedded-pointers-using-cpp-interop.md)."},{"content":"Example","pos":[1402,1409]},{"content":"Passing structures to native code requires that a managed structure that is equivalent in terms of data layout to the native structure is created.","pos":[1413,1559]},{"content":"However, structures that contain pointers require special handling.","pos":[1560,1627]},{"content":"For each embedded pointer in the native structure, the managed version of the structure should contain an instance of the &lt;xref:System.IntPtr&gt; type.","pos":[1628,1776],"source":" For each embedded pointer in the native structure, the managed version of the structure should contain an instance of the <xref:System.IntPtr> type."},{"content":"Also, memory for these instances must be explicitly allocated, initialized, and released using the &lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;, &lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;, and &lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt; methods.","pos":[1777,2081],"source":" Also, memory for these instances must be explicitly allocated, initialized, and released using the <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A>, and <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> methods."},{"content":"The following code consists of an unmanaged and a managed module.","pos":[2088,2153]},{"content":"The unmanaged module is a DLL that defines a function that accepts a structure called ListString that contains a pointer, and a function called TakesListStruct.","pos":[2154,2314]},{"content":"The managed module is a command-line application that imports the TakesListStruct function and defines a structure called MListStruct that is equivalent to the native ListStruct except that the double* is represented with an &lt;xref:System.IntPtr&gt; instance.","pos":[2315,2570],"source":" The managed module is a command-line application that imports the TakesListStruct function and defines a structure called MListStruct that is equivalent to the native ListStruct except that the double* is represented with an <xref:System.IntPtr> instance."},{"content":"Before calling TakesListStruct, the main function allocates and initializes the memory that this field references.","pos":[2571,2685]},{"content":"The managed module is compiled with /clr, but /clr:pure works as well.","pos":[2692,2762]},{"content":"Note that no portion of the DLL is exposed to the managed code using the traditional #include directive.","pos":[4625,4729]},{"content":"In fact, the DLL is accessed at run time only, so problems with functions imported with &lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt; will not be detected at compile time.","pos":[4730,4912],"source":" In fact, the DLL is accessed at run time only, so problems with functions imported with <xref:System.Runtime.InteropServices.DllImportAttribute> will not be detected at compile time."},{"content":"See Also","pos":[4921,4929]},{"content":"Using Explicit PInvoke in C++ (DllImport Attribute)","pos":[4934,4985]}],"content":"---\ntitle: \"How to: Marshal Embedded Pointers Using PInvoke | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"embedded pointers [C++]\"\n  - \"interop [C++], embedded pointers\"\n  - \"platform invoke [C++], embedded pointers\"\n  - \"marshaling [C++], embedded pointers\"\n  - \"data marshaling [C++], embedded pointers\"\nms.assetid: f12c1b9a-4f82-45f8-83c8-3fc9321dbb98\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Marshal Embedded Pointers Using PInvoke\nFunctions that are implemented in unmanaged DLLs can be called from managed code using Platform Invoke (P/Invoke) functionality. If the source code for the DLL is not available, P/Invoke is the only option for interoperating. However, unlike other .NET languages, Visual C++ provides an alternative to P/Invoke. For more information, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md) and [How to: Marshal Embedded Pointers Using C++ Interop](../dotnet/how-to-marshal-embedded-pointers-using-cpp-interop.md).  \n  \n## Example  \n Passing structures to native code requires that a managed structure that is equivalent in terms of data layout to the native structure is created. However, structures that contain pointers require special handling. For each embedded pointer in the native structure, the managed version of the structure should contain an instance of the <xref:System.IntPtr> type. Also, memory for these instances must be explicitly allocated, initialized, and released using the <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A>, and <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> methods.  \n  \n The following code consists of an unmanaged and a managed module. The unmanaged module is a DLL that defines a function that accepts a structure called ListString that contains a pointer, and a function called TakesListStruct. The managed module is a command-line application that imports the TakesListStruct function and defines a structure called MListStruct that is equivalent to the native ListStruct except that the double* is represented with an <xref:System.IntPtr> instance. Before calling TakesListStruct, the main function allocates and initializes the memory that this field references.  \n  \n The managed module is compiled with /clr, but /clr:pure works as well.  \n  \n```  \n// TraditionalDll6.cpp  \n// compile with: /EHsc /LD  \n#include <stdio.h>  \n#include <iostream>  \n#define TRADITIONALDLL_EXPORTS  \n#ifdef TRADITIONALDLL_EXPORTS  \n#define TRADITIONALDLL_API __declspec(dllexport)  \n#else  \n#define TRADITIONALDLL_API __declspec(dllimport)  \n#endif  \n  \n#pragma pack(push, 8)  \nstruct ListStruct {  \n   int count;  \n   double* item;  \n};  \n#pragma pack(pop)  \n  \nextern \"C\" {  \n   TRADITIONALDLL_API void TakesListStruct(ListStruct);  \n}  \n  \nvoid TakesListStruct(ListStruct list) {  \n   printf_s(\"[unmanaged] count = %d\\n\", list.count);  \n   for (int i=0; i<list.count; i++)  \n      printf_s(\"array[%d] = %f\\n\", i, list.item[i]);  \n}  \n```  \n  \n```  \n// EmbeddedPointerMarshalling.cpp  \n// compile with: /clr  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n[StructLayout(LayoutKind::Sequential, Pack=8)]  \nvalue struct MListStruct {  \n   int count;  \n   IntPtr item;  \n};  \n  \nvalue struct TraditionalDLL {  \n    [DllImport(\"TraditionalDLL6.dll\")]  \n   static public void TakesListStruct(MListStruct);  \n};  \n  \nint main() {  \n   array<double>^ parray = gcnew array<double>(10);  \n   Console::WriteLine(\"[managed] count = {0}\", parray->Length);  \n  \n   Random^ r = gcnew Random();  \n   for (int i=0; i<parray->Length; i++) {  \n      parray[i] = r->NextDouble() * 100.0;  \n      Console::WriteLine(\"array[{0}] = {1}\", i, parray[i]);  \n   }  \n  \n   int size = Marshal::SizeOf(double::typeid);  \n   MListStruct list;  \n   list.count = parray->Length;  \n   list.item = Marshal::AllocCoTaskMem(size * parray->Length);  \n  \n   for (int i=0; i<parray->Length; i++) {  \n      IntPtr t = IntPtr(list.item.ToInt32() + i * size);  \n      Marshal::StructureToPtr(parray[i], t, false);  \n   }  \n  \n   TraditionalDLL::TakesListStruct( list );  \n   Marshal::FreeCoTaskMem(list.item);  \n}  \n```  \n  \n Note that no portion of the DLL is exposed to the managed code using the traditional #include directive. In fact, the DLL is accessed at run time only, so problems with functions imported with <xref:System.Runtime.InteropServices.DllImportAttribute> will not be detected at compile time.  \n  \n## See Also  \n [Using Explicit PInvoke in C++ (DllImport Attribute)](../dotnet/using-explicit-pinvoke-in-cpp-dllimport-attribute.md)"}