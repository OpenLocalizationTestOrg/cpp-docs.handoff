{"nodes":[{"pos":[12,58],"content":"__lzcnt16, __lzcnt, __lzcnt64 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"__lzcnt16, __lzcnt, __lzcnt64 | Microsoft Docs","pos":[0,46]}]},{"content":"__lzcnt16, __lzcnt, __lzcnt64","pos":[817,846]},{"content":"Microsoft Specific","pos":[849,867]},{"content":"Counts the number of leading zeros in a 16-, 32-, or 64-byte integer.","pos":[876,945]},{"content":"Syntax","pos":[954,960]},{"content":"Parameters","pos":[1161,1171]},{"content":"[in]","pos":[1175,1179]},{"content":"The 16-, 32-, or 64-bit unsigned integer to scan for leading zeros.","pos":[1191,1258]},{"content":"Return Value","pos":[1267,1279]},{"content":"The number of leading zero bits in the <ph id=\"ph1\">`value`</ph> parameter.","pos":[1283,1340],"source":"The number of leading zero bits in the `value` parameter."},{"content":"If <ph id=\"ph1\">`value`</ph> is zero, the return value is the size of the input operand (16, 32, or 64).","pos":[1341,1427],"source":" If `value` is zero, the return value is the size of the input operand (16, 32, or 64)."},{"content":"If the most significant bit of <ph id=\"ph1\">`value`</ph> is one, the return value is zero.","pos":[1428,1500],"source":" If the most significant bit of `value` is one, the return value is zero."},{"content":"Requirements","pos":[1509,1521]},{"content":"Intrinsic","pos":[1528,1537]},{"content":"Architecture","pos":[1538,1550]},{"content":"AMD: Advanced Bit Manipulation (ABM)","pos":[1606,1642]},{"content":"Intel: Haswell","pos":[1655,1669]},{"content":"AMD: Advanced Bit Manipulation (ABM)","pos":[1684,1720]},{"content":"Intel: Haswell","pos":[1733,1747]},{"content":"AMD: Advanced Bit Manipulation (ABM) in 64-bit mode.","pos":[1764,1816]},{"content":"Intel: Haswell","pos":[1829,1843]},{"pos":[1851,1878],"content":"<bpt id=\"p1\">**</bpt>Header file<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>intrin.h&gt;","source":"**Header file** \\<intrin.h>"},{"content":"Remarks","pos":[1887,1894]},{"content":"Each of these intrinsics generates the <ph id=\"ph1\">`lzcnt`</ph> instruction.","pos":[1898,1957],"source":"Each of these intrinsics generates the `lzcnt` instruction."},{"content":"The size of the value that the <ph id=\"ph1\">`lzcnt`</ph> instruction returns is the same as the size of its argument.","pos":[1959,2058],"source":"  The size of the value that the `lzcnt` instruction returns is the same as the size of its argument."},{"content":"In 32-bit mode there are no 64-bit general-purpose registers, hence no 64-bit <ph id=\"ph1\">`lzcnt`</ph>.","pos":[2060,2146],"source":"  In 32-bit mode there are no 64-bit general-purpose registers, hence no 64-bit `lzcnt`."},{"content":"To determine hardware support for the <ph id=\"ph1\">`lzcnt`</ph> instruction call the <ph id=\"ph2\">`__cpuid`</ph> intrinsic with <ph id=\"ph3\">`InfoType=0x80000001`</ph> and check bit 5 of <ph id=\"ph4\">`CPUInfo[2] (ECX)`</ph>.","pos":[2153,2305],"source":"To determine hardware support for the `lzcnt` instruction call the `__cpuid` intrinsic with `InfoType=0x80000001` and check bit 5 of `CPUInfo[2] (ECX)`."},{"content":"This bit will be 1 if the instruction is supported, and 0 otherwise.","pos":[2306,2374]},{"content":"If you run code that uses this intrinsic on hardware that does not support the <ph id=\"ph1\">`lzcnt`</ph> instruction, the results are unpredictable.","pos":[2375,2505],"source":" If you run code that uses this intrinsic on hardware that does not support the `lzcnt` instruction, the results are unpredictable."},{"content":"On Intel processors that do not support the <ph id=\"ph1\">`lzcnt`</ph> instruction, the instruction byte encoding is executed as <ph id=\"ph2\">`bsr`</ph> (bit scan reverse).","pos":[2512,2647],"source":"On Intel processors that do not support the `lzcnt` instruction, the instruction byte encoding is executed as `bsr` (bit scan reverse)."},{"content":"If code portability is a concern, consider use of the <ph id=\"ph1\">`_BitScanReverse`</ph> intrinsic instead.","pos":[2648,2738],"source":" If code portability is a concern, consider use of the `_BitScanReverse` intrinsic instead."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>_BitScanReverse, _BitScanReverse64<ept id=\"p1\">](../intrinsics/bitscanreverse-bitscanreverse64.md)</ept>.","pos":[2739,2852],"source":" For more information, see [_BitScanReverse, _BitScanReverse64](../intrinsics/bitscanreverse-bitscanreverse64.md)."},{"content":"Example","pos":[2861,2868]},{"content":"END Microsoft Specific","pos":[3646,3668]},{"content":"Portions of this content are Copyright 2007 by Advanced Micro Devices, Inc. All rights reserved.","pos":[3672,3768]},{"content":"Reproduced with permission from Advanced Micro Devices, Inc.","pos":[3769,3829]},{"content":"See Also","pos":[3838,3846]},{"content":"Compiler Intrinsics","pos":[3851,3870]}],"content":"---\ntitle: \"__lzcnt16, __lzcnt, __lzcnt64 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"__lzcnt64\"\n  - \"__lzcnt16\"\n  - \"__lzcnt\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__lzcnt intrinsic\"\n  - \"lzcnt instruction\"\n  - \"lzcnt16 intrinsic\"\n  - \"lzcnt intrinsic\"\n  - \"__lzcnt16 intrinsic\"\n  - \"lzcnt64 intrinsic\"\n  - \"__lzcnt64 intrinsic\"\nms.assetid: 412113e7-052e-46e5-8bfa-d5ad72abc10e\ncaps.latest.revision: 14\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# __lzcnt16, __lzcnt, __lzcnt64\n**Microsoft Specific**  \n  \n Counts the number of leading zeros in a 16-, 32-, or 64-byte integer.  \n  \n## Syntax  \n  \n```  \nunsigned short __lzcnt16(  \n   unsigned short value  \n);  \nunsigned int __lzcnt(  \n   unsigned int value  \n);  \nunsigned __int64 __lzcnt64(  \n   unsigned __int64 value  \n);  \n```  \n  \n#### Parameters  \n [in] `value`  \n The 16-, 32-, or 64-bit unsigned integer to scan for leading zeros.  \n  \n## Return Value  \n The number of leading zero bits in the `value` parameter. If `value` is zero, the return value is the size of the input operand (16, 32, or 64). If the most significant bit of `value` is one, the return value is zero.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|  \n|---------------|------------------|  \n|`__lzcnt16`|AMD: Advanced Bit Manipulation (ABM)<br /><br /> Intel: Haswell|  \n|`__lzcnt`|AMD: Advanced Bit Manipulation (ABM)<br /><br /> Intel: Haswell|  \n|`__lzcnt64`|AMD: Advanced Bit Manipulation (ABM) in 64-bit mode.<br /><br /> Intel: Haswell|  \n  \n **Header file** \\<intrin.h>  \n  \n## Remarks  \n Each of these intrinsics generates the `lzcnt` instruction.  The size of the value that the `lzcnt` instruction returns is the same as the size of its argument.  In 32-bit mode there are no 64-bit general-purpose registers, hence no 64-bit `lzcnt`.  \n  \n To determine hardware support for the `lzcnt` instruction call the `__cpuid` intrinsic with `InfoType=0x80000001` and check bit 5 of `CPUInfo[2] (ECX)`. This bit will be 1 if the instruction is supported, and 0 otherwise. If you run code that uses this intrinsic on hardware that does not support the `lzcnt` instruction, the results are unpredictable.  \n  \n On Intel processors that do not support the `lzcnt` instruction, the instruction byte encoding is executed as `bsr` (bit scan reverse). If code portability is a concern, consider use of the `_BitScanReverse` intrinsic instead. For more information, see [_BitScanReverse, _BitScanReverse64](../intrinsics/bitscanreverse-bitscanreverse64.md).  \n  \n## Example  \n  \n```  \n// Compile this test with: /EHsc  \n#include <iostream>   \n#include <intrin.h>   \nusing namespace std;   \n  \nint main()   \n{  \n  unsigned short us[3] = {0, 0xFF, 0xFFFF};  \n  unsigned short usr;  \n  unsigned int   ui[4] = {0, 0xFF, 0xFFFF, 0xFFFFFFFF};  \n  unsigned int   uir;  \n  \n  for (int i=0; i<3; i++) {  \n    usr = __lzcnt16(us[i]);  \n    cout << \"__lzcnt16(0x\" << hex << us[i] << \") = \" << dec << usr << endl;  \n  }  \n  \n  for (int i=0; i<4; i++) {  \n    uir = __lzcnt(ui[i]);  \n    cout << \"__lzcnt(0x\" << hex << ui[i] << \") = \" << dec << uir << endl;  \n  }  \n}  \n  \n```  \n  \n```Output  \n__lzcnt16(0x0) = 16  \n__lzcnt16(0xff) = 8  \n__lzcnt16(0xffff) = 0  \n__lzcnt(0x0) = 32  \n__lzcnt(0xff) = 24  \n__lzcnt(0xffff) = 16  \n__lzcnt(0xffffffff) = 0  \n```  \n  \n## END Microsoft Specific  \n Portions of this content are Copyright 2007 by Advanced Micro Devices, Inc. All rights reserved. Reproduced with permission from Advanced Micro Devices, Inc.  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)"}