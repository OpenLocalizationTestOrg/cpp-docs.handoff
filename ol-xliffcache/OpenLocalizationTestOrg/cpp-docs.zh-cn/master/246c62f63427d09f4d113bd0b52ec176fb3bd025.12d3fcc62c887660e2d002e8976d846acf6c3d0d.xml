{"nodes":[{"pos":[12,51],"content":"Abstract Classes (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Abstract Classes (C++) | Microsoft Docs","pos":[0,39]}]},{"content":"Abstract Classes (C++)","pos":[694,716]},{"content":"Abstract classes act as expressions of general concepts from which more specific classes can be derived.","pos":[717,821]},{"content":"You cannot create an object of an abstract class type; however, you can use pointers and references to abstract class types.","pos":[822,946]},{"content":"A class that contains at least one pure virtual function is considered an abstract class.","pos":[953,1042]},{"content":"Classes derived from the abstract class must implement the pure virtual function or they, too, are abstract classes.","pos":[1043,1159]},{"content":"A virtual function is declared as \"pure\" by using the <bpt id=\"p1\">*</bpt>pure-specifier<ept id=\"p1\">*</ept> syntax (described in <bpt id=\"p2\">[</bpt>Class Protocol Implementation<ept id=\"p2\">](http://msdn.microsoft.com/en-us/a319f1b3-05e8-400e-950a-1ca6eb105ab5)</ept>).","pos":[1166,1361],"source":"A virtual function is declared as \"pure\" by using the *pure-specifier* syntax (described in [Class Protocol Implementation](http://msdn.microsoft.com/en-us/a319f1b3-05e8-400e-950a-1ca6eb105ab5))."},{"content":"Consider the example presented in <bpt id=\"p1\">[</bpt>Virtual Functions<ept id=\"p1\">](../cpp/virtual-functions.md)</ept>.","pos":[1362,1445],"source":" Consider the example presented in [Virtual Functions](../cpp/virtual-functions.md)."},{"content":"The intent of class <ph id=\"ph1\">`Account`</ph> is to provide general functionality, but objects of type <ph id=\"ph2\">`Account`</ph> are too general to be useful.","pos":[1446,1572],"source":" The intent of class `Account` is to provide general functionality, but objects of type `Account` are too general to be useful."},{"content":"Therefore, <ph id=\"ph1\">`Account`</ph> is a good candidate for an abstract class:","pos":[1573,1636],"source":" Therefore, `Account` is a good candidate for an abstract class:"},{"pos":[1947,2080],"content":"The only difference between this declaration and the previous one is that <ph id=\"ph1\">`PrintBalance`</ph> is declared with the pure specifier (<ph id=\"ph2\">`= 0`</ph>).","source":"The only difference between this declaration and the previous one is that `PrintBalance` is declared with the pure specifier (`= 0`)."},{"content":"Restrictions on abstract classes","pos":[2089,2121]},{"content":"Abstract classes cannot be used for:","pos":[2125,2161]},{"content":"Variables or member data","pos":[2171,2195]},{"content":"Argument types","pos":[2205,2219]},{"content":"Function return types","pos":[2229,2250]},{"content":"Types of explicit conversions","pos":[2260,2289]},{"content":"Another restriction is that if the constructor for an abstract class calls a pure virtual function, either directly or indirectly, the result is undefined.","pos":[2296,2451]},{"content":"However, constructors and destructors for abstract classes can call other member functions.","pos":[2452,2543]},{"content":"Pure virtual functions can be defined for abstract classes, but they can be called directly only by using the syntax:","pos":[2550,2667]},{"pos":[2674,2723],"content":"<bpt id=\"p1\">*</bpt>abstract-class-name<ept id=\"p1\">*</ept> <ph id=\"ph1\">`::`</ph> <bpt id=\"p2\">*</bpt>function-name<ept id=\"p2\">*</ept><bpt id=\"p3\">**</bpt>( )<ept id=\"p3\">**</ept>","source":"*abstract-class-name* `::` *function-name***( )**"},{"content":"This helps when designing class hierarchies whose base class(es) include pure virtual destructors, because base class destructors are always called in the process of destroying an object.","pos":[2730,2917]},{"content":"Consider the following example:","pos":[2918,2949]},{"content":"When the object pointed to by <ph id=\"ph1\">`pDerived`</ph> is deleted, the destructor for class <ph id=\"ph2\">`derived`</ph> is called and then the destructor for class <ph id=\"ph3\">`base`</ph> is called.","pos":[3394,3543],"source":"When the object pointed to by `pDerived` is deleted, the destructor for class `derived` is called and then the destructor for class `base` is called."},{"content":"The empty implementation for the pure virtual function ensures that at least some implementation exists for the function.","pos":[3544,3665]},{"pos":[3673,3904],"content":"[!NOTE]\n In the preceding example, the pure virtual function `base::~base` is called implicitly from `derived::~derived`. It is also possible to call pure virtual functions explicitly using a fully qualified member-function name.","leadings":["","> "],"nodes":[{"content":" In the preceding example, the pure virtual function `base::~base` is called implicitly from `derived::~derived`. It is also possible to call pure virtual functions explicitly using a fully qualified member-function name.","pos":[8,229],"nodes":[{"content":"In the preceding example, the pure virtual function <ph id=\"ph1\">`base::~base`</ph> is called implicitly from <ph id=\"ph2\">`derived::~derived`</ph>.","pos":[1,113],"source":" In the preceding example, the pure virtual function `base::~base` is called implicitly from `derived::~derived`."},{"content":"It is also possible to call pure virtual functions explicitly using a fully qualified member-function name.","pos":[114,221]}]}]},{"content":"See Also","pos":[3913,3921]},{"content":"Inheritance","pos":[3926,3937]}],"content":"---\ntitle: \"Abstract Classes (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"classes [C++], abstract\"\n  - \"base classes, abstract classes\"\n  - \"abstract classes\"\n  - \"derived classes, abstract classes\"\nms.assetid: f0c5975b-39de-4d68-9640-6ce57f4632e6\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Abstract Classes (C++)\nAbstract classes act as expressions of general concepts from which more specific classes can be derived. You cannot create an object of an abstract class type; however, you can use pointers and references to abstract class types.  \n  \n A class that contains at least one pure virtual function is considered an abstract class. Classes derived from the abstract class must implement the pure virtual function or they, too, are abstract classes.  \n  \n A virtual function is declared as \"pure\" by using the *pure-specifier* syntax (described in [Class Protocol Implementation](http://msdn.microsoft.com/en-us/a319f1b3-05e8-400e-950a-1ca6eb105ab5)). Consider the example presented in [Virtual Functions](../cpp/virtual-functions.md). The intent of class `Account` is to provide general functionality, but objects of type `Account` are too general to be useful. Therefore, `Account` is a good candidate for an abstract class:  \n  \n```  \n// deriv_AbstractClasses.cpp  \n// compile with: /LD  \nclass Account {  \npublic:  \n   Account( double d );   // Constructor.  \n   virtual double GetBalance();   // Obtain balance.  \n   virtual void PrintBalance() = 0;   // Pure virtual function.  \nprivate:  \n    double _balance;  \n};  \n  \n```  \n  \n The only difference between this declaration and the previous one is that `PrintBalance` is declared with the pure specifier (`= 0`).  \n  \n## Restrictions on abstract classes  \n Abstract classes cannot be used for:  \n  \n-   Variables or member data  \n  \n-   Argument types  \n  \n-   Function return types  \n  \n-   Types of explicit conversions  \n  \n Another restriction is that if the constructor for an abstract class calls a pure virtual function, either directly or indirectly, the result is undefined. However, constructors and destructors for abstract classes can call other member functions.  \n  \n Pure virtual functions can be defined for abstract classes, but they can be called directly only by using the syntax:  \n  \n *abstract-class-name* `::` *function-name***( )**  \n  \n This helps when designing class hierarchies whose base class(es) include pure virtual destructors, because base class destructors are always called in the process of destroying an object. Consider the following example:  \n  \n```  \n// Declare an abstract base class with a pure virtual destructor.  \n// deriv_RestrictionsonUsingAbstractClasses.cpp  \nclass base {  \npublic:  \n    base() {}  \n    virtual ~base()=0;  \n};  \n  \n// Provide a definition for destructor.  \nbase::~base() {}  \n  \nclass derived:public base {  \npublic:  \n    derived() {}  \n    ~derived(){}  \n};  \n  \nint main() {  \n    derived *pDerived = new derived;  \n    delete pDerived;  \n}  \n```  \n  \n When the object pointed to by `pDerived` is deleted, the destructor for class `derived` is called and then the destructor for class `base` is called. The empty implementation for the pure virtual function ensures that at least some implementation exists for the function.  \n  \n> [!NOTE]\n>  In the preceding example, the pure virtual function `base::~base` is called implicitly from `derived::~derived`. It is also possible to call pure virtual functions explicitly using a fully qualified member-function name.  \n  \n## See Also  \n [Inheritance](../cpp/inheritance-cpp.md)"}