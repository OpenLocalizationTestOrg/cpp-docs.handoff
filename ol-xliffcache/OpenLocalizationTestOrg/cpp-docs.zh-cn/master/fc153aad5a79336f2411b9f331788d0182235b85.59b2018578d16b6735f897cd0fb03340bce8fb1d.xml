{"nodes":[{"pos":[12,45],"content":"_mm_cvttss_si64x | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_mm_cvttss_si64x | Microsoft Docs","pos":[0,33]}]},{"content":"_mm_cvttss_si64x","pos":[672,688]},{"content":"Microsoft Specific","pos":[691,709]},{"pos":[718,863],"content":"Emits the x64 extended version of the Convert with Truncation Single-Precision Floating-Point Number to 64-Bit Integer (<ph id=\"ph1\">`cvttss2si`</ph>) instruction.","source":"Emits the x64 extended version of the Convert with Truncation Single-Precision Floating-Point Number to 64-Bit Integer (`cvttss2si`) instruction."},{"content":"Syntax","pos":[872,878]},{"content":"Parameters","pos":[957,967]},{"content":"[in]","pos":[971,975]},{"content":"An <ph id=\"ph1\">`__m128`</ph> structure containing single-precision floating-point values.","pos":[987,1059],"source":" An `__m128` structure containing single-precision floating-point values."},{"content":"Return Value","pos":[1068,1080]},{"content":"The result of the conversion of the first floating-point value to a 64-bit integer.","pos":[1084,1167]},{"content":"Requirements","pos":[1176,1188]},{"content":"Intrinsic","pos":[1195,1204]},{"content":"Architecture","pos":[1205,1217]},{"pos":[1351,1378],"content":"<bpt id=\"p1\">**</bpt>Header file<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>intrin.h&gt;","source":"**Header file** \\<intrin.h>"},{"content":"Remarks","pos":[1387,1394]},{"content":"The intrinsic differs from <ph id=\"ph1\">`_mm_cvtss_si64x`</ph> only in that inexact conversions are truncated toward zero.","pos":[1398,1502],"source":"The intrinsic differs from `_mm_cvtss_si64x` only in that inexact conversions are truncated toward zero."},{"content":"Because the <ph id=\"ph1\">`__m128`</ph> structure represents an XMM register, the instruction generated moves data from an XMM register into system memory.","pos":[1503,1639],"source":" Because the `__m128` structure represents an XMM register, the instruction generated moves data from an XMM register into system memory."},{"content":"This routine is only available as an intrinsic.","pos":[1646,1693]},{"content":"Example","pos":[1702,1709]},{"content":"END Microsoft Specific","pos":[2391,2413]},{"content":"See Also","pos":[2422,2430]},{"content":"__m128","pos":[2435,2441]},{"content":"Compiler Intrinsics","pos":[2464,2483]}],"content":"---\ntitle: \"_mm_cvttss_si64x | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_mm_cvttss_si64x\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"_mm_cvttss_si64x intrinsic\"\n  - \"cvttss2si instruction\"\nms.assetid: f9a3fd07-5bd8-4758-8744-6315c082cf87\ncaps.latest.revision: 14\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# _mm_cvttss_si64x\n**Microsoft Specific**  \n  \n Emits the x64 extended version of the Convert with Truncation Single-Precision Floating-Point Number to 64-Bit Integer (`cvttss2si`) instruction.  \n  \n## Syntax  \n  \n```  \n__int64 _mm_cvttss_si64x(   \n   __m128 value   \n);  \n```  \n  \n#### Parameters  \n [in] `value`  \n An `__m128` structure containing single-precision floating-point values.  \n  \n## Return Value  \n The result of the conversion of the first floating-point value to a 64-bit integer.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|  \n|---------------|------------------|  \n|`_mm_cvttss_si64x`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|  \n  \n **Header file** \\<intrin.h>  \n  \n## Remarks  \n The intrinsic differs from `_mm_cvtss_si64x` only in that inexact conversions are truncated toward zero. Because the `__m128` structure represents an XMM register, the instruction generated moves data from an XMM register into system memory.  \n  \n This routine is only available as an intrinsic.  \n  \n## Example  \n  \n```  \n// _mm_cvttss_si64x.cpp  \n// processor: x64  \n#include <intrin.h>  \n#include <stdio.h>  \n  \n#pragma intrinsic(_mm_cvttss_si64x)  \n  \nint main()  \n{  \n    __m128 a;  \n    __int64 b = 54;  \n  \n    // _mm_load_ps requires an aligned buffer.  \n    __declspec(align(16)) float af[4] = { 101.5, 200.75,  \n                                          300.5, 400.5 };  \n  \n    // Load a with the floating point values.  \n    // The values will be copied to the XMM registers.  \n    a = _mm_load_ps(af);  \n  \n    // Extract the first element of a and convert to an integer  \n    b = _mm_cvttss_si64x(a);  \n  \n    printf_s(\"%I64d\\n\", b);  \n}  \n```  \n  \n```Output  \n101  \n```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [__m128](../cpp/m128.md)   \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)"}