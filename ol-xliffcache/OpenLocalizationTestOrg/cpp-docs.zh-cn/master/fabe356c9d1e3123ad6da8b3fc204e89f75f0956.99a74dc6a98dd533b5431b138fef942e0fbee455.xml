{"nodes":[{"pos":[12,38],"content":"CDC Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CDC Class | Microsoft Docs","pos":[0,26]}]},{"content":"CDC Class","pos":[830,839]},{"content":"Defines a class of device-context objects.","pos":[840,882]},{"content":"Syntax","pos":[891,897]},{"content":"Members","pos":[950,957]},{"content":"Public Constructors","pos":[967,986]},{"content":"Name","pos":[993,997]},{"content":"Description","pos":[998,1009]},{"content":"CDC::CDC","pos":[1048,1056]},{"pos":[1069,1095],"content":"Constructs a <ph id=\"ph1\">`CDC`</ph> object.","source":"Constructs a `CDC` object."},{"content":"Public Methods","pos":[1106,1120]},{"content":"Name","pos":[1127,1131]},{"content":"Description","pos":[1132,1143]},{"content":"CDC::AbortDoc","pos":[1182,1195]},{"pos":[1213,1362],"content":"Terminates the current print job, erasing everything the application has written to the device since the last call of the <ph id=\"ph1\">`StartDoc`</ph> member function.","source":"Terminates the current print job, erasing everything the application has written to the device since the last call of the `StartDoc` member function."},{"content":"CDC::AbortPath","pos":[1368,1382]},{"content":"Closes and discards any paths in the device context.","pos":[1401,1453]},{"content":"CDC::AddMetaFileComment","pos":[1459,1482]},{"content":"Copies the comment from a buffer into a specified enhanced-format metafile.","pos":[1510,1585]},{"content":"CDC::AlphaBlend","pos":[1591,1606]},{"content":"Displays bitmaps that have transparent or semitransparent pixels.","pos":[1626,1691]},{"content":"CDC::AngleArc","pos":[1697,1710]},{"content":"Draws a line segment and an arc, and moves the current position to the ending point of the arc.","pos":[1728,1823]},{"content":"CDC::Arc","pos":[1829,1837]},{"content":"Draws an elliptical arc.","pos":[1850,1874]},{"content":"CDC::ArcTo","pos":[1880,1890]},{"content":"Draws an elliptical arc.","pos":[1905,1929]},{"content":"This function is similar to <ph id=\"ph1\">`Arc`</ph>, except that the current position is updated.","pos":[1930,2009],"source":" This function is similar to `Arc`, except that the current position is updated."},{"content":"CDC::Attach","pos":[2015,2026]},{"pos":[2042,2097],"content":"Attaches a Windows device context to this <ph id=\"ph1\">`CDC`</ph> object.","source":"Attaches a Windows device context to this `CDC` object."},{"content":"CDC::BeginPath","pos":[2103,2117]},{"content":"Opens a path bracket in the device context.","pos":[2136,2179]},{"content":"CDC::BitBlt","pos":[2185,2196]},{"content":"Copies a bitmap from a specified device context.","pos":[2212,2260]},{"content":"CDC::Chord","pos":[2266,2276]},{"content":"Draws a chord (a closed figure bounded by the intersection of an ellipse and a line segment).","pos":[2291,2384]},{"content":"CDC::CloseFigure","pos":[2390,2406]},{"content":"Closes an open figure in a path.","pos":[2427,2459]},{"content":"CDC::CreateCompatibleDC","pos":[2465,2488]},{"content":"Creates a memory-device context that is compatible with another device context.","pos":[2516,2595]},{"content":"You can use it to prepare images in memory.","pos":[2596,2639]},{"content":"CDC::CreateDC","pos":[2645,2658]},{"content":"Creates a device context for a specific device.","pos":[2676,2723]},{"content":"CDC::CreateIC","pos":[2729,2742]},{"content":"Creates an information context for a specific device.","pos":[2760,2813]},{"content":"This provides a fast way to get information about the device without creating a device context.","pos":[2814,2909]},{"content":"CDC::DeleteDC","pos":[2915,2928]},{"pos":[2946,3015],"content":"Deletes the Windows device context associated with this <ph id=\"ph1\">`CDC`</ph> object.","source":"Deletes the Windows device context associated with this `CDC` object."},{"content":"CDC::DeleteTempMap","pos":[3021,3039]},{"content":"Called by the <ph id=\"ph1\">`CWinApp`</ph> idle-time handler to delete any temporary <ph id=\"ph2\">`CDC`</ph> object created by <ph id=\"ph3\">`FromHandle`</ph>.","pos":[3062,3165],"source":"Called by the `CWinApp` idle-time handler to delete any temporary `CDC` object created by `FromHandle`."},{"content":"Also detaches the device context.","pos":[3166,3199]},{"content":"CDC::Detach","pos":[3205,3216]},{"pos":[3232,3291],"content":"Detaches the Windows device context from this <ph id=\"ph1\">`CDC`</ph> object.","source":"Detaches the Windows device context from this `CDC` object."},{"content":"CDC::DPtoHIMETRIC","pos":[3297,3314]},{"pos":[3336,3382],"content":"Converts device units into <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> units.","source":"Converts device units into **HIMETRIC** units."},{"content":"CDC::DPtoLP","pos":[3388,3399]},{"content":"Converts device units into logical units.","pos":[3415,3456]},{"content":"CDC::Draw3dRect","pos":[3462,3477]},{"content":"Draws a three-dimensional rectangle.","pos":[3497,3533]},{"content":"CDC::DrawDragRect","pos":[3539,3556]},{"content":"Erases and redraws a rectangle as it is dragged.","pos":[3578,3626]},{"content":"CDC::DrawEdge","pos":[3632,3645]},{"content":"Draws the edges of a rectangle.","pos":[3663,3694]},{"content":"CDC::DrawEscape","pos":[3700,3715]},{"content":"Accesses drawing capabilities of a video display that are not directly available through the graphics device interface (GDI).","pos":[3735,3860]},{"content":"CDC::DrawFocusRect","pos":[3866,3884]},{"content":"Draws a rectangle in the style used to indicate focus.","pos":[3907,3961]},{"content":"CDC::DrawFrameControl","pos":[3967,3988]},{"content":"Draw a frame control.","pos":[4014,4035]},{"content":"CDC::DrawIcon","pos":[4041,4054]},{"content":"Draws an icon.","pos":[4072,4086]},{"content":"CDC::DrawState","pos":[4092,4106]},{"content":"Displays an image and applies a visual effect to indicate a state.","pos":[4125,4191]},{"content":"CDC::DrawText","pos":[4197,4210]},{"content":"Draws formatted text in the specified rectangle.","pos":[4228,4276]},{"content":"CDC::DrawTextEx","pos":[4282,4297]},{"content":"Draws formatted text in the specified rectangle using additional formats.","pos":[4317,4390]},{"content":"CDC::Ellipse","pos":[4396,4408]},{"content":"Draws an ellipse.","pos":[4425,4442]},{"content":"CDC::EndDoc","pos":[4448,4459]},{"pos":[4475,4534],"content":"Ends a print job started by the <ph id=\"ph1\">`StartDoc`</ph> member function.","source":"Ends a print job started by the `StartDoc` member function."},{"content":"CDC::EndPage","pos":[4540,4552]},{"content":"Informs the device driver that a page is ending.","pos":[4569,4617]},{"content":"CDC::EndPath","pos":[4623,4635]},{"content":"Closes a path bracket and selects the path defined by the bracket into the device context.","pos":[4652,4742]},{"content":"CDC::EnumObjects","pos":[4748,4764]},{"content":"Enumerates the pens and brushes available in a device context.","pos":[4785,4847]},{"content":"CDC::Escape","pos":[4853,4864]},{"content":"Allows applications to access facilities that are not directly available from a particular device through GDI.","pos":[4880,4990]},{"content":"Also allows access to Windows escape functions.","pos":[4991,5038]},{"content":"Escape calls made by an application are translated and sent to the device driver.","pos":[5039,5120]},{"content":"CDC::ExcludeClipRect","pos":[5126,5146]},{"content":"Creates a new clipping region that consists of the existing clipping region minus the specified rectangle.","pos":[5171,5277]},{"content":"CDC::ExcludeUpdateRgn","pos":[5283,5304]},{"content":"Prevents drawing within invalid areas of a window by excluding an updated region in the window from a clipping region.","pos":[5330,5448]},{"content":"CDC::ExtFloodFill","pos":[5454,5471]},{"content":"Fills an area with the current brush.","pos":[5493,5530]},{"content":"Provides more flexibility than the <bpt id=\"p1\">[</bpt>CDC::FloodFill<ept id=\"p1\">](#cdc__floodfill)</ept> member function.","pos":[5531,5616],"source":" Provides more flexibility than the [CDC::FloodFill](#cdc__floodfill) member function."},{"content":"CDC::ExtTextOut","pos":[5622,5637]},{"content":"Writes a character string within a rectangular region using the currently selected font.","pos":[5657,5745]},{"content":"CDC::FillPath","pos":[5751,5764]},{"content":"Closes any open figures in the current path and fills the path's interior by using the current brush and polygon-filling mode.","pos":[5782,5908]},{"content":"CDC::FillRect","pos":[5914,5927]},{"content":"Fills a given rectangle by using a specific brush.","pos":[5945,5995]},{"content":"CDC::FillRgn","pos":[6001,6013]},{"content":"Fills a specific region with the specified brush.","pos":[6030,6079]},{"content":"CDC::FillSolidRect","pos":[6085,6103]},{"content":"Fills a rectangle with a solid color.","pos":[6126,6163]},{"content":"CDC::FlattenPath","pos":[6169,6185]},{"content":"Transforms any curves in the path selected into the current device context, and turns each curve into a sequence of lines.","pos":[6206,6328]},{"content":"CDC::FloodFill","pos":[6334,6348]},{"content":"Fills an area with the current brush.","pos":[6367,6404]},{"content":"CDC::FrameRect","pos":[6410,6424]},{"content":"Draws a border around a rectangle.","pos":[6443,6477]},{"content":"CDC::FrameRgn","pos":[6483,6496]},{"content":"Draws a border around a specific region using a brush.","pos":[6514,6568]},{"content":"CDC::FromHandle","pos":[6574,6589]},{"content":"Returns a pointer to a <ph id=\"ph1\">`CDC`</ph> object when given a handle to a device context.","pos":[6609,6685],"source":"Returns a pointer to a `CDC` object when given a handle to a device context."},{"content":"If a <ph id=\"ph1\">`CDC`</ph> object is not attached to the handle, a temporary <ph id=\"ph2\">`CDC`</ph> object is created and attached.","pos":[6686,6784],"source":" If a `CDC` object is not attached to the handle, a temporary `CDC` object is created and attached."},{"content":"CDC::GetArcDirection","pos":[6790,6810]},{"content":"Returns the current arc direction for the device context.","pos":[6835,6892]},{"content":"CDC::GetAspectRatioFilter","pos":[6898,6923]},{"content":"Retrieves the setting for the current aspect-ratio filter.","pos":[6953,7011]},{"content":"CDC::GetBkColor","pos":[7017,7032]},{"content":"Retrieves the current background color.","pos":[7052,7091]},{"content":"CDC::GetBkMode","pos":[7097,7111]},{"content":"Retrieves the background mode.","pos":[7130,7160]},{"content":"CDC::GetBoundsRect","pos":[7166,7184]},{"content":"Returns the current accumulated bounding rectangle for the specified device context.","pos":[7207,7291]},{"content":"CDC::GetBrushOrg","pos":[7297,7313]},{"content":"Retrieves the origin of the current brush.","pos":[7334,7376]},{"content":"CDC::GetCharABCWidths","pos":[7382,7403]},{"content":"Retrieves the widths, in logical units, of consecutive characters in a given range from the current font.","pos":[7429,7534]},{"content":"CDC::GetCharABCWidthsI","pos":[7540,7562]},{"content":"Retrieves the widths, in logical units, of consecutive glyph indices in a specified range from the current TrueType font.","pos":[7589,7710]},{"content":"CDC::GetCharacterPlacement","pos":[7716,7742]},{"content":"Retrieves various types of information on a character string.","pos":[7773,7834]},{"content":"CDC::GetCharWidth","pos":[7840,7857]},{"content":"Retrieves the fractional widths of consecutive characters in a given range from the current font.","pos":[7879,7976]},{"content":"CDC::GetCharWidthI","pos":[7982,8000]},{"content":"Retrieves the widths, in logical coordinates, of consecutive glyph indices in a specified range from the current font.","pos":[8023,8141]},{"content":"CDC::GetClipBox","pos":[8147,8162]},{"content":"Retrieves the dimensions of the tightest bounding rectangle around the current clipping boundary.","pos":[8182,8279]},{"content":"CDC::GetColorAdjustment","pos":[8285,8308]},{"content":"Retrieves the color adjustment values for the device context.","pos":[8336,8397]},{"content":"CDC::GetCurrentBitmap","pos":[8403,8424]},{"pos":[8450,8511],"content":"Returns a pointer to the currently selected <ph id=\"ph1\">`CBitmap`</ph> object.","source":"Returns a pointer to the currently selected `CBitmap` object."},{"content":"CDC::GetCurrentBrush","pos":[8517,8537]},{"pos":[8562,8622],"content":"Returns a pointer to the currently selected <ph id=\"ph1\">`CBrush`</ph> object.","source":"Returns a pointer to the currently selected `CBrush` object."},{"content":"CDC::GetCurrentFont","pos":[8628,8647]},{"pos":[8671,8730],"content":"Returns a pointer to the currently selected <ph id=\"ph1\">`CFont`</ph> object.","source":"Returns a pointer to the currently selected `CFont` object."},{"content":"CDC::GetCurrentPalette","pos":[8736,8758]},{"pos":[8785,8847],"content":"Returns a pointer to the currently selected <ph id=\"ph1\">`CPalette`</ph> object.","source":"Returns a pointer to the currently selected `CPalette` object."},{"content":"CDC::GetCurrentPen","pos":[8853,8871]},{"pos":[8894,8952],"content":"Returns a pointer to the currently selected <ph id=\"ph1\">`CPen`</ph> object.","source":"Returns a pointer to the currently selected `CPen` object."},{"content":"CDC::GetCurrentPosition","pos":[8958,8981]},{"content":"Retrieves the current position of the pen (in logical coordinates).","pos":[9009,9076]},{"content":"CDC::GetDCBrushColor","pos":[9082,9102]},{"content":"Retrieves the current brush color.","pos":[9127,9161]},{"content":"CDC::GetDCPenColor","pos":[9167,9185]},{"content":"Retrieves the current pen color.","pos":[9208,9240]},{"content":"CDC::GetDeviceCaps","pos":[9246,9264]},{"content":"Retrieves a specified kind of device-specific information about a given display device's capabilities.","pos":[9287,9389]},{"content":"CDC::GetFontData","pos":[9395,9411]},{"content":"Retrieves font metric information from a scalable font file.","pos":[9432,9492]},{"content":"The information to retrieve is identified by specifying an offset into the font file and the length of the information to return.","pos":[9493,9622]},{"content":"CDC::GetFontLanguageInfo","pos":[9628,9652]},{"content":"Returns information about the currently selected font for the specified display context.","pos":[9681,9769]},{"content":"CDC::GetGlyphOutline","pos":[9775,9795]},{"content":"Retrieves the outline curve or bitmap for an outline character in the current font.","pos":[9820,9903]},{"content":"CDC::GetGraphicsMode","pos":[9909,9929]},{"content":"Retrieves the current graphics mode for the specified device context.","pos":[9954,10023]},{"content":"CDC::GetHalftoneBrush","pos":[10029,10050]},{"content":"Retrieves a halftone brush.","pos":[10076,10103]},{"content":"CDC::GetKerningPairs","pos":[10109,10129]},{"content":"Retrieves the character kerning pairs for the font that is currently selected in the specified device context.","pos":[10154,10264]},{"content":"CDC::GetLayout","pos":[10270,10284]},{"content":"Retrieves the layout of a device context (DC).","pos":[10303,10349]},{"content":"The layout can be either left to right (default) or right to left (mirrored).","pos":[10350,10427]},{"content":"CDC::GetMapMode","pos":[10433,10448]},{"content":"Retrieves the current mapping mode.","pos":[10468,10503]},{"content":"CDC::GetMiterLimit","pos":[10509,10527]},{"content":"Returns the miter limit for the device context.","pos":[10550,10597]},{"content":"CDC::GetNearestColor","pos":[10603,10623]},{"content":"Retrieves the closest logical color to a specified logical color that the given device can represent.","pos":[10648,10749]},{"content":"CDC::GetOutlineTextMetrics","pos":[10755,10781]},{"content":"Retrieves font metric information for TrueType fonts.","pos":[10812,10865]},{"content":"CDC::GetOutputCharWidth","pos":[10871,10894]},{"content":"Retrieves the widths of individual characters in a consecutive group of characters from the current font using the output device context.","pos":[10922,11059]},{"content":"CDC::GetOutputTabbedTextExtent","pos":[11065,11095]},{"content":"Computes the width and height of a character string on the output device context.","pos":[11130,11211]},{"content":"CDC::GetOutputTextExtent","pos":[11217,11241]},{"content":"Computes the width and height of a line of text on the output device context using the current font to determine the dimensions.","pos":[11270,11398]},{"content":"CDC::GetOutputTextMetrics","pos":[11404,11429]},{"content":"Retrieves the metrics for the current font from the output device context.","pos":[11459,11533]},{"content":"CDC::GetPath","pos":[11539,11551]},{"content":"Retrieves the coordinates defining the endpoints of lines and the control points of curves found in the path that is selected into the device context.","pos":[11568,11718]},{"content":"CDC::GetPixel","pos":[11724,11737]},{"content":"Retrieves the RGB color value of the pixel at the specified point.","pos":[11755,11821]},{"content":"CDC::GetPolyFillMode","pos":[11827,11847]},{"content":"Retrieves the current polygon-filling mode.","pos":[11872,11915]},{"content":"CDC::GetROP2","pos":[11921,11933]},{"content":"Retrieves the current drawing mode.","pos":[11950,11985]},{"content":"CDC::GetSafeHdc","pos":[11991,12006]},{"pos":[12026,12087],"content":"Returns <bpt id=\"p1\">[</bpt>CDC::m_hDC<ept id=\"p1\">](#cdc__m_hdc)</ept>, the output device context.","source":"Returns [CDC::m_hDC](#cdc__m_hdc), the output device context."},{"content":"CDC::GetStretchBltMode","pos":[12093,12115]},{"content":"Retrieves the current bitmap-stretching mode.","pos":[12142,12187]},{"content":"CDC::GetTabbedTextExtent","pos":[12193,12217]},{"content":"Computes the width and height of a character string on the attribute device context.","pos":[12246,12330]},{"content":"CDC::GetTextAlign","pos":[12336,12353]},{"content":"Retrieves the text-alignment flags.","pos":[12375,12410]},{"content":"CDC::GetTextCharacterExtra","pos":[12416,12442]},{"content":"Retrieves the current setting for the amount of intercharacter spacing.","pos":[12473,12544]},{"content":"CDC::GetTextColor","pos":[12550,12567]},{"content":"Retrieves the current text color.","pos":[12589,12622]},{"content":"CDC::GetTextExtent","pos":[12628,12646]},{"content":"Computes the width and height of a line of text on the attribute device context using the current font to determine the dimensions.","pos":[12669,12800]},{"content":"CDC::GetTextExtentExPointI","pos":[12806,12832]},{"content":"Retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters.","pos":[12863,13028]},{"content":"CDC::GetTextExtentPointI","pos":[13034,13058]},{"content":"Retrieves the width and height of the specified array of glyph indices.","pos":[13087,13158]},{"content":"CDC::GetTextFace","pos":[13164,13180]},{"content":"Copies the typeface name of the current font into a buffer as a null-terminated string.","pos":[13201,13288]},{"content":"CDC::GetTextMetrics","pos":[13294,13313]},{"content":"Retrieves the metrics for the current font from the attribute device context.","pos":[13337,13414]},{"content":"CDC::GetViewportExt","pos":[13420,13439]},{"content":"Retrieves the x- and y-extents of the viewport.","pos":[13463,13510]},{"content":"CDC::GetViewportOrg","pos":[13516,13535]},{"content":"Retrieves the x- and y-coordinates of the viewport origin.","pos":[13559,13617]},{"content":"CDC::GetWindow","pos":[13623,13637]},{"content":"Returns the window associated with the display device context.","pos":[13656,13718]},{"content":"CDC::GetWindowExt","pos":[13724,13741]},{"content":"Retrieves the x- and y-extents of the associated window.","pos":[13763,13819]},{"content":"CDC::GetWindowOrg","pos":[13825,13842]},{"content":"Retrieves the x- and y-coordinates of the origin of the associated window.","pos":[13864,13938]},{"content":"CDC::GetWorldTransform","pos":[13944,13966]},{"content":"Retrieves the current world-space to page-space transformation.","pos":[13993,14056]},{"content":"CDC::GradientFill","pos":[14062,14079]},{"content":"Fills rectangle and triangle structures with a gradating color.","pos":[14101,14164]},{"content":"CDC::GrayString","pos":[14170,14185]},{"content":"Draws dimmed (grayed) text at the given location.","pos":[14205,14254]},{"content":"CDC::HIMETRICtoDP","pos":[14260,14277]},{"pos":[14299,14345],"content":"Converts <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> units into device units.","source":"Converts **HIMETRIC** units into device units."},{"content":"CDC::HIMETRICtoLP","pos":[14351,14368]},{"pos":[14390,14437],"content":"Converts <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> units into logical units.","source":"Converts **HIMETRIC** units into logical units."},{"content":"CDC::IntersectClipRect","pos":[14443,14465]},{"content":"Creates a new clipping region by forming the intersection of the current region and a rectangle.","pos":[14492,14588]},{"content":"CDC::InvertRect","pos":[14594,14609]},{"content":"Inverts the contents of a rectangle.","pos":[14629,14665]},{"content":"CDC::InvertRgn","pos":[14671,14685]},{"content":"Inverts the colors in a region.","pos":[14704,14735]},{"content":"CDC::IsPrinting","pos":[14741,14756]},{"content":"Determines whether the device context is being used for printing.","pos":[14776,14841]},{"content":"CDC::LineTo","pos":[14847,14858]},{"content":"Draws a line from the current position up to, but not including, a point.","pos":[14874,14947]},{"content":"CDC::LPtoDP","pos":[14953,14964]},{"content":"Converts logical units into device units.","pos":[14980,15021]},{"content":"CDC::LPtoHIMETRIC","pos":[15027,15044]},{"pos":[15066,15113],"content":"Converts logical units into <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> units.","source":"Converts logical units into **HIMETRIC** units."},{"content":"CDC::MaskBlt","pos":[15119,15131]},{"content":"Combines the color data for the source and destination bitmaps using the given mask and raster operation.","pos":[15148,15253]},{"content":"CDC::ModifyWorldTransform","pos":[15259,15284]},{"content":"Changes the world transformation for a device context using the specified mode.","pos":[15314,15393]},{"content":"CDC::MoveTo","pos":[15399,15410]},{"content":"Moves the current position.","pos":[15426,15453]},{"content":"CDC::OffsetClipRgn","pos":[15459,15477]},{"content":"Moves the clipping region of the given device.","pos":[15500,15546]},{"content":"CDC::OffsetViewportOrg","pos":[15552,15574]},{"content":"Modifies the viewport origin relative to the coordinates of the current viewport origin.","pos":[15601,15689]},{"content":"CDC::OffsetWindowOrg","pos":[15695,15715]},{"content":"Modifies the window origin relative to the coordinates of the current window origin.","pos":[15740,15824]},{"content":"CDC::PaintRgn","pos":[15830,15843]},{"content":"Fills a region with the selected brush.","pos":[15861,15900]},{"content":"CDC::PatBlt","pos":[15906,15917]},{"content":"Creates a bit pattern.","pos":[15933,15955]},{"content":"CDC::Pie","pos":[15961,15969]},{"content":"Draws a pie-shaped wedge.","pos":[15982,16007]},{"content":"CDC::PlayMetaFile","pos":[16013,16030]},{"content":"Plays the contents of the specified metafile on the given device.","pos":[16052,16117]},{"content":"The enhanced version of <ph id=\"ph1\">`PlayMetaFile`</ph> displays the picture stored in the given enhanced-format metafile.","pos":[16118,16223],"source":" The enhanced version of `PlayMetaFile` displays the picture stored in the given enhanced-format metafile."},{"content":"The metafile can be played any number of times.","pos":[16224,16271]},{"content":"CDC::PlgBlt","pos":[16277,16288]},{"content":"Performs a bit-block transfer of the bits of color data from the specified rectangle in the source device context to the specified parallelogram in the given device context.","pos":[16304,16477]},{"content":"CDC::PolyBezier","pos":[16483,16498]},{"content":"Draws one or more Bzier splines.","pos":[16518,16550]},{"content":"The current position is neither used nor updated.","pos":[16551,16600]},{"content":"CDC::PolyBezierTo","pos":[16606,16623]},{"content":"Draws one or more Bzier splines, and moves the current position to the ending point of the last Bzier spline.","pos":[16645,16754]},{"content":"CDC::PolyDraw","pos":[16760,16773]},{"content":"Draws a set of line segments and Bzier splines.","pos":[16791,16838]},{"content":"This function updates the current position.","pos":[16839,16882]},{"content":"CDC::Polygon","pos":[16888,16900]},{"content":"Draws a polygon consisting of two or more points (vertices) connected by lines.","pos":[16917,16996]},{"content":"CDC::Polyline","pos":[17002,17015]},{"content":"Draws a set of line segments connecting the specified points.","pos":[17033,17094]},{"content":"CDC::PolylineTo","pos":[17100,17115]},{"content":"Draws one or more straight lines and moves the current position to the ending point of the last line.","pos":[17135,17236]},{"content":"CDC::PolyPolygon","pos":[17242,17258]},{"content":"Creates two or more polygons that are filled using the current polygon-filling mode.","pos":[17279,17363]},{"content":"The polygons may be disjoint or they may overlap.","pos":[17364,17413]},{"content":"CDC::PolyPolyline","pos":[17419,17436]},{"content":"Draws multiple series of connected line segments.","pos":[17458,17507]},{"content":"The current position is neither used nor updated by this function.","pos":[17508,17574]},{"content":"CDC::PtVisible","pos":[17580,17594]},{"content":"Specifies whether the given point is within the clipping region.","pos":[17613,17677]},{"content":"CDC::RealizePalette","pos":[17683,17702]},{"content":"Maps palette entries in the current logical palette to the system palette.","pos":[17726,17800]},{"content":"CDC::Rectangle","pos":[17806,17820]},{"content":"Draws a rectangle using the current pen and fills it using the current brush.","pos":[17839,17916]},{"content":"CDC::RectVisible","pos":[17922,17938]},{"content":"Determines whether any part of the given rectangle lies within the clipping region.","pos":[17959,18042]},{"content":"CDC::ReleaseAttribDC","pos":[18048,18068]},{"pos":[18093,18146],"content":"Releases <ph id=\"ph1\">`m_hAttribDC`</ph>, the attribute device context.","source":"Releases `m_hAttribDC`, the attribute device context."},{"content":"CDC::ReleaseOutputDC","pos":[18152,18172]},{"pos":[18197,18241],"content":"Releases <ph id=\"ph1\">`m_hDC`</ph>, the output device context.","source":"Releases `m_hDC`, the output device context."},{"content":"CDC::ResetDC","pos":[18247,18259]},{"pos":[18276,18317],"content":"Updates the <ph id=\"ph1\">`m_hAttribDC`</ph> device context.","source":"Updates the `m_hAttribDC` device context."},{"content":"CDC::RestoreDC","pos":[18323,18337]},{"pos":[18356,18424],"content":"Restores the device context to a previous state saved with <ph id=\"ph1\">`SaveDC`</ph>.","source":"Restores the device context to a previous state saved with `SaveDC`."},{"content":"CDC::RoundRect","pos":[18430,18444]},{"content":"Draws a rectangle with rounded corners using the current pen and filled using the current brush.","pos":[18463,18559]},{"content":"CDC::SaveDC","pos":[18565,18576]},{"content":"Saves the current state of the device context.","pos":[18592,18638]},{"content":"CDC::ScaleViewportExt","pos":[18644,18665]},{"content":"Modifies the viewport extent relative to the current values.","pos":[18691,18751]},{"content":"CDC::ScaleWindowExt","pos":[18757,18776]},{"content":"Modifies the window extents relative to the current values.","pos":[18800,18859]},{"content":"CDC::ScrollDC","pos":[18865,18878]},{"content":"Scrolls a rectangle of bits horizontally and vertically.","pos":[18896,18952]},{"content":"CDC::SelectClipPath","pos":[18958,18977]},{"content":"Selects the current path as a clipping region for the device context, combining the new region with any existing clipping region by using the specified mode.","pos":[19001,19158]},{"content":"CDC::SelectClipRgn","pos":[19164,19182]},{"content":"Combines the given region with the current clipping region by using the specified mode.","pos":[19205,19292]},{"content":"CDC::SelectObject","pos":[19298,19315]},{"content":"Selects a GDI drawing object such as a pen.","pos":[19337,19380]},{"content":"CDC::SelectPalette","pos":[19386,19404]},{"content":"Selects the logical palette.","pos":[19427,19455]},{"content":"CDC::SelectStockObject","pos":[19461,19483]},{"content":"Selects one of the predefined stock pens, brushes, or fonts provided by Windows.","pos":[19510,19590]},{"content":"CDC::SetAbortProc","pos":[19596,19613]},{"content":"Sets a programmer-supplied callback function that Windows calls if a print job must be aborted.","pos":[19635,19730]},{"content":"CDC::SetArcDirection","pos":[19736,19756]},{"content":"Sets the drawing direction to be used for arc and rectangle functions.","pos":[19781,19851]},{"content":"CDC::SetAttribDC","pos":[19857,19873]},{"pos":[19894,19943],"content":"Sets <ph id=\"ph1\">`m_hAttribDC`</ph>, the attribute device context.","source":"Sets `m_hAttribDC`, the attribute device context."},{"content":"CDC::SetBkColor","pos":[19949,19964]},{"content":"Sets the current background color.","pos":[19984,20018]},{"content":"CDC::SetBkMode","pos":[20024,20038]},{"content":"Sets the background mode.","pos":[20057,20082]},{"content":"CDC::SetBoundsRect","pos":[20088,20106]},{"content":"Controls the accumulation of bounding-rectangle information for the specified device context.","pos":[20129,20222]},{"content":"CDC::SetBrushOrg","pos":[20228,20244]},{"content":"Specifies the origin for the next brush selected into a device context.","pos":[20265,20336]},{"content":"CDC::SetColorAdjustment","pos":[20342,20365]},{"content":"Sets the color adjustment values for the device context using the specified values.","pos":[20393,20476]},{"content":"CDC::SetDCBrushColor","pos":[20482,20502]},{"content":"Sets the current brush color.","pos":[20527,20556]},{"content":"CDC::SetDCPenColor","pos":[20562,20580]},{"content":"Sets the current pen color.","pos":[20603,20630]},{"content":"CDC::SetGraphicsMode","pos":[20636,20656]},{"content":"Sets the current graphics mode for the specified device context.","pos":[20681,20745]},{"content":"CDC::SetLayout","pos":[20751,20765]},{"content":"Changes the layout of a device context (DC).","pos":[20784,20828]},{"content":"CDC::SetMapMode","pos":[20834,20849]},{"content":"Sets the current mapping mode.","pos":[20869,20899]},{"content":"CDC::SetMapperFlags","pos":[20905,20924]},{"content":"Alters the algorithm that the font mapper uses when it maps logical fonts to physical fonts.","pos":[20948,21040]},{"content":"CDC::SetMiterLimit","pos":[21046,21064]},{"content":"Sets the limit for the length of miter joins for the device context.","pos":[21087,21155]},{"content":"CDC::SetOutputDC","pos":[21161,21177]},{"pos":[21198,21238],"content":"Sets <ph id=\"ph1\">`m_hDC`</ph>, the output device context.","source":"Sets `m_hDC`, the output device context."},{"content":"CDC::SetPixel","pos":[21244,21257]},{"content":"Sets the pixel at the specified point to the closest approximation of the specified color.","pos":[21275,21365]},{"content":"CDC::SetPixelV","pos":[21371,21385]},{"content":"Sets the pixel at the specified coordinates to the closest approximation of the specified color.","pos":[21404,21500]},{"content":"is faster than <ph id=\"ph1\">`SetPixel`</ph> because it does not need to return the color value of the point actually painted.","pos":[21513,21620],"source":" is faster than `SetPixel` because it does not need to return the color value of the point actually painted."},{"content":"CDC::SetPolyFillMode","pos":[21626,21646]},{"content":"Sets the polygon-filling mode.","pos":[21671,21701]},{"content":"CDC::SetROP2","pos":[21707,21719]},{"content":"Sets the current drawing mode.","pos":[21736,21766]},{"content":"CDC::SetStretchBltMode","pos":[21772,21794]},{"content":"Sets the bitmap-stretching mode.","pos":[21821,21853]},{"content":"CDC::SetTextAlign","pos":[21859,21876]},{"content":"Sets the text-alignment flags.","pos":[21898,21928]},{"content":"CDC::SetTextCharacterExtra","pos":[21934,21960]},{"content":"Sets the amount of intercharacter spacing.","pos":[21991,22033]},{"content":"CDC::SetTextColor","pos":[22039,22056]},{"content":"Sets the text color.","pos":[22078,22098]},{"content":"CDC::SetTextJustification","pos":[22104,22129]},{"content":"Adds space to the break characters in a string.","pos":[22159,22206]},{"content":"CDC::SetViewportExt","pos":[22212,22231]},{"content":"Sets the x- and y-extents of the viewport.","pos":[22255,22297]},{"content":"CDC::SetViewportOrg","pos":[22303,22322]},{"content":"Sets the viewport origin.","pos":[22346,22371]},{"content":"CDC::SetWindowExt","pos":[22377,22394]},{"content":"Sets the x- and y-extents of the associated window.","pos":[22416,22467]},{"content":"CDC::SetWindowOrg","pos":[22473,22490]},{"content":"Sets the window origin of the device context.","pos":[22512,22557]},{"content":"CDC::SetWorldTransform","pos":[22563,22585]},{"content":"Sets the current world-space to page-space transformation.","pos":[22612,22670]},{"content":"CDC::StartDoc","pos":[22676,22689]},{"content":"Informs the device driver that a new print job is starting.","pos":[22707,22766]},{"content":"CDC::StartPage","pos":[22772,22786]},{"content":"Informs the device driver that a new page is starting.","pos":[22805,22859]},{"content":"CDC::StretchBlt","pos":[22865,22880]},{"content":"Moves a bitmap from a source rectangle and device into a destination rectangle, stretching or compressing the bitmap if necessary to fit the dimensions of the destination rectangle.","pos":[22900,23081]},{"content":"CDC::StrokeAndFillPath","pos":[23087,23109]},{"content":"Closes any open figures in a path, strikes the outline of the path by using the current pen, and fills its interior by using the current brush.","pos":[23136,23279]},{"content":"CDC::StrokePath","pos":[23285,23300]},{"content":"Renders the specified path by using the current pen.","pos":[23320,23372]},{"content":"CDC::TabbedTextOut","pos":[23378,23396]},{"content":"Writes a character string at a specified location, expanding tabs to the values specified in an array of tab-stop positions.","pos":[23419,23543]},{"content":"CDC::TextOut","pos":[23549,23561]},{"content":"Writes a character string at a specified location using the currently selected font.","pos":[23578,23662]},{"content":"CDC::TransparentBlt","pos":[23668,23687]},{"content":"Transfers a bit-block of color data from the specified source device context into a destination device context, rendering a specified color transparent in the transfer.","pos":[23711,23879]},{"content":"CDC::UpdateColors","pos":[23885,23902]},{"content":"Updates the client area of the device context by matching the current colors in the client area to the system palette on a pixel-by-pixel basis.","pos":[23924,24068]},{"content":"CDC::WidenPath","pos":[24074,24088]},{"content":"Redefines the current path as the area that would be painted if the path were stroked using the pen currently selected into the device context.","pos":[24107,24250]},{"content":"Public Operators","pos":[24261,24277]},{"content":"Name","pos":[24284,24288]},{"content":"Description","pos":[24289,24300]},{"content":"CDC::operator HDC","pos":[24339,24356]},{"content":"Retrieves the handle of the device context.","pos":[24378,24421]},{"content":"Public Data Members","pos":[24432,24451]},{"content":"Name","pos":[24458,24462]},{"content":"Description","pos":[24463,24474]},{"content":"CDC::m_hAttribDC","pos":[24513,24529]},{"pos":[24550,24605],"content":"The attribute-device context used by this <ph id=\"ph1\">`CDC`</ph> object.","source":"The attribute-device context used by this `CDC` object."},{"content":"CDC::m_hDC","pos":[24611,24621]},{"pos":[24636,24688],"content":"The output-device context used by this <ph id=\"ph1\">`CDC`</ph> object.","source":"The output-device context used by this `CDC` object."},{"content":"Remarks","pos":[24698,24705]},{"pos":[24709,24915],"content":"The <ph id=\"ph1\">`CDC`</ph> object provides member functions for working with a device context, such as a display or printer, as well as members for working with a display context associated with the client area of a window.","source":"The `CDC` object provides member functions for working with a device context, such as a display or printer, as well as members for working with a display context associated with the client area of a window."},{"content":"Do all drawing through the member functions of a <ph id=\"ph1\">`CDC`</ph> object.","pos":[24922,24984],"source":"Do all drawing through the member functions of a `CDC` object."},{"content":"The class provides member functions for device-context operations, working with drawing tools, type-safe graphics device interface (GDI) object selection, and working with colors and palettes.","pos":[24985,25177]},{"content":"It also provides member functions for getting and setting drawing attributes, mapping, working with the viewport, working with the window extent, converting coordinates, working with regions, clipping, drawing lines, and drawing simple shapes, ellipses, and polygons.","pos":[25178,25445]},{"content":"Member functions are also provided for drawing text, working with fonts, using printer escapes, scrolling, and playing metafiles.","pos":[25446,25575]},{"pos":[25582,25711],"content":"To use a <ph id=\"ph1\">`CDC`</ph> object, construct it, and then call its member functions that parallel Windows functions that use device contexts.","source":"To use a `CDC` object, construct it, and then call its member functions that parallel Windows functions that use device contexts."},{"pos":[25719,25890],"content":"[!NOTE]\n Under Windows 95/98, all screen coordinates are limited to 16 bits. Therefore, an `int` passed to a `CDC` member function must lie in the range –32768 to 32767.","leadings":["","> "],"nodes":[{"content":" Under Windows 95/98, all screen coordinates are limited to 16 bits. Therefore, an `int` passed to a `CDC` member function must lie in the range –32768 to 32767.","pos":[8,169],"nodes":[{"content":"Under Windows 95/98, all screen coordinates are limited to 16 bits.","pos":[1,68]},{"content":"Therefore, an <ph id=\"ph1\">`int`</ph> passed to a <ph id=\"ph2\">`CDC`</ph> member function must lie in the range –32768 to 32767.","pos":[69,161],"source":" Therefore, an `int` passed to a `CDC` member function must lie in the range –32768 to 32767."}]}]},{"content":"For specific uses, the Microsoft Foundation Class Library provides several classes derived from <ph id=\"ph1\">`CDC`</ph> .","pos":[25897,26000],"source":"For specific uses, the Microsoft Foundation Class Library provides several classes derived from `CDC` ."},{"content":"encapsulates calls to <ph id=\"ph1\">`BeginPaint`</ph> and <ph id=\"ph2\">`EndPaint`</ph>.","pos":[26012,26062],"source":" encapsulates calls to `BeginPaint` and `EndPaint`."},{"content":"manages a display context associated with a window's client area.","pos":[26075,26140]},{"content":"manages a display context associated with an entire window, including its frame and controls.","pos":[26153,26246]},{"content":"associates a device context with a metafile.","pos":[26261,26305]},{"content":"provides two member functions, <bpt id=\"p1\">[</bpt>GetLayout<ept id=\"p1\">](#cdc__getlayout)</ept> and <bpt id=\"p2\">[</bpt>SetLayout<ept id=\"p2\">](#cdc__setlayout)</ept>, for reversing the layout of a device context, which does not inherit its layout from a window.","pos":[26318,26506],"source":" provides two member functions, [GetLayout](#cdc__getlayout) and [SetLayout](#cdc__setlayout), for reversing the layout of a device context, which does not inherit its layout from a window."},{"content":"Such right-to-left orientation is necessary for applications written for cultures, such as Arabic or Hebrew, where the character layout is not the European standard.","pos":[26507,26672]},{"content":"contains two device contexts, <bpt id=\"p1\">[</bpt>m_hDC<ept id=\"p1\">](#cdc__m_hdc)</ept> and <bpt id=\"p2\">[</bpt>m_hAttribDC<ept id=\"p2\">](#cdc__m_hattribdc)</ept>, which, on creation of a <ph id=\"ph1\">`CDC`</ph> object, refer to the same device.","pos":[26685,26837],"source":" contains two device contexts, [m_hDC](#cdc__m_hdc) and [m_hAttribDC](#cdc__m_hattribdc), which, on creation of a `CDC` object, refer to the same device."},{"content":"directs all output GDI calls to <ph id=\"ph1\">`m_hDC`</ph> and most attribute GDI calls to <ph id=\"ph2\">`m_hAttribDC`</ph>.","pos":[26844,26930],"source":" directs all output GDI calls to `m_hDC` and most attribute GDI calls to `m_hAttribDC`."},{"content":"(An example of an attribute call is <ph id=\"ph1\">`GetTextColor`</ph>, while <ph id=\"ph2\">`SetTextColor`</ph> is an output call.)","pos":[26931,27023],"source":" (An example of an attribute call is `GetTextColor`, while `SetTextColor` is an output call.)"},{"content":"For example, the framework uses these two device contexts to implement a <ph id=\"ph1\">`CMetaFileDC`</ph> object that will send output to a metafile while reading attributes from a physical device.","pos":[27030,27208],"source":"For example, the framework uses these two device contexts to implement a `CMetaFileDC` object that will send output to a metafile while reading attributes from a physical device."},{"content":"Print preview is implemented in the framework in a similar fashion.","pos":[27209,27276]},{"content":"You can also use the two device contexts in a similar way in your application-specific code.","pos":[27277,27369]},{"content":"There are times when you may need text-metric information from both the <ph id=\"ph1\">`m_hDC`</ph> and <ph id=\"ph2\">`m_hAttribDC`</ph> device contexts.","pos":[27376,27490],"source":"There are times when you may need text-metric information from both the `m_hDC` and `m_hAttribDC` device contexts."},{"content":"The following pairs of functions provide this capability:","pos":[27491,27548]},{"content":"Uses m_hAttribDC","pos":[27555,27571]},{"content":"Uses m_hDC","pos":[27572,27582]},{"content":"GetTextExtent","pos":[27634,27647]},{"content":"GetOutputTextExtent","pos":[27671,27690]},{"content":"GetTabbedTextExtent","pos":[27724,27743]},{"content":"GetOutputTabbedTextExtent","pos":[27773,27798]},{"content":"GetTextMetrics","pos":[27838,27852]},{"content":"GetOutputTextMetrics","pos":[27877,27897]},{"content":"GetCharWidth","pos":[27932,27944]},{"content":"GetOutputCharWidth","pos":[27967,27985]},{"pos":[28020,28103],"content":"For more information on <ph id=\"ph1\">`CDC`</ph>, see <bpt id=\"p1\">[</bpt>Device Contexts<ept id=\"p1\">](../../mfc/device-contexts.md)</ept>.","source":"For more information on `CDC`, see [Device Contexts](../../mfc/device-contexts.md)."},{"content":"Inheritance Hierarchy","pos":[28112,28133]},{"content":"CObject","pos":[28138,28145]},{"content":"Requirements","pos":[28205,28217]},{"pos":[28221,28241],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afxwin.h","source":"**Header:** afxwin.h"},{"pos":[28281,28294],"content":"CDC::AbortDoc"},{"pos":[28298,28465],"content":"Terminates the current print job and erases everything the application has written to the device since the last call to the <bpt id=\"p1\">[</bpt>StartDoc<ept id=\"p1\">](#cdc__startdoc)</ept> member function.","source":"Terminates the current print job and erases everything the application has written to the device since the last call to the [StartDoc](#cdc__startdoc) member function."},{"content":"Return Value","pos":[28506,28518]},{"content":"A value greater than or equal to 0 if successful, or a negative value if an error has occurred.","pos":[28522,28617]},{"content":"The following list shows common error values and their meanings:","pos":[28618,28682]},{"pos":[28690,28717],"content":"<bpt id=\"p1\">**</bpt>SP_ERROR<ept id=\"p1\">**</ept> General error.","source":"**SP_ERROR** General error."},{"pos":[28725,28841],"content":"<bpt id=\"p1\">**</bpt>SP_OUTOFDISK<ept id=\"p1\">**</ept> Not enough disk space is currently available for spooling, and no more space will become available.","source":"**SP_OUTOFDISK** Not enough disk space is currently available for spooling, and no more space will become available."},{"pos":[28849,28912],"content":"<bpt id=\"p1\">**</bpt>SP_OUTOFMEMORY<ept id=\"p1\">**</ept> Not enough memory is available for spooling.","source":"**SP_OUTOFMEMORY** Not enough memory is available for spooling."},{"pos":[28920,28987],"content":"<bpt id=\"p1\">**</bpt>SP_USERABORT<ept id=\"p1\">**</ept> User terminated the job through the Print Manager.","source":"**SP_USERABORT** User terminated the job through the Print Manager."},{"content":"Remarks","pos":[28997,29004]},{"pos":[29008,29068],"content":"This member function replaces the <ph id=\"ph1\">`ABORTDOC`</ph> printer escape.","source":"This member function replaces the `ABORTDOC` printer escape."},{"pos":[29075,29130],"content":"<bpt id=\"p1\">**</bpt>AbortDoc<ept id=\"p1\">**</ept> should be used to terminate the following:","source":"**AbortDoc** should be used to terminate the following:"},{"pos":[29140,29239],"content":"Printing operations that do not specify an abort function using <bpt id=\"p1\">[</bpt>SetAbortProc<ept id=\"p1\">](#cdc__setabortproc)</ept>.","source":"Printing operations that do not specify an abort function using [SetAbortProc](#cdc__setabortproc)."},{"pos":[29249,29348],"content":"Printing operations that have not yet reached their first <bpt id=\"p1\">**</bpt>NEWFRAME<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>NEXTBAND<ept id=\"p2\">**</ept> escape call.","source":"Printing operations that have not yet reached their first **NEWFRAME** or **NEXTBAND** escape call."},{"content":"If an application encounters a printing error or a canceled print operation, it must not attempt to terminate the operation by using either the <bpt id=\"p1\">[</bpt>EndDoc<ept id=\"p1\">](#cdc__enddoc)</ept> or <bpt id=\"p2\">**</bpt>AbortDoc<ept id=\"p2\">**</ept> member functions of class <ph id=\"ph1\">`CDC`</ph>.","pos":[29355,29570],"source":"If an application encounters a printing error or a canceled print operation, it must not attempt to terminate the operation by using either the [EndDoc](#cdc__enddoc) or **AbortDoc** member functions of class `CDC`."},{"content":"GDI automatically terminates the operation before returning the error value.","pos":[29571,29647]},{"pos":[29654,29803],"content":"If the application displays a dialog box to allow the user to cancel the print operation, it must call <bpt id=\"p1\">**</bpt>AbortDoc<ept id=\"p1\">**</ept> before destroying the dialog box.","source":"If the application displays a dialog box to allow the user to cancel the print operation, it must call **AbortDoc** before destroying the dialog box."},{"content":"If Print Manager was used to start the print job, calling <bpt id=\"p1\">**</bpt>AbortDoc<ept id=\"p1\">**</ept> erases the entire spool job — the printer receives nothing.","pos":[29810,29940],"source":"If Print Manager was used to start the print job, calling **AbortDoc** erases the entire spool job — the printer receives nothing."},{"content":"If Print Manager was not used to start the print job, the data may have been sent to the printer before <bpt id=\"p1\">**</bpt>AbortDoc<ept id=\"p1\">**</ept> was called.","pos":[29941,30069],"source":" If Print Manager was not used to start the print job, the data may have been sent to the printer before **AbortDoc** was called."},{"content":"In this case, the printer driver would have reset the printer (when possible) and closed the print job.","pos":[30070,30173]},{"content":"Example","pos":[30183,30190]},{"pos":[30195,30247],"content":"See the example for <bpt id=\"p1\">[</bpt>CDC::StartDoc<ept id=\"p1\">](#cdc__startdoc)</ept>.","source":"See the example for [CDC::StartDoc](#cdc__startdoc)."},{"pos":[30288,30302],"content":"CDC::AbortPath"},{"content":"Closes and discards any paths in the device context.","pos":[30306,30358]},{"content":"Return Value","pos":[30401,30413]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[30417,30468]},{"content":"Remarks","pos":[30478,30485]},{"content":"If there is an open path bracket in the device context, the path bracket is closed and the path is discarded.","pos":[30489,30598]},{"content":"If there is a closed path in the device context, the path is discarded.","pos":[30599,30670]},{"pos":[30720,30743],"content":"CDC::AddMetaFileComment"},{"content":"Copies the comment from a buffer into a specified enhanced-format metafile.","pos":[30747,30822]},{"content":"Parameters","pos":[30925,30935]},{"content":"nDataSize","pos":[30940,30949]},{"content":"Specifies the length of the comment buffer, in bytes.","pos":[30954,31007]},{"content":"pCommentData","pos":[31015,31027]},{"content":"Points to the buffer that contains the comment.","pos":[31032,31079]},{"content":"Return Value","pos":[31089,31101]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[31105,31156]},{"content":"Remarks","pos":[31166,31173]},{"content":"A comment may include any private information — for example, the source of the picture and the date it was created.","pos":[31177,31292]},{"content":"A comment should begin with an application signature, followed by the data.","pos":[31293,31368]},{"content":"Comments should not contain position-specific data.","pos":[31369,31420]},{"content":"Position-specific data specifies the location of a record, and it should not be included because one metafile may be embedded within another metafile.","pos":[31421,31571]},{"content":"This function can only be used with enhanced metafiles.","pos":[31572,31627]},{"pos":[31669,31684],"content":"CDC::AlphaBlend"},{"content":"Call this member function to display bitmaps that have transparent or semitransparent pixels.","pos":[31688,31781]},{"content":"Parameters","pos":[32022,32032]},{"content":"Specifies the x-coordinate, in logical units, of the upper-left corner of the destination rectangle.","pos":[32047,32147]},{"content":"Specifies the y-coordinate, in logical units, of the upper-left corner of the destination rectangle.","pos":[32165,32265]},{"content":"Specifies the width, in logical units, of the destination rectangle.","pos":[32288,32356]},{"content":"Specifies the height, in logical units, of the destination rectangle.","pos":[32380,32449]},{"content":"A pointer to the source device context.","pos":[32468,32507]},{"content":"Specifies the x-coordinate, in logical units, of the upper-left corner of the source rectangle.","pos":[32524,32619]},{"content":"Specifies the y-coordinate, in logical units, of the upper-left corner of the source rectangle.","pos":[32636,32731]},{"content":"Specifies the width, in logical units, of the source rectangle.","pos":[32753,32816]},{"content":"Specifies the height, in logical units, of the source rectangle.","pos":[32839,32903]},{"content":"blend","pos":[32911,32916]},{"content":"Specifies a <bpt id=\"p1\">[</bpt>BLENDFUNCTION<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd183393)</ept> structure.","pos":[32921,33019],"source":" Specifies a [BLENDFUNCTION](http://msdn.microsoft.com/library/windows/desktop/dd183393) structure."},{"content":"Return Value","pos":[33029,33041]},{"pos":[33045,33089],"content":"<bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept> if successful; otherwise <bpt id=\"p2\">**</bpt>FALSE<ept id=\"p2\">**</ept>.","source":"**TRUE** if successful; otherwise **FALSE**."},{"content":"Remarks","pos":[33099,33106]},{"pos":[33110,33267],"content":"See <bpt id=\"p1\">[</bpt>AlphaBlend<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd183351)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph> for more information.","source":"See [AlphaBlend](http://msdn.microsoft.com/library/windows/desktop/dd183351) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for more information."},{"pos":[33307,33320],"content":"CDC::AngleArc"},{"content":"Draws a line segment and an arc.","pos":[33324,33356]},{"content":"Parameters","pos":[33490,33500]},{"content":"x","pos":[33505,33506]},{"content":"Specifies the logical x-coordinate of the center of the circle.","pos":[33511,33574]},{"content":"y","pos":[33582,33583]},{"content":"Specifies the logical y-coordinate of the center of the circle.","pos":[33588,33651]},{"content":"nRadius","pos":[33659,33666]},{"content":"Specifies the radius of the circle in logical units.","pos":[33671,33723]},{"content":"This value must be positive.","pos":[33724,33752]},{"content":"fStartAngle","pos":[33760,33771]},{"content":"Specifies the starting angle in degrees relative to the x-axis.","pos":[33776,33839]},{"content":"fSweepAngle","pos":[33847,33858]},{"content":"Specifies the sweep angle in degrees relative to the starting angle.","pos":[33863,33931]},{"content":"Return Value","pos":[33941,33953]},{"content":"Nonzero if successful; otherwise 0.","pos":[33957,33992]},{"content":"Remarks","pos":[34002,34009]},{"content":"The line segment is drawn from the current position to the beginning of the arc.","pos":[34013,34093]},{"content":"The arc is drawn along the perimeter of a circle with the given radius and center.","pos":[34094,34176]},{"content":"The length of the arc is defined by the given start and sweep angles.","pos":[34177,34246]},{"content":"moves the current position to the ending point of the arc.","pos":[34264,34322]},{"content":"The arc drawn by this function may appear to be elliptical, depending on the current transformation and mapping mode.","pos":[34323,34440]},{"content":"Before drawing the arc, this function draws the line segment from the current position to the beginning of the arc.","pos":[34441,34556]},{"content":"The arc is drawn by constructing an imaginary circle with the specified radius around the specified center point.","pos":[34557,34670]},{"content":"The starting point of the arc is determined by measuring counterclockwise from the x-axis of the circle by the number of degrees in the start angle.","pos":[34671,34819]},{"content":"The ending point is similarly located by measuring counterclockwise from the starting point by the number of degrees in the sweep angle.","pos":[34820,34956]},{"content":"If the sweep angle is greater than 360 degrees the arc is swept multiple times.","pos":[34963,35042]},{"content":"This function draws lines by using the current pen.","pos":[35043,35094]},{"content":"The figure is not filled.","pos":[35095,35120]},{"pos":[35155,35163],"content":"CDC::Arc"},{"content":"Draws an elliptical arc.","pos":[35167,35191]},{"content":"Parameters","pos":[35411,35421]},{"content":"Specifies the x-coordinate of the upper-left corner of the bounding rectangle (in logical units).","pos":[35433,35530]},{"content":"Specifies the y-coordinate of the upper-left corner of the bounding rectangle (in logical units).","pos":[35545,35642]},{"content":"Specifies the x-coordinate of the lower-right corner of the bounding rectangle (in logical units).","pos":[35657,35755]},{"content":"Specifies the y-coordinate of the lower-right corner of the bounding rectangle (in logical units).","pos":[35770,35868]},{"content":"x3","pos":[35876,35878]},{"content":"Specifies the x-coordinate of the point that defines the arc's starting point (in logical units).","pos":[35883,35980]},{"content":"This point does not have to lie exactly on the arc.","pos":[35981,36032]},{"content":"Specifies the y-coordinate of the point that defines the arc's starting point (in logical units).","pos":[36047,36144]},{"content":"This point does not have to lie exactly on the arc.","pos":[36145,36196]},{"content":"Specifies the x-coordinate of the point that defines the arc's endpoint (in logical units).","pos":[36211,36302]},{"content":"This point does not have to lie exactly on the arc.","pos":[36303,36354]},{"content":"Specifies the y-coordinate of the point that defines the arc's endpoint (in logical units).","pos":[36369,36460]},{"content":"This point does not have to lie exactly on the arc.","pos":[36461,36512]},{"content":"Specifies the bounding rectangle (in logical units).","pos":[36531,36583]},{"content":"You can pass either an <ph id=\"ph1\">`LPRECT`</ph> or a <bpt id=\"p1\">[</bpt>CRect<ept id=\"p1\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object for this parameter.","pos":[36584,36702],"source":" You can pass either an `LPRECT` or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter."},{"content":"Specifies the x- and y-coordinates of the point that defines the arc's starting point (in logical units).","pos":[36722,36827]},{"content":"This point does not have to lie exactly on the arc.","pos":[36828,36879]},{"content":"You can pass either a <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> structure or a <bpt id=\"p2\">[</bpt>CPoint<ept id=\"p2\">](../../atl-mfc-shared/reference/cpoint-class.md)</ept> object for this parameter.","pos":[36880,37049],"source":" You can pass either a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter."},{"content":"Specifies the x- and y-coordinates of the point that defines the arc's ending point (in logical units).","pos":[37067,37170]},{"content":"This point does not have to lie exactly on the arc.","pos":[37171,37222]},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[37223,37305],"source":" You can pass either a **POINT** structure or a `CPoint` object for this parameter."},{"content":"Return Value","pos":[37315,37327]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[37331,37382]},{"content":"Remarks","pos":[37392,37399]},{"content":"The arc drawn by using the function is a segment of the ellipse defined by the specified bounding rectangle.","pos":[37403,37511]},{"content":"The actual starting point of the arc is the point at which a ray drawn from the center of the bounding rectangle through the specified starting point intersects the ellipse.","pos":[37518,37691]},{"content":"The actual ending point of the arc is the point at which a ray drawn from the center of the bounding rectangle through the specified ending point intersects the ellipse.","pos":[37692,37861]},{"content":"The arc is drawn in a counterclockwise direction.","pos":[37862,37911]},{"content":"Since an arc is not a closed figure, it is not filled.","pos":[37912,37966]},{"content":"Both the width and height of the rectangle must be greater than 2 units and less than 32,767 units.","pos":[37967,38066]},{"content":"Example","pos":[38076,38083]},{"pos":[38098,38115],"content":"NVC_MFCDocView#29"},{"pos":[38197,38207],"content":"CDC::ArcTo"},{"content":"Draws an elliptical arc.","pos":[38211,38235]},{"content":"Parameters","pos":[38459,38469]},{"content":"Specifies the x-coordinate of the upper-left corner of the bounding rectangle (in logical units).","pos":[38481,38578]},{"content":"Specifies the y-coordinate of the upper-left corner of the bounding rectangle (in logical units).","pos":[38593,38690]},{"content":"Specifies the x-coordinate of the lower-right corner of the bounding rectangle (in logical units).","pos":[38705,38803]},{"content":"Specifies the y-coordinate of the lower-right corner of the bounding rectangle (in logical units).","pos":[38818,38916]},{"content":"x3","pos":[38924,38926]},{"content":"Specifies the x-coordinate of the point that defines the arc's starting point (in logical units).","pos":[38931,39028]},{"content":"This point does not have to lie exactly on the arc.","pos":[39029,39080]},{"content":"Specifies the y-coordinate of the point that defines the arc's starting point (in logical units).","pos":[39095,39192]},{"content":"This point does not have to lie exactly on the arc.","pos":[39193,39244]},{"content":"Specifies the x-coordinate of the point that defines the arc's endpoint (in logical units).","pos":[39259,39350]},{"content":"This point does not have to lie exactly on the arc.","pos":[39351,39402]},{"content":"Specifies the y-coordinate of the point that defines the arc's endpoint (in logical units).","pos":[39417,39508]},{"content":"This point does not have to lie exactly on the arc.","pos":[39509,39560]},{"content":"Specifies the bounding rectangle (in logical units).","pos":[39579,39631]},{"content":"You can pass either a pointer to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> data structure or a <bpt id=\"p2\">[</bpt>CRect<ept id=\"p2\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object for this parameter.","pos":[39632,39815],"source":" You can pass either a pointer to a [RECT](../../mfc/reference/rect-structure1.md) data structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter."},{"content":"Specifies the x- and y-coordinates of the point that defines the arc's starting point (in logical units).","pos":[39835,39940]},{"content":"This point does not have to lie exactly on the arc.","pos":[39941,39992]},{"content":"You can pass either a <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> data structure or a <bpt id=\"p2\">[</bpt>CPoint<ept id=\"p2\">](../../atl-mfc-shared/reference/cpoint-class.md)</ept> object for this parameter.","pos":[39993,40167],"source":" You can pass either a [POINT](../../mfc/reference/point-structure1.md) data structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter."},{"content":"Specifies the x- and y-coordinates of the point that defines the arc's ending point (in logical units).","pos":[40185,40288]},{"content":"This point does not have to lie exactly on the arc.","pos":[40289,40340]},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> data structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[40341,40428],"source":" You can pass either a **POINT** data structure or a `CPoint` object for this parameter."},{"content":"Return Value","pos":[40438,40450]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[40454,40505]},{"content":"Remarks","pos":[40515,40522]},{"content":"This function is similar to <ph id=\"ph1\">`CDC::Arc`</ph>, except that the current position is updated.","pos":[40526,40610],"source":"This function is similar to `CDC::Arc`, except that the current position is updated."},{"content":"The points ( <ph id=\"ph1\">`x1`</ph>, <ph id=\"ph2\">`y1`</ph>) and ( <ph id=\"ph3\">`x2`</ph>, <ph id=\"ph4\">`y2`</ph>) specify the bounding rectangle.","pos":[40611,40685],"source":" The points ( `x1`, `y1`) and ( `x2`, `y2`) specify the bounding rectangle."},{"content":"An ellipse formed by the given bounding rectangle defines the curve of the arc.","pos":[40686,40765]},{"content":"The arc extends counterclockwise (the default arc direction) from the point where it intersects the radial line from the center of the bounding rectangle to ( <bpt id=\"p1\">*</bpt>x3<ept id=\"p1\">*</ept>, <ph id=\"ph1\">`y3`</ph>).","pos":[40766,40937],"source":" The arc extends counterclockwise (the default arc direction) from the point where it intersects the radial line from the center of the bounding rectangle to ( *x3*, `y3`)."},{"content":"The arc ends where it intersects the radial line from the center of the bounding rectangle to ( <ph id=\"ph1\">`x4`</ph>, <ph id=\"ph2\">`y4`</ph>).","pos":[40938,41046],"source":" The arc ends where it intersects the radial line from the center of the bounding rectangle to ( `x4`, `y4`)."},{"content":"If the starting point and ending point are the same, a complete ellipse is drawn.","pos":[41047,41128]},{"content":"A line is drawn from the current position to the starting point of the arc.","pos":[41135,41210]},{"content":"If no error occurs, the current position is set to the ending point of the arc.","pos":[41211,41290]},{"content":"The arc is drawn using the current pen; it is not filled.","pos":[41291,41348]},{"pos":[41386,41397],"content":"CDC::Attach"},{"pos":[41401,41465],"content":"Use this member function to attach an <ph id=\"ph1\">`hDC`</ph> to the <ph id=\"ph2\">`CDC`</ph> object.","source":"Use this member function to attach an `hDC` to the `CDC` object."},{"content":"Parameters","pos":[41512,41522]},{"content":"A Windows device context.","pos":[41535,41560]},{"content":"Return Value","pos":[41570,41582]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[41586,41637]},{"content":"Remarks","pos":[41647,41654]},{"pos":[41658,41773],"content":"The <ph id=\"ph1\">`hDC`</ph> is stored in both <ph id=\"ph2\">`m_hDC`</ph>, the output device context, and in <ph id=\"ph3\">`m_hAttribDC`</ph>, the attribute device context.","source":"The `hDC` is stored in both `m_hDC`, the output device context, and in `m_hAttribDC`, the attribute device context."},{"pos":[41814,41828],"content":"CDC::BeginPath"},{"content":"Opens a path bracket in the device context.","pos":[41832,41875]},{"content":"Return Value","pos":[41918,41930]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[41934,41985]},{"content":"Remarks","pos":[41995,42002]},{"content":"After a path bracket is open, an application can begin calling GDI drawing functions to define the points that lie in the path.","pos":[42006,42133]},{"content":"An application can close an open path bracket by calling the <ph id=\"ph1\">`EndPath`</ph> member function.","pos":[42134,42221],"source":" An application can close an open path bracket by calling the `EndPath` member function."},{"content":"When an application calls <ph id=\"ph1\">`BeginPath`</ph>, any previous paths are discarded.","pos":[42222,42294],"source":" When an application calls `BeginPath`, any previous paths are discarded."},{"pos":[42301,42501],"content":"See <bpt id=\"p1\">[</bpt>BeginPath<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd183363)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph> for a list of the drawing functions that define points in a path.","source":"See [BeginPath](http://msdn.microsoft.com/library/windows/desktop/dd183363) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a list of the drawing functions that define points in a path."},{"content":"Example","pos":[42511,42518]},{"pos":[42533,42550],"content":"NVC_MFCDocView#30"},{"pos":[42633,42644],"content":"CDC::BitBlt"},{"content":"Copies a bitmap from the source device context to this current device context.","pos":[42648,42726]},{"content":"Parameters","pos":[42896,42906]},{"content":"x","pos":[42911,42912]},{"content":"Specifies the logical x-coordinate of the upper-left corner of the destination rectangle.","pos":[42917,43006]},{"content":"y","pos":[43014,43015]},{"content":"Specifies the logical y-coordinate of the upper-left corner of the destination rectangle.","pos":[43020,43109]},{"content":"Specifies the width (in logical units) of the destination rectangle and source bitmap.","pos":[43128,43214]},{"content":"Specifies the height (in logical units) of the destination rectangle and source bitmap.","pos":[43234,43321]},{"content":"Pointer to a <ph id=\"ph1\">`CDC`</ph> object that identifies the device context from which the bitmap will be copied.","pos":[43340,43438],"source":" Pointer to a `CDC` object that identifies the device context from which the bitmap will be copied."},{"content":"It must be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if <bpt id=\"p2\">*</bpt>dwRop<ept id=\"p2\">*</ept> specifies a raster operation that does not include a source.","pos":[43439,43530],"source":" It must be **NULL** if *dwRop* specifies a raster operation that does not include a source."},{"content":"Specifies the logical x-coordinate of the upper-left corner of the source bitmap.","pos":[43547,43628]},{"content":"Specifies the logical y-coordinate of the upper-left corner of the source bitmap.","pos":[43645,43726]},{"content":"dwRop","pos":[43734,43739]},{"content":"Specifies the raster operation to be performed.","pos":[43744,43791]},{"content":"Raster-operation codes define how the GDI combines colors in output operations that involve a current brush, a possible source bitmap, and a destination bitmap.","pos":[43792,43952]},{"content":"See <bpt id=\"p1\">[</bpt>BitBlt<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd183370)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph> for a list of the raster-operation codes for <bpt id=\"p2\">*</bpt>dwRop<ept id=\"p2\">*</ept> and their descriptions","pos":[43953,44160],"source":" See [BitBlt](http://msdn.microsoft.com/library/windows/desktop/dd183370) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a list of the raster-operation codes for *dwRop* and their descriptions"},{"pos":[44167,44368],"content":"For a complete list of raster-operation codes, see <bpt id=\"p1\">[</bpt>About Raster Operation Codes<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162892)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"For a complete list of raster-operation codes, see [About Raster Operation Codes](http://msdn.microsoft.com/library/windows/desktop/dd162892) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"Return Value","pos":[44378,44390]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[44394,44445]},{"content":"Remarks","pos":[44455,44462]},{"content":"The application can align the windows or client areas on byte boundaries to ensure that the <ph id=\"ph1\">`BitBlt`</ph> operations occur on byte-aligned rectangles.","pos":[44466,44611],"source":"The application can align the windows or client areas on byte boundaries to ensure that the `BitBlt` operations occur on byte-aligned rectangles."},{"content":"(Set the <bpt id=\"p1\">**</bpt>CS_BYTEALIGNWINDOW<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>CS_BYTEALIGNCLIENT<ept id=\"p2\">**</ept> flags when you register the window classes.)","pos":[44612,44714],"source":" (Set the **CS_BYTEALIGNWINDOW** or **CS_BYTEALIGNCLIENT** flags when you register the window classes.)"},{"content":"operations on byte-aligned rectangles are considerably faster than <ph id=\"ph1\">`BitBlt`</ph> operations on rectangles that are not byte aligned.","pos":[44730,44857],"source":" operations on byte-aligned rectangles are considerably faster than `BitBlt` operations on rectangles that are not byte aligned."},{"content":"If you want to specify class styles such as byte-alignment for your own device context, you will have to register a window class rather than relying on the Microsoft Foundation classes to do it for you.","pos":[44858,45060]},{"content":"Use the global function <bpt id=\"p1\">[</bpt>AfxRegisterWndClass<ept id=\"p1\">](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)</ept>.","pos":[45061,45190],"source":" Use the global function [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)."},{"content":"GDI transforms <ph id=\"ph1\">`nWidth`</ph> and <ph id=\"ph2\">`nHeight`</ph>, once by using the destination device context, and once by using the source device context.","pos":[45197,45326],"source":"GDI transforms `nWidth` and `nHeight`, once by using the destination device context, and once by using the source device context."},{"content":"If the resulting extents do not match, GDI uses the Windows <ph id=\"ph1\">`StretchBlt`</ph> function to compress or stretch the source bitmap as necessary.","pos":[45327,45463],"source":" If the resulting extents do not match, GDI uses the Windows `StretchBlt` function to compress or stretch the source bitmap as necessary."},{"content":"If destination, source, and pattern bitmaps do not have the same color format, the <ph id=\"ph1\">`BitBlt`</ph> function converts the source and pattern bitmaps to match the destination.","pos":[45470,45636],"source":"If destination, source, and pattern bitmaps do not have the same color format, the `BitBlt` function converts the source and pattern bitmaps to match the destination."},{"content":"The foreground and background colors of the destination bitmap are used in the conversion.","pos":[45637,45727]},{"content":"When the <ph id=\"ph1\">`BitBlt`</ph> function converts a monochrome bitmap to color, it sets white bits (1) to the background color and black bits (0) to the foreground color.","pos":[45734,45890],"source":"When the `BitBlt` function converts a monochrome bitmap to color, it sets white bits (1) to the background color and black bits (0) to the foreground color."},{"content":"The foreground and background colors of the destination device context are used.","pos":[45891,45971]},{"content":"To convert color to monochrome, <ph id=\"ph1\">`BitBlt`</ph> sets pixels that match the background color to white and sets all other pixels to black.","pos":[45972,46101],"source":" To convert color to monochrome, `BitBlt` sets pixels that match the background color to white and sets all other pixels to black."},{"content":"uses the foreground and background colors of the color device context to convert from color to monochrome.","pos":[46111,46217]},{"content":"Note that not all device contexts support <ph id=\"ph1\">`BitBlt`</ph>.","pos":[46224,46275],"source":"Note that not all device contexts support `BitBlt`."},{"content":"To check whether a given device context does support <ph id=\"ph1\">`BitBlt`</ph>, use the <ph id=\"ph2\">`GetDeviceCaps`</ph> member function and specify the <bpt id=\"p1\">**</bpt>RASTERCAPS<ept id=\"p1\">**</ept> index.","pos":[46276,46416],"source":" To check whether a given device context does support `BitBlt`, use the `GetDeviceCaps` member function and specify the **RASTERCAPS** index."},{"content":"Example","pos":[46426,46433]},{"pos":[46438,46510],"content":"See the example for <bpt id=\"p1\">[</bpt>CDC::CreateCompatibleDC<ept id=\"p1\">](#cdc__createcompatibledc)</ept>.","source":"See the example for [CDC::CreateCompatibleDC](#cdc__createcompatibledc)."},{"pos":[46545,46553],"content":"CDC::CDC"},{"pos":[46557,46583],"content":"Constructs a <ph id=\"ph1\">`CDC`</ph> object.","source":"Constructs a `CDC` object."},{"pos":[46642,46652],"content":"CDC::Chord"},{"content":"Draws a chord (a closed figure bounded by the intersection of an ellipse and a line segment).","pos":[46656,46749]},{"content":"Parameters","pos":[46973,46983]},{"content":"Specifies the x-coordinate of the upper-left corner of the chord's bounding rectangle (in logical units).","pos":[46995,47100]},{"content":"Specifies the y-coordinate of the upper-left corner of the chord's bounding rectangle (in logical units).","pos":[47115,47220]},{"content":"Specifies the x-coordinate of the lower-right corner of the chord's bounding rectangle (in logical units).","pos":[47235,47341]},{"content":"Specifies the y-coordinate of the lower-right corner of the chord's bounding rectangle (in logical units).","pos":[47356,47462]},{"content":"x3","pos":[47470,47472]},{"content":"Specifies the x-coordinate of the point that defines the chord's starting point (in logical units).","pos":[47477,47576]},{"content":"Specifies the y-coordinate of the point that defines the chord's starting point (in logical units).","pos":[47591,47690]},{"content":"Specifies the x-coordinate of the point that defines the chord's endpoint (in logical units).","pos":[47705,47798]},{"content":"Specifies the y-coordinate of the point that defines the chord's endpoint (in logical units).","pos":[47813,47906]},{"content":"Specifies the bounding rectangle (in logical units).","pos":[47925,47977]},{"content":"You can pass either a <ph id=\"ph1\">`LPRECT`</ph> or a <bpt id=\"p1\">[</bpt>CRect<ept id=\"p1\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object for this parameter.","pos":[47978,48095],"source":" You can pass either a `LPRECT` or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter."},{"content":"Specifies the x- and y-coordinates of the point that defines the chord's starting point (in logical units).","pos":[48115,48222]},{"content":"This point does not have to lie exactly on the chord.","pos":[48223,48276]},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[48277,48359],"source":" You can pass either a **POINT** structure or a `CPoint` object for this parameter."},{"content":"Specifies the x- and y-coordinates of the point that defines the chord's ending point (in logical units).","pos":[48377,48482]},{"content":"This point does not have to lie exactly on the chord.","pos":[48483,48536]},{"content":"You can pass either a <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> structure or a <bpt id=\"p2\">[</bpt>CPoint<ept id=\"p2\">](../../atl-mfc-shared/reference/cpoint-class.md)</ept> object for this parameter.","pos":[48537,48706],"source":" You can pass either a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter."},{"content":"Return Value","pos":[48716,48728]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[48732,48783]},{"content":"Remarks","pos":[48793,48800]},{"content":"The ( <ph id=\"ph1\">`x1`</ph>, <ph id=\"ph2\">`y1`</ph>) and ( <ph id=\"ph3\">`x2`</ph>, <ph id=\"ph4\">`y2`</ph>) parameters specify the upper-left and lower-right corners, respectively, of a rectangle bounding the ellipse that is part of the chord.","pos":[48804,48975],"source":"The ( `x1`, `y1`) and ( `x2`, `y2`) parameters specify the upper-left and lower-right corners, respectively, of a rectangle bounding the ellipse that is part of the chord."},{"content":"The ( <bpt id=\"p1\">*</bpt>x3<ept id=\"p1\">*</ept>, <ph id=\"ph1\">`y3`</ph>) and ( <ph id=\"ph2\">`x4`</ph>, <ph id=\"ph3\">`y4`</ph>) parameters specify the endpoints of a line that intersects the ellipse.","pos":[48976,49083],"source":" The ( *x3*, `y3`) and ( `x4`, `y4`) parameters specify the endpoints of a line that intersects the ellipse."},{"content":"The chord is drawn by using the selected pen and filled by using the selected brush.","pos":[49084,49168]},{"content":"The figure drawn by the <ph id=\"ph1\">`Chord`</ph> function extends up to, but does not include the right and bottom coordinates.","pos":[49175,49285],"source":"The figure drawn by the `Chord` function extends up to, but does not include the right and bottom coordinates."},{"content":"This means that the height of the figure is <ph id=\"ph1\">`y2`</ph> – <ph id=\"ph2\">`y1`</ph> and the width of the figure is <ph id=\"ph3\">`x2`</ph> – <ph id=\"ph4\">`x1`</ph>.","pos":[49286,49385],"source":" This means that the height of the figure is `y2` – `y1` and the width of the figure is `x2` – `x1`."},{"content":"Example","pos":[49395,49402]},{"pos":[49417,49434],"content":"NVC_MFCDocView#31"},{"pos":[49522,49538],"content":"CDC::CloseFigure"},{"content":"Closes an open figure in a path.","pos":[49542,49574]},{"content":"Return Value","pos":[49619,49631]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[49635,49686]},{"content":"Remarks","pos":[49696,49703]},{"content":"The function closes the figure by drawing a line from the current position to the first point of the figure (usually, the point specified by the most recent call to the <ph id=\"ph1\">`MoveTo`</ph> member function) and connects the lines by using the line join style.","pos":[49707,49954],"source":"The function closes the figure by drawing a line from the current position to the first point of the figure (usually, the point specified by the most recent call to the `MoveTo` member function) and connects the lines by using the line join style."},{"content":"If a figure is closed by using the <ph id=\"ph1\">`LineTo`</ph> member function instead of <ph id=\"ph2\">`CloseFigure`</ph>, end caps are used to create the corner instead of a join.","pos":[49955,50098],"source":" If a figure is closed by using the `LineTo` member function instead of `CloseFigure`, end caps are used to create the corner instead of a join."},{"content":"should only be called if there is an open path bracket in the device context.","pos":[50113,50190]},{"content":"A figure in a path is open unless it is explicitly closed by using this function.","pos":[50197,50278]},{"content":"(A figure can be open even if the current point and the starting point of the figure are the same.) Any line or curve added to the path after <ph id=\"ph1\">`CloseFigure`</ph> starts a new figure.","pos":[50279,50455],"source":" (A figure can be open even if the current point and the starting point of the figure are the same.) Any line or curve added to the path after `CloseFigure` starts a new figure."},{"pos":[50505,50528],"content":"CDC::CreateCompatibleDC"},{"pos":[50532,50618],"content":"Creates a memory device context that is compatible with the device specified by <ph id=\"ph1\">`pDC`</ph>.","source":"Creates a memory device context that is compatible with the device specified by `pDC`."},{"content":"Parameters","pos":[50678,50688]},{"content":"A pointer to a device context.","pos":[50701,50731]},{"content":"If <ph id=\"ph1\">`pDC`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the function creates a memory device context that is compatible with the system display.","pos":[50732,50842],"source":" If `pDC` is **NULL**, the function creates a memory device context that is compatible with the system display."},{"content":"Return Value","pos":[50852,50864]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[50868,50919]},{"content":"Remarks","pos":[50929,50936]},{"content":"A memory device context is a block of memory that represents a display surface.","pos":[50940,51019]},{"content":"It can be used to prepare images in memory before copying them to the actual device surface of the compatible device.","pos":[51020,51137]},{"content":"When a memory device context is created, GDI automatically selects a 1-by-1 monochrome stock bitmap for it.","pos":[51144,51251]},{"content":"GDI output functions can be used with a memory device context only if a bitmap has been created and selected into that context.","pos":[51252,51379]},{"content":"This function can only be used to create compatible device contexts for devices that support raster operations.","pos":[51386,51497]},{"content":"See the <bpt id=\"p1\">[</bpt>CDC::BitBlt<ept id=\"p1\">](#cdc__bitblt)</ept> member function for information regarding bit-block transfers between device contexts.","pos":[51498,51620],"source":" See the [CDC::BitBlt](#cdc__bitblt) member function for information regarding bit-block transfers between device contexts."},{"content":"To determine whether a device context supports raster operations, see the <bpt id=\"p1\">**</bpt>RC_BITBLT<ept id=\"p1\">**</ept> raster capability in the member function <ph id=\"ph1\">`CDC::GetDeviceCaps`</ph>.","pos":[51621,51771],"source":" To determine whether a device context supports raster operations, see the **RC_BITBLT** raster capability in the member function `CDC::GetDeviceCaps`."},{"content":"Example","pos":[51781,51788]},{"pos":[51803,51820],"content":"NVC_MFCDocView#32"},{"pos":[51905,51918],"content":"CDC::CreateDC"},{"content":"Creates a device context for the specified device.","pos":[51922,51972]},{"content":"Parameters","pos":[52127,52137]},{"content":"Points to a null-terminated string that specifies the filename (without extension) of the device driver (for example, \"EPSON\").","pos":[52161,52288]},{"content":"You can also pass a <ph id=\"ph1\">`CString`</ph> object for this parameter.","pos":[52289,52345],"source":" You can also pass a `CString` object for this parameter."},{"content":"Points to a null-terminated string that specifies the name of the specific device to be supported (for example, \"EPSON FX-80\").","pos":[52372,52499]},{"content":"The <ph id=\"ph1\">`lpszDeviceName`</ph> parameter is used if the module supports more than one device.","pos":[52500,52583],"source":" The `lpszDeviceName` parameter is used if the module supports more than one device."},{"content":"You can also pass a <ph id=\"ph1\">`CString`</ph> object for this parameter.","pos":[52584,52640],"source":" You can also pass a `CString` object for this parameter."},{"content":"Points to a null-terminated string that specifies the file or device name for the physical output medium (file or output port).","pos":[52663,52790]},{"content":"You can also pass a <ph id=\"ph1\">`CString`</ph> object for this parameter.","pos":[52791,52847],"source":" You can also pass a `CString` object for this parameter."},{"content":"Points to a <ph id=\"ph1\">`DEVMODE`</ph> structure containing device-specific initialization data for the device driver.","pos":[52870,52971],"source":" Points to a `DEVMODE` structure containing device-specific initialization data for the device driver."},{"content":"The Windows <bpt id=\"p1\">**</bpt>DocumentProperties<ept id=\"p1\">**</ept> function retrieves this structure filled in for a given device.","pos":[52972,53070],"source":" The Windows **DocumentProperties** function retrieves this structure filled in for a given device."},{"content":"The <ph id=\"ph1\">`lpInitData`</ph> parameter must be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if the device driver is to use the default initialization (if any) specified by the user through the Control Panel.","pos":[53071,53230],"source":" The `lpInitData` parameter must be **NULL** if the device driver is to use the default initialization (if any) specified by the user through the Control Panel."},{"content":"Return Value","pos":[53240,53252]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[53256,53307]},{"content":"Remarks","pos":[53317,53324]},{"pos":[53328,53459],"content":"The PRINT.H header file is required if the <bpt id=\"p1\">[</bpt>DEVMODE<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd183565)</ept> structure is used.","source":"The PRINT.H header file is required if the [DEVMODE](http://msdn.microsoft.com/library/windows/desktop/dd183565) structure is used."},{"content":"Device names follow these conventions: an ending colon (:) is recommended, but optional.","pos":[53466,53554]},{"content":"Windows strips the terminating colon so that a device name ending with a colon is mapped to the same port as the same name without a colon.","pos":[53555,53694]},{"content":"The driver and port names must not contain leading or trailing spaces.","pos":[53695,53765]},{"content":"GDI output functions cannot be used with information contexts.","pos":[53766,53828]},{"pos":[53868,53881],"content":"CDC::CreateIC"},{"content":"Creates an information context for the specified device.","pos":[53885,53941]},{"content":"Parameters","pos":[54096,54106]},{"content":"Points to a null-terminated string that specifies the filename (without extension) of the device driver (for example, \"EPSON\").","pos":[54130,54257]},{"content":"You can pass a <ph id=\"ph1\">`CString`</ph> object for this parameter.","pos":[54258,54309],"source":" You can pass a `CString` object for this parameter."},{"content":"Points to a null-terminated string that specifies the name of the specific device to be supported (for example, \"EPSON FX-80\").","pos":[54336,54463]},{"content":"The <ph id=\"ph1\">`lpszDeviceName`</ph> parameter is used if the module supports more than one device.","pos":[54464,54547],"source":" The `lpszDeviceName` parameter is used if the module supports more than one device."},{"content":"You can pass a <ph id=\"ph1\">`CString`</ph> object for this parameter.","pos":[54548,54599],"source":" You can pass a `CString` object for this parameter."},{"content":"Points to a null-terminated string that specifies the file or device name for the physical output medium (file or port).","pos":[54622,54742]},{"content":"You can pass a <ph id=\"ph1\">`CString`</ph> object for this parameter.","pos":[54743,54794],"source":" You can pass a `CString` object for this parameter."},{"content":"Points to device-specific initialization data for the device driver.","pos":[54817,54885]},{"content":"The <ph id=\"ph1\">`lpInitData`</ph> parameter must be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if the device driver is to use the default initialization (if any) specified by the user through the Control Panel.","pos":[54886,55045],"source":" The `lpInitData` parameter must be **NULL** if the device driver is to use the default initialization (if any) specified by the user through the Control Panel."},{"content":"See <ph id=\"ph1\">`CreateDC`</ph> for the data format for device-specific initialization.","pos":[55046,55116],"source":" See `CreateDC` for the data format for device-specific initialization."},{"content":"Return Value","pos":[55126,55138]},{"content":"Nonzero if successful; otherwise 0.","pos":[55142,55177]},{"content":"Remarks","pos":[55187,55194]},{"content":"The information context provides a fast way to get information about the device without creating a device context.","pos":[55198,55312]},{"content":"Device names follow these conventions: an ending colon (:) is recommended, but optional.","pos":[55319,55407]},{"content":"Windows strips the terminating colon so that a device name ending with a colon is mapped to the same port as the same name without a colon.","pos":[55408,55547]},{"content":"The driver and port names must not contain leading or trailing spaces.","pos":[55548,55618]},{"content":"GDI output functions cannot be used with information contexts.","pos":[55619,55681]},{"pos":[55721,55734],"content":"CDC::DeleteDC"},{"content":"In general, do not call this function; the destructor will do it for you.","pos":[55738,55811]},{"content":"Return Value","pos":[55853,55865]},{"content":"Nonzero if the function completed successfully; otherwise 0.","pos":[55869,55929]},{"content":"Remarks","pos":[55939,55946]},{"content":"The <ph id=\"ph1\">`DeleteDC`</ph> member function deletes the Windows device contexts that are associated with <ph id=\"ph2\">`m_hDC`</ph> in the current <ph id=\"ph3\">`CDC`</ph> object.","pos":[55950,56078],"source":"The `DeleteDC` member function deletes the Windows device contexts that are associated with `m_hDC` in the current `CDC` object."},{"content":"If this <ph id=\"ph1\">`CDC`</ph> object is the last active device context for a given device, the device is notified and all storage and system resources used by the device are released.","pos":[56079,56246],"source":" If this `CDC` object is the last active device context for a given device, the device is notified and all storage and system resources used by the device are released."},{"content":"An application should not call <ph id=\"ph1\">`DeleteDC`</ph> if objects have been selected into the device context.","pos":[56253,56349],"source":"An application should not call `DeleteDC` if objects have been selected into the device context."},{"content":"Objects must first be selected out of the device context before it is deleted.","pos":[56350,56428]},{"content":"An application must not delete a device context whose handle was obtained by calling <bpt id=\"p1\">[</bpt>CWnd::GetDC<ept id=\"p1\">](../../mfc/reference/cwnd-class.md#cwnd__getdc)</ept>.","pos":[56435,56581],"source":"An application must not delete a device context whose handle was obtained by calling [CWnd::GetDC](../../mfc/reference/cwnd-class.md#cwnd__getdc)."},{"content":"Instead, it must call <bpt id=\"p1\">[</bpt>CWnd::ReleaseDC<ept id=\"p1\">](../../mfc/reference/cwnd-class.md#cwnd__releasedc)</ept> to free the device context.","pos":[56582,56700],"source":" Instead, it must call [CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#cwnd__releasedc) to free the device context."},{"content":"The <bpt id=\"p1\">[</bpt>CClientDC<ept id=\"p1\">](../../mfc/reference/cclientdc-class.md)</ept> and <bpt id=\"p2\">[</bpt>CWindowDC<ept id=\"p2\">](../../mfc/reference/cwindowdc-class.md)</ept> classes are provided to wrap this functionality.","pos":[56701,56861],"source":" The [CClientDC](../../mfc/reference/cclientdc-class.md) and [CWindowDC](../../mfc/reference/cwindowdc-class.md) classes are provided to wrap this functionality."},{"pos":[56868,57055],"content":"The <ph id=\"ph1\">`DeleteDC`</ph> function is generally used to delete device contexts created with <bpt id=\"p1\">[</bpt>CreateDC<ept id=\"p1\">](#cdc__createdc)</ept>, <bpt id=\"p2\">[</bpt>CreateIC<ept id=\"p2\">](#cdc__createic)</ept>, or <bpt id=\"p3\">[</bpt>CreateCompatibleDC<ept id=\"p3\">](#cdc__createcompatibledc)</ept>.","source":"The `DeleteDC` function is generally used to delete device contexts created with [CreateDC](#cdc__createdc), [CreateIC](#cdc__createic), or [CreateCompatibleDC](#cdc__createcompatibledc)."},{"content":"Example","pos":[57065,57072]},{"pos":[57077,57196],"content":"See the example for <bpt id=\"p1\">[</bpt>CPrintDialog::GetPrinterDC<ept id=\"p1\">](../../mfc/reference/cprintdialog-class.md#cprintdialog__getprinterdc)</ept>.","source":"See the example for [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#cprintdialog__getprinterdc)."},{"pos":[57241,57259],"content":"CDC::DeleteTempMap"},{"pos":[57263,57501],"content":"Called automatically by the <ph id=\"ph1\">`CWinApp`</ph> idle-time handler, <ph id=\"ph2\">`DeleteTempMap`</ph> deletes any temporary <ph id=\"ph3\">`CDC`</ph> objects created by <ph id=\"ph4\">`FromHandle`</ph>, but does not destroy the device context handles ( <ph id=\"ph5\">`hDC`</ph>s) temporarily associated with the <ph id=\"ph6\">`CDC`</ph> objects.","source":"Called automatically by the `CWinApp` idle-time handler, `DeleteTempMap` deletes any temporary `CDC` objects created by `FromHandle`, but does not destroy the device context handles ( `hDC`s) temporarily associated with the `CDC` objects."},{"pos":[57590,57601],"content":"CDC::Detach"},{"pos":[57605,57743],"content":"Call this function to detach <ph id=\"ph1\">`m_hDC`</ph> (the output device context) from the <ph id=\"ph2\">`CDC`</ph> object and set both <ph id=\"ph3\">`m_hDC`</ph> and <ph id=\"ph4\">`m_hAttribDC`</ph> to <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"Call this function to detach `m_hDC` (the output device context) from the `CDC` object and set both `m_hDC` and `m_hAttribDC` to **NULL**."},{"content":"Return Value","pos":[57782,57794]},{"content":"A Windows device context.","pos":[57798,57823]},{"pos":[57867,57884],"content":"CDC::DPtoHIMETRIC"},{"pos":[57888,57981],"content":"Use this function when you give <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> sizes to OLE, converting pixels to <bpt id=\"p2\">**</bpt>HIMETRIC<ept id=\"p2\">**</ept>.","source":"Use this function when you give **HIMETRIC** sizes to OLE, converting pixels to **HIMETRIC**."},{"content":"Parameters","pos":[58049,58059]},{"content":"Points to a <bpt id=\"p1\">[</bpt>SIZE<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145106)</ept> structure or <bpt id=\"p2\">[</bpt>CSize<ept id=\"p2\">](../../atl-mfc-shared/reference/csize-class.md)</ept> object.","pos":[58075,58229],"source":" Points to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure or [CSize](../../atl-mfc-shared/reference/csize-class.md) object."},{"content":"Remarks","pos":[58239,58246]},{"content":"If the mapping mode of the device context object is <ph id=\"ph1\">`MM_LOENGLISH`</ph>, <ph id=\"ph2\">`MM_HIENGLISH`</ph>, <ph id=\"ph3\">`MM_LOMETRIC`</ph>, or <ph id=\"ph4\">`MM_HIMETRIC`</ph>, then the conversion is based on the number of pixels in the physical inch.","pos":[58250,58441],"source":"If the mapping mode of the device context object is `MM_LOENGLISH`, `MM_HIENGLISH`, `MM_LOMETRIC`, or `MM_HIMETRIC`, then the conversion is based on the number of pixels in the physical inch."},{"content":"If the mapping mode is one of the other non-constrained modes (e.g., <ph id=\"ph1\">`MM_TEXT`</ph>), then the conversion is based on the number of pixels in the logical inch.","pos":[58442,58596],"source":" If the mapping mode is one of the other non-constrained modes (e.g., `MM_TEXT`), then the conversion is based on the number of pixels in the logical inch."},{"pos":[58634,58645],"content":"CDC::DPtoLP"},{"content":"Converts device units into logical units.","pos":[58649,58690]},{"content":"Parameters","pos":[58870,58880]},{"content":"Points to an array of <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> structures or <bpt id=\"p2\">[</bpt>CPoint<ept id=\"p2\">](../../atl-mfc-shared/reference/cpoint-class.md)</ept> objects.","pos":[58898,59048],"source":" Points to an array of [POINT](../../mfc/reference/point-structure1.md) structures or [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objects."},{"content":"The number of points in the array.","pos":[59067,59101]},{"content":"Points to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure or <bpt id=\"p2\">[</bpt>CRect<ept id=\"p2\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object.","pos":[59120,59254],"source":" Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or [CRect](../../atl-mfc-shared/reference/crect-class.md) object."},{"content":"This parameter is used for the simple case of converting one rectangle from device points to logical points.","pos":[59255,59363]},{"content":"Points to a <bpt id=\"p1\">[</bpt>SIZE<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145106)</ept> structure or <bpt id=\"p2\">[</bpt>CSize<ept id=\"p2\">](../../atl-mfc-shared/reference/csize-class.md)</ept> object.","pos":[59382,59536],"source":" Points to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure or [CSize](../../atl-mfc-shared/reference/csize-class.md) object."},{"content":"Remarks","pos":[59546,59553]},{"content":"The function maps the coordinates of each point, or dimension of a size, from the device coordinate system into GDI's logical coordinate system.","pos":[59557,59701]},{"content":"The conversion depends on the current mapping mode and the settings of the origins and extents for the device's window and viewport.","pos":[59702,59834]},{"pos":[59876,59891],"content":"CDC::Draw3dRect"},{"content":"Call this member function to draw a three-dimensional rectangle.","pos":[59895,59959]},{"content":"Parameters","pos":[60211,60221]},{"content":"Specifies the bounding rectangle (in logical units).","pos":[60237,60289]},{"content":"You can pass either a pointer to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure or a <bpt id=\"p2\">[</bpt>CRect<ept id=\"p2\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object for this parameter.","pos":[60290,60468],"source":" You can pass either a pointer to a [RECT](../../mfc/reference/rect-structure1.md) structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter."},{"content":"clrTopLeft","pos":[60476,60486]},{"content":"Specifies the color of the top and left sides of the three-dimensional rectangle.","pos":[60491,60572]},{"content":"Specifies the color of the bottom and right sides of the three-dimensional rectangle.","pos":[60599,60684]},{"content":"x","pos":[60692,60693]},{"content":"Specifies the logical x-coordinate of the upper-left corner of the three-dimensional rectangle.","pos":[60698,60793]},{"content":"y","pos":[60801,60802]},{"content":"Specifies the logical y-coordinate of the upper-left corner of the three-dimensional rectangle.","pos":[60807,60902]},{"content":"cx","pos":[60909,60911]},{"content":"Specifies the width of the three-dimensional rectangle.","pos":[60915,60970]},{"content":"cy","pos":[60977,60979]},{"content":"Specifies the height of the three-dimensional rectangle.","pos":[60983,61039]},{"content":"Remarks","pos":[61049,61056]},{"pos":[61060,61229],"content":"The rectangle will be drawn with the top and left sides in the color specified by <bpt id=\"p1\">*</bpt>clrTopLeft<ept id=\"p1\">*</ept> and the bottom and right sides in the color specified by <ph id=\"ph1\">`clrBottomRight`</ph>.","source":"The rectangle will be drawn with the top and left sides in the color specified by *clrTopLeft* and the bottom and right sides in the color specified by `clrBottomRight`."},{"content":"Example","pos":[61239,61246]},{"pos":[61261,61278],"content":"NVC_MFCDocView#33"},{"pos":[61367,61384],"content":"CDC::DrawDragRect"},{"content":"Call this member function repeatedly to redraw a drag rectangle.","pos":[61388,61452]},{"content":"Parameters","pos":[61643,61653]},{"content":"Points to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure or a <bpt id=\"p2\">[</bpt>CRect<ept id=\"p2\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object that specifies the logical coordinates of a rectangle — in this case, the end position of the rectangle being redrawn.","pos":[61669,61923],"source":" Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object that specifies the logical coordinates of a rectangle — in this case, the end position of the rectangle being redrawn."},{"content":"Specifies the displacement from the top-left corner of the outer border to the top-left corner of the inner border (that is, the thickness of the border) of a rectangle.","pos":[61940,62109]},{"content":"Points to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure or a <bpt id=\"p2\">[</bpt>CRect<ept id=\"p2\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object that specifies the logical coordinates of the position of a rectangle — in this case, the original position of the rectangle being redrawn.","pos":[62132,62407],"source":" Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object that specifies the logical coordinates of the position of a rectangle — in this case, the original position of the rectangle being redrawn."},{"content":"sizeLast","pos":[62415,62423]},{"content":"Specifies the displacement from the top-left corner of the outer border to the top-left corner of the inner border (that is, the thickness of the border) of the original rectangle being redrawn.","pos":[62428,62622]},{"content":"Pointer to a brush object.","pos":[62641,62667]},{"content":"Set to <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> to use the default halftone brush.","pos":[62668,62718],"source":" Set to **NULL** to use the default halftone brush."},{"content":"pBrushLast","pos":[62726,62736]},{"content":"Pointer to the last brush object used.","pos":[62741,62779]},{"content":"Set to <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> to use the default halftone brush.","pos":[62780,62830],"source":" Set to **NULL** to use the default halftone brush."},{"content":"Remarks","pos":[62840,62847]},{"content":"Call it in a loop as you sample mouse position, in order to give visual feedback.","pos":[62851,62932]},{"content":"When you call <ph id=\"ph1\">`DrawDragRect`</ph>, the previous rectangle is erased and a new one is drawn.","pos":[62933,63019],"source":" When you call `DrawDragRect`, the previous rectangle is erased and a new one is drawn."},{"content":"For example, as the user drags a rectangle across the screen, <ph id=\"ph1\">`DrawDragRect`</ph> will erase the original rectangle and redraw a new one in its new position.","pos":[63020,63172],"source":" For example, as the user drags a rectangle across the screen, `DrawDragRect` will erase the original rectangle and redraw a new one in its new position."},{"content":"By default, <ph id=\"ph1\">`DrawDragRect`</ph> draws the rectangle by using a halftone brush to eliminate flicker and to create the appearance of a smoothly moving rectangle.","pos":[63173,63327],"source":" By default, `DrawDragRect` draws the rectangle by using a halftone brush to eliminate flicker and to create the appearance of a smoothly moving rectangle."},{"pos":[63334,63420],"content":"The first time you call <ph id=\"ph1\">`DrawDragRect`</ph>, the <ph id=\"ph2\">`lpRectLast`</ph> parameter should be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"The first time you call `DrawDragRect`, the `lpRectLast` parameter should be **NULL**."},{"pos":[63460,63473],"content":"CDC::DrawEdge"},{"content":"Call this member function to draw the edges of a rectangle of the specified type and style.","pos":[63477,63568]},{"content":"Parameters","pos":[63665,63675]},{"content":"A pointer to a <bpt id=\"p1\">**</bpt>RECT<ept id=\"p1\">**</ept> structure that contains the logical coordinates of the rectangle.","pos":[63691,63780],"source":" A pointer to a **RECT** structure that contains the logical coordinates of the rectangle."},{"content":"nEdge","pos":[63788,63793]},{"content":"Specifies the type of inner and outer edge to draw.","pos":[63798,63849]},{"content":"This parameter must be a combination of one inner-border flag and one outer-border flag.","pos":[63850,63938]},{"content":"See <bpt id=\"p1\">[</bpt>DrawEdge<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162477)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph> for a table of the parameter's types.","pos":[63939,64110],"source":" See [DrawEdge](http://msdn.microsoft.com/library/windows/desktop/dd162477) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a table of the parameter's types."},{"content":"The flags that specify the type of border to be drawn.","pos":[64129,64183]},{"content":"See <ph id=\"ph1\">`DrawEdge`</ph> in the <ph id=\"ph2\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph> for a table of the parameter's values.","pos":[64184,64296],"source":" See `DrawEdge` in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a table of the parameter's values."},{"content":"For diagonal lines, the <bpt id=\"p1\">**</bpt>BF_RECT<ept id=\"p1\">**</ept> flags specify the end point of the vector bounded by the rectangle parameter.","pos":[64297,64410],"source":" For diagonal lines, the **BF_RECT** flags specify the end point of the vector bounded by the rectangle parameter."},{"content":"Return Value","pos":[64420,64432]},{"content":"Nonzero if successful; otherwise 0.","pos":[64436,64471]},{"pos":[64513,64528],"content":"CDC::DrawEscape"},{"content":"Accesses drawing capabilities of a video display that are not directly available through the graphics device interface (GDI).","pos":[64532,64657]},{"content":"Parameters","pos":[64766,64776]},{"content":"Specifies the escape function to be performed.","pos":[64793,64839]},{"content":"Specifies the number of bytes of data pointed to by the <ph id=\"ph1\">`lpszInputData`</ph> parameter.","pos":[64862,64944],"source":" Specifies the number of bytes of data pointed to by the `lpszInputData` parameter."},{"content":"Points to the input structure required for the specified escape.","pos":[64970,65034]},{"content":"Return Value","pos":[65044,65056]},{"content":"Specifies the outcome of the function.","pos":[65060,65098]},{"content":"Greater than zero if successful, except for the <bpt id=\"p1\">**</bpt>QUERYESCSUPPORT<ept id=\"p1\">**</ept> draw escape, which checks for implementation only; or zero if the escape is not implemented; or less than zero if an error occurred.","pos":[65099,65299],"source":" Greater than zero if successful, except for the **QUERYESCSUPPORT** draw escape, which checks for implementation only; or zero if the escape is not implemented; or less than zero if an error occurred."},{"content":"Remarks","pos":[65309,65316]},{"pos":[65320,65467],"content":"When an application calls <ph id=\"ph1\">`DrawEscape`</ph>, the data identified by <ph id=\"ph2\">`nInputSize`</ph> and <ph id=\"ph3\">`lpszInputData`</ph> is passed directly to the specified display driver.","source":"When an application calls `DrawEscape`, the data identified by `nInputSize` and `lpszInputData` is passed directly to the specified display driver."},{"pos":[65512,65530],"content":"CDC::DrawFocusRect"},{"content":"Draws a rectangle in the style used to indicate that the rectangle has the focus.","pos":[65534,65615]},{"content":"Parameters","pos":[65676,65686]},{"content":"Points to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure or a <bpt id=\"p2\">[</bpt>CRect<ept id=\"p2\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object that specifies the logical coordinates of the rectangle to be drawn.","pos":[65702,65906],"source":" Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object that specifies the logical coordinates of the rectangle to be drawn."},{"content":"Remarks","pos":[65916,65923]},{"content":"Since this is a Boolean XOR function, calling this function a second time with the same rectangle removes the rectangle from the display.","pos":[65927,66064]},{"content":"The rectangle drawn by this function cannot be scrolled.","pos":[66065,66121]},{"content":"To scroll an area containing a rectangle drawn by this function, first call <ph id=\"ph1\">`DrawFocusRect`</ph> to remove the rectangle from the display, then scroll the area, and then call <ph id=\"ph2\">`DrawFocusRect`</ph> again to draw the rectangle in the new position.","pos":[66122,66356],"source":" To scroll an area containing a rectangle drawn by this function, first call `DrawFocusRect` to remove the rectangle from the display, then scroll the area, and then call `DrawFocusRect` again to draw the rectangle in the new position."},{"pos":[66364,66534],"content":"[!CAUTION]\n`DrawFocusRect` works only in `MM_TEXT` mode. In other modes, this function does not draw the focus rectangle correctly, but it does not return error values.","leadings":["","> "],"nodes":[{"content":" works only in `MM_TEXT` mode. In other modes, this function does not draw the focus rectangle correctly, but it does not return error values.","pos":[26,168],"nodes":[{"content":"works only in <ph id=\"ph1\">`MM_TEXT`</ph> mode.","pos":[1,30],"source":" works only in `MM_TEXT` mode."},{"content":"In other modes, this function does not draw the focus rectangle correctly, but it does not return error values.","pos":[31,142]}]}]},{"pos":[66582,66603],"content":"CDC::DrawFrameControl"},{"content":"Call this member function to draw a frame control of the specified type and style.","pos":[66607,66689]},{"content":"Parameters","pos":[66794,66804]},{"content":"A pointer to a <bpt id=\"p1\">**</bpt>RECT<ept id=\"p1\">**</ept> structure that contains the logical coordinates of the rectangle.","pos":[66820,66909],"source":" A pointer to a **RECT** structure that contains the logical coordinates of the rectangle."},{"content":"Specifies the type of frame control to draw.","pos":[66927,66971]},{"content":"See the <bpt id=\"p1\">*</bpt>uType<ept id=\"p1\">*</ept> parameter in <bpt id=\"p2\">[</bpt>DrawFrameControl<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/dd162480)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph> for a list of this parameter's possible values.","pos":[66972,67186],"source":" See the *uType* parameter in [DrawFrameControl](http://msdn.microsoft.com/library/windows/desktop/dd162480) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a list of this parameter's possible values."},{"content":"Specifies the initial state of the frame control.","pos":[67205,67254]},{"content":"Can be one or more of the values described for the <bpt id=\"p1\">*</bpt>uState<ept id=\"p1\">*</ept> parameter in <ph id=\"ph1\">`DrawFrameControl`</ph> in the <ph id=\"ph2\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[67255,67406],"source":" Can be one or more of the values described for the *uState* parameter in `DrawFrameControl` in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"Use the <ph id=\"ph1\">`nState`</ph> value <bpt id=\"p1\">**</bpt>DFCS_ADJUSTRECT<ept id=\"p1\">**</ept> to adjust the bounding rectangle to exclude the surrounding edge of the push button.","pos":[67407,67534],"source":" Use the `nState` value **DFCS_ADJUSTRECT** to adjust the bounding rectangle to exclude the surrounding edge of the push button."},{"content":"Return Value","pos":[67544,67556]},{"content":"Nonzero if successful; otherwise 0.","pos":[67560,67595]},{"content":"Remarks","pos":[67605,67612]},{"content":"In several cases, <ph id=\"ph1\">`nState`</ph> depends on the <ph id=\"ph2\">`nType`</ph> parameter.","pos":[67616,67676],"source":"In several cases, `nState` depends on the `nType` parameter."},{"content":"The following list shows the relationship between the four <ph id=\"ph1\">`nType`</ph> values and <ph id=\"ph2\">`nState`</ph>:","pos":[67677,67764],"source":" The following list shows the relationship between the four `nType` values and `nState`:"},{"content":"DFC_BUTTON","pos":[67774,67784]},{"pos":[67798,67838],"content":"<bpt id=\"p1\">**</bpt>DFCS_BUTTON3STATE<ept id=\"p1\">**</ept> Three-state button","source":"**DFCS_BUTTON3STATE** Three-state button"},{"pos":[67850,67880],"content":"<bpt id=\"p1\">**</bpt>DFCS_BUTTONCHECK<ept id=\"p1\">**</ept> Check box","source":"**DFCS_BUTTONCHECK** Check box"},{"pos":[67892,67923],"content":"<bpt id=\"p1\">**</bpt>DFCS_BUTTONPUSH<ept id=\"p1\">**</ept> Push button","source":"**DFCS_BUTTONPUSH** Push button"},{"pos":[67935,67968],"content":"<bpt id=\"p1\">**</bpt>DFCS_BUTTONRADIO<ept id=\"p1\">**</ept> Radio button","source":"**DFCS_BUTTONRADIO** Radio button"},{"pos":[67980,68052],"content":"<bpt id=\"p1\">**</bpt>DFCS_BUTTONRADIOIMAGE<ept id=\"p1\">**</ept> Image for radio button (nonsquare needs image)","source":"**DFCS_BUTTONRADIOIMAGE** Image for radio button (nonsquare needs image)"},{"pos":[68064,68133],"content":"<bpt id=\"p1\">**</bpt>DFCS_BUTTONRADIOMASK<ept id=\"p1\">**</ept> Mask for radio button (nonsquare needs mask)","source":"**DFCS_BUTTONRADIOMASK** Mask for radio button (nonsquare needs mask)"},{"content":"DFC_CAPTION","pos":[68143,68154]},{"pos":[68168,68202],"content":"<bpt id=\"p1\">**</bpt>DFCS_CAPTIONCLOSE<ept id=\"p1\">**</ept> Close button","source":"**DFCS_CAPTIONCLOSE** Close button"},{"pos":[68214,68246],"content":"<bpt id=\"p1\">**</bpt>DFCS_CAPTIONHELP<ept id=\"p1\">**</ept> Help button","source":"**DFCS_CAPTIONHELP** Help button"},{"pos":[68258,68293],"content":"<bpt id=\"p1\">**</bpt>DFCS_CAPTIONMAX<ept id=\"p1\">**</ept> Maximize button","source":"**DFCS_CAPTIONMAX** Maximize button"},{"pos":[68305,68340],"content":"<bpt id=\"p1\">**</bpt>DFCS_CAPTIONMIN<ept id=\"p1\">**</ept> Minimize button","source":"**DFCS_CAPTIONMIN** Minimize button"},{"pos":[68352,68390],"content":"<bpt id=\"p1\">**</bpt>DFCS_CAPTIONRESTORE<ept id=\"p1\">**</ept> Restore button","source":"**DFCS_CAPTIONRESTORE** Restore button"},{"content":"DFC_MENU","pos":[68400,68408]},{"pos":[68422,68454],"content":"<bpt id=\"p1\">**</bpt>DFCS_MENUARROW<ept id=\"p1\">**</ept> Submenu arrow","source":"**DFCS_MENUARROW** Submenu arrow"},{"pos":[68466,68492],"content":"<bpt id=\"p1\">**</bpt>DFCS_MENUBULLET<ept id=\"p1\">**</ept> Bullet","source":"**DFCS_MENUBULLET** Bullet"},{"pos":[68504,68533],"content":"<bpt id=\"p1\">**</bpt>DFCS_MENUCHECK<ept id=\"p1\">**</ept> Check mark","source":"**DFCS_MENUCHECK** Check mark"},{"content":"DFC_SCROLL","pos":[68543,68553]},{"pos":[68567,68611],"content":"<bpt id=\"p1\">**</bpt>DFCS_SCROLLCOMBOBOX<ept id=\"p1\">**</ept> Combo box scroll bar","source":"**DFCS_SCROLLCOMBOBOX** Combo box scroll bar"},{"pos":[68623,68667],"content":"<bpt id=\"p1\">**</bpt>DFCS_SCROLLDOWN<ept id=\"p1\">**</ept> Down arrow of scroll bar","source":"**DFCS_SCROLLDOWN** Down arrow of scroll bar"},{"pos":[68679,68723],"content":"<bpt id=\"p1\">**</bpt>DFCS_SCROLLLEFT<ept id=\"p1\">**</ept> Left arrow of scroll bar","source":"**DFCS_SCROLLLEFT** Left arrow of scroll bar"},{"pos":[68735,68781],"content":"<bpt id=\"p1\">**</bpt>DFCS_SCROLLRIGHT<ept id=\"p1\">**</ept> Right arrow of scroll bar","source":"**DFCS_SCROLLRIGHT** Right arrow of scroll bar"},{"pos":[68793,68859],"content":"<bpt id=\"p1\">**</bpt>DFCS_SCROLLSIZEGRIP<ept id=\"p1\">**</ept> Size grip in bottom-right corner of window","source":"**DFCS_SCROLLSIZEGRIP** Size grip in bottom-right corner of window"},{"pos":[68871,68911],"content":"<bpt id=\"p1\">**</bpt>DFCS_SCROLLUP<ept id=\"p1\">**</ept> Up arrow of scroll bar","source":"**DFCS_SCROLLUP** Up arrow of scroll bar"},{"content":"Example","pos":[68921,68928]},{"content":"This code draws the size gripper in the bottom-right corner of your window.","pos":[68932,69007]},{"content":"It's appropriate for the <ph id=\"ph1\">`OnPaint`</ph> handler of a dialog box, which has no styles and normally doesn't contain other controls (like a status bar) that may give it a size gripper.","pos":[69008,69184],"source":" It's appropriate for the `OnPaint` handler of a dialog box, which has no styles and normally doesn't contain other controls (like a status bar) that may give it a size gripper."},{"pos":[69202,69219],"content":"NVC_MFCDocView#34"},{"pos":[69304,69317],"content":"CDC::DrawIcon"},{"pos":[69321,69389],"content":"Draws an icon on the device represented by the current <ph id=\"ph1\">`CDC`</ph> object.","source":"Draws an icon on the device represented by the current `CDC` object."},{"content":"Parameters","pos":[69528,69538]},{"content":"x","pos":[69543,69544]},{"content":"Specifies the logical x-coordinate of the upper-left corner of the icon.","pos":[69549,69621]},{"content":"y","pos":[69629,69630]},{"content":"Specifies the logical y-coordinate of the upper-left corner of the icon.","pos":[69635,69707]},{"content":"Identifies the handle of the icon to be drawn.","pos":[69725,69771]},{"content":"Specifies the logical x- and y-coordinates of the upper-left corner of the icon.","pos":[69789,69869]},{"content":"You can pass a <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> structure or a <bpt id=\"p2\">[</bpt>CPoint<ept id=\"p2\">](../../atl-mfc-shared/reference/cpoint-class.md)</ept> object for this parameter.","pos":[69870,70032],"source":" You can pass a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter."},{"content":"Return Value","pos":[70042,70054]},{"content":"Nonzero if the function completed successfully; otherwise 0.","pos":[70058,70118]},{"content":"Remarks","pos":[70128,70135]},{"content":"The function places the icon's upper-left corner at the location specified by <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept>.","pos":[70139,70229],"source":"The function places the icon's upper-left corner at the location specified by *x* and *y*."},{"content":"The location is subject to the current mapping mode of the device context.","pos":[70230,70304]},{"content":"The icon resource must have been previously loaded by using the functions <ph id=\"ph1\">`CWinApp::LoadIcon`</ph>, <ph id=\"ph2\">`CWinApp::LoadStandardIcon`</ph>, or <ph id=\"ph3\">`CWinApp::LoadOEMIcon`</ph>.","pos":[70311,70461],"source":"The icon resource must have been previously loaded by using the functions `CWinApp::LoadIcon`, `CWinApp::LoadStandardIcon`, or `CWinApp::LoadOEMIcon`."},{"content":"The <ph id=\"ph1\">`MM_TEXT`</ph> mapping mode must be selected prior to using this function.","pos":[70462,70535],"source":" The `MM_TEXT` mapping mode must be selected prior to using this function."},{"content":"Example","pos":[70545,70552]},{"pos":[70557,70644],"content":"See the example for <bpt id=\"p1\">[</bpt>CWnd::IsIconic<ept id=\"p1\">](../../mfc/reference/cwnd-class.md#cwnd__isiconic)</ept>.","source":"See the example for [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#cwnd__isiconic)."},{"pos":[70685,70699],"content":"CDC::DrawState"},{"content":"Call this member function to display an image and apply a visual effect to indicate a state, such as a disabled or default state.","pos":[70703,70832]},{"pos":[70840,70970],"content":"[!NOTE]\n For all `nFlag` states except **DSS_NORMAL**, the image is converted to monochrome before the visual effect is applied.","leadings":["","> "],"nodes":[{"content":"For all <ph id=\"ph1\">`nFlag`</ph> states except <bpt id=\"p1\">**</bpt>DSS_NORMAL<ept id=\"p1\">**</ept>, the image is converted to monochrome before the visual effect is applied.","pos":[9,128],"source":" For all `nFlag` states except **DSS_NORMAL**, the image is converted to monochrome before the visual effect is applied."}]},{"content":"Parameters","pos":[72143,72153]},{"content":"Specifies the location of the image.","pos":[72165,72201]},{"content":"Specifies the size of the image.","pos":[72218,72250]},{"content":"A handle to a bitmap.","pos":[72270,72291]},{"content":"Flags that specify the image type and state.","pos":[72310,72354]},{"content":"See <bpt id=\"p1\">[</bpt>DrawState<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162496)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph> for the possible <ph id=\"ph2\">`nFlags`</ph> types and states.","pos":[72355,72533],"source":" See [DrawState](http://msdn.microsoft.com/library/windows/desktop/dd162496) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for the possible `nFlags` types and states."},{"content":"A handle to a brush.","pos":[72552,72572]},{"content":"A pointer to a CBitmap object.","pos":[72592,72622]},{"content":"A pointer to a CBrush object.","pos":[72641,72670]},{"content":"A handle to an icon.","pos":[72688,72708]},{"content":"A pointer to text.","pos":[72729,72747]},{"content":"bPrefixText","pos":[72755,72766]},{"content":"Text that may contain an accelerator mnemonic.","pos":[72771,72817]},{"content":"The <ph id=\"ph1\">`lData`</ph> parameter specifies the address of the string, and the <ph id=\"ph2\">`nTextLen`</ph> parameter specifies the length.","pos":[72818,72927],"source":" The `lData` parameter specifies the address of the string, and the `nTextLen` parameter specifies the length."},{"content":"If <ph id=\"ph1\">`nTextLen`</ph> is 0, the string is assumed to be null-terminated.","pos":[72928,72992],"source":" If `nTextLen` is 0, the string is assumed to be null-terminated."},{"content":"Length of the text string pointed to by <ph id=\"ph1\">`lpszText`</ph>.","pos":[73013,73064],"source":" Length of the text string pointed to by `lpszText`."},{"content":"If <ph id=\"ph1\">`nTextLen`</ph> is 0, the string is assumed to be null-terminated.","pos":[73065,73129],"source":" If `nTextLen` is 0, the string is assumed to be null-terminated."},{"content":"lpDrawProc","pos":[73137,73147]},{"content":"A pointer to a callback function used to render an image.","pos":[73152,73209]},{"content":"This parameter is required if the image type in <ph id=\"ph1\">`nFlags`</ph> is <bpt id=\"p1\">**</bpt>DST_COMPLEX<ept id=\"p1\">**</ept>.","pos":[73210,73286],"source":" This parameter is required if the image type in `nFlags` is **DST_COMPLEX**."},{"content":"It is optional and can be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if the image type is <bpt id=\"p2\">**</bpt>DST_TEXT<ept id=\"p2\">**</ept>.","pos":[73287,73356],"source":" It is optional and can be **NULL** if the image type is **DST_TEXT**."},{"content":"For all other image types, this parameter is ignored.","pos":[73357,73410]},{"content":"For more information about the callback function, see the <bpt id=\"p1\">[</bpt>DrawStateProc<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162497)</ept> function in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[73411,73613],"source":" For more information about the callback function, see the [DrawStateProc](http://msdn.microsoft.com/library/windows/desktop/dd162497) function in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"Specifies information about the image.","pos":[73631,73669]},{"content":"The meaning of this parameter depends on the image type.","pos":[73670,73726]},{"content":"Return Value","pos":[73736,73748]},{"content":"Nonzero if successful; otherwise 0.","pos":[73752,73787]},{"pos":[73827,73840],"content":"CDC::DrawText"},{"content":"Call this member function to format text in the given rectangle.","pos":[73844,73908]},{"content":"To specify additional formatting options, use <bpt id=\"p1\">[</bpt>CDC::DrawTextEx<ept id=\"p1\">](#cdc__drawtextex)</ept>.","pos":[73909,73991],"source":" To specify additional formatting options, use [CDC::DrawTextEx](#cdc__drawtextex)."},{"content":"Parameters","pos":[74205,74215]},{"content":"Points to the string to be drawn.","pos":[74235,74268]},{"content":"If <ph id=\"ph1\">`nCount`</ph> is –1, the string must be null-terminated.","pos":[74269,74323],"source":" If `nCount` is –1, the string must be null-terminated."},{"content":"Specifies the number of chars in the string.","pos":[74342,74386]},{"content":"If <ph id=\"ph1\">`nCount`</ph> is –1, then <ph id=\"ph2\">`lpszString`</ph> is assumed to be a long pointer to a null-terminated string and <ph id=\"ph3\">`DrawText`</ph> computes the character count automatically.","pos":[74387,74542],"source":" If `nCount` is –1, then `lpszString` is assumed to be a long pointer to a null-terminated string and `DrawText` computes the character count automatically."},{"content":"Points to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure or <bpt id=\"p2\">[</bpt>CRect<ept id=\"p2\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object that contains the rectangle (in logical coordinates) in which the text is to be formatted.","pos":[74561,74785],"source":" Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or [CRect](../../atl-mfc-shared/reference/crect-class.md) object that contains the rectangle (in logical coordinates) in which the text is to be formatted."},{"content":"A <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object that contains the specified characters to be drawn.","pos":[74801,74921],"source":" A [CString](../../atl-mfc-shared/reference/cstringt-class.md) object that contains the specified characters to be drawn."},{"content":"Specifies the method of formatting the text.","pos":[74941,74985]},{"content":"It can be any combination of the values described for the <ph id=\"ph1\">`uFormat`</ph> parameter in <bpt id=\"p1\">[</bpt>DrawText<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162498)</ept> in the <ph id=\"ph2\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[74986,75197],"source":" It can be any combination of the values described for the `uFormat` parameter in [DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"(combine using the bitwise OR operator):","pos":[75198,75238]},{"pos":[75246,75640],"content":"[!NOTE]\n Some `uFormat` flag combinations can cause the passed string to be modified. Using **DT_MODIFYSTRING** with either **DT_END_ELLIPSIS** or **DT_PATH_ELLIPSIS** may cause the string to be modified, causing an assertion in the `CString` override. The values `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, and `DT_NOPREFIX` cannot be used with the `DT_TABSTOP` value.","leadings":["","> "],"nodes":[{"content":" Some `uFormat` flag combinations can cause the passed string to be modified. Using **DT_MODIFYSTRING** with either **DT_END_ELLIPSIS** or **DT_PATH_ELLIPSIS** may cause the string to be modified, causing an assertion in the `CString` override. The values `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, and `DT_NOPREFIX` cannot be used with the `DT_TABSTOP` value.","pos":[8,392],"nodes":[{"content":"Some <ph id=\"ph1\">`uFormat`</ph> flag combinations can cause the passed string to be modified.","pos":[1,77],"source":" Some `uFormat` flag combinations can cause the passed string to be modified."},{"content":"Using <bpt id=\"p1\">**</bpt>DT_MODIFYSTRING<ept id=\"p1\">**</ept> with either <bpt id=\"p2\">**</bpt>DT_END_ELLIPSIS<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>DT_PATH_ELLIPSIS<ept id=\"p3\">**</ept> may cause the string to be modified, causing an assertion in the <ph id=\"ph1\">`CString`</ph> override.","pos":[78,244],"source":" Using **DT_MODIFYSTRING** with either **DT_END_ELLIPSIS** or **DT_PATH_ELLIPSIS** may cause the string to be modified, causing an assertion in the `CString` override."},{"content":"The values <ph id=\"ph1\">`DT_CALCRECT`</ph>, <ph id=\"ph2\">`DT_EXTERNALLEADING`</ph>, <bpt id=\"p1\">**</bpt>DT_INTERNAL<ept id=\"p1\">**</ept>, <ph id=\"ph3\">`DT_NOCLIP`</ph>, and <ph id=\"ph4\">`DT_NOPREFIX`</ph> cannot be used with the <ph id=\"ph5\">`DT_TABSTOP`</ph> value.","pos":[245,384],"source":" The values `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, and `DT_NOPREFIX` cannot be used with the `DT_TABSTOP` value."}]}]},{"content":"Return Value","pos":[75650,75662]},{"content":"The height of the text if the function is successful.","pos":[75666,75719]},{"content":"Remarks","pos":[75729,75736]},{"content":"It formats text by expanding tabs into appropriate spaces, aligning text to the left, right, or center of the given rectangle, and breaking text into lines that fit within the given rectangle.","pos":[75740,75932]},{"content":"The type of formatting is specified by <ph id=\"ph1\">`nFormat`</ph>.","pos":[75933,75982],"source":" The type of formatting is specified by `nFormat`."},{"content":"This member function uses the device context's selected font, text color, and background color to draw the text.","pos":[75989,76101]},{"content":"Unless the <ph id=\"ph1\">`DT_NOCLIP`</ph> format is used, <ph id=\"ph2\">`DrawText`</ph> clips the text so that the text does not appear outside the given rectangle.","pos":[76102,76228],"source":" Unless the `DT_NOCLIP` format is used, `DrawText` clips the text so that the text does not appear outside the given rectangle."},{"content":"All formatting is assumed to have multiple lines unless the <ph id=\"ph1\">`DT_SINGLELINE`</ph> format is given.","pos":[76229,76321],"source":" All formatting is assumed to have multiple lines unless the `DT_SINGLELINE` format is given."},{"pos":[76328,76468],"content":"If the selected font is too large for the specified rectangle, the <ph id=\"ph1\">`DrawText`</ph> member function does not attempt to substitute a smaller font.","source":"If the selected font is too large for the specified rectangle, the `DrawText` member function does not attempt to substitute a smaller font."},{"pos":[76475,76623],"content":"If the <ph id=\"ph1\">`DT_CALCRECT`</ph> flag is specified, the rectangle specified by <ph id=\"ph2\">`lpRect`</ph> will be updated to reflect the width and height needed to draw the text.","source":"If the `DT_CALCRECT` flag is specified, the rectangle specified by `lpRect` will be updated to reflect the width and height needed to draw the text."},{"content":"If the <bpt id=\"p1\">**</bpt>TA_UPDATECP<ept id=\"p1\">**</ept> text-alignment flag has been set (see <bpt id=\"p2\">[</bpt>CDC::SetTextAlign<ept id=\"p2\">](#cdc__settextalign)</ept>), <ph id=\"ph1\">`DrawText`</ph> will display text starting at the current position, rather than at the left of the given rectangle.","pos":[76630,76843],"source":"If the **TA_UPDATECP** text-alignment flag has been set (see [CDC::SetTextAlign](#cdc__settextalign)), `DrawText` will display text starting at the current position, rather than at the left of the given rectangle."},{"content":"will not wrap text when the <bpt id=\"p1\">**</bpt>TA_UPDATECP<ept id=\"p1\">**</ept> flag has been set (that is, the <ph id=\"ph1\">`DT_WORDBREAK`</ph> flag will have no effect).","pos":[76855,76972],"source":" will not wrap text when the **TA_UPDATECP** flag has been set (that is, the `DT_WORDBREAK` flag will have no effect)."},{"pos":[76979,77048],"content":"The text color may be set by <bpt id=\"p1\">[</bpt>CDC::SetTextColor<ept id=\"p1\">](#cdc__settextcolor)</ept>.","source":"The text color may be set by [CDC::SetTextColor](#cdc__settextcolor)."},{"pos":[77090,77105],"content":"CDC::DrawTextEx"},{"content":"Formats text in the given rectangle.","pos":[77109,77145]},{"content":"Parameters","pos":[77428,77438]},{"content":"Points to the string to be drawn.","pos":[77458,77491]},{"content":"If <ph id=\"ph1\">`nCount`</ph> is –1, the string must be null terminated.","pos":[77492,77546],"source":" If `nCount` is –1, the string must be null terminated."},{"content":"Specifies the number of chars in the string.","pos":[77565,77609]},{"content":"If <ph id=\"ph1\">`nCount`</ph> is –1, then <ph id=\"ph2\">`lpszString`</ph> is assumed to be a long pointer to a null-terminated string and <ph id=\"ph3\">`DrawText`</ph> computes the character count automatically.","pos":[77610,77765],"source":" If `nCount` is –1, then `lpszString` is assumed to be a long pointer to a null-terminated string and `DrawText` computes the character count automatically."},{"content":"Points to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure or <bpt id=\"p2\">[</bpt>CRect<ept id=\"p2\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object that contains the rectangle (in logical coordinates) in which the text is to be formatted.","pos":[77784,78008],"source":" Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or [CRect](../../atl-mfc-shared/reference/crect-class.md) object that contains the rectangle (in logical coordinates) in which the text is to be formatted."},{"content":"A <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object that contains the specified characters to be drawn.","pos":[78024,78144],"source":" A [CString](../../atl-mfc-shared/reference/cstringt-class.md) object that contains the specified characters to be drawn."},{"content":"Specifies the method of formatting the text.","pos":[78164,78208]},{"content":"It can be any combination of the values described for the <ph id=\"ph1\">`uFormat`</ph> parameter in <bpt id=\"p1\">[</bpt>DrawText<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162498)</ept> in the <ph id=\"ph2\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[78209,78420],"source":" It can be any combination of the values described for the `uFormat` parameter in [DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"(Combine using the bitwise <ph id=\"ph1\">`OR`</ph> operator):","pos":[78421,78463],"source":" (Combine using the bitwise `OR` operator):"},{"pos":[78471,78865],"content":"[!NOTE]\n Some `uFormat` flag combinations can cause the passed string to be modified. Using **DT_MODIFYSTRING** with either **DT_END_ELLIPSIS** or **DT_PATH_ELLIPSIS** may cause the string to be modified, causing an assertion in the `CString` override. The values `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, and `DT_NOPREFIX` cannot be used with the `DT_TABSTOP` value.","leadings":["","> "],"nodes":[{"content":" Some `uFormat` flag combinations can cause the passed string to be modified. Using **DT_MODIFYSTRING** with either **DT_END_ELLIPSIS** or **DT_PATH_ELLIPSIS** may cause the string to be modified, causing an assertion in the `CString` override. The values `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, and `DT_NOPREFIX` cannot be used with the `DT_TABSTOP` value.","pos":[8,392],"nodes":[{"content":"Some <ph id=\"ph1\">`uFormat`</ph> flag combinations can cause the passed string to be modified.","pos":[1,77],"source":" Some `uFormat` flag combinations can cause the passed string to be modified."},{"content":"Using <bpt id=\"p1\">**</bpt>DT_MODIFYSTRING<ept id=\"p1\">**</ept> with either <bpt id=\"p2\">**</bpt>DT_END_ELLIPSIS<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>DT_PATH_ELLIPSIS<ept id=\"p3\">**</ept> may cause the string to be modified, causing an assertion in the <ph id=\"ph1\">`CString`</ph> override.","pos":[78,244],"source":" Using **DT_MODIFYSTRING** with either **DT_END_ELLIPSIS** or **DT_PATH_ELLIPSIS** may cause the string to be modified, causing an assertion in the `CString` override."},{"content":"The values <ph id=\"ph1\">`DT_CALCRECT`</ph>, <ph id=\"ph2\">`DT_EXTERNALLEADING`</ph>, <bpt id=\"p1\">**</bpt>DT_INTERNAL<ept id=\"p1\">**</ept>, <ph id=\"ph3\">`DT_NOCLIP`</ph>, and <ph id=\"ph4\">`DT_NOPREFIX`</ph> cannot be used with the <ph id=\"ph5\">`DT_TABSTOP`</ph> value.","pos":[245,384],"source":" The values `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, and `DT_NOPREFIX` cannot be used with the `DT_TABSTOP` value."}]}]},{"content":"Pointer to a <bpt id=\"p1\">[</bpt>DRAWTEXTPARAMS<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162500)</ept> structure that specifies additional formatting options.","pos":[78888,79033],"source":" Pointer to a [DRAWTEXTPARAMS](http://msdn.microsoft.com/library/windows/desktop/dd162500) structure that specifies additional formatting options."},{"content":"This parameter can be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[79034,79065],"source":" This parameter can be **NULL**."},{"content":"Remarks","pos":[79075,79082]},{"content":"It formats text by expanding tabs into appropriate spaces, aligning text to the left, right, or center of the given rectangle, and breaking text into lines that fit within the given rectangle.","pos":[79086,79278]},{"content":"The type of formatting is specified by <ph id=\"ph1\">`nFormat`</ph> and <ph id=\"ph2\">`lpDTParams`</ph>.","pos":[79279,79345],"source":" The type of formatting is specified by `nFormat` and `lpDTParams`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>CDC::DrawText<ept id=\"p1\">](#cdc__drawtext)</ept> and <bpt id=\"p2\">[</bpt>DrawTextEx<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/dd162499)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[79346,79540],"source":" For more information, see [CDC::DrawText](#cdc__drawtext) and [DrawTextEx](http://msdn.microsoft.com/library/windows/desktop/dd162499) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[79547,79616],"content":"The text color may be set by <bpt id=\"p1\">[</bpt>CDC::SetTextColor<ept id=\"p1\">](#cdc__settextcolor)</ept>.","source":"The text color may be set by [CDC::SetTextColor](#cdc__settextcolor)."},{"pos":[79655,79667],"content":"CDC::Ellipse"},{"content":"Draws an ellipse.","pos":[79671,79688]},{"content":"Parameters","pos":[79820,79830]},{"content":"Specifies the logical x-coordinate of the upper-left corner of the ellipse's bounding rectangle.","pos":[79842,79938]},{"content":"Specifies the logical y-coordinate of the upper-left corner of the ellipse's bounding rectangle.","pos":[79953,80049]},{"content":"Specifies the logical x-coordinate of the lower-right corner of the ellipse's bounding rectangle.","pos":[80064,80161]},{"content":"Specifies the logical y-coordinate of the lower-right corner of the ellipse's bounding rectangle.","pos":[80176,80273]},{"content":"Specifies the ellipse's bounding rectangle.","pos":[80292,80335]},{"content":"You can also pass a <bpt id=\"p1\">[</bpt>CRect<ept id=\"p1\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object for this parameter.","pos":[80336,80437],"source":" You can also pass a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter."},{"content":"Return Value","pos":[80447,80459]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[80463,80514]},{"content":"Remarks","pos":[80524,80531]},{"content":"The center of the ellipse is the center of the bounding rectangle specified by <ph id=\"ph1\">`x1`</ph>, <ph id=\"ph2\">`y1`</ph>, <ph id=\"ph3\">`x2`</ph>, and <ph id=\"ph4\">`y2`</ph>, or <ph id=\"ph5\">`lpRect`</ph>.","pos":[80535,80654],"source":"The center of the ellipse is the center of the bounding rectangle specified by `x1`, `y1`, `x2`, and `y2`, or `lpRect`."},{"content":"The ellipse is drawn with the current pen, and its interior is filled with the current brush.","pos":[80655,80748]},{"content":"The figure drawn by this function extends up to, but does not include, the right and bottom coordinates.","pos":[80755,80859]},{"content":"This means that the height of the figure is <ph id=\"ph1\">`y2`</ph> – <ph id=\"ph2\">`y1`</ph> and the width of the figure is <ph id=\"ph3\">`x2`</ph> – <ph id=\"ph4\">`x1`</ph>.","pos":[80860,80959],"source":" This means that the height of the figure is `y2` – `y1` and the width of the figure is `x2` – `x1`."},{"content":"If either the width or the height of the bounding rectangle is 0, no ellipse is drawn.","pos":[80966,81052]},{"pos":[81090,81101],"content":"CDC::EndDoc"},{"pos":[81105,81190],"content":"Ends a print job started by a call to the <bpt id=\"p1\">[</bpt>StartDoc<ept id=\"p1\">](#cdc__startdoc)</ept> member function.","source":"Ends a print job started by a call to the [StartDoc](#cdc__startdoc) member function."},{"content":"Return Value","pos":[81229,81241]},{"content":"Greater than or equal to 0 if the function is successful, or a negative value if an error occurred.","pos":[81245,81344]},{"content":"Remarks","pos":[81354,81361]},{"pos":[81365,81498],"content":"This member function replaces the <bpt id=\"p1\">**</bpt>ENDDOC<ept id=\"p1\">**</ept> printer escape, and should be called immediately after finishing a successful print job.","source":"This member function replaces the **ENDDOC** printer escape, and should be called immediately after finishing a successful print job."},{"content":"If an application encounters a printing error or a canceled print operation, it must not attempt to terminate the operation by using either <ph id=\"ph1\">`EndDoc`</ph> or <bpt id=\"p1\">[</bpt>AbortDoc<ept id=\"p1\">](#cdc__abortdoc)</ept>.","pos":[81505,81684],"source":"If an application encounters a printing error or a canceled print operation, it must not attempt to terminate the operation by using either `EndDoc` or [AbortDoc](#cdc__abortdoc)."},{"content":"GDI automatically terminates the operation before returning the error value.","pos":[81685,81761]},{"content":"This function should not be used inside metafiles.","pos":[81768,81818]},{"content":"Example","pos":[81828,81835]},{"pos":[81840,81892],"content":"See the example for <bpt id=\"p1\">[</bpt>CDC::StartDoc<ept id=\"p1\">](#cdc__startdoc)</ept>.","source":"See the example for [CDC::StartDoc](#cdc__startdoc)."},{"pos":[81931,81943],"content":"CDC::EndPage"},{"content":"Informs the device that the application has finished writing to a page.","pos":[81947,82018]},{"content":"Return Value","pos":[82058,82070]},{"content":"Greater than or equal to 0 if the function is successful, or a negative value if an error occurred.","pos":[82074,82173]},{"content":"Remarks","pos":[82183,82190]},{"content":"This member function is typically used to direct the device driver to advance to a new page.","pos":[82194,82286]},{"content":"This member function replaces the <bpt id=\"p1\">**</bpt>NEWFRAME<ept id=\"p1\">**</ept> printer escape.","pos":[82293,82355],"source":"This member function replaces the **NEWFRAME** printer escape."},{"content":"Unlike <bpt id=\"p1\">**</bpt>NEWFRAME<ept id=\"p1\">**</ept>, this function is always called after printing a page.","pos":[82356,82430],"source":" Unlike **NEWFRAME**, this function is always called after printing a page."},{"content":"Example","pos":[82440,82447]},{"pos":[82452,82504],"content":"See the example for <bpt id=\"p1\">[</bpt>CDC::StartDoc<ept id=\"p1\">](#cdc__startdoc)</ept>.","source":"See the example for [CDC::StartDoc](#cdc__startdoc)."},{"pos":[82543,82555],"content":"CDC::EndPath"},{"content":"Closes a path bracket and selects the path defined by the bracket into the device context.","pos":[82559,82649]},{"content":"Return Value","pos":[82690,82702]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[82706,82757]},{"content":"Example","pos":[82767,82774]},{"pos":[82779,82833],"content":"See the example for <bpt id=\"p1\">[</bpt>CDC::BeginPath<ept id=\"p1\">](#cdc__beginpath)</ept>.","source":"See the example for [CDC::BeginPath](#cdc__beginpath)."},{"pos":[82876,82892],"content":"CDC::EnumObjects"},{"content":"Enumerates the pens and brushes available in a device context.","pos":[82896,82958]},{"content":"Parameters","pos":[83101,83111]},{"content":"nObjectType","pos":[83116,83127]},{"content":"Specifies the object type.","pos":[83132,83158]},{"content":"It can have the values <bpt id=\"p1\">**</bpt>OBJ_BRUSH<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>OBJ_PEN<ept id=\"p2\">**</ept>.","pos":[83159,83211],"source":" It can have the values **OBJ_BRUSH** or **OBJ_PEN**."},{"content":"Is the procedure-instance address of the application-supplied callback function.","pos":[83228,83308]},{"content":"See the \"Remarks\" section below.","pos":[83309,83341]},{"content":"Points to the application-supplied data.","pos":[83360,83400]},{"content":"The data is passed to the callback function along with the object information.","pos":[83401,83479]},{"content":"Return Value","pos":[83489,83501]},{"content":"Specifies the last value returned by the <bpt id=\"p1\">[</bpt>callback function<ept id=\"p1\">](../../mfc/reference/callback-function-for-cdc-enumobjects.md)</ept>.","pos":[83505,83628],"source":"Specifies the last value returned by the [callback function](../../mfc/reference/callback-function-for-cdc-enumobjects.md)."},{"content":"Its meaning is user-defined.","pos":[83629,83657]},{"content":"Remarks","pos":[83667,83674]},{"content":"For each object of a given type, the callback function that you pass is called with the information for that object.","pos":[83678,83794]},{"content":"The system calls the callback function until there are no more objects or the callback function returns 0.","pos":[83795,83901]},{"content":"Note that new features of Microsoft Visual C++ let you use an ordinary function as the function passed to <ph id=\"ph1\">`EnumObjects`</ph>.","pos":[83908,84028],"source":"Note that new features of Microsoft Visual C++ let you use an ordinary function as the function passed to `EnumObjects`."},{"content":"The address passed to <ph id=\"ph1\">`EnumObjects`</ph> is a pointer to a function exported with <bpt id=\"p1\">**</bpt>EXPORT<ept id=\"p1\">**</ept> and with the Pascal calling convention.","pos":[84029,84156],"source":" The address passed to `EnumObjects` is a pointer to a function exported with **EXPORT** and with the Pascal calling convention."},{"content":"In protect-mode applications, you do not have to create this function with the Windows                         MakeProcInstance function or free the function after use with the FreeProcInstance Windows function.","pos":[84157,84368]},{"content":"You also do not have to export the function name in an <bpt id=\"p1\">**</bpt>EXPORTS<ept id=\"p1\">**</ept> statement in your application's module-definition file.","pos":[84375,84497],"source":"You also do not have to export the function name in an **EXPORTS** statement in your application's module-definition file."},{"content":"You can instead use the <bpt id=\"p1\">**</bpt>EXPORT<ept id=\"p1\">**</ept> function modifier, as in","pos":[84498,84557],"source":" You can instead use the **EXPORT** function modifier, as in"},{"pos":[84564,84621],"content":"<bpt id=\"p1\">**</bpt>int CALLBACK EXPORT<ept id=\"p1\">**</ept> AFunction <bpt id=\"p2\">**</bpt>(LPSTR<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>LPSTR);<ept id=\"p3\">**</ept>","source":"**int CALLBACK EXPORT** AFunction **(LPSTR**, **LPSTR);**"},{"content":"to cause the compiler to emit the proper export record for export by name without aliasing.","pos":[84628,84719]},{"content":"This works for most needs.","pos":[84720,84746]},{"content":"For some special cases, such as exporting a function by ordinal or aliasing the export, you still need to use an <bpt id=\"p1\">**</bpt>EXPORTS<ept id=\"p1\">**</ept> statement in a module-definition file.","pos":[84747,84910],"source":" For some special cases, such as exporting a function by ordinal or aliasing the export, you still need to use an **EXPORTS** statement in a module-definition file."},{"content":"For compiling Microsoft Foundation programs, you will normally use the /GA and /GEs compiler options.","pos":[84917,85018]},{"content":"The /Gw compiler option is not used with the Microsoft Foundation classes.","pos":[85019,85093]},{"content":"(If you do use the Windows function <bpt id=\"p1\">**</bpt>MakeProcInstance<ept id=\"p1\">**</ept>, you will need to explicitly cast the returned function pointer from <bpt id=\"p2\">**</bpt>FARPROC<ept id=\"p2\">**</ept> to the type needed in this API.) Callback registration interfaces are now type-safe (you must pass in a function pointer that points to the right kind of function for the specific callback).","pos":[85094,85422],"source":" (If you do use the Windows function **MakeProcInstance**, you will need to explicitly cast the returned function pointer from **FARPROC** to the type needed in this API.) Callback registration interfaces are now type-safe (you must pass in a function pointer that points to the right kind of function for the specific callback)."},{"content":"Also note that all callback functions must trap Microsoft Foundation exceptions before returning to Windows, since exceptions cannot be thrown across callback boundaries.","pos":[85429,85599]},{"content":"For more information about exceptions, see the article <bpt id=\"p1\">[</bpt>Exceptions<ept id=\"p1\">](../../mfc/exception-handling-in-mfc.md)</ept>.","pos":[85600,85708],"source":" For more information about exceptions, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md)."},{"content":"Example","pos":[85718,85725]},{"pos":[85740,85757],"content":"NVC_MFCDocView#35"},{"pos":[85840,85851],"content":"CDC::Escape"},{"content":"This member function is practically obsolete for Win32 programming.","pos":[85855,85922]},{"content":"Parameters","pos":[86186,86196]},{"content":"Specifies the escape function to be performed.","pos":[86213,86259]},{"pos":[86266,86439],"content":"For a complete list of escape functions, see <bpt id=\"p1\">[</bpt>Escape<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162701)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"For a complete list of escape functions, see [Escape](http://msdn.microsoft.com/library/windows/desktop/dd162701) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"Specifies the number of bytes of data pointed to by <ph id=\"ph1\">`lpszInData`</ph>.","pos":[86458,86523],"source":" Specifies the number of bytes of data pointed to by `lpszInData`."},{"content":"Points to the input data structure required for this escape.","pos":[86546,86606]},{"content":"Points to the structure that is to receive output from this escape.","pos":[86628,86695]},{"content":"The <ph id=\"ph1\">`lpOutData`</ph> parameter is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if no data is returned.","pos":[86696,86757],"source":" The `lpOutData` parameter is **NULL** if no data is returned."},{"content":"Specifies the number of bytes of data pointed to by the <ph id=\"ph1\">`lpszInputData`</ph> parameter.","pos":[86780,86862],"source":" Specifies the number of bytes of data pointed to by the `lpszInputData` parameter."},{"content":"Points to the input structure required for the specified escape.","pos":[86888,86952]},{"content":"Specifies the number of bytes of data pointed to by the <ph id=\"ph1\">`lpszOutputData`</ph> parameter.","pos":[86976,87059],"source":" Specifies the number of bytes of data pointed to by the `lpszOutputData` parameter."},{"content":"Points to the structure that receives output from this escape.","pos":[87086,87148]},{"content":"This parameter should be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if no data is returned.","pos":[87149,87206],"source":" This parameter should be **NULL** if no data is returned."},{"content":"Return Value","pos":[87216,87228]},{"content":"A positive value is returned if the function is successful, except for the <bpt id=\"p1\">**</bpt>QUERYESCSUPPORT<ept id=\"p1\">**</ept> escape, which only checks for implementation.","pos":[87232,87372],"source":"A positive value is returned if the function is successful, except for the **QUERYESCSUPPORT** escape, which only checks for implementation."},{"content":"Zero is returned if the escape is not implemented.","pos":[87373,87423]},{"content":"A negative value is returned if an error occurred.","pos":[87424,87474]},{"content":"The following are common error values:","pos":[87475,87513]},{"pos":[87521,87548],"content":"<bpt id=\"p1\">**</bpt>SP_ERROR<ept id=\"p1\">**</ept> General error.","source":"**SP_ERROR** General error."},{"pos":[87556,87672],"content":"<bpt id=\"p1\">**</bpt>SP_OUTOFDISK<ept id=\"p1\">**</ept> Not enough disk space is currently available for spooling, and no more space will become available.","source":"**SP_OUTOFDISK** Not enough disk space is currently available for spooling, and no more space will become available."},{"pos":[87680,87743],"content":"<bpt id=\"p1\">**</bpt>SP_OUTOFMEMORY<ept id=\"p1\">**</ept> Not enough memory is available for spooling.","source":"**SP_OUTOFMEMORY** Not enough memory is available for spooling."},{"pos":[87751,87813],"content":"<bpt id=\"p1\">**</bpt>SP_USERABORT<ept id=\"p1\">**</ept> User ended the job through the Print Manager.","source":"**SP_USERABORT** User ended the job through the Print Manager."},{"content":"Remarks","pos":[87823,87830]},{"content":"Of the original printer escapes, only <bpt id=\"p1\">**</bpt>QUERYESCSUPPORT<ept id=\"p1\">**</ept> is supported for Win32 applications.","pos":[87834,87928],"source":"Of the original printer escapes, only **QUERYESCSUPPORT** is supported for Win32 applications."},{"content":"All other printer escapes are obsolete and are supported only for compatibility with 16-bit applications.","pos":[87929,88034]},{"pos":[88041,88155],"content":"For Win32 programming, <ph id=\"ph1\">`CDC`</ph> now provides six member functions that supersede their corresponding printer escapes:","source":"For Win32 programming, `CDC` now provides six member functions that supersede their corresponding printer escapes:"},{"content":"CDC::AbortDoc","pos":[88164,88177]},{"content":"CDC::EndDoc","pos":[88203,88214]},{"content":"CDC::EndPage","pos":[88238,88250]},{"content":"CDC::SetAbortProc","pos":[88275,88292]},{"content":"CDC::StartDoc","pos":[88322,88335]},{"content":"CDC::StartPage","pos":[88361,88375]},{"content":"In addition, <bpt id=\"p1\">[</bpt>CDC::GetDeviceCaps<ept id=\"p1\">](#cdc__getdevicecaps)</ept> supports Win32 indexes that supersede other printer escapes.","pos":[88400,88515],"source":"In addition, [CDC::GetDeviceCaps](#cdc__getdevicecaps) supports Win32 indexes that supersede other printer escapes."},{"content":"See <bpt id=\"p1\">[</bpt>GetDeviceCaps<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144877)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph> for more information.","pos":[88516,88676],"source":" See [GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for more information."},{"content":"This member function allows applications to access facilities of a particular device that are not directly available through GDI.","pos":[88683,88812]},{"content":"Use the first version if your application uses predefined escape values.","pos":[88819,88891]},{"content":"Use the second version if your application defines private escape values.","pos":[88892,88965]},{"content":"See <bpt id=\"p1\">[</bpt>ExtEscape<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162708)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph> for more information about the second version.","pos":[88966,89147],"source":" See [ExtEscape](http://msdn.microsoft.com/library/windows/desktop/dd162708) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for more information about the second version."},{"pos":[89194,89214],"content":"CDC::ExcludeClipRect"},{"content":"Creates a new clipping region that consists of the existing clipping region minus the specified rectangle.","pos":[89218,89324]},{"content":"Parameters","pos":[89470,89480]},{"content":"Specifies the logical x-coordinate of the upper-left corner of the rectangle.","pos":[89492,89569]},{"content":"Specifies the logical y-coordinate of the upper-left corner of the rectangle.","pos":[89584,89661]},{"content":"Specifies the logical x-coordinate of the lower-right corner of the rectangle.","pos":[89676,89754]},{"content":"Specifies the logical y-coordinate of the lower-right corner of the rectangle.","pos":[89769,89847]},{"content":"Specifies the rectangle.","pos":[89866,89890]},{"content":"Can also be a <ph id=\"ph1\">`CRect`</ph> object.","pos":[89891,89920],"source":" Can also be a `CRect` object."},{"content":"Return Value","pos":[89930,89942]},{"content":"Specifies the new clipping region's type.","pos":[89946,89987]},{"content":"It can be any of the following values:","pos":[89988,90026]},{"pos":[90034,90087],"content":"<bpt id=\"p1\">**</bpt>COMPLEXREGION<ept id=\"p1\">**</ept> The region has overlapping borders.","source":"**COMPLEXREGION** The region has overlapping borders."},{"pos":[90095,90127],"content":"<bpt id=\"p1\">**</bpt>ERROR<ept id=\"p1\">**</ept> No region was created.","source":"**ERROR** No region was created."},{"pos":[90135,90170],"content":"<bpt id=\"p1\">**</bpt>NULLREGION<ept id=\"p1\">**</ept> The region is empty.","source":"**NULLREGION** The region is empty."},{"pos":[90178,90233],"content":"<bpt id=\"p1\">**</bpt>SIMPLEREGION<ept id=\"p1\">**</ept> The region has no overlapping borders.","source":"**SIMPLEREGION** The region has no overlapping borders."},{"content":"Remarks","pos":[90243,90250]},{"content":"The width of the rectangle, specified by the absolute value of <ph id=\"ph1\">`x2`</ph> – <ph id=\"ph2\">`x1`</ph>, must not exceed 32,767 units.","pos":[90254,90359],"source":"The width of the rectangle, specified by the absolute value of `x2` – `x1`, must not exceed 32,767 units."},{"content":"This limit applies to the height of the rectangle as well.","pos":[90360,90418]},{"pos":[90466,90487],"content":"CDC::ExcludeUpdateRgn"},{"pos":[90491,90644],"content":"Prevents drawing within invalid areas of a window by excluding an updated region in the window from the clipping region associated with the <ph id=\"ph1\">`CDC`</ph> object.","source":"Prevents drawing within invalid areas of a window by excluding an updated region in the window from the clipping region associated with the `CDC` object."},{"content":"Parameters","pos":[90703,90713]},{"content":"Points to the window object whose window is being updated.","pos":[90727,90785]},{"content":"Return Value","pos":[90795,90807]},{"content":"The type of excluded region.","pos":[90811,90839]},{"content":"It can be any one of the following values:","pos":[90840,90882]},{"pos":[90890,90943],"content":"<bpt id=\"p1\">**</bpt>COMPLEXREGION<ept id=\"p1\">**</ept> The region has overlapping borders.","source":"**COMPLEXREGION** The region has overlapping borders."},{"pos":[90951,90983],"content":"<bpt id=\"p1\">**</bpt>ERROR<ept id=\"p1\">**</ept> No region was created.","source":"**ERROR** No region was created."},{"pos":[90991,91026],"content":"<bpt id=\"p1\">**</bpt>NULLREGION<ept id=\"p1\">**</ept> The region is empty.","source":"**NULLREGION** The region is empty."},{"pos":[91034,91089],"content":"<bpt id=\"p1\">**</bpt>SIMPLEREGION<ept id=\"p1\">**</ept> The region has no overlapping borders.","source":"**SIMPLEREGION** The region has no overlapping borders."},{"pos":[91133,91150],"content":"CDC::ExtFloodFill"},{"content":"Fills an area of the display surface with the current brush.","pos":[91154,91214]},{"content":"Parameters","pos":[91329,91339]},{"content":"x","pos":[91344,91345]},{"content":"Specifies the logical x-coordinate of the point where filling begins.","pos":[91350,91419]},{"content":"y","pos":[91427,91428]},{"content":"Specifies the logical y-coordinate of the point where filling begins.","pos":[91433,91502]},{"content":"Specifies the color of the boundary or of the area to be filled.","pos":[91522,91586]},{"content":"The interpretation of <ph id=\"ph1\">`crColor`</ph> depends on the value of <ph id=\"ph2\">`nFillType`</ph>.","pos":[91587,91655],"source":" The interpretation of `crColor` depends on the value of `nFillType`."},{"content":"Specifies the type of flood fill to be performed.","pos":[91677,91726]},{"content":"It must be either of the following values:","pos":[91727,91769]},{"content":"<bpt id=\"p1\">**</bpt>FLOODFILLBORDER<ept id=\"p1\">**</ept> The fill area is bounded by the color specified by <ph id=\"ph1\">`crColor`</ph>.","pos":[91777,91858],"source":"**FLOODFILLBORDER** The fill area is bounded by the color specified by `crColor`."},{"content":"This style is identical to the filling performed by <ph id=\"ph1\">`FloodFill`</ph>.","pos":[91859,91923],"source":" This style is identical to the filling performed by `FloodFill`."},{"content":"<bpt id=\"p1\">**</bpt>FLOODFILLSURFACE<ept id=\"p1\">**</ept> The fill area is defined by the color specified by <ph id=\"ph1\">`crColor`</ph>.","pos":[91931,92013],"source":"**FLOODFILLSURFACE** The fill area is defined by the color specified by `crColor`."},{"content":"Filling continues outward in all directions as long as the color is encountered.","pos":[92014,92094]},{"content":"This style is useful for filling areas with multicolored boundaries.","pos":[92095,92163]},{"content":"Return Value","pos":[92173,92185]},{"pos":[92189,92538],"content":"Nonzero if the function is successful; otherwise 0 if the filling could not be completed, if the given point has the boundary color specified by <ph id=\"ph1\">`crColor`</ph> (if <bpt id=\"p1\">**</bpt>FLOODFILLBORDER<ept id=\"p1\">**</ept> was requested), if the given point does not have the color specified by <ph id=\"ph2\">`crColor`</ph> (if <bpt id=\"p2\">**</bpt>FLOODFILLSURFACE<ept id=\"p2\">**</ept> was requested), or if the point is outside the clipping region.","source":"Nonzero if the function is successful; otherwise 0 if the filling could not be completed, if the given point has the boundary color specified by `crColor` (if **FLOODFILLBORDER** was requested), if the given point does not have the color specified by `crColor` (if **FLOODFILLSURFACE** was requested), or if the point is outside the clipping region."},{"content":"Remarks","pos":[92548,92555]},{"pos":[92559,92672],"content":"This member function offers more flexibility than <ph id=\"ph1\">`FloodFill`</ph> because you can specify a fill type in <ph id=\"ph2\">`nFillType`</ph>.","source":"This member function offers more flexibility than `FloodFill` because you can specify a fill type in `nFillType`."},{"content":"If <ph id=\"ph1\">`nFillType`</ph> is set to <bpt id=\"p1\">**</bpt>FLOODFILLBORDER<ept id=\"p1\">**</ept>, the area is assumed to be completely bounded by the color specified by <ph id=\"ph2\">`crColor`</ph>.","pos":[92679,92806],"source":"If `nFillType` is set to **FLOODFILLBORDER**, the area is assumed to be completely bounded by the color specified by `crColor`."},{"content":"The function begins at the point specified by <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> and fills in all directions to the color boundary.","pos":[92807,92915],"source":" The function begins at the point specified by *x* and *y* and fills in all directions to the color boundary."},{"pos":[92922,93131],"content":"If <ph id=\"ph1\">`nFillType`</ph> is set to <bpt id=\"p1\">**</bpt>FLOODFILLSURFACE<ept id=\"p1\">**</ept>, the function begins at the point specified by <bpt id=\"p2\">*</bpt>x<ept id=\"p2\">*</ept> and <bpt id=\"p3\">*</bpt>y<ept id=\"p3\">*</ept> and continues in all directions, filling all adjacent areas containing the color specified by <ph id=\"ph2\">`crColor`</ph>.","source":"If `nFillType` is set to **FLOODFILLSURFACE**, the function begins at the point specified by *x* and *y* and continues in all directions, filling all adjacent areas containing the color specified by `crColor`."},{"content":"Only memory-device contexts and devices that support raster-display technology support <ph id=\"ph1\">`ExtFloodFill`</ph>.","pos":[93138,93240],"source":"Only memory-device contexts and devices that support raster-display technology support `ExtFloodFill`."},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>GetDeviceCaps<ept id=\"p1\">](#cdc__getdevicecaps)</ept> member function.","pos":[93241,93324],"source":" For more information, see the [GetDeviceCaps](#cdc__getdevicecaps) member function."},{"pos":[93366,93381],"content":"CDC::ExtTextOut"},{"content":"Call this member function to write a character string within a rectangular region using the currently selected font.","pos":[93385,93501]},{"content":"Parameters","pos":[93826,93836]},{"content":"x","pos":[93841,93842]},{"content":"Specifies the logical x-coordinate of the character cell for the first character in the specified string.","pos":[93847,93952]},{"content":"y","pos":[93960,93961]},{"content":"Specifies the logical y-coordinate of the top of the character cell for the first character in the specified string.","pos":[93966,94082]},{"content":"Specifies the rectangle type.","pos":[94103,94132]},{"content":"This parameter can be one, both, or neither of the following values:","pos":[94133,94201]},{"pos":[94209,94273],"content":"<bpt id=\"p1\">**</bpt>ETO_CLIPPED<ept id=\"p1\">**</ept> Specifies that text is clipped to the rectangle.","source":"**ETO_CLIPPED** Specifies that text is clipped to the rectangle."},{"content":"<bpt id=\"p1\">**</bpt>ETO_OPAQUE<ept id=\"p1\">**</ept> Specifies that the current background color fills the rectangle.","pos":[94281,94360],"source":"**ETO_OPAQUE** Specifies that the current background color fills the rectangle."},{"content":"(You can set and query the current background color with the <bpt id=\"p1\">[</bpt>SetBkColor<ept id=\"p1\">](#cdc__setbkcolor)</ept> and <bpt id=\"p2\">[</bpt>GetBkColor<ept id=\"p2\">](#cdc__getbkcolor)</ept> member functions.)","pos":[94361,94506],"source":" (You can set and query the current background color with the [SetBkColor](#cdc__setbkcolor) and [GetBkColor](#cdc__getbkcolor) member functions.)"},{"pos":[94513,94776],"content":"`lpRect`  \nPoints to a [RECT](../../mfc/reference/rect-structure1.md) structure that determines the dimensions of the rectangle. This parameter can be **NULL**. You can also pass a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter.","leadings":[""," "],"nodes":[{"content":"Points to a [RECT](../../mfc/reference/rect-structure1.md) structure that determines the dimensions of the rectangle. This parameter can be **NULL**. You can also pass a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter.","pos":[11,262],"nodes":[{"content":"Points to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure that determines the dimensions of the rectangle.","pos":[0,117],"source":"Points to a [RECT](../../mfc/reference/rect-structure1.md) structure that determines the dimensions of the rectangle."},{"content":"This parameter can be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[118,149],"source":" This parameter can be **NULL**."},{"content":"You can also pass a <bpt id=\"p1\">[</bpt>CRect<ept id=\"p1\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object for this parameter.","pos":[150,251],"source":" You can also pass a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter."}]}]},{"pos":[94783,94959],"content":"`lpszString`  \nPoints to the specified character string to be drawn. You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter.","leadings":[""," "],"nodes":[{"content":"Points to the specified character string to be drawn. You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter.","pos":[15,175],"nodes":[{"content":"Points to the specified character string to be drawn.","pos":[0,53]},{"content":"You can also pass a <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object for this parameter.","pos":[54,160],"source":" You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter."}]}]},{"pos":[94966,95027],"content":"`nCount`  \nSpecifies the number of characters in the string.","leadings":[""," "],"nodes":[{"content":"Specifies the number of characters in the string.","pos":[11,60]}]},{"pos":[95034,95360],"content":"`lpDxWidths`  \nPoints to an array of values that indicate the distance between origins of adjacent character cells. For instance, `lpDxWidths`[ *i*] logical units will separate the origins of character cell *i* and character cell *i* + 1. If `lpDxWidths` is **NULL**, `ExtTextOut` uses the default spacing between characters.","leadings":[""," "],"nodes":[{"content":"Points to an array of values that indicate the distance between origins of adjacent character cells. For instance, `lpDxWidths`[ *i*] logical units will separate the origins of character cell *i* and character cell *i* + 1. If `lpDxWidths` is **NULL**, `ExtTextOut` uses the default spacing between characters.","pos":[15,325],"nodes":[{"content":"Points to an array of values that indicate the distance between origins of adjacent character cells.","pos":[0,100]},{"content":"For instance, <ph id=\"ph1\">`lpDxWidths`</ph>[ <bpt id=\"p1\">*</bpt>i<ept id=\"p1\">*</ept>] logical units will separate the origins of character cell <bpt id=\"p2\">*</bpt>i<ept id=\"p2\">*</ept> and character cell <bpt id=\"p3\">*</bpt>i<ept id=\"p3\">*</ept> + 1.","pos":[101,223],"source":" For instance, `lpDxWidths`[ *i*] logical units will separate the origins of character cell *i* and character cell *i* + 1."},{"content":"If <ph id=\"ph1\">`lpDxWidths`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, <ph id=\"ph2\">`ExtTextOut`</ph> uses the default spacing between characters.","pos":[224,310],"source":" If `lpDxWidths` is **NULL**, `ExtTextOut` uses the default spacing between characters."}]}]},{"pos":[95367,95446],"content":"`str`  \nA `CString` object that contains the specified characters to be drawn.","leadings":[""," "],"nodes":[{"content":"A <ph id=\"ph1\">`CString`</ph> object that contains the specified characters to be drawn.","pos":[8,78],"source":"A `CString` object that contains the specified characters to be drawn."}]},{"content":"Return Value","pos":[95456,95468]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[95472,95523]},{"content":"Remarks","pos":[95533,95540]},{"content":"The rectangular region can be opaque (filled with the current background color), and it can be a clipping region.","pos":[95544,95657]},{"content":"If <ph id=\"ph1\">`nOptions`</ph> is 0 and <ph id=\"ph2\">`lpRect`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the function writes text to the device context without using a rectangular region.","pos":[95664,95791],"source":"If `nOptions` is 0 and `lpRect` is **NULL**, the function writes text to the device context without using a rectangular region."},{"content":"By default, the current position is not used or updated by the function.","pos":[95792,95864]},{"content":"If an application needs to update the current position when it calls <ph id=\"ph1\">`ExtTextOut`</ph>, the application can call the <ph id=\"ph2\">`CDC`</ph> member function <bpt id=\"p1\">[</bpt>SetTextAlign<ept id=\"p1\">](#cdc__settextalign)</ept> with <ph id=\"ph3\">`nFlags`</ph> set to <bpt id=\"p2\">**</bpt>TA_UPDATECP<ept id=\"p2\">**</ept>.","pos":[95865,96071],"source":" If an application needs to update the current position when it calls `ExtTextOut`, the application can call the `CDC` member function [SetTextAlign](#cdc__settextalign) with `nFlags` set to **TA_UPDATECP**."},{"content":"When this flag is set, Windows ignores <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> on subsequent calls to <ph id=\"ph1\">`ExtTextOut`</ph> and uses the current position instead.","pos":[96072,96197],"source":" When this flag is set, Windows ignores *x* and *y* on subsequent calls to `ExtTextOut` and uses the current position instead."},{"content":"When an application uses <bpt id=\"p1\">**</bpt>TA_UPDATECP<ept id=\"p1\">**</ept> to update the current position, <ph id=\"ph1\">`ExtTextOut`</ph> sets the current position either to the end of the previous line of text or to the position specified by the last element of the array pointed to by <ph id=\"ph2\">`lpDxWidths`</ph>, whichever is greater.","pos":[96198,96468],"source":" When an application uses **TA_UPDATECP** to update the current position, `ExtTextOut` sets the current position either to the end of the previous line of text or to the position specified by the last element of the array pointed to by `lpDxWidths`, whichever is greater."},{"pos":[96508,96521],"content":"CDC::FillPath"},{"content":"Closes any open figures in the current path and fills the path's interior by using the current brush and polygon-filling mode.","pos":[96525,96651]},{"content":"Return Value","pos":[96693,96705]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[96709,96760]},{"content":"Remarks","pos":[96770,96777]},{"content":"After its interior is filled, the path is discarded from the device context.","pos":[96781,96857]},{"pos":[96897,96910],"content":"CDC::FillRect"},{"content":"Call this member function to fill a given rectangle using the specified brush.","pos":[96914,96992]},{"content":"Parameters","pos":[97075,97085]},{"content":"Points to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure that contains the logical coordinates of the rectangle to be filled.","pos":[97101,97238],"source":" Points to a [RECT](../../mfc/reference/rect-structure1.md) structure that contains the logical coordinates of the rectangle to be filled."},{"content":"You can also pass a <bpt id=\"p1\">[</bpt>CRect<ept id=\"p1\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object for this parameter.","pos":[97239,97340],"source":" You can also pass a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter."},{"content":"Identifies the brush used to fill the rectangle.","pos":[97359,97407]},{"content":"Remarks","pos":[97417,97424]},{"content":"The function fills the complete rectangle, including the left and top borders, but it does not fill the right and bottom borders.","pos":[97428,97557]},{"pos":[97564,97982],"content":"The brush needs to either be created using the <bpt id=\"p1\">[</bpt>CBrush<ept id=\"p1\">](../../mfc/reference/cbrush-class.md)</ept> member functions <bpt id=\"p2\">[</bpt>CreateHatchBrush<ept id=\"p2\">](../../mfc/reference/cbrush-class.md#cbrush__createhatchbrush)</ept>, <bpt id=\"p3\">[</bpt>CreatePatternBrush<ept id=\"p3\">](../../mfc/reference/cbrush-class.md#cbrush__createpatternbrush)</ept>, and <bpt id=\"p4\">[</bpt>CreateSolidBrush<ept id=\"p4\">](../../mfc/reference/cbrush-class.md#cbrush__createsolidbrush)</ept>, or retrieved by the <ph id=\"ph1\">`GetStockObject`</ph> Windows function.","source":"The brush needs to either be created using the [CBrush](../../mfc/reference/cbrush-class.md) member functions [CreateHatchBrush](../../mfc/reference/cbrush-class.md#cbrush__createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#cbrush__createpatternbrush), and [CreateSolidBrush](../../mfc/reference/cbrush-class.md#cbrush__createsolidbrush), or retrieved by the `GetStockObject` Windows function."},{"content":"When filling the specified rectangle, <ph id=\"ph1\">`FillRect`</ph> does not include the rectangle's right and bottom sides.","pos":[97989,98094],"source":"When filling the specified rectangle, `FillRect` does not include the rectangle's right and bottom sides."},{"content":"GDI fills a rectangle up to, but does not include, the right column and bottom row, regardless of the current mapping mode.","pos":[98095,98218]},{"content":"compares the values of the <bpt id=\"p1\">**</bpt>top<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>bottom<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>left<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>right<ept id=\"p4\">**</ept> members of the specified rectangle.","pos":[98230,98337],"source":" compares the values of the **top**, **bottom**, **left**, and **right** members of the specified rectangle."},{"content":"If <bpt id=\"p1\">**</bpt>bottom<ept id=\"p1\">**</ept> is less than or equal to <bpt id=\"p2\">**</bpt>top<ept id=\"p2\">**</ept>, or if <bpt id=\"p3\">**</bpt>right<ept id=\"p3\">**</ept> is less than or equal to <bpt id=\"p4\">**</bpt>left<ept id=\"p4\">**</ept>, the rectangle is not drawn.","pos":[98338,98464],"source":" If **bottom** is less than or equal to **top**, or if **right** is less than or equal to **left**, the rectangle is not drawn."},{"content":"is similar to <bpt id=\"p1\">[</bpt>CDC::FillSolidRect<ept id=\"p1\">](#cdc__fillsolidrect)</ept>; however, <ph id=\"ph1\">`FillRect`</ph> takes a brush and therefore can be used to fill a rectangle with a solid color, a dithered color, hatched brushes, or a pattern.","pos":[98482,98687],"source":" is similar to [CDC::FillSolidRect](#cdc__fillsolidrect); however, `FillRect` takes a brush and therefore can be used to fill a rectangle with a solid color, a dithered color, hatched brushes, or a pattern."},{"content":"uses only solid colors (indicated by a <bpt id=\"p1\">**</bpt>COLORREF<ept id=\"p1\">**</ept> parameter).","pos":[98704,98767],"source":" uses only solid colors (indicated by a **COLORREF** parameter)."},{"content":"usually is slower than <ph id=\"ph1\">`FillSolidRect`</ph>.","pos":[98779,98818],"source":" usually is slower than `FillSolidRect`."},{"pos":[98857,98869],"content":"CDC::FillRgn"},{"pos":[98873,98947],"content":"Fills the region specified by <ph id=\"ph1\">`pRgn`</ph> with the brush specified by <ph id=\"ph2\">`pBrush`</ph>.","source":"Fills the region specified by `pRgn` with the brush specified by `pBrush`."},{"content":"Parameters","pos":[99025,99035]},{"content":"A pointer to the region to be filled.","pos":[99049,99086]},{"content":"The coordinates for the given region are specified in logical units.","pos":[99087,99155]},{"content":"Identifies the brush to be used to fill the region.","pos":[99174,99225]},{"content":"Return Value","pos":[99235,99247]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[99251,99302]},{"content":"Remarks","pos":[99312,99319]},{"pos":[99323,99492],"content":"The brush must either be created using the <ph id=\"ph1\">`CBrush`</ph> member functions <ph id=\"ph2\">`CreateHatchBrush`</ph>, <ph id=\"ph3\">`CreatePatternBrush`</ph>, <ph id=\"ph4\">`CreateSolidBrush`</ph>, or be retrieved by <bpt id=\"p1\">**</bpt>GetStockObject<ept id=\"p1\">**</ept>.","source":"The brush must either be created using the `CBrush` member functions `CreateHatchBrush`, `CreatePatternBrush`, `CreateSolidBrush`, or be retrieved by **GetStockObject**."},{"content":"Example","pos":[99502,99509]},{"pos":[99514,99621],"content":"See the example for <bpt id=\"p1\">[</bpt>CRgn::CreateRoundRectRgn<ept id=\"p1\">](../../mfc/reference/crgn-class.md#crgn__createroundrectrgn)</ept>.","source":"See the example for [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#crgn__createroundrectrgn)."},{"pos":[99666,99684],"content":"CDC::FillSolidRect"},{"content":"Call this member function to fill the given rectangle with the specified solid color.","pos":[99688,99773]},{"content":"Parameters","pos":[99955,99965]},{"content":"Specifies the bounding rectangle (in logical units).","pos":[99981,100033]},{"content":"You can pass either a pointer to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> data structure or a <ph id=\"ph1\">`CRect`</ph> object for this parameter.","pos":[100034,100170],"source":" You can pass either a pointer to a [RECT](../../mfc/reference/rect-structure1.md) data structure or a `CRect` object for this parameter."},{"pos":[100183,100236],"content":"Specifies the color to be used to fill the rectangle."},{"content":"x","pos":[100244,100245]},{"content":"Specifies the logical x-coordinate of the upper-left corner of the rectangle.","pos":[100250,100327]},{"content":"y","pos":[100335,100336]},{"content":"Specifies the logical y-coordinate of the upper-left corner of the destination rectangle.","pos":[100341,100430]},{"content":"Specifies the width of the rectangle.","pos":[100445,100482]},{"content":"Specifies the height of the rectangle.","pos":[100497,100535]},{"content":"Remarks","pos":[100545,100552]},{"content":"is very similar to <bpt id=\"p1\">[</bpt>CDC::FillRect<ept id=\"p1\">](#cdc__fillrect)</ept>; however, <ph id=\"ph1\">`FillSolidRect`</ph> uses only solid colors (indicated by the <bpt id=\"p2\">**</bpt>COLORREF<ept id=\"p2\">**</ept> parameter), while <ph id=\"ph2\">`FillRect`</ph> takes a brush and therefore can be used to fill a rectangle with a solid color, a dithered color, hatched brushes, or a pattern.","pos":[100572,100860],"source":" is very similar to [CDC::FillRect](#cdc__fillrect); however, `FillSolidRect` uses only solid colors (indicated by the **COLORREF** parameter), while `FillRect` takes a brush and therefore can be used to fill a rectangle with a solid color, a dithered color, hatched brushes, or a pattern."},{"content":"usually is faster than <ph id=\"ph1\">`FillRect`</ph>.","pos":[100877,100911],"source":" usually is faster than `FillRect`."},{"pos":[100919,101085],"content":"[!NOTE]\n When you call `FillSolidRect`, the background color, which was previously set using [SetBkColor](#cdc__setbkcolor), is set to the color indicated by `clr`.","leadings":["","> "],"nodes":[{"content":"When you call <ph id=\"ph1\">`FillSolidRect`</ph>, the background color, which was previously set using <bpt id=\"p1\">[</bpt>SetBkColor<ept id=\"p1\">](#cdc__setbkcolor)</ept>, is set to the color indicated by <ph id=\"ph2\">`clr`</ph>.","pos":[9,164],"source":" When you call `FillSolidRect`, the background color, which was previously set using [SetBkColor](#cdc__setbkcolor), is set to the color indicated by `clr`."}]},{"pos":[101128,101144],"content":"CDC::FlattenPath"},{"content":"Transforms any curves in the path selected into the current device context, and turns each curve into a sequence of lines.","pos":[101148,101270]},{"content":"Return Value","pos":[101315,101327]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[101331,101382]},{"pos":[101423,101437],"content":"CDC::FloodFill"},{"content":"Fills an area of the display surface with the current brush.","pos":[101441,101501]},{"content":"Parameters","pos":[101591,101601]},{"content":"x","pos":[101606,101607]},{"content":"Specifies the logical x-coordinate of the point where filling begins.","pos":[101612,101681]},{"content":"y","pos":[101689,101690]},{"content":"Specifies the logical y-coordinate of the point where filling begins.","pos":[101695,101764]},{"content":"Specifies the color of the boundary.","pos":[101784,101820]},{"content":"Return Value","pos":[101830,101842]},{"pos":[101846,102055],"content":"Nonzero if the function is successful; otherwise 0 is returned if the filling could not be completed, the given point has the boundary color specified by <ph id=\"ph1\">`crColor`</ph>, or the point is outside the clipping region.","source":"Nonzero if the function is successful; otherwise 0 is returned if the filling could not be completed, the given point has the boundary color specified by `crColor`, or the point is outside the clipping region."},{"content":"Remarks","pos":[102065,102072]},{"content":"The area is assumed to be bounded as specified by <ph id=\"ph1\">`crColor`</ph>.","pos":[102076,102136],"source":"The area is assumed to be bounded as specified by `crColor`."},{"content":"The <ph id=\"ph1\">`FloodFill`</ph> function begins at the point specified by <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> and continues in all directions to the color boundary.","pos":[102137,102261],"source":" The `FloodFill` function begins at the point specified by *x* and *y* and continues in all directions to the color boundary."},{"content":"Only memory-device contexts and devices that support raster-display technology support the <ph id=\"ph1\">`FloodFill`</ph> member function.","pos":[102268,102387],"source":"Only memory-device contexts and devices that support raster-display technology support the `FloodFill` member function."},{"content":"For information about <bpt id=\"p1\">**</bpt>RC_BITBLT<ept id=\"p1\">**</ept> capability, see the <ph id=\"ph1\">`GetDeviceCaps`</ph> member function.","pos":[102388,102476],"source":" For information about **RC_BITBLT** capability, see the `GetDeviceCaps` member function."},{"pos":[102483,102563],"content":"The <ph id=\"ph1\">`ExtFloodFill`</ph> function provides similar capability but greater flexibility.","source":"The `ExtFloodFill` function provides similar capability but greater flexibility."},{"pos":[102604,102618],"content":"CDC::FrameRect"},{"pos":[102622,102680],"content":"Draws a border around the rectangle specified by <ph id=\"ph1\">`lpRect`</ph>.","source":"Draws a border around the rectangle specified by `lpRect`."},{"content":"Parameters","pos":[102764,102774]},{"content":"Points to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure or <bpt id=\"p2\">[</bpt>CRect<ept id=\"p2\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object that contains the logical coordinates of the upper-left and lower-right corners of the rectangle.","pos":[102790,103021],"source":" Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or [CRect](../../atl-mfc-shared/reference/crect-class.md) object that contains the logical coordinates of the upper-left and lower-right corners of the rectangle."},{"content":"You can also pass a <ph id=\"ph1\">`CRect`</ph> object for this parameter.","pos":[103022,103076],"source":" You can also pass a `CRect` object for this parameter."},{"content":"Identifies the brush to be used for framing the rectangle.","pos":[103095,103153]},{"content":"Remarks","pos":[103163,103170]},{"content":"The function uses the given brush to draw the border.","pos":[103174,103227]},{"content":"The width and height of the border is always 1 logical unit.","pos":[103228,103288]},{"pos":[103295,103448],"content":"If the rectangle's <bpt id=\"p1\">**</bpt>bottom<ept id=\"p1\">**</ept> coordinate is less than or equal to <bpt id=\"p2\">**</bpt>top<ept id=\"p2\">**</ept>, or if <bpt id=\"p3\">**</bpt>right<ept id=\"p3\">**</ept> is less than or equal to <bpt id=\"p4\">**</bpt>left<ept id=\"p4\">**</ept>, the rectangle is not drawn.","source":"If the rectangle's **bottom** coordinate is less than or equal to **top**, or if **right** is less than or equal to **left**, the rectangle is not drawn."},{"content":"The border drawn by <ph id=\"ph1\">`FrameRect`</ph> is in the same position as a border drawn by the <bpt id=\"p1\">**</bpt>Rectangle<ept id=\"p1\">**</ept> member function using the same coordinates (if <bpt id=\"p2\">**</bpt>Rectangle<ept id=\"p2\">**</ept> uses a pen that is 1 logical unit wide).","pos":[103455,103651],"source":"The border drawn by `FrameRect` is in the same position as a border drawn by the **Rectangle** member function using the same coordinates (if **Rectangle** uses a pen that is 1 logical unit wide)."},{"content":"The interior of the rectangle is not filled by <ph id=\"ph1\">`FrameRect`</ph>.","pos":[103652,103711],"source":" The interior of the rectangle is not filled by `FrameRect`."},{"pos":[103751,103764],"content":"CDC::FrameRgn"},{"pos":[103768,103859],"content":"Draws a border around the region specified by <ph id=\"ph1\">`pRgn`</ph> using the brush specified by <ph id=\"ph2\">`pBrush`</ph>.","source":"Draws a border around the region specified by `pRgn` using the brush specified by `pBrush`."},{"content":"Parameters","pos":[103975,103985]},{"content":"Points to the <ph id=\"ph1\">`CRgn`</ph> object that identifies the region to be enclosed in a border.","pos":[103999,104081],"source":" Points to the `CRgn` object that identifies the region to be enclosed in a border."},{"content":"The coordinates for the given region are specified in logical units.","pos":[104082,104150]},{"content":"Points to the <ph id=\"ph1\">`CBrush`</ph> object that identifies the brush to be used to draw the border.","pos":[104169,104255],"source":" Points to the `CBrush` object that identifies the brush to be used to draw the border."},{"content":"Specifies the width of the border in vertical brush strokes in device units.","pos":[104274,104350]},{"content":"Specifies the height of the border in horizontal brush strokes in device units.","pos":[104370,104449]},{"content":"Return Value","pos":[104459,104471]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[104475,104526]},{"content":"Example","pos":[104536,104543]},{"pos":[104548,104639],"content":"See the example for <bpt id=\"p1\">[</bpt>CRgn::CombineRgn<ept id=\"p1\">](../../mfc/reference/crgn-class.md#crgn__combinergn)</ept>.","source":"See the example for [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#crgn__combinergn)."},{"pos":[104681,104696],"content":"CDC::FromHandle"},{"pos":[104700,104776],"content":"Returns a pointer to a <ph id=\"ph1\">`CDC`</ph> object when given a handle to a device context.","source":"Returns a pointer to a `CDC` object when given a handle to a device context."},{"content":"Parameters","pos":[104841,104851]},{"content":"Contains a handle to a Windows device context.","pos":[104864,104910]},{"content":"Return Value","pos":[104920,104932]},{"content":"The pointer may be temporary and should not be stored beyond immediate use.","pos":[104936,105011]},{"content":"Remarks","pos":[105021,105028]},{"pos":[105032,105130],"content":"If a <ph id=\"ph1\">`CDC`</ph> object is not attached to the handle, a temporary <ph id=\"ph2\">`CDC`</ph> object is created and attached.","source":"If a `CDC` object is not attached to the handle, a temporary `CDC` object is created and attached."},{"content":"Example","pos":[105140,105147]},{"pos":[105152,105271],"content":"See the example for <bpt id=\"p1\">[</bpt>CPrintDialog::GetPrinterDC<ept id=\"p1\">](../../mfc/reference/cprintdialog-class.md#cprintdialog__getprinterdc)</ept>.","source":"See the example for [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#cprintdialog__getprinterdc)."},{"pos":[105318,105338],"content":"CDC::GetArcDirection"},{"content":"Returns the current arc direction for the device context.","pos":[105342,105399]},{"content":"Return Value","pos":[105456,105468]},{"content":"Specifies the current arc direction, if successful.","pos":[105472,105523]},{"content":"Following are the valid return values:","pos":[105524,105562]},{"pos":[105570,105637],"content":"<bpt id=\"p1\">**</bpt>AD_COUNTERCLOCKWISE<ept id=\"p1\">**</ept> Arcs and rectangles drawn counterclockwise.","source":"**AD_COUNTERCLOCKWISE** Arcs and rectangles drawn counterclockwise."},{"pos":[105645,105698],"content":"<bpt id=\"p1\">**</bpt>AD_CLOCKWISE<ept id=\"p1\">**</ept> Arcs and rectangles drawn clockwise.","source":"**AD_CLOCKWISE** Arcs and rectangles drawn clockwise."},{"content":"If an error occurs, the return value is zero.","pos":[105705,105750]},{"content":"Remarks","pos":[105760,105767]},{"content":"Arc and rectangle functions use the arc direction.","pos":[105771,105821]},{"pos":[105873,105898],"content":"CDC::GetAspectRatioFilter"},{"content":"Retrieves the setting for the current aspect-ratio filter.","pos":[105902,105960]},{"content":"Return Value","pos":[106024,106036]},{"pos":[106040,106127],"content":"A <ph id=\"ph1\">`CSize`</ph> object representing the aspect ratio used by the current aspect ratio filter.","source":"A `CSize` object representing the aspect ratio used by the current aspect ratio filter."},{"content":"Remarks","pos":[106137,106144]},{"content":"The aspect ratio is the ratio formed by a device's pixel width and height.","pos":[106148,106222]},{"content":"Information about a device's aspect ratio is used in the creation, selection, and display of fonts.","pos":[106223,106322]},{"content":"Windows provides a special filter, the aspect-ratio filter, to select fonts designed for a particular aspect ratio from all of the available fonts.","pos":[106323,106470]},{"content":"The filter uses the aspect ratio specified by the <ph id=\"ph1\">`SetMapperFlags`</ph> member function.","pos":[106471,106554],"source":" The filter uses the aspect ratio specified by the `SetMapperFlags` member function."},{"pos":[106596,106611],"content":"CDC::GetBkColor"},{"content":"Returns the current background color.","pos":[106615,106652]},{"content":"Return Value","pos":[106709,106721]},{"content":"An RGB color value.","pos":[106725,106744]},{"content":"Remarks","pos":[106754,106761]},{"content":"If the background mode is <bpt id=\"p1\">**</bpt>OPAQUE<ept id=\"p1\">**</ept>, the system uses the background color to fill the gaps in styled lines, the gaps between hatched lines in brushes, and the background in character cells.","pos":[106765,106955],"source":"If the background mode is **OPAQUE**, the system uses the background color to fill the gaps in styled lines, the gaps between hatched lines in brushes, and the background in character cells."},{"content":"The system also uses the background color when converting bitmaps between color and monochrome device contexts.","pos":[106956,107067]},{"pos":[107108,107122],"content":"CDC::GetBkMode"},{"content":"Returns the background mode.","pos":[107126,107154]},{"content":"Return Value","pos":[107205,107217]},{"pos":[107221,107293],"content":"The current background mode, which can be <bpt id=\"p1\">**</bpt>OPAQUE<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>TRANSPARENT<ept id=\"p2\">**</ept>.","source":"The current background mode, which can be **OPAQUE** or **TRANSPARENT**."},{"content":"Remarks","pos":[107303,107310]},{"content":"The background mode defines whether the system removes existing background colors on the drawing surface before drawing text, hatched brushes, or any pen style that is not a solid line.","pos":[107314,107499]},{"pos":[107544,107562],"content":"CDC::GetBoundsRect"},{"content":"Returns the current accumulated bounding rectangle for the specified device context.","pos":[107566,107650]},{"content":"Parameters","pos":[107739,107749]},{"content":"Points to a buffer that will receive the current bounding rectangle.","pos":[107771,107839]},{"content":"The rectangle is returned in logical coordinates.","pos":[107840,107889]},{"content":"Specifies whether the bounding rectangle is to be cleared after it is returned.","pos":[107907,107986]},{"content":"This parameter should be  zero or set to the following value:","pos":[107987,108048]},{"pos":[108056,108135],"content":"<bpt id=\"p1\">**</bpt>DCB_RESET<ept id=\"p1\">**</ept> Forces the bounding rectangle to be cleared after it is returned.","source":"**DCB_RESET** Forces the bounding rectangle to be cleared after it is returned."},{"content":"Return Value","pos":[108145,108157]},{"content":"Specifies the current state of the bounding rectangle if the function is successful.","pos":[108161,108245]},{"content":"It can be a combination of the following values:","pos":[108246,108294]},{"pos":[108302,108366],"content":"<bpt id=\"p1\">**</bpt>DCB_ACCUMULATE<ept id=\"p1\">**</ept> Bounding rectangle accumulation is occurring.","source":"**DCB_ACCUMULATE** Bounding rectangle accumulation is occurring."},{"pos":[108374,108416],"content":"<bpt id=\"p1\">**</bpt>DCB_RESET<ept id=\"p1\">**</ept> Bounding rectangle is empty.","source":"**DCB_RESET** Bounding rectangle is empty."},{"pos":[108424,108468],"content":"<bpt id=\"p1\">**</bpt>DCB_SET<ept id=\"p1\">**</ept> Bounding rectangle is not empty.","source":"**DCB_SET** Bounding rectangle is not empty."},{"pos":[108476,108519],"content":"<bpt id=\"p1\">**</bpt>DCB_ENABLE<ept id=\"p1\">**</ept> Bounding accumulation is on.","source":"**DCB_ENABLE** Bounding accumulation is on."},{"pos":[108527,108572],"content":"<bpt id=\"p1\">**</bpt>DCB_DISABLE<ept id=\"p1\">**</ept> Bounding accumulation is off.","source":"**DCB_DISABLE** Bounding accumulation is off."},{"pos":[108615,108631],"content":"CDC::GetBrushOrg"},{"content":"Retrieves the origin (in device units) of the brush currently selected for the device context.","pos":[108635,108729]},{"content":"Return Value","pos":[108785,108797]},{"pos":[108801,108920],"content":"The current origin of the brush (in device units) as a <bpt id=\"p1\">[</bpt>CPoint<ept id=\"p1\">](../../atl-mfc-shared/reference/cpoint-class.md)</ept> object.","source":"The current origin of the brush (in device units) as a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object."},{"content":"Remarks","pos":[108930,108937]},{"content":"The initial brush origin is at (0,0) of the client area.","pos":[108941,108997]},{"content":"The return value specifies this point in device units relative to the origin of the desktop window.","pos":[108998,109097]},{"pos":[109150,109176],"content":"CDC::GetCharacterPlacement"},{"content":"Retrieves various types of information on a character string.","pos":[109180,109241]},{"content":"Parameters","pos":[109550,109560]},{"content":"A pointer to the character string to process.","pos":[109578,109623]},{"content":"Specifies the length of the string.","pos":[109642,109677]},{"content":"For the ANSI version, it is a BYTE count and for the Unicode function it is a WORD count.","pos":[109678,109767]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>GetCharacterPlacement<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144860\\(v=vs.85\\).aspx)</ept>.","pos":[109768,109894],"source":" For more information, see [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\\(v=vs.85\\).aspx)."},{"content":"Specifies the maximum extent (in logical units) to which the string is processed.","pos":[109917,109998]},{"content":"Characters that, if processed, would exceed this extent are ignored.","pos":[109999,110067]},{"content":"Computations for any required ordering or glyph arrays apply only to the included characters.","pos":[110068,110161]},{"content":"This parameter is used only if the GCP_MAXEXTENT value is specified in the <ph id=\"ph1\">`dwFlags`</ph> parameter.","pos":[110162,110257],"source":" This parameter is used only if the GCP_MAXEXTENT value is specified in the `dwFlags` parameter."},{"content":"As the function processes the input string, each character and its extent is added to the output, extent, and other arrays only if the total extent has not yet exceeded the maximum.","pos":[110258,110439]},{"content":"Once the limit is reached, processing will stop.","pos":[110440,110488]},{"content":"lpResults","pos":[110495,110504]},{"content":"Pointer to a <bpt id=\"p1\">[</bpt>GCP_Results<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144842\\(v=vs.85\\).aspx)</ept> structure that receives the results of the function.","pos":[110508,110663],"source":" Pointer to a [GCP_Results](http://msdn.microsoft.com/library/windows/desktop/dd144842\\(v=vs.85\\).aspx) structure that receives the results of the function."},{"content":"Specifies how to process the string into the required arrays.","pos":[110683,110744]},{"content":"This parameter can be one or more of the values listed in the <ph id=\"ph1\">`dwFlags`</ph> section of the <bpt id=\"p1\">[</bpt>GetCharacterPlacement<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144860\\(v=vs.85\\).aspx)</ept> topic.","pos":[110745,110938],"source":" This parameter can be one or more of the values listed in the `dwFlags` section of the [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\\(v=vs.85\\).aspx) topic."},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object to process.","pos":[110954,111047],"source":" A pointer to a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object to process."},{"content":"Return Value","pos":[111057,111069]},{"content":"If the function succeeds, the return value is the width and height of the string in logical units.","pos":[111073,111171]},{"content":"If the function fails, the return value is zero.","pos":[111178,111226]},{"content":"Remarks","pos":[111236,111243]},{"pos":[111247,111484],"content":"This member function emulates the functionality of the function <bpt id=\"p1\">[</bpt>GetCharacterPlacement<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144860\\(v=vs.85\\).aspx)</ept>, as described in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"This member function emulates the functionality of the function [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\\(v=vs.85\\).aspx), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[111532,111553],"content":"CDC::GetCharABCWidths"},{"content":"Retrieves the widths of consecutive characters in a specified range from the current TrueType font.","pos":[111557,111656]},{"content":"Parameters","pos":[111879,111889]},{"content":"Specifies the first character in the range of characters from the current font for which character widths are returned.","pos":[111909,112028]},{"content":"Specifies the last character in the range of characters from the current font for which character widths are returned.","pos":[112050,112168]},{"content":"Points to an array of <bpt id=\"p1\">[</bpt>ABC<ept id=\"p1\">](../../mfc/reference/abc-structure.md)</ept> structures that receive the character widths when the function returns.","pos":[112186,112323],"source":" Points to an array of [ABC](../../mfc/reference/abc-structure.md) structures that receive the character widths when the function returns."},{"content":"This array must contain at least as many <bpt id=\"p1\">**</bpt>ABC<ept id=\"p1\">**</ept> structures as there are characters in the range specified by the <ph id=\"ph1\">`nFirstChar`</ph> and <ph id=\"ph2\">`nLastChar`</ph> parameters.","pos":[112324,112478],"source":" This array must contain at least as many **ABC** structures as there are characters in the range specified by the `nFirstChar` and `nLastChar` parameters."},{"content":"lpABCF","pos":[112486,112492]},{"content":"Points to an application-supplied buffer with an array of <bpt id=\"p1\">[</bpt>ABCFLOAT<ept id=\"p1\">](../../mfc/reference/abcfloat-structure.md)</ept> structures to receive the character widths when the function returns.","pos":[112497,112678],"source":" Points to an application-supplied buffer with an array of [ABCFLOAT](../../mfc/reference/abcfloat-structure.md) structures to receive the character widths when the function returns."},{"content":"The widths returned by this function are in the IEEE floating-point format.","pos":[112679,112754]},{"content":"Return Value","pos":[112764,112776]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[112780,112831]},{"content":"Remarks","pos":[112841,112848]},{"content":"The widths are returned in logical units.","pos":[112852,112893]},{"content":"This function succeeds only with TrueType fonts.","pos":[112894,112942]},{"content":"The TrueType rasterizer provides \"ABC\" character spacing after a specific point size has been selected.","pos":[112949,113052]},{"content":"\"A\" spacing is the distance that is added to the current position before placing the glyph.","pos":[113053,113144]},{"content":"\"B\" spacing is the width of the black part of the glyph.","pos":[113145,113201]},{"content":"\"C\" spacing is added to the current position to account for the white space to the right of the glyph.","pos":[113202,113304]},{"content":"The total advanced width is given by A + B + C.","pos":[113305,113352]},{"pos":[113359,113505],"content":"When the <ph id=\"ph1\">`GetCharABCWidths`</ph> member function retrieves negative \"A\" or \"C\" widths for a character, that character includes underhangs or overhangs.","source":"When the `GetCharABCWidths` member function retrieves negative \"A\" or \"C\" widths for a character, that character includes underhangs or overhangs."},{"content":"To convert the ABC widths to font design units, an application should create a font whose height (as specified in the <bpt id=\"p1\">**</bpt>lfHeight<ept id=\"p1\">**</ept> member of the <bpt id=\"p2\">[</bpt>LOGFONT<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/dd145037)</ept> structure) is equal to the value stored in the <bpt id=\"p3\">**</bpt>ntmSizeEM<ept id=\"p3\">**</ept> member of the <bpt id=\"p4\">[</bpt>NEWTEXTMETRIC<ept id=\"p4\">](http://msdn.microsoft.com/library/windows/desktop/dd162741)</ept> structure.","pos":[113512,113888],"source":"To convert the ABC widths to font design units, an application should create a font whose height (as specified in the **lfHeight** member of the [LOGFONT](http://msdn.microsoft.com/library/windows/desktop/dd145037) structure) is equal to the value stored in the **ntmSizeEM** member of the [NEWTEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162741) structure."},{"content":"(The value of the <bpt id=\"p1\">**</bpt>ntmSizeEM<ept id=\"p1\">**</ept> member can be retrieved by calling the <bpt id=\"p2\">[</bpt>EnumFontFamilies<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/dd162619)</ept> Windows function.)","pos":[113889,114057],"source":" (The value of the **ntmSizeEM** member can be retrieved by calling the [EnumFontFamilies](http://msdn.microsoft.com/library/windows/desktop/dd162619) Windows function.)"},{"content":"The ABC widths of the default character are used for characters that are outside the range of the currently selected font.","pos":[114064,114186]},{"pos":[114193,114373],"content":"To retrieve the widths of characters in non-TrueType fonts, applications should use the <bpt id=\"p1\">[</bpt>GetCharWidth<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144861)</ept> Windows function.","source":"To retrieve the widths of characters in non-TrueType fonts, applications should use the [GetCharWidth](http://msdn.microsoft.com/library/windows/desktop/dd144861) Windows function."},{"pos":[114422,114444],"content":"CDC::GetCharABCWidthsI"},{"content":"Retrieves the widths, in logical units, of consecutive glyph indices in a specified range from the current TrueType font.","pos":[114448,114569]},{"content":"Parameters","pos":[114699,114709]},{"content":"Specifies the first glyph index in the group of consecutive glyph indices from the current font.","pos":[114726,114822]},{"content":"This parameter is only used if the <ph id=\"ph1\">`pgi`</ph> parameter is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[114823,114886],"source":" This parameter is only used if the `pgi` parameter is **NULL**."},{"content":"Specifies the number of glyph indices.","pos":[114902,114940]},{"content":"A pointer to an array containing glyph indices.","pos":[114956,115003]},{"content":"If the value is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the <ph id=\"ph1\">`giFirst`</ph> parameter is used instead.","pos":[115004,115070],"source":" If the value is **NULL**, the `giFirst` parameter is used instead."},{"content":"The <ph id=\"ph1\">`cgi`</ph> parameter specifies the number of glyph indices in this array.","pos":[115071,115143],"source":" The `cgi` parameter specifies the number of glyph indices in this array."},{"content":"Pointer to an array of <bpt id=\"p1\">[</bpt>ABC<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162454)</ept> structures receiving the character widths.","pos":[115161,115292],"source":" Pointer to an array of [ABC](http://msdn.microsoft.com/library/windows/desktop/dd162454) structures receiving the character widths."},{"content":"This array must contain at least as many <bpt id=\"p1\">**</bpt>ABC<ept id=\"p1\">**</ept> structures as there are glyph indices specified by the <ph id=\"ph1\">`cgi`</ph> parameter.","pos":[115293,115413],"source":" This array must contain at least as many **ABC** structures as there are glyph indices specified by the `cgi` parameter."},{"content":"Return Value","pos":[115423,115435]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[115439,115490]},{"content":"Remarks","pos":[115500,115507]},{"pos":[115511,115728],"content":"This member function emulates the functionality of the function <bpt id=\"p1\">[</bpt>GetCharABCWidthsI<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144859)</ept>, as described in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"This member function emulates the functionality of the function [GetCharABCWidthsI](http://msdn.microsoft.com/library/windows/desktop/dd144859), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[115772,115789],"content":"CDC::GetCharWidth"},{"pos":[115793,115945],"content":"Retrieves the widths of individual characters in a consecutive group of characters from the current font, using <ph id=\"ph1\">`m_hAttribDC`</ph>, the input device context.","source":"Retrieves the widths of individual characters in a consecutive group of characters from the current font, using `m_hAttribDC`, the input device context."},{"content":"Parameters","pos":[116166,116176]},{"content":"Specifies the first character in a consecutive group of characters in the current font.","pos":[116196,116283]},{"content":"Specifies the last character in a consecutive group of characters in the current font.","pos":[116305,116391]},{"content":"Points to a buffer that will receive the width values for a consecutive group of characters in the current font.","pos":[116412,116524]},{"content":"lpFloatBuffer","pos":[116532,116545]},{"content":"Points to a buffer to receive the character widths.","pos":[116550,116601]},{"content":"The returned widths are in the 32-bit IEEE floating-point format.","pos":[116602,116667]},{"content":"(The widths are measured along the base line of the characters.)","pos":[116668,116732]},{"content":"Return Value","pos":[116742,116754]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[116758,116809]},{"content":"Remarks","pos":[116819,116826]},{"pos":[116830,116990],"content":"For example, if <ph id=\"ph1\">`nFirstChar`</ph> identifies the letter 'a' and <ph id=\"ph2\">`nLastChar`</ph> identifies the letter 'z', the function retrieves the widths of all lowercase characters.","source":"For example, if `nFirstChar` identifies the letter 'a' and `nLastChar` identifies the letter 'z', the function retrieves the widths of all lowercase characters."},{"content":"The function stores the values in the buffer pointed to by <ph id=\"ph1\">`lpBuffer`</ph>.","pos":[116997,117067],"source":"The function stores the values in the buffer pointed to by `lpBuffer`."},{"content":"This buffer must be large enough to hold all of the widths.","pos":[117068,117127]},{"content":"That is, there must be at least 26 entries in the example given.","pos":[117128,117192]},{"content":"If a character in the consecutive group of characters does not exist in a particular font, it will be assigned the width value of the default character.","pos":[117199,117351]},{"pos":[117396,117414],"content":"CDC::GetCharWidthI"},{"content":"Retrieves the widths, in logical coordinates, of consecutive glyph indices in a specified range from the current font.","pos":[117418,117536]},{"content":"Parameters","pos":[117665,117675]},{"content":"Specifies the first glyph index in the group of consecutive glyph indices from the current font.","pos":[117692,117788]},{"content":"This parameter is only used if the <ph id=\"ph1\">`pgi`</ph> parameter is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[117789,117852],"source":" This parameter is only used if the `pgi` parameter is **NULL**."},{"content":"Specifies the number of glyph indices.","pos":[117868,117906]},{"content":"A pointer to an array containing glyph indices.","pos":[117922,117969]},{"content":"If the value is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the <ph id=\"ph1\">`giFirst`</ph> parameter is used instead.","pos":[117970,118036],"source":" If the value is **NULL**, the `giFirst` parameter is used instead."},{"content":"The <ph id=\"ph1\">`cgi`</ph> parameter specifies the number of glyph indices in this array.","pos":[118037,118109],"source":" The `cgi` parameter specifies the number of glyph indices in this array."},{"content":"A pointer to a buffer that receives the widths.","pos":[118130,118177]},{"content":"Return Value","pos":[118187,118199]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[118203,118254]},{"content":"Remarks","pos":[118264,118271]},{"pos":[118275,118488],"content":"This member function emulates the functionality of the function <bpt id=\"p1\">[</bpt>GetCharWidthI<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144864)</ept>, as described in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"This member function emulates the functionality of the function [GetCharWidthI](http://msdn.microsoft.com/library/windows/desktop/dd144864), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[118530,118545],"content":"CDC::GetClipBox"},{"content":"Retrieves the dimensions of the tightest bounding rectangle around the current clipping boundary.","pos":[118549,118646]},{"content":"Parameters","pos":[118719,118729]},{"content":"Points to the <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure or <bpt id=\"p2\">[</bpt>CRect<ept id=\"p2\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object that is to receive the rectangle dimensions.","pos":[118745,118925],"source":" Points to the [RECT](../../mfc/reference/rect-structure1.md) structure or [CRect](../../atl-mfc-shared/reference/crect-class.md) object that is to receive the rectangle dimensions."},{"content":"Return Value","pos":[118935,118947]},{"content":"The clipping region's type.","pos":[118951,118978]},{"content":"It can be any of the following values:","pos":[118979,119017]},{"pos":[119025,119083],"content":"<bpt id=\"p1\">**</bpt>COMPLEXREGION<ept id=\"p1\">**</ept> Clipping region has overlapping borders.","source":"**COMPLEXREGION** Clipping region has overlapping borders."},{"pos":[119091,119129],"content":"<bpt id=\"p1\">**</bpt>ERROR<ept id=\"p1\">**</ept> Device context is not valid.","source":"**ERROR** Device context is not valid."},{"pos":[119137,119177],"content":"<bpt id=\"p1\">**</bpt>NULLREGION<ept id=\"p1\">**</ept> Clipping region is empty.","source":"**NULLREGION** Clipping region is empty."},{"pos":[119185,119245],"content":"<bpt id=\"p1\">**</bpt>SIMPLEREGION<ept id=\"p1\">**</ept> Clipping region has no overlapping borders.","source":"**SIMPLEREGION** Clipping region has no overlapping borders."},{"content":"Remarks","pos":[119255,119262]},{"pos":[119266,119329],"content":"The dimensions are copied to the buffer pointed to by <ph id=\"ph1\">`lpRect`</ph>.","source":"The dimensions are copied to the buffer pointed to by `lpRect`."},{"pos":[119379,119402],"content":"CDC::GetColorAdjustment"},{"content":"Retrieves the color adjustment values for the device context.","pos":[119406,119467]},{"content":"Parameters","pos":[119559,119569]},{"content":"Points to a <bpt id=\"p1\">[</bpt>COLORADJUSTMENT<ept id=\"p1\">](../../mfc/reference/coloradjustment-structure.md)</ept> data structure to receive the color adjustment values.","pos":[119592,119726],"source":" Points to a [COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md) data structure to receive the color adjustment values."},{"content":"Return Value","pos":[119736,119748]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[119752,119803]},{"pos":[119851,119872],"content":"CDC::GetCurrentBitmap"},{"pos":[119876,119937],"content":"Returns a pointer to the currently selected <ph id=\"ph1\">`CBitmap`</ph> object.","source":"Returns a pointer to the currently selected `CBitmap` object."},{"content":"Return Value","pos":[120000,120012]},{"pos":[120016,120081],"content":"Pointer to a <ph id=\"ph1\">`CBitmap`</ph> object, if successful; otherwise <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"Pointer to a `CBitmap` object, if successful; otherwise **NULL**."},{"content":"Remarks","pos":[120091,120098]},{"content":"This member function may return temporary objects.","pos":[120102,120152]},{"pos":[120199,120219],"content":"CDC::GetCurrentBrush"},{"pos":[120223,120283],"content":"Returns a pointer to the currently selected <ph id=\"ph1\">`CBrush`</ph> object.","source":"Returns a pointer to the currently selected `CBrush` object."},{"content":"Return Value","pos":[120344,120356]},{"pos":[120360,120424],"content":"Pointer to a <ph id=\"ph1\">`CBrush`</ph> object, if successful; otherwise <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"Pointer to a `CBrush` object, if successful; otherwise **NULL**."},{"content":"Remarks","pos":[120434,120441]},{"content":"This member function may return temporary objects.","pos":[120445,120495]},{"pos":[120541,120560],"content":"CDC::GetCurrentFont"},{"pos":[120564,120623],"content":"Returns a pointer to the currently selected <ph id=\"ph1\">`CFont`</ph> object.","source":"Returns a pointer to the currently selected `CFont` object."},{"content":"Return Value","pos":[120682,120694]},{"pos":[120698,120761],"content":"Pointer to a <ph id=\"ph1\">`CFont`</ph> object, if successful; otherwise <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"Pointer to a `CFont` object, if successful; otherwise **NULL**."},{"content":"Remarks","pos":[120771,120778]},{"content":"This member function may return temporary objects.","pos":[120782,120832]},{"pos":[120881,120903],"content":"CDC::GetCurrentPalette"},{"pos":[120907,120969],"content":"Returns a pointer to the currently selected <ph id=\"ph1\">`CPalette`</ph> object.","source":"Returns a pointer to the currently selected `CPalette` object."},{"content":"Return Value","pos":[121034,121046]},{"pos":[121050,121116],"content":"Pointer to a <ph id=\"ph1\">`CPalette`</ph> object, if successful; otherwise <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"Pointer to a `CPalette` object, if successful; otherwise **NULL**."},{"content":"Remarks","pos":[121126,121133]},{"content":"This member function may return temporary objects.","pos":[121137,121187]},{"pos":[121232,121250],"content":"CDC::GetCurrentPen"},{"pos":[121254,121312],"content":"Returns a pointer to the currently selected <ph id=\"ph1\">`CPen`</ph> object.","source":"Returns a pointer to the currently selected `CPen` object."},{"content":"Return Value","pos":[121369,121381]},{"pos":[121385,121447],"content":"Pointer to a <ph id=\"ph1\">`CPen`</ph> object, if successful; otherwise <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"Pointer to a `CPen` object, if successful; otherwise **NULL**."},{"content":"Remarks","pos":[121457,121464]},{"content":"This member function may return temporary objects.","pos":[121468,121518]},{"pos":[121568,121591],"content":"CDC::GetCurrentPosition"},{"content":"Retrieves the current position (in logical coordinates).","pos":[121595,121651]},{"content":"Return Value","pos":[121714,121726]},{"pos":[121730,121772],"content":"The current position as a <ph id=\"ph1\">`CPoint`</ph> object.","source":"The current position as a `CPoint` object."},{"content":"Remarks","pos":[121782,121789]},{"pos":[121793,121859],"content":"The current position can be set with the <ph id=\"ph1\">`MoveTo`</ph> member function.","source":"The current position can be set with the `MoveTo` member function."},{"pos":[121906,121926],"content":"CDC::GetDCBrushColor"},{"content":"Retrieves the current brush color.","pos":[121930,121964]},{"content":"Return Value","pos":[122026,122038]},{"pos":[122042,122197],"content":"If the function succeeds, the return value is the <bpt id=\"p1\">[</bpt>COLORREF<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd183449)</ept> value for the current brush color.","source":"If the function succeeds, the return value is the [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) value for the current brush color."},{"pos":[122204,122263],"content":"If the function fails, the return value is <bpt id=\"p1\">**</bpt>CLR_INVALID<ept id=\"p1\">**</ept>.","source":"If the function fails, the return value is **CLR_INVALID**."},{"content":"Remarks","pos":[122273,122280]},{"pos":[122284,122499],"content":"This member function emulates the functionality of the function <bpt id=\"p1\">[</bpt>GetDCBrushColor<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144872)</ept>, as described in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"This member function emulates the functionality of the function [GetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd144872), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[122544,122562],"content":"CDC::GetDCPenColor"},{"content":"Retrieves the current pen color.","pos":[122566,122598]},{"content":"Return Value","pos":[122658,122670]},{"pos":[122674,122827],"content":"If the function succeeds, the return value is the <bpt id=\"p1\">[</bpt>COLORREF<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd183449)</ept> value for the current pen color.","source":"If the function succeeds, the return value is the [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) value for the current pen color."},{"pos":[122834,122893],"content":"If the function fails, the return value is <bpt id=\"p1\">**</bpt>CLR_INVALID<ept id=\"p1\">**</ept>.","source":"If the function fails, the return value is **CLR_INVALID**."},{"content":"Remarks","pos":[122903,122910]},{"pos":[122914,123112],"content":"This member function utilizes the Win32 function <bpt id=\"p1\">[</bpt>GetDCPenColor<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144875)</ept>, as described in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"This member function utilizes the Win32 function [GetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd144875), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[123157,123175],"content":"CDC::GetDeviceCaps"},{"content":"Retrieves a wide range of device-specific information about the display device.","pos":[123179,123258]},{"content":"Parameters","pos":[123323,123333]},{"content":"Specifies the type of information to return.","pos":[123349,123393]},{"content":"See <bpt id=\"p1\">[</bpt>GetDeviceCaps<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144877)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph> for a list of values.","pos":[123394,123554],"source":" See [GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a list of values."},{"content":"Return Value","pos":[123564,123576]},{"content":"The value of the requested capability if the function is successful.","pos":[123580,123648]},{"content":"Example","pos":[123658,123665]},{"pos":[123670,123787],"content":"See the example for <bpt id=\"p1\">[</bpt>CPrintDialog::GetDefaults<ept id=\"p1\">](../../mfc/reference/cprintdialog-class.md#cprintdialog__getdefaults)</ept>.","source":"See the example for [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#cprintdialog__getdefaults)."},{"pos":[123830,123846],"content":"CDC::GetFontData"},{"content":"Retrieves font-metric information from a scalable font file.","pos":[123850,123910]},{"content":"Parameters","pos":[124046,124056]},{"content":"Specifies the name of the metric table to be returned.","pos":[124073,124127]},{"content":"This parameter can be one of the metric tables documented in the TrueType Font Files specification published by Microsoft Corporation.","pos":[124128,124262]},{"content":"If this parameter is 0, the information is retrieved starting at the beginning of the font file.","pos":[124263,124359]},{"content":"Specifies the offset from the beginning of the table at which to begin retrieving information.","pos":[124380,124474]},{"content":"If this parameter is 0, the information is retrieved starting at the beginning of the table specified by the <ph id=\"ph1\">`dwTable`</ph> parameter.","pos":[124475,124604],"source":" If this parameter is 0, the information is retrieved starting at the beginning of the table specified by the `dwTable` parameter."},{"content":"If this value is greater than or equal to the size of the table, <ph id=\"ph1\">`GetFontData`</ph> returns 0.","pos":[124605,124694],"source":" If this value is greater than or equal to the size of the table, `GetFontData` returns 0."},{"content":"Points to a buffer that will receive the font information.","pos":[124713,124771]},{"content":"If this value is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the function returns the size of the buffer required for the font data specified in the <ph id=\"ph1\">`dwTable`</ph> parameter.","pos":[124772,124907],"source":" If this value is **NULL**, the function returns the size of the buffer required for the font data specified in the `dwTable` parameter."},{"content":"Specifies the length, in bytes, of the information to be retrieved.","pos":[124926,124993]},{"content":"If this parameter is 0, <ph id=\"ph1\">`GetFontData`</ph> returns the size of the data specified in the <ph id=\"ph2\">`dwTable`</ph> parameter.","pos":[124994,125098],"source":" If this parameter is 0, `GetFontData` returns the size of the data specified in the `dwTable` parameter."},{"content":"Return Value","pos":[125108,125120]},{"pos":[125124,125244],"content":"Specifies the number of bytes returned in the buffer pointed to by <ph id=\"ph1\">`lpData`</ph> if the function is successful; otherwise –1.","source":"Specifies the number of bytes returned in the buffer pointed to by `lpData` if the function is successful; otherwise –1."},{"content":"Remarks","pos":[125254,125261]},{"content":"The information to retrieve is identified by specifying an offset into the font file and the length of the information to return.","pos":[125265,125394]},{"content":"An application can sometimes use the <ph id=\"ph1\">`GetFontData`</ph> member function to save a TrueType font with a document.","pos":[125401,125508],"source":"An application can sometimes use the `GetFontData` member function to save a TrueType font with a document."},{"content":"To do this, the application determines whether the font can be embedded and then retrieves the entire font file, specifying 0 for the <ph id=\"ph1\">`dwTable`</ph>, <ph id=\"ph2\">`dwOffset`</ph>, and <ph id=\"ph3\">`cbData`</ph> parameters.","pos":[125509,125690],"source":" To do this, the application determines whether the font can be embedded and then retrieves the entire font file, specifying 0 for the `dwTable`, `dwOffset`, and `cbData` parameters."},{"content":"Applications can determine whether a font can be embedded by checking the <bpt id=\"p1\">**</bpt>otmfsType<ept id=\"p1\">**</ept> member of the <bpt id=\"p2\">[</bpt>OUTLINETEXTMETRIC<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/dd162755)</ept> structure.","pos":[125697,125889],"source":"Applications can determine whether a font can be embedded by checking the **otmfsType** member of the [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structure."},{"content":"If bit 1 of <bpt id=\"p1\">**</bpt>otmfsType<ept id=\"p1\">**</ept> is set, embedding is not permitted for the font.","pos":[125890,125964],"source":" If bit 1 of **otmfsType** is set, embedding is not permitted for the font."},{"content":"If bit 1 is clear, the font can be embedded.","pos":[125965,126009]},{"content":"If bit 2 is set, the embedding is read only.","pos":[126010,126054]},{"pos":[126061,126203],"content":"If an application attempts to use this function to retrieve information for a non-TrueType font, the <ph id=\"ph1\">`GetFontData`</ph> member function returns –1.","source":"If an application attempts to use this function to retrieve information for a non-TrueType font, the `GetFontData` member function returns –1."},{"pos":[126254,126278],"content":"CDC::GetFontLanguageInfo"},{"content":"Returns information about the currently selected font for the specified display context.","pos":[126282,126370]},{"content":"Return Value","pos":[126433,126445]},{"content":"The return value identifies characteristics of the currently selected font.","pos":[126449,126524]},{"content":"For a complete listing of possible values, see <bpt id=\"p1\">[</bpt>GetFontLanguageInfo<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144886)</ept>.","pos":[126525,126654],"source":" For a complete listing of possible values, see [GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886)."},{"content":"Remarks","pos":[126664,126671]},{"pos":[126675,126894],"content":"This member function emulates the functionality of the function <bpt id=\"p1\">[</bpt>GetFontLanguageInfo<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144886)</ept>, as described in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"This member function emulates the functionality of the function [GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[126941,126961],"content":"CDC::GetGlyphOutline"},{"content":"Retrieves the outline curve or bitmap for an outline character in the current font.","pos":[126965,127048]},{"content":"Parameters","pos":[127240,127250]},{"content":"Specifies the character for which information is to be returned.","pos":[127265,127329]},{"content":"Specifies the format in which the function is to return information.","pos":[127349,127417]},{"content":"It can be one of the following values, or 0:","pos":[127418,127462]},{"content":"Value","pos":[127469,127474]},{"content":"Meaning","pos":[127475,127482]},{"content":"GGO_BITMAP","pos":[127519,127529]},{"content":"Returns the glyph bitmap.","pos":[127532,127557]},{"content":"When the function returns, the buffer pointed to by <ph id=\"ph1\">`lpBuffer`</ph> contains a 1-bit-per-pixel bitmap whose rows start on doubleword boundaries.","pos":[127558,127697],"source":" When the function returns, the buffer pointed to by `lpBuffer` contains a 1-bit-per-pixel bitmap whose rows start on doubleword boundaries."},{"content":"GGO_NATIVE","pos":[127704,127714]},{"content":"Returns the curve data points in the rasterizer's native format, using device units.","pos":[127717,127801]},{"content":"When this value is specified, any transformation specified in <ph id=\"ph1\">`lpmat2`</ph> is ignored.","pos":[127802,127884],"source":" When this value is specified, any transformation specified in `lpmat2` is ignored."},{"pos":[127892,128074],"content":"When the value of <ph id=\"ph1\">`nFormat`</ph> is 0, the function fills in a <bpt id=\"p1\">[</bpt>GLYPHMETRICS<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144955)</ept> structure but does not return glyph-outline data.","source":"When the value of `nFormat` is 0, the function fills in a [GLYPHMETRICS](http://msdn.microsoft.com/library/windows/desktop/dd144955) structure but does not return glyph-outline data."},{"content":"lpgm","pos":[128082,128086]},{"content":"Points to a <bpt id=\"p1\">**</bpt>GLYPHMETRICS<ept id=\"p1\">**</ept> structure that describes the placement of the glyph in the character cell.","pos":[128091,128194],"source":" Points to a **GLYPHMETRICS** structure that describes the placement of the glyph in the character cell."},{"content":"Specifies the size of the buffer into which the function copies information about the outline character.","pos":[128215,128319]},{"content":"If this value is 0 and the <ph id=\"ph1\">`nFormat`</ph> parameter is either the <bpt id=\"p1\">**</bpt>GGO_BITMAP<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>GGO_NATIVE<ept id=\"p2\">**</ept> values, the function returns the required size of the buffer.","pos":[128320,128475],"source":" If this value is 0 and the `nFormat` parameter is either the **GGO_BITMAP** or **GGO_NATIVE** values, the function returns the required size of the buffer."},{"content":"Points to a buffer into which the function copies information about the outline character.","pos":[128496,128586]},{"content":"If <ph id=\"ph1\">`nFormat`</ph> specifies the <bpt id=\"p1\">**</bpt>GGO_NATIVE<ept id=\"p1\">**</ept> value, the information is copied in the form of <bpt id=\"p2\">**</bpt>TTPOLYGONHEADER<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>TTPOLYCURVE<ept id=\"p3\">**</ept> structures.","pos":[128587,128728],"source":" If `nFormat` specifies the **GGO_NATIVE** value, the information is copied in the form of **TTPOLYGONHEADER** and **TTPOLYCURVE** structures."},{"content":"If this value is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`nFormat`</ph> is either the <bpt id=\"p2\">**</bpt>GGO_BITMAP<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>GGO_NATIVE<ept id=\"p3\">**</ept> value, the function returns the required size of the buffer.","pos":[128729,128876],"source":" If this value is **NULL** and `nFormat` is either the **GGO_BITMAP** or **GGO_NATIVE** value, the function returns the required size of the buffer."},{"content":"Points to a <bpt id=\"p1\">[</bpt>MAT2<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145048)</ept> structure that contains a transformation matrix for the character.","pos":[128895,129040],"source":" Points to a [MAT2](http://msdn.microsoft.com/library/windows/desktop/dd145048) structure that contains a transformation matrix for the character."},{"content":"This parameter cannot be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, even when the <bpt id=\"p2\">**</bpt>GGO_NATIVE<ept id=\"p2\">**</ept> value is specified for <ph id=\"ph1\">`nFormat`</ph>.","pos":[129041,129138],"source":" This parameter cannot be **NULL**, even when the **GGO_NATIVE** value is specified for `nFormat`."},{"content":"Return Value","pos":[129148,129160]},{"content":"The size, in bytes, of the buffer required for the retrieved information if <ph id=\"ph1\">`cbBuffer`</ph> is 0 or <ph id=\"ph2\">`lpBuffer`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[129164,129282],"source":"The size, in bytes, of the buffer required for the retrieved information if `cbBuffer` is 0 or `lpBuffer` is **NULL**."},{"content":"Otherwise, it is a positive value if the function is successful, or –1 if there is an error.","pos":[129283,129375]},{"content":"Remarks","pos":[129385,129392]},{"pos":[129396,129545],"content":"An application can rotate characters retrieved in bitmap format by specifying a 2-by-2 transformation matrix in the structure pointed to by <ph id=\"ph1\">`lpmat2`</ph>.","source":"An application can rotate characters retrieved in bitmap format by specifying a 2-by-2 transformation matrix in the structure pointed to by `lpmat2`."},{"content":"A glyph outline is returned as a series of contours.","pos":[129552,129604]},{"content":"Each contour is defined by a <bpt id=\"p1\">[</bpt>TTPOLYGONHEADER<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145158)</ept> structure followed by as many <bpt id=\"p2\">**</bpt>TTPOLYCURVE<ept id=\"p2\">**</ept> structures as are required to describe it.","pos":[129605,129800],"source":" Each contour is defined by a [TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158) structure followed by as many **TTPOLYCURVE** structures as are required to describe it."},{"content":"All points are returned as <bpt id=\"p1\">[</bpt>POINTFX<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162806)</ept> structures and represent absolute positions, not relative moves.","pos":[129801,129962],"source":" All points are returned as [POINTFX](http://msdn.microsoft.com/library/windows/desktop/dd162806) structures and represent absolute positions, not relative moves."},{"content":"The starting point given by the <bpt id=\"p1\">**</bpt>pfxStart<ept id=\"p1\">**</ept> member of the <bpt id=\"p2\">[</bpt>TTPOLYGONHEADER<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/dd145158)</ept> structure is the point at which the outline for a contour begins.","pos":[129963,130165],"source":" The starting point given by the **pfxStart** member of the [TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158) structure is the point at which the outline for a contour begins."},{"content":"The <bpt id=\"p1\">[</bpt>TTPOLYCURVE<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145157)</ept> structures that follow can be either polyline records or spline records.","pos":[130166,130316],"source":" The [TTPOLYCURVE](http://msdn.microsoft.com/library/windows/desktop/dd145157) structures that follow can be either polyline records or spline records."},{"content":"Polyline records are a series of points; lines drawn between the points describe the outline of the character.","pos":[130317,130427]},{"content":"Spline records represent the quadratic curves used by TrueType (that is, quadratic b-splines).","pos":[130428,130522]},{"pos":[130569,130589],"content":"CDC::GetGraphicsMode"},{"content":"Retrieves the current graphics mode for the specified device context.","pos":[130593,130662]},{"content":"Return Value","pos":[130719,130731]},{"content":"Returns the current graphics mode on success.","pos":[130735,130780]},{"content":"For a list of the values that this method can return, see <bpt id=\"p1\">[</bpt>GetGraphicsMode<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144892)</ept>.","pos":[130781,130917],"source":" For a list of the values that this method can return, see [GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892)."},{"content":"Returns 0 on failure.","pos":[130924,130945]},{"pos":[130952,131067],"content":"To get extended error information, call <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms679360)</ept>.","source":"To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)."},{"content":"Remarks","pos":[131077,131084]},{"pos":[131088,131209],"content":"This method wraps the Windows GDI function <bpt id=\"p1\">[</bpt>GetGraphicsMode<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144892)</ept>.","source":"This method wraps the Windows GDI function [GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892)."},{"pos":[131257,131278],"content":"CDC::GetHalftoneBrush"},{"content":"Call this member function to retrieve a halftone brush.","pos":[131282,131337]},{"content":"Return Value","pos":[131404,131416]},{"pos":[131420,131485],"content":"A pointer to a <ph id=\"ph1\">`CBrush`</ph> object if successful; otherwise <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"A pointer to a `CBrush` object if successful; otherwise **NULL**."},{"content":"Remarks","pos":[131495,131502]},{"content":"A halftone brush shows pixels that are alternately foreground and background colors to create a dithered pattern.","pos":[131506,131619]},{"content":"The following is an example of a dithered pattern created by a halftone brush.","pos":[131620,131698]},{"content":"Detail of a dithered pen stroke","pos":[131707,131738]},{"pos":[131835,131855],"content":"CDC::GetKerningPairs"},{"content":"Retrieves the character kerning pairs for the font that is currently selected in the specified device context.","pos":[131859,131969]},{"content":"Parameters","pos":[132072,132082]},{"content":"Specifies the number of <bpt id=\"p1\">[</bpt>KERNINGPAIR<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145024)</ept> structures pointed to by <ph id=\"ph1\">`lpkrnpair`</ph>.","pos":[132098,132233],"source":" Specifies the number of [KERNINGPAIR](http://msdn.microsoft.com/library/windows/desktop/dd145024) structures pointed to by `lpkrnpair`."},{"content":"The function will not copy more kerning pairs than specified by <ph id=\"ph1\">`nPairs`</ph>.","pos":[132234,132307],"source":" The function will not copy more kerning pairs than specified by `nPairs`."},{"content":"Points to an array of <bpt id=\"p1\">**</bpt>KERNINGPAIR<ept id=\"p1\">**</ept> structures that receive the kerning pairs when the function returns.","pos":[132329,132435],"source":" Points to an array of **KERNINGPAIR** structures that receive the kerning pairs when the function returns."},{"content":"This array must contain at least as many structures as specified by <ph id=\"ph1\">`nPairs`</ph>.","pos":[132436,132513],"source":" This array must contain at least as many structures as specified by `nPairs`."},{"content":"If this parameter is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the function returns the total number of kerning pairs for the font.","pos":[132514,132613],"source":" If this parameter is **NULL**, the function returns the total number of kerning pairs for the font."},{"content":"Return Value","pos":[132623,132635]},{"content":"Specifies the number of kerning pairs retrieved or the total number of kerning pairs in the font, if the function is successful.","pos":[132639,132767]},{"content":"Zero is returned if the function fails or there are no kerning pairs for the font.","pos":[132768,132850]},{"pos":[132891,132905],"content":"CDC::GetLayout"},{"content":"Call this member function to determine the layout of the text and graphics for a device context, such as a printer or a metafile.","pos":[132909,133038]},{"content":"Return Value","pos":[133091,133103]},{"content":"If successful, the layout flags for the current device context.","pos":[133107,133170]},{"content":"Otherwise, <bpt id=\"p1\">**</bpt>GDI_ERROR<ept id=\"p1\">**</ept>.","pos":[133171,133196],"source":" Otherwise, **GDI_ERROR**."},{"content":"For extended error information, call <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms679360)</ept>.","pos":[133197,133309],"source":" For extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)."},{"content":"For a list of the layout flags, see <bpt id=\"p1\">[</bpt>CDC::SetLayout<ept id=\"p1\">](#cdc__setlayout)</ept>.","pos":[133310,133380],"source":" For a list of the layout flags, see [CDC::SetLayout](#cdc__setlayout)."},{"content":"Remarks","pos":[133390,133397]},{"content":"The default layout is left to right.","pos":[133401,133437]},{"pos":[133479,133494],"content":"CDC::GetMapMode"},{"content":"Retrieves the current mapping mode.","pos":[133498,133533]},{"content":"Return Value","pos":[133585,133597]},{"content":"The mapping mode.","pos":[133601,133618]},{"content":"Remarks","pos":[133628,133635]},{"pos":[133639,133716],"content":"For a description of the mapping modes, see the <ph id=\"ph1\">`SetMapMode`</ph> member function.","source":"For a description of the mapping modes, see the `SetMapMode` member function."},{"pos":[133724,133967],"content":"[!NOTE]\n If you call [SetLayout](#cdc__setlayout) to change the DC to right-to-left layout, **SetLayout** automatically changes the mapping mode to `MM_ISOTROPIC`. Consequently, any subsequent call to `GetMapMode` will return `MM_ISOTROPIC`.","leadings":["","> "],"nodes":[{"content":" If you call [SetLayout](#cdc__setlayout) to change the DC to right-to-left layout, **SetLayout** automatically changes the mapping mode to `MM_ISOTROPIC`. Consequently, any subsequent call to `GetMapMode` will return `MM_ISOTROPIC`.","pos":[8,241],"nodes":[{"content":"If you call <bpt id=\"p1\">[</bpt>SetLayout<ept id=\"p1\">](#cdc__setlayout)</ept> to change the DC to right-to-left layout, <bpt id=\"p2\">**</bpt>SetLayout<ept id=\"p2\">**</ept> automatically changes the mapping mode to <ph id=\"ph1\">`MM_ISOTROPIC`</ph>.","pos":[1,155],"source":" If you call [SetLayout](#cdc__setlayout) to change the DC to right-to-left layout, **SetLayout** automatically changes the mapping mode to `MM_ISOTROPIC`."},{"content":"Consequently, any subsequent call to <ph id=\"ph1\">`GetMapMode`</ph> will return <ph id=\"ph2\">`MM_ISOTROPIC`</ph>.","pos":[156,233],"source":" Consequently, any subsequent call to `GetMapMode` will return `MM_ISOTROPIC`."}]}]},{"pos":[134012,134030],"content":"CDC::GetMiterLimit"},{"content":"Returns the miter limit for the device context.","pos":[134034,134081]},{"content":"Return Value","pos":[134138,134150]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[134154,134205]},{"content":"Remarks","pos":[134215,134222]},{"content":"The miter limit is used when drawing geometric lines that have miter joins.","pos":[134226,134301]},{"pos":[134348,134368],"content":"CDC::GetNearestColor"},{"content":"Returns the solid color that best matches a specified logical color.","pos":[134372,134440]},{"content":"Parameters","pos":[134518,134528]},{"content":"Specifies the color to be matched.","pos":[134545,134579]},{"content":"Return Value","pos":[134589,134601]},{"pos":[134605,134733],"content":"An RGB (red, green, blue) color value that defines the solid color closest to the <ph id=\"ph1\">`crColor`</ph> value that the device can represent.","source":"An RGB (red, green, blue) color value that defines the solid color closest to the `crColor` value that the device can represent."},{"content":"Remarks","pos":[134743,134750]},{"content":"The given device must be able to represent this color.","pos":[134754,134808]},{"pos":[134861,134887],"content":"CDC::GetOutlineTextMetrics"},{"content":"Retrieves metric information for TrueType fonts.","pos":[134891,134939]},{"content":"Parameters","pos":[135052,135062]},{"content":"Points to an array of <bpt id=\"p1\">[</bpt>OUTLINETEXTMETRIC<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162755)</ept> structures.","pos":[135077,135190],"source":" Points to an array of [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structures."},{"content":"If this parameter is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the function returns the size of the buffer required for the retrieved metric data.","pos":[135191,135305],"source":" If this parameter is **NULL**, the function returns the size of the buffer required for the retrieved metric data."},{"content":"Specifies the size, in bytes, of the buffer to which information is returned.","pos":[135324,135401]},{"content":"Points to an <bpt id=\"p1\">**</bpt>OUTLINETEXTMETRIC<ept id=\"p1\">**</ept> structure.","pos":[135419,135464],"source":" Points to an **OUTLINETEXTMETRIC** structure."},{"content":"If this parameter is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the function returns the size of the buffer required for the retrieved metric information.","pos":[135465,135586],"source":" If this parameter is **NULL**, the function returns the size of the buffer required for the retrieved metric information."},{"content":"Return Value","pos":[135596,135608]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[135612,135663]},{"content":"Remarks","pos":[135673,135680]},{"content":"The <bpt id=\"p1\">[</bpt>OUTLINETEXTMETRIC<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162755)</ept> structure contains most of the font metric information provided with the TrueType format, including a <bpt id=\"p2\">[</bpt>TEXTMETRIC<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/dd145132)</ept> structure.","pos":[135684,135953],"source":"The [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structure contains most of the font metric information provided with the TrueType format, including a [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure."},{"content":"The last four members of the <bpt id=\"p1\">**</bpt>OUTLINETEXTMETRIC<ept id=\"p1\">**</ept> structure are pointers to strings.","pos":[135954,136039],"source":" The last four members of the **OUTLINETEXTMETRIC** structure are pointers to strings."},{"content":"Applications should allocate space for these strings in addition to the space required for the other members.","pos":[136040,136149]},{"content":"Because there is no system-imposed limit to the size of the strings, the simplest method for allocating memory is to retrieve the required size by specifying <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> for <ph id=\"ph1\">`lpotm`</ph> in the first call to the <ph id=\"ph2\">`GetOutlineTextMetrics`</ph> function.","pos":[136150,136387],"source":" Because there is no system-imposed limit to the size of the strings, the simplest method for allocating memory is to retrieve the required size by specifying **NULL** for `lpotm` in the first call to the `GetOutlineTextMetrics` function."},{"pos":[136437,136460],"content":"CDC::GetOutputCharWidth"},{"pos":[136464,136614],"content":"Uses the output device context, <ph id=\"ph1\">`m_hDC`</ph>, and retrieves the widths of individual characters in a consecutive group of characters from the current font.","source":"Uses the output device context, `m_hDC`, and retrieves the widths of individual characters in a consecutive group of characters from the current font."},{"content":"Parameters","pos":[136739,136749]},{"content":"Specifies the first character in a consecutive group of characters in the current font.","pos":[136769,136856]},{"content":"Specifies the last character in a consecutive group of characters in the current font.","pos":[136878,136964]},{"content":"Points to a buffer that will receive the width values for a consecutive group of characters in the current font.","pos":[136985,137097]},{"content":"Return Value","pos":[137107,137119]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[137123,137174]},{"content":"Remarks","pos":[137184,137191]},{"pos":[137195,137355],"content":"For example, if <ph id=\"ph1\">`nFirstChar`</ph> identifies the letter 'a' and <ph id=\"ph2\">`nLastChar`</ph> identifies the letter 'z', the function retrieves the widths of all lowercase characters.","source":"For example, if `nFirstChar` identifies the letter 'a' and `nLastChar` identifies the letter 'z', the function retrieves the widths of all lowercase characters."},{"content":"The function stores the values in the buffer pointed to by <ph id=\"ph1\">`lpBuffer`</ph>.","pos":[137362,137432],"source":"The function stores the values in the buffer pointed to by `lpBuffer`."},{"content":"This buffer must be large enough to hold all of the widths; that is, there must be at least 26 entries in the example given.","pos":[137433,137557]},{"content":"If a character in the consecutive group of characters does not exist in a particular font, it will be assigned the width value of the default character.","pos":[137564,137716]},{"pos":[137773,137803],"content":"CDC::GetOutputTabbedTextExtent"},{"pos":[137807,137941],"content":"Call this member function to compute the width and height of a character string using <bpt id=\"p1\">[</bpt>m_hDC<ept id=\"p1\">](#cdc__m_hdc)</ept>, the output device context.","source":"Call this member function to compute the width and height of a character string using [m_hDC](#cdc__m_hdc), the output device context."},{"content":"Parameters","pos":[138236,138246]},{"content":"Points to a character string to be measured.","pos":[138266,138310]},{"content":"You can also pass a <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object for this parameter.","pos":[138311,138417],"source":" You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter."},{"content":"Specifies the number of characters in the string.","pos":[138436,138485]},{"content":"If <ph id=\"ph1\">`nCount`</ph> is –1, the length is calculated.","pos":[138486,138530],"source":" If `nCount` is –1, the length is calculated."},{"content":"Specifies the number of tab-stop positions in the array pointed to by <ph id=\"ph1\">`lpnTabStopPositions`</ph>.","pos":[138556,138648],"source":" Specifies the number of tab-stop positions in the array pointed to by `lpnTabStopPositions`."},{"content":"Points to an array of integers containing the tab-stop positions in logical units.","pos":[138680,138762]},{"content":"The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array.","pos":[138763,138872]},{"content":"Back tabs are not allowed.","pos":[138873,138899]},{"content":"A <ph id=\"ph1\">`CString`</ph> object that contains the specified characters to be measured.","pos":[138915,138988],"source":" A `CString` object that contains the specified characters to be measured."},{"content":"Return Value","pos":[138998,139010]},{"pos":[139014,139129],"content":"The dimensions of the string (in logical units) in a <bpt id=\"p1\">[</bpt>CSize<ept id=\"p1\">](../../atl-mfc-shared/reference/csize-class.md)</ept> object.","source":"The dimensions of the string (in logical units) in a [CSize](../../atl-mfc-shared/reference/csize-class.md) object."},{"content":"Remarks","pos":[139139,139146]},{"content":"If the string contains one or more tab characters, the width of the string is based upon the tab stops specified by <ph id=\"ph1\">`lpnTabStopPositions`</ph>.","pos":[139150,139288],"source":"If the string contains one or more tab characters, the width of the string is based upon the tab stops specified by `lpnTabStopPositions`."},{"content":"The function uses the currently selected font to compute the dimensions of the string.","pos":[139289,139375]},{"pos":[139382,139500],"content":"The current clipping region does not offset the width and height returned by the <ph id=\"ph1\">`GetOutputTabbedTextExtent`</ph> function.","source":"The current clipping region does not offset the width and height returned by the `GetOutputTabbedTextExtent` function."},{"content":"Since some devices do not place characters in regular cell arrays (that is, they kern the characters), the sum of the extents of the characters in a string may not be equal to the extent of the string.","pos":[139507,139708]},{"content":"If <ph id=\"ph1\">`nTabPositions`</ph> is 0 and <ph id=\"ph2\">`lpnTabStopPositions`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, tabs are expanded to eight average character widths.","pos":[139715,139830],"source":"If `nTabPositions` is 0 and `lpnTabStopPositions` is **NULL**, tabs are expanded to eight average character widths."},{"content":"If <ph id=\"ph1\">`nTabPositions`</ph> is 1, the tab stops will be separated by the distance specified by the first value in the array to which <ph id=\"ph2\">`lpnTabStopPositions`</ph> points.","pos":[139831,139984],"source":" If `nTabPositions` is 1, the tab stops will be separated by the distance specified by the first value in the array to which `lpnTabStopPositions` points."},{"content":"If <ph id=\"ph1\">`lpnTabStopPositions`</ph> points to more than a single value, a tab stop is set for each value in the array, up to the number specified by <ph id=\"ph2\">`nTabPositions`</ph>.","pos":[139985,140139],"source":" If `lpnTabStopPositions` points to more than a single value, a tab stop is set for each value in the array, up to the number specified by `nTabPositions`."},{"pos":[140190,140214],"content":"CDC::GetOutputTextExtent"},{"pos":[140218,140375],"content":"Call this member function to use the output device context, <bpt id=\"p1\">[</bpt>m_hDC<ept id=\"p1\">](#cdc__m_hdc)</ept>, and compute the width and height of a line of text, using the current font.","source":"Call this member function to use the output device context, [m_hDC](#cdc__m_hdc), and compute the width and height of a line of text, using the current font."},{"content":"Parameters","pos":[140542,140552]},{"content":"Points to a string of characters.","pos":[140572,140605]},{"content":"You can also pass a <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object for this parameter.","pos":[140606,140712],"source":" You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter."},{"content":"Specifies the number of characters in the string.","pos":[140731,140780]},{"content":"If <ph id=\"ph1\">`nCount`</ph> is –1, the length is calculated.","pos":[140781,140825],"source":" If `nCount` is –1, the length is calculated."},{"content":"A <ph id=\"ph1\">`CString`</ph> object that contains the specified characters to be measured.","pos":[140841,140914],"source":" A `CString` object that contains the specified characters to be measured."},{"content":"Return Value","pos":[140924,140936]},{"pos":[140940,141064],"content":"The dimensions of the string (in logical units) returned in a <bpt id=\"p1\">[</bpt>CSize<ept id=\"p1\">](../../atl-mfc-shared/reference/csize-class.md)</ept> object.","source":"The dimensions of the string (in logical units) returned in a [CSize](../../atl-mfc-shared/reference/csize-class.md) object."},{"content":"Remarks","pos":[141074,141081]},{"pos":[141085,141184],"content":"The current clipping region does not affect the width and height returned by <ph id=\"ph1\">`GetOutputTextExtent`</ph>.","source":"The current clipping region does not affect the width and height returned by `GetOutputTextExtent`."},{"content":"Since some devices do not place characters in regular cell arrays (that is, they carry out kerning), the sum of the extents of the characters in a string may not be equal to the extent of the string.","pos":[141191,141390]},{"pos":[141442,141467],"content":"CDC::GetOutputTextMetrics"},{"pos":[141471,141555],"content":"Retrieves the metrics for the current font using <ph id=\"ph1\">`m_hDC`</ph>, the output device context.","source":"Retrieves the metrics for the current font using `m_hDC`, the output device context."},{"content":"Parameters","pos":[141640,141650]},{"content":"Points to the <bpt id=\"p1\">[</bpt>TEXTMETRIC<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145132)</ept> structure that receives the metrics.","pos":[141669,141792],"source":" Points to the [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure that receives the metrics."},{"content":"Return Value","pos":[141802,141814]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[141818,141869]},{"pos":[141908,141920],"content":"CDC::GetPath"},{"content":"Retrieves the coordinates defining the endpoints of lines and the control points of curves found in the path that is selected into the device context.","pos":[141924,142074]},{"content":"Parameters","pos":[142184,142194]},{"content":"Points to an array of <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> data structures or <ph id=\"ph1\">`CPoint`</ph> objects where the line endpoints and curve control points are placed.","pos":[142212,142380],"source":" Points to an array of [POINT](../../mfc/reference/point-structure1.md) data structures or `CPoint` objects where the line endpoints and curve control points are placed."},{"content":"Points to an array of bytes where the vertex types are placed.","pos":[142400,142462]},{"content":"Values are one of the following:","pos":[142463,142495]},{"pos":[142503,142595],"content":"<bpt id=\"p1\">**</bpt>PT_MOVETO<ept id=\"p1\">**</ept> Specifies that the corresponding point in <ph id=\"ph1\">`lpPoints`</ph> starts a disjoint figure.","source":"**PT_MOVETO** Specifies that the corresponding point in `lpPoints` starts a disjoint figure."},{"pos":[142603,142721],"content":"<bpt id=\"p1\">**</bpt>PT_LINETO<ept id=\"p1\">**</ept> Specifies that the previous point and the corresponding point in <ph id=\"ph1\">`lpPoints`</ph> are the endpoints of a line.","source":"**PT_LINETO** Specifies that the previous point and the corresponding point in `lpPoints` are the endpoints of a line."},{"pos":[142729,142851],"content":"<bpt id=\"p1\">**</bpt>PT_BEZIERTO<ept id=\"p1\">**</ept> Specifies that the corresponding point in <ph id=\"ph1\">`lpPoints`</ph> is a control point or ending point for a Bzier curve.","source":"**PT_BEZIERTO** Specifies that the corresponding point in `lpPoints` is a control point or ending point for a Bzier curve."},{"content":"<bpt id=\"p1\">**</bpt>PT_BEZIERTO<ept id=\"p1\">**</ept> types always occur in sets of three.","pos":[142858,142910],"source":"**PT_BEZIERTO** types always occur in sets of three."},{"content":"The point in the path immediately preceding them defines the starting point for the Bzier curve.","pos":[142911,143007]},{"content":"The first two <bpt id=\"p1\">**</bpt>PT_BEZIERTO<ept id=\"p1\">**</ept> points are the control points, and the third <bpt id=\"p2\">**</bpt>PT_BEZIERTO<ept id=\"p2\">**</ept> point is the end point (if hard-coded).","pos":[143008,143138],"source":" The first two **PT_BEZIERTO** points are the control points, and the third **PT_BEZIERTO** point is the end point (if hard-coded)."},{"pos":[143149,143374],"content":"A <bpt id=\"p1\">**</bpt>PT_LINETO<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>PT_BEZIERTO<ept id=\"p2\">**</ept> type may be combined with the following flag (by using the bitwise operator <ph id=\"ph1\">`OR`</ph>) to indicate that the corresponding point is the last point in a figure and that the figure should be closed:","source":"A **PT_LINETO** or **PT_BEZIERTO** type may be combined with the following flag (by using the bitwise operator `OR`) to indicate that the corresponding point is the last point in a figure and that the figure should be closed:"},{"content":"<bpt id=\"p1\">**</bpt>PT_CLOSEFIGURE<ept id=\"p1\">**</ept> Specifies that the figure is automatically closed after the corresponding line or curve is drawn.","pos":[143382,143498],"source":"**PT_CLOSEFIGURE** Specifies that the figure is automatically closed after the corresponding line or curve is drawn."},{"content":"The figure is closed by drawing a line from the line or curve endpoint to the point corresponding to the last <bpt id=\"p1\">**</bpt>PT_MOVETO<ept id=\"p1\">**</ept>.","pos":[143499,143623],"source":" The figure is closed by drawing a line from the line or curve endpoint to the point corresponding to the last **PT_MOVETO**."},{"pos":[143630,143874],"content":"`nCount`  \nSpecifies the total number of [POINT](../../mfc/reference/point-structure1.md) data structures that may be placed in the `lpPoints` array. This value must be the same as the number of bytes that may be placed in the `lpTypes` array.","leadings":[""," "],"nodes":[{"content":"Specifies the total number of [POINT](../../mfc/reference/point-structure1.md) data structures that may be placed in the `lpPoints` array. This value must be the same as the number of bytes that may be placed in the `lpTypes` array.","pos":[11,243],"nodes":[{"content":"Specifies the total number of <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> data structures that may be placed in the <ph id=\"ph1\">`lpPoints`</ph> array.","pos":[0,138],"source":"Specifies the total number of [POINT](../../mfc/reference/point-structure1.md) data structures that may be placed in the `lpPoints` array."},{"content":"This value must be the same as the number of bytes that may be placed in the <ph id=\"ph1\">`lpTypes`</ph> array.","pos":[139,232],"source":" This value must be the same as the number of bytes that may be placed in the `lpTypes` array."}]}]},{"content":"Return Value","pos":[143884,143896]},{"content":"If the <ph id=\"ph1\">`nCount`</ph> parameter is nonzero, the number of points enumerated.","pos":[143900,143970],"source":"If the `nCount` parameter is nonzero, the number of points enumerated."},{"content":"If <ph id=\"ph1\">`nCount`</ph> is 0, the total number of points in the path (and <ph id=\"ph2\">`GetPath`</ph> writes nothing to the buffers).","pos":[143971,144074],"source":" If `nCount` is 0, the total number of points in the path (and `GetPath` writes nothing to the buffers)."},{"content":"If <ph id=\"ph1\">`nCount`</ph> is nonzero and is less than the number of points in the path, the return value is -1.","pos":[144075,144172],"source":" If `nCount` is nonzero and is less than the number of points in the path, the return value is -1."},{"content":"Remarks","pos":[144182,144189]},{"content":"The device context must contain a closed path.","pos":[144193,144239]},{"content":"The points of the path are returned in logical coordinates.","pos":[144240,144299]},{"content":"Points are stored in the path in device coordinates, so <ph id=\"ph1\">`GetPath`</ph> changes the points from device coordinates to logical coordinates by using the inverse of the current transformation.","pos":[144300,144483],"source":" Points are stored in the path in device coordinates, so `GetPath` changes the points from device coordinates to logical coordinates by using the inverse of the current transformation."},{"content":"The <ph id=\"ph1\">`FlattenPath`</ph> member function may be called before <ph id=\"ph2\">`GetPath`</ph>, to convert all curves in the path into line segments.","pos":[144484,144603],"source":" The `FlattenPath` member function may be called before `GetPath`, to convert all curves in the path into line segments."},{"content":"Example","pos":[144613,144620]},{"pos":[144625,144679],"content":"See the example for <bpt id=\"p1\">[</bpt>CDC::BeginPath<ept id=\"p1\">](#cdc__beginpath)</ept>.","source":"See the example for [CDC::BeginPath](#cdc__beginpath)."},{"pos":[144719,144732],"content":"CDC::GetPixel"},{"pos":[144736,144817],"content":"Retrieves the RGB color value of the pixel at the point specified by <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept>.","source":"Retrieves the RGB color value of the pixel at the point specified by *x* and *y*."},{"content":"Parameters","pos":[144943,144953]},{"content":"x","pos":[144958,144959]},{"content":"Specifies the logical x-coordinate of the point to be examined.","pos":[144964,145027]},{"content":"y","pos":[145035,145036]},{"content":"Specifies the logical y-coordinate of the point to be examined.","pos":[145041,145104]},{"content":"Specifies the logical x- and y-coordinates of the point to be examined.","pos":[145122,145193]},{"content":"Return Value","pos":[145203,145215]},{"content":"For either version of the function, an RGB color value for the color of the given point.","pos":[145219,145307]},{"content":"It is –1 if the coordinates do not specify a point in the clipping region.","pos":[145308,145382]},{"content":"Remarks","pos":[145392,145399]},{"content":"The point must be in the clipping region.","pos":[145403,145444]},{"content":"If the point is not in the clipping region, the function has no effect and returns –1.","pos":[145445,145531]},{"content":"Not all devices support the <bpt id=\"p1\">**</bpt>GetPixel<ept id=\"p1\">**</ept> function.","pos":[145538,145588],"source":"Not all devices support the **GetPixel** function."},{"content":"For more information, see the <bpt id=\"p1\">**</bpt>RC_BITBLT<ept id=\"p1\">**</ept> raster capability under the <bpt id=\"p2\">[</bpt>GetDeviceCaps<ept id=\"p2\">](#cdc__getdevicecaps)</ept> member function.","pos":[145589,145714],"source":" For more information, see the **RC_BITBLT** raster capability under the [GetDeviceCaps](#cdc__getdevicecaps) member function."},{"content":"The <bpt id=\"p1\">**</bpt>GetPixel<ept id=\"p1\">**</ept> member function has two forms.","pos":[145721,145768],"source":"The **GetPixel** member function has two forms."},{"content":"The first takes two coordinate values; the second takes either a <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> structure or a <bpt id=\"p2\">[</bpt>CPoint<ept id=\"p2\">](../../atl-mfc-shared/reference/cpoint-class.md)</ept> object.","pos":[145769,145962],"source":" The first takes two coordinate values; the second takes either a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object."},{"pos":[146009,146029],"content":"CDC::GetPolyFillMode"},{"content":"Retrieves the current polygon-filling mode.","pos":[146033,146076]},{"content":"Return Value","pos":[146133,146145]},{"pos":[146149,146242],"content":"The current polygon-filled mode, <bpt id=\"p1\">**</bpt>ALTERNATE<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>WINDING<ept id=\"p2\">**</ept>, if the function is successful.","source":"The current polygon-filled mode, **ALTERNATE** or **WINDING**, if the function is successful."},{"content":"Remarks","pos":[146252,146259]},{"pos":[146263,146352],"content":"See the <ph id=\"ph1\">`SetPolyFillMode`</ph> member function for a description of the polygon-filling modes.","source":"See the `SetPolyFillMode` member function for a description of the polygon-filling modes."},{"pos":[146391,146403],"content":"CDC::GetROP2"},{"content":"Retrieves the current drawing mode.","pos":[146407,146442]},{"content":"Return Value","pos":[146491,146503]},{"content":"The drawing mode.","pos":[146507,146524]},{"content":"For a list of the drawing mode values, see the <ph id=\"ph1\">`SetROP2`</ph> member function.","pos":[146525,146598],"source":" For a list of the drawing mode values, see the `SetROP2` member function."},{"content":"Remarks","pos":[146608,146615]},{"content":"The drawing mode specifies how the colors of the pen and the interior of filled objects are combined with the color already on the display surface.","pos":[146619,146766]},{"pos":[146808,146823],"content":"CDC::GetSafeHdc"},{"pos":[146827,146908],"content":"Call this member function to get <bpt id=\"p1\">[</bpt>m_hDC<ept id=\"p1\">](#cdc__m_hdc)</ept>, the output device context.","source":"Call this member function to get [m_hDC](#cdc__m_hdc), the output device context."},{"content":"Return Value","pos":[146960,146972]},{"content":"A device context handle.","pos":[146976,147000]},{"content":"Remarks","pos":[147010,147017]},{"content":"This member function also works with null pointers.","pos":[147021,147072]},{"pos":[147121,147143],"content":"CDC::GetStretchBltMode"},{"content":"Retrieves the current bitmap-stretching mode.","pos":[147147,147192]},{"content":"Return Value","pos":[147251,147263]},{"pos":[147267,147433],"content":"The return value specifies the current bitmap-stretching mode — <bpt id=\"p1\">**</bpt>STRETCH_ANDSCANS<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>STRETCH_DELETESCANS<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>STRETCH_ORSCANS<ept id=\"p3\">**</ept> — if the function is successful.","source":"The return value specifies the current bitmap-stretching mode — **STRETCH_ANDSCANS**, **STRETCH_DELETESCANS**, or **STRETCH_ORSCANS** — if the function is successful."},{"content":"Remarks","pos":[147443,147450]},{"pos":[147454,147598],"content":"The bitmap-stretching mode defines how information is removed from bitmaps that are stretched or compressed by the <ph id=\"ph1\">`StretchBlt`</ph> member function.","source":"The bitmap-stretching mode defines how information is removed from bitmaps that are stretched or compressed by the `StretchBlt` member function."},{"content":"The <bpt id=\"p1\">**</bpt>STRETCH_ANDSCANS<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>STRETCH_ORSCANS<ept id=\"p2\">**</ept> modes are typically used to preserve foreground pixels in monochrome bitmaps.","pos":[147605,147731],"source":"The **STRETCH_ANDSCANS** and **STRETCH_ORSCANS** modes are typically used to preserve foreground pixels in monochrome bitmaps."},{"content":"The <bpt id=\"p1\">**</bpt>STRETCH_DELETESCANS<ept id=\"p1\">**</ept> mode is typically used to preserve color in color bitmaps.","pos":[147732,147818],"source":" The **STRETCH_DELETESCANS** mode is typically used to preserve color in color bitmaps."},{"pos":[147869,147893],"content":"CDC::GetTabbedTextExtent"},{"pos":[147897,148046],"content":"Call this member function to compute the width and height of a character string using <bpt id=\"p1\">[</bpt>m_hAttribDC<ept id=\"p1\">](#cdc__m_hattribdc)</ept>, the attribute device context.","source":"Call this member function to compute the width and height of a character string using [m_hAttribDC](#cdc__m_hattribdc), the attribute device context."},{"content":"Parameters","pos":[148329,148339]},{"content":"Points to a character string.","pos":[148359,148388]},{"content":"You can also pass a <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object for this parameter.","pos":[148389,148495],"source":" You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter."},{"content":"Specifies the number of characters in the string.","pos":[148514,148563]},{"content":"If <ph id=\"ph1\">`nCount`</ph> is –1, the length is calculated.","pos":[148564,148608],"source":" If `nCount` is –1, the length is calculated."},{"content":"Specifies the number of tab-stop positions in the array pointed to by <ph id=\"ph1\">`lpnTabStopPositions`</ph>.","pos":[148634,148726],"source":" Specifies the number of tab-stop positions in the array pointed to by `lpnTabStopPositions`."},{"content":"Points to an array of integers containing the tab-stop positions in logical units.","pos":[148758,148840]},{"content":"The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array.","pos":[148841,148950]},{"content":"Back tabs are not allowed.","pos":[148951,148977]},{"content":"A <ph id=\"ph1\">`CString`</ph> object that contains the specified characters to be drawn.","pos":[148993,149063],"source":" A `CString` object that contains the specified characters to be drawn."},{"content":"Return Value","pos":[149073,149085]},{"pos":[149089,149204],"content":"The dimensions of the string (in logical units) in a <bpt id=\"p1\">[</bpt>CSize<ept id=\"p1\">](../../atl-mfc-shared/reference/csize-class.md)</ept> object.","source":"The dimensions of the string (in logical units) in a [CSize](../../atl-mfc-shared/reference/csize-class.md) object."},{"content":"Remarks","pos":[149214,149221]},{"content":"If the string contains one or more tab characters, the width of the string is based upon the tab stops specified by <ph id=\"ph1\">`lpnTabStopPositions`</ph>.","pos":[149225,149363],"source":"If the string contains one or more tab characters, the width of the string is based upon the tab stops specified by `lpnTabStopPositions`."},{"content":"The function uses the currently selected font to compute the dimensions of the string.","pos":[149364,149450]},{"pos":[149457,149569],"content":"The current clipping region does not offset the width and height returned by the <ph id=\"ph1\">`GetTabbedTextExtent`</ph> function.","source":"The current clipping region does not offset the width and height returned by the `GetTabbedTextExtent` function."},{"content":"Since some devices do not place characters in regular cell arrays (that is, they kern the characters), the sum of the extents of the characters in a string may not be equal to the extent of the string.","pos":[149576,149777]},{"content":"If <ph id=\"ph1\">`nTabPositions`</ph> is 0 and <ph id=\"ph2\">`lpnTabStopPositions`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, tabs are expanded to eight times the average character width.","pos":[149784,149908],"source":"If `nTabPositions` is 0 and `lpnTabStopPositions` is **NULL**, tabs are expanded to eight times the average character width."},{"content":"If <ph id=\"ph1\">`nTabPositions`</ph> is 1, the tab stops will be separated by the distance specified by the first value in the array to which <ph id=\"ph2\">`lpnTabStopPositions`</ph> points.","pos":[149909,150062],"source":" If `nTabPositions` is 1, the tab stops will be separated by the distance specified by the first value in the array to which `lpnTabStopPositions` points."},{"content":"If <ph id=\"ph1\">`lpnTabStopPositions`</ph> points to more than a single value, a tab stop is set for each value in the array, up to the number specified by <ph id=\"ph2\">`nTabPositions`</ph>.","pos":[150063,150217],"source":" If `lpnTabStopPositions` points to more than a single value, a tab stop is set for each value in the array, up to the number specified by `nTabPositions`."},{"pos":[150261,150278],"content":"CDC::GetTextAlign"},{"content":"Retrieves the status of the text-alignment flags for the device context.","pos":[150282,150354]},{"content":"Return Value","pos":[150409,150421]},{"content":"The status of the text-alignment flags.","pos":[150425,150464]},{"content":"The return value is one or more of the following values:","pos":[150465,150521]},{"pos":[150529,150645],"content":"<bpt id=\"p1\">**</bpt>TA_BASELINE<ept id=\"p1\">**</ept> Specifies alignment of the x-axis and the baseline of the chosen font within the bounding rectangle.","source":"**TA_BASELINE** Specifies alignment of the x-axis and the baseline of the chosen font within the bounding rectangle."},{"pos":[150653,150742],"content":"<bpt id=\"p1\">**</bpt>TA_BOTTOM<ept id=\"p1\">**</ept> Specifies alignment of the x-axis and the bottom of the bounding rectangle.","source":"**TA_BOTTOM** Specifies alignment of the x-axis and the bottom of the bounding rectangle."},{"pos":[150750,150839],"content":"<bpt id=\"p1\">**</bpt>TA_CENTER<ept id=\"p1\">**</ept> Specifies alignment of the y-axis and the center of the bounding rectangle.","source":"**TA_CENTER** Specifies alignment of the y-axis and the center of the bounding rectangle."},{"pos":[150847,150937],"content":"<bpt id=\"p1\">**</bpt>TA_LEFT<ept id=\"p1\">**</ept> Specifies alignment of the y-axis and the left side of the bounding rectangle.","source":"**TA_LEFT** Specifies alignment of the y-axis and the left side of the bounding rectangle."},{"pos":[150945,151014],"content":"<bpt id=\"p1\">**</bpt>TA_NOUPDATECP<ept id=\"p1\">**</ept> Specifies that the current position is not updated.","source":"**TA_NOUPDATECP** Specifies that the current position is not updated."},{"pos":[151022,151114],"content":"<bpt id=\"p1\">**</bpt>TA_RIGHT<ept id=\"p1\">**</ept> Specifies alignment of the y-axis and the right side of the bounding rectangle.","source":"**TA_RIGHT** Specifies alignment of the y-axis and the right side of the bounding rectangle."},{"pos":[151122,151205],"content":"<bpt id=\"p1\">**</bpt>TA_TOP<ept id=\"p1\">**</ept> Specifies alignment of the x-axis and the top of the bounding rectangle.","source":"**TA_TOP** Specifies alignment of the x-axis and the top of the bounding rectangle."},{"pos":[151213,151276],"content":"<bpt id=\"p1\">**</bpt>TA_UPDATECP<ept id=\"p1\">**</ept> Specifies that the current position is updated.","source":"**TA_UPDATECP** Specifies that the current position is updated."},{"content":"Remarks","pos":[151286,151293]},{"content":"The text-alignment flags determine how the <ph id=\"ph1\">`TextOut`</ph> and <ph id=\"ph2\">`ExtTextOut`</ph> member functions align a string of text in relation to the string's starting point.","pos":[151297,151450],"source":"The text-alignment flags determine how the `TextOut` and `ExtTextOut` member functions align a string of text in relation to the string's starting point."},{"content":"The text-alignment flags are not necessarily single-bit flags and may be equal to 0.","pos":[151451,151535]},{"content":"To test whether a flag is set, an application should follow these steps:","pos":[151536,151608]},{"content":"Apply the bitwise OR operator to the flag and its related flags, grouped as follows:","pos":[151618,151702]},{"pos":[151714,151758],"content":"<bpt id=\"p1\">**</bpt>TA_LEFT<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>TA_CENTER<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>TA_RIGHT<ept id=\"p3\">**</ept>","source":"**TA_LEFT**, **TA_CENTER**, and **TA_RIGHT**"},{"pos":[151770,151816],"content":"<bpt id=\"p1\">**</bpt>TA_BASELINE<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>TA_BOTTOM<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>TA_TOP<ept id=\"p3\">**</ept>","source":"**TA_BASELINE**, **TA_BOTTOM**, and **TA_TOP**"},{"pos":[151828,151865],"content":"<bpt id=\"p1\">**</bpt>TA_NOUPDATECP<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>TA_UPDATECP<ept id=\"p2\">**</ept>","source":"**TA_NOUPDATECP** and **TA_UPDATECP**"},{"pos":[151875,151959],"content":"Apply the bitwise-AND operator to the result and the return value of <ph id=\"ph1\">`GetTextAlign`</ph>.","source":"Apply the bitwise-AND operator to the result and the return value of `GetTextAlign`."},{"content":"Test for the equality of this result and the flag.","pos":[151969,152019]},{"pos":[152072,152098],"content":"CDC::GetTextCharacterExtra"},{"content":"Retrieves the current setting for the amount of intercharacter spacing.","pos":[152102,152173]},{"content":"Return Value","pos":[152236,152248]},{"content":"The amount of the intercharacter spacing.","pos":[152252,152293]},{"content":"Remarks","pos":[152303,152310]},{"content":"GDI adds this spacing to each character, including break characters, when it writes a line of text to the device context.","pos":[152314,152435]},{"content":"The default value for the amount of intercharacter spacing is 0.","pos":[152442,152506]},{"pos":[152550,152567],"content":"CDC::GetTextColor"},{"content":"Retrieves the current text color.","pos":[152571,152604]},{"content":"Return Value","pos":[152663,152675]},{"content":"The current text color as an RGB color value.","pos":[152679,152724]},{"content":"Remarks","pos":[152734,152741]},{"pos":[152745,152949],"content":"The text color is the foreground color of characters drawn by using the GDI text-output member functions <bpt id=\"p1\">[</bpt>TextOut<ept id=\"p1\">](#cdc__textout)</ept>, <bpt id=\"p2\">[</bpt>ExtTextOut<ept id=\"p2\">](#cdc__exttextout)</ept>, and <bpt id=\"p3\">[</bpt>TabbedTextOut<ept id=\"p3\">](#cdc__tabbedtextout)</ept>.","source":"The text color is the foreground color of characters drawn by using the GDI text-output member functions [TextOut](#cdc__textout), [ExtTextOut](#cdc__exttextout), and [TabbedTextOut](#cdc__tabbedtextout)."},{"pos":[152994,153012],"content":"CDC::GetTextExtent"},{"content":"Call this member function to compute the width and height of a line of text using the current font to determine the dimensions.","pos":[153016,153143]},{"content":"Parameters","pos":[153298,153308]},{"content":"Points to a string of characters.","pos":[153328,153361]},{"content":"You can also pass a <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object for this parameter.","pos":[153362,153468],"source":" You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter."},{"content":"Specifies the number of characters in the string.","pos":[153487,153536]},{"content":"A <ph id=\"ph1\">`CString`</ph> object that contains the specified characters.","pos":[153552,153610],"source":" A `CString` object that contains the specified characters."},{"content":"Return Value","pos":[153620,153632]},{"pos":[153636,153751],"content":"The dimensions of the string (in logical units) in a <bpt id=\"p1\">[</bpt>CSize<ept id=\"p1\">](../../atl-mfc-shared/reference/csize-class.md)</ept> object.","source":"The dimensions of the string (in logical units) in a [CSize](../../atl-mfc-shared/reference/csize-class.md) object."},{"content":"Remarks","pos":[153761,153768]},{"pos":[153772,153869],"content":"The information is retrieved from <bpt id=\"p1\">[</bpt>m_hAttribDC<ept id=\"p1\">](#cdc__m_hattribdc)</ept>, the attribute device context.","source":"The information is retrieved from [m_hAttribDC](#cdc__m_hattribdc), the attribute device context."},{"content":"By default, <ph id=\"ph1\">`GetTextExtent`</ph> assumes the text for which it retrieves the dimension is set along a horizontal line (that is, the escapement is 0).","pos":[153876,154020],"source":"By default, `GetTextExtent` assumes the text for which it retrieves the dimension is set along a horizontal line (that is, the escapement is 0)."},{"content":"If you create a font specifying a non-zero escapement, you must convert the angle of the text explicitly to get the dimensions of the string.","pos":[154021,154162]},{"pos":[154169,154262],"content":"The current clipping region does not affect the width and height returned by <ph id=\"ph1\">`GetTextExtent`</ph>.","source":"The current clipping region does not affect the width and height returned by `GetTextExtent`."},{"content":"Since some devices do not place characters in regular cell arrays (that is, they carry out kerning), the sum of the extents of the characters in a string may not be equal to the extent of the string.","pos":[154269,154468]},{"pos":[154521,154547],"content":"CDC::GetTextExtentExPointI"},{"content":"Retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters.","pos":[154551,154716]},{"content":"Parameters","pos":[154894,154904]},{"content":"A pointer to an array of glyph indices for which extents are to be retrieved.","pos":[154919,154996]},{"content":"Specifies the number of glyphs in the array pointed to by <ph id=\"ph1\">`pgiIn`</ph>.","pos":[155012,155078],"source":" Specifies the number of glyphs in the array pointed to by `pgiIn`."},{"content":"Specifies the maximum allowable width, in logical units, of the formatted string.","pos":[155101,155182]},{"content":"A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by <ph id=\"ph1\">`nMaxExtent`</ph>.","pos":[155201,155336],"source":" A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by `nMaxExtent`."},{"content":"When <ph id=\"ph1\">`lpnFit`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, <ph id=\"ph2\">`nMaxExtent`</ph> is ignored.","pos":[155337,155388],"source":" When `lpnFit` is **NULL**, `nMaxExtent` is ignored."},{"content":"alpDx","pos":[155396,155401]},{"content":"A pointer to an array of integers that receives partial glyph extents.","pos":[155406,155476]},{"content":"Each element in the array gives the distance, in logical units, between the beginning of the glyph indices array and one of the glyphs that fits in the space specified by <ph id=\"ph1\">`nMaxExtent`</ph>.","pos":[155477,155661],"source":" Each element in the array gives the distance, in logical units, between the beginning of the glyph indices array and one of the glyphs that fits in the space specified by `nMaxExtent`."},{"content":"Although this array should have at least as many elements as glyph indices specified by <ph id=\"ph1\">`cgi`</ph>, the function fills the array with extents only for as many glyph indices as are specified by <ph id=\"ph2\">`lpnFit`</ph>.","pos":[155662,155859],"source":" Although this array should have at least as many elements as glyph indices specified by `cgi`, the function fills the array with extents only for as many glyph indices as are specified by `lpnFit`."},{"content":"If <bpt id=\"p1\">*</bpt>lpnDx<ept id=\"p1\">*</ept> is <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept>, the function does not compute partial string widths.","pos":[155860,155936],"source":" If *lpnDx* is **NULL**, the function does not compute partial string widths."},{"content":"Pointer to a <bpt id=\"p1\">[</bpt>SIZE<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145106)</ept> structure that receives the dimensions of the glyph indices array, in logical units.","pos":[155955,156119],"source":" Pointer to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure that receives the dimensions of the glyph indices array, in logical units."},{"content":"This value cannot be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[156120,156150],"source":" This value cannot be **NULL**."},{"content":"Return Value","pos":[156160,156172]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[156176,156227]},{"content":"Remarks","pos":[156237,156244]},{"pos":[156248,156469],"content":"This member function emulates the functionality of the function <bpt id=\"p1\">[</bpt>GetTextExtentExPointI<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144936)</ept>, as described in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"This member function emulates the functionality of the function [GetTextExtentExPointI](http://msdn.microsoft.com/library/windows/desktop/dd144936), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[156520,156544],"content":"CDC::GetTextExtentPointI"},{"content":"Retrieves the width and height of the specified array of glyph indices.","pos":[156548,156619]},{"content":"Parameters","pos":[156734,156744]},{"content":"A pointer to an array of glyph indices for which extents are to be retrieved.","pos":[156759,156836]},{"content":"Specifies the number of glyphs in the array pointed to by <ph id=\"ph1\">`pgiIn`</ph>.","pos":[156852,156918],"source":" Specifies the number of glyphs in the array pointed to by `pgiIn`."},{"content":"Pointer to a <bpt id=\"p1\">[</bpt>SIZE<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145106)</ept> structure that receives the dimensions of the glyph indices array, in logical units.","pos":[156937,157101],"source":" Pointer to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure that receives the dimensions of the glyph indices array, in logical units."},{"content":"This value cannot be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[157102,157132],"source":" This value cannot be **NULL**."},{"content":"Return Value","pos":[157142,157154]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[157158,157209]},{"content":"Remarks","pos":[157219,157226]},{"pos":[157230,157449],"content":"This member function emulates the functionality of the function <bpt id=\"p1\">[</bpt>GetTextExtentPointI<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144939)</ept>, as described in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"This member function emulates the functionality of the function [GetTextExtentPointI](http://msdn.microsoft.com/library/windows/desktop/dd144939), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[157492,157508],"content":"CDC::GetTextFace"},{"content":"Call this member function to copy the typeface name of the current font into a buffer.","pos":[157512,157598]},{"content":"Parameters","pos":[157744,157754]},{"content":"Specifies the size of the buffer (in bytes).","pos":[157770,157814]},{"content":"If the typeface name is longer than the number of bytes specified by this parameter, the name is truncated.","pos":[157815,157922]},{"content":"lpszFacename","pos":[157930,157942]},{"content":"Points to the buffer for the typeface name.","pos":[157947,157990]},{"content":"A reference to a <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object.","pos":[158010,158094],"source":" A reference to a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object."},{"content":"Return Value","pos":[158104,158116]},{"content":"The number of bytes copied to the buffer, not including the terminating null character.","pos":[158120,158207]},{"content":"It is 0 if an error occurs.","pos":[158208,158235]},{"content":"Remarks","pos":[158245,158252]},{"content":"The typeface name is copied as a null-terminated string.","pos":[158256,158312]},{"pos":[158358,158377],"content":"CDC::GetTextMetrics"},{"content":"Retrieves the metrics for the current font using the attribute device context.","pos":[158381,158459]},{"content":"Parameters","pos":[158538,158548]},{"content":"Points to the <bpt id=\"p1\">[</bpt>TEXTMETRIC<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145132)</ept> structure that receives the metrics.","pos":[158567,158690],"source":" Points to the [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure that receives the metrics."},{"content":"Return Value","pos":[158700,158712]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[158716,158767]},{"pos":[158813,158832],"content":"CDC::GetViewportExt"},{"content":"Retrieves the x- and y-extents of the device context's viewport.","pos":[158836,158900]},{"content":"Return Value","pos":[158958,158970]},{"pos":[158974,159033],"content":"The x- and y-extents (in device units) as a <ph id=\"ph1\">`CSize`</ph> object.","source":"The x- and y-extents (in device units) as a `CSize` object."},{"pos":[159079,159098],"content":"CDC::GetViewportOrg"},{"content":"Retrieves the x- and y-coordinates of the origin of the viewport associated with the device context.","pos":[159102,159202]},{"content":"Return Value","pos":[159261,159273]},{"pos":[159277,159349],"content":"The origin of the viewport (in device coordinates) as a <ph id=\"ph1\">`CPoint`</ph> object.","source":"The origin of the viewport (in device coordinates) as a `CPoint` object."},{"pos":[159390,159404],"content":"CDC::GetWindow"},{"content":"Returns the window associated with the display device context.","pos":[159408,159470]},{"content":"Return Value","pos":[159523,159535]},{"pos":[159539,159600],"content":"Pointer to a <ph id=\"ph1\">`CWnd`</ph> object if successful; otherwise <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"Pointer to a `CWnd` object if successful; otherwise **NULL**."},{"content":"Remarks","pos":[159610,159617]},{"content":"This is an advanced function.","pos":[159621,159650]},{"content":"For example, this member function may not return the view window when printing or in print preview.","pos":[159651,159750]},{"content":"It always returns the window associated with output.","pos":[159751,159803]},{"content":"Output functions that use the given DC draw into this window.","pos":[159804,159865]},{"pos":[159909,159926],"content":"CDC::GetWindowExt"},{"content":"Retrieves the x- and y-extents of the window associated with the device context.","pos":[159930,160010]},{"content":"Return Value","pos":[160066,160078]},{"pos":[160082,160142],"content":"The x- and y-extents (in logical units) as a <ph id=\"ph1\">`CSize`</ph> object.","source":"The x- and y-extents (in logical units) as a `CSize` object."},{"pos":[160186,160203],"content":"CDC::GetWindowOrg"},{"content":"Retrieves the x- and y-coordinates of the origin of the window associated with the device context.","pos":[160207,160305]},{"content":"Return Value","pos":[160362,160374]},{"pos":[160378,160449],"content":"The origin of the window (in logical coordinates) as a <ph id=\"ph1\">`CPoint`</ph> object.","source":"The origin of the window (in logical coordinates) as a `CPoint` object."},{"pos":[160498,160520],"content":"CDC::GetWorldTransform"},{"content":"Retrieves the current world-space to page-space transformation.","pos":[160524,160587]},{"content":"Parameters","pos":[160660,160670]},{"content":"Reference to an <bpt id=\"p1\">[</bpt>XFORM<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145228)</ept> structure that receives the current world-space to page-space transformation.","pos":[160686,160847],"source":" Reference to an [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure that receives the current world-space to page-space transformation."},{"content":"Return Value","pos":[160857,160869]},{"content":"Returns a nonzero value on success.","pos":[160873,160908]},{"content":"Returns 0 on failure.","pos":[160915,160936]},{"pos":[160943,161058],"content":"To get extended error information, call <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms679360)</ept>.","source":"To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)."},{"content":"Remarks","pos":[161068,161075]},{"pos":[161079,161202],"content":"This method wraps the Windows GDI function <bpt id=\"p1\">[</bpt>GetWorldTransform<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144953)</ept>.","source":"This method wraps the Windows GDI function [GetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd144953)."},{"pos":[161246,161263],"content":"CDC::GradientFill"},{"content":"Call this member function to fill rectangle and triangle structures with color that smoothly fades from one side to the other.","pos":[161267,161393]},{"content":"Parameters","pos":[161553,161563]},{"content":"pVertices","pos":[161568,161577]},{"content":"Pointer to an array of <bpt id=\"p1\">[</bpt>TRIVERTEX<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145142)</ept> structures that each define a triangle vertex.","pos":[161582,161723],"source":" Pointer to an array of [TRIVERTEX](http://msdn.microsoft.com/library/windows/desktop/dd145142) structures that each define a triangle vertex."},{"content":"nVertices","pos":[161731,161740]},{"content":"The number of vertices.","pos":[161745,161768]},{"content":"Array of <bpt id=\"p1\">[</bpt>GRADIENT_TRIANGLE<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144959)</ept> structures in triangle mode, or an array of <bpt id=\"p2\">[</bpt>GRADIENT_RECT<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/dd144958)</ept> structures in rectangle mode.","pos":[161786,162024],"source":" Array of [GRADIENT_TRIANGLE](http://msdn.microsoft.com/library/windows/desktop/dd144959) structures in triangle mode, or an array of [GRADIENT_RECT](http://msdn.microsoft.com/library/windows/desktop/dd144958) structures in rectangle mode."},{"content":"nMeshElements","pos":[162032,162045]},{"content":"The number of elements (triangles or rectangles) in <ph id=\"ph1\">`pMesh`</ph>.","pos":[162050,162110],"source":" The number of elements (triangles or rectangles) in `pMesh`."},{"content":"Specifies gradient fill mode.","pos":[162129,162158]},{"content":"For a list of possible values, see <bpt id=\"p1\">[</bpt>GradientFill<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd144957)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[162159,162328],"source":" For a list of possible values, see [GradientFill](http://msdn.microsoft.com/library/windows/desktop/dd144957) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"Return Value","pos":[162338,162350]},{"pos":[162354,162398],"content":"<bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept> if successful; otherwise <bpt id=\"p2\">**</bpt>FALSE<ept id=\"p2\">**</ept>.","source":"**TRUE** if successful; otherwise **FALSE**."},{"content":"Remarks","pos":[162408,162415]},{"pos":[162419,162519],"content":"For more information, see <ph id=\"ph1\">`GradientFill`</ph> in the <ph id=\"ph2\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"For more information, see `GradientFill` in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[162561,162576],"content":"CDC::GrayString"},{"content":"Draws dimmed (gray) text at the given location by writing the text in a memory bitmap, dimming the bitmap, and then copying the bitmap to the display.","pos":[162580,162730]},{"content":"Parameters","pos":[162974,162984]},{"content":"Identifies the brush to be used for dimming (graying).","pos":[163000,163054]},{"content":"Specifies the procedure-instance address of the application-supplied callback function that will draw the string.","pos":[163077,163190]},{"content":"For more information, see the description of the Windows <bpt id=\"p1\">**</bpt>OutputFunc<ept id=\"p1\">**</ept> <bpt id=\"p2\">[</bpt>callback function<ept id=\"p2\">](../../mfc/reference/callback-function-for-cdc-graystring.md)</ept>.","pos":[163191,163344],"source":" For more information, see the description of the Windows **OutputFunc** [callback function](../../mfc/reference/callback-function-for-cdc-graystring.md)."},{"content":"If this parameter is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the system uses the Windows <ph id=\"ph1\">`TextOut`</ph> function to draw the string, and <ph id=\"ph2\">`lpData`</ph> is assumed to be a long pointer to the character string to be output.","pos":[163345,163525],"source":" If this parameter is **NULL**, the system uses the Windows `TextOut` function to draw the string, and `lpData` is assumed to be a long pointer to the character string to be output."},{"content":"Specifies a far pointer to data to be passed to the output function.","pos":[163544,163612]},{"content":"If <ph id=\"ph1\">`lpfnOutput`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, <ph id=\"ph2\">`lpData`</ph> must be a long pointer to the string to be output.","pos":[163613,163701],"source":" If `lpfnOutput` is **NULL**, `lpData` must be a long pointer to the string to be output."},{"content":"Specifies the number of characters to be output.","pos":[163720,163768]},{"content":"If this parameter is 0, <ph id=\"ph1\">`GrayString`</ph> calculates the length of the string (assuming that <ph id=\"ph2\">`lpData`</ph> is a pointer to the string).","pos":[163769,163894],"source":" If this parameter is 0, `GrayString` calculates the length of the string (assuming that `lpData` is a pointer to the string)."},{"content":"If <ph id=\"ph1\">`nCount`</ph> is –1 and the function pointed to by <ph id=\"ph2\">`lpfnOutput`</ph> returns 0, the image is shown but not dimmed.","pos":[163895,164002],"source":" If `nCount` is –1 and the function pointed to by `lpfnOutput` returns 0, the image is shown but not dimmed."},{"content":"x","pos":[164010,164011]},{"content":"Specifies the logical x-coordinate of the starting position of the rectangle that encloses the string.","pos":[164016,164118]},{"content":"y","pos":[164126,164127]},{"content":"Specifies the logical y-coordinate of the starting position of the rectangle that encloses the string.","pos":[164132,164234]},{"content":"Specifies the width (in logical units) of the rectangle that encloses the string.","pos":[164253,164334]},{"content":"If <ph id=\"ph1\">`nWidth`</ph> is 0, <ph id=\"ph2\">`GrayString`</ph> calculates the width of the area, assuming <ph id=\"ph3\">`lpData`</ph> is a pointer to the string.","pos":[164335,164445],"source":" If `nWidth` is 0, `GrayString` calculates the width of the area, assuming `lpData` is a pointer to the string."},{"content":"Specifies the height (in logical units) of the rectangle that encloses the string.","pos":[164465,164547]},{"content":"If <ph id=\"ph1\">`nHeight`</ph> is 0, <ph id=\"ph2\">`GrayString`</ph> calculates the height of the area, assuming <ph id=\"ph3\">`lpData`</ph> is a pointer to the string.","pos":[164548,164660],"source":" If `nHeight` is 0, `GrayString` calculates the height of the area, assuming `lpData` is a pointer to the string."},{"content":"Return Value","pos":[164670,164682]},{"pos":[164686,164886],"content":"Nonzero if the string is drawn, or 0 if either the <ph id=\"ph1\">`TextOut`</ph> function or the application-supplied output function returned 0, or if there was insufficient memory to create a memory bitmap for dimming.","source":"Nonzero if the string is drawn, or 0 if either the `TextOut` function or the application-supplied output function returned 0, or if there was insufficient memory to create a memory bitmap for dimming."},{"content":"Remarks","pos":[164896,164903]},{"content":"The function dims the text regardless of the selected brush and background.","pos":[164907,164982]},{"content":"The <ph id=\"ph1\">`GrayString`</ph> member function uses the currently selected font.","pos":[164983,165049],"source":" The `GrayString` member function uses the currently selected font."},{"content":"The <ph id=\"ph1\">`MM_TEXT`</ph> mapping mode must be selected before using this function.","pos":[165050,165121],"source":" The `MM_TEXT` mapping mode must be selected before using this function."},{"content":"An application can draw dimmed (grayed) strings on devices that support a solid gray color without calling the <ph id=\"ph1\">`GrayString`</ph> member function.","pos":[165128,165268],"source":"An application can draw dimmed (grayed) strings on devices that support a solid gray color without calling the `GrayString` member function."},{"content":"The system color <bpt id=\"p1\">**</bpt>COLOR_GRAYTEXT<ept id=\"p1\">**</ept> is the solid-gray system color used to draw disabled text.","pos":[165269,165363],"source":" The system color **COLOR_GRAYTEXT** is the solid-gray system color used to draw disabled text."},{"content":"The application can call the <bpt id=\"p1\">**</bpt>GetSysColor<ept id=\"p1\">**</ept> Windows function to retrieve the color value of <bpt id=\"p2\">**</bpt>COLOR_GRAYTEXT<ept id=\"p2\">**</ept>.","pos":[165364,165476],"source":" The application can call the **GetSysColor** Windows function to retrieve the color value of **COLOR_GRAYTEXT**."},{"content":"If the color is other than 0 (black), the application can call the <ph id=\"ph1\">`SetTextColor`</ph> member function to set the text color to the color value and then draw the string directly.","pos":[165477,165650],"source":" If the color is other than 0 (black), the application can call the `SetTextColor` member function to set the text color to the color value and then draw the string directly."},{"content":"If the retrieved color is black, the application must call <ph id=\"ph1\">`GrayString`</ph> to dim (gray) the text.","pos":[165651,165746],"source":" If the retrieved color is black, the application must call `GrayString` to dim (gray) the text."},{"content":"If <ph id=\"ph1\">`lpfnOutput`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, GDI uses the Windows <bpt id=\"p2\">[</bpt>TextOut<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/dd145133)</ept> function, and <ph id=\"ph2\">`lpData`</ph> is assumed to be a far pointer to the character to be output.","pos":[165753,165957],"source":"If `lpfnOutput` is **NULL**, GDI uses the Windows [TextOut](http://msdn.microsoft.com/library/windows/desktop/dd145133) function, and `lpData` is assumed to be a far pointer to the character to be output."},{"content":"If the characters to be output cannot be handled by the <ph id=\"ph1\">`TextOut`</ph> member function (for example, the string is stored as a bitmap), the application must supply its own output function.","pos":[165958,166141],"source":" If the characters to be output cannot be handled by the `TextOut` member function (for example, the string is stored as a bitmap), the application must supply its own output function."},{"content":"Also note that all callback functions must trap Microsoft Foundation exceptions before returning to Windows, since exceptions cannot be thrown across callback boundaries.","pos":[166148,166318]},{"content":"For more information about exceptions, see the article <bpt id=\"p1\">[</bpt>Exceptions<ept id=\"p1\">](../../mfc/exception-handling-in-mfc.md)</ept>.","pos":[166319,166427],"source":" For more information about exceptions, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md)."},{"pos":[166434,166562],"content":"The callback function passed to <ph id=\"ph1\">`GrayString`</ph> must use the <ph id=\"ph2\">`__stdcall`</ph> calling convention and must be exported with <ph id=\"ph3\">`__declspec`</ph>.","source":"The callback function passed to `GrayString` must use the `__stdcall` calling convention and must be exported with `__declspec`."},{"pos":[166569,166726],"content":"When the framework is in preview mode, a call to the <ph id=\"ph1\">`GrayString`</ph> member function is translated to a <ph id=\"ph2\">`TextOut`</ph> call, and the callback function is not called.","source":"When the framework is in preview mode, a call to the `GrayString` member function is translated to a `TextOut` call, and the callback function is not called."},{"pos":[166770,166787],"content":"CDC::HIMETRICtoDP"},{"pos":[166791,166864],"content":"Use this function when you convert <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> sizes from OLE to pixels.","source":"Use this function when you convert **HIMETRIC** sizes from OLE to pixels."},{"content":"Parameters","pos":[166932,166942]},{"content":"Points to a <bpt id=\"p1\">[</bpt>SIZE<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145106)</ept> structure or <bpt id=\"p2\">[</bpt>CSize<ept id=\"p2\">](../../atl-mfc-shared/reference/csize-class.md)</ept> object.","pos":[166958,167112],"source":" Points to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure or [CSize](../../atl-mfc-shared/reference/csize-class.md) object."},{"content":"Remarks","pos":[167122,167129]},{"content":"If the mapping mode of the device context object is <ph id=\"ph1\">`MM_LOENGLISH`</ph>, <ph id=\"ph2\">`MM_HIENGLISH`</ph>, <ph id=\"ph3\">`MM_LOMETRIC`</ph> or <ph id=\"ph4\">`MM_HIMETRIC`</ph>, then the conversion is based on the number of pixels in the physical inch.","pos":[167133,167323],"source":"If the mapping mode of the device context object is `MM_LOENGLISH`, `MM_HIENGLISH`, `MM_LOMETRIC` or `MM_HIMETRIC`, then the conversion is based on the number of pixels in the physical inch."},{"content":"If the mapping mode is one of the other non-constrained modes (e.g., <ph id=\"ph1\">`MM_TEXT`</ph>), then the conversion is based on the number of pixels in the logical inch.","pos":[167324,167478],"source":" If the mapping mode is one of the other non-constrained modes (e.g., `MM_TEXT`), then the conversion is based on the number of pixels in the logical inch."},{"pos":[167522,167539],"content":"CDC::HIMETRICtoLP"},{"pos":[167543,167611],"content":"Call this function to convert <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> units into logical units.","source":"Call this function to convert **HIMETRIC** units into logical units."},{"content":"Parameters","pos":[167679,167689]},{"content":"Points to a <bpt id=\"p1\">[</bpt>SIZE<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145106)</ept> structure or <bpt id=\"p2\">[</bpt>CSize<ept id=\"p2\">](../../atl-mfc-shared/reference/csize-class.md)</ept> object.","pos":[167705,167859],"source":" Points to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure or [CSize](../../atl-mfc-shared/reference/csize-class.md) object."},{"content":"Remarks","pos":[167869,167876]},{"pos":[167880,168007],"content":"Use this function when you get <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> sizes from OLE and wish to convert them to your application's natural mapping mode.","source":"Use this function when you get **HIMETRIC** sizes from OLE and wish to convert them to your application's natural mapping mode."},{"content":"The conversion is accomplished by first converting the <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> units into pixels and then converting these units into logical units using the device context's current mapping units.","pos":[168014,168200],"source":"The conversion is accomplished by first converting the **HIMETRIC** units into pixels and then converting these units into logical units using the device context's current mapping units."},{"content":"Note that the extents of the device's window and viewport will affect the result.","pos":[168201,168282]},{"pos":[168331,168353],"content":"CDC::IntersectClipRect"},{"pos":[168357,168495],"content":"Creates a new clipping region by forming the intersection of the current region and the rectangle specified by <ph id=\"ph1\">`x1`</ph>, <ph id=\"ph2\">`y1`</ph>, <ph id=\"ph3\">`x2`</ph>, and <ph id=\"ph4\">`y2`</ph>.","source":"Creates a new clipping region by forming the intersection of the current region and the rectangle specified by `x1`, `y1`, `x2`, and `y2`."},{"content":"Parameters","pos":[168645,168655]},{"content":"Specifies the logical x-coordinate of the upper-left corner of the rectangle.","pos":[168667,168744]},{"content":"Specifies the logical y-coordinate of the upper-left corner of the rectangle.","pos":[168759,168836]},{"content":"Specifies the logical x-coordinate of the lower-right corner of the rectangle.","pos":[168851,168929]},{"content":"Specifies the logical y-coordinate of the lower-right corner of the rectangle.","pos":[168944,169022]},{"content":"Specifies the rectangle.","pos":[169041,169065]},{"content":"You can pass either a <ph id=\"ph1\">`CRect`</ph> object or a pointer to a <ph id=\"ph2\">`RECT`</ph> structure for this parameter.","pos":[169066,169157],"source":" You can pass either a `CRect` object or a pointer to a `RECT` structure for this parameter."},{"content":"Return Value","pos":[169167,169179]},{"content":"The new clipping region's type.","pos":[169183,169214]},{"content":"It can be any one of the following values:","pos":[169215,169257]},{"pos":[169265,169327],"content":"<bpt id=\"p1\">**</bpt>COMPLEXREGION<ept id=\"p1\">**</ept> New clipping region has overlapping borders.","source":"**COMPLEXREGION** New clipping region has overlapping borders."},{"pos":[169335,169373],"content":"<bpt id=\"p1\">**</bpt>ERROR<ept id=\"p1\">**</ept> Device context is not valid.","source":"**ERROR** Device context is not valid."},{"pos":[169381,169425],"content":"<bpt id=\"p1\">**</bpt>NULLREGION<ept id=\"p1\">**</ept> New clipping region is empty.","source":"**NULLREGION** New clipping region is empty."},{"pos":[169433,169497],"content":"<bpt id=\"p1\">**</bpt>SIMPLEREGION<ept id=\"p1\">**</ept> New clipping region has no overlapping borders.","source":"**SIMPLEREGION** New clipping region has no overlapping borders."},{"content":"Remarks","pos":[169507,169514]},{"content":"GDI clips all subsequent output to fit within the new boundary.","pos":[169518,169581]},{"content":"The width and height must not exceed 32,767.","pos":[169582,169626]},{"pos":[169668,169683],"content":"CDC::InvertRect"},{"content":"Inverts the contents of the given rectangle.","pos":[169687,169731]},{"content":"Parameters","pos":[169789,169799]},{"content":"Points to a <ph id=\"ph1\">`RECT`</ph> that contains the logical coordinates of the rectangle to be inverted.","pos":[169815,169904],"source":" Points to a `RECT` that contains the logical coordinates of the rectangle to be inverted."},{"content":"You can also pass a <ph id=\"ph1\">`CRect`</ph> object for this parameter.","pos":[169905,169959],"source":" You can also pass a `CRect` object for this parameter."},{"content":"Remarks","pos":[169969,169976]},{"content":"Inversion is a logical NOT operation and flips the bits of each pixel.","pos":[169980,170050]},{"content":"On monochrome displays, the function makes white pixels black and black pixels white.","pos":[170051,170136]},{"content":"On color displays, the inversion depends on how colors are generated for the display.","pos":[170137,170222]},{"content":"Calling <ph id=\"ph1\">`InvertRect`</ph> twice with the same rectangle restores the display to its previous colors.","pos":[170223,170318],"source":" Calling `InvertRect` twice with the same rectangle restores the display to its previous colors."},{"content":"If the rectangle is empty, nothing is drawn.","pos":[170325,170369]},{"content":"Example","pos":[170379,170386]},{"pos":[170401,170418],"content":"NVC_MFCDocView#36"},{"pos":[170504,170518],"content":"CDC::InvertRgn"},{"pos":[170522,170575],"content":"Inverts the colors in the region specified by <ph id=\"ph1\">`pRgn`</ph>.","source":"Inverts the colors in the region specified by `pRgn`."},{"content":"Parameters","pos":[170628,170638]},{"content":"Identifies the region to be inverted.","pos":[170652,170689]},{"content":"The coordinates for the region are specified in logical units.","pos":[170690,170752]},{"content":"Return Value","pos":[170762,170774]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[170778,170829]},{"content":"Remarks","pos":[170839,170846]},{"content":"On monochrome displays, the function makes white pixels black and black pixels white.","pos":[170850,170935]},{"content":"On color displays, the inversion depends on how the colors are generated for the display.","pos":[170936,171025]},{"pos":[171067,171082],"content":"CDC::IsPrinting"},{"content":"Determines whether the device context is being used for printing.","pos":[171086,171151]},{"content":"Return Value","pos":[171204,171216]},{"pos":[171220,171277],"content":"Nonzero if the <ph id=\"ph1\">`CDC`</ph> object is a printer DC; otherwise 0.","source":"Nonzero if the `CDC` object is a printer DC; otherwise 0."},{"pos":[171315,171326],"content":"CDC::LineTo"},{"pos":[171330,171443],"content":"Draws a line from the current position up to, but not including, the point specified by <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> (or <ph id=\"ph1\">`point`</ph>).","source":"Draws a line from the current position up to, but not including, the point specified by *x* and *y* (or `point`)."},{"content":"Parameters","pos":[171540,171550]},{"content":"x","pos":[171555,171556]},{"content":"Specifies the logical x-coordinate of the endpoint for the line.","pos":[171561,171625]},{"content":"y","pos":[171633,171634]},{"content":"Specifies the logical y-coordinate of the endpoint for the line.","pos":[171639,171703]},{"content":"Specifies the endpoint for the line.","pos":[171721,171757]},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[171758,171840],"source":" You can pass either a **POINT** structure or a `CPoint` object for this parameter."},{"content":"Return Value","pos":[171850,171862]},{"content":"Nonzero if the line is drawn; otherwise 0.","pos":[171866,171908]},{"content":"Remarks","pos":[171918,171925]},{"content":"The line is drawn with the selected pen.","pos":[171929,171969]},{"content":"The current position is set to <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> or to <ph id=\"ph1\">`point`</ph>.","pos":[171970,172024],"source":" The current position is set to *x*, *y* or to `point`."},{"content":"Example","pos":[172034,172041]},{"pos":[172046,172153],"content":"See the example for <bpt id=\"p1\">[</bpt>CRect::CenterPoint<ept id=\"p1\">](../../atl-mfc-shared/reference/crect-class.md#crect__centerpoint)</ept>.","source":"See the example for [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#crect__centerpoint)."},{"pos":[172191,172202],"content":"CDC::LPtoDP"},{"content":"Converts logical units into device units.","pos":[172206,172247]},{"content":"Parameters","pos":[172427,172437]},{"content":"Points to an array of points.","pos":[172455,172484]},{"content":"Each point in the array is a <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> structure or a <bpt id=\"p2\">[</bpt>CPoint<ept id=\"p2\">](../../atl-mfc-shared/reference/cpoint-class.md)</ept> object.","pos":[172485,172642],"source":" Each point in the array is a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object."},{"content":"The number of points in the array.","pos":[172661,172695]},{"content":"Points to a <bpt id=\"p1\">[</bpt>RECT<ept id=\"p1\">](../../mfc/reference/rect-structure1.md)</ept> structure or a <bpt id=\"p2\">[</bpt>CRect<ept id=\"p2\">](../../atl-mfc-shared/reference/crect-class.md)</ept> object.","pos":[172714,172850],"source":" Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object."},{"content":"This parameter is used for the common case of mapping a rectangle from logical to device units.","pos":[172851,172946]},{"content":"Points to a <bpt id=\"p1\">[</bpt>SIZE<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145106)</ept> structure or a <bpt id=\"p2\">[</bpt>CSize<ept id=\"p2\">](../../atl-mfc-shared/reference/csize-class.md)</ept> object.","pos":[172965,173121],"source":" Points to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure or a [CSize](../../atl-mfc-shared/reference/csize-class.md) object."},{"content":"Remarks","pos":[173131,173138]},{"content":"The function maps the coordinates of each point, or dimensions of a size, from GDI's logical coordinate system into a device coordinate system.","pos":[173142,173285]},{"content":"The conversion depends on the current mapping mode and the settings of the origins and extents of the device's window and viewport.","pos":[173286,173417]},{"content":"The x- and y-coordinates of points are 2-byte signed integers in the range –32,768 through 32,767.","pos":[173424,173522]},{"content":"In cases where the mapping mode would result in values larger than these limits, the system sets the values to –32,768 and 32,767, respectively.","pos":[173523,173667]},{"pos":[173711,173728],"content":"CDC::LPtoHIMETRIC"},{"pos":[173732,173800],"content":"Call this function to convert logical units into <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> units.","source":"Call this function to convert logical units into **HIMETRIC** units."},{"content":"Parameters","pos":[173868,173878]},{"content":"Points to a <bpt id=\"p1\">**</bpt>SIZE<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CSize`</ph> object.","pos":[173894,173945],"source":" Points to a **SIZE** structure or a `CSize` object."},{"content":"Remarks","pos":[173955,173962]},{"content":"Use this function when you give <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> sizes to OLE, converting from your application's natural mapping mode.","pos":[173966,174081],"source":"Use this function when you give **HIMETRIC** sizes to OLE, converting from your application's natural mapping mode."},{"content":"Note that the extents of the device's window and viewport will affect the result.","pos":[174082,174163]},{"pos":[174170,174356],"content":"The conversion is accomplished by first converting the logical units into pixels using the device context's current mapping units and then converting these units into <bpt id=\"p1\">**</bpt>HIMETRIC<ept id=\"p1\">**</ept> units.","source":"The conversion is accomplished by first converting the logical units into pixels using the device context's current mapping units and then converting these units into **HIMETRIC** units."},{"pos":[174399,174415],"content":"CDC::m_hAttribDC"},{"pos":[174419,174470],"content":"The attribute device context for this <ph id=\"ph1\">`CDC`</ph> object.","source":"The attribute device context for this `CDC` object."},{"content":"Remarks","pos":[174514,174521]},{"content":"By default, this device context is equal to <ph id=\"ph1\">`m_hDC`</ph>.","pos":[174525,174577],"source":"By default, this device context is equal to `m_hDC`."},{"content":"In general, <ph id=\"ph1\">`CDC`</ph> GDI calls that request information from the device context are directed to <ph id=\"ph2\">`m_hAttribDC`</ph>.","pos":[174578,174685],"source":" In general, `CDC` GDI calls that request information from the device context are directed to `m_hAttribDC`."},{"content":"See the <bpt id=\"p1\">[</bpt>CDC<ept id=\"p1\">](../../mfc/reference/cdc-class.md)</ept> class description for more on the use of these two device contexts.","pos":[174686,174801],"source":" See the [CDC](../../mfc/reference/cdc-class.md) class description for more on the use of these two device contexts."},{"pos":[174838,174848],"content":"CDC::m_hDC"},{"pos":[174852,174900],"content":"The output device context for this <ph id=\"ph1\">`CDC`</ph> object.","source":"The output device context for this `CDC` object."},{"content":"Remarks","pos":[174938,174945]},{"content":"By default, <ph id=\"ph1\">`m_hDC`</ph> is equal to <ph id=\"ph2\">`m_hAttribDC`</ph>, the other device context wrapped by <ph id=\"ph3\">`CDC`</ph>.","pos":[174949,175038],"source":"By default, `m_hDC` is equal to `m_hAttribDC`, the other device context wrapped by `CDC`."},{"content":"In general, <ph id=\"ph1\">`CDC`</ph> GDI calls that create output go to the <ph id=\"ph2\">`m_hDC`</ph> device context.","pos":[175039,175119],"source":" In general, `CDC` GDI calls that create output go to the `m_hDC` device context."},{"content":"You can initialize <ph id=\"ph1\">`m_hDC`</ph> and <ph id=\"ph2\">`m_hAttribDC`</ph> to point to different devices.","pos":[175120,175195],"source":" You can initialize `m_hDC` and `m_hAttribDC` to point to different devices."},{"content":"See the <bpt id=\"p1\">[</bpt>CDC<ept id=\"p1\">](../../mfc/reference/cdc-class.md)</ept> class description for more on the use of these two device contexts.","pos":[175196,175311],"source":" See the [CDC](../../mfc/reference/cdc-class.md) class description for more on the use of these two device contexts."},{"pos":[175350,175362],"content":"CDC::MaskBlt"},{"content":"Combines the color data for the source and destination bitmaps using the given mask and raster operation.","pos":[175366,175471]},{"content":"Parameters","pos":[175703,175713]},{"content":"x","pos":[175718,175719]},{"content":"Specifies the logical x-coordinate of the upper-left corner of the destination rectangle.","pos":[175724,175813]},{"content":"y","pos":[175821,175822]},{"content":"Specifies the logical y-coordinate of the upper-left corner of the destination rectangle.","pos":[175827,175916]},{"content":"Specifies the width, in logical units, of the destination rectangle and source bitmap.","pos":[175935,176021]},{"content":"Specifies the height, in logical units, of the destination rectangle and source bitmap.","pos":[176041,176128]},{"content":"Identifies the device context from which the bitmap is to be copied.","pos":[176147,176215]},{"content":"It must be zero if the <bpt id=\"p1\">*</bpt>dwRop<ept id=\"p1\">*</ept> parameter specifies a raster operation that does not include a source.","pos":[176216,176317],"source":" It must be zero if the *dwRop* parameter specifies a raster operation that does not include a source."},{"content":"Specifies the logical x-coordinate of the upper-left corner of the source bitmap.","pos":[176334,176415]},{"content":"Specifies the logical y-coordinate of the upper-left corner of the source bitmap.","pos":[176432,176513]},{"content":"Identifies the monochrome mask bitmap combined with the color bitmap in the source device context.","pos":[176536,176634]},{"content":"Specifies the horizontal pixel offset for the mask bitmap specified by the <ph id=\"ph1\">`maskBitmap`</ph> parameter.","pos":[176652,176750],"source":" Specifies the horizontal pixel offset for the mask bitmap specified by the `maskBitmap` parameter."},{"content":"Specifies the vertical pixel offset for the mask bitmap specified by the <ph id=\"ph1\">`maskBitmap`</ph> parameter.","pos":[176768,176864],"source":" Specifies the vertical pixel offset for the mask bitmap specified by the `maskBitmap` parameter."},{"content":"dwRop","pos":[176872,176877]},{"content":"Specifies both foreground and background ternary raster operation codes, which the function uses to control the combination of source and destination data.","pos":[176882,177037]},{"content":"The background raster operation code is stored in the high byte of the high word of this value; the foreground raster operation code is stored in the low byte of the high word of this value; the low word of this value is ignored, and should be zero.","pos":[177038,177287]},{"content":"The macro <bpt id=\"p1\">**</bpt>MAKEROP4<ept id=\"p1\">**</ept> creates such combinations of foreground and background raster operation codes.","pos":[177288,177389],"source":" The macro **MAKEROP4** creates such combinations of foreground and background raster operation codes."},{"content":"See the Remarks section for a discussion of foreground and background in the context of this function.","pos":[177390,177492]},{"content":"See the <ph id=\"ph1\">`BitBlt`</ph> member function for a list of common raster operation codes.","pos":[177493,177570],"source":" See the `BitBlt` member function for a list of common raster operation codes."},{"content":"Return Value","pos":[177580,177592]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[177596,177647]},{"content":"Remarks","pos":[177657,177664]},{"content":"A value of 1 in the mask specified by <ph id=\"ph1\">`maskBitmap`</ph> indicates that the foreground raster operation code specified by <bpt id=\"p1\">*</bpt>dwRop<ept id=\"p1\">*</ept> should be applied at that location.","pos":[177668,177827],"source":"A value of 1 in the mask specified by `maskBitmap` indicates that the foreground raster operation code specified by *dwRop* should be applied at that location."},{"content":"A value of 0 in the mask indicates that the background raster operation code specified by <bpt id=\"p1\">*</bpt>dwRop<ept id=\"p1\">*</ept> should be applied at that location.","pos":[177828,177961],"source":" A value of 0 in the mask indicates that the background raster operation code specified by *dwRop* should be applied at that location."},{"content":"If the raster operations require a source, the mask rectangle must cover the source rectangle.","pos":[177962,178056]},{"content":"If it does not, the function will fail.","pos":[178057,178096]},{"content":"If the raster operations do not require a source, the mask rectangle must cover the destination rectangle.","pos":[178097,178203]},{"content":"If it does not, the function will fail.","pos":[178204,178243]},{"content":"If a rotation or shear transformation is in effect for the source device context when this function is called, an error occurs.","pos":[178250,178377]},{"content":"However, other types of transformations are allowed.","pos":[178378,178430]},{"content":"If the color formats of the source, pattern, and destination bitmaps differ, this function converts the pattern or source format, or both, to match the destination format.","pos":[178437,178608]},{"content":"If the mask bitmap is not a monochrome bitmap, an error occurs.","pos":[178609,178672]},{"content":"When an enhanced metafile is being recorded, an error occurs (and the function returns 0) if the source device context identifies an enhanced-metafile device context.","pos":[178673,178839]},{"content":"Not all devices support <ph id=\"ph1\">`MaskBlt`</ph>.","pos":[178840,178874],"source":" Not all devices support `MaskBlt`."},{"content":"An application should call <ph id=\"ph1\">`GetDeviceCaps`</ph> to determine whether a device supports this function.","pos":[178875,178971],"source":" An application should call `GetDeviceCaps` to determine whether a device supports this function."},{"content":"If no mask bitmap is supplied, this function behaves exactly like <ph id=\"ph1\">`BitBlt`</ph>, using the foreground raster operation code.","pos":[178972,179091],"source":" If no mask bitmap is supplied, this function behaves exactly like `BitBlt`, using the foreground raster operation code."},{"content":"The pixel offsets in the mask bitmap map to the point (0,0) in the source device context's bitmap.","pos":[179092,179190]},{"content":"This is useful for cases in which a mask bitmap contains a set of masks; an application can easily apply any one of them to a mask-blitting task by adjusting the pixel offsets and rectangle sizes sent to <ph id=\"ph1\">`MaskBlt`</ph>.","pos":[179191,179405],"source":" This is useful for cases in which a mask bitmap contains a set of masks; an application can easily apply any one of them to a mask-blitting task by adjusting the pixel offsets and rectangle sizes sent to `MaskBlt`."},{"pos":[179457,179482],"content":"CDC::ModifyWorldTransform"},{"content":"Changes the world transformation for a device context using the specified mode.","pos":[179486,179565]},{"content":"Parameters","pos":[179662,179672]},{"content":"Reference to an <bpt id=\"p1\">[</bpt>XFORM<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145228)</ept> structure used to modify the world transformation for the given device context.","pos":[179688,179851],"source":" Reference to an [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure used to modify the world transformation for the given device context."},{"content":"Specifies how the transformation data modifies the current world transformation.","pos":[179869,179949]},{"content":"For a list of the values that this parameter can take, see <bpt id=\"p1\">[</bpt>ModifyWorldTransform<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145060)</ept>.","pos":[179950,180092],"source":" For a list of the values that this parameter can take, see [ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060)."},{"content":"Return Value","pos":[180102,180114]},{"content":"Returns a nonzero value on success.","pos":[180118,180153]},{"content":"Returns 0 on failure.","pos":[180160,180181]},{"pos":[180188,180303],"content":"To get extended error information, call <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms679360)</ept>.","source":"To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)."},{"content":"Remarks","pos":[180313,180320]},{"pos":[180324,180450],"content":"This method wraps the Windows GDI function <bpt id=\"p1\">[</bpt>ModifyWorldTransform<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145060)</ept>.","source":"This method wraps the Windows GDI function [ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060)."},{"pos":[180488,180499],"content":"CDC::MoveTo"},{"pos":[180503,180584],"content":"Moves the current position to the point specified by <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> (or by <ph id=\"ph1\">`point`</ph>).","source":"Moves the current position to the point specified by *x* and *y* (or by `point`)."},{"content":"Parameters","pos":[180685,180695]},{"content":"x","pos":[180700,180701]},{"content":"Specifies the logical x-coordinate of the new position.","pos":[180706,180761]},{"content":"y","pos":[180769,180770]},{"content":"Specifies the logical y-coordinate of the new position.","pos":[180775,180830]},{"content":"Specifies the new position.","pos":[180848,180875]},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[180876,180958],"source":" You can pass either a **POINT** structure or a `CPoint` object for this parameter."},{"content":"Return Value","pos":[180968,180980]},{"pos":[180984,181055],"content":"The x- and y-coordinates of the previous position as a <ph id=\"ph1\">`CPoint`</ph> object.","source":"The x- and y-coordinates of the previous position as a `CPoint` object."},{"content":"Example","pos":[181065,181072]},{"pos":[181077,181184],"content":"See the example for <bpt id=\"p1\">[</bpt>CRect::CenterPoint<ept id=\"p1\">](../../atl-mfc-shared/reference/crect-class.md#crect__centerpoint)</ept>.","source":"See the example for [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#crect__centerpoint)."},{"pos":[181229,181247],"content":"CDC::OffsetClipRgn"},{"content":"Moves the clipping region of the device context by the specified offsets.","pos":[181251,181324]},{"content":"Parameters","pos":[181431,181441]},{"content":"x","pos":[181446,181447]},{"content":"Specifies the number of logical units to move left or right.","pos":[181452,181512]},{"content":"y","pos":[181520,181521]},{"content":"Specifies the number of logical units to move up or down.","pos":[181526,181583]},{"content":"Specifies the amount to offset.","pos":[181600,181631]},{"content":"Return Value","pos":[181641,181653]},{"content":"The new region's type.","pos":[181657,181679]},{"content":"It can be any one of the following values:","pos":[181680,181722]},{"pos":[181730,181788],"content":"<bpt id=\"p1\">**</bpt>COMPLEXREGION<ept id=\"p1\">**</ept> Clipping region has overlapping borders.","source":"**COMPLEXREGION** Clipping region has overlapping borders."},{"pos":[181796,181834],"content":"<bpt id=\"p1\">**</bpt>ERROR<ept id=\"p1\">**</ept> Device context is not valid.","source":"**ERROR** Device context is not valid."},{"pos":[181842,181882],"content":"<bpt id=\"p1\">**</bpt>NULLREGION<ept id=\"p1\">**</ept> Clipping region is empty.","source":"**NULLREGION** Clipping region is empty."},{"pos":[181890,181950],"content":"<bpt id=\"p1\">**</bpt>SIMPLEREGION<ept id=\"p1\">**</ept> Clipping region has no overlapping borders.","source":"**SIMPLEREGION** Clipping region has no overlapping borders."},{"content":"Remarks","pos":[181960,181967]},{"pos":[181971,182059],"content":"The function moves the region <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> units along the x-axis and <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> units along the y-axis.","source":"The function moves the region *x* units along the x-axis and *y* units along the y-axis."},{"pos":[182108,182130],"content":"CDC::OffsetViewportOrg"},{"content":"Modifies the coordinates of the viewport origin relative to the coordinates of the current viewport origin.","pos":[182134,182241]},{"content":"Parameters","pos":[182336,182346]},{"content":"Specifies the number of device units to add to the current origin's x-coordinate.","pos":[182362,182443]},{"content":"Specifies the number of device units to add to the current origin's y-coordinate.","pos":[182463,182544]},{"content":"Return Value","pos":[182554,182566]},{"pos":[182570,182644],"content":"The previous viewport origin (in device coordinates) as a <ph id=\"ph1\">`CPoint`</ph> object.","source":"The previous viewport origin (in device coordinates) as a `CPoint` object."},{"pos":[182691,182711],"content":"CDC::OffsetWindowOrg"},{"content":"Modifies the coordinates of the window origin relative to the coordinates of the current window origin.","pos":[182715,182818]},{"content":"Parameters","pos":[182903,182913]},{"content":"Specifies the number of logical units to add to the current origin's x-coordinate.","pos":[182929,183011]},{"content":"Specifies the number of logical units to add to the current origin's y-coordinate.","pos":[183031,183113]},{"content":"Return Value","pos":[183123,183135]},{"pos":[183139,183212],"content":"The previous window origin (in logical coordinates) as a <ph id=\"ph1\">`CPoint`</ph> object.","source":"The previous window origin (in logical coordinates) as a `CPoint` object."},{"pos":[183256,183273],"content":"CDC::operator HDC"},{"pos":[183277,183353],"content":"Use this operator to retrieve the device context handle of the <ph id=\"ph1\">`CDC`</ph> object.","source":"Use this operator to retrieve the device context handle of the `CDC` object."},{"content":"Return Value","pos":[183403,183415]},{"pos":[183419,183495],"content":"If successful, the handle of the device context object; otherwise, <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"If successful, the handle of the device context object; otherwise, **NULL**."},{"content":"Remarks","pos":[183505,183512]},{"content":"You can use the handle to call Windows APIs directly.","pos":[183516,183569]},{"pos":[183609,183622],"content":"CDC::PaintRgn"},{"pos":[183626,183687],"content":"Fills the region specified by <ph id=\"ph1\">`pRgn`</ph> using the current brush.","source":"Fills the region specified by `pRgn` using the current brush."},{"content":"Parameters","pos":[183739,183749]},{"content":"Identifies the region to be filled.","pos":[183763,183798]},{"content":"The coordinates for the given region are specified in logical units.","pos":[183799,183867]},{"content":"Return Value","pos":[183877,183889]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[183893,183944]},{"pos":[183982,183993],"content":"CDC::PatBlt"},{"content":"Creates a bit pattern on the device.","pos":[183997,184033]},{"content":"Parameters","pos":[184152,184162]},{"content":"x","pos":[184167,184168]},{"content":"Specifies the logical x-coordinate of the upper-left corner of the rectangle that is to receive the pattern.","pos":[184173,184281]},{"content":"y","pos":[184289,184290]},{"content":"Specifies the logical y-coordinate of the upper-left corner of the rectangle that is to receive the pattern.","pos":[184295,184403]},{"content":"Specifies the width (in logical units) of the rectangle that is to receive the pattern.","pos":[184422,184509]},{"content":"Specifies the height (in logical units) of the rectangle that is to receive the pattern.","pos":[184529,184617]},{"content":"dwRop","pos":[184625,184630]},{"content":"Specifies the raster-operation code.","pos":[184635,184671]},{"content":"Raster-operation codes (ROPs) define how GDI combines colors in output operations that involve a current brush, a possible source bitmap, and a destination bitmap.","pos":[184672,184835]},{"content":"This parameter can be one of the following values:","pos":[184836,184886]},{"pos":[184894,184943],"content":"<bpt id=\"p1\">**</bpt>PATCOPY<ept id=\"p1\">**</ept> Copies pattern to destination bitmap.","source":"**PATCOPY** Copies pattern to destination bitmap."},{"pos":[184951,185037],"content":"<bpt id=\"p1\">**</bpt>PATINVERT<ept id=\"p1\">**</ept> Combines destination bitmap with pattern using the Boolean XOR operator.","source":"**PATINVERT** Combines destination bitmap with pattern using the Boolean XOR operator."},{"pos":[185045,185090],"content":"<bpt id=\"p1\">**</bpt>DSTINVERT<ept id=\"p1\">**</ept> Inverts the destination bitmap.","source":"**DSTINVERT** Inverts the destination bitmap."},{"pos":[185098,185135],"content":"<bpt id=\"p1\">**</bpt>BLACKNESS<ept id=\"p1\">**</ept> Turns all output black.","source":"**BLACKNESS** Turns all output black."},{"pos":[185143,185180],"content":"<bpt id=\"p1\">**</bpt>WHITENESS<ept id=\"p1\">**</ept> Turns all output white.","source":"**WHITENESS** Turns all output white."},{"content":"Return Value","pos":[185190,185202]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[185206,185257]},{"content":"Remarks","pos":[185267,185274]},{"content":"The pattern is a combination of the selected brush and the pattern already on the device.","pos":[185278,185367]},{"content":"The raster-operation code specified by <bpt id=\"p1\">*</bpt>dwRop<ept id=\"p1\">*</ept> defines how the patterns are to be combined.","pos":[185368,185459],"source":" The raster-operation code specified by *dwRop* defines how the patterns are to be combined."},{"content":"The raster operations listed for this function are a limited subset of the full 256 ternary raster-operation codes; in particular, a raster-operation code that refers to a source cannot be used.","pos":[185460,185654]},{"content":"Not all device contexts support the <ph id=\"ph1\">`PatBlt`</ph> function.","pos":[185661,185715],"source":"Not all device contexts support the `PatBlt` function."},{"content":"To determine whether a device context supports <ph id=\"ph1\">`PatBlt`</ph>, call the <ph id=\"ph2\">`GetDeviceCaps`</ph> member function with the <bpt id=\"p1\">**</bpt>RASTERCAPS<ept id=\"p1\">**</ept> index and check the return value for the <bpt id=\"p2\">**</bpt>RC_BITBLT<ept id=\"p2\">**</ept> flag.","pos":[185716,185898],"source":" To determine whether a device context supports `PatBlt`, call the `GetDeviceCaps` member function with the **RASTERCAPS** index and check the return value for the **RC_BITBLT** flag."},{"pos":[185933,185941],"content":"CDC::Pie"},{"content":"Draws a pie-shaped wedge by drawing an elliptical arc whose center and two endpoints are joined by lines.","pos":[185945,186050]},{"content":"Parameters","pos":[186266,186276]},{"content":"Specifies the x-coordinate of the upper-left corner of the bounding rectangle (in logical units).","pos":[186288,186385]},{"content":"Specifies the y-coordinate of the upper-left corner of the bounding rectangle (in logical units).","pos":[186400,186497]},{"content":"Specifies the x-coordinate of the lower-right corner of the bounding rectangle (in logical units).","pos":[186512,186610]},{"content":"Specifies the y-coordinate of the lower-right corner of the bounding rectangle (in logical units).","pos":[186625,186723]},{"content":"x3","pos":[186731,186733]},{"content":"Specifies the x-coordinate of the arc's starting point (in logical units).","pos":[186738,186812]},{"content":"This point does not have to lie exactly on the arc.","pos":[186813,186864]},{"content":"Specifies the y-coordinate of the arc's starting point (in logical units).","pos":[186879,186953]},{"content":"This point does not have to lie exactly on the arc.","pos":[186954,187005]},{"content":"Specifies the x-coordinate of the arc's endpoint (in logical units).","pos":[187020,187088]},{"content":"This point does not have to lie exactly on the arc.","pos":[187089,187140]},{"content":"Specifies the y-coordinate of the arc's endpoint (in logical units).","pos":[187155,187223]},{"content":"This point does not have to lie exactly on the arc.","pos":[187224,187275]},{"content":"Specifies the bounding rectangle.","pos":[187294,187327]},{"content":"You can pass either a <ph id=\"ph1\">`CRect`</ph> object or a pointer to a <ph id=\"ph2\">`RECT`</ph> structure for this parameter.","pos":[187328,187419],"source":" You can pass either a `CRect` object or a pointer to a `RECT` structure for this parameter."},{"content":"Specifies the starting point of the arc.","pos":[187439,187479]},{"content":"This point does not have to lie exactly on the arc.","pos":[187480,187531]},{"content":"You can pass either a <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> structure or a <bpt id=\"p2\">[</bpt>CPoint<ept id=\"p2\">](../../atl-mfc-shared/reference/cpoint-class.md)</ept> object for this parameter.","pos":[187532,187701],"source":" You can pass either a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter."},{"content":"Specifies the endpoint of the arc.","pos":[187719,187753]},{"content":"This point does not have to lie exactly on the arc.","pos":[187754,187805]},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[187806,187888],"source":" You can pass either a **POINT** structure or a `CPoint` object for this parameter."},{"content":"Return Value","pos":[187898,187910]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[187914,187965]},{"content":"Remarks","pos":[187975,187982]},{"content":"The center of the arc is the center of the bounding rectangle specified by <ph id=\"ph1\">`x1`</ph>, <ph id=\"ph2\">`y1`</ph>, <ph id=\"ph3\">`x2`</ph>, and <ph id=\"ph4\">`y2`</ph> (or by <ph id=\"ph5\">`lpRect`</ph>).","pos":[187986,188105],"source":"The center of the arc is the center of the bounding rectangle specified by `x1`, `y1`, `x2`, and `y2` (or by `lpRect`)."},{"content":"The starting and ending points of the arc are specified by <bpt id=\"p1\">*</bpt>x3<ept id=\"p1\">*</ept>, <ph id=\"ph1\">`y3`</ph>, <ph id=\"ph2\">`x4`</ph>, and <ph id=\"ph3\">`y4`</ph> (or by <ph id=\"ph4\">`ptStart`</ph> and <ph id=\"ph5\">`ptEnd`</ph>).","pos":[188106,188222],"source":" The starting and ending points of the arc are specified by *x3*, `y3`, `x4`, and `y4` (or by `ptStart` and `ptEnd`)."},{"content":"The arc is drawn with the selected pen, moving in a counterclockwise direction.","pos":[188229,188308]},{"content":"Two additional lines are drawn from each endpoint to the arc's center.","pos":[188309,188379]},{"content":"The pie-shaped area is filled with the current brush.","pos":[188380,188433]},{"content":"If <bpt id=\"p1\">*</bpt>x3<ept id=\"p1\">*</ept> equals <ph id=\"ph1\">`x4`</ph> and <ph id=\"ph2\">`y3`</ph> equals <ph id=\"ph3\">`y4`</ph>, the result is an ellipse with a single line from the center of the ellipse to the point ( <bpt id=\"p2\">*</bpt>x3<ept id=\"p2\">*</ept>, <ph id=\"ph4\">`y3`</ph>) or ( <ph id=\"ph5\">`x4`</ph>, <ph id=\"ph6\">`y4`</ph>).","pos":[188434,188595],"source":" If *x3* equals `x4` and `y3` equals `y4`, the result is an ellipse with a single line from the center of the ellipse to the point ( *x3*, `y3`) or ( `x4`, `y4`)."},{"content":"The figure drawn by this function extends up to but does not include the right and bottom coordinates.","pos":[188602,188704]},{"content":"This means that the height of the figure is <ph id=\"ph1\">`y2`</ph> – <ph id=\"ph2\">`y1`</ph> and the width of the figure is <ph id=\"ph3\">`x2`</ph> – <ph id=\"ph4\">`x1`</ph>.","pos":[188705,188804],"source":" This means that the height of the figure is `y2` – `y1` and the width of the figure is `x2` – `x1`."},{"content":"Both the width and the height of the bounding rectangle must be greater than 2 units and less than 32,767 units.","pos":[188805,188917]},{"content":"Example","pos":[188927,188934]},{"pos":[188949,188966],"content":"NVC_MFCDocView#37"},{"pos":[189055,189072],"content":"CDC::PlayMetaFile"},{"content":"Plays the contents of the specified metafile on the device context.","pos":[189076,189143]},{"content":"Parameters","pos":[189285,189295]},{"content":"hMF","pos":[189300,189303]},{"content":"Identifies the metafile to be played.","pos":[189308,189345]},{"content":"hEnhMetaFile","pos":[189353,189365]},{"content":"Identifies the enhanced metafile.","pos":[189370,189403]},{"content":"Points to a <ph id=\"ph1\">`RECT`</ph> structure or a <ph id=\"ph2\">`CRect`</ph> object that contains the coordinates of the bounding rectangle used to display the picture.","pos":[189424,189557],"source":" Points to a `RECT` structure or a `CRect` object that contains the coordinates of the bounding rectangle used to display the picture."},{"content":"The coordinates are specified in logical units.","pos":[189558,189605]},{"content":"Return Value","pos":[189615,189627]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[189631,189682]},{"content":"Remarks","pos":[189692,189699]},{"content":"The metafile can be played any number of times.","pos":[189703,189750]},{"content":"The second version of <ph id=\"ph1\">`PlayMetaFile`</ph> displays the picture stored in the given enhanced-format metafile.","pos":[189757,189860],"source":"The second version of `PlayMetaFile` displays the picture stored in the given enhanced-format metafile."},{"content":"When an application calls the second version of <ph id=\"ph1\">`PlayMetaFile`</ph>, Windows uses the picture frame in the enhanced-metafile header to map the picture onto the rectangle pointed to by the <ph id=\"ph2\">`lpBounds`</ph> parameter.","pos":[189861,190065],"source":" When an application calls the second version of `PlayMetaFile`, Windows uses the picture frame in the enhanced-metafile header to map the picture onto the rectangle pointed to by the `lpBounds` parameter."},{"content":"(This picture may be sheared or rotated by setting the world transform in the output device before calling <ph id=\"ph1\">`PlayMetaFile`</ph>.) Points along the edges of the rectangle are included in the picture.","pos":[190066,190258],"source":" (This picture may be sheared or rotated by setting the world transform in the output device before calling `PlayMetaFile`.) Points along the edges of the rectangle are included in the picture."},{"content":"An enhanced-metafile picture can be clipped by defining the clipping region in the output device before playing the enhanced metafile.","pos":[190259,190393]},{"content":"If an enhanced metafile contains an optional palette, an application can achieve consistent colors by setting up a color palette on the output device before calling the second version of <ph id=\"ph1\">`PlayMetaFile`</ph>.","pos":[190400,190602],"source":"If an enhanced metafile contains an optional palette, an application can achieve consistent colors by setting up a color palette on the output device before calling the second version of `PlayMetaFile`."},{"content":"To retrieve the optional palette, use the <bpt id=\"p1\">**</bpt>GetEnhMetaFilePaletteEntries<ept id=\"p1\">**</ept> Windows function.","pos":[190603,190695],"source":" To retrieve the optional palette, use the **GetEnhMetaFilePaletteEntries** Windows function."},{"content":"An enhanced metafile can be embedded in a newly created enhanced metafile by calling the second version of <ph id=\"ph1\">`PlayMetaFile`</ph> and playing the source enhanced metafile into the device context for the new enhanced metafile.","pos":[190696,190913],"source":" An enhanced metafile can be embedded in a newly created enhanced metafile by calling the second version of `PlayMetaFile` and playing the source enhanced metafile into the device context for the new enhanced metafile."},{"content":"The states of the output device context are preserved by this function.","pos":[190920,190991]},{"content":"Any object created but not deleted in the enhanced metafile is deleted by this function.","pos":[190992,191080]},{"content":"To stop this function, an application can call the <bpt id=\"p1\">**</bpt>CancelDC<ept id=\"p1\">**</ept> Windows function from another thread to terminate the operation.","pos":[191081,191209],"source":" To stop this function, an application can call the **CancelDC** Windows function from another thread to terminate the operation."},{"content":"In this case, the function returns zero.","pos":[191210,191250]},{"pos":[191288,191299],"content":"CDC::PlgBlt"},{"content":"Performs a bit-block transfer of the bits of color data from the specified rectangle in the source device context to the specified parallelogram in the given device context.","pos":[191303,191476]},{"content":"Parameters","pos":[191685,191695]},{"content":"Points to an array of three points in logical space that identifies three corners of the destination parallelogram.","pos":[191712,191827]},{"content":"The upper-left corner of the source rectangle is mapped to the first point in this array, the upper-right corner to the second point in this array, and the lower-left corner to the third point.","pos":[191828,192021]},{"content":"The lower-right corner of the source rectangle is mapped to the implicit fourth point in the parallelogram.","pos":[192022,192129]},{"content":"Identifies the source device context.","pos":[192148,192185]},{"content":"Specifies the x-coordinate, in logical units, of the upper-left corner of the source rectangle.","pos":[192202,192297]},{"content":"Specifies the y-coordinate, in logical units, of the upper-left corner of the source rectangle.","pos":[192314,192409]},{"content":"Specifies the width, in logical units, of the source rectangle.","pos":[192428,192491]},{"content":"Specifies the height, in logical units, of the source rectangle.","pos":[192511,192575]},{"content":"Identifies an optional monochrome bitmap that is used to mask the colors of the source rectangle.","pos":[192598,192695]},{"content":"Specifies the x-coordinate of the upper-left corner of the monochrome bitmap.","pos":[192713,192790]},{"content":"Specifies the y-coordinate of the upper-left corner of the monochrome bitmap.","pos":[192808,192885]},{"content":"Return Value","pos":[192895,192907]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[192911,192962]},{"content":"Remarks","pos":[192972,192979]},{"content":"If the given bitmask handle identifies a valid monochrome bitmap, the function uses this bitmap to mask the bits of color data from the source rectangle.","pos":[192983,193136]},{"content":"The fourth vertex of the parallelogram (D) is defined by treating the first three points (A, B, and C) as vectors and computing D = B + C - A.","pos":[193143,193285]},{"content":"If the bitmask exists, a value of 1 in the mask indicates that the source pixel color should be copied to the destination.","pos":[193292,193414]},{"content":"A value of 0 in the mask indicates that the destination pixel color is not to be changed.","pos":[193415,193504]},{"content":"If the mask rectangle is smaller than the source and destination rectangles, the function replicates the mask pattern.","pos":[193511,193629]},{"content":"Scaling, translation, and reflection transformations are allowed in the source device context; however, rotation and shear transformations are not.","pos":[193636,193783]},{"content":"If the mask bitmap is not a monochrome bitmap, an error occurs.","pos":[193784,193847]},{"content":"The stretching mode for the destination device context is used to determine how to stretch or compress the pixels, if that is necessary.","pos":[193848,193984]},{"content":"When an enhanced metafile is being recorded, an error occurs if the source device context identifies an enhanced-metafile device context.","pos":[193985,194122]},{"content":"The destination coordinates are transformed according to the destination device context; the source coordinates are transformed according to the source device context.","pos":[194129,194296]},{"content":"If the source transformation has a rotation or shear, an error is returned.","pos":[194297,194372]},{"content":"If the destination and source rectangles do not have the same color format, <ph id=\"ph1\">`PlgBlt`</ph> converts the source rectangle to match the destination rectangle.","pos":[194373,194523],"source":" If the destination and source rectangles do not have the same color format, `PlgBlt` converts the source rectangle to match the destination rectangle."},{"content":"Not all devices support <ph id=\"ph1\">`PlgBlt`</ph>.","pos":[194524,194557],"source":" Not all devices support `PlgBlt`."},{"content":"For more information, see the description of the <bpt id=\"p1\">**</bpt>RC_BITBLT<ept id=\"p1\">**</ept> raster capability in the <ph id=\"ph1\">`CDC::GetDeviceCaps`</ph> member function.","pos":[194558,194683],"source":" For more information, see the description of the **RC_BITBLT** raster capability in the `CDC::GetDeviceCaps` member function."},{"pos":[194690,194794],"content":"If the source and destination device contexts represent incompatible devices, <ph id=\"ph1\">`PlgBlt`</ph> returns an error.","source":"If the source and destination device contexts represent incompatible devices, `PlgBlt` returns an error."},{"pos":[194836,194851],"content":"CDC::PolyBezier"},{"content":"Draws one or more Bzier splines.","pos":[194855,194887]},{"content":"Parameters","pos":[194975,194985]},{"content":"Points to an array of <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> data structures that contain the endpoints and control points of the spline(s).","pos":[195003,195153],"source":" Points to an array of [POINT](../../mfc/reference/point-structure1.md) data structures that contain the endpoints and control points of the spline(s)."},{"content":"Specifies the number of points in the <ph id=\"ph1\">`lpPoints`</ph> array.","pos":[195172,195227],"source":" Specifies the number of points in the `lpPoints` array."},{"content":"This value must be one more than three times the number of splines to be drawn, because each Bzier spline requires two control points and an endpoint, and the initial spline requires an additional starting point.","pos":[195228,195440]},{"content":"Return Value","pos":[195450,195462]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[195466,195517]},{"content":"Remarks","pos":[195527,195534]},{"content":"This function draws cubic Bzier splines by using the endpoints and control points specified by the <ph id=\"ph1\">`lpPoints`</ph> parameter.","pos":[195538,195658],"source":"This function draws cubic Bzier splines by using the endpoints and control points specified by the `lpPoints` parameter."},{"content":"The first spline is drawn from the first point to the fourth point by using the second and third points as control points.","pos":[195659,195781]},{"content":"Each subsequent spline in the sequence needs exactly three more points: the end point of the previous spline is used as the starting point, the next two points in the sequence are control points, and the third is the end point.","pos":[195782,196009]},{"content":"The current position is neither used nor updated by the <ph id=\"ph1\">`PolyBezier`</ph> function.","pos":[196016,196094],"source":"The current position is neither used nor updated by the `PolyBezier` function."},{"content":"The figure is not filled.","pos":[196095,196120]},{"content":"This function draws lines by using the current pen.","pos":[196121,196172]},{"pos":[196216,196233],"content":"CDC::PolyBezierTo"},{"content":"Draws one or more Bzier splines.","pos":[196237,196269]},{"content":"Parameters","pos":[196359,196369]},{"content":"Points to an array of <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> data structures that contains the endpoints and control points.","pos":[196387,196521],"source":" Points to an array of [POINT](../../mfc/reference/point-structure1.md) data structures that contains the endpoints and control points."},{"content":"Specifies the number of points in the <ph id=\"ph1\">`lpPoints`</ph> array.","pos":[196540,196595],"source":" Specifies the number of points in the `lpPoints` array."},{"content":"This value must be three times the number of splines to be drawn, because each Bzier spline requires two control points and an end point.","pos":[196596,196733]},{"content":"Return Value","pos":[196743,196755]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[196759,196810]},{"content":"Remarks","pos":[196820,196827]},{"content":"This function draws cubic Bzier splines by using the control points specified by the <ph id=\"ph1\">`lpPoints`</ph> parameter.","pos":[196831,196937],"source":"This function draws cubic Bzier splines by using the control points specified by the `lpPoints` parameter."},{"content":"The first spline is drawn from the current position to the third point by using the first two points as control points.","pos":[196938,197057]},{"content":"For each subsequent spline, the function needs exactly three more points, and uses the end point of the previous spline as the starting point for the next.","pos":[197058,197213]},{"content":"moves the current position to the end point of the last Bzier spline.","pos":[197229,197298]},{"content":"The figure is not filled.","pos":[197299,197324]},{"content":"This function draws lines by using the current pen.","pos":[197325,197376]},{"content":"Example","pos":[197386,197393]},{"pos":[197398,197452],"content":"See the example for <bpt id=\"p1\">[</bpt>CDC::BeginPath<ept id=\"p1\">](#cdc__beginpath)</ept>.","source":"See the example for [CDC::BeginPath](#cdc__beginpath)."},{"pos":[197492,197505],"content":"CDC::PolyDraw"},{"content":"Draws a set of line segments and Bzier splines.","pos":[197509,197556]},{"content":"Parameters","pos":[197669,197679]},{"content":"Points to an array of <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> data structures that contains the endpoints for each line segment and the endpoints and control points for each Bzier spline.","pos":[197697,197893],"source":" Points to an array of [POINT](../../mfc/reference/point-structure1.md) data structures that contains the endpoints for each line segment and the endpoints and control points for each Bzier spline."},{"content":"Points to an array that specifies how each point in the <ph id=\"ph1\">`lpPoints`</ph> array is used.","pos":[197913,197994],"source":" Points to an array that specifies how each point in the `lpPoints` array is used."},{"content":"Values can be one of the following:","pos":[197995,198030]},{"content":"<bpt id=\"p1\">**</bpt>PT_MOVETO<ept id=\"p1\">**</ept> Specifies that this point starts a disjoint figure.","pos":[198038,198103],"source":"**PT_MOVETO** Specifies that this point starts a disjoint figure."},{"content":"This point becomes the new current position.","pos":[198104,198148]},{"pos":[198156,198292],"content":"<bpt id=\"p1\">**</bpt>PT_LINETO<ept id=\"p1\">**</ept> Specifies that a line is to be drawn from the current position to this point, which then becomes the new current position.","source":"**PT_LINETO** Specifies that a line is to be drawn from the current position to this point, which then becomes the new current position."},{"pos":[198300,198396],"content":"<bpt id=\"p1\">**</bpt>PT_BEZIERTO<ept id=\"p1\">**</ept> Specifies that this point is a control point or ending point for a Bzier spline.","source":"**PT_BEZIERTO** Specifies that this point is a control point or ending point for a Bzier spline."},{"content":"<bpt id=\"p1\">**</bpt>PT_BEZIERTO<ept id=\"p1\">**</ept> types always occur in sets of three.","pos":[198403,198455],"source":"**PT_BEZIERTO** types always occur in sets of three."},{"content":"The current position defines the starting point for the Bzier spline.","pos":[198456,198525]},{"content":"The first two <bpt id=\"p1\">**</bpt>PT_BEZIERTO<ept id=\"p1\">**</ept> points are the control points, and the third <bpt id=\"p2\">**</bpt>PT_BEZIERTO<ept id=\"p2\">**</ept> point is the ending point.","pos":[198526,198643],"source":" The first two **PT_BEZIERTO** points are the control points, and the third **PT_BEZIERTO** point is the ending point."},{"content":"The ending point becomes the new current position.","pos":[198644,198694]},{"content":"If there are not three consecutive <bpt id=\"p1\">**</bpt>PT_BEZIERTO<ept id=\"p1\">**</ept> points, an error results.","pos":[198695,198771],"source":" If there are not three consecutive **PT_BEZIERTO** points, an error results."},{"pos":[198782,198995],"content":"A <bpt id=\"p1\">**</bpt>PT_LINETO<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>PT_BEZIERTO<ept id=\"p2\">**</ept> type can be combined with the following constant by using the bitwise operator OR to indicate that the corresponding point is the last point in a figure and the figure is closed:","source":"A **PT_LINETO** or **PT_BEZIERTO** type can be combined with the following constant by using the bitwise operator OR to indicate that the corresponding point is the last point in a figure and the figure is closed:"},{"content":"<bpt id=\"p1\">**</bpt>PT_CLOSEFIGURE<ept id=\"p1\">**</ept> Specifies that the figure is automatically closed after the <bpt id=\"p2\">**</bpt>PT_LINETO<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>PT_BEZIERTO<ept id=\"p3\">**</ept> type for this point is done.","pos":[199003,199143],"source":"**PT_CLOSEFIGURE** Specifies that the figure is automatically closed after the **PT_LINETO** or **PT_BEZIERTO** type for this point is done."},{"content":"A line is drawn from this point to the most recent <bpt id=\"p1\">**</bpt>PT_MOVETO<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`MoveTo`</ph> point.","pos":[199144,199227],"source":" A line is drawn from this point to the most recent **PT_MOVETO** or `MoveTo` point."},{"content":"This flag is combined with the <bpt id=\"p1\">**</bpt>PT_LINETO<ept id=\"p1\">**</ept> type for a line, or with the <bpt id=\"p2\">**</bpt>PT_BEZIERTO<ept id=\"p2\">**</ept> type of ending point for a Bzier spline, by using the bitwise <ph id=\"ph1\">`OR`</ph> operator.","pos":[199238,199404],"source":"This flag is combined with the **PT_LINETO** type for a line, or with the **PT_BEZIERTO** type of ending point for a Bzier spline, by using the bitwise `OR` operator."},{"content":"The current position is set to the ending point of the closing line.","pos":[199405,199473]},{"pos":[199480,199609],"content":"`nCount`  \nSpecifies the total number of points in the `lpPoints` array, the same as the number of bytes in the `lpTypes` array.","leadings":[""," "],"nodes":[{"content":"Specifies the total number of points in the <ph id=\"ph1\">`lpPoints`</ph> array, the same as the number of bytes in the <ph id=\"ph2\">`lpTypes`</ph> array.","pos":[11,128],"source":"Specifies the total number of points in the `lpPoints` array, the same as the number of bytes in the `lpTypes` array."}]},{"content":"Return Value","pos":[199619,199631]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[199635,199686]},{"content":"Remarks","pos":[199696,199703]},{"content":"This function can be used to draw disjoint figures in place of consecutive calls to <ph id=\"ph1\">`CDC::MoveTo`</ph>, <ph id=\"ph2\">`CDC::LineTo`</ph>, and <ph id=\"ph3\">`CDC::PolyBezierTo`</ph> member functions.","pos":[199707,199862],"source":"This function can be used to draw disjoint figures in place of consecutive calls to `CDC::MoveTo`, `CDC::LineTo`, and `CDC::PolyBezierTo` member functions."},{"content":"The lines and splines are drawn using the current pen, and figures are not filled.","pos":[199863,199945]},{"content":"If there is an active path started by calling the <ph id=\"ph1\">`CDC::BeginPath`</ph> member function, <ph id=\"ph2\">`PolyDraw`</ph> adds to the path.","pos":[199946,200058],"source":" If there is an active path started by calling the `CDC::BeginPath` member function, `PolyDraw` adds to the path."},{"content":"The points contained in the <ph id=\"ph1\">`lpPoints`</ph> array and in <ph id=\"ph2\">`lpTypes`</ph> indicate whether each point is part of a <ph id=\"ph3\">`CDC::MoveTo`</ph>, a <ph id=\"ph4\">`CDC::LineTo`</ph>, or a <bpt id=\"p1\">**</bpt>CDC::BezierTo<ept id=\"p1\">**</ept> operation.","pos":[200059,200227],"source":" The points contained in the `lpPoints` array and in `lpTypes` indicate whether each point is part of a `CDC::MoveTo`, a `CDC::LineTo`, or a **CDC::BezierTo** operation."},{"content":"It is also possible to close figures.","pos":[200228,200265]},{"content":"This function updates the current position.","pos":[200266,200309]},{"content":"Example","pos":[200319,200326]},{"pos":[200331,200385],"content":"See the example for <bpt id=\"p1\">[</bpt>CDC::BeginPath<ept id=\"p1\">](#cdc__beginpath)</ept>.","source":"See the example for [CDC::BeginPath](#cdc__beginpath)."},{"pos":[200424,200436],"content":"CDC::Polygon"},{"content":"Draws a polygon consisting of two or more points (vertices) connected by lines, using the current pen.","pos":[200440,200542]},{"content":"Parameters","pos":[200622,200632]},{"content":"Points to an array of points that specifies the vertices of the polygon.","pos":[200650,200722]},{"content":"Each point in the array is a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object.","pos":[200723,200793],"source":" Each point in the array is a **POINT** structure or a `CPoint` object."},{"content":"Specifies the number of vertices in the array.","pos":[200812,200858]},{"content":"Return Value","pos":[200868,200880]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[200884,200935]},{"content":"Remarks","pos":[200945,200952]},{"content":"The system closes the polygon automatically, if necessary, by drawing a line from the last vertex to the first.","pos":[200956,201067]},{"pos":[201074,201201],"content":"The current polygon-filling mode can be retrieved or set by using the <ph id=\"ph1\">`GetPolyFillMode`</ph> and <ph id=\"ph2\">`SetPolyFillMode`</ph> member functions.","source":"The current polygon-filling mode can be retrieved or set by using the `GetPolyFillMode` and `SetPolyFillMode` member functions."},{"content":"Example","pos":[201211,201218]},{"pos":[201233,201250],"content":"NVC_MFCDocView#38"},{"pos":[201336,201349],"content":"CDC::Polyline"},{"pos":[201353,201428],"content":"Draws a set of line segments connecting the points specified by <ph id=\"ph1\">`lpPoints`</ph>.","source":"Draws a set of line segments connecting the points specified by `lpPoints`."},{"content":"Parameters","pos":[201509,201519]},{"content":"Points to an array of <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structures or <ph id=\"ph1\">`CPoint`</ph> objects to be connected.","pos":[201537,201616],"source":" Points to an array of **POINT** structures or `CPoint` objects to be connected."},{"content":"Specifies the number of points in the array.","pos":[201635,201679]},{"content":"This value must be at least 2.","pos":[201680,201710]},{"content":"Return Value","pos":[201720,201732]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[201736,201787]},{"content":"Remarks","pos":[201797,201804]},{"content":"The lines are drawn from the first point through subsequent points using the current pen.","pos":[201808,201897]},{"content":"Unlike the <ph id=\"ph1\">`LineTo`</ph> member function, the <ph id=\"ph2\">`Polyline`</ph> function neither uses nor updates the current position.","pos":[201898,202005],"source":" Unlike the `LineTo` member function, the `Polyline` function neither uses nor updates the current position."},{"pos":[202012,202168],"content":"For more information, see <bpt id=\"p1\">[</bpt>PolyLine<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162815)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"For more information, see [PolyLine](http://msdn.microsoft.com/library/windows/desktop/dd162815) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[202210,202225],"content":"CDC::PolylineTo"},{"content":"Draws one or more straight lines.","pos":[202229,202262]},{"content":"Parameters","pos":[202350,202360]},{"content":"Points to an array of <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> data structures that contains the vertices of the line.","pos":[202378,202504],"source":" Points to an array of [POINT](../../mfc/reference/point-structure1.md) data structures that contains the vertices of the line."},{"content":"Specifies the number of points in the array.","pos":[202523,202567]},{"content":"Return Value","pos":[202577,202589]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[202593,202644]},{"content":"Remarks","pos":[202654,202661]},{"content":"A line is drawn from the current position to the first point specified by the <ph id=\"ph1\">`lpPoints`</ph> parameter by using the current pen.","pos":[202665,202789],"source":"A line is drawn from the current position to the first point specified by the `lpPoints` parameter by using the current pen."},{"content":"For each additional line, the function draws from the ending point of the previous line to the next point specified by <ph id=\"ph1\">`lpPoints`</ph>.","pos":[202790,202920],"source":" For each additional line, the function draws from the ending point of the previous line to the next point specified by `lpPoints`."},{"content":"moves the current position to the ending point of the last line.","pos":[202934,202998]},{"content":"If the line segments drawn by this function form a closed figure, the figure is not filled.","pos":[202999,203090]},{"pos":[203133,203149],"content":"CDC::PolyPolygon"},{"content":"Creates two or more polygons that are filled using the current polygon-filling mode.","pos":[203153,203237]},{"content":"Parameters","pos":[203347,203357]},{"content":"Points to an array of <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structures or <ph id=\"ph1\">`CPoint`</ph> objects that define the vertices of the polygons.","pos":[203375,203479],"source":" Points to an array of **POINT** structures or `CPoint` objects that define the vertices of the polygons."},{"content":"Points to an array of integers, each of which specifies the number of points in one of the polygons in the <ph id=\"ph1\">`lpPoints`</ph> array.","pos":[203504,203628],"source":" Points to an array of integers, each of which specifies the number of points in one of the polygons in the `lpPoints` array."},{"content":"The number of entries in the <ph id=\"ph1\">`lpPolyCounts`</ph> array.","pos":[203647,203697],"source":" The number of entries in the `lpPolyCounts` array."},{"content":"This number specifies the number of polygons to be drawn.","pos":[203698,203755]},{"content":"This value must be at least 2.","pos":[203756,203786]},{"content":"Return Value","pos":[203796,203808]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[203812,203863]},{"content":"Remarks","pos":[203873,203880]},{"content":"The polygons may be disjoint or overlapping.","pos":[203884,203928]},{"content":"Each polygon specified in a call to the <ph id=\"ph1\">`PolyPolygon`</ph> function must be closed.","pos":[203935,204013],"source":"Each polygon specified in a call to the `PolyPolygon` function must be closed."},{"content":"Unlike polygons created by the <bpt id=\"p1\">**</bpt>Polygon<ept id=\"p1\">**</ept> member function, the polygons created by <ph id=\"ph1\">`PolyPolygon`</ph> are not closed automatically.","pos":[204014,204141],"source":" Unlike polygons created by the **Polygon** member function, the polygons created by `PolyPolygon` are not closed automatically."},{"content":"The function creates two or more polygons.","pos":[204148,204190]},{"content":"To create a single polygon, an application should use the <bpt id=\"p1\">**</bpt>Polygon<ept id=\"p1\">**</ept> member function.","pos":[204191,204277],"source":" To create a single polygon, an application should use the **Polygon** member function."},{"pos":[204284,204411],"content":"The current polygon-filling mode can be retrieved or set by using the <ph id=\"ph1\">`GetPolyFillMode`</ph> and <ph id=\"ph2\">`SetPolyFillMode`</ph> member functions.","source":"The current polygon-filling mode can be retrieved or set by using the `GetPolyFillMode` and `SetPolyFillMode` member functions."},{"pos":[204455,204472],"content":"CDC::PolyPolyline"},{"content":"Draws multiple series of connected line segments.","pos":[204476,204525]},{"content":"Parameters","pos":[204648,204658]},{"content":"Points to an array of structures that contains the vertices of the polylines.","pos":[204676,204753]},{"content":"The polylines are specified consecutively.","pos":[204754,204796]},{"content":"Points to an array of variables specifying the number of points in the <ph id=\"ph1\">`lpPoints`</ph> array for the corresponding polygon.","pos":[204821,204939],"source":" Points to an array of variables specifying the number of points in the `lpPoints` array for the corresponding polygon."},{"content":"Each entry must be greater than or equal to 2.","pos":[204940,204986]},{"content":"Specifies the total number of counts in the <ph id=\"ph1\">`lpPolyPoints`</ph> array.","pos":[205005,205070],"source":" Specifies the total number of counts in the `lpPolyPoints` array."},{"content":"Return Value","pos":[205080,205092]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[205096,205147]},{"content":"Remarks","pos":[205157,205164]},{"content":"The line segments are drawn by using the current pen.","pos":[205168,205221]},{"content":"The figures formed by the segments are not filled.","pos":[205222,205272]},{"content":"The current position is neither used nor updated by this function.","pos":[205273,205339]},{"pos":[205380,205394],"content":"CDC::PtVisible"},{"content":"Determines whether the given point is within the clipping region of the device context.","pos":[205398,205485]},{"content":"Parameters","pos":[205613,205623]},{"content":"x","pos":[205628,205629]},{"content":"Specifies the logical x-coordinate of the point.","pos":[205634,205682]},{"content":"y","pos":[205690,205691]},{"content":"Specifies the logical y-coordinate of the point.","pos":[205696,205744]},{"content":"Specifies the point to check in logical coordinates.","pos":[205762,205814]},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[205815,205897],"source":" You can pass either a **POINT** structure or a `CPoint` object for this parameter."},{"content":"Return Value","pos":[205907,205919]},{"content":"Nonzero if the specified point is within the clipping region; otherwise 0.","pos":[205923,205997]},{"pos":[206039,206054],"content":"CDC::QueryAbort"},{"pos":[206058,206232],"content":"Calls the abort function installed by the <bpt id=\"p1\">[</bpt>SetAbortProc<ept id=\"p1\">](#cdc__setabortproc)</ept> member function for a printing application and queries whether the printing should be terminated.","source":"Calls the abort function installed by the [SetAbortProc](#cdc__setabortproc) member function for a printing application and queries whether the printing should be terminated."},{"content":"Return Value","pos":[206285,206297]},{"content":"The return value is nonzero if printing should continue or if there is no abort procedure.","pos":[206301,206391]},{"content":"It is 0 if the print job should be terminated.","pos":[206392,206438]},{"content":"The return value is supplied by the abort function.","pos":[206439,206490]},{"pos":[206536,206555],"content":"CDC::RealizePalette"},{"content":"Maps entries from the current logical palette to the system palette.","pos":[206559,206627]},{"content":"Return Value","pos":[206675,206687]},{"content":"Indicates how many entries in the logical palette were mapped to different entries in the system palette.","pos":[206691,206796]},{"content":"This represents the number of entries that this function remapped to accommodate changes in the system palette since the logical palette was last realized.","pos":[206797,206952]},{"content":"Remarks","pos":[206962,206969]},{"content":"A logical color palette acts as a buffer between color-intensive applications and the system, allowing an application to use as many colors as needed without interfering with its own displayed colors or with colors displayed by other windows.","pos":[206973,207215]},{"content":"When a window has the input focus and calls <ph id=\"ph1\">`RealizePalette`</ph>, Windows ensures that the window will display all the requested colors, up to the maximum number simultaneously available on the screen.","pos":[207222,207419],"source":"When a window has the input focus and calls `RealizePalette`, Windows ensures that the window will display all the requested colors, up to the maximum number simultaneously available on the screen."},{"content":"Windows also displays colors not found in the window's palette by matching them to available colors.","pos":[207420,207520]},{"content":"In addition, Windows matches the colors requested by inactive windows that call the function as closely as possible to the available colors.","pos":[207527,207667]},{"content":"This significantly reduces undesirable changes in the colors displayed in inactive windows.","pos":[207668,207759]},{"pos":[207800,207814],"content":"CDC::Rectangle"},{"content":"Draws a rectangle using the current pen.","pos":[207818,207858]},{"content":"Parameters","pos":[207994,208004]},{"content":"Specifies the x-coordinate of the upper-left corner of the rectangle (in logical units).","pos":[208016,208104]},{"content":"Specifies the y-coordinate of the upper-left corner of the rectangle (in logical units).","pos":[208119,208207]},{"content":"Specifies the x-coordinate of the lower-right corner of the rectangle (in logical units).","pos":[208222,208311]},{"content":"Specifies the y-coordinate of the lower-right corner of the rectangle (in logical units).","pos":[208326,208415]},{"content":"Specifies the rectangle in logical units.","pos":[208434,208475]},{"content":"You can pass either a <ph id=\"ph1\">`CRect`</ph> object or a pointer to a <ph id=\"ph2\">`RECT`</ph> structure for this parameter.","pos":[208476,208567],"source":" You can pass either a `CRect` object or a pointer to a `RECT` structure for this parameter."},{"content":"Return Value","pos":[208577,208589]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[208593,208644]},{"content":"Remarks","pos":[208654,208661]},{"content":"The interior of the rectangle is filled using the current brush.","pos":[208665,208729]},{"content":"The rectangle extends up to, but does not include, the right and bottom coordinates.","pos":[208736,208820]},{"content":"This means that the height of the rectangle is <ph id=\"ph1\">`y2`</ph> – <ph id=\"ph2\">`y1`</ph> and the width of the rectangle is <ph id=\"ph3\">`x2`</ph> – <ph id=\"ph4\">`x1`</ph>.","pos":[208821,208926],"source":" This means that the height of the rectangle is `y2` – `y1` and the width of the rectangle is `x2` – `x1`."},{"content":"Both the width and the height of a rectangle must be greater than 2 units and less than 32,767 units.","pos":[208927,209028]},{"content":"Example","pos":[209038,209045]},{"pos":[209060,209077],"content":"NVC_MFCDocView#39"},{"pos":[209166,209182],"content":"CDC::RectVisible"},{"content":"Determines whether any part of the given rectangle lies within the clipping region of the display context.","pos":[209186,209292]},{"content":"Parameters","pos":[209368,209378]},{"content":"Points to a <ph id=\"ph1\">`RECT`</ph> structure or a <ph id=\"ph2\">`CRect`</ph> object that contains the logical coordinates of the specified rectangle.","pos":[209394,209508],"source":" Points to a `RECT` structure or a `CRect` object that contains the logical coordinates of the specified rectangle."},{"content":"Return Value","pos":[209518,209530]},{"content":"Nonzero if any portion of the given rectangle lies within the clipping region; otherwise 0.","pos":[209534,209625]},{"pos":[209672,209692],"content":"CDC::ReleaseAttribDC"},{"pos":[209696,209755],"content":"Call this member function to set <ph id=\"ph1\">`m_hAttribDC`</ph> to <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"Call this member function to set `m_hAttribDC` to **NULL**."},{"content":"Remarks","pos":[209812,209819]},{"content":"This does not cause a <bpt id=\"p1\">**</bpt>Detach<ept id=\"p1\">**</ept> to occur.","pos":[209823,209865],"source":"This does not cause a **Detach** to occur."},{"content":"Only the output device context is attached to the <ph id=\"ph1\">`CDC`</ph> object, and only it can be detached.","pos":[209866,209958],"source":" Only the output device context is attached to the `CDC` object, and only it can be detached."},{"pos":[210005,210025],"content":"CDC::ReleaseOutputDC"},{"pos":[210029,210093],"content":"Call this member function to set the <ph id=\"ph1\">`m_hDC`</ph> member to <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"Call this member function to set the `m_hDC` member to **NULL**."},{"content":"Remarks","pos":[210150,210157]},{"content":"This member function cannot be called when the output device context is attached to the <ph id=\"ph1\">`CDC`</ph> object.","pos":[210161,210262],"source":"This member function cannot be called when the output device context is attached to the `CDC` object."},{"content":"Use the <bpt id=\"p1\">**</bpt>Detach<ept id=\"p1\">**</ept> member function to detach the output device context.","pos":[210263,210334],"source":" Use the **Detach** member function to detach the output device context."},{"pos":[210373,210385],"content":"CDC::ResetDC"},{"pos":[210389,210472],"content":"Call this member function to update the device context wrapped by the <ph id=\"ph1\">`CDC`</ph> object.","source":"Call this member function to update the device context wrapped by the `CDC` object."},{"content":"Parameters","pos":[210537,210547]},{"content":"lpDevMode","pos":[210552,210561]},{"content":"A pointer to a Windows <ph id=\"ph1\">`DEVMODE`</ph> structure.","pos":[210566,210609],"source":" A pointer to a Windows `DEVMODE` structure."},{"content":"Return Value","pos":[210619,210631]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[210635,210686]},{"content":"Remarks","pos":[210696,210703]},{"content":"The device context is updated from the information specified in the Windows <ph id=\"ph1\">`DEVMODE`</ph> structure.","pos":[210707,210803],"source":"The device context is updated from the information specified in the Windows `DEVMODE` structure."},{"content":"This member function only resets the attribute device context.","pos":[210804,210866]},{"content":"An application will typically use the <ph id=\"ph1\">`ResetDC`</ph> member function when a window processes a <ph id=\"ph2\">`WM_DEVMODECHANGE`</ph> message.","pos":[210873,210990],"source":"An application will typically use the `ResetDC` member function when a window processes a `WM_DEVMODECHANGE` message."},{"content":"You can also use this member function to change the paper orientation or paper bins while printing a document.","pos":[210991,211101]},{"content":"You cannot use this member function to change the driver name, device name, or output port.","pos":[211108,211199]},{"content":"When the user changes the port connection or device name, you must delete the original device context and create a new device context with the new information.","pos":[211200,211359]},{"content":"Before you call this member function, you must ensure that all objects (other than stock objects) that had been selected into the device context have been selected out.","pos":[211366,211534]},{"pos":[211575,211589],"content":"CDC::RestoreDC"},{"pos":[211593,211668],"content":"Restores the device context to the previous state identified by <ph id=\"ph1\">`nSavedDC`</ph>.","source":"Restores the device context to the previous state identified by `nSavedDC`."},{"content":"Parameters","pos":[211731,211741]},{"content":"Specifies the device context to be restored.","pos":[211759,211803]},{"content":"It can be a value returned by a previous <ph id=\"ph1\">`SaveDC`</ph> function call.","pos":[211804,211868],"source":" It can be a value returned by a previous `SaveDC` function call."},{"content":"If <ph id=\"ph1\">`nSavedDC`</ph> is –1, the most recently saved device context is restored.","pos":[211869,211941],"source":" If `nSavedDC` is –1, the most recently saved device context is restored."},{"content":"Return Value","pos":[211951,211963]},{"content":"Nonzero if the specified context was restored; otherwise 0.","pos":[211967,212026]},{"content":"Remarks","pos":[212036,212043]},{"pos":[212059,212185],"content":"restores the device context by popping state information off a stack created by earlier calls to the <ph id=\"ph1\">`SaveDC`</ph> member function.","source":" restores the device context by popping state information off a stack created by earlier calls to the `SaveDC` member function."},{"content":"The stack can contain the state information for several device contexts.","pos":[212192,212264]},{"content":"If the context specified by <ph id=\"ph1\">`nSavedDC`</ph> is not at the top of the stack, <ph id=\"ph2\">`RestoreDC`</ph> deletes all state information between the device context specified by <ph id=\"ph3\">`nSavedDC`</ph> and the top of the stack.","pos":[212265,212454],"source":" If the context specified by `nSavedDC` is not at the top of the stack, `RestoreDC` deletes all state information between the device context specified by `nSavedDC` and the top of the stack."},{"content":"The deleted information is lost.","pos":[212455,212487]},{"pos":[212528,212542],"content":"CDC::RoundRect"},{"content":"Draws a rectangle with rounded corners using the current pen.","pos":[212546,212607]},{"content":"Parameters","pos":[212788,212798]},{"content":"Specifies the x-coordinate of the upper-left corner of the rectangle (in logical units).","pos":[212810,212898]},{"content":"Specifies the y-coordinate of the upper-left corner of the rectangle (in logical units).","pos":[212913,213001]},{"content":"Specifies the x-coordinate of the lower-right corner of the rectangle (in logical units).","pos":[213016,213105]},{"content":"Specifies the y-coordinate of the lower-right corner of the rectangle (in logical units).","pos":[213120,213209]},{"content":"x3","pos":[213217,213219]},{"content":"Specifies the width of the ellipse used to draw the rounded corners (in logical units).","pos":[213224,213311]},{"content":"Specifies the height of the ellipse used to draw the rounded corners (in logical units).","pos":[213326,213414]},{"content":"Specifies the bounding rectangle in logical units.","pos":[213433,213483]},{"content":"You can pass either a <ph id=\"ph1\">`CRect`</ph> object or a pointer to a <ph id=\"ph2\">`RECT`</ph> structure for this parameter.","pos":[213484,213575],"source":" You can pass either a `CRect` object or a pointer to a `RECT` structure for this parameter."},{"content":"The x-coordinate of <ph id=\"ph1\">`point`</ph> specifies the width of the ellipse to draw the rounded corners (in logical units).","pos":[213593,213703],"source":" The x-coordinate of `point` specifies the width of the ellipse to draw the rounded corners (in logical units)."},{"content":"The y-coordinate of <ph id=\"ph1\">`point`</ph> specifies the height of the ellipse to draw the rounded corners (in logical units).","pos":[213704,213815],"source":" The y-coordinate of `point` specifies the height of the ellipse to draw the rounded corners (in logical units)."},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[213816,213898],"source":" You can pass either a **POINT** structure or a `CPoint` object for this parameter."},{"content":"Return Value","pos":[213908,213920]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[213924,213975]},{"content":"Remarks","pos":[213985,213992]},{"content":"The interior of the rectangle is filled using the current brush.","pos":[213996,214060]},{"content":"The figure this function draws extends up to but does not include the right and bottom coordinates.","pos":[214067,214166]},{"content":"This means that the height of the figure is <ph id=\"ph1\">`y2`</ph> – <ph id=\"ph2\">`y1`</ph> and the width of the figure is <ph id=\"ph3\">`x2`</ph> – <ph id=\"ph4\">`x1`</ph>.","pos":[214167,214266],"source":" This means that the height of the figure is `y2` – `y1` and the width of the figure is `x2` – `x1`."},{"content":"Both the height and the width of the bounding rectangle must be greater than 2 units and less than 32,767 units.","pos":[214267,214379]},{"content":"Example","pos":[214389,214396]},{"pos":[214411,214428],"content":"NVC_MFCDocView#40"},{"pos":[214512,214523],"content":"CDC::SaveDC"},{"content":"Saves the current state of the device context by copying state information (such as clipping region, selected objects, and mapping mode) to a context stack maintained by Windows.","pos":[214527,214705]},{"content":"Return Value","pos":[214752,214764]},{"content":"An integer identifying the saved device context.","pos":[214768,214816]},{"content":"It is 0 if an error occurs.","pos":[214817,214844]},{"content":"This return value can be used to restore the device context by calling <ph id=\"ph1\">`RestoreDC`</ph>.","pos":[214845,214928],"source":" This return value can be used to restore the device context by calling `RestoreDC`."},{"content":"Remarks","pos":[214938,214945]},{"pos":[214949,215017],"content":"The saved device context can later be restored by using <ph id=\"ph1\">`RestoreDC`</ph>.","source":"The saved device context can later be restored by using `RestoreDC`."},{"pos":[215033,215109],"content":"can be used any number of times to save any number of device-context states."},{"pos":[215157,215178],"content":"CDC::ScaleViewportExt"},{"content":"Modifies the viewport extents relative to the current values.","pos":[215182,215243]},{"content":"Parameters","pos":[215367,215377]},{"content":"Specifies the amount by which to multiply the current x-extent.","pos":[215391,215454]},{"content":"Specifies the amount by which to divide the result of multiplying the current x-extent by the value of the <ph id=\"ph1\">`xNum`</ph> parameter.","pos":[215473,215597],"source":" Specifies the amount by which to divide the result of multiplying the current x-extent by the value of the `xNum` parameter."},{"content":"Specifies the amount by which to multiply the current y-extent.","pos":[215614,215677]},{"content":"Specifies the amount by which to divide the result of multiplying the current y-extent by the value of the <ph id=\"ph1\">`yNum`</ph> parameter.","pos":[215696,215820],"source":" Specifies the amount by which to divide the result of multiplying the current y-extent by the value of the `yNum` parameter."},{"content":"Return Value","pos":[215830,215842]},{"pos":[215846,215914],"content":"The previous viewport extents (in device units) as a <ph id=\"ph1\">`CSize`</ph> object.","source":"The previous viewport extents (in device units) as a `CSize` object."},{"content":"Remarks","pos":[215924,215931]},{"content":"The formulas are written as follows:","pos":[215935,215971]},{"content":"The new viewport extents are calculated by multiplying the current extents by the given numerator and then dividing by the given denominator.","pos":[216066,216207]},{"pos":[216253,216272],"content":"CDC::ScaleWindowExt"},{"content":"Modifies the window extents relative to the current values.","pos":[216276,216335]},{"content":"Parameters","pos":[216457,216467]},{"content":"Specifies the amount by which to multiply the current x-extent.","pos":[216481,216544]},{"content":"Specifies the amount by which to divide the result of multiplying the current x-extent by the value of the <ph id=\"ph1\">`xNum`</ph> parameter.","pos":[216563,216687],"source":" Specifies the amount by which to divide the result of multiplying the current x-extent by the value of the `xNum` parameter."},{"content":"Specifies the amount by which to multiply the current y-extent.","pos":[216704,216767]},{"content":"Specifies the amount by which to divide the result of multiplying the current y-extent by the value of the <ph id=\"ph1\">`yNum`</ph> parameter.","pos":[216786,216910],"source":" Specifies the amount by which to divide the result of multiplying the current y-extent by the value of the `yNum` parameter."},{"content":"Return Value","pos":[216920,216932]},{"pos":[216936,217003],"content":"The previous window extents (in logical units) as a <ph id=\"ph1\">`CSize`</ph> object.","source":"The previous window extents (in logical units) as a `CSize` object."},{"content":"Remarks","pos":[217013,217020]},{"content":"The formulas are written as follows:","pos":[217024,217060]},{"content":"The new window extents are calculated by multiplying the current extents by the given numerator and then dividing by the given denominator.","pos":[217155,217294]},{"pos":[217334,217347],"content":"CDC::ScrollDC"},{"content":"Scrolls a rectangle of bits horizontally and vertically.","pos":[217351,217407]},{"content":"Parameters","pos":[217579,217589]},{"content":"Specifies the number of horizontal scroll units.","pos":[217601,217649]},{"content":"dy","pos":[217657,217659]},{"content":"Specifies the number of vertical scroll units.","pos":[217664,217710]},{"content":"Points to the <ph id=\"ph1\">`RECT`</ph> structure or <ph id=\"ph2\">`CRect`</ph> object that contains the coordinates of the scrolling rectangle.","pos":[217735,217841],"source":" Points to the `RECT` structure or `CRect` object that contains the coordinates of the scrolling rectangle."},{"content":"Points to the <ph id=\"ph1\">`RECT`</ph> structure or <ph id=\"ph2\">`CRect`</ph> object that contains the coordinates of the clipping rectangle.","pos":[217864,217969],"source":" Points to the `RECT` structure or `CRect` object that contains the coordinates of the clipping rectangle."},{"content":"When this rectangle is smaller than the original one pointed to by <ph id=\"ph1\">`lpRectScroll`</ph>, scrolling occurs only in the smaller rectangle.","pos":[217970,218100],"source":" When this rectangle is smaller than the original one pointed to by `lpRectScroll`, scrolling occurs only in the smaller rectangle."},{"content":"Identifies the region uncovered by the scrolling process.","pos":[218123,218180]},{"content":"The <ph id=\"ph1\">`ScrollDC`</ph> function defines this region; it is not necessarily a rectangle.","pos":[218181,218260],"source":" The `ScrollDC` function defines this region; it is not necessarily a rectangle."},{"content":"Points to the <ph id=\"ph1\">`RECT`</ph> structure or <ph id=\"ph2\">`CRect`</ph> object that receives the coordinates of the rectangle that bounds the scrolling update region.","pos":[218285,218421],"source":" Points to the `RECT` structure or `CRect` object that receives the coordinates of the rectangle that bounds the scrolling update region."},{"content":"This is the largest rectangular area that requires repainting.","pos":[218422,218484]},{"content":"The values in the structure or object when the function returns are in client coordinates, regardless of the mapping mode for the given device context.","pos":[218485,218636]},{"content":"Return Value","pos":[218646,218658]},{"content":"Nonzero if scrolling is executed; otherwise 0.","pos":[218662,218708]},{"content":"Remarks","pos":[218718,218725]},{"content":"If <ph id=\"ph1\">`lpRectUpdate`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, Windows does not compute the update rectangle.","pos":[218729,218806],"source":"If `lpRectUpdate` is **NULL**, Windows does not compute the update rectangle."},{"content":"If both <ph id=\"ph1\">`pRgnUpdate`</ph> and <ph id=\"ph2\">`lpRectUpdate`</ph> are <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, Windows does not compute the update region.","pos":[218807,218904],"source":" If both `pRgnUpdate` and `lpRectUpdate` are **NULL**, Windows does not compute the update region."},{"content":"If <ph id=\"ph1\">`pRgnUpdate`</ph> is not <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, Windows assumes that it contains a valid pointer to the region uncovered by the scrolling process (defined by the <ph id=\"ph2\">`ScrollDC`</ph> member function).","pos":[218905,219080],"source":" If `pRgnUpdate` is not **NULL**, Windows assumes that it contains a valid pointer to the region uncovered by the scrolling process (defined by the `ScrollDC` member function)."},{"content":"The update region returned in <ph id=\"ph1\">`lpRectUpdate`</ph> can be passed to <ph id=\"ph2\">`CWnd::InvalidateRgn`</ph> if required.","pos":[219081,219177],"source":" The update region returned in `lpRectUpdate` can be passed to `CWnd::InvalidateRgn` if required."},{"content":"An application should use the <ph id=\"ph1\">`ScrollWindow`</ph> member function of class <ph id=\"ph2\">`CWnd`</ph> when it is necessary to scroll the entire client area of a window.","pos":[219184,219327],"source":"An application should use the `ScrollWindow` member function of class `CWnd` when it is necessary to scroll the entire client area of a window."},{"content":"Otherwise, it should use <ph id=\"ph1\">`ScrollDC`</ph>.","pos":[219328,219364],"source":" Otherwise, it should use `ScrollDC`."},{"pos":[219410,219429],"content":"CDC::SelectClipPath"},{"content":"Selects the current path as a clipping region for the device context, combining the new region with any existing clipping region by using the specified mode.","pos":[219433,219590]},{"content":"Parameters","pos":[219647,219657]},{"content":"Specifies the way to use the path.","pos":[219672,219706]},{"content":"The following values are allowed:","pos":[219707,219740]},{"pos":[219748,219882],"content":"<bpt id=\"p1\">**</bpt>RGN_AND<ept id=\"p1\">**</ept> The new clipping region includes the intersection (overlapping areas) of the current clipping region and the current path.","source":"**RGN_AND** The new clipping region includes the intersection (overlapping areas) of the current clipping region and the current path."},{"pos":[219890,219947],"content":"<bpt id=\"p1\">**</bpt>RGN_COPY<ept id=\"p1\">**</ept> The new clipping region is the current path.","source":"**RGN_COPY** The new clipping region is the current path."},{"pos":[219955,220086],"content":"<bpt id=\"p1\">**</bpt>RGN_DIFF<ept id=\"p1\">**</ept> The new clipping region includes the areas of the current clipping region, and those of the current path are excluded.","source":"**RGN_DIFF** The new clipping region includes the areas of the current clipping region, and those of the current path are excluded."},{"pos":[220094,220217],"content":"<bpt id=\"p1\">**</bpt>RGN_OR<ept id=\"p1\">**</ept> The new clipping region includes the union (combined areas) of the current clipping region and the current path.","source":"**RGN_OR** The new clipping region includes the union (combined areas) of the current clipping region and the current path."},{"pos":[220225,220367],"content":"<bpt id=\"p1\">**</bpt>RGN_XOR<ept id=\"p1\">**</ept> The new clipping region includes the union of the current clipping region and the current path, but without the overlapping areas.","source":"**RGN_XOR** The new clipping region includes the union of the current clipping region and the current path, but without the overlapping areas."},{"content":"Return Value","pos":[220377,220389]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[220393,220444]},{"content":"Remarks","pos":[220454,220461]},{"content":"The device context identified must contain a closed path.","pos":[220465,220522]},{"pos":[220567,220585],"content":"CDC::SelectClipRgn"},{"content":"Selects the given region as the current clipping region for the device context.","pos":[220589,220668]},{"content":"Parameters","pos":[220785,220795]},{"content":"Identifies the region to be selected.","pos":[220809,220846]},{"pos":[220856,221000],"content":"For the first version of this function, if this value is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the entire client area is selected and output is still clipped to the window.","source":"For the first version of this function, if this value is **NULL**, the entire client area is selected and output is still clipped to the window."},{"pos":[221010,221124],"content":"For the second version of this function, this handle can be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> only when the <bpt id=\"p2\">**</bpt>RGN_COPY<ept id=\"p2\">**</ept> mode is specified.","source":"For the second version of this function, this handle can be **NULL** only when the **RGN_COPY** mode is specified."},{"pos":[221131,221222],"content":"`nMode`  \nSpecifies the operation to be performed. It must be one of the following values:","leadings":[""," "],"nodes":[{"content":"Specifies the operation to be performed. It must be one of the following values:","pos":[10,90],"nodes":[{"content":"Specifies the operation to be performed.","pos":[0,40]},{"content":"It must be one of the following values:","pos":[41,80]}]}]},{"pos":[221230,221364],"content":"<bpt id=\"p1\">**</bpt>RGN_AND<ept id=\"p1\">**</ept> The new clipping region combines the overlapping areas of the current clipping region and the region identified by <ph id=\"ph1\">`pRgn`</ph>.","source":"**RGN_AND** The new clipping region combines the overlapping areas of the current clipping region and the region identified by `pRgn`."},{"content":"<bpt id=\"p1\">**</bpt>RGN_COPY<ept id=\"p1\">**</ept> The new clipping region is a copy of the region identified by <ph id=\"ph1\">`pRgn`</ph>.","pos":[221372,221454],"source":"**RGN_COPY** The new clipping region is a copy of the region identified by `pRgn`."},{"content":"This is functionality is identical to the first version of <ph id=\"ph1\">`SelectClipRgn`</ph>.","pos":[221455,221530],"source":" This is functionality is identical to the first version of `SelectClipRgn`."},{"content":"If the region identified by <ph id=\"ph1\">`pRgn`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the new clipping region becomes the default clipping region (a null region).","pos":[221531,221655],"source":" If the region identified by `pRgn` is **NULL**, the new clipping region becomes the default clipping region (a null region)."},{"pos":[221663,221813],"content":"<bpt id=\"p1\">**</bpt>RGN_DIFF<ept id=\"p1\">**</ept> The new clipping region combines the areas of the current clipping region with those areas excluded from the region identified by <ph id=\"ph1\">`pRgn`</ph>.","source":"**RGN_DIFF** The new clipping region combines the areas of the current clipping region with those areas excluded from the region identified by `pRgn`."},{"pos":[221821,221929],"content":"<bpt id=\"p1\">**</bpt>RGN_OR<ept id=\"p1\">**</ept> The new clipping region combines the current clipping region and the region identified by <ph id=\"ph1\">`pRgn`</ph>.","source":"**RGN_OR** The new clipping region combines the current clipping region and the region identified by `pRgn`."},{"pos":[221937,222081],"content":"<bpt id=\"p1\">**</bpt>RGN_XOR<ept id=\"p1\">**</ept> The new clipping region combines the current clipping region and the region identified by <ph id=\"ph1\">`pRgn`</ph> but excludes any overlapping areas.","source":"**RGN_XOR** The new clipping region combines the current clipping region and the region identified by `pRgn` but excludes any overlapping areas."},{"content":"Return Value","pos":[222091,222103]},{"content":"The region's type.","pos":[222107,222125]},{"content":"It can be any of the following values:","pos":[222126,222164]},{"pos":[222172,222234],"content":"<bpt id=\"p1\">**</bpt>COMPLEXREGION<ept id=\"p1\">**</ept> New clipping region has overlapping borders.","source":"**COMPLEXREGION** New clipping region has overlapping borders."},{"pos":[222242,222290],"content":"<bpt id=\"p1\">**</bpt>ERROR<ept id=\"p1\">**</ept> Device context or region is not valid.","source":"**ERROR** Device context or region is not valid."},{"pos":[222298,222342],"content":"<bpt id=\"p1\">**</bpt>NULLREGION<ept id=\"p1\">**</ept> New clipping region is empty.","source":"**NULLREGION** New clipping region is empty."},{"pos":[222350,222414],"content":"<bpt id=\"p1\">**</bpt>SIMPLEREGION<ept id=\"p1\">**</ept> New clipping region has no overlapping borders.","source":"**SIMPLEREGION** New clipping region has no overlapping borders."},{"content":"Remarks","pos":[222424,222431]},{"content":"Only a copy of the selected region is used.","pos":[222435,222478]},{"content":"The region itself can be selected for any number of other device contexts, or it can be deleted.","pos":[222479,222575]},{"content":"The function assumes that the coordinates for the given region are specified in device units.","pos":[222582,222675]},{"content":"Some printer devices support text output at a higher resolution than graphics output in order to retain the precision needed to express text metrics.","pos":[222676,222825]},{"content":"These devices report device units at the higher resolution, that is, in text units.","pos":[222826,222909]},{"content":"These devices then scale coordinates for graphics so that several reported device units map to only 1 graphic unit.","pos":[222910,223025]},{"content":"You should always call the <ph id=\"ph1\">`SelectClipRgn`</ph> function using text units.","pos":[223026,223095],"source":" You should always call the `SelectClipRgn` function using text units."},{"content":"Applications that must take the scaling of graphics objects in the GDI can use the <bpt id=\"p1\">**</bpt>GETSCALINGFACTOR<ept id=\"p1\">**</ept> printer escape to determine the scaling factor.","pos":[223102,223253],"source":"Applications that must take the scaling of graphics objects in the GDI can use the **GETSCALINGFACTOR** printer escape to determine the scaling factor."},{"content":"This scaling factor affects clipping.","pos":[223254,223291]},{"content":"If a region is used to clip graphics, GDI divides the coordinates by the scaling factor.","pos":[223292,223380]},{"content":"If the region is used to clip text, GDI makes no scaling adjustment.","pos":[223381,223449]},{"content":"A scaling factor of 1 causes the coordinates to be divided by 2; a scaling factor of 2 causes the coordinates to be divided by 4; and so on.","pos":[223450,223590]},{"pos":[223634,223651],"content":"CDC::SelectObject"},{"content":"Selects an object into the device context.","pos":[223655,223697]},{"content":"Parameters","pos":[223968,223978]},{"content":"pPen","pos":[223983,223987]},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>CPen<ept id=\"p1\">](../../mfc/reference/cpen-class.md)</ept> object to be selected.","pos":[223992,224071],"source":" A pointer to a [CPen](../../mfc/reference/cpen-class.md) object to be selected."},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>CBrush<ept id=\"p1\">](../../mfc/reference/cbrush-class.md)</ept> object to be selected.","pos":[224090,224173],"source":" A pointer to a [CBrush](../../mfc/reference/cbrush-class.md) object to be selected."},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>CFont<ept id=\"p1\">](../../mfc/reference/cfont-class.md)</ept> object to be selected.","pos":[224191,224272],"source":" A pointer to a [CFont](../../mfc/reference/cfont-class.md) object to be selected."},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>CBitmap<ept id=\"p1\">](../../mfc/reference/cbitmap-class.md)</ept> object to be selected.","pos":[224292,224377],"source":" A pointer to a [CBitmap](../../mfc/reference/cbitmap-class.md) object to be selected."},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>CRgn<ept id=\"p1\">](../../mfc/reference/crgn-class.md)</ept> object to be selected.","pos":[224394,224473],"source":" A pointer to a [CRgn](../../mfc/reference/crgn-class.md) object to be selected."},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>CGdiObject<ept id=\"p1\">](../../mfc/reference/cgdiobject-class.md)</ept> object to be selected.","pos":[224493,224584],"source":" A pointer to a [CGdiObject](../../mfc/reference/cgdiobject-class.md) object to be selected."},{"content":"Return Value","pos":[224594,224606]},{"content":"A pointer to the object being replaced.","pos":[224610,224649]},{"content":"This is a pointer to an object of one of the classes derived from <ph id=\"ph1\">`CGdiObject`</ph>, such as <ph id=\"ph2\">`CPen`</ph>, depending on which version of the function is used.","pos":[224650,224797],"source":" This is a pointer to an object of one of the classes derived from `CGdiObject`, such as `CPen`, depending on which version of the function is used."},{"content":"The return value is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if there is an error.","pos":[224798,224848],"source":" The return value is **NULL** if there is an error."},{"content":"This function may return a pointer to a temporary object.","pos":[224849,224906]},{"content":"This temporary object is only valid during the processing of one Windows message.","pos":[224907,224988]},{"content":"For more information, see <ph id=\"ph1\">`CGdiObject::FromHandle`</ph>.","pos":[224989,225040],"source":" For more information, see `CGdiObject::FromHandle`."},{"content":"The version of the member function that takes a region parameter performs the same task as the <ph id=\"ph1\">`SelectClipRgn`</ph> member function.","pos":[225047,225174],"source":"The version of the member function that takes a region parameter performs the same task as the `SelectClipRgn` member function."},{"content":"Its return value can be any of the following:","pos":[225175,225220]},{"pos":[225228,225290],"content":"<bpt id=\"p1\">**</bpt>COMPLEXREGION<ept id=\"p1\">**</ept> New clipping region has overlapping borders.","source":"**COMPLEXREGION** New clipping region has overlapping borders."},{"pos":[225298,225346],"content":"<bpt id=\"p1\">**</bpt>ERROR<ept id=\"p1\">**</ept> Device context or region is not valid.","source":"**ERROR** Device context or region is not valid."},{"pos":[225354,225398],"content":"<bpt id=\"p1\">**</bpt>NULLREGION<ept id=\"p1\">**</ept> New clipping region is empty.","source":"**NULLREGION** New clipping region is empty."},{"pos":[225406,225470],"content":"<bpt id=\"p1\">**</bpt>SIMPLEREGION<ept id=\"p1\">**</ept> New clipping region has no overlapping borders.","source":"**SIMPLEREGION** New clipping region has no overlapping borders."},{"content":"Remarks","pos":[225480,225487]},{"content":"Class <ph id=\"ph1\">`CDC`</ph> provides five versions specialized for particular kinds of GDI objects, including pens, brushes, fonts, bitmaps, and regions.","pos":[225491,225628],"source":"Class `CDC` provides five versions specialized for particular kinds of GDI objects, including pens, brushes, fonts, bitmaps, and regions."},{"content":"The newly selected object replaces the previous object of the same type.","pos":[225629,225701]},{"content":"For example, if <ph id=\"ph1\">`pObject`</ph> of the general version of <ph id=\"ph2\">`SelectObject`</ph> points to a <bpt id=\"p1\">[</bpt>CPen<ept id=\"p1\">](../../mfc/reference/cpen-class.md)</ept> object, the function replaces the current pen with the pen specified by <ph id=\"ph3\">`pObject`</ph>.","pos":[225702,225905],"source":" For example, if `pObject` of the general version of `SelectObject` points to a [CPen](../../mfc/reference/cpen-class.md) object, the function replaces the current pen with the pen specified by `pObject`."},{"content":"An application can select a bitmap into memory device contexts only and into only one memory device context at a time.","pos":[225912,226030]},{"content":"The format of the bitmap must either be monochrome or compatible with the device context; if it is not, <ph id=\"ph1\">`SelectObject`</ph> returns an error.","pos":[226031,226167],"source":" The format of the bitmap must either be monochrome or compatible with the device context; if it is not, `SelectObject` returns an error."},{"content":"For Windows 3.1 and later, the <ph id=\"ph1\">`SelectObject`</ph> function returns the same value whether it is used in a metafile or not.","pos":[226174,226292],"source":"For Windows 3.1 and later, the `SelectObject` function returns the same value whether it is used in a metafile or not."},{"content":"Under previous versions of Windows, <ph id=\"ph1\">`SelectObject`</ph> returned a nonzero value for success and 0 for failure when it was used in a metafile.","pos":[226293,226430],"source":" Under previous versions of Windows, `SelectObject` returned a nonzero value for success and 0 for failure when it was used in a metafile."},{"pos":[226475,226493],"content":"CDC::SelectPalette"},{"pos":[226497,226610],"content":"Selects the logical palette that is specified by <ph id=\"ph1\">`pPalette`</ph> as the selected palette object of the device context.","source":"Selects the logical palette that is specified by `pPalette` as the selected palette object of the device context."},{"content":"Parameters","pos":[226714,226724]},{"content":"Identifies the logical palette to be selected.","pos":[226742,226788]},{"content":"This palette must already have been created with the <ph id=\"ph1\">`CPalette`</ph> member function <bpt id=\"p1\">[</bpt>CreatePalette<ept id=\"p1\">](../../mfc/reference/cpalette-class.md#cpalette__createpalette)</ept>.","pos":[226789,226948],"source":" This palette must already have been created with the `CPalette` member function [CreatePalette](../../mfc/reference/cpalette-class.md#cpalette__createpalette)."},{"content":"Specifies whether the logical palette is forced to be a background palette.","pos":[226977,227052]},{"content":"If <ph id=\"ph1\">`bForceBackground`</ph> is nonzero, the selected palette is always a background palette, regardless of whether the window has the input focus.","pos":[227053,227193],"source":" If `bForceBackground` is nonzero, the selected palette is always a background palette, regardless of whether the window has the input focus."},{"content":"If <ph id=\"ph1\">`bForceBackground`</ph> is 0 and the device context is attached to a window, the logical palette is a foreground palette when the window has the input focus.","pos":[227194,227349],"source":" If `bForceBackground` is 0 and the device context is attached to a window, the logical palette is a foreground palette when the window has the input focus."},{"content":"Return Value","pos":[227359,227371]},{"content":"A pointer to a <ph id=\"ph1\">`CPalette`</ph> object identifying the logical palette replaced by the palette specified by <ph id=\"ph2\">`pPalette`</ph>.","pos":[227375,227488],"source":"A pointer to a `CPalette` object identifying the logical palette replaced by the palette specified by `pPalette`."},{"content":"It is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if there is an error.","pos":[227489,227525],"source":" It is **NULL** if there is an error."},{"content":"Remarks","pos":[227535,227542]},{"content":"The new palette becomes the palette object used by GDI to control colors displayed in the device context and replaces the previous palette.","pos":[227546,227685]},{"content":"An application can select a logical palette into more than one device context.","pos":[227692,227770]},{"content":"However, changes to a logical palette will affect all device contexts for which it is selected.","pos":[227771,227866]},{"content":"If an application selects a palette into more than one device context, the device contexts must all belong to the same physical device.","pos":[227867,228002]},{"pos":[228051,228073],"content":"CDC::SelectStockObject"},{"pos":[228077,228220],"content":"Selects a <bpt id=\"p1\">[</bpt>CGdiObject<ept id=\"p1\">](../../mfc/reference/cgdiobject-class.md)</ept> object that corresponds to one of the predefined stock pens, brushes, or fonts.","source":"Selects a [CGdiObject](../../mfc/reference/cgdiobject-class.md) object that corresponds to one of the predefined stock pens, brushes, or fonts."},{"content":"Parameters","pos":[228296,228306]},{"content":"Specifies the kind of stock object desired.","pos":[228322,228365]},{"content":"It can be one of the following values:","pos":[228366,228404]},{"pos":[228412,228440],"content":"<bpt id=\"p1\">**</bpt>BLACK_BRUSH<ept id=\"p1\">**</ept> Black brush.","source":"**BLACK_BRUSH** Black brush."},{"pos":[228448,228481],"content":"<bpt id=\"p1\">**</bpt>DKGRAY_BRUSH<ept id=\"p1\">**</ept> Dark gray brush.","source":"**DKGRAY_BRUSH** Dark gray brush."},{"pos":[228489,228515],"content":"<bpt id=\"p1\">**</bpt>GRAY_BRUSH<ept id=\"p1\">**</ept> Gray brush.","source":"**GRAY_BRUSH** Gray brush."},{"pos":[228523,228553],"content":"<bpt id=\"p1\">**</bpt>HOLLOW_BRUSH<ept id=\"p1\">**</ept> Hollow brush.","source":"**HOLLOW_BRUSH** Hollow brush."},{"pos":[228561,228595],"content":"<bpt id=\"p1\">**</bpt>LTGRAY_BRUSH<ept id=\"p1\">**</ept> Light gray brush.","source":"**LTGRAY_BRUSH** Light gray brush."},{"pos":[228603,228629],"content":"<bpt id=\"p1\">**</bpt>NULL_BRUSH<ept id=\"p1\">**</ept> Null brush.","source":"**NULL_BRUSH** Null brush."},{"pos":[228637,228665],"content":"<bpt id=\"p1\">**</bpt>WHITE_BRUSH<ept id=\"p1\">**</ept> White brush.","source":"**WHITE_BRUSH** White brush."},{"pos":[228673,228697],"content":"<bpt id=\"p1\">**</bpt>BLACK_PEN<ept id=\"p1\">**</ept> Black pen.","source":"**BLACK_PEN** Black pen."},{"pos":[228705,228727],"content":"<bpt id=\"p1\">**</bpt>NULL_PEN<ept id=\"p1\">**</ept> Null pen.","source":"**NULL_PEN** Null pen."},{"pos":[228735,228759],"content":"<bpt id=\"p1\">**</bpt>WHITE_PEN<ept id=\"p1\">**</ept> White pen.","source":"**WHITE_PEN** White pen."},{"pos":[228767,228810],"content":"<bpt id=\"p1\">**</bpt>ANSI_FIXED_FONT<ept id=\"p1\">**</ept> ANSI fixed system font.","source":"**ANSI_FIXED_FONT** ANSI fixed system font."},{"pos":[228818,228862],"content":"<bpt id=\"p1\">**</bpt>ANSI_VAR_FONT<ept id=\"p1\">**</ept> ANSI variable system font.","source":"**ANSI_VAR_FONT** ANSI variable system font."},{"pos":[228870,228916],"content":"<bpt id=\"p1\">**</bpt>DEVICE_DEFAULT_FONT<ept id=\"p1\">**</ept> Device-dependent font.","source":"**DEVICE_DEFAULT_FONT** Device-dependent font."},{"pos":[228924,228968],"content":"<bpt id=\"p1\">**</bpt>OEM_FIXED_FONT<ept id=\"p1\">**</ept> OEM-dependent fixed font.","source":"**OEM_FIXED_FONT** OEM-dependent fixed font."},{"content":"<bpt id=\"p1\">**</bpt>SYSTEM_FONT<ept id=\"p1\">**</ept> The system font.","pos":[228976,229008],"source":"**SYSTEM_FONT** The system font."},{"content":"By default, Windows uses the system font to draw menus, dialog-box controls, and other text.","pos":[229009,229101]},{"content":"It is best, however, not to rely on SYSTEM_FONT to obtain the font used by dialogs and windows.","pos":[229102,229197]},{"content":"Instead, use the <ph id=\"ph1\">`SystemParametersInfo`</ph> function with the SPI_GETNONCLIENTMETRICS parameter to retrieve the current font.","pos":[229198,229319],"source":" Instead, use the `SystemParametersInfo` function with the SPI_GETNONCLIENTMETRICS parameter to retrieve the current font."},{"content":"takes into account the current theme and provides font information for captions, menus, and message dialogs.","pos":[229343,229451]},{"content":"<bpt id=\"p1\">**</bpt>SYSTEM_FIXED_FONT<ept id=\"p1\">**</ept> The fixed-width system font used in Windows prior to version 3.0.","pos":[229459,229546],"source":"**SYSTEM_FIXED_FONT** The fixed-width system font used in Windows prior to version 3.0."},{"content":"This object is available for compatibility with earlier versions of Windows.","pos":[229547,229623]},{"content":"<bpt id=\"p1\">**</bpt>DEFAULT_PALETTE<ept id=\"p1\">**</ept> Default color palette.","pos":[229631,229673],"source":"**DEFAULT_PALETTE** Default color palette."},{"content":"This palette consists of the 20 static colors in the system palette.","pos":[229674,229742]},{"content":"Return Value","pos":[229752,229764]},{"content":"A pointer to the <ph id=\"ph1\">`CGdiObject`</ph> object that was replaced if the function is successful.","pos":[229768,229853],"source":"A pointer to the `CGdiObject` object that was replaced if the function is successful."},{"content":"The actual object pointed to is a <bpt id=\"p1\">[</bpt>CPen<ept id=\"p1\">](../../mfc/reference/cpen-class.md)</ept>, <bpt id=\"p2\">[</bpt>CBrush<ept id=\"p2\">](../../mfc/reference/cbrush-class.md)</ept>, or <bpt id=\"p3\">[</bpt>CFont<ept id=\"p3\">](../../mfc/reference/cfont-class.md)</ept> object.","pos":[229854,230032],"source":" The actual object pointed to is a [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md), or [CFont](../../mfc/reference/cfont-class.md) object."},{"content":"If the call is unsuccessful, the return value is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[230033,230091],"source":" If the call is unsuccessful, the return value is **NULL**."},{"pos":[230135,230152],"content":"CDC::SetAbortProc"},{"content":"Installs the abort procedure for the print job.","pos":[230156,230203]},{"content":"Parameters","pos":[230294,230304]},{"content":"A pointer to the abort function to install as the abort procedure.","pos":[230318,230384]},{"content":"For more about the callback function, see <bpt id=\"p1\">[</bpt>Callback Function for CDC::SetAbortProc<ept id=\"p1\">](../../mfc/reference/callback-function-for-cdc-setabortproc.md)</ept>.","pos":[230385,230532],"source":" For more about the callback function, see [Callback Function for CDC::SetAbortProc](../../mfc/reference/callback-function-for-cdc-setabortproc.md)."},{"content":"Return Value","pos":[230542,230554]},{"content":"Specifies the outcome of the <ph id=\"ph1\">`SetAbortProc`</ph> function.","pos":[230558,230611],"source":"Specifies the outcome of the `SetAbortProc` function."},{"content":"Some of the following values are more probable than others, but all are possible.","pos":[230612,230693]},{"pos":[230701,230728],"content":"<bpt id=\"p1\">**</bpt>SP_ERROR<ept id=\"p1\">**</ept> General error.","source":"**SP_ERROR** General error."},{"pos":[230736,230852],"content":"<bpt id=\"p1\">**</bpt>SP_OUTOFDISK<ept id=\"p1\">**</ept> Not enough disk space is currently available for spooling, and no more space will become available.","source":"**SP_OUTOFDISK** Not enough disk space is currently available for spooling, and no more space will become available."},{"pos":[230860,230923],"content":"<bpt id=\"p1\">**</bpt>SP_OUTOFMEMORY<ept id=\"p1\">**</ept> Not enough memory is available for spooling.","source":"**SP_OUTOFMEMORY** Not enough memory is available for spooling."},{"pos":[230931,230993],"content":"<bpt id=\"p1\">**</bpt>SP_USERABORT<ept id=\"p1\">**</ept> User ended the job through the Print Manager.","source":"**SP_USERABORT** User ended the job through the Print Manager."},{"content":"Remarks","pos":[231003,231010]},{"content":"If an application is to allow the print job to be canceled during spooling, it must set the abort function before the print job is started with the <bpt id=\"p1\">[</bpt>StartDoc<ept id=\"p1\">](#cdc__startdoc)</ept> member function.","pos":[231014,231205],"source":"If an application is to allow the print job to be canceled during spooling, it must set the abort function before the print job is started with the [StartDoc](#cdc__startdoc) member function."},{"content":"The Print Manager calls the abort function during spooling to allow the application to cancel the print job or to process out-of-disk-space conditions.","pos":[231206,231357]},{"content":"If no abort function is set, the print job will fail if there is not enough disk space for spooling.","pos":[231358,231458]},{"content":"Note that the features of Microsoft Visual C++ simplify the creation of the callback function passed to <ph id=\"ph1\">`SetAbortProc`</ph>.","pos":[231465,231584],"source":"Note that the features of Microsoft Visual C++ simplify the creation of the callback function passed to `SetAbortProc`."},{"content":"The address passed to the <ph id=\"ph1\">`EnumObjects`</ph> member function is a pointer to a function exported with <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> and with the <ph id=\"ph2\">`__stdcall`</ph> calling convention.","pos":[231585,231752],"source":" The address passed to the `EnumObjects` member function is a pointer to a function exported with **__declspec(dllexport)** and with the `__stdcall` calling convention."},{"content":"You also do not have to export the function name in an <bpt id=\"p1\">**</bpt>EXPORTS<ept id=\"p1\">**</ept> statement in your application's module-definition file.","pos":[231759,231881],"source":"You also do not have to export the function name in an **EXPORTS** statement in your application's module-definition file."},{"content":"You can instead use the <bpt id=\"p1\">**</bpt>EXPORT<ept id=\"p1\">**</ept> function modifier, as in","pos":[231882,231941],"source":" You can instead use the **EXPORT** function modifier, as in"},{"pos":[231948,232004],"content":"<bpt id=\"p1\">**</bpt>BOOL CALLBACK EXPORT<ept id=\"p1\">**</ept> AFunction( <bpt id=\"p2\">**</bpt>HDC<ept id=\"p2\">**</ept>, <ph id=\"ph1\">`int`</ph><bpt id=\"p3\">**</bpt>);<ept id=\"p3\">**</ept>","source":"**BOOL CALLBACK EXPORT** AFunction( **HDC**, `int`**);**"},{"content":"to cause the compiler to emit the proper export record for export by name without aliasing.","pos":[232011,232102]},{"content":"This works for most needs.","pos":[232103,232129]},{"content":"For some special cases, such as exporting a function by ordinal or aliasing the export, you still need to use an <bpt id=\"p1\">**</bpt>EXPORTS<ept id=\"p1\">**</ept> statement in a module-definition file.","pos":[232130,232293],"source":" For some special cases, such as exporting a function by ordinal or aliasing the export, you still need to use an **EXPORTS** statement in a module-definition file."},{"content":"Callback registration interfaces are now type-safe (you must pass in a function pointer that points to the right kind of function for the specific callback).","pos":[232300,232457]},{"content":"Also note that all callback functions must trap Microsoft Foundation exceptions before returning to Windows, since exceptions cannot be thrown across callback boundaries.","pos":[232464,232634]},{"content":"For more information about exceptions, see the article <bpt id=\"p1\">[</bpt>Exceptions<ept id=\"p1\">](../../mfc/exception-handling-in-mfc.md)</ept>.","pos":[232635,232743],"source":" For more information about exceptions, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md)."},{"pos":[232790,232810],"content":"CDC::SetArcDirection"},{"content":"Sets the drawing direction to be used for arc and rectangle functions.","pos":[232814,232884]},{"content":"Parameters","pos":[232949,232959]},{"content":"nArcDirection","pos":[232964,232977]},{"content":"Specifies the new arc direction.","pos":[232982,233014]},{"content":"This parameter can be either of the following values:","pos":[233015,233068]},{"pos":[233076,233131],"content":"<bpt id=\"p1\">**</bpt>AD_COUNTERCLOCKWISE<ept id=\"p1\">**</ept> Figures drawn counterclockwise.","source":"**AD_COUNTERCLOCKWISE** Figures drawn counterclockwise."},{"pos":[233139,233180],"content":"<bpt id=\"p1\">**</bpt>AD_CLOCKWISE<ept id=\"p1\">**</ept> Figures drawn clockwise.","source":"**AD_CLOCKWISE** Figures drawn clockwise."},{"content":"Return Value","pos":[233190,233202]},{"content":"Specifies the old arc direction, if successful; otherwise 0.","pos":[233206,233266]},{"content":"Remarks","pos":[233276,233283]},{"content":"The default direction is counterclockwise.","pos":[233287,233329]},{"content":"The <ph id=\"ph1\">`SetArcDirection`</ph> function specifies the direction in which the following functions draw:","pos":[233330,233423],"source":" The `SetArcDirection` function specifies the direction in which the following functions draw:"},{"content":"Arc","pos":[233430,233433]},{"content":"Pie","pos":[233434,233437]},{"content":"Rectangle","pos":[233476,233485]},{"content":"Ellipse","pos":[233518,233525]},{"pos":[233572,233588],"content":"CDC::SetAttribDC"},{"pos":[233592,233662],"content":"Call this function to set the attribute device context, <ph id=\"ph1\">`m_hAttribDC`</ph>.","source":"Call this function to set the attribute device context, `m_hAttribDC`."},{"content":"Parameters","pos":[233722,233732]},{"content":"A Windows device context.","pos":[233745,233770]},{"content":"Remarks","pos":[233780,233787]},{"content":"This member function does not attach the device context to the <ph id=\"ph1\">`CDC`</ph> object.","pos":[233791,233867],"source":"This member function does not attach the device context to the `CDC` object."},{"content":"Only the output device context is attached to a <ph id=\"ph1\">`CDC`</ph> object.","pos":[233868,233929],"source":" Only the output device context is attached to a `CDC` object."},{"pos":[233971,233986],"content":"CDC::SetBkColor"},{"content":"Sets the current background color to the specified color.","pos":[233990,234047]},{"content":"Parameters","pos":[234119,234129]},{"content":"Specifies the new background color.","pos":[234146,234181]},{"content":"Return Value","pos":[234191,234203]},{"content":"The previous background color as an RGB color value.","pos":[234207,234259]},{"content":"If an error occurs, the return value is 0x80000000.","pos":[234260,234311]},{"content":"Remarks","pos":[234321,234328]},{"content":"If the background mode is <bpt id=\"p1\">**</bpt>OPAQUE<ept id=\"p1\">**</ept>, the system uses the background color to fill the gaps in styled lines, the gaps between hatched lines in brushes, and the background in character cells.","pos":[234332,234522],"source":"If the background mode is **OPAQUE**, the system uses the background color to fill the gaps in styled lines, the gaps between hatched lines in brushes, and the background in character cells."},{"content":"The system also uses the background color when converting bitmaps between color and monochrome device contexts.","pos":[234523,234634]},{"content":"If the device cannot display the specified color, the system sets the background color to the nearest physical color.","pos":[234641,234758]},{"pos":[234799,234813],"content":"CDC::SetBkMode"},{"content":"Sets the background mode.","pos":[234817,234842]},{"content":"Parameters","pos":[234895,234905]},{"content":"nBkMode","pos":[234910,234917]},{"content":"Specifies the mode to be set.","pos":[234922,234951]},{"content":"This parameter can be either of the following values:","pos":[234952,235005]},{"content":"<bpt id=\"p1\">**</bpt>OPAQUE<ept id=\"p1\">**</ept> Background is filled with the current background color before the text, hatched brush, or pen is drawn.","pos":[235013,235127],"source":"**OPAQUE** Background is filled with the current background color before the text, hatched brush, or pen is drawn."},{"content":"This is the default background mode.","pos":[235128,235164]},{"pos":[235172,235229],"content":"<bpt id=\"p1\">**</bpt>TRANSPARENT<ept id=\"p1\">**</ept> Background is not changed before drawing.","source":"**TRANSPARENT** Background is not changed before drawing."},{"content":"Return Value","pos":[235239,235251]},{"content":"The previous background mode.","pos":[235255,235284]},{"content":"Remarks","pos":[235294,235301]},{"content":"The background mode defines whether the system removes existing background colors on the drawing surface before drawing text, hatched brushes, or any pen style that is not a solid line.","pos":[235305,235490]},{"content":"Example","pos":[235500,235507]},{"pos":[235512,235603],"content":"See the example for <bpt id=\"p1\">[</bpt>CWnd::OnCtlColor<ept id=\"p1\">](../../mfc/reference/cwnd-class.md#cwnd__onctlcolor)</ept>.","source":"See the example for [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#cwnd__onctlcolor)."},{"pos":[235648,235666],"content":"CDC::SetBoundsRect"},{"content":"Controls the accumulation of bounding-rectangle information for the specified device context.","pos":[235670,235763]},{"content":"Parameters","pos":[235853,235863]},{"content":"Points to a <ph id=\"ph1\">`RECT`</ph> structure or <ph id=\"ph2\">`CRect`</ph> object that is used to set the bounding rectangle.","pos":[235885,235975],"source":" Points to a `RECT` structure or `CRect` object that is used to set the bounding rectangle."},{"content":"Rectangle dimensions are given in logical coordinates.","pos":[235976,236030]},{"content":"This parameter can be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[236031,236062],"source":" This parameter can be **NULL**."},{"content":"Specifies how the new rectangle will be combined with the accumulated rectangle.","pos":[236080,236160]},{"content":"This parameter can be a combination of the following values:","pos":[236161,236221]},{"pos":[236229,236356],"content":"<bpt id=\"p1\">**</bpt>DCB_ACCUMULATE<ept id=\"p1\">**</ept> Add the rectangle specified by <ph id=\"ph1\">`lpRectBounds`</ph> to the bounding rectangle (using a rectangle-union operation).","source":"**DCB_ACCUMULATE** Add the rectangle specified by `lpRectBounds` to the bounding rectangle (using a rectangle-union operation)."},{"pos":[236364,236409],"content":"<bpt id=\"p1\">**</bpt>DCB_DISABLE<ept id=\"p1\">**</ept> Turn off bounds accumulation.","source":"**DCB_DISABLE** Turn off bounds accumulation."},{"content":"<bpt id=\"p1\">**</bpt>DCB_ENABLE<ept id=\"p1\">**</ept> Turn on bounds accumulation.","pos":[236417,236460],"source":"**DCB_ENABLE** Turn on bounds accumulation."},{"content":"(The default setting for bounds accumulation is disabled.)","pos":[236461,236519]},{"content":"Return Value","pos":[236529,236541]},{"content":"The current state of the bounding rectangle, if the function is successful.","pos":[236545,236620]},{"content":"Like <ph id=\"ph1\">`flags`</ph>, the return value can be a combination of <bpt id=\"p1\">**</bpt>DCB_<ept id=\"p1\">**</ept> values:","pos":[236621,236692],"source":" Like `flags`, the return value can be a combination of **DCB_** values:"},{"content":"<bpt id=\"p1\">**</bpt>DCB_ACCUMULATE<ept id=\"p1\">**</ept> The bounding rectangle is not empty.","pos":[236700,236755],"source":"**DCB_ACCUMULATE** The bounding rectangle is not empty."},{"content":"This value will always be set.","pos":[236756,236786]},{"pos":[236794,236837],"content":"<bpt id=\"p1\">**</bpt>DCB_DISABLE<ept id=\"p1\">**</ept> Bounds accumulation is off.","source":"**DCB_DISABLE** Bounds accumulation is off."},{"pos":[236845,236886],"content":"<bpt id=\"p1\">**</bpt>DCB_ENABLE<ept id=\"p1\">**</ept> Bounds accumulation is on.","source":"**DCB_ENABLE** Bounds accumulation is on."},{"content":"Remarks","pos":[236896,236903]},{"content":"Windows can maintain a bounding rectangle for all drawing operations.","pos":[236907,236976]},{"content":"This rectangle can be queried and reset by the application.","pos":[236977,237036]},{"content":"The drawing bounds are useful for invalidating bitmap caches.","pos":[237037,237098]},{"pos":[237141,237157],"content":"CDC::SetBrushOrg"},{"content":"Specifies the origin that GDI will assign to the next brush that the application selects into the device context.","pos":[237161,237274]},{"content":"Parameters","pos":[237385,237395]},{"content":"x","pos":[237400,237401]},{"content":"Specifies the x-coordinate (in device units) of the new origin.","pos":[237406,237469]},{"content":"This value must be in the range 0–7.","pos":[237470,237506]},{"content":"y","pos":[237514,237515]},{"content":"Specifies the y-coordinate (in device units) of the new origin.","pos":[237520,237583]},{"content":"This value must be in the range 0–7.","pos":[237584,237620]},{"content":"Specifies the x- and y-coordinates of the new origin.","pos":[237638,237691]},{"content":"Each value must be in the range 0–7.","pos":[237692,237728]},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[237729,237811],"source":" You can pass either a **POINT** structure or a `CPoint` object for this parameter."},{"content":"Return Value","pos":[237821,237833]},{"content":"The previous origin of the brush in device units.","pos":[237837,237886]},{"content":"Remarks","pos":[237896,237903]},{"content":"The default coordinates for the brush origin are (0, 0).","pos":[237907,237963]},{"content":"To alter the origin of a brush, call the <ph id=\"ph1\">`UnrealizeObject`</ph> function for the <ph id=\"ph2\">`CBrush`</ph> object, call <ph id=\"ph3\">`SetBrushOrg`</ph>, and then call the <ph id=\"ph4\">`SelectObject`</ph> member function to select the brush into the device context.","pos":[237964,238170],"source":" To alter the origin of a brush, call the `UnrealizeObject` function for the `CBrush` object, call `SetBrushOrg`, and then call the `SelectObject` member function to select the brush into the device context."},{"pos":[238177,238230],"content":"Do not use <ph id=\"ph1\">`SetBrushOrg`</ph> with stock <ph id=\"ph2\">`CBrush`</ph> objects.","source":"Do not use `SetBrushOrg` with stock `CBrush` objects."},{"pos":[238280,238303],"content":"CDC::SetColorAdjustment"},{"content":"Sets the color adjustment values for the device context using the specified values.","pos":[238307,238390]},{"content":"Parameters","pos":[238478,238488]},{"content":"Points to a <bpt id=\"p1\">[</bpt>COLORADJUSTMENT<ept id=\"p1\">](../../mfc/reference/coloradjustment-structure.md)</ept> data structure containing the color adjustment values.","pos":[238511,238645],"source":" Points to a [COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md) data structure containing the color adjustment values."},{"content":"Return Value","pos":[238655,238667]},{"content":"Nonzero if successful; otherwise 0.","pos":[238671,238706]},{"content":"Remarks","pos":[238716,238723]},{"pos":[238727,238892],"content":"The color adjustment values are used to adjust the input color of the source bitmap for calls to the <ph id=\"ph1\">`CDC::StretchBlt`</ph> member function when <bpt id=\"p1\">**</bpt>HALFTONE<ept id=\"p1\">**</ept> mode is set.","source":"The color adjustment values are used to adjust the input color of the source bitmap for calls to the `CDC::StretchBlt` member function when **HALFTONE** mode is set."},{"pos":[238939,238959],"content":"CDC::SetDCBrushColor"},{"content":"Sets the current device context (DC) brush color to the specified color value.","pos":[238963,239041]},{"content":"Parameters","pos":[239110,239120]},{"content":"Specifies the new brush color.","pos":[239137,239167]},{"content":"Return Value","pos":[239177,239189]},{"pos":[239193,239296],"content":"If the function succeeds, the return value specifies the previous DC brush color as a <ph id=\"ph1\">`COLORREF`</ph> value.","source":"If the function succeeds, the return value specifies the previous DC brush color as a `COLORREF` value."},{"pos":[239303,239360],"content":"If the function fails, the return value is <ph id=\"ph1\">`CLR_INVALID`</ph>.","source":"If the function fails, the return value is `CLR_INVALID`."},{"content":"Remarks","pos":[239370,239377]},{"pos":[239381,239587],"content":"This method emulates the functionality of the function <bpt id=\"p1\">[</bpt>SetDCBrushColor<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162969)</ept>, as described in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"This method emulates the functionality of the function [SetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd162969), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[239632,239650],"content":"CDC::SetDCPenColor"},{"content":"Sets the current device context (DC) pen color to the specified color value.","pos":[239654,239730]},{"content":"Parameters","pos":[239797,239807]},{"content":"Specifies the new pen color.","pos":[239824,239852]},{"content":"Return Value","pos":[239862,239874]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[239878,239929]},{"content":"Remarks","pos":[239939,239946]},{"pos":[239950,240148],"content":"This member function utilizes the Win32 function <bpt id=\"p1\">[</bpt>SetDCPenColor<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162970)</ept>, as described in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"This member function utilizes the Win32 function [SetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd162970), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[240195,240215],"content":"CDC::SetGraphicsMode"},{"content":"Sets the graphics mode for the specified device context.","pos":[240219,240275]},{"content":"Parameters","pos":[240332,240342]},{"content":"Specifies the graphics mode.","pos":[240357,240385]},{"content":"For a list of the values that this parameter can take, see <bpt id=\"p1\">[</bpt>SetGraphicsMode<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162977)</ept>.","pos":[240386,240523],"source":" For a list of the values that this parameter can take, see [SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977)."},{"content":"Return Value","pos":[240533,240545]},{"content":"Returns the old graphics mode on success.","pos":[240549,240590]},{"content":"Returns 0 on failure.","pos":[240597,240618]},{"content":"To get extended error information, call <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms679360)</ept>.","pos":[240619,240734],"source":" To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)."},{"content":"Remarks","pos":[240744,240751]},{"pos":[240755,240876],"content":"This method wraps the Windows GDI function <bpt id=\"p1\">[</bpt>SetGraphicsMode<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162977)</ept>.","source":"This method wraps the Windows GDI function [SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977)."},{"pos":[240917,240931],"content":"CDC::SetLayout"},{"content":"Call this member function to change the layout of the text and graphics for a device context to right to left, the standard layout for cultures such as Arabic and Hebrew.","pos":[240935,241105]},{"content":"Parameters","pos":[241163,241173]},{"content":"Device context layout and bitmap control flags.","pos":[241191,241238]},{"content":"It can be a combination of the following values.","pos":[241239,241287]},{"content":"Value","pos":[241294,241299]},{"content":"Meaning","pos":[241300,241307]},{"content":"LAYOUT_BITMAPORIENTATIONPRESERVED","pos":[241342,241375]},{"pos":[241376,241481],"content":"Disables any reflection for calls to <bpt id=\"p1\">[</bpt>CDC::BitBlt<ept id=\"p1\">](#cdc__bitblt)</ept> and <bpt id=\"p2\">[</bpt>CDC::StretchBlt<ept id=\"p2\">](#cdc__stretchblt)</ept>.","source":"Disables any reflection for calls to [CDC::BitBlt](#cdc__bitblt) and [CDC::StretchBlt](#cdc__stretchblt)."},{"content":"LAYOUT_RTL","pos":[241486,241496]},{"content":"Sets the default horizontal layout to be right to left.","pos":[241497,241552]},{"content":"LAYOUT_LTR","pos":[241557,241567]},{"content":"Sets the default layout to be left to right.","pos":[241568,241612]},{"content":"Return Value","pos":[241623,241635]},{"content":"If successful, the previous layout of the device context.","pos":[241639,241696]},{"content":"If unsuccessful, <bpt id=\"p1\">**</bpt>GDI_ERROR<ept id=\"p1\">**</ept>.","pos":[241703,241734],"source":"If unsuccessful, **GDI_ERROR**."},{"content":"To get extended error information, call <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms679360)</ept>.","pos":[241735,241850],"source":" To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)."},{"content":"Remarks","pos":[241860,241867]},{"content":"Normally, you would not call <bpt id=\"p1\">**</bpt>SetLayout<ept id=\"p1\">**</ept> for a window.","pos":[241871,241927],"source":"Normally, you would not call **SetLayout** for a window."},{"content":"Rather, you control the right-to-left layout in a window by setting the <bpt id=\"p1\">[</bpt>extended window styles<ept id=\"p1\">](../../mfc/reference/extended-window-styles.md)</ept> such as <bpt id=\"p2\">**</bpt>WS_EX_RTLREADING<ept id=\"p2\">**</ept>.","pos":[241928,242101],"source":" Rather, you control the right-to-left layout in a window by setting the [extended window styles](../../mfc/reference/extended-window-styles.md) such as **WS_EX_RTLREADING**."},{"content":"A device context, such as a printer or a metafile, does not inherit this layout.","pos":[242102,242182]},{"content":"The only way to set the device context for a right-to-left layout is by calling <bpt id=\"p1\">**</bpt>SetLayout<ept id=\"p1\">**</ept>.","pos":[242183,242277],"source":" The only way to set the device context for a right-to-left layout is by calling **SetLayout**."},{"content":"If you call <bpt id=\"p1\">**</bpt>SetLayout(LAYOUT_RTL<ept id=\"p1\">**</ept> ), <bpt id=\"p2\">**</bpt>SetLayout<ept id=\"p2\">**</ept> automatically changes the mapping mode to <ph id=\"ph1\">`MM_ISOTROPIC`</ph>.","pos":[242284,242395],"source":"If you call **SetLayout(LAYOUT_RTL** ), **SetLayout** automatically changes the mapping mode to `MM_ISOTROPIC`."},{"content":"As a result, a subsequent call to <bpt id=\"p1\">[</bpt>GetMapMode<ept id=\"p1\">](#cdc__getmapmode)</ept> will return <bpt id=\"p2\">**</bpt>MM_ISOTROPIC<ept id=\"p2\">**</ept> instead of <ph id=\"ph1\">`MM_TEXT`</ph>.","pos":[242396,242511],"source":" As a result, a subsequent call to [GetMapMode](#cdc__getmapmode) will return **MM_ISOTROPIC** instead of `MM_TEXT`."},{"content":"In some cases, such as with many bitmaps, you may want to preserve the left-to-right layout.","pos":[242518,242610]},{"content":"In these cases, render the image by calling <ph id=\"ph1\">`BitBlt`</ph> or <ph id=\"ph2\">`StretchBlt`</ph>, then set the bitmap control flag for <ph id=\"ph3\">`dwLayout`</ph> to <bpt id=\"p1\">**</bpt>LAYOUT_BITMAPORIENTATIONPRESERVED<ept id=\"p1\">**</ept>.","pos":[242611,242770],"source":" In these cases, render the image by calling `BitBlt` or `StretchBlt`, then set the bitmap control flag for `dwLayout` to **LAYOUT_BITMAPORIENTATIONPRESERVED**."},{"content":"Once you change the layout with the <bpt id=\"p1\">**</bpt>LAYOUT_RTL<ept id=\"p1\">**</ept> flag, the flags normally specifying right or left are reversed.","pos":[242777,242891],"source":"Once you change the layout with the **LAYOUT_RTL** flag, the flags normally specifying right or left are reversed."},{"content":"To avoid confusion, you may want to define alternate names for the standard flags.","pos":[242892,242974]},{"content":"For a list of suggested alternate flag names, see <bpt id=\"p1\">[</bpt>SetLayout<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd162979)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[242975,243156],"source":" For a list of suggested alternate flag names, see [SetLayout](http://msdn.microsoft.com/library/windows/desktop/dd162979) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[243198,243213],"content":"CDC::SetMapMode"},{"content":"Sets the mapping mode.","pos":[243217,243239]},{"content":"Parameters","pos":[243302,243312]},{"content":"Specifies the new mapping mode.","pos":[243330,243361]},{"content":"It can be any one of the following values:","pos":[243362,243404]},{"content":"Logical units are converted to arbitrary units with arbitrarily scaled axes.","pos":[243429,243505]},{"content":"Setting the mapping mode to <ph id=\"ph1\">`MM_ANISOTROPIC`</ph> does not change the current window or viewport settings.","pos":[243506,243607],"source":" Setting the mapping mode to `MM_ANISOTROPIC` does not change the current window or viewport settings."},{"content":"To change the units, orientation, and scaling, call the <bpt id=\"p1\">[</bpt>SetWindowExt<ept id=\"p1\">](#cdc__setwindowext)</ept> and <bpt id=\"p2\">[</bpt>SetViewportExt<ept id=\"p2\">](#cdc__setviewportext)</ept> member functions.","pos":[243608,243759],"source":" To change the units, orientation, and scaling, call the [SetWindowExt](#cdc__setwindowext) and [SetViewportExt](#cdc__setviewportext) member functions."},{"content":"Each logical unit is converted to 0.001 inch.","pos":[243782,243827]},{"content":"Positive x is to the right; positive y is up.","pos":[243828,243873]},{"content":"Each logical unit is converted to 0.01 millimeter.","pos":[243895,243945]},{"content":"Positive x is to the right; positive y is up.","pos":[243946,243991]},{"content":"Logical units are converted to arbitrary units with equally scaled axes; that is, 1 unit along the x-axis is equal to 1 unit along the y-axis.","pos":[244014,244156]},{"content":"Use the <ph id=\"ph1\">`SetWindowExt`</ph> and <ph id=\"ph2\">`SetViewportExt`</ph> member functions to specify the desired units and the orientation of the axes.","pos":[244157,244279],"source":" Use the `SetWindowExt` and `SetViewportExt` member functions to specify the desired units and the orientation of the axes."},{"content":"GDI makes adjustments as necessary to ensure that the x and y units remain the same size.","pos":[244280,244369]},{"content":"Each logical unit is converted to 0.01 inch.","pos":[244392,244436]},{"content":"Positive x is to the right; positive y is up.","pos":[244437,244482]},{"content":"Each logical unit is converted to 0.1 millimeter.","pos":[244504,244553]},{"content":"Positive x is to the right; positive y is up.","pos":[244554,244599]},{"content":"Each logical unit is converted to 1 device pixel.","pos":[244617,244666]},{"content":"Positive x is to the right; positive y is down.","pos":[244667,244714]},{"content":"Each logical unit is converted to 1/20 of a point.","pos":[244733,244783]},{"content":"(Because a point is 1/72 inch, a twip is 1/1440 inch.) Positive x is to the right; positive y is up.","pos":[244784,244884]},{"content":"Return Value","pos":[244894,244906]},{"content":"The previous mapping mode.","pos":[244910,244936]},{"content":"Remarks","pos":[244946,244953]},{"content":"The mapping mode defines the unit of measure used to convert logical units to device units; it also defines the orientation of the device's x- and y-axes.","pos":[244957,245111]},{"content":"GDI uses the mapping mode to convert logical coordinates into the appropriate device coordinates.","pos":[245112,245209]},{"content":"The <ph id=\"ph1\">`MM_TEXT`</ph> mode allows applications to work in device pixels, where 1 unit is equal to 1 pixel.","pos":[245210,245308],"source":" The `MM_TEXT` mode allows applications to work in device pixels, where 1 unit is equal to 1 pixel."},{"content":"The physical size of a pixel varies from device to device.","pos":[245309,245367]},{"content":"The <ph id=\"ph1\">`MM_HIENGLISH`</ph>, <ph id=\"ph2\">`MM_HIMETRIC`</ph>, <ph id=\"ph3\">`MM_LOENGLISH`</ph>, <ph id=\"ph4\">`MM_LOMETRIC`</ph>, and <ph id=\"ph5\">`MM_TWIPS`</ph> modes are useful for applications that must draw in physically meaningful units (such as inches or millimeters).","pos":[245374,245567],"source":"The `MM_HIENGLISH`, `MM_HIMETRIC`, `MM_LOENGLISH`, `MM_LOMETRIC`, and `MM_TWIPS` modes are useful for applications that must draw in physically meaningful units (such as inches or millimeters)."},{"content":"The <ph id=\"ph1\">`MM_ISOTROPIC`</ph> mode ensures a 1:1 aspect ratio, which is useful when it is important to preserve the exact shape of an image.","pos":[245568,245697],"source":" The `MM_ISOTROPIC` mode ensures a 1:1 aspect ratio, which is useful when it is important to preserve the exact shape of an image."},{"content":"The <ph id=\"ph1\">`MM_ANISOTROPIC`</ph> mode allows the x- and y-coordinates to be adjusted independently.","pos":[245698,245785],"source":" The `MM_ANISOTROPIC` mode allows the x- and y-coordinates to be adjusted independently."},{"pos":[245793,245975],"content":"[!NOTE]\n If you call [SetLayout](#cdc__setlayout) to change the DC (device context) to right-to-left layout, **SetLayout** automatically changes the mapping mode to `MM_ISOTROPIC`.","leadings":["","> "],"nodes":[{"content":"If you call <bpt id=\"p1\">[</bpt>SetLayout<ept id=\"p1\">](#cdc__setlayout)</ept> to change the DC (device context) to right-to-left layout, <bpt id=\"p2\">**</bpt>SetLayout<ept id=\"p2\">**</ept> automatically changes the mapping mode to <ph id=\"ph1\">`MM_ISOTROPIC`</ph>.","pos":[9,180],"source":" If you call [SetLayout](#cdc__setlayout) to change the DC (device context) to right-to-left layout, **SetLayout** automatically changes the mapping mode to `MM_ISOTROPIC`."}]},{"content":"Example","pos":[245985,245992]},{"pos":[245997,246093],"content":"See the example for <bpt id=\"p1\">[</bpt>CView::OnPrepareDC<ept id=\"p1\">](../../mfc/reference/cview-class.md#cview__onpreparedc)</ept>.","source":"See the example for [CView::OnPrepareDC](../../mfc/reference/cview-class.md#cview__onpreparedc)."},{"pos":[246139,246158],"content":"CDC::SetMapperFlags"},{"content":"Changes the method used by the font mapper when it converts a logical font to a physical font.","pos":[246162,246256]},{"content":"Parameters","pos":[246317,246327]},{"content":"Specifies whether the font mapper attempts to match a font's aspect height and width to the device.","pos":[246343,246442]},{"content":"When this value is <bpt id=\"p1\">**</bpt>ASPECT_FILTERING<ept id=\"p1\">**</ept>, the mapper selects only fonts whose x-aspect and y-aspect exactly match those of the specified device.","pos":[246443,246586],"source":" When this value is **ASPECT_FILTERING**, the mapper selects only fonts whose x-aspect and y-aspect exactly match those of the specified device."},{"content":"Return Value","pos":[246596,246608]},{"content":"The previous value of the font-mapper flag.","pos":[246612,246655]},{"content":"Remarks","pos":[246665,246672]},{"pos":[246676,246845],"content":"An application can use <ph id=\"ph1\">`SetMapperFlags`</ph> to cause the font mapper to attempt to choose only a physical font that exactly matches the aspect ratio of the specified device.","source":"An application can use `SetMapperFlags` to cause the font mapper to attempt to choose only a physical font that exactly matches the aspect ratio of the specified device."},{"content":"An application that uses only raster fonts can use the <ph id=\"ph1\">`SetMapperFlags`</ph> function to ensure that the font selected by the font mapper is attractive and readable on the specified device.","pos":[246852,247036],"source":"An application that uses only raster fonts can use the `SetMapperFlags` function to ensure that the font selected by the font mapper is attractive and readable on the specified device."},{"content":"Applications that use scalable (TrueType) fonts typically do not use <ph id=\"ph1\">`SetMapperFlags`</ph>.","pos":[247037,247123],"source":" Applications that use scalable (TrueType) fonts typically do not use `SetMapperFlags`."},{"content":"If no physical font has an aspect ratio that matches the specification in the logical font, GDI chooses a new aspect ratio and selects a font that matches this new aspect ratio.","pos":[247130,247307]},{"pos":[247352,247370],"content":"CDC::SetMiterLimit"},{"content":"Sets the limit for the length of miter joins for the device context.","pos":[247374,247442]},{"content":"Parameters","pos":[247506,247516]},{"content":"fMiterLimit","pos":[247521,247532]},{"content":"Specifies the new miter limit for the device context.","pos":[247537,247590]},{"content":"Return Value","pos":[247600,247612]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[247616,247667]},{"content":"Remarks","pos":[247677,247684]},{"content":"The miter length is defined as the distance from the intersection of the line walls on the inside of the join to the intersection of the line walls on the outside of the join.","pos":[247688,247863]},{"content":"The miter limit is the maximum allowed ratio of the miter length to the line width.","pos":[247864,247947]},{"content":"The default miter limit is 10.0.","pos":[247948,247980]},{"pos":[248023,248039],"content":"CDC::SetOutputDC"},{"pos":[248043,248111],"content":"Call this member function to set the output device context, <ph id=\"ph1\">`m_hDC`</ph>.","source":"Call this member function to set the output device context, `m_hDC`."},{"content":"Parameters","pos":[248171,248181]},{"content":"A Windows device context.","pos":[248194,248219]},{"content":"Remarks","pos":[248229,248236]},{"content":"This member function can only be called when a device context has not been attached to the <ph id=\"ph1\">`CDC`</ph> object.","pos":[248240,248344],"source":"This member function can only be called when a device context has not been attached to the `CDC` object."},{"content":"This member function sets <ph id=\"ph1\">`m_hDC`</ph> but does not attach the device context to the <ph id=\"ph2\">`CDC`</ph> object.","pos":[248345,248438],"source":" This member function sets `m_hDC` but does not attach the device context to the `CDC` object."},{"pos":[248478,248491],"content":"CDC::SetPixel"},{"pos":[248495,248598],"content":"Sets the pixel at the point specified to the closest approximation of the color specified by <ph id=\"ph1\">`crColor`</ph>.","source":"Sets the pixel at the point specified to the closest approximation of the color specified by `crColor`."},{"content":"Parameters","pos":[248755,248765]},{"content":"x","pos":[248770,248771]},{"content":"Specifies the logical x-coordinate of the point to be set.","pos":[248776,248834]},{"content":"y","pos":[248842,248843]},{"content":"Specifies the logical y-coordinate of the point to be set.","pos":[248848,248906]},{"content":"A <bpt id=\"p1\">**</bpt>COLORREF<ept id=\"p1\">**</ept> RGB value that specifies the color used to paint the point.","pos":[248926,249000],"source":" A **COLORREF** RGB value that specifies the color used to paint the point."},{"content":"See <bpt id=\"p1\">[</bpt>COLORREF<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd183449)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph> for a description of this value.","pos":[249001,249167],"source":" See [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a description of this value."},{"content":"Specifies the logical x- and y-coordinates of the point to be set.","pos":[249185,249251]},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[249252,249334],"source":" You can pass either a **POINT** structure or a `CPoint` object for this parameter."},{"content":"Return Value","pos":[249344,249356]},{"content":"An RGB value for the color that the point is actually painted.","pos":[249360,249422]},{"content":"This value can be different from that specified by <ph id=\"ph1\">`crColor`</ph> if an approximation of that color is used.","pos":[249423,249526],"source":" This value can be different from that specified by `crColor` if an approximation of that color is used."},{"content":"If the function fails (if the point is outside the clipping region), the return value is –1.","pos":[249527,249619]},{"content":"Remarks","pos":[249629,249636]},{"content":"The point must be in the clipping region.","pos":[249640,249681]},{"content":"If the point is not in the clipping region, the function does nothing.","pos":[249682,249752]},{"content":"Not all devices support the <ph id=\"ph1\">`SetPixel`</ph> function.","pos":[249759,249807],"source":"Not all devices support the `SetPixel` function."},{"content":"To determine whether a device supports <ph id=\"ph1\">`SetPixel`</ph>, call the <ph id=\"ph2\">`GetDeviceCaps`</ph> member function with the <bpt id=\"p1\">**</bpt>RASTERCAPS<ept id=\"p1\">**</ept> index and check the return value for the <bpt id=\"p2\">**</bpt>RC_BITBLT<ept id=\"p2\">**</ept> flag.","pos":[249808,249984],"source":" To determine whether a device supports `SetPixel`, call the `GetDeviceCaps` member function with the **RASTERCAPS** index and check the return value for the **RC_BITBLT** flag."},{"pos":[250025,250039],"content":"CDC::SetPixelV"},{"content":"Sets the pixel at the specified coordinates to the closest approximation of the specified color.","pos":[250043,250139]},{"content":"Parameters","pos":[250290,250300]},{"content":"x","pos":[250305,250306]},{"content":"Specifies the x-coordinate, in logical units, of the point to be set.","pos":[250311,250380]},{"content":"y","pos":[250388,250389]},{"content":"Specifies the y-coordinate, in logical units, of the point to be set.","pos":[250394,250463]},{"content":"Specifies the color to be used to paint the point.","pos":[250483,250533]},{"content":"Specifies the logical x- and y-coordinates of the point to be set.","pos":[250551,250617]},{"content":"You can pass either a <bpt id=\"p1\">[</bpt>POINT<ept id=\"p1\">](../../mfc/reference/point-structure1.md)</ept> data structure or a <bpt id=\"p2\">[</bpt>CPoint<ept id=\"p2\">](../../atl-mfc-shared/reference/cpoint-class.md)</ept> object for this parameter.","pos":[250618,250792],"source":" You can pass either a [POINT](../../mfc/reference/point-structure1.md) data structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter."},{"content":"Return Value","pos":[250802,250814]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[250818,250869]},{"content":"Remarks","pos":[250879,250886]},{"content":"The point must be in both the clipping region and the visible part of the device surface.","pos":[250890,250979]},{"content":"Not all devices support the member function.","pos":[250980,251024]},{"content":"For more information, see the <bpt id=\"p1\">**</bpt>RC_BITBLT<ept id=\"p1\">**</ept> capability in the <ph id=\"ph1\">`CDC::GetDeviceCaps`</ph> member function.","pos":[251025,251124],"source":" For more information, see the **RC_BITBLT** capability in the `CDC::GetDeviceCaps` member function."},{"content":"is faster than <ph id=\"ph1\">`SetPixel`</ph> because it does not need to return the color value of the point actually painted.","pos":[251137,251244],"source":" is faster than `SetPixel` because it does not need to return the color value of the point actually painted."},{"pos":[251291,251311],"content":"CDC::SetPolyFillMode"},{"content":"Sets the polygon-filling mode.","pos":[251315,251345]},{"content":"Parameters","pos":[251410,251420]},{"content":"Specifies the new filling mode.","pos":[251443,251474]},{"content":"This value may be either <bpt id=\"p1\">**</bpt>ALTERNATE<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>WINDING<ept id=\"p2\">**</ept>.","pos":[251475,251529],"source":" This value may be either **ALTERNATE** or **WINDING**."},{"content":"The default mode set in Windows is <bpt id=\"p1\">**</bpt>ALTERNATE<ept id=\"p1\">**</ept>.","pos":[251530,251579],"source":" The default mode set in Windows is **ALTERNATE**."},{"content":"Return Value","pos":[251589,251601]},{"content":"The previous filling mode, if successful; otherwise 0.","pos":[251605,251659]},{"content":"Remarks","pos":[251669,251676]},{"content":"When the polygon-filling mode is <bpt id=\"p1\">**</bpt>ALTERNATE<ept id=\"p1\">**</ept>, the system fills the area between odd-numbered and even-numbered polygon sides on each scan line.","pos":[251680,251825],"source":"When the polygon-filling mode is **ALTERNATE**, the system fills the area between odd-numbered and even-numbered polygon sides on each scan line."},{"content":"That is, the system fills the area between the first and second side, between the third and fourth side, and so on.","pos":[251826,251941]},{"content":"This mode is the default.","pos":[251942,251967]},{"content":"When the polygon-filling mode is <bpt id=\"p1\">**</bpt>WINDING<ept id=\"p1\">**</ept>, the system uses the direction in which a figure was drawn to determine whether to fill an area.","pos":[251974,252115],"source":"When the polygon-filling mode is **WINDING**, the system uses the direction in which a figure was drawn to determine whether to fill an area."},{"content":"Each line segment in a polygon is drawn in either a clockwise or a counterclockwise direction.","pos":[252116,252210]},{"content":"Whenever an imaginary line drawn from an enclosed area to the outside of a figure passes through a clockwise line segment, a count is incremented.","pos":[252211,252357]},{"content":"When the line passes through a counterclockwise line segment, the count is decremented.","pos":[252358,252445]},{"content":"The area is filled if the count is nonzero when the line reaches the outside of the figure.","pos":[252446,252537]},{"pos":[252576,252588],"content":"CDC::SetROP2"},{"content":"Sets the current drawing mode.","pos":[252592,252622]},{"content":"Parameters","pos":[252675,252685]},{"content":"Specifies the new drawing mode.","pos":[252704,252735]},{"content":"It can be any of the following values:","pos":[252736,252774]},{"pos":[252782,252817],"content":"<bpt id=\"p1\">**</bpt>R2_BLACK<ept id=\"p1\">**</ept> Pixel is always black.","source":"**R2_BLACK** Pixel is always black."},{"pos":[252825,252860],"content":"<bpt id=\"p1\">**</bpt>R2_WHITE<ept id=\"p1\">**</ept> Pixel is always white.","source":"**R2_WHITE** Pixel is always white."},{"pos":[252868,252903],"content":"<bpt id=\"p1\">**</bpt>R2_NOP<ept id=\"p1\">**</ept> Pixel remains unchanged.","source":"**R2_NOP** Pixel remains unchanged."},{"pos":[252911,252963],"content":"<bpt id=\"p1\">**</bpt>R2_NOT<ept id=\"p1\">**</ept> Pixel is the inverse of the screen color.","source":"**R2_NOT** Pixel is the inverse of the screen color."},{"pos":[252971,253009],"content":"<bpt id=\"p1\">**</bpt>R2_COPYPEN<ept id=\"p1\">**</ept> Pixel is the pen color.","source":"**R2_COPYPEN** Pixel is the pen color."},{"pos":[253017,253073],"content":"<bpt id=\"p1\">**</bpt>R2_NOTCOPYPEN<ept id=\"p1\">**</ept> Pixel is the inverse of the pen color.","source":"**R2_NOTCOPYPEN** Pixel is the inverse of the pen color."},{"pos":[253081,253218],"content":"<bpt id=\"p1\">**</bpt>R2_MERGEPENNOT<ept id=\"p1\">**</ept> Pixel is a combination of the pen color and the inverse of the screen color (final pixel = (NOT screen pixel) OR pen).","source":"**R2_MERGEPENNOT** Pixel is a combination of the pen color and the inverse of the screen color (final pixel = (NOT screen pixel) OR pen)."},{"pos":[253226,253377],"content":"<bpt id=\"p1\">**</bpt>R2_MASKPENNOT<ept id=\"p1\">**</ept> Pixel is a combination of the colors common to both the pen and the inverse of the screen (final pixel = (NOT screen pixel) AND pen).","source":"**R2_MASKPENNOT** Pixel is a combination of the colors common to both the pen and the inverse of the screen (final pixel = (NOT screen pixel) AND pen)."},{"pos":[253385,253522],"content":"<bpt id=\"p1\">**</bpt>R2_MERGENOTPEN<ept id=\"p1\">**</ept> Pixel is a combination of the screen color and the inverse of the pen color (final pixel = (NOT pen) OR screen pixel).","source":"**R2_MERGENOTPEN** Pixel is a combination of the screen color and the inverse of the pen color (final pixel = (NOT pen) OR screen pixel)."},{"pos":[253530,253681],"content":"<bpt id=\"p1\">**</bpt>R2_MASKNOTPEN<ept id=\"p1\">**</ept> Pixel is a combination of the colors common to both the screen and the inverse of the pen (final pixel = (NOT pen) AND screen pixel).","source":"**R2_MASKNOTPEN** Pixel is a combination of the colors common to both the screen and the inverse of the pen (final pixel = (NOT pen) AND screen pixel)."},{"pos":[253689,253802],"content":"<bpt id=\"p1\">**</bpt>R2_MERGEPEN<ept id=\"p1\">**</ept> Pixel is a combination of the pen color and the screen color (final pixel = pen OR screen pixel).","source":"**R2_MERGEPEN** Pixel is a combination of the pen color and the screen color (final pixel = pen OR screen pixel)."},{"pos":[253810,253920],"content":"<bpt id=\"p1\">**</bpt>R2_NOTMERGEPEN<ept id=\"p1\">**</ept> Pixel is the inverse of the <bpt id=\"p2\">**</bpt>R2_MERGEPEN<ept id=\"p2\">**</ept> color (final pixel = NOT(pen OR screen pixel)).","source":"**R2_NOTMERGEPEN** Pixel is the inverse of the **R2_MERGEPEN** color (final pixel = NOT(pen OR screen pixel))."},{"pos":[253928,254055],"content":"<bpt id=\"p1\">**</bpt>R2_MASKPEN<ept id=\"p1\">**</ept> Pixel is a combination of the colors common to both the pen and the screen (final pixel = pen AND screen pixel).","source":"**R2_MASKPEN** Pixel is a combination of the colors common to both the pen and the screen (final pixel = pen AND screen pixel)."},{"pos":[254063,254172],"content":"<bpt id=\"p1\">**</bpt>R2_NOTMASKPEN<ept id=\"p1\">**</ept> Pixel is the inverse of the <bpt id=\"p2\">**</bpt>R2_MASKPEN<ept id=\"p2\">**</ept> color (final pixel = NOT(pen AND screen pixel)).","source":"**R2_NOTMASKPEN** Pixel is the inverse of the **R2_MASKPEN** color (final pixel = NOT(pen AND screen pixel))."},{"pos":[254180,254322],"content":"<bpt id=\"p1\">**</bpt>R2_XORPEN<ept id=\"p1\">**</ept> Pixel is a combination of the colors that are in the pen or in the screen, but not in both (final pixel = pen XOR screen pixel).","source":"**R2_XORPEN** Pixel is a combination of the colors that are in the pen or in the screen, but not in both (final pixel = pen XOR screen pixel)."},{"pos":[254330,254437],"content":"<bpt id=\"p1\">**</bpt>R2_NOTXORPEN<ept id=\"p1\">**</ept> Pixel is the inverse of the <bpt id=\"p2\">**</bpt>R2_XORPEN<ept id=\"p2\">**</ept> color (final pixel = NOT(pen XOR screen pixel)).","source":"**R2_NOTXORPEN** Pixel is the inverse of the **R2_XORPEN** color (final pixel = NOT(pen XOR screen pixel))."},{"content":"Return Value","pos":[254447,254459]},{"content":"The previous drawing mode.","pos":[254463,254489]},{"pos":[254496,254589],"content":"It can be any of the values given in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"It can be any of the values given in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"Remarks","pos":[254599,254606]},{"content":"The drawing mode specifies how the colors of the pen and the interior of filled objects are combined with the color already on the display surface.","pos":[254610,254757]},{"content":"The drawing mode is for raster devices only; it does not apply to vector devices.","pos":[254764,254845]},{"content":"Drawing modes are binary raster-operation codes representing all possible Boolean combinations of two variables, using the binary operators AND, OR, and XOR (exclusive OR), and the unary operation NOT.","pos":[254846,255047]},{"pos":[255096,255118],"content":"CDC::SetStretchBltMode"},{"pos":[255122,255191],"content":"Sets the bitmap-stretching mode for the <ph id=\"ph1\">`StretchBlt`</ph> member function.","source":"Sets the bitmap-stretching mode for the `StretchBlt` member function."},{"content":"Parameters","pos":[255257,255267]},{"content":"nStretchMode","pos":[255272,255284]},{"content":"Specifies the stretching mode.","pos":[255289,255319]},{"content":"It can be any of the following values:","pos":[255320,255358]},{"content":"Value","pos":[255365,255370]},{"content":"Description","pos":[255371,255382]},{"content":"BLACKONWHITE","pos":[255423,255435]},{"content":"Performs a Boolean AND operation using the color values for the eliminated and existing pixels.","pos":[255438,255533]},{"content":"If the bitmap is a monochrome bitmap, this mode preserves black pixels at the expense of white pixels.","pos":[255534,255636]},{"content":"COLORONCOLOR","pos":[255643,255655]},{"content":"Deletes the pixels.","pos":[255658,255677]},{"content":"This mode deletes all eliminated lines of pixels without trying to preserve their information.","pos":[255678,255772]},{"content":"HALFTONE","pos":[255779,255787]},{"content":"Maps pixels from the source rectangle into blocks of pixels in the destination rectangle.","pos":[255790,255879]},{"content":"The average color over the destination block of pixels approximates the color of the source pixels.","pos":[255880,255979]},{"content":"After setting the <bpt id=\"p1\">**</bpt>HALFTONE<ept id=\"p1\">**</ept> stretching mode, an application must call the Win32 function <bpt id=\"p2\">[</bpt>SetBrushOrgEx<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/dd162967)</ept> to set the brush origin.","pos":[255985,256177],"source":"After setting the **HALFTONE** stretching mode, an application must call the Win32 function [SetBrushOrgEx](http://msdn.microsoft.com/library/windows/desktop/dd162967) to set the brush origin."},{"content":"If it fails to do so, brush misalignment occurs.","pos":[256178,256226]},{"content":"STRETCH_ANDSCANS","pos":[256233,256249]},{"pos":[256252,256295],"content":"<bpt id=\"p1\">**</bpt>Windows 95/98<ept id=\"p1\">**</ept>: Same as <bpt id=\"p2\">**</bpt>BLACKONWHITE<ept id=\"p2\">**</ept>","source":"**Windows 95/98**: Same as **BLACKONWHITE**"},{"content":"STRETCH_DELETESCANS","pos":[256302,256321]},{"pos":[256324,256367],"content":"<bpt id=\"p1\">**</bpt>Windows 95/98<ept id=\"p1\">**</ept>: Same as <bpt id=\"p2\">**</bpt>COLORONCOLOR<ept id=\"p2\">**</ept>","source":"**Windows 95/98**: Same as **COLORONCOLOR**"},{"content":"STRETCH_HALFTONE","pos":[256374,256390]},{"pos":[256393,256433],"content":"<bpt id=\"p1\">**</bpt>Windows 95/98<ept id=\"p1\">**</ept>: Same as <bpt id=\"p2\">**</bpt>HALFTONE<ept id=\"p2\">**</ept>.","source":"**Windows 95/98**: Same as **HALFTONE**."},{"content":"STRETCH_ORSCANS","pos":[256440,256455]},{"pos":[256458,256501],"content":"<bpt id=\"p1\">**</bpt>Windows 95/98<ept id=\"p1\">**</ept>: Same as <bpt id=\"p2\">**</bpt>WHITEONBLACK<ept id=\"p2\">**</ept>","source":"**Windows 95/98**: Same as **WHITEONBLACK**"},{"content":"WHITEONBLACK","pos":[256508,256520]},{"content":"Performs a Boolean OR operation using the color values for the eliminated and existing pixels.","pos":[256523,256617]},{"content":"If the bitmap is a monochrome bitmap, this mode preserves white pixels at the expense of black pixels.","pos":[256618,256720]},{"content":"Return Value","pos":[256731,256743]},{"content":"The previous stretching mode.","pos":[256747,256776]},{"content":"It can be <bpt id=\"p1\">**</bpt>STRETCH_ANDSCANS<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>STRETCH_DELETESCANS<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>STRETCH_ORSCANS<ept id=\"p3\">**</ept>.","pos":[256777,256857],"source":" It can be **STRETCH_ANDSCANS**, **STRETCH_DELETESCANS**, or **STRETCH_ORSCANS**."},{"content":"Remarks","pos":[256867,256874]},{"content":"The bitmap-stretching mode defines how information is removed from bitmaps that are compressed by using the function.","pos":[256878,256995]},{"content":"The <bpt id=\"p1\">**</bpt>BLACKONWHITE<ept id=\"p1\">**</ept> ( <bpt id=\"p2\">**</bpt>STRETCH_ANDSCANS<ept id=\"p2\">**</ept>) and <bpt id=\"p3\">**</bpt>WHITEONBLACK<ept id=\"p3\">**</ept> ( <bpt id=\"p4\">**</bpt>STRETCH_ORSCANS<ept id=\"p4\">**</ept>) modes are typically used to preserve foreground pixels in monochrome bitmaps.","pos":[257002,257168],"source":"The **BLACKONWHITE** ( **STRETCH_ANDSCANS**) and **WHITEONBLACK** ( **STRETCH_ORSCANS**) modes are typically used to preserve foreground pixels in monochrome bitmaps."},{"content":"The <bpt id=\"p1\">**</bpt>COLORONCOLOR<ept id=\"p1\">**</ept> ( <bpt id=\"p2\">**</bpt>STRETCH_DELETESCANS<ept id=\"p2\">**</ept>) mode is typically used to preserve color in color bitmaps.","pos":[257169,257275],"source":" The **COLORONCOLOR** ( **STRETCH_DELETESCANS**) mode is typically used to preserve color in color bitmaps."},{"content":"The <bpt id=\"p1\">**</bpt>HALFTONE<ept id=\"p1\">**</ept> mode requires more processing of the source image than the other three modes; it is slower than the others, but produces higher quality images.","pos":[257282,257442],"source":"The **HALFTONE** mode requires more processing of the source image than the other three modes; it is slower than the others, but produces higher quality images."},{"content":"Also note that <bpt id=\"p1\">**</bpt>SetBrushOrgEx<ept id=\"p1\">**</ept> must be called after setting the <bpt id=\"p2\">**</bpt>HALFTONE<ept id=\"p2\">**</ept> mode to avoid brush misalignment.","pos":[257443,257555],"source":" Also note that **SetBrushOrgEx** must be called after setting the **HALFTONE** mode to avoid brush misalignment."},{"content":"Additional stretching modes might also be available depending on the capabilities of the device driver.","pos":[257562,257665]},{"pos":[257709,257726],"content":"CDC::SetTextAlign"},{"content":"Sets the text-alignment flags.","pos":[257730,257760]},{"content":"Parameters","pos":[257817,257827]},{"content":"Specifies text-alignment flags.","pos":[257843,257874]},{"content":"The flags specify the relationship between a point and a rectangle that bounds the text.","pos":[257875,257963]},{"content":"The point can be either the current position or coordinates specified by a text-output function.","pos":[257964,258060]},{"content":"The rectangle that bounds the text is defined by the adjacent character cells in the text string.","pos":[258061,258158]},{"content":"The <ph id=\"ph1\">`nFlags`</ph> parameter can be one or more flags from the following three categories.","pos":[258159,258243],"source":" The `nFlags` parameter can be one or more flags from the following three categories."},{"content":"Choose only one flag from each category.","pos":[258244,258284]},{"content":"The first category affects text alignment in the x-direction:","pos":[258285,258346]},{"pos":[258354,258438],"content":"<bpt id=\"p1\">**</bpt>TA_CENTER<ept id=\"p1\">**</ept> Aligns the point with the horizontal center of the bounding rectangle.","source":"**TA_CENTER** Aligns the point with the horizontal center of the bounding rectangle."},{"content":"<bpt id=\"p1\">**</bpt>TA_LEFT<ept id=\"p1\">**</ept> Aligns the point with the left side of the bounding rectangle.","pos":[258446,258520],"source":"**TA_LEFT** Aligns the point with the left side of the bounding rectangle."},{"content":"This is the default setting.","pos":[258521,258549]},{"pos":[258557,258633],"content":"<bpt id=\"p1\">**</bpt>TA_RIGHT<ept id=\"p1\">**</ept> Aligns the point with the right side of the bounding rectangle.","source":"**TA_RIGHT** Aligns the point with the right side of the bounding rectangle."},{"content":"The second category affects text alignment in the y-direction:","pos":[258640,258702]},{"pos":[258710,258781],"content":"<bpt id=\"p1\">**</bpt>TA_BASELINE<ept id=\"p1\">**</ept> Aligns the point with the base line of the chosen font.","source":"**TA_BASELINE** Aligns the point with the base line of the chosen font."},{"pos":[258789,258862],"content":"<bpt id=\"p1\">**</bpt>TA_BOTTOM<ept id=\"p1\">**</ept> Aligns the point with the bottom of the bounding rectangle.","source":"**TA_BOTTOM** Aligns the point with the bottom of the bounding rectangle."},{"content":"<bpt id=\"p1\">**</bpt>TA_TOP<ept id=\"p1\">**</ept> Aligns the point with the top of the bounding rectangle.","pos":[258870,258937],"source":"**TA_TOP** Aligns the point with the top of the bounding rectangle."},{"content":"This is the default setting.","pos":[258938,258966]},{"content":"The third category determines whether the current position is updated when text is written:","pos":[258973,259064]},{"content":"<bpt id=\"p1\">**</bpt>TA_NOUPDATECP<ept id=\"p1\">**</ept> Does not update the current position after each call to a text-output function.","pos":[259072,259169],"source":"**TA_NOUPDATECP** Does not update the current position after each call to a text-output function."},{"content":"This is the default setting.","pos":[259170,259198]},{"content":"<bpt id=\"p1\">**</bpt>TA_UPDATECP<ept id=\"p1\">**</ept> Updates the current x-position after each call to a text-output function.","pos":[259206,259295],"source":"**TA_UPDATECP** Updates the current x-position after each call to a text-output function."},{"content":"The new position is at the right side of the bounding rectangle for the text.","pos":[259296,259373]},{"content":"When this flag is set, the coordinates specified in calls to the <ph id=\"ph1\">`TextOut`</ph> member function are ignored.","pos":[259374,259477],"source":" When this flag is set, the coordinates specified in calls to the `TextOut` member function are ignored."},{"content":"Return Value","pos":[259487,259499]},{"content":"The previous text-alignment setting, if successful.","pos":[259503,259554]},{"content":"The low-order byte contains the horizontal setting and the high-order byte contains the vertical setting; otherwise 0.","pos":[259555,259673]},{"content":"Remarks","pos":[259683,259690]},{"content":"The <ph id=\"ph1\">`TextOut`</ph> and <ph id=\"ph2\">`ExtTextOut`</ph> member functions use these flags when positioning a string of text on a display or device.","pos":[259694,259815],"source":"The `TextOut` and `ExtTextOut` member functions use these flags when positioning a string of text on a display or device."},{"content":"The flags specify the relationship between a specific point and a rectangle that bounds the text.","pos":[259816,259913]},{"content":"The coordinates of this point are passed as parameters to the <ph id=\"ph1\">`TextOut`</ph> member function.","pos":[259914,260002],"source":" The coordinates of this point are passed as parameters to the `TextOut` member function."},{"content":"The rectangle that bounds the text is formed by the adjacent character cells in the text string.","pos":[260003,260099]},{"pos":[260152,260178],"content":"CDC::SetTextCharacterExtra"},{"content":"Sets the amount of intercharacter spacing.","pos":[260182,260224]},{"content":"Parameters","pos":[260292,260302]},{"content":"Specifies the amount of extra space (in logical units) to be added to each character.","pos":[260322,260407]},{"content":"If the current mapping mode is not <ph id=\"ph1\">`MM_TEXT`</ph>, <ph id=\"ph2\">`nCharExtra`</ph> is transformed and rounded to the nearest pixel.","pos":[260408,260515],"source":" If the current mapping mode is not `MM_TEXT`, `nCharExtra` is transformed and rounded to the nearest pixel."},{"content":"Return Value","pos":[260525,260537]},{"content":"The amount of the previous intercharacter spacing.","pos":[260541,260591]},{"content":"Remarks","pos":[260601,260608]},{"content":"GDI adds this spacing to each character, including break characters, when it writes a line of text to the device context.","pos":[260612,260733]},{"content":"The default value for the amount of intercharacter spacing is 0.","pos":[260734,260798]},{"pos":[260842,260859],"content":"CDC::SetTextColor"},{"content":"Sets the text color to the specified color.","pos":[260863,260906]},{"content":"Parameters","pos":[260980,260990]},{"content":"Specifies the color of the text as an RGB color value.","pos":[261007,261061]},{"content":"Return Value","pos":[261071,261083]},{"content":"An RGB value for the previous text color.","pos":[261087,261128]},{"content":"Remarks","pos":[261138,261145]},{"content":"The system will use this text color when writing text to this device context and also when converting bitmaps between color and monochrome device contexts.","pos":[261149,261304]},{"content":"If the device cannot represent the specified color, the system sets the text color to the nearest physical color.","pos":[261311,261424]},{"content":"The background color for a character is specified by the <ph id=\"ph1\">`SetBkColor`</ph> and <ph id=\"ph2\">`SetBkMode`</ph> member functions.","pos":[261425,261528],"source":" The background color for a character is specified by the `SetBkColor` and `SetBkMode` member functions."},{"content":"Example","pos":[261538,261545]},{"pos":[261550,261641],"content":"See the example for <bpt id=\"p1\">[</bpt>CWnd::OnCtlColor<ept id=\"p1\">](../../mfc/reference/cwnd-class.md#cwnd__onctlcolor)</ept>.","source":"See the example for [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#cwnd__onctlcolor)."},{"pos":[261693,261718],"content":"CDC::SetTextJustification"},{"content":"Adds space to the break characters in a string.","pos":[261722,261769]},{"content":"Parameters","pos":[261865,261875]},{"content":"Specifies the total extra space to be added to the line of text (in logical units).","pos":[261896,261979]},{"content":"If the current mapping mode is not <ph id=\"ph1\">`MM_TEXT`</ph>, the value given by this parameter is converted to the current mapping mode and rounded to the nearest device unit.","pos":[261980,262140],"source":" If the current mapping mode is not `MM_TEXT`, the value given by this parameter is converted to the current mapping mode and rounded to the nearest device unit."},{"content":"nBreakCount","pos":[262148,262159]},{"content":"Specifies the number of break characters in the line.","pos":[262164,262217]},{"content":"Return Value","pos":[262227,262239]},{"content":"One if the function is successful; otherwise 0.","pos":[262243,262290]},{"content":"Remarks","pos":[262300,262307]},{"pos":[262311,262409],"content":"An application can use the <ph id=\"ph1\">`GetTextMetrics`</ph> member functions to retrieve a font's break character.","source":"An application can use the `GetTextMetrics` member functions to retrieve a font's break character."},{"content":"After the <ph id=\"ph1\">`SetTextJustification`</ph> member function is called, a call to a text-output function (such as <ph id=\"ph2\">`TextOut`</ph>) distributes the specified extra space evenly among the specified number of break characters.","pos":[262416,262621],"source":"After the `SetTextJustification` member function is called, a call to a text-output function (such as `TextOut`) distributes the specified extra space evenly among the specified number of break characters."},{"content":"The break character is usually the space character (ASCII 32), but may be defined by a font as some other character.","pos":[262622,262738]},{"content":"The member function <ph id=\"ph1\">`GetTextExtent`</ph> is typically used with <ph id=\"ph2\">`SetTextJustification`</ph>.","pos":[262745,262827],"source":"The member function `GetTextExtent` is typically used with `SetTextJustification`."},{"content":"computes the width of a given line before alignment.","pos":[262844,262896]},{"content":"An application can determine how much space to specify in the <ph id=\"ph1\">`nBreakExtra`</ph> parameter by subtracting the value returned by <ph id=\"ph2\">`GetTextExtent`</ph> from the width of the string after alignment.","pos":[262897,263081],"source":" An application can determine how much space to specify in the `nBreakExtra` parameter by subtracting the value returned by `GetTextExtent` from the width of the string after alignment."},{"content":"The <ph id=\"ph1\">`SetTextJustification`</ph> function can be used to align a line that contains multiple runs in different fonts.","pos":[263088,263199],"source":"The `SetTextJustification` function can be used to align a line that contains multiple runs in different fonts."},{"content":"In this case, the line must be created piecemeal by aligning and writing each run separately.","pos":[263200,263293]},{"content":"Because rounding errors can occur during alignment, the system keeps a running error term that defines the current error.","pos":[263300,263421]},{"content":"When aligning a line that contains multiple runs, <ph id=\"ph1\">`GetTextExtent`</ph> automatically uses this error term when it computes the extent of the next run.","pos":[263422,263567],"source":" When aligning a line that contains multiple runs, `GetTextExtent` automatically uses this error term when it computes the extent of the next run."},{"content":"This allows the text-output function to blend the error into the new run.","pos":[263568,263641]},{"content":"After each line has been aligned, this error term must be cleared to prevent it from being incorporated into the next line.","pos":[263648,263771]},{"content":"The term can be cleared by calling <ph id=\"ph1\">`SetTextJustification`</ph> with <ph id=\"ph2\">`nBreakExtra`</ph> set to 0.","pos":[263772,263858],"source":" The term can be cleared by calling `SetTextJustification` with `nBreakExtra` set to 0."},{"pos":[263904,263923],"content":"CDC::SetViewportExt"},{"content":"Sets the x- and y-extents of the viewport of the device context.","pos":[263927,263991]},{"content":"Parameters","pos":[264114,264124]},{"content":"Specifies the x-extent of the viewport (in device units).","pos":[264136,264193]},{"content":"Specifies the y-extent of the viewport (in device units).","pos":[264208,264265]},{"content":"Specifies the x- and y-extents of the viewport (in device units).","pos":[264282,264347]},{"content":"Return Value","pos":[264357,264369]},{"content":"The previous extents of the viewport as a <bpt id=\"p1\">[</bpt>CSize<ept id=\"p1\">](../../atl-mfc-shared/reference/csize-class.md)</ept> object.","pos":[264373,264477],"source":"The previous extents of the viewport as a [CSize](../../atl-mfc-shared/reference/csize-class.md) object."},{"content":"When an error occurs, the x- and y-coordinates of the returned <ph id=\"ph1\">`CSize`</ph> object are both set to 0.","pos":[264478,264574],"source":" When an error occurs, the x- and y-coordinates of the returned `CSize` object are both set to 0."},{"content":"Remarks","pos":[264584,264591]},{"content":"The viewport, along with the device-context window, defines how GDI maps points in the logical coordinate system to points in the coordinate system of the actual device.","pos":[264595,264764]},{"content":"In other words, they define how GDI converts logical coordinates into device coordinates.","pos":[264765,264854]},{"pos":[264861,264960],"content":"When the following mapping modes are set, calls to <ph id=\"ph1\">`SetWindowExt`</ph> and <ph id=\"ph2\">`SetViewportExt`</ph> are ignored:","source":"When the following mapping modes are set, calls to `SetWindowExt` and `SetViewportExt` are ignored:"},{"content":"MM_HIENGLISH","pos":[264967,264979]},{"content":"MM_LOMETRIC","pos":[264980,264991]},{"pos":[265100,265226],"content":"When <ph id=\"ph1\">`MM_ISOTROPIC`</ph> mode is set, an application must call the <ph id=\"ph2\">`SetWindowExt`</ph> member function before it calls <ph id=\"ph3\">`SetViewportExt`</ph>.","source":"When `MM_ISOTROPIC` mode is set, an application must call the `SetWindowExt` member function before it calls `SetViewportExt`."},{"content":"Example","pos":[265236,265243]},{"pos":[265248,265344],"content":"See the example for <bpt id=\"p1\">[</bpt>CView::OnPrepareDC<ept id=\"p1\">](../../mfc/reference/cview-class.md#cview__onpreparedc)</ept>.","source":"See the example for [CView::OnPrepareDC](../../mfc/reference/cview-class.md#cview__onpreparedc)."},{"pos":[265390,265409],"content":"CDC::SetViewportOrg"},{"content":"Sets the viewport origin of the device context.","pos":[265413,265460]},{"content":"Parameters","pos":[265585,265595]},{"content":"x","pos":[265600,265601]},{"content":"Specifies the x-coordinate (in device units) of the origin of the viewport.","pos":[265606,265681]},{"content":"The value must be within the range of the device coordinate system.","pos":[265682,265749]},{"content":"y","pos":[265757,265758]},{"content":"Specifies the y-coordinate (in device units) of the origin of the viewport.","pos":[265763,265838]},{"content":"The value must be within the range of the device coordinate system.","pos":[265839,265906]},{"content":"Specifies the origin of the viewport.","pos":[265924,265961]},{"content":"The values must be within the range of the device coordinate system.","pos":[265962,266030]},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[266031,266113],"source":" You can pass either a **POINT** structure or a `CPoint` object for this parameter."},{"content":"Return Value","pos":[266123,266135]},{"pos":[266139,266220],"content":"The previous origin of the viewport (in device coordinates) as a <ph id=\"ph1\">`CPoint`</ph> object.","source":"The previous origin of the viewport (in device coordinates) as a `CPoint` object."},{"content":"Remarks","pos":[266230,266237]},{"content":"The viewport, along with the device-context window, defines how GDI maps points in the logical coordinate system to points in the coordinate system of the actual device.","pos":[266241,266410]},{"content":"In other words, they define how GDI converts logical coordinates into device coordinates.","pos":[266411,266500]},{"content":"The viewport origin marks the point in the device coordinate system to which GDI maps the window origin, a point in the logical coordinate system specified by the <bpt id=\"p1\">**</bpt>SetWindowOrg<ept id=\"p1\">**</ept> member function.","pos":[266507,266703],"source":"The viewport origin marks the point in the device coordinate system to which GDI maps the window origin, a point in the logical coordinate system specified by the **SetWindowOrg** member function."},{"content":"GDI maps all other points by following the same process required to map the window origin to the viewport origin.","pos":[266704,266817]},{"content":"For example, all points in a circle around the point at the window origin will be in a circle around the point at the viewport origin.","pos":[266818,266952]},{"content":"Similarly, all points in a line that passes through the window origin will be in a line that passes through the viewport origin.","pos":[266953,267081]},{"content":"Example","pos":[267091,267098]},{"pos":[267103,267199],"content":"See the example for <bpt id=\"p1\">[</bpt>CView::OnPrepareDC<ept id=\"p1\">](../../mfc/reference/cview-class.md#cview__onpreparedc)</ept>.","source":"See the example for [CView::OnPrepareDC](../../mfc/reference/cview-class.md#cview__onpreparedc)."},{"pos":[267243,267260],"content":"CDC::SetWindowExt"},{"content":"Sets the x- and y-extents of the window associated with the device context.","pos":[267264,267339]},{"content":"Parameters","pos":[267458,267468]},{"content":"Specifies the x-extent (in logical units) of the window.","pos":[267480,267536]},{"content":"Specifies the y-extent (in logical units) of the window.","pos":[267551,267607]},{"content":"Specifies the x- and y-extents (in logical units) of the window.","pos":[267624,267688]},{"content":"Return Value","pos":[267698,267710]},{"content":"The previous extents of the window (in logical units) as a <ph id=\"ph1\">`CSize`</ph> object.","pos":[267714,267788],"source":"The previous extents of the window (in logical units) as a `CSize` object."},{"content":"If an error occurs, the x- and y-coordinates of the returned <ph id=\"ph1\">`CSize`</ph> object are both set to 0.","pos":[267789,267883],"source":" If an error occurs, the x- and y-coordinates of the returned `CSize` object are both set to 0."},{"content":"Remarks","pos":[267893,267900]},{"content":"The window, along with the device-context viewport, defines how GDI maps points in the logical coordinate system to points in the device coordinate system.","pos":[267904,268059]},{"pos":[268066,268175],"content":"When the following mapping modes are set, calls to <ph id=\"ph1\">`SetWindowExt`</ph> and <ph id=\"ph2\">`SetViewportExt`</ph> functions are ignored:","source":"When the following mapping modes are set, calls to `SetWindowExt` and `SetViewportExt` functions are ignored:"},{"pos":[268303,268428],"content":"When <ph id=\"ph1\">`MM_ISOTROPIC`</ph> mode is set, an application must call the <ph id=\"ph2\">`SetWindowExt`</ph> member function before calling <ph id=\"ph3\">`SetViewportExt`</ph>.","source":"When `MM_ISOTROPIC` mode is set, an application must call the `SetWindowExt` member function before calling `SetViewportExt`."},{"content":"Example","pos":[268438,268445]},{"pos":[268450,268546],"content":"See the example for <bpt id=\"p1\">[</bpt>CView::OnPrepareDC<ept id=\"p1\">](../../mfc/reference/cview-class.md#cview__onpreparedc)</ept>.","source":"See the example for [CView::OnPrepareDC](../../mfc/reference/cview-class.md#cview__onpreparedc)."},{"pos":[268590,268607],"content":"CDC::SetWindowOrg"},{"content":"Sets the window origin of the device context.","pos":[268611,268656]},{"content":"Parameters","pos":[268769,268779]},{"content":"x","pos":[268784,268785]},{"content":"Specifies the logical x-coordinate of the new origin of the window.","pos":[268790,268857]},{"content":"y","pos":[268865,268866]},{"content":"Specifies the logical y-coordinate of the new origin of the window.","pos":[268871,268938]},{"content":"Specifies the logical coordinates of the new origin of the window.","pos":[268956,269022]},{"content":"You can pass either a <bpt id=\"p1\">**</bpt>POINT<ept id=\"p1\">**</ept> structure or a <ph id=\"ph1\">`CPoint`</ph> object for this parameter.","pos":[269023,269105],"source":" You can pass either a **POINT** structure or a `CPoint` object for this parameter."},{"content":"Return Value","pos":[269115,269127]},{"pos":[269131,269186],"content":"The previous origin of the window as a <ph id=\"ph1\">`CPoint`</ph> object.","source":"The previous origin of the window as a `CPoint` object."},{"content":"Remarks","pos":[269196,269203]},{"content":"The window, along with the device-context viewport, defines how GDI maps points in the logical coordinate system to points in the device coordinate system.","pos":[269207,269362]},{"content":"The window origin marks the point in the logical coordinate system from which GDI maps the viewport origin, a point in the device coordinate system specified by the <bpt id=\"p1\">**</bpt>SetWindowOrg<ept id=\"p1\">**</ept> function.","pos":[269369,269560],"source":"The window origin marks the point in the logical coordinate system from which GDI maps the viewport origin, a point in the device coordinate system specified by the **SetWindowOrg** function."},{"content":"GDI maps all other points by following the same process required to map the window origin to the viewport origin.","pos":[269561,269674]},{"content":"For example, all points in a circle around the point at the window origin will be in a circle around the point at the viewport origin.","pos":[269675,269809]},{"content":"Similarly, all points in a line that passes through the window origin will be in a line that passes through the viewport origin.","pos":[269810,269938]},{"pos":[269987,270009],"content":"CDC::SetWorldTransform"},{"content":"Sets a two-dimensional linear transformation between world space and page space for the specified device context.","pos":[270013,270126]},{"content":"This transformation can be used to scale, rotate, shear, or translate graphics output.","pos":[270127,270213]},{"content":"Parameters","pos":[270283,270293]},{"content":"Reference to an <bpt id=\"p1\">[</bpt>XFORM<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145228)</ept> structure that contains the transformation data.","pos":[270309,270441],"source":" Reference to an [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure that contains the transformation data."},{"content":"Return Value","pos":[270451,270463]},{"content":"Returns a nonzero value on success.","pos":[270467,270502]},{"content":"Returns 0 on failure.","pos":[270509,270530]},{"pos":[270537,270652],"content":"To get extended error information, call <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms679360)</ept>.","source":"To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)."},{"content":"Remarks","pos":[270662,270669]},{"pos":[270673,270796],"content":"This method wraps the Windows GDI function <bpt id=\"p1\">[</bpt>SetWorldTransform<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145104)</ept>.","source":"This method wraps the Windows GDI function [SetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145104)."},{"pos":[270836,270849],"content":"CDC::StartDoc"},{"pos":[270853,271035],"content":"Informs the device driver that a new print job is starting and that all subsequent <ph id=\"ph1\">`StartPage`</ph> and <ph id=\"ph2\">`EndPage`</ph> calls should be spooled under the same job until an <ph id=\"ph3\">`EndDoc`</ph> call occurs.","source":"Informs the device driver that a new print job is starting and that all subsequent `StartPage` and `EndPage` calls should be spooled under the same job until an `EndDoc` call occurs."},{"content":"Parameters","pos":[271133,271143]},{"content":"lpDocInfo","pos":[271148,271157]},{"content":"Points to a <bpt id=\"p1\">[</bpt>DOCINFO<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd183574)</ept> structure containing the name of the document file and the name of the output file.","pos":[271162,271327],"source":" Points to a [DOCINFO](http://msdn.microsoft.com/library/windows/desktop/dd183574) structure containing the name of the document file and the name of the output file."},{"content":"lpszDocName","pos":[271335,271346]},{"content":"Pointer to a string containing the name of the document file.","pos":[271351,271412]},{"content":"Return Value","pos":[271422,271434]},{"content":"If the function succeeds, the return value is greater than zero.","pos":[271438,271502]},{"content":"This value is the print job identifier for the document.","pos":[271503,271559]},{"content":"If the function fails, the return value is less than or equal to zero.","pos":[271566,271636]},{"content":"Remarks","pos":[271646,271653]},{"content":"This ensures that documents longer than one page will not be interspersed with other jobs.","pos":[271657,271747]},{"content":"For Windows versions 3.1 and later, this function replaces the <bpt id=\"p1\">**</bpt>STARTDOC<ept id=\"p1\">**</ept> printer escape.","pos":[271754,271845],"source":"For Windows versions 3.1 and later, this function replaces the **STARTDOC** printer escape."},{"content":"Using this function ensures that documents containing more than one page are not interspersed with other print jobs.","pos":[271846,271962]},{"pos":[271980,272016],"content":"should not be used inside metafiles."},{"content":"Example","pos":[272026,272033]},{"content":"This code fragment gets the default printer, opens a print job, and spools one page with \"Hello, World!\"","pos":[272037,272141]},{"content":"on it.","pos":[272142,272148]},{"content":"Because the text printed by this code isn't scaled to the printer's logical units, the output text may be in such small letters that the result is unreadable.","pos":[272149,272307]},{"content":"The CDC scaling functions, such as <ph id=\"ph1\">`SetMapMode`</ph>, <ph id=\"ph2\">`SetViewportOrg`</ph>, and <ph id=\"ph3\">`SetWindowExt`</ph>, can be used to fix the scaling.","pos":[272308,272426],"source":" The CDC scaling functions, such as `SetMapMode`, `SetViewportOrg`, and `SetWindowExt`, can be used to fix the scaling."},{"pos":[272444,272461],"content":"NVC_MFCDocView#41"},{"pos":[272548,272562],"content":"CDC::StartPage"},{"content":"Call this member function to prepare the printer driver to receive data.","pos":[272566,272638]},{"content":"Return Value","pos":[272680,272692]},{"content":"Greater than or equal to 0 if the function is successful, or a negative value if an error occurred.","pos":[272696,272795]},{"content":"Remarks","pos":[272805,272812]},{"pos":[272828,272881],"content":"supersedes the <bpt id=\"p1\">**</bpt>NEWFRAME<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>BANDINFO<ept id=\"p2\">**</ept> escapes.","source":" supersedes the **NEWFRAME** and **BANDINFO** escapes."},{"pos":[272888,272990],"content":"For an overview of the sequence of printing calls, see the <bpt id=\"p1\">[</bpt>StartDoc<ept id=\"p1\">](#cdc__startdoc)</ept> member function.","source":"For an overview of the sequence of printing calls, see the [StartDoc](#cdc__startdoc) member function."},{"pos":[272997,273090],"content":"The system disables the <ph id=\"ph1\">`ResetDC`</ph> member function between calls to <ph id=\"ph2\">`StartPage`</ph> and <ph id=\"ph3\">`EndPage`</ph>.","source":"The system disables the `ResetDC` member function between calls to `StartPage` and `EndPage`."},{"content":"Example","pos":[273100,273107]},{"pos":[273112,273164],"content":"See the example for <bpt id=\"p1\">[</bpt>CDC::StartDoc<ept id=\"p1\">](#cdc__startdoc)</ept>.","source":"See the example for [CDC::StartDoc](#cdc__startdoc)."},{"pos":[273206,273221],"content":"CDC::StretchBlt"},{"content":"Copies a bitmap from a source rectangle into a destination rectangle, stretching or compressing the bitmap if necessary to fit the dimensions of the destination rectangle.","pos":[273225,273396]},{"content":"Parameters","pos":[273613,273623]},{"content":"x","pos":[273628,273629]},{"content":"Specifies the x-coordinate (in logical units) of the upper-left corner of the destination rectangle.","pos":[273634,273734]},{"content":"y","pos":[273742,273743]},{"content":"Specifies the y-coordinate (in logical units) of the upper-left corner of the destination rectangle.","pos":[273748,273848]},{"content":"Specifies the width (in logical units) of the destination rectangle.","pos":[273867,273935]},{"content":"Specifies the height (in logical units) of the destination rectangle.","pos":[273955,274024]},{"content":"Specifies the source device context.","pos":[274043,274079]},{"content":"Specifies the x-coordinate (in logical units) of the upper-left corner of the source rectangle.","pos":[274096,274191]},{"content":"Specifies the y-coordinate (in logical units) of the upper-left corner of the source rectangle.","pos":[274208,274303]},{"content":"Specifies the width (in logical units) of the source rectangle.","pos":[274325,274388]},{"content":"Specifies the height (in logical units) of the source rectangle.","pos":[274411,274475]},{"content":"dwRop","pos":[274483,274488]},{"content":"Specifies the raster operation to be performed.","pos":[274493,274540]},{"content":"Raster operation codes define how GDI combines colors in output operations that involve a current brush, a possible source bitmap, and a destination bitmap.","pos":[274541,274697]},{"content":"This parameter may be one of the following values:","pos":[274698,274748]},{"pos":[274756,274793],"content":"<bpt id=\"p1\">**</bpt>BLACKNESS<ept id=\"p1\">**</ept> Turns all output black.","source":"**BLACKNESS** Turns all output black."},{"pos":[274801,274846],"content":"<bpt id=\"p1\">**</bpt>DSTINVERT<ept id=\"p1\">**</ept> Inverts the destination bitmap.","source":"**DSTINVERT** Inverts the destination bitmap."},{"pos":[274854,274942],"content":"<bpt id=\"p1\">**</bpt>MERGECOPY<ept id=\"p1\">**</ept> Combines the pattern and the source bitmap using the Boolean AND operator.","source":"**MERGECOPY** Combines the pattern and the source bitmap using the Boolean AND operator."},{"pos":[274950,275059],"content":"<bpt id=\"p1\">**</bpt>MERGEPAINT<ept id=\"p1\">**</ept> Combines the inverted source bitmap with the destination bitmap using the Boolean OR operator.","source":"**MERGEPAINT** Combines the inverted source bitmap with the destination bitmap using the Boolean OR operator."},{"pos":[275067,275135],"content":"<bpt id=\"p1\">**</bpt>NOTSRCCOPY<ept id=\"p1\">**</ept> Copies the inverted source bitmap to the destination.","source":"**NOTSRCCOPY** Copies the inverted source bitmap to the destination."},{"pos":[275143,275256],"content":"<bpt id=\"p1\">**</bpt>NOTSRCERASE<ept id=\"p1\">**</ept> Inverts the result of combining the destination and source bitmaps using the Boolean OR operator.","source":"**NOTSRCERASE** Inverts the result of combining the destination and source bitmaps using the Boolean OR operator."},{"pos":[275264,275321],"content":"<bpt id=\"p1\">**</bpt>PATCOPY<ept id=\"p1\">**</ept> Copies the pattern to the destination bitmap.","source":"**PATCOPY** Copies the pattern to the destination bitmap."},{"pos":[275329,275423],"content":"<bpt id=\"p1\">**</bpt>PATINVERT<ept id=\"p1\">**</ept> Combines the destination bitmap with the pattern using the Boolean XOR operator.","source":"**PATINVERT** Combines the destination bitmap with the pattern using the Boolean XOR operator."},{"content":"<bpt id=\"p1\">**</bpt>PATPAINT<ept id=\"p1\">**</ept> Combines the inverted source bitmap with the pattern using the Boolean OR operator.","pos":[275431,275527],"source":"**PATPAINT** Combines the inverted source bitmap with the pattern using the Boolean OR operator."},{"content":"Combines the result of this operation with the destination bitmap using the Boolean OR operator.","pos":[275528,275624]},{"pos":[275632,275728],"content":"<bpt id=\"p1\">**</bpt>SRCAND<ept id=\"p1\">**</ept> Combines pixels of the destination and source bitmaps using the Boolean AND operator.","source":"**SRCAND** Combines pixels of the destination and source bitmaps using the Boolean AND operator."},{"pos":[275736,275799],"content":"<bpt id=\"p1\">**</bpt>SRCCOPY<ept id=\"p1\">**</ept> Copies the source bitmap to the destination bitmap.","source":"**SRCCOPY** Copies the source bitmap to the destination bitmap."},{"pos":[275807,275929],"content":"<bpt id=\"p1\">**</bpt>SRCERASE<ept id=\"p1\">**</ept> Inverts the destination bitmap and combines the result with the source bitmap using the Boolean AND operator.","source":"**SRCERASE** Inverts the destination bitmap and combines the result with the source bitmap using the Boolean AND operator."},{"pos":[275937,276036],"content":"<bpt id=\"p1\">**</bpt>SRCINVERT<ept id=\"p1\">**</ept> Combines pixels of the destination and source bitmaps using the Boolean XOR operator.","source":"**SRCINVERT** Combines pixels of the destination and source bitmaps using the Boolean XOR operator."},{"pos":[276044,276141],"content":"<bpt id=\"p1\">**</bpt>SRCPAINT<ept id=\"p1\">**</ept> Combines pixels of the destination and source bitmaps using the Boolean OR operator.","source":"**SRCPAINT** Combines pixels of the destination and source bitmaps using the Boolean OR operator."},{"pos":[276149,276186],"content":"<bpt id=\"p1\">**</bpt>WHITENESS<ept id=\"p1\">**</ept> Turns all output white.","source":"**WHITENESS** Turns all output white."},{"content":"Return Value","pos":[276196,276208]},{"content":"Nonzero if the bitmap is drawn; otherwise 0.","pos":[276212,276256]},{"content":"Remarks","pos":[276266,276273]},{"pos":[276277,276429],"content":"The function uses the stretching mode of the destination device context (set by <ph id=\"ph1\">`SetStretchBltMode`</ph>) to determine how to stretch or compress the bitmap.","source":"The function uses the stretching mode of the destination device context (set by `SetStretchBltMode`) to determine how to stretch or compress the bitmap."},{"content":"The <ph id=\"ph1\">`StretchBlt`</ph> function moves the bitmap from the source device given by <ph id=\"ph2\">`pSrcDC`</ph> to the destination device represented by the device-context object whose member function is being called.","pos":[276436,276625],"source":"The `StretchBlt` function moves the bitmap from the source device given by `pSrcDC` to the destination device represented by the device-context object whose member function is being called."},{"content":"The <ph id=\"ph1\">`xSrc`</ph>, <ph id=\"ph2\">`ySrc`</ph>, <ph id=\"ph3\">`nSrcWidth`</ph>, and <ph id=\"ph4\">`nSrcHeight`</ph> parameters define the upper-left corner and dimensions of the source rectangle.","pos":[276626,276755],"source":" The `xSrc`, `ySrc`, `nSrcWidth`, and `nSrcHeight` parameters define the upper-left corner and dimensions of the source rectangle."},{"content":"The <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept>, <ph id=\"ph1\">`nWidth`</ph>, and <ph id=\"ph2\">`nHeight`</ph> parameters give the upper-left corner and dimensions of the destination rectangle.","pos":[276756,276876],"source":" The *x*, *y*, `nWidth`, and `nHeight` parameters give the upper-left corner and dimensions of the destination rectangle."},{"content":"The raster operation specified by <bpt id=\"p1\">*</bpt>dwRop<ept id=\"p1\">*</ept> defines how the source bitmap and the bits already on the destination device are combined.","pos":[276877,277009],"source":" The raster operation specified by *dwRop* defines how the source bitmap and the bits already on the destination device are combined."},{"content":"The <ph id=\"ph1\">`StretchBlt`</ph> function creates a mirror image of a bitmap if the signs of the <ph id=\"ph2\">`nSrcWidth`</ph> and <ph id=\"ph3\">`nWidth`</ph> or <ph id=\"ph4\">`nSrcHeight`</ph> and <ph id=\"ph5\">`nHeight`</ph> parameters differ.","pos":[277016,277170],"source":"The `StretchBlt` function creates a mirror image of a bitmap if the signs of the `nSrcWidth` and `nWidth` or `nSrcHeight` and `nHeight` parameters differ."},{"content":"If <ph id=\"ph1\">`nSrcWidth`</ph> and <ph id=\"ph2\">`nWidth`</ph> have different signs, the function creates a mirror image of the bitmap along the x-axis.","pos":[277171,277288],"source":" If `nSrcWidth` and `nWidth` have different signs, the function creates a mirror image of the bitmap along the x-axis."},{"content":"If <ph id=\"ph1\">`nSrcHeight`</ph> and <ph id=\"ph2\">`nHeight`</ph> have different signs, the function creates a mirror image of the bitmap along the y-axis.","pos":[277289,277408],"source":" If `nSrcHeight` and `nHeight` have different signs, the function creates a mirror image of the bitmap along the y-axis."},{"content":"The <ph id=\"ph1\">`StretchBlt`</ph> function stretches or compresses the source bitmap in memory and then copies the result to the destination.","pos":[277415,277539],"source":"The `StretchBlt` function stretches or compresses the source bitmap in memory and then copies the result to the destination."},{"content":"If a pattern is to be merged with the result, it is not merged until the stretched source bitmap is copied to the destination.","pos":[277540,277666]},{"content":"If a brush is used, it is the selected brush in the destination device context.","pos":[277667,277746]},{"content":"The destination coordinates are transformed according to the destination device context; the source coordinates are transformed according to the source device context.","pos":[277747,277914]},{"content":"If the destination, source, and pattern bitmaps do not have the same color format, <ph id=\"ph1\">`StretchBlt`</ph> converts the source and pattern bitmaps to match the destination bitmaps.","pos":[277921,278090],"source":"If the destination, source, and pattern bitmaps do not have the same color format, `StretchBlt` converts the source and pattern bitmaps to match the destination bitmaps."},{"content":"The foreground and background colors of the destination device context are used in the conversion.","pos":[278091,278189]},{"content":"If <ph id=\"ph1\">`StretchBlt`</ph> must convert a monochrome bitmap to color, it sets white bits (1) to the background color and black bits (0) to the foreground color.","pos":[278196,278345],"source":"If `StretchBlt` must convert a monochrome bitmap to color, it sets white bits (1) to the background color and black bits (0) to the foreground color."},{"content":"To convert color to monochrome, it sets pixels that match the background color to white (1) and sets all other pixels to black (0).","pos":[278346,278477]},{"content":"The foreground and background colors of the device context with color are used.","pos":[278478,278557]},{"content":"Not all devices support the <ph id=\"ph1\">`StretchBlt`</ph> function.","pos":[278564,278614],"source":"Not all devices support the `StretchBlt` function."},{"content":"To determine whether a device supports <ph id=\"ph1\">`StretchBlt`</ph>, call the <ph id=\"ph2\">`GetDeviceCaps`</ph> member function with the <bpt id=\"p1\">**</bpt>RASTERCAPS<ept id=\"p1\">**</ept> index and check the return value for the <bpt id=\"p2\">**</bpt>RC_STRETCHBLT<ept id=\"p2\">**</ept> flag.","pos":[278615,278797],"source":" To determine whether a device supports `StretchBlt`, call the `GetDeviceCaps` member function with the **RASTERCAPS** index and check the return value for the **RC_STRETCHBLT** flag."},{"pos":[278846,278868],"content":"CDC::StrokeAndFillPath"},{"content":"Closes any open figures in a path, strokes the outline of the path by using the current pen, and fills its interior by using the current brush.","pos":[278872,279015]},{"content":"Return Value","pos":[279066,279078]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[279082,279133]},{"content":"Remarks","pos":[279143,279150]},{"content":"The device context must contain a closed path.","pos":[279154,279200]},{"content":"The <ph id=\"ph1\">`StrokeAndFillPath`</ph> member function has the same effect as closing all the open figures in the path, and stroking and filling the path separately, except that the filled region will not overlap the stroked region even if the pen is wide.","pos":[279201,279442],"source":" The `StrokeAndFillPath` member function has the same effect as closing all the open figures in the path, and stroking and filling the path separately, except that the filled region will not overlap the stroked region even if the pen is wide."},{"pos":[279484,279499],"content":"CDC::StrokePath"},{"content":"Renders the specified path by using the current pen.","pos":[279503,279555]},{"content":"Return Value","pos":[279599,279611]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[279615,279666]},{"content":"Remarks","pos":[279676,279683]},{"content":"The device context must contain a closed path.","pos":[279687,279733]},{"pos":[279778,279796],"content":"CDC::TabbedTextOut"},{"content":"Call this member function to write a character string at the specified location, expanding tabs to the values specified in the array of tab-stop positions.","pos":[279800,279955]},{"content":"Parameters","pos":[280313,280323]},{"content":"x","pos":[280328,280329]},{"content":"Specifies the logical x-coordinate of the starting point of the string.","pos":[280334,280405]},{"content":"y","pos":[280413,280414]},{"content":"Specifies the logical y-coordinate of the starting point of the string.","pos":[280419,280490]},{"content":"Points to the character string to draw.","pos":[280513,280552]},{"content":"You can pass either a pointer to an array of characters or a <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object for this parameter.","pos":[280553,280700],"source":" You can pass either a pointer to an array of characters or a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter."},{"content":"Specifies the number of characters in the string.","pos":[280719,280768]},{"content":"If <ph id=\"ph1\">`nCount`</ph> is –1, the length is calculated.","pos":[280769,280813],"source":" If `nCount` is –1, the length is calculated."},{"content":"Specifies the number of values in the array of tab-stop positions.","pos":[280839,280905]},{"content":"Points to an array containing the tab-stop positions (in logical units).","pos":[280937,281009]},{"content":"The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array.","pos":[281010,281119]},{"content":"Specifies the x-coordinate of the starting position from which tabs are expanded (in logical units).","pos":[281142,281242]},{"content":"A <ph id=\"ph1\">`CString`</ph> object that contains the specified characters.","pos":[281258,281316],"source":" A `CString` object that contains the specified characters."},{"content":"Return Value","pos":[281326,281338]},{"pos":[281342,281410],"content":"The dimensions of the string (in logical units) as a <ph id=\"ph1\">`CSize`</ph> object.","source":"The dimensions of the string (in logical units) as a `CSize` object."},{"content":"Remarks","pos":[281420,281427]},{"content":"Text is written in the currently selected font.","pos":[281431,281478]},{"content":"If <ph id=\"ph1\">`nTabPositions`</ph> is 0 and <ph id=\"ph2\">`lpnTabStopPositions`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, tabs are expanded to eight times the average character width.","pos":[281479,281603],"source":" If `nTabPositions` is 0 and `lpnTabStopPositions` is **NULL**, tabs are expanded to eight times the average character width."},{"content":"If <ph id=\"ph1\">`nTabPositions`</ph> is 1, the tab stops are separated by the distance specified by the first value in the <ph id=\"ph2\">`lpnTabStopPositions`</ph> array.","pos":[281610,281743],"source":"If `nTabPositions` is 1, the tab stops are separated by the distance specified by the first value in the `lpnTabStopPositions` array."},{"content":"If the <ph id=\"ph1\">`lpnTabStopPositions`</ph> array contains more than one value, a tab stop is set for each value in the array, up to the number specified by <ph id=\"ph2\">`nTabPositions`</ph>.","pos":[281744,281902],"source":" If the `lpnTabStopPositions` array contains more than one value, a tab stop is set for each value in the array, up to the number specified by `nTabPositions`."},{"content":"The <ph id=\"ph1\">`nTabOrigin`</ph> parameter allows an application to call the <ph id=\"ph2\">`TabbedTextOut`</ph> function several times for a single line.","pos":[281903,282021],"source":" The `nTabOrigin` parameter allows an application to call the `TabbedTextOut` function several times for a single line."},{"content":"If the application calls the function more than once with the <ph id=\"ph1\">`nTabOrigin`</ph> set to the same value each time, the function expands all tabs relative to the position specified by <ph id=\"ph2\">`nTabOrigin`</ph>.","pos":[282022,282211],"source":" If the application calls the function more than once with the `nTabOrigin` set to the same value each time, the function expands all tabs relative to the position specified by `nTabOrigin`."},{"content":"By default, the current position is not used or updated by the function.","pos":[282218,282290]},{"content":"If an application needs to update the current position when it calls the function, the application can call the <bpt id=\"p1\">[</bpt>SetTextAlign<ept id=\"p1\">](#cdc__settextalign)</ept> member function with <ph id=\"ph1\">`nFlags`</ph> set to <bpt id=\"p2\">**</bpt>TA_UPDATECP<ept id=\"p2\">**</ept>.","pos":[282291,282491],"source":" If an application needs to update the current position when it calls the function, the application can call the [SetTextAlign](#cdc__settextalign) member function with `nFlags` set to **TA_UPDATECP**."},{"content":"When this flag is set, Windows ignores the <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> parameters on subsequent calls to <ph id=\"ph1\">`TabbedTextOut`</ph>, using the current position instead.","pos":[282492,282633],"source":" When this flag is set, Windows ignores the *x* and *y* parameters on subsequent calls to `TabbedTextOut`, using the current position instead."},{"pos":[282672,282684],"content":"CDC::TextOut"},{"content":"Writes a character string at the specified location using the currently selected font.","pos":[282688,282774]},{"content":"Parameters","pos":[282954,282964]},{"content":"x","pos":[282969,282970]},{"content":"Specifies the logical x-coordinate of the starting point of the text.","pos":[282975,283044]},{"content":"y","pos":[283052,283053]},{"content":"Specifies the logical y-coordinate of the starting point of the text.","pos":[283058,283127]},{"content":"Points to the character string to be drawn.","pos":[283150,283193]},{"content":"Specifies the number of characters in the string.","pos":[283212,283261]},{"content":"A <ph id=\"ph1\">`CString`</ph> object that contains the characters to be drawn.","pos":[283277,283337],"source":" A `CString` object that contains the characters to be drawn."},{"content":"Return Value","pos":[283347,283359]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[283363,283414]},{"content":"Remarks","pos":[283424,283431]},{"content":"Character origins are at the upper-left corner of the character cell.","pos":[283435,283504]},{"content":"By default, the current position is not used or updated by the function.","pos":[283505,283577]},{"content":"If an application needs to update the current position when it calls <ph id=\"ph1\">`TextOut`</ph>, the application can call the <ph id=\"ph2\">`SetTextAlign`</ph> member function with <ph id=\"ph3\">`nFlags`</ph> set to <bpt id=\"p1\">**</bpt>TA_UPDATECP<ept id=\"p1\">**</ept>.","pos":[283584,283761],"source":"If an application needs to update the current position when it calls `TextOut`, the application can call the `SetTextAlign` member function with `nFlags` set to **TA_UPDATECP**."},{"content":"When this flag is set, Windows ignores the <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> parameters on subsequent calls to <ph id=\"ph1\">`TextOut`</ph>, using the current position instead.","pos":[283762,283897],"source":" When this flag is set, Windows ignores the *x* and *y* parameters on subsequent calls to `TextOut`, using the current position instead."},{"content":"Example","pos":[283907,283914]},{"pos":[283919,283973],"content":"See the example for <bpt id=\"p1\">[</bpt>CDC::BeginPath<ept id=\"p1\">](#cdc__beginpath)</ept>.","source":"See the example for [CDC::BeginPath](#cdc__beginpath)."},{"pos":[284019,284038],"content":"CDC::TransparentBlt"},{"content":"Call this member function to transfer a bit-block of the color data, which corresponds to a rectangle of pixels from the specified source device context, into a destination device context.","pos":[284042,284230]},{"content":"Parameters","pos":[284471,284481]},{"content":"Specifies the x-coordinate, in logical units, of the upper-left corner of the destination rectangle.","pos":[284496,284596]},{"content":"Specifies the y-coordinate, in logical units, of the upper-left corner of the destination rectangle.","pos":[284614,284714]},{"content":"Specifies the width, in logical units, of the destination rectangle.","pos":[284737,284805]},{"content":"Specifies the height, in logical units, of the destination rectangle.","pos":[284829,284898]},{"content":"Pointer to the source device context.","pos":[284917,284954]},{"content":"Specifies the x-coordinate, in logical units, of the source rectangle.","pos":[284971,285041]},{"content":"Specifies the y-coordinate, in logical units, of the source rectangle.","pos":[285058,285128]},{"content":"Specifies the width, in logical units, of the source rectangle.","pos":[285150,285213]},{"content":"Specifies the height, in logical units, of the source rectangle.","pos":[285236,285300]},{"content":"The RGB color in the source bitmap to treat as transparent.","pos":[285327,285386]},{"content":"Return Value","pos":[285396,285408]},{"pos":[285412,285456],"content":"<bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept> if successful; otherwise <bpt id=\"p2\">**</bpt>FALSE<ept id=\"p2\">**</ept>.","source":"**TRUE** if successful; otherwise **FALSE**."},{"content":"Remarks","pos":[285466,285473]},{"pos":[285494,285613],"content":"allows for transparency; that is, the RGB color indicated by <ph id=\"ph1\">`clrTransparent`</ph> is rendered transparent for the transfer.","source":" allows for transparency; that is, the RGB color indicated by `clrTransparent` is rendered transparent for the transfer."},{"pos":[285620,285782],"content":"For more information, see <bpt id=\"p1\">[</bpt>TransparentBlt<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145141)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"For more information, see [TransparentBlt](http://msdn.microsoft.com/library/windows/desktop/dd145141) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[285826,285843],"content":"CDC::UpdateColors"},{"content":"Updates the client area of the device context by matching the current colors in the client area to the system palette on a pixel-by-pixel basis.","pos":[285847,285991]},{"content":"Remarks","pos":[286037,286044]},{"pos":[286048,286202],"content":"An inactive window with a realized logical palette may call <ph id=\"ph1\">`UpdateColors`</ph> as an alternative to redrawing its client area when the system palette changes.","source":"An inactive window with a realized logical palette may call `UpdateColors` as an alternative to redrawing its client area when the system palette changes."},{"pos":[286209,286396],"content":"For more information about using color palettes, see <bpt id=\"p1\">[</bpt>UpdateColors<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/dd145166)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"For more information about using color palettes, see [UpdateColors](http://msdn.microsoft.com/library/windows/desktop/dd145166) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"The <ph id=\"ph1\">`UpdateColors`</ph> member function typically updates a client area faster than redrawing the area.","pos":[286403,286501],"source":"The `UpdateColors` member function typically updates a client area faster than redrawing the area."},{"content":"However, because the function performs the color translation based on the color of each pixel before the system palette changed, each call to this function results in the loss of some color accuracy.","pos":[286502,286701]},{"pos":[286742,286756],"content":"CDC::WidenPath"},{"content":"Redefines the current path as the area that would be painted if the path were stroked using the pen currently selected into the device context.","pos":[286760,286903]},{"content":"Return Value","pos":[286946,286958]},{"content":"Nonzero if the function is successful; otherwise 0.","pos":[286962,287013]},{"content":"Remarks","pos":[287023,287030]},{"content":"This function is successful only if the current pen is a geometric pen created by the second version of <ph id=\"ph1\">`CreatePen`</ph> member function, or if the pen is created with the first version of <ph id=\"ph2\">`CreatePen`</ph> and has a width, in device units, of greater than 1.","pos":[287034,287282],"source":"This function is successful only if the current pen is a geometric pen created by the second version of `CreatePen` member function, or if the pen is created with the first version of `CreatePen` and has a width, in device units, of greater than 1."},{"content":"The device context must contain a closed path.","pos":[287283,287329]},{"content":"Any Bzier curves in the path are converted to sequences of straight lines approximating the widened curves.","pos":[287330,287437]},{"content":"As such, no Bzier curves remain in the path after <ph id=\"ph1\">`WidenPath`</ph> is called.","pos":[287438,287510],"source":" As such, no Bzier curves remain in the path after `WidenPath` is called."},{"content":"See Also","pos":[287519,287527]},{"content":"CObject Class","pos":[287532,287545]},{"content":"Hierarchy Chart","pos":[287590,287605]},{"content":"CPaintDC Class","pos":[287642,287656]},{"content":"CWindowDC Class","pos":[287702,287717]},{"content":"CClientDC Class","pos":[287764,287779]},{"content":"CMetaFileDC Class","pos":[287826,287843]}],"content":"---\ntitle: \"CDC Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CDC\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"Windows [C++], device contexts\"\n  - \"Windows 95 [C++], screen coordinates\"\n  - \"device contexts [C++], CDC class\"\n  - \"screen coordinates in device contexts\"\n  - \"coordinates in Windows 95/98 [C++]\"\n  - \"Windows 98 [C++], screen coordinates\"\n  - \"CDC class\"\nms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CDC Class\nDefines a class of device-context objects.  \n  \n## Syntax  \n  \n```  \nclass CDC : public CObject  \n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CDC::CDC](#cdc__cdc)|Constructs a `CDC` object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CDC::AbortDoc](#cdc__abortdoc)|Terminates the current print job, erasing everything the application has written to the device since the last call of the `StartDoc` member function.|  \n|[CDC::AbortPath](#cdc__abortpath)|Closes and discards any paths in the device context.|  \n|[CDC::AddMetaFileComment](#cdc__addmetafilecomment)|Copies the comment from a buffer into a specified enhanced-format metafile.|  \n|[CDC::AlphaBlend](#cdc__alphablend)|Displays bitmaps that have transparent or semitransparent pixels.|  \n|[CDC::AngleArc](#cdc__anglearc)|Draws a line segment and an arc, and moves the current position to the ending point of the arc.|  \n|[CDC::Arc](#cdc__arc)|Draws an elliptical arc.|  \n|[CDC::ArcTo](#cdc__arcto)|Draws an elliptical arc. This function is similar to `Arc`, except that the current position is updated.|  \n|[CDC::Attach](#cdc__attach)|Attaches a Windows device context to this `CDC` object.|  \n|[CDC::BeginPath](#cdc__beginpath)|Opens a path bracket in the device context.|  \n|[CDC::BitBlt](#cdc__bitblt)|Copies a bitmap from a specified device context.|  \n|[CDC::Chord](#cdc__chord)|Draws a chord (a closed figure bounded by the intersection of an ellipse and a line segment).|  \n|[CDC::CloseFigure](#cdc__closefigure)|Closes an open figure in a path.|  \n|[CDC::CreateCompatibleDC](#cdc__createcompatibledc)|Creates a memory-device context that is compatible with another device context. You can use it to prepare images in memory.|  \n|[CDC::CreateDC](#cdc__createdc)|Creates a device context for a specific device.|  \n|[CDC::CreateIC](#cdc__createic)|Creates an information context for a specific device. This provides a fast way to get information about the device without creating a device context.|  \n|[CDC::DeleteDC](#cdc__deletedc)|Deletes the Windows device context associated with this `CDC` object.|  \n|[CDC::DeleteTempMap](#cdc__deletetempmap)|Called by the `CWinApp` idle-time handler to delete any temporary `CDC` object created by `FromHandle`. Also detaches the device context.|  \n|[CDC::Detach](#cdc__detach)|Detaches the Windows device context from this `CDC` object.|  \n|[CDC::DPtoHIMETRIC](#cdc__dptohimetric)|Converts device units into **HIMETRIC** units.|  \n|[CDC::DPtoLP](#cdc__dptolp)|Converts device units into logical units.|  \n|[CDC::Draw3dRect](#cdc__draw3drect)|Draws a three-dimensional rectangle.|  \n|[CDC::DrawDragRect](#cdc__drawdragrect)|Erases and redraws a rectangle as it is dragged.|  \n|[CDC::DrawEdge](#cdc__drawedge)|Draws the edges of a rectangle.|  \n|[CDC::DrawEscape](#cdc__drawescape)|Accesses drawing capabilities of a video display that are not directly available through the graphics device interface (GDI).|  \n|[CDC::DrawFocusRect](#cdc__drawfocusrect)|Draws a rectangle in the style used to indicate focus.|  \n|[CDC::DrawFrameControl](#cdc__drawframecontrol)|Draw a frame control.|  \n|[CDC::DrawIcon](#cdc__drawicon)|Draws an icon.|  \n|[CDC::DrawState](#cdc__drawstate)|Displays an image and applies a visual effect to indicate a state.|  \n|[CDC::DrawText](#cdc__drawtext)|Draws formatted text in the specified rectangle.|  \n|[CDC::DrawTextEx](#cdc__drawtextex)|Draws formatted text in the specified rectangle using additional formats.|  \n|[CDC::Ellipse](#cdc__ellipse)|Draws an ellipse.|  \n|[CDC::EndDoc](#cdc__enddoc)|Ends a print job started by the `StartDoc` member function.|  \n|[CDC::EndPage](#cdc__endpage)|Informs the device driver that a page is ending.|  \n|[CDC::EndPath](#cdc__endpath)|Closes a path bracket and selects the path defined by the bracket into the device context.|  \n|[CDC::EnumObjects](#cdc__enumobjects)|Enumerates the pens and brushes available in a device context.|  \n|[CDC::Escape](#cdc__escape)|Allows applications to access facilities that are not directly available from a particular device through GDI. Also allows access to Windows escape functions. Escape calls made by an application are translated and sent to the device driver.|  \n|[CDC::ExcludeClipRect](#cdc__excludecliprect)|Creates a new clipping region that consists of the existing clipping region minus the specified rectangle.|  \n|[CDC::ExcludeUpdateRgn](#cdc__excludeupdatergn)|Prevents drawing within invalid areas of a window by excluding an updated region in the window from a clipping region.|  \n|[CDC::ExtFloodFill](#cdc__extfloodfill)|Fills an area with the current brush. Provides more flexibility than the [CDC::FloodFill](#cdc__floodfill) member function.|  \n|[CDC::ExtTextOut](#cdc__exttextout)|Writes a character string within a rectangular region using the currently selected font.|  \n|[CDC::FillPath](#cdc__fillpath)|Closes any open figures in the current path and fills the path's interior by using the current brush and polygon-filling mode.|  \n|[CDC::FillRect](#cdc__fillrect)|Fills a given rectangle by using a specific brush.|  \n|[CDC::FillRgn](#cdc__fillrgn)|Fills a specific region with the specified brush.|  \n|[CDC::FillSolidRect](#cdc__fillsolidrect)|Fills a rectangle with a solid color.|  \n|[CDC::FlattenPath](#cdc__flattenpath)|Transforms any curves in the path selected into the current device context, and turns each curve into a sequence of lines.|  \n|[CDC::FloodFill](#cdc__floodfill)|Fills an area with the current brush.|  \n|[CDC::FrameRect](#cdc__framerect)|Draws a border around a rectangle.|  \n|[CDC::FrameRgn](#cdc__framergn)|Draws a border around a specific region using a brush.|  \n|[CDC::FromHandle](#cdc__fromhandle)|Returns a pointer to a `CDC` object when given a handle to a device context. If a `CDC` object is not attached to the handle, a temporary `CDC` object is created and attached.|  \n|[CDC::GetArcDirection](#cdc__getarcdirection)|Returns the current arc direction for the device context.|  \n|[CDC::GetAspectRatioFilter](#cdc__getaspectratiofilter)|Retrieves the setting for the current aspect-ratio filter.|  \n|[CDC::GetBkColor](#cdc__getbkcolor)|Retrieves the current background color.|  \n|[CDC::GetBkMode](#cdc__getbkmode)|Retrieves the background mode.|  \n|[CDC::GetBoundsRect](#cdc__getboundsrect)|Returns the current accumulated bounding rectangle for the specified device context.|  \n|[CDC::GetBrushOrg](#cdc__getbrushorg)|Retrieves the origin of the current brush.|  \n|[CDC::GetCharABCWidths](#cdc__getcharabcwidths)|Retrieves the widths, in logical units, of consecutive characters in a given range from the current font.|  \n|[CDC::GetCharABCWidthsI](#cdc__getcharabcwidthsi)|Retrieves the widths, in logical units, of consecutive glyph indices in a specified range from the current TrueType font.|  \n|[CDC::GetCharacterPlacement](#cdc__getcharacterplacement)|Retrieves various types of information on a character string.|  \n|[CDC::GetCharWidth](#cdc__getcharwidth)|Retrieves the fractional widths of consecutive characters in a given range from the current font.|  \n|[CDC::GetCharWidthI](#cdc__getcharwidthi)|Retrieves the widths, in logical coordinates, of consecutive glyph indices in a specified range from the current font.|  \n|[CDC::GetClipBox](#cdc__getclipbox)|Retrieves the dimensions of the tightest bounding rectangle around the current clipping boundary.|  \n|[CDC::GetColorAdjustment](#cdc__getcoloradjustment)|Retrieves the color adjustment values for the device context.|  \n|[CDC::GetCurrentBitmap](#cdc__getcurrentbitmap)|Returns a pointer to the currently selected `CBitmap` object.|  \n|[CDC::GetCurrentBrush](#cdc__getcurrentbrush)|Returns a pointer to the currently selected `CBrush` object.|  \n|[CDC::GetCurrentFont](#cdc__getcurrentfont)|Returns a pointer to the currently selected `CFont` object.|  \n|[CDC::GetCurrentPalette](#cdc__getcurrentpalette)|Returns a pointer to the currently selected `CPalette` object.|  \n|[CDC::GetCurrentPen](#cdc__getcurrentpen)|Returns a pointer to the currently selected `CPen` object.|  \n|[CDC::GetCurrentPosition](#cdc__getcurrentposition)|Retrieves the current position of the pen (in logical coordinates).|  \n|[CDC::GetDCBrushColor](#cdc__getdcbrushcolor)|Retrieves the current brush color.|  \n|[CDC::GetDCPenColor](#cdc__getdcpencolor)|Retrieves the current pen color.|  \n|[CDC::GetDeviceCaps](#cdc__getdevicecaps)|Retrieves a specified kind of device-specific information about a given display device's capabilities.|  \n|[CDC::GetFontData](#cdc__getfontdata)|Retrieves font metric information from a scalable font file. The information to retrieve is identified by specifying an offset into the font file and the length of the information to return.|  \n|[CDC::GetFontLanguageInfo](#cdc__getfontlanguageinfo)|Returns information about the currently selected font for the specified display context.|  \n|[CDC::GetGlyphOutline](#cdc__getglyphoutline)|Retrieves the outline curve or bitmap for an outline character in the current font.|  \n|[CDC::GetGraphicsMode](#cdc__getgraphicsmode)|Retrieves the current graphics mode for the specified device context.|  \n|[CDC::GetHalftoneBrush](#cdc__gethalftonebrush)|Retrieves a halftone brush.|  \n|[CDC::GetKerningPairs](#cdc__getkerningpairs)|Retrieves the character kerning pairs for the font that is currently selected in the specified device context.|  \n|[CDC::GetLayout](#cdc__getlayout)|Retrieves the layout of a device context (DC). The layout can be either left to right (default) or right to left (mirrored).|  \n|[CDC::GetMapMode](#cdc__getmapmode)|Retrieves the current mapping mode.|  \n|[CDC::GetMiterLimit](#cdc__getmiterlimit)|Returns the miter limit for the device context.|  \n|[CDC::GetNearestColor](#cdc__getnearestcolor)|Retrieves the closest logical color to a specified logical color that the given device can represent.|  \n|[CDC::GetOutlineTextMetrics](#cdc__getoutlinetextmetrics)|Retrieves font metric information for TrueType fonts.|  \n|[CDC::GetOutputCharWidth](#cdc__getoutputcharwidth)|Retrieves the widths of individual characters in a consecutive group of characters from the current font using the output device context.|  \n|[CDC::GetOutputTabbedTextExtent](#cdc__getoutputtabbedtextextent)|Computes the width and height of a character string on the output device context.|  \n|[CDC::GetOutputTextExtent](#cdc__getoutputtextextent)|Computes the width and height of a line of text on the output device context using the current font to determine the dimensions.|  \n|[CDC::GetOutputTextMetrics](#cdc__getoutputtextmetrics)|Retrieves the metrics for the current font from the output device context.|  \n|[CDC::GetPath](#cdc__getpath)|Retrieves the coordinates defining the endpoints of lines and the control points of curves found in the path that is selected into the device context.|  \n|[CDC::GetPixel](#cdc__getpixel)|Retrieves the RGB color value of the pixel at the specified point.|  \n|[CDC::GetPolyFillMode](#cdc__getpolyfillmode)|Retrieves the current polygon-filling mode.|  \n|[CDC::GetROP2](#cdc__getrop2)|Retrieves the current drawing mode.|  \n|[CDC::GetSafeHdc](#cdc__getsafehdc)|Returns [CDC::m_hDC](#cdc__m_hdc), the output device context.|  \n|[CDC::GetStretchBltMode](#cdc__getstretchbltmode)|Retrieves the current bitmap-stretching mode.|  \n|[CDC::GetTabbedTextExtent](#cdc__gettabbedtextextent)|Computes the width and height of a character string on the attribute device context.|  \n|[CDC::GetTextAlign](#cdc__gettextalign)|Retrieves the text-alignment flags.|  \n|[CDC::GetTextCharacterExtra](#cdc__gettextcharacterextra)|Retrieves the current setting for the amount of intercharacter spacing.|  \n|[CDC::GetTextColor](#cdc__gettextcolor)|Retrieves the current text color.|  \n|[CDC::GetTextExtent](#cdc__gettextextent)|Computes the width and height of a line of text on the attribute device context using the current font to determine the dimensions.|  \n|[CDC::GetTextExtentExPointI](#cdc__gettextextentexpointi)|Retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters.|  \n|[CDC::GetTextExtentPointI](#cdc__gettextextentpointi)|Retrieves the width and height of the specified array of glyph indices.|  \n|[CDC::GetTextFace](#cdc__gettextface)|Copies the typeface name of the current font into a buffer as a null-terminated string.|  \n|[CDC::GetTextMetrics](#cdc__gettextmetrics)|Retrieves the metrics for the current font from the attribute device context.|  \n|[CDC::GetViewportExt](#cdc__getviewportext)|Retrieves the x- and y-extents of the viewport.|  \n|[CDC::GetViewportOrg](#cdc__getviewportorg)|Retrieves the x- and y-coordinates of the viewport origin.|  \n|[CDC::GetWindow](#cdc__getwindow)|Returns the window associated with the display device context.|  \n|[CDC::GetWindowExt](#cdc__getwindowext)|Retrieves the x- and y-extents of the associated window.|  \n|[CDC::GetWindowOrg](#cdc__getwindoworg)|Retrieves the x- and y-coordinates of the origin of the associated window.|  \n|[CDC::GetWorldTransform](#cdc__getworldtransform)|Retrieves the current world-space to page-space transformation.|  \n|[CDC::GradientFill](#cdc__gradientfill)|Fills rectangle and triangle structures with a gradating color.|  \n|[CDC::GrayString](#cdc__graystring)|Draws dimmed (grayed) text at the given location.|  \n|[CDC::HIMETRICtoDP](#cdc__himetrictodp)|Converts **HIMETRIC** units into device units.|  \n|[CDC::HIMETRICtoLP](#cdc__himetrictolp)|Converts **HIMETRIC** units into logical units.|  \n|[CDC::IntersectClipRect](#cdc__intersectcliprect)|Creates a new clipping region by forming the intersection of the current region and a rectangle.|  \n|[CDC::InvertRect](#cdc__invertrect)|Inverts the contents of a rectangle.|  \n|[CDC::InvertRgn](#cdc__invertrgn)|Inverts the colors in a region.|  \n|[CDC::IsPrinting](#cdc__isprinting)|Determines whether the device context is being used for printing.|  \n|[CDC::LineTo](#cdc__lineto)|Draws a line from the current position up to, but not including, a point.|  \n|[CDC::LPtoDP](#cdc__lptodp)|Converts logical units into device units.|  \n|[CDC::LPtoHIMETRIC](#cdc__lptohimetric)|Converts logical units into **HIMETRIC** units.|  \n|[CDC::MaskBlt](#cdc__maskblt)|Combines the color data for the source and destination bitmaps using the given mask and raster operation.|  \n|[CDC::ModifyWorldTransform](#cdc__modifyworldtransform)|Changes the world transformation for a device context using the specified mode.|  \n|[CDC::MoveTo](#cdc__moveto)|Moves the current position.|  \n|[CDC::OffsetClipRgn](#cdc__offsetcliprgn)|Moves the clipping region of the given device.|  \n|[CDC::OffsetViewportOrg](#cdc__offsetviewportorg)|Modifies the viewport origin relative to the coordinates of the current viewport origin.|  \n|[CDC::OffsetWindowOrg](#cdc__offsetwindoworg)|Modifies the window origin relative to the coordinates of the current window origin.|  \n|[CDC::PaintRgn](#cdc__paintrgn)|Fills a region with the selected brush.|  \n|[CDC::PatBlt](#cdc__patblt)|Creates a bit pattern.|  \n|[CDC::Pie](#cdc__pie)|Draws a pie-shaped wedge.|  \n|[CDC::PlayMetaFile](#cdc__playmetafile)|Plays the contents of the specified metafile on the given device. The enhanced version of `PlayMetaFile` displays the picture stored in the given enhanced-format metafile. The metafile can be played any number of times.|  \n|[CDC::PlgBlt](#cdc__plgblt)|Performs a bit-block transfer of the bits of color data from the specified rectangle in the source device context to the specified parallelogram in the given device context.|  \n|[CDC::PolyBezier](#cdc__polybezier)|Draws one or more Bzier splines. The current position is neither used nor updated.|  \n|[CDC::PolyBezierTo](#cdc__polybezierto)|Draws one or more Bzier splines, and moves the current position to the ending point of the last Bzier spline.|  \n|[CDC::PolyDraw](#cdc__polydraw)|Draws a set of line segments and Bzier splines. This function updates the current position.|  \n|[CDC::Polygon](#cdc__polygon)|Draws a polygon consisting of two or more points (vertices) connected by lines.|  \n|[CDC::Polyline](#cdc__polyline)|Draws a set of line segments connecting the specified points.|  \n|[CDC::PolylineTo](#cdc__polylineto)|Draws one or more straight lines and moves the current position to the ending point of the last line.|  \n|[CDC::PolyPolygon](#cdc__polypolygon)|Creates two or more polygons that are filled using the current polygon-filling mode. The polygons may be disjoint or they may overlap.|  \n|[CDC::PolyPolyline](#cdc__polypolyline)|Draws multiple series of connected line segments. The current position is neither used nor updated by this function.|  \n|[CDC::PtVisible](#cdc__ptvisible)|Specifies whether the given point is within the clipping region.|  \n|[CDC::RealizePalette](#cdc__realizepalette)|Maps palette entries in the current logical palette to the system palette.|  \n|[CDC::Rectangle](#cdc__rectangle)|Draws a rectangle using the current pen and fills it using the current brush.|  \n|[CDC::RectVisible](#cdc__rectvisible)|Determines whether any part of the given rectangle lies within the clipping region.|  \n|[CDC::ReleaseAttribDC](#cdc__releaseattribdc)|Releases `m_hAttribDC`, the attribute device context.|  \n|[CDC::ReleaseOutputDC](#cdc__releaseoutputdc)|Releases `m_hDC`, the output device context.|  \n|[CDC::ResetDC](#cdc__resetdc)|Updates the `m_hAttribDC` device context.|  \n|[CDC::RestoreDC](#cdc__restoredc)|Restores the device context to a previous state saved with `SaveDC`.|  \n|[CDC::RoundRect](#cdc__roundrect)|Draws a rectangle with rounded corners using the current pen and filled using the current brush.|  \n|[CDC::SaveDC](#cdc__savedc)|Saves the current state of the device context.|  \n|[CDC::ScaleViewportExt](#cdc__scaleviewportext)|Modifies the viewport extent relative to the current values.|  \n|[CDC::ScaleWindowExt](#cdc__scalewindowext)|Modifies the window extents relative to the current values.|  \n|[CDC::ScrollDC](#cdc__scrolldc)|Scrolls a rectangle of bits horizontally and vertically.|  \n|[CDC::SelectClipPath](#cdc__selectclippath)|Selects the current path as a clipping region for the device context, combining the new region with any existing clipping region by using the specified mode.|  \n|[CDC::SelectClipRgn](#cdc__selectcliprgn)|Combines the given region with the current clipping region by using the specified mode.|  \n|[CDC::SelectObject](#cdc__selectobject)|Selects a GDI drawing object such as a pen.|  \n|[CDC::SelectPalette](#cdc__selectpalette)|Selects the logical palette.|  \n|[CDC::SelectStockObject](#cdc__selectstockobject)|Selects one of the predefined stock pens, brushes, or fonts provided by Windows.|  \n|[CDC::SetAbortProc](#cdc__setabortproc)|Sets a programmer-supplied callback function that Windows calls if a print job must be aborted.|  \n|[CDC::SetArcDirection](#cdc__setarcdirection)|Sets the drawing direction to be used for arc and rectangle functions.|  \n|[CDC::SetAttribDC](#cdc__setattribdc)|Sets `m_hAttribDC`, the attribute device context.|  \n|[CDC::SetBkColor](#cdc__setbkcolor)|Sets the current background color.|  \n|[CDC::SetBkMode](#cdc__setbkmode)|Sets the background mode.|  \n|[CDC::SetBoundsRect](#cdc__setboundsrect)|Controls the accumulation of bounding-rectangle information for the specified device context.|  \n|[CDC::SetBrushOrg](#cdc__setbrushorg)|Specifies the origin for the next brush selected into a device context.|  \n|[CDC::SetColorAdjustment](#cdc__setcoloradjustment)|Sets the color adjustment values for the device context using the specified values.|  \n|[CDC::SetDCBrushColor](#cdc__setdcbrushcolor)|Sets the current brush color.|  \n|[CDC::SetDCPenColor](#cdc__setdcpencolor)|Sets the current pen color.|  \n|[CDC::SetGraphicsMode](#cdc__setgraphicsmode)|Sets the current graphics mode for the specified device context.|  \n|[CDC::SetLayout](#cdc__setlayout)|Changes the layout of a device context (DC).|  \n|[CDC::SetMapMode](#cdc__setmapmode)|Sets the current mapping mode.|  \n|[CDC::SetMapperFlags](#cdc__setmapperflags)|Alters the algorithm that the font mapper uses when it maps logical fonts to physical fonts.|  \n|[CDC::SetMiterLimit](#cdc__setmiterlimit)|Sets the limit for the length of miter joins for the device context.|  \n|[CDC::SetOutputDC](#cdc__setoutputdc)|Sets `m_hDC`, the output device context.|  \n|[CDC::SetPixel](#cdc__setpixel)|Sets the pixel at the specified point to the closest approximation of the specified color.|  \n|[CDC::SetPixelV](#cdc__setpixelv)|Sets the pixel at the specified coordinates to the closest approximation of the specified color. `SetPixelV` is faster than `SetPixel` because it does not need to return the color value of the point actually painted.|  \n|[CDC::SetPolyFillMode](#cdc__setpolyfillmode)|Sets the polygon-filling mode.|  \n|[CDC::SetROP2](#cdc__setrop2)|Sets the current drawing mode.|  \n|[CDC::SetStretchBltMode](#cdc__setstretchbltmode)|Sets the bitmap-stretching mode.|  \n|[CDC::SetTextAlign](#cdc__settextalign)|Sets the text-alignment flags.|  \n|[CDC::SetTextCharacterExtra](#cdc__settextcharacterextra)|Sets the amount of intercharacter spacing.|  \n|[CDC::SetTextColor](#cdc__settextcolor)|Sets the text color.|  \n|[CDC::SetTextJustification](#cdc__settextjustification)|Adds space to the break characters in a string.|  \n|[CDC::SetViewportExt](#cdc__setviewportext)|Sets the x- and y-extents of the viewport.|  \n|[CDC::SetViewportOrg](#cdc__setviewportorg)|Sets the viewport origin.|  \n|[CDC::SetWindowExt](#cdc__setwindowext)|Sets the x- and y-extents of the associated window.|  \n|[CDC::SetWindowOrg](#cdc__setwindoworg)|Sets the window origin of the device context.|  \n|[CDC::SetWorldTransform](#cdc__setworldtransform)|Sets the current world-space to page-space transformation.|  \n|[CDC::StartDoc](#cdc__startdoc)|Informs the device driver that a new print job is starting.|  \n|[CDC::StartPage](#cdc__startpage)|Informs the device driver that a new page is starting.|  \n|[CDC::StretchBlt](#cdc__stretchblt)|Moves a bitmap from a source rectangle and device into a destination rectangle, stretching or compressing the bitmap if necessary to fit the dimensions of the destination rectangle.|  \n|[CDC::StrokeAndFillPath](#cdc__strokeandfillpath)|Closes any open figures in a path, strikes the outline of the path by using the current pen, and fills its interior by using the current brush.|  \n|[CDC::StrokePath](#cdc__strokepath)|Renders the specified path by using the current pen.|  \n|[CDC::TabbedTextOut](#cdc__tabbedtextout)|Writes a character string at a specified location, expanding tabs to the values specified in an array of tab-stop positions.|  \n|[CDC::TextOut](#cdc__textout)|Writes a character string at a specified location using the currently selected font.|  \n|[CDC::TransparentBlt](#cdc__transparentblt)|Transfers a bit-block of color data from the specified source device context into a destination device context, rendering a specified color transparent in the transfer.|  \n|[CDC::UpdateColors](#cdc__updatecolors)|Updates the client area of the device context by matching the current colors in the client area to the system palette on a pixel-by-pixel basis.|  \n|[CDC::WidenPath](#cdc__widenpath)|Redefines the current path as the area that would be painted if the path were stroked using the pen currently selected into the device context.|  \n  \n### Public Operators  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CDC::operator HDC](#cdc__operator_hdc)|Retrieves the handle of the device context.|  \n  \n### Public Data Members  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CDC::m_hAttribDC](#cdc__m_hattribdc)|The attribute-device context used by this `CDC` object.|  \n|[CDC::m_hDC](#cdc__m_hdc)|The output-device context used by this `CDC` object.|  \n  \n## Remarks  \n The `CDC` object provides member functions for working with a device context, such as a display or printer, as well as members for working with a display context associated with the client area of a window.  \n  \n Do all drawing through the member functions of a `CDC` object. The class provides member functions for device-context operations, working with drawing tools, type-safe graphics device interface (GDI) object selection, and working with colors and palettes. It also provides member functions for getting and setting drawing attributes, mapping, working with the viewport, working with the window extent, converting coordinates, working with regions, clipping, drawing lines, and drawing simple shapes, ellipses, and polygons. Member functions are also provided for drawing text, working with fonts, using printer escapes, scrolling, and playing metafiles.  \n  \n To use a `CDC` object, construct it, and then call its member functions that parallel Windows functions that use device contexts.  \n  \n> [!NOTE]\n>  Under Windows 95/98, all screen coordinates are limited to 16 bits. Therefore, an `int` passed to a `CDC` member function must lie in the range –32768 to 32767.  \n  \n For specific uses, the Microsoft Foundation Class Library provides several classes derived from `CDC` . `CPaintDC` encapsulates calls to `BeginPaint` and `EndPaint`. `CClientDC` manages a display context associated with a window's client area. `CWindowDC` manages a display context associated with an entire window, including its frame and controls. `CMetaFileDC` associates a device context with a metafile.  \n  \n `CDC` provides two member functions, [GetLayout](#cdc__getlayout) and [SetLayout](#cdc__setlayout), for reversing the layout of a device context, which does not inherit its layout from a window. Such right-to-left orientation is necessary for applications written for cultures, such as Arabic or Hebrew, where the character layout is not the European standard.  \n  \n `CDC` contains two device contexts, [m_hDC](#cdc__m_hdc) and [m_hAttribDC](#cdc__m_hattribdc), which, on creation of a `CDC` object, refer to the same device. `CDC` directs all output GDI calls to `m_hDC` and most attribute GDI calls to `m_hAttribDC`. (An example of an attribute call is `GetTextColor`, while `SetTextColor` is an output call.)  \n  \n For example, the framework uses these two device contexts to implement a `CMetaFileDC` object that will send output to a metafile while reading attributes from a physical device. Print preview is implemented in the framework in a similar fashion. You can also use the two device contexts in a similar way in your application-specific code.  \n  \n There are times when you may need text-metric information from both the `m_hDC` and `m_hAttribDC` device contexts. The following pairs of functions provide this capability:  \n  \n|Uses m_hAttribDC|Uses m_hDC|  \n|-----------------------|-----------------|  \n|[GetTextExtent](#cdc__gettextextent)|[GetOutputTextExtent](#cdc__getoutputtextextent)|  \n|[GetTabbedTextExtent](#cdc__gettabbedtextextent)|[GetOutputTabbedTextExtent](#cdc__getoutputtabbedtextextent)|  \n|[GetTextMetrics](#cdc__gettextmetrics)|[GetOutputTextMetrics](#cdc__getoutputtextmetrics)|  \n|[GetCharWidth](#cdc__getcharwidth)|[GetOutputCharWidth](#cdc__getoutputcharwidth)|  \n  \n For more information on `CDC`, see [Device Contexts](../../mfc/device-contexts.md).  \n  \n## Inheritance Hierarchy  \n [CObject](../../mfc/reference/cobject-class.md)  \n  \n `CDC`  \n  \n## Requirements  \n **Header:** afxwin.h  \n  \n##  <a name=\"cdc__abortdoc\"></a>  CDC::AbortDoc  \n Terminates the current print job and erases everything the application has written to the device since the last call to the [StartDoc](#cdc__startdoc) member function.  \n  \n```  \nint AbortDoc();\n```  \n  \n### Return Value  \n A value greater than or equal to 0 if successful, or a negative value if an error has occurred. The following list shows common error values and their meanings:  \n  \n- **SP_ERROR** General error.  \n  \n- **SP_OUTOFDISK** Not enough disk space is currently available for spooling, and no more space will become available.  \n  \n- **SP_OUTOFMEMORY** Not enough memory is available for spooling.  \n  \n- **SP_USERABORT** User terminated the job through the Print Manager.  \n  \n### Remarks  \n This member function replaces the `ABORTDOC` printer escape.  \n  \n **AbortDoc** should be used to terminate the following:  \n  \n-   Printing operations that do not specify an abort function using [SetAbortProc](#cdc__setabortproc).  \n  \n-   Printing operations that have not yet reached their first **NEWFRAME** or **NEXTBAND** escape call.  \n  \n If an application encounters a printing error or a canceled print operation, it must not attempt to terminate the operation by using either the [EndDoc](#cdc__enddoc) or **AbortDoc** member functions of class `CDC`. GDI automatically terminates the operation before returning the error value.  \n  \n If the application displays a dialog box to allow the user to cancel the print operation, it must call **AbortDoc** before destroying the dialog box.  \n  \n If Print Manager was used to start the print job, calling **AbortDoc** erases the entire spool job — the printer receives nothing. If Print Manager was not used to start the print job, the data may have been sent to the printer before **AbortDoc** was called. In this case, the printer driver would have reset the printer (when possible) and closed the print job.  \n  \n### Example  \n  See the example for [CDC::StartDoc](#cdc__startdoc).  \n  \n##  <a name=\"cdc__abortpath\"></a>  CDC::AbortPath  \n Closes and discards any paths in the device context.  \n  \n```  \nBOOL AbortPath();\n```  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n If there is an open path bracket in the device context, the path bracket is closed and the path is discarded. If there is a closed path in the device context, the path is discarded.  \n  \n##  <a name=\"cdc__addmetafilecomment\"></a>  CDC::AddMetaFileComment  \n Copies the comment from a buffer into a specified enhanced-format metafile.  \n  \n```  \nBOOL AddMetaFileComment(\n    UINT nDataSize,  \n    const BYTE* pCommentData);\n```  \n  \n### Parameters  \n *nDataSize*  \n Specifies the length of the comment buffer, in bytes.  \n  \n *pCommentData*  \n Points to the buffer that contains the comment.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n A comment may include any private information — for example, the source of the picture and the date it was created. A comment should begin with an application signature, followed by the data. Comments should not contain position-specific data. Position-specific data specifies the location of a record, and it should not be included because one metafile may be embedded within another metafile. This function can only be used with enhanced metafiles.  \n  \n##  <a name=\"cdc__alphablend\"></a>  CDC::AlphaBlend  \n Call this member function to display bitmaps that have transparent or semitransparent pixels.  \n  \n```  \nBOOL AlphaBlend(\n    int xDest,  \n    int yDest,  \n    int nDestWidth,  \n    int nDestHeight,  \n    CDC* pSrcDC,  \n    int xSrc,  \n    int ySrc,  \n    int nSrcWidth,  \n    int nSrcHeight,  \n    BLENDFUNCTION blend);\n```  \n  \n### Parameters  \n `xDest`  \n Specifies the x-coordinate, in logical units, of the upper-left corner of the destination rectangle.  \n  \n `yDest`  \n Specifies the y-coordinate, in logical units, of the upper-left corner of the destination rectangle.  \n  \n `nDestWidth`  \n Specifies the width, in logical units, of the destination rectangle.  \n  \n `nDestHeight`  \n Specifies the height, in logical units, of the destination rectangle.  \n  \n `pSrcDC`  \n A pointer to the source device context.  \n  \n `xSrc`  \n Specifies the x-coordinate, in logical units, of the upper-left corner of the source rectangle.  \n  \n `ySrc`  \n Specifies the y-coordinate, in logical units, of the upper-left corner of the source rectangle.  \n  \n `nSrcWidth`  \n Specifies the width, in logical units, of the source rectangle.  \n  \n `nSrcHeight`  \n Specifies the height, in logical units, of the source rectangle.  \n  \n *blend*  \n Specifies a [BLENDFUNCTION](http://msdn.microsoft.com/library/windows/desktop/dd183393) structure.  \n  \n### Return Value  \n **TRUE** if successful; otherwise **FALSE**.  \n  \n### Remarks  \n See [AlphaBlend](http://msdn.microsoft.com/library/windows/desktop/dd183351) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for more information.  \n  \n##  <a name=\"cdc__anglearc\"></a>  CDC::AngleArc  \n Draws a line segment and an arc.  \n  \n```  \nBOOL AngleArc(\n    int x,  \n    int y,  \n    int nRadius,  \n    float fStartAngle,  \n    float fSweepAngle);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the center of the circle.  \n  \n *y*  \n Specifies the logical y-coordinate of the center of the circle.  \n  \n *nRadius*  \n Specifies the radius of the circle in logical units. This value must be positive.  \n  \n *fStartAngle*  \n Specifies the starting angle in degrees relative to the x-axis.  \n  \n *fSweepAngle*  \n Specifies the sweep angle in degrees relative to the starting angle.  \n  \n### Return Value  \n Nonzero if successful; otherwise 0.  \n  \n### Remarks  \n The line segment is drawn from the current position to the beginning of the arc. The arc is drawn along the perimeter of a circle with the given radius and center. The length of the arc is defined by the given start and sweep angles.  \n  \n `AngleArc` moves the current position to the ending point of the arc. The arc drawn by this function may appear to be elliptical, depending on the current transformation and mapping mode. Before drawing the arc, this function draws the line segment from the current position to the beginning of the arc. The arc is drawn by constructing an imaginary circle with the specified radius around the specified center point. The starting point of the arc is determined by measuring counterclockwise from the x-axis of the circle by the number of degrees in the start angle. The ending point is similarly located by measuring counterclockwise from the starting point by the number of degrees in the sweep angle.  \n  \n If the sweep angle is greater than 360 degrees the arc is swept multiple times. This function draws lines by using the current pen. The figure is not filled.  \n  \n##  <a name=\"cdc__arc\"></a>  CDC::Arc  \n Draws an elliptical arc.  \n  \n```  \nBOOL Arc(\n    int x1,  \n    int y1,  \n    int x2,  \n    int y2,  \n    int x3,  \n    int y3,  \n    int x4,  \n    int y4);\n\n \nBOOL Arc(\n    LPCRECT lpRect,  \n    POINT ptStart,  \n    POINT ptEnd);\n```  \n  \n### Parameters  \n `x1`  \n Specifies the x-coordinate of the upper-left corner of the bounding rectangle (in logical units).  \n  \n `y1`  \n Specifies the y-coordinate of the upper-left corner of the bounding rectangle (in logical units).  \n  \n `x2`  \n Specifies the x-coordinate of the lower-right corner of the bounding rectangle (in logical units).  \n  \n `y2`  \n Specifies the y-coordinate of the lower-right corner of the bounding rectangle (in logical units).  \n  \n *x3*  \n Specifies the x-coordinate of the point that defines the arc's starting point (in logical units). This point does not have to lie exactly on the arc.  \n  \n `y3`  \n Specifies the y-coordinate of the point that defines the arc's starting point (in logical units). This point does not have to lie exactly on the arc.  \n  \n `x4`  \n Specifies the x-coordinate of the point that defines the arc's endpoint (in logical units). This point does not have to lie exactly on the arc.  \n  \n `y4`  \n Specifies the y-coordinate of the point that defines the arc's endpoint (in logical units). This point does not have to lie exactly on the arc.  \n  \n `lpRect`  \n Specifies the bounding rectangle (in logical units). You can pass either an `LPRECT` or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter.  \n  \n `ptStart`  \n Specifies the x- and y-coordinates of the point that defines the arc's starting point (in logical units). This point does not have to lie exactly on the arc. You can pass either a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter.  \n  \n `ptEnd`  \n Specifies the x- and y-coordinates of the point that defines the arc's ending point (in logical units). This point does not have to lie exactly on the arc. You can pass either a **POINT** structure or a `CPoint` object for this parameter.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The arc drawn by using the function is a segment of the ellipse defined by the specified bounding rectangle.  \n  \n The actual starting point of the arc is the point at which a ray drawn from the center of the bounding rectangle through the specified starting point intersects the ellipse. The actual ending point of the arc is the point at which a ray drawn from the center of the bounding rectangle through the specified ending point intersects the ellipse. The arc is drawn in a counterclockwise direction. Since an arc is not a closed figure, it is not filled. Both the width and height of the rectangle must be greater than 2 units and less than 32,767 units.  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]  \n  \n##  <a name=\"cdc__arcto\"></a>  CDC::ArcTo  \n Draws an elliptical arc.  \n  \n```  \nBOOL ArcTo(\n    int x1,  \n    int y1,  \n    int x2,  \n    int y2,  \n    int x3,  \n    int y3,  \n    int x4,  \n    int y4);\n\n \nBOOL ArcTo(\n    LPCRECT lpRect,  \n    POINT ptStart,  \n    POINT ptEnd);\n```  \n  \n### Parameters  \n `x1`  \n Specifies the x-coordinate of the upper-left corner of the bounding rectangle (in logical units).  \n  \n `y1`  \n Specifies the y-coordinate of the upper-left corner of the bounding rectangle (in logical units).  \n  \n `x2`  \n Specifies the x-coordinate of the lower-right corner of the bounding rectangle (in logical units).  \n  \n `y2`  \n Specifies the y-coordinate of the lower-right corner of the bounding rectangle (in logical units).  \n  \n *x3*  \n Specifies the x-coordinate of the point that defines the arc's starting point (in logical units). This point does not have to lie exactly on the arc.  \n  \n `y3`  \n Specifies the y-coordinate of the point that defines the arc's starting point (in logical units). This point does not have to lie exactly on the arc.  \n  \n `x4`  \n Specifies the x-coordinate of the point that defines the arc's endpoint (in logical units). This point does not have to lie exactly on the arc.  \n  \n `y4`  \n Specifies the y-coordinate of the point that defines the arc's endpoint (in logical units). This point does not have to lie exactly on the arc.  \n  \n `lpRect`  \n Specifies the bounding rectangle (in logical units). You can pass either a pointer to a [RECT](../../mfc/reference/rect-structure1.md) data structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter.  \n  \n `ptStart`  \n Specifies the x- and y-coordinates of the point that defines the arc's starting point (in logical units). This point does not have to lie exactly on the arc. You can pass either a [POINT](../../mfc/reference/point-structure1.md) data structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter.  \n  \n `ptEnd`  \n Specifies the x- and y-coordinates of the point that defines the arc's ending point (in logical units). This point does not have to lie exactly on the arc. You can pass either a **POINT** data structure or a `CPoint` object for this parameter.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n This function is similar to `CDC::Arc`, except that the current position is updated. The points ( `x1`, `y1`) and ( `x2`, `y2`) specify the bounding rectangle. An ellipse formed by the given bounding rectangle defines the curve of the arc. The arc extends counterclockwise (the default arc direction) from the point where it intersects the radial line from the center of the bounding rectangle to ( *x3*, `y3`). The arc ends where it intersects the radial line from the center of the bounding rectangle to ( `x4`, `y4`). If the starting point and ending point are the same, a complete ellipse is drawn.  \n  \n A line is drawn from the current position to the starting point of the arc. If no error occurs, the current position is set to the ending point of the arc. The arc is drawn using the current pen; it is not filled.  \n  \n##  <a name=\"cdc__attach\"></a>  CDC::Attach  \n Use this member function to attach an `hDC` to the `CDC` object.  \n  \n```  \nBOOL Attach(HDC hDC);\n```  \n  \n### Parameters  \n `hDC`  \n A Windows device context.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The `hDC` is stored in both `m_hDC`, the output device context, and in `m_hAttribDC`, the attribute device context.  \n  \n##  <a name=\"cdc__beginpath\"></a>  CDC::BeginPath  \n Opens a path bracket in the device context.  \n  \n```  \nBOOL BeginPath();\n```  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n After a path bracket is open, an application can begin calling GDI drawing functions to define the points that lie in the path. An application can close an open path bracket by calling the `EndPath` member function. When an application calls `BeginPath`, any previous paths are discarded.  \n  \n See [BeginPath](http://msdn.microsoft.com/library/windows/desktop/dd183363) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a list of the drawing functions that define points in a path.  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]  \n  \n##  <a name=\"cdc__bitblt\"></a>  CDC::BitBlt  \n Copies a bitmap from the source device context to this current device context.  \n  \n```  \nBOOL BitBlt(\n    int x,  \n    int y,  \n    int nWidth,  \n    int nHeight,  \n    CDC* pSrcDC,  \n    int xSrc,  \n    int ySrc,  \n    DWORD dwRop);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the upper-left corner of the destination rectangle.  \n  \n *y*  \n Specifies the logical y-coordinate of the upper-left corner of the destination rectangle.  \n  \n `nWidth`  \n Specifies the width (in logical units) of the destination rectangle and source bitmap.  \n  \n `nHeight`  \n Specifies the height (in logical units) of the destination rectangle and source bitmap.  \n  \n `pSrcDC`  \n Pointer to a `CDC` object that identifies the device context from which the bitmap will be copied. It must be **NULL** if *dwRop* specifies a raster operation that does not include a source.  \n  \n `xSrc`  \n Specifies the logical x-coordinate of the upper-left corner of the source bitmap.  \n  \n `ySrc`  \n Specifies the logical y-coordinate of the upper-left corner of the source bitmap.  \n  \n *dwRop*  \n Specifies the raster operation to be performed. Raster-operation codes define how the GDI combines colors in output operations that involve a current brush, a possible source bitmap, and a destination bitmap. See [BitBlt](http://msdn.microsoft.com/library/windows/desktop/dd183370) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a list of the raster-operation codes for *dwRop* and their descriptions  \n  \n For a complete list of raster-operation codes, see [About Raster Operation Codes](http://msdn.microsoft.com/library/windows/desktop/dd162892) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The application can align the windows or client areas on byte boundaries to ensure that the `BitBlt` operations occur on byte-aligned rectangles. (Set the **CS_BYTEALIGNWINDOW** or **CS_BYTEALIGNCLIENT** flags when you register the window classes.)  \n  \n `BitBlt` operations on byte-aligned rectangles are considerably faster than `BitBlt` operations on rectangles that are not byte aligned. If you want to specify class styles such as byte-alignment for your own device context, you will have to register a window class rather than relying on the Microsoft Foundation classes to do it for you. Use the global function [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).  \n  \n GDI transforms `nWidth` and `nHeight`, once by using the destination device context, and once by using the source device context. If the resulting extents do not match, GDI uses the Windows `StretchBlt` function to compress or stretch the source bitmap as necessary.  \n  \n If destination, source, and pattern bitmaps do not have the same color format, the `BitBlt` function converts the source and pattern bitmaps to match the destination. The foreground and background colors of the destination bitmap are used in the conversion.  \n  \n When the `BitBlt` function converts a monochrome bitmap to color, it sets white bits (1) to the background color and black bits (0) to the foreground color. The foreground and background colors of the destination device context are used. To convert color to monochrome, `BitBlt` sets pixels that match the background color to white and sets all other pixels to black. `BitBlt` uses the foreground and background colors of the color device context to convert from color to monochrome.  \n  \n Note that not all device contexts support `BitBlt`. To check whether a given device context does support `BitBlt`, use the `GetDeviceCaps` member function and specify the **RASTERCAPS** index.  \n  \n### Example  \n  See the example for [CDC::CreateCompatibleDC](#cdc__createcompatibledc).  \n  \n##  <a name=\"cdc__cdc\"></a>  CDC::CDC  \n Constructs a `CDC` object.  \n  \n```  \nCDC();\n```  \n  \n##  <a name=\"cdc__chord\"></a>  CDC::Chord  \n Draws a chord (a closed figure bounded by the intersection of an ellipse and a line segment).  \n  \n```  \nBOOL Chord(\n    int x1,  \n    int y1,  \n    int x2,  \n    int y2,  \n    int x3,  \n    int y3,  \n    int x4,  \n    int y4);\n\n \nBOOL Chord(\n    LPCRECT lpRect,  \n    POINT ptStart,  \n    POINT ptEnd);\n```  \n  \n### Parameters  \n `x1`  \n Specifies the x-coordinate of the upper-left corner of the chord's bounding rectangle (in logical units).  \n  \n `y1`  \n Specifies the y-coordinate of the upper-left corner of the chord's bounding rectangle (in logical units).  \n  \n `x2`  \n Specifies the x-coordinate of the lower-right corner of the chord's bounding rectangle (in logical units).  \n  \n `y2`  \n Specifies the y-coordinate of the lower-right corner of the chord's bounding rectangle (in logical units).  \n  \n *x3*  \n Specifies the x-coordinate of the point that defines the chord's starting point (in logical units).  \n  \n `y3`  \n Specifies the y-coordinate of the point that defines the chord's starting point (in logical units).  \n  \n `x4`  \n Specifies the x-coordinate of the point that defines the chord's endpoint (in logical units).  \n  \n `y4`  \n Specifies the y-coordinate of the point that defines the chord's endpoint (in logical units).  \n  \n `lpRect`  \n Specifies the bounding rectangle (in logical units). You can pass either a `LPRECT` or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter.  \n  \n `ptStart`  \n Specifies the x- and y-coordinates of the point that defines the chord's starting point (in logical units). This point does not have to lie exactly on the chord. You can pass either a **POINT** structure or a `CPoint` object for this parameter.  \n  \n `ptEnd`  \n Specifies the x- and y-coordinates of the point that defines the chord's ending point (in logical units). This point does not have to lie exactly on the chord. You can pass either a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The ( `x1`, `y1`) and ( `x2`, `y2`) parameters specify the upper-left and lower-right corners, respectively, of a rectangle bounding the ellipse that is part of the chord. The ( *x3*, `y3`) and ( `x4`, `y4`) parameters specify the endpoints of a line that intersects the ellipse. The chord is drawn by using the selected pen and filled by using the selected brush.  \n  \n The figure drawn by the `Chord` function extends up to, but does not include the right and bottom coordinates. This means that the height of the figure is `y2` – `y1` and the width of the figure is `x2` – `x1`.  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]  \n  \n##  <a name=\"cdc__closefigure\"></a>  CDC::CloseFigure  \n Closes an open figure in a path.  \n  \n```  \nBOOL CloseFigure();\n```  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The function closes the figure by drawing a line from the current position to the first point of the figure (usually, the point specified by the most recent call to the `MoveTo` member function) and connects the lines by using the line join style. If a figure is closed by using the `LineTo` member function instead of `CloseFigure`, end caps are used to create the corner instead of a join. `CloseFigure` should only be called if there is an open path bracket in the device context.  \n  \n A figure in a path is open unless it is explicitly closed by using this function. (A figure can be open even if the current point and the starting point of the figure are the same.) Any line or curve added to the path after `CloseFigure` starts a new figure.  \n  \n##  <a name=\"cdc__createcompatibledc\"></a>  CDC::CreateCompatibleDC  \n Creates a memory device context that is compatible with the device specified by `pDC`.  \n  \n```  \nBOOL CreateCompatibleDC(CDC* pDC);\n```  \n  \n### Parameters  \n `pDC`  \n A pointer to a device context. If `pDC` is **NULL**, the function creates a memory device context that is compatible with the system display.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n A memory device context is a block of memory that represents a display surface. It can be used to prepare images in memory before copying them to the actual device surface of the compatible device.  \n  \n When a memory device context is created, GDI automatically selects a 1-by-1 monochrome stock bitmap for it. GDI output functions can be used with a memory device context only if a bitmap has been created and selected into that context.  \n  \n This function can only be used to create compatible device contexts for devices that support raster operations. See the [CDC::BitBlt](#cdc__bitblt) member function for information regarding bit-block transfers between device contexts. To determine whether a device context supports raster operations, see the **RC_BITBLT** raster capability in the member function `CDC::GetDeviceCaps`.  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]  \n  \n##  <a name=\"cdc__createdc\"></a>  CDC::CreateDC  \n Creates a device context for the specified device.  \n  \n```  \nBOOL CreateDC(\n    LPCTSTR lpszDriverName,  \n    LPCTSTR lpszDeviceName,  \n    LPCTSTR lpszOutput,  \n    const void* lpInitData);\n```  \n  \n### Parameters  \n `lpszDriverName`  \n Points to a null-terminated string that specifies the filename (without extension) of the device driver (for example, \"EPSON\"). You can also pass a `CString` object for this parameter.  \n  \n `lpszDeviceName`  \n Points to a null-terminated string that specifies the name of the specific device to be supported (for example, \"EPSON FX-80\"). The `lpszDeviceName` parameter is used if the module supports more than one device. You can also pass a `CString` object for this parameter.  \n  \n `lpszOutput`  \n Points to a null-terminated string that specifies the file or device name for the physical output medium (file or output port). You can also pass a `CString` object for this parameter.  \n  \n `lpInitData`  \n Points to a `DEVMODE` structure containing device-specific initialization data for the device driver. The Windows **DocumentProperties** function retrieves this structure filled in for a given device. The `lpInitData` parameter must be **NULL** if the device driver is to use the default initialization (if any) specified by the user through the Control Panel.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The PRINT.H header file is required if the [DEVMODE](http://msdn.microsoft.com/library/windows/desktop/dd183565) structure is used.  \n  \n Device names follow these conventions: an ending colon (:) is recommended, but optional. Windows strips the terminating colon so that a device name ending with a colon is mapped to the same port as the same name without a colon. The driver and port names must not contain leading or trailing spaces. GDI output functions cannot be used with information contexts.  \n  \n##  <a name=\"cdc__createic\"></a>  CDC::CreateIC  \n Creates an information context for the specified device.  \n  \n```  \nBOOL CreateIC(\n    LPCTSTR lpszDriverName,  \n    LPCTSTR lpszDeviceName,  \n    LPCTSTR lpszOutput,  \n    const void* lpInitData);\n```  \n  \n### Parameters  \n `lpszDriverName`  \n Points to a null-terminated string that specifies the filename (without extension) of the device driver (for example, \"EPSON\"). You can pass a `CString` object for this parameter.  \n  \n `lpszDeviceName`  \n Points to a null-terminated string that specifies the name of the specific device to be supported (for example, \"EPSON FX-80\"). The `lpszDeviceName` parameter is used if the module supports more than one device. You can pass a `CString` object for this parameter.  \n  \n `lpszOutput`  \n Points to a null-terminated string that specifies the file or device name for the physical output medium (file or port). You can pass a `CString` object for this parameter.  \n  \n `lpInitData`  \n Points to device-specific initialization data for the device driver. The `lpInitData` parameter must be **NULL** if the device driver is to use the default initialization (if any) specified by the user through the Control Panel. See `CreateDC` for the data format for device-specific initialization.  \n  \n### Return Value  \n Nonzero if successful; otherwise 0.  \n  \n### Remarks  \n The information context provides a fast way to get information about the device without creating a device context.  \n  \n Device names follow these conventions: an ending colon (:) is recommended, but optional. Windows strips the terminating colon so that a device name ending with a colon is mapped to the same port as the same name without a colon. The driver and port names must not contain leading or trailing spaces. GDI output functions cannot be used with information contexts.  \n  \n##  <a name=\"cdc__deletedc\"></a>  CDC::DeleteDC  \n In general, do not call this function; the destructor will do it for you.  \n  \n```  \nBOOL DeleteDC();\n```  \n  \n### Return Value  \n Nonzero if the function completed successfully; otherwise 0.  \n  \n### Remarks  \n The `DeleteDC` member function deletes the Windows device contexts that are associated with `m_hDC` in the current `CDC` object. If this `CDC` object is the last active device context for a given device, the device is notified and all storage and system resources used by the device are released.  \n  \n An application should not call `DeleteDC` if objects have been selected into the device context. Objects must first be selected out of the device context before it is deleted.  \n  \n An application must not delete a device context whose handle was obtained by calling [CWnd::GetDC](../../mfc/reference/cwnd-class.md#cwnd__getdc). Instead, it must call [CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#cwnd__releasedc) to free the device context. The [CClientDC](../../mfc/reference/cclientdc-class.md) and [CWindowDC](../../mfc/reference/cwindowdc-class.md) classes are provided to wrap this functionality.  \n  \n The `DeleteDC` function is generally used to delete device contexts created with [CreateDC](#cdc__createdc), [CreateIC](#cdc__createic), or [CreateCompatibleDC](#cdc__createcompatibledc).  \n  \n### Example  \n  See the example for [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#cprintdialog__getprinterdc).  \n  \n##  <a name=\"cdc__deletetempmap\"></a>  CDC::DeleteTempMap  \n Called automatically by the `CWinApp` idle-time handler, `DeleteTempMap` deletes any temporary `CDC` objects created by `FromHandle`, but does not destroy the device context handles ( `hDC`s) temporarily associated with the `CDC` objects.  \n  \n```  \nstatic void PASCAL DeleteTempMap();\n```  \n  \n##  <a name=\"cdc__detach\"></a>  CDC::Detach  \n Call this function to detach `m_hDC` (the output device context) from the `CDC` object and set both `m_hDC` and `m_hAttribDC` to **NULL**.  \n  \n```  \nHDC Detach();\n```  \n  \n### Return Value  \n A Windows device context.  \n  \n##  <a name=\"cdc__dptohimetric\"></a>  CDC::DPtoHIMETRIC  \n Use this function when you give **HIMETRIC** sizes to OLE, converting pixels to **HIMETRIC**.  \n  \n```  \nvoid DPtoHIMETRIC(LPSIZE lpSize) const;\n\n \n```  \n  \n### Parameters  \n `lpSize`  \n Points to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure or [CSize](../../atl-mfc-shared/reference/csize-class.md) object.  \n  \n### Remarks  \n If the mapping mode of the device context object is `MM_LOENGLISH`, `MM_HIENGLISH`, `MM_LOMETRIC`, or `MM_HIMETRIC`, then the conversion is based on the number of pixels in the physical inch. If the mapping mode is one of the other non-constrained modes (e.g., `MM_TEXT`), then the conversion is based on the number of pixels in the logical inch.  \n  \n##  <a name=\"cdc__dptolp\"></a>  CDC::DPtoLP  \n Converts device units into logical units.  \n  \n```  \nvoid DPtoLP(\n    LPPOINT lpPoints,  \n    int nCount = 1) const;\n\n \n \nvoid DPtoLP(\n    LPRECT lpRect) const;\n\n \n \nvoid DPtoLP(\n    LPSIZE lpSize) const;\n\n \n```  \n  \n### Parameters  \n `lpPoints`  \n Points to an array of [POINT](../../mfc/reference/point-structure1.md) structures or [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objects.  \n  \n `nCount`  \n The number of points in the array.  \n  \n `lpRect`  \n Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or [CRect](../../atl-mfc-shared/reference/crect-class.md) object. This parameter is used for the simple case of converting one rectangle from device points to logical points.  \n  \n `lpSize`  \n Points to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure or [CSize](../../atl-mfc-shared/reference/csize-class.md) object.  \n  \n### Remarks  \n The function maps the coordinates of each point, or dimension of a size, from the device coordinate system into GDI's logical coordinate system. The conversion depends on the current mapping mode and the settings of the origins and extents for the device's window and viewport.  \n  \n##  <a name=\"cdc__draw3drect\"></a>  CDC::Draw3dRect  \n Call this member function to draw a three-dimensional rectangle.  \n  \n```  \nvoid Draw3dRect(\n    LPCRECT lpRect,  \n    COLORREF clrTopLeft,  \n    COLORREF clrBottomRight);\n\n \nvoid Draw3dRect(\n    int x,  \n    int y,  \n    int cx,  \n    int cy,  \n    COLORREF clrTopLeft,  \n    COLORREF clrBottomRight);\n```  \n  \n### Parameters  \n `lpRect`  \n Specifies the bounding rectangle (in logical units). You can pass either a pointer to a [RECT](../../mfc/reference/rect-structure1.md) structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter.  \n  \n *clrTopLeft*  \n Specifies the color of the top and left sides of the three-dimensional rectangle.  \n  \n `clrBottomRight`  \n Specifies the color of the bottom and right sides of the three-dimensional rectangle.  \n  \n *x*  \n Specifies the logical x-coordinate of the upper-left corner of the three-dimensional rectangle.  \n  \n *y*  \n Specifies the logical y-coordinate of the upper-left corner of the three-dimensional rectangle.  \n  \n cx  \n Specifies the width of the three-dimensional rectangle.  \n  \n cy  \n Specifies the height of the three-dimensional rectangle.  \n  \n### Remarks  \n The rectangle will be drawn with the top and left sides in the color specified by *clrTopLeft* and the bottom and right sides in the color specified by `clrBottomRight`.  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]  \n  \n##  <a name=\"cdc__drawdragrect\"></a>  CDC::DrawDragRect  \n Call this member function repeatedly to redraw a drag rectangle.  \n  \n```  \nvoid DrawDragRect(\n    LPCRECT lpRect,  \n    SIZE size,  \n    LPCRECT lpRectLast,  \n    SIZE sizeLast,  \n    CBrush* pBrush = NULL,  \n    CBrush* pBrushLast = NULL);\n```  \n  \n### Parameters  \n `lpRect`  \n Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object that specifies the logical coordinates of a rectangle — in this case, the end position of the rectangle being redrawn.  \n  \n `size`  \n Specifies the displacement from the top-left corner of the outer border to the top-left corner of the inner border (that is, the thickness of the border) of a rectangle.  \n  \n `lpRectLast`  \n Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object that specifies the logical coordinates of the position of a rectangle — in this case, the original position of the rectangle being redrawn.  \n  \n *sizeLast*  \n Specifies the displacement from the top-left corner of the outer border to the top-left corner of the inner border (that is, the thickness of the border) of the original rectangle being redrawn.  \n  \n `pBrush`  \n Pointer to a brush object. Set to **NULL** to use the default halftone brush.  \n  \n *pBrushLast*  \n Pointer to the last brush object used. Set to **NULL** to use the default halftone brush.  \n  \n### Remarks  \n Call it in a loop as you sample mouse position, in order to give visual feedback. When you call `DrawDragRect`, the previous rectangle is erased and a new one is drawn. For example, as the user drags a rectangle across the screen, `DrawDragRect` will erase the original rectangle and redraw a new one in its new position. By default, `DrawDragRect` draws the rectangle by using a halftone brush to eliminate flicker and to create the appearance of a smoothly moving rectangle.  \n  \n The first time you call `DrawDragRect`, the `lpRectLast` parameter should be **NULL**.  \n  \n##  <a name=\"cdc__drawedge\"></a>  CDC::DrawEdge  \n Call this member function to draw the edges of a rectangle of the specified type and style.  \n  \n```  \nBOOL DrawEdge(\n    LPRECT lpRect,  \n    UINT nEdge,  \n    UINT nFlags);\n```  \n  \n### Parameters  \n `lpRect`  \n A pointer to a **RECT** structure that contains the logical coordinates of the rectangle.  \n  \n *nEdge*  \n Specifies the type of inner and outer edge to draw. This parameter must be a combination of one inner-border flag and one outer-border flag. See [DrawEdge](http://msdn.microsoft.com/library/windows/desktop/dd162477) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a table of the parameter's types.  \n  \n `nFlags`  \n The flags that specify the type of border to be drawn. See `DrawEdge` in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a table of the parameter's values. For diagonal lines, the **BF_RECT** flags specify the end point of the vector bounded by the rectangle parameter.  \n  \n### Return Value  \n Nonzero if successful; otherwise 0.  \n  \n##  <a name=\"cdc__drawescape\"></a>  CDC::DrawEscape  \n Accesses drawing capabilities of a video display that are not directly available through the graphics device interface (GDI).  \n  \n```  \nint DrawEscape(\n    int nEscape,  \n    int nInputSize,  \n    LPCSTR lpszInputData);\n```  \n  \n### Parameters  \n `nEscape`  \n Specifies the escape function to be performed.  \n  \n `nInputSize`  \n Specifies the number of bytes of data pointed to by the `lpszInputData` parameter.  \n  \n `lpszInputData`  \n Points to the input structure required for the specified escape.  \n  \n### Return Value  \n Specifies the outcome of the function. Greater than zero if successful, except for the **QUERYESCSUPPORT** draw escape, which checks for implementation only; or zero if the escape is not implemented; or less than zero if an error occurred.  \n  \n### Remarks  \n When an application calls `DrawEscape`, the data identified by `nInputSize` and `lpszInputData` is passed directly to the specified display driver.  \n  \n##  <a name=\"cdc__drawfocusrect\"></a>  CDC::DrawFocusRect  \n Draws a rectangle in the style used to indicate that the rectangle has the focus.  \n  \n```  \nvoid DrawFocusRect(LPCRECT lpRect);\n```  \n  \n### Parameters  \n `lpRect`  \n Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object that specifies the logical coordinates of the rectangle to be drawn.  \n  \n### Remarks  \n Since this is a Boolean XOR function, calling this function a second time with the same rectangle removes the rectangle from the display. The rectangle drawn by this function cannot be scrolled. To scroll an area containing a rectangle drawn by this function, first call `DrawFocusRect` to remove the rectangle from the display, then scroll the area, and then call `DrawFocusRect` again to draw the rectangle in the new position.  \n  \n> [!CAUTION]\n> `DrawFocusRect` works only in `MM_TEXT` mode. In other modes, this function does not draw the focus rectangle correctly, but it does not return error values.  \n  \n##  <a name=\"cdc__drawframecontrol\"></a>  CDC::DrawFrameControl  \n Call this member function to draw a frame control of the specified type and style.  \n  \n```  \nBOOL DrawFrameControl(\n    LPRECT lpRect,  \n    UINT nType,  \n    UINT nState);\n```  \n  \n### Parameters  \n `lpRect`  \n A pointer to a **RECT** structure that contains the logical coordinates of the rectangle.  \n  \n `nType`  \n Specifies the type of frame control to draw. See the *uType* parameter in [DrawFrameControl](http://msdn.microsoft.com/library/windows/desktop/dd162480) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a list of this parameter's possible values.  \n  \n `nState`  \n Specifies the initial state of the frame control. Can be one or more of the values described for the *uState* parameter in `DrawFrameControl` in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. Use the `nState` value **DFCS_ADJUSTRECT** to adjust the bounding rectangle to exclude the surrounding edge of the push button.  \n  \n### Return Value  \n Nonzero if successful; otherwise 0.  \n  \n### Remarks  \n In several cases, `nState` depends on the `nType` parameter. The following list shows the relationship between the four `nType` values and `nState`:  \n  \n- **DFC_BUTTON**  \n  \n    - **DFCS_BUTTON3STATE** Three-state button  \n  \n    - **DFCS_BUTTONCHECK** Check box  \n  \n    - **DFCS_BUTTONPUSH** Push button  \n  \n    - **DFCS_BUTTONRADIO** Radio button  \n  \n    - **DFCS_BUTTONRADIOIMAGE** Image for radio button (nonsquare needs image)  \n  \n    - **DFCS_BUTTONRADIOMASK** Mask for radio button (nonsquare needs mask)  \n  \n- **DFC_CAPTION**  \n  \n    - **DFCS_CAPTIONCLOSE** Close button  \n  \n    - **DFCS_CAPTIONHELP** Help button  \n  \n    - **DFCS_CAPTIONMAX** Maximize button  \n  \n    - **DFCS_CAPTIONMIN** Minimize button  \n  \n    - **DFCS_CAPTIONRESTORE** Restore button  \n  \n- **DFC_MENU**  \n  \n    - **DFCS_MENUARROW** Submenu arrow  \n  \n    - **DFCS_MENUBULLET** Bullet  \n  \n    - **DFCS_MENUCHECK** Check mark  \n  \n- **DFC_SCROLL**  \n  \n    - **DFCS_SCROLLCOMBOBOX** Combo box scroll bar  \n  \n    - **DFCS_SCROLLDOWN** Down arrow of scroll bar  \n  \n    - **DFCS_SCROLLLEFT** Left arrow of scroll bar  \n  \n    - **DFCS_SCROLLRIGHT** Right arrow of scroll bar  \n  \n    - **DFCS_SCROLLSIZEGRIP** Size grip in bottom-right corner of window  \n  \n    - **DFCS_SCROLLUP** Up arrow of scroll bar  \n  \n### Example  \n This code draws the size gripper in the bottom-right corner of your window. It's appropriate for the `OnPaint` handler of a dialog box, which has no styles and normally doesn't contain other controls (like a status bar) that may give it a size gripper.  \n  \n [!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]  \n  \n##  <a name=\"cdc__drawicon\"></a>  CDC::DrawIcon  \n Draws an icon on the device represented by the current `CDC` object.  \n  \n```  \nBOOL DrawIcon(\n    int x,  \n    int y,  \n    HICON hIcon);\n\n \nBOOL DrawIcon(\n    POINT point,  \n    HICON hIcon);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the upper-left corner of the icon.  \n  \n *y*  \n Specifies the logical y-coordinate of the upper-left corner of the icon.  \n  \n `hIcon`  \n Identifies the handle of the icon to be drawn.  \n  \n `point`  \n Specifies the logical x- and y-coordinates of the upper-left corner of the icon. You can pass a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter.  \n  \n### Return Value  \n Nonzero if the function completed successfully; otherwise 0.  \n  \n### Remarks  \n The function places the icon's upper-left corner at the location specified by *x* and *y*. The location is subject to the current mapping mode of the device context.  \n  \n The icon resource must have been previously loaded by using the functions `CWinApp::LoadIcon`, `CWinApp::LoadStandardIcon`, or `CWinApp::LoadOEMIcon`. The `MM_TEXT` mapping mode must be selected prior to using this function.  \n  \n### Example  \n  See the example for [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#cwnd__isiconic).  \n  \n##  <a name=\"cdc__drawstate\"></a>  CDC::DrawState  \n Call this member function to display an image and apply a visual effect to indicate a state, such as a disabled or default state.  \n  \n> [!NOTE]\n>  For all `nFlag` states except **DSS_NORMAL**, the image is converted to monochrome before the visual effect is applied.  \n  \n```  \nBOOL DrawState(\n    CPoint pt,  \n    CSize size,  \n    HBITMAP hBitmap,  \n    UINT nFlags,  \n    HBRUSH hBrush = NULL);\n\n \nBOOL DrawState(\n    CPoint pt,  \n    CSize size,  \n    CBitmap* pBitmap,  \n    UINT nFlags,  \n    CBrush* pBrush = NULL);\n\n \nBOOL DrawState(\n    CPoint pt,  \n    CSize size,  \n    HICON hIcon,  \n    UINT nFlags,  \n    HBRUSH hBrush = NULL);\n\n \nBOOL DrawState(\n    CPoint pt,  \n    CSize size,  \n    HICON hIcon,  \n    UINT nFlags,  \n    CBrush* pBrush = NULL);\n\n \nBOOL DrawState(\n    CPoint pt,  \n    CSize size,  \n    LPCTSTR lpszText,  \n    UINT nFlags,  \n    BOOL bPrefixText = TRUE,  \n    int nTextLen = 0,  \n    HBRUSH hBrush = NULL);\n\n \nBOOL DrawState(\n    CPoint pt,  \n    CSize size,  \n    LPCTSTR lpszText,  \n    UINT nFlags,  \n    BOOL bPrefixText = TRUE,  \n    int nTextLen = 0,  \n    CBrush* pBrush = NULL);\n\n \nBOOL DrawState(\n    CPoint pt,  \n    CSize size,  \n    DRAWSTATEPROC lpDrawProc,  \n    LPARAM lData,  \n    UINT nFlags,  \n    HBRUSH hBrush = NULL);\n\n \nBOOL DrawState(\n    CPoint pt,  \n    CSize size,  \n    DRAWSTATEPROC lpDrawProc,  \n    LPARAM lData,  \n    UINT nFlags,  \n    CBrush* pBrush = NULL);\n```  \n  \n### Parameters  \n `pt`  \n Specifies the location of the image.  \n  \n `size`  \n Specifies the size of the image.  \n  \n `hBitmap`  \n A handle to a bitmap.  \n  \n `nFlags`  \n Flags that specify the image type and state. See [DrawState](http://msdn.microsoft.com/library/windows/desktop/dd162496) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for the possible `nFlags` types and states.  \n  \n `hBrush`  \n A handle to a brush.  \n  \n `pBitmap`  \n A pointer to a CBitmap object.  \n  \n `pBrush`  \n A pointer to a CBrush object.  \n  \n `hIcon`  \n A handle to an icon.  \n  \n `lpszText`  \n A pointer to text.  \n  \n *bPrefixText*  \n Text that may contain an accelerator mnemonic. The `lData` parameter specifies the address of the string, and the `nTextLen` parameter specifies the length. If `nTextLen` is 0, the string is assumed to be null-terminated.  \n  \n `nTextLen`  \n Length of the text string pointed to by `lpszText`. If `nTextLen` is 0, the string is assumed to be null-terminated.  \n  \n *lpDrawProc*  \n A pointer to a callback function used to render an image. This parameter is required if the image type in `nFlags` is **DST_COMPLEX**. It is optional and can be **NULL** if the image type is **DST_TEXT**. For all other image types, this parameter is ignored. For more information about the callback function, see the [DrawStateProc](http://msdn.microsoft.com/library/windows/desktop/dd162497) function in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n `lData`  \n Specifies information about the image. The meaning of this parameter depends on the image type.  \n  \n### Return Value  \n Nonzero if successful; otherwise 0.  \n  \n##  <a name=\"cdc__drawtext\"></a>  CDC::DrawText  \n Call this member function to format text in the given rectangle. To specify additional formatting options, use [CDC::DrawTextEx](#cdc__drawtextex).  \n  \n```  \nvirtual int DrawText(\n    LPCTSTR lpszString,  \n    int nCount,  \n    LPRECT lpRect,  \n    UINT nFormat);\n\n \nint DrawText(\n    const CString& str,  \n    LPRECT lpRect,  \n    UINT nFormat);\n```  \n  \n### Parameters  \n `lpszString`  \n Points to the string to be drawn. If `nCount` is –1, the string must be null-terminated.  \n  \n `nCount`  \n Specifies the number of chars in the string. If `nCount` is –1, then `lpszString` is assumed to be a long pointer to a null-terminated string and `DrawText` computes the character count automatically.  \n  \n `lpRect`  \n Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or [CRect](../../atl-mfc-shared/reference/crect-class.md) object that contains the rectangle (in logical coordinates) in which the text is to be formatted.  \n  \n `str`  \n A [CString](../../atl-mfc-shared/reference/cstringt-class.md) object that contains the specified characters to be drawn.  \n  \n `nFormat`  \n Specifies the method of formatting the text. It can be any combination of the values described for the `uFormat` parameter in [DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. (combine using the bitwise OR operator):  \n  \n> [!NOTE]\n>  Some `uFormat` flag combinations can cause the passed string to be modified. Using **DT_MODIFYSTRING** with either **DT_END_ELLIPSIS** or **DT_PATH_ELLIPSIS** may cause the string to be modified, causing an assertion in the `CString` override. The values `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, and `DT_NOPREFIX` cannot be used with the `DT_TABSTOP` value.  \n  \n### Return Value  \n The height of the text if the function is successful.  \n  \n### Remarks  \n It formats text by expanding tabs into appropriate spaces, aligning text to the left, right, or center of the given rectangle, and breaking text into lines that fit within the given rectangle. The type of formatting is specified by `nFormat`.  \n  \n This member function uses the device context's selected font, text color, and background color to draw the text. Unless the `DT_NOCLIP` format is used, `DrawText` clips the text so that the text does not appear outside the given rectangle. All formatting is assumed to have multiple lines unless the `DT_SINGLELINE` format is given.  \n  \n If the selected font is too large for the specified rectangle, the `DrawText` member function does not attempt to substitute a smaller font.  \n  \n If the `DT_CALCRECT` flag is specified, the rectangle specified by `lpRect` will be updated to reflect the width and height needed to draw the text.  \n  \n If the **TA_UPDATECP** text-alignment flag has been set (see [CDC::SetTextAlign](#cdc__settextalign)), `DrawText` will display text starting at the current position, rather than at the left of the given rectangle. `DrawText` will not wrap text when the **TA_UPDATECP** flag has been set (that is, the `DT_WORDBREAK` flag will have no effect).  \n  \n The text color may be set by [CDC::SetTextColor](#cdc__settextcolor).  \n  \n##  <a name=\"cdc__drawtextex\"></a>  CDC::DrawTextEx  \n Formats text in the given rectangle.  \n  \n```  \nvirtual int DrawTextEx(\n    LPTSTR lpszString,  \n    int nCount,  \n    LPRECT lpRect,  \n    UINT nFormat,\n    LPDRAWTEXTPARAMS lpDTParams);\n\n \nint DrawTextEx(\n    const CString& str,  \n    LPRECT lpRect,  \n    UINT nFormat,\n    LPDRAWTEXTPARAMS lpDTParams);\n```  \n  \n### Parameters  \n `lpszString`  \n Points to the string to be drawn. If `nCount` is –1, the string must be null terminated.  \n  \n `nCount`  \n Specifies the number of chars in the string. If `nCount` is –1, then `lpszString` is assumed to be a long pointer to a null-terminated string and `DrawText` computes the character count automatically.  \n  \n `lpRect`  \n Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or [CRect](../../atl-mfc-shared/reference/crect-class.md) object that contains the rectangle (in logical coordinates) in which the text is to be formatted.  \n  \n `str`  \n A [CString](../../atl-mfc-shared/reference/cstringt-class.md) object that contains the specified characters to be drawn.  \n  \n `nFormat`  \n Specifies the method of formatting the text. It can be any combination of the values described for the `uFormat` parameter in [DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. (Combine using the bitwise `OR` operator):  \n  \n> [!NOTE]\n>  Some `uFormat` flag combinations can cause the passed string to be modified. Using **DT_MODIFYSTRING** with either **DT_END_ELLIPSIS** or **DT_PATH_ELLIPSIS** may cause the string to be modified, causing an assertion in the `CString` override. The values `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, and `DT_NOPREFIX` cannot be used with the `DT_TABSTOP` value.  \n  \n `lpDTParams`  \n Pointer to a [DRAWTEXTPARAMS](http://msdn.microsoft.com/library/windows/desktop/dd162500) structure that specifies additional formatting options. This parameter can be **NULL**.  \n  \n### Remarks  \n It formats text by expanding tabs into appropriate spaces, aligning text to the left, right, or center of the given rectangle, and breaking text into lines that fit within the given rectangle. The type of formatting is specified by `nFormat` and `lpDTParams`. For more information, see [CDC::DrawText](#cdc__drawtext) and [DrawTextEx](http://msdn.microsoft.com/library/windows/desktop/dd162499) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n The text color may be set by [CDC::SetTextColor](#cdc__settextcolor).  \n  \n##  <a name=\"cdc__ellipse\"></a>  CDC::Ellipse  \n Draws an ellipse.  \n  \n```  \nBOOL Ellipse(\n    int x1,  \n    int y1,  \n    int x2,  \n    int y2);\n\n \nBOOL Ellipse(\n    LPCRECT lpRect);\n```  \n  \n### Parameters  \n `x1`  \n Specifies the logical x-coordinate of the upper-left corner of the ellipse's bounding rectangle.  \n  \n `y1`  \n Specifies the logical y-coordinate of the upper-left corner of the ellipse's bounding rectangle.  \n  \n `x2`  \n Specifies the logical x-coordinate of the lower-right corner of the ellipse's bounding rectangle.  \n  \n `y2`  \n Specifies the logical y-coordinate of the lower-right corner of the ellipse's bounding rectangle.  \n  \n `lpRect`  \n Specifies the ellipse's bounding rectangle. You can also pass a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The center of the ellipse is the center of the bounding rectangle specified by `x1`, `y1`, `x2`, and `y2`, or `lpRect`. The ellipse is drawn with the current pen, and its interior is filled with the current brush.  \n  \n The figure drawn by this function extends up to, but does not include, the right and bottom coordinates. This means that the height of the figure is `y2` – `y1` and the width of the figure is `x2` – `x1`.  \n  \n If either the width or the height of the bounding rectangle is 0, no ellipse is drawn.  \n  \n##  <a name=\"cdc__enddoc\"></a>  CDC::EndDoc  \n Ends a print job started by a call to the [StartDoc](#cdc__startdoc) member function.  \n  \n```  \nint EndDoc();\n```  \n  \n### Return Value  \n Greater than or equal to 0 if the function is successful, or a negative value if an error occurred.  \n  \n### Remarks  \n This member function replaces the **ENDDOC** printer escape, and should be called immediately after finishing a successful print job.  \n  \n If an application encounters a printing error or a canceled print operation, it must not attempt to terminate the operation by using either `EndDoc` or [AbortDoc](#cdc__abortdoc). GDI automatically terminates the operation before returning the error value.  \n  \n This function should not be used inside metafiles.  \n  \n### Example  \n  See the example for [CDC::StartDoc](#cdc__startdoc).  \n  \n##  <a name=\"cdc__endpage\"></a>  CDC::EndPage  \n Informs the device that the application has finished writing to a page.  \n  \n```  \nint EndPage();\n```  \n  \n### Return Value  \n Greater than or equal to 0 if the function is successful, or a negative value if an error occurred.  \n  \n### Remarks  \n This member function is typically used to direct the device driver to advance to a new page.  \n  \n This member function replaces the **NEWFRAME** printer escape. Unlike **NEWFRAME**, this function is always called after printing a page.  \n  \n### Example  \n  See the example for [CDC::StartDoc](#cdc__startdoc).  \n  \n##  <a name=\"cdc__endpath\"></a>  CDC::EndPath  \n Closes a path bracket and selects the path defined by the bracket into the device context.  \n  \n```  \nBOOL EndPath();\n```  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Example  \n  See the example for [CDC::BeginPath](#cdc__beginpath).  \n  \n##  <a name=\"cdc__enumobjects\"></a>  CDC::EnumObjects  \n Enumerates the pens and brushes available in a device context.  \n  \n```  \nint EnumObjects(\n    int nObjectType,  \n    int (\n    CALLBACK* lpfn)(\n    LPVOID,\n    LPARAM),  \n    LPARAM lpData);\n```  \n  \n### Parameters  \n *nObjectType*  \n Specifies the object type. It can have the values **OBJ_BRUSH** or **OBJ_PEN**.  \n  \n `lpfn`  \n Is the procedure-instance address of the application-supplied callback function. See the \"Remarks\" section below.  \n  \n `lpData`  \n Points to the application-supplied data. The data is passed to the callback function along with the object information.  \n  \n### Return Value  \n Specifies the last value returned by the [callback function](../../mfc/reference/callback-function-for-cdc-enumobjects.md). Its meaning is user-defined.  \n  \n### Remarks  \n For each object of a given type, the callback function that you pass is called with the information for that object. The system calls the callback function until there are no more objects or the callback function returns 0.  \n  \n Note that new features of Microsoft Visual C++ let you use an ordinary function as the function passed to `EnumObjects`. The address passed to `EnumObjects` is a pointer to a function exported with **EXPORT** and with the Pascal calling convention. In protect-mode applications, you do not have to create this function with the Windows                         MakeProcInstance function or free the function after use with the FreeProcInstance Windows function.  \n  \n You also do not have to export the function name in an **EXPORTS** statement in your application's module-definition file. You can instead use the **EXPORT** function modifier, as in  \n  \n **int CALLBACK EXPORT** AFunction **(LPSTR**, **LPSTR);**  \n  \n to cause the compiler to emit the proper export record for export by name without aliasing. This works for most needs. For some special cases, such as exporting a function by ordinal or aliasing the export, you still need to use an **EXPORTS** statement in a module-definition file.  \n  \n For compiling Microsoft Foundation programs, you will normally use the /GA and /GEs compiler options. The /Gw compiler option is not used with the Microsoft Foundation classes. (If you do use the Windows function **MakeProcInstance**, you will need to explicitly cast the returned function pointer from **FARPROC** to the type needed in this API.) Callback registration interfaces are now type-safe (you must pass in a function pointer that points to the right kind of function for the specific callback).  \n  \n Also note that all callback functions must trap Microsoft Foundation exceptions before returning to Windows, since exceptions cannot be thrown across callback boundaries. For more information about exceptions, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md).  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]  \n  \n##  <a name=\"cdc__escape\"></a>  CDC::Escape  \n This member function is practically obsolete for Win32 programming.  \n  \n```  \nvirtual int Escape(\n    int nEscape,  \n    int nCount,  \n    LPCSTR lpszInData,  \n    LPVOID lpOutData);\n\n \nint Escape(\n    int nEscape,  \n    int nInputSize,  \n    LPCSTR lpszInputData,  \n    int nOutputSize,  \n    LPSTR lpszOutputData);\n```  \n  \n### Parameters  \n `nEscape`  \n Specifies the escape function to be performed.  \n  \n For a complete list of escape functions, see [Escape](http://msdn.microsoft.com/library/windows/desktop/dd162701) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n `nCount`  \n Specifies the number of bytes of data pointed to by `lpszInData`.  \n  \n `lpszInData`  \n Points to the input data structure required for this escape.  \n  \n `lpOutData`  \n Points to the structure that is to receive output from this escape. The `lpOutData` parameter is **NULL** if no data is returned.  \n  \n `nInputSize`  \n Specifies the number of bytes of data pointed to by the `lpszInputData` parameter.  \n  \n `lpszInputData`  \n Points to the input structure required for the specified escape.  \n  \n `nOutputSize`  \n Specifies the number of bytes of data pointed to by the `lpszOutputData` parameter.  \n  \n `lpszOutputData`  \n Points to the structure that receives output from this escape. This parameter should be **NULL** if no data is returned.  \n  \n### Return Value  \n A positive value is returned if the function is successful, except for the **QUERYESCSUPPORT** escape, which only checks for implementation. Zero is returned if the escape is not implemented. A negative value is returned if an error occurred. The following are common error values:  \n  \n- **SP_ERROR** General error.  \n  \n- **SP_OUTOFDISK** Not enough disk space is currently available for spooling, and no more space will become available.  \n  \n- **SP_OUTOFMEMORY** Not enough memory is available for spooling.  \n  \n- **SP_USERABORT** User ended the job through the Print Manager.  \n  \n### Remarks  \n Of the original printer escapes, only **QUERYESCSUPPORT** is supported for Win32 applications. All other printer escapes are obsolete and are supported only for compatibility with 16-bit applications.  \n  \n For Win32 programming, `CDC` now provides six member functions that supersede their corresponding printer escapes:  \n  \n- [CDC::AbortDoc](#cdc__abortdoc)  \n  \n- [CDC::EndDoc](#cdc__enddoc)  \n  \n- [CDC::EndPage](#cdc__endpage)  \n  \n- [CDC::SetAbortProc](#cdc__setabortproc)  \n  \n- [CDC::StartDoc](#cdc__startdoc)  \n  \n- [CDC::StartPage](#cdc__startpage)  \n  \n In addition, [CDC::GetDeviceCaps](#cdc__getdevicecaps) supports Win32 indexes that supersede other printer escapes. See [GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for more information.  \n  \n This member function allows applications to access facilities of a particular device that are not directly available through GDI.  \n  \n Use the first version if your application uses predefined escape values. Use the second version if your application defines private escape values. See [ExtEscape](http://msdn.microsoft.com/library/windows/desktop/dd162708) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for more information about the second version.  \n  \n##  <a name=\"cdc__excludecliprect\"></a>  CDC::ExcludeClipRect  \n Creates a new clipping region that consists of the existing clipping region minus the specified rectangle.  \n  \n```  \nint ExcludeClipRect(\n    int x1,  \n    int y1,  \n    int x2,  \n    int y2);\n\n \nint ExcludeClipRect(\n    LPCRECT lpRect);\n```  \n  \n### Parameters  \n `x1`  \n Specifies the logical x-coordinate of the upper-left corner of the rectangle.  \n  \n `y1`  \n Specifies the logical y-coordinate of the upper-left corner of the rectangle.  \n  \n `x2`  \n Specifies the logical x-coordinate of the lower-right corner of the rectangle.  \n  \n `y2`  \n Specifies the logical y-coordinate of the lower-right corner of the rectangle.  \n  \n `lpRect`  \n Specifies the rectangle. Can also be a `CRect` object.  \n  \n### Return Value  \n Specifies the new clipping region's type. It can be any of the following values:  \n  \n- **COMPLEXREGION** The region has overlapping borders.  \n  \n- **ERROR** No region was created.  \n  \n- **NULLREGION** The region is empty.  \n  \n- **SIMPLEREGION** The region has no overlapping borders.  \n  \n### Remarks  \n The width of the rectangle, specified by the absolute value of `x2` – `x1`, must not exceed 32,767 units. This limit applies to the height of the rectangle as well.  \n  \n##  <a name=\"cdc__excludeupdatergn\"></a>  CDC::ExcludeUpdateRgn  \n Prevents drawing within invalid areas of a window by excluding an updated region in the window from the clipping region associated with the `CDC` object.  \n  \n```  \nint ExcludeUpdateRgn(CWnd* pWnd);\n```  \n  \n### Parameters  \n `pWnd`  \n Points to the window object whose window is being updated.  \n  \n### Return Value  \n The type of excluded region. It can be any one of the following values:  \n  \n- **COMPLEXREGION** The region has overlapping borders.  \n  \n- **ERROR** No region was created.  \n  \n- **NULLREGION** The region is empty.  \n  \n- **SIMPLEREGION** The region has no overlapping borders.  \n  \n##  <a name=\"cdc__extfloodfill\"></a>  CDC::ExtFloodFill  \n Fills an area of the display surface with the current brush.  \n  \n```  \nBOOL ExtFloodFill(\n    int x,  \n    int y,  \n    COLORREF crColor,  \n    UINT nFillType);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the point where filling begins.  \n  \n *y*  \n Specifies the logical y-coordinate of the point where filling begins.  \n  \n `crColor`  \n Specifies the color of the boundary or of the area to be filled. The interpretation of `crColor` depends on the value of `nFillType`.  \n  \n `nFillType`  \n Specifies the type of flood fill to be performed. It must be either of the following values:  \n  \n- **FLOODFILLBORDER** The fill area is bounded by the color specified by `crColor`. This style is identical to the filling performed by `FloodFill`.  \n  \n- **FLOODFILLSURFACE** The fill area is defined by the color specified by `crColor`. Filling continues outward in all directions as long as the color is encountered. This style is useful for filling areas with multicolored boundaries.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0 if the filling could not be completed, if the given point has the boundary color specified by `crColor` (if **FLOODFILLBORDER** was requested), if the given point does not have the color specified by `crColor` (if **FLOODFILLSURFACE** was requested), or if the point is outside the clipping region.  \n  \n### Remarks  \n This member function offers more flexibility than `FloodFill` because you can specify a fill type in `nFillType`.  \n  \n If `nFillType` is set to **FLOODFILLBORDER**, the area is assumed to be completely bounded by the color specified by `crColor`. The function begins at the point specified by *x* and *y* and fills in all directions to the color boundary.  \n  \n If `nFillType` is set to **FLOODFILLSURFACE**, the function begins at the point specified by *x* and *y* and continues in all directions, filling all adjacent areas containing the color specified by `crColor`.  \n  \n Only memory-device contexts and devices that support raster-display technology support `ExtFloodFill`. For more information, see the [GetDeviceCaps](#cdc__getdevicecaps) member function.  \n  \n##  <a name=\"cdc__exttextout\"></a>  CDC::ExtTextOut  \n Call this member function to write a character string within a rectangular region using the currently selected font.  \n  \n```  \nvirtual BOOL ExtTextOut(\n    int x,  \n    int y,  \n    UINT nOptions,  \n    LPCRECT lpRect,  \n    LPCTSTR lpszString,  \n    UINT nCount,  \n    LPINT lpDxWidths);\n\n \nBOOL ExtTextOut(\n    int x,  \n    int y,  \n    UINT nOptions,  \n    LPCRECT lpRect,  \n    const CString& str,  \n    LPINT lpDxWidths);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the character cell for the first character in the specified string.  \n  \n *y*  \n Specifies the logical y-coordinate of the top of the character cell for the first character in the specified string.  \n  \n `nOptions`  \n Specifies the rectangle type. This parameter can be one, both, or neither of the following values:  \n  \n- **ETO_CLIPPED** Specifies that text is clipped to the rectangle.  \n  \n- **ETO_OPAQUE** Specifies that the current background color fills the rectangle. (You can set and query the current background color with the [SetBkColor](#cdc__setbkcolor) and [GetBkColor](#cdc__getbkcolor) member functions.)  \n  \n `lpRect`  \n Points to a [RECT](../../mfc/reference/rect-structure1.md) structure that determines the dimensions of the rectangle. This parameter can be **NULL**. You can also pass a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter.  \n  \n `lpszString`  \n Points to the specified character string to be drawn. You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter.  \n  \n `nCount`  \n Specifies the number of characters in the string.  \n  \n `lpDxWidths`  \n Points to an array of values that indicate the distance between origins of adjacent character cells. For instance, `lpDxWidths`[ *i*] logical units will separate the origins of character cell *i* and character cell *i* + 1. If `lpDxWidths` is **NULL**, `ExtTextOut` uses the default spacing between characters.  \n  \n `str`  \n A `CString` object that contains the specified characters to be drawn.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The rectangular region can be opaque (filled with the current background color), and it can be a clipping region.  \n  \n If `nOptions` is 0 and `lpRect` is **NULL**, the function writes text to the device context without using a rectangular region. By default, the current position is not used or updated by the function. If an application needs to update the current position when it calls `ExtTextOut`, the application can call the `CDC` member function [SetTextAlign](#cdc__settextalign) with `nFlags` set to **TA_UPDATECP**. When this flag is set, Windows ignores *x* and *y* on subsequent calls to `ExtTextOut` and uses the current position instead. When an application uses **TA_UPDATECP** to update the current position, `ExtTextOut` sets the current position either to the end of the previous line of text or to the position specified by the last element of the array pointed to by `lpDxWidths`, whichever is greater.  \n  \n##  <a name=\"cdc__fillpath\"></a>  CDC::FillPath  \n Closes any open figures in the current path and fills the path's interior by using the current brush and polygon-filling mode.  \n  \n```  \nBOOL FillPath();\n```  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n After its interior is filled, the path is discarded from the device context.  \n  \n##  <a name=\"cdc__fillrect\"></a>  CDC::FillRect  \n Call this member function to fill a given rectangle using the specified brush.  \n  \n```  \nvoid FillRect(\n    LPCRECT lpRect,  \n    CBrush* pBrush);\n```  \n  \n### Parameters  \n `lpRect`  \n Points to a [RECT](../../mfc/reference/rect-structure1.md) structure that contains the logical coordinates of the rectangle to be filled. You can also pass a [CRect](../../atl-mfc-shared/reference/crect-class.md) object for this parameter.  \n  \n `pBrush`  \n Identifies the brush used to fill the rectangle.  \n  \n### Remarks  \n The function fills the complete rectangle, including the left and top borders, but it does not fill the right and bottom borders.  \n  \n The brush needs to either be created using the [CBrush](../../mfc/reference/cbrush-class.md) member functions [CreateHatchBrush](../../mfc/reference/cbrush-class.md#cbrush__createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#cbrush__createpatternbrush), and [CreateSolidBrush](../../mfc/reference/cbrush-class.md#cbrush__createsolidbrush), or retrieved by the `GetStockObject` Windows function.  \n  \n When filling the specified rectangle, `FillRect` does not include the rectangle's right and bottom sides. GDI fills a rectangle up to, but does not include, the right column and bottom row, regardless of the current mapping mode. `FillRect` compares the values of the **top**, **bottom**, **left**, and **right** members of the specified rectangle. If **bottom** is less than or equal to **top**, or if **right** is less than or equal to **left**, the rectangle is not drawn.  \n  \n `FillRect` is similar to [CDC::FillSolidRect](#cdc__fillsolidrect); however, `FillRect` takes a brush and therefore can be used to fill a rectangle with a solid color, a dithered color, hatched brushes, or a pattern. `FillSolidRect` uses only solid colors (indicated by a **COLORREF** parameter). `FillRect` usually is slower than `FillSolidRect`.  \n  \n##  <a name=\"cdc__fillrgn\"></a>  CDC::FillRgn  \n Fills the region specified by `pRgn` with the brush specified by `pBrush`.  \n  \n```  \nBOOL FillRgn(\n    CRgn* pRgn,  \n    CBrush* pBrush);\n```  \n  \n### Parameters  \n `pRgn`  \n A pointer to the region to be filled. The coordinates for the given region are specified in logical units.  \n  \n `pBrush`  \n Identifies the brush to be used to fill the region.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The brush must either be created using the `CBrush` member functions `CreateHatchBrush`, `CreatePatternBrush`, `CreateSolidBrush`, or be retrieved by **GetStockObject**.  \n  \n### Example  \n  See the example for [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#crgn__createroundrectrgn).  \n  \n##  <a name=\"cdc__fillsolidrect\"></a>  CDC::FillSolidRect  \n Call this member function to fill the given rectangle with the specified solid color.  \n  \n```  \nvoid FillSolidRect(\n    LPCRECT lpRect,  \n    COLORREF clr);\n\n \nvoid FillSolidRect(\n    int x,  \n    int y,  \n    int cx,  \n    int cy,  \n    COLORREF clr);\n```  \n  \n### Parameters  \n `lpRect`  \n Specifies the bounding rectangle (in logical units). You can pass either a pointer to a [RECT](../../mfc/reference/rect-structure1.md) data structure or a `CRect` object for this parameter.  \n  \n `clr` Specifies the color to be used to fill the rectangle.  \n  \n *x*  \n Specifies the logical x-coordinate of the upper-left corner of the rectangle.  \n  \n *y*  \n Specifies the logical y-coordinate of the upper-left corner of the destination rectangle.  \n  \n `cx`  \n Specifies the width of the rectangle.  \n  \n `cy`  \n Specifies the height of the rectangle.  \n  \n### Remarks  \n `FillSolidRect` is very similar to [CDC::FillRect](#cdc__fillrect); however, `FillSolidRect` uses only solid colors (indicated by the **COLORREF** parameter), while `FillRect` takes a brush and therefore can be used to fill a rectangle with a solid color, a dithered color, hatched brushes, or a pattern. `FillSolidRect` usually is faster than `FillRect`.  \n  \n> [!NOTE]\n>  When you call `FillSolidRect`, the background color, which was previously set using [SetBkColor](#cdc__setbkcolor), is set to the color indicated by `clr`.  \n  \n##  <a name=\"cdc__flattenpath\"></a>  CDC::FlattenPath  \n Transforms any curves in the path selected into the current device context, and turns each curve into a sequence of lines.  \n  \n```  \nBOOL FlattenPath();\n```  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n##  <a name=\"cdc__floodfill\"></a>  CDC::FloodFill  \n Fills an area of the display surface with the current brush.  \n  \n```  \nBOOL FloodFill(\n    int x,  \n    int y,  \n    COLORREF crColor);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the point where filling begins.  \n  \n *y*  \n Specifies the logical y-coordinate of the point where filling begins.  \n  \n `crColor`  \n Specifies the color of the boundary.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0 is returned if the filling could not be completed, the given point has the boundary color specified by `crColor`, or the point is outside the clipping region.  \n  \n### Remarks  \n The area is assumed to be bounded as specified by `crColor`. The `FloodFill` function begins at the point specified by *x* and *y* and continues in all directions to the color boundary.  \n  \n Only memory-device contexts and devices that support raster-display technology support the `FloodFill` member function. For information about **RC_BITBLT** capability, see the `GetDeviceCaps` member function.  \n  \n The `ExtFloodFill` function provides similar capability but greater flexibility.  \n  \n##  <a name=\"cdc__framerect\"></a>  CDC::FrameRect  \n Draws a border around the rectangle specified by `lpRect`.  \n  \n```  \nvoid FrameRect(\n    LPCRECT lpRect,  \n    CBrush* pBrush);\n```  \n  \n### Parameters  \n `lpRect`  \n Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or [CRect](../../atl-mfc-shared/reference/crect-class.md) object that contains the logical coordinates of the upper-left and lower-right corners of the rectangle. You can also pass a `CRect` object for this parameter.  \n  \n `pBrush`  \n Identifies the brush to be used for framing the rectangle.  \n  \n### Remarks  \n The function uses the given brush to draw the border. The width and height of the border is always 1 logical unit.  \n  \n If the rectangle's **bottom** coordinate is less than or equal to **top**, or if **right** is less than or equal to **left**, the rectangle is not drawn.  \n  \n The border drawn by `FrameRect` is in the same position as a border drawn by the **Rectangle** member function using the same coordinates (if **Rectangle** uses a pen that is 1 logical unit wide). The interior of the rectangle is not filled by `FrameRect`.  \n  \n##  <a name=\"cdc__framergn\"></a>  CDC::FrameRgn  \n Draws a border around the region specified by `pRgn` using the brush specified by `pBrush`.  \n  \n```  \nBOOL FrameRgn(\n    CRgn* pRgn,  \n    CBrush* pBrush,  \n    int nWidth,  \n    int nHeight);\n```  \n  \n### Parameters  \n `pRgn`  \n Points to the `CRgn` object that identifies the region to be enclosed in a border. The coordinates for the given region are specified in logical units.  \n  \n `pBrush`  \n Points to the `CBrush` object that identifies the brush to be used to draw the border.  \n  \n `nWidth`  \n Specifies the width of the border in vertical brush strokes in device units.  \n  \n `nHeight`  \n Specifies the height of the border in horizontal brush strokes in device units.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Example  \n  See the example for [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#crgn__combinergn).  \n  \n##  <a name=\"cdc__fromhandle\"></a>  CDC::FromHandle  \n Returns a pointer to a `CDC` object when given a handle to a device context.  \n  \n```  \nstatic CDC* PASCAL FromHandle(HDC hDC);\n```  \n  \n### Parameters  \n `hDC`  \n Contains a handle to a Windows device context.  \n  \n### Return Value  \n The pointer may be temporary and should not be stored beyond immediate use.  \n  \n### Remarks  \n If a `CDC` object is not attached to the handle, a temporary `CDC` object is created and attached.  \n  \n### Example  \n  See the example for [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#cprintdialog__getprinterdc).  \n  \n##  <a name=\"cdc__getarcdirection\"></a>  CDC::GetArcDirection  \n Returns the current arc direction for the device context.  \n  \n```  \nint GetArcDirection() const;\n\n \n```  \n  \n### Return Value  \n Specifies the current arc direction, if successful. Following are the valid return values:  \n  \n- **AD_COUNTERCLOCKWISE** Arcs and rectangles drawn counterclockwise.  \n  \n- **AD_CLOCKWISE** Arcs and rectangles drawn clockwise.  \n  \n If an error occurs, the return value is zero.  \n  \n### Remarks  \n Arc and rectangle functions use the arc direction.  \n  \n##  <a name=\"cdc__getaspectratiofilter\"></a>  CDC::GetAspectRatioFilter  \n Retrieves the setting for the current aspect-ratio filter.  \n  \n```  \nCSize GetAspectRatioFilter() const;\n\n \n```  \n  \n### Return Value  \n A `CSize` object representing the aspect ratio used by the current aspect ratio filter.  \n  \n### Remarks  \n The aspect ratio is the ratio formed by a device's pixel width and height. Information about a device's aspect ratio is used in the creation, selection, and display of fonts. Windows provides a special filter, the aspect-ratio filter, to select fonts designed for a particular aspect ratio from all of the available fonts. The filter uses the aspect ratio specified by the `SetMapperFlags` member function.  \n  \n##  <a name=\"cdc__getbkcolor\"></a>  CDC::GetBkColor  \n Returns the current background color.  \n  \n```  \nCOLORREF GetBkColor() const;\n\n \n```  \n  \n### Return Value  \n An RGB color value.  \n  \n### Remarks  \n If the background mode is **OPAQUE**, the system uses the background color to fill the gaps in styled lines, the gaps between hatched lines in brushes, and the background in character cells. The system also uses the background color when converting bitmaps between color and monochrome device contexts.  \n  \n##  <a name=\"cdc__getbkmode\"></a>  CDC::GetBkMode  \n Returns the background mode.  \n  \n```  \nint GetBkMode() const;\n\n \n```  \n  \n### Return Value  \n The current background mode, which can be **OPAQUE** or **TRANSPARENT**.  \n  \n### Remarks  \n The background mode defines whether the system removes existing background colors on the drawing surface before drawing text, hatched brushes, or any pen style that is not a solid line.  \n  \n##  <a name=\"cdc__getboundsrect\"></a>  CDC::GetBoundsRect  \n Returns the current accumulated bounding rectangle for the specified device context.  \n  \n```  \nUINT GetBoundsRect(\n    LPRECT lpRectBounds,  \n    UINT flags);\n```  \n  \n### Parameters  \n `lpRectBounds`  \n Points to a buffer that will receive the current bounding rectangle. The rectangle is returned in logical coordinates.  \n  \n `flags`  \n Specifies whether the bounding rectangle is to be cleared after it is returned. This parameter should be  zero or set to the following value:  \n  \n- **DCB_RESET** Forces the bounding rectangle to be cleared after it is returned.  \n  \n### Return Value  \n Specifies the current state of the bounding rectangle if the function is successful. It can be a combination of the following values:  \n  \n- **DCB_ACCUMULATE** Bounding rectangle accumulation is occurring.  \n  \n- **DCB_RESET** Bounding rectangle is empty.  \n  \n- **DCB_SET** Bounding rectangle is not empty.  \n  \n- **DCB_ENABLE** Bounding accumulation is on.  \n  \n- **DCB_DISABLE** Bounding accumulation is off.  \n  \n##  <a name=\"cdc__getbrushorg\"></a>  CDC::GetBrushOrg  \n Retrieves the origin (in device units) of the brush currently selected for the device context.  \n  \n```  \nCPoint GetBrushOrg() const;\n\n \n```  \n  \n### Return Value  \n The current origin of the brush (in device units) as a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object.  \n  \n### Remarks  \n The initial brush origin is at (0,0) of the client area. The return value specifies this point in device units relative to the origin of the desktop window.  \n  \n##  <a name=\"cdc__getcharacterplacement\"></a>  CDC::GetCharacterPlacement  \n Retrieves various types of information on a character string.  \n  \n```  \nDWORD GetCharacterPlacement(\n    LPCTSTR lpString,  \n    int nCount,  \n    int nMaxExtent,  \n    LPGCP_RESULTS lpResults,  \n    DWORD dwFlags) const;\n\n \nDWORD GetCharacterPlacement(\n    CString& str,  \n    int nMaxExtent,  \n    LPGCP_RESULTS lpResults,  \n    DWORD dwFlags) const;\n\n \n```  \n  \n### Parameters  \n `lpString`  \n A pointer to the character string to process.  \n  \n `nCount`  \n Specifies the length of the string. For the ANSI version, it is a BYTE count and for the Unicode function it is a WORD count. For more information, see [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\\(v=vs.85\\).aspx).  \n  \n `nMaxExtent`  \n Specifies the maximum extent (in logical units) to which the string is processed. Characters that, if processed, would exceed this extent are ignored. Computations for any required ordering or glyph arrays apply only to the included characters. This parameter is used only if the GCP_MAXEXTENT value is specified in the `dwFlags` parameter. As the function processes the input string, each character and its extent is added to the output, extent, and other arrays only if the total extent has not yet exceeded the maximum. Once the limit is reached, processing will stop.  \n  \n lpResults  \n Pointer to a [GCP_Results](http://msdn.microsoft.com/library/windows/desktop/dd144842\\(v=vs.85\\).aspx) structure that receives the results of the function.  \n  \n `dwFlags`  \n Specifies how to process the string into the required arrays. This parameter can be one or more of the values listed in the `dwFlags` section of the [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\\(v=vs.85\\).aspx) topic.  \n  \n `str`  \n A pointer to a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object to process.  \n  \n### Return Value  \n If the function succeeds, the return value is the width and height of the string in logical units.  \n  \n If the function fails, the return value is zero.  \n  \n### Remarks  \n This member function emulates the functionality of the function [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\\(v=vs.85\\).aspx), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__getcharabcwidths\"></a>  CDC::GetCharABCWidths  \n Retrieves the widths of consecutive characters in a specified range from the current TrueType font.  \n  \n```  \nBOOL GetCharABCWidths(\n    UINT nFirstChar,  \n    UINT nLastChar,  \n    LPABC lpabc) const;\n\n \n \nBOOL GetCharABCWidths(\n    UINT nFirstChar,  \n    UINT nLastChar,  \n    LPABCFLOAT lpABCF) const;\n\n \n```  \n  \n### Parameters  \n `nFirstChar`  \n Specifies the first character in the range of characters from the current font for which character widths are returned.  \n  \n `nLastChar`  \n Specifies the last character in the range of characters from the current font for which character widths are returned.  \n  \n `lpabc`  \n Points to an array of [ABC](../../mfc/reference/abc-structure.md) structures that receive the character widths when the function returns. This array must contain at least as many **ABC** structures as there are characters in the range specified by the `nFirstChar` and `nLastChar` parameters.  \n  \n *lpABCF*  \n Points to an application-supplied buffer with an array of [ABCFLOAT](../../mfc/reference/abcfloat-structure.md) structures to receive the character widths when the function returns. The widths returned by this function are in the IEEE floating-point format.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The widths are returned in logical units. This function succeeds only with TrueType fonts.  \n  \n The TrueType rasterizer provides \"ABC\" character spacing after a specific point size has been selected. \"A\" spacing is the distance that is added to the current position before placing the glyph. \"B\" spacing is the width of the black part of the glyph. \"C\" spacing is added to the current position to account for the white space to the right of the glyph. The total advanced width is given by A + B + C.  \n  \n When the `GetCharABCWidths` member function retrieves negative \"A\" or \"C\" widths for a character, that character includes underhangs or overhangs.  \n  \n To convert the ABC widths to font design units, an application should create a font whose height (as specified in the **lfHeight** member of the [LOGFONT](http://msdn.microsoft.com/library/windows/desktop/dd145037) structure) is equal to the value stored in the **ntmSizeEM** member of the [NEWTEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162741) structure. (The value of the **ntmSizeEM** member can be retrieved by calling the [EnumFontFamilies](http://msdn.microsoft.com/library/windows/desktop/dd162619) Windows function.)  \n  \n The ABC widths of the default character are used for characters that are outside the range of the currently selected font.  \n  \n To retrieve the widths of characters in non-TrueType fonts, applications should use the [GetCharWidth](http://msdn.microsoft.com/library/windows/desktop/dd144861) Windows function.  \n  \n##  <a name=\"cdc__getcharabcwidthsi\"></a>  CDC::GetCharABCWidthsI  \n Retrieves the widths, in logical units, of consecutive glyph indices in a specified range from the current TrueType font.  \n  \n```  \nBOOL GetCharABCWidthsI(\n    UINT giFirst,  \n    UINT cgi,  \n    LPWORD pgi,  \n    LPABC lpabc) const;\n\n \n```  \n  \n### Parameters  \n `giFirst`  \n Specifies the first glyph index in the group of consecutive glyph indices from the current font. This parameter is only used if the `pgi` parameter is **NULL**.  \n  \n `cgi`  \n Specifies the number of glyph indices.  \n  \n `pgi`  \n A pointer to an array containing glyph indices. If the value is **NULL**, the `giFirst` parameter is used instead. The `cgi` parameter specifies the number of glyph indices in this array.  \n  \n `lpabc`  \n Pointer to an array of [ABC](http://msdn.microsoft.com/library/windows/desktop/dd162454) structures receiving the character widths. This array must contain at least as many **ABC** structures as there are glyph indices specified by the `cgi` parameter.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n This member function emulates the functionality of the function [GetCharABCWidthsI](http://msdn.microsoft.com/library/windows/desktop/dd144859), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__getcharwidth\"></a>  CDC::GetCharWidth  \n Retrieves the widths of individual characters in a consecutive group of characters from the current font, using `m_hAttribDC`, the input device context.  \n  \n```  \nBOOL GetCharWidth(\n    UINT nFirstChar,  \n    UINT nLastChar,  \n    LPINT lpBuffer) const;\n\n \n \nBOOL GetCharWidth(\n    UINT nFirstChar,  \n    UINT nLastChar,  \n    float* lpFloatBuffer) const;\n\n \n```  \n  \n### Parameters  \n `nFirstChar`  \n Specifies the first character in a consecutive group of characters in the current font.  \n  \n `nLastChar`  \n Specifies the last character in a consecutive group of characters in the current font.  \n  \n `lpBuffer`  \n Points to a buffer that will receive the width values for a consecutive group of characters in the current font.  \n  \n *lpFloatBuffer*  \n Points to a buffer to receive the character widths. The returned widths are in the 32-bit IEEE floating-point format. (The widths are measured along the base line of the characters.)  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n For example, if `nFirstChar` identifies the letter 'a' and `nLastChar` identifies the letter 'z', the function retrieves the widths of all lowercase characters.  \n  \n The function stores the values in the buffer pointed to by `lpBuffer`. This buffer must be large enough to hold all of the widths. That is, there must be at least 26 entries in the example given.  \n  \n If a character in the consecutive group of characters does not exist in a particular font, it will be assigned the width value of the default character.  \n  \n##  <a name=\"cdc__getcharwidthi\"></a>  CDC::GetCharWidthI  \n Retrieves the widths, in logical coordinates, of consecutive glyph indices in a specified range from the current font.  \n  \n```  \nBOOL GetCharWidthI(\n    UINT giFirst,  \n    UINT cgi,  \n    LPWORD pgi,  \n    LPINT lpBuffer) const;\n\n \n```  \n  \n### Parameters  \n `giFirst`  \n Specifies the first glyph index in the group of consecutive glyph indices from the current font. This parameter is only used if the `pgi` parameter is **NULL**.  \n  \n `cgi`  \n Specifies the number of glyph indices.  \n  \n `pgi`  \n A pointer to an array containing glyph indices. If the value is **NULL**, the `giFirst` parameter is used instead. The `cgi` parameter specifies the number of glyph indices in this array.  \n  \n `lpBuffer`  \n A pointer to a buffer that receives the widths.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n This member function emulates the functionality of the function [GetCharWidthI](http://msdn.microsoft.com/library/windows/desktop/dd144864), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__getclipbox\"></a>  CDC::GetClipBox  \n Retrieves the dimensions of the tightest bounding rectangle around the current clipping boundary.  \n  \n```  \nvirtual int GetClipBox(LPRECT lpRect) const;\n\n \n```  \n  \n### Parameters  \n `lpRect`  \n Points to the [RECT](../../mfc/reference/rect-structure1.md) structure or [CRect](../../atl-mfc-shared/reference/crect-class.md) object that is to receive the rectangle dimensions.  \n  \n### Return Value  \n The clipping region's type. It can be any of the following values:  \n  \n- **COMPLEXREGION** Clipping region has overlapping borders.  \n  \n- **ERROR** Device context is not valid.  \n  \n- **NULLREGION** Clipping region is empty.  \n  \n- **SIMPLEREGION** Clipping region has no overlapping borders.  \n  \n### Remarks  \n The dimensions are copied to the buffer pointed to by `lpRect`.  \n  \n##  <a name=\"cdc__getcoloradjustment\"></a>  CDC::GetColorAdjustment  \n Retrieves the color adjustment values for the device context.  \n  \n```  \nBOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;\n\n \n```  \n  \n### Parameters  \n `lpColorAdjust`  \n Points to a [COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md) data structure to receive the color adjustment values.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n##  <a name=\"cdc__getcurrentbitmap\"></a>  CDC::GetCurrentBitmap  \n Returns a pointer to the currently selected `CBitmap` object.  \n  \n```  \nCBitmap* GetCurrentBitmap() const;\n\n \n```  \n  \n### Return Value  \n Pointer to a `CBitmap` object, if successful; otherwise **NULL**.  \n  \n### Remarks  \n This member function may return temporary objects.  \n  \n##  <a name=\"cdc__getcurrentbrush\"></a>  CDC::GetCurrentBrush  \n Returns a pointer to the currently selected `CBrush` object.  \n  \n```  \nCBrush* GetCurrentBrush() const;\n\n \n```  \n  \n### Return Value  \n Pointer to a `CBrush` object, if successful; otherwise **NULL**.  \n  \n### Remarks  \n This member function may return temporary objects.  \n  \n##  <a name=\"cdc__getcurrentfont\"></a>  CDC::GetCurrentFont  \n Returns a pointer to the currently selected `CFont` object.  \n  \n```  \nCFont* GetCurrentFont() const;\n\n \n```  \n  \n### Return Value  \n Pointer to a `CFont` object, if successful; otherwise **NULL**.  \n  \n### Remarks  \n This member function may return temporary objects.  \n  \n##  <a name=\"cdc__getcurrentpalette\"></a>  CDC::GetCurrentPalette  \n Returns a pointer to the currently selected `CPalette` object.  \n  \n```  \nCPalette* GetCurrentPalette() const;\n\n \n```  \n  \n### Return Value  \n Pointer to a `CPalette` object, if successful; otherwise **NULL**.  \n  \n### Remarks  \n This member function may return temporary objects.  \n  \n##  <a name=\"cdc__getcurrentpen\"></a>  CDC::GetCurrentPen  \n Returns a pointer to the currently selected `CPen` object.  \n  \n```  \nCPen* GetCurrentPen() const;\n\n \n```  \n  \n### Return Value  \n Pointer to a `CPen` object, if successful; otherwise **NULL**.  \n  \n### Remarks  \n This member function may return temporary objects.  \n  \n##  <a name=\"cdc__getcurrentposition\"></a>  CDC::GetCurrentPosition  \n Retrieves the current position (in logical coordinates).  \n  \n```  \nCPoint GetCurrentPosition() const;\n\n \n```  \n  \n### Return Value  \n The current position as a `CPoint` object.  \n  \n### Remarks  \n The current position can be set with the `MoveTo` member function.  \n  \n##  <a name=\"cdc__getdcbrushcolor\"></a>  CDC::GetDCBrushColor  \n Retrieves the current brush color.  \n  \n```  \nCOLORREF GetDCBrushColor() const;\n\n \n```  \n  \n### Return Value  \n If the function succeeds, the return value is the [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) value for the current brush color.  \n  \n If the function fails, the return value is **CLR_INVALID**.  \n  \n### Remarks  \n This member function emulates the functionality of the function [GetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd144872), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__getdcpencolor\"></a>  CDC::GetDCPenColor  \n Retrieves the current pen color.  \n  \n```  \nCOLORREF GetDCPenColor() const;\n\n \n```  \n  \n### Return Value  \n If the function succeeds, the return value is the [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) value for the current pen color.  \n  \n If the function fails, the return value is **CLR_INVALID**.  \n  \n### Remarks  \n This member function utilizes the Win32 function [GetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd144875), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__getdevicecaps\"></a>  CDC::GetDeviceCaps  \n Retrieves a wide range of device-specific information about the display device.  \n  \n```  \nint GetDeviceCaps(int nIndex) const;\n\n \n```  \n  \n### Parameters  \n `nIndex`  \n Specifies the type of information to return. See [GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a list of values.  \n  \n### Return Value  \n The value of the requested capability if the function is successful.  \n  \n### Example  \n  See the example for [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#cprintdialog__getdefaults).  \n  \n##  <a name=\"cdc__getfontdata\"></a>  CDC::GetFontData  \n Retrieves font-metric information from a scalable font file.  \n  \n```  \nDWORD GetFontData(\n    DWORD dwTable,  \n    DWORD dwOffset,  \n    LPVOID lpData,  \n    DWORD cbData) const;\n\n \n```  \n  \n### Parameters  \n `dwTable`  \n Specifies the name of the metric table to be returned. This parameter can be one of the metric tables documented in the TrueType Font Files specification published by Microsoft Corporation. If this parameter is 0, the information is retrieved starting at the beginning of the font file.  \n  \n `dwOffset`  \n Specifies the offset from the beginning of the table at which to begin retrieving information. If this parameter is 0, the information is retrieved starting at the beginning of the table specified by the `dwTable` parameter. If this value is greater than or equal to the size of the table, `GetFontData` returns 0.  \n  \n `lpData`  \n Points to a buffer that will receive the font information. If this value is **NULL**, the function returns the size of the buffer required for the font data specified in the `dwTable` parameter.  \n  \n `cbData`  \n Specifies the length, in bytes, of the information to be retrieved. If this parameter is 0, `GetFontData` returns the size of the data specified in the `dwTable` parameter.  \n  \n### Return Value  \n Specifies the number of bytes returned in the buffer pointed to by `lpData` if the function is successful; otherwise –1.  \n  \n### Remarks  \n The information to retrieve is identified by specifying an offset into the font file and the length of the information to return.  \n  \n An application can sometimes use the `GetFontData` member function to save a TrueType font with a document. To do this, the application determines whether the font can be embedded and then retrieves the entire font file, specifying 0 for the `dwTable`, `dwOffset`, and `cbData` parameters.  \n  \n Applications can determine whether a font can be embedded by checking the **otmfsType** member of the [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structure. If bit 1 of **otmfsType** is set, embedding is not permitted for the font. If bit 1 is clear, the font can be embedded. If bit 2 is set, the embedding is read only.  \n  \n If an application attempts to use this function to retrieve information for a non-TrueType font, the `GetFontData` member function returns –1.  \n  \n##  <a name=\"cdc__getfontlanguageinfo\"></a>  CDC::GetFontLanguageInfo  \n Returns information about the currently selected font for the specified display context.  \n  \n```  \nDWORD GetFontLanguageInfo() const;\n\n \n```  \n  \n### Return Value  \n The return value identifies characteristics of the currently selected font. For a complete listing of possible values, see [GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886).  \n  \n### Remarks  \n This member function emulates the functionality of the function [GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__getglyphoutline\"></a>  CDC::GetGlyphOutline  \n Retrieves the outline curve or bitmap for an outline character in the current font.  \n  \n```  \nDWORD GetGlyphOutline(\n    UINT nChar,  \n    UINT nFormat,  \n    LPGLYPHMETRICS lpgm,  \n    DWORD cbBuffer,  \n    LPVOID lpBuffer,  \n    const MAT2* lpmat2) const;\n\n \n```  \n  \n### Parameters  \n `nChar`  \n Specifies the character for which information is to be returned.  \n  \n `nFormat`  \n Specifies the format in which the function is to return information. It can be one of the following values, or 0:  \n  \n|Value|Meaning|  \n|-----------|-------------|  \n|**GGO_BITMAP**|Returns the glyph bitmap. When the function returns, the buffer pointed to by `lpBuffer` contains a 1-bit-per-pixel bitmap whose rows start on doubleword boundaries.|  \n|**GGO_NATIVE**|Returns the curve data points in the rasterizer's native format, using device units. When this value is specified, any transformation specified in `lpmat2` is ignored.|  \n  \n When the value of `nFormat` is 0, the function fills in a [GLYPHMETRICS](http://msdn.microsoft.com/library/windows/desktop/dd144955) structure but does not return glyph-outline data.  \n  \n *lpgm*  \n Points to a **GLYPHMETRICS** structure that describes the placement of the glyph in the character cell.  \n  \n `cbBuffer`  \n Specifies the size of the buffer into which the function copies information about the outline character. If this value is 0 and the `nFormat` parameter is either the **GGO_BITMAP** or **GGO_NATIVE** values, the function returns the required size of the buffer.  \n  \n `lpBuffer`  \n Points to a buffer into which the function copies information about the outline character. If `nFormat` specifies the **GGO_NATIVE** value, the information is copied in the form of **TTPOLYGONHEADER** and **TTPOLYCURVE** structures. If this value is **NULL** and `nFormat` is either the **GGO_BITMAP** or **GGO_NATIVE** value, the function returns the required size of the buffer.  \n  \n `lpmat2`  \n Points to a [MAT2](http://msdn.microsoft.com/library/windows/desktop/dd145048) structure that contains a transformation matrix for the character. This parameter cannot be **NULL**, even when the **GGO_NATIVE** value is specified for `nFormat`.  \n  \n### Return Value  \n The size, in bytes, of the buffer required for the retrieved information if `cbBuffer` is 0 or `lpBuffer` is **NULL**. Otherwise, it is a positive value if the function is successful, or –1 if there is an error.  \n  \n### Remarks  \n An application can rotate characters retrieved in bitmap format by specifying a 2-by-2 transformation matrix in the structure pointed to by `lpmat2`.  \n  \n A glyph outline is returned as a series of contours. Each contour is defined by a [TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158) structure followed by as many **TTPOLYCURVE** structures as are required to describe it. All points are returned as [POINTFX](http://msdn.microsoft.com/library/windows/desktop/dd162806) structures and represent absolute positions, not relative moves. The starting point given by the **pfxStart** member of the [TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158) structure is the point at which the outline for a contour begins. The [TTPOLYCURVE](http://msdn.microsoft.com/library/windows/desktop/dd145157) structures that follow can be either polyline records or spline records. Polyline records are a series of points; lines drawn between the points describe the outline of the character. Spline records represent the quadratic curves used by TrueType (that is, quadratic b-splines).  \n  \n##  <a name=\"cdc__getgraphicsmode\"></a>  CDC::GetGraphicsMode  \n Retrieves the current graphics mode for the specified device context.  \n  \n```  \nint GetGraphicsMode() const;\n\n \n```  \n  \n### Return Value  \n Returns the current graphics mode on success. For a list of the values that this method can return, see [GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892).  \n  \n Returns 0 on failure.  \n  \n To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  \n  \n### Remarks  \n This method wraps the Windows GDI function [GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892).  \n  \n##  <a name=\"cdc__gethalftonebrush\"></a>  CDC::GetHalftoneBrush  \n Call this member function to retrieve a halftone brush.  \n  \n```  \nstatic CBrush* PASCAL GetHalftoneBrush();\n```  \n  \n### Return Value  \n A pointer to a `CBrush` object if successful; otherwise **NULL**.  \n  \n### Remarks  \n A halftone brush shows pixels that are alternately foreground and background colors to create a dithered pattern. The following is an example of a dithered pattern created by a halftone brush.  \n  \n ![Detail of a dithered pen stroke](../../mfc/reference/media/vc318s1.gif \"vc318s1\")  \n  \n##  <a name=\"cdc__getkerningpairs\"></a>  CDC::GetKerningPairs  \n Retrieves the character kerning pairs for the font that is currently selected in the specified device context.  \n  \n```  \nint GetKerningPairs(\n    int nPairs,  \n    LPKERNINGPAIR lpkrnpair) const;\n\n \n```  \n  \n### Parameters  \n `nPairs`  \n Specifies the number of [KERNINGPAIR](http://msdn.microsoft.com/library/windows/desktop/dd145024) structures pointed to by `lpkrnpair`. The function will not copy more kerning pairs than specified by `nPairs`.  \n  \n `lpkrnpair`  \n Points to an array of **KERNINGPAIR** structures that receive the kerning pairs when the function returns. This array must contain at least as many structures as specified by `nPairs`. If this parameter is **NULL**, the function returns the total number of kerning pairs for the font.  \n  \n### Return Value  \n Specifies the number of kerning pairs retrieved or the total number of kerning pairs in the font, if the function is successful. Zero is returned if the function fails or there are no kerning pairs for the font.  \n  \n##  <a name=\"cdc__getlayout\"></a>  CDC::GetLayout  \n Call this member function to determine the layout of the text and graphics for a device context, such as a printer or a metafile.  \n  \n```  \nDWORD GetLayout() const;\n\n \n```  \n  \n### Return Value  \n If successful, the layout flags for the current device context. Otherwise, **GDI_ERROR**. For extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360). For a list of the layout flags, see [CDC::SetLayout](#cdc__setlayout).  \n  \n### Remarks  \n The default layout is left to right.  \n  \n##  <a name=\"cdc__getmapmode\"></a>  CDC::GetMapMode  \n Retrieves the current mapping mode.  \n  \n```  \nint GetMapMode() const;\n\n \n```  \n  \n### Return Value  \n The mapping mode.  \n  \n### Remarks  \n For a description of the mapping modes, see the `SetMapMode` member function.  \n  \n> [!NOTE]\n>  If you call [SetLayout](#cdc__setlayout) to change the DC to right-to-left layout, **SetLayout** automatically changes the mapping mode to `MM_ISOTROPIC`. Consequently, any subsequent call to `GetMapMode` will return `MM_ISOTROPIC`.  \n  \n##  <a name=\"cdc__getmiterlimit\"></a>  CDC::GetMiterLimit  \n Returns the miter limit for the device context.  \n  \n```  \nfloat GetMiterLimit() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The miter limit is used when drawing geometric lines that have miter joins.  \n  \n##  <a name=\"cdc__getnearestcolor\"></a>  CDC::GetNearestColor  \n Returns the solid color that best matches a specified logical color.  \n  \n```  \nCOLORREF GetNearestColor(COLORREF crColor) const;\n\n \n```  \n  \n### Parameters  \n `crColor`  \n Specifies the color to be matched.  \n  \n### Return Value  \n An RGB (red, green, blue) color value that defines the solid color closest to the `crColor` value that the device can represent.  \n  \n### Remarks  \n The given device must be able to represent this color.  \n  \n##  <a name=\"cdc__getoutlinetextmetrics\"></a>  CDC::GetOutlineTextMetrics  \n Retrieves metric information for TrueType fonts.  \n  \n```  \nUINT GetOutlineTextMetrics(\n    UINT cbData,  \n    LPOUTLINETEXTMETRIC lpotm) const;\n\n \n```  \n  \n### Parameters  \n `lpotm`  \n Points to an array of [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structures. If this parameter is **NULL**, the function returns the size of the buffer required for the retrieved metric data.  \n  \n `cbData`  \n Specifies the size, in bytes, of the buffer to which information is returned.  \n  \n `lpotm`  \n Points to an **OUTLINETEXTMETRIC** structure. If this parameter is **NULL**, the function returns the size of the buffer required for the retrieved metric information.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structure contains most of the font metric information provided with the TrueType format, including a [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure. The last four members of the **OUTLINETEXTMETRIC** structure are pointers to strings. Applications should allocate space for these strings in addition to the space required for the other members. Because there is no system-imposed limit to the size of the strings, the simplest method for allocating memory is to retrieve the required size by specifying **NULL** for `lpotm` in the first call to the `GetOutlineTextMetrics` function.  \n  \n##  <a name=\"cdc__getoutputcharwidth\"></a>  CDC::GetOutputCharWidth  \n Uses the output device context, `m_hDC`, and retrieves the widths of individual characters in a consecutive group of characters from the current font.  \n  \n```  \nBOOL GetOutputCharWidth(\n    UINT nFirstChar,  \n    UINT nLastChar,  \n    LPINT lpBuffer) const;\n\n \n```  \n  \n### Parameters  \n `nFirstChar`  \n Specifies the first character in a consecutive group of characters in the current font.  \n  \n `nLastChar`  \n Specifies the last character in a consecutive group of characters in the current font.  \n  \n `lpBuffer`  \n Points to a buffer that will receive the width values for a consecutive group of characters in the current font.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n For example, if `nFirstChar` identifies the letter 'a' and `nLastChar` identifies the letter 'z', the function retrieves the widths of all lowercase characters.  \n  \n The function stores the values in the buffer pointed to by `lpBuffer`. This buffer must be large enough to hold all of the widths; that is, there must be at least 26 entries in the example given.  \n  \n If a character in the consecutive group of characters does not exist in a particular font, it will be assigned the width value of the default character.  \n  \n##  <a name=\"cdc__getoutputtabbedtextextent\"></a>  CDC::GetOutputTabbedTextExtent  \n Call this member function to compute the width and height of a character string using [m_hDC](#cdc__m_hdc), the output device context.  \n  \n```  \nCSize GetOutputTabbedTextExtent(\n    LPCTSTR lpszString,  \n    int nCount,  \n    int nTabPositions,  \n    LPINT lpnTabStopPositions) const;\n\n \n \nCSize GetOutputTabbedTextExtent(\n    const CString& str,  \n    int nTabPositions,  \n    LPINT lpnTabStopPositions) const;\n\n \n```  \n  \n### Parameters  \n `lpszString`  \n Points to a character string to be measured. You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter.  \n  \n `nCount`  \n Specifies the number of characters in the string. If `nCount` is –1, the length is calculated.  \n  \n `nTabPositions`  \n Specifies the number of tab-stop positions in the array pointed to by `lpnTabStopPositions`.  \n  \n `lpnTabStopPositions`  \n Points to an array of integers containing the tab-stop positions in logical units. The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array. Back tabs are not allowed.  \n  \n `str`  \n A `CString` object that contains the specified characters to be measured.  \n  \n### Return Value  \n The dimensions of the string (in logical units) in a [CSize](../../atl-mfc-shared/reference/csize-class.md) object.  \n  \n### Remarks  \n If the string contains one or more tab characters, the width of the string is based upon the tab stops specified by `lpnTabStopPositions`. The function uses the currently selected font to compute the dimensions of the string.  \n  \n The current clipping region does not offset the width and height returned by the `GetOutputTabbedTextExtent` function.  \n  \n Since some devices do not place characters in regular cell arrays (that is, they kern the characters), the sum of the extents of the characters in a string may not be equal to the extent of the string.  \n  \n If `nTabPositions` is 0 and `lpnTabStopPositions` is **NULL**, tabs are expanded to eight average character widths. If `nTabPositions` is 1, the tab stops will be separated by the distance specified by the first value in the array to which `lpnTabStopPositions` points. If `lpnTabStopPositions` points to more than a single value, a tab stop is set for each value in the array, up to the number specified by `nTabPositions`.  \n  \n##  <a name=\"cdc__getoutputtextextent\"></a>  CDC::GetOutputTextExtent  \n Call this member function to use the output device context, [m_hDC](#cdc__m_hdc), and compute the width and height of a line of text, using the current font.  \n  \n```  \nCSize GetOutputTextExtent(\n    LPCTSTR lpszString,  \n    int nCount) const;\n\n \n \nCSize GetOutputTextExtent(\n    const CString& str) const;\n\n \n```  \n  \n### Parameters  \n `lpszString`  \n Points to a string of characters. You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter.  \n  \n `nCount`  \n Specifies the number of characters in the string. If `nCount` is –1, the length is calculated.  \n  \n `str`  \n A `CString` object that contains the specified characters to be measured.  \n  \n### Return Value  \n The dimensions of the string (in logical units) returned in a [CSize](../../atl-mfc-shared/reference/csize-class.md) object.  \n  \n### Remarks  \n The current clipping region does not affect the width and height returned by `GetOutputTextExtent`.  \n  \n Since some devices do not place characters in regular cell arrays (that is, they carry out kerning), the sum of the extents of the characters in a string may not be equal to the extent of the string.  \n  \n##  <a name=\"cdc__getoutputtextmetrics\"></a>  CDC::GetOutputTextMetrics  \n Retrieves the metrics for the current font using `m_hDC`, the output device context.  \n  \n```  \nBOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;\n\n \n```  \n  \n### Parameters  \n `lpMetrics`  \n Points to the [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure that receives the metrics.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n##  <a name=\"cdc__getpath\"></a>  CDC::GetPath  \n Retrieves the coordinates defining the endpoints of lines and the control points of curves found in the path that is selected into the device context.  \n  \n```  \nint GetPath(\n    LPPOINT lpPoints,  \n    LPBYTE lpTypes,  \n    int nCount) const;\n\n \n```  \n  \n### Parameters  \n `lpPoints`  \n Points to an array of [POINT](../../mfc/reference/point-structure1.md) data structures or `CPoint` objects where the line endpoints and curve control points are placed.  \n  \n `lpTypes`  \n Points to an array of bytes where the vertex types are placed. Values are one of the following:  \n  \n- **PT_MOVETO** Specifies that the corresponding point in `lpPoints` starts a disjoint figure.  \n  \n- **PT_LINETO** Specifies that the previous point and the corresponding point in `lpPoints` are the endpoints of a line.  \n  \n- **PT_BEZIERTO** Specifies that the corresponding point in `lpPoints` is a control point or ending point for a Bzier curve.  \n  \n **PT_BEZIERTO** types always occur in sets of three. The point in the path immediately preceding them defines the starting point for the Bzier curve. The first two **PT_BEZIERTO** points are the control points, and the third **PT_BEZIERTO** point is the end point (if hard-coded).  \n  \n     A **PT_LINETO** or **PT_BEZIERTO** type may be combined with the following flag (by using the bitwise operator `OR`) to indicate that the corresponding point is the last point in a figure and that the figure should be closed:  \n  \n- **PT_CLOSEFIGURE** Specifies that the figure is automatically closed after the corresponding line or curve is drawn. The figure is closed by drawing a line from the line or curve endpoint to the point corresponding to the last **PT_MOVETO**.  \n  \n `nCount`  \n Specifies the total number of [POINT](../../mfc/reference/point-structure1.md) data structures that may be placed in the `lpPoints` array. This value must be the same as the number of bytes that may be placed in the `lpTypes` array.  \n  \n### Return Value  \n If the `nCount` parameter is nonzero, the number of points enumerated. If `nCount` is 0, the total number of points in the path (and `GetPath` writes nothing to the buffers). If `nCount` is nonzero and is less than the number of points in the path, the return value is -1.  \n  \n### Remarks  \n The device context must contain a closed path. The points of the path are returned in logical coordinates. Points are stored in the path in device coordinates, so `GetPath` changes the points from device coordinates to logical coordinates by using the inverse of the current transformation. The `FlattenPath` member function may be called before `GetPath`, to convert all curves in the path into line segments.  \n  \n### Example  \n  See the example for [CDC::BeginPath](#cdc__beginpath).  \n  \n##  <a name=\"cdc__getpixel\"></a>  CDC::GetPixel  \n Retrieves the RGB color value of the pixel at the point specified by *x* and *y*.  \n  \n```  \nCOLORREF GetPixel(\n    int x,  \n    int y) const;\n\n \n \nCOLORREF GetPixel(\n    POINT point) const;\n\n \n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the point to be examined.  \n  \n *y*  \n Specifies the logical y-coordinate of the point to be examined.  \n  \n `point`  \n Specifies the logical x- and y-coordinates of the point to be examined.  \n  \n### Return Value  \n For either version of the function, an RGB color value for the color of the given point. It is –1 if the coordinates do not specify a point in the clipping region.  \n  \n### Remarks  \n The point must be in the clipping region. If the point is not in the clipping region, the function has no effect and returns –1.  \n  \n Not all devices support the **GetPixel** function. For more information, see the **RC_BITBLT** raster capability under the [GetDeviceCaps](#cdc__getdevicecaps) member function.  \n  \n The **GetPixel** member function has two forms. The first takes two coordinate values; the second takes either a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object.  \n  \n##  <a name=\"cdc__getpolyfillmode\"></a>  CDC::GetPolyFillMode  \n Retrieves the current polygon-filling mode.  \n  \n```  \nint GetPolyFillMode() const;\n\n \n```  \n  \n### Return Value  \n The current polygon-filled mode, **ALTERNATE** or **WINDING**, if the function is successful.  \n  \n### Remarks  \n See the `SetPolyFillMode` member function for a description of the polygon-filling modes.  \n  \n##  <a name=\"cdc__getrop2\"></a>  CDC::GetROP2  \n Retrieves the current drawing mode.  \n  \n```  \nint GetROP2() const;\n\n \n```  \n  \n### Return Value  \n The drawing mode. For a list of the drawing mode values, see the `SetROP2` member function.  \n  \n### Remarks  \n The drawing mode specifies how the colors of the pen and the interior of filled objects are combined with the color already on the display surface.  \n  \n##  <a name=\"cdc__getsafehdc\"></a>  CDC::GetSafeHdc  \n Call this member function to get [m_hDC](#cdc__m_hdc), the output device context.  \n  \n```  \nHDC GetSafeHdc() const;\n\n \n```  \n  \n### Return Value  \n A device context handle.  \n  \n### Remarks  \n This member function also works with null pointers.  \n  \n##  <a name=\"cdc__getstretchbltmode\"></a>  CDC::GetStretchBltMode  \n Retrieves the current bitmap-stretching mode.  \n  \n```  \nint GetStretchBltMode() const;\n\n \n```  \n  \n### Return Value  \n The return value specifies the current bitmap-stretching mode — **STRETCH_ANDSCANS**, **STRETCH_DELETESCANS**, or **STRETCH_ORSCANS** — if the function is successful.  \n  \n### Remarks  \n The bitmap-stretching mode defines how information is removed from bitmaps that are stretched or compressed by the `StretchBlt` member function.  \n  \n The **STRETCH_ANDSCANS** and **STRETCH_ORSCANS** modes are typically used to preserve foreground pixels in monochrome bitmaps. The **STRETCH_DELETESCANS** mode is typically used to preserve color in color bitmaps.  \n  \n##  <a name=\"cdc__gettabbedtextextent\"></a>  CDC::GetTabbedTextExtent  \n Call this member function to compute the width and height of a character string using [m_hAttribDC](#cdc__m_hattribdc), the attribute device context.  \n  \n```  \nCSize GetTabbedTextExtent(\n    LPCTSTR lpszString,  \n    int nCount,  \n    int nTabPositions,  \n    LPINT lpnTabStopPositions) const;\n\n \n \nCSize GetTabbedTextExtent(\n    const CString& str,  \n    int nTabPositions,  \n    LPINT lpnTabStopPositions) const;\n\n \n```  \n  \n### Parameters  \n `lpszString`  \n Points to a character string. You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter.  \n  \n `nCount`  \n Specifies the number of characters in the string. If `nCount` is –1, the length is calculated.  \n  \n `nTabPositions`  \n Specifies the number of tab-stop positions in the array pointed to by `lpnTabStopPositions`.  \n  \n `lpnTabStopPositions`  \n Points to an array of integers containing the tab-stop positions in logical units. The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array. Back tabs are not allowed.  \n  \n `str`  \n A `CString` object that contains the specified characters to be drawn.  \n  \n### Return Value  \n The dimensions of the string (in logical units) in a [CSize](../../atl-mfc-shared/reference/csize-class.md) object.  \n  \n### Remarks  \n If the string contains one or more tab characters, the width of the string is based upon the tab stops specified by `lpnTabStopPositions`. The function uses the currently selected font to compute the dimensions of the string.  \n  \n The current clipping region does not offset the width and height returned by the `GetTabbedTextExtent` function.  \n  \n Since some devices do not place characters in regular cell arrays (that is, they kern the characters), the sum of the extents of the characters in a string may not be equal to the extent of the string.  \n  \n If `nTabPositions` is 0 and `lpnTabStopPositions` is **NULL**, tabs are expanded to eight times the average character width. If `nTabPositions` is 1, the tab stops will be separated by the distance specified by the first value in the array to which `lpnTabStopPositions` points. If `lpnTabStopPositions` points to more than a single value, a tab stop is set for each value in the array, up to the number specified by `nTabPositions`.  \n  \n##  <a name=\"cdc__gettextalign\"></a>  CDC::GetTextAlign  \n Retrieves the status of the text-alignment flags for the device context.  \n  \n```  \nUINT GetTextAlign() const;\n\n \n```  \n  \n### Return Value  \n The status of the text-alignment flags. The return value is one or more of the following values:  \n  \n- **TA_BASELINE** Specifies alignment of the x-axis and the baseline of the chosen font within the bounding rectangle.  \n  \n- **TA_BOTTOM** Specifies alignment of the x-axis and the bottom of the bounding rectangle.  \n  \n- **TA_CENTER** Specifies alignment of the y-axis and the center of the bounding rectangle.  \n  \n- **TA_LEFT** Specifies alignment of the y-axis and the left side of the bounding rectangle.  \n  \n- **TA_NOUPDATECP** Specifies that the current position is not updated.  \n  \n- **TA_RIGHT** Specifies alignment of the y-axis and the right side of the bounding rectangle.  \n  \n- **TA_TOP** Specifies alignment of the x-axis and the top of the bounding rectangle.  \n  \n- **TA_UPDATECP** Specifies that the current position is updated.  \n  \n### Remarks  \n The text-alignment flags determine how the `TextOut` and `ExtTextOut` member functions align a string of text in relation to the string's starting point. The text-alignment flags are not necessarily single-bit flags and may be equal to 0. To test whether a flag is set, an application should follow these steps:  \n  \n1.  Apply the bitwise OR operator to the flag and its related flags, grouped as follows:  \n  \n    - **TA_LEFT**, **TA_CENTER**, and **TA_RIGHT**  \n  \n    - **TA_BASELINE**, **TA_BOTTOM**, and **TA_TOP**  \n  \n    - **TA_NOUPDATECP** and **TA_UPDATECP**  \n  \n2.  Apply the bitwise-AND operator to the result and the return value of `GetTextAlign`.  \n  \n3.  Test for the equality of this result and the flag.  \n  \n##  <a name=\"cdc__gettextcharacterextra\"></a>  CDC::GetTextCharacterExtra  \n Retrieves the current setting for the amount of intercharacter spacing.  \n  \n```  \nint GetTextCharacterExtra() const;\n\n \n```  \n  \n### Return Value  \n The amount of the intercharacter spacing.  \n  \n### Remarks  \n GDI adds this spacing to each character, including break characters, when it writes a line of text to the device context.  \n  \n The default value for the amount of intercharacter spacing is 0.  \n  \n##  <a name=\"cdc__gettextcolor\"></a>  CDC::GetTextColor  \n Retrieves the current text color.  \n  \n```  \nCOLORREF GetTextColor() const;\n\n \n```  \n  \n### Return Value  \n The current text color as an RGB color value.  \n  \n### Remarks  \n The text color is the foreground color of characters drawn by using the GDI text-output member functions [TextOut](#cdc__textout), [ExtTextOut](#cdc__exttextout), and [TabbedTextOut](#cdc__tabbedtextout).  \n  \n##  <a name=\"cdc__gettextextent\"></a>  CDC::GetTextExtent  \n Call this member function to compute the width and height of a line of text using the current font to determine the dimensions.  \n  \n```  \nCSize GetTextExtent(\n    LPCTSTR lpszString,  \n    int nCount) const;\n\n \n \nCSize GetTextExtent(\n    const CString& str) const;\n\n \n```  \n  \n### Parameters  \n `lpszString`  \n Points to a string of characters. You can also pass a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter.  \n  \n `nCount`  \n Specifies the number of characters in the string.  \n  \n `str`  \n A `CString` object that contains the specified characters.  \n  \n### Return Value  \n The dimensions of the string (in logical units) in a [CSize](../../atl-mfc-shared/reference/csize-class.md) object.  \n  \n### Remarks  \n The information is retrieved from [m_hAttribDC](#cdc__m_hattribdc), the attribute device context.  \n  \n By default, `GetTextExtent` assumes the text for which it retrieves the dimension is set along a horizontal line (that is, the escapement is 0). If you create a font specifying a non-zero escapement, you must convert the angle of the text explicitly to get the dimensions of the string.  \n  \n The current clipping region does not affect the width and height returned by `GetTextExtent`.  \n  \n Since some devices do not place characters in regular cell arrays (that is, they carry out kerning), the sum of the extents of the characters in a string may not be equal to the extent of the string.  \n  \n##  <a name=\"cdc__gettextextentexpointi\"></a>  CDC::GetTextExtentExPointI  \n Retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters.  \n  \n```  \nBOOL GetTextExtentExPointI(\n    LPWORD pgiIn,  \n    int cgi,  \n    int nMaxExtent,  \n    LPINT lpnFit,  \n    LPINT alpDx,  \n    LPSIZE lpSize) const;\n\n \n```  \n  \n### Parameters  \n `pgiIn`  \n A pointer to an array of glyph indices for which extents are to be retrieved.  \n  \n `cgi`  \n Specifies the number of glyphs in the array pointed to by `pgiIn`.  \n  \n `nMaxExtent`  \n Specifies the maximum allowable width, in logical units, of the formatted string.  \n  \n `lpnFit`  \n A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by `nMaxExtent`. When `lpnFit` is **NULL**, `nMaxExtent` is ignored.  \n  \n *alpDx*  \n A pointer to an array of integers that receives partial glyph extents. Each element in the array gives the distance, in logical units, between the beginning of the glyph indices array and one of the glyphs that fits in the space specified by `nMaxExtent`. Although this array should have at least as many elements as glyph indices specified by `cgi`, the function fills the array with extents only for as many glyph indices as are specified by `lpnFit`. If *lpnDx* is **NULL**, the function does not compute partial string widths.  \n  \n `lpSize`  \n Pointer to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure that receives the dimensions of the glyph indices array, in logical units. This value cannot be **NULL**.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n This member function emulates the functionality of the function [GetTextExtentExPointI](http://msdn.microsoft.com/library/windows/desktop/dd144936), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__gettextextentpointi\"></a>  CDC::GetTextExtentPointI  \n Retrieves the width and height of the specified array of glyph indices.  \n  \n```  \nBOOL GetTextExtentPointI(\n    LPWORD pgiIn,  \n    int cgi,  \n    LPSIZE lpSize) const;\n\n \n```  \n  \n### Parameters  \n `pgiIn`  \n A pointer to an array of glyph indices for which extents are to be retrieved.  \n  \n `cgi`  \n Specifies the number of glyphs in the array pointed to by `pgiIn`.  \n  \n `lpSize`  \n Pointer to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure that receives the dimensions of the glyph indices array, in logical units. This value cannot be **NULL**.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n This member function emulates the functionality of the function [GetTextExtentPointI](http://msdn.microsoft.com/library/windows/desktop/dd144939), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__gettextface\"></a>  CDC::GetTextFace  \n Call this member function to copy the typeface name of the current font into a buffer.  \n  \n```  \nint GetTextFace(\n    int nCount,  \n    LPTSTR lpszFacename) const;\n\n \n \nint GetTextFace(\n    CString& rString) const;\n\n \n```  \n  \n### Parameters  \n `nCount`  \n Specifies the size of the buffer (in bytes). If the typeface name is longer than the number of bytes specified by this parameter, the name is truncated.  \n  \n *lpszFacename*  \n Points to the buffer for the typeface name.  \n  \n `rString`  \n A reference to a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object.  \n  \n### Return Value  \n The number of bytes copied to the buffer, not including the terminating null character. It is 0 if an error occurs.  \n  \n### Remarks  \n The typeface name is copied as a null-terminated string.  \n  \n##  <a name=\"cdc__gettextmetrics\"></a>  CDC::GetTextMetrics  \n Retrieves the metrics for the current font using the attribute device context.  \n  \n```  \nBOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;\n\n \n```  \n  \n### Parameters  \n `lpMetrics`  \n Points to the [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure that receives the metrics.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n##  <a name=\"cdc__getviewportext\"></a>  CDC::GetViewportExt  \n Retrieves the x- and y-extents of the device context's viewport.  \n  \n```  \nCSize GetViewportExt() const;\n\n \n```  \n  \n### Return Value  \n The x- and y-extents (in device units) as a `CSize` object.  \n  \n##  <a name=\"cdc__getviewportorg\"></a>  CDC::GetViewportOrg  \n Retrieves the x- and y-coordinates of the origin of the viewport associated with the device context.  \n  \n```  \nCPoint GetViewportOrg() const;\n\n \n```  \n  \n### Return Value  \n The origin of the viewport (in device coordinates) as a `CPoint` object.  \n  \n##  <a name=\"cdc__getwindow\"></a>  CDC::GetWindow  \n Returns the window associated with the display device context.  \n  \n```  \nCWnd* GetWindow() const;\n\n \n```  \n  \n### Return Value  \n Pointer to a `CWnd` object if successful; otherwise **NULL**.  \n  \n### Remarks  \n This is an advanced function. For example, this member function may not return the view window when printing or in print preview. It always returns the window associated with output. Output functions that use the given DC draw into this window.  \n  \n##  <a name=\"cdc__getwindowext\"></a>  CDC::GetWindowExt  \n Retrieves the x- and y-extents of the window associated with the device context.  \n  \n```  \nCSize GetWindowExt() const;\n\n \n```  \n  \n### Return Value  \n The x- and y-extents (in logical units) as a `CSize` object.  \n  \n##  <a name=\"cdc__getwindoworg\"></a>  CDC::GetWindowOrg  \n Retrieves the x- and y-coordinates of the origin of the window associated with the device context.  \n  \n```  \nCPoint GetWindowOrg() const;\n\n \n```  \n  \n### Return Value  \n The origin of the window (in logical coordinates) as a `CPoint` object.  \n  \n##  <a name=\"cdc__getworldtransform\"></a>  CDC::GetWorldTransform  \n Retrieves the current world-space to page-space transformation.  \n  \n```  \nBOOL GetWorldTransform(XFORM& rXform) const;\n\n \n```  \n  \n### Parameters  \n `rXform`  \n Reference to an [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure that receives the current world-space to page-space transformation.  \n  \n### Return Value  \n Returns a nonzero value on success.  \n  \n Returns 0 on failure.  \n  \n To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  \n  \n### Remarks  \n This method wraps the Windows GDI function [GetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd144953).  \n  \n##  <a name=\"cdc__gradientfill\"></a>  CDC::GradientFill  \n Call this member function to fill rectangle and triangle structures with color that smoothly fades from one side to the other.  \n  \n```  \nBOOL GradientFill(\n    TRIVERTEX* pVertices,  \n    ULONG nVertices,  \n    void* pMesh,  \n    ULONG nMeshElements,  \n    DWORD dwMode);\n```  \n  \n### Parameters  \n *pVertices*  \n Pointer to an array of [TRIVERTEX](http://msdn.microsoft.com/library/windows/desktop/dd145142) structures that each define a triangle vertex.  \n  \n *nVertices*  \n The number of vertices.  \n  \n `pMesh`  \n Array of [GRADIENT_TRIANGLE](http://msdn.microsoft.com/library/windows/desktop/dd144959) structures in triangle mode, or an array of [GRADIENT_RECT](http://msdn.microsoft.com/library/windows/desktop/dd144958) structures in rectangle mode.  \n  \n *nMeshElements*  \n The number of elements (triangles or rectangles) in `pMesh`.  \n  \n `dwMode`  \n Specifies gradient fill mode. For a list of possible values, see [GradientFill](http://msdn.microsoft.com/library/windows/desktop/dd144957) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n### Return Value  \n **TRUE** if successful; otherwise **FALSE**.  \n  \n### Remarks  \n For more information, see `GradientFill` in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__graystring\"></a>  CDC::GrayString  \n Draws dimmed (gray) text at the given location by writing the text in a memory bitmap, dimming the bitmap, and then copying the bitmap to the display.  \n  \n```  \nvirtual BOOL GrayString(\n    CBrush* pBrush,  \n    BOOL (\n    CALLBACK* lpfnOutput)(\n    HDC,\n    LPARAM,\n    int),  \n    LPARAM lpData,  \n    int nCount,  \n    int x,  \n    int y,  \n    int nWidth,  \n    int nHeight);\n```  \n  \n### Parameters  \n `pBrush`  \n Identifies the brush to be used for dimming (graying).  \n  \n `lpfnOutput`  \n Specifies the procedure-instance address of the application-supplied callback function that will draw the string. For more information, see the description of the Windows **OutputFunc** [callback function](../../mfc/reference/callback-function-for-cdc-graystring.md). If this parameter is **NULL**, the system uses the Windows `TextOut` function to draw the string, and `lpData` is assumed to be a long pointer to the character string to be output.  \n  \n `lpData`  \n Specifies a far pointer to data to be passed to the output function. If `lpfnOutput` is **NULL**, `lpData` must be a long pointer to the string to be output.  \n  \n `nCount`  \n Specifies the number of characters to be output. If this parameter is 0, `GrayString` calculates the length of the string (assuming that `lpData` is a pointer to the string). If `nCount` is –1 and the function pointed to by `lpfnOutput` returns 0, the image is shown but not dimmed.  \n  \n *x*  \n Specifies the logical x-coordinate of the starting position of the rectangle that encloses the string.  \n  \n *y*  \n Specifies the logical y-coordinate of the starting position of the rectangle that encloses the string.  \n  \n `nWidth`  \n Specifies the width (in logical units) of the rectangle that encloses the string. If `nWidth` is 0, `GrayString` calculates the width of the area, assuming `lpData` is a pointer to the string.  \n  \n `nHeight`  \n Specifies the height (in logical units) of the rectangle that encloses the string. If `nHeight` is 0, `GrayString` calculates the height of the area, assuming `lpData` is a pointer to the string.  \n  \n### Return Value  \n Nonzero if the string is drawn, or 0 if either the `TextOut` function or the application-supplied output function returned 0, or if there was insufficient memory to create a memory bitmap for dimming.  \n  \n### Remarks  \n The function dims the text regardless of the selected brush and background. The `GrayString` member function uses the currently selected font. The `MM_TEXT` mapping mode must be selected before using this function.  \n  \n An application can draw dimmed (grayed) strings on devices that support a solid gray color without calling the `GrayString` member function. The system color **COLOR_GRAYTEXT** is the solid-gray system color used to draw disabled text. The application can call the **GetSysColor** Windows function to retrieve the color value of **COLOR_GRAYTEXT**. If the color is other than 0 (black), the application can call the `SetTextColor` member function to set the text color to the color value and then draw the string directly. If the retrieved color is black, the application must call `GrayString` to dim (gray) the text.  \n  \n If `lpfnOutput` is **NULL**, GDI uses the Windows [TextOut](http://msdn.microsoft.com/library/windows/desktop/dd145133) function, and `lpData` is assumed to be a far pointer to the character to be output. If the characters to be output cannot be handled by the `TextOut` member function (for example, the string is stored as a bitmap), the application must supply its own output function.  \n  \n Also note that all callback functions must trap Microsoft Foundation exceptions before returning to Windows, since exceptions cannot be thrown across callback boundaries. For more information about exceptions, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md).  \n  \n The callback function passed to `GrayString` must use the `__stdcall` calling convention and must be exported with `__declspec`.  \n  \n When the framework is in preview mode, a call to the `GrayString` member function is translated to a `TextOut` call, and the callback function is not called.  \n  \n##  <a name=\"cdc__himetrictodp\"></a>  CDC::HIMETRICtoDP  \n Use this function when you convert **HIMETRIC** sizes from OLE to pixels.  \n  \n```  \nvoid HIMETRICtoDP(LPSIZE lpSize) const;\n\n \n```  \n  \n### Parameters  \n `lpSize`  \n Points to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure or [CSize](../../atl-mfc-shared/reference/csize-class.md) object.  \n  \n### Remarks  \n If the mapping mode of the device context object is `MM_LOENGLISH`, `MM_HIENGLISH`, `MM_LOMETRIC` or `MM_HIMETRIC`, then the conversion is based on the number of pixels in the physical inch. If the mapping mode is one of the other non-constrained modes (e.g., `MM_TEXT`), then the conversion is based on the number of pixels in the logical inch.  \n  \n##  <a name=\"cdc__himetrictolp\"></a>  CDC::HIMETRICtoLP  \n Call this function to convert **HIMETRIC** units into logical units.  \n  \n```  \nvoid HIMETRICtoLP(LPSIZE lpSize) const;\n\n \n```  \n  \n### Parameters  \n `lpSize`  \n Points to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure or [CSize](../../atl-mfc-shared/reference/csize-class.md) object.  \n  \n### Remarks  \n Use this function when you get **HIMETRIC** sizes from OLE and wish to convert them to your application's natural mapping mode.  \n  \n The conversion is accomplished by first converting the **HIMETRIC** units into pixels and then converting these units into logical units using the device context's current mapping units. Note that the extents of the device's window and viewport will affect the result.  \n  \n##  <a name=\"cdc__intersectcliprect\"></a>  CDC::IntersectClipRect  \n Creates a new clipping region by forming the intersection of the current region and the rectangle specified by `x1`, `y1`, `x2`, and `y2`.  \n  \n```  \nint IntersectClipRect(\n    int x1,  \n    int y1,  \n    int x2,  \n    int y2);\n\n \nint IntersectClipRect(\n    LPCRECT lpRect);\n```  \n  \n### Parameters  \n `x1`  \n Specifies the logical x-coordinate of the upper-left corner of the rectangle.  \n  \n `y1`  \n Specifies the logical y-coordinate of the upper-left corner of the rectangle.  \n  \n `x2`  \n Specifies the logical x-coordinate of the lower-right corner of the rectangle.  \n  \n `y2`  \n Specifies the logical y-coordinate of the lower-right corner of the rectangle.  \n  \n `lpRect`  \n Specifies the rectangle. You can pass either a `CRect` object or a pointer to a `RECT` structure for this parameter.  \n  \n### Return Value  \n The new clipping region's type. It can be any one of the following values:  \n  \n- **COMPLEXREGION** New clipping region has overlapping borders.  \n  \n- **ERROR** Device context is not valid.  \n  \n- **NULLREGION** New clipping region is empty.  \n  \n- **SIMPLEREGION** New clipping region has no overlapping borders.  \n  \n### Remarks  \n GDI clips all subsequent output to fit within the new boundary. The width and height must not exceed 32,767.  \n  \n##  <a name=\"cdc__invertrect\"></a>  CDC::InvertRect  \n Inverts the contents of the given rectangle.  \n  \n```  \nvoid InvertRect(LPCRECT lpRect);\n```  \n  \n### Parameters  \n `lpRect`  \n Points to a `RECT` that contains the logical coordinates of the rectangle to be inverted. You can also pass a `CRect` object for this parameter.  \n  \n### Remarks  \n Inversion is a logical NOT operation and flips the bits of each pixel. On monochrome displays, the function makes white pixels black and black pixels white. On color displays, the inversion depends on how colors are generated for the display. Calling `InvertRect` twice with the same rectangle restores the display to its previous colors.  \n  \n If the rectangle is empty, nothing is drawn.  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]  \n  \n##  <a name=\"cdc__invertrgn\"></a>  CDC::InvertRgn  \n Inverts the colors in the region specified by `pRgn`.  \n  \n```  \nBOOL InvertRgn(CRgn* pRgn);\n```  \n  \n### Parameters  \n `pRgn`  \n Identifies the region to be inverted. The coordinates for the region are specified in logical units.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n On monochrome displays, the function makes white pixels black and black pixels white. On color displays, the inversion depends on how the colors are generated for the display.  \n  \n##  <a name=\"cdc__isprinting\"></a>  CDC::IsPrinting  \n Determines whether the device context is being used for printing.  \n  \n```  \nBOOL IsPrinting() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the `CDC` object is a printer DC; otherwise 0.  \n  \n##  <a name=\"cdc__lineto\"></a>  CDC::LineTo  \n Draws a line from the current position up to, but not including, the point specified by *x* and *y* (or `point`).  \n  \n```  \nBOOL LineTo(\n    int x,  \n    int y);\n\n \nBOOL LineTo(\n    POINT point);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the endpoint for the line.  \n  \n *y*  \n Specifies the logical y-coordinate of the endpoint for the line.  \n  \n `point`  \n Specifies the endpoint for the line. You can pass either a **POINT** structure or a `CPoint` object for this parameter.  \n  \n### Return Value  \n Nonzero if the line is drawn; otherwise 0.  \n  \n### Remarks  \n The line is drawn with the selected pen. The current position is set to *x*, *y* or to `point`.  \n  \n### Example  \n  See the example for [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#crect__centerpoint).  \n  \n##  <a name=\"cdc__lptodp\"></a>  CDC::LPtoDP  \n Converts logical units into device units.  \n  \n```  \nvoid LPtoDP(\n    LPPOINT lpPoints,  \n    int nCount = 1) const;\n\n \n \nvoid LPtoDP(\n    LPRECT lpRect) const;\n\n \n \nvoid LPtoDP(\n    LPSIZE lpSize) const;\n\n \n```  \n  \n### Parameters  \n `lpPoints`  \n Points to an array of points. Each point in the array is a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object.  \n  \n `nCount`  \n The number of points in the array.  \n  \n `lpRect`  \n Points to a [RECT](../../mfc/reference/rect-structure1.md) structure or a [CRect](../../atl-mfc-shared/reference/crect-class.md) object. This parameter is used for the common case of mapping a rectangle from logical to device units.  \n  \n `lpSize`  \n Points to a [SIZE](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure or a [CSize](../../atl-mfc-shared/reference/csize-class.md) object.  \n  \n### Remarks  \n The function maps the coordinates of each point, or dimensions of a size, from GDI's logical coordinate system into a device coordinate system. The conversion depends on the current mapping mode and the settings of the origins and extents of the device's window and viewport.  \n  \n The x- and y-coordinates of points are 2-byte signed integers in the range –32,768 through 32,767. In cases where the mapping mode would result in values larger than these limits, the system sets the values to –32,768 and 32,767, respectively.  \n  \n##  <a name=\"cdc__lptohimetric\"></a>  CDC::LPtoHIMETRIC  \n Call this function to convert logical units into **HIMETRIC** units.  \n  \n```  \nvoid LPtoHIMETRIC(LPSIZE lpSize) const;\n\n \n```  \n  \n### Parameters  \n `lpSize`  \n Points to a **SIZE** structure or a `CSize` object.  \n  \n### Remarks  \n Use this function when you give **HIMETRIC** sizes to OLE, converting from your application's natural mapping mode. Note that the extents of the device's window and viewport will affect the result.  \n  \n The conversion is accomplished by first converting the logical units into pixels using the device context's current mapping units and then converting these units into **HIMETRIC** units.  \n  \n##  <a name=\"cdc__m_hattribdc\"></a>  CDC::m_hAttribDC  \n The attribute device context for this `CDC` object.  \n  \n```  \nHDC m_hAttribDC;  \n```  \n  \n### Remarks  \n By default, this device context is equal to `m_hDC`. In general, `CDC` GDI calls that request information from the device context are directed to `m_hAttribDC`. See the [CDC](../../mfc/reference/cdc-class.md) class description for more on the use of these two device contexts.  \n  \n##  <a name=\"cdc__m_hdc\"></a>  CDC::m_hDC  \n The output device context for this `CDC` object.  \n  \n```  \nHDC m_hDC;  \n```  \n  \n### Remarks  \n By default, `m_hDC` is equal to `m_hAttribDC`, the other device context wrapped by `CDC`. In general, `CDC` GDI calls that create output go to the `m_hDC` device context. You can initialize `m_hDC` and `m_hAttribDC` to point to different devices. See the [CDC](../../mfc/reference/cdc-class.md) class description for more on the use of these two device contexts.  \n  \n##  <a name=\"cdc__maskblt\"></a>  CDC::MaskBlt  \n Combines the color data for the source and destination bitmaps using the given mask and raster operation.  \n  \n```  \nBOOL MaskBlt(\n    int x,  \n    int y,  \n    int nWidth,  \n    int nHeight,  \n    CDC* pSrcDC,  \n    int xSrc,  \n    int ySrc,  \n    CBitmap& maskBitmap,  \n    int xMask,  \n    int yMask,  \n    DWORD dwRop);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the upper-left corner of the destination rectangle.  \n  \n *y*  \n Specifies the logical y-coordinate of the upper-left corner of the destination rectangle.  \n  \n `nWidth`  \n Specifies the width, in logical units, of the destination rectangle and source bitmap.  \n  \n `nHeight`  \n Specifies the height, in logical units, of the destination rectangle and source bitmap.  \n  \n `pSrcDC`  \n Identifies the device context from which the bitmap is to be copied. It must be zero if the *dwRop* parameter specifies a raster operation that does not include a source.  \n  \n `xSrc`  \n Specifies the logical x-coordinate of the upper-left corner of the source bitmap.  \n  \n `ySrc`  \n Specifies the logical y-coordinate of the upper-left corner of the source bitmap.  \n  \n `maskBitmap`  \n Identifies the monochrome mask bitmap combined with the color bitmap in the source device context.  \n  \n `xMask`  \n Specifies the horizontal pixel offset for the mask bitmap specified by the `maskBitmap` parameter.  \n  \n `yMask`  \n Specifies the vertical pixel offset for the mask bitmap specified by the `maskBitmap` parameter.  \n  \n *dwRop*  \n Specifies both foreground and background ternary raster operation codes, which the function uses to control the combination of source and destination data. The background raster operation code is stored in the high byte of the high word of this value; the foreground raster operation code is stored in the low byte of the high word of this value; the low word of this value is ignored, and should be zero. The macro **MAKEROP4** creates such combinations of foreground and background raster operation codes. See the Remarks section for a discussion of foreground and background in the context of this function. See the `BitBlt` member function for a list of common raster operation codes.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n A value of 1 in the mask specified by `maskBitmap` indicates that the foreground raster operation code specified by *dwRop* should be applied at that location. A value of 0 in the mask indicates that the background raster operation code specified by *dwRop* should be applied at that location. If the raster operations require a source, the mask rectangle must cover the source rectangle. If it does not, the function will fail. If the raster operations do not require a source, the mask rectangle must cover the destination rectangle. If it does not, the function will fail.  \n  \n If a rotation or shear transformation is in effect for the source device context when this function is called, an error occurs. However, other types of transformations are allowed.  \n  \n If the color formats of the source, pattern, and destination bitmaps differ, this function converts the pattern or source format, or both, to match the destination format. If the mask bitmap is not a monochrome bitmap, an error occurs. When an enhanced metafile is being recorded, an error occurs (and the function returns 0) if the source device context identifies an enhanced-metafile device context. Not all devices support `MaskBlt`. An application should call `GetDeviceCaps` to determine whether a device supports this function. If no mask bitmap is supplied, this function behaves exactly like `BitBlt`, using the foreground raster operation code. The pixel offsets in the mask bitmap map to the point (0,0) in the source device context's bitmap. This is useful for cases in which a mask bitmap contains a set of masks; an application can easily apply any one of them to a mask-blitting task by adjusting the pixel offsets and rectangle sizes sent to `MaskBlt`.  \n  \n##  <a name=\"cdc__modifyworldtransform\"></a>  CDC::ModifyWorldTransform  \n Changes the world transformation for a device context using the specified mode.  \n  \n```  \nBOOL ModifyWorldTransform(\n    const XFORM& rXform,  \n    DWORD iMode);\n```  \n  \n### Parameters  \n `rXform`  \n Reference to an [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure used to modify the world transformation for the given device context.  \n  \n `iMode`  \n Specifies how the transformation data modifies the current world transformation. For a list of the values that this parameter can take, see [ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060).  \n  \n### Return Value  \n Returns a nonzero value on success.  \n  \n Returns 0 on failure.  \n  \n To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  \n  \n### Remarks  \n This method wraps the Windows GDI function [ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060).  \n  \n##  <a name=\"cdc__moveto\"></a>  CDC::MoveTo  \n Moves the current position to the point specified by *x* and *y* (or by `point`).  \n  \n```  \nCPoint MoveTo(\n    int x,  \n    int y);\n\n \nCPoint MoveTo(\n    POINT point);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the new position.  \n  \n *y*  \n Specifies the logical y-coordinate of the new position.  \n  \n `point`  \n Specifies the new position. You can pass either a **POINT** structure or a `CPoint` object for this parameter.  \n  \n### Return Value  \n The x- and y-coordinates of the previous position as a `CPoint` object.  \n  \n### Example  \n  See the example for [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#crect__centerpoint).  \n  \n##  <a name=\"cdc__offsetcliprgn\"></a>  CDC::OffsetClipRgn  \n Moves the clipping region of the device context by the specified offsets.  \n  \n```  \nint OffsetClipRgn(\n    int x,  \n    int y);\n\n \nint OffsetClipRgn(\n    SIZE size);\n```  \n  \n### Parameters  \n *x*  \n Specifies the number of logical units to move left or right.  \n  \n *y*  \n Specifies the number of logical units to move up or down.  \n  \n `size`  \n Specifies the amount to offset.  \n  \n### Return Value  \n The new region's type. It can be any one of the following values:  \n  \n- **COMPLEXREGION** Clipping region has overlapping borders.  \n  \n- **ERROR** Device context is not valid.  \n  \n- **NULLREGION** Clipping region is empty.  \n  \n- **SIMPLEREGION** Clipping region has no overlapping borders.  \n  \n### Remarks  \n The function moves the region *x* units along the x-axis and *y* units along the y-axis.  \n  \n##  <a name=\"cdc__offsetviewportorg\"></a>  CDC::OffsetViewportOrg  \n Modifies the coordinates of the viewport origin relative to the coordinates of the current viewport origin.  \n  \n```  \nvirtual CPoint OffsetViewportOrg(\n    int nWidth,  \n    int nHeight);\n```  \n  \n### Parameters  \n `nWidth`  \n Specifies the number of device units to add to the current origin's x-coordinate.  \n  \n `nHeight`  \n Specifies the number of device units to add to the current origin's y-coordinate.  \n  \n### Return Value  \n The previous viewport origin (in device coordinates) as a `CPoint` object.  \n  \n##  <a name=\"cdc__offsetwindoworg\"></a>  CDC::OffsetWindowOrg  \n Modifies the coordinates of the window origin relative to the coordinates of the current window origin.  \n  \n```  \nCPoint OffsetWindowOrg(\n    int nWidth,  \n    int nHeight);\n```  \n  \n### Parameters  \n `nWidth`  \n Specifies the number of logical units to add to the current origin's x-coordinate.  \n  \n `nHeight`  \n Specifies the number of logical units to add to the current origin's y-coordinate.  \n  \n### Return Value  \n The previous window origin (in logical coordinates) as a `CPoint` object.  \n  \n##  <a name=\"cdc__operator_hdc\"></a>  CDC::operator HDC  \n Use this operator to retrieve the device context handle of the `CDC` object.  \n  \n```  \noperator HDC() const;\n\n \n```  \n  \n### Return Value  \n If successful, the handle of the device context object; otherwise, **NULL**.  \n  \n### Remarks  \n You can use the handle to call Windows APIs directly.  \n  \n##  <a name=\"cdc__paintrgn\"></a>  CDC::PaintRgn  \n Fills the region specified by `pRgn` using the current brush.  \n  \n```  \nBOOL PaintRgn(CRgn* pRgn);\n```  \n  \n### Parameters  \n `pRgn`  \n Identifies the region to be filled. The coordinates for the given region are specified in logical units.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n##  <a name=\"cdc__patblt\"></a>  CDC::PatBlt  \n Creates a bit pattern on the device.  \n  \n```  \nBOOL PatBlt(\n    int x,  \n    int y,  \n    int nWidth,  \n    int nHeight,  \n    DWORD dwRop);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the upper-left corner of the rectangle that is to receive the pattern.  \n  \n *y*  \n Specifies the logical y-coordinate of the upper-left corner of the rectangle that is to receive the pattern.  \n  \n `nWidth`  \n Specifies the width (in logical units) of the rectangle that is to receive the pattern.  \n  \n `nHeight`  \n Specifies the height (in logical units) of the rectangle that is to receive the pattern.  \n  \n *dwRop*  \n Specifies the raster-operation code. Raster-operation codes (ROPs) define how GDI combines colors in output operations that involve a current brush, a possible source bitmap, and a destination bitmap. This parameter can be one of the following values:  \n  \n- **PATCOPY** Copies pattern to destination bitmap.  \n  \n- **PATINVERT** Combines destination bitmap with pattern using the Boolean XOR operator.  \n  \n- **DSTINVERT** Inverts the destination bitmap.  \n  \n- **BLACKNESS** Turns all output black.  \n  \n- **WHITENESS** Turns all output white.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The pattern is a combination of the selected brush and the pattern already on the device. The raster-operation code specified by *dwRop* defines how the patterns are to be combined. The raster operations listed for this function are a limited subset of the full 256 ternary raster-operation codes; in particular, a raster-operation code that refers to a source cannot be used.  \n  \n Not all device contexts support the `PatBlt` function. To determine whether a device context supports `PatBlt`, call the `GetDeviceCaps` member function with the **RASTERCAPS** index and check the return value for the **RC_BITBLT** flag.  \n  \n##  <a name=\"cdc__pie\"></a>  CDC::Pie  \n Draws a pie-shaped wedge by drawing an elliptical arc whose center and two endpoints are joined by lines.  \n  \n```  \nBOOL Pie(\n    int x1,  \n    int y1,  \n    int x2,  \n    int y2,  \n    int x3,  \n    int y3,  \n    int x4,  \n    int y4);\n\n \nBOOL Pie(\n    LPCRECT lpRect,\n    POINT ptStart,\n    POINT ptEnd);\n```  \n  \n### Parameters  \n `x1`  \n Specifies the x-coordinate of the upper-left corner of the bounding rectangle (in logical units).  \n  \n `y1`  \n Specifies the y-coordinate of the upper-left corner of the bounding rectangle (in logical units).  \n  \n `x2`  \n Specifies the x-coordinate of the lower-right corner of the bounding rectangle (in logical units).  \n  \n `y2`  \n Specifies the y-coordinate of the lower-right corner of the bounding rectangle (in logical units).  \n  \n *x3*  \n Specifies the x-coordinate of the arc's starting point (in logical units). This point does not have to lie exactly on the arc.  \n  \n `y3`  \n Specifies the y-coordinate of the arc's starting point (in logical units). This point does not have to lie exactly on the arc.  \n  \n `x4`  \n Specifies the x-coordinate of the arc's endpoint (in logical units). This point does not have to lie exactly on the arc.  \n  \n `y4`  \n Specifies the y-coordinate of the arc's endpoint (in logical units). This point does not have to lie exactly on the arc.  \n  \n `lpRect`  \n Specifies the bounding rectangle. You can pass either a `CRect` object or a pointer to a `RECT` structure for this parameter.  \n  \n `ptStart`  \n Specifies the starting point of the arc. This point does not have to lie exactly on the arc. You can pass either a [POINT](../../mfc/reference/point-structure1.md) structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter.  \n  \n `ptEnd`  \n Specifies the endpoint of the arc. This point does not have to lie exactly on the arc. You can pass either a **POINT** structure or a `CPoint` object for this parameter.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The center of the arc is the center of the bounding rectangle specified by `x1`, `y1`, `x2`, and `y2` (or by `lpRect`). The starting and ending points of the arc are specified by *x3*, `y3`, `x4`, and `y4` (or by `ptStart` and `ptEnd`).  \n  \n The arc is drawn with the selected pen, moving in a counterclockwise direction. Two additional lines are drawn from each endpoint to the arc's center. The pie-shaped area is filled with the current brush. If *x3* equals `x4` and `y3` equals `y4`, the result is an ellipse with a single line from the center of the ellipse to the point ( *x3*, `y3`) or ( `x4`, `y4`).  \n  \n The figure drawn by this function extends up to but does not include the right and bottom coordinates. This means that the height of the figure is `y2` – `y1` and the width of the figure is `x2` – `x1`. Both the width and the height of the bounding rectangle must be greater than 2 units and less than 32,767 units.  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]  \n  \n##  <a name=\"cdc__playmetafile\"></a>  CDC::PlayMetaFile  \n Plays the contents of the specified metafile on the device context.  \n  \n```  \nBOOL PlayMetaFile(\n    HMETAFILE hMF);\n\n \nBOOL PlayMetaFile(\n    HENHMETAFILE hEnhMetaFile,  \n    LPCRECT lpBounds);\n```  \n  \n### Parameters  \n *hMF*  \n Identifies the metafile to be played.  \n  \n *hEnhMetaFile*  \n Identifies the enhanced metafile.  \n  \n `lpBounds`  \n Points to a `RECT` structure or a `CRect` object that contains the coordinates of the bounding rectangle used to display the picture. The coordinates are specified in logical units.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The metafile can be played any number of times.  \n  \n The second version of `PlayMetaFile` displays the picture stored in the given enhanced-format metafile. When an application calls the second version of `PlayMetaFile`, Windows uses the picture frame in the enhanced-metafile header to map the picture onto the rectangle pointed to by the `lpBounds` parameter. (This picture may be sheared or rotated by setting the world transform in the output device before calling `PlayMetaFile`.) Points along the edges of the rectangle are included in the picture. An enhanced-metafile picture can be clipped by defining the clipping region in the output device before playing the enhanced metafile.  \n  \n If an enhanced metafile contains an optional palette, an application can achieve consistent colors by setting up a color palette on the output device before calling the second version of `PlayMetaFile`. To retrieve the optional palette, use the **GetEnhMetaFilePaletteEntries** Windows function. An enhanced metafile can be embedded in a newly created enhanced metafile by calling the second version of `PlayMetaFile` and playing the source enhanced metafile into the device context for the new enhanced metafile.  \n  \n The states of the output device context are preserved by this function. Any object created but not deleted in the enhanced metafile is deleted by this function. To stop this function, an application can call the **CancelDC** Windows function from another thread to terminate the operation. In this case, the function returns zero.  \n  \n##  <a name=\"cdc__plgblt\"></a>  CDC::PlgBlt  \n Performs a bit-block transfer of the bits of color data from the specified rectangle in the source device context to the specified parallelogram in the given device context.  \n  \n```  \nBOOL PlgBlt(\n    LPPOINT lpPoint,  \n    CDC* pSrcDC,  \n    int xSrc,  \n    int ySrc,  \n    int nWidth,  \n    int nHeight,  \n    CBitmap& maskBitmap,  \n    int xMask,  \n    int yMask);\n```  \n  \n### Parameters  \n `lpPoint`  \n Points to an array of three points in logical space that identifies three corners of the destination parallelogram. The upper-left corner of the source rectangle is mapped to the first point in this array, the upper-right corner to the second point in this array, and the lower-left corner to the third point. The lower-right corner of the source rectangle is mapped to the implicit fourth point in the parallelogram.  \n  \n `pSrcDC`  \n Identifies the source device context.  \n  \n `xSrc`  \n Specifies the x-coordinate, in logical units, of the upper-left corner of the source rectangle.  \n  \n `ySrc`  \n Specifies the y-coordinate, in logical units, of the upper-left corner of the source rectangle.  \n  \n `nWidth`  \n Specifies the width, in logical units, of the source rectangle.  \n  \n `nHeight`  \n Specifies the height, in logical units, of the source rectangle.  \n  \n `maskBitmap`  \n Identifies an optional monochrome bitmap that is used to mask the colors of the source rectangle.  \n  \n `xMask`  \n Specifies the x-coordinate of the upper-left corner of the monochrome bitmap.  \n  \n `yMask`  \n Specifies the y-coordinate of the upper-left corner of the monochrome bitmap.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n If the given bitmask handle identifies a valid monochrome bitmap, the function uses this bitmap to mask the bits of color data from the source rectangle.  \n  \n The fourth vertex of the parallelogram (D) is defined by treating the first three points (A, B, and C) as vectors and computing D = B + C - A.  \n  \n If the bitmask exists, a value of 1 in the mask indicates that the source pixel color should be copied to the destination. A value of 0 in the mask indicates that the destination pixel color is not to be changed.  \n  \n If the mask rectangle is smaller than the source and destination rectangles, the function replicates the mask pattern.  \n  \n Scaling, translation, and reflection transformations are allowed in the source device context; however, rotation and shear transformations are not. If the mask bitmap is not a monochrome bitmap, an error occurs. The stretching mode for the destination device context is used to determine how to stretch or compress the pixels, if that is necessary. When an enhanced metafile is being recorded, an error occurs if the source device context identifies an enhanced-metafile device context.  \n  \n The destination coordinates are transformed according to the destination device context; the source coordinates are transformed according to the source device context. If the source transformation has a rotation or shear, an error is returned. If the destination and source rectangles do not have the same color format, `PlgBlt` converts the source rectangle to match the destination rectangle. Not all devices support `PlgBlt`. For more information, see the description of the **RC_BITBLT** raster capability in the `CDC::GetDeviceCaps` member function.  \n  \n If the source and destination device contexts represent incompatible devices, `PlgBlt` returns an error.  \n  \n##  <a name=\"cdc__polybezier\"></a>  CDC::PolyBezier  \n Draws one or more Bzier splines.  \n  \n```  \nBOOL PolyBezier(\n    const POINT* lpPoints,  \n    int nCount);\n```  \n  \n### Parameters  \n `lpPoints`  \n Points to an array of [POINT](../../mfc/reference/point-structure1.md) data structures that contain the endpoints and control points of the spline(s).  \n  \n `nCount`  \n Specifies the number of points in the `lpPoints` array. This value must be one more than three times the number of splines to be drawn, because each Bzier spline requires two control points and an endpoint, and the initial spline requires an additional starting point.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n This function draws cubic Bzier splines by using the endpoints and control points specified by the `lpPoints` parameter. The first spline is drawn from the first point to the fourth point by using the second and third points as control points. Each subsequent spline in the sequence needs exactly three more points: the end point of the previous spline is used as the starting point, the next two points in the sequence are control points, and the third is the end point.  \n  \n The current position is neither used nor updated by the `PolyBezier` function. The figure is not filled. This function draws lines by using the current pen.  \n  \n##  <a name=\"cdc__polybezierto\"></a>  CDC::PolyBezierTo  \n Draws one or more Bzier splines.  \n  \n```  \nBOOL PolyBezierTo(\n    const POINT* lpPoints,  \n    int nCount);\n```  \n  \n### Parameters  \n `lpPoints`  \n Points to an array of [POINT](../../mfc/reference/point-structure1.md) data structures that contains the endpoints and control points.  \n  \n `nCount`  \n Specifies the number of points in the `lpPoints` array. This value must be three times the number of splines to be drawn, because each Bzier spline requires two control points and an end point.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n This function draws cubic Bzier splines by using the control points specified by the `lpPoints` parameter. The first spline is drawn from the current position to the third point by using the first two points as control points. For each subsequent spline, the function needs exactly three more points, and uses the end point of the previous spline as the starting point for the next. `PolyBezierTo` moves the current position to the end point of the last Bzier spline. The figure is not filled. This function draws lines by using the current pen.  \n  \n### Example  \n  See the example for [CDC::BeginPath](#cdc__beginpath).  \n  \n##  <a name=\"cdc__polydraw\"></a>  CDC::PolyDraw  \n Draws a set of line segments and Bzier splines.  \n  \n```  \nBOOL PolyDraw(\n    const POINT* lpPoints,  \n    const BYTE* lpTypes,  \n    int nCount);\n```  \n  \n### Parameters  \n `lpPoints`  \n Points to an array of [POINT](../../mfc/reference/point-structure1.md) data structures that contains the endpoints for each line segment and the endpoints and control points for each Bzier spline.  \n  \n `lpTypes`  \n Points to an array that specifies how each point in the `lpPoints` array is used. Values can be one of the following:  \n  \n- **PT_MOVETO** Specifies that this point starts a disjoint figure. This point becomes the new current position.  \n  \n- **PT_LINETO** Specifies that a line is to be drawn from the current position to this point, which then becomes the new current position.  \n  \n- **PT_BEZIERTO** Specifies that this point is a control point or ending point for a Bzier spline.  \n  \n **PT_BEZIERTO** types always occur in sets of three. The current position defines the starting point for the Bzier spline. The first two **PT_BEZIERTO** points are the control points, and the third **PT_BEZIERTO** point is the ending point. The ending point becomes the new current position. If there are not three consecutive **PT_BEZIERTO** points, an error results.  \n  \n     A **PT_LINETO** or **PT_BEZIERTO** type can be combined with the following constant by using the bitwise operator OR to indicate that the corresponding point is the last point in a figure and the figure is closed:  \n  \n- **PT_CLOSEFIGURE** Specifies that the figure is automatically closed after the **PT_LINETO** or **PT_BEZIERTO** type for this point is done. A line is drawn from this point to the most recent **PT_MOVETO** or `MoveTo` point.  \n  \n     This flag is combined with the **PT_LINETO** type for a line, or with the **PT_BEZIERTO** type of ending point for a Bzier spline, by using the bitwise `OR` operator. The current position is set to the ending point of the closing line.  \n  \n `nCount`  \n Specifies the total number of points in the `lpPoints` array, the same as the number of bytes in the `lpTypes` array.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n This function can be used to draw disjoint figures in place of consecutive calls to `CDC::MoveTo`, `CDC::LineTo`, and `CDC::PolyBezierTo` member functions. The lines and splines are drawn using the current pen, and figures are not filled. If there is an active path started by calling the `CDC::BeginPath` member function, `PolyDraw` adds to the path. The points contained in the `lpPoints` array and in `lpTypes` indicate whether each point is part of a `CDC::MoveTo`, a `CDC::LineTo`, or a **CDC::BezierTo** operation. It is also possible to close figures. This function updates the current position.  \n  \n### Example  \n  See the example for [CDC::BeginPath](#cdc__beginpath).  \n  \n##  <a name=\"cdc__polygon\"></a>  CDC::Polygon  \n Draws a polygon consisting of two or more points (vertices) connected by lines, using the current pen.  \n  \n```  \nBOOL Polygon(\n    LPPOINT lpPoints,  \n    int nCount);\n```  \n  \n### Parameters  \n `lpPoints`  \n Points to an array of points that specifies the vertices of the polygon. Each point in the array is a **POINT** structure or a `CPoint` object.  \n  \n `nCount`  \n Specifies the number of vertices in the array.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The system closes the polygon automatically, if necessary, by drawing a line from the last vertex to the first.  \n  \n The current polygon-filling mode can be retrieved or set by using the `GetPolyFillMode` and `SetPolyFillMode` member functions.  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]  \n  \n##  <a name=\"cdc__polyline\"></a>  CDC::Polyline  \n Draws a set of line segments connecting the points specified by `lpPoints`.  \n  \n```  \nBOOL Polyline(\n    LPPOINT lpPoints,  \n    int nCount);\n```  \n  \n### Parameters  \n `lpPoints`  \n Points to an array of **POINT** structures or `CPoint` objects to be connected.  \n  \n `nCount`  \n Specifies the number of points in the array. This value must be at least 2.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The lines are drawn from the first point through subsequent points using the current pen. Unlike the `LineTo` member function, the `Polyline` function neither uses nor updates the current position.  \n  \n For more information, see [PolyLine](http://msdn.microsoft.com/library/windows/desktop/dd162815) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__polylineto\"></a>  CDC::PolylineTo  \n Draws one or more straight lines.  \n  \n```  \nBOOL PolylineTo(\n    const POINT* lpPoints,  \n    int nCount);\n```  \n  \n### Parameters  \n `lpPoints`  \n Points to an array of [POINT](../../mfc/reference/point-structure1.md) data structures that contains the vertices of the line.  \n  \n `nCount`  \n Specifies the number of points in the array.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n A line is drawn from the current position to the first point specified by the `lpPoints` parameter by using the current pen. For each additional line, the function draws from the ending point of the previous line to the next point specified by `lpPoints`. `PolylineTo` moves the current position to the ending point of the last line. If the line segments drawn by this function form a closed figure, the figure is not filled.  \n  \n##  <a name=\"cdc__polypolygon\"></a>  CDC::PolyPolygon  \n Creates two or more polygons that are filled using the current polygon-filling mode.  \n  \n```  \nBOOL PolyPolygon(\n    LPPOINT lpPoints,  \n    LPINT lpPolyCounts,  \n    int nCount);\n```  \n  \n### Parameters  \n `lpPoints`  \n Points to an array of **POINT** structures or `CPoint` objects that define the vertices of the polygons.  \n  \n `lpPolyCounts`  \n Points to an array of integers, each of which specifies the number of points in one of the polygons in the `lpPoints` array.  \n  \n `nCount`  \n The number of entries in the `lpPolyCounts` array. This number specifies the number of polygons to be drawn. This value must be at least 2.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The polygons may be disjoint or overlapping.  \n  \n Each polygon specified in a call to the `PolyPolygon` function must be closed. Unlike polygons created by the **Polygon** member function, the polygons created by `PolyPolygon` are not closed automatically.  \n  \n The function creates two or more polygons. To create a single polygon, an application should use the **Polygon** member function.  \n  \n The current polygon-filling mode can be retrieved or set by using the `GetPolyFillMode` and `SetPolyFillMode` member functions.  \n  \n##  <a name=\"cdc__polypolyline\"></a>  CDC::PolyPolyline  \n Draws multiple series of connected line segments.  \n  \n```  \nBOOL PolyPolyline(\n    const POINT* lpPoints,  \n    const DWORD* lpPolyPoints,  \n    int nCount);\n```  \n  \n### Parameters  \n `lpPoints`  \n Points to an array of structures that contains the vertices of the polylines. The polylines are specified consecutively.  \n  \n `lpPolyPoints`  \n Points to an array of variables specifying the number of points in the `lpPoints` array for the corresponding polygon. Each entry must be greater than or equal to 2.  \n  \n `nCount`  \n Specifies the total number of counts in the `lpPolyPoints` array.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The line segments are drawn by using the current pen. The figures formed by the segments are not filled. The current position is neither used nor updated by this function.  \n  \n##  <a name=\"cdc__ptvisible\"></a>  CDC::PtVisible  \n Determines whether the given point is within the clipping region of the device context.  \n  \n```  \nvirtual BOOL PtVisible(\n    int x,  \n    int y) const;\n\n \n \nBOOL PtVisible(\n    POINT point) const;\n\n \n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the point.  \n  \n *y*  \n Specifies the logical y-coordinate of the point.  \n  \n `point`  \n Specifies the point to check in logical coordinates. You can pass either a **POINT** structure or a `CPoint` object for this parameter.  \n  \n### Return Value  \n Nonzero if the specified point is within the clipping region; otherwise 0.  \n  \n##  <a name=\"cdc__queryabort\"></a>  CDC::QueryAbort  \n Calls the abort function installed by the [SetAbortProc](#cdc__setabortproc) member function for a printing application and queries whether the printing should be terminated.  \n  \n```  \nBOOL QueryAbort() const;\n\n \n```  \n  \n### Return Value  \n The return value is nonzero if printing should continue or if there is no abort procedure. It is 0 if the print job should be terminated. The return value is supplied by the abort function.  \n  \n##  <a name=\"cdc__realizepalette\"></a>  CDC::RealizePalette  \n Maps entries from the current logical palette to the system palette.  \n  \n```  \nUINT RealizePalette();\n```  \n  \n### Return Value  \n Indicates how many entries in the logical palette were mapped to different entries in the system palette. This represents the number of entries that this function remapped to accommodate changes in the system palette since the logical palette was last realized.  \n  \n### Remarks  \n A logical color palette acts as a buffer between color-intensive applications and the system, allowing an application to use as many colors as needed without interfering with its own displayed colors or with colors displayed by other windows.  \n  \n When a window has the input focus and calls `RealizePalette`, Windows ensures that the window will display all the requested colors, up to the maximum number simultaneously available on the screen. Windows also displays colors not found in the window's palette by matching them to available colors.  \n  \n In addition, Windows matches the colors requested by inactive windows that call the function as closely as possible to the available colors. This significantly reduces undesirable changes in the colors displayed in inactive windows.  \n  \n##  <a name=\"cdc__rectangle\"></a>  CDC::Rectangle  \n Draws a rectangle using the current pen.  \n  \n```  \nBOOL Rectangle(\n    int x1,  \n    int y1,  \n    int x2,  \n    int y2);\n\n \nBOOL Rectangle(\n    LPCRECT lpRect);\n```  \n  \n### Parameters  \n `x1`  \n Specifies the x-coordinate of the upper-left corner of the rectangle (in logical units).  \n  \n `y1`  \n Specifies the y-coordinate of the upper-left corner of the rectangle (in logical units).  \n  \n `x2`  \n Specifies the x-coordinate of the lower-right corner of the rectangle (in logical units).  \n  \n `y2`  \n Specifies the y-coordinate of the lower-right corner of the rectangle (in logical units).  \n  \n `lpRect`  \n Specifies the rectangle in logical units. You can pass either a `CRect` object or a pointer to a `RECT` structure for this parameter.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The interior of the rectangle is filled using the current brush.  \n  \n The rectangle extends up to, but does not include, the right and bottom coordinates. This means that the height of the rectangle is `y2` – `y1` and the width of the rectangle is `x2` – `x1`. Both the width and the height of a rectangle must be greater than 2 units and less than 32,767 units.  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]  \n  \n##  <a name=\"cdc__rectvisible\"></a>  CDC::RectVisible  \n Determines whether any part of the given rectangle lies within the clipping region of the display context.  \n  \n```  \nvirtual BOOL RectVisible(LPCRECT lpRect) const;\n\n \n```  \n  \n### Parameters  \n `lpRect`  \n Points to a `RECT` structure or a `CRect` object that contains the logical coordinates of the specified rectangle.  \n  \n### Return Value  \n Nonzero if any portion of the given rectangle lies within the clipping region; otherwise 0.  \n  \n##  <a name=\"cdc__releaseattribdc\"></a>  CDC::ReleaseAttribDC  \n Call this member function to set `m_hAttribDC` to **NULL**.  \n  \n```  \nvirtual void ReleaseAttribDC();\n```  \n  \n### Remarks  \n This does not cause a **Detach** to occur. Only the output device context is attached to the `CDC` object, and only it can be detached.  \n  \n##  <a name=\"cdc__releaseoutputdc\"></a>  CDC::ReleaseOutputDC  \n Call this member function to set the `m_hDC` member to **NULL**.  \n  \n```  \nvirtual void ReleaseOutputDC();\n```  \n  \n### Remarks  \n This member function cannot be called when the output device context is attached to the `CDC` object. Use the **Detach** member function to detach the output device context.  \n  \n##  <a name=\"cdc__resetdc\"></a>  CDC::ResetDC  \n Call this member function to update the device context wrapped by the `CDC` object.  \n  \n```  \nBOOL ResetDC(const DEVMODE* lpDevMode);\n```  \n  \n### Parameters  \n *lpDevMode*  \n A pointer to a Windows `DEVMODE` structure.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The device context is updated from the information specified in the Windows `DEVMODE` structure. This member function only resets the attribute device context.  \n  \n An application will typically use the `ResetDC` member function when a window processes a `WM_DEVMODECHANGE` message. You can also use this member function to change the paper orientation or paper bins while printing a document.  \n  \n You cannot use this member function to change the driver name, device name, or output port. When the user changes the port connection or device name, you must delete the original device context and create a new device context with the new information.  \n  \n Before you call this member function, you must ensure that all objects (other than stock objects) that had been selected into the device context have been selected out.  \n  \n##  <a name=\"cdc__restoredc\"></a>  CDC::RestoreDC  \n Restores the device context to the previous state identified by `nSavedDC`.  \n  \n```  \nvirtual BOOL RestoreDC(int nSavedDC);\n```  \n  \n### Parameters  \n `nSavedDC`  \n Specifies the device context to be restored. It can be a value returned by a previous `SaveDC` function call. If `nSavedDC` is –1, the most recently saved device context is restored.  \n  \n### Return Value  \n Nonzero if the specified context was restored; otherwise 0.  \n  \n### Remarks  \n `RestoreDC` restores the device context by popping state information off a stack created by earlier calls to the `SaveDC` member function.  \n  \n The stack can contain the state information for several device contexts. If the context specified by `nSavedDC` is not at the top of the stack, `RestoreDC` deletes all state information between the device context specified by `nSavedDC` and the top of the stack. The deleted information is lost.  \n  \n##  <a name=\"cdc__roundrect\"></a>  CDC::RoundRect  \n Draws a rectangle with rounded corners using the current pen.  \n  \n```  \nBOOL RoundRect(\n    int x1,  \n    int y1,  \n    int x2,  \n    int y2,  \n    int x3,  \n    int y3);\n\n \nBOOL RoundRect(\n    LPCRECT lpRect,\n    POINT point);\n```  \n  \n### Parameters  \n `x1`  \n Specifies the x-coordinate of the upper-left corner of the rectangle (in logical units).  \n  \n `y1`  \n Specifies the y-coordinate of the upper-left corner of the rectangle (in logical units).  \n  \n `x2`  \n Specifies the x-coordinate of the lower-right corner of the rectangle (in logical units).  \n  \n `y2`  \n Specifies the y-coordinate of the lower-right corner of the rectangle (in logical units).  \n  \n *x3*  \n Specifies the width of the ellipse used to draw the rounded corners (in logical units).  \n  \n `y3`  \n Specifies the height of the ellipse used to draw the rounded corners (in logical units).  \n  \n `lpRect`  \n Specifies the bounding rectangle in logical units. You can pass either a `CRect` object or a pointer to a `RECT` structure for this parameter.  \n  \n `point`  \n The x-coordinate of `point` specifies the width of the ellipse to draw the rounded corners (in logical units). The y-coordinate of `point` specifies the height of the ellipse to draw the rounded corners (in logical units). You can pass either a **POINT** structure or a `CPoint` object for this parameter.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The interior of the rectangle is filled using the current brush.  \n  \n The figure this function draws extends up to but does not include the right and bottom coordinates. This means that the height of the figure is `y2` – `y1` and the width of the figure is `x2` – `x1`. Both the height and the width of the bounding rectangle must be greater than 2 units and less than 32,767 units.  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]  \n  \n##  <a name=\"cdc__savedc\"></a>  CDC::SaveDC  \n Saves the current state of the device context by copying state information (such as clipping region, selected objects, and mapping mode) to a context stack maintained by Windows.  \n  \n```  \nvirtual int SaveDC();\n```  \n  \n### Return Value  \n An integer identifying the saved device context. It is 0 if an error occurs. This return value can be used to restore the device context by calling `RestoreDC`.  \n  \n### Remarks  \n The saved device context can later be restored by using `RestoreDC`.  \n  \n `SaveDC` can be used any number of times to save any number of device-context states.  \n  \n##  <a name=\"cdc__scaleviewportext\"></a>  CDC::ScaleViewportExt  \n Modifies the viewport extents relative to the current values.  \n  \n```  \nvirtual CSize ScaleViewportExt(\n    int xNum,  \n    int xDenom,  \n    int yNum,  \n    int yDenom);\n```  \n  \n### Parameters  \n `xNum`  \n Specifies the amount by which to multiply the current x-extent.  \n  \n `xDenom`  \n Specifies the amount by which to divide the result of multiplying the current x-extent by the value of the `xNum` parameter.  \n  \n `yNum`  \n Specifies the amount by which to multiply the current y-extent.  \n  \n `yDenom`  \n Specifies the amount by which to divide the result of multiplying the current y-extent by the value of the `yNum` parameter.  \n  \n### Return Value  \n The previous viewport extents (in device units) as a `CSize` object.  \n  \n### Remarks  \n The formulas are written as follows:  \n  \n `xNewVE = ( xOldVE * xNum ) / xDenom`  \n  \n `yNewVE = ( yOldVE * yNum ) / yDenom`  \n  \n The new viewport extents are calculated by multiplying the current extents by the given numerator and then dividing by the given denominator.  \n  \n##  <a name=\"cdc__scalewindowext\"></a>  CDC::ScaleWindowExt  \n Modifies the window extents relative to the current values.  \n  \n```  \nvirtual CSize ScaleWindowExt(\n    int xNum,  \n    int xDenom,  \n    int yNum,  \n    int yDenom);\n```  \n  \n### Parameters  \n `xNum`  \n Specifies the amount by which to multiply the current x-extent.  \n  \n `xDenom`  \n Specifies the amount by which to divide the result of multiplying the current x-extent by the value of the `xNum` parameter.  \n  \n `yNum`  \n Specifies the amount by which to multiply the current y-extent.  \n  \n `yDenom`  \n Specifies the amount by which to divide the result of multiplying the current y-extent by the value of the `yNum` parameter.  \n  \n### Return Value  \n The previous window extents (in logical units) as a `CSize` object.  \n  \n### Remarks  \n The formulas are written as follows:  \n  \n `xNewWE = ( xOldWE * xNum ) / xDenom`  \n  \n `yNewWE = ( yOldWE * yNum ) / yDenom`  \n  \n The new window extents are calculated by multiplying the current extents by the given numerator and then dividing by the given denominator.  \n  \n##  <a name=\"cdc__scrolldc\"></a>  CDC::ScrollDC  \n Scrolls a rectangle of bits horizontally and vertically.  \n  \n```  \nBOOL ScrollDC(\n    int dx,  \n    int dy,  \n    LPCRECT lpRectScroll,  \n    LPCRECT lpRectClip,  \n    CRgn* pRgnUpdate,  \n    LPRECT lpRectUpdate);\n```  \n  \n### Parameters  \n `dx`  \n Specifies the number of horizontal scroll units.  \n  \n *dy*  \n Specifies the number of vertical scroll units.  \n  \n `lpRectScroll`  \n Points to the `RECT` structure or `CRect` object that contains the coordinates of the scrolling rectangle.  \n  \n `lpRectClip`  \n Points to the `RECT` structure or `CRect` object that contains the coordinates of the clipping rectangle. When this rectangle is smaller than the original one pointed to by `lpRectScroll`, scrolling occurs only in the smaller rectangle.  \n  \n `pRgnUpdate`  \n Identifies the region uncovered by the scrolling process. The `ScrollDC` function defines this region; it is not necessarily a rectangle.  \n  \n `lpRectUpdate`  \n Points to the `RECT` structure or `CRect` object that receives the coordinates of the rectangle that bounds the scrolling update region. This is the largest rectangular area that requires repainting. The values in the structure or object when the function returns are in client coordinates, regardless of the mapping mode for the given device context.  \n  \n### Return Value  \n Nonzero if scrolling is executed; otherwise 0.  \n  \n### Remarks  \n If `lpRectUpdate` is **NULL**, Windows does not compute the update rectangle. If both `pRgnUpdate` and `lpRectUpdate` are **NULL**, Windows does not compute the update region. If `pRgnUpdate` is not **NULL**, Windows assumes that it contains a valid pointer to the region uncovered by the scrolling process (defined by the `ScrollDC` member function). The update region returned in `lpRectUpdate` can be passed to `CWnd::InvalidateRgn` if required.  \n  \n An application should use the `ScrollWindow` member function of class `CWnd` when it is necessary to scroll the entire client area of a window. Otherwise, it should use `ScrollDC`.  \n  \n##  <a name=\"cdc__selectclippath\"></a>  CDC::SelectClipPath  \n Selects the current path as a clipping region for the device context, combining the new region with any existing clipping region by using the specified mode.  \n  \n```  \nBOOL SelectClipPath(int nMode);\n```  \n  \n### Parameters  \n `nMode`  \n Specifies the way to use the path. The following values are allowed:  \n  \n- **RGN_AND** The new clipping region includes the intersection (overlapping areas) of the current clipping region and the current path.  \n  \n- **RGN_COPY** The new clipping region is the current path.  \n  \n- **RGN_DIFF** The new clipping region includes the areas of the current clipping region, and those of the current path are excluded.  \n  \n- **RGN_OR** The new clipping region includes the union (combined areas) of the current clipping region and the current path.  \n  \n- **RGN_XOR** The new clipping region includes the union of the current clipping region and the current path, but without the overlapping areas.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The device context identified must contain a closed path.  \n  \n##  <a name=\"cdc__selectcliprgn\"></a>  CDC::SelectClipRgn  \n Selects the given region as the current clipping region for the device context.  \n  \n```  \nint SelectClipRgn(\n    CRgn* pRgn);\n\n \nint SelectClipRgn(\n    CRgn* pRgn,  \n    int nMode);\n```  \n  \n### Parameters  \n `pRgn`  \n Identifies the region to be selected.  \n  \n-   For the first version of this function, if this value is **NULL**, the entire client area is selected and output is still clipped to the window.  \n  \n-   For the second version of this function, this handle can be **NULL** only when the **RGN_COPY** mode is specified.  \n  \n `nMode`  \n Specifies the operation to be performed. It must be one of the following values:  \n  \n- **RGN_AND** The new clipping region combines the overlapping areas of the current clipping region and the region identified by `pRgn`.  \n  \n- **RGN_COPY** The new clipping region is a copy of the region identified by `pRgn`. This is functionality is identical to the first version of `SelectClipRgn`. If the region identified by `pRgn` is **NULL**, the new clipping region becomes the default clipping region (a null region).  \n  \n- **RGN_DIFF** The new clipping region combines the areas of the current clipping region with those areas excluded from the region identified by `pRgn`.  \n  \n- **RGN_OR** The new clipping region combines the current clipping region and the region identified by `pRgn`.  \n  \n- **RGN_XOR** The new clipping region combines the current clipping region and the region identified by `pRgn` but excludes any overlapping areas.  \n  \n### Return Value  \n The region's type. It can be any of the following values:  \n  \n- **COMPLEXREGION** New clipping region has overlapping borders.  \n  \n- **ERROR** Device context or region is not valid.  \n  \n- **NULLREGION** New clipping region is empty.  \n  \n- **SIMPLEREGION** New clipping region has no overlapping borders.  \n  \n### Remarks  \n Only a copy of the selected region is used. The region itself can be selected for any number of other device contexts, or it can be deleted.  \n  \n The function assumes that the coordinates for the given region are specified in device units. Some printer devices support text output at a higher resolution than graphics output in order to retain the precision needed to express text metrics. These devices report device units at the higher resolution, that is, in text units. These devices then scale coordinates for graphics so that several reported device units map to only 1 graphic unit. You should always call the `SelectClipRgn` function using text units.  \n  \n Applications that must take the scaling of graphics objects in the GDI can use the **GETSCALINGFACTOR** printer escape to determine the scaling factor. This scaling factor affects clipping. If a region is used to clip graphics, GDI divides the coordinates by the scaling factor. If the region is used to clip text, GDI makes no scaling adjustment. A scaling factor of 1 causes the coordinates to be divided by 2; a scaling factor of 2 causes the coordinates to be divided by 4; and so on.  \n  \n##  <a name=\"cdc__selectobject\"></a>  CDC::SelectObject  \n Selects an object into the device context.  \n  \n```  \nCPen* SelectObject(CPen* pPen);\n\n \nCBrush* SelectObject(CBrush* pBrush);\n\n \nvirtual CFont* SelectObject(CFont* pFont);\n\n \nCBitmap* SelectObject(CBitmap* pBitmap);\n\n \nint SelectObject(CRgn* pRgn);\n\n \nCGdiObject* SelectObject(CGdiObject* pObject);\n```  \n  \n### Parameters  \n *pPen*  \n A pointer to a [CPen](../../mfc/reference/cpen-class.md) object to be selected.  \n  \n `pBrush`  \n A pointer to a [CBrush](../../mfc/reference/cbrush-class.md) object to be selected.  \n  \n `pFont`  \n A pointer to a [CFont](../../mfc/reference/cfont-class.md) object to be selected.  \n  \n `pBitmap`  \n A pointer to a [CBitmap](../../mfc/reference/cbitmap-class.md) object to be selected.  \n  \n `pRgn`  \n A pointer to a [CRgn](../../mfc/reference/crgn-class.md) object to be selected.  \n  \n `pObject`  \n A pointer to a [CGdiObject](../../mfc/reference/cgdiobject-class.md) object to be selected.  \n  \n### Return Value  \n A pointer to the object being replaced. This is a pointer to an object of one of the classes derived from `CGdiObject`, such as `CPen`, depending on which version of the function is used. The return value is **NULL** if there is an error. This function may return a pointer to a temporary object. This temporary object is only valid during the processing of one Windows message. For more information, see `CGdiObject::FromHandle`.  \n  \n The version of the member function that takes a region parameter performs the same task as the `SelectClipRgn` member function. Its return value can be any of the following:  \n  \n- **COMPLEXREGION** New clipping region has overlapping borders.  \n  \n- **ERROR** Device context or region is not valid.  \n  \n- **NULLREGION** New clipping region is empty.  \n  \n- **SIMPLEREGION** New clipping region has no overlapping borders.  \n  \n### Remarks  \n Class `CDC` provides five versions specialized for particular kinds of GDI objects, including pens, brushes, fonts, bitmaps, and regions. The newly selected object replaces the previous object of the same type. For example, if `pObject` of the general version of `SelectObject` points to a [CPen](../../mfc/reference/cpen-class.md) object, the function replaces the current pen with the pen specified by `pObject`.  \n  \n An application can select a bitmap into memory device contexts only and into only one memory device context at a time. The format of the bitmap must either be monochrome or compatible with the device context; if it is not, `SelectObject` returns an error.  \n  \n For Windows 3.1 and later, the `SelectObject` function returns the same value whether it is used in a metafile or not. Under previous versions of Windows, `SelectObject` returned a nonzero value for success and 0 for failure when it was used in a metafile.  \n  \n##  <a name=\"cdc__selectpalette\"></a>  CDC::SelectPalette  \n Selects the logical palette that is specified by `pPalette` as the selected palette object of the device context.  \n  \n```  \nCPalette* SelectPalette(\n    CPalette* pPalette,  \n    BOOL bForceBackground);\n```  \n  \n### Parameters  \n `pPalette`  \n Identifies the logical palette to be selected. This palette must already have been created with the `CPalette` member function [CreatePalette](../../mfc/reference/cpalette-class.md#cpalette__createpalette).  \n  \n `bForceBackground`  \n Specifies whether the logical palette is forced to be a background palette. If `bForceBackground` is nonzero, the selected palette is always a background palette, regardless of whether the window has the input focus. If `bForceBackground` is 0 and the device context is attached to a window, the logical palette is a foreground palette when the window has the input focus.  \n  \n### Return Value  \n A pointer to a `CPalette` object identifying the logical palette replaced by the palette specified by `pPalette`. It is **NULL** if there is an error.  \n  \n### Remarks  \n The new palette becomes the palette object used by GDI to control colors displayed in the device context and replaces the previous palette.  \n  \n An application can select a logical palette into more than one device context. However, changes to a logical palette will affect all device contexts for which it is selected. If an application selects a palette into more than one device context, the device contexts must all belong to the same physical device.  \n  \n##  <a name=\"cdc__selectstockobject\"></a>  CDC::SelectStockObject  \n Selects a [CGdiObject](../../mfc/reference/cgdiobject-class.md) object that corresponds to one of the predefined stock pens, brushes, or fonts.  \n  \n```  \nvirtual CGdiObject* SelectStockObject(int nIndex);\n```  \n  \n### Parameters  \n `nIndex`  \n Specifies the kind of stock object desired. It can be one of the following values:  \n  \n- **BLACK_BRUSH** Black brush.  \n  \n- **DKGRAY_BRUSH** Dark gray brush.  \n  \n- **GRAY_BRUSH** Gray brush.  \n  \n- **HOLLOW_BRUSH** Hollow brush.  \n  \n- **LTGRAY_BRUSH** Light gray brush.  \n  \n- **NULL_BRUSH** Null brush.  \n  \n- **WHITE_BRUSH** White brush.  \n  \n- **BLACK_PEN** Black pen.  \n  \n- **NULL_PEN** Null pen.  \n  \n- **WHITE_PEN** White pen.  \n  \n- **ANSI_FIXED_FONT** ANSI fixed system font.  \n  \n- **ANSI_VAR_FONT** ANSI variable system font.  \n  \n- **DEVICE_DEFAULT_FONT** Device-dependent font.  \n  \n- **OEM_FIXED_FONT** OEM-dependent fixed font.  \n  \n- **SYSTEM_FONT** The system font. By default, Windows uses the system font to draw menus, dialog-box controls, and other text. It is best, however, not to rely on SYSTEM_FONT to obtain the font used by dialogs and windows. Instead, use the `SystemParametersInfo` function with the SPI_GETNONCLIENTMETRICS parameter to retrieve the current font. `SystemParametersInfo` takes into account the current theme and provides font information for captions, menus, and message dialogs.  \n  \n- **SYSTEM_FIXED_FONT** The fixed-width system font used in Windows prior to version 3.0. This object is available for compatibility with earlier versions of Windows.  \n  \n- **DEFAULT_PALETTE** Default color palette. This palette consists of the 20 static colors in the system palette.  \n  \n### Return Value  \n A pointer to the `CGdiObject` object that was replaced if the function is successful. The actual object pointed to is a [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md), or [CFont](../../mfc/reference/cfont-class.md) object. If the call is unsuccessful, the return value is **NULL**.  \n  \n##  <a name=\"cdc__setabortproc\"></a>  CDC::SetAbortProc  \n Installs the abort procedure for the print job.  \n  \n```  \nint SetAbortProc(\n    BOOL (\n    CALLBACK* lpfn)(\n    HDC, int));\n```  \n  \n### Parameters  \n `lpfn`  \n A pointer to the abort function to install as the abort procedure. For more about the callback function, see [Callback Function for CDC::SetAbortProc](../../mfc/reference/callback-function-for-cdc-setabortproc.md).  \n  \n### Return Value  \n Specifies the outcome of the `SetAbortProc` function. Some of the following values are more probable than others, but all are possible.  \n  \n- **SP_ERROR** General error.  \n  \n- **SP_OUTOFDISK** Not enough disk space is currently available for spooling, and no more space will become available.  \n  \n- **SP_OUTOFMEMORY** Not enough memory is available for spooling.  \n  \n- **SP_USERABORT** User ended the job through the Print Manager.  \n  \n### Remarks  \n If an application is to allow the print job to be canceled during spooling, it must set the abort function before the print job is started with the [StartDoc](#cdc__startdoc) member function. The Print Manager calls the abort function during spooling to allow the application to cancel the print job or to process out-of-disk-space conditions. If no abort function is set, the print job will fail if there is not enough disk space for spooling.  \n  \n Note that the features of Microsoft Visual C++ simplify the creation of the callback function passed to `SetAbortProc`. The address passed to the `EnumObjects` member function is a pointer to a function exported with **__declspec(dllexport)** and with the `__stdcall` calling convention.  \n  \n You also do not have to export the function name in an **EXPORTS** statement in your application's module-definition file. You can instead use the **EXPORT** function modifier, as in  \n  \n **BOOL CALLBACK EXPORT** AFunction( **HDC**, `int`**);**  \n  \n to cause the compiler to emit the proper export record for export by name without aliasing. This works for most needs. For some special cases, such as exporting a function by ordinal or aliasing the export, you still need to use an **EXPORTS** statement in a module-definition file.  \n  \n Callback registration interfaces are now type-safe (you must pass in a function pointer that points to the right kind of function for the specific callback).  \n  \n Also note that all callback functions must trap Microsoft Foundation exceptions before returning to Windows, since exceptions cannot be thrown across callback boundaries. For more information about exceptions, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md).  \n  \n##  <a name=\"cdc__setarcdirection\"></a>  CDC::SetArcDirection  \n Sets the drawing direction to be used for arc and rectangle functions.  \n  \n```  \nint SetArcDirection(int nArcDirection);\n```  \n  \n### Parameters  \n *nArcDirection*  \n Specifies the new arc direction. This parameter can be either of the following values:  \n  \n- **AD_COUNTERCLOCKWISE** Figures drawn counterclockwise.  \n  \n- **AD_CLOCKWISE** Figures drawn clockwise.  \n  \n### Return Value  \n Specifies the old arc direction, if successful; otherwise 0.  \n  \n### Remarks  \n The default direction is counterclockwise. The `SetArcDirection` function specifies the direction in which the following functions draw:  \n  \n|Arc|Pie|  \n|---------|---------|  \n|`ArcTo`|**Rectangle**|  \n|`Chord`|`RoundRect`|  \n|**Ellipse**||  \n  \n##  <a name=\"cdc__setattribdc\"></a>  CDC::SetAttribDC  \n Call this function to set the attribute device context, `m_hAttribDC`.  \n  \n```  \nvirtual void SetAttribDC(HDC hDC);\n```  \n  \n### Parameters  \n `hDC`  \n A Windows device context.  \n  \n### Remarks  \n This member function does not attach the device context to the `CDC` object. Only the output device context is attached to a `CDC` object.  \n  \n##  <a name=\"cdc__setbkcolor\"></a>  CDC::SetBkColor  \n Sets the current background color to the specified color.  \n  \n```  \nvirtual COLORREF SetBkColor(COLORREF crColor);\n```  \n  \n### Parameters  \n `crColor`  \n Specifies the new background color.  \n  \n### Return Value  \n The previous background color as an RGB color value. If an error occurs, the return value is 0x80000000.  \n  \n### Remarks  \n If the background mode is **OPAQUE**, the system uses the background color to fill the gaps in styled lines, the gaps between hatched lines in brushes, and the background in character cells. The system also uses the background color when converting bitmaps between color and monochrome device contexts.  \n  \n If the device cannot display the specified color, the system sets the background color to the nearest physical color.  \n  \n##  <a name=\"cdc__setbkmode\"></a>  CDC::SetBkMode  \n Sets the background mode.  \n  \n```  \nint SetBkMode(int nBkMode);\n```  \n  \n### Parameters  \n *nBkMode*  \n Specifies the mode to be set. This parameter can be either of the following values:  \n  \n- **OPAQUE** Background is filled with the current background color before the text, hatched brush, or pen is drawn. This is the default background mode.  \n  \n- **TRANSPARENT** Background is not changed before drawing.  \n  \n### Return Value  \n The previous background mode.  \n  \n### Remarks  \n The background mode defines whether the system removes existing background colors on the drawing surface before drawing text, hatched brushes, or any pen style that is not a solid line.  \n  \n### Example  \n  See the example for [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#cwnd__onctlcolor).  \n  \n##  <a name=\"cdc__setboundsrect\"></a>  CDC::SetBoundsRect  \n Controls the accumulation of bounding-rectangle information for the specified device context.  \n  \n```  \nUINT SetBoundsRect(\n    LPCRECT lpRectBounds,  \n    UINT flags);\n```  \n  \n### Parameters  \n `lpRectBounds`  \n Points to a `RECT` structure or `CRect` object that is used to set the bounding rectangle. Rectangle dimensions are given in logical coordinates. This parameter can be **NULL**.  \n  \n `flags`  \n Specifies how the new rectangle will be combined with the accumulated rectangle. This parameter can be a combination of the following values:  \n  \n- **DCB_ACCUMULATE** Add the rectangle specified by `lpRectBounds` to the bounding rectangle (using a rectangle-union operation).  \n  \n- **DCB_DISABLE** Turn off bounds accumulation.  \n  \n- **DCB_ENABLE** Turn on bounds accumulation. (The default setting for bounds accumulation is disabled.)  \n  \n### Return Value  \n The current state of the bounding rectangle, if the function is successful. Like `flags`, the return value can be a combination of **DCB_** values:  \n  \n- **DCB_ACCUMULATE** The bounding rectangle is not empty. This value will always be set.  \n  \n- **DCB_DISABLE** Bounds accumulation is off.  \n  \n- **DCB_ENABLE** Bounds accumulation is on.  \n  \n### Remarks  \n Windows can maintain a bounding rectangle for all drawing operations. This rectangle can be queried and reset by the application. The drawing bounds are useful for invalidating bitmap caches.  \n  \n##  <a name=\"cdc__setbrushorg\"></a>  CDC::SetBrushOrg  \n Specifies the origin that GDI will assign to the next brush that the application selects into the device context.  \n  \n```  \nCPoint SetBrushOrg(\n    int x,  \n    int y);\n\n \nCPoint SetBrushOrg(\n    POINT point);\n```  \n  \n### Parameters  \n *x*  \n Specifies the x-coordinate (in device units) of the new origin. This value must be in the range 0–7.  \n  \n *y*  \n Specifies the y-coordinate (in device units) of the new origin. This value must be in the range 0–7.  \n  \n `point`  \n Specifies the x- and y-coordinates of the new origin. Each value must be in the range 0–7. You can pass either a **POINT** structure or a `CPoint` object for this parameter.  \n  \n### Return Value  \n The previous origin of the brush in device units.  \n  \n### Remarks  \n The default coordinates for the brush origin are (0, 0). To alter the origin of a brush, call the `UnrealizeObject` function for the `CBrush` object, call `SetBrushOrg`, and then call the `SelectObject` member function to select the brush into the device context.  \n  \n Do not use `SetBrushOrg` with stock `CBrush` objects.  \n  \n##  <a name=\"cdc__setcoloradjustment\"></a>  CDC::SetColorAdjustment  \n Sets the color adjustment values for the device context using the specified values.  \n  \n```  \nBOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);\n```  \n  \n### Parameters  \n `lpColorAdjust`  \n Points to a [COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md) data structure containing the color adjustment values.  \n  \n### Return Value  \n Nonzero if successful; otherwise 0.  \n  \n### Remarks  \n The color adjustment values are used to adjust the input color of the source bitmap for calls to the `CDC::StretchBlt` member function when **HALFTONE** mode is set.  \n  \n##  <a name=\"cdc__setdcbrushcolor\"></a>  CDC::SetDCBrushColor  \n Sets the current device context (DC) brush color to the specified color value.  \n  \n```  \nCOLORREF SetDCBrushColor(COLORREF crColor);\n```  \n  \n### Parameters  \n `crColor`  \n Specifies the new brush color.  \n  \n### Return Value  \n If the function succeeds, the return value specifies the previous DC brush color as a `COLORREF` value.  \n  \n If the function fails, the return value is `CLR_INVALID`.  \n  \n### Remarks  \n This method emulates the functionality of the function [SetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd162969), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__setdcpencolor\"></a>  CDC::SetDCPenColor  \n Sets the current device context (DC) pen color to the specified color value.  \n  \n```  \nCOLORREF SetDCPenColor(COLORREF crColor);\n```  \n  \n### Parameters  \n `crColor`  \n Specifies the new pen color.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n This member function utilizes the Win32 function [SetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd162970), as described in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__setgraphicsmode\"></a>  CDC::SetGraphicsMode  \n Sets the graphics mode for the specified device context.  \n  \n```  \nint SetGraphicsMode(int iMode);\n```  \n  \n### Parameters  \n `iMode`  \n Specifies the graphics mode. For a list of the values that this parameter can take, see [SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977).  \n  \n### Return Value  \n Returns the old graphics mode on success.  \n  \n Returns 0 on failure. To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  \n  \n### Remarks  \n This method wraps the Windows GDI function [SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977).  \n  \n##  <a name=\"cdc__setlayout\"></a>  CDC::SetLayout  \n Call this member function to change the layout of the text and graphics for a device context to right to left, the standard layout for cultures such as Arabic and Hebrew.  \n  \n```  \nDWORD SetLayout(DWORD dwLayout);\n```  \n  \n### Parameters  \n `dwLayout`  \n Device context layout and bitmap control flags. It can be a combination of the following values.  \n  \n|Value|Meaning|  \n|-----------|-------------|  \n|LAYOUT_BITMAPORIENTATIONPRESERVED|Disables any reflection for calls to [CDC::BitBlt](#cdc__bitblt) and [CDC::StretchBlt](#cdc__stretchblt).|  \n|LAYOUT_RTL|Sets the default horizontal layout to be right to left.|  \n|LAYOUT_LTR|Sets the default layout to be left to right.|  \n  \n### Return Value  \n If successful, the previous layout of the device context.  \n  \n If unsuccessful, **GDI_ERROR**. To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  \n  \n### Remarks  \n Normally, you would not call **SetLayout** for a window. Rather, you control the right-to-left layout in a window by setting the [extended window styles](../../mfc/reference/extended-window-styles.md) such as **WS_EX_RTLREADING**. A device context, such as a printer or a metafile, does not inherit this layout. The only way to set the device context for a right-to-left layout is by calling **SetLayout**.  \n  \n If you call **SetLayout(LAYOUT_RTL** ), **SetLayout** automatically changes the mapping mode to `MM_ISOTROPIC`. As a result, a subsequent call to [GetMapMode](#cdc__getmapmode) will return **MM_ISOTROPIC** instead of `MM_TEXT`.  \n  \n In some cases, such as with many bitmaps, you may want to preserve the left-to-right layout. In these cases, render the image by calling `BitBlt` or `StretchBlt`, then set the bitmap control flag for `dwLayout` to **LAYOUT_BITMAPORIENTATIONPRESERVED**.  \n  \n Once you change the layout with the **LAYOUT_RTL** flag, the flags normally specifying right or left are reversed. To avoid confusion, you may want to define alternate names for the standard flags. For a list of suggested alternate flag names, see [SetLayout](http://msdn.microsoft.com/library/windows/desktop/dd162979) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__setmapmode\"></a>  CDC::SetMapMode  \n Sets the mapping mode.  \n  \n```  \nvirtual int SetMapMode(int nMapMode);\n```  \n  \n### Parameters  \n `nMapMode`  \n Specifies the new mapping mode. It can be any one of the following values:  \n  \n- `MM_ANISOTROPIC` Logical units are converted to arbitrary units with arbitrarily scaled axes. Setting the mapping mode to `MM_ANISOTROPIC` does not change the current window or viewport settings. To change the units, orientation, and scaling, call the [SetWindowExt](#cdc__setwindowext) and [SetViewportExt](#cdc__setviewportext) member functions.  \n  \n- `MM_HIENGLISH` Each logical unit is converted to 0.001 inch. Positive x is to the right; positive y is up.  \n  \n- `MM_HIMETRIC` Each logical unit is converted to 0.01 millimeter. Positive x is to the right; positive y is up.  \n  \n- `MM_ISOTROPIC` Logical units are converted to arbitrary units with equally scaled axes; that is, 1 unit along the x-axis is equal to 1 unit along the y-axis. Use the `SetWindowExt` and `SetViewportExt` member functions to specify the desired units and the orientation of the axes. GDI makes adjustments as necessary to ensure that the x and y units remain the same size.  \n  \n- `MM_LOENGLISH` Each logical unit is converted to 0.01 inch. Positive x is to the right; positive y is up.  \n  \n- `MM_LOMETRIC` Each logical unit is converted to 0.1 millimeter. Positive x is to the right; positive y is up.  \n  \n- `MM_TEXT` Each logical unit is converted to 1 device pixel. Positive x is to the right; positive y is down.  \n  \n- `MM_TWIPS` Each logical unit is converted to 1/20 of a point. (Because a point is 1/72 inch, a twip is 1/1440 inch.) Positive x is to the right; positive y is up.  \n  \n### Return Value  \n The previous mapping mode.  \n  \n### Remarks  \n The mapping mode defines the unit of measure used to convert logical units to device units; it also defines the orientation of the device's x- and y-axes. GDI uses the mapping mode to convert logical coordinates into the appropriate device coordinates. The `MM_TEXT` mode allows applications to work in device pixels, where 1 unit is equal to 1 pixel. The physical size of a pixel varies from device to device.  \n  \n The `MM_HIENGLISH`, `MM_HIMETRIC`, `MM_LOENGLISH`, `MM_LOMETRIC`, and `MM_TWIPS` modes are useful for applications that must draw in physically meaningful units (such as inches or millimeters). The `MM_ISOTROPIC` mode ensures a 1:1 aspect ratio, which is useful when it is important to preserve the exact shape of an image. The `MM_ANISOTROPIC` mode allows the x- and y-coordinates to be adjusted independently.  \n  \n> [!NOTE]\n>  If you call [SetLayout](#cdc__setlayout) to change the DC (device context) to right-to-left layout, **SetLayout** automatically changes the mapping mode to `MM_ISOTROPIC`.  \n  \n### Example  \n  See the example for [CView::OnPrepareDC](../../mfc/reference/cview-class.md#cview__onpreparedc).  \n  \n##  <a name=\"cdc__setmapperflags\"></a>  CDC::SetMapperFlags  \n Changes the method used by the font mapper when it converts a logical font to a physical font.  \n  \n```  \nDWORD SetMapperFlags(DWORD dwFlag);\n```  \n  \n### Parameters  \n `dwFlag`  \n Specifies whether the font mapper attempts to match a font's aspect height and width to the device. When this value is **ASPECT_FILTERING**, the mapper selects only fonts whose x-aspect and y-aspect exactly match those of the specified device.  \n  \n### Return Value  \n The previous value of the font-mapper flag.  \n  \n### Remarks  \n An application can use `SetMapperFlags` to cause the font mapper to attempt to choose only a physical font that exactly matches the aspect ratio of the specified device.  \n  \n An application that uses only raster fonts can use the `SetMapperFlags` function to ensure that the font selected by the font mapper is attractive and readable on the specified device. Applications that use scalable (TrueType) fonts typically do not use `SetMapperFlags`.  \n  \n If no physical font has an aspect ratio that matches the specification in the logical font, GDI chooses a new aspect ratio and selects a font that matches this new aspect ratio.  \n  \n##  <a name=\"cdc__setmiterlimit\"></a>  CDC::SetMiterLimit  \n Sets the limit for the length of miter joins for the device context.  \n  \n```  \nBOOL SetMiterLimit(float fMiterLimit);\n```  \n  \n### Parameters  \n *fMiterLimit*  \n Specifies the new miter limit for the device context.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The miter length is defined as the distance from the intersection of the line walls on the inside of the join to the intersection of the line walls on the outside of the join. The miter limit is the maximum allowed ratio of the miter length to the line width. The default miter limit is 10.0.  \n  \n##  <a name=\"cdc__setoutputdc\"></a>  CDC::SetOutputDC  \n Call this member function to set the output device context, `m_hDC`.  \n  \n```  \nvirtual void SetOutputDC(HDC hDC);\n```  \n  \n### Parameters  \n `hDC`  \n A Windows device context.  \n  \n### Remarks  \n This member function can only be called when a device context has not been attached to the `CDC` object. This member function sets `m_hDC` but does not attach the device context to the `CDC` object.  \n  \n##  <a name=\"cdc__setpixel\"></a>  CDC::SetPixel  \n Sets the pixel at the point specified to the closest approximation of the color specified by `crColor`.  \n  \n```  \nCOLORREF SetPixel(\n    int x,  \n    int y,  \n    COLORREF crColor);\n\n \nCOLORREF SetPixel(\n    POINT point,  \n    COLORREF crColor);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the point to be set.  \n  \n *y*  \n Specifies the logical y-coordinate of the point to be set.  \n  \n `crColor`  \n A **COLORREF** RGB value that specifies the color used to paint the point. See [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] for a description of this value.  \n  \n `point`  \n Specifies the logical x- and y-coordinates of the point to be set. You can pass either a **POINT** structure or a `CPoint` object for this parameter.  \n  \n### Return Value  \n An RGB value for the color that the point is actually painted. This value can be different from that specified by `crColor` if an approximation of that color is used. If the function fails (if the point is outside the clipping region), the return value is –1.  \n  \n### Remarks  \n The point must be in the clipping region. If the point is not in the clipping region, the function does nothing.  \n  \n Not all devices support the `SetPixel` function. To determine whether a device supports `SetPixel`, call the `GetDeviceCaps` member function with the **RASTERCAPS** index and check the return value for the **RC_BITBLT** flag.  \n  \n##  <a name=\"cdc__setpixelv\"></a>  CDC::SetPixelV  \n Sets the pixel at the specified coordinates to the closest approximation of the specified color.  \n  \n```  \nBOOL SetPixelV(\n    int x,  \n    int y,  \n    COLORREF crColor);\n\n \nBOOL SetPixelV(\n    POINT point,  \n    COLORREF crColor);\n```  \n  \n### Parameters  \n *x*  \n Specifies the x-coordinate, in logical units, of the point to be set.  \n  \n *y*  \n Specifies the y-coordinate, in logical units, of the point to be set.  \n  \n `crColor`  \n Specifies the color to be used to paint the point.  \n  \n `point`  \n Specifies the logical x- and y-coordinates of the point to be set. You can pass either a [POINT](../../mfc/reference/point-structure1.md) data structure or a [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) object for this parameter.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The point must be in both the clipping region and the visible part of the device surface. Not all devices support the member function. For more information, see the **RC_BITBLT** capability in the `CDC::GetDeviceCaps` member function. `SetPixelV` is faster than `SetPixel` because it does not need to return the color value of the point actually painted.  \n  \n##  <a name=\"cdc__setpolyfillmode\"></a>  CDC::SetPolyFillMode  \n Sets the polygon-filling mode.  \n  \n```  \nint SetPolyFillMode(int nPolyFillMode);\n```  \n  \n### Parameters  \n `nPolyFillMode`  \n Specifies the new filling mode. This value may be either **ALTERNATE** or **WINDING**. The default mode set in Windows is **ALTERNATE**.  \n  \n### Return Value  \n The previous filling mode, if successful; otherwise 0.  \n  \n### Remarks  \n When the polygon-filling mode is **ALTERNATE**, the system fills the area between odd-numbered and even-numbered polygon sides on each scan line. That is, the system fills the area between the first and second side, between the third and fourth side, and so on. This mode is the default.  \n  \n When the polygon-filling mode is **WINDING**, the system uses the direction in which a figure was drawn to determine whether to fill an area. Each line segment in a polygon is drawn in either a clockwise or a counterclockwise direction. Whenever an imaginary line drawn from an enclosed area to the outside of a figure passes through a clockwise line segment, a count is incremented. When the line passes through a counterclockwise line segment, the count is decremented. The area is filled if the count is nonzero when the line reaches the outside of the figure.  \n  \n##  <a name=\"cdc__setrop2\"></a>  CDC::SetROP2  \n Sets the current drawing mode.  \n  \n```  \nint SetROP2(int nDrawMode);\n```  \n  \n### Parameters  \n `nDrawMode`  \n Specifies the new drawing mode. It can be any of the following values:  \n  \n- **R2_BLACK** Pixel is always black.  \n  \n- **R2_WHITE** Pixel is always white.  \n  \n- **R2_NOP** Pixel remains unchanged.  \n  \n- **R2_NOT** Pixel is the inverse of the screen color.  \n  \n- **R2_COPYPEN** Pixel is the pen color.  \n  \n- **R2_NOTCOPYPEN** Pixel is the inverse of the pen color.  \n  \n- **R2_MERGEPENNOT** Pixel is a combination of the pen color and the inverse of the screen color (final pixel = (NOT screen pixel) OR pen).  \n  \n- **R2_MASKPENNOT** Pixel is a combination of the colors common to both the pen and the inverse of the screen (final pixel = (NOT screen pixel) AND pen).  \n  \n- **R2_MERGENOTPEN** Pixel is a combination of the screen color and the inverse of the pen color (final pixel = (NOT pen) OR screen pixel).  \n  \n- **R2_MASKNOTPEN** Pixel is a combination of the colors common to both the screen and the inverse of the pen (final pixel = (NOT pen) AND screen pixel).  \n  \n- **R2_MERGEPEN** Pixel is a combination of the pen color and the screen color (final pixel = pen OR screen pixel).  \n  \n- **R2_NOTMERGEPEN** Pixel is the inverse of the **R2_MERGEPEN** color (final pixel = NOT(pen OR screen pixel)).  \n  \n- **R2_MASKPEN** Pixel is a combination of the colors common to both the pen and the screen (final pixel = pen AND screen pixel).  \n  \n- **R2_NOTMASKPEN** Pixel is the inverse of the **R2_MASKPEN** color (final pixel = NOT(pen AND screen pixel)).  \n  \n- **R2_XORPEN** Pixel is a combination of the colors that are in the pen or in the screen, but not in both (final pixel = pen XOR screen pixel).  \n  \n- **R2_NOTXORPEN** Pixel is the inverse of the **R2_XORPEN** color (final pixel = NOT(pen XOR screen pixel)).  \n  \n### Return Value  \n The previous drawing mode.  \n  \n It can be any of the values given in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n### Remarks  \n The drawing mode specifies how the colors of the pen and the interior of filled objects are combined with the color already on the display surface.  \n  \n The drawing mode is for raster devices only; it does not apply to vector devices. Drawing modes are binary raster-operation codes representing all possible Boolean combinations of two variables, using the binary operators AND, OR, and XOR (exclusive OR), and the unary operation NOT.  \n  \n##  <a name=\"cdc__setstretchbltmode\"></a>  CDC::SetStretchBltMode  \n Sets the bitmap-stretching mode for the `StretchBlt` member function.  \n  \n```  \nint SetStretchBltMode(int nStretchMode);\n```  \n  \n### Parameters  \n *nStretchMode*  \n Specifies the stretching mode. It can be any of the following values:  \n  \n|Value|Description|  \n|-----------|-----------------|  \n|**BLACKONWHITE**|Performs a Boolean AND operation using the color values for the eliminated and existing pixels. If the bitmap is a monochrome bitmap, this mode preserves black pixels at the expense of white pixels.|  \n|**COLORONCOLOR**|Deletes the pixels. This mode deletes all eliminated lines of pixels without trying to preserve their information.|  \n|**HALFTONE**|Maps pixels from the source rectangle into blocks of pixels in the destination rectangle. The average color over the destination block of pixels approximates the color of the source pixels.|  \n||After setting the **HALFTONE** stretching mode, an application must call the Win32 function [SetBrushOrgEx](http://msdn.microsoft.com/library/windows/desktop/dd162967) to set the brush origin. If it fails to do so, brush misalignment occurs.|  \n|**STRETCH_ANDSCANS**|**Windows 95/98**: Same as **BLACKONWHITE**|  \n|**STRETCH_DELETESCANS**|**Windows 95/98**: Same as **COLORONCOLOR**|  \n|**STRETCH_HALFTONE**|**Windows 95/98**: Same as **HALFTONE**.|  \n|**STRETCH_ORSCANS**|**Windows 95/98**: Same as **WHITEONBLACK**|  \n|**WHITEONBLACK**|Performs a Boolean OR operation using the color values for the eliminated and existing pixels. If the bitmap is a monochrome bitmap, this mode preserves white pixels at the expense of black pixels.|  \n  \n### Return Value  \n The previous stretching mode. It can be **STRETCH_ANDSCANS**, **STRETCH_DELETESCANS**, or **STRETCH_ORSCANS**.  \n  \n### Remarks  \n The bitmap-stretching mode defines how information is removed from bitmaps that are compressed by using the function.  \n  \n The **BLACKONWHITE** ( **STRETCH_ANDSCANS**) and **WHITEONBLACK** ( **STRETCH_ORSCANS**) modes are typically used to preserve foreground pixels in monochrome bitmaps. The **COLORONCOLOR** ( **STRETCH_DELETESCANS**) mode is typically used to preserve color in color bitmaps.  \n  \n The **HALFTONE** mode requires more processing of the source image than the other three modes; it is slower than the others, but produces higher quality images. Also note that **SetBrushOrgEx** must be called after setting the **HALFTONE** mode to avoid brush misalignment.  \n  \n Additional stretching modes might also be available depending on the capabilities of the device driver.  \n  \n##  <a name=\"cdc__settextalign\"></a>  CDC::SetTextAlign  \n Sets the text-alignment flags.  \n  \n```  \nUINT SetTextAlign(UINT nFlags);\n```  \n  \n### Parameters  \n `nFlags`  \n Specifies text-alignment flags. The flags specify the relationship between a point and a rectangle that bounds the text. The point can be either the current position or coordinates specified by a text-output function. The rectangle that bounds the text is defined by the adjacent character cells in the text string. The `nFlags` parameter can be one or more flags from the following three categories. Choose only one flag from each category. The first category affects text alignment in the x-direction:  \n  \n- **TA_CENTER** Aligns the point with the horizontal center of the bounding rectangle.  \n  \n- **TA_LEFT** Aligns the point with the left side of the bounding rectangle. This is the default setting.  \n  \n- **TA_RIGHT** Aligns the point with the right side of the bounding rectangle.  \n  \n The second category affects text alignment in the y-direction:  \n  \n- **TA_BASELINE** Aligns the point with the base line of the chosen font.  \n  \n- **TA_BOTTOM** Aligns the point with the bottom of the bounding rectangle.  \n  \n- **TA_TOP** Aligns the point with the top of the bounding rectangle. This is the default setting.  \n  \n The third category determines whether the current position is updated when text is written:  \n  \n- **TA_NOUPDATECP** Does not update the current position after each call to a text-output function. This is the default setting.  \n  \n- **TA_UPDATECP** Updates the current x-position after each call to a text-output function. The new position is at the right side of the bounding rectangle for the text. When this flag is set, the coordinates specified in calls to the `TextOut` member function are ignored.  \n  \n### Return Value  \n The previous text-alignment setting, if successful. The low-order byte contains the horizontal setting and the high-order byte contains the vertical setting; otherwise 0.  \n  \n### Remarks  \n The `TextOut` and `ExtTextOut` member functions use these flags when positioning a string of text on a display or device. The flags specify the relationship between a specific point and a rectangle that bounds the text. The coordinates of this point are passed as parameters to the `TextOut` member function. The rectangle that bounds the text is formed by the adjacent character cells in the text string.  \n  \n##  <a name=\"cdc__settextcharacterextra\"></a>  CDC::SetTextCharacterExtra  \n Sets the amount of intercharacter spacing.  \n  \n```  \nint SetTextCharacterExtra(int nCharExtra);\n```  \n  \n### Parameters  \n `nCharExtra`  \n Specifies the amount of extra space (in logical units) to be added to each character. If the current mapping mode is not `MM_TEXT`, `nCharExtra` is transformed and rounded to the nearest pixel.  \n  \n### Return Value  \n The amount of the previous intercharacter spacing.  \n  \n### Remarks  \n GDI adds this spacing to each character, including break characters, when it writes a line of text to the device context. The default value for the amount of intercharacter spacing is 0.  \n  \n##  <a name=\"cdc__settextcolor\"></a>  CDC::SetTextColor  \n Sets the text color to the specified color.  \n  \n```  \nvirtual COLORREF SetTextColor(COLORREF crColor);\n```  \n  \n### Parameters  \n `crColor`  \n Specifies the color of the text as an RGB color value.  \n  \n### Return Value  \n An RGB value for the previous text color.  \n  \n### Remarks  \n The system will use this text color when writing text to this device context and also when converting bitmaps between color and monochrome device contexts.  \n  \n If the device cannot represent the specified color, the system sets the text color to the nearest physical color. The background color for a character is specified by the `SetBkColor` and `SetBkMode` member functions.  \n  \n### Example  \n  See the example for [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#cwnd__onctlcolor).  \n  \n##  <a name=\"cdc__settextjustification\"></a>  CDC::SetTextJustification  \n Adds space to the break characters in a string.  \n  \n```  \nint SetTextJustification(\n    int nBreakExtra,  \n    int nBreakCount);\n```  \n  \n### Parameters  \n `nBreakExtra`  \n Specifies the total extra space to be added to the line of text (in logical units). If the current mapping mode is not `MM_TEXT`, the value given by this parameter is converted to the current mapping mode and rounded to the nearest device unit.  \n  \n *nBreakCount*  \n Specifies the number of break characters in the line.  \n  \n### Return Value  \n One if the function is successful; otherwise 0.  \n  \n### Remarks  \n An application can use the `GetTextMetrics` member functions to retrieve a font's break character.  \n  \n After the `SetTextJustification` member function is called, a call to a text-output function (such as `TextOut`) distributes the specified extra space evenly among the specified number of break characters. The break character is usually the space character (ASCII 32), but may be defined by a font as some other character.  \n  \n The member function `GetTextExtent` is typically used with `SetTextJustification`. `GetTextExtent` computes the width of a given line before alignment. An application can determine how much space to specify in the `nBreakExtra` parameter by subtracting the value returned by `GetTextExtent` from the width of the string after alignment.  \n  \n The `SetTextJustification` function can be used to align a line that contains multiple runs in different fonts. In this case, the line must be created piecemeal by aligning and writing each run separately.  \n  \n Because rounding errors can occur during alignment, the system keeps a running error term that defines the current error. When aligning a line that contains multiple runs, `GetTextExtent` automatically uses this error term when it computes the extent of the next run. This allows the text-output function to blend the error into the new run.  \n  \n After each line has been aligned, this error term must be cleared to prevent it from being incorporated into the next line. The term can be cleared by calling `SetTextJustification` with `nBreakExtra` set to 0.  \n  \n##  <a name=\"cdc__setviewportext\"></a>  CDC::SetViewportExt  \n Sets the x- and y-extents of the viewport of the device context.  \n  \n```  \nvirtual CSize SetViewportExt(\n    int cx,  \n    int cy);\n\n \nCSize SetViewportExt(\n    SIZE size);\n```  \n  \n### Parameters  \n `cx`  \n Specifies the x-extent of the viewport (in device units).  \n  \n `cy`  \n Specifies the y-extent of the viewport (in device units).  \n  \n `size`  \n Specifies the x- and y-extents of the viewport (in device units).  \n  \n### Return Value  \n The previous extents of the viewport as a [CSize](../../atl-mfc-shared/reference/csize-class.md) object. When an error occurs, the x- and y-coordinates of the returned `CSize` object are both set to 0.  \n  \n### Remarks  \n The viewport, along with the device-context window, defines how GDI maps points in the logical coordinate system to points in the coordinate system of the actual device. In other words, they define how GDI converts logical coordinates into device coordinates.  \n  \n When the following mapping modes are set, calls to `SetWindowExt` and `SetViewportExt` are ignored:  \n  \n|MM_HIENGLISH|MM_LOMETRIC|  \n|-------------------|------------------|  \n|`MM_HIMETRIC`|`MM_TEXT`|  \n|`MM_LOENGLISH`|`MM_TWIPS`|  \n  \n When `MM_ISOTROPIC` mode is set, an application must call the `SetWindowExt` member function before it calls `SetViewportExt`.  \n  \n### Example  \n  See the example for [CView::OnPrepareDC](../../mfc/reference/cview-class.md#cview__onpreparedc).  \n  \n##  <a name=\"cdc__setviewportorg\"></a>  CDC::SetViewportOrg  \n Sets the viewport origin of the device context.  \n  \n```  \nvirtual CPoint SetViewportOrg(\n    int x,  \n    int y);\n\n \nCPoint SetViewportOrg(\n    POINT point);\n```  \n  \n### Parameters  \n *x*  \n Specifies the x-coordinate (in device units) of the origin of the viewport. The value must be within the range of the device coordinate system.  \n  \n *y*  \n Specifies the y-coordinate (in device units) of the origin of the viewport. The value must be within the range of the device coordinate system.  \n  \n `point`  \n Specifies the origin of the viewport. The values must be within the range of the device coordinate system. You can pass either a **POINT** structure or a `CPoint` object for this parameter.  \n  \n### Return Value  \n The previous origin of the viewport (in device coordinates) as a `CPoint` object.  \n  \n### Remarks  \n The viewport, along with the device-context window, defines how GDI maps points in the logical coordinate system to points in the coordinate system of the actual device. In other words, they define how GDI converts logical coordinates into device coordinates.  \n  \n The viewport origin marks the point in the device coordinate system to which GDI maps the window origin, a point in the logical coordinate system specified by the **SetWindowOrg** member function. GDI maps all other points by following the same process required to map the window origin to the viewport origin. For example, all points in a circle around the point at the window origin will be in a circle around the point at the viewport origin. Similarly, all points in a line that passes through the window origin will be in a line that passes through the viewport origin.  \n  \n### Example  \n  See the example for [CView::OnPrepareDC](../../mfc/reference/cview-class.md#cview__onpreparedc).  \n  \n##  <a name=\"cdc__setwindowext\"></a>  CDC::SetWindowExt  \n Sets the x- and y-extents of the window associated with the device context.  \n  \n```  \nvirtual CSize SetWindowExt(\n    int cx,  \n    int cy);\n\n \nCSize SetWindowExt(\n    SIZE size);\n```  \n  \n### Parameters  \n `cx`  \n Specifies the x-extent (in logical units) of the window.  \n  \n `cy`  \n Specifies the y-extent (in logical units) of the window.  \n  \n `size`  \n Specifies the x- and y-extents (in logical units) of the window.  \n  \n### Return Value  \n The previous extents of the window (in logical units) as a `CSize` object. If an error occurs, the x- and y-coordinates of the returned `CSize` object are both set to 0.  \n  \n### Remarks  \n The window, along with the device-context viewport, defines how GDI maps points in the logical coordinate system to points in the device coordinate system.  \n  \n When the following mapping modes are set, calls to `SetWindowExt` and `SetViewportExt` functions are ignored:  \n  \n- `MM_HIENGLISH`  \n  \n- `MM_HIMETRIC`  \n  \n- `MM_LOENGLISH`  \n  \n- `MM_LOMETRIC`  \n  \n- `MM_TEXT`  \n  \n- `MM_TWIPS`  \n  \n When `MM_ISOTROPIC` mode is set, an application must call the `SetWindowExt` member function before calling `SetViewportExt`.  \n  \n### Example  \n  See the example for [CView::OnPrepareDC](../../mfc/reference/cview-class.md#cview__onpreparedc).  \n  \n##  <a name=\"cdc__setwindoworg\"></a>  CDC::SetWindowOrg  \n Sets the window origin of the device context.  \n  \n```  \nCPoint SetWindowOrg(\n    int x,  \n    int y);\n\n \nCPoint SetWindowOrg(\n    POINT point);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the new origin of the window.  \n  \n *y*  \n Specifies the logical y-coordinate of the new origin of the window.  \n  \n `point`  \n Specifies the logical coordinates of the new origin of the window. You can pass either a **POINT** structure or a `CPoint` object for this parameter.  \n  \n### Return Value  \n The previous origin of the window as a `CPoint` object.  \n  \n### Remarks  \n The window, along with the device-context viewport, defines how GDI maps points in the logical coordinate system to points in the device coordinate system.  \n  \n The window origin marks the point in the logical coordinate system from which GDI maps the viewport origin, a point in the device coordinate system specified by the **SetWindowOrg** function. GDI maps all other points by following the same process required to map the window origin to the viewport origin. For example, all points in a circle around the point at the window origin will be in a circle around the point at the viewport origin. Similarly, all points in a line that passes through the window origin will be in a line that passes through the viewport origin.  \n  \n##  <a name=\"cdc__setworldtransform\"></a>  CDC::SetWorldTransform  \n Sets a two-dimensional linear transformation between world space and page space for the specified device context. This transformation can be used to scale, rotate, shear, or translate graphics output.  \n  \n```  \nBOOL SetWorldTransform(const XFORM& rXform);\n```  \n  \n### Parameters  \n `rXform`  \n Reference to an [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure that contains the transformation data.  \n  \n### Return Value  \n Returns a nonzero value on success.  \n  \n Returns 0 on failure.  \n  \n To get extended error information, call [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  \n  \n### Remarks  \n This method wraps the Windows GDI function [SetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145104).  \n  \n##  <a name=\"cdc__startdoc\"></a>  CDC::StartDoc  \n Informs the device driver that a new print job is starting and that all subsequent `StartPage` and `EndPage` calls should be spooled under the same job until an `EndDoc` call occurs.  \n  \n```  \nint StartDoc(LPDOCINFO lpDocInfo);\n\n \nint StartDoc(LPCTSTR lpszDocName);\n```  \n  \n### Parameters  \n *lpDocInfo*  \n Points to a [DOCINFO](http://msdn.microsoft.com/library/windows/desktop/dd183574) structure containing the name of the document file and the name of the output file.  \n  \n *lpszDocName*  \n Pointer to a string containing the name of the document file.  \n  \n### Return Value  \n If the function succeeds, the return value is greater than zero. This value is the print job identifier for the document.  \n  \n If the function fails, the return value is less than or equal to zero.  \n  \n### Remarks  \n This ensures that documents longer than one page will not be interspersed with other jobs.  \n  \n For Windows versions 3.1 and later, this function replaces the **STARTDOC** printer escape. Using this function ensures that documents containing more than one page are not interspersed with other print jobs.  \n  \n `StartDoc` should not be used inside metafiles.  \n  \n### Example  \n This code fragment gets the default printer, opens a print job, and spools one page with \"Hello, World!\" on it. Because the text printed by this code isn't scaled to the printer's logical units, the output text may be in such small letters that the result is unreadable. The CDC scaling functions, such as `SetMapMode`, `SetViewportOrg`, and `SetWindowExt`, can be used to fix the scaling.  \n  \n [!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]  \n  \n##  <a name=\"cdc__startpage\"></a>  CDC::StartPage  \n Call this member function to prepare the printer driver to receive data.  \n  \n```  \nint StartPage();\n```  \n  \n### Return Value  \n Greater than or equal to 0 if the function is successful, or a negative value if an error occurred.  \n  \n### Remarks  \n `StartPage` supersedes the **NEWFRAME** and **BANDINFO** escapes.  \n  \n For an overview of the sequence of printing calls, see the [StartDoc](#cdc__startdoc) member function.  \n  \n The system disables the `ResetDC` member function between calls to `StartPage` and `EndPage`.  \n  \n### Example  \n  See the example for [CDC::StartDoc](#cdc__startdoc).  \n  \n##  <a name=\"cdc__stretchblt\"></a>  CDC::StretchBlt  \n Copies a bitmap from a source rectangle into a destination rectangle, stretching or compressing the bitmap if necessary to fit the dimensions of the destination rectangle.  \n  \n```  \nBOOL StretchBlt(\n    int x,  \n    int y,  \n    int nWidth,  \n    int nHeight,  \n    CDC* pSrcDC,  \n    int xSrc,  \n    int ySrc,  \n    int nSrcWidth,  \n    int nSrcHeight,  \n    DWORD dwRop);\n```  \n  \n### Parameters  \n *x*  \n Specifies the x-coordinate (in logical units) of the upper-left corner of the destination rectangle.  \n  \n *y*  \n Specifies the y-coordinate (in logical units) of the upper-left corner of the destination rectangle.  \n  \n `nWidth`  \n Specifies the width (in logical units) of the destination rectangle.  \n  \n `nHeight`  \n Specifies the height (in logical units) of the destination rectangle.  \n  \n `pSrcDC`  \n Specifies the source device context.  \n  \n `xSrc`  \n Specifies the x-coordinate (in logical units) of the upper-left corner of the source rectangle.  \n  \n `ySrc`  \n Specifies the y-coordinate (in logical units) of the upper-left corner of the source rectangle.  \n  \n `nSrcWidth`  \n Specifies the width (in logical units) of the source rectangle.  \n  \n `nSrcHeight`  \n Specifies the height (in logical units) of the source rectangle.  \n  \n *dwRop*  \n Specifies the raster operation to be performed. Raster operation codes define how GDI combines colors in output operations that involve a current brush, a possible source bitmap, and a destination bitmap. This parameter may be one of the following values:  \n  \n- **BLACKNESS** Turns all output black.  \n  \n- **DSTINVERT** Inverts the destination bitmap.  \n  \n- **MERGECOPY** Combines the pattern and the source bitmap using the Boolean AND operator.  \n  \n- **MERGEPAINT** Combines the inverted source bitmap with the destination bitmap using the Boolean OR operator.  \n  \n- **NOTSRCCOPY** Copies the inverted source bitmap to the destination.  \n  \n- **NOTSRCERASE** Inverts the result of combining the destination and source bitmaps using the Boolean OR operator.  \n  \n- **PATCOPY** Copies the pattern to the destination bitmap.  \n  \n- **PATINVERT** Combines the destination bitmap with the pattern using the Boolean XOR operator.  \n  \n- **PATPAINT** Combines the inverted source bitmap with the pattern using the Boolean OR operator. Combines the result of this operation with the destination bitmap using the Boolean OR operator.  \n  \n- **SRCAND** Combines pixels of the destination and source bitmaps using the Boolean AND operator.  \n  \n- **SRCCOPY** Copies the source bitmap to the destination bitmap.  \n  \n- **SRCERASE** Inverts the destination bitmap and combines the result with the source bitmap using the Boolean AND operator.  \n  \n- **SRCINVERT** Combines pixels of the destination and source bitmaps using the Boolean XOR operator.  \n  \n- **SRCPAINT** Combines pixels of the destination and source bitmaps using the Boolean OR operator.  \n  \n- **WHITENESS** Turns all output white.  \n  \n### Return Value  \n Nonzero if the bitmap is drawn; otherwise 0.  \n  \n### Remarks  \n The function uses the stretching mode of the destination device context (set by `SetStretchBltMode`) to determine how to stretch or compress the bitmap.  \n  \n The `StretchBlt` function moves the bitmap from the source device given by `pSrcDC` to the destination device represented by the device-context object whose member function is being called. The `xSrc`, `ySrc`, `nSrcWidth`, and `nSrcHeight` parameters define the upper-left corner and dimensions of the source rectangle. The *x*, *y*, `nWidth`, and `nHeight` parameters give the upper-left corner and dimensions of the destination rectangle. The raster operation specified by *dwRop* defines how the source bitmap and the bits already on the destination device are combined.  \n  \n The `StretchBlt` function creates a mirror image of a bitmap if the signs of the `nSrcWidth` and `nWidth` or `nSrcHeight` and `nHeight` parameters differ. If `nSrcWidth` and `nWidth` have different signs, the function creates a mirror image of the bitmap along the x-axis. If `nSrcHeight` and `nHeight` have different signs, the function creates a mirror image of the bitmap along the y-axis.  \n  \n The `StretchBlt` function stretches or compresses the source bitmap in memory and then copies the result to the destination. If a pattern is to be merged with the result, it is not merged until the stretched source bitmap is copied to the destination. If a brush is used, it is the selected brush in the destination device context. The destination coordinates are transformed according to the destination device context; the source coordinates are transformed according to the source device context.  \n  \n If the destination, source, and pattern bitmaps do not have the same color format, `StretchBlt` converts the source and pattern bitmaps to match the destination bitmaps. The foreground and background colors of the destination device context are used in the conversion.  \n  \n If `StretchBlt` must convert a monochrome bitmap to color, it sets white bits (1) to the background color and black bits (0) to the foreground color. To convert color to monochrome, it sets pixels that match the background color to white (1) and sets all other pixels to black (0). The foreground and background colors of the device context with color are used.  \n  \n Not all devices support the `StretchBlt` function. To determine whether a device supports `StretchBlt`, call the `GetDeviceCaps` member function with the **RASTERCAPS** index and check the return value for the **RC_STRETCHBLT** flag.  \n  \n##  <a name=\"cdc__strokeandfillpath\"></a>  CDC::StrokeAndFillPath  \n Closes any open figures in a path, strokes the outline of the path by using the current pen, and fills its interior by using the current brush.  \n  \n```  \nBOOL StrokeAndFillPath();\n```  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The device context must contain a closed path. The `StrokeAndFillPath` member function has the same effect as closing all the open figures in the path, and stroking and filling the path separately, except that the filled region will not overlap the stroked region even if the pen is wide.  \n  \n##  <a name=\"cdc__strokepath\"></a>  CDC::StrokePath  \n Renders the specified path by using the current pen.  \n  \n```  \nBOOL StrokePath();\n```  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n The device context must contain a closed path.  \n  \n##  <a name=\"cdc__tabbedtextout\"></a>  CDC::TabbedTextOut  \n Call this member function to write a character string at the specified location, expanding tabs to the values specified in the array of tab-stop positions.  \n  \n```  \nvirtual CSize TabbedTextOut(\n    int x,  \n    int y,  \n    LPCTSTR lpszString,  \n    int nCount,  \n    int nTabPositions,  \n    LPINT lpnTabStopPositions,  \n    int nTabOrigin);\n\n \nCSize TabbedTextOut(\n    int x,  \n    int y,  \n    const CString& str,  \n    int nTabPositions,  \n    LPINT lpnTabStopPositions,  \n    int nTabOrigin);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the starting point of the string.  \n  \n *y*  \n Specifies the logical y-coordinate of the starting point of the string.  \n  \n `lpszString`  \n Points to the character string to draw. You can pass either a pointer to an array of characters or a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object for this parameter.  \n  \n `nCount`  \n Specifies the number of characters in the string. If `nCount` is –1, the length is calculated.  \n  \n `nTabPositions`  \n Specifies the number of values in the array of tab-stop positions.  \n  \n `lpnTabStopPositions`  \n Points to an array containing the tab-stop positions (in logical units). The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array.  \n  \n `nTabOrigin`  \n Specifies the x-coordinate of the starting position from which tabs are expanded (in logical units).  \n  \n `str`  \n A `CString` object that contains the specified characters.  \n  \n### Return Value  \n The dimensions of the string (in logical units) as a `CSize` object.  \n  \n### Remarks  \n Text is written in the currently selected font. If `nTabPositions` is 0 and `lpnTabStopPositions` is **NULL**, tabs are expanded to eight times the average character width.  \n  \n If `nTabPositions` is 1, the tab stops are separated by the distance specified by the first value in the `lpnTabStopPositions` array. If the `lpnTabStopPositions` array contains more than one value, a tab stop is set for each value in the array, up to the number specified by `nTabPositions`. The `nTabOrigin` parameter allows an application to call the `TabbedTextOut` function several times for a single line. If the application calls the function more than once with the `nTabOrigin` set to the same value each time, the function expands all tabs relative to the position specified by `nTabOrigin`.  \n  \n By default, the current position is not used or updated by the function. If an application needs to update the current position when it calls the function, the application can call the [SetTextAlign](#cdc__settextalign) member function with `nFlags` set to **TA_UPDATECP**. When this flag is set, Windows ignores the *x* and *y* parameters on subsequent calls to `TabbedTextOut`, using the current position instead.  \n  \n##  <a name=\"cdc__textout\"></a>  CDC::TextOut  \n Writes a character string at the specified location using the currently selected font.  \n  \n```  \nvirtual BOOL TextOut(\n    int x,  \n    int y,  \n    LPCTSTR lpszString,  \n    int nCount);\n\n \nBOOL TextOut(\n    int x,\n    int y,\n    const CString& str);\n```  \n  \n### Parameters  \n *x*  \n Specifies the logical x-coordinate of the starting point of the text.  \n  \n *y*  \n Specifies the logical y-coordinate of the starting point of the text.  \n  \n `lpszString`  \n Points to the character string to be drawn.  \n  \n `nCount`  \n Specifies the number of characters in the string.  \n  \n `str`  \n A `CString` object that contains the characters to be drawn.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n Character origins are at the upper-left corner of the character cell. By default, the current position is not used or updated by the function.  \n  \n If an application needs to update the current position when it calls `TextOut`, the application can call the `SetTextAlign` member function with `nFlags` set to **TA_UPDATECP**. When this flag is set, Windows ignores the *x* and *y* parameters on subsequent calls to `TextOut`, using the current position instead.  \n  \n### Example  \n  See the example for [CDC::BeginPath](#cdc__beginpath).  \n  \n##  <a name=\"cdc__transparentblt\"></a>  CDC::TransparentBlt  \n Call this member function to transfer a bit-block of the color data, which corresponds to a rectangle of pixels from the specified source device context, into a destination device context.  \n  \n```  \nBOOL TransparentBlt(\n    int xDest,  \n    int yDest,\n    int nDestWidth,\n    int nDestHeight,  \n    CDC* pSrcDC,  \n    int xSrc,  \n    int ySrc,  \n    int nSrcWidth,  \n    int nSrcHeight,  \n    UINT clrTransparent);\n```  \n  \n### Parameters  \n `xDest`  \n Specifies the x-coordinate, in logical units, of the upper-left corner of the destination rectangle.  \n  \n `yDest`  \n Specifies the y-coordinate, in logical units, of the upper-left corner of the destination rectangle.  \n  \n `nDestWidth`  \n Specifies the width, in logical units, of the destination rectangle.  \n  \n `nDestHeight`  \n Specifies the height, in logical units, of the destination rectangle.  \n  \n `pSrcDC`  \n Pointer to the source device context.  \n  \n `xSrc`  \n Specifies the x-coordinate, in logical units, of the source rectangle.  \n  \n `ySrc`  \n Specifies the y-coordinate, in logical units, of the source rectangle.  \n  \n `nSrcWidth`  \n Specifies the width, in logical units, of the source rectangle.  \n  \n `nSrcHeight`  \n Specifies the height, in logical units, of the source rectangle.  \n  \n `clrTransparent`  \n The RGB color in the source bitmap to treat as transparent.  \n  \n### Return Value  \n **TRUE** if successful; otherwise **FALSE**.  \n  \n### Remarks  \n `TransparentBlt` allows for transparency; that is, the RGB color indicated by `clrTransparent` is rendered transparent for the transfer.  \n  \n For more information, see [TransparentBlt](http://msdn.microsoft.com/library/windows/desktop/dd145141) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"cdc__updatecolors\"></a>  CDC::UpdateColors  \n Updates the client area of the device context by matching the current colors in the client area to the system palette on a pixel-by-pixel basis.  \n  \n```  \nvoid UpdateColors();\n```  \n  \n### Remarks  \n An inactive window with a realized logical palette may call `UpdateColors` as an alternative to redrawing its client area when the system palette changes.  \n  \n For more information about using color palettes, see [UpdateColors](http://msdn.microsoft.com/library/windows/desktop/dd145166) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n The `UpdateColors` member function typically updates a client area faster than redrawing the area. However, because the function performs the color translation based on the color of each pixel before the system palette changed, each call to this function results in the loss of some color accuracy.  \n  \n##  <a name=\"cdc__widenpath\"></a>  CDC::WidenPath  \n Redefines the current path as the area that would be painted if the path were stroked using the pen currently selected into the device context.  \n  \n```  \nBOOL WidenPath();\n```  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0.  \n  \n### Remarks  \n This function is successful only if the current pen is a geometric pen created by the second version of `CreatePen` member function, or if the pen is created with the first version of `CreatePen` and has a width, in device units, of greater than 1. The device context must contain a closed path. Any Bzier curves in the path are converted to sequences of straight lines approximating the widened curves. As such, no Bzier curves remain in the path after `WidenPath` is called.  \n  \n## See Also  \n [CObject Class](../../mfc/reference/cobject-class.md)   \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)   \n [CPaintDC Class](../../mfc/reference/cpaintdc-class.md)   \n [CWindowDC Class](../../mfc/reference/cwindowdc-class.md)   \n [CClientDC Class](../../mfc/reference/cclientdc-class.md)   \n [CMetaFileDC Class](../../mfc/reference/cmetafiledc-class.md)\n"}