{"nodes":[{"pos":[12,67],"content":"TN038: MFC-OLE IUnknown Implementation | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN038: MFC-OLE IUnknown Implementation | Microsoft Docs","pos":[0,55]}]},{"content":"TN038: MFC/OLE IUnknown Implementation","pos":[992,1030]},{"pos":[1033,1348],"content":"[!NOTE]\n The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","leadings":["","> "],"nodes":[{"content":" The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[8,313],"nodes":[{"content":"The following technical note has not been updated since it was first included in the online documentation.","pos":[1,107]},{"content":"As a result, some procedures and topics might be out of date or incorrect.","pos":[108,182]},{"content":"For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[183,305]}]}]},{"content":"At the heart of OLE 2 is the \"OLE Component Object Model\", or COM.","pos":[1355,1421]},{"content":"COM defines a standard for how cooperating objects communicate to one another.","pos":[1422,1500]},{"content":"This includes the details of what an \"object\" looks like, including how methods are dispatched on an object.","pos":[1501,1609]},{"content":"COM also defines a base class, from which all COM compatible classes are derived.","pos":[1610,1691]},{"content":"This base class is <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>.","pos":[1692,1782],"source":" This base class is [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509)."},{"content":"Although the <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> interface is referred to as a C++ class, COM is not specific to any one language — it can be implemented in C, PASCAL, or any other language that can support the binary layout of a COM object.","pos":[1783,2059],"source":" Although the [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) interface is referred to as a C++ class, COM is not specific to any one language — it can be implemented in C, PASCAL, or any other language that can support the binary layout of a COM object."},{"content":"OLE refers to all classes derived from <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> as \"interfaces.\"","pos":[2066,2192],"source":"OLE refers to all classes derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) as \"interfaces.\""},{"content":"This is an important distinction, since an \"interface\" such as <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> carries with it no implementation.","pos":[2193,2361],"source":" This is an important distinction, since an \"interface\" such as [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) carries with it no implementation."},{"content":"It simply defines the protocol by which objects communicate, not the specifics of what those implementations do.","pos":[2362,2474]},{"content":"This is reasonable for a system that allows for maximum flexibility.","pos":[2475,2543]},{"content":"It is MFC's job to implement a default behavior for MFC/C++ programs.","pos":[2544,2613]},{"content":"To understand MFC's implementation of <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> you must first understand what this interface is.","pos":[2620,2778],"source":"To understand MFC's implementation of [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) you must first understand what this interface is."},{"content":"A simplified version of <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> is defined below:","pos":[2779,2891],"source":" A simplified version of [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) is defined below:"},{"pos":[3088,3200],"content":"[!NOTE]\n Certain necessary calling convention details, such as `__stdcall` are left out for this illustration.","leadings":["","> "],"nodes":[{"content":"Certain necessary calling convention details, such as <ph id=\"ph1\">`__stdcall`</ph> are left out for this illustration.","pos":[9,110],"source":" Certain necessary calling convention details, such as `__stdcall` are left out for this illustration."}]},{"content":"The <bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> member functions control memory management of the object.","pos":[3207,3411],"source":"The [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) member functions control memory management of the object."},{"content":"COM uses a reference counting scheme to keep track of objects.","pos":[3412,3474]},{"content":"An object is never referenced directly as you would in C++.","pos":[3475,3534]},{"content":"Instead, COM objects are always referenced through a pointer.","pos":[3535,3596]},{"content":"To release the object when the owner is done using it, the object's <bpt id=\"p1\">[</bpt>Release<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> member is called (as opposed to using operator delete, as would be done for a traditional C++ object).","pos":[3597,3837],"source":" To release the object when the owner is done using it, the object's [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) member is called (as opposed to using operator delete, as would be done for a traditional C++ object)."},{"content":"The reference counting mechanism allows for multiple references to a single object to be managed.","pos":[3838,3935]},{"content":"An implementation of <bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> maintains a reference count on the object — the object is not deleted until its reference count reaches zero.","pos":[3936,4209],"source":" An implementation of [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) maintains a reference count on the object — the object is not deleted until its reference count reaches zero."},{"content":"<bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> are fairly straightforward from an implementation standpoint.","pos":[4216,4420],"source":"[AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) are fairly straightforward from an implementation standpoint."},{"content":"Here is a trivial implementation:","pos":[4421,4454]},{"content":"The <bpt id=\"p1\">[</bpt>QueryInterface<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> member function is a little more interesting.","pos":[4669,4795],"source":"The [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) member function is a little more interesting."},{"content":"It is not very interesting to have an object whose only member functions are <bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> — it would be nice to tell the object to do more things than <bpt id=\"p3\">[</bpt>IUnknown<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> provides.","pos":[4796,5157],"source":" It is not very interesting to have an object whose only member functions are [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) — it would be nice to tell the object to do more things than [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) provides."},{"content":"This is where <bpt id=\"p1\">[</bpt>QueryInterface<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> is useful.","pos":[5158,5259],"source":" This is where [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) is useful."},{"content":"It allows you to obtain a different \"interface\" on the same object.","pos":[5260,5327]},{"content":"These interfaces are usually derived from <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> and add additional functionality by adding new member functions.","pos":[5328,5505],"source":" These interfaces are usually derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) and add additional functionality by adding new member functions."},{"content":"COM interfaces never have member variables declared in the interface, and all member functions are declared as pure-virtual.","pos":[5506,5630]},{"content":"For example,","pos":[5631,5643]},{"content":"To get an IPrintInterface if you only have an <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>, call <bpt id=\"p2\">[</bpt>QueryInterface<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> using the <ph id=\"ph1\">`IID`</ph> of the <bpt id=\"p3\">**</bpt>IPrintInterface<ept id=\"p3\">**</ept>.","pos":[5764,6007],"source":"To get an IPrintInterface if you only have an [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509), call [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) using the `IID` of the **IPrintInterface**."},{"content":"An <ph id=\"ph1\">`IID`</ph> is a 128-bit number that uniquely identifies the interface.","pos":[6008,6076],"source":" An `IID` is a 128-bit number that uniquely identifies the interface."},{"content":"There is an <ph id=\"ph1\">`IID`</ph> for each interface that either you or OLE define.","pos":[6077,6144],"source":" There is an `IID` for each interface that either you or OLE define."},{"content":"If <ph id=\"ph1\">`pUnk`</ph> is a pointer to an <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> object, the code to retrieve an IPrintInterface from it might be:","pos":[6145,6310],"source":" If `pUnk` is a pointer to an [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) object, the code to retrieve an IPrintInterface from it might be:"},{"content":"That seems fairly easy, but how would you implement an object supporting both the IPrintInterface and <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> interface In this case it is simple since the IPrintInterface is derived directly from <bpt id=\"p2\">[</bpt>IUnknown<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> — by implementing IPrintInterface, <bpt id=\"p3\">[</bpt>IUnknown<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> is automatically supported.","pos":[6551,7015],"source":"That seems fairly easy, but how would you implement an object supporting both the IPrintInterface and [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) interface In this case it is simple since the IPrintInterface is derived directly from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) — by implementing IPrintInterface, [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) is automatically supported."},{"content":"For example:","pos":[7016,7028]},{"content":"The implementations of <bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> would be exactly the same as those implemented above.","pos":[7248,7467],"source":"The implementations of [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) would be exactly the same as those implemented above."},{"content":"<bpt id=\"p1\">**</bpt>CPrintObj::QueryInterface<ept id=\"p1\">**</ept> would look something like this:","pos":[7468,7529],"source":"**CPrintObj::QueryInterface** would look something like this:"},{"content":"As you can see, if the interface identifier (IID) is recognized, a pointer is returned to your object; otherwise an error occurs.","pos":[7780,7909]},{"content":"Also note that a successful <bpt id=\"p1\">[</bpt>QueryInterface<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> results in an implied <bpt id=\"p2\">[</bpt>AddRef<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>.","pos":[7910,8106],"source":" Also note that a successful [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) results in an implied [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379)."},{"content":"Of course, you'd also have to implement CEditObj::Print.","pos":[8107,8163]},{"content":"That is simple because the IPrintInterface was directly derived from the <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> interface.","pos":[8164,8318],"source":" That is simple because the IPrintInterface was directly derived from the [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) interface."},{"content":"However, if you wanted to support two different interfaces, both derived from <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>, consider the following:","pos":[8319,8492],"source":" However, if you wanted to support two different interfaces, both derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509), consider the following:"},{"content":"Although there are a number of different ways to implement a class supporting both IEditInterface and IPrintInterface, including using C++ multiple inheritance, this note will concentrate on the use of nested classes to implement this functionality.","pos":[8610,8859]},{"content":"The entire implementation is included below:","pos":[9524,9568]},{"content":"Notice that most of the <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> implementation is placed into the CEditPrintObj class rather than duplicating the code in CEditPrintObj::CEditObj and CEditPrintObj::CPrintObj.","pos":[10908,11146],"source":"Notice that most of the [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) implementation is placed into the CEditPrintObj class rather than duplicating the code in CEditPrintObj::CEditObj and CEditPrintObj::CPrintObj."},{"content":"This reduces the amount of code and avoids bugs.","pos":[11147,11195]},{"content":"The key point here is that from the IUnknown interface it is possible to call <bpt id=\"p1\">[</bpt>QueryInterface<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> to retrieve any interface the object might support, and from each of those interfaces it is possible to do the same.","pos":[11196,11467],"source":" The key point here is that from the IUnknown interface it is possible to call [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) to retrieve any interface the object might support, and from each of those interfaces it is possible to do the same."},{"content":"This means that all <bpt id=\"p1\">[</bpt>QueryInterface<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> functions available from each interface must behave exactly the same way.","pos":[11468,11638],"source":" This means that all [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) functions available from each interface must behave exactly the same way."},{"content":"In order for these embedded objects to call the implementation in the \"outer object\", a back-pointer is used (m_pParent).","pos":[11639,11760]},{"content":"The m_pParent pointer is initialized during the CEditPrintObj constructor.","pos":[11761,11835]},{"content":"Then you would implement CEditPrintObj::CPrintObj::PrintObject and CEditPrintObj::CEditObj::EditObject as well.","pos":[11836,11947]},{"content":"Quite a bit of code was added to add one feature — the ability to edit the object.","pos":[11948,12030]},{"content":"Fortunately, it is quite uncommon for interfaces to have only a single member function (although it does happen) and in this case, EditObject and PrintObject would usually be combined into a single interface.","pos":[12031,12239]},{"content":"That's a lot of explanation and a lot of code for such a simple scenario.","pos":[12246,12319]},{"content":"The MFC/OLE classes provide a simpler alternative.","pos":[12320,12370]},{"content":"The MFC implementation uses a technique similar to the way Windows messages are wrapped with Message Maps.","pos":[12371,12477]},{"content":"This facility is called <bpt id=\"p1\">*</bpt>Interface Maps<ept id=\"p1\">*</ept> and is discussed in the next section.","pos":[12478,12556],"source":" This facility is called *Interface Maps* and is discussed in the next section."},{"content":"MFC Interface Maps","pos":[12565,12583]},{"content":"MFC/OLE includes an implementation of \"Interface Maps\" similar to MFC's \"Message Maps\" and \"Dispatch Maps\" in concept and execution.","pos":[12587,12719]},{"content":"The core features of MFC's Interface Maps are as follows:","pos":[12720,12777]},{"pos":[12787,12922],"content":"A standard implementation of <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>, built into the <ph id=\"ph1\">`CCmdTarget`</ph> class.","source":"A standard implementation of [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509), built into the `CCmdTarget` class."},{"pos":[12932,13122],"content":"Maintenance of the reference count, modified by <bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>","source":"Maintenance of the reference count, modified by [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317)"},{"pos":[13132,13238],"content":"Data driven implementation of <bpt id=\"p1\">[</bpt>QueryInterface<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept>","source":"Data driven implementation of [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521)"},{"content":"In addition, interface maps support the following advanced features:","pos":[13245,13313]},{"content":"Support for creating aggregatable COM objects","pos":[13323,13368]},{"content":"Support for using aggregate objects in the implementation of a COM object","pos":[13378,13451]},{"content":"The implementation is hookable and extensible","pos":[13461,13506]},{"pos":[13513,13654],"content":"For more information on aggregation, see the <bpt id=\"p1\">[</bpt>Aggregation<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms686558\\(v=vs.85\\).aspx)</ept> topic.","source":"For more information on aggregation, see the [Aggregation](http://msdn.microsoft.com/library/windows/desktop/ms686558\\(v=vs.85\\).aspx) topic."},{"content":"MFC's interface map support is rooted in the <ph id=\"ph1\">`CCmdTarget`</ph> class.","pos":[13661,13725],"source":"MFC's interface map support is rooted in the `CCmdTarget` class."},{"content":"\"<bpt id=\"p1\">*</bpt>has-a<ept id=\"p1\">*</ept>\" reference count as well as all the member functions associated with the <bpt id=\"p2\">[</bpt>IUnknown<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> implementation (the reference count for example is in <ph id=\"ph1\">`CCmdTarget`</ph>).","pos":[13739,13960],"source":" \"*has-a*\" reference count as well as all the member functions associated with the [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) implementation (the reference count for example is in `CCmdTarget`)."},{"content":"To create a class that supports OLE COM, you derive a class from <ph id=\"ph1\">`CCmdTarget`</ph> and use various macros as well as member functions of <ph id=\"ph2\">`CCmdTarget`</ph> to implement the desired interfaces.","pos":[13961,14142],"source":" To create a class that supports OLE COM, you derive a class from `CCmdTarget` and use various macros as well as member functions of `CCmdTarget` to implement the desired interfaces."},{"content":"MFC's implementation uses nested classes to define each interface implementation much like the example above.","pos":[14143,14252]},{"content":"This is made easier with a standard implementation of IUnknown as well as a number of macros that eliminate some of the repetitive code.","pos":[14253,14389]},{"content":"Interface Map Basics","pos":[14398,14418]},{"content":"To implement a class using MFC's interface maps","pos":[14429,14476]},{"pos":[14486,14549],"content":"Derive a class either directly or indirectly from <ph id=\"ph1\">`CCmdTarget`</ph>.","source":"Derive a class either directly or indirectly from `CCmdTarget`."},{"pos":[14559,14632],"content":"Use the <ph id=\"ph1\">`DECLARE_INTERFACE_MAP`</ph> function in the derived class definition.","source":"Use the `DECLARE_INTERFACE_MAP` function in the derived class definition."},{"pos":[14642,14769],"content":"For each interface you wish to support, use the <ph id=\"ph1\">`BEGIN_INTERFACE_PART`</ph> and <ph id=\"ph2\">`END_INTERFACE_PART`</ph> macros in the class definition.","source":"For each interface you wish to support, use the `BEGIN_INTERFACE_PART` and `END_INTERFACE_PART` macros in the class definition."},{"pos":[14779,14904],"content":"In the implementation file, use the <ph id=\"ph1\">`BEGIN_INTERFACE_MAP`</ph> and <ph id=\"ph2\">`END_INTERFACE_MAP`</ph> macros to define the class's interface map.","source":"In the implementation file, use the `BEGIN_INTERFACE_MAP` and `END_INTERFACE_MAP` macros to define the class's interface map."},{"pos":[14914,15085],"content":"For each IID supported, use the <ph id=\"ph1\">`INTERFACE_PART`</ph> macro between the <ph id=\"ph2\">`BEGIN_INTERFACE_MAP`</ph> and <ph id=\"ph3\">`END_INTERFACE_MAP`</ph> macros to map that IID to a specific \"part\" of your class.","source":"For each IID supported, use the `INTERFACE_PART` macro between the `BEGIN_INTERFACE_MAP` and `END_INTERFACE_MAP` macros to map that IID to a specific \"part\" of your class."},{"content":"Implement each of the nested classes that represent the interfaces you support.","pos":[15095,15174]},{"pos":[15184,15266],"content":"Use the <ph id=\"ph1\">`METHOD_PROLOGUE`</ph> macro to access the parent, <ph id=\"ph2\">`CCmdTarget`</ph>-derived object.","source":"Use the `METHOD_PROLOGUE` macro to access the parent, `CCmdTarget`-derived object."},{"pos":[15275,15632],"content":"<bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>, and <bpt id=\"p3\">[</bpt>QueryInterface<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> can delegate to the <ph id=\"ph1\">`CCmdTarget`</ph> implementation of these functions (<ph id=\"ph2\">`ExternalAddRef`</ph>, <ph id=\"ph3\">`ExternalRelease`</ph>, and <ph id=\"ph4\">`ExternalQueryInterface`</ph>).","source":"[AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) can delegate to the `CCmdTarget` implementation of these functions (`ExternalAddRef`, `ExternalRelease`, and `ExternalQueryInterface`)."},{"content":"The CPrintEditObj example above could be implemented as follows:","pos":[15639,15703]},{"content":"The above declaration creates a class derived from <ph id=\"ph1\">`CCmdTarget`</ph>.","pos":[16171,16235],"source":"The above declaration creates a class derived from `CCmdTarget`."},{"content":"The <ph id=\"ph1\">`DECLARE_INTERFACE_MAP`</ph> macro tells the framework that this class will have a custom interface map.","pos":[16236,16339],"source":" The `DECLARE_INTERFACE_MAP` macro tells the framework that this class will have a custom interface map."},{"content":"In addition, the <ph id=\"ph1\">`BEGIN_INTERFACE_PART`</ph> and <ph id=\"ph2\">`END_INTERFACE_PART`</ph> macros define nested classes, in this case with names CEditObj and CPrintObj (the X is used only to differentiate the nested classes from global classes which start with \"C\" and interface classes which start with \"I\").","pos":[16340,16623],"source":" In addition, the `BEGIN_INTERFACE_PART` and `END_INTERFACE_PART` macros define nested classes, in this case with names CEditObj and CPrintObj (the X is used only to differentiate the nested classes from global classes which start with \"C\" and interface classes which start with \"I\")."},{"content":"Two nested members of these classes are created: m_CEditObj, and m_CPrintObj, respectively.","pos":[16624,16715]},{"content":"The macros automatically declare the <bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>, and <bpt id=\"p3\">[</bpt>QueryInterface<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> functions; therefore you only declare the functions specific to this interface: EditObject and PrintObject (the OLE macro <ph id=\"ph1\">`STDMETHOD`</ph> is used so that <ph id=\"ph2\">`_stdcall`</ph> and virtual keywords are provided as appropriate for the target platform).","pos":[16716,17210],"source":" The macros automatically declare the [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) functions; therefore you only declare the functions specific to this interface: EditObject and PrintObject (the OLE macro `STDMETHOD` is used so that `_stdcall` and virtual keywords are provided as appropriate for the target platform)."},{"content":"To implement the interface map for this class:","pos":[17217,17263]},{"content":"This connects the IID_IPrintInterface IID with m_CPrintObj and IID_IEditInterface with m_CEditObj respectively.","pos":[17508,17619]},{"content":"The <ph id=\"ph1\">`CCmdTarget`</ph> implementation of <bpt id=\"p1\">[</bpt>QueryInterface<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> (<ph id=\"ph2\">`CCmdTarget::ExternalQueryInterface`</ph>) uses this map to return pointers to m_CPrintObj and m_CEditObj when requested.","pos":[17620,17849],"source":" The `CCmdTarget` implementation of [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) (`CCmdTarget::ExternalQueryInterface`) uses this map to return pointers to m_CPrintObj and m_CEditObj when requested."},{"content":"It is not necessary to include an entry for <ph id=\"ph1\">`IID_IUnknown`</ph>; the framework will use the first interface in the map (in this case, m_CPrintObj) when <ph id=\"ph2\">`IID_IUnknown`</ph> is requested.","pos":[17850,18025],"source":" It is not necessary to include an entry for `IID_IUnknown`; the framework will use the first interface in the map (in this case, m_CPrintObj) when `IID_IUnknown` is requested."},{"pos":[18032,18377],"content":"Even though the <ph id=\"ph1\">`BEGIN_INTERFACE_PART`</ph> macro automatically declared the <bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> and <bpt id=\"p3\">[</bpt>QueryInterface<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> functions for you, you still need to implement them:","source":"Even though the `BEGIN_INTERFACE_PART` macro automatically declared the [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) functions for you, you still need to implement them:"},{"content":"The implementation for CEditPrintObj::CPrintObj, would be similar to the above definitions for CEditPrintObj::CEditObj.","pos":[19108,19227]},{"content":"Although it would be possible to create a macro that could be used to automatically generate these functions (but earlier in MFC/OLE development this was the case), it becomes difficult to set break points when a macro generates more than one line of code.","pos":[19228,19484]},{"content":"For this reason, this code is expanded manually.","pos":[19485,19533]},{"content":"By using the framework implementation of message maps, there are a number of things that were not necessary to do:","pos":[19540,19654]},{"content":"Implement QueryInterface","pos":[19664,19688]},{"content":"Implement AddRef and Release","pos":[19698,19726]},{"content":"Declare either of these built-in methods on both of your interfaces","pos":[19736,19803]},{"content":"In addition, the framework uses message maps internally.","pos":[19810,19866]},{"content":"This allows you to derive from a framework class, say <ph id=\"ph1\">`COleServerDoc`</ph>, that already supports certain interfaces and provides either replacements or additions to the interfaces provided by the framework.","pos":[19867,20069],"source":" This allows you to derive from a framework class, say `COleServerDoc`, that already supports certain interfaces and provides either replacements or additions to the interfaces provided by the framework."},{"content":"You can do this because the framework fully supports inheriting an interface map from a base class.","pos":[20070,20169]},{"content":"That is the reason why <ph id=\"ph1\">`BEGIN_INTERFACE_MAP`</ph> takes as its second parameter the name of the base class.","pos":[20170,20272],"source":" That is the reason why `BEGIN_INTERFACE_MAP` takes as its second parameter the name of the base class."},{"pos":[20280,20935],"content":"[!NOTE]\n It is generally not possible to reuse the implementation of MFC's built-in implementations of the OLE interfaces just by inheriting the embedded specialization of that interface from the MFC version. This is not possible because the use of the `METHOD_PROLOGUE` macro to get access to the containing `CCmdTarget`-derived object implies a *fixed offset* of the embedded object from the `CCmdTarget`-derived object. This means, for example, you cannot derive an embedded XMyAdviseSink from MFC's implementation in `COleClientItem::XAdviseSink`, because XAdviseSink relies on being at a specific offset from the top of the `COleClientItem` object.","leadings":["","> "],"nodes":[{"content":" It is generally not possible to reuse the implementation of MFC's built-in implementations of the OLE interfaces just by inheriting the embedded specialization of that interface from the MFC version. This is not possible because the use of the `METHOD_PROLOGUE` macro to get access to the containing `CCmdTarget`-derived object implies a *fixed offset* of the embedded object from the `CCmdTarget`-derived object. This means, for example, you cannot derive an embedded XMyAdviseSink from MFC's implementation in `COleClientItem::XAdviseSink`, because XAdviseSink relies on being at a specific offset from the top of the `COleClientItem` object.","pos":[8,653],"nodes":[{"content":"It is generally not possible to reuse the implementation of MFC's built-in implementations of the OLE interfaces just by inheriting the embedded specialization of that interface from the MFC version.","pos":[1,200]},{"content":"This is not possible because the use of the <ph id=\"ph1\">`METHOD_PROLOGUE`</ph> macro to get access to the containing <ph id=\"ph2\">`CCmdTarget`</ph>-derived object implies a <bpt id=\"p1\">*</bpt>fixed offset<ept id=\"p1\">*</ept> of the embedded object from the <ph id=\"ph3\">`CCmdTarget`</ph>-derived object.","pos":[201,414],"source":" This is not possible because the use of the `METHOD_PROLOGUE` macro to get access to the containing `CCmdTarget`-derived object implies a *fixed offset* of the embedded object from the `CCmdTarget`-derived object."},{"content":"This means, for example, you cannot derive an embedded XMyAdviseSink from MFC's implementation in <ph id=\"ph1\">`COleClientItem::XAdviseSink`</ph>, because XAdviseSink relies on being at a specific offset from the top of the <ph id=\"ph2\">`COleClientItem`</ph> object.","pos":[415,645],"source":" This means, for example, you cannot derive an embedded XMyAdviseSink from MFC's implementation in `COleClientItem::XAdviseSink`, because XAdviseSink relies on being at a specific offset from the top of the `COleClientItem` object."}]}]},{"pos":[20943,21436],"content":"[!NOTE]\n You can, however, delegate to the MFC implementation for all of the functions that you want MFC's default behavior. This is done in the MFC implementation of `IOleInPlaceFrame` (XOleInPlaceFrame) in the `COleFrameHook` class (it delegates to m_xOleInPlaceUIWindow for many functions). This design was chosen to reduce the runtime size of objects which implement many interfaces; it eliminates the need for a back-pointer (such as the way m_pParent was used in the previous section).","leadings":["","> "],"nodes":[{"content":" You can, however, delegate to the MFC implementation for all of the functions that you want MFC's default behavior. This is done in the MFC implementation of `IOleInPlaceFrame` (XOleInPlaceFrame) in the `COleFrameHook` class (it delegates to m_xOleInPlaceUIWindow for many functions). This design was chosen to reduce the runtime size of objects which implement many interfaces; it eliminates the need for a back-pointer (such as the way m_pParent was used in the previous section).","pos":[8,491],"nodes":[{"content":"You can, however, delegate to the MFC implementation for all of the functions that you want MFC's default behavior.","pos":[1,116]},{"content":"This is done in the MFC implementation of <ph id=\"ph1\">`IOleInPlaceFrame`</ph> (XOleInPlaceFrame) in the <ph id=\"ph2\">`COleFrameHook`</ph> class (it delegates to m_xOleInPlaceUIWindow for many functions).","pos":[117,285],"source":" This is done in the MFC implementation of `IOleInPlaceFrame` (XOleInPlaceFrame) in the `COleFrameHook` class (it delegates to m_xOleInPlaceUIWindow for many functions)."},{"content":"This design was chosen to reduce the runtime size of objects which implement many interfaces; it eliminates the need for a back-pointer (such as the way m_pParent was used in the previous section).","pos":[286,483]}]}]},{"content":"Aggregation and Interface Maps","pos":[21446,21476]},{"content":"In addition to supporting stand-alone COM objects, MFC also supports aggregation.","pos":[21480,21561]},{"content":"Aggregation itself is too complex a topic to discuss here; refer to the <bpt id=\"p1\">[</bpt>Aggregation<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms686558\\(v=vs.85\\).aspx)</ept> topic for more information on aggregation.","pos":[21562,21766],"source":" Aggregation itself is too complex a topic to discuss here; refer to the [Aggregation](http://msdn.microsoft.com/library/windows/desktop/ms686558\\(v=vs.85\\).aspx) topic for more information on aggregation."},{"content":"This note will simply describe the support for aggregation built into the framework and interface maps.","pos":[21767,21870]},{"content":"There are two ways to use aggregation: (1) using a COM object that supports aggregation, and (2) implementing an object that can be aggregated by another.","pos":[21877,22031]},{"content":"These capabilities can be referred to as \"using an aggregate object\" and \"making an object aggregatable\".","pos":[22032,22137]},{"content":"MFC supports both.","pos":[22138,22156]},{"content":"Using an Aggregate Object","pos":[22166,22191]},{"content":"To use an aggregate object, there needs to be some way to tie the aggregate into the QueryInterface mechanism.","pos":[22195,22305]},{"content":"In other words, the aggregate object must behave as though it is a native part of your object.","pos":[22306,22400]},{"content":"So how does this tie into MFC's interface map mechanism In addition to the <ph id=\"ph1\">`INTERFACE_PART`</ph> macro, where a nested object is mapped to an IID, you can also declare an aggregate object as part of your <ph id=\"ph2\">`CCmdTarget`</ph> derived class.","pos":[22401,22627],"source":" So how does this tie into MFC's interface map mechanism In addition to the `INTERFACE_PART` macro, where a nested object is mapped to an IID, you can also declare an aggregate object as part of your `CCmdTarget` derived class."},{"content":"To do so, the <ph id=\"ph1\">`INTERFACE_AGGREGATE`</ph> macro is used.","pos":[22628,22678],"source":" To do so, the `INTERFACE_AGGREGATE` macro is used."},{"content":"This allows you to specify a member variable (which must be a pointer to an <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> or derived class), which is to be integrated into the interface map mechanism.","pos":[22679,22904],"source":" This allows you to specify a member variable (which must be a pointer to an [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) or derived class), which is to be integrated into the interface map mechanism."},{"content":"If the pointer is not NULL when <ph id=\"ph1\">`CCmdTarget::ExternalQueryInterface`</ph> is called, the framework will automatically call the aggregate object's <bpt id=\"p1\">[</bpt>QueryInterface<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> member function, if the <ph id=\"ph2\">`IID`</ph> requested is not one of the native <ph id=\"ph3\">`IID`</ph>s supported by the <ph id=\"ph4\">`CCmdTarget`</ph> object itself.","pos":[22905,23239],"source":" If the pointer is not NULL when `CCmdTarget::ExternalQueryInterface` is called, the framework will automatically call the aggregate object's [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) member function, if the `IID` requested is not one of the native `IID`s supported by the `CCmdTarget` object itself."},{"content":"To use the INTERFACE_AGGREGATE macro","pos":[23251,23287]},{"pos":[23297,23393],"content":"Declare a member variable (an <ph id=\"ph1\">`IUnknown*`</ph>) which will contain a pointer to the aggregate object.","source":"Declare a member variable (an `IUnknown*`) which will contain a pointer to the aggregate object."},{"pos":[23403,23509],"content":"Include an <ph id=\"ph1\">`INTERFACE_AGGREGATE`</ph> macro in your interface map, which refers to the member variable by name.","source":"Include an `INTERFACE_AGGREGATE` macro in your interface map, which refers to the member variable by name."},{"pos":[23519,23644],"content":"At some point (usually during <ph id=\"ph1\">`CCmdTarget::OnCreateAggregates`</ph>), initialize the member variable to something other than NULL.","source":"At some point (usually during `CCmdTarget::OnCreateAggregates`), initialize the member variable to something other than NULL."},{"content":"For example:","pos":[23651,23663]},{"content":"The m_lpAggrInner variable is initialized in the constructor to NULL.","pos":[24575,24644]},{"content":"The framework ignores a NULL member variable in the default implementation of <bpt id=\"p1\">[</bpt>QueryInterface<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept>.","pos":[24645,24800],"source":" The framework ignores a NULL member variable in the default implementation of [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521)."},{"content":"is a good place to actually create your aggregate objects.","pos":[24822,24880]},{"content":"You'll have to call it explicitly if you are creating the object outside of the MFC implementation of <ph id=\"ph1\">`COleObjectFactory`</ph>.","pos":[24881,25003],"source":" You'll have to call it explicitly if you are creating the object outside of the MFC implementation of `COleObjectFactory`."},{"content":"The reason for creating aggregates in <ph id=\"ph1\">`CCmdTarget::OnCreateAggregates`</ph> as well as the usage of <ph id=\"ph2\">`CCmdTarget::GetControllingUnknown`</ph> will become apparent when creating aggregatable objects is discussed.","pos":[25004,25204],"source":" The reason for creating aggregates in `CCmdTarget::OnCreateAggregates` as well as the usage of `CCmdTarget::GetControllingUnknown` will become apparent when creating aggregatable objects is discussed."},{"content":"This technique will give your object all of the interfaces that the aggregate object supports plus its native interfaces.","pos":[25211,25332]},{"content":"If you only want a subset of the interfaces that the aggregate supports, you can override <ph id=\"ph1\">`CCmdTarget::GetInterfaceHook`</ph>.","pos":[25333,25454],"source":" If you only want a subset of the interfaces that the aggregate supports, you can override `CCmdTarget::GetInterfaceHook`."},{"content":"This allows you very low-level hookability, similar to <bpt id=\"p1\">[</bpt>QueryInterface<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept>.","pos":[25455,25587],"source":" This allows you very low-level hookability, similar to [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521)."},{"content":"Usually, you want all the interfaces that the aggregate supports.","pos":[25588,25653]},{"content":"Making an Object Implementation Aggregatable","pos":[25663,25707]},{"content":"For an object to be aggregatable, the implementation of <bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>, and <bpt id=\"p3\">[</bpt>QueryInterface<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> must delegate to a \"controlling unknown.\"","pos":[25711,26030],"source":"For an object to be aggregatable, the implementation of [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) must delegate to a \"controlling unknown.\""},{"content":"In other words, for it to be part of the object, it must delegate <bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>, and <bpt id=\"p3\">[</bpt>QueryInterface<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> to a different object, also derived from <bpt id=\"p4\">[</bpt>IUnknown<ept id=\"p4\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>.","pos":[26031,26431],"source":" In other words, for it to be part of the object, it must delegate [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) to a different object, also derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509)."},{"content":"This \"controlling unknown\" is provided to the object when it is created, that is, it is provided to the implementation of <ph id=\"ph1\">`COleObjectFactory`</ph>.","pos":[26432,26574],"source":" This \"controlling unknown\" is provided to the object when it is created, that is, it is provided to the implementation of `COleObjectFactory`."},{"content":"Implementing this carries a small amount of overhead, and in some cases is not desirable, so MFC makes this optional.","pos":[26575,26692]},{"content":"To enable an object to be aggregatable, you call <ph id=\"ph1\">`CCmdTarget::EnableAggregation`</ph> from the object's constructor.","pos":[26693,26804],"source":" To enable an object to be aggregatable, you call `CCmdTarget::EnableAggregation` from the object's constructor."},{"content":"If the object also uses aggregates, you must also be sure to pass the correct \"controlling unknown\" to the aggregate objects.","pos":[26811,26936]},{"content":"Usually this <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> pointer is passed to the object when the aggregate is created.","pos":[26937,27083],"source":" Usually this [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) pointer is passed to the object when the aggregate is created."},{"content":"For example, the pUnkOuter parameter is the \"controlling unknown\" for objects created with <ph id=\"ph1\">`CoCreateInstance`</ph>.","pos":[27084,27194],"source":" For example, the pUnkOuter parameter is the \"controlling unknown\" for objects created with `CoCreateInstance`."},{"content":"The correct \"controlling unknown\" pointer can be retrieved by calling <ph id=\"ph1\">`CCmdTarget::GetControllingUnknown`</ph>.","pos":[27195,27301],"source":" The correct \"controlling unknown\" pointer can be retrieved by calling `CCmdTarget::GetControllingUnknown`."},{"content":"The value returned from that function, however, is not valid during the constructor.","pos":[27302,27386]},{"content":"For this reason, it is suggested that you create your aggregates only in an override of <ph id=\"ph1\">`CCmdTarget::OnCreateAggregates`</ph>, where the return value from <ph id=\"ph2\">`GetControllingUnknown`</ph> is reliable, even if created from the <ph id=\"ph3\">`COleObjectFactory`</ph> implementation.","pos":[27387,27634],"source":" For this reason, it is suggested that you create your aggregates only in an override of `CCmdTarget::OnCreateAggregates`, where the return value from `GetControllingUnknown` is reliable, even if created from the `COleObjectFactory` implementation."},{"content":"It is also important that the object manipulate the correct reference count when adding or releasing artificial reference counts.","pos":[27641,27770]},{"content":"To ensure this is the case, always call <ph id=\"ph1\">`ExternalAddRef`</ph> and <ph id=\"ph2\">`ExternalRelease`</ph> instead of <ph id=\"ph3\">`InternalRelease`</ph> and <ph id=\"ph4\">`InternalAddRef`</ph>.","pos":[27771,27900],"source":" To ensure this is the case, always call `ExternalAddRef` and `ExternalRelease` instead of `InternalRelease` and `InternalAddRef`."},{"content":"It is rare to call <ph id=\"ph1\">`InternalRelease`</ph> or <ph id=\"ph2\">`InternalAddRef`</ph> on a class that supports aggregation.","pos":[27901,27995],"source":" It is rare to call `InternalRelease` or `InternalAddRef` on a class that supports aggregation."},{"content":"Reference Material","pos":[28005,28023]},{"content":"Advanced usage of OLE, such as defining your own interfaces or overriding the framework's implementation of the OLE interfaces requires the use of the underlying interface map mechanism.","pos":[28027,28213]},{"content":"This section discusses each macro and the APIs which is used to implement these advanced features.","pos":[28220,28318]},{"content":"CCmdTarget::EnableAggregation — Function Description","pos":[28328,28380]},{"content":"Remarks","pos":[28435,28442]},{"content":"Call this function in the constructor of the derived class if you wish to support OLE aggregation for objects of this type.","pos":[28446,28569]},{"content":"This prepares a special IUnknown implementation that is required for aggregatable objects.","pos":[28570,28660]},{"content":"CCmdTarget::ExternalQueryInterface — Function Description","pos":[28670,28727]},{"content":"Remarks","pos":[28827,28834]},{"content":"Parameters","pos":[28845,28855]},{"content":"A far pointer to an IID (the first argument to QueryInterface)","pos":[28870,28932]},{"content":"A pointer to an IUnknown* (second argument to QueryInterface)","pos":[28951,29012]},{"content":"Remarks","pos":[29021,29028]},{"content":"Call this function in your implementation of IUnknown for each interface your class implements.","pos":[29032,29127]},{"content":"This function provides the standard data-driven implementation of QueryInterface based on your object's interface map.","pos":[29128,29246]},{"content":"It is necessary to cast the return value to an HRESULT.","pos":[29247,29302]},{"content":"If the object is aggregated, this function will call the \"controlling IUnknown\" instead of using the local interface map.","pos":[29303,29424]},{"content":"CCmdTarget::ExternalAddRef — Function Description","pos":[29434,29483]},{"content":"Remarks","pos":[29536,29543]},{"content":"Call this function in your implementation of IUnknown::AddRef for each interface your class implements.","pos":[29547,29650]},{"content":"The return value is the new reference count on the CCmdTarget object.","pos":[29651,29720]},{"content":"If the object is aggregated, this function will call the \"controlling IUnknown\" instead of manipulating the local reference count.","pos":[29721,29851]},{"content":"CCmdTarget::ExternalRelease — Function Description","pos":[29861,29911]},{"content":"Remarks","pos":[29965,29972]},{"content":"Call this function in your implementation of IUnknown::Release for each interface your class implements.","pos":[29976,30080]},{"content":"The return value indicates the new reference count on the object.","pos":[30081,30146]},{"content":"If the object is aggregated, this function will call the \"controlling IUnknown\" instead of manipulating the local reference count.","pos":[30147,30277]},{"content":"DECLARE_INTERFACE_MAP — Macro Description","pos":[30287,30328]},{"content":"Remarks","pos":[30380,30387]},{"content":"Use this macro in any class derived from <ph id=\"ph1\">`CCmdTarget`</ph> that will have an interface map.","pos":[30391,30477],"source":"Use this macro in any class derived from `CCmdTarget` that will have an interface map."},{"content":"Used in much the same way as <ph id=\"ph1\">`DECLARE_MESSAGE_MAP`</ph>.","pos":[30478,30529],"source":" Used in much the same way as `DECLARE_MESSAGE_MAP`."},{"content":"This macro invocation should be placed in the class definition, usually in a header (.H) file.","pos":[30530,30624]},{"content":"A class with <ph id=\"ph1\">`DECLARE_INTERFACE_MAP`</ph> must define the interface map in the implementation file (.CPP) with the <ph id=\"ph2\">`BEGIN_INTERFACE_MAP`</ph> and <ph id=\"ph3\">`END_INTERFACE_MAP`</ph> macros.","pos":[30625,30788],"source":" A class with `DECLARE_INTERFACE_MAP` must define the interface map in the implementation file (.CPP) with the `BEGIN_INTERFACE_MAP` and `END_INTERFACE_MAP` macros."},{"content":"BEGIN_INTERFACE_PART and END_INTERFACE_PART — Macro Descriptions","pos":[30798,30862]},{"content":"Remarks","pos":[30978,30985]},{"content":"Parameters","pos":[30996,31006]},{"content":"l","pos":[31010,31011]},{"content":"The name of the class that implements the interface","pos":[31026,31077]},{"content":"The name of the interface that this class implements","pos":[31095,31147]},{"content":"Remarks","pos":[31156,31163]},{"content":"For each interface that your class will implement, you need to have a <ph id=\"ph1\">`BEGIN_INTERFACE_PART`</ph> and <ph id=\"ph2\">`END_INTERFACE_PART`</ph> pair.","pos":[31167,31290],"source":"For each interface that your class will implement, you need to have a `BEGIN_INTERFACE_PART` and `END_INTERFACE_PART` pair."},{"content":"These macros define a local class derived from the OLE interface that you define as well as an embedded member variable of that class.","pos":[31291,31425]},{"content":"The <bpt id=\"p1\">[</bpt>AddRef<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id=\"p2\">[</bpt>Release<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>, and <bpt id=\"p3\">[</bpt>QueryInterface<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> members are declared automatically.","pos":[31426,31687],"source":" The [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) members are declared automatically."},{"content":"You must include the declarations for the other member functions that are part of the interface being implemented (those declarations are placed between the <ph id=\"ph1\">`BEGIN_INTERFACE_PART`</ph> and <ph id=\"ph2\">`END_INTERFACE_PART`</ph> macros).","pos":[31688,31901],"source":" You must include the declarations for the other member functions that are part of the interface being implemented (those declarations are placed between the `BEGIN_INTERFACE_PART` and `END_INTERFACE_PART` macros)."},{"pos":[31908,32053],"content":"The <ph id=\"ph1\">`iface`</ph> argument is the OLE interface that you wish to implement, such as <ph id=\"ph2\">`IAdviseSink`</ph>, or <ph id=\"ph3\">`IPersistStorage`</ph> (or your own custom interface).","source":"The `iface` argument is the OLE interface that you wish to implement, such as `IAdviseSink`, or `IPersistStorage` (or your own custom interface)."},{"content":"The <ph id=\"ph1\">`localClass`</ph> argument is the name of the local class that will be defined.","pos":[32060,32138],"source":"The `localClass` argument is the name of the local class that will be defined."},{"content":"An 'X' will automatically be prepended to the name.","pos":[32139,32190]},{"content":"This naming convention is used to avoid collisions with global classes of the same name.","pos":[32191,32279]},{"content":"In addition, the name of the embedded member, the same as the <ph id=\"ph1\">`localClass`</ph> name except it is prefixed by 'm_x'.","pos":[32280,32391],"source":" In addition, the name of the embedded member, the same as the `localClass` name except it is prefixed by 'm_x'."},{"content":"For example:","pos":[32398,32410]},{"content":"would define a local class called XMyAdviseSink derived from IAdviseSink, and a member of the class in which it is declared called m_xMyAdviseSink.Note:","pos":[32764,32916]},{"pos":[32924,33099],"content":"[!NOTE]\n The lines beginning with `STDMETHOD`_ are essentially copied from OLE2.H and modified slightly. Copying them from OLE2.H can reduce errors that are hard to resolve.","leadings":["","> "],"nodes":[{"content":" The lines beginning with `STDMETHOD`_ are essentially copied from OLE2.H and modified slightly. Copying them from OLE2.H can reduce errors that are hard to resolve.","pos":[8,173],"nodes":[{"content":"The lines beginning with <ph id=\"ph1\">`STDMETHOD`</ph>_ are essentially copied from OLE2.H and modified slightly.","pos":[1,96],"source":" The lines beginning with `STDMETHOD`_ are essentially copied from OLE2.H and modified slightly."},{"content":"Copying them from OLE2.H can reduce errors that are hard to resolve.","pos":[97,165]}]}]},{"content":"BEGIN_INTERFACE_MAP and END_INTERFACE_MAP — Macro Descriptions","pos":[33109,33171]},{"content":"Remarks","pos":[33269,33276]},{"content":"Parameters","pos":[33287,33297]},{"content":"The class in which the interface map is to be defined","pos":[33315,33368]},{"content":"The class from which <ph id=\"ph1\">`theClass`</ph> derives from.","pos":[33390,33435],"source":" The class from which `theClass` derives from."},{"content":"Remarks","pos":[33444,33451]},{"content":"The <ph id=\"ph1\">`BEGIN_INTERFACE_MAP`</ph> and <ph id=\"ph2\">`END_INTERFACE_MAP`</ph> macros are used in the implementation file to actually define the interface map.","pos":[33455,33585],"source":"The `BEGIN_INTERFACE_MAP` and `END_INTERFACE_MAP` macros are used in the implementation file to actually define the interface map."},{"content":"For each interface that is implemented there is one or more <ph id=\"ph1\">`INTERFACE_PART`</ph> macro invocations.","pos":[33586,33681],"source":" For each interface that is implemented there is one or more `INTERFACE_PART` macro invocations."},{"content":"For each aggregate that the class uses, there is one <ph id=\"ph1\">`INTERFACE_AGGREGATE`</ph> macro invocation.","pos":[33682,33774],"source":" For each aggregate that the class uses, there is one `INTERFACE_AGGREGATE` macro invocation."},{"content":"INTERFACE_PART — Macro Description","pos":[33784,33818]},{"content":"Remarks","pos":[33905,33912]},{"content":"Parameters","pos":[33923,33933]},{"content":"The name of the class that contains the interface map.","pos":[33951,34005]},{"content":"The <ph id=\"ph1\">`IID`</ph> that is to be mapped to the embedded class.","pos":[34021,34074],"source":" The `IID` that is to be mapped to the embedded class."},{"content":"The name of the local class (less the 'X').","pos":[34097,34140]},{"content":"Remarks","pos":[34149,34156]},{"content":"This macro is used between the <ph id=\"ph1\">`BEGIN_INTERFACE_MAP`</ph> macro and the <ph id=\"ph2\">`END_INTERFACE_MAP`</ph> macro for each interface your object will support.","pos":[34160,34297],"source":"This macro is used between the `BEGIN_INTERFACE_MAP` macro and the `END_INTERFACE_MAP` macro for each interface your object will support."},{"content":"It allows you to map an IID to a member of the class indicated by <ph id=\"ph1\">`theClass`</ph> and <ph id=\"ph2\">`localClass`</ph>.","pos":[34298,34392],"source":" It allows you to map an IID to a member of the class indicated by `theClass` and `localClass`."},{"content":"The 'm_x' will be added to the <ph id=\"ph1\">`localClass`</ph> automatically.","pos":[34393,34451],"source":" The 'm_x' will be added to the `localClass` automatically."},{"content":"Note that more than one <ph id=\"ph1\">`IID`</ph> may be associated with a single member.","pos":[34452,34521],"source":" Note that more than one `IID` may be associated with a single member."},{"content":"This is very useful when you are implementing only a \"most derived\" interface and wish to provide all intermediate interfaces as well.","pos":[34522,34656]},{"content":"A good example of this is the <ph id=\"ph1\">`IOleInPlaceFrameWindow`</ph> interface.","pos":[34657,34722],"source":" A good example of this is the `IOleInPlaceFrameWindow` interface."},{"content":"Its hierarchy looks like this:","pos":[34723,34753]},{"content":"If an object implements <ph id=\"ph1\">`IOleInPlaceFrameWindow`</ph>, a client may <ph id=\"ph2\">`QueryInterface`</ph> on any of these interfaces: <ph id=\"ph3\">`IOleUIWindow`</ph>, <ph id=\"ph4\">`IOleWindow`</ph>, or <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>, besides the \"most derived\" interface <ph id=\"ph5\">`IOleInPlaceFrameWindow`</ph> (the one you are actually implementing).","pos":[34848,35163],"source":"If an object implements `IOleInPlaceFrameWindow`, a client may `QueryInterface` on any of these interfaces: `IOleUIWindow`, `IOleWindow`, or [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509), besides the \"most derived\" interface `IOleInPlaceFrameWindow` (the one you are actually implementing)."},{"content":"To handle this you can use more than one <ph id=\"ph1\">`INTERFACE_PART`</ph> macro to map each and every base interface to the <ph id=\"ph2\">`IOleInPlaceFrameWindow`</ph> interface:","pos":[35164,35307],"source":" To handle this you can use more than one `INTERFACE_PART` macro to map each and every base interface to the `IOleInPlaceFrameWindow` interface:"},{"content":"in the class definition file:","pos":[35314,35343]},{"content":"in the class implementation file:","pos":[35428,35461]},{"content":"The framework takes care of IUnknown because it is always required.","pos":[35766,35833]},{"content":"INTERFACE_PART — Macro Description","pos":[35843,35877]},{"content":"Remarks","pos":[35956,35963]},{"content":"Parameters","pos":[35974,35984]},{"content":"The name of the class that contains the interface map,","pos":[36002,36056]},{"content":"The name of the member variable that is to be aggregated.","pos":[36076,36133]},{"content":"Remarks","pos":[36142,36149]},{"content":"This macro is used to tell the framework that the class is using an aggregate object.","pos":[36153,36238]},{"content":"It must appear between the <ph id=\"ph1\">`BEGIN_INTERFACE_PART`</ph> and <ph id=\"ph2\">`END_INTERFACE_PART`</ph> macros.","pos":[36239,36321],"source":" It must appear between the `BEGIN_INTERFACE_PART` and `END_INTERFACE_PART` macros."},{"content":"An aggregate object is a separate object, derived from <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>.","pos":[36322,36448],"source":" An aggregate object is a separate object, derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509)."},{"content":"By using an aggregate and the <ph id=\"ph1\">`INTERFACE_AGGREGATE`</ph> macro, you can make all the interfaces that the aggregate supports appear to be directly supported by the object.","pos":[36449,36614],"source":" By using an aggregate and the `INTERFACE_AGGREGATE` macro, you can make all the interfaces that the aggregate supports appear to be directly supported by the object."},{"content":"The <ph id=\"ph1\">`theAggr`</ph> argument is simply the name of a member variable of your class which is derived from <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> (either directly or indirectly).","pos":[36615,36817],"source":" The `theAggr` argument is simply the name of a member variable of your class which is derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) (either directly or indirectly)."},{"content":"All <ph id=\"ph1\">`INTERFACE_AGGREGATE`</ph> macros must follow the <ph id=\"ph2\">`INTERFACE_PART`</ph> macros when placed in an interface map.","pos":[36818,36923],"source":" All `INTERFACE_AGGREGATE` macros must follow the `INTERFACE_PART` macros when placed in an interface map."},{"content":"See Also","pos":[36932,36940]},{"content":"Technical Notes by Number","pos":[36945,36970]},{"content":"Technical Notes by Category","pos":[37014,37041]}],"content":"---\ntitle: \"TN038: MFC-OLE IUnknown Implementation | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mfc.ole\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"aggregation macros [C++]\"\n  - \"COM interfaces, base interface\"\n  - \"IUnknown interface\"\n  - \"END_INTERFACE_MAP macro\"\n  - \"TN038\"\n  - \"BEGIN_INTERFACE_PART macro\"\n  - \"DECLARE_INTERFACE_MAP macro\"\n  - \"BEGIN_INTERFACE_MAP macro\"\n  - \"OLE [C++], implementing IUnknown interface\"\n  - \"METHOD_PROLOGUE macro\"\n  - \"STDMETHOD macro\"\n  - \"END_INTERFACE_PART macro\"\n  - \"INTERFACE_PART macro\"\nms.assetid: 19d946ba-beaf-4881-85c6-0b598d7f6f11\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN038: MFC/OLE IUnknown Implementation\n> [!NOTE]\n>  The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.  \n  \n At the heart of OLE 2 is the \"OLE Component Object Model\", or COM. COM defines a standard for how cooperating objects communicate to one another. This includes the details of what an \"object\" looks like, including how methods are dispatched on an object. COM also defines a base class, from which all COM compatible classes are derived. This base class is [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509). Although the [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) interface is referred to as a C++ class, COM is not specific to any one language — it can be implemented in C, PASCAL, or any other language that can support the binary layout of a COM object.  \n  \n OLE refers to all classes derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) as \"interfaces.\" This is an important distinction, since an \"interface\" such as [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) carries with it no implementation. It simply defines the protocol by which objects communicate, not the specifics of what those implementations do. This is reasonable for a system that allows for maximum flexibility. It is MFC's job to implement a default behavior for MFC/C++ programs.  \n  \n To understand MFC's implementation of [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) you must first understand what this interface is. A simplified version of [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) is defined below:  \n  \n```  \nclass IUnknown  \n{  \npublic:  \n    virtual HRESULT QueryInterface(REFIID iid, void** ppvObj) = 0;  \n    virtual ULONG AddRef() = 0;  \n    virtual ULONG Release() = 0;  \n};  \n```  \n  \n> [!NOTE]\n>  Certain necessary calling convention details, such as `__stdcall` are left out for this illustration.  \n  \n The [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) member functions control memory management of the object. COM uses a reference counting scheme to keep track of objects. An object is never referenced directly as you would in C++. Instead, COM objects are always referenced through a pointer. To release the object when the owner is done using it, the object's [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) member is called (as opposed to using operator delete, as would be done for a traditional C++ object). The reference counting mechanism allows for multiple references to a single object to be managed. An implementation of [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) maintains a reference count on the object — the object is not deleted until its reference count reaches zero.  \n  \n [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) are fairly straightforward from an implementation standpoint. Here is a trivial implementation:  \n  \n```  \nULONG CMyObj::AddRef()   \n{   \n    return ++m_dwRef;   \n}  \n \nULONG CMyObj::Release()   \n{   \n    if (--m_dwRef == 0)   \n {  \n    delete this;   \n    return 0;  \n }  \n    return m_dwRef;  \n}  \n```  \n  \n The [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) member function is a little more interesting. It is not very interesting to have an object whose only member functions are [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) — it would be nice to tell the object to do more things than [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) provides. This is where [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) is useful. It allows you to obtain a different \"interface\" on the same object. These interfaces are usually derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) and add additional functionality by adding new member functions. COM interfaces never have member variables declared in the interface, and all member functions are declared as pure-virtual. For example,  \n  \n```  \nclass IPrintInterface : public IUnknown  \n{  \npublic:  \n    virtual void PrintObject() = 0;  \n};  \n```  \n  \n To get an IPrintInterface if you only have an [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509), call [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) using the `IID` of the **IPrintInterface**. An `IID` is a 128-bit number that uniquely identifies the interface. There is an `IID` for each interface that either you or OLE define. If `pUnk` is a pointer to an [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) object, the code to retrieve an IPrintInterface from it might be:  \n  \n```  \nIPrintInterface* pPrint = NULL;  \nif (pUnk->QueryInterface(IID_IPrintInterface,   \n (void**)&pPrint) == NOERROR)  \n{  \n    pPrint->PrintObject();\npPrint->Release();\n*// release pointer obtained via QueryInterface  \n}  \n```  \n  \n That seems fairly easy, but how would you implement an object supporting both the IPrintInterface and [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) interface In this case it is simple since the IPrintInterface is derived directly from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) — by implementing IPrintInterface, [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) is automatically supported. For example:  \n  \n```  \nclass CPrintObj : public CPrintInterface  \n{  \n    virtual HRESULT QueryInterface(REFIID iid, void** ppvObj);\n\n    virtual ULONG AddRef();\nvirtual ULONG Release();\nvirtual void PrintObject();\n\n};  \n```  \n  \n The implementations of [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) would be exactly the same as those implemented above. **CPrintObj::QueryInterface** would look something like this:  \n  \n```  \nHRESULT CPrintObj::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)  \n{  \n    if (iid == IID_IUnknown || iid == IID_IPrintInterface)  \n {  \n *ppvObj = this;  \n    AddRef();\nreturn NOERROR;  \n }  \n    return E_NOINTERFACE;  \n}  \n```  \n  \n As you can see, if the interface identifier (IID) is recognized, a pointer is returned to your object; otherwise an error occurs. Also note that a successful [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) results in an implied [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379). Of course, you'd also have to implement CEditObj::Print. That is simple because the IPrintInterface was directly derived from the [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) interface. However, if you wanted to support two different interfaces, both derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509), consider the following:  \n  \n```  \nclass IEditInterface : public IUnkown  \n{  \npublic:  \n    virtual void EditObject() = 0;  \n};  \n```  \n  \n Although there are a number of different ways to implement a class supporting both IEditInterface and IPrintInterface, including using C++ multiple inheritance, this note will concentrate on the use of nested classes to implement this functionality.  \n  \n```  \nclass CEditPrintObj  \n{  \npublic:  \n    CEditPrintObj();\n\n \n    HRESULT QueryInterface(REFIID iid,\n    void**);\n\n    ULONG AddRef();\nULONG Release();\nDWORD m_dwRef;  \n \n    class CPrintObj : public IPrintInterface  \n {  \n    public: \n    CEditPrintObj* m_pParent;  \n    virtual HRESULT QueryInterface(REFIID iid,\n    void** ppvObj);\n\n    virtual ULONG AddRef();\nvirtual ULONG Release();\n\n } m_printObj;  \n \n    class CEditObj : public IEditInterface  \n {  \n    public: \n    CEditPrintObj* m_pParent;  \n    virtual ULONG QueryInterface(REFIID iid,\n    void** ppvObj);\n\n    virtual ULONG AddRef();\nvirtual ULONG Release();\n\n } m_editObj;  \n};  \n```  \n  \n The entire implementation is included below:  \n  \n```  \nCEditPrintObj::CEditPrintObj()  \n{  \n    m_editObj.m_pParent = this;  \n    m_printObj.m_pParent = this;  \n}  \n \nULONG CEditPrintObj::AddRef()   \n{   \n    return ++m_dwRef;  \n}  \n \nCEditPrintObj::Release()  \n{  \n    if (--m_dwRef == 0)  \n {  \n    delete this;  \n    return 0;  \n }  \n    return m_dwRef;  \n}  \n \nHRESULT CEditPrintObj::QueryInterface(REFIID iid,\n    void** ppvObj)  \n{  \n    if (iid == IID_IUnknown || iid == IID_IPrintInterface)  \n {  \n *ppvObj = &m_printObj;  \n    AddRef();\nreturn NOERROR;  \n }  \n    else if (iid == IID_IEditInterface)  \n {  \n *ppvObj = &m_editObj;  \n    AddRef();\nreturn NOERROR;  \n }  \n    return E_NOINTERFACE;  \n}  \n \nULONG CEditPrintObj::CEditObj::AddRef()   \n{   \n    return m_pParent->AddRef();\n\n}  \n \nULONG CEditPrintObj::CEditObj::Release()   \n{   \n    return m_pParent->Release();\n\n}  \n \nHRESULT CEditPrintObj::CEditObj::QueryInterface(\n    REFIID iid,\n    void** ppvObj)   \n{   \n    return m_pParent->QueryInterface(iid,\n    ppvObj);\n\n}  \n \nULONG CEditPrintObj::CPrintObj::AddRef()   \n{   \n    return m_pParent->AddRef();\n\n}  \n \nULONG CEditPrintObj::CPrintObj::Release()   \n{   \n    return m_pParent->Release();\n\n}  \n \nHRESULT CEditPrintObj::CPrintObj::QueryInterface(\n    REFIID iid,\n    void** ppvObj)   \n{   \n    return m_pParent->QueryInterface(iid,\n    ppvObj);\n\n}  \n```  \n  \n Notice that most of the [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) implementation is placed into the CEditPrintObj class rather than duplicating the code in CEditPrintObj::CEditObj and CEditPrintObj::CPrintObj. This reduces the amount of code and avoids bugs. The key point here is that from the IUnknown interface it is possible to call [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) to retrieve any interface the object might support, and from each of those interfaces it is possible to do the same. This means that all [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) functions available from each interface must behave exactly the same way. In order for these embedded objects to call the implementation in the \"outer object\", a back-pointer is used (m_pParent). The m_pParent pointer is initialized during the CEditPrintObj constructor. Then you would implement CEditPrintObj::CPrintObj::PrintObject and CEditPrintObj::CEditObj::EditObject as well. Quite a bit of code was added to add one feature — the ability to edit the object. Fortunately, it is quite uncommon for interfaces to have only a single member function (although it does happen) and in this case, EditObject and PrintObject would usually be combined into a single interface.  \n  \n That's a lot of explanation and a lot of code for such a simple scenario. The MFC/OLE classes provide a simpler alternative. The MFC implementation uses a technique similar to the way Windows messages are wrapped with Message Maps. This facility is called *Interface Maps* and is discussed in the next section.  \n  \n## MFC Interface Maps  \n MFC/OLE includes an implementation of \"Interface Maps\" similar to MFC's \"Message Maps\" and \"Dispatch Maps\" in concept and execution. The core features of MFC's Interface Maps are as follows:  \n  \n-   A standard implementation of [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509), built into the `CCmdTarget` class.  \n  \n-   Maintenance of the reference count, modified by [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317)  \n  \n-   Data driven implementation of [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521)  \n  \n In addition, interface maps support the following advanced features:  \n  \n-   Support for creating aggregatable COM objects  \n  \n-   Support for using aggregate objects in the implementation of a COM object  \n  \n-   The implementation is hookable and extensible  \n  \n For more information on aggregation, see the [Aggregation](http://msdn.microsoft.com/library/windows/desktop/ms686558\\(v=vs.85\\).aspx) topic.  \n  \n MFC's interface map support is rooted in the `CCmdTarget` class. `CCmdTarget` \"*has-a*\" reference count as well as all the member functions associated with the [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) implementation (the reference count for example is in `CCmdTarget`). To create a class that supports OLE COM, you derive a class from `CCmdTarget` and use various macros as well as member functions of `CCmdTarget` to implement the desired interfaces. MFC's implementation uses nested classes to define each interface implementation much like the example above. This is made easier with a standard implementation of IUnknown as well as a number of macros that eliminate some of the repetitive code.  \n  \n## Interface Map Basics  \n  \n#### To implement a class using MFC's interface maps  \n  \n1.  Derive a class either directly or indirectly from `CCmdTarget`.  \n  \n2.  Use the `DECLARE_INTERFACE_MAP` function in the derived class definition.  \n  \n3.  For each interface you wish to support, use the `BEGIN_INTERFACE_PART` and `END_INTERFACE_PART` macros in the class definition.  \n  \n4.  In the implementation file, use the `BEGIN_INTERFACE_MAP` and `END_INTERFACE_MAP` macros to define the class's interface map.  \n  \n5.  For each IID supported, use the `INTERFACE_PART` macro between the `BEGIN_INTERFACE_MAP` and `END_INTERFACE_MAP` macros to map that IID to a specific \"part\" of your class.  \n  \n6.  Implement each of the nested classes that represent the interfaces you support.  \n  \n7.  Use the `METHOD_PROLOGUE` macro to access the parent, `CCmdTarget`-derived object.  \n  \n8. [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) can delegate to the `CCmdTarget` implementation of these functions (`ExternalAddRef`, `ExternalRelease`, and `ExternalQueryInterface`).  \n  \n The CPrintEditObj example above could be implemented as follows:  \n  \n```  \nclass CPrintEditObj : public CCmdTarget  \n{  \npublic: *// member data and member functions for CPrintEditObj go here  \n \n// Interface Maps  \nprotected:  \n    DECLARE_INTERFACE_MAP() \n \n    BEGIN_INTERFACE_PART(EditObj,\n    IEditInterface)  \n    STDMETHOD_(void,\n    EditObject)();\nEND_INTERFACE_PART(EditObj) \n \n    BEGIN_INTERFACE_PART(PrintObj,\n    IPrintInterface)  \n    STDMETHOD_(void,\n    PrintObject)();\nEND_INTERFACE_PART(PrintObj) \n};  \n```  \n  \n The above declaration creates a class derived from `CCmdTarget`. The `DECLARE_INTERFACE_MAP` macro tells the framework that this class will have a custom interface map. In addition, the `BEGIN_INTERFACE_PART` and `END_INTERFACE_PART` macros define nested classes, in this case with names CEditObj and CPrintObj (the X is used only to differentiate the nested classes from global classes which start with \"C\" and interface classes which start with \"I\"). Two nested members of these classes are created: m_CEditObj, and m_CPrintObj, respectively. The macros automatically declare the [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) functions; therefore you only declare the functions specific to this interface: EditObject and PrintObject (the OLE macro `STDMETHOD` is used so that `_stdcall` and virtual keywords are provided as appropriate for the target platform).  \n  \n To implement the interface map for this class:  \n  \n```  \nBEGIN_INTERFACE_MAP(CPrintEditObj,\n    CCmdTarget)  \n    INTERFACE_PART(CPrintEditObj,\n    IID_IPrintInterface,\n    PrintObj)  \n    INTERFACE_PART(CPrintEditObj,\n    IID_IEditInterface,\n    EditObj)  \nEND_INTERFACE_MAP()  \n```  \n  \n This connects the IID_IPrintInterface IID with m_CPrintObj and IID_IEditInterface with m_CEditObj respectively. The `CCmdTarget` implementation of [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) (`CCmdTarget::ExternalQueryInterface`) uses this map to return pointers to m_CPrintObj and m_CEditObj when requested. It is not necessary to include an entry for `IID_IUnknown`; the framework will use the first interface in the map (in this case, m_CPrintObj) when `IID_IUnknown` is requested.  \n  \n Even though the `BEGIN_INTERFACE_PART` macro automatically declared the [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317) and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) functions for you, you still need to implement them:  \n  \n```  \nULONG FAR EXPORT CEditPrintObj::XEditObj::AddRef()  \n{  \n    METHOD_PROLOGUE(CEditPrintObj,\n    EditObj)  \n    return pThis->ExternalAddRef();\n\n}  \n \nULONG FAR EXPORT CEditPrintObj::XEditObj::Release()  \n{  \n    METHOD_PROLOGUE(CEditPrintObj,\n    EditObj)  \n    return pThis->ExternalRelease();\n\n}  \n \nHRESULT FAR EXPORT CEditPrintObj::XEditObj::QueryInterface(\n    REFIID iid,\n    void FAR* FAR* ppvObj)  \n{  \n    METHOD_PROLOGUE(CEditPrintObj,\n    EditObj)  \n    return (HRESULT)pThis->ExternalQueryInterface(&iid,\n    ppvObj);\n\n}  \n \nvoid FAR EXPORT CEditPrintObj::XEditObj::EditObject()  \n{  \n    METHOD_PROLOGUE(CEditPrintObj,\n    EditObj) *// code to \"Edit\" the object,\n    whatever that means...  \n}  \n```  \n  \n The implementation for CEditPrintObj::CPrintObj, would be similar to the above definitions for CEditPrintObj::CEditObj. Although it would be possible to create a macro that could be used to automatically generate these functions (but earlier in MFC/OLE development this was the case), it becomes difficult to set break points when a macro generates more than one line of code. For this reason, this code is expanded manually.  \n  \n By using the framework implementation of message maps, there are a number of things that were not necessary to do:  \n  \n-   Implement QueryInterface  \n  \n-   Implement AddRef and Release  \n  \n-   Declare either of these built-in methods on both of your interfaces  \n  \n In addition, the framework uses message maps internally. This allows you to derive from a framework class, say `COleServerDoc`, that already supports certain interfaces and provides either replacements or additions to the interfaces provided by the framework. You can do this because the framework fully supports inheriting an interface map from a base class. That is the reason why `BEGIN_INTERFACE_MAP` takes as its second parameter the name of the base class.  \n  \n> [!NOTE]\n>  It is generally not possible to reuse the implementation of MFC's built-in implementations of the OLE interfaces just by inheriting the embedded specialization of that interface from the MFC version. This is not possible because the use of the `METHOD_PROLOGUE` macro to get access to the containing `CCmdTarget`-derived object implies a *fixed offset* of the embedded object from the `CCmdTarget`-derived object. This means, for example, you cannot derive an embedded XMyAdviseSink from MFC's implementation in `COleClientItem::XAdviseSink`, because XAdviseSink relies on being at a specific offset from the top of the `COleClientItem` object.  \n  \n> [!NOTE]\n>  You can, however, delegate to the MFC implementation for all of the functions that you want MFC's default behavior. This is done in the MFC implementation of `IOleInPlaceFrame` (XOleInPlaceFrame) in the `COleFrameHook` class (it delegates to m_xOleInPlaceUIWindow for many functions). This design was chosen to reduce the runtime size of objects which implement many interfaces; it eliminates the need for a back-pointer (such as the way m_pParent was used in the previous section).  \n  \n### Aggregation and Interface Maps  \n In addition to supporting stand-alone COM objects, MFC also supports aggregation. Aggregation itself is too complex a topic to discuss here; refer to the [Aggregation](http://msdn.microsoft.com/library/windows/desktop/ms686558\\(v=vs.85\\).aspx) topic for more information on aggregation. This note will simply describe the support for aggregation built into the framework and interface maps.  \n  \n There are two ways to use aggregation: (1) using a COM object that supports aggregation, and (2) implementing an object that can be aggregated by another. These capabilities can be referred to as \"using an aggregate object\" and \"making an object aggregatable\". MFC supports both.  \n  \n### Using an Aggregate Object  \n To use an aggregate object, there needs to be some way to tie the aggregate into the QueryInterface mechanism. In other words, the aggregate object must behave as though it is a native part of your object. So how does this tie into MFC's interface map mechanism In addition to the `INTERFACE_PART` macro, where a nested object is mapped to an IID, you can also declare an aggregate object as part of your `CCmdTarget` derived class. To do so, the `INTERFACE_AGGREGATE` macro is used. This allows you to specify a member variable (which must be a pointer to an [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) or derived class), which is to be integrated into the interface map mechanism. If the pointer is not NULL when `CCmdTarget::ExternalQueryInterface` is called, the framework will automatically call the aggregate object's [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) member function, if the `IID` requested is not one of the native `IID`s supported by the `CCmdTarget` object itself.  \n  \n##### To use the INTERFACE_AGGREGATE macro  \n  \n1.  Declare a member variable (an `IUnknown*`) which will contain a pointer to the aggregate object.  \n  \n2.  Include an `INTERFACE_AGGREGATE` macro in your interface map, which refers to the member variable by name.  \n  \n3.  At some point (usually during `CCmdTarget::OnCreateAggregates`), initialize the member variable to something other than NULL.  \n  \n For example:  \n  \n```  \nclass CAggrExample : public CCmdTarget  \n{  \npublic:  \n    CAggrExample();\n\n \nprotected:  \n    LPUNKNOWN m_lpAggrInner;  \n    virtual BOOL OnCreateAggregates();\n\n \n    DECLARE_INTERFACE_MAP() *// \"native\" interface part macros may be used here  \n};  \n \nCAggrExample::CAggrExample()  \n{  \n    m_lpAggrInner = NULL;  \n}  \n \nBOOL CAggrExample::OnCreateAggregates()  \n{ *// wire up aggregate with correct controlling unknown  \n    m_lpAggrInner = CoCreateInstance(CLSID_Example,  \n    GetControllingUnknown(),\n    CLSCTX_INPROC_SERVER,  \n    IID_IUnknown, (LPVOID*)&m_lpAggrInner);\n\n    if (m_lpAggrInner == NULL)  \n    return FALSE; *// optionally,\n    create other aggregate objects here  \n    return TRUE;  \n}  \n \nBEGIN_INTERFACE_MAP(CAggrExample,\n    CCmdTarget) *// native \"INTERFACE_PART\" entries go here  \n    INTERFACE_AGGREGATE(CAggrExample,\n    m_lpAggrInner)  \nEND_INTERFACE_MAP()  \n```  \n  \n The m_lpAggrInner variable is initialized in the constructor to NULL. The framework ignores a NULL member variable in the default implementation of [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521). `OnCreateAggregates` is a good place to actually create your aggregate objects. You'll have to call it explicitly if you are creating the object outside of the MFC implementation of `COleObjectFactory`. The reason for creating aggregates in `CCmdTarget::OnCreateAggregates` as well as the usage of `CCmdTarget::GetControllingUnknown` will become apparent when creating aggregatable objects is discussed.  \n  \n This technique will give your object all of the interfaces that the aggregate object supports plus its native interfaces. If you only want a subset of the interfaces that the aggregate supports, you can override `CCmdTarget::GetInterfaceHook`. This allows you very low-level hookability, similar to [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521). Usually, you want all the interfaces that the aggregate supports.  \n  \n### Making an Object Implementation Aggregatable  \n For an object to be aggregatable, the implementation of [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) must delegate to a \"controlling unknown.\" In other words, for it to be part of the object, it must delegate [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) to a different object, also derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509). This \"controlling unknown\" is provided to the object when it is created, that is, it is provided to the implementation of `COleObjectFactory`. Implementing this carries a small amount of overhead, and in some cases is not desirable, so MFC makes this optional. To enable an object to be aggregatable, you call `CCmdTarget::EnableAggregation` from the object's constructor.  \n  \n If the object also uses aggregates, you must also be sure to pass the correct \"controlling unknown\" to the aggregate objects. Usually this [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) pointer is passed to the object when the aggregate is created. For example, the pUnkOuter parameter is the \"controlling unknown\" for objects created with `CoCreateInstance`. The correct \"controlling unknown\" pointer can be retrieved by calling `CCmdTarget::GetControllingUnknown`. The value returned from that function, however, is not valid during the constructor. For this reason, it is suggested that you create your aggregates only in an override of `CCmdTarget::OnCreateAggregates`, where the return value from `GetControllingUnknown` is reliable, even if created from the `COleObjectFactory` implementation.  \n  \n It is also important that the object manipulate the correct reference count when adding or releasing artificial reference counts. To ensure this is the case, always call `ExternalAddRef` and `ExternalRelease` instead of `InternalRelease` and `InternalAddRef`. It is rare to call `InternalRelease` or `InternalAddRef` on a class that supports aggregation.  \n  \n### Reference Material  \n Advanced usage of OLE, such as defining your own interfaces or overriding the framework's implementation of the OLE interfaces requires the use of the underlying interface map mechanism.  \n  \n This section discusses each macro and the APIs which is used to implement these advanced features.  \n  \n### CCmdTarget::EnableAggregation — Function Description  \n  \n```  \n \nvoid EnableAggregation();\n\n \n```  \n  \n## Remarks  \n Call this function in the constructor of the derived class if you wish to support OLE aggregation for objects of this type. This prepares a special IUnknown implementation that is required for aggregatable objects.  \n  \n### CCmdTarget::ExternalQueryInterface — Function Description  \n  \n```  \n \n    DWORD ExternalQueryInterface(constvoidFAR* lpIID, LPVOIDFAR* ppvObj);\n```  \n  \n## Remarks  \n  \n#### Parameters  \n `lpIID`  \n A far pointer to an IID (the first argument to QueryInterface)  \n  \n `ppvObj`  \n A pointer to an IUnknown* (second argument to QueryInterface)  \n  \n## Remarks  \n Call this function in your implementation of IUnknown for each interface your class implements. This function provides the standard data-driven implementation of QueryInterface based on your object's interface map. It is necessary to cast the return value to an HRESULT. If the object is aggregated, this function will call the \"controlling IUnknown\" instead of using the local interface map.  \n  \n### CCmdTarget::ExternalAddRef — Function Description  \n  \n```  \n \nDWORD ExternalAddRef();\n\n \n```  \n  \n## Remarks  \n Call this function in your implementation of IUnknown::AddRef for each interface your class implements. The return value is the new reference count on the CCmdTarget object. If the object is aggregated, this function will call the \"controlling IUnknown\" instead of manipulating the local reference count.  \n  \n### CCmdTarget::ExternalRelease — Function Description  \n  \n```  \n \nDWORD ExternalRelease();\n\n \n```  \n  \n## Remarks  \n Call this function in your implementation of IUnknown::Release for each interface your class implements. The return value indicates the new reference count on the object. If the object is aggregated, this function will call the \"controlling IUnknown\" instead of manipulating the local reference count.  \n  \n### DECLARE_INTERFACE_MAP — Macro Description  \n  \n```  \n \nDECLARE_INTERFACE_MAP  \n \n```  \n  \n## Remarks  \n Use this macro in any class derived from `CCmdTarget` that will have an interface map. Used in much the same way as `DECLARE_MESSAGE_MAP`. This macro invocation should be placed in the class definition, usually in a header (.H) file. A class with `DECLARE_INTERFACE_MAP` must define the interface map in the implementation file (.CPP) with the `BEGIN_INTERFACE_MAP` and `END_INTERFACE_MAP` macros.  \n  \n### BEGIN_INTERFACE_PART and END_INTERFACE_PART — Macro Descriptions  \n  \n```  \n \n    BEGIN_INTERFACE_PART(\n localClass,   \n    iface);\n\nEND_INTERFACE_PART(\n localClass)  \n```  \n  \n## Remarks  \n  \n#### Parameters  \n l`ocalClass`  \n The name of the class that implements the interface  \n  \n `iface`  \n The name of the interface that this class implements  \n  \n## Remarks  \n For each interface that your class will implement, you need to have a `BEGIN_INTERFACE_PART` and `END_INTERFACE_PART` pair. These macros define a local class derived from the OLE interface that you define as well as an embedded member variable of that class. The [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379), [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), and [QueryInterface](http://msdn.microsoft.com/library/windows/desktop/ms682521) members are declared automatically. You must include the declarations for the other member functions that are part of the interface being implemented (those declarations are placed between the `BEGIN_INTERFACE_PART` and `END_INTERFACE_PART` macros).  \n  \n The `iface` argument is the OLE interface that you wish to implement, such as `IAdviseSink`, or `IPersistStorage` (or your own custom interface).  \n  \n The `localClass` argument is the name of the local class that will be defined. An 'X' will automatically be prepended to the name. This naming convention is used to avoid collisions with global classes of the same name. In addition, the name of the embedded member, the same as the `localClass` name except it is prefixed by 'm_x'.  \n  \n For example:  \n  \n```  \nBEGIN_INTERFACE_PART(MyAdviseSink,\n    IAdviseSink)  \n    STDMETHOD_(void,\n    OnDataChange)(LPFORMATETC,\n    LPSTGMEDIUM);\n\n    STDMETHOD_(void,\n    OnViewChange)(DWORD,\n    LONG);\n\n    STDMETHOD_(void,\n    OnRename)(LPMONIKER);\n\n STDMETHOD_(void,\n    OnSave)();\nSTDMETHOD_(void,\n    OnClose)();\n\nEND_INTERFACE_PART(MyAdviseSink) \n```  \n  \n would define a local class called XMyAdviseSink derived from IAdviseSink, and a member of the class in which it is declared called m_xMyAdviseSink.Note:  \n  \n> [!NOTE]\n>  The lines beginning with `STDMETHOD`_ are essentially copied from OLE2.H and modified slightly. Copying them from OLE2.H can reduce errors that are hard to resolve.  \n  \n### BEGIN_INTERFACE_MAP and END_INTERFACE_MAP — Macro Descriptions  \n  \n```  \n \n    BEGIN_INTERFACE_MAP(\n theClass,   \n    baseClass)END_INTERFACE_MAP \n```  \n  \n## Remarks  \n  \n#### Parameters  \n `theClass`  \n The class in which the interface map is to be defined  \n  \n `baseClass`  \n The class from which `theClass` derives from.  \n  \n## Remarks  \n The `BEGIN_INTERFACE_MAP` and `END_INTERFACE_MAP` macros are used in the implementation file to actually define the interface map. For each interface that is implemented there is one or more `INTERFACE_PART` macro invocations. For each aggregate that the class uses, there is one `INTERFACE_AGGREGATE` macro invocation.  \n  \n### INTERFACE_PART — Macro Description  \n  \n```  \n \n    INTERFACE_PART(\n theClass,   \n    iid, \n    localClass) \n```  \n  \n## Remarks  \n  \n#### Parameters  \n `theClass`  \n The name of the class that contains the interface map.  \n  \n `iid`  \n The `IID` that is to be mapped to the embedded class.  \n  \n `localClass`  \n The name of the local class (less the 'X').  \n  \n## Remarks  \n This macro is used between the `BEGIN_INTERFACE_MAP` macro and the `END_INTERFACE_MAP` macro for each interface your object will support. It allows you to map an IID to a member of the class indicated by `theClass` and `localClass`. The 'm_x' will be added to the `localClass` automatically. Note that more than one `IID` may be associated with a single member. This is very useful when you are implementing only a \"most derived\" interface and wish to provide all intermediate interfaces as well. A good example of this is the `IOleInPlaceFrameWindow` interface. Its hierarchy looks like this:  \n  \n```  \nIUnknown  \n    IOleWindow \n    IOleUIWindow \n    IOleInPlaceFrameWindow \n```  \n  \n If an object implements `IOleInPlaceFrameWindow`, a client may `QueryInterface` on any of these interfaces: `IOleUIWindow`, `IOleWindow`, or [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509), besides the \"most derived\" interface `IOleInPlaceFrameWindow` (the one you are actually implementing). To handle this you can use more than one `INTERFACE_PART` macro to map each and every base interface to the `IOleInPlaceFrameWindow` interface:  \n  \n in the class definition file:  \n  \n```  \nBEGIN_INTERFACE_PART(CMyFrameWindow, IOleInPlaceFrameWindow)  \n```  \n  \n in the class implementation file:  \n  \n```  \nBEGIN_INTERFACE_MAP(CMyWnd,\n    CFrameWnd)  \n    INTERFACE_PART(CMyWnd,\n    IID_IOleWindow,\n    MyFrameWindow)  \n    INTERFACE_PART(CMyWnd,\n    IID_IOleUIWindow,\n    MyFrameWindow)  \n    INTERFACE_PART(CMyWnd,\n    IID_IOleInPlaceFrameWindow,\n    MyFrameWindow)  \nEND_INTERFACE_MAP  \n```  \n  \n The framework takes care of IUnknown because it is always required.  \n  \n### INTERFACE_PART — Macro Description  \n  \n```  \n \n    INTERFACE_AGGREGATE(\n theClass,   \n    theAggr) \n```  \n  \n## Remarks  \n  \n#### Parameters  \n `theClass`  \n The name of the class that contains the interface map,  \n  \n `theAggr`  \n The name of the member variable that is to be aggregated.  \n  \n## Remarks  \n This macro is used to tell the framework that the class is using an aggregate object. It must appear between the `BEGIN_INTERFACE_PART` and `END_INTERFACE_PART` macros. An aggregate object is a separate object, derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509). By using an aggregate and the `INTERFACE_AGGREGATE` macro, you can make all the interfaces that the aggregate supports appear to be directly supported by the object. The `theAggr` argument is simply the name of a member variable of your class which is derived from [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) (either directly or indirectly). All `INTERFACE_AGGREGATE` macros must follow the `INTERFACE_PART` macros when placed in an interface map.  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}