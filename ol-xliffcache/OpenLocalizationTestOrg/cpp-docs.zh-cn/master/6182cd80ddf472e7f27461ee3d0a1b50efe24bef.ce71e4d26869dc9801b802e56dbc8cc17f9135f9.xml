{"nodes":[{"pos":[12,69],"content":"Source code organization (C++ Templates) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Source code organization (C++ Templates) | Microsoft Docs","pos":[0,57]}]},{"content":"Source code organization (C++ Templates)","pos":[327,367]},{"content":"When defining a class template, you must organize the source code in such a way that the member definitions are visible to the compiler when it needs them.","pos":[368,523]},{"content":"You have the choice of using the <bpt id=\"p1\">*</bpt>inclusion model<ept id=\"p1\">*</ept> or the <bpt id=\"p2\">*</bpt>explicit instantiation<ept id=\"p2\">*</ept> model.","pos":[526,615],"source":"   You have the choice of using the *inclusion model* or the *explicit instantiation* model."},{"content":"In the inclusion model, you include  the member definitions in every file that uses a template.","pos":[616,711]},{"content":"This approach is simplest and provides maximum flexibility in terms of what concrete types can be used with your template.","pos":[712,834]},{"content":"Its disadvantage is that it can increase compilation times.","pos":[835,894]},{"content":"The impact can be significant if a project and/or the included files themselves are large.","pos":[895,985]},{"content":"With the explicit instantiation approach, the template itself instantiates concrete classes or class members for specific types.","pos":[986,1114]},{"content":"This approach can speed up compilation times, but it limits usage to only those classes that the template implementer has enabled ahead of time.","pos":[1116,1260]},{"content":"In general, we recommend that you use the inclusion model  unless the compilation times become a problem.","pos":[1261,1366]},{"content":"Background","pos":[1375,1385]},{"content":"Templates are not like ordinary classes in the sense that the compiler does not generate object code for a template or any of its members.","pos":[1389,1527]},{"content":"There is nothing to generate until the template is instantiated with concrete types.","pos":[1528,1612]},{"content":"When the compiler encounters a template instantiation such as <ph id=\"ph1\">`MyClass&lt;int&gt; mc;`</ph>, and no class with that signature exists yet, then  it generates a new class.","pos":[1616,1774],"source":"    When the compiler encounters a template instantiation such as `MyClass<int> mc;`, and no class with that signature exists yet, then  it generates a new class."},{"content":"It also attempts to generate code for any member functions that are used.","pos":[1775,1848]},{"content":"If those definitions are in a file that is not #included, directly or indirectly, in the .cpp file that is being compiled, the compiler can't see them.","pos":[1849,2000]},{"content":"From the compiler's point of view, this isn't necessarily an error because the functions may be defined in another translation unit, in which case the linker will find them.","pos":[2002,2175]},{"content":"If the linker does not find that code, it raises an <bpt id=\"p1\">**</bpt>unresolved external<ept id=\"p1\">**</ept> error.","pos":[2177,2259],"source":"  If the linker does not find that code, it raises an **unresolved external** error."},{"content":"The inclusion model","pos":[2268,2287]},{"content":"The simplest and most common way to make template definitions visible throughout a translation unit,  is to put the definitions in the header file itself.","pos":[2291,2445]},{"content":"Any .cpp file that uses the template simply has to #include the header.","pos":[2447,2518]},{"content":"This is the approach used in the Standard Library.","pos":[2519,2569]},{"content":"With this approach,  the compiler has access to the complete template definition and can instantiate templates on-demand for any type.","pos":[2995,3129]},{"content":"It is simple and relatively easy to maintain.","pos":[3130,3175]},{"content":"However, the inclusion model does have a cost in terms of compilation times.","pos":[3176,3252]},{"content":"This cost can be significant in large programs, especially if the template header itself #includes other headers.","pos":[3255,3368]},{"content":"Every .cpp file that #includes the header will get its own copy of the function templates and all the definitions.","pos":[3369,3483]},{"content":"The linker will generally be able to sort things out so that you do not end up with multiple definitions for a function, but it takes time to do this work.","pos":[3484,3639]},{"content":"In smaller programs that extra compilation time is probably not significant.","pos":[3640,3716]},{"content":"Explicit instantiation","pos":[3725,3747]},{"content":"If the inclusion model is not viable for your project, and you know definitively the set of types that will be used to instantiate a template, then you can separate out the template code into an .h and .cpp file, and in the .cpp file explicitly instantiate the templates.","pos":[3751,4022]},{"content":"This will cause object code to be generated that the compiler will see when it encounters user instantiations.","pos":[4023,4133]},{"content":"You create an explicit instantiation by using the keyword template followed by the signature of the entity you want to instantiate.","pos":[4140,4271]},{"content":"This can be a type or a member.","pos":[4272,4303]},{"content":"If you explicitly instantiate a type, all members are instantiated.","pos":[4304,4371]},{"content":"In the previous example, the explicit instantiations are at the bottom of the .cpp file.","pos":[5055,5143]},{"content":"A MyArray may be used only for <ph id=\"ph1\">`double`</ph> or <ph id=\"ph2\">`string`</ph> types.","pos":[5144,5202],"source":" A MyArray may be used only for `double` or `string` types."},{"pos":[5210,5390],"content":"[!NOTE]\n In C++11 the `export` keyword was deprecated in the context of template definitions. In practical terms this has little impact because most compilers never supported it.","leadings":["","> "],"nodes":[{"content":" In C++11 the `export` keyword was deprecated in the context of template definitions. In practical terms this has little impact because most compilers never supported it.","pos":[8,178],"nodes":[{"content":"In C++11 the <ph id=\"ph1\">`export`</ph> keyword was deprecated in the context of template definitions.","pos":[1,85],"source":" In C++11 the `export` keyword was deprecated in the context of template definitions."},{"content":"In practical terms this has little impact because most compilers never supported it.","pos":[86,170]}]}]}],"content":"---\ntitle: \"Source code organization (C++ Templates) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 50569c5d-0219-4966-9bcf-a8689074ad1d\ncaps.latest.revision: 5\nmanager: \"ghogen\"\n---\n# Source code organization (C++ Templates)\nWhen defining a class template, you must organize the source code in such a way that the member definitions are visible to the compiler when it needs them.   You have the choice of using the *inclusion model* or the *explicit instantiation* model. In the inclusion model, you include  the member definitions in every file that uses a template. This approach is simplest and provides maximum flexibility in terms of what concrete types can be used with your template. Its disadvantage is that it can increase compilation times. The impact can be significant if a project and/or the included files themselves are large. With the explicit instantiation approach, the template itself instantiates concrete classes or class members for specific types.  This approach can speed up compilation times, but it limits usage to only those classes that the template implementer has enabled ahead of time. In general, we recommend that you use the inclusion model  unless the compilation times become a problem.  \n  \n## Background  \n Templates are not like ordinary classes in the sense that the compiler does not generate object code for a template or any of its members. There is nothing to generate until the template is instantiated with concrete types.    When the compiler encounters a template instantiation such as `MyClass<int> mc;`, and no class with that signature exists yet, then  it generates a new class. It also attempts to generate code for any member functions that are used. If those definitions are in a file that is not #included, directly or indirectly, in the .cpp file that is being compiled, the compiler can't see them.  From the compiler's point of view, this isn't necessarily an error because the functions may be defined in another translation unit, in which case the linker will find them.  If the linker does not find that code, it raises an **unresolved external** error.  \n  \n## The inclusion model  \n The simplest and most common way to make template definitions visible throughout a translation unit,  is to put the definitions in the header file itself.  Any .cpp file that uses the template simply has to #include the header. This is the approach used in the Standard Library.  \n  \n```  \n#ifndef MYARRAY  \n#define MYARRAY  \n#include <iostream>  \n  \ntemplate<typename T, size_t N>  \nclass MyArray  \n{  \n    T arr[N];  \npublic:  \n    // Full definitions:  \n    MyArray(){}  \n    void Print()  \n    {  \n        for (const auto v : arr)  \n        {  \n            std::cout << v << \" , \";  \n        }  \n    }  \n  \n    T& operator[](int i)  \n   {  \n       return arr[i];  \n   }   \n};  \n#endif  \n  \n```  \n  \n With this approach,  the compiler has access to the complete template definition and can instantiate templates on-demand for any type. It is simple and relatively easy to maintain. However, the inclusion model does have a cost in terms of compilation times.   This cost can be significant in large programs, especially if the template header itself #includes other headers. Every .cpp file that #includes the header will get its own copy of the function templates and all the definitions. The linker will generally be able to sort things out so that you do not end up with multiple definitions for a function, but it takes time to do this work. In smaller programs that extra compilation time is probably not significant.  \n  \n## Explicit instantiation  \n If the inclusion model is not viable for your project, and you know definitively the set of types that will be used to instantiate a template, then you can separate out the template code into an .h and .cpp file, and in the .cpp file explicitly instantiate the templates. This will cause object code to be generated that the compiler will see when it encounters user instantiations.  \n  \n You create an explicit instantiation by using the keyword template followed by the signature of the entity you want to instantiate. This can be a type or a member. If you explicitly instantiate a type, all members are instantiated.  \n  \n```  \ntemplate MyArray<double, 5>;  \n```  \n  \n```  \n//MyArray.h  \n#ifndef MYARRAY  \n#define MYARRAY  \n  \ntemplate<typename T, size_t N>  \nclass MyArray  \n{  \n    T arr[N];  \npublic:  \n    MyArray();  \n    void Print();  \n    T& operator[](int i);  \n};  \n#endif  \n  \n//MyArray.cpp  \n#include \"stdafx.h\"  \n#include <iostream>  \n#include \"MyArray.h\"  \n  \nusing namespace std;  \n  \ntemplate<typename T, size_t N>  \nMyArray<T,N>::MyArray(){}  \n  \ntemplate<typename T, size_t N>  \nvoid MyArray<T,N>::Print()  \n{  \n    for(const auto v : arr)  \n    {  \n        cout << v << \"'\";  \n    }  \n    cout << endl;  \n}  \n  \ntemplate MyArray<double, 5>;template MyArray<string, 5>;  \n```  \n  \n In the previous example, the explicit instantiations are at the bottom of the .cpp file. A MyArray may be used only for `double` or `string` types.  \n  \n> [!NOTE]\n>  In C++11 the `export` keyword was deprecated in the context of template definitions. In practical terms this has little impact because most compilers never supported it."}