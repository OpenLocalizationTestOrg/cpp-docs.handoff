{"nodes":[{"pos":[12,52],"content":"Algorithms (Modern C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Algorithms (Modern C++) | Microsoft Docs","pos":[0,40]}]},{"content":"Algorithms (Modern C++)","pos":[533,556]},{"content":"For modern C++ programming, we recommend that you use the algorithms in the <bpt id=\"p1\">[</bpt>Standard Template Library<ept id=\"p1\">](../standard-library/cpp-standard-library-reference.md)</ept> (STL).","pos":[557,722],"source":"For modern C++ programming, we recommend that you use the algorithms in the [Standard Template Library](../standard-library/cpp-standard-library-reference.md) (STL)."},{"content":"Here are some important examples:","pos":[723,756]},{"content":", which is the default traversal algorithm.","pos":[776,819]},{"content":"(Also <ph id=\"ph1\">`transform`</ph> for not-in-place semantics.)","pos":[820,866],"source":" (Also `transform` for not-in-place semantics.)"},{"pos":[885,925],"content":", which is the default search algorithm."},{"pos":[941,1013],"content":", <ph id=\"ph1\">`lower_bound`</ph>, and the other default sorting and searching algorithms.","source":", `lower_bound`, and the other default sorting and searching algorithms."},{"pos":[1020,1096],"content":"To write a comparator, use strict <ph id=\"ph1\">`&lt;`</ph> and use  <bpt id=\"p1\">*</bpt>named lambdas<ept id=\"p1\">*</ept> when you can.","source":"To write a comparator, use strict `<` and use  *named lambdas* when you can."},{"content":"Loops","pos":[1322,1327]},{"content":"When possible, use range-based <ph id=\"ph1\">`for`</ph> loops or algorithm calls, or both, instead of hand-written loops.<ph id=\"ph2\">`copy`</ph>, <ph id=\"ph3\">`transform`</ph>, <ph id=\"ph4\">`count_if`</ph>, <ph id=\"ph5\">`remove_if`</ph>, and others like them are much better than handwritten loops because their intent is obvious and they make it easier to write bug-free code.","pos":[1331,1618],"source":"When possible, use range-based `for` loops or algorithm calls, or both, instead of hand-written loops.`copy`, `transform`, `count_if`, `remove_if`, and others like them are much better than handwritten loops because their intent is obvious and they make it easier to write bug-free code."},{"content":"Also, many STL algorithms have implementation optimizations that make them more efficient.","pos":[1619,1709]},{"content":"Instead of old C++ like this:","pos":[1716,1745]},{"content":"Use modern C++ like this:","pos":[1953,1978]},{"content":"Range-based for loops","pos":[2174,2195]},{"content":"The range-based <ph id=\"ph1\">`for`</ph> loop is a C++11 language feature, not an STL algorithm.","pos":[2199,2276],"source":"The range-based `for` loop is a C++11 language feature, not an STL algorithm."},{"content":"But it deserves mention in this discussion about loops.","pos":[2277,2332]},{"content":"Range-based <ph id=\"ph1\">`for`</ph> loops are an extension of the <ph id=\"ph2\">`for`</ph> keyword and provide a convenient and efficient way to write loops that iterate over a range of values.","pos":[2333,2489],"source":" Range-based `for` loops are an extension of the `for` keyword and provide a convenient and efficient way to write loops that iterate over a range of values."},{"content":"STL containers, strings, and arrays are ready-made for range-based <ph id=\"ph1\">`for`</ph> loops.","pos":[2490,2569],"source":" STL containers, strings, and arrays are ready-made for range-based `for` loops."},{"content":"To enable this new iteration syntax for your user-defined type, add the following support:","pos":[2570,2660]},{"pos":[2670,2819],"content":"A <ph id=\"ph1\">`begin`</ph> method that returns an iterator to the beginning of the structure and an <ph id=\"ph2\">`end`</ph> method that returns an iterator to the end of the structure.","source":"A `begin` method that returns an iterator to the beginning of the structure and an `end` method that returns an iterator to the end of the structure."},{"pos":[2829,2933],"content":"Support in the iterator for these methods: <ph id=\"ph1\">`operator*`</ph>, <ph id=\"ph2\">`operator!=`</ph>, and <ph id=\"ph3\">`operator++`</ph> (prefix version).","source":"Support in the iterator for these methods: `operator*`, `operator!=`, and `operator++` (prefix version)."},{"content":"These methods can be either members or stand-alone functions.","pos":[2940,3001]},{"content":"Random Numbers","pos":[3010,3024]},{"content":"It's no secret that the old CRT <ph id=\"ph1\">`rand()`</ph> function has many flaws, which have been discussed at length in the C++ community.","pos":[3028,3151],"source":"It's no secret that the old CRT `rand()` function has many flaws, which have been discussed at length in the C++ community."},{"content":"In modern C++, you don't have to deal with those shortcomings—nor do you have to invent your own uniformly distributed random number generator—because the tools for quickly and easily creating them are available in the STL, as shown in <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>random&gt;<ept id=\"p1\">](../standard-library/random.md)</ept>.","pos":[3152,3431],"source":" In modern C++, you don't have to deal with those shortcomings—nor do you have to invent your own uniformly distributed random number generator—because the tools for quickly and easily creating them are available in the STL, as shown in [\\<random>](../standard-library/random.md)."},{"content":"See Also","pos":[3440,3448]},{"content":"Welcome Back to C++","pos":[3453,3472]},{"content":"C++ Language Reference","pos":[3521,3543]},{"content":"C++ Standard Library","pos":[3584,3604]}],"content":"---\ntitle: \"Algorithms (Modern C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 6f758d3c-a7c7-4a50-92bb-97b2f6d4ab27\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Algorithms (Modern C++)\nFor modern C++ programming, we recommend that you use the algorithms in the [Standard Template Library](../standard-library/cpp-standard-library-reference.md) (STL). Here are some important examples:  \n  \n-   `for_each`, which is the default traversal algorithm. (Also `transform` for not-in-place semantics.)  \n  \n-   `find_if`, which is the default search algorithm.  \n  \n-   `sort`, `lower_bound`, and the other default sorting and searching algorithms.  \n  \n To write a comparator, use strict `<` and use  *named lambdas* when you can.  \n  \n```cpp  \n  \nauto comp = [](const widget& w1, const widget& w2)  \n      { return w1.weight() < w2.weight(); }  \n  \nsort( v.begin(), v.end(), comp );  \n  \nauto i = lower_bound( v.begin(), v.end(), comp );  \n  \n```  \n  \n## Loops  \n When possible, use range-based `for` loops or algorithm calls, or both, instead of hand-written loops.`copy`, `transform`, `count_if`, `remove_if`, and others like them are much better than handwritten loops because their intent is obvious and they make it easier to write bug-free code. Also, many STL algorithms have implementation optimizations that make them more efficient.  \n  \n Instead of old C++ like this:  \n  \n```cpp  \n  \nfor( auto i = strings.begin(); i != strings.end(); ++i ) {  \n  :::  \n  :::  \n}  \n  \nauto i = v.begin();  \n  \nfor( ; i != v.end(); ++i ) {  \n  if (*i > x && *i < y) break;  \n}  \n  \n```  \n  \n Use modern C++ like this:  \n  \n```cpp  \n  \nfor_each( begin(strings), end(strings), [](string& s) {  \n  :::  \n  :::  \n} );  \nauto i = find_if( begin(v), end(v),  [=](int i) { return i > x && i < y; }  );  \n  \n```  \n  \n### Range-based for loops  \n The range-based `for` loop is a C++11 language feature, not an STL algorithm. But it deserves mention in this discussion about loops. Range-based `for` loops are an extension of the `for` keyword and provide a convenient and efficient way to write loops that iterate over a range of values. STL containers, strings, and arrays are ready-made for range-based `for` loops. To enable this new iteration syntax for your user-defined type, add the following support:  \n  \n-   A `begin` method that returns an iterator to the beginning of the structure and an `end` method that returns an iterator to the end of the structure.  \n  \n-   Support in the iterator for these methods: `operator*`, `operator!=`, and `operator++` (prefix version).  \n  \n These methods can be either members or stand-alone functions.  \n  \n## Random Numbers  \n It's no secret that the old CRT `rand()` function has many flaws, which have been discussed at length in the C++ community. In modern C++, you don't have to deal with those shortcomings—nor do you have to invent your own uniformly distributed random number generator—because the tools for quickly and easily creating them are available in the STL, as shown in [\\<random>](../standard-library/random.md).  \n  \n## See Also  \n [Welcome Back to C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   \n [C++ Language Reference](../cpp/cpp-language-reference.md)   \n [C++ Standard Library](../standard-library/cpp-standard-library-reference.md)"}