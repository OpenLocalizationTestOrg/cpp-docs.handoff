{"nodes":[{"pos":[12,49],"content":"Compiler Error C3535 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Error C3535 | Microsoft Docs","pos":[0,37]}]},{"content":"Compiler Error C3535","pos":[597,617]},{"content":"cannot deduce type for 'type1' from 'type2'","pos":[618,661]},{"content":"The type of the variable declared by the <ph id=\"ph1\">`auto`</ph> keyword cannot be deduced from the type of the initialization expression.","pos":[668,789],"source":"The type of the variable declared by the `auto` keyword cannot be deduced from the type of the initialization expression."},{"content":"For example, this error occurs if the initialization expression evaluates to <ph id=\"ph1\">`void`</ph>, which is not a type.","pos":[790,895],"source":" For example, this error occurs if the initialization expression evaluates to `void`, which is not a type."},{"content":"To correct this error","pos":[905,926]},{"pos":[936,1004],"content":"Ensure that the type of the initialization expression is not <ph id=\"ph1\">`void`</ph>.","source":"Ensure that the type of the initialization expression is not `void`."},{"content":"Ensure that the declaration is not a pointer to a fundamental type.","pos":[1014,1081]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Fundamental Types<ept id=\"p1\">](../../cpp/fundamental-types-cpp.md)</ept>.","pos":[1082,1164],"source":" For more information, see [Fundamental Types](../../cpp/fundamental-types-cpp.md)."},{"content":"Ensure that if the declaration is a pointer to a type, the initialization expression is a pointer type.","pos":[1174,1277]},{"content":"Example","pos":[1286,1293]},{"pos":[1297,1390],"content":"The following example yields C3535 because the initialization expression evaluates to <ph id=\"ph1\">`void`</ph>.","source":"The following example yields C3535 because the initialization expression evaluates to `void`."},{"content":"Example","pos":[1535,1542]},{"content":"The following example yields C3535 because the statement declares variable <ph id=\"ph1\">`x`</ph> as a pointer to a deduced type, but the type of the initializer expression is double.","pos":[1546,1710],"source":"The following example yields C3535 because the statement declares variable `x` as a pointer to a deduced type, but the type of the initializer expression is double."},{"content":"Consequently, the compiler cannot deduce the type of the variable.","pos":[1711,1777]},{"content":"Example","pos":[1913,1920]},{"pos":[1924,2074],"content":"The following example yields C3535 because variable <ph id=\"ph1\">`p`</ph> declares a pointer to a deduced type, but the initialization expression is not a pointer type.","source":"The following example yields C3535 because variable `p` declares a pointer to a deduced type, but the initialization expression is not a pointer type."},{"content":"See Also","pos":[2188,2196]},{"content":"auto Keyword","pos":[2201,2213]},{"content":"Fundamental Types","pos":[2247,2264]}],"content":"---\ntitle: \"Compiler Error C3535 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C3535\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C3535\"\nms.assetid: 24449c98-f681-484d-a00b-32533dca3a88\ncaps.latest.revision: 6\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Compiler Error C3535\ncannot deduce type for 'type1' from 'type2'  \n  \n The type of the variable declared by the `auto` keyword cannot be deduced from the type of the initialization expression. For example, this error occurs if the initialization expression evaluates to `void`, which is not a type.  \n  \n### To correct this error  \n  \n1.  Ensure that the type of the initialization expression is not `void`.  \n  \n2.  Ensure that the declaration is not a pointer to a fundamental type. For more information, see [Fundamental Types](../../cpp/fundamental-types-cpp.md).  \n  \n3.  Ensure that if the declaration is a pointer to a type, the initialization expression is a pointer type.  \n  \n## Example  \n The following example yields C3535 because the initialization expression evaluates to `void`.  \n  \n```  \n// C3535a.cpp  \n// Compile with /Zc:auto  \nvoid f(){}  \nint main()  \n{  \n   auto x = f();   //C3535  \n   return 0;  \n}  \n```  \n  \n## Example  \n The following example yields C3535 because the statement declares variable `x` as a pointer to a deduced type, but the type of the initializer expression is double. Consequently, the compiler cannot deduce the type of the variable.  \n  \n```  \n// C3535b.cpp  \n// Compile with /Zc:auto  \nint main()  \n{  \n   auto* x = 123.0;   // C3535  \n   return 0;  \n}  \n```  \n  \n## Example  \n The following example yields C3535 because variable `p` declares a pointer to a deduced type, but the initialization expression is not a pointer type.  \n  \n```  \n// C3535c.cpp  \n// Compile with /Zc:auto  \nclass A { };  \nA x;  \nauto *p = x;  // C3535  \n```  \n  \n## See Also  \n [auto Keyword](../../cpp/auto-keyword.md)   \n [Fundamental Types](../../cpp/fundamental-types-cpp.md)"}