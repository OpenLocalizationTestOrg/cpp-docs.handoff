{"nodes":[{"pos":[12,48],"content":"unordered_map Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"unordered_map Class | Microsoft Docs","pos":[0,36]}]},{"content":"unordered_map Class","pos":[794,813]},{"content":"The template class describes an object that controls a varying-length sequence of elements of type <ph id=\"ph1\">`std::pair&lt;const Key, Ty&gt;`</ph>.","pos":[814,940],"source":"The template class describes an object that controls a varying-length sequence of elements of type `std::pair<const Key, Ty>`."},{"content":"The sequence is weakly ordered by a hash function, which partitions the sequence into an ordered set of subsequences called buckets.","pos":[941,1073]},{"content":"Within each bucket a comparison function determines whether any pair of elements has equivalent ordering.","pos":[1074,1179]},{"content":"Each element stores two objects, a sort key and a value.","pos":[1180,1236]},{"content":"The sequence is represented in a way that permits lookup, insertion, and removal of an arbitrary element with a number of operations that can be independent of the number of elements in the sequence (constant time), at least when all buckets are of roughly equal length.","pos":[1237,1507]},{"content":"In the worst case, when all of the elements are in one bucket, the number of operations is proportional to the number of elements in the sequence (linear time).","pos":[1508,1668]},{"content":"Moreover, inserting an element invalidates no iterators, and removing an element invalidates only those iterators which point at the removed element.","pos":[1669,1818]},{"content":"Syntax","pos":[1827,1833]},{"content":"Parameters","pos":[2057,2067]},{"content":"Parameter","pos":[2088,2097]},{"content":"Description","pos":[2098,2109]},{"content":"The key type.","pos":[2120,2133]},{"content":"The mapped type.","pos":[2143,2159]},{"content":"The hash function object type.","pos":[2171,2201]},{"content":"The equality comparison function object type.","pos":[2213,2258]},{"content":"The allocator class.","pos":[2271,2291]},{"content":"Members","pos":[2301,2308]},{"content":"Type Definition","pos":[2329,2344]},{"content":"Description","pos":[2345,2356]},{"content":"unordered_map::allocator_type","pos":[2362,2391]},{"content":"The type of an allocator for managing storage.","pos":[2425,2471]},{"content":"unordered_map::const_iterator","pos":[2477,2506]},{"content":"The type of a constant iterator for the controlled sequence.","pos":[2540,2600]},{"content":"unordered_map::const_local_iterator","pos":[2606,2641]},{"content":"The type of a constant bucket iterator for the controlled sequence.","pos":[2681,2748]},{"content":"unordered_map::const_pointer","pos":[2754,2782]},{"content":"The type of a constant pointer to an element.","pos":[2815,2860]},{"content":"unordered_map::const_reference","pos":[2866,2896]},{"content":"The type of a constant reference to an element.","pos":[2931,2978]},{"content":"unordered_map::difference_type","pos":[2984,3014]},{"content":"The type of a signed distance between two elements.","pos":[3049,3100]},{"content":"unordered_map::hasher","pos":[3106,3127]},{"content":"The type of the hash function.","pos":[3153,3183]},{"content":"unordered_map::iterator","pos":[3189,3212]},{"content":"The type of an iterator for the controlled sequence.","pos":[3240,3292]},{"content":"unordered_map::key_equal","pos":[3298,3322]},{"content":"The type of the comparison function.","pos":[3351,3387]},{"content":"unordered_map::key_type","pos":[3393,3416]},{"content":"The type of an ordering key.","pos":[3444,3472]},{"content":"unordered_map::local_iterator","pos":[3478,3507]},{"content":"The type of a bucket iterator for the controlled sequence.","pos":[3541,3599]},{"content":"unordered_map::mapped_type","pos":[3605,3631]},{"content":"The type of a mapped value associated with each key.","pos":[3662,3714]},{"content":"unordered_map::pointer","pos":[3720,3742]},{"content":"The type of a pointer to an element.","pos":[3769,3805]},{"content":"unordered_map::reference","pos":[3811,3835]},{"content":"The type of a reference to an element.","pos":[3864,3902]},{"content":"unordered_map::size_type","pos":[3908,3932]},{"content":"The type of an unsigned distance between two elements.","pos":[3961,4015]},{"content":"unordered_map::value_type","pos":[4021,4046]},{"content":"The type of an element.","pos":[4076,4099]},{"content":"Member Function","pos":[4121,4136]},{"content":"Description","pos":[4137,4148]},{"content":"unordered_map::at","pos":[4154,4171]},{"content":"Finds an element with the specified key.","pos":[4193,4233]},{"content":"unordered_map::begin","pos":[4239,4259]},{"content":"Designates the beginning of the controlled sequence.","pos":[4284,4336]},{"content":"unordered_map::bucket","pos":[4342,4363]},{"content":"Gets the bucket number for a key value.","pos":[4389,4428]},{"content":"unordered_map::bucket_count","pos":[4434,4461]},{"content":"Gets the number of buckets.","pos":[4493,4520]},{"content":"unordered_map::bucket_size","pos":[4526,4552]},{"content":"Gets the size of a bucket.","pos":[4583,4609]},{"content":"unordered_map::cbegin","pos":[4615,4636]},{"content":"Designates the beginning of the controlled sequence.","pos":[4662,4714]},{"content":"unordered_map::cend","pos":[4720,4739]},{"content":"Designates the end of the controlled sequence.","pos":[4763,4809]},{"content":"unordered_map::clear","pos":[4815,4835]},{"content":"Removes all elements.","pos":[4860,4881]},{"content":"unordered_map::count","pos":[4887,4907]},{"content":"Finds the number of elements matching a specified key.","pos":[4932,4986]},{"content":"unordered_map::emplace","pos":[4992,5014]},{"content":"Adds an element constructed in place.","pos":[5041,5078]},{"content":"unordered_map::emplace_hint","pos":[5084,5111]},{"content":"Adds an element constructed in place, with hint.","pos":[5143,5191]},{"content":"unordered_map::empty","pos":[5197,5217]},{"content":"Tests whether no elements are present.","pos":[5242,5280]},{"content":"unordered_map::end","pos":[5286,5304]},{"content":"Designates the end of the controlled sequence.","pos":[5327,5373]},{"content":"unordered_map::equal_range","pos":[5379,5405]},{"content":"Finds range that matches a specified key.","pos":[5436,5477]},{"content":"unordered_map::erase","pos":[5483,5503]},{"content":"Removes elements at specified positions.","pos":[5528,5568]},{"content":"unordered_map::find","pos":[5574,5593]},{"content":"Finds an element that matches a specified key.","pos":[5617,5663]},{"content":"unordered_map::get_allocator","pos":[5669,5697]},{"content":"Gets the stored allocator object.","pos":[5730,5763]},{"content":"unordered_map::hash_function","pos":[5769,5797]},{"content":"Gets the stored hash function object.","pos":[5830,5867]},{"content":"unordered_map::insert","pos":[5873,5894]},{"content":"Adds elements.","pos":[5920,5934]},{"content":"unordered_map::key_eq","pos":[5940,5961]},{"content":"Gets the stored comparison function object.","pos":[5987,6030]},{"content":"unordered_map::load_factor","pos":[6036,6062]},{"content":"Counts the average elements per bucket.","pos":[6093,6132]},{"content":"unordered_map::max_bucket_count","pos":[6138,6169]},{"content":"Gets the maximum number of buckets.","pos":[6205,6240]},{"content":"unordered_map::max_load_factor","pos":[6246,6276]},{"content":"Gets or sets the maximum elements per bucket.","pos":[6311,6356]},{"content":"unordered_map::max_size","pos":[6362,6385]},{"content":"Gets the maximum size of the controlled sequence.","pos":[6413,6462]},{"content":"unordered_map::rehash","pos":[6468,6489]},{"content":"Rebuilds the hash table.","pos":[6515,6539]},{"content":"unordered_map::size","pos":[6545,6564]},{"content":"Counts the number of elements.","pos":[6588,6618]},{"content":"unordered_map::swap","pos":[6624,6643]},{"content":"Swaps the contents of two containers.","pos":[6667,6704]},{"content":"unordered_map::unordered_map","pos":[6710,6738]},{"content":"Constructs a container object.","pos":[6771,6801]},{"content":"Operator","pos":[6823,6831]},{"content":"Description","pos":[6832,6843]},{"content":"unordered_map::operator[]","pos":[6849,6874]},{"content":"Finds or inserts an element with the specified key.","pos":[6905,6956]},{"content":"unordered_map::operator=","pos":[6962,6986]},{"content":"Copies a hash table.","pos":[7017,7037]},{"content":"Remarks","pos":[7047,7054]},{"content":"The object orders the sequence it controls by calling two stored objects, a comparison function object of type <bpt id=\"p1\">[</bpt>unordered_map::key_equal<ept id=\"p1\">](#unordered_map__key_equal)</ept> and a hash function object of type <bpt id=\"p2\">[</bpt>unordered_map::hasher<ept id=\"p2\">](#unordered_map__hasher)</ept>.","pos":[7058,7306],"source":"The object orders the sequence it controls by calling two stored objects, a comparison function object of type [unordered_map::key_equal](#unordered_map__key_equal) and a hash function object of type [unordered_map::hasher](#unordered_map__hasher)."},{"content":"You access the first stored object by calling the member function <bpt id=\"p1\">[</bpt>unordered_map::key_eq<ept id=\"p1\">](#unordered_map__key_eq)</ept><ph id=\"ph1\">`()`</ph>; and you access the second stored object by calling the member function <bpt id=\"p2\">[</bpt>unordered_map::hash_function<ept id=\"p2\">](#unordered_map__hash_function)</ept><ph id=\"ph2\">`()`</ph>.","pos":[7307,7563],"source":" You access the first stored object by calling the member function [unordered_map::key_eq](#unordered_map__key_eq)`()`; and you access the second stored object by calling the member function [unordered_map::hash_function](#unordered_map__hash_function)`()`."},{"content":"Specifically, for all values <ph id=\"ph1\">`X`</ph> and <ph id=\"ph2\">`Y`</ph> of type <ph id=\"ph3\">`Key`</ph>, the call <ph id=\"ph4\">`key_eq()(X, Y)`</ph> returns true only if the two argument values have equivalent ordering; the call <ph id=\"ph5\">`hash_function()(keyval)`</ph> yields a distribution of values of type <ph id=\"ph6\">`size_t`</ph>.","pos":[7564,7801],"source":" Specifically, for all values `X` and `Y` of type `Key`, the call `key_eq()(X, Y)` returns true only if the two argument values have equivalent ordering; the call `hash_function()(keyval)` yields a distribution of values of type `size_t`."},{"content":"Unlike template class <bpt id=\"p1\">[</bpt>unordered_multimap Class<ept id=\"p1\">](../standard-library/unordered-multimap-class.md)</ept>, an object of template class <ph id=\"ph1\">`unordered_map`</ph> ensures that <ph id=\"ph2\">`key_eq()(X, Y)`</ph> is always false for any two elements of the controlled sequence.","pos":[7802,8039],"source":" Unlike template class [unordered_multimap Class](../standard-library/unordered-multimap-class.md), an object of template class `unordered_map` ensures that `key_eq()(X, Y)` is always false for any two elements of the controlled sequence."},{"content":"(Keys are unique.)","pos":[8040,8058]},{"content":"The object also stores a maximum load factor, which specifies the maximum desired average number of elements per bucket.","pos":[8065,8185]},{"content":"If inserting an element causes <bpt id=\"p1\">[</bpt>unordered_map::load_factor<ept id=\"p1\">](#unordered_map__load_factor)</ept><ph id=\"ph1\">`()`</ph> to exceed the maximum load factor, the container increases the number of buckets and rebuilds the hash table as needed.","pos":[8186,8398],"source":" If inserting an element causes [unordered_map::load_factor](#unordered_map__load_factor)`()` to exceed the maximum load factor, the container increases the number of buckets and rebuilds the hash table as needed."},{"content":"The actual order of elements in the controlled sequence depends on the hash function, the comparison function, the order of insertion, the maximum load factor, and the current number of buckets.","pos":[8405,8599]},{"content":"You cannot in general predict the order of elements in the controlled sequence.","pos":[8600,8679]},{"content":"You can always be assured, however, that any subset of elements that have equivalent ordering are adjacent in the controlled sequence.","pos":[8680,8814]},{"content":"The object allocates and frees storage for the sequence it controls through a stored allocator object of type <bpt id=\"p1\">[</bpt>unordered_map::allocator_type<ept id=\"p1\">](#unordered_map__allocator_type)</ept>.","pos":[8821,8995],"source":"The object allocates and frees storage for the sequence it controls through a stored allocator object of type [unordered_map::allocator_type](#unordered_map__allocator_type)."},{"content":"Such an allocator object must have the same external interface as an object of template class <ph id=\"ph1\">`allocator`</ph>.","pos":[8996,9102],"source":" Such an allocator object must have the same external interface as an object of template class `allocator`."},{"content":"Note that the stored allocator object is not copied when the container object is assigned.","pos":[9103,9193]},{"content":"Requirements","pos":[9202,9214]},{"pos":[9218,9245],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> &lt;unordered_map&gt;","source":"**Header:** <unordered_map>"},{"pos":[9252,9270],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[9326,9355],"content":"unordered_map::allocator_type"},{"content":"The type of an allocator for managing storage.","pos":[9359,9405]},{"content":"Remarks","pos":[9462,9469]},{"pos":[9473,9530],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Alloc`</ph>.","source":"The type is a synonym for the template parameter `Alloc`."},{"content":"Example","pos":[9540,9547]},{"pos":[10120,10137],"content":"unordered_map::at"},{"content":"Finds an element in a unordered_map with a specified key value.","pos":[10141,10204]},{"content":"Parameters","pos":[10289,10299]},{"content":"Parameter","pos":[10320,10329]},{"content":"Description","pos":[10330,10341]},{"content":"The key value to find.","pos":[10353,10375]},{"content":"Return Value","pos":[10386,10398]},{"content":"A reference to the data value of the element found.","pos":[10402,10453]},{"content":"Remarks","pos":[10463,10470]},{"pos":[10474,10573],"content":"If the argument key value is not found, then the function throws an object of class <ph id=\"ph1\">`out_of_range`</ph>.","source":"If the argument key value is not found, then the function throws an object of class `out_of_range`."},{"content":"Example","pos":[10583,10590]},{"pos":[11245,11265],"content":"unordered_map::begin"},{"content":"Designates the beginning of the controlled sequence or a bucket.","pos":[11269,11333]},{"content":"Parameters","pos":[11501,11511]},{"content":"Parameter","pos":[11532,11541]},{"content":"Description","pos":[11542,11553]},{"content":"The bucket number.","pos":[11568,11586]},{"content":"Remarks","pos":[11597,11604]},{"content":"The first two member functions return a forward iterator that points at the first element of the sequence (or just beyond the end of an empty sequence).","pos":[11608,11760]},{"content":"The last two member functions return a forward iterator that points at the first element of bucket <ph id=\"ph1\">`nbucket`</ph> (or just beyond the end of an empty bucket).","pos":[11761,11914],"source":" The last two member functions return a forward iterator that points at the first element of bucket `nbucket` (or just beyond the end of an empty bucket)."},{"content":"Example","pos":[11924,11931]},{"pos":[13076,13097],"content":"unordered_map::bucket"},{"content":"Gets the bucket number for a key value.","pos":[13101,13140]},{"content":"Parameters","pos":[13208,13218]},{"content":"The key value to map.","pos":[13234,13255]},{"content":"Remarks","pos":[13265,13272]},{"pos":[13276,13372],"content":"The member function returns the bucket number currently corresponding to the key value <ph id=\"ph1\">`keyval`</ph>.","source":"The member function returns the bucket number currently corresponding to the key value `keyval`."},{"content":"Example","pos":[13382,13389]},{"pos":[14350,14377],"content":"unordered_map::bucket_count"},{"content":"Gets the number of buckets.","pos":[14381,14408]},{"content":"Remarks","pos":[14465,14472]},{"content":"The member function returns the current number of buckets.","pos":[14476,14534]},{"content":"Example","pos":[14544,14551]},{"pos":[16738,16764],"content":"unordered_map::bucket_size"},{"content":"Gets the size of a bucket","pos":[16768,16793]},{"content":"Parameters","pos":[16866,16876]},{"content":"The bucket number.","pos":[16893,16911]},{"content":"Remarks","pos":[16921,16928]},{"pos":[16932,16997],"content":"The member functions returns the size of bucket number <ph id=\"ph1\">`nbucket`</ph>.","source":"The member functions returns the size of bucket number `nbucket`."},{"content":"Example","pos":[17007,17014]},{"pos":[17977,17998],"content":"unordered_map::cbegin"},{"pos":[18002,18075],"content":"Returns a <ph id=\"ph1\">`const`</ph> iterator that addresses the first element in the range.","source":"Returns a `const` iterator that addresses the first element in the range."},{"content":"Return Value","pos":[18131,18143]},{"pos":[18147,18325],"content":"A <ph id=\"ph1\">`const`</ph> forward-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, <ph id=\"ph2\">`cbegin() == cend()`</ph>).","source":"A `const` forward-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, `cbegin() == cend()`)."},{"content":"Remarks","pos":[18335,18342]},{"pos":[18346,18426],"content":"With the return value of <ph id=\"ph1\">`cbegin`</ph>, the elements in the range cannot be modified.","source":"With the return value of `cbegin`, the elements in the range cannot be modified."},{"content":"You can use this member function in place of the <ph id=\"ph1\">`begin()`</ph> member function to guarantee that the return value is <ph id=\"ph2\">`const_iterator`</ph>.","pos":[18433,18563],"source":"You can use this member function in place of the `begin()` member function to guarantee that the return value is `const_iterator`."},{"content":"Typically, it's used in conjunction with the <bpt id=\"p1\">[</bpt>auto<ept id=\"p1\">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.","pos":[18564,18694],"source":" Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example."},{"content":"In the example, consider <ph id=\"ph1\">`Container`</ph> to be a modifiable (non- <ph id=\"ph2\">`const`</ph>) container of any kind that supports <ph id=\"ph3\">`begin()`</ph> and <ph id=\"ph4\">`cbegin()`</ph>.","pos":[18695,18827],"source":" In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `begin()` and `cbegin()`."},{"pos":[19028,19047],"content":"unordered_map::cend"},{"pos":[19051,19146],"content":"Returns a <ph id=\"ph1\">`const`</ph> iterator that addresses the location just beyond the last element in a range.","source":"Returns a `const` iterator that addresses the location just beyond the last element in a range."},{"content":"Return Value","pos":[19200,19212]},{"pos":[19216,19295],"content":"A <ph id=\"ph1\">`const`</ph> forward-access iterator that points just beyond the end of the range.","source":"A `const` forward-access iterator that points just beyond the end of the range."},{"content":"Remarks","pos":[19305,19312]},{"pos":[19323,19391],"content":"is used to test whether an iterator has passed the end of its range."},{"content":"You can use this member function in place of the <ph id=\"ph1\">`end()`</ph> member function to guarantee that the return value is <ph id=\"ph2\">`const_iterator`</ph>.","pos":[19398,19526],"source":"You can use this member function in place of the `end()` member function to guarantee that the return value is `const_iterator`."},{"content":"Typically, it's used in conjunction with the <bpt id=\"p1\">[</bpt>auto<ept id=\"p1\">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.","pos":[19527,19657],"source":" Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example."},{"content":"In the example, consider <ph id=\"ph1\">`Container`</ph> to be a modifiable (non- <ph id=\"ph2\">`const`</ph>) container of any kind that supports <ph id=\"ph3\">`end()`</ph> and <ph id=\"ph4\">`cend()`</ph>.","pos":[19658,19786],"source":" In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `end()` and `cend()`."},{"pos":[19943,19999],"content":"The value returned by <ph id=\"ph1\">`cend`</ph> should not be dereferenced.","source":"The value returned by `cend` should not be dereferenced."},{"pos":[20046,20066],"content":"unordered_map::clear"},{"content":"Removes all elements.","pos":[20070,20091]},{"content":"Remarks","pos":[20130,20137]},{"pos":[20141,20314],"content":"The member function calls <bpt id=\"p1\">[</bpt>unordered_map::erase<ept id=\"p1\">](#unordered_map__erase)</ept><ph id=\"ph1\">`(`</ph> <bpt id=\"p2\">[</bpt>unordered_map::begin<ept id=\"p2\">](#unordered_map__begin)</ept><ph id=\"ph2\">`(),`</ph> <bpt id=\"p3\">[</bpt>unordered_map::end<ept id=\"p3\">](#unordered_map__end)</ept><ph id=\"ph3\">`())`</ph>.","source":"The member function calls [unordered_map::erase](#unordered_map__erase)`(` [unordered_map::begin](#unordered_map__begin)`(),` [unordered_map::end](#unordered_map__end)`())`."},{"content":"Example","pos":[20324,20331]},{"pos":[21770,21799],"content":"unordered_map::const_iterator"},{"content":"The type of a constant iterator for the controlled sequence.","pos":[21803,21863]},{"content":"Remarks","pos":[21917,21924]},{"content":"The type describes an object that can serve as a constant forward iterator for the controlled sequence.","pos":[21928,22031]},{"content":"It is described here as a synonym for the implementation-defined type <ph id=\"ph1\">`T1`</ph>.","pos":[22032,22107],"source":" It is described here as a synonym for the implementation-defined type `T1`."},{"content":"Example","pos":[22117,22124]},{"pos":[22836,22871],"content":"unordered_map::const_local_iterator"},{"content":"The type of a constant bucket iterator for the controlled sequence.","pos":[22875,22942]},{"content":"Remarks","pos":[23002,23009]},{"content":"The type describes an object that can serve as a constant forward iterator for a bucket.","pos":[23013,23101]},{"content":"It is described here as a synonym for the implementation-defined type <ph id=\"ph1\">`T5`</ph>.","pos":[23102,23177],"source":" It is described here as a synonym for the implementation-defined type `T5`."},{"content":"Example","pos":[23187,23194]},{"pos":[24084,24112],"content":"unordered_map::const_pointer"},{"content":"The type of a constant pointer to an element.","pos":[24116,24161]},{"content":"Remarks","pos":[24232,24239]},{"content":"The type describes an object that can serve as a constant pointer to an element of the controlled sequence.","pos":[24243,24350]},{"content":"Example","pos":[24360,24367]},{"pos":[25114,25144],"content":"unordered_map::const_reference"},{"content":"The type of a constant reference to an element.","pos":[25148,25195]},{"content":"Remarks","pos":[25270,25277]},{"content":"The type describes an object that can serve as a constant reference to an element of the controlled sequence.","pos":[25281,25390]},{"content":"Example","pos":[25400,25407]},{"pos":[26154,26174],"content":"unordered_map::count"},{"content":"Finds the number of elements matching a specified key.","pos":[26178,26232]},{"content":"Parameters","pos":[26299,26309]},{"content":"Key value to search for.","pos":[26325,26349]},{"content":"Remarks","pos":[26359,26366]},{"pos":[26370,26515],"content":"The member function returns the number of elements in the range delimited by <bpt id=\"p1\">[</bpt>unordered_map::equal_range<ept id=\"p1\">](#unordered_map__equal_range)</ept><ph id=\"ph1\">`(keyval)`</ph>.","source":"The member function returns the number of elements in the range delimited by [unordered_map::equal_range](#unordered_map__equal_range)`(keyval)`."},{"content":"Example","pos":[26525,26532]},{"pos":[27482,27512],"content":"unordered_map::difference_type"},{"content":"The type of a signed distance between two elements.","pos":[27516,27567]},{"content":"Remarks","pos":[27622,27629]},{"content":"The signed integer type describes an object that can represent the difference between the addresses of any two elements in the controlled sequence.","pos":[27633,27780]},{"content":"It is described here as a synonym for the implementation-defined type <ph id=\"ph1\">`T3`</ph>.","pos":[27781,27856],"source":" It is described here as a synonym for the implementation-defined type `T3`."},{"content":"Example","pos":[27866,27873]},{"pos":[29052,29074],"content":"unordered_map::emplace"},{"content":"Inserts an element constructed in place (no copy or move operations are performed) into an unordered_map.","pos":[29078,29183]},{"content":"Parameters","pos":[29283,29293]},{"content":"Parameter","pos":[29314,29323]},{"content":"Description","pos":[29324,29335]},{"content":"The arguments forwarded to construct an element to be inserted into the unordered_map unless it already contains an element whose value is equivalently ordered.","pos":[29347,29507]},{"content":"Return Value","pos":[29518,29530]},{"pos":[29534,29840],"content":"A <ph id=\"ph1\">`pair`</ph> whose <ph id=\"ph2\">`bool`</ph> component returns true if an insertion was made and false if the <ph id=\"ph3\">`unordered_map`</ph> already contained an element whose key had an equivalent value in the ordering, and whose iterator component returns the address where a new element was inserted or where the element was already located.","source":"A `pair` whose `bool` component returns true if an insertion was made and false if the `unordered_map` already contained an element whose key had an equivalent value in the ordering, and whose iterator component returns the address where a new element was inserted or where the element was already located."},{"content":"To access the iterator component of a pair <ph id=\"ph1\">`pr`</ph> returned by this member function, use <ph id=\"ph2\">`pr.first`</ph>, and to dereference it, use <ph id=\"ph3\">`*(pr.first)`</ph>.","pos":[29847,29986],"source":"To access the iterator component of a pair `pr` returned by this member function, use `pr.first`, and to dereference it, use `*(pr.first)`."},{"content":"To access the <ph id=\"ph1\">`bool`</ph> component of a pair <ph id=\"ph2\">`pr`</ph> returned by this member function, use <ph id=\"ph3\">`pr.second`</ph>.","pos":[29987,30083],"source":" To access the `bool` component of a pair `pr` returned by this member function, use `pr.second`."},{"content":"Remarks","pos":[30093,30100]},{"content":"No iterators or references are invalidated by this function.","pos":[30104,30164]},{"content":"During the insertion, if an exception is thrown but does not occur in the container's hash function, the container is not modified.","pos":[30171,30302]},{"content":"If the exception is thrown in the hash function, the result is undefined.","pos":[30303,30376]},{"pos":[30383,30469],"content":"For a code example, see <bpt id=\"p1\">[</bpt>map::emplace<ept id=\"p1\">](../standard-library/map-class.md#map__emplace)</ept>.","source":"For a code example, see [map::emplace](../standard-library/map-class.md#map__emplace)."},{"pos":[30523,30550],"content":"unordered_map::emplace_hint"},{"content":"Inserts an element constructed in place (no copy or move operations are performed), with a placement hint.","pos":[30554,30660]},{"content":"Parameters","pos":[30773,30783]},{"content":"Parameter","pos":[30804,30813]},{"content":"Description","pos":[30814,30825]},{"content":"The arguments forwarded to construct an element to be inserted into the unordered_map unless the unordered_map already contains that element or, more generally, unless it already contains an element whose key is equivalently ordered.","pos":[30837,31070]},{"content":"A hint regarding the place to start searching for the correct point of insertion.","pos":[31083,31164]},{"content":"Return Value","pos":[31175,31187]},{"content":"An iterator to the newly inserted element.","pos":[31191,31233]},{"content":"If the insertion failed because the element already exists, returns an iterator to the existing element.","pos":[31240,31344]},{"content":"Remarks","pos":[31354,31361]},{"content":"No references are invalidated by this function.","pos":[31365,31412]},{"content":"During the insertion, if an exception is thrown but does not occur in the container's hash function, the container is not modified.","pos":[31419,31550]},{"content":"If the exception is thrown in the hash function, the result is undefined.","pos":[31551,31624]},{"pos":[31631,31891],"content":"The <bpt id=\"p1\">[</bpt>value_type<ept id=\"p1\">](../standard-library/map-class.md#map__value_type)</ept> of an element is a pair, so that the value of an element will be an ordered pair with the first component equal to the key value and the second component equal to the data value of the element.","source":"The [value_type](../standard-library/map-class.md#map__value_type) of an element is a pair, so that the value of an element will be an ordered pair with the first component equal to the key value and the second component equal to the data value of the element."},{"pos":[31898,31994],"content":"For a code example, see <bpt id=\"p1\">[</bpt>map::emplace_hint<ept id=\"p1\">](../standard-library/map-class.md#map__emplace_hint)</ept>.","source":"For a code example, see [map::emplace_hint](../standard-library/map-class.md#map__emplace_hint)."},{"pos":[32041,32061],"content":"unordered_map::empty"},{"content":"Tests whether no elements are present.","pos":[32065,32103]},{"content":"Remarks","pos":[32148,32155]},{"content":"The member function returns true for an empty controlled sequence.","pos":[32159,32225]},{"content":"Example","pos":[32235,32242]},{"pos":[33667,33685],"content":"unordered_map::end"},{"content":"Designates the end of the controlled sequence.","pos":[33689,33735]},{"content":"Parameters","pos":[33895,33905]},{"content":"Parameter","pos":[33926,33935]},{"content":"Description","pos":[33936,33947]},{"content":"The bucket number.","pos":[33962,33980]},{"content":"Remarks","pos":[33991,33998]},{"content":"The first two member functions return a forward iterator that points just beyond the end of the sequence.","pos":[34002,34107]},{"content":"The last two member functions return a forward iterator that points just beyond the end of bucket <ph id=\"ph1\">`nbucket`</ph>.","pos":[34108,34216],"source":" The last two member functions return a forward iterator that points just beyond the end of bucket `nbucket`."},{"pos":[34269,34295],"content":"unordered_map::equal_range"},{"content":"Finds range that matches a specified key.","pos":[34299,34340]},{"content":"Parameters","pos":[34509,34519]},{"content":"Key value to search for.","pos":[34535,34559]},{"content":"Remarks","pos":[34569,34576]},{"content":"The member function returns a pair of iterators <ph id=\"ph1\">`X`</ph> such that <ph id=\"ph2\">`[X.first, X.second)`</ph> delimits just those elements of the controlled sequence that have equivalent ordering with <ph id=\"ph3\">`keyval`</ph>.","pos":[34580,34764],"source":"The member function returns a pair of iterators `X` such that `[X.first, X.second)` delimits just those elements of the controlled sequence that have equivalent ordering with `keyval`."},{"content":"If no such elements exist, both iterators are <ph id=\"ph1\">`end()`</ph>.","pos":[34765,34819],"source":" If no such elements exist, both iterators are `end()`."},{"content":"Example","pos":[34829,34836]},{"pos":[36218,36238],"content":"unordered_map::erase"},{"content":"Removes an element or a range of elements in a unordered_map from specified positions or removes elements that match a specified key.","pos":[36242,36375]},{"content":"Parameters","pos":[36535,36545]},{"content":"Position of the element to be removed.","pos":[36560,36598]},{"content":"Position of the first element to be removed.","pos":[36616,36660]},{"content":"Position just beyond the last element to be removed.","pos":[36677,36729]},{"content":"The key value of the elements to be removed.","pos":[36745,36789]},{"content":"Return Value","pos":[36799,36811]},{"content":"For the first two member functions, a bidirectional iterator that designates the first element remaining beyond any elements removed, or an element that is the end of the map if no such element exists.","pos":[36815,37016]},{"content":"For the third member function, returns the number of elements that have been removed from the unordered_map.","pos":[37023,37131]},{"content":"Remarks","pos":[37141,37148]},{"pos":[37152,37234],"content":"For a code example, see <bpt id=\"p1\">[</bpt>map::erase<ept id=\"p1\">](../standard-library/map-class.md#map__erase)</ept>.","source":"For a code example, see [map::erase](../standard-library/map-class.md#map__erase)."},{"pos":[37280,37299],"content":"unordered_map::find"},{"content":"Finds an element that matches a specified key.","pos":[37303,37349]},{"content":"Parameters","pos":[37420,37430]},{"content":"Key value to search for.","pos":[37446,37470]},{"content":"Remarks","pos":[37480,37487]},{"pos":[37491,37593],"content":"The member function returns <bpt id=\"p1\">[</bpt>unordered_map::equal_range<ept id=\"p1\">](#unordered_map__equal_range)</ept><ph id=\"ph1\">`(keyval).first`</ph>.","source":"The member function returns [unordered_map::equal_range](#unordered_map__equal_range)`(keyval).first`."},{"content":"Example","pos":[37603,37610]},{"pos":[38717,38745],"content":"unordered_map::get_allocator"},{"content":"Gets the stored allocator object.","pos":[38749,38782]},{"content":"Remarks","pos":[38836,38843]},{"content":"The member function returns the stored allocator object.","pos":[38847,38903]},{"content":"Example","pos":[38913,38920]},{"pos":[39504,39532],"content":"unordered_map::hash_function"},{"content":"Gets the stored hash function object.","pos":[39536,39573]},{"content":"Remarks","pos":[39626,39633]},{"content":"The member function returns the stored hash function object.","pos":[39637,39697]},{"content":"Example","pos":[39707,39714]},{"pos":[40242,40263],"content":"unordered_map::hasher"},{"content":"The type of the hash function.","pos":[40267,40297]},{"content":"Remarks","pos":[40345,40352]},{"pos":[40356,40412],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Hash`</ph>.","source":"The type is a synonym for the template parameter `Hash`."},{"content":"Example","pos":[40422,40429]},{"pos":[40948,40969],"content":"unordered_map::insert"},{"content":"Inserts an element or a range of elements into an unordered_map.","pos":[40973,41037]},{"content":"Parameters","pos":[41707,41717]},{"content":"Parameter","pos":[41738,41747]},{"content":"Description","pos":[41748,41759]},{"content":"The value of an element to be inserted into the unordered_map unless it already contains an element whose key is equivalently ordered.","pos":[41770,41904]},{"content":"The place to start searching for the correct point of insertion.","pos":[41917,41981]},{"pos":[41994,42210],"content":"Template parameter that specifies the argument type that the unordered_map can use to construct an element of <bpt id=\"p1\">[</bpt>value_type<ept id=\"p1\">](../standard-library/map-class.md#map__value_type)</ept>, and perfect-forwards <ph id=\"ph1\">`Val`</ph> as an argument.","source":"Template parameter that specifies the argument type that the unordered_map can use to construct an element of [value_type](../standard-library/map-class.md#map__value_type), and perfect-forwards `Val` as an argument."},{"content":"The position of the first element to be copied.","pos":[42223,42270]},{"content":"The position just beyond the last element to be copied.","pos":[42282,42337]},{"pos":[42358,42621],"content":"Template function argument that meets the requirements of an <bpt id=\"p1\">[</bpt>input iterator<ept id=\"p1\">](../standard-library/input-iterator-tag-struct.md)</ept> that points to elements of a type that can be used to construct <bpt id=\"p2\">[</bpt>value_type<ept id=\"p2\">](../standard-library/map-class.md#map__value_type)</ept> objects.","source":"Template function argument that meets the requirements of an [input iterator](../standard-library/input-iterator-tag-struct.md) that points to elements of a type that can be used to construct [value_type](../standard-library/map-class.md#map__value_type) objects."},{"pos":[42634,42730],"content":"The <bpt id=\"p1\">[</bpt>initializer_list<ept id=\"p1\">](../standard-library/initializer-list.md)</ept> from which to copy the elements.","source":"The [initializer_list](../standard-library/initializer-list.md) from which to copy the elements."},{"content":"Return Value","pos":[42741,42753]},{"content":"The single-element member functions, (1) and (2), return a <bpt id=\"p1\">[</bpt>pair<ept id=\"p1\">](../standard-library/pair-structure.md)</ept> whose <ph id=\"ph1\">`bool`</ph> component is true if an insertion was made, and false if the unordered_map already contained an element whose key had an equivalent value in the ordering.","pos":[42757,43029],"source":"The single-element member functions, (1) and (2), return a [pair](../standard-library/pair-structure.md) whose `bool` component is true if an insertion was made, and false if the unordered_map already contained an element whose key had an equivalent value in the ordering."},{"content":"The iterator component of the return-value pair points to the newly inserted element if the <ph id=\"ph1\">`bool`</ph> component is true, or to the existing element if the <ph id=\"ph2\">`bool`</ph> component is false.","pos":[43030,43208],"source":" The iterator component of the return-value pair points to the newly inserted element if the `bool` component is true, or to the existing element if the `bool` component is false."},{"content":"The single-element-with-hint member functions, (3) and (4), return an iterator that points to the position where the new element was inserted into the unordered_map or, if an element with an equivalent key already exists, to the existing element.","pos":[43215,43461]},{"content":"Remarks","pos":[43471,43478]},{"content":"No iterators, pointers, or references are invalidated by this function.","pos":[43482,43553]},{"content":"During the insertion of just one element, if an exception is thrown but does not occur in the container's hash function, the container's state is not modified.","pos":[43560,43719]},{"content":"If the exception is thrown in the hash function, the result is undefined.","pos":[43720,43793]},{"content":"During the insertion of multiple elements, if an exception is thrown, the container is left in an unspecified but valid state.","pos":[43794,43920]},{"content":"To access the iterator component of a <ph id=\"ph1\">`pair``pr`</ph> that's returned by the single-element member functions, use <ph id=\"ph2\">`pr.first`</ph>; to dereference the iterator within the returned pair, use <ph id=\"ph3\">`*pr.first`</ph>, giving you an element.","pos":[43927,44141],"source":"To access the iterator component of a `pair``pr` that's returned by the single-element member functions, use `pr.first`; to dereference the iterator within the returned pair, use `*pr.first`, giving you an element."},{"content":"To access the <ph id=\"ph1\">`bool`</ph> component, use <ph id=\"ph2\">`pr.second`</ph>.","pos":[44142,44190],"source":" To access the `bool` component, use `pr.second`."},{"content":"For an example, see the sample code later in this article.","pos":[44191,44249]},{"content":"The <bpt id=\"p1\">[</bpt>value_type<ept id=\"p1\">](../standard-library/map-class.md#map__value_type)</ept> of a container is a typedef that belongs to the container, and for map, <ph id=\"ph1\">`map&lt;K, V&gt;::value_type`</ph> is <ph id=\"ph2\">`pair&lt;const K, V&gt;`</ph>.","pos":[44256,44441],"source":"The [value_type](../standard-library/map-class.md#map__value_type) of a container is a typedef that belongs to the container, and for map, `map<K, V>::value_type` is `pair<const K, V>`."},{"content":"The value of an element is an ordered pair in which the first component is equal to the key value and the second component is equal to the data value of the element.","pos":[44442,44607]},{"content":"The range member function (5) inserts the sequence of element values into an unordered_map that corresponds to each element addressed by an iterator in the range <ph id=\"ph1\">`[First, Last)`</ph>; therefore, <ph id=\"ph2\">`Last`</ph> does not get inserted.","pos":[44614,44833],"source":"The range member function (5) inserts the sequence of element values into an unordered_map that corresponds to each element addressed by an iterator in the range `[First, Last)`; therefore, `Last` does not get inserted."},{"content":"The container member function <ph id=\"ph1\">`end()`</ph> refers to the position just after the last element in the container—for example, the statement <ph id=\"ph2\">`m.insert(v.begin(), v.end());`</ph> attempts to insert all elements of <ph id=\"ph3\">`v`</ph> into <ph id=\"ph4\">`m`</ph>.","pos":[44834,45047],"source":" The container member function `end()` refers to the position just after the last element in the container—for example, the statement `m.insert(v.begin(), v.end());` attempts to insert all elements of `v` into `m`."},{"content":"Only elements that have unique values in the range are inserted; duplicates are ignored.","pos":[45048,45136]},{"content":"To observe which elements are rejected, use the single-element versions of <ph id=\"ph1\">`insert`</ph>.","pos":[45137,45221],"source":" To observe which elements are rejected, use the single-element versions of `insert`."},{"pos":[45228,45377],"content":"The initializer list member function (6) uses an <bpt id=\"p1\">[</bpt>initializer_list<ept id=\"p1\">](../standard-library/initializer-list.md)</ept> to copy elements into the unordered_map.","source":"The initializer list member function (6) uses an [initializer_list](../standard-library/initializer-list.md) to copy elements into the unordered_map."},{"pos":[45384,45601],"content":"For insertion of an element constructed in place—that is, no copy or move operations are performed—see <bpt id=\"p1\">[</bpt>unordered_map::emplace<ept id=\"p1\">](#unordered_map__emplace)</ept> and <bpt id=\"p2\">[</bpt>unordered_map::emplace_hint<ept id=\"p2\">](#unordered_map__emplace_hint)</ept>.","source":"For insertion of an element constructed in place—that is, no copy or move operations are performed—see [unordered_map::emplace](#unordered_map__emplace) and [unordered_map::emplace_hint](#unordered_map__emplace_hint)."},{"pos":[45608,45692],"content":"For a code example, see <bpt id=\"p1\">[</bpt>map::insert<ept id=\"p1\">](../standard-library/map-class.md#map__insert)</ept>.","source":"For a code example, see [map::insert](../standard-library/map-class.md#map__insert)."},{"pos":[45742,45765],"content":"unordered_map::iterator"},{"content":"The type of an iterator for the controlled sequence.","pos":[45769,45821]},{"content":"Remarks","pos":[45869,45876]},{"content":"The type describes an object that can serve as a forward iterator for the controlled sequence.","pos":[45880,45974]},{"content":"It is described here as a synonym for the implementation-defined type <ph id=\"ph1\">`T0`</ph>.","pos":[45975,46050],"source":" It is described here as a synonym for the implementation-defined type `T0`."},{"content":"Example","pos":[46060,46067]},{"pos":[46801,46822],"content":"unordered_map::key_eq"},{"content":"Gets the stored comparison function object.","pos":[46826,46869]},{"content":"Remarks","pos":[46915,46922]},{"content":"The member function returns the stored comparison function object.","pos":[46926,46992]},{"content":"Example","pos":[47002,47009]},{"pos":[47664,47688],"content":"unordered_map::key_equal"},{"content":"The type of the comparison function.","pos":[47692,47728]},{"content":"Remarks","pos":[47779,47786]},{"pos":[47790,47846],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Pred`</ph>.","source":"The type is a synonym for the template parameter `Pred`."},{"content":"Example","pos":[47856,47863]},{"pos":[48520,48543],"content":"unordered_map::key_type"},{"content":"The type of an ordering key.","pos":[48547,48575]},{"content":"Remarks","pos":[48624,48631]},{"pos":[48635,48690],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Key`</ph>.","source":"The type is a synonym for the template parameter `Key`."},{"content":"Example","pos":[48700,48707]},{"pos":[49865,49891],"content":"unordered_map::load_factor"},{"content":"Counts the average elements per bucket.","pos":[49895,49934]},{"content":"Remarks","pos":[49986,49993]},{"pos":[49997,50198],"content":"The member function returns <ph id=\"ph1\">`(float)`</ph><bpt id=\"p1\">[</bpt>unordered_map::size<ept id=\"p1\">](#unordered_map__size)</ept><ph id=\"ph2\">`() / (float)`</ph><bpt id=\"p2\">[</bpt>unordered_map::bucket_count<ept id=\"p2\">](#unordered_map__bucket_count)</ept><ph id=\"ph3\">`()`</ph>, the average number of elements per bucket.","source":"The member function returns `(float)`[unordered_map::size](#unordered_map__size)`() / (float)`[unordered_map::bucket_count](#unordered_map__bucket_count)`()`, the average number of elements per bucket."},{"content":"Example","pos":[50208,50215]},{"pos":[52558,52587],"content":"unordered_map::local_iterator"},{"content":"The type of a bucket iterator.","pos":[52591,52621]},{"content":"Remarks","pos":[52675,52682]},{"content":"The type describes an object that can serve as a forward iterator for a bucket.","pos":[52686,52765]},{"content":"It is described here as a synonym for the implementation-defined type <ph id=\"ph1\">`T4`</ph>.","pos":[52766,52841],"source":" It is described here as a synonym for the implementation-defined type `T4`."},{"content":"Example","pos":[52851,52858]},{"pos":[53788,53814],"content":"unordered_map::mapped_type"},{"content":"The type of a mapped value associated with each key.","pos":[53818,53870]},{"content":"Remarks","pos":[53921,53928]},{"pos":[53932,53986],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Ty`</ph>.","source":"The type is a synonym for the template parameter `Ty`."},{"content":"Example","pos":[53996,54003]},{"pos":[55169,55200],"content":"unordered_map::max_bucket_count"},{"content":"Gets the maximum number of buckets.","pos":[55204,55239]},{"content":"Remarks","pos":[55300,55307]},{"content":"The member function returns the maximum number of buckets currently permitted.","pos":[55311,55389]},{"content":"Example","pos":[55399,55406]},{"pos":[57755,57785],"content":"unordered_map::max_load_factor"},{"content":"Gets or sets the maximum elements per bucket.","pos":[57789,57834]},{"content":"Parameters","pos":[57929,57939]},{"content":"The new maximum load factor.","pos":[57955,57983]},{"content":"Remarks","pos":[57993,58000]},{"content":"The first member function returns the stored maximum load factor.","pos":[58004,58069]},{"content":"The second member function replaces the stored maximum load factor with <ph id=\"ph1\">`factor`</ph>.","pos":[58070,58151],"source":" The second member function replaces the stored maximum load factor with `factor`."},{"content":"Example","pos":[58161,58168]},{"pos":[60509,60532],"content":"unordered_map::max_size"},{"content":"Gets the maximum size of the controlled sequence.","pos":[60536,60585]},{"content":"Remarks","pos":[60638,60645]},{"content":"The member function returns the length of the longest sequence that the object can control.","pos":[60649,60740]},{"content":"Example","pos":[60750,60757]},{"pos":[61204,61229],"content":"unordered_map::operator[]"},{"content":"Finds or inserts an element with the specified key.","pos":[61233,61284]},{"content":"Parameters","pos":[61375,61385]},{"content":"Parameter","pos":[61406,61415]},{"content":"Description","pos":[61416,61427]},{"content":"The key value to find or insert.","pos":[61441,61473]},{"content":"Return Value","pos":[61484,61496]},{"content":"A reference to the data value of the inserted element.","pos":[61500,61554]},{"content":"Remarks","pos":[61564,61571]},{"content":"If the argument key value is not found, then it is inserted along with the default value of the data type.","pos":[61575,61681]},{"pos":[61701,61877],"content":"may be used to insert elements into a map <bpt id=\"p1\">*</bpt>m<ept id=\"p1\">*</ept> using <bpt id=\"p2\">*</bpt>m<ept id=\"p2\">*</ept>[_ <bpt id=\"p3\">*</bpt>Key<ept id=\"p3\">*</ept>] = <ph id=\"ph1\">`DataValue`</ph>; where <ph id=\"ph2\">`DataValue`</ph> is the value of the <ph id=\"ph3\">`mapped_type`</ph> of the element with a key value of <ph id=\"ph4\">\\_</ph> <bpt id=\"p4\">*</bpt>Key<ept id=\"p4\">*</ept>.","source":" may be used to insert elements into a map *m* using *m*[_ *Key*] = `DataValue`; where `DataValue` is the value of the `mapped_type` of the element with a key value of \\_ *Key*."},{"content":"When using <ph id=\"ph1\">`operator[]`</ph> to insert elements, the returned reference does not indicate whether an insertion is changing a pre-existing element or creating a new one.","pos":[61884,62047],"source":"When using `operator[]` to insert elements, the returned reference does not indicate whether an insertion is changing a pre-existing element or creating a new one."},{"content":"The member functions <bpt id=\"p1\">[</bpt>find<ept id=\"p1\">](../standard-library/map-class.md#map__find)</ept> and <bpt id=\"p2\">[</bpt>insert<ept id=\"p2\">](../standard-library/map-class.md#map__insert)</ept> can be used to determine whether an element with a specified key is already present before an insertion.","pos":[62048,62283],"source":" The member functions [find](../standard-library/map-class.md#map__find) and [insert](../standard-library/map-class.md#map__insert) can be used to determine whether an element with a specified key is already present before an insertion."},{"content":"Example","pos":[62293,62300]},{"content":"Remarks","pos":[63766,63773]},{"content":"The member function determines the iterator <ph id=\"ph1\">`where`</ph> as the return value of <bpt id=\"p1\">[</bpt>unordered_map::insert<ept id=\"p1\">](#unordered_map__insert)</ept><ph id=\"ph2\">`(`</ph> <bpt id=\"p2\">[</bpt>unordered_map::value_type<ept id=\"p2\">](#unordered_map__value_type)</ept><ph id=\"ph3\">`(keyval, Ty())`</ph>.","pos":[63777,63975],"source":"The member function determines the iterator `where` as the return value of [unordered_map::insert](#unordered_map__insert)`(` [unordered_map::value_type](#unordered_map__value_type)`(keyval, Ty())`."},{"content":"(It inserts an element with the specified key if no such element exists.) It then returns a reference to <ph id=\"ph1\">`(*where).second`</ph>.","pos":[63976,64099],"source":" (It inserts an element with the specified key if no such element exists.) It then returns a reference to `(*where).second`."},{"pos":[64152,64176],"content":"unordered_map::operator="},{"content":"Replaces the elements of this unordered_map using the elements from another unordered_map.","pos":[64180,64270]},{"content":"Parameters","pos":[64399,64409]},{"content":"Parameter","pos":[64430,64439]},{"content":"Description","pos":[64440,64451]},{"content":"The unordered_map that the operator function assigns content from.","pos":[64465,64531]},{"content":"Remarks","pos":[64542,64549]},{"pos":[64553,64634],"content":"The first version copies all of the elements from <ph id=\"ph1\">` right`</ph> to this unordered_map.","source":"The first version copies all of the elements from ` right` to this unordered_map."},{"pos":[64641,64722],"content":"The second version moves all of the elements from <ph id=\"ph1\">` right`</ph> to this unordered_map.","source":"The second version moves all of the elements from ` right` to this unordered_map."},{"pos":[64729,64815],"content":"Any elements that are in this unordered_map before <ph id=\"ph1\">`operator`</ph>= executes are discarded.","source":"Any elements that are in this unordered_map before `operator`= executes are discarded."},{"content":"Example","pos":[64825,64832]},{"pos":[65674,65696],"content":"unordered_map::pointer"},{"content":"The type of a pointer to an element.","pos":[65700,65736]},{"content":"Remarks","pos":[65795,65802]},{"content":"The type describes an object that can serve as a pointer to an element of the controlled sequence.","pos":[65806,65904]},{"content":"Example","pos":[65914,65921]},{"pos":[66717,66741],"content":"unordered_map::reference"},{"content":"The type of a reference to an element.","pos":[66745,66783]},{"content":"Remarks","pos":[66846,66853]},{"content":"The type describes an object that can serve as a reference to an element of the controlled sequence.","pos":[66857,66957]},{"content":"Example","pos":[66967,66974]},{"pos":[67774,67795],"content":"unordered_map::rehash"},{"content":"Rebuilds the hash table.","pos":[67799,67823]},{"content":"Parameters","pos":[67881,67891]},{"content":"The requested number of buckets.","pos":[67909,67941]},{"content":"Remarks","pos":[67951,67958]},{"pos":[67962,68075],"content":"The member function alters the number of buckets to be at least <ph id=\"ph1\">`nbuckets`</ph> and rebuilds the hash table as needed.","source":"The member function alters the number of buckets to be at least `nbuckets` and rebuilds the hash table as needed."},{"content":"Example","pos":[68085,68092]},{"pos":[69988,70007],"content":"unordered_map::size"},{"content":"Counts the number of elements.","pos":[70011,70041]},{"content":"Remarks","pos":[70090,70097]},{"content":"The member function returns the length of the controlled sequence.","pos":[70101,70167]},{"content":"Example","pos":[70177,70184]},{"pos":[71698,71722],"content":"unordered_map::size_type"},{"content":"The type of an unsigned distance between two elements.","pos":[71726,71780]},{"content":"Remarks","pos":[71829,71836]},{"content":"The unsigned integer type describes an object that can represent the length of any controlled sequence.","pos":[71840,71943]},{"content":"It is described here as a synonym for the implementation-defined type <ph id=\"ph1\">`T2`</ph>.","pos":[71944,72019],"source":" It is described here as a synonym for the implementation-defined type `T2`."},{"content":"Example","pos":[72029,72036]},{"pos":[72486,72505],"content":"unordered_map::swap"},{"content":"Swaps the contents of two containers.","pos":[72509,72546]},{"content":"Parameters","pos":[72604,72614]},{"content":"The container to swap with.","pos":[72629,72656]},{"content":"Remarks","pos":[72666,72673]},{"content":"The member function swaps the controlled sequences between <ph id=\"ph1\">`*this`</ph> and <ph id=\"ph2\">`right`</ph>.","pos":[72677,72756],"source":"The member function swaps the controlled sequences between `*this` and `right`."},{"content":"If <bpt id=\"p1\">[</bpt>unordered_map::get_allocator<ept id=\"p1\">](#unordered_map__get_allocator)</ept><ph id=\"ph1\">`() == right.get_allocator()`</ph>, it does so in constant time, it throws an exception only as a result of copying the stored traits object of type <ph id=\"ph2\">`Tr`</ph>, and it invalidates no references, pointers, or iterators that designate elements in the two controlled sequences.","pos":[72757,73084],"source":" If [unordered_map::get_allocator](#unordered_map__get_allocator)`() == right.get_allocator()`, it does so in constant time, it throws an exception only as a result of copying the stored traits object of type `Tr`, and it invalidates no references, pointers, or iterators that designate elements in the two controlled sequences."},{"content":"Otherwise, it performs a number of element assignments and constructor calls proportional to the number of elements in the two controlled sequences.","pos":[73085,73233]},{"content":"Example","pos":[73243,73250]},{"pos":[74712,74740],"content":"unordered_map::unordered_map"},{"content":"Constructs a container object.","pos":[74744,74774]},{"content":"Parameters","pos":[75781,75791]},{"content":"Parameter","pos":[75812,75821]},{"content":"Description","pos":[75822,75833]},{"content":"The allocator object to store.","pos":[75843,75873]},{"content":"The comparison function object to store.","pos":[75885,75925]},{"content":"The hash function object to store.","pos":[75937,75971]},{"content":"The minimum number of buckets.","pos":[75991,76021]},{"content":"The container to copy.","pos":[76034,76056]},{"content":"The initializer_list that contains the elements to be copied.","pos":[76094,76155]},{"content":"Remarks","pos":[76166,76173]},{"content":"The first constructor specifies a copy of the sequence controlled by <ph id=\"ph1\">`right`</ph>.","pos":[76177,76254],"source":"The first constructor specifies a copy of the sequence controlled by `right`."},{"content":"The second constructor specifies an empty controlled sequence.","pos":[76255,76317]},{"content":"The third constructor inserts the sequence of element values <ph id=\"ph1\">`[first, last)`</ph>.","pos":[76318,76395],"source":" The third constructor inserts the sequence of element values `[first, last)`."},{"content":"The fourth constructor specifies a copy of the sequence by moving <ph id=\"ph1\">`right`</ph>.","pos":[76396,76470],"source":" The fourth constructor specifies a copy of the sequence by moving `right`."},{"content":"All constructors also initialize several stored values.","pos":[76477,76532]},{"content":"For the copy constructor, the values are obtained from <ph id=\"ph1\">`Right`</ph>.","pos":[76533,76596],"source":" For the copy constructor, the values are obtained from `Right`."},{"content":"Otherwise:","pos":[76597,76607]},{"pos":[76614,76776],"content":"the minimum number of buckets is the argument <ph id=\"ph1\">`Bucket_count`</ph>, if present; otherwise it is a default value described here as the implementation-defined value <ph id=\"ph2\">`N0`</ph>.","source":"the minimum number of buckets is the argument `Bucket_count`, if present; otherwise it is a default value described here as the implementation-defined value `N0`."},{"pos":[76783,76869],"content":"the hash function object is the argument <ph id=\"ph1\">`Hash`</ph>, if present; otherwise it is <ph id=\"ph2\">`Hash()`</ph>.","source":"the hash function object is the argument `Hash`, if present; otherwise it is `Hash()`."},{"pos":[76876,76968],"content":"The comparison function object is the argument <ph id=\"ph1\">`Comp`</ph>, if present; otherwise it is <ph id=\"ph2\">`Pred()`</ph>.","source":"The comparison function object is the argument `Comp`, if present; otherwise it is `Pred()`."},{"pos":[76975,77057],"content":"The allocator object is the argument <ph id=\"ph1\">`Al`</ph>, if present; otherwise, it is <ph id=\"ph2\">`Alloc()`</ph>.","source":"The allocator object is the argument `Al`, if present; otherwise, it is `Alloc()`."},{"content":"Example","pos":[77067,77074]},{"pos":[80690,80715],"content":"unordered_map::value_type"},{"content":"The type of an element.","pos":[80719,80742]},{"content":"Remarks","pos":[80814,80821]},{"content":"The type describes an element of the controlled sequence.","pos":[80825,80882]},{"content":"Example","pos":[80892,80899]},{"content":"See Also","pos":[81941,81949]},{"content":"&lt;unordered_map&gt;","pos":[81954,81969],"source":"<unordered_map>"},{"content":"Containers","pos":[82014,82024]},{"content":"Thread Safety in the C++ Standard Library","pos":[82064,82105]},{"content":"C++ Standard Library Reference","pos":[82178,82208]}],"content":"---\ntitle: \"unordered_map Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std::tr1::unordered_map\"\n  - \"std.tr1.unordered_map\"\n  - \"tr1.unordered_map\"\n  - \"tr1::unordered_map\"\n  - \"unordered_map\"\n  - \"unordered_map/std::tr1::unordered_map\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"unordered_map class\"\n  - \"unordered_map class [TR1]\"\nms.assetid: 7cf7cfa1-16e7-461c-a9b2-3b8d8ec24e0d\ncaps.latest.revision: 20\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# unordered_map Class\nThe template class describes an object that controls a varying-length sequence of elements of type `std::pair<const Key, Ty>`. The sequence is weakly ordered by a hash function, which partitions the sequence into an ordered set of subsequences called buckets. Within each bucket a comparison function determines whether any pair of elements has equivalent ordering. Each element stores two objects, a sort key and a value. The sequence is represented in a way that permits lookup, insertion, and removal of an arbitrary element with a number of operations that can be independent of the number of elements in the sequence (constant time), at least when all buckets are of roughly equal length. In the worst case, when all of the elements are in one bucket, the number of operations is proportional to the number of elements in the sequence (linear time). Moreover, inserting an element invalidates no iterators, and removing an element invalidates only those iterators which point at the removed element.  \n  \n## Syntax  \n  \n```  \ntemplate <class Key,  \n    class Ty,  \n    class Hash = std::hash<Key>,  \n    class Pred = std::equal_to<Key>,  \n    class Alloc = std::allocator<std::pair<const Key, Ty>>>  \nclass unordered_map;  \n```  \n  \n#### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`Key`|The key type.|  \n|`Ty`|The mapped type.|  \n|`Hash`|The hash function object type.|  \n|`Pred`|The equality comparison function object type.|  \n|`Alloc`|The allocator class.|  \n  \n## Members  \n  \n|||  \n|-|-|  \n|Type Definition|Description|  \n|[unordered_map::allocator_type](#unordered_map__allocator_type)|The type of an allocator for managing storage.|  \n|[unordered_map::const_iterator](#unordered_map__const_iterator)|The type of a constant iterator for the controlled sequence.|  \n|[unordered_map::const_local_iterator](#unordered_map__const_local_iterator)|The type of a constant bucket iterator for the controlled sequence.|  \n|[unordered_map::const_pointer](#unordered_map__const_pointer)|The type of a constant pointer to an element.|  \n|[unordered_map::const_reference](#unordered_map__const_reference)|The type of a constant reference to an element.|  \n|[unordered_map::difference_type](#unordered_map__difference_type)|The type of a signed distance between two elements.|  \n|[unordered_map::hasher](#unordered_map__hasher)|The type of the hash function.|  \n|[unordered_map::iterator](#unordered_map__iterator)|The type of an iterator for the controlled sequence.|  \n|[unordered_map::key_equal](#unordered_map__key_equal)|The type of the comparison function.|  \n|[unordered_map::key_type](#unordered_map__key_type)|The type of an ordering key.|  \n|[unordered_map::local_iterator](#unordered_map__local_iterator)|The type of a bucket iterator for the controlled sequence.|  \n|[unordered_map::mapped_type](#unordered_map__mapped_type)|The type of a mapped value associated with each key.|  \n|[unordered_map::pointer](#unordered_map__pointer)|The type of a pointer to an element.|  \n|[unordered_map::reference](#unordered_map__reference)|The type of a reference to an element.|  \n|[unordered_map::size_type](#unordered_map__size_type)|The type of an unsigned distance between two elements.|  \n|[unordered_map::value_type](#unordered_map__value_type)|The type of an element.|  \n  \n|||  \n|-|-|  \n|Member Function|Description|  \n|[unordered_map::at](#unordered_map__at)|Finds an element with the specified key.|  \n|[unordered_map::begin](#unordered_map__begin)|Designates the beginning of the controlled sequence.|  \n|[unordered_map::bucket](#unordered_map__bucket)|Gets the bucket number for a key value.|  \n|[unordered_map::bucket_count](#unordered_map__bucket_count)|Gets the number of buckets.|  \n|[unordered_map::bucket_size](#unordered_map__bucket_size)|Gets the size of a bucket.|  \n|[unordered_map::cbegin](#unordered_map__cbegin)|Designates the beginning of the controlled sequence.|  \n|[unordered_map::cend](#unordered_map__cend)|Designates the end of the controlled sequence.|  \n|[unordered_map::clear](#unordered_map__clear)|Removes all elements.|  \n|[unordered_map::count](#unordered_map__count)|Finds the number of elements matching a specified key.|  \n|[unordered_map::emplace](#unordered_map__emplace)|Adds an element constructed in place.|  \n|[unordered_map::emplace_hint](#unordered_map__emplace_hint)|Adds an element constructed in place, with hint.|  \n|[unordered_map::empty](#unordered_map__empty)|Tests whether no elements are present.|  \n|[unordered_map::end](#unordered_map__end)|Designates the end of the controlled sequence.|  \n|[unordered_map::equal_range](#unordered_map__equal_range)|Finds range that matches a specified key.|  \n|[unordered_map::erase](#unordered_map__erase)|Removes elements at specified positions.|  \n|[unordered_map::find](#unordered_map__find)|Finds an element that matches a specified key.|  \n|[unordered_map::get_allocator](#unordered_map__get_allocator)|Gets the stored allocator object.|  \n|[unordered_map::hash_function](#unordered_map__hash_function)|Gets the stored hash function object.|  \n|[unordered_map::insert](#unordered_map__insert)|Adds elements.|  \n|[unordered_map::key_eq](#unordered_map__key_eq)|Gets the stored comparison function object.|  \n|[unordered_map::load_factor](#unordered_map__load_factor)|Counts the average elements per bucket.|  \n|[unordered_map::max_bucket_count](#unordered_map__max_bucket_count)|Gets the maximum number of buckets.|  \n|[unordered_map::max_load_factor](#unordered_map__max_load_factor)|Gets or sets the maximum elements per bucket.|  \n|[unordered_map::max_size](#unordered_map__max_size)|Gets the maximum size of the controlled sequence.|  \n|[unordered_map::rehash](#unordered_map__rehash)|Rebuilds the hash table.|  \n|[unordered_map::size](#unordered_map__size)|Counts the number of elements.|  \n|[unordered_map::swap](#unordered_map__swap)|Swaps the contents of two containers.|  \n|[unordered_map::unordered_map](#unordered_map__unordered_map)|Constructs a container object.|  \n  \n|||  \n|-|-|  \n|Operator|Description|  \n|[unordered_map::operator[]](#unordered_map__operator_at)|Finds or inserts an element with the specified key.|  \n|[unordered_map::operator=](#unordered_map__operator_eq)|Copies a hash table.|  \n  \n## Remarks  \n The object orders the sequence it controls by calling two stored objects, a comparison function object of type [unordered_map::key_equal](#unordered_map__key_equal) and a hash function object of type [unordered_map::hasher](#unordered_map__hasher). You access the first stored object by calling the member function [unordered_map::key_eq](#unordered_map__key_eq)`()`; and you access the second stored object by calling the member function [unordered_map::hash_function](#unordered_map__hash_function)`()`. Specifically, for all values `X` and `Y` of type `Key`, the call `key_eq()(X, Y)` returns true only if the two argument values have equivalent ordering; the call `hash_function()(keyval)` yields a distribution of values of type `size_t`. Unlike template class [unordered_multimap Class](../standard-library/unordered-multimap-class.md), an object of template class `unordered_map` ensures that `key_eq()(X, Y)` is always false for any two elements of the controlled sequence. (Keys are unique.)  \n  \n The object also stores a maximum load factor, which specifies the maximum desired average number of elements per bucket. If inserting an element causes [unordered_map::load_factor](#unordered_map__load_factor)`()` to exceed the maximum load factor, the container increases the number of buckets and rebuilds the hash table as needed.  \n  \n The actual order of elements in the controlled sequence depends on the hash function, the comparison function, the order of insertion, the maximum load factor, and the current number of buckets. You cannot in general predict the order of elements in the controlled sequence. You can always be assured, however, that any subset of elements that have equivalent ordering are adjacent in the controlled sequence.  \n  \n The object allocates and frees storage for the sequence it controls through a stored allocator object of type [unordered_map::allocator_type](#unordered_map__allocator_type). Such an allocator object must have the same external interface as an object of template class `allocator`. Note that the stored allocator object is not copied when the container object is assigned.  \n  \n## Requirements  \n **Header:** <unordered_map>  \n  \n **Namespace:** std  \n  \n##  <a name=\"unordered_map__allocator_type\"></a>  unordered_map::allocator_type  \n The type of an allocator for managing storage.  \n  \n```  \ntypedef Alloc allocator_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `Alloc`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_allocator_type.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;\ntypedef std::allocator<std::pair<const char, int> > Myalloc;\nint main()\n{\n    Mymap c1;\n\n    Mymap::allocator_type al = c1.get_allocator();\n    std::cout << \"al == std::allocator() is \"\n        << std::boolalpha << (al == Myalloc()) << std::endl;\n\n    return (0);\n}\n  \n```  \n  \n```Output  \nal == std::allocator() is true  \n```  \n  \n##  <a name=\"unordered_map__at\"></a>  unordered_map::at  \n Finds an element in a unordered_map with a specified key value.  \n  \n```  \nTy& at(const Key& key);\nconst Ty& at(const Key& key) const;\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` key`|The key value to find.|  \n  \n### Return Value  \n A reference to the data value of the element found.  \n  \n### Remarks  \n If the argument key value is not found, then the function throws an object of class `out_of_range`.  \n  \n### Example  \n  \n```cpp  \n// unordered_map_at.cpp  \n// compile with: /EHsc  \n#include <unordered_map>  \n#include <iostream>  \n  \ntypedef std::unordered_map<char, int> Mymap;   \ntypedef std::unordered_map<char, int> Mymap;\nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // find and show elements  \n    std::cout << \"c1.at('a') == \" << c1.at('a') << std::endl;\n    std::cout << \"c1.at('b') == \" << c1.at('b') << std::endl;\n    std::cout << \"c1.at('c') == \" << c1.at('c') << std::endl;\n\n    return (0);\n}  \n```  \n  \n##  <a name=\"unordered_map__begin\"></a>  unordered_map::begin  \n Designates the beginning of the controlled sequence or a bucket.  \n  \n```  \niterator begin();\nconst_iterator begin() const; \nlocal_iterator begin(size_type nbucket);\nconst_local_iterator begin(size_type nbucket) const;\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`nbucket`|The bucket number.|  \n  \n### Remarks  \n The first two member functions return a forward iterator that points at the first element of the sequence (or just beyond the end of an empty sequence). The last two member functions return a forward iterator that points at the first element of bucket `nbucket` (or just beyond the end of an empty bucket).  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_begin.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \n#typedef std::unordered_map<char, int> Mymap;\nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    // inspect first two items \" [c 3] [b 2]\"   \n    Mymap::iterator it2 = c1.begin();\n    std::cout << \" [\" << it2->first << \", \" << it2->second << \"]\";\n    ++it2;\n    std::cout << \" [\" << it2->first << \", \" << it2->second << \"]\";\n    std::cout << std::endl;\n\n    // inspect bucket containing 'a'   \n    Mymap::const_local_iterator lit = c1.begin(c1.bucket('a'));\n    std::cout << \" [\" << lit->first << \", \" << lit->second << \"]\";\n\n    return (0);\n}\n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n[c, 3] [b, 2]  \n[a, 1]  \n```  \n  \n##  <a name=\"unordered_map__bucket\"></a>  unordered_map::bucket  \n Gets the bucket number for a key value.  \n  \n```  \nsize_type bucket(const Key& keyval) const;\n```  \n  \n### Parameters  \n `keyval`  \n The key value to map.  \n  \n### Remarks  \n The member function returns the bucket number currently corresponding to the key value `keyval`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_bucket.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;\nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    // display buckets for keys   \n    Mymap::size_type bs = c1.bucket('a');\n    std::cout << \"bucket('a') == \" << bs << std::endl;\n    std::cout << \"bucket_size(\" << bs << \") == \" << c1.bucket_size(bs)\n        << std::endl;\n\n    return (0);\n}\n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nbucket('a') == 7  \nbucket_size(7) == 1  \n```  \n  \n##  <a name=\"unordered_map__bucket_count\"></a>  unordered_map::bucket_count  \n Gets the number of buckets.  \n  \n```  \nsize_type bucket_count() const;\n```  \n  \n### Remarks  \n The member function returns the current number of buckets.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_bucket_count.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;\nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    // inspect current parameters   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;\n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;\n    std::cout << \"max_bucket_count() == \"\n        << c1.max_bucket_count() << std::endl;\n    std::cout << \"max_load_factor() == \"\n        << c1.max_load_factor() << std::endl;\n    std::cout << std::endl;\n\n    // change max_load_factor and redisplay   \n    c1.max_load_factor(0.10f);\n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;\n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;\n    std::cout << \"max_bucket_count() == \"\n        << c1.max_bucket_count() << std::endl;\n    std::cout << \"max_load_factor() == \"\n        << c1.max_load_factor() << std::endl;\n    std::cout << std::endl;\n\n    // rehash and redisplay   \n    c1.rehash(100);\n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;\n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;\n    std::cout << \"max_bucket_count() == \"\n        << c1.max_bucket_count() << std::endl;\n    std::cout << \"max_load_factor() == \"\n        << c1.max_load_factor() << std::endl;\n    std::cout << std::endl;\n\n    return (0);\n}\n\n```\n\n```Output\n[c, 3][b, 2][a, 1]\nbucket_count() == 8\nload_factor() == 0.375\nmax_bucket_count() == 8\nmax_load_factor() == 4\n\nbucket_count() == 8\nload_factor() == 0.375\nmax_bucket_count() == 8\nmax_load_factor() == 0.1\n\nbucket_count() == 128\nload_factor() == 0.0234375\nmax_bucket_count() == 128\nmax_load_factor() == 0.1\n\n```  \n  \n##  <a name=\"unordered_map__bucket_size\"></a>  unordered_map::bucket_size  \n Gets the size of a bucket  \n  \n```  \nsize_type bucket_size(size_type nbucket) const;\n```  \n  \n### Parameters  \n `nbucket`  \n The bucket number.  \n  \n### Remarks  \n The member functions returns the size of bucket number `nbucket`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_bucket_size.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    // display buckets for keys   \n    Mymap::size_type bs = c1.bucket('a');\n    std::cout << \"bucket('a') == \" << bs << std::endl;\n    std::cout << \"bucket_size(\" << bs << \") == \" << c1.bucket_size(bs)\n        << std::endl;\n\n    return (0);\n}\n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nbucket('a') == 7  \nbucket_size(7) == 1  \n```  \n  \n##  <a name=\"unordered_map__cbegin\"></a>  unordered_map::cbegin  \n Returns a `const` iterator that addresses the first element in the range.  \n  \n```  \nconst_iterator cbegin() const;\n```  \n  \n### Return Value  \n A `const` forward-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, `cbegin() == cend()`).  \n  \n### Remarks  \n With the return value of `cbegin`, the elements in the range cannot be modified.  \n  \n You can use this member function in place of the `begin()` member function to guarantee that the return value is `const_iterator`. Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example. In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `begin()` and `cbegin()`.  \n  \n```cpp  \n \nauto i1 = Container.begin();\n// i1 is Container<T>::iterator   \nauto i2 = Container.cbegin();\n\n// i2 is Container<T>::const_iterator  \n```  \n  \n##  <a name=\"unordered_map__cend\"></a>  unordered_map::cend  \n Returns a `const` iterator that addresses the location just beyond the last element in a range.  \n  \n```  \nconst_iterator cend() const;\n```  \n  \n### Return Value  \n A `const` forward-access iterator that points just beyond the end of the range.  \n  \n### Remarks  \n `cend` is used to test whether an iterator has passed the end of its range.  \n  \n You can use this member function in place of the `end()` member function to guarantee that the return value is `const_iterator`. Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example. In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `end()` and `cend()`.  \n  \n```cpp  \n \nauto i1 = Container.end();\n// i1 is Container<T>::iterator   \nauto i2 = Container.cend();\n// i2 is Container<T>::const_iterator  \n```  \n  \n The value returned by `cend` should not be dereferenced.  \n  \n##  <a name=\"unordered_map__clear\"></a>  unordered_map::clear  \n Removes all elements.  \n  \n```  \nvoid clear();\n```  \n  \n### Remarks  \n The member function calls [unordered_map::erase](#unordered_map__erase)`(` [unordered_map::begin](#unordered_map__begin)`(),` [unordered_map::end](#unordered_map__end)`())`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_clear.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    // clear the container and reinspect   \n    c1.clear();\n    std::cout << \"size == \" << c1.size() << std::endl;\n    std::cout << \"empty() == \" << std::boolalpha << c1.empty() << std::endl;\n    std::cout << std::endl;\n\n    c1.insert(Mymap::value_type('d', 4));\n    c1.insert(Mymap::value_type('e', 5));\n\n    // display contents \" [e 5] [d 4]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    std::cout << \"size == \" << c1.size() << std::endl;\n    std::cout << \"empty() == \" << std::boolalpha << c1.empty() << std::endl;\n\n    return (0);\n}\n  \n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nsize == 0  \nempty() == true  \n  \n [e, 5] [d, 4]  \nsize == 2  \nempty() == false  \n```  \n  \n##  <a name=\"unordered_map__const_iterator\"></a>  unordered_map::const_iterator  \n The type of a constant iterator for the controlled sequence.  \n  \n```  \ntypedef T1 const_iterator;  \n```  \n  \n### Remarks  \n The type describes an object that can serve as a constant forward iterator for the controlled sequence. It is described here as a synonym for the implementation-defined type `T1`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_const_iterator.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;\nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    return (0);\n}\n  \n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n```  \n  \n##  <a name=\"unordered_map__const_local_iterator\"></a>  unordered_map::const_local_iterator  \n The type of a constant bucket iterator for the controlled sequence.  \n  \n```  \ntypedef T5 const_local_iterator;  \n```  \n  \n### Remarks  \n The type describes an object that can serve as a constant forward iterator for a bucket. It is described here as a synonym for the implementation-defined type `T5`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_const_local_iterator.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n\ntypedef std::unordered_map<char, int> Mymap;\nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    // inspect bucket containing 'a'   \n    Mymap::const_local_iterator lit = c1.begin(c1.bucket('a'));\n    std::cout << \" [\" << lit->first << \", \" << lit->second << \"]\";\n\n    return (0);\n}\n  \n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n[a, 1]  \n```  \n  \n##  <a name=\"unordered_map__const_pointer\"></a>  unordered_map::const_pointer  \n The type of a constant pointer to an element.  \n  \n```  \ntypedef Alloc::const_pointer const_pointer;  \n```  \n  \n### Remarks  \n The type describes an object that can serve as a constant pointer to an element of the controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_const_pointer.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n\ntypedef std::unordered_map<char, int> Mymap;\nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::iterator it = c1.begin();\n        it != c1.end(); ++it)\n    {\n        Mymap::const_pointer p = &*it;\n        std::cout << \" [\" << p->first << \", \" << p->second << \"]\";\n    }\n    std::cout << std::endl;\n\n    return (0);\n}\n  \n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n```  \n  \n##  <a name=\"unordered_map__const_reference\"></a>  unordered_map::const_reference  \n The type of a constant reference to an element.  \n  \n```  \ntypedef Alloc::const_reference const_reference;  \n```  \n  \n### Remarks  \n The type describes an object that can serve as a constant reference to an element of the controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_const_reference.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::iterator it = c1.begin();\n        it != c1.end(); ++it)\n    {\n        Mymap::const_reference ref = *it;\n        std::cout << \" [\" << ref.first << \", \" << ref.second << \"]\";\n    }\n    std::cout << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n```  \n  \n##  <a name=\"unordered_map__count\"></a>  unordered_map::count  \n Finds the number of elements matching a specified key.  \n  \n```  \nsize_type count(const Key& keyval) const;\n```  \n  \n### Parameters  \n `keyval`  \n Key value to search for.  \n  \n### Remarks  \n The member function returns the number of elements in the range delimited by [unordered_map::equal_range](#unordered_map__equal_range)`(keyval)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_count.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    std::cout << \"count('A') == \" << c1.count('A') << std::endl;\n    std::cout << \"count('b') == \" << c1.count('b') << std::endl;\n    std::cout << \"count('C') == \" << c1.count('C') << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \ncount('A') == 0  \ncount('b') == 1  \ncount('C') == 0  \n```  \n  \n##  <a name=\"unordered_map__difference_type\"></a>  unordered_map::difference_type  \n The type of a signed distance between two elements.  \n  \n```  \ntypedef T3 difference_type;  \n```  \n  \n### Remarks  \n The signed integer type describes an object that can represent the difference between the addresses of any two elements in the controlled sequence. It is described here as a synonym for the implementation-defined type `T3`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_difference_type.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    // compute positive difference   \n    Mymap::difference_type diff = 0;\n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        ++diff;\n    std::cout << \"end()-begin() == \" << diff << std::endl;\n\n    // compute negative difference   \n    diff = 0;\n    for (Mymap::const_iterator it = c1.end();\n        it != c1.begin(); --it)\n        --diff;\n    std::cout << \"begin()-end() == \" << diff << std::endl;\n\n    return (0);\n}\n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nend()-begin() == 3  \nbegin()-end() == -3  \n```  \n  \n##  <a name=\"unordered_map__emplace\"></a>  unordered_map::emplace  \n Inserts an element constructed in place (no copy or move operations are performed) into an unordered_map.  \n  \n```  \ntemplate <class... Args>  \npair<iterator, bool>  emplace( Args&&... args);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`args`|The arguments forwarded to construct an element to be inserted into the unordered_map unless it already contains an element whose value is equivalently ordered.|  \n  \n### Return Value  \n A `pair` whose `bool` component returns true if an insertion was made and false if the `unordered_map` already contained an element whose key had an equivalent value in the ordering, and whose iterator component returns the address where a new element was inserted or where the element was already located.  \n  \n To access the iterator component of a pair `pr` returned by this member function, use `pr.first`, and to dereference it, use `*(pr.first)`. To access the `bool` component of a pair `pr` returned by this member function, use `pr.second`.  \n  \n### Remarks  \n No iterators or references are invalidated by this function.  \n  \n During the insertion, if an exception is thrown but does not occur in the container's hash function, the container is not modified. If the exception is thrown in the hash function, the result is undefined.  \n  \n For a code example, see [map::emplace](../standard-library/map-class.md#map__emplace).  \n  \n##  <a name=\"unordered_map__emplace_hint\"></a>  unordered_map::emplace_hint  \n Inserts an element constructed in place (no copy or move operations are performed), with a placement hint.  \n  \n```  \ntemplate <class... Args>  \niterator emplace_hint(const_iterator where, Args&&... args);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`args`|The arguments forwarded to construct an element to be inserted into the unordered_map unless the unordered_map already contains that element or, more generally, unless it already contains an element whose key is equivalently ordered.|  \n|`where`|A hint regarding the place to start searching for the correct point of insertion.|  \n  \n### Return Value  \n An iterator to the newly inserted element.  \n  \n If the insertion failed because the element already exists, returns an iterator to the existing element.  \n  \n### Remarks  \n No references are invalidated by this function.  \n  \n During the insertion, if an exception is thrown but does not occur in the container's hash function, the container is not modified. If the exception is thrown in the hash function, the result is undefined.  \n  \n The [value_type](../standard-library/map-class.md#map__value_type) of an element is a pair, so that the value of an element will be an ordered pair with the first component equal to the key value and the second component equal to the data value of the element.  \n  \n For a code example, see [map::emplace_hint](../standard-library/map-class.md#map__emplace_hint).  \n  \n##  <a name=\"unordered_map__empty\"></a>  unordered_map::empty  \n Tests whether no elements are present.  \n  \n```  \nbool empty() const;\n```  \n  \n### Remarks  \n The member function returns true for an empty controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_empty.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    // clear the container and reinspect   \n    c1.clear();\n    std::cout << \"size == \" << c1.size() << std::endl;\n    std::cout << \"empty() == \" << std::boolalpha << c1.empty() << std::endl;\n    std::cout << std::endl;\n\n    c1.insert(Mymap::value_type('d', 4));\n    c1.insert(Mymap::value_type('e', 5));\n\n    // display contents \" [e 5] [d 4]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    std::cout << \"size == \" << c1.size() << std::endl;\n    std::cout << \"empty() == \" << std::boolalpha << c1.empty() << std::endl;\n\n    return (0);\n}\n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nsize == 0  \nempty() == true  \n  \n [e, 5] [d, 4]  \nsize == 2  \nempty() == false  \n```  \n  \n##  <a name=\"unordered_map__end\"></a>  unordered_map::end  \n Designates the end of the controlled sequence.  \n  \n```  \niterator end();\nconst_iterator end() const; \nlocal_iterator end(size_type nbucket);\nconst_local_iterator end(size_type nbucket) const;\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`nbucket`|The bucket number.|  \n  \n### Remarks  \n The first two member functions return a forward iterator that points just beyond the end of the sequence. The last two member functions return a forward iterator that points just beyond the end of bucket `nbucket`.  \n  \n##  <a name=\"unordered_map__equal_range\"></a>  unordered_map::equal_range  \n Finds range that matches a specified key.  \n  \n```  \nstd::pair<iterator, iterator>  equal_range(const Key& keyval);\nstd::pair<const_iterator, const_iterator>  equal_range(const Key& keyval) const;\n```  \n  \n### Parameters  \n `keyval`  \n Key value to search for.  \n  \n### Remarks  \n The member function returns a pair of iterators `X` such that `[X.first, X.second)` delimits just those elements of the controlled sequence that have equivalent ordering with `keyval`. If no such elements exist, both iterators are `end()`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_equal_range.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;\nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    // display results of failed search   \n    std::pair<Mymap::iterator, Mymap::iterator> pair1 =\n        c1.equal_range('x');\n    std::cout << \"equal_range('x'):\";\n    for (; pair1.first != pair1.second; ++pair1.first)\n        std::cout << \" [\" << pair1.first->first\n        << \", \" << pair1.first->second << \"]\";\n    std::cout << std::endl;\n\n    // display results of successful search   \n    pair1 = c1.equal_range('b');\n    std::cout << \"equal_range('b'):\";\n    for (; pair1.first != pair1.second; ++pair1.first)\n        std::cout << \" [\" << pair1.first->first\n        << \", \" << pair1.first->second << \"]\";\n    std::cout << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nequal_range('x'):  \nequal_range('b'): [b, 2]  \n```  \n  \n##  <a name=\"unordered_map__erase\"></a>  unordered_map::erase  \n Removes an element or a range of elements in a unordered_map from specified positions or removes elements that match a specified key.  \n  \n```  \niterator erase(const_iterator Where);\niterator erase(const_iterator First, const_iterator Last);\nsize_type erase(const key_type& Key);\n```  \n  \n### Parameters  \n `Where`  \n Position of the element to be removed.  \n  \n `First`  \n Position of the first element to be removed.  \n  \n `Last`  \n Position just beyond the last element to be removed.  \n  \n `Key`  \n The key value of the elements to be removed.  \n  \n### Return Value  \n For the first two member functions, a bidirectional iterator that designates the first element remaining beyond any elements removed, or an element that is the end of the map if no such element exists.  \n  \n For the third member function, returns the number of elements that have been removed from the unordered_map.  \n  \n### Remarks  \n For a code example, see [map::erase](../standard-library/map-class.md#map__erase).  \n  \n##  <a name=\"unordered_map__find\"></a>  unordered_map::find  \n Finds an element that matches a specified key.  \n  \n```  \nconst_iterator find(const Key& keyval) const;\n```  \n  \n### Parameters  \n `keyval`  \n Key value to search for.  \n  \n### Remarks  \n The member function returns [unordered_map::equal_range](#unordered_map__equal_range)`(keyval).first`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_find.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    // try to find and fail   \n    std::cout << \"find('A') == \"\n        << std::boolalpha << (c1.find('A') != c1.end()) << std::endl;\n\n    // try to find and succeed   \n    Mymap::iterator it = c1.find('b');\n    std::cout << \"find('b') == \"\n        << std::boolalpha << (it != c1.end())\n        << \": [\" << it->first << \", \" << it->second << \"]\" << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nfind('A') == false  \nfind('b') == true: [b, 2]  \n```  \n  \n##  <a name=\"unordered_map__get_allocator\"></a>  unordered_map::get_allocator  \n Gets the stored allocator object.  \n  \n```  \nAlloc get_allocator() const;\n```  \n  \n### Remarks  \n The member function returns the stored allocator object.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_get_allocator.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \ntypedef std::allocator<std::pair<const char, int> > Myalloc;\nint main()\n{\n    Mymap c1;\n\n    Mymap::allocator_type al = c1.get_allocator();\n    std::cout << \"al == std::allocator() is \"\n        << std::boolalpha << (al == Myalloc()) << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \nal == std::allocator() is true  \n```  \n  \n##  <a name=\"unordered_map__hash_function\"></a>  unordered_map::hash_function  \n Gets the stored hash function object.  \n  \n```  \nHash hash_function() const;\n```  \n  \n### Remarks  \n The member function returns the stored hash function object.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_hash_function.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;\nint main()\n{\n    Mymap c1;\n\n    Mymap::hasher hfn = c1.hash_function();\n    std::cout << \"hfn('a') == \" << hfn('a') << std::endl;\n    std::cout << \"hfn('b') == \" << hfn('b') << std::endl;\n\n    return (0);\n}\n  \n```  \n  \n```Output  \nhfn('a') == 1630279  \nhfn('b') == 1647086  \n```  \n  \n##  <a name=\"unordered_map__hasher\"></a>  unordered_map::hasher  \n The type of the hash function.  \n  \n```  \ntypedef Hash hasher;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `Hash`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_hasher.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;\nint main()\n{\n    Mymap c1;\n\n    Mymap::hasher hfn = c1.hash_function();\n    std::cout << \"hfn('a') == \" << hfn('a') << std::endl;\n    std::cout << \"hfn('b') == \" << hfn('b') << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \nhfn('a') == 1630279  \nhfn('b') == 1647086  \n```  \n  \n##  <a name=\"unordered_map__insert\"></a>  unordered_map::insert  \n Inserts an element or a range of elements into an unordered_map.  \n  \n```  \n// (1) single element  \npair<iterator, bool> insert(    const value_type& Val);\n\n \n// (2) single element, perfect forwarded  \ntemplate <class ValTy>  \npair<iterator, bool>  \ninsert(    ValTy&& Val);\n\n \n// (3) single element with hint  \niterator insert(    const_iterator Where,  \n    const value_type& Val);\n\n \n// (4) single element, perfect forwarded, with hint  \ntemplate <class ValTy>  \niterator insert(    const_iterator Where,  \n    ValTy&& Val);\n\n \n// (5) range   \ntemplate <class InputIterator>   \nvoid insert(InputIterator First,  \n    InputIterator Last);\n\n \n// (6) initializer list  \nvoid insert(initializer_list<value_type>  \nIList);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`Val`|The value of an element to be inserted into the unordered_map unless it already contains an element whose key is equivalently ordered.|  \n|`Where`|The place to start searching for the correct point of insertion.|  \n|`ValTy`|Template parameter that specifies the argument type that the unordered_map can use to construct an element of [value_type](../standard-library/map-class.md#map__value_type), and perfect-forwards `Val` as an argument.|  \n|`First`|The position of the first element to be copied.|  \n|`Last`|The position just beyond the last element to be copied.|  \n|`InputIterator`|Template function argument that meets the requirements of an [input iterator](../standard-library/input-iterator-tag-struct.md) that points to elements of a type that can be used to construct [value_type](../standard-library/map-class.md#map__value_type) objects.|  \n|`IList`|The [initializer_list](../standard-library/initializer-list.md) from which to copy the elements.|  \n  \n### Return Value  \n The single-element member functions, (1) and (2), return a [pair](../standard-library/pair-structure.md) whose `bool` component is true if an insertion was made, and false if the unordered_map already contained an element whose key had an equivalent value in the ordering. The iterator component of the return-value pair points to the newly inserted element if the `bool` component is true, or to the existing element if the `bool` component is false.  \n  \n The single-element-with-hint member functions, (3) and (4), return an iterator that points to the position where the new element was inserted into the unordered_map or, if an element with an equivalent key already exists, to the existing element.  \n  \n### Remarks  \n No iterators, pointers, or references are invalidated by this function.  \n  \n During the insertion of just one element, if an exception is thrown but does not occur in the container's hash function, the container's state is not modified. If the exception is thrown in the hash function, the result is undefined. During the insertion of multiple elements, if an exception is thrown, the container is left in an unspecified but valid state.  \n  \n To access the iterator component of a `pair``pr` that's returned by the single-element member functions, use `pr.first`; to dereference the iterator within the returned pair, use `*pr.first`, giving you an element. To access the `bool` component, use `pr.second`. For an example, see the sample code later in this article.  \n  \n The [value_type](../standard-library/map-class.md#map__value_type) of a container is a typedef that belongs to the container, and for map, `map<K, V>::value_type` is `pair<const K, V>`. The value of an element is an ordered pair in which the first component is equal to the key value and the second component is equal to the data value of the element.  \n  \n The range member function (5) inserts the sequence of element values into an unordered_map that corresponds to each element addressed by an iterator in the range `[First, Last)`; therefore, `Last` does not get inserted. The container member function `end()` refers to the position just after the last element in the container—for example, the statement `m.insert(v.begin(), v.end());` attempts to insert all elements of `v` into `m`. Only elements that have unique values in the range are inserted; duplicates are ignored. To observe which elements are rejected, use the single-element versions of `insert`.  \n  \n The initializer list member function (6) uses an [initializer_list](../standard-library/initializer-list.md) to copy elements into the unordered_map.  \n  \n For insertion of an element constructed in place—that is, no copy or move operations are performed—see [unordered_map::emplace](#unordered_map__emplace) and [unordered_map::emplace_hint](#unordered_map__emplace_hint).  \n  \n For a code example, see [map::insert](../standard-library/map-class.md#map__insert).  \n  \n##  <a name=\"unordered_map__iterator\"></a>  unordered_map::iterator  \n The type of an iterator for the controlled sequence.  \n  \n```  \ntypedef T0 iterator;  \n```  \n  \n### Remarks  \n The type describes an object that can serve as a forward iterator for the controlled sequence. It is described here as a synonym for the implementation-defined type `T0`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_iterator.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n```  \n  \n##  <a name=\"unordered_map__key_eq\"></a>  unordered_map::key_eq  \n Gets the stored comparison function object.  \n  \n```  \nPred key_eq() const;\n```  \n  \n### Remarks  \n The member function returns the stored comparison function object.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_key_eq.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    Mymap::key_equal cmpfn = c1.key_eq();   \n    std::cout << \"cmpfn('a', 'a') == \"   \n        << std::boolalpha << cmpfn('a', 'a') << std::endl;   \n    std::cout << \"cmpfn('a', 'b') == \"   \n        << std::boolalpha << cmpfn('a', 'b') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ncmpfn('a', 'a') == true  \ncmpfn('a', 'b') == false  \n```  \n  \n##  <a name=\"unordered_map__key_equal\"></a>  unordered_map::key_equal  \n The type of the comparison function.  \n  \n```  \ntypedef Pred key_equal;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `Pred`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_key_equal.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    Mymap::key_equal cmpfn = c1.key_eq();   \n    std::cout << \"cmpfn('a', 'a') == \"   \n        << std::boolalpha << cmpfn('a', 'a') << std::endl;   \n    std::cout << \"cmpfn('a', 'b') == \"   \n        << std::boolalpha << cmpfn('a', 'b') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ncmpfn('a', 'a') == true  \ncmpfn('a', 'b') == false  \n```  \n  \n##  <a name=\"unordered_map__key_type\"></a>  unordered_map::key_type  \n The type of an ordering key.  \n  \n```  \ntypedef Key key_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `Key`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_key_type.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n// add a value and reinspect   \n    Mymap::key_type key = 'd';   \n    Mymap::mapped_type mapped = 4;   \n    Mymap::value_type val = Mymap::value_type(key, mapped);   \n    c1.insert(val);   \n  \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n[d, 4] [c, 3] [b, 2] [a, 1]  \n```  \n  \n##  <a name=\"unordered_map__load_factor\"></a>  unordered_map::load_factor  \n Counts the average elements per bucket.  \n  \n```  \nfloat load_factor() const;\n```  \n  \n### Remarks  \n The member function returns `(float)`[unordered_map::size](#unordered_map__size)`() / (float)`[unordered_map::bucket_count](#unordered_map__bucket_count)`()`, the average number of elements per bucket.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_load_factor.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n// inspect current parameters   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_bucket_count() == \"   \n        << c1.max_bucket_count() << std::endl;   \n    std::cout << \"max_load_factor() == \"   \n        << c1.max_load_factor() << std::endl;   \n    std::cout << std::endl;   \n  \n// change max_load_factor and redisplay   \n    c1.max_load_factor(0.10f);   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_bucket_count() == \"   \n        << c1.max_bucket_count() << std::endl;   \n    std::cout << \"max_load_factor() == \"   \n        << c1.max_load_factor() << std::endl;   \n    std::cout << std::endl;   \n  \n// rehash and redisplay   \n    c1.rehash(100);   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_bucket_count() == \"   \n        << c1.max_bucket_count() << std::endl;   \n    std::cout << \"max_load_factor() == \"   \n        << c1.max_load_factor() << std::endl;   \n    std::cout << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nbucket_count() == 8  \nload_factor() == 0.375  \nmax_bucket_count() == 8  \nmax_load_factor() == 4  \n  \nbucket_count() == 8  \nload_factor() == 0.375  \nmax_bucket_count() == 8  \nmax_load_factor() == 0.1  \n  \nbucket_count() == 128  \nload_factor() == 0.0234375  \nmax_bucket_count() == 128  \nmax_load_factor() == 0.1  \n  \n```  \n  \n##  <a name=\"unordered_map__local_iterator\"></a>  unordered_map::local_iterator  \n The type of a bucket iterator.  \n  \n```  \ntypedef T4 local_iterator;  \n```  \n  \n### Remarks  \n The type describes an object that can serve as a forward iterator for a bucket. It is described here as a synonym for the implementation-defined type `T4`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_local_iterator.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n// inspect bucket containing 'a'   \n    Mymap::local_iterator lit = c1.begin(c1.bucket('a'));   \n    std::cout << \" [\" << lit->first << \", \" << lit->second << \"]\";   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n[a, 1]  \n```  \n  \n##  <a name=\"unordered_map__mapped_type\"></a>  unordered_map::mapped_type  \n The type of a mapped value associated with each key.  \n  \n```  \ntypedef Ty mapped_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `Ty`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_mapped_type.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n// add a value and reinspect   \n    Mymap::key_type key = 'd';   \n    Mymap::mapped_type mapped = 4;   \n    Mymap::value_type val = Mymap::value_type(key, mapped);   \n    c1.insert(val);   \n  \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n[d, 4] [c, 3] [b, 2] [a, 1]  \n```  \n  \n##  <a name=\"unordered_map__max_bucket_count\"></a>  unordered_map::max_bucket_count  \n Gets the maximum number of buckets.  \n  \n```  \nsize_type max_bucket_count() const;\n```  \n  \n### Remarks  \n The member function returns the maximum number of buckets currently permitted.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_max_bucket_count.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n// inspect current parameters   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_bucket_count() == \"   \n        << c1.max_bucket_count() << std::endl;   \n    std::cout << \"max_load_factor() == \"   \n        << c1.max_load_factor() << std::endl;   \n    std::cout << std::endl;   \n  \n// change max_load_factor and redisplay   \n    c1.max_load_factor(0.10f);   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_bucket_count() == \"   \n        << c1.max_bucket_count() << std::endl;   \n    std::cout << \"max_load_factor() == \"   \n        << c1.max_load_factor() << std::endl;   \n    std::cout << std::endl;   \n  \n// rehash and redisplay   \n    c1.rehash(100);   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_bucket_count() == \"   \n        << c1.max_bucket_count() << std::endl;   \n    std::cout << \"max_load_factor() == \"   \n        << c1.max_load_factor() << std::endl;   \n    std::cout << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nbucket_count() == 8  \nload_factor() == 0.375  \nmax_bucket_count() == 8  \nmax_load_factor() == 4  \n  \nbucket_count() == 8  \nload_factor() == 0.375  \nmax_bucket_count() == 8  \nmax_load_factor() == 0.1  \n  \nbucket_count() == 128  \nload_factor() == 0.0234375  \nmax_bucket_count() == 128  \nmax_load_factor() == 0.1  \n  \n```  \n  \n##  <a name=\"unordered_map__max_load_factor\"></a>  unordered_map::max_load_factor  \n Gets or sets the maximum elements per bucket.  \n  \n```  \nfloat max_load_factor() const;\n\n \nvoid max_load_factor(float factor);\n```  \n  \n### Parameters  \n `factor`  \n The new maximum load factor.  \n  \n### Remarks  \n The first member function returns the stored maximum load factor. The second member function replaces the stored maximum load factor with `factor`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_max_load_factor.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n// inspect current parameters   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_bucket_count() == \"   \n        << c1.max_bucket_count() << std::endl;   \n    std::cout << \"max_load_factor() == \"   \n        << c1.max_load_factor() << std::endl;   \n    std::cout << std::endl;   \n  \n// change max_load_factor and redisplay   \n    c1.max_load_factor(0.10f);   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_bucket_count() == \"   \n        << c1.max_bucket_count() << std::endl;   \n    std::cout << \"max_load_factor() == \"   \n        << c1.max_load_factor() << std::endl;   \n    std::cout << std::endl;   \n  \n// rehash and redisplay   \n    c1.rehash(100);   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_bucket_count() == \"   \n        << c1.max_bucket_count() << std::endl;   \n    std::cout << \"max_load_factor() == \"   \n        << c1.max_load_factor() << std::endl;   \n    std::cout << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nbucket_count() == 8  \nload_factor() == 0.375  \nmax_bucket_count() == 8  \nmax_load_factor() == 4  \n  \nbucket_count() == 8  \nload_factor() == 0.375  \nmax_bucket_count() == 8  \nmax_load_factor() == 0.1  \n  \nbucket_count() == 128  \nload_factor() == 0.0234375  \nmax_bucket_count() == 128  \nmax_load_factor() == 0.1  \n  \n```  \n  \n##  <a name=\"unordered_map__max_size\"></a>  unordered_map::max_size  \n Gets the maximum size of the controlled sequence.  \n  \n```  \nsize_type max_size() const;\n```  \n  \n### Remarks  \n The member function returns the length of the longest sequence that the object can control.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_max_size.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    std::cout << \"max_size() == \" << c1.max_size() << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmax_size() == 536870911  \n```  \n  \n##  <a name=\"unordered_map__operator_at\"></a>  unordered_map::operator[]  \n Finds or inserts an element with the specified key.  \n  \n```  \nTy& operator[](const Key& keyval);\n\nTy& operator[](Key&& keyval);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`Keyval`|The key value to find or insert.|  \n  \n### Return Value  \n A reference to the data value of the inserted element.  \n  \n### Remarks  \n If the argument key value is not found, then it is inserted along with the default value of the data type.  \n  \n `operator[]` may be used to insert elements into a map *m* using *m*[_ *Key*] = `DataValue`; where `DataValue` is the value of the `mapped_type` of the element with a key value of \\_ *Key*.  \n  \n When using `operator[]` to insert elements, the returned reference does not indicate whether an insertion is changing a pre-existing element or creating a new one. The member functions [find](../standard-library/map-class.md#map__find) and [insert](../standard-library/map-class.md#map__insert) can be used to determine whether an element with a specified key is already present before an insertion.  \n  \n### Example  \n  \n```cpp  \n// std__unordered_map__unordered_map_operator_sub.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n#include <string>  \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n// try to find and fail   \n    std::cout << \"c1['A'] == \" << c1['A'] << std::endl;   \n  \n// try to find and succeed   \n    std::cout << \"c1['a'] == \" << c1['a'] << std::endl;   \n  \n// redisplay contents   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n// insert by moving key  \n    std::tr1::unordered_map<string, int> c2;  \n    std::string str(\"abc\");  \n    std::cout << \"c2[std::move(str)] == \" << c2[std::move(str)] << std::endl;  \n    std::cout << \"c2[\"abc\"] == \" << c2[\"abc\"] << std::endl;  \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nc1['A'] == 0  \nc1['a'] == 1  \n [c, 3] [b, 2] [A, 0] [a, 1]  \nc2[move(str)] == 0  \nc2[\"abc\"] == 1  \n```  \n  \n### Remarks  \n The member function determines the iterator `where` as the return value of [unordered_map::insert](#unordered_map__insert)`(` [unordered_map::value_type](#unordered_map__value_type)`(keyval, Ty())`. (It inserts an element with the specified key if no such element exists.) It then returns a reference to `(*where).second`.  \n  \n##  <a name=\"unordered_map__operator_eq\"></a>  unordered_map::operator=  \n Replaces the elements of this unordered_map using the elements from another unordered_map.  \n  \n```  \nunordered_map& operator=(const unordered_map& right);\n\nunordered_map& operator=(unordered_map&& right);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` right`|The unordered_map that the operator function assigns content from.|  \n  \n### Remarks  \n The first version copies all of the elements from ` right` to this unordered_map.  \n  \n The second version moves all of the elements from ` right` to this unordered_map.  \n  \n Any elements that are in this unordered_map before `operator`= executes are discarded.  \n  \n### Example  \n  \n```cpp  \n// unordered_map_operator_as.cpp  \n// compile with: /EHsc  \n#include <unordered_map>  \n#include <iostream>  \n  \nint main( )  \n   {  \n   using namespace std;  \n   unordered_map<int, int> v1, v2, v3;  \n   unordered_map<int, int>::iterator iter;  \n  \n   v1.insert(pair<int, int>(1, 10));  \n  \n   cout << \"v1 = \" ;  \n   for (iter = v1.begin(); iter != v1.end(); iter++)  \n      cout << iter->second << \" \";  \n   cout << endl;  \n  \n   v2 = v1;  \n   cout << \"v2 = \";  \n   for (iter = v2.begin(); iter != v2.end(); iter++)  \n      cout << iter->second << \" \";  \n   cout << endl;  \n  \n// move v1 into v2  \n   v2.clear();  \n   v2 = move(v1);  \n   cout << \"v2 = \";  \n   for (iter = v2.begin(); iter != v2.end(); iter++)  \n      cout << iter->second << \" \";  \n   cout << endl;  \n   }  \n```  \n  \n##  <a name=\"unordered_map__pointer\"></a>  unordered_map::pointer  \n The type of a pointer to an element.  \n  \n```  \ntypedef Alloc::pointer pointer;  \n```  \n  \n### Remarks  \n The type describes an object that can serve as a pointer to an element of the controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_pointer.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        {   \n        Mymap::pointer p = &*it;   \n        std::cout << \" [\" << p->first << \", \" << p->second << \"]\";   \n        }   \n    std::cout << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n```  \n  \n##  <a name=\"unordered_map__reference\"></a>  unordered_map::reference  \n The type of a reference to an element.  \n  \n```  \ntypedef Alloc::reference reference;  \n```  \n  \n### Remarks  \n The type describes an object that can serve as a reference to an element of the controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_reference.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        {   \n        Mymap::reference ref = *it;   \n        std::cout << \" [\" << ref.first << \", \" << ref.second << \"]\";   \n        }   \n    std::cout << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n```  \n  \n##  <a name=\"unordered_map__rehash\"></a>  unordered_map::rehash  \n Rebuilds the hash table.  \n  \n```  \nvoid rehash(size_type nbuckets);\n```  \n  \n### Parameters  \n `nbuckets`  \n The requested number of buckets.  \n  \n### Remarks  \n The member function alters the number of buckets to be at least `nbuckets` and rebuilds the hash table as needed.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_rehash.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n// inspect current parameters   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_load_factor() == \" << c1.max_load_factor() << std::endl;   \n    std::cout << std::endl;   \n  \n// change max_load_factor and redisplay   \n    c1.max_load_factor(0.10f);   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_load_factor() == \" << c1.max_load_factor() << std::endl;   \n    std::cout << std::endl;   \n  \n// rehash and redisplay   \n    c1.rehash(100);   \n    std::cout << \"bucket_count() == \" << c1.bucket_count() << std::endl;   \n    std::cout << \"load_factor() == \" << c1.load_factor() << std::endl;   \n    std::cout << \"max_load_factor() == \" << c1.max_load_factor() << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nbucket_count() == 8  \nload_factor() == 0.375  \nmax_load_factor() == 4  \n  \nbucket_count() == 8  \nload_factor() == 0.375  \nmax_load_factor() == 0.1  \n  \nbucket_count() == 128  \nload_factor() == 0.0234375  \nmax_load_factor() == 0.1  \n```  \n  \n##  <a name=\"unordered_map__size\"></a>  unordered_map::size  \n Counts the number of elements.  \n  \n```  \nsize_type size() const;\n```  \n  \n### Remarks  \n The member function returns the length of the controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_size.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n// clear the container and reinspect   \n    c1.clear();   \n    std::cout << \"size == \" << c1.size() << std::endl;   \n    std::cout << \"empty() == \" << std::boolalpha << c1.empty() << std::endl;   \n    std::cout << std::endl;   \n  \n    c1.insert(Mymap::value_type('d', 4));   \n    c1.insert(Mymap::value_type('e', 5));   \n  \n// display contents \" [e 5] [d 4]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n    std::cout << \"size == \" << c1.size() << std::endl;   \n    std::cout << \"empty() == \" << std::boolalpha << c1.empty() << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n [c, 3] [b, 2] [a, 1]  \nsize == 0  \nempty() == true  \n  \n [e, 5] [d, 4]  \nsize == 2  \nempty() == false  \n```  \n  \n##  <a name=\"unordered_map__size_type\"></a>  unordered_map::size_type  \n The type of an unsigned distance between two elements.  \n  \n```  \ntypedef T2 size_type;  \n```  \n  \n### Remarks  \n The unsigned integer type describes an object that can represent the length of any controlled sequence. It is described here as a synonym for the implementation-defined type `T2`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_size_type.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n    Mymap::size_type sz = c1.size();   \n  \n    std::cout << \"size == \" << sz << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsize == 0  \n```  \n  \n##  <a name=\"unordered_map__swap\"></a>  unordered_map::swap  \n Swaps the contents of two containers.  \n  \n```  \nvoid swap(unordered_map& right);\n```  \n  \n### Parameters  \n `right`  \n The container to swap with.  \n  \n### Remarks  \n The member function swaps the controlled sequences between `*this` and `right`. If [unordered_map::get_allocator](#unordered_map__get_allocator)`() == right.get_allocator()`, it does so in constant time, it throws an exception only as a result of copying the stored traits object of type `Tr`, and it invalidates no references, pointers, or iterators that designate elements in the two controlled sequences. Otherwise, it performs a number of element assignments and constructor calls proportional to the number of elements in the two controlled sequences.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_swap.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;   \nint main()   \n    {   \n    Mymap c1;   \n  \n    c1.insert(Mymap::value_type('a', 1));   \n    c1.insert(Mymap::value_type('b', 2));   \n    c1.insert(Mymap::value_type('c', 3));   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n    Mymap c2;   \n  \n    c2.insert(Mymap::value_type('d', 4));   \n    c2.insert(Mymap::value_type('e', 5));   \n    c2.insert(Mymap::value_type('f', 6));   \n  \n    c1.swap(c2);   \n  \n// display contents \" [f 6] [e 5] [d 4]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n    swap(c1, c2);   \n  \n// display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();   \n        it != c1.end(); ++it)   \n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";   \n    std::cout << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n[f, 6] [e, 5] [d, 4]  \n[c, 3] [b, 2] [a, 1]  \n```  \n  \n##  <a name=\"unordered_map__unordered_map\"></a>  unordered_map::unordered_map  \n Constructs a container object.  \n  \n```  \nunordered_map(const unordered_map& Right);\n\nexplicit unordered_map(\n    size_type Bucket_count = N0,  \n    const Hash& Hash = Hash(),  \n    const Comp& Comp = Comp(),  \n    const Allocator& Al = Allocator());\n\nunordered_map(unordered_map&& Right);\nunordered_map(initializer_list<Type> IList);\nunordered_map(initializer_list<Type> IList, size_type Bucket_count);\n\nunordered_map(\n    initializer_list<Type> IList,   \n    size_type Bucket_count,   \n    const Hash& Hash);\n\nunordered_map(\n    initializer_list<Type> IList,   \n    size_type Bucket_count,   \n    const Hash& Hash,  \n    KeyEqual& equal);\n\nunordered_map(\n    initializer_list<Type> IList,   \n    size_type Bucket_count,  \n    const Hash& Hash,  \n    KeyEqual& Equal  \n    const Allocator& Al);\n\ntemplate <class InIt>  \nunordered_map(\n InputIterator First,   \n    InputIterator Last,  \n    size_type Bucket_count = N0,  \n    const Hash& Hash = Hash(),  \n    const Comp& Comp = Comp(),  \n    const Allocator& Al = Alloc());\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`Al`|The allocator object to store.|  \n|`Comp`|The comparison function object to store.|  \n|`Hash`|The hash function object to store.|  \n|`Bucket_count`|The minimum number of buckets.|  \n|`Right`|The container to copy.|  \n|`First`||  \n|`Last`||  \n|`IList`|The initializer_list that contains the elements to be copied.|  \n  \n### Remarks  \n The first constructor specifies a copy of the sequence controlled by `right`. The second constructor specifies an empty controlled sequence. The third constructor inserts the sequence of element values `[first, last)`. The fourth constructor specifies a copy of the sequence by moving `right`.  \n  \n All constructors also initialize several stored values. For the copy constructor, the values are obtained from `Right`. Otherwise:  \n  \n the minimum number of buckets is the argument `Bucket_count`, if present; otherwise it is a default value described here as the implementation-defined value `N0`.  \n  \n the hash function object is the argument `Hash`, if present; otherwise it is `Hash()`.  \n  \n The comparison function object is the argument `Comp`, if present; otherwise it is `Pred()`.  \n  \n The allocator object is the argument `Al`, if present; otherwise, it is `Alloc()`.  \n  \n### Example  \n  \n```cpp  \n// std__unordered_map__unordered_map_construct.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n#include <initializer_list>  \n  \nusing namespace std;  \n  \nusing Mymap = unordered_map<char, int>;  \n  \nint main()  \n{  \n    Mymap c1;  \n  \n    c1.insert(Mymap::value_type('a', 1));  \n    c1.insert(Mymap::value_type('b', 2));  \n    c1.insert(Mymap::value_type('c', 3));  \n  \n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (const auto& c : c1) {  \n        cout << \" [\" << c.first << \", \" << c.second << \"]\";  \n    }  \n    cout << endl;  \n  \n    Mymap c2(8,  \n        tr1::hash<char>(),  \n        equal_to<char>(),  \n        allocator<pair<const char, int> >());  \n  \n    c2.insert(Mymap::value_type('d', 4));  \n    c2.insert(Mymap::value_type('e', 5));  \n    c2.insert(Mymap::value_type('f', 6));  \n  \n    // display contents \" [f 6] [e 5] [d 4]\"   \n    for (const auto& c : c2) {  \n        cout << \" [\" << c.first << \", \" << c.second << \"]\";  \n    }  \n    cout << endl;  \n  \n    Mymap c3(c1.begin(),  \n        c1.end(),  \n        8,  \n        tr1::hash<char>(),  \n        equal_to<char>(),  \n        allocator<pair<const char, int> >());  \n  \n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (const auto& c : c3) {  \n        cout << \" [\" << c.first << \", \" << c.second << \"]\";  \n    }  \n    cout << endl;  \n  \n    Mymap c4(move(c3));  \n  \n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (const auto& c : c4) {  \n        cout << \" [\" << c.first << \", \" << c.second << \"]\";  \n    }  \n    cout << endl;  \n    cout << endl;  \n  \n    // Construct with an initializer_list  \n    unordered_map<int, char> c5({ { 5, 'g' }, { 6, 'h' }, { 7, 'i' }, { 8, 'j' } });  \n    for (const auto& c : c5) {  \n        cout << \" [\" << c.first << \", \" << c.second << \"]\";  \n    }  \n    cout << endl;  \n  \n    // Initializer_list plus size  \n    unordered_map<int, char> c6({ { 5, 'g' }, { 6, 'h' }, { 7, 'i' }, { 8, 'j' } }, 4);  \n    for (const auto& c : c1) {  \n        cout << \" [\" << c.first << \", \" << c.second << \"]\";  \n    }  \n    cout << endl;  \n    cout << endl;  \n  \n    // Initializer_list plus size and hash  \n    unordered_map<int, char, tr1::hash<char>> c7(  \n        { { 5, 'g' }, { 6, 'h' }, { 7, 'i' }, { 8, 'j' } },   \n        4,   \n        tr1::hash<char>()  \n    );  \n  \n    for (const auto& c : c1) {  \n        cout << \" [\" << c.first << \", \" << c.second << \"]\";  \n    }  \n    cout << endl;  \n  \n    // Initializer_list plus size, hash, and key_equal  \n    unordered_map<int, char, tr1::hash<char>, equal_to<char>> c8(  \n        { { 5, 'g' }, { 6, 'h' }, { 7, 'i' }, { 8, 'j' } },   \n        4,   \n        tr1::hash<char>(),   \n        equal_to<char>()  \n    );  \n  \n    for (const auto& c : c1) {  \n        cout << \" [\" << c.first << \", \" << c.second << \"]\";  \n    }  \n    cout << endl;  \n  \n    // Initializer_list plus size, hash, key_equal, and allocator  \n    unordered_map<int, char, tr1::hash<char>, equal_to<char>> c9(  \n        { { 5, 'g' }, { 6, 'h' }, { 7, 'i' }, { 8, 'j' } },  \n        4,  \n        tr1::hash<char>(),  \n        equal_to<char>(),  \n        allocator<pair<const char, int> >()  \n    );  \n  \n    for (const auto& c : c1) {  \n        cout << \" [\" << c.first << \", \" << c.second << \"]\";  \n    }  \n    cout << endl;  \n}  \n```  \n  \n```Output  \n[a, 1] [b, 2] [c, 3] [d, 4] [e, 5] [f, 6] [a, 1] [b, 2] [c, 3] [a, 1] [b, 2] [c, 3] [5, g] [6, h] [7, i] [8, j] [5, g] [6, h] [7, i] [8, j] [5, g] [6, h] [7, i] [8, j] [5, g] [6, h] [7, i] [8, j] [5, g] [6, h] [7, i] [8, j]  \n```  \n  \n##  <a name=\"unordered_map__value_type\"></a>  unordered_map::value_type  \n The type of an element.  \n  \n```  \ntypedef std::pair<const Key, Ty> value_type;  \n```  \n  \n### Remarks  \n The type describes an element of the controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__unordered_map__unordered_map_value_type.cpp   \n// compile with: /EHsc   \n#include <unordered_map>   \n#include <iostream>   \n  \ntypedef std::unordered_map<char, int> Mymap;\nint main()\n{\n    Mymap c1;\n\n    c1.insert(Mymap::value_type('a', 1));\n    c1.insert(Mymap::value_type('b', 2));\n    c1.insert(Mymap::value_type('c', 3));\n\n    // display contents \" [c 3] [b 2] [a 1]\"   \n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    // add a value and reinspect   \n    Mymap::key_type key = 'd';\n    Mymap::mapped_type mapped = 4;\n    Mymap::value_type val = Mymap::value_type(key, mapped);\n    c1.insert(val);\n\n    for (Mymap::const_iterator it = c1.begin();\n        it != c1.end(); ++it)\n        std::cout << \" [\" << it->first << \", \" << it->second << \"]\";\n    std::cout << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \n[c, 3] [b, 2] [a, 1]  \n[d, 4] [c, 3] [b, 2] [a, 1]  \n```  \n  \n## See Also  \n [<unordered_map>](../standard-library/unordered-map.md)   \n [Containers](../cpp/containers-modern-cpp.md)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)\n\n"}