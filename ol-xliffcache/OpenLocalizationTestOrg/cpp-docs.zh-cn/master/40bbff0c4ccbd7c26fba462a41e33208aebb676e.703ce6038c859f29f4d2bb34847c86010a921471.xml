{"nodes":[{"pos":[12,60],"content":"Changes to Conversion Operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Changes to Conversion Operators | Microsoft Docs","pos":[0,48]}]},{"content":"Changes to Conversion Operators","pos":[738,769]},{"pos":[770,925],"content":"The syntax for conversion operators has changed from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"The syntax for conversion operators has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"One example is to write <ph id=\"ph1\">`op_Implicit`</ph> to specify a conversion.","pos":[932,994],"source":"One example is to write `op_Implicit` to specify a conversion."},{"content":"Here is a definition of <ph id=\"ph1\">`MyDouble`</ph> taken from the language specification:","pos":[995,1068],"source":" Here is a definition of `MyDouble` taken from the language specification:"},{"content":"This says that, given an integer, the algorithm for converting that integer into a <ph id=\"ph1\">`MyDouble`</ph> is provided by the <ph id=\"ph2\">`op_Implicit`</ph> operator.","pos":[1262,1398],"source":"This says that, given an integer, the algorithm for converting that integer into a `MyDouble` is provided by the `op_Implicit` operator."},{"content":"Moreover, that conversion will be performed implicitly by the compiler.","pos":[1399,1470]},{"content":"Similarly, given a <ph id=\"ph1\">`MyDouble`</ph> object, the two <ph id=\"ph2\">`op_Explicit`</ph> operators provide the respective algorithms for converting that object into either an integer or a managed <ph id=\"ph3\">`String`</ph> entity.","pos":[1471,1654],"source":" Similarly, given a `MyDouble` object, the two `op_Explicit` operators provide the respective algorithms for converting that object into either an integer or a managed `String` entity."},{"content":"However, the compiler will not perform the conversion unless explicitly requested by the user.","pos":[1655,1749]},{"content":"In C#, this looks as follows:","pos":[1756,1785]},{"content":"The C# code looks more like C++ than Managed Extensions for C++ does.","pos":[2008,2077]},{"content":"That is not the case in the new syntax.","pos":[2078,2117]},{"content":"The ISO-C++ committee introduced a keyword, <ph id=\"ph1\">`explicit`</ph>, to mitigate unintended consequences – for example, an <ph id=\"ph2\">`Array`</ph> class which takes a single integer argument as a dimension will implicitly convert any integer into an <ph id=\"ph3\">`Array`</ph> object which is not what you want.","pos":[2124,2387],"source":"The ISO-C++ committee introduced a keyword, `explicit`, to mitigate unintended consequences – for example, an `Array` class which takes a single integer argument as a dimension will implicitly convert any integer into an `Array` object which is not what you want."},{"content":"One way to prevent this is a design idiom of a dummy second argument to a constructor","pos":[2388,2473]},{"content":"On the other hand, you should not provide a conversion pair when designing a class type within C++.","pos":[2480,2579]},{"content":"The best example for that is the standard string class.","pos":[2580,2635]},{"content":"The implicit conversion is the single-argument constructor taking a C-style string.","pos":[2636,2719]},{"content":"However, it does not provide the corresponding implicit conversion operator – that of converting a string object to a C-style string, but rather requires the user to explicitly invoke a named function – in this case, <ph id=\"ph1\">`c_str()`</ph>.","pos":[2720,2947],"source":" However, it does not provide the corresponding implicit conversion operator – that of converting a string object to a C-style string, but rather requires the user to explicitly invoke a named function – in this case, `c_str()`."},{"content":"So, associating an implicit/explicit behavior on a conversion operator (and as encapsulating the set of conversions to a single form of declaration) appears to be an improvement on the original C++ support for conversion operators, which eventually led to the <ph id=\"ph1\">`explicit`</ph> keyword.","pos":[2954,3233],"source":"So, associating an implicit/explicit behavior on a conversion operator (and as encapsulating the set of conversions to a single form of declaration) appears to be an improvement on the original C++ support for conversion operators, which eventually led to the `explicit` keyword."},{"content":"The <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph> language support for conversion operators looks as follows, which is slightly less verbose than that of C# because of the default behavior of the operator supporting an implicit application of the conversion algorithm:","pos":[3234,3528],"source":" The [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] language support for conversion operators looks as follows, which is slightly less verbose than that of C# because of the default behavior of the operator supporting an implicit application of the conversion algorithm:"},{"content":"Another change is that a single argument constructor is treated as if it is declared as <ph id=\"ph1\">`explicit`</ph>.","pos":[3741,3840],"source":"Another change is that a single argument constructor is treated as if it is declared as `explicit`."},{"content":"This means that in order to trigger its invocations, an explicit cast is required.","pos":[3841,3923]},{"content":"Note, however, that if an explicit conversion operator is defined, it and not the single-argument constructor, is invoked.","pos":[3924,4046]},{"content":"See Also","pos":[4055,4063]},{"content":"Member Declarations within a Class or Interface (C++/CLI)","pos":[4068,4125]}],"content":"---\ntitle: \"Changes to Conversion Operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"conversion operators\"\n  - \"operators [C++], explicit type conversion\"\n  - \"type conversion, explicit conversions\"\n  - \"conversions, explicit\"\n  - \"explicit keyword [C++]\"\nms.assetid: 9b83925c-71b7-4bd3-ac2e-843dd7c7f184\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Changes to Conversion Operators\nThe syntax for conversion operators has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n One example is to write `op_Implicit` to specify a conversion. Here is a definition of `MyDouble` taken from the language specification:  \n  \n```  \n__gc struct MyDouble {  \n   static MyDouble* op_Implicit( int i );   \n   static int op_Explicit( MyDouble* val );  \n   static String* op_Explicit( MyDouble* val );   \n};  \n```  \n  \n This says that, given an integer, the algorithm for converting that integer into a `MyDouble` is provided by the `op_Implicit` operator. Moreover, that conversion will be performed implicitly by the compiler. Similarly, given a `MyDouble` object, the two `op_Explicit` operators provide the respective algorithms for converting that object into either an integer or a managed `String` entity. However, the compiler will not perform the conversion unless explicitly requested by the user.  \n  \n In C#, this looks as follows:  \n  \n```  \nclass MyDouble {  \n   public static implicit operator MyDouble( int i );   \n   public static explicit operator int( MyDouble val );  \n   public static explicit operator string( MyDouble val );   \n};  \n```  \n  \n The C# code looks more like C++ than Managed Extensions for C++ does. That is not the case in the new syntax.  \n  \n The ISO-C++ committee introduced a keyword, `explicit`, to mitigate unintended consequences – for example, an `Array` class which takes a single integer argument as a dimension will implicitly convert any integer into an `Array` object which is not what you want. One way to prevent this is a design idiom of a dummy second argument to a constructor  \n  \n On the other hand, you should not provide a conversion pair when designing a class type within C++. The best example for that is the standard string class. The implicit conversion is the single-argument constructor taking a C-style string. However, it does not provide the corresponding implicit conversion operator – that of converting a string object to a C-style string, but rather requires the user to explicitly invoke a named function – in this case, `c_str()`.  \n  \n So, associating an implicit/explicit behavior on a conversion operator (and as encapsulating the set of conversions to a single form of declaration) appears to be an improvement on the original C++ support for conversion operators, which eventually led to the `explicit` keyword. The [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] language support for conversion operators looks as follows, which is slightly less verbose than that of C# because of the default behavior of the operator supporting an implicit application of the conversion algorithm:  \n  \n```  \nref struct MyDouble {  \npublic:  \n   static operator MyDouble^ ( int i );  \n   static explicit operator int ( MyDouble^ val );  \n   static explicit operator String^ ( MyDouble^ val );  \n};  \n```  \n  \n Another change is that a single argument constructor is treated as if it is declared as `explicit`. This means that in order to trigger its invocations, an explicit cast is required. Note, however, that if an explicit conversion operator is defined, it and not the single-argument constructor, is invoked.  \n  \n## See Also  \n [Member Declarations within a Class or Interface (C++/CLI)](../dotnet/member-declarations-within-a-class-or-interface-cpp-cli.md)"}