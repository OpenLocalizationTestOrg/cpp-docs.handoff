{"nodes":[{"pos":[12,47],"content":"Scope (Visual C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Scope (Visual C++) | Microsoft Docs","pos":[0,35]}]},{"content":"Scope (Visual C++)","pos":[725,743]},{"content":"C++ names can be used only in certain regions of a program.","pos":[744,803]},{"content":"This area is called the \"scope\" of the name.","pos":[804,848]},{"content":"Scope determines the \"lifetime\" of a name that does not denote an object of static extent.","pos":[849,939]},{"content":"Scope also determines the visibility of a name, when class constructors and destructors are called, and when variables local to the scope are initialized.","pos":[940,1094]},{"content":"(For more information, see <bpt id=\"p1\">[</bpt>Constructors<ept id=\"p1\">](../cpp/constructors-cpp.md)</ept> and <bpt id=\"p2\">[</bpt>Destructors<ept id=\"p2\">](../cpp/destructors-cpp.md)</ept>.) There are five kinds of scope:","pos":[1095,1242],"source":" (For more information, see [Constructors](../cpp/constructors-cpp.md) and [Destructors](../cpp/destructors-cpp.md).) There are five kinds of scope:"},{"content":"<bpt id=\"p1\">**</bpt>Local scope<ept id=\"p1\">**</ept> A name declared within a block is accessible only within that block and blocks enclosed by it, and only after the point of declaration.","pos":[1252,1403],"source":"**Local scope** A name declared within a block is accessible only within that block and blocks enclosed by it, and only after the point of declaration."},{"content":"The names of formal arguments to a function in the scope of the outermost block of the function have local scope, as if they had been declared inside the block enclosing the function body.","pos":[1404,1592]},{"content":"Consider the following code fragment:","pos":[1593,1630]},{"pos":[1697,1871],"content":"Because the declaration of <ph id=\"ph1\">`i`</ph> is in a block enclosed by curly braces, <ph id=\"ph2\">`i`</ph> has local scope and is never accessible because no code accesses it before the closing curly brace.","source":"Because the declaration of `i` is in a block enclosed by curly braces, `i` has local scope and is never accessible because no code accesses it before the closing curly brace."},{"content":"<bpt id=\"p1\">**</bpt>Function scope<ept id=\"p1\">**</ept> Labels are the only names that have function scope.","pos":[1881,1951],"source":"**Function scope** Labels are the only names that have function scope."},{"content":"They can be used anywhere within a function, but are not accessible outside that function.","pos":[1952,2042]},{"content":"Formal arguments (arguments specified in function definitions) to functions are considered to be in the scope of the outermost block of the function body.","pos":[2043,2197]},{"content":"<bpt id=\"p1\">**</bpt>File scope<ept id=\"p1\">**</ept> Any name declared outside all blocks or classes has file scope.","pos":[2207,2285],"source":"**File scope** Any name declared outside all blocks or classes has file scope."},{"content":"It is accessible anywhere in the translation unit after its declaration.","pos":[2286,2358]},{"content":"Names with file scope that do not declare static objects are often called global names.","pos":[2359,2446]},{"content":"In C++, file scope is also known as namespace scope.","pos":[2457,2509]},{"content":"<bpt id=\"p1\">**</bpt>Class scope<ept id=\"p1\">**</ept> Names of class members have class scope.","pos":[2519,2575],"source":"**Class scope** Names of class members have class scope."},{"content":"Class member functions can be accessed only by using the member-selection operators (<bpt id=\"p1\">**</bpt>.<ept id=\"p1\">**</ept>","pos":[2576,2666],"source":" Class member functions can be accessed only by using the member-selection operators (**.**"},{"content":"or <bpt id=\"p1\">**</bpt>–&gt;<ept id=\"p1\">**</ept>) or pointer-to-member operators (<bpt id=\"p2\">**</bpt>.<ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept>","pos":[2667,2717],"source":" or **–>**) or pointer-to-member operators (**.\\***"},{"content":"or <bpt id=\"p1\">**</bpt>–&gt;<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept>) on an object or pointer to an object of that class; nonstatic class member data is considered local to the object of that class.","pos":[2718,2859],"source":" or **–>\\***) on an object or pointer to an object of that class; nonstatic class member data is considered local to the object of that class."},{"content":"Consider the following class declaration:","pos":[2860,2901]},{"pos":[3004,3085],"content":"The class members <ph id=\"ph1\">`x`</ph> and <ph id=\"ph2\">`y`</ph> are considered to be in the scope of class <ph id=\"ph3\">`Point`</ph>.","source":"The class members `x` and `y` are considered to be in the scope of class `Point`."},{"content":"<bpt id=\"p1\">**</bpt>Prototype scope<ept id=\"p1\">**</ept> Names declared in a function prototype are visible only until the end of the prototype.","pos":[3095,3202],"source":"**Prototype scope** Names declared in a function prototype are visible only until the end of the prototype."},{"content":"The following prototype declares three names (<ph id=\"ph1\">`strDestination`</ph>, <ph id=\"ph2\">`numberOfElements`</ph>, and <ph id=\"ph3\">`strSource`</ph>); these names go out of scope at the end of the prototype:","pos":[3203,3361],"source":" The following prototype declares three names (`strDestination`, `numberOfElements`, and `strSource`); these names go out of scope at the end of the prototype:"},{"content":"Hiding Names","pos":[3489,3501]},{"content":"You can hide a name by declaring it in an enclosed block.","pos":[3505,3562]},{"content":"In the following figure, <ph id=\"ph1\">`i`</ph> is redeclared within the inner block, thereby hiding the variable associated with <ph id=\"ph2\">`i`</ph> in the outer block scope.","pos":[3563,3703],"source":" In the following figure, `i` is redeclared within the inner block, thereby hiding the variable associated with `i` in the outer block scope."},{"content":"Block&amp;#45;scope name hiding","pos":[3712,3739],"source":"Block&#45;scope name hiding"},{"content":"Block Scope and Name Hiding","pos":[3779,3806]},{"content":"The output from the program shown in the figure is:","pos":[3813,3864]},{"pos":[3919,4093],"content":"[!NOTE]\n The argument `szWhat` is considered to be in the scope of the function. Therefore, it is treated as if it had been declared in the outermost block of the function.","leadings":["","> "],"nodes":[{"content":" The argument `szWhat` is considered to be in the scope of the function. Therefore, it is treated as if it had been declared in the outermost block of the function.","pos":[8,172],"nodes":[{"content":"The argument <ph id=\"ph1\">`szWhat`</ph> is considered to be in the scope of the function.","pos":[1,72],"source":" The argument `szWhat` is considered to be in the scope of the function."},{"content":"Therefore, it is treated as if it had been declared in the outermost block of the function.","pos":[73,164]}]}]},{"content":"Hiding class names","pos":[4102,4120]},{"content":"You can hide class names by declaring a function, object or variable, or enumerator in the same scope.","pos":[4124,4226]},{"content":"However, the class name can still be accessed when prefixed by the keyword <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept>.","pos":[4227,4312],"source":" However, the class name can still be accessed when prefixed by the keyword **class**."},{"pos":[5044,5395],"content":"[!NOTE]\n Any place the class name (`Account`) is called for, the keyword class must be used to differentiate it from the file-scoped variable Account. This rule does not apply when the class name occurs on the left side of the scope-resolution operator (::). Names on the left side of the scope-resolution operator are always considered class names.","leadings":["","> "],"nodes":[{"content":" Any place the class name (`Account`) is called for, the keyword class must be used to differentiate it from the file-scoped variable Account. This rule does not apply when the class name occurs on the left side of the scope-resolution operator (::). Names on the left side of the scope-resolution operator are always considered class names.","pos":[8,349],"nodes":[{"content":"Any place the class name (<ph id=\"ph1\">`Account`</ph>) is called for, the keyword class must be used to differentiate it from the file-scoped variable Account.","pos":[1,142],"source":" Any place the class name (`Account`) is called for, the keyword class must be used to differentiate it from the file-scoped variable Account."},{"content":"This rule does not apply when the class name occurs on the left side of the scope-resolution operator (::).","pos":[143,250]},{"content":"Names on the left side of the scope-resolution operator are always considered class names.","pos":[251,341]}]}]},{"pos":[5402,5521],"content":"The following example demonstrates how to declare a pointer to an object of type <ph id=\"ph1\">`Account`</ph> using the <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept> keyword:","source":"The following example demonstrates how to declare a pointer to an object of type `Account` using the **class** keyword:"},{"pos":[5601,5719],"content":"The <ph id=\"ph1\">`Account`</ph> in the initializer (in parentheses) in the preceding statement has file scope; it is of type <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>.","source":"The `Account` in the initializer (in parentheses) in the preceding statement has file scope; it is of type **double**."},{"pos":[5727,5830],"content":"[!NOTE]\n The reuse of identifier names as shown in this example is considered poor programming style.","leadings":["","> "],"nodes":[{"content":"The reuse of identifier names as shown in this example is considered poor programming style.","pos":[9,101]}]},{"content":"For more information about pointers, see <bpt id=\"p1\">[</bpt>Derived Types<ept id=\"p1\">](http://msdn.microsoft.com/en-us/aa14183c-02fe-4d81-95fe-beddb0c01c7c)</ept>.","pos":[5837,5964],"source":"For more information about pointers, see [Derived Types](http://msdn.microsoft.com/en-us/aa14183c-02fe-4d81-95fe-beddb0c01c7c)."},{"content":"For information about declaration and initialization of class objects, see <bpt id=\"p1\">[</bpt>Classes, Structures, and Unions<ept id=\"p1\">](../cpp/classes-and-structs-cpp.md)</ept>.","pos":[5965,6109],"source":" For information about declaration and initialization of class objects, see [Classes, Structures, and Unions](../cpp/classes-and-structs-cpp.md)."},{"content":"For information about using the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> free-store operators, see <bpt id=\"p3\">[</bpt>new and delete operators<ept id=\"p3\">](new-and-delete-operators.md)</ept>.","pos":[6110,6247],"source":" For information about using the **new** and **delete** free-store operators, see [new and delete operators](new-and-delete-operators.md)."},{"content":"Hiding names with file scope","pos":[6256,6284]},{"content":"You can hide names with file scope by explicitly declaring the same name in block scope.","pos":[6288,6376]},{"content":"However, file-scope names can be accessed using the scope-resolution operator (<ph id=\"ph1\">`::`</ph>).","pos":[6377,6462],"source":" However, file-scope names can be accessed using the scope-resolution operator (`::`)."},{"content":"See Also","pos":[6952,6960]},{"content":"Basic Concepts","pos":[6965,6979]}],"content":"---\ntitle: \"Scope (Visual C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"classes [C++], scope\"\n  - \"scope\"\n  - \"function prototypes, scope\"\n  - \"class scope\"\n  - \"prototype scope\"\n  - \"functions [C++], scope\"\n  - \"scope, C++ names\"\nms.assetid: 81fecbb0-338b-4325-8332-49f33e716352\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Scope (Visual C++)\nC++ names can be used only in certain regions of a program. This area is called the \"scope\" of the name. Scope determines the \"lifetime\" of a name that does not denote an object of static extent. Scope also determines the visibility of a name, when class constructors and destructors are called, and when variables local to the scope are initialized. (For more information, see [Constructors](../cpp/constructors-cpp.md) and [Destructors](../cpp/destructors-cpp.md).) There are five kinds of scope:  \n  \n-   **Local scope** A name declared within a block is accessible only within that block and blocks enclosed by it, and only after the point of declaration. The names of formal arguments to a function in the scope of the outermost block of the function have local scope, as if they had been declared inside the block enclosing the function body. Consider the following code fragment:  \n  \n    ```  \n    {  \n        int i;  \n    }  \n    ```  \n  \n     Because the declaration of `i` is in a block enclosed by curly braces, `i` has local scope and is never accessible because no code accesses it before the closing curly brace.  \n  \n-   **Function scope** Labels are the only names that have function scope. They can be used anywhere within a function, but are not accessible outside that function. Formal arguments (arguments specified in function definitions) to functions are considered to be in the scope of the outermost block of the function body.  \n  \n-   **File scope** Any name declared outside all blocks or classes has file scope. It is accessible anywhere in the translation unit after its declaration. Names with file scope that do not declare static objects are often called global names.  \n  \n     In C++, file scope is also known as namespace scope.  \n  \n-   **Class scope** Names of class members have class scope. Class member functions can be accessed only by using the member-selection operators (**.** or **–>**) or pointer-to-member operators (**.\\*** or **–>\\***) on an object or pointer to an object of that class; nonstatic class member data is considered local to the object of that class. Consider the following class declaration:  \n  \n    ```  \n    class Point  \n    {  \n        int x;  \n        int y;  \n    };  \n    ```  \n  \n     The class members `x` and `y` are considered to be in the scope of class `Point`.  \n  \n-   **Prototype scope** Names declared in a function prototype are visible only until the end of the prototype. The following prototype declares three names (`strDestination`, `numberOfElements`, and `strSource`); these names go out of scope at the end of the prototype:  \n  \n    ```  \n    errno_t strcpy_s( char *strDestination, size_t numberOfElements, const char *strSource );  \n    ```  \n  \n## Hiding Names  \n You can hide a name by declaring it in an enclosed block. In the following figure, `i` is redeclared within the inner block, thereby hiding the variable associated with `i` in the outer block scope.  \n  \n ![Block&#45;scope name hiding](../cpp/media/vc38sf1.png \"vc38SF1\")  \nBlock Scope and Name Hiding  \n  \n The output from the program shown in the figure is:  \n  \n```  \ni = 0  \ni = 7  \nj = 9  \ni = 0  \n```  \n  \n> [!NOTE]\n>  The argument `szWhat` is considered to be in the scope of the function. Therefore, it is treated as if it had been declared in the outermost block of the function.  \n  \n## Hiding class names  \n You can hide class names by declaring a function, object or variable, or enumerator in the same scope. However, the class name can still be accessed when prefixed by the keyword **class**.  \n  \n```  \n// hiding_class_names.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \n// Declare class Account at file scope.  \nclass Account  \n{  \npublic:  \n    Account( double InitialBalance )  \n        { balance = InitialBalance; }  \n    double GetBalance()  \n        { return balance; }  \nprivate:  \n    double balance;  \n};  \n  \ndouble Account = 15.37;            // Hides class name Account  \n  \nint main()  \n{  \n    class Account Checking( Account ); // Qualifies Account as   \n                                       //  class name  \n  \n    cout << \"Opening account with balance of: \"  \n         << Checking.GetBalance() << \"\\n\";  \n}  \n//Output: Opening account with balance of: 15.37  \n```  \n  \n> [!NOTE]\n>  Any place the class name (`Account`) is called for, the keyword class must be used to differentiate it from the file-scoped variable Account. This rule does not apply when the class name occurs on the left side of the scope-resolution operator (::). Names on the left side of the scope-resolution operator are always considered class names.  \n  \n The following example demonstrates how to declare a pointer to an object of type `Account` using the **class** keyword:  \n  \n```  \nclass Account *Checking = new class Account( Account );  \n```  \n  \n The `Account` in the initializer (in parentheses) in the preceding statement has file scope; it is of type **double**.  \n  \n> [!NOTE]\n>  The reuse of identifier names as shown in this example is considered poor programming style.  \n  \n For more information about pointers, see [Derived Types](http://msdn.microsoft.com/en-us/aa14183c-02fe-4d81-95fe-beddb0c01c7c). For information about declaration and initialization of class objects, see [Classes, Structures, and Unions](../cpp/classes-and-structs-cpp.md). For information about using the **new** and **delete** free-store operators, see [new and delete operators](new-and-delete-operators.md).  \n  \n## Hiding names with file scope  \n You can hide names with file scope by explicitly declaring the same name in block scope. However, file-scope names can be accessed using the scope-resolution operator (`::`).  \n  \n```  \n// file_scopes.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nint i = 7;   // i has file scope, outside all blocks  \nusing namespace std;  \n  \nint main( int argc, char *argv[] ) {  \n   int i = 5;   // i has block scope, hides i at file scope  \n   cout << \"Block-scoped i has the value: \" << i << \"\\n\";  \n   cout << \"File-scoped i has the value: \" << ::i << \"\\n\";  \n}  \n```  \n  \n```Output  \nBlock-scoped i has the value: 5  \nFile-scoped i has the value: 7  \n```  \n  \n## See Also  \n [Basic Concepts](../cpp/basic-concepts-cpp.md)"}