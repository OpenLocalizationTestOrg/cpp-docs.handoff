{"nodes":[{"pos":[12,43],"content":"C++ Bit Fields | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"C++ Bit Fields | Microsoft Docs","pos":[0,31]}]},{"content":"C++ Bit Fields","pos":[602,616]},{"content":"Classes and structures can contain members that occupy less storage than an integral type.","pos":[617,707]},{"content":"These members are specified as bit fields.","pos":[708,750]},{"content":"The syntax for bit-field <bpt id=\"p1\">*</bpt>member-declarator<ept id=\"p1\">*</ept> specification follows:","pos":[751,818],"source":" The syntax for bit-field *member-declarator* specification follows:"},{"content":"Syntax","pos":[827,833]},{"content":"Remarks","pos":[896,903]},{"content":"The (optional) <ph id=\"ph1\">`declarator`</ph> is the name by which the member is accessed in the program.","pos":[907,994],"source":"The (optional) `declarator` is the name by which the member is accessed in the program."},{"content":"It must be an integral type (including enumerated types).","pos":[995,1052]},{"content":"The <bpt id=\"p1\">*</bpt>constant-expression<ept id=\"p1\">*</ept> specifies the number of bits the member occupies in the structure.","pos":[1053,1145],"source":" The *constant-expression* specifies the number of bits the member occupies in the structure."},{"content":"Anonymous bit fields — that is, bit-field members with no identifier — can be used for padding.","pos":[1146,1241]},{"pos":[1249,1399],"content":"[!NOTE]\n An unnamed bit field of width 0 forces alignment of the next bit field to the next `type` boundary, where `type` is the type of the member.","leadings":["","> "],"nodes":[{"content":"An unnamed bit field of width 0 forces alignment of the next bit field to the next <ph id=\"ph1\">`type`</ph> boundary, where <ph id=\"ph2\">`type`</ph> is the type of the member.","pos":[9,148],"source":" An unnamed bit field of width 0 forces alignment of the next bit field to the next `type` boundary, where `type` is the type of the member."}]},{"content":"The following example declares a structure that contains bit fields:","pos":[1406,1474]},{"pos":[1789,1879],"content":"The conceptual memory layout of an object of type <ph id=\"ph1\">`Date`</ph> is shown in the following figure.","source":"The conceptual memory layout of an object of type `Date` is shown in the following figure."},{"content":"Memory layout of a date object","pos":[1888,1918]},{"content":"Memory Layout of Date Object","pos":[1958,1986]},{"content":"Note that <ph id=\"ph1\">`nYear`</ph> is 8 bits long and would overflow the word boundary of the declared type, <bpt id=\"p1\">**</bpt>unsigned short<ept id=\"p1\">**</ept>.","pos":[1993,2104],"source":"Note that `nYear` is 8 bits long and would overflow the word boundary of the declared type, **unsigned short**."},{"content":"Therefore, it is begun at the beginning of a new <bpt id=\"p1\">**</bpt>unsigned short<ept id=\"p1\">**</ept>.","pos":[2105,2173],"source":" Therefore, it is begun at the beginning of a new **unsigned short**."},{"content":"It is not necessary that all bit fields fit in one object of the underlying type; new units of storage are allocated, according to the number of bits requested in the declaration.","pos":[2174,2353]},{"content":"Microsoft Specific","pos":[2362,2380]},{"content":"The ordering of data declared as bit fields is from low to high bit, as shown in the figure above.","pos":[2389,2487]},{"content":"END Microsoft Specific","pos":[2496,2518]},{"content":"If the declaration of a structure includes an unnamed field of length 0, as shown in the following example,","pos":[2527,2634]},{"content":"the memory layout is as shown in the following figure.","pos":[2994,3048]},{"content":"Layout of Date object with zero&amp;#45;length bit field","pos":[3057,3109],"source":"Layout of Date object with zero&#45;length bit field"},{"content":"Layout of Date Object with Zero-Length Bit Field","pos":[3149,3197]},{"pos":[3204,3334],"content":"The underlying type of a bit field must be an integral type, as described in <bpt id=\"p1\">[</bpt>Fundamental Types<ept id=\"p1\">](../cpp/fundamental-types-cpp.md)</ept>.","source":"The underlying type of a bit field must be an integral type, as described in [Fundamental Types](../cpp/fundamental-types-cpp.md)."},{"content":"Restrictions on bit fields","pos":[3343,3369]},{"content":"The following list details erroneous operations on bit fields:","pos":[3373,3435]},{"content":"Taking the address of a bit field.","pos":[3445,3479]},{"content":"Initializing a reference with a bit field.","pos":[3489,3531]},{"content":"See Also","pos":[3540,3548]},{"content":"Classes and Structs","pos":[3553,3572]}],"content":"---\ntitle: \"C++ Bit Fields | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"bitfields\"\n  - \"fields [C++], bit\"\n  - \"bit fields\"\nms.assetid: 6f4b62e3-cc1d-4e5d-bf34-05904104f71a\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# C++ Bit Fields\nClasses and structures can contain members that occupy less storage than an integral type. These members are specified as bit fields. The syntax for bit-field *member-declarator* specification follows:  \n  \n## Syntax  \n  \n```  \n  \ndeclarator  : constant-expression  \n```  \n  \n## Remarks  \n The (optional) `declarator` is the name by which the member is accessed in the program. It must be an integral type (including enumerated types). The *constant-expression* specifies the number of bits the member occupies in the structure. Anonymous bit fields — that is, bit-field members with no identifier — can be used for padding.  \n  \n> [!NOTE]\n>  An unnamed bit field of width 0 forces alignment of the next bit field to the next `type` boundary, where `type` is the type of the member.  \n  \n The following example declares a structure that contains bit fields:  \n  \n```  \n// bit_fields1.cpp  \n// compile with: /LD  \nstruct Date {  \n   unsigned short nWeekDay  : 3;    // 0..7   (3 bits)  \n   unsigned short nMonthDay : 6;    // 0..31  (6 bits)  \n   unsigned short nMonth    : 5;    // 0..12  (5 bits)  \n   unsigned short nYear     : 8;    // 0..100 (8 bits)  \n};  \n```  \n  \n The conceptual memory layout of an object of type `Date` is shown in the following figure.  \n  \n ![Memory layout of a date object](../cpp/media/vc38uq1.png \"vc38UQ1\")  \nMemory Layout of Date Object  \n  \n Note that `nYear` is 8 bits long and would overflow the word boundary of the declared type, **unsigned short**. Therefore, it is begun at the beginning of a new **unsigned short**. It is not necessary that all bit fields fit in one object of the underlying type; new units of storage are allocated, according to the number of bits requested in the declaration.  \n  \n **Microsoft Specific**  \n  \n The ordering of data declared as bit fields is from low to high bit, as shown in the figure above.  \n  \n **END Microsoft Specific**  \n  \n If the declaration of a structure includes an unnamed field of length 0, as shown in the following example,  \n  \n```  \n// bit_fields2.cpp  \n// compile with: /LD  \nstruct Date {  \n   unsigned nWeekDay  : 3;    // 0..7   (3 bits)  \n   unsigned nMonthDay : 6;    // 0..31  (6 bits)  \n   unsigned           : 0;    // Force alignment to next boundary.  \n   unsigned nMonth    : 5;    // 0..12  (5 bits)  \n   unsigned nYear     : 8;    // 0..100 (8 bits)  \n};  \n```  \n  \n the memory layout is as shown in the following figure.  \n  \n ![Layout of Date object with zero&#45;length bit field](../cpp/media/vc38uq2.png \"vc38UQ2\")  \nLayout of Date Object with Zero-Length Bit Field  \n  \n The underlying type of a bit field must be an integral type, as described in [Fundamental Types](../cpp/fundamental-types-cpp.md).  \n  \n## Restrictions on bit fields  \n The following list details erroneous operations on bit fields:  \n  \n1.  Taking the address of a bit field.  \n  \n2.  Initializing a reference with a bit field.  \n  \n## See Also  \n [Classes and Structs](../cpp/classes-and-structs-cpp.md)"}