{"nodes":[{"pos":[12,50],"content":"code_seg (__declspec) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"code_seg (__declspec) | Microsoft Docs","pos":[0,38]}]},{"content":"code_seg (__declspec)","pos":[646,667]},{"content":"Microsoft Specific","pos":[670,688]},{"pos":[697,867],"content":"The <ph id=\"ph1\">`code_seg`</ph> declaration attribute names an executable text segment in the .obj file in which the object code for the function or class member functions will be stored.","source":"The `code_seg` declaration attribute names an executable text segment in the .obj file in which the object code for the function or class member functions will be stored."},{"content":"Syntax","pos":[876,882]},{"content":"Remarks","pos":[951,958]},{"content":"The <ph id=\"ph1\">`__declspec(code_seg(...))`</ph> attribute enables the placement of code into separate named segments that can be paged or locked in memory individually.","pos":[962,1114],"source":"The `__declspec(code_seg(...))` attribute enables the placement of code into separate named segments that can be paged or locked in memory individually."},{"content":"You can use this attribute to control the placement of instantiated templates and compiler-generated code.","pos":[1115,1221]},{"content":"A <bpt id=\"p1\">*</bpt>segment<ept id=\"p1\">*</ept> is a named block of data in an .obj file that is loaded into memory as a unit.","pos":[1228,1318],"source":"A *segment* is a named block of data in an .obj file that is loaded into memory as a unit."},{"content":"A <bpt id=\"p1\">*</bpt>text segment<ept id=\"p1\">*</ept> is a segment that contains executable code.","pos":[1319,1379],"source":" A *text segment* is a segment that contains executable code."},{"content":"The term <bpt id=\"p1\">*</bpt>section<ept id=\"p1\">*</ept> is often used interchangeably with segment.","pos":[1380,1442],"source":" The term *section* is often used interchangeably with segment."},{"content":"Object code that's generated when <ph id=\"ph1\">`declarator`</ph> is defined is put in the text segment specified by <ph id=\"ph2\">`segname`</ph>, which is a narrow-string literal.","pos":[1449,1591],"source":"Object code that's generated when `declarator` is defined is put in the text segment specified by `segname`, which is a narrow-string literal."},{"content":"The name <ph id=\"ph1\">`segname`</ph> does not have to be specified in a <bpt id=\"p1\">[</bpt>section<ept id=\"p1\">](../preprocessor/section.md)</ept> pragma before it can be used in a declaration.","pos":[1592,1730],"source":" The name `segname` does not have to be specified in a [section](../preprocessor/section.md) pragma before it can be used in a declaration."},{"content":"By default, when no <ph id=\"ph1\">`code_seg`</ph> is specified, object code is put in a segment named .text.","pos":[1731,1820],"source":" By default, when no `code_seg` is specified, object code is put in a segment named .text."},{"content":"A <ph id=\"ph1\">`code_seg`</ph> attribute overrides any existing <bpt id=\"p1\">[</bpt>#pragma code_seg<ept id=\"p1\">](../preprocessor/code-seg.md)</ept> directive.","pos":[1821,1925],"source":" A `code_seg` attribute overrides any existing [#pragma code_seg](../preprocessor/code-seg.md) directive."},{"content":"A <ph id=\"ph1\">`code_seg`</ph> attribute applied to a member function overrides any <ph id=\"ph2\">`code_seg`</ph> attribute applied to the enclosing class.","pos":[1926,2044],"source":" A `code_seg` attribute applied to a member function overrides any `code_seg` attribute applied to the enclosing class."},{"content":"If an entity has a <ph id=\"ph1\">`code_seg`</ph> attribute, all declarations and definitions of the same entity must have identical <ph id=\"ph2\">`code_seg`</ph> attributes.","pos":[2051,2186],"source":"If an entity has a `code_seg` attribute, all declarations and definitions of the same entity must have identical `code_seg` attributes."},{"content":"If a base-class has a <ph id=\"ph1\">`code_seg`</ph> attribute, derived classes must have the same attribute.","pos":[2187,2276],"source":" If a base-class has a `code_seg` attribute, derived classes must have the same attribute."},{"content":"When a <ph id=\"ph1\">`code_seg`</ph> attribute is applied to a namespace-scope function or a member function, the object code for that function is put in the specified text segment.","pos":[2283,2445],"source":"When a `code_seg` attribute is applied to a namespace-scope function or a member function, the object code for that function is put in the specified text segment."},{"content":"When this attribute is applied to a class, all member functions of the class and nested classes—this includes compiler-generated special member functions—are put in the specified segment.","pos":[2446,2633]},{"content":"Locally defined classes—for example, classes defined in a member function body—do not inherit the <ph id=\"ph1\">`code_seg`</ph> attribute of the enclosing scope.","pos":[2634,2776],"source":" Locally defined classes—for example, classes defined in a member function body—do not inherit the `code_seg` attribute of the enclosing scope."},{"content":"When a <ph id=\"ph1\">`code_seg`</ph> attribute is applied to a template class or template function, all implicit specializations of the template are put in the specified segment.","pos":[2783,2942],"source":"When a `code_seg` attribute is applied to a template class or template function, all implicit specializations of the template are put in the specified segment."},{"content":"Explicit or partial specializations do not inherit the <ph id=\"ph1\">`code_seg`</ph> attribute from the primary template.","pos":[2943,3045],"source":" Explicit or partial specializations do not inherit the `code_seg` attribute from the primary template."},{"content":"You may specify the same or a different <ph id=\"ph1\">`code_seg`</ph> attribute on the specialization.","pos":[3046,3129],"source":" You may specify the same or a different `code_seg` attribute on the specialization."},{"content":"A <ph id=\"ph1\">`code_seg`</ph> attribute can’t be applied to an explicit template instantiation.","pos":[3130,3208],"source":" A `code_seg` attribute can’t be applied to an explicit template instantiation."},{"content":"By default, compiler-generated code such as a special member function is put in the .text segment.","pos":[3215,3313]},{"content":"The <ph id=\"ph1\">`#pragma code_seg`</ph> directive does not override this default.","pos":[3314,3378],"source":" The `#pragma code_seg` directive does not override this default."},{"content":"Use the <ph id=\"ph1\">`code_seg`</ph> attribute on the class, class template, or function template to control where compiler-generated code is put.","pos":[3379,3507],"source":" Use the `code_seg` attribute on the class, class template, or function template to control where compiler-generated code is put."},{"content":"Lambdas inherit <ph id=\"ph1\">`code_seg`</ph> attributes from their enclosing scope.","pos":[3514,3579],"source":"Lambdas inherit `code_seg` attributes from their enclosing scope."},{"content":"To specify a segment for a lambda, apply a <ph id=\"ph1\">`code_seg`</ph> attribute after the parameter-declaration clause and before any mutable or exception specification, any trailing return-type specification, and the lambda body.","pos":[3580,3794],"source":" To specify a segment for a lambda, apply a `code_seg` attribute after the parameter-declaration clause and before any mutable or exception specification, any trailing return-type specification, and the lambda body."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Lambda Expression Syntax<ept id=\"p1\">](../cpp/lambda-expression-syntax.md)</ept>.","pos":[3795,3884],"source":" For more information, see [Lambda Expression Syntax](../cpp/lambda-expression-syntax.md)."},{"content":"This example defines a lambda in a segment named PagedMem:","pos":[3885,3943]},{"content":"Be careful when you put specific member functions—especially virtual member functions—in different segments.","pos":[4048,4156]},{"content":"If you define a virtual function in a derived class that resides in a paged segment when the base class method resides in a non-paged segment, other base class methods or user code may assume that invoking the virtual method will not trigger a page fault.","pos":[4157,4412]},{"content":"Example","pos":[4421,4428]},{"pos":[4432,4564],"content":"This example shows how a <ph id=\"ph1\">`code_seg`</ph> attribute controls segment placement when implicit and explicit template specialization is used:","source":"This example shows how a `code_seg` attribute controls segment placement when implicit and explicit template specialization is used:"},{"content":"END Microsoft Specific","pos":[5961,5983]},{"content":"See Also","pos":[5994,6002]},{"content":"__declspec","pos":[6007,6017]},{"content":"Keywords","pos":[6044,6052]}],"content":"---\ntitle: \"code_seg (__declspec) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"code_seg_cpp\"\n  - \"code_seg\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"code_seg __declspec keyword\"\nms.assetid: ad3c1105-15d3-4e08-b7b9-e4bd9d7b6aa0\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# code_seg (__declspec)\n**Microsoft Specific**  \n  \n The `code_seg` declaration attribute names an executable text segment in the .obj file in which the object code for the function or class member functions will be stored.  \n  \n## Syntax  \n  \n```  \n__declspec(code_seg(\"segname\")) declarator  \n```  \n  \n## Remarks  \n The `__declspec(code_seg(...))` attribute enables the placement of code into separate named segments that can be paged or locked in memory individually. You can use this attribute to control the placement of instantiated templates and compiler-generated code.  \n  \n A *segment* is a named block of data in an .obj file that is loaded into memory as a unit. A *text segment* is a segment that contains executable code. The term *section* is often used interchangeably with segment.  \n  \n Object code that's generated when `declarator` is defined is put in the text segment specified by `segname`, which is a narrow-string literal. The name `segname` does not have to be specified in a [section](../preprocessor/section.md) pragma before it can be used in a declaration. By default, when no `code_seg` is specified, object code is put in a segment named .text. A `code_seg` attribute overrides any existing [#pragma code_seg](../preprocessor/code-seg.md) directive. A `code_seg` attribute applied to a member function overrides any `code_seg` attribute applied to the enclosing class.  \n  \n If an entity has a `code_seg` attribute, all declarations and definitions of the same entity must have identical `code_seg` attributes. If a base-class has a `code_seg` attribute, derived classes must have the same attribute.  \n  \n When a `code_seg` attribute is applied to a namespace-scope function or a member function, the object code for that function is put in the specified text segment. When this attribute is applied to a class, all member functions of the class and nested classes—this includes compiler-generated special member functions—are put in the specified segment. Locally defined classes—for example, classes defined in a member function body—do not inherit the `code_seg` attribute of the enclosing scope.  \n  \n When a `code_seg` attribute is applied to a template class or template function, all implicit specializations of the template are put in the specified segment. Explicit or partial specializations do not inherit the `code_seg` attribute from the primary template. You may specify the same or a different `code_seg` attribute on the specialization. A `code_seg` attribute can’t be applied to an explicit template instantiation.  \n  \n By default, compiler-generated code such as a special member function is put in the .text segment. The `#pragma code_seg` directive does not override this default. Use the `code_seg` attribute on the class, class template, or function template to control where compiler-generated code is put.  \n  \n Lambdas inherit `code_seg` attributes from their enclosing scope. To specify a segment for a lambda, apply a `code_seg` attribute after the parameter-declaration clause and before any mutable or exception specification, any trailing return-type specification, and the lambda body. For more information, see [Lambda Expression Syntax](../cpp/lambda-expression-syntax.md). This example defines a lambda in a segment named PagedMem:  \n  \n```cpp  \nauto Sqr = [](int t) __declspec(code_seg(\"PagedMem\")) -> int { return t*t; };  \n```  \n  \n Be careful when you put specific member functions—especially virtual member functions—in different segments. If you define a virtual function in a derived class that resides in a paged segment when the base class method resides in a non-paged segment, other base class methods or user code may assume that invoking the virtual method will not trigger a page fault.  \n  \n## Example  \n This example shows how a `code_seg` attribute controls segment placement when implicit and explicit template specialization is used:  \n  \n```  \n// code_seg.cpp  \n// Compile: cl /EHsc /W4 code_seg.cpp  \n  \n// Base template places object code in Segment_1 segment  \ntemplate<class T>  \nclass __declspec(code_seg(\"Segment_1\")) Example  \n{  \npublic:  \n   virtual void VirtualMemberFunction(T /*arg*/) {}  \n};  \n  \n// bool specialization places code in default .text segment  \ntemplate<>  \nclass Example<bool>   \n{  \npublic:  \n   virtual void VirtualMemberFunction(bool /*arg*/) {}  \n};  \n  \n// int specialization places code in Segment_2 segment  \ntemplate<>  \nclass __declspec(code_seg(\"Segment_2\")) Example<int>   \n{  \npublic:  \n   virtual void VirtualMemberFunction(int /*arg*/) {}  \n};  \n  \n// Compiler warns and ignores __declspec(code_seg(\"Segment_3\"))  \n// in this explicit specialization  \n__declspec(code_seg(\"Segment_3\")) Example<short>; // C4071  \n  \nint main()  \n{  \n   // implicit double specialization uses base template's  \n   // __declspec(code_seg(\"Segment_1\")) to place object code  \n   Example<double> doubleExample{};  \n   doubleExample.VirtualMemberFunction(3.14L);  \n  \n   // bool specialization places object code in default .text segment  \n   Example<bool> boolExample{};  \n   boolExample.VirtualMemberFunction(true);  \n  \n   // int specialization uses __declspec(code_seg(\"Segment_2\"))  \n   // to place object code  \n   Example<int> intExample{};  \n   intExample.VirtualMemberFunction(42);  \n}  \n```  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [__declspec](../cpp/declspec.md)   \n [Keywords](../cpp/keywords-cpp.md)"}