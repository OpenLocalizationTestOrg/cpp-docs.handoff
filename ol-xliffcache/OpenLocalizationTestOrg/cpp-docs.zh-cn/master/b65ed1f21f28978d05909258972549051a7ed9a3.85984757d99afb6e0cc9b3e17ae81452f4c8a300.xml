{"nodes":[{"pos":[12,67],"content":"Conversions from Signed Integral Types | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Conversions from Signed Integral Types | Microsoft Docs","pos":[0,55]}]},{"content":"Conversions from Signed Integral Types","pos":[799,837]},{"content":"When a signed integer is converted to an unsigned integer with equal or greater size and the value of the signed integer is not negative, the value is unchanged.","pos":[838,999]},{"content":"The conversion is made by sign-extending the signed integer.","pos":[1000,1060]},{"content":"A signed integer is converted to a shorter signed integer by truncating the high-order bits.","pos":[1061,1153]},{"content":"The result is interpreted as an unsigned value, as shown in this example.","pos":[1154,1227]},{"pos":[1342,1545],"content":"No information is lost when a signed integer is converted to a floating value, except that some precision may be lost when a <bpt id=\"p1\">**</bpt>long int<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>unsigned long int<ept id=\"p2\">**</ept> value is converted to a <bpt id=\"p3\">**</bpt>float<ept id=\"p3\">**</ept> value.","source":"No information is lost when a signed integer is converted to a floating value, except that some precision may be lost when a **long int** or **unsigned long int** value is converted to a **float** value."},{"content":"The following table summarizes conversions from signed integral types.","pos":[1552,1622]},{"content":"This table assumes that the <ph id=\"ph1\">`char`</ph> type is signed by default.","pos":[1623,1684],"source":" This table assumes that the `char` type is signed by default."},{"content":"If you use a compile-time option to change the default for the <ph id=\"ph1\">`char`</ph> type to unsigned, the conversions given in the <bpt id=\"p1\">[</bpt>Conversions from Unsigned Integral Types<ept id=\"p1\">](../c-language/conversions-from-unsigned-integral-types.md)</ept> table for the <ph id=\"ph2\">`unsigned char`</ph> type apply instead of the conversions in the following table, Conversions from Signed Integral Types.","pos":[1685,2035],"source":" If you use a compile-time option to change the default for the `char` type to unsigned, the conversions given in the [Conversions from Unsigned Integral Types](../c-language/conversions-from-unsigned-integral-types.md) table for the `unsigned char` type apply instead of the conversions in the following table, Conversions from Signed Integral Types."},{"content":"Conversions from Signed Integral Types","pos":[2045,2083]},{"content":"From","pos":[2090,2094]},{"content":"To","pos":[2095,2097]},{"content":"Method","pos":[2098,2104]},{"pos":[2152,2153],"content":"1"},{"content":"short","pos":[2156,2161]},{"content":"Sign-extend","pos":[2164,2175]},{"content":"long","pos":[2189,2193]},{"content":"Sign-extend","pos":[2196,2207]},{"content":"Preserve pattern; high-order bit loses function as sign bit","pos":[2235,2294]},{"content":"unsigned short","pos":[2308,2322]},{"pos":[2325,2390],"content":"Sign-extend to <bpt id=\"p1\">**</bpt>short<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>short<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>unsigned short<ept id=\"p3\">**</ept>","source":"Sign-extend to **short**; convert **short** to **unsigned short**"},{"pos":[2418,2462],"content":"Sign-extend to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to","source":"Sign-extend to **long**; convert **long** to "},{"content":"float","pos":[2492,2497]},{"pos":[2500,2554],"content":"Sign-extend to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>float<ept id=\"p3\">**</ept>","source":"Sign-extend to **long**; convert **long** to **float**"},{"content":"double","pos":[2568,2574]},{"pos":[2577,2632],"content":"Sign-extend to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept>","source":"Sign-extend to **long**; convert **long** to **double**"},{"pos":[2658,2713],"content":"Sign-extend to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept>","source":"Sign-extend to **long**; convert **long** to **double**"},{"content":"short","pos":[2720,2725]},{"content":"Preserve low-order byte","pos":[2735,2758]},{"content":"short","pos":[2765,2770]},{"content":"long","pos":[2775,2779]},{"content":"Sign-extend","pos":[2782,2793]},{"content":"short","pos":[2800,2805]},{"content":"Preserve low-order byte","pos":[2824,2847]},{"content":"short","pos":[2854,2859]},{"content":"unsigned short","pos":[2864,2878]},{"content":"Preserve bit pattern; high-order bit loses function as sign bit","pos":[2881,2944]},{"content":"short","pos":[2951,2956]},{"pos":[2975,3019],"content":"Sign-extend to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to","source":"Sign-extend to **long**; convert **long** to "},{"content":"short","pos":[3042,3047]},{"content":"float","pos":[3052,3057]},{"pos":[3060,3114],"content":"Sign-extend to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>float<ept id=\"p3\">**</ept>","source":"Sign-extend to **long**; convert **long** to **float**"},{"content":"short","pos":[3121,3126]},{"content":"double","pos":[3131,3137]},{"pos":[3140,3195],"content":"Sign-extend to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept>","source":"Sign-extend to **long**; convert **long** to **double**"},{"content":"short","pos":[3202,3207]},{"pos":[3224,3279],"content":"Sign-extend to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept>","source":"Sign-extend to **long**; convert **long** to **double**"},{"content":"long","pos":[3286,3290]},{"content":"Preserve low-order byte","pos":[3300,3323]},{"content":"long","pos":[3330,3334]},{"content":"short","pos":[3339,3344]},{"content":"Preserve low-order word","pos":[3347,3370]},{"content":"long","pos":[3377,3381]},{"content":"Preserve low-order byte","pos":[3400,3423]},{"content":"long","pos":[3430,3434]},{"content":"unsigned short","pos":[3439,3453]},{"content":"Preserve low-order word","pos":[3456,3479]},{"content":"long","pos":[3486,3490]},{"content":"Preserve bit pattern; high-order bit loses function as sign bit","pos":[3509,3572]},{"content":"long","pos":[3579,3583]},{"content":"float","pos":[3588,3593]},{"content":"Represent as <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[3596,3619],"source":"Represent as **float**."},{"content":"If <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> cannot be represented exactly, some precision is lost.","pos":[3620,3686],"source":" If **long** cannot be represented exactly, some precision is lost."},{"content":"long","pos":[3693,3697]},{"content":"double","pos":[3702,3708]},{"content":"Represent as <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>.","pos":[3711,3735],"source":"Represent as **double**."},{"content":"If <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> cannot be represented exactly as a <bpt id=\"p2\">**</bpt>double<ept id=\"p2\">**</ept>, some precision is lost.","pos":[3736,3818],"source":" If **long** cannot be represented exactly as a **double**, some precision is lost."},{"content":"long","pos":[3825,3829]},{"content":"Represent as <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>.","pos":[3846,3870],"source":"Represent as **double**."},{"content":"If <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> cannot be represented exactly as a <bpt id=\"p2\">**</bpt>double<ept id=\"p2\">**</ept>, some precision is lost.","pos":[3871,3953],"source":" If **long** cannot be represented exactly as a **double**, some precision is lost."},{"pos":[3964,4032],"content":"All <ph id=\"ph1\">`char`</ph> entries assume that the <ph id=\"ph2\">`char`</ph> type is signed by default.","source":"All `char` entries assume that the `char` type is signed by default."},{"content":"Microsoft Specific","pos":[4041,4059]},{"content":"For the Microsoft 32-bit C compiler, an integer is equivalent to a <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>.","pos":[4068,4144],"source":"For the Microsoft 32-bit C compiler, an integer is equivalent to a **long**."},{"content":"Conversion of an <ph id=\"ph1\">`int`</ph> value proceeds the same as for a <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>.","pos":[4145,4210],"source":" Conversion of an `int` value proceeds the same as for a **long**."},{"content":"END Microsoft Specific","pos":[4219,4241]},{"content":"See Also","pos":[4252,4260]},{"content":"Assignment Conversions","pos":[4265,4287]}],"content":"---\ntitle: \"Conversions from Signed Integral Types | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"integral conversions, from signed\"\n  - \"integers, converting\"\n  - \"conversions [C++], integral\"\n  - \"data type conversion [C++], signed and unsigned integers\"\n  - \"type conversion [C++], signed and unsigned integers\"\nms.assetid: 5eea32f8-8b14-413d-acac-c063b3d118d7\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Conversions from Signed Integral Types\nWhen a signed integer is converted to an unsigned integer with equal or greater size and the value of the signed integer is not negative, the value is unchanged. The conversion is made by sign-extending the signed integer. A signed integer is converted to a shorter signed integer by truncating the high-order bits. The result is interpreted as an unsigned value, as shown in this example.  \n  \n```  \nint i = -3;  \nunsigned short u;  \n  \nu = i;   \nprintf_s( \"%hu\\n\", u );  // Prints 65533  \n  \n```  \n  \n No information is lost when a signed integer is converted to a floating value, except that some precision may be lost when a **long int** or **unsigned long int** value is converted to a **float** value.  \n  \n The following table summarizes conversions from signed integral types. This table assumes that the `char` type is signed by default. If you use a compile-time option to change the default for the `char` type to unsigned, the conversions given in the [Conversions from Unsigned Integral Types](../c-language/conversions-from-unsigned-integral-types.md) table for the `unsigned char` type apply instead of the conversions in the following table, Conversions from Signed Integral Types.  \n  \n### Conversions from Signed Integral Types  \n  \n|From|To|Method|  \n|----------|--------|------------|  \n|`char`1|**short**|Sign-extend|  \n|`char`|**long**|Sign-extend|  \n|`char`|`unsigned char`|Preserve pattern; high-order bit loses function as sign bit|  \n|`char`|**unsigned short**|Sign-extend to **short**; convert **short** to **unsigned short**|  \n|`char`|`unsigned long`|Sign-extend to **long**; convert **long** to `unsigned long`|  \n|`char`|**float**|Sign-extend to **long**; convert **long** to **float**|  \n|`char`|**double**|Sign-extend to **long**; convert **long** to **double**|  \n|`char`|`long double`|Sign-extend to **long**; convert **long** to **double**|  \n|**short**|`char`|Preserve low-order byte|  \n|**short**|**long**|Sign-extend|  \n|**short**|`unsigned char`|Preserve low-order byte|  \n|**short**|**unsigned short**|Preserve bit pattern; high-order bit loses function as sign bit|  \n|**short**|`unsigned long`|Sign-extend to **long**; convert **long** to `unsigned long`|  \n|**short**|**float**|Sign-extend to **long**; convert **long** to **float**|  \n|**short**|**double**|Sign-extend to **long**; convert **long** to **double**|  \n|**short**|`long double`|Sign-extend to **long**; convert **long** to **double**|  \n|**long**|`char`|Preserve low-order byte|  \n|**long**|**short**|Preserve low-order word|  \n|**long**|`unsigned char`|Preserve low-order byte|  \n|**long**|**unsigned short**|Preserve low-order word|  \n|**long**|`unsigned long`|Preserve bit pattern; high-order bit loses function as sign bit|  \n|**long**|**float**|Represent as **float**. If **long** cannot be represented exactly, some precision is lost.|  \n|**long**|**double**|Represent as **double**. If **long** cannot be represented exactly as a **double**, some precision is lost.|  \n|**long**|`long double`|Represent as **double**. If **long** cannot be represented exactly as a **double**, some precision is lost.|  \n  \n 1. All `char` entries assume that the `char` type is signed by default.  \n  \n **Microsoft Specific**  \n  \n For the Microsoft 32-bit C compiler, an integer is equivalent to a **long**. Conversion of an `int` value proceeds the same as for a **long**.  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [Assignment Conversions](../c-language/assignment-conversions.md)"}