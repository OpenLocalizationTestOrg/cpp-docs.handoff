{"nodes":[{"pos":[12,65],"content":"Message Handling and Command Targets | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Message Handling and Command Targets | Microsoft Docs","pos":[0,53]}]},{"content":"Message Handling and Command Targets","pos":[742,778]},{"content":"The command dispatch interface <ph id=\"ph1\">`IOleCommandTarget`</ph> defines a simple and extensible mechanism to query and execute commands.","pos":[779,902],"source":"The command dispatch interface `IOleCommandTarget` defines a simple and extensible mechanism to query and execute commands."},{"content":"This mechanism is simpler than Automation's <ph id=\"ph1\">`IDispatch`</ph> because it relies entirely on a standard set of commands; commands rarely have arguments, and no type information is involved (type safety is diminished for command arguments as well).","pos":[903,1143],"source":" This mechanism is simpler than Automation's `IDispatch` because it relies entirely on a standard set of commands; commands rarely have arguments, and no type information is involved (type safety is diminished for command arguments as well)."},{"content":"In the command dispatch interface design, each command belongs to a \"command group\" which is itself identified with a <bpt id=\"p1\">**</bpt>GUID<ept id=\"p1\">**</ept>.","pos":[1150,1277],"source":"In the command dispatch interface design, each command belongs to a \"command group\" which is itself identified with a **GUID**."},{"content":"Therefore, anyone can define a new group and define all the commands within that group without any need to coordinate with Microsoft or any other vendor.","pos":[1278,1431]},{"content":"(This is essentially the same means of definition as a <bpt id=\"p1\">**</bpt>dispinterface<ept id=\"p1\">**</ept> plus <bpt id=\"p2\">**</bpt>dispIDs<ept id=\"p2\">**</ept> in Automation.","pos":[1432,1536],"source":" (This is essentially the same means of definition as a **dispinterface** plus **dispIDs** in Automation."},{"content":"There is overlap here, although this command routing mechanism is only for command routing and not for scripting/programmability on a large scale as Automation handles.)","pos":[1537,1706]},{"pos":[1733,1765],"content":"handles the following scenarios:"},{"content":"When an object is in-place activated, only the object's toolbars are typically displayed and the object's toolbars may have buttons for some of the container commands like <bpt id=\"p1\">**</bpt>Print<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Print Preview<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>Save<ept id=\"p3\">**</ept>, <ph id=\"ph1\">`New`</ph>, <bpt id=\"p4\">**</bpt>Zoom<ept id=\"p4\">**</ept>, and others.","pos":[1775,2015],"source":"When an object is in-place activated, only the object's toolbars are typically displayed and the object's toolbars may have buttons for some of the container commands like **Print**, **Print Preview**, **Save**, `New`, **Zoom**, and others."},{"content":"(In-place activation standards recommend that objects remove such buttons from their toolbars, or at least disable them.","pos":[2016,2136]},{"content":"This design allows those commands to be enabled and yet routed to the right handler.) Currently, there is no mechanism for the object to dispatch these commands to the container.","pos":[2137,2315]},{"pos":[2325,2550],"content":"When an active document is embedded in an active document container (such as Office Binder), the container may need to send commands such <bpt id=\"p1\">**</bpt>Print<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Page Setup<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>Properties<ept id=\"p3\">**</ept>, and others to the contained active document.","source":"When an active document is embedded in an active document container (such as Office Binder), the container may need to send commands such **Print**, **Page Setup**, **Properties**, and others to the contained active document."},{"content":"This simple command routing could be handled through existing Automation standards and <ph id=\"ph1\">`IDispatch`</ph>.","pos":[2557,2656],"source":"This simple command routing could be handled through existing Automation standards and `IDispatch`."},{"content":"However, the overhead involved with <ph id=\"ph1\">`IDispatch`</ph> is more than is necessary here, so <ph id=\"ph2\">`IOleCommandTarget`</ph> provides a simpler means to achieve the same ends:","pos":[2657,2810],"source":" However, the overhead involved with `IDispatch` is more than is necessary here, so `IOleCommandTarget` provides a simpler means to achieve the same ends:"},{"content":"The <ph id=\"ph1\">`QueryStatus`</ph> method here tests whether a particular set of commands, the set being identified with a <bpt id=\"p1\">**</bpt>GUID<ept id=\"p1\">**</ept>, is supported.","pos":[3248,3377],"source":"The `QueryStatus` method here tests whether a particular set of commands, the set being identified with a **GUID**, is supported."},{"content":"This call fills an array of <bpt id=\"p1\">**</bpt>OLECMD<ept id=\"p1\">**</ept> values (structures) with the supported list of commands as well as returning text describing the name of a command and/or status information.","pos":[3378,3558],"source":" This call fills an array of **OLECMD** values (structures) with the supported list of commands as well as returning text describing the name of a command and/or status information."},{"content":"When the caller wishes to invoke a command, it can pass the command (and the set <bpt id=\"p1\">**</bpt>GUID<ept id=\"p1\">**</ept>) to <bpt id=\"p2\">**</bpt>Exec<ept id=\"p2\">**</ept> along with options and arguments, getting back a return value.","pos":[3559,3724],"source":" When the caller wishes to invoke a command, it can pass the command (and the set **GUID**) to **Exec** along with options and arguments, getting back a return value."},{"content":"See Also","pos":[3733,3741]},{"content":"Active Document Containers","pos":[3746,3772]}],"content":"---\ntitle: \"Message Handling and Command Targets | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"IOleCommandTarget\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"command targets\"\n  - \"message handling, active documents\"\n  - \"IOleCommandTarget interface\"\n  - \"command routing, command targets\"\nms.assetid: e45ce14c-e6b6-4262-8f3b-4e891e0ec2a3\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Message Handling and Command Targets\nThe command dispatch interface `IOleCommandTarget` defines a simple and extensible mechanism to query and execute commands. This mechanism is simpler than Automation's `IDispatch` because it relies entirely on a standard set of commands; commands rarely have arguments, and no type information is involved (type safety is diminished for command arguments as well).  \n  \n In the command dispatch interface design, each command belongs to a \"command group\" which is itself identified with a **GUID**. Therefore, anyone can define a new group and define all the commands within that group without any need to coordinate with Microsoft or any other vendor. (This is essentially the same means of definition as a **dispinterface** plus **dispIDs** in Automation. There is overlap here, although this command routing mechanism is only for command routing and not for scripting/programmability on a large scale as Automation handles.)  \n  \n `IOleCommandTarget` handles the following scenarios:  \n  \n-   When an object is in-place activated, only the object's toolbars are typically displayed and the object's toolbars may have buttons for some of the container commands like **Print**, **Print Preview**, **Save**, `New`, **Zoom**, and others. (In-place activation standards recommend that objects remove such buttons from their toolbars, or at least disable them. This design allows those commands to be enabled and yet routed to the right handler.) Currently, there is no mechanism for the object to dispatch these commands to the container.  \n  \n-   When an active document is embedded in an active document container (such as Office Binder), the container may need to send commands such **Print**, **Page Setup**, **Properties**, and others to the contained active document.  \n  \n This simple command routing could be handled through existing Automation standards and `IDispatch`. However, the overhead involved with `IDispatch` is more than is necessary here, so `IOleCommandTarget` provides a simpler means to achieve the same ends:  \n  \n `interface IOleCommandTarget : IUnknown`  \n  \n `{`  \n  \n `HRESULT QueryStatus(`  \n  \n `[in] GUID *pguidCmdGroup,`  \n  \n `[in] ULONG cCmds,`  \n  \n `[in,out][size_is(cCmds)] OLECMD *prgCmds,`  \n  \n `[in,out] OLECMDTEXT *pCmdText);`  \n  \n `HRESULT Exec(`  \n  \n `[in] GUID *pguidCmdGroup,`  \n  \n `[in] DWORD nCmdID,`  \n  \n `[in] DWORD nCmdExecOpt,`  \n  \n `[in] VARIANTARG *pvaIn,`  \n  \n `[in,out] VARIANTARG *pvaOut);`  \n  \n `}`  \n  \n The `QueryStatus` method here tests whether a particular set of commands, the set being identified with a **GUID**, is supported. This call fills an array of **OLECMD** values (structures) with the supported list of commands as well as returning text describing the name of a command and/or status information. When the caller wishes to invoke a command, it can pass the command (and the set **GUID**) to **Exec** along with options and arguments, getting back a return value.  \n  \n## See Also  \n [Active Document Containers](../mfc/active-document-containers.md)\n\n"}