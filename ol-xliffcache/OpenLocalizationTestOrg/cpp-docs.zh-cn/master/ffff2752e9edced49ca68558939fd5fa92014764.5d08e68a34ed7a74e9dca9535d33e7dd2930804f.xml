{"nodes":[{"pos":[12,37],"content":"code_seg | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"code_seg | Microsoft Docs","pos":[0,25]}]},{"content":"code_seg","pos":[651,659]},{"content":"Specifies the text segment where functions are stored in the .obj file.","pos":[660,731]},{"content":"Syntax","pos":[740,746]},{"content":"Remarks","pos":[870,877]},{"content":"The <ph id=\"ph1\">`code_seg`</ph> pragma directive does not control placement of object code generated for instantiated templates, nor code generated implicitly by the compiler—for example, special member functions.","pos":[881,1077],"source":"The `code_seg` pragma directive does not control placement of object code generated for instantiated templates, nor code generated implicitly by the compiler—for example, special member functions."},{"content":"We recommend that you use the <bpt id=\"p1\">[</bpt>__declspec(code_seg(...))<ept id=\"p1\">](../cpp/code-seg-declspec.md)</ept> attribute instead because it gives you control over placement of all object code.","pos":[1078,1246],"source":" We recommend that you use the [__declspec(code_seg(...))](../cpp/code-seg-declspec.md) attribute instead because it gives you control over placement of all object code."},{"content":"This includes compiler-generated code.","pos":[1247,1285]},{"content":"A <bpt id=\"p1\">*</bpt>segment<ept id=\"p1\">*</ept> in an .obj file is a named block of data that's loaded into memory as a unit.","pos":[1292,1381],"source":"A *segment* in an .obj file is a named block of data that's loaded into memory as a unit."},{"content":"A <bpt id=\"p1\">*</bpt>text segment<ept id=\"p1\">*</ept> is a segment that contains executable code.","pos":[1382,1442],"source":" A *text segment* is a segment that contains executable code."},{"content":"In this article, the terms <bpt id=\"p1\">*</bpt>segment<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>section<ept id=\"p2\">*</ept> are used interchangeably.","pos":[1443,1519],"source":" In this article, the terms *segment* and *section* are used interchangeably."},{"content":"The <ph id=\"ph1\">`code_seg`</ph> pragma directive tells the compiler to put all subsequent object code from the translation unit into a text segment named <ph id=\"ph2\">`segment-name`</ph>.","pos":[1526,1678],"source":"The `code_seg` pragma directive tells the compiler to put all subsequent object code from the translation unit into a text segment named `segment-name`."},{"content":"By default, the text segment used for functions in an .obj file is named .text.","pos":[1679,1758]},{"pos":[1765,1883],"content":"A <ph id=\"ph1\">`code_seg`</ph> pragma directive without parameters resets the text segment name for the subsequent object code to .text.","source":"A `code_seg` pragma directive without parameters resets the text segment name for the subsequent object code to .text."},{"content":"<bpt id=\"p1\">**</bpt>Push<ept id=\"p1\">**</ept> (optional)","pos":[1890,1909],"source":"**Push** (optional)"},{"content":"Puts a record on the internal compiler stack.","pos":[1913,1958]},{"content":"A <bpt id=\"p1\">**</bpt>push<ept id=\"p1\">**</ept> can have an <ph id=\"ph1\">`identifier`</ph> and <ph id=\"ph2\">`segment-name`</ph>.","pos":[1959,2014],"source":" A **push** can have an `identifier` and `segment-name`."},{"content":"<bpt id=\"p1\">**</bpt>pop<ept id=\"p1\">**</ept> (optional)","pos":[2021,2039],"source":"**pop** (optional)"},{"content":"Removes a record from the top of the internal compiler stack.","pos":[2043,2104]},{"content":"(optional)","pos":[2124,2134]},{"content":"When used with <bpt id=\"p1\">**</bpt>push<ept id=\"p1\">**</ept>, assigns a name to the record on the internal compiler stack.","pos":[2138,2223],"source":" When used with **push**, assigns a name to the record on the internal compiler stack."},{"content":"When used with <bpt id=\"p1\">**</bpt>pop<ept id=\"p1\">**</ept>, pops records off the internal stack until <ph id=\"ph1\">`identifier`</ph> is removed; if <ph id=\"ph2\">`identifier`</ph> is not found on the internal stack, nothing is popped.","pos":[2224,2385],"source":" When used with **pop**, pops records off the internal stack until `identifier` is removed; if `identifier` is not found on the internal stack, nothing is popped."},{"pos":[2405,2473],"content":"enables multiple records to be popped with just one <bpt id=\"p1\">**</bpt>pop<ept id=\"p1\">**</ept> command.","source":" enables multiple records to be popped with just one **pop** command."},{"content":"\"<ph id=\"ph1\">`segment-name`</ph>\" (optional)","pos":[2480,2507],"source":"\"`segment-name`\" (optional)"},{"content":"The name of a segment.","pos":[2511,2533]},{"content":"When used with <bpt id=\"p1\">**</bpt>pop<ept id=\"p1\">**</ept>, the stack is popped and <ph id=\"ph1\">`segment-name`</ph> becomes the active text segment name.","pos":[2534,2634],"source":" When used with **pop**, the stack is popped and `segment-name` becomes the active text segment name."},{"content":"\"<ph id=\"ph1\">`segment-class`</ph>\" (optional)","pos":[2641,2669],"source":"\"`segment-class`\" (optional)"},{"content":"Ignored, but included for compatibility with versions of C++ earlier than version 2.0.","pos":[2673,2759]},{"content":"You can use the <bpt id=\"p1\">[</bpt>DUMPBIN.EXE<ept id=\"p1\">](../build/reference/dumpbin-command-line.md)</ept> application to view .obj files.","pos":[2766,2871],"source":"You can use the [DUMPBIN.EXE](../build/reference/dumpbin-command-line.md) application to view .obj files."},{"content":"Versions of DUMPBIN for each supported target architecture are included with <ph id=\"ph1\">[!INCLUDE[vsprvs](../assembler/masm/includes/vsprvs_md.md)]</ph>.","pos":[2872,3009],"source":" Versions of DUMPBIN for each supported target architecture are included with [!INCLUDE[vsprvs](../assembler/masm/includes/vsprvs_md.md)]."},{"content":"Example","pos":[3018,3025]},{"pos":[3029,3127],"content":"This example shows how to use the <ph id=\"ph1\">`code_seg`</ph> pragma directive to control where object code is put:","source":"This example shows how to use the `code_seg` pragma directive to control where object code is put:"},{"pos":[3542,3680],"content":"For a list of names that should not be used to create a section, see <bpt id=\"p1\">[</bpt>/SECTION<ept id=\"p1\">](../build/reference/section-specify-section-attributes.md)</ept>.","source":"For a list of names that should not be used to create a section, see [/SECTION](../build/reference/section-specify-section-attributes.md)."},{"pos":[3687,3905],"content":"You can also specify sections for initialized data (<bpt id=\"p1\">[</bpt>data_seg<ept id=\"p1\">](../preprocessor/data-seg.md)</ept>), uninitialized data (<bpt id=\"p2\">[</bpt>bss_seg<ept id=\"p2\">](../preprocessor/bss-seg.md)</ept>), and const variables (<bpt id=\"p3\">[</bpt>const_seg<ept id=\"p3\">](../preprocessor/const-seg.md)</ept>).","source":"You can also specify sections for initialized data ([data_seg](../preprocessor/data-seg.md)), uninitialized data ([bss_seg](../preprocessor/bss-seg.md)), and const variables ([const_seg](../preprocessor/const-seg.md))."},{"content":"See Also","pos":[3914,3922]},{"content":"code_seg (__declspec)","pos":[3927,3948]},{"content":"Pragma Directives and the __Pragma Keyword","pos":[3984,4026]}],"content":"---\ntitle: \"code_seg | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"code_seg_CPP\"\n  - \"vc-pragma.code_seg\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"pragmas, code_seg\"\n  - \"code_seg pragma\"\nms.assetid: bf4faac1-a511-46a6-8d9e-456851d97d56\ncaps.latest.revision: 9\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# code_seg\nSpecifies the text segment where functions are stored in the .obj file.  \n  \n## Syntax  \n  \n```  \n#pragma code_seg( [ [ { push | pop }, ] [ identifier, ] ] [ \"segment-name\" [, \"segment-class\" ] )  \n```  \n  \n## Remarks  \n The `code_seg` pragma directive does not control placement of object code generated for instantiated templates, nor code generated implicitly by the compiler—for example, special member functions. We recommend that you use the [__declspec(code_seg(...))](../cpp/code-seg-declspec.md) attribute instead because it gives you control over placement of all object code. This includes compiler-generated code.  \n  \n A *segment* in an .obj file is a named block of data that's loaded into memory as a unit. A *text segment* is a segment that contains executable code. In this article, the terms *segment* and *section* are used interchangeably.  \n  \n The `code_seg` pragma directive tells the compiler to put all subsequent object code from the translation unit into a text segment named `segment-name`. By default, the text segment used for functions in an .obj file is named .text.  \n  \n A `code_seg` pragma directive without parameters resets the text segment name for the subsequent object code to .text.  \n  \n **Push** (optional)  \n Puts a record on the internal compiler stack. A **push** can have an `identifier` and `segment-name`.  \n  \n **pop** (optional)  \n Removes a record from the top of the internal compiler stack.  \n  \n `identifier` (optional)  \n When used with **push**, assigns a name to the record on the internal compiler stack. When used with **pop**, pops records off the internal stack until `identifier` is removed; if `identifier` is not found on the internal stack, nothing is popped.  \n  \n `identifier` enables multiple records to be popped with just one **pop** command.  \n  \n \"`segment-name`\" (optional)  \n The name of a segment. When used with **pop**, the stack is popped and `segment-name` becomes the active text segment name.  \n  \n \"`segment-class`\" (optional)  \n Ignored, but included for compatibility with versions of C++ earlier than version 2.0.  \n  \n You can use the [DUMPBIN.EXE](../build/reference/dumpbin-command-line.md) application to view .obj files. Versions of DUMPBIN for each supported target architecture are included with [!INCLUDE[vsprvs](../assembler/masm/includes/vsprvs_md.md)].  \n  \n## Example  \n This example shows how to use the `code_seg` pragma directive to control where object code is put:  \n  \n```  \n// pragma_directive_code_seg.cpp  \nvoid func1() {                  // stored in .text  \n}  \n  \n#pragma code_seg(\".my_data1\")  \nvoid func2() {                  // stored in my_data1  \n}  \n  \n#pragma code_seg(push, r1, \".my_data2\")  \nvoid func3() {                  // stored in my_data2  \n}  \n  \n#pragma code_seg(pop, r1)      // stored in my_data1  \nvoid func4() {  \n}  \n  \nint main() {  \n}  \n```  \n  \n For a list of names that should not be used to create a section, see [/SECTION](../build/reference/section-specify-section-attributes.md).  \n  \n You can also specify sections for initialized data ([data_seg](../preprocessor/data-seg.md)), uninitialized data ([bss_seg](../preprocessor/bss-seg.md)), and const variables ([const_seg](../preprocessor/const-seg.md)).  \n  \n## See Also  \n [code_seg (__declspec)](../cpp/code-seg-declspec.md)   \n [Pragma Directives and the __Pragma Keyword](../preprocessor/pragma-directives-and-the-pragma-keyword.md)"}