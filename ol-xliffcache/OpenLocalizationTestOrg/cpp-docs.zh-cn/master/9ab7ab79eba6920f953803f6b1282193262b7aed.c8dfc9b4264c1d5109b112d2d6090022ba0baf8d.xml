{"nodes":[{"pos":[12,97],"content":"A.19   Examples Showing Incorrect Nesting of Work-sharing Directives | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"A.19   Examples Showing Incorrect Nesting of Work-sharing Directives | Microsoft Docs","pos":[0,85]}]},{"content":"A.19   Examples Showing Incorrect Nesting of Work-sharing Directives","pos":[577,645]},{"content":"The examples in this section illustrate the directive nesting rules.","pos":[646,714]},{"content":"For more information on directive nesting, see <bpt id=\"p1\">[</bpt>Section 2.9<ept id=\"p1\">](../../parallel/openmp/2-9-directive-nesting.md)</ept> on page 33.","pos":[715,835],"source":" For more information on directive nesting, see [Section 2.9](../../parallel/openmp/2-9-directive-nesting.md) on page 33."},{"pos":[842,978],"content":"The following example is noncompliant because the inner and outer <ph id=\"ph1\">`for`</ph> directives are nested and bind to the same <ph id=\"ph2\">`parallel`</ph> directive:","source":"The following example is noncompliant because the inner and outer `for` directives are nested and bind to the same `parallel` directive:"},{"content":"The following dynamically nested version of the preceding example is also noncompliant:","pos":[1259,1346]},{"pos":[1652,1786],"content":"The following example is noncompliant because the <ph id=\"ph1\">`for`</ph> and <ph id=\"ph2\">`single`</ph> directives are nested, and they bind to the same parallel region:","source":"The following example is noncompliant because the `for` and `single` directives are nested, and they bind to the same parallel region:"},{"pos":[2015,2121],"content":"The following example is noncompliant because a <ph id=\"ph1\">`barrier`</ph> directive inside a <ph id=\"ph2\">`for`</ph> can result in deadlock:","source":"The following example is noncompliant because a `barrier` directive inside a `for` can result in deadlock:"},{"pos":[2370,2528],"content":"The following example is noncompliant because the <ph id=\"ph1\">`barrier`</ph> results in deadlock due to the fact that only one thread at a time can enter the critical section:","source":"The following example is noncompliant because the `barrier` results in deadlock due to the fact that only one thread at a time can enter the critical section:"},{"pos":[2719,2866],"content":"The following example is noncompliant because the <ph id=\"ph1\">`barrier`</ph> results in deadlock due to the fact that only one thread executes the <ph id=\"ph2\">`single`</ph> section:","source":"The following example is noncompliant because the `barrier` results in deadlock due to the fact that only one thread executes the `single` section:"}],"content":"---\ntitle: \"A.19   Examples Showing Incorrect Nesting of Work-sharing Directives | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 906e900d-9259-44d6-a095-c1ba9135d269\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# A.19   Examples Showing Incorrect Nesting of Work-sharing Directives\nThe examples in this section illustrate the directive nesting rules. For more information on directive nesting, see [Section 2.9](../../parallel/openmp/2-9-directive-nesting.md) on page 33.  \n  \n The following example is noncompliant because the inner and outer `for` directives are nested and bind to the same `parallel` directive:  \n  \n```  \nvoid wrong1(int n)  \n{  \n  #pragma omp parallel default(shared)  \n  {  \n      int i, j;  \n      #pragma omp for  \n      for (i=0; i<n; i++) {  \n          #pragma omp for  \n              for (j=0; j<n; j++)  \n                 work(i, j);  \n     }  \n   }  \n}  \n```  \n  \n The following dynamically nested version of the preceding example is also noncompliant:  \n  \n```  \nvoid wrong2(int n)  \n{  \n  #pragma omp parallel default(shared)  \n  {  \n    int i;  \n    #pragma omp for  \n      for (i=0; i<n; i++)  \n        work1(i, n);  \n  }  \n}  \n  \nvoid work1(int i, int n)  \n{  \n  int j;  \n  #pragma omp for  \n    for (j=0; j<n; j++)  \n      work2(i, j);  \n}  \n```  \n  \n The following example is noncompliant because the `for` and `single` directives are nested, and they bind to the same parallel region:  \n  \n```  \nvoid wrong3(int n)  \n{  \n  #pragma omp parallel default(shared)  \n  {  \n    int i;  \n    #pragma omp for  \n      for (i=0; i<n; i++) {  \n        #pragma omp single  \n          work(i);  \n      }  \n  }  \n}  \n```  \n  \n The following example is noncompliant because a `barrier` directive inside a `for` can result in deadlock:  \n  \n```  \nvoid wrong4(int n)  \n{  \n  #pragma omp parallel default(shared)  \n  {  \n    int i;  \n    #pragma omp for  \n      for (i=0; i<n; i++) {  \n        work1(i);  \n        #pragma omp barrier  \n        work2(i);  \n      }  \n  }  \n}  \n```  \n  \n The following example is noncompliant because the `barrier` results in deadlock due to the fact that only one thread at a time can enter the critical section:  \n  \n```  \nvoid wrong5()  \n{  \n  #pragma omp parallel  \n  {  \n    #pragma omp critical  \n    {  \n       work1();  \n       #pragma omp barrier  \n       work2();  \n    }  \n  }  \n}  \n```  \n  \n The following example is noncompliant because the `barrier` results in deadlock due to the fact that only one thread executes the `single` section:  \n  \n```  \nvoid wrong6()  \n{  \n  #pragma omp parallel  \n  {  \n    setup();  \n    #pragma omp single  \n    {  \n      work1();  \n      #pragma omp barrier  \n      work2();  \n    }  \n    finish();  \n  }  \n}  \n```"}