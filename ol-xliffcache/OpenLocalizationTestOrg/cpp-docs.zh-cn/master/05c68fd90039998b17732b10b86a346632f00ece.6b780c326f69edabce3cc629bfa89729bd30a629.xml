{"nodes":[{"pos":[12,49],"content":"Overloaded Operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Overloaded Operators | Microsoft Docs","pos":[0,37]}]},{"content":"Overloaded Operators","pos":[629,649]},{"pos":[650,804],"content":"Operator overloading has changed significantly from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"Operator overloading has changed significantly from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"In the declaration of a reference type, for example, rather than using the native <ph id=\"ph1\">`operator+`</ph> syntax, you explicitly write out the underlying internal name of the operator – in this case, <ph id=\"ph2\">`op_Addition`</ph>.","pos":[811,1013],"source":"In the declaration of a reference type, for example, rather than using the native `operator+` syntax, you explicitly write out the underlying internal name of the operator – in this case, `op_Addition`."},{"content":"In addition, the invocation of an operator has to be explicitly invoked through that name, thus precluding the two primary benefits of operator overloading: (a) the intuitive syntax, and (b) the ability to intermix new types with existing types.","pos":[1014,1259]},{"content":"For example:","pos":[1260,1272]},{"content":"In the new syntax, the usual expectations of a native C++ programmer are restored, both in the declaration and use of the static operators.","pos":[2002,2141]},{"content":"Here is the <ph id=\"ph1\">`Vector`</ph> class translated into the new syntax:","pos":[2142,2200],"source":" Here is the `Vector` class translated into the new syntax:"},{"content":"See Also","pos":[2835,2843]},{"content":"Member Declarations within a Class or Interface (C++/CLI)","pos":[2848,2905]}],"content":"---\ntitle: \"Overloaded Operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"operator overloading, in a CLR class\"\n  - \"operators [C++], overloading\"\nms.assetid: 30391426-afe7-4497-bf22-e4816c1e48c8\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Overloaded Operators\nOperator overloading has changed significantly from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n In the declaration of a reference type, for example, rather than using the native `operator+` syntax, you explicitly write out the underlying internal name of the operator – in this case, `op_Addition`. In addition, the invocation of an operator has to be explicitly invoked through that name, thus precluding the two primary benefits of operator overloading: (a) the intuitive syntax, and (b) the ability to intermix new types with existing types. For example:  \n  \n```  \npublic __gc __sealed class Vector {  \npublic:  \n   Vector( double x, double y, double z );  \n  \n   static bool    op_Equality( const Vector*, const Vector* );  \n   static Vector* op_Division( const Vector*, double );  \n   static Vector* op_Addition( const Vector*, const Vector* );  \n   static Vector* op_Subtraction( const Vector*, const Vector* );  \n};  \n  \nint main()  \n{  \n   Vector *pa = new Vector( 0.231, 2.4745, 0.023 );  \n   Vector *pb = new Vector( 1.475, 4.8916, -1.23 );   \n  \n   Vector *pc1 = Vector::op_Addition( pa, pb );  \n   Vector *pc2 = Vector::op_Subtraction( pa, pc1 );  \n   Vector *pc3 = Vector::op_Division( pc1, pc2->x );  \n  \n   if ( Vector::op_Equality( pc1, pc2 ))  \n      ;  \n}  \n```  \n  \n In the new syntax, the usual expectations of a native C++ programmer are restored, both in the declaration and use of the static operators. Here is the `Vector` class translated into the new syntax:  \n  \n```  \npublic ref class Vector sealed {  \npublic:  \n   Vector( double x, double y, double z );  \n  \n   static bool    operator ==( const Vector^, const Vector^ );  \n   static Vector^ operator /( const Vector^, double );  \n   static Vector^ operator +( const Vector^, const Vector^ );  \n   static Vector^ operator -( const Vector^, const Vector^ );  \n};  \n  \nint main()  \n{  \n   Vector^ pa = gcnew Vector( 0.231, 2.4745, 0.023 );  \n   Vector^ pb = gcnew Vector( 1.475,4.8916,-1.23 );  \n  \n   Vector^ pc1 = pa + pb;  \n   Vector^ pc2 = pa - pc1;  \n   Vector^ pc3 = pc1 / pc2->x;  \n  \n   if ( pc1 == pc2 )  \n      ;  \n}  \n```  \n  \n## See Also  \n [Member Declarations within a Class or Interface (C++/CLI)](../dotnet/member-declarations-within-a-class-or-interface-cpp-cli.md)"}