{"nodes":[{"pos":[12,87],"content":"Implementing CComObject, CComAggObject, and CComPolyObject | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Implementing CComObject, CComAggObject, and CComPolyObject | Microsoft Docs","pos":[0,75]}]},{"content":"Implementing CComObject, CComAggObject, and CComPolyObject","pos":[794,852]},{"content":"The template classes <bpt id=\"p1\">[</bpt>CComObject<ept id=\"p1\">](../atl/reference/ccomobject-class.md)</ept>, <bpt id=\"p2\">[</bpt>CComAggObject<ept id=\"p2\">](../atl/reference/ccomaggobject-class.md)</ept>, and <bpt id=\"p3\">[</bpt>CComPolyObject<ept id=\"p3\">](../atl/reference/ccompolyobject-class.md)</ept> are always the most derived classes in the inheritance chain.","pos":[853,1108],"source":"The template classes [CComObject](../atl/reference/ccomobject-class.md), [CComAggObject](../atl/reference/ccomaggobject-class.md), and [CComPolyObject](../atl/reference/ccompolyobject-class.md) are always the most derived classes in the inheritance chain."},{"content":"It is their responsibility to handle all of the methods in <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept>: <ph id=\"ph1\">`QueryInterface`</ph>, <ph id=\"ph2\">`AddRef`</ph>, and <bpt id=\"p2\">**</bpt>Release<ept id=\"p2\">**</ept>.","pos":[1109,1226],"source":" It is their responsibility to handle all of the methods in **IUnknown**: `QueryInterface`, `AddRef`, and **Release**."},{"content":"In addition, <ph id=\"ph1\">`CComAggObject`</ph> and <ph id=\"ph2\">`CComPolyObject`</ph> (when used for aggregated objects) provide the special reference counting and <ph id=\"ph3\">`QueryInterface`</ph> semantics required for the inner unknown.","pos":[1227,1413],"source":" In addition, `CComAggObject` and `CComPolyObject` (when used for aggregated objects) provide the special reference counting and `QueryInterface` semantics required for the inner unknown."},{"pos":[1420,1556],"content":"Whether <ph id=\"ph1\">`CComObject`</ph>, <ph id=\"ph2\">`CComAggObject`</ph>, or <ph id=\"ph3\">`CComPolyObject`</ph> is used depends on whether you declare one (or none) of the following macros:","source":"Whether `CComObject`, `CComAggObject`, or `CComPolyObject` is used depends on whether you declare one (or none) of the following macros:"},{"content":"Macro","pos":[1563,1568]},{"content":"Effect","pos":[1569,1575]},{"pos":[1636,1661],"content":"Always uses <ph id=\"ph1\">`CComObject`</ph>.","source":"Always uses `CComObject`."},{"content":"Uses <ph id=\"ph1\">`CComAggObject`</ph> if the object is aggregated and <ph id=\"ph2\">`CComObject`</ph> if it is not.","pos":[1689,1768],"source":"Uses `CComAggObject` if the object is aggregated and `CComObject` if it is not."},{"content":"contains this macro so if none of the <bpt id=\"p1\">**</bpt>DECLARE_<ph id=\"ph1\">\\*</ph>_AGGREGATABLE<ept id=\"p1\">**</ept> macros are declared in your class, this will be the default.","pos":[1783,1909],"source":" contains this macro so if none of the **DECLARE_\\*_AGGREGATABLE** macros are declared in your class, this will be the default."},{"content":"Always uses <ph id=\"ph1\">`CComAggObject`</ph>.","pos":[1942,1970],"source":"Always uses `CComAggObject`."},{"content":"Returns an error if the object is not aggregated.","pos":[1971,2020]},{"content":"ATL creates an instance of <bpt id=\"p1\">**</bpt>CComPolyObject<ph id=\"ph1\">\\&lt;</ph>CYourClass&gt;<ept id=\"p1\">**</ept> when <bpt id=\"p2\">**</bpt>IClassFactory::CreateInstance<ept id=\"p2\">**</ept> is called.","pos":[2053,2161],"source":"ATL creates an instance of **CComPolyObject\\<CYourClass>** when **IClassFactory::CreateInstance** is called."},{"content":"During creation, the value of the outer unknown is checked.","pos":[2162,2221]},{"content":"If it is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>IUnknown<ept id=\"p2\">**</ept> is implemented for a nonaggregated object.","pos":[2222,2296],"source":" If it is **NULL**, **IUnknown** is implemented for a nonaggregated object."},{"content":"If the outer unknown is not <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>IUnknown<ept id=\"p2\">**</ept> is implemented for an aggregated object.","pos":[2297,2388],"source":" If the outer unknown is not **NULL**, **IUnknown** is implemented for an aggregated object."},{"content":"The advantage of using <ph id=\"ph1\">`CComAggObject`</ph> and <ph id=\"ph2\">`CComObject`</ph> is that the implementation of <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> is optimized for the kind of object being created.","pos":[2396,2545],"source":"The advantage of using `CComAggObject` and `CComObject` is that the implementation of **IUnknown** is optimized for the kind of object being created."},{"content":"For instance, a nonaggregated object only needs a reference count, while an aggregated object needs both a reference count for the inner unknown and a pointer to the outer unknown.","pos":[2546,2726]},{"content":"The advantage of using <ph id=\"ph1\">`CComPolyObject`</ph> is that you avoid having both <ph id=\"ph2\">`CComAggObject`</ph> and <ph id=\"ph3\">`CComObject`</ph> in your module to handle the aggregated and nonaggregated cases.","pos":[2733,2900],"source":"The advantage of using `CComPolyObject` is that you avoid having both `CComAggObject` and `CComObject` in your module to handle the aggregated and nonaggregated cases."},{"content":"A single <ph id=\"ph1\">`CComPolyObject`</ph> object handles both cases.","pos":[2901,2953],"source":" A single `CComPolyObject` object handles both cases."},{"content":"This means only one copy of the vtable and one copy of the functions exist in your module.","pos":[2954,3044]},{"content":"If your vtable is large, this can substantially decrease your module size.","pos":[3045,3119]},{"content":"However, if your vtable is small, using <ph id=\"ph1\">`CComPolyObject`</ph> can result in a slightly larger module size because it is not optimized for an aggregated or nonaggregated object, as are <ph id=\"ph2\">`CComAggObject`</ph> and <ph id=\"ph3\">`CComObject`</ph>.","pos":[3120,3332],"source":" However, if your vtable is small, using `CComPolyObject` can result in a slightly larger module size because it is not optimized for an aggregated or nonaggregated object, as are `CComAggObject` and `CComObject`."},{"content":"See Also","pos":[3341,3349]},{"content":"Fundamentals of ATL COM Objects","pos":[3354,3385]},{"content":"Aggregation and Class Factory Macros","pos":[3435,3471]}],"content":"---\ntitle: \"Implementing CComObject, CComAggObject, and CComPolyObject | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"CComPolyObject\"\n  - \"CComAggObject\"\n  - \"CComObject\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CComPolyObject class, implementing\"\n  - \"CreateInstance method\"\n  - \"CComAggObject class\"\n  - \"CComObject class, implementing\"\nms.assetid: 5aabe938-104d-492e-9c41-9f7fb1c62098\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Implementing CComObject, CComAggObject, and CComPolyObject\nThe template classes [CComObject](../atl/reference/ccomobject-class.md), [CComAggObject](../atl/reference/ccomaggobject-class.md), and [CComPolyObject](../atl/reference/ccompolyobject-class.md) are always the most derived classes in the inheritance chain. It is their responsibility to handle all of the methods in **IUnknown**: `QueryInterface`, `AddRef`, and **Release**. In addition, `CComAggObject` and `CComPolyObject` (when used for aggregated objects) provide the special reference counting and `QueryInterface` semantics required for the inner unknown.  \n  \n Whether `CComObject`, `CComAggObject`, or `CComPolyObject` is used depends on whether you declare one (or none) of the following macros:  \n  \n|Macro|Effect|  \n|-----------|------------|  \n|`DECLARE_NOT_AGGREGATABLE`|Always uses `CComObject`.|  \n|`DECLARE_AGGREGATABLE`|Uses `CComAggObject` if the object is aggregated and `CComObject` if it is not. `CComCoClass` contains this macro so if none of the **DECLARE_\\*_AGGREGATABLE** macros are declared in your class, this will be the default.|  \n|`DECLARE_ONLY_AGGREGATABLE`|Always uses `CComAggObject`. Returns an error if the object is not aggregated.|  \n|`DECLARE_POLY_AGGREGATABLE`|ATL creates an instance of **CComPolyObject\\<CYourClass>** when **IClassFactory::CreateInstance** is called. During creation, the value of the outer unknown is checked. If it is **NULL**, **IUnknown** is implemented for a nonaggregated object. If the outer unknown is not **NULL**, **IUnknown** is implemented for an aggregated object.|  \n  \n The advantage of using `CComAggObject` and `CComObject` is that the implementation of **IUnknown** is optimized for the kind of object being created. For instance, a nonaggregated object only needs a reference count, while an aggregated object needs both a reference count for the inner unknown and a pointer to the outer unknown.  \n  \n The advantage of using `CComPolyObject` is that you avoid having both `CComAggObject` and `CComObject` in your module to handle the aggregated and nonaggregated cases. A single `CComPolyObject` object handles both cases. This means only one copy of the vtable and one copy of the functions exist in your module. If your vtable is large, this can substantially decrease your module size. However, if your vtable is small, using `CComPolyObject` can result in a slightly larger module size because it is not optimized for an aggregated or nonaggregated object, as are `CComAggObject` and `CComObject`.  \n  \n## See Also  \n [Fundamentals of ATL COM Objects](../atl/fundamentals-of-atl-com-objects.md)   \n [Aggregation and Class Factory Macros](../atl/reference/aggregation-and-class-factory-macros.md)\n\n"}