{"nodes":[{"pos":[12,51],"content":"References to Pointers | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"References to Pointers | Microsoft Docs","pos":[0,39]}]},{"content":"References to Pointers","pos":[595,617]},{"content":"References to pointers can be declared in much the same way as references to objects.","pos":[618,703]},{"content":"Declaring a reference to a pointer yields a modifiable value that is used like a normal pointer.","pos":[704,800]},{"content":"Example","pos":[809,816]},{"content":"The following code samples illustrate the difference between using a pointer to a pointer and a reference to a pointer.","pos":[820,939]},{"content":"Functions <ph id=\"ph1\">`Add1`</ph> and <ph id=\"ph2\">`Add2`</ph> are functionally equivalent (although they are not called the same way).","pos":[946,1046],"source":"Functions `Add1` and `Add2` are functionally equivalent (although they are not called the same way)."},{"content":"The difference is that <ph id=\"ph1\">`Add1`</ph> uses double indirection whereas <ph id=\"ph2\">`Add2`</ph> uses the convenience of a reference to a pointer.","pos":[1047,1165],"source":" The difference is that `Add1` uses double indirection whereas `Add2` uses the convenience of a reference to a pointer."},{"content":"See Also","pos":[4722,4730]},{"content":"References","pos":[4735,4745]}],"content":"---\ntitle: \"References to Pointers | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"references, to pointers\"\nms.assetid: 4ce48b08-1511-4d2f-a31f-95f99eac0c70\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# References to Pointers\nReferences to pointers can be declared in much the same way as references to objects. Declaring a reference to a pointer yields a modifiable value that is used like a normal pointer.  \n  \n## Example  \n The following code samples illustrate the difference between using a pointer to a pointer and a reference to a pointer.  \n  \n Functions `Add1` and `Add2` are functionally equivalent (although they are not called the same way). The difference is that `Add1` uses double indirection whereas `Add2` uses the convenience of a reference to a pointer.  \n  \n```  \n// references_to_pointers.cpp  \n// compile with: /EHsc  \n  \n#include <iostream>  \n#include <string>  \n  \n// STL namespace  \nusing namespace std;  \n  \nenum {  \n   sizeOfBuffer = 132  \n};  \n  \n// Define a binary tree structure.  \nstruct BTree {  \n   char  *szText;  \n   BTree *Left;  \n   BTree *Right;  \n};  \n  \n// Define a pointer to the root of the tree.  \nBTree *btRoot = 0;  \n  \nint Add1( BTree **Root, char *szToAdd );  \nint Add2( BTree*& Root, char *szToAdd );  \nvoid PrintTree( BTree* btRoot );  \n  \nint main( int argc, char *argv[] ) {  \n   // Usage message  \n   if( argc < 2 ) {  \n      cerr << \"Usage: Refptr [1 | 2]\" << \"\\n\";  \n      cerr << \"\\nwhere:\\n\";  \n      cerr << \"1 uses double indirection\\n\";  \n      cerr << \"2 uses a reference to a pointer.\\n\";  \n      cerr << \"\\nInput is from stdin.\\n\";  \n      return 1;  \n   }  \n  \n   char *szBuf = new char[sizeOfBuffer];  \n   if (szBuf == NULL) {  \n      cerr << \"Out of memory!\\n\";  \n      return -1;  \n   }  \n  \n   // Read a text file from the standard input device and  \n   //  build a binary tree.  \n   //while( !cin.eof() )   \n   {  \n      cin.get( szBuf, sizeOfBuffer, '\\n' );  \n      cin.get();  \n  \n      if ( strlen( szBuf ) ) {  \n         switch ( *argv[1] ) {  \n            // Method 1: Use double indirection.  \n            case '1':  \n               Add1( &btRoot, szBuf );  \n               break;  \n            // Method 2: Use reference to a pointer.  \n            case '2':  \n               Add2( btRoot, szBuf );  \n               break;  \n            default:  \n               cerr << \"Illegal value '\"  \n                  << *argv[1]  \n                  << \"' supplied for add method.\\n\"  \n                     << \"Choose 1 or 2.\\n\";  \n               return -1;  \n         }  \n      }  \n   }  \n   // Display the sorted list.  \n   PrintTree( btRoot );  \n}  \n  \n// PrintTree: Display the binary tree in order.  \nvoid PrintTree( BTree* MybtRoot ) {  \n   // Traverse the left branch of the tree recursively.  \n   if ( btRoot->Left )  \n      PrintTree( btRoot->Left );  \n  \n   // Print the current node.  \n   cout << btRoot->szText << \"\\n\";  \n  \n   // Traverse the right branch of the tree recursively.  \n   if ( btRoot->Right )  \n      PrintTree( btRoot->Right );  \n}  \n  \n// Add1: Add a node to the binary tree.  \n//       Uses double indirection.  \nint Add1( BTree **Root, char *szToAdd ) {  \n   if ( (*Root) == 0 ) {  \n      (*Root) = new BTree;  \n      (*Root)->Left = 0;  \n      (*Root)->Right = 0;  \n      (*Root)->szText = new char[strlen( szToAdd ) + 1];  \n      strcpy_s((*Root)->szText, (strlen( szToAdd ) + 1), szToAdd );  \n      return 1;  \n   }  \n   else {  \n      if ( strcmp( (*Root)->szText, szToAdd ) > 0 )  \n         return Add1( &((*Root)->Left), szToAdd );  \n      else  \n         return Add1( &((*Root)->Right), szToAdd );  \n   }  \n}  \n  \n// Add2: Add a node to the binary tree.  \n//       Uses reference to pointer  \nint Add2( BTree*& Root, char *szToAdd ) {  \n   if ( Root == 0 ) {  \n      Root = new BTree;  \n      Root->Left = 0;  \n      Root->Right = 0;  \n      Root->szText = new char[strlen( szToAdd ) + 1];  \n      strcpy_s( Root->szText, (strlen( szToAdd ) + 1), szToAdd );  \n      return 1;  \n   }  \n   else {  \n      if ( strcmp( Root->szText, szToAdd ) > 0 )  \n         return Add2( Root->Left, szToAdd );  \n      else  \n         return Add2( Root->Right, szToAdd );  \n   }  \n}  \n```  \n  \n```Output  \nUsage: Refptr [1 | 2]  \n  \nwhere:  \n1 uses double indirection  \n2 uses a reference to a pointer.  \n  \nInput is from stdin.  \n```  \n  \n## See Also  \n [References](../cpp/references-cpp.md)"}