{"nodes":[{"pos":[12,56],"content":"const and volatile Pointers | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"const and volatile Pointers | Microsoft Docs","pos":[0,44]}]},{"content":"const and volatile Pointers","pos":[702,729]},{"content":"The <bpt id=\"p1\">[</bpt>const<ept id=\"p1\">](../cpp/const-cpp.md)</ept> and <bpt id=\"p2\">[</bpt>volatile<ept id=\"p2\">](../cpp/volatile-cpp.md)</ept> keywords change how pointers are treated.","pos":[730,843],"source":"The [const](../cpp/const-cpp.md) and [volatile](../cpp/volatile-cpp.md) keywords change how pointers are treated."},{"content":"The <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> keyword specifies that the pointer cannot be modified after initialization; the pointer is protected from modification thereafter.","pos":[844,988],"source":" The **const** keyword specifies that the pointer cannot be modified after initialization; the pointer is protected from modification thereafter."},{"content":"The <ph id=\"ph1\">`volatile`</ph> keyword specifies that the value associated with the name that follows can be modified by actions other than those in the user application.","pos":[995,1149],"source":"The `volatile` keyword specifies that the value associated with the name that follows can be modified by actions other than those in the user application."},{"content":"Therefore, the <ph id=\"ph1\">`volatile`</ph> keyword is useful for declaring objects in shared memory that can be accessed by multiple processes or global data areas used for communication with interrupt service routines.","pos":[1150,1352],"source":" Therefore, the `volatile` keyword is useful for declaring objects in shared memory that can be accessed by multiple processes or global data areas used for communication with interrupt service routines."},{"content":"When a name is declared as <ph id=\"ph1\">`volatile`</ph>, the compiler reloads the value from memory each time it is accessed by the program.","pos":[1359,1481],"source":"When a name is declared as `volatile`, the compiler reloads the value from memory each time it is accessed by the program."},{"content":"This dramatically reduces the possible optimizations.","pos":[1482,1535]},{"content":"However, when the state of an object can change unexpectedly, it is the only way to ensure predictable program performance.","pos":[1536,1659]},{"pos":[1666,1772],"content":"To declare the object pointed to by the pointer as <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph>, use a declaration of the form:","source":"To declare the object pointed to by the pointer as **const** or `volatile`, use a declaration of the form:"},{"pos":[1837,1985],"content":"To declare the value of the pointer — that is, the actual address stored in the pointer — as <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph>, use a declaration of the form:","source":"To declare the value of the pointer — that is, the actual address stored in the pointer — as **const** or `volatile`, use a declaration of the form:"},{"content":"The C++ language prevents assignments that would allow modification of an object or pointer declared as <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>.","pos":[2052,2166],"source":"The C++ language prevents assignments that would allow modification of an object or pointer declared as **const**."},{"content":"Such assignments would remove the information that the object or pointer was declared with, thereby violating the intent of the original declaration.","pos":[2167,2316]},{"content":"Consider the following declarations:","pos":[2317,2353]},{"pos":[2416,2577],"content":"Given the preceding declarations of two objects (<ph id=\"ph1\">`cch`</ph>, of type <bpt id=\"p1\">**</bpt>const char<ept id=\"p1\">**</ept>, and <ph id=\"ph2\">`ch`</ph>, of type <bpt id=\"p2\">**</bpt>char)<ept id=\"p2\">**</ept>, the following declaration/initializations are valid:","source":"Given the preceding declarations of two objects (`cch`, of type **const char**, and `ch`, of type **char)**, the following declaration/initializations are valid:"},{"content":"The following declaration/initializations are erroneous.","pos":[2763,2819]},{"content":"The declaration of <ph id=\"ph1\">`pch2`</ph> declares a pointer through which a constant object might be modified and is therefore disallowed.","pos":[2911,3034],"source":"The declaration of `pch2` declares a pointer through which a constant object might be modified and is therefore disallowed."},{"content":"The declaration of <ph id=\"ph1\">`pch3`</ph> specifies that the <ph id=\"ph2\">`pointer`</ph> is constant, not the object; the declaration is disallowed for the same reason the <ph id=\"ph3\">`pch2`</ph> declaration is disallowed.","pos":[3035,3206],"source":" The declaration of `pch3` specifies that the `pointer` is constant, not the object; the declaration is disallowed for the same reason the `pch2` declaration is disallowed."},{"pos":[3213,3416],"content":"The following eight assignments show assigning through pointer and changing of pointer value for the preceding declarations; for now, assume that the initialization was correct for <ph id=\"ph1\">`pch1`</ph> through <ph id=\"ph2\">`pch8`</ph>.","source":"The following eight assignments show assigning through pointer and changing of pointer value for the preceding declarations; for now, assume that the initialization was correct for `pch1` through `pch8`."},{"pos":[3807,3905],"content":"Pointers declared as <ph id=\"ph1\">`volatile`</ph>, or as a mixture of <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and <ph id=\"ph2\">`volatile`</ph>, obey the same rules.","source":"Pointers declared as `volatile`, or as a mixture of **const** and `volatile`, obey the same rules."},{"pos":[3912,3993],"content":"Pointers to <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> objects are often used in function declarations as follows:","source":"Pointers to **const** objects are often used in function declarations as follows:"},{"content":"The preceding statement declares a function, <bpt id=\"p1\">[</bpt>strcpy_s<ept id=\"p1\">](../c-runtime-library/reference/strcpy-s-wcscpy-s-mbscpy-s.md)</ept>, where two of the three arguments are of type pointer to <ph id=\"ph1\">`char`</ph>.","pos":[4107,4289],"source":"The preceding statement declares a function, [strcpy_s](../c-runtime-library/reference/strcpy-s-wcscpy-s-mbscpy-s.md), where two of the three arguments are of type pointer to `char`."},{"content":"Because the arguments are passed by reference and not by value, the function would be free to modify both <ph id=\"ph1\">`strDestination`</ph> and <ph id=\"ph2\">`strSource`</ph> if <ph id=\"ph3\">`strSource`</ph> were not declared as <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>.","pos":[4290,4475],"source":" Because the arguments are passed by reference and not by value, the function would be free to modify both `strDestination` and `strSource` if `strSource` were not declared as **const**."},{"content":"The declaration of <ph id=\"ph1\">`strSource`</ph> as <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> assures the caller that <ph id=\"ph2\">`strSource`</ph> cannot be changed by the called function.","pos":[4476,4597],"source":" The declaration of `strSource` as **const** assures the caller that `strSource` cannot be changed by the called function."},{"pos":[4605,4963],"content":"[!NOTE]\n Because there is a standard conversion from *typename* **\\*** to **const** *typename* **\\***, it is legal to pass an argument of type **char \\*** to [strcpy_s](../c-runtime-library/reference/strcpy-s-wcscpy-s-mbscpy-s.md). However, the reverse is not true; no implicit conversion exists to remove the **const** attribute from an object or pointer.","leadings":["","> "],"nodes":[{"content":" Because there is a standard conversion from *typename* **\\*** to **const** *typename* **\\***, it is legal to pass an argument of type **char \\*** to [strcpy_s](../c-runtime-library/reference/strcpy-s-wcscpy-s-mbscpy-s.md). However, the reverse is not true; no implicit conversion exists to remove the **const** attribute from an object or pointer.","pos":[8,356],"nodes":[{"content":"Because there is a standard conversion from <bpt id=\"p1\">*</bpt>typename<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>const<ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt>typename<ept id=\"p4\">*</ept> <bpt id=\"p5\">**</bpt><ph id=\"ph2\">\\*</ph><ept id=\"p5\">**</ept>, it is legal to pass an argument of type <bpt id=\"p6\">**</bpt>char <ph id=\"ph3\">\\*</ph><ept id=\"p6\">**</ept> to <bpt id=\"p7\">[</bpt>strcpy_s<ept id=\"p7\">](../c-runtime-library/reference/strcpy-s-wcscpy-s-mbscpy-s.md)</ept>.","pos":[1,223],"source":" Because there is a standard conversion from *typename* **\\*** to **const** *typename* **\\***, it is legal to pass an argument of type **char \\*** to [strcpy_s](../c-runtime-library/reference/strcpy-s-wcscpy-s-mbscpy-s.md)."},{"content":"However, the reverse is not true; no implicit conversion exists to remove the <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> attribute from an object or pointer.","pos":[224,348],"source":" However, the reverse is not true; no implicit conversion exists to remove the **const** attribute from an object or pointer."}]}]},{"content":"A <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> pointer of a given type can be assigned to a pointer of the same type.","pos":[4970,5052],"source":"A **const** pointer of a given type can be assigned to a pointer of the same type."},{"content":"However, a pointer that is not <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> cannot be assigned to a <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> pointer.","pos":[5053,5136],"source":" However, a pointer that is not **const** cannot be assigned to a **const** pointer."},{"content":"The following code shows correct and incorrect assignments:","pos":[5137,5196]},{"content":"The following sample shows how to declare an object as const if you have a pointer to a pointer to an object.","pos":[5361,5470]},{"content":"See Also","pos":[5796,5804]},{"content":"Pointers","pos":[5809,5817]}],"content":"---\ntitle: \"const and volatile Pointers | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"volatile keyword [C++], and pointers\"\n  - \"pointers, and const\"\n  - \"pointers, and volatile\"\n  - \"const keyword [C++], volatile pointers\"\nms.assetid: 0c92dc6c-400e-4342-b345-63ddfe649d7e\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# const and volatile Pointers\nThe [const](../cpp/const-cpp.md) and [volatile](../cpp/volatile-cpp.md) keywords change how pointers are treated. The **const** keyword specifies that the pointer cannot be modified after initialization; the pointer is protected from modification thereafter.  \n  \n The `volatile` keyword specifies that the value associated with the name that follows can be modified by actions other than those in the user application. Therefore, the `volatile` keyword is useful for declaring objects in shared memory that can be accessed by multiple processes or global data areas used for communication with interrupt service routines.  \n  \n When a name is declared as `volatile`, the compiler reloads the value from memory each time it is accessed by the program. This dramatically reduces the possible optimizations. However, when the state of an object can change unexpectedly, it is the only way to ensure predictable program performance.  \n  \n To declare the object pointed to by the pointer as **const** or `volatile`, use a declaration of the form:  \n  \n```  \nconst char *cpch;  \nvolatile char *vpch;  \n```  \n  \n To declare the value of the pointer — that is, the actual address stored in the pointer — as **const** or `volatile`, use a declaration of the form:  \n  \n```  \nchar * const pchc;  \nchar * volatile pchv;  \n```  \n  \n The C++ language prevents assignments that would allow modification of an object or pointer declared as **const**. Such assignments would remove the information that the object or pointer was declared with, thereby violating the intent of the original declaration. Consider the following declarations:  \n  \n```  \nconst char cch = 'A';  \nchar ch = 'B';  \n```  \n  \n Given the preceding declarations of two objects (`cch`, of type **const char**, and `ch`, of type **char)**, the following declaration/initializations are valid:  \n  \n```  \nconst char *pch1 = &cch;  \nconst char *const pch4 = &cch;  \nconst char *pch5 = &ch;  \nchar *pch6 = &ch;  \nchar *const pch7 = &ch;  \nconst char *const pch8 = &ch;  \n```  \n  \n The following declaration/initializations are erroneous.  \n  \n```  \nchar *pch2 = &cch;   // Error  \nchar *const pch3 = &cch;   // Error  \n```  \n  \n The declaration of `pch2` declares a pointer through which a constant object might be modified and is therefore disallowed. The declaration of `pch3` specifies that the `pointer` is constant, not the object; the declaration is disallowed for the same reason the `pch2` declaration is disallowed.  \n  \n The following eight assignments show assigning through pointer and changing of pointer value for the preceding declarations; for now, assume that the initialization was correct for `pch1` through `pch8`.  \n  \n```  \n*pch1 = 'A';  // Error: object declared const  \npch1 = &ch;   // OK: pointer not declared const  \n*pch2 = 'A';  // OK: normal pointer  \npch2 = &ch;   // OK: normal pointer  \n*pch3 = 'A';  // OK: object not declared const  \npch3 = &ch;   // Error: pointer declared const  \n*pch4 = 'A';  // Error: object declared const  \npch4 = &ch;   // Error: pointer declared const  \n```  \n  \n Pointers declared as `volatile`, or as a mixture of **const** and `volatile`, obey the same rules.  \n  \n Pointers to **const** objects are often used in function declarations as follows:  \n  \n```  \nerrno_t strcpy_s( char *strDestination, size_t numberOfElements, const char *strSource );  \n```  \n  \n The preceding statement declares a function, [strcpy_s](../c-runtime-library/reference/strcpy-s-wcscpy-s-mbscpy-s.md), where two of the three arguments are of type pointer to `char`. Because the arguments are passed by reference and not by value, the function would be free to modify both `strDestination` and `strSource` if `strSource` were not declared as **const**. The declaration of `strSource` as **const** assures the caller that `strSource` cannot be changed by the called function.  \n  \n> [!NOTE]\n>  Because there is a standard conversion from *typename* **\\*** to **const** *typename* **\\***, it is legal to pass an argument of type **char \\*** to [strcpy_s](../c-runtime-library/reference/strcpy-s-wcscpy-s-mbscpy-s.md). However, the reverse is not true; no implicit conversion exists to remove the **const** attribute from an object or pointer.  \n  \n A **const** pointer of a given type can be assigned to a pointer of the same type. However, a pointer that is not **const** cannot be assigned to a **const** pointer. The following code shows correct and incorrect assignments:  \n  \n```  \n// const_pointer.cpp  \nint *const cpObject = 0;  \nint *pObject;  \n  \nint main() {  \npObject = cpObject;  \ncpObject = pObject;   // C3892  \n}  \n```  \n  \n The following sample shows how to declare an object as const if you have a pointer to a pointer to an object.  \n  \n```  \n// const_pointer2.cpp  \nstruct X {  \n   X(int i) : m_i(i) { }  \n   int m_i;  \n};  \n  \nint main() {  \n   // correct  \n   const X cx(10);  \n   const X * pcx = &cx;  \n   const X ** ppcx = &pcx;  \n  \n   // also correct  \n   X const cx2(20);  \n   X const * pcx2 = &cx2;  \n   X const ** ppcx2 = &pcx2;  \n}  \n```  \n  \n## See Also  \n [Pointers](../cpp/pointers-cpp.md)"}