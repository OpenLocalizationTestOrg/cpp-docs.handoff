{"nodes":[{"pos":[12,47],"content":"Reference Counting | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Reference Counting | Microsoft Docs","pos":[0,35]}]},{"content":"Reference Counting","pos":[697,715]},{"content":"COM itself does not automatically try to remove an object from memory when it thinks the object is no longer being used.","pos":[716,836]},{"content":"Instead, the object programmer must remove the unused object.","pos":[837,898]},{"content":"The programmer determines whether an object can be removed based on a reference count.","pos":[899,985]},{"content":"COM uses the <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> methods, <bpt id=\"p2\">[</bpt>AddRef<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id=\"p3\">[</bpt>Release<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>, to manage the reference count of interfaces on an object.","pos":[992,1228],"source":"COM uses the **IUnknown** methods, [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), to manage the reference count of interfaces on an object."},{"content":"The general rules for calling these methods are:","pos":[1229,1277]},{"pos":[1287,1377],"content":"Whenever a client receives an interface pointer, <ph id=\"ph1\">`AddRef`</ph> must be called on the interface.","source":"Whenever a client receives an interface pointer, `AddRef` must be called on the interface."},{"pos":[1387,1474],"content":"Whenever the client has finished using the interface pointer, it must call <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept>.","source":"Whenever the client has finished using the interface pointer, it must call **Release**."},{"content":"In a simple implementation, each <ph id=\"ph1\">`AddRef`</ph> call increments and each <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept> call decrements a counter variable inside the object.","pos":[1481,1613],"source":"In a simple implementation, each `AddRef` call increments and each **Release** call decrements a counter variable inside the object."},{"content":"When the count returns to zero, the interface no longer has any users and is free to remove itself from memory.","pos":[1614,1725]},{"content":"Reference counting can also be implemented so that each reference to the object (not to an individual interface) is counted.","pos":[1732,1856]},{"content":"In this case, each <ph id=\"ph1\">`AddRef`</ph> and <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept> call delegates to a central implementation on the object, and <bpt id=\"p2\">**</bpt>Release<ept id=\"p2\">**</ept> frees the entire object when its reference count reaches zero.","pos":[1857,2037],"source":" In this case, each `AddRef` and **Release** call delegates to a central implementation on the object, and **Release** frees the entire object when its reference count reaches zero."},{"pos":[2045,2263],"content":"[!NOTE]\n When a `CComObject`-derived object is constructed using the **new** operator, the reference count is 0. Therefore, a call to `AddRef` must be made after successfully creating the `CComObject`-derived object.","leadings":["","> "],"nodes":[{"content":" When a `CComObject`-derived object is constructed using the **new** operator, the reference count is 0. Therefore, a call to `AddRef` must be made after successfully creating the `CComObject`-derived object.","pos":[8,216],"nodes":[{"content":"When a <ph id=\"ph1\">`CComObject`</ph>-derived object is constructed using the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator, the reference count is 0.","pos":[1,104],"source":" When a `CComObject`-derived object is constructed using the **new** operator, the reference count is 0."},{"content":"Therefore, a call to <ph id=\"ph1\">`AddRef`</ph> must be made after successfully creating the <ph id=\"ph2\">`CComObject`</ph>-derived object.","pos":[105,208],"source":" Therefore, a call to `AddRef` must be made after successfully creating the `CComObject`-derived object."}]}]},{"content":"See Also","pos":[2272,2280]},{"content":"Introduction to COM","pos":[2285,2304]},{"content":"Managing Object Lifetimes through Reference Counting","pos":[2342,2394]}],"content":"---\ntitle: \"Reference Counting | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"AddRef method [C++], reference counting\"\n  - \"reference counting\"\n  - \"AddRef method [C++]\"\n  - \"reference counts\"\n  - \"references, counting\"\nms.assetid: b1fd4514-6de6-429f-9e60-2777c0d07a3d\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Reference Counting\nCOM itself does not automatically try to remove an object from memory when it thinks the object is no longer being used. Instead, the object programmer must remove the unused object. The programmer determines whether an object can be removed based on a reference count.  \n  \n COM uses the **IUnknown** methods, [AddRef](http://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](http://msdn.microsoft.com/library/windows/desktop/ms682317), to manage the reference count of interfaces on an object. The general rules for calling these methods are:  \n  \n-   Whenever a client receives an interface pointer, `AddRef` must be called on the interface.  \n  \n-   Whenever the client has finished using the interface pointer, it must call **Release**.  \n  \n In a simple implementation, each `AddRef` call increments and each **Release** call decrements a counter variable inside the object. When the count returns to zero, the interface no longer has any users and is free to remove itself from memory.  \n  \n Reference counting can also be implemented so that each reference to the object (not to an individual interface) is counted. In this case, each `AddRef` and **Release** call delegates to a central implementation on the object, and **Release** frees the entire object when its reference count reaches zero.  \n  \n> [!NOTE]\n>  When a `CComObject`-derived object is constructed using the **new** operator, the reference count is 0. Therefore, a call to `AddRef` must be made after successfully creating the `CComObject`-derived object.  \n  \n## See Also  \n [Introduction to COM](../atl/introduction-to-com.md)   \n [Managing Object Lifetimes through Reference Counting](http://msdn.microsoft.com/library/windows/desktop/ms687260)\n\n"}