{"nodes":[{"pos":[12,73],"content":"Numeric, Boolean and Pointer Literals  (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Numeric, Boolean and Pointer Literals  (C++) | Microsoft Docs","pos":[0,61]}]},{"content":"Numeric, Boolean and Pointer Literals  (C++)","pos":[648,692]},{"content":"A literal is a program element that directly represents a value.","pos":[693,757]},{"content":"This article covers literals of type integer, floating-point, boolean and pointer.","pos":[758,840]},{"content":"For information about string and character literals, see <bpt id=\"p1\">[</bpt>String and Character Literals  (C++)<ept id=\"p1\">](../cpp/string-and-character-literals-cpp.md)</ept>.","pos":[841,982],"source":" For information about string and character literals, see [String and Character Literals  (C++)](../cpp/string-and-character-literals-cpp.md)."},{"content":"You can also define your own literals based on any of these categories; for more information see <bpt id=\"p1\">[</bpt>User-Defined Literals  (C++)<ept id=\"p1\">](../cpp/user-defined-literals-cpp.md)</ept>","pos":[983,1147],"source":" You can also define your own literals based on any of these categories; for more information see [User-Defined Literals  (C++)](../cpp/user-defined-literals-cpp.md)"},{"content":".","pos":[1154,1155]},{"content":"You can use literals in many contexts, but most commonly to initialize named variables and to pass arguments to functions:","pos":[1156,1278]},{"content":"Sometimes it's important to tell the compiler how to interpret a literal, or what specific type to give to it.","pos":[1523,1633]},{"content":"You do this by appending prefixes or suffixes to the literal.","pos":[1634,1695]},{"content":"For example, the  prefix 0x tells the compiler to interpret the number that follows it as a hexadecimal value, for example 0x35.","pos":[1696,1824]},{"content":"The ULL suffix tells the compiler to treat the value as an <ph id=\"ph1\">`unsigned long long`</ph> type, as in 5894345ULL.","pos":[1825,1928],"source":" The ULL suffix tells the compiler to treat the value as an `unsigned long long` type, as in 5894345ULL."},{"content":"See the following sections for the complete list of prefixes and suffixes for each literal type.","pos":[1929,2025]},{"content":"Syntax","pos":[2034,2040]},{"content":"Integer literals","pos":[2049,2065]},{"content":"Integer literals begin with a digit and have no fractional parts or exponents.","pos":[2069,2147]},{"content":"You can specify integer literals in decimal, octal, or hexadecimal form.","pos":[2148,2220]},{"content":"They can specify signed or unsigned types and long or short types.","pos":[2221,2287]},{"pos":[2294,2478],"content":"When no prefix or suffix is present, the compiler will give an integral literal value type <ph id=\"ph1\">`int`</ph> (32 bits), if the value will fit, otherwise it will give it type <ph id=\"ph2\">`long long`</ph> (64 bits).","source":"When no prefix or suffix is present, the compiler will give an integral literal value type `int` (32 bits), if the value will fit, otherwise it will give it type `long long` (64 bits)."},{"content":"To specify a decimal integral literal, begin the specification with a nonzero digit.","pos":[2485,2569]},{"content":"For example:","pos":[2570,2582]},{"content":"To specify an octal integral literal, begin the specification with 0, followed by a sequence of digits in the range 0 through 7.","pos":[2867,2995]},{"content":"The digits 8 and 9 are errors in specifying an octal literal.","pos":[2996,3057]},{"content":"For example:","pos":[3058,3070]},{"content":"To specify a hexadecimal integral literal, begin the specification with <ph id=\"ph1\">`0x`</ph> or <ph id=\"ph2\">`0X`</ph> (the case of the \"x\" does not matter), followed by a sequence of digits in the range <ph id=\"ph3\">`0`</ph> through <ph id=\"ph4\">`9`</ph> and <ph id=\"ph5\">`a`</ph> (or <ph id=\"ph6\">`A`</ph>) through <ph id=\"ph7\">`f`</ph> (or <ph id=\"ph8\">`F`</ph>).","pos":[3184,3408],"source":"To specify a hexadecimal integral literal, begin the specification with `0x` or `0X` (the case of the \"x\" does not matter), followed by a sequence of digits in the range `0` through `9` and `a` (or `A`) through `f` (or `F`)."},{"content":"Hexadecimal digits <ph id=\"ph1\">`a`</ph> (or <ph id=\"ph2\">`A`</ph>) through <ph id=\"ph3\">`f`</ph> (or <ph id=\"ph4\">`F`</ph>) represent values in the range 10 through 15.","pos":[3409,3506],"source":" Hexadecimal digits `a` (or `A`) through `f` (or `F`) represent values in the range 10 through 15."},{"content":"For example:","pos":[3507,3519]},{"content":"To specify an unsigned type, use either the <bpt id=\"p1\">**</bpt>u<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>U<ept id=\"p2\">**</ept> suffix.","pos":[3623,3689],"source":"To specify an unsigned type, use either the **u** or **U** suffix."},{"content":"To specify a long type, use either the <bpt id=\"p1\">**</bpt>l<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>L<ept id=\"p2\">**</ept> suffix.","pos":[3690,3751],"source":" To specify a long type, use either the **l** or **L** suffix."},{"content":"To specify a 64-bit integral type, use the LL, or ll suffix.","pos":[3752,3812]},{"content":"The i64 suffix is still supported but should be avoided because it is specific to Microsoft and is not portable.","pos":[3813,3925]},{"content":"For example:","pos":[3926,3938]},{"content":"<bpt id=\"p1\">**</bpt>Digit separators<ept id=\"p1\">**</ept>: You can use the single-quote character (apostrophe) to separate place values in larger numbers to make them easier for humans to read.","pos":[4347,4503],"source":"**Digit separators**: You can use the single-quote character (apostrophe) to separate place values in larger numbers to make them easier for humans to read."},{"content":"Separators have no effect on compilation.","pos":[4504,4545]},{"content":"Floating point literals","pos":[4600,4623]},{"content":"Floating-point literals specify values that must have a fractional part.","pos":[4627,4699]},{"content":"These values contain decimal points (<bpt id=\"p1\">**</bpt>.<ept id=\"p1\">**</ept>) and can contain exponents.","pos":[4700,4770],"source":" These values contain decimal points (**.**) and can contain exponents."},{"content":"Floating-point literals have a \"mantissa,\" which specifies the value of the number, an \"exponent,\" which specifies the magnitude of the number, and an optional suffix that specifies the literal's type.","pos":[4777,4978]},{"content":"The mantissa is specified as a sequence of digits followed by a period, followed by an optional sequence of digits representing the fractional part of the number.","pos":[4979,5141]},{"content":"For example:","pos":[5142,5154]},{"content":"The exponent, if present, specifies the magnitude of the number as a power of 10, as shown in the following example:","pos":[5190,5306]},{"content":"The exponent may be specified using <bpt id=\"p1\">**</bpt>e<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>E<ept id=\"p2\">**</ept>, which have the same meaning, followed by an optional sign (+ or -) and a sequence of digits.","pos":[5381,5525],"source":"The exponent may be specified using **e** or **E**, which have the same meaning, followed by an optional sign (+ or -) and a sequence of digits."},{"content":"If an exponent is present, the trailing decimal point is unnecessary in whole numbers such as <ph id=\"ph1\">`18E0`</ph>.","pos":[5527,5628],"source":"  If an exponent is present, the trailing decimal point is unnecessary in whole numbers such as `18E0`."},{"content":"Floating-point literals default to type <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>.","pos":[5635,5686],"source":"Floating-point literals default to type **double**."},{"content":"By using the suffixes <bpt id=\"p1\">**</bpt>f<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>l<ept id=\"p2\">**</ept> (or <bpt id=\"p3\">**</bpt>F<ept id=\"p3\">**</ept> or <bpt id=\"p4\">**</bpt>L<ept id=\"p4\">**</ept> — the suffix is not case sensitive), the literal can be specified as <bpt id=\"p5\">**</bpt>float<ept id=\"p5\">**</ept> or <ph id=\"ph1\">`long double`</ph>, respectively.","pos":[5687,5853],"source":" By using the suffixes **f** or **l** (or **F** or **L** — the suffix is not case sensitive), the literal can be specified as **float** or `long double`, respectively."},{"content":"Although <ph id=\"ph1\">`long double`</ph> and <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept> have the same representation, they are not the same type.","pos":[5860,5955],"source":"Although `long double` and **double** have the same representation, they are not the same type."},{"content":"For example, you can have overloaded functions like","pos":[5956,6007]},{"content":"and","pos":[6052,6055]},{"content":"Boolean literals","pos":[6107,6123]},{"pos":[6127,6171],"content":"The boolean literals are <ph id=\"ph1\">`true`</ph> and <ph id=\"ph2\">`false`</ph>.","source":"The boolean literals are `true` and `false`."},{"content":"Pointer literal (C++11)","pos":[6180,6203]},{"content":"C++ introduces the <bpt id=\"p1\">[</bpt>nullptr<ept id=\"p1\">](../cpp/nullptr.md)</ept> literal to specify a zero-initialized pointer.","pos":[6207,6301],"source":"C++ introduces the [nullptr](../cpp/nullptr.md) literal to specify a zero-initialized pointer."},{"content":"In portable code, <ph id=\"ph1\">`nullptr`</ph> should be used instead of integral-type zero or macros such as NULL.","pos":[6302,6398],"source":" In portable code, `nullptr` should be used instead of integral-type zero or macros such as NULL."},{"content":"Binary literals (C++14)","pos":[6407,6430]},{"pos":[6434,6545],"content":"A binary literal can be specified by the use of the <ph id=\"ph1\">`0B`</ph> or <ph id=\"ph2\">`0b`</ph> prefix, followed by a sequence of 1's and 0's:","source":"A binary literal can be specified by the use of the `0B` or `0b` prefix, followed by a sequence of 1's and 0's:"},{"content":"Avoid using literals as \"magic constants\"","pos":[6630,6671]},{"content":"You can use literals directly in expressions and statements although it's not always good programming practice:","pos":[6675,6786]},{"content":"In the previous example, it might be better to use a named constant that conveys a clear meaning, for example \"MAXIMUM_ERROR_THRESHOLD\".","pos":[6852,6988]},{"content":"And if the return value \"Success\" is seen by end users, then it might be better to use a named string constant that can be stored in a single location in a file from where it can be localized into other languages.","pos":[6989,7202]},{"content":"Using named constants helps others as well as yourself to understand the intent of the code.","pos":[7203,7295]},{"content":"See Also","pos":[7304,7312]},{"content":"Lexical Conventions","pos":[7317,7336]},{"content":"C++ Integer Constants","pos":[7374,7395]},{"content":"C++ Character Literals","pos":[7472,7494]},{"content":"C++ Floating-Point Constants","pos":[7571,7599]},{"content":"C++ String Literals","pos":[7676,7695]},{"content":"C++ User-Defined Literals","pos":[7747,7772]}],"content":"---\ntitle: \"Numeric, Boolean and Pointer Literals  (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"literals, C++\"\n  - \"constants, literals\"\n  - \"literals\"\nms.assetid: 17c09fc3-3ad7-47e2-8b48-ba8ae994edc8\ncaps.latest.revision: 16\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Numeric, Boolean and Pointer Literals  (C++)\nA literal is a program element that directly represents a value. This article covers literals of type integer, floating-point, boolean and pointer. For information about string and character literals, see [String and Character Literals  (C++)](../cpp/string-and-character-literals-cpp.md). You can also define your own literals based on any of these categories; for more information see [User-Defined Literals  (C++)](../cpp/user-defined-literals-cpp.md)  \n  \n . You can use literals in many contexts, but most commonly to initialize named variables and to pass arguments to functions:  \n  \n```  \nconst int answer = 42; // integer literal  \ndouble d = sin(108.87);     //floating point literal passed to sin function  \nbool b = true;              // boolean literal  \nMyClass* mc = nullptr;      // pointer literal  \n  \n```  \n  \n Sometimes it's important to tell the compiler how to interpret a literal, or what specific type to give to it. You do this by appending prefixes or suffixes to the literal. For example, the  prefix 0x tells the compiler to interpret the number that follows it as a hexadecimal value, for example 0x35. The ULL suffix tells the compiler to treat the value as an `unsigned long long` type, as in 5894345ULL. See the following sections for the complete list of prefixes and suffixes for each literal type.  \n  \n## Syntax  \n  \n## Integer literals  \n Integer literals begin with a digit and have no fractional parts or exponents. You can specify integer literals in decimal, octal, or hexadecimal form. They can specify signed or unsigned types and long or short types.  \n  \n When no prefix or suffix is present, the compiler will give an integral literal value type `int` (32 bits), if the value will fit, otherwise it will give it type `long long` (64 bits).  \n  \n To specify a decimal integral literal, begin the specification with a nonzero digit. For example:  \n  \n```  \nint i = 157;   // Decimal literal  \nint j = 0198;       // Not a decimal number; erroneous octal literal  \nint k = 0365;       // Leading zero specifies octal literal, not decimal  \nint m = 36'000'000  // digit separators make large values more readable  \nint   \n```  \n  \n To specify an octal integral literal, begin the specification with 0, followed by a sequence of digits in the range 0 through 7. The digits 8 and 9 are errors in specifying an octal literal. For example:  \n  \n```  \nint i = 0377;   // Octal literal  \nint j = 0397;        // Error: 9 is not an octal digit  \n```  \n  \n To specify a hexadecimal integral literal, begin the specification with `0x` or `0X` (the case of the \"x\" does not matter), followed by a sequence of digits in the range `0` through `9` and `a` (or `A`) through `f` (or `F`). Hexadecimal digits `a` (or `A`) through `f` (or `F`) represent values in the range 10 through 15. For example:  \n  \n```  \nint i = 0x3fff;   // Hexadecimal literal  \nint j = 0X3FFF;        // Equal to i  \n```  \n  \n To specify an unsigned type, use either the **u** or **U** suffix. To specify a long type, use either the **l** or **L** suffix. To specify a 64-bit integral type, use the LL, or ll suffix. The i64 suffix is still supported but should be avoided because it is specific to Microsoft and is not portable. For example:  \n  \n```  \nunsigned val_1 = 328u;             // Unsigned value  \nlong val_2 = 0x7FFFFFL;                 // Long value specified   \n                                        //  as hex literal  \nunsigned long val_3 = 0776745ul;        // Unsigned long value  \nauto val_4 = 108LL;                           // signed long long  \nauto val_4 = 0x8000000000000000ULL << 16;     // unsigned long long   \n```  \n  \n **Digit separators**: You can use the single-quote character (apostrophe) to separate place values in larger numbers to make them easier for humans to read. Separators have no effect on compilation.  \n  \n```  \nlong long i = 24'847'458'121  \n```  \n  \n## Floating point literals  \n Floating-point literals specify values that must have a fractional part. These values contain decimal points (**.**) and can contain exponents.  \n  \n Floating-point literals have a \"mantissa,\" which specifies the value of the number, an \"exponent,\" which specifies the magnitude of the number, and an optional suffix that specifies the literal's type. The mantissa is specified as a sequence of digits followed by a period, followed by an optional sequence of digits representing the fractional part of the number. For example:  \n  \n```  \n18.46  \n38.  \n```  \n  \n The exponent, if present, specifies the magnitude of the number as a power of 10, as shown in the following example:  \n  \n```  \n18.46e0      // 18.46  \n18.46e1           // 184.6  \n```  \n  \n The exponent may be specified using **e** or **E**, which have the same meaning, followed by an optional sign (+ or -) and a sequence of digits.  If an exponent is present, the trailing decimal point is unnecessary in whole numbers such as `18E0`.  \n  \n Floating-point literals default to type **double**. By using the suffixes **f** or **l** (or **F** or **L** — the suffix is not case sensitive), the literal can be specified as **float** or `long double`, respectively.  \n  \n Although `long double` and **double** have the same representation, they are not the same type. For example, you can have overloaded functions like  \n  \n```  \nvoid func( double );  \n```  \n  \n and  \n  \n```  \nvoid func( long double );  \n```  \n  \n## Boolean literals  \n The boolean literals are `true` and `false`.  \n  \n## Pointer literal (C++11)  \n C++ introduces the [nullptr](../cpp/nullptr.md) literal to specify a zero-initialized pointer. In portable code, `nullptr` should be used instead of integral-type zero or macros such as NULL.  \n  \n## Binary literals (C++14)  \n A binary literal can be specified by the use of the `0B` or `0b` prefix, followed by a sequence of 1's and 0's:  \n  \n```  \n  \nauto x = 0B001101 ; // int  \nauto y = 0b000001 ; // int  \n```  \n  \n## Avoid using literals as \"magic constants\"  \n You can use literals directly in expressions and statements although it's not always good programming practice:  \n  \n```  \nif (num < 100)  \n    return \"Success\";  \n  \n```  \n  \n In the previous example, it might be better to use a named constant that conveys a clear meaning, for example \"MAXIMUM_ERROR_THRESHOLD\". And if the return value \"Success\" is seen by end users, then it might be better to use a named string constant that can be stored in a single location in a file from where it can be localized into other languages. Using named constants helps others as well as yourself to understand the intent of the code.  \n  \n## See Also  \n [Lexical Conventions](../cpp/lexical-conventions.md)   \n [C++ Integer Constants](http://msdn.microsoft.com/en-us/1f3b58a4-8346-4533-ba6e-df26d76f8dcf)   \n [C++ Character Literals](http://msdn.microsoft.com/en-us/a7901c61-524d-47c6-beb6-d9dacc2e72ed)   \n [C++ Floating-Point Constants](http://msdn.microsoft.com/en-us/f6273f24-a876-4484-a7a2-e82275692ad3)   \n [C++ String Literals](../cpp/string-and-character-literals-cpp.md)   \n [C++ User-Defined Literals](../cpp/user-defined-literals-cpp.md)"}