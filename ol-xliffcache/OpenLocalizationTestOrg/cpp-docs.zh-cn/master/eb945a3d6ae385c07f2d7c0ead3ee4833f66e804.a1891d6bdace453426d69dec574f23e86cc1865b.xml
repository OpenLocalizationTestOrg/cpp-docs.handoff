{"nodes":[{"pos":[12,89],"content":"How to: Use parallel_invoke to Write a Parallel Sort Routine | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Use parallel_invoke to Write a Parallel Sort Routine | Microsoft Docs","pos":[0,77]}]},{"content":"How to: Use parallel_invoke to Write a Parallel Sort Routine","pos":[836,896]},{"content":"This document describes how to use the <bpt id=\"p1\">[</bpt>parallel_invoke<ept id=\"p1\">](../../parallel/concrt/parallel-algorithms.md#parallel_invoke)</ept> algorithm to improve the performance of the bitonic sort algorithm.","pos":[897,1083],"source":"This document describes how to use the [parallel_invoke](../../parallel/concrt/parallel-algorithms.md#parallel_invoke) algorithm to improve the performance of the bitonic sort algorithm."},{"content":"The bitonic sort algorithm recursively divides the input sequence into smaller sorted partitions.","pos":[1084,1181]},{"content":"The bitonic sort algorithm can run in parallel because each partition operation is independent of all other operations.","pos":[1182,1301]},{"pos":[1308,1481],"content":"Although the bitonic sort is an example of a <bpt id=\"p1\">*</bpt>sorting network<ept id=\"p1\">*</ept> that sorts all combinations of input sequences, this example sorts sequences whose lengths are a power of two.","source":"Although the bitonic sort is an example of a *sorting network* that sorts all combinations of input sequences, this example sorts sequences whose lengths are a power of two."},{"pos":[1489,2028],"content":"[!NOTE]\n This example uses a parallel sort routine for illustration. You can also use the built-in sorting algorithms that the PPL provides: [concurrency::parallel_sort](reference/concurrency-namespace-functions.md#parallel_sort), [concurrency::parallel_buffered_sort](reference/concurrency-namespace-functions.md#parallel_buffered_sort), and [concurrency::parallel_radixsort](reference/concurrency-namespace-functions.md#parallel_radixsort). For more information, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md).","leadings":["","> "],"nodes":[{"content":" This example uses a parallel sort routine for illustration. You can also use the built-in sorting algorithms that the PPL provides: [concurrency::parallel_sort](reference/concurrency-namespace-functions.md#parallel_sort), [concurrency::parallel_buffered_sort](reference/concurrency-namespace-functions.md#parallel_buffered_sort), and [concurrency::parallel_radixsort](reference/concurrency-namespace-functions.md#parallel_radixsort). For more information, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md).","pos":[8,537],"nodes":[{"content":"This example uses a parallel sort routine for illustration.","pos":[1,60]},{"content":"You can also use the built-in sorting algorithms that the PPL provides: <bpt id=\"p1\">[</bpt>concurrency::parallel_sort<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_sort)</ept>, <bpt id=\"p2\">[</bpt>concurrency::parallel_buffered_sort<ept id=\"p2\">](reference/concurrency-namespace-functions.md#parallel_buffered_sort)</ept>, and <bpt id=\"p3\">[</bpt>concurrency::parallel_radixsort<ept id=\"p3\">](reference/concurrency-namespace-functions.md#parallel_radixsort)</ept>.","pos":[61,434],"source":" You can also use the built-in sorting algorithms that the PPL provides: [concurrency::parallel_sort](reference/concurrency-namespace-functions.md#parallel_sort), [concurrency::parallel_buffered_sort](reference/concurrency-namespace-functions.md#parallel_buffered_sort), and [concurrency::parallel_radixsort](reference/concurrency-namespace-functions.md#parallel_radixsort)."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Parallel Algorithms<ept id=\"p1\">](../../parallel/concrt/parallel-algorithms.md)</ept>.","pos":[435,529],"source":" For more information, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)."}]}]},{"pos":[2057,2065],"content":"Sections"},{"content":"This document describes the following tasks:","pos":[2069,2113]},{"content":"Performing Bitonic Sort Serially","pos":[2122,2154]},{"content":"Using parallel_invoke to Perform Bitonic Sort in Parallel","pos":[2173,2230]},{"pos":[2274,2306],"content":"Performing Bitonic Sort Serially"},{"content":"The following example shows the serial version of the bitonic sort algorithm.","pos":[2310,2387]},{"content":"The <ph id=\"ph1\">`bitonic_sort`</ph> function divides the sequence into two partitions, sorts those partitions in opposite directions, and then merges the results.","pos":[2388,2533],"source":" The `bitonic_sort` function divides the sequence into two partitions, sorts those partitions in opposite directions, and then merges the results."},{"content":"This function calls itself two times recursively to sort each partition.","pos":[2534,2606]},{"pos":[2624,2654],"content":"concrt-parallel-bitonic-sort#1"},{"pos":[2768,2781],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[2815,2872],"content":"Using parallel_invoke to Perform Bitonic Sort in Parallel"},{"pos":[2876,2992],"content":"This section describes how to use the <ph id=\"ph1\">`parallel_invoke`</ph> algorithm to perform the bitonic sort algorithm in parallel.","source":"This section describes how to use the `parallel_invoke` algorithm to perform the bitonic sort algorithm in parallel."},{"content":"Procedures","pos":[3002,3012]},{"content":"To perform the bitonic sort algorithm in parallel","pos":[3024,3073]},{"pos":[3083,3136],"content":"Add a <ph id=\"ph1\">`#include`</ph> directive for the header file ppl.h.","source":"Add a `#include` directive for the header file ppl.h."},{"pos":[3154,3185],"content":"concrt-parallel-bitonic-sort#10"},{"pos":[3302,3358],"content":"Add a <ph id=\"ph1\">`using`</ph> directive for the <ph id=\"ph2\">`concurrency`</ph> namespace.","source":"Add a `using` directive for the `concurrency` namespace."},{"pos":[3376,3407],"content":"concrt-parallel-bitonic-sort#11"},{"content":"Create a new function, called <ph id=\"ph1\">`parallel_bitonic_mege`</ph>, which uses the <ph id=\"ph2\">`parallel_invoke`</ph> algorithm to merge the sequences in parallel if there is sufficient amount of work to do.","pos":[3524,3701],"source":"Create a new function, called `parallel_bitonic_mege`, which uses the `parallel_invoke` algorithm to merge the sequences in parallel if there is sufficient amount of work to do."},{"content":"Otherwise, call <ph id=\"ph1\">`bitonic_merge`</ph> to merge the sequences serially.","pos":[3702,3766],"source":" Otherwise, call `bitonic_merge` to merge the sequences serially."},{"pos":[3784,3814],"content":"concrt-parallel-bitonic-sort#2"},{"pos":[3931,4030],"content":"Perform a process that resembles the one in the previous step, but for the <ph id=\"ph1\">`bitonic_sort`</ph> function.","source":"Perform a process that resembles the one in the previous step, but for the `bitonic_sort` function."},{"pos":[4048,4078],"content":"concrt-parallel-bitonic-sort#3"},{"pos":[4195,4305],"content":"Create an overloaded version of the <ph id=\"ph1\">`parallel_bitonic_sort`</ph> function that sorts the array in increasing order.","source":"Create an overloaded version of the `parallel_bitonic_sort` function that sorts the array in increasing order."},{"pos":[4323,4353],"content":"concrt-parallel-bitonic-sort#4"},{"content":"The <ph id=\"ph1\">`parallel_invoke`</ph> algorithm reduces overhead by performing the last of the series of tasks on the calling context.","pos":[4467,4585],"source":"The `parallel_invoke` algorithm reduces overhead by performing the last of the series of tasks on the calling context."},{"content":"For example, in the <ph id=\"ph1\">`parallel_bitonic_sort`</ph> function, the first task runs on a separate context, and the second task runs on the calling context.","pos":[4586,4731],"source":" For example, in the `parallel_bitonic_sort` function, the first task runs on a separate context, and the second task runs on the calling context."},{"pos":[4749,4779],"content":"concrt-parallel-bitonic-sort#5"},{"content":"The following complete example performs both the serial and the parallel versions of the bitonic sort algorithm.","pos":[4893,5005]},{"content":"The example also prints to the console the time that is required to perform each computation.","pos":[5006,5099]},{"pos":[5117,5147],"content":"concrt-parallel-bitonic-sort#8"},{"content":"The following sample output is for a computer that has four processors.","pos":[5261,5332]},{"pos":[5402,5415],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"content":"Compiling the Code","pos":[5424,5442]},{"pos":[5446,5661],"content":"To compile the code, copy it and then paste it in a Visual Studio project, or paste it in a file that is named <ph id=\"ph1\">`parallel-bitonic-sort.cpp`</ph> and then run the following command in a Visual Studio Command Prompt window.","source":"To compile the code, copy it and then paste it in a Visual Studio project, or paste it in a file that is named `parallel-bitonic-sort.cpp` and then run the following command in a Visual Studio Command Prompt window."},{"content":"cl.exe /EHsc parallel-bitonic-sort.cpp","pos":[5670,5708]},{"content":"Robust Programming","pos":[5719,5737]},{"content":"This example uses the <ph id=\"ph1\">`parallel_invoke`</ph> algorithm instead of the <bpt id=\"p1\">[</bpt>concurrency::task_group<ept id=\"p1\">](reference/task-group-class.md)</ept> class because the lifetime of each task group does not extend beyond a function.","pos":[5741,5943],"source":"This example uses the `parallel_invoke` algorithm instead of the [concurrency::task_group](reference/task-group-class.md) class because the lifetime of each task group does not extend beyond a function."},{"content":"We recommend that you use <ph id=\"ph1\">`parallel_invoke`</ph> when you can because it has less execution overhead than <ph id=\"ph2\">`task group`</ph> objects, and therefore lets you write better performing code.","pos":[5944,6119],"source":" We recommend that you use `parallel_invoke` when you can because it has less execution overhead than `task group` objects, and therefore lets you write better performing code."},{"content":"The parallel versions of some algorithms perform better only when there is sufficient work to do.","pos":[6126,6223]},{"content":"For example, the <ph id=\"ph1\">`parallel_bitonic_merge`</ph> function calls the serial version, <ph id=\"ph2\">`bitonic_merge`</ph>, if there are 500 or fewer elements in the sequence.","pos":[6224,6369],"source":" For example, the `parallel_bitonic_merge` function calls the serial version, `bitonic_merge`, if there are 500 or fewer elements in the sequence."},{"content":"You can also plan your overall sorting strategy based on the amount of work.","pos":[6370,6446]},{"content":"For example, it might be more efficient to use the serial version of the quick sort algorithm if the array contains fewer than 500 items, as shown in the following example:","pos":[6447,6619]},{"pos":[6637,6667],"content":"concrt-parallel-bitonic-sort#9"},{"content":"As with any parallel algorithm, we recommend that you profile and tune your code as appropriate.","pos":[6781,6877]},{"content":"See Also","pos":[6886,6894]},{"content":"Task Parallelism","pos":[6899,6915]},{"content":"parallel_invoke Function","pos":[6985,7009]}],"content":"---\ntitle: \"How to: Use parallel_invoke to Write a Parallel Sort Routine | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"task_handle class, example\"\n  - \"task_group class, example\"\n  - \"make_task function, example\"\n  - \"structured_task_group class, example\"\n  - \"improving parallel performance with task groups [Concurrency Runtime]\"\nms.assetid: 53979a2a-525d-4437-8952-f1ff85b37673\ncaps.latest.revision: 23\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# How to: Use parallel_invoke to Write a Parallel Sort Routine\nThis document describes how to use the [parallel_invoke](../../parallel/concrt/parallel-algorithms.md#parallel_invoke) algorithm to improve the performance of the bitonic sort algorithm. The bitonic sort algorithm recursively divides the input sequence into smaller sorted partitions. The bitonic sort algorithm can run in parallel because each partition operation is independent of all other operations.  \n  \n Although the bitonic sort is an example of a *sorting network* that sorts all combinations of input sequences, this example sorts sequences whose lengths are a power of two.  \n  \n> [!NOTE]\n>  This example uses a parallel sort routine for illustration. You can also use the built-in sorting algorithms that the PPL provides: [concurrency::parallel_sort](reference/concurrency-namespace-functions.md#parallel_sort), [concurrency::parallel_buffered_sort](reference/concurrency-namespace-functions.md#parallel_buffered_sort), and [concurrency::parallel_radixsort](reference/concurrency-namespace-functions.md#parallel_radixsort). For more information, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md).  \n  \n##  <a name=\"top\"></a> Sections  \n This document describes the following tasks:  \n  \n- [Performing Bitonic Sort Serially](#serial)  \n  \n- [Using parallel_invoke to Perform Bitonic Sort in Parallel](#parallel)  \n  \n##  <a name=\"serial\"></a> Performing Bitonic Sort Serially  \n The following example shows the serial version of the bitonic sort algorithm. The `bitonic_sort` function divides the sequence into two partitions, sorts those partitions in opposite directions, and then merges the results. This function calls itself two times recursively to sort each partition.  \n  \n [!code-cpp[concrt-parallel-bitonic-sort#1](../../parallel/concrt/codesnippet/cpp/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine_1.cpp)]  \n  \n [[Top](#top)]  \n  \n##  <a name=\"parallel\"></a> Using parallel_invoke to Perform Bitonic Sort in Parallel  \n This section describes how to use the `parallel_invoke` algorithm to perform the bitonic sort algorithm in parallel.  \n  \n### Procedures  \n  \n##### To perform the bitonic sort algorithm in parallel  \n  \n1.  Add a `#include` directive for the header file ppl.h.  \n  \n [!code-cpp[concrt-parallel-bitonic-sort#10](../../parallel/concrt/codesnippet/cpp/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine_2.cpp)]  \n  \n2.  Add a `using` directive for the `concurrency` namespace.  \n  \n [!code-cpp[concrt-parallel-bitonic-sort#11](../../parallel/concrt/codesnippet/cpp/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine_3.cpp)]  \n  \n3.  Create a new function, called `parallel_bitonic_mege`, which uses the `parallel_invoke` algorithm to merge the sequences in parallel if there is sufficient amount of work to do. Otherwise, call `bitonic_merge` to merge the sequences serially.  \n  \n [!code-cpp[concrt-parallel-bitonic-sort#2](../../parallel/concrt/codesnippet/cpp/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine_4.cpp)]  \n  \n4.  Perform a process that resembles the one in the previous step, but for the `bitonic_sort` function.  \n  \n [!code-cpp[concrt-parallel-bitonic-sort#3](../../parallel/concrt/codesnippet/cpp/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine_5.cpp)]  \n  \n5.  Create an overloaded version of the `parallel_bitonic_sort` function that sorts the array in increasing order.  \n  \n [!code-cpp[concrt-parallel-bitonic-sort#4](../../parallel/concrt/codesnippet/cpp/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine_6.cpp)]  \n  \n The `parallel_invoke` algorithm reduces overhead by performing the last of the series of tasks on the calling context. For example, in the `parallel_bitonic_sort` function, the first task runs on a separate context, and the second task runs on the calling context.  \n  \n [!code-cpp[concrt-parallel-bitonic-sort#5](../../parallel/concrt/codesnippet/cpp/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine_7.cpp)]  \n  \n The following complete example performs both the serial and the parallel versions of the bitonic sort algorithm. The example also prints to the console the time that is required to perform each computation.  \n  \n [!code-cpp[concrt-parallel-bitonic-sort#8](../../parallel/concrt/codesnippet/cpp/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine_8.cpp)]  \n  \n The following sample output is for a computer that has four processors.  \n  \n```Output  \nserial time: 4353  \nparallel time: 1248  \n```  \n  \n [[Top](#top)]  \n  \n## Compiling the Code  \n To compile the code, copy it and then paste it in a Visual Studio project, or paste it in a file that is named `parallel-bitonic-sort.cpp` and then run the following command in a Visual Studio Command Prompt window.  \n  \n **cl.exe /EHsc parallel-bitonic-sort.cpp**  \n  \n## Robust Programming  \n This example uses the `parallel_invoke` algorithm instead of the [concurrency::task_group](reference/task-group-class.md) class because the lifetime of each task group does not extend beyond a function. We recommend that you use `parallel_invoke` when you can because it has less execution overhead than `task group` objects, and therefore lets you write better performing code.  \n  \n The parallel versions of some algorithms perform better only when there is sufficient work to do. For example, the `parallel_bitonic_merge` function calls the serial version, `bitonic_merge`, if there are 500 or fewer elements in the sequence. You can also plan your overall sorting strategy based on the amount of work. For example, it might be more efficient to use the serial version of the quick sort algorithm if the array contains fewer than 500 items, as shown in the following example:  \n  \n [!code-cpp[concrt-parallel-bitonic-sort#9](../../parallel/concrt/codesnippet/cpp/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine_9.cpp)]  \n  \n As with any parallel algorithm, we recommend that you profile and tune your code as appropriate.  \n  \n## See Also  \n [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md)   \n [parallel_invoke Function](reference/concurrency-namespace-functions.md#parallel_invoke)\n\n"}