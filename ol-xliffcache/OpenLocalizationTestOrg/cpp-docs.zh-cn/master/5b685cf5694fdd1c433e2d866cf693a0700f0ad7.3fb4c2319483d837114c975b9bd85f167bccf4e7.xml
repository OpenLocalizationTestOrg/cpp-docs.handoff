{"nodes":[{"pos":[12,53],"content":"CString Argument Passing | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CString Argument Passing | Microsoft Docs","pos":[0,41]}]},{"content":"CString Argument Passing","pos":[850,874]},{"pos":[875,1038],"content":"This article explains how to pass <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../atl-mfc-shared/reference/cstringt-class.md)</ept> objects to functions and how to return <ph id=\"ph1\">`CString`</ph> objects from functions.","source":"This article explains how to pass [CString](../atl-mfc-shared/reference/cstringt-class.md) objects to functions and how to return `CString` objects from functions."},{"pos":[1109,1145],"content":"CString Argument-Passing Conventions"},{"content":"When you define a class interface, you must determine the argument-passing convention for your member functions.","pos":[1149,1261]},{"content":"There are some standard rules for passing and returning <ph id=\"ph1\">`CString`</ph> objects.","pos":[1262,1336],"source":" There are some standard rules for passing and returning `CString` objects."},{"content":"If you follow the rules described in <bpt id=\"p1\">[</bpt>Strings as Function Inputs<ept id=\"p1\">](#_core_strings_as_function_inputs)</ept> and <bpt id=\"p2\">[</bpt>Strings as Function Outputs<ept id=\"p2\">](#_core_strings_as_function_outputs)</ept>, you will have efficient, correct code.","pos":[1337,1547],"source":" If you follow the rules described in [Strings as Function Inputs](#_core_strings_as_function_inputs) and [Strings as Function Outputs](#_core_strings_as_function_outputs), you will have efficient, correct code."},{"pos":[1605,1631],"content":"Strings as Function Inputs"},{"content":"The most efficient and secure way to use a <ph id=\"ph1\">`CString`</ph> object in called functions is to pass a <ph id=\"ph2\">`CString`</ph> object to the function.","pos":[1635,1761],"source":"The most efficient and secure way to use a `CString` object in called functions is to pass a `CString` object to the function."},{"content":"Despite the name, a <ph id=\"ph1\">`CString`</ph> object does not store a string internally as a C-style string that has a null terminator.","pos":[1762,1881],"source":" Despite the name, a `CString` object does not store a string internally as a C-style string that has a null terminator."},{"content":"Instead, a <ph id=\"ph1\">`CString`</ph> object keeps careful track of the number of characters it has.","pos":[1882,1965],"source":" Instead, a `CString` object keeps careful track of the number of characters it has."},{"content":"Having <ph id=\"ph1\">`CString`</ph> provide a <ph id=\"ph2\">`LPCTSTR`</ph> pointer to a null-terminated string is a small amount of work that can become significant if your code has to do it constantly.","pos":[1966,2130],"source":" Having `CString` provide a `LPCTSTR` pointer to a null-terminated string is a small amount of work that can become significant if your code has to do it constantly."},{"content":"The result is temporary because any change to the <ph id=\"ph1\">`CString`</ph> contents invalidates old copies of the <ph id=\"ph2\">`LPCTSTR`</ph> pointer.","pos":[2131,2248],"source":" The result is temporary because any change to the `CString` contents invalidates old copies of the `LPCTSTR` pointer."},{"content":"It does make sense in some cases to provide a C-style string.","pos":[2255,2316]},{"content":"For example, there can be a situation where a called function is written in C and does not support objects.","pos":[2317,2424]},{"content":"In this case, coerce the <ph id=\"ph1\">`CString`</ph> parameter to <ph id=\"ph2\">`LPCTSTR`</ph>, and the function will get a C-style null-terminated string.","pos":[2425,2543],"source":" In this case, coerce the `CString` parameter to `LPCTSTR`, and the function will get a C-style null-terminated string."},{"content":"You can also go the other direction and create a <ph id=\"ph1\">`CString`</ph> object by using the <ph id=\"ph2\">`CString`</ph> constructor that accepts a C-style string parameter.","pos":[2544,2685],"source":" You can also go the other direction and create a `CString` object by using the `CString` constructor that accepts a C-style string parameter."},{"pos":[2692,2822],"content":"If the string contents are to be changed by a function, declare the parameter as a nonconstant <ph id=\"ph1\">`CString`</ph> reference (<bpt id=\"p1\">**</bpt>CString&amp;<ept id=\"p1\">**</ept>).","source":"If the string contents are to be changed by a function, declare the parameter as a nonconstant `CString` reference (**CString&**)."},{"pos":[2881,2908],"content":"Strings as Function Outputs"},{"content":"Typically you can return <ph id=\"ph1\">`CString`</ph> objects from functions because <ph id=\"ph2\">`CString`</ph> objects follow value semantics like primitive types.","pos":[2912,3040],"source":"Typically you can return `CString` objects from functions because `CString` objects follow value semantics like primitive types."},{"content":"To return a read-only string, use a constant <ph id=\"ph1\">`CString`</ph> reference (<bpt id=\"p1\">**</bpt>const CString&amp;<ept id=\"p1\">**</ept>).","pos":[3041,3127],"source":" To return a read-only string, use a constant `CString` reference (**const CString&**)."},{"content":"The following example illustrates the use of <ph id=\"ph1\">`CString`</ph> parameters and return types:","pos":[3128,3211],"source":" The following example illustrates the use of `CString` parameters and return types:"},{"pos":[3229,3253],"content":"NVC_ATLMFC_Utilities#197"},{"pos":[3339,3363],"content":"NVC_ATLMFC_Utilities#198"},{"content":"See Also","pos":[3440,3448]},{"content":"Strings (ATL/MFC)","pos":[3453,3470]}],"content":"---\ntitle: \"CString Argument Passing | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"strings [C++], as function input/output\"\n  - \"argument passing [C++]\"\n  - \"arguments [C++], passing\"\n  - \"functions [C++], strings as input/output\"\n  - \"argument passing [C++], C strings\"\n  - \"passing arguments, C strings\"\n  - \"CString objects, passing arguments\"\n  - \"string arguments\"\nms.assetid: a67bebff-edf1-4cf4-bbff-d1cc6a901099\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CString Argument Passing\nThis article explains how to pass [CString](../atl-mfc-shared/reference/cstringt-class.md) objects to functions and how to return `CString` objects from functions.  \n  \n##  <a name=\"_core_cstring_argument.2d.passing_conventions\"></a> CString Argument-Passing Conventions  \n When you define a class interface, you must determine the argument-passing convention for your member functions. There are some standard rules for passing and returning `CString` objects. If you follow the rules described in [Strings as Function Inputs](#_core_strings_as_function_inputs) and [Strings as Function Outputs](#_core_strings_as_function_outputs), you will have efficient, correct code.  \n  \n##  <a name=\"_core_strings_as_function_inputs\"></a> Strings as Function Inputs  \n The most efficient and secure way to use a `CString` object in called functions is to pass a `CString` object to the function. Despite the name, a `CString` object does not store a string internally as a C-style string that has a null terminator. Instead, a `CString` object keeps careful track of the number of characters it has. Having `CString` provide a `LPCTSTR` pointer to a null-terminated string is a small amount of work that can become significant if your code has to do it constantly. The result is temporary because any change to the `CString` contents invalidates old copies of the `LPCTSTR` pointer.  \n  \n It does make sense in some cases to provide a C-style string. For example, there can be a situation where a called function is written in C and does not support objects. In this case, coerce the `CString` parameter to `LPCTSTR`, and the function will get a C-style null-terminated string. You can also go the other direction and create a `CString` object by using the `CString` constructor that accepts a C-style string parameter.  \n  \n If the string contents are to be changed by a function, declare the parameter as a nonconstant `CString` reference (**CString&**).  \n  \n##  <a name=\"_core_strings_as_function_outputs\"></a> Strings as Function Outputs  \n Typically you can return `CString` objects from functions because `CString` objects follow value semantics like primitive types. To return a read-only string, use a constant `CString` reference (**const CString&**). The following example illustrates the use of `CString` parameters and return types:  \n  \n [!code-cpp[NVC_ATLMFC_Utilities#197](../atl-mfc-shared/codesnippet/cpp/cstring-argument-passing_1.cpp)]  \n  \n [!code-cpp[NVC_ATLMFC_Utilities#198](../atl-mfc-shared/codesnippet/cpp/cstring-argument-passing_2.cpp)]  \n  \n## See Also  \n [Strings (ATL/MFC)](../atl-mfc-shared/strings-atl-mfc.md)\n\n"}