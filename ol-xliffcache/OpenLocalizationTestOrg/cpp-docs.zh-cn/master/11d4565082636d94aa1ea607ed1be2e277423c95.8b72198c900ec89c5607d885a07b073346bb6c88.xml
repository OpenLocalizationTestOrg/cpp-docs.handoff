{"nodes":[{"pos":[12,44],"content":"Class Templates | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Class Templates | Microsoft Docs","pos":[0,32]}]},{"content":"Class Templates","pos":[652,667]},{"content":"This topic describes rules that are specific to C++ class templates.","pos":[668,736]},{"content":"Member functions of class templates","pos":[745,780]},{"content":"Member functions can be defined inside or outside of a class template.","pos":[784,854]},{"content":"They are defined like function templates if defined outside the class template.","pos":[855,934]},{"content":"Note that just as with any template class member function, the definition of the class's constructor member function includes the template argument list twice.","pos":[1493,1652]},{"content":"Member functions can themselves be function templates, specifying additional parameters, as in the following example.","pos":[1659,1776]},{"content":"Nested class templates","pos":[2047,2069]},{"content":"Templates can be defined within classes or class templates, in which case they are referred to as member templates.","pos":[2073,2188]},{"content":"Member templates that are classes are referred to as nested class templates.","pos":[2189,2265]},{"content":"Member templates that are functions are discussed in <bpt id=\"p1\">[</bpt>Member Function Templates<ept id=\"p1\">](../cpp/member-function-templates.md)</ept>.","pos":[2266,2384],"source":" Member templates that are functions are discussed in [Member Function Templates](../cpp/member-function-templates.md)."},{"content":"Nested class templates are declared as class templates inside the scope of the outer class.","pos":[2391,2482]},{"content":"They can be defined inside or outside of the enclosing class.","pos":[2483,2544]},{"content":"The following code demonstrates a nested class template inside an ordinary class.","pos":[2551,2632]},{"content":"Local classes are not allowed to have member templates.","pos":[4261,4316]},{"content":"Template friends","pos":[4325,4341]},{"content":"Class templates can have <bpt id=\"p1\">[</bpt>friends<ept id=\"p1\">](http://msdn.microsoft.com/en-us/bf412640-d857-4acb-b2b5-513131cb9681)</ept>.","pos":[4345,4450],"source":"Class templates can have [friends](http://msdn.microsoft.com/en-us/bf412640-d857-4acb-b2b5-513131cb9681)."},{"content":"A class or class template, function, or function template can be a friend to a template class.","pos":[4451,4545]},{"content":"Friends can also be specializations of a class template or function template, but not partial specializations.","pos":[4546,4656]},{"content":"In the following example, a friend function is defined as a function template within the class template.","pos":[4663,4767]},{"content":"This code produces a version of the friend function for every instantiation of the template.","pos":[4768,4860]},{"content":"This construct is useful if your friend function depends on the same template parameters as the class does.","pos":[4861,4968]},{"content":"The next example involves a friend that has a template specialization.","pos":[6673,6743]},{"content":"A function template specialization is automatically a friend if the original function template is a friend.","pos":[6744,6851]},{"content":"It is also possible to declare only the specialized version of the template as the friend, as the comment before the friend declaration in the following code indicates.","pos":[6858,7026]},{"content":"If you do this, you must put the definition of the friend template specialization outside of the template class.","pos":[7027,7139]},{"content":"The next example shows a friend class template declared within a class template.","pos":[8837,8917]},{"content":"The class template is then used as the template argument for the friend class.","pos":[8918,8996]},{"content":"Friend class templates must be defined outside of the class template in which they are declared.","pos":[8997,9093]},{"content":"Any specializations or partial specializations of the friend template are also friends of the original class template.","pos":[9094,9212]},{"content":"Reuse of Template Parameters","pos":[10131,10159]},{"content":"Template parameters can be reused in the template parameter list.","pos":[10163,10228]},{"content":"For example, the following code is allowed:","pos":[10229,10272]},{"content":"See Also","pos":[10526,10534]},{"content":"Templates","pos":[10539,10548]}],"content":"---\ntitle: \"Class Templates | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"classes [C++], operating on type\"\n  - \"class templates\"\n  - \"templates, class templates\"\nms.assetid: 633a53c8-24ee-4c23-8c88-e7c3cb0b7ac3\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Class Templates\nThis topic describes rules that are specific to C++ class templates.  \n  \n## Member functions of class templates  \n Member functions can be defined inside or outside of a class template. They are defined like function templates if defined outside the class template.  \n  \n```cpp  \n  \nCopy Code  \n// member_function_templates1.cpp  \ntemplate<class T, int i> class MyStack  \n{  \n    T*  pStack;  \n    T StackBuffer[i];  \n    static const int cItems = i * sizeof(T);  \npublic:   \n    MyStack( void );  \n    void push( const T item );  \n    T& pop( void );  \n};  \n  \ntemplate< class T, int i > MyStack< T, i >::MyStack( void )  \n{  \n};  \n  \ntemplate< class T, int i > void MyStack< T, i >::push( const T item )  \n{  \n};  \n  \ntemplate< class T, int i > T& MyStack< T, i >::pop( void )  \n{  \n};  \n  \nint main()  \n{  \n}  \n```  \n  \n Note that just as with any template class member function, the definition of the class's constructor member function includes the template argument list twice.  \n  \n Member functions can themselves be function templates, specifying additional parameters, as in the following example.  \n  \n```cpp  \n  \n// member_templates.cpp  \ntemplate<typename T>  \nclass X  \n{  \npublic:  \n   template<typename U>  \n   void mf(const U &u);  \n};  \n  \ntemplate<typename T> template <typename U>  \nvoid X<T>::mf(const U &u)  \n{  \n}  \n  \nint main()  \n{  \n}  \n  \n```  \n  \n## Nested class templates  \n Templates can be defined within classes or class templates, in which case they are referred to as member templates. Member templates that are classes are referred to as nested class templates. Member templates that are functions are discussed in [Member Function Templates](../cpp/member-function-templates.md).  \n  \n Nested class templates are declared as class templates inside the scope of the outer class. They can be defined inside or outside of the enclosing class.  \n  \n The following code demonstrates a nested class template inside an ordinary class.  \n  \n```cpp  \n// nested_class_template1.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \nclass X  \n{  \n  \n   template <class T>  \n   struct Y  \n   {  \n      T m_t;  \n      Y(T t): m_t(t) { }     \n   };  \n  \n   Y<int> yInt;  \n   Y<char> yChar;  \n  \npublic:  \n   X(int i, char c) : yInt(i), yChar(c) { }  \n   void print()  \n   {  \n      cout << yInt.m_t << \" \" << yChar.m_t << endl;  \n   }  \n};  \n  \nint main()  \n{  \n   X x(1, 'a');  \n   x.print();  \n}  \n```  \n  \n```cpp  \n// nested_class_template2.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \ntemplate <class T>  \nclass X  \n{  \n   template <class U> class Y  \n   {  \n      U* u;  \n   public:  \n      Y();  \n      U& Value();  \n      void print();  \n      ~Y();  \n   };  \n  \n   Y<int> y;  \npublic:  \n   X(T t) { y.Value() = t; }  \n   void print() { y.print(); }  \n};  \n  \ntemplate <class T>   \ntemplate <class U>  \nX<T>::Y<U>::Y()  \n{  \n   cout << \"X<T>::Y<U>::Y()\" << endl;  \n   u = new U();  \n}  \n  \ntemplate <class T>   \ntemplate <class U>  \nU& X<T>::Y<U>::Value()  \n{  \n   return *u;  \n}  \n  \ntemplate <class T>   \ntemplate <class U>  \nvoid X<T>::Y<U>::print()  \n{  \n   cout << this->Value() << endl;  \n}  \n  \ntemplate <class T>   \ntemplate <class U>  \nX<T>::Y<U>::~Y()  \n{  \n   cout << \"X<T>::Y<U>::~Y()\" << endl;  \n   delete u;  \n}  \n  \nint main()  \n{  \n   X<int>* xi = new X<int>(10);  \n   X<char>* xc = new X<char>('c');  \n   xi->print();  \n   xc->print();  \n   delete xi;  \n   delete xc;  \n}  \n  \n//Output:   \nX<T>::Y<U>::Y()  \nX<T>::Y<U>::Y()  \n10  \n99  \nX<T>::Y<U>::~Y()  \nX<T>::Y<U>::~Y()  \n  \n```  \n  \n Local classes are not allowed to have member templates.  \n  \n## Template friends  \n Class templates can have [friends](http://msdn.microsoft.com/en-us/bf412640-d857-4acb-b2b5-513131cb9681). A class or class template, function, or function template can be a friend to a template class. Friends can also be specializations of a class template or function template, but not partial specializations.  \n  \n In the following example, a friend function is defined as a function template within the class template. This code produces a version of the friend function for every instantiation of the template. This construct is useful if your friend function depends on the same template parameters as the class does.  \n  \n```cpp  \n// template_friend1.cpp  \n// compile with: /EHsc  \n  \n#include <iostream>  \nusing namespace std;  \n  \ntemplate <class T> class Array {  \n   T* array;  \n   int size;  \n  \npublic:  \n   Array(int sz): size(sz) {  \n      array = new T[size];  \n      memset(array, 0, size * sizeof(T));  \n   }  \n  \n   Array(const Array& a) {  \n      size = a.size;  \n      array = new T[size];  \n      memcpy_s(array, a.array, sizeof(T));  \n   }  \n  \n   T& operator[](int i) {  \n      return *(array + i);  \n   }  \n  \n   int Length() { return size; }  \n  \n   void print() {  \n      for (int i = 0; i < size; i++)        \n         cout << *(array + i) << \" \";  \n  \n      cout << endl;  \n   }  \n  \n   template<class T>  \n   friend Array<T>* combine(Array<T>& a1, Array<T>& a2);  \n};  \n  \ntemplate<class T>  \nArray<T>* combine(Array<T>& a1, Array<T>& a2) {  \n   Array<T>* a = new Array<T>(a1.size + a2.size);  \n   for (int i = 0; i < a1.size; i++)  \n      (*a)[i] = *(a1.array + i);  \n  \n   for (int i = 0; i < a2.size; i++)  \n      (*a)[i + a1.size] = *(a2.array + i);  \n  \n   return a;  \n}  \n  \nint main() {  \n   Array<char> alpha1(26);  \n   for (int i = 0 ; i < alpha1.Length() ; i++)  \n      alpha1[i] = 'A' + i;  \n  \n   alpha1.print();  \n  \n   Array<char> alpha2(26);  \n   for (int i = 0 ; i < alpha2.Length() ; i++)  \n      alpha2[i] = 'a' + i;  \n  \n   alpha2.print();  \n   Array<char>*alpha3 = combine(alpha1, alpha2);  \n   alpha3->print();  \n   delete alpha3;  \n}  \n//Output:   \nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z   \na b c d e f g h i j k l m n o p q r s t u v w x y z   \nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z   \n```  \n  \n The next example involves a friend that has a template specialization. A function template specialization is automatically a friend if the original function template is a friend.  \n  \n It is also possible to declare only the specialized version of the template as the friend, as the comment before the friend declaration in the following code indicates. If you do this, you must put the definition of the friend template specialization outside of the template class.  \n  \n```cpp  \n// template_friend2.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \ntemplate <class T>  \nclass Array;  \n  \ntemplate <class T>  \nvoid f(Array<T>& a);  \n  \ntemplate <class T> class Array  \n{  \n    T* array;  \n    int size;  \n  \npublic:  \n    Array(int sz): size(sz)  \n    {  \n        array = new T[size];  \n        memset(array, 0, size * sizeof(T));  \n    }  \n    Array(const Array& a)  \n    {  \n        size = a.size;  \n        array = new T[size];  \n        memcpy_s(array, a.array, sizeof(T));  \n    }  \n    T& operator[](int i)  \n    {  \n        return *(array + i);  \n    }  \n    int Length()  \n    {   \n        return size;  \n    }  \n    void print()  \n    {  \n        for (int i = 0; i < size; i++)  \n        {  \n            cout << *(array + i) << \" \";  \n        }  \n        cout << endl;  \n    }  \n    // If you replace the friend declaration with the int-specific  \n    // version, only the int specialization will be a friend.  \n    // The code in the generic f will fail  \n    // with C2248: 'Array<T>::size' :  \n    // cannot access private member declared in class 'Array<T>'.  \n    //friend void f<int>(Array<int>& a);  \n  \n    friend void f<>(Array<T>& a);  \n};  \n  \n// f function template, friend of Array<T>  \ntemplate <class T>  \nvoid f(Array<T>& a)  \n{  \n    cout << a.size << \" generic\" << endl;  \n}  \n  \n// Specialization of f for int arrays  \n// will be a friend because the template f is a friend.  \ntemplate<> void f(Array<int>& a)  \n{  \n    cout << a.size << \" int\" << endl;  \n}  \n  \nint main()  \n{  \n    Array<char> ac(10);  \n    f(ac);  \n  \n    Array<int> a(10);  \n    f(a);  \n}  \n//Output:  \n10 generic  \n10 int  \n```  \n  \n The next example shows a friend class template declared within a class template. The class template is then used as the template argument for the friend class. Friend class templates must be defined outside of the class template in which they are declared. Any specializations or partial specializations of the friend template are also friends of the original class template.  \n  \n```cpp  \n// template_friend3.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \ntemplate <class T>  \nclass X  \n{  \nprivate:  \n   T* data;  \n   void InitData(int seed) { data = new T(seed); }  \npublic:  \n   void print() { cout << *data << endl; }  \n   template <class U> friend class Factory;  \n};  \n  \ntemplate <class U>  \nclass Factory  \n{  \npublic:  \n   U* GetNewObject(int seed)  \n   {  \n      U* pu = new U;  \n      pu->InitData(seed);  \n      return pu;  \n   }  \n};  \n  \nint main()  \n{  \n   Factory< X<int> > XintFactory;  \n   X<int>* x1 = XintFactory.GetNewObject(65);  \n   X<int>* x2 = XintFactory.GetNewObject(97);  \n  \n   Factory< X<char> > XcharFactory;  \n   X<char>* x3 = XcharFactory.GetNewObject(65);  \n   X<char>* x4 = XcharFactory.GetNewObject(97);  \n   x1->print();  \n   x2->print();  \n   x3->print();  \n   x4->print();  \n}  \n//Output:   \n65  \n97  \nA  \na  \n```  \n  \n## Reuse of Template Parameters  \n Template parameters can be reused in the template parameter list. For example, the following code is allowed:  \n  \n```cpp  \n// template_specifications2.cpp  \n  \nclass Y   \n{  \n};  \ntemplate<class T, T* pT> class X1   \n{  \n};  \ntemplate<class T1, class T2 = T1> class X2   \n{  \n};  \n  \nY aY;  \n  \nX1<Y, &aY> x1;  \nX2<int> x2;  \n  \nint main()  \n{  \n}  \n```  \n  \n## See Also  \n [Templates](../cpp/templates-cpp.md)"}