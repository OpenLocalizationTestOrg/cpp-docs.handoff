{"nodes":[{"pos":[12,57],"content":"Avoidance of Heap Contention | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Avoidance of Heap Contention | Microsoft Docs","pos":[0,45]}]},{"content":"Avoidance of Heap Contention","pos":[584,612]},{"content":"The default string managers provided by MFC and ATL are simple wrappers on top of a global heap.","pos":[613,709]},{"content":"This global heap is fully thread-safe, meaning that multiple threads can allocate and free memory from it simultaneously without corrupting the heap.","pos":[710,859]},{"content":"To help provide thread safety, the heap has to serialize access to itself.","pos":[860,934]},{"content":"This is usually accomplished with a critical section or similar locking mechanism.","pos":[935,1017]},{"content":"Whenever two threads try to access the heap simultaneously, one thread is blocked until the other thread's request is finished.","pos":[1018,1145]},{"content":"For many applications, this situation rarely occurs and the performance impact of the heap's locking mechanism is negligible.","pos":[1146,1271]},{"content":"However, for applications that frequently access the heap from multiple threads contention for the heap's lock can cause the application to run slower than if it were single-threaded (even on machines with multiple CPUs).","pos":[1272,1493]},{"pos":[1500,1720],"content":"Applications that use <bpt id=\"p1\">[</bpt>CStringT<ept id=\"p1\">](../atl-mfc-shared/reference/cstringt-class.md)</ept> are especially susceptible to heap contention because operations on <ph id=\"ph1\">`CStringT`</ph> objects frequently require reallocation of the string buffer.","source":"Applications that use [CStringT](../atl-mfc-shared/reference/cstringt-class.md) are especially susceptible to heap contention because operations on `CStringT` objects frequently require reallocation of the string buffer."},{"content":"One way to alleviate heap contention between threads is to have each thread allocate strings from a private, thread-local heap.","pos":[1727,1854]},{"content":"As long as the strings allocated with a particular thread's allocator are used only in that thread, the allocator need not be thread-safe.","pos":[1855,1993]},{"content":"Example","pos":[2002,2009]},{"content":"The example below illustrates a thread procedure that allocates its own private non-thread-safe heap to use for strings on that thread:","pos":[2013,2148]},{"pos":[2166,2190],"content":"NVC_ATLMFC_Utilities#182"},{"content":"Comments","pos":[2271,2279]},{"content":"Multiple threads could be running using this same thread procedure but since each thread has its own heap there is no contention between threads.","pos":[2283,2428]},{"content":"In addition, the fact that each heap is not thread-safe gives a measurable increase in performance even if just one copy of the thread is running.","pos":[2429,2575]},{"content":"This is the result of the heap not using expensive interlocked operations to protect against concurrent access.","pos":[2576,2687]},{"content":"For a more complicated thread procedure, it may be convenient to store a pointer to the thread's string manager in a thread local storage (TLS) slot.","pos":[2694,2843]},{"content":"This allows other functions called by the thread procedure to access the thread's string manager.","pos":[2844,2941]},{"content":"See Also","pos":[2950,2958]},{"content":"Memory Management with CStringT","pos":[2963,2994]}],"content":"---\ntitle: \"Avoidance of Heap Contention | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"heap contention\"\nms.assetid: 797129d7-5f8c-4b0e-8974-bb93217e9ab5\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Avoidance of Heap Contention\nThe default string managers provided by MFC and ATL are simple wrappers on top of a global heap. This global heap is fully thread-safe, meaning that multiple threads can allocate and free memory from it simultaneously without corrupting the heap. To help provide thread safety, the heap has to serialize access to itself. This is usually accomplished with a critical section or similar locking mechanism. Whenever two threads try to access the heap simultaneously, one thread is blocked until the other thread's request is finished. For many applications, this situation rarely occurs and the performance impact of the heap's locking mechanism is negligible. However, for applications that frequently access the heap from multiple threads contention for the heap's lock can cause the application to run slower than if it were single-threaded (even on machines with multiple CPUs).  \n  \n Applications that use [CStringT](../atl-mfc-shared/reference/cstringt-class.md) are especially susceptible to heap contention because operations on `CStringT` objects frequently require reallocation of the string buffer.  \n  \n One way to alleviate heap contention between threads is to have each thread allocate strings from a private, thread-local heap. As long as the strings allocated with a particular thread's allocator are used only in that thread, the allocator need not be thread-safe.  \n  \n## Example  \n The example below illustrates a thread procedure that allocates its own private non-thread-safe heap to use for strings on that thread:  \n  \n [!code-cpp[NVC_ATLMFC_Utilities#182](../atl-mfc-shared/codesnippet/cpp/avoidance-of-heap-contention_1.cpp)]  \n  \n## Comments  \n Multiple threads could be running using this same thread procedure but since each thread has its own heap there is no contention between threads. In addition, the fact that each heap is not thread-safe gives a measurable increase in performance even if just one copy of the thread is running. This is the result of the heap not using expensive interlocked operations to protect against concurrent access.  \n  \n For a more complicated thread procedure, it may be convenient to store a pointer to the thread's string manager in a thread local storage (TLS) slot. This allows other functions called by the thread procedure to access the thread's string manager.  \n  \n## See Also  \n [Memory Management with CStringT](../atl-mfc-shared/memory-management-with-cstringt.md)\n\n"}