{"nodes":[{"pos":[12,54],"content":"Windows Sockets: Blocking | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Windows Sockets: Blocking | Microsoft Docs","pos":[0,42]}]},{"content":"Windows Sockets: Blocking","pos":[771,796]},{"content":"This article and two companion articles explain several issues in Windows Sockets programming.","pos":[797,891]},{"content":"This article covers blocking.","pos":[892,921]},{"content":"The other issues are covered in the articles: <bpt id=\"p1\">[</bpt>Windows Sockets: Byte Ordering<ept id=\"p1\">](../mfc/windows-sockets-byte-ordering.md)</ept> and <bpt id=\"p2\">[</bpt>Windows Sockets: Converting Strings<ept id=\"p2\">](../mfc/windows-sockets-converting-strings.md)</ept>.","pos":[922,1130],"source":" The other issues are covered in the articles: [Windows Sockets: Byte Ordering](../mfc/windows-sockets-byte-ordering.md) and [Windows Sockets: Converting Strings](../mfc/windows-sockets-converting-strings.md)."},{"content":"If you use or derive from class <bpt id=\"p1\">[</bpt>CAsyncSocket<ept id=\"p1\">](../mfc/reference/casyncsocket-class.md)</ept>, you will need to manage these issues yourself.","pos":[1137,1271],"source":"If you use or derive from class [CAsyncSocket](../mfc/reference/casyncsocket-class.md), you will need to manage these issues yourself."},{"content":"If you use or derive from class <bpt id=\"p1\">[</bpt>CSocket<ept id=\"p1\">](../mfc/reference/csocket-class.md)</ept>, MFC manages them for you.","pos":[1272,1375],"source":" If you use or derive from class [CSocket](../mfc/reference/csocket-class.md), MFC manages them for you."},{"content":"Blocking","pos":[1384,1392]},{"content":"A socket can be in \"blocking mode\" or \"nonblocking mode.\"","pos":[1396,1453]},{"content":"The functions of sockets in blocking (or synchronous) mode do not return until they can complete their action.","pos":[1454,1564]},{"content":"This is called blocking because the socket whose function was called cannot do anything — is blocked — until the call returns.","pos":[1565,1691]},{"content":"A call to the <bpt id=\"p1\">**</bpt>Receive<ept id=\"p1\">**</ept> member function, for example, might take an arbitrarily long time to complete as it waits for the sending application to send (this is if you are using <ph id=\"ph1\">`CSocket`</ph>, or using <ph id=\"ph2\">`CAsyncSocket`</ph> with blocking).","pos":[1692,1920],"source":" A call to the **Receive** member function, for example, might take an arbitrarily long time to complete as it waits for the sending application to send (this is if you are using `CSocket`, or using `CAsyncSocket` with blocking)."},{"content":"If a <ph id=\"ph1\">`CAsyncSocket`</ph> object is in nonblocking mode (operating asynchronously), the call returns immediately and the current error code, retrievable with the <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](../mfc/reference/casyncsocket-class.md#casyncsocket__getlasterror)</ept> member function, is <bpt id=\"p2\">**</bpt>WSAEWOULDBLOCK<ept id=\"p2\">**</ept>, indicating that the call would have blocked had it not returned immediately because of the mode.","pos":[1921,2295],"source":" If a `CAsyncSocket` object is in nonblocking mode (operating asynchronously), the call returns immediately and the current error code, retrievable with the [GetLastError](../mfc/reference/casyncsocket-class.md#casyncsocket__getlasterror) member function, is **WSAEWOULDBLOCK**, indicating that the call would have blocked had it not returned immediately because of the mode."},{"content":"(<ph id=\"ph1\">`CSocket`</ph> never returns <bpt id=\"p1\">**</bpt>WSAEWOULDBLOCK<ept id=\"p1\">**</ept>.","pos":[2296,2340],"source":" (`CSocket` never returns **WSAEWOULDBLOCK**."},{"content":"The class manages blocking for you.)","pos":[2341,2377]},{"content":"The behavior of sockets is different under 32-bit and 64-bit operating systems (such as Windows 95 or Windows 98) than under 16-bit operating systems (such as Windows 3.1).","pos":[2384,2556]},{"content":"Unlike 16-bit operating systems, the 32-bit and 64-bit operating systems use preemptive multitasking and provide multithreading.","pos":[2557,2685]},{"content":"Under the 32-bit and 64-bit operating systems, you can put your sockets in separate worker threads.","pos":[2686,2785]},{"content":"A socket in a thread can block without interfering with other activities in your application and without spending compute time on the blocking.","pos":[2786,2929]},{"content":"For information on multithreaded programming, see the article <bpt id=\"p1\">[</bpt>Multithreading<ept id=\"p1\">](../parallel/multithreading-support-for-older-code-visual-cpp.md)</ept>.","pos":[2930,3074],"source":" For information on multithreaded programming, see the article [Multithreading](../parallel/multithreading-support-for-older-code-visual-cpp.md)."},{"pos":[3082,3712],"content":"[!NOTE]\n In multithreaded applications, you can use the blocking nature of `CSocket` to simplify your program's design without affecting the responsiveness of the user interface. By handling user interactions in the main thread and `CSocket` processing in alternate threads, you can separate these logical operations. In an application that is not multithreaded, these two activities must be combined and handled as a single thread, which usually means using `CAsyncSocket` so you can handle communications requests on demand, or overriding `CSocket::OnMessagePending` to handle user actions during lengthy synchronous activity.","leadings":["","> "],"nodes":[{"content":" In multithreaded applications, you can use the blocking nature of `CSocket` to simplify your program's design without affecting the responsiveness of the user interface. By handling user interactions in the main thread and `CSocket` processing in alternate threads, you can separate these logical operations. In an application that is not multithreaded, these two activities must be combined and handled as a single thread, which usually means using `CAsyncSocket` so you can handle communications requests on demand, or overriding `CSocket::OnMessagePending` to handle user actions during lengthy synchronous activity.","pos":[8,628],"nodes":[{"content":"In multithreaded applications, you can use the blocking nature of <ph id=\"ph1\">`CSocket`</ph> to simplify your program's design without affecting the responsiveness of the user interface.","pos":[1,170],"source":" In multithreaded applications, you can use the blocking nature of `CSocket` to simplify your program's design without affecting the responsiveness of the user interface."},{"content":"By handling user interactions in the main thread and <ph id=\"ph1\">`CSocket`</ph> processing in alternate threads, you can separate these logical operations.","pos":[171,309],"source":" By handling user interactions in the main thread and `CSocket` processing in alternate threads, you can separate these logical operations."},{"content":"In an application that is not multithreaded, these two activities must be combined and handled as a single thread, which usually means using <ph id=\"ph1\">`CAsyncSocket`</ph> so you can handle communications requests on demand, or overriding <ph id=\"ph2\">`CSocket::OnMessagePending`</ph> to handle user actions during lengthy synchronous activity.","pos":[310,620],"source":" In an application that is not multithreaded, these two activities must be combined and handled as a single thread, which usually means using `CAsyncSocket` so you can handle communications requests on demand, or overriding `CSocket::OnMessagePending` to handle user actions during lengthy synchronous activity."}]}]},{"content":"The rest of this discussion is for programmers targeting 16-bit operating systems:","pos":[3719,3801]},{"content":"Normally, if you are using <ph id=\"ph1\">`CAsyncSocket`</ph>, you should avoid using blocking operations and operate asynchronously instead.","pos":[3808,3929],"source":"Normally, if you are using `CAsyncSocket`, you should avoid using blocking operations and operate asynchronously instead."},{"content":"In asynchronous operations, from the point at which you receive a <bpt id=\"p1\">**</bpt>WSAEWOULDBLOCK<ept id=\"p1\">**</ept> error code after calling <bpt id=\"p2\">**</bpt>Receive<ept id=\"p2\">**</ept>, for example, you wait until your <ph id=\"ph1\">`OnReceive`</ph> member function is called to notify you that you can read again.","pos":[3930,4162],"source":" In asynchronous operations, from the point at which you receive a **WSAEWOULDBLOCK** error code after calling **Receive**, for example, you wait until your `OnReceive` member function is called to notify you that you can read again."},{"content":"Asynchronous calls are made by calling back your socket's appropriate callback notification function, such as <bpt id=\"p1\">[</bpt>OnReceive<ept id=\"p1\">](../mfc/reference/casyncsocket-class.md#casyncsocket__onreceive)</ept>.","pos":[4163,4349],"source":" Asynchronous calls are made by calling back your socket's appropriate callback notification function, such as [OnReceive](../mfc/reference/casyncsocket-class.md#casyncsocket__onreceive)."},{"content":"Under Windows, blocking calls are considered bad practice.","pos":[4356,4414]},{"content":"By default, <bpt id=\"p1\">[</bpt>CAsyncSocket<ept id=\"p1\">](../mfc/reference/casyncsocket-class.md)</ept> supports asynchronous calls, and you must manage the blocking yourself using callback notifications.","pos":[4415,4582],"source":" By default, [CAsyncSocket](../mfc/reference/casyncsocket-class.md) supports asynchronous calls, and you must manage the blocking yourself using callback notifications."},{"content":"Class <bpt id=\"p1\">[</bpt>CSocket<ept id=\"p1\">](../mfc/reference/csocket-class.md)</ept>, on the other hand, is synchronous.","pos":[4583,4669],"source":" Class [CSocket](../mfc/reference/csocket-class.md), on the other hand, is synchronous."},{"content":"It pumps Windows messages and manages blocking for you.","pos":[4670,4725]},{"content":"For more information about blocking, see the Windows Sockets specification.","pos":[4732,4807]},{"content":"For more information about \"On\" functions, see <bpt id=\"p1\">[</bpt>Windows Sockets: Socket Notifications<ept id=\"p1\">](../mfc/windows-sockets-socket-notifications.md)</ept> and <bpt id=\"p2\">[</bpt>Windows Sockets: Deriving from Socket Classes<ept id=\"p2\">](../mfc/windows-sockets-deriving-from-socket-classes.md)</ept>.","pos":[4808,5051],"source":" For more information about \"On\" functions, see [Windows Sockets: Socket Notifications](../mfc/windows-sockets-socket-notifications.md) and [Windows Sockets: Deriving from Socket Classes](../mfc/windows-sockets-deriving-from-socket-classes.md)."},{"content":"For more information, see:","pos":[5058,5084]},{"content":"Windows Sockets: Using Class CAsyncSocket","pos":[5095,5136]},{"content":"Windows Sockets: Using Sockets with Archives","pos":[5200,5244]},{"content":"Windows Sockets: Background","pos":[5311,5338]},{"content":"Windows Sockets: Stream Sockets","pos":[5388,5419]},{"content":"Windows Sockets: Datagram Sockets","pos":[5473,5506]},{"content":"See Also","pos":[5560,5568]},{"content":"Windows Sockets in MFC","pos":[5573,5595]},{"content":"CAsyncSocket::OnSend","pos":[5636,5656]}],"content":"---\ntitle: \"Windows Sockets: Blocking | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"sockets [C++], blocking mode\"\n  - \"Windows Sockets [C++], Windows platforms\"\n  - \"Windows Sockets [C++], blocking mode\"\n  - \"sockets [C++], behavior on different Windows platforms\"\n  - \"blocking mode sockets\"\nms.assetid: 10aca9b1-bfba-41a8-9c55-ea8082181e63\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Windows Sockets: Blocking\nThis article and two companion articles explain several issues in Windows Sockets programming. This article covers blocking. The other issues are covered in the articles: [Windows Sockets: Byte Ordering](../mfc/windows-sockets-byte-ordering.md) and [Windows Sockets: Converting Strings](../mfc/windows-sockets-converting-strings.md).  \n  \n If you use or derive from class [CAsyncSocket](../mfc/reference/casyncsocket-class.md), you will need to manage these issues yourself. If you use or derive from class [CSocket](../mfc/reference/csocket-class.md), MFC manages them for you.  \n  \n## Blocking  \n A socket can be in \"blocking mode\" or \"nonblocking mode.\" The functions of sockets in blocking (or synchronous) mode do not return until they can complete their action. This is called blocking because the socket whose function was called cannot do anything — is blocked — until the call returns. A call to the **Receive** member function, for example, might take an arbitrarily long time to complete as it waits for the sending application to send (this is if you are using `CSocket`, or using `CAsyncSocket` with blocking). If a `CAsyncSocket` object is in nonblocking mode (operating asynchronously), the call returns immediately and the current error code, retrievable with the [GetLastError](../mfc/reference/casyncsocket-class.md#casyncsocket__getlasterror) member function, is **WSAEWOULDBLOCK**, indicating that the call would have blocked had it not returned immediately because of the mode. (`CSocket` never returns **WSAEWOULDBLOCK**. The class manages blocking for you.)  \n  \n The behavior of sockets is different under 32-bit and 64-bit operating systems (such as Windows 95 or Windows 98) than under 16-bit operating systems (such as Windows 3.1). Unlike 16-bit operating systems, the 32-bit and 64-bit operating systems use preemptive multitasking and provide multithreading. Under the 32-bit and 64-bit operating systems, you can put your sockets in separate worker threads. A socket in a thread can block without interfering with other activities in your application and without spending compute time on the blocking. For information on multithreaded programming, see the article [Multithreading](../parallel/multithreading-support-for-older-code-visual-cpp.md).  \n  \n> [!NOTE]\n>  In multithreaded applications, you can use the blocking nature of `CSocket` to simplify your program's design without affecting the responsiveness of the user interface. By handling user interactions in the main thread and `CSocket` processing in alternate threads, you can separate these logical operations. In an application that is not multithreaded, these two activities must be combined and handled as a single thread, which usually means using `CAsyncSocket` so you can handle communications requests on demand, or overriding `CSocket::OnMessagePending` to handle user actions during lengthy synchronous activity.  \n  \n The rest of this discussion is for programmers targeting 16-bit operating systems:  \n  \n Normally, if you are using `CAsyncSocket`, you should avoid using blocking operations and operate asynchronously instead. In asynchronous operations, from the point at which you receive a **WSAEWOULDBLOCK** error code after calling **Receive**, for example, you wait until your `OnReceive` member function is called to notify you that you can read again. Asynchronous calls are made by calling back your socket's appropriate callback notification function, such as [OnReceive](../mfc/reference/casyncsocket-class.md#casyncsocket__onreceive).  \n  \n Under Windows, blocking calls are considered bad practice. By default, [CAsyncSocket](../mfc/reference/casyncsocket-class.md) supports asynchronous calls, and you must manage the blocking yourself using callback notifications. Class [CSocket](../mfc/reference/csocket-class.md), on the other hand, is synchronous. It pumps Windows messages and manages blocking for you.  \n  \n For more information about blocking, see the Windows Sockets specification. For more information about \"On\" functions, see [Windows Sockets: Socket Notifications](../mfc/windows-sockets-socket-notifications.md) and [Windows Sockets: Deriving from Socket Classes](../mfc/windows-sockets-deriving-from-socket-classes.md).  \n  \n For more information, see:  \n  \n-   [Windows Sockets: Using Class CAsyncSocket](../mfc/windows-sockets-using-class-casyncsocket.md)  \n  \n-   [Windows Sockets: Using Sockets with Archives](../mfc/windows-sockets-using-sockets-with-archives.md)  \n  \n-   [Windows Sockets: Background](../mfc/windows-sockets-background.md)  \n  \n-   [Windows Sockets: Stream Sockets](../mfc/windows-sockets-stream-sockets.md)  \n  \n-   [Windows Sockets: Datagram Sockets](../mfc/windows-sockets-datagram-sockets.md)  \n  \n## See Also  \n [Windows Sockets in MFC](../mfc/windows-sockets-in-mfc.md)   \n [CAsyncSocket::OnSend](../mfc/reference/casyncsocket-class.md#casyncsocket__onsend)\n\n"}