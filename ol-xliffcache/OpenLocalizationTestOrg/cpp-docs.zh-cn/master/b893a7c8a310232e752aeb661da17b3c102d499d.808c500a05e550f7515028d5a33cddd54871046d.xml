{"nodes":[{"pos":[12,79],"content":"Relational Operators: &lt;, &gt;, &lt;=, and &gt;= | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Relational Operators: <ph id=\"ph1\">&amp;lt;</ph>, <ph id=\"ph2\">&amp;gt;</ph>, <ph id=\"ph3\">&amp;lt;</ph>=, and <ph id=\"ph4\">&amp;gt;</ph>= | Microsoft Docs","pos":[0,67],"source":"Relational Operators: &lt;, &gt;, &lt;=, and &gt;= | Microsoft Docs"}]},{"content":"Relational Operators: <ph id=\"ph1\">&amp;lt;</ph>, <ph id=\"ph2\">&amp;gt;</ph>, <ph id=\"ph3\">&amp;lt;</ph>=, and","pos":[859,903],"source":"Relational Operators: &lt;, &gt;, &lt;=, and "},{"content":"Syntax","pos":[913,919]},{"content":"Remarks","pos":[1049,1056]},{"content":"The binary relational operators determine the following relationships:","pos":[1060,1130]},{"pos":[1140,1158],"content":"Less than (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\&lt;</ph><ept id=\"p1\">**</ept>)","source":"Less than (**\\<**)"},{"pos":[1168,1188],"content":"Greater than (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">&gt;</ph><ept id=\"p1\">**</ept>)","source":"Greater than (**>**)"},{"pos":[1198,1229],"content":"Less than or equal to (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\&lt;=</ph><ept id=\"p1\">**</ept>)","source":"Less than or equal to (**\\<=**)"},{"pos":[1239,1272],"content":"Greater than or equal to (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">&gt;=</ph><ept id=\"p1\">**</ept>)","source":"Greater than or equal to (**>=**)"},{"content":"The relational operators have left-to-right associativity.","pos":[1279,1337]},{"content":"Both operands of relational operators must be of arithmetic or pointer type.","pos":[1338,1414]},{"content":"They yield values of type <ph id=\"ph1\">`bool`</ph>.","pos":[1415,1448],"source":" They yield values of type `bool`."},{"content":"The value returned is <bpt id=\"p1\">**</bpt>false<ept id=\"p1\">**</ept> (0) if the relationship in the expression is false; otherwise, the value returned is <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> (1).","pos":[1449,1579],"source":" The value returned is **false** (0) if the relationship in the expression is false; otherwise, the value returned is **true** (1)."},{"content":"Example","pos":[1588,1595]},{"content":"The expressions in the preceding example must be enclosed in parentheses because the stream insertion operator (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">&lt;&lt;</ph><ept id=\"p1\">**</ept>) has higher precedence than the relational operators.","pos":[1916,2088],"source":"The expressions in the preceding example must be enclosed in parentheses because the stream insertion operator (**<<**) has higher precedence than the relational operators."},{"content":"Therefore, the first expression without the parentheses would be evaluated as:","pos":[2089,2167]},{"pos":[2258,2394],"content":"The usual arithmetic conversions covered in <bpt id=\"p1\">[</bpt>Standard Conversions<ept id=\"p1\">](standard-conversions.md)</ept> are applied to operands of arithmetic types.","source":"The usual arithmetic conversions covered in [Standard Conversions](standard-conversions.md) are applied to operands of arithmetic types."},{"content":"Comparing pointers","pos":[2403,2421]},{"content":"When two pointers to objects of the same type are compared, the result is determined by the location of the objects pointed to in the program's address space.","pos":[2425,2583]},{"content":"Pointers can also be compared to a constant expression that evaluates to 0 or to a pointer of type void *.","pos":[2584,2690]},{"content":"If a pointer comparison is made against a pointer of type void <ph id=\"ph1\">\\*</ph>, the other pointer is implicitly converted to type void <ph id=\"ph2\">\\*</ph>.","pos":[2691,2816],"source":" If a pointer comparison is made against a pointer of type void \\*, the other pointer is implicitly converted to type void \\*."},{"content":"Then the comparison is made.","pos":[2817,2845]},{"content":"Two pointers of different types cannot be compared unless:","pos":[2852,2910]},{"content":"One type is a class type derived from the other type.","pos":[2920,2973]},{"content":"At least one of the pointers is explicitly converted (cast) to type void *.","pos":[2983,3058]},{"content":"(The other pointer is implicitly converted to type void <ph id=\"ph1\">\\*</ph> for the conversion.)","pos":[3059,3138],"source":" (The other pointer is implicitly converted to type void \\* for the conversion.)"},{"content":"Two pointers of the same type that point to the same object are guaranteed to compare equal.","pos":[3145,3237]},{"content":"If two pointers to nonstatic members of an object are compared, the following rules apply:","pos":[3238,3328]},{"pos":[3338,3587],"content":"If the class type is not a union, and if the two members are not separated by an <bpt id=\"p1\">*</bpt>access-specifier<ept id=\"p1\">*</ept>, such as public, protected, or private, the pointer to the member declared last will compare greater than the pointer to the member declared earlier.","source":"If the class type is not a union, and if the two members are not separated by an *access-specifier*, such as public, protected, or private, the pointer to the member declared last will compare greater than the pointer to the member declared earlier."},{"pos":[3597,3682],"content":"If the two members are separated by an <bpt id=\"p1\">*</bpt>access-specifier<ept id=\"p1\">*</ept>, the results are undefined.","source":"If the two members are separated by an *access-specifier*, the results are undefined."},{"content":"If the class type is a union, pointers to different data members in that union compare equal.","pos":[3692,3785]},{"content":"If two pointers point to elements of the same array or to the element one beyond the end of the array, the pointer to the object with the higher subscript compares higher.","pos":[3792,3963]},{"content":"Comparison of pointers is guaranteed valid only when the pointers refer to objects in the same array or to the location one past the end of the array.","pos":[3964,4114]},{"content":"See Also","pos":[4123,4131]},{"content":"Expressions with Binary Operators","pos":[4136,4169]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[4221,4273]},{"content":"C Relational and Equality Operators","pos":[4343,4378]}],"content":"---\ntitle: \"Relational Operators: &lt;, &gt;, &lt;=, and &gt;= | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"<\"\n  - \">\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"> operator\"\n  - \"less than operator\"\n  - \"relational operators, syntax\"\n  - \">= operator\"\n  - \"greater than or equal to operators\"\n  - \"greater than operators\"\n  - \"< operator\"\n  - \"less than or equal to operator\"\n  - \"<= operator\"\nms.assetid: d346b53d-f14d-4962-984f-89d39a17ca0f\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Relational Operators: &lt;, &gt;, &lt;=, and &gt;=\n## Syntax  \n  \n```  \nexpression < expression  \nexpression > expression  \nexpression <= expression  \nexpression >= expression  \n```  \n  \n## Remarks  \n The binary relational operators determine the following relationships:  \n  \n-   Less than (**\\<**)  \n  \n-   Greater than (**>**)  \n  \n-   Less than or equal to (**\\<=**)  \n  \n-   Greater than or equal to (**>=**)  \n  \n The relational operators have left-to-right associativity. Both operands of relational operators must be of arithmetic or pointer type. They yield values of type `bool`. The value returned is **false** (0) if the relationship in the expression is false; otherwise, the value returned is **true** (1).  \n  \n## Example  \n  \n```  \n// expre_Relational_Operators.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nusing namespace std;  \n  \nint main() {  \n   cout  << \"The true expression 3 > 2 yields: \"  \n         << (3 > 2) << endl  \n         << \"The false expression 20 < 10 yields: \"  \n         << (20 < 10) << endl;  \n}  \n```  \n  \n The expressions in the preceding example must be enclosed in parentheses because the stream insertion operator (**<<**) has higher precedence than the relational operators. Therefore, the first expression without the parentheses would be evaluated as:  \n  \n```  \n(cout << \"The true expression 3 > 2 yields: \" << 3) < (2 << \"\\n\");  \n```  \n  \n The usual arithmetic conversions covered in [Standard Conversions](standard-conversions.md) are applied to operands of arithmetic types.  \n  \n## Comparing pointers  \n When two pointers to objects of the same type are compared, the result is determined by the location of the objects pointed to in the program's address space. Pointers can also be compared to a constant expression that evaluates to 0 or to a pointer of type void *. If a pointer comparison is made against a pointer of type void \\*, the other pointer is implicitly converted to type void \\*. Then the comparison is made.  \n  \n Two pointers of different types cannot be compared unless:  \n  \n-   One type is a class type derived from the other type.  \n  \n-   At least one of the pointers is explicitly converted (cast) to type void *. (The other pointer is implicitly converted to type void \\* for the conversion.)  \n  \n Two pointers of the same type that point to the same object are guaranteed to compare equal. If two pointers to nonstatic members of an object are compared, the following rules apply:  \n  \n-   If the class type is not a union, and if the two members are not separated by an *access-specifier*, such as public, protected, or private, the pointer to the member declared last will compare greater than the pointer to the member declared earlier.  \n  \n-   If the two members are separated by an *access-specifier*, the results are undefined.  \n  \n-   If the class type is a union, pointers to different data members in that union compare equal.  \n  \n If two pointers point to elements of the same array or to the element one beyond the end of the array, the pointer to the object with the higher subscript compares higher. Comparison of pointers is guaranteed valid only when the pointers refer to objects in the same array or to the location one past the end of the array.  \n  \n## See Also  \n [Expressions with Binary Operators](../cpp/expressions-with-binary-operators.md)   \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   \n [C Relational and Equality Operators](../c-language/c-relational-and-equality-operators.md)"}