{"nodes":[{"pos":[12,46],"content":"Destructors (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Destructors (C++) | Microsoft Docs","pos":[0,34]}]},{"content":"Destructors (C++)","pos":[761,778]},{"content":"A destructor is a member function that is invoked automatically when the object goes out of scope or is explicitly destroyed by a call to <ph id=\"ph1\">`delete`</ph>.","pos":[779,926],"source":"A destructor is a member function that is invoked automatically when the object goes out of scope or is explicitly destroyed by a call to `delete`."},{"content":"A destructor has the same name as the class, preceded by a tilde (<ph id=\"ph1\">`~`</ph>).","pos":[927,998],"source":" A destructor has the same name as the class, preceded by a tilde (`~`)."},{"content":"For example, the destructor for class <ph id=\"ph1\">`String`</ph> is declared: <ph id=\"ph2\">`~String()`</ph>.","pos":[999,1071],"source":" For example, the destructor for class `String` is declared: `~String()`."},{"content":"If you do not define a destructor, the compiler will provide a default one; for many classes this is sufficient.","pos":[1072,1185],"source":" \nIf you do not define a destructor, the compiler will provide a default one; for many classes this is sufficient."},{"content":"You only need to define a custom destructor when the class stores handles to system resources that need to be released, or pointers that own the memory they point to.","pos":[1186,1352]},{"pos":[1354,1409],"content":"Consider the following declaration of a <ph id=\"ph1\">`String`</ph> class:","source":"Consider the following declaration of a `String` class:"},{"pos":[2249,2398],"content":"In the preceding example, the destructor <ph id=\"ph1\">`String::~String`</ph> uses the <ph id=\"ph2\">`delete`</ph> operator to deallocate the space dynamically allocated for text storage.","source":"In the preceding example, the destructor `String::~String` uses the `delete` operator to deallocate the space dynamically allocated for text storage."},{"content":"Delcaring destructors","pos":[2407,2428]},{"pos":[2432,2519],"content":"Destructors are functions with the same name as the class but preceded by a tilde (<ph id=\"ph1\">`~`</ph>)","source":"Destructors are functions with the same name as the class but preceded by a tilde (`~`)"},{"content":"Several rules govern the declaration of destructors.","pos":[2526,2578]},{"content":"Destructors:","pos":[2579,2591]},{"content":"Do not accept arguments.","pos":[2601,2625]},{"pos":[2635,2669],"content":"Do not return a value (or <ph id=\"ph1\">`void`</ph>).","source":"Do not return a value (or `void`)."},{"content":"Cannot be declared as <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`volatile`</ph>, or <bpt id=\"p2\">**</bpt>static<ept id=\"p2\">**</ept>.","pos":[2679,2738],"source":"Cannot be declared as **const**, `volatile`, or **static**."},{"content":"However, they can be invoked for the destruction of objects declared as <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`volatile`</ph>, or <bpt id=\"p2\">**</bpt>static<ept id=\"p2\">**</ept>.","pos":[2739,2848],"source":" However, they can be invoked for the destruction of objects declared as **const**, `volatile`, or **static**."},{"content":"Can be declared as <bpt id=\"p1\">**</bpt>virtual<ept id=\"p1\">**</ept>.","pos":[2858,2889],"source":"Can be declared as **virtual**."},{"content":"Using virtual destructors, you can destroy objects without knowing their type — the correct destructor for the object is invoked using the virtual function mechanism.","pos":[2890,3056]},{"content":"Note that destructors can also be declared as pure virtual functions for abstract classes.","pos":[3057,3147]},{"content":"Using destructors","pos":[3156,3173]},{"content":"Destructors are called when one of the following events occurs:","pos":[3177,3240]},{"content":"A local (automatic) object with block scope goes out of scope.","pos":[3248,3310]},{"pos":[3318,3408],"content":"An object allocated using the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator is explicitly deallocated using <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept>.","source":"An object allocated using the **new** operator is explicitly deallocated using **delete**."},{"content":"The lifetime of a temporary object ends.","pos":[3419,3459]},{"content":"A program ends and global or static objects exist.","pos":[3469,3519]},{"content":"The destructor is explicitly called using the destructor function's fully qualified name.","pos":[3529,3618]},{"content":"Destructors can freely call class member functions and access class member data.","pos":[3623,3703]},{"content":"There are two restrictions on the use of destructors:","pos":[3708,3761]},{"content":"you cannot take its address","pos":[3765,3792]},{"content":"derived classes do not inherit the destructor of their base class.","pos":[3796,3862]},{"content":"Order of destruction","pos":[3869,3889]},{"content":"When an object goes out of scope or is deleted, the sequence of events in its complete destruction is as follows:","pos":[3893,4006]},{"content":"The class's destructor is called, and the body of the destructor function is executed.","pos":[4016,4102]},{"content":"Destructors for nonstatic member objects are called in the reverse order in which they appear in the class declaration.","pos":[4112,4231]},{"content":"The optional member initialization list used in construction of these members does not affect the order of construction or destruction.","pos":[4232,4367]},{"content":"Destructors for nonvirtual base classes are called in the reverse order of declaration.","pos":[4378,4465]},{"content":"Destructors for virtual base classes are called in the reverse order of declaration.","pos":[4475,4559]},{"content":"Virtual base classes","pos":[5252,5272]},{"content":"Destructors for virtual base classes are called in the reverse order of their appearance in a directed acyclic graph (depth-first, left-to-right, postorder traversal).","pos":[5276,5443]},{"content":"the following figure depicts an inheritance graph.","pos":[5444,5494]},{"content":"Inheritance graph that shows virtual base classes","pos":[5503,5552]},{"content":"Inheritance Graph Showing Virtual Base Classes","pos":[5592,5638]},{"content":"The following lists the class heads for the classes shown in the figure.","pos":[5645,5717]},{"pos":[5902,6057],"content":"To determine the order of destruction of the virtual base classes of an object of type <ph id=\"ph1\">`E`</ph>, the compiler builds a list by applying the following algorithm:","source":"To determine the order of destruction of the virtual base classes of an object of type `E`, the compiler builds a list by applying the following algorithm:"},{"pos":[6067,6155],"content":"Traverse the graph left, starting at the deepest point in the graph (in this case, <ph id=\"ph1\">`E`</ph>).","source":"Traverse the graph left, starting at the deepest point in the graph (in this case, `E`)."},{"content":"Perform leftward traversals until all nodes have been visited.","pos":[6165,6227]},{"content":"Note the name of the current node.","pos":[6228,6262]},{"content":"Revisit the previous node (down and to the right) to find out whether the node being remembered is a virtual base class.","pos":[6272,6392]},{"content":"If the remembered node is a virtual base class, scan the list to see whether it has already been entered.","pos":[6402,6507]},{"content":"If it is not a virtual base class, ignore it.","pos":[6508,6553]},{"content":"If the remembered node is not yet in the list, add it to the bottom of the list.","pos":[6563,6643]},{"content":"Traverse the graph up and along the next path to the right.","pos":[6653,6712]},{"content":"Go to step 2.","pos":[6722,6735]},{"content":"When the last upward path is exhausted, note the name of the current node.","pos":[6745,6819]},{"content":"Go to step 3.","pos":[6828,6841]},{"content":"Continue this process until the bottom node is again the current node.","pos":[6851,6921]},{"pos":[6928,6982],"content":"Therefore, for class <ph id=\"ph1\">`E`</ph>, the order of destruction is:","source":"Therefore, for class `E`, the order of destruction is:"},{"pos":[6992,7022],"content":"The nonvirtual base class <ph id=\"ph1\">`E`</ph>.","source":"The nonvirtual base class `E`."},{"pos":[7032,7062],"content":"The nonvirtual base class <ph id=\"ph1\">`D`</ph>.","source":"The nonvirtual base class `D`."},{"pos":[7072,7102],"content":"The nonvirtual base class <ph id=\"ph1\">`C`</ph>.","source":"The nonvirtual base class `C`."},{"pos":[7112,7139],"content":"The virtual base class <ph id=\"ph1\">`B`</ph>.","source":"The virtual base class `B`."},{"pos":[7149,7176],"content":"The virtual base class <ph id=\"ph1\">`A`</ph>.","source":"The virtual base class `A`."},{"content":"This process produces an ordered list of unique entries.","pos":[7183,7239]},{"content":"No class name appears twice.","pos":[7240,7268]},{"content":"Once the list is constructed, it is walked in reverse order, and the destructor for each of the classes in the list from the last to the first is called.","pos":[7269,7422]},{"pos":[7429,7749],"content":"The order of construction or destruction is primarily important when constructors or destructors in one class rely on the other component being created first or persisting longer — for example, if the destructor for <ph id=\"ph1\">`A`</ph> (in the figure shown above) relied on <ph id=\"ph2\">`B`</ph> still being present when its code executed, or vice versa.","source":"The order of construction or destruction is primarily important when constructors or destructors in one class rely on the other component being created first or persisting longer — for example, if the destructor for `A` (in the figure shown above) relied on `B` still being present when its code executed, or vice versa."},{"content":"Such interdependencies between classes in an inheritance graph are inherently dangerous because classes derived later can alter which is the leftmost path, thereby changing the order of construction and destruction.","pos":[7756,7971]},{"content":"Nonvirtual base classes","pos":[7981,8004]},{"content":"The destructors for nonvirtual base classes are called in the reverse order in which the base class names are declared.","pos":[8008,8127]},{"content":"Consider the following class declaration:","pos":[8128,8169]},{"pos":[8246,8343],"content":"In the preceding example, the destructor for <ph id=\"ph1\">`Base2`</ph> is called before the destructor for <ph id=\"ph2\">`Base1`</ph>.","source":"In the preceding example, the destructor for `Base2` is called before the destructor for `Base1`."},{"content":"Explicit destructor calls","pos":[8352,8377]},{"content":"Calling a destructor explicitly is seldom necessary.","pos":[8381,8433]},{"content":"However, it can be useful to perform cleanup of objects placed at absolute addresses.","pos":[8434,8519]},{"content":"These objects are commonly allocated using a user-defined <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator that takes a placement argument.","pos":[8520,8627],"source":" These objects are commonly allocated using a user-defined **new** operator that takes a placement argument."},{"content":"The <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> operator cannot deallocate this memory because it is not allocated from the free store (for more information, see <bpt id=\"p2\">[</bpt>The new and delete Operators<ept id=\"p2\">](../cpp/new-and-delete-operators.md)</ept>).","pos":[8628,8825],"source":" The **delete** operator cannot deallocate this memory because it is not allocated from the free store (for more information, see [The new and delete Operators](../cpp/new-and-delete-operators.md))."},{"content":"A call to the destructor, however, can perform appropriate cleanup.","pos":[8826,8893]},{"content":"To explicitly call the destructor for an object, <ph id=\"ph1\">`s`</ph>, of class <ph id=\"ph2\">`String`</ph>, use one of the following statements:","pos":[8894,9003],"source":" To explicitly call the destructor for an object, `s`, of class `String`, use one of the following statements:"},{"content":"The notation for explicit calls to destructors, shown in the preceding, can be used regardless of whether the type defines a destructor.","pos":[9194,9330]},{"content":"This allows you to make such explicit calls without knowing if a destructor is defined for the type.","pos":[9331,9431]},{"content":"An explicit call to a destructor where none is defined has no effect.","pos":[9432,9501]}],"content":"---\ntitle: \"Destructors (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"objects [C++], destroying\"\n  - \"Visual C++, destructors\"\n  - \"destroying objects, destructors\"\n  - \"~ operator, specifying destructors\"\n  - \"destructors, about destructors\"\n  - \"destructors, C++\"\nms.assetid: afa859b0-f3bc-4c4d-b250-c68b335b6004\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Destructors (C++)\nA destructor is a member function that is invoked automatically when the object goes out of scope or is explicitly destroyed by a call to `delete`. A destructor has the same name as the class, preceded by a tilde (`~`). For example, the destructor for class `String` is declared: `~String()`. \nIf you do not define a destructor, the compiler will provide a default one; for many classes this is sufficient. You only need to define a custom destructor when the class stores handles to system resources that need to be released, or pointers that own the memory they point to.\n\nConsider the following declaration of a `String` class:  \n  \n```  \n// spec1_destructors.cpp  \n#include <string.h>  \n  \nclass String {  \npublic:  \n   String( char *ch );  // Declare constructor  \n   ~String();           //  and destructor.  \nprivate:  \n   char    *_text;  \n   size_t  sizeOfText;  \n};  \n  \n// Define the constructor.  \nString::String( char *ch ) {  \n   sizeOfText = strlen( ch ) + 1;  \n  \n   // Dynamically allocate the correct amount of memory.  \n   _text = new char[ sizeOfText ];  \n  \n   // If the allocation succeeds, copy the initialization string.  \n   if( _text )  \n      strcpy_s( _text, sizeOfText, ch );  \n}  \n  \n// Define the destructor.  \nString::~String() {  \n   // Deallocate the memory that was previously reserved  \n   //  for this string.  \n   if (_text)  \n      delete[] _text;  \n}  \n  \nint main() {  \n   String str(\"The piper in the glen...\");  \n}  \n```  \n  \n In the preceding example, the destructor `String::~String` uses the `delete` operator to deallocate the space dynamically allocated for text storage.  \n  \n## Delcaring destructors  \n Destructors are functions with the same name as the class but preceded by a tilde (`~`)  \n  \n Several rules govern the declaration of destructors. Destructors:  \n  \n-   Do not accept arguments.  \n  \n-   Do not return a value (or `void`).  \n  \n-   Cannot be declared as **const**, `volatile`, or **static**. However, they can be invoked for the destruction of objects declared as **const**, `volatile`, or **static**.  \n  \n-   Can be declared as **virtual**. Using virtual destructors, you can destroy objects without knowing their type — the correct destructor for the object is invoked using the virtual function mechanism. Note that destructors can also be declared as pure virtual functions for abstract classes.  \n  \n## Using destructors  \n Destructors are called when one of the following events occurs:  \n\n-   A local (automatic) object with block scope goes out of scope.  \n\n-   An object allocated using the **new** operator is explicitly deallocated using **delete**.   \n  \n-   The lifetime of a temporary object ends.  \n  \n-   A program ends and global or static objects exist.  \n  \n-   The destructor is explicitly called using the destructor function's fully qualified name.\n  \n Destructors can freely call class member functions and access class member data.\n  \n There are two restrictions on the use of destructors:\n - you cannot take its address\n-  derived classes do not inherit the destructor of their base class.\n  \n## Order of destruction  \n When an object goes out of scope or is deleted, the sequence of events in its complete destruction is as follows:  \n  \n1.  The class's destructor is called, and the body of the destructor function is executed.  \n  \n2.  Destructors for nonstatic member objects are called in the reverse order in which they appear in the class declaration. The optional member initialization list used in construction of these members does not affect the order of construction or destruction.   \n  \n3.  Destructors for nonvirtual base classes are called in the reverse order of declaration.  \n  \n4.  Destructors for virtual base classes are called in the reverse order of declaration.  \n  \n```  \n// order_of_destruction.cpp  \n#include <stdio.h>  \n  \nstruct A1      { virtual ~A1() { printf(\"A1 dtor\\n\"); } };  \nstruct A2 : A1 { virtual ~A2() { printf(\"A2 dtor\\n\"); } };  \nstruct A3 : A2 { virtual ~A3() { printf(\"A3 dtor\\n\"); } };  \n  \nstruct B1      { ~B1() { printf(\"B1 dtor\\n\"); } };  \nstruct B2 : B1 { ~B2() { printf(\"B2 dtor\\n\"); } };  \nstruct B3 : B2 { ~B3() { printf(\"B3 dtor\\n\"); } };  \n  \nint main() {  \n   A1 * a = new A3;  \n   delete a;  \n   printf(\"\\n\");  \n  \n   B1 * b = new B3;  \n   delete b;  \n   printf(\"\\n\");  \n  \n   B3 * b2 = new B3;  \n   delete b2;  \n}  \n  \nOutput: A3 dtor  \nA2 dtor  \nA1 dtor  \n  \nB1 dtor  \n  \nB3 dtor  \nB2 dtor  \nB1 dtor  \n  \n```  \n  \n### Virtual base classes  \n Destructors for virtual base classes are called in the reverse order of their appearance in a directed acyclic graph (depth-first, left-to-right, postorder traversal). the following figure depicts an inheritance graph.  \n  \n ![Inheritance graph that shows virtual base classes](../cpp/media/vc392j1.gif \"vc392J1\")  \nInheritance Graph Showing Virtual Base Classes  \n  \n The following lists the class heads for the classes shown in the figure.  \n  \n```  \nclass A  \nclass B  \nclass C : virtual public A, virtual public B  \nclass D : virtual public A, virtual public B  \nclass E : public C, public D, virtual public B  \n```  \n  \n To determine the order of destruction of the virtual base classes of an object of type `E`, the compiler builds a list by applying the following algorithm:  \n  \n1.  Traverse the graph left, starting at the deepest point in the graph (in this case, `E`).  \n  \n2.  Perform leftward traversals until all nodes have been visited. Note the name of the current node.  \n  \n3.  Revisit the previous node (down and to the right) to find out whether the node being remembered is a virtual base class.  \n  \n4.  If the remembered node is a virtual base class, scan the list to see whether it has already been entered. If it is not a virtual base class, ignore it.  \n  \n5.  If the remembered node is not yet in the list, add it to the bottom of the list.  \n  \n6.  Traverse the graph up and along the next path to the right.  \n  \n7.  Go to step 2.  \n  \n8.  When the last upward path is exhausted, note the name of the current node.  \n  \n9. Go to step 3.  \n  \n10. Continue this process until the bottom node is again the current node.  \n  \n Therefore, for class `E`, the order of destruction is:  \n  \n1.  The nonvirtual base class `E`.  \n  \n2.  The nonvirtual base class `D`.  \n  \n3.  The nonvirtual base class `C`.  \n  \n4.  The virtual base class `B`.  \n  \n5.  The virtual base class `A`.  \n  \n This process produces an ordered list of unique entries. No class name appears twice. Once the list is constructed, it is walked in reverse order, and the destructor for each of the classes in the list from the last to the first is called.  \n  \n The order of construction or destruction is primarily important when constructors or destructors in one class rely on the other component being created first or persisting longer — for example, if the destructor for `A` (in the figure shown above) relied on `B` still being present when its code executed, or vice versa.  \n  \n Such interdependencies between classes in an inheritance graph are inherently dangerous because classes derived later can alter which is the leftmost path, thereby changing the order of construction and destruction.  \n  \n### Nonvirtual base classes  \n The destructors for nonvirtual base classes are called in the reverse order in which the base class names are declared. Consider the following class declaration:  \n  \n```  \nclass MultInherit : public Base1, public Base2  \n...  \n```  \n  \n In the preceding example, the destructor for `Base2` is called before the destructor for `Base1`.  \n  \n## Explicit destructor calls  \n Calling a destructor explicitly is seldom necessary. However, it can be useful to perform cleanup of objects placed at absolute addresses. These objects are commonly allocated using a user-defined **new** operator that takes a placement argument. The **delete** operator cannot deallocate this memory because it is not allocated from the free store (for more information, see [The new and delete Operators](../cpp/new-and-delete-operators.md)). A call to the destructor, however, can perform appropriate cleanup. To explicitly call the destructor for an object, `s`, of class `String`, use one of the following statements:  \n  \n```  \ns.String::~String();     // Nonvirtual call  \nps->String::~String();   // Nonvirtual call  \n  \ns.~String();       // Virtual call  \nps->~String();     // Virtual call  \n```  \n  \n The notation for explicit calls to destructors, shown in the preceding, can be used regardless of whether the type defines a destructor. This allows you to make such explicit calls without knowing if a destructor is defined for the type. An explicit call to a destructor where none is defined has no effect.  \n"}