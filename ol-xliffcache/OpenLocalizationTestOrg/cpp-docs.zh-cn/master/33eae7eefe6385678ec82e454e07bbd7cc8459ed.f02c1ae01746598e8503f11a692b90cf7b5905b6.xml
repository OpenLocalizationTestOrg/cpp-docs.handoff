{"nodes":[{"pos":[12,72],"content":"Exporting and Importing Using AFX_EXT_CLASS | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Exporting and Importing Using AFX_EXT_CLASS | Microsoft Docs","pos":[0,60]}]},{"content":"Exporting and Importing Using AFX_EXT_CLASS","pos":[833,876]},{"content":"<bpt id=\"p1\">[</bpt>Extension DLLs<ept id=\"p1\">](../build/extension-dlls-overview.md)</ept> use the macro <bpt id=\"p2\">**</bpt>AFX_EXT_CLASS<ept id=\"p2\">**</ept> to export classes; the executables that link to the extension DLL use the macro to import classes.","pos":[877,1061],"source":"[Extension DLLs](../build/extension-dlls-overview.md) use the macro **AFX_EXT_CLASS** to export classes; the executables that link to the extension DLL use the macro to import classes."},{"content":"With the <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> macro, the same header files that are used to build the extension DLL can be used with the executables that link to the DLL.","pos":[1062,1213],"source":" With the **AFX_EXT_CLASS** macro, the same header files that are used to build the extension DLL can be used with the executables that link to the DLL."},{"pos":[1220,1331],"content":"In the header file for your DLL, add the <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> keyword to the declaration of your class as follows:","source":"In the header file for your DLL, add the **AFX_EXT_CLASS** keyword to the declaration of your class as follows:"},{"content":"This macro is defined by MFC as <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> when the preprocessor symbols <bpt id=\"p2\">**</bpt>_AFXDLL<ept id=\"p2\">**</ept> and <ph id=\"ph1\">`_AFXEXT`</ph> are defined.","pos":[1433,1559],"source":"This macro is defined by MFC as **__declspec(dllexport)** when the preprocessor symbols **_AFXDLL** and `_AFXEXT` are defined."},{"content":"But the macro is defined as <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> when <bpt id=\"p2\">**</bpt>_AFXDLL<ept id=\"p2\">**</ept> is defined and <ph id=\"ph1\">`_AFXEXT`</ph> is not defined.","pos":[1560,1671],"source":" But the macro is defined as **__declspec(dllimport)** when **_AFXDLL** is defined and `_AFXEXT` is not defined."},{"content":"When defined, the preprocessor symbol <bpt id=\"p1\">**</bpt>_AFXDLL<ept id=\"p1\">**</ept> indicates that the shared version of MFC is being used by the target executable (either a DLL or an application).","pos":[1672,1835],"source":" When defined, the preprocessor symbol **_AFXDLL** indicates that the shared version of MFC is being used by the target executable (either a DLL or an application)."},{"content":"When both <bpt id=\"p1\">**</bpt>_AFXDLL<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`_AFXEXT`</ph> are defined, this indicates that the target executable is an extension DLL.","pos":[1836,1947],"source":" When both **_AFXDLL** and `_AFXEXT` are defined, this indicates that the target executable is an extension DLL."},{"content":"Because <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> is defined as <bpt id=\"p2\">**</bpt>__declspec(dllexport)<ept id=\"p2\">**</ept> when exporting from an extension DLL, you can export entire classes without placing the decorated names for all of that class's symbols in the .def file.","pos":[1954,2173],"source":"Because **AFX_EXT_CLASS** is defined as **__declspec(dllexport)** when exporting from an extension DLL, you can export entire classes without placing the decorated names for all of that class's symbols in the .def file."},{"content":"This method is used by the MFC sample <bpt id=\"p1\">[</bpt>DLLHUSK<ept id=\"p1\">](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90)</ept>.","pos":[2174,2292],"source":" This method is used by the MFC sample [DLLHUSK](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90)."},{"content":"Although you can avoid creating a .def file and all of the decorated names for the class with this method, creating a .def file is more efficient because the names can be exported by ordinal.","pos":[2299,2490]},{"content":"To use the .def file method of exporting, place the following code at the beginning and end of your header file:","pos":[2491,2603]},{"pos":[2745,3129],"content":"[!CAUTION]\n Be careful when exporting inline functions, because they can create the possibility of version conflicts. An inline function gets expanded into the application code; therefore, if you later rewrite the function, it does not get updated unless the application itself is recompiled. Normally, DLL functions can be updated without rebuilding the applications that use them.","leadings":["","> "],"nodes":[{"content":" Be careful when exporting inline functions, because they can create the possibility of version conflicts. An inline function gets expanded into the application code; therefore, if you later rewrite the function, it does not get updated unless the application itself is recompiled. Normally, DLL functions can be updated without rebuilding the applications that use them.","pos":[11,382],"nodes":[{"content":"Be careful when exporting inline functions, because they can create the possibility of version conflicts.","pos":[1,106]},{"content":"An inline function gets expanded into the application code; therefore, if you later rewrite the function, it does not get updated unless the application itself is recompiled.","pos":[107,281]},{"content":"Normally, DLL functions can be updated without rebuilding the applications that use them.","pos":[282,371]}]}]},{"content":"Exporting Individual Members in a Class","pos":[3138,3177]},{"content":"Sometimes you might want to export individual members of your class.","pos":[3181,3249]},{"content":"For example, if you are exporting a <ph id=\"ph1\">`CDialog`</ph>-derived class, you might only need to export the constructor and the <ph id=\"ph2\">`DoModal`</ph> call.","pos":[3250,3380],"source":" For example, if you are exporting a `CDialog`-derived class, you might only need to export the constructor and the `DoModal` call."},{"content":"You can use <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> on the individual members you need to export.","pos":[3381,3456],"source":" You can use **AFX_EXT_CLASS** on the individual members you need to export."},{"content":"For example:","pos":[3463,3475]},{"content":"Because you are no longer exporting all members of the class, you may run into an additional problem because of the way that MFC macros work.","pos":[3678,3819]},{"content":"Several of MFC's helper macros actually declare or define data members.","pos":[3820,3891]},{"content":"Therefore, these data members must also be exported from your DLL.","pos":[3892,3958]},{"pos":[3965,4059],"content":"For example, the <ph id=\"ph1\">`DECLARE_DYNAMIC`</ph> macro is defined as follows when building an extension DLL:","source":"For example, the `DECLARE_DYNAMIC` macro is defined as follows when building an extension DLL:"},{"content":"The line that begins with static <ph id=\"ph1\">`AFX_DATA`</ph> is declaring a static object inside of your class.","pos":[4312,4406],"source":"The line that begins with static `AFX_DATA` is declaring a static object inside of your class."},{"content":"To export this class correctly and access the run-time information from a client executable, you must export this static object.","pos":[4407,4535]},{"content":"Because the static object is declared with the modifier <ph id=\"ph1\">`AFX_DATA`</ph>, you only need to define <ph id=\"ph2\">`AFX_DATA`</ph> to be <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> when building your DLL and define it as <bpt id=\"p2\">**</bpt>__declspec(dllimport)<ept id=\"p2\">**</ept> when building your client executable.","pos":[4536,4774],"source":" Because the static object is declared with the modifier `AFX_DATA`, you only need to define `AFX_DATA` to be **__declspec(dllexport)** when building your DLL and define it as **__declspec(dllimport)** when building your client executable."},{"content":"Because <bpt id=\"p1\">**</bpt>AFX_EXT_CLASS<ept id=\"p1\">**</ept> is already defined in this way, you just need to redefine <ph id=\"ph1\">`AFX_DATA`</ph> to be the same as <bpt id=\"p2\">**</bpt>AFX_EXT_CLASS<ept id=\"p2\">**</ept> around your class definition.","pos":[4775,4935],"source":" Because **AFX_EXT_CLASS** is already defined in this way, you just need to redefine `AFX_DATA` to be the same as **AFX_EXT_CLASS** around your class definition."},{"content":"For example:","pos":[4942,4954]},{"content":"Because MFC always uses the <ph id=\"ph1\">`AFX_DATA`</ph> symbol on data items it defines within its macros, this technique works for all such scenarios.","pos":[5173,5307],"source":"Because MFC always uses the `AFX_DATA` symbol on data items it defines within its macros, this technique works for all such scenarios."},{"content":"For example, it works for <ph id=\"ph1\">`DECLARE_MESSAGE_MAP`</ph>.","pos":[5308,5356],"source":" For example, it works for `DECLARE_MESSAGE_MAP`."},{"pos":[5364,5503],"content":"[!NOTE]\n If you are exporting the entire class rather than selected members of the class, static data members are automatically exported.","leadings":["","> "],"nodes":[{"content":"If you are exporting the entire class rather than selected members of the class, static data members are automatically exported.","pos":[9,137]}]},{"content":"What do you want to do?","pos":[5513,5536]},{"content":"Export from a DLL using .def files","pos":[5547,5581]},{"content":"Export from a DLL using __declspec(dllexport)","pos":[5643,5688]},{"content":"Export C++ functions for use in C-language executables","pos":[5759,5813]},{"content":"Export C functions for use in C or C++-language executables","pos":[5896,5955]},{"content":"Determine which exporting method to use","pos":[6043,6082]},{"content":"Import into an application using __declspec(dllimport)","pos":[6149,6203]},{"content":"Initialize a DLL","pos":[6283,6299]},{"content":"What do you want to know more about?","pos":[6342,6378]},{"content":"Decorated names","pos":[6389,6404]},{"content":"Importing and exporting inline functions","pos":[6455,6495]},{"content":"Mutual imports","pos":[6561,6575]},{"content":"See Also","pos":[6613,6621]},{"content":"Exporting from a DLL","pos":[6626,6646]}],"content":"---\ntitle: \"Exporting and Importing Using AFX_EXT_CLASS | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"afx_ext_class\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"AFX_EXT_CLASS macro\"\n  - \"exporting classes [C++]\"\n  - \"importing DLLs [C++]\"\n  - \"extension DLLs [C++], exporting classes\"\n  - \"executable files [C++], importing classes\"\n  - \"exporting DLLs [C++], AFX_EXT_CLASS macro\"\nms.assetid: 6b72cb2b-e92e-4ecd-bcab-c335e1d1cfde\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Exporting and Importing Using AFX_EXT_CLASS\n[Extension DLLs](../build/extension-dlls-overview.md) use the macro **AFX_EXT_CLASS** to export classes; the executables that link to the extension DLL use the macro to import classes. With the **AFX_EXT_CLASS** macro, the same header files that are used to build the extension DLL can be used with the executables that link to the DLL.  \n  \n In the header file for your DLL, add the **AFX_EXT_CLASS** keyword to the declaration of your class as follows:  \n  \n```  \nclass AFX_EXT_CLASS CMyClass : public CDocument  \n{  \n// <body of class>  \n};  \n```  \n  \n This macro is defined by MFC as **__declspec(dllexport)** when the preprocessor symbols **_AFXDLL** and `_AFXEXT` are defined. But the macro is defined as **__declspec(dllimport)** when **_AFXDLL** is defined and `_AFXEXT` is not defined. When defined, the preprocessor symbol **_AFXDLL** indicates that the shared version of MFC is being used by the target executable (either a DLL or an application). When both **_AFXDLL** and `_AFXEXT` are defined, this indicates that the target executable is an extension DLL.  \n  \n Because **AFX_EXT_CLASS** is defined as **__declspec(dllexport)** when exporting from an extension DLL, you can export entire classes without placing the decorated names for all of that class's symbols in the .def file. This method is used by the MFC sample [DLLHUSK](http://msdn.microsoft.com/en-us/dfcaa6ff-b8e2-4efd-8100-ee3650071f90).  \n  \n Although you can avoid creating a .def file and all of the decorated names for the class with this method, creating a .def file is more efficient because the names can be exported by ordinal. To use the .def file method of exporting, place the following code at the beginning and end of your header file:  \n  \n```  \n#undef AFX_DATA  \n#define AFX_DATA AFX_EXT_DATA  \n// <body of your header file>  \n#undef AFX_DATA  \n#define AFX_DATA  \n```  \n  \n> [!CAUTION]\n>  Be careful when exporting inline functions, because they can create the possibility of version conflicts. An inline function gets expanded into the application code; therefore, if you later rewrite the function, it does not get updated unless the application itself is recompiled. Normally, DLL functions can be updated without rebuilding the applications that use them.  \n  \n## Exporting Individual Members in a Class  \n Sometimes you might want to export individual members of your class. For example, if you are exporting a `CDialog`-derived class, you might only need to export the constructor and the `DoModal` call. You can use **AFX_EXT_CLASS** on the individual members you need to export.  \n  \n For example:  \n  \n```  \nclass CExampleDialog : public CDialog  \n{  \npublic:  \n   AFX_EXT_CLASS CExampleDialog();  \n   AFX_EXT_CLASS int DoModal();  \n   ...  \n   // rest of class definition  \n   ...  \n};  \n```  \n  \n Because you are no longer exporting all members of the class, you may run into an additional problem because of the way that MFC macros work. Several of MFC's helper macros actually declare or define data members. Therefore, these data members must also be exported from your DLL.  \n  \n For example, the `DECLARE_DYNAMIC` macro is defined as follows when building an extension DLL:  \n  \n```  \n#define DECLARE_DYNAMIC(class_name) \\  \nprotected: \\  \n   static CRuntimeClass* PASCAL _GetBaseClass(); \\  \npublic: \\  \n   static AFX_DATA CRuntimeClass class##class_name; \\  \n   virtual CRuntimeClass* GetRuntimeClass() const; \\  \n```  \n  \n The line that begins with static `AFX_DATA` is declaring a static object inside of your class. To export this class correctly and access the run-time information from a client executable, you must export this static object. Because the static object is declared with the modifier `AFX_DATA`, you only need to define `AFX_DATA` to be **__declspec(dllexport)** when building your DLL and define it as **__declspec(dllimport)** when building your client executable. Because **AFX_EXT_CLASS** is already defined in this way, you just need to redefine `AFX_DATA` to be the same as **AFX_EXT_CLASS** around your class definition.  \n  \n For example:  \n  \n```  \n#undef  AFX_DATA  \n#define AFX_DATA AFX_EXT_CLASS  \n  \nclass CExampleView : public CView  \n{  \n   DECLARE_DYNAMIC()  \n   // ... class definition ...  \n};  \n  \n#undef  AFX_DATA  \n#define AFX_DATA  \n```  \n  \n Because MFC always uses the `AFX_DATA` symbol on data items it defines within its macros, this technique works for all such scenarios. For example, it works for `DECLARE_MESSAGE_MAP`.  \n  \n> [!NOTE]\n>  If you are exporting the entire class rather than selected members of the class, static data members are automatically exported.  \n  \n### What do you want to do?  \n  \n-   [Export from a DLL using .def files](../build/exporting-from-a-dll-using-def-files.md)  \n  \n-   [Export from a DLL using __declspec(dllexport)](../build/exporting-from-a-dll-using-declspec-dllexport.md)  \n  \n-   [Export C++ functions for use in C-language executables](../build/exporting-cpp-functions-for-use-in-c-language-executables.md)  \n  \n-   [Export C functions for use in C or C++-language executables](../build/exporting-c-functions-for-use-in-c-or-cpp-language-executables.md)  \n  \n-   [Determine which exporting method to use](../build/determining-which-exporting-method-to-use.md)  \n  \n-   [Import into an application using __declspec(dllimport)](../build/importing-into-an-application-using-declspec-dllimport.md)  \n  \n-   [Initialize a DLL](../build/initializing-a-dll.md)  \n  \n### What do you want to know more about?  \n  \n-   [Decorated names](../build/reference/decorated-names.md)  \n  \n-   [Importing and exporting inline functions](../build/importing-and-exporting-inline-functions.md)  \n  \n-   [Mutual imports](../build/mutual-imports.md)  \n  \n## See Also  \n [Exporting from a DLL](../build/exporting-from-a-dll.md)"}