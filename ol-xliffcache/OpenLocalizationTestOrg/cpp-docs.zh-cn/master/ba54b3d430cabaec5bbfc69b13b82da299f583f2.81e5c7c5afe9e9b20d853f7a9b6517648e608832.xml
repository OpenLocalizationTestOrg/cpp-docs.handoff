{"nodes":[{"pos":[12,59],"content":"Implicit Boxing of Value Types | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Implicit Boxing of Value Types | Microsoft Docs","pos":[0,47]}]},{"content":"Implicit Boxing of Value Types","pos":[672,702]},{"pos":[703,848],"content":"The boxing of value types has changed from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"The boxing of value types has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"In language design, we imposed a philosophical position in lieu of practical experience with the feature and, in practice, it was a mistake.","pos":[855,995]},{"content":"As an analogy, in the original multiple inheritance language design, Stroustrup decided that a virtual base class sub-object could not be initialized within a derived class constructor, and therefore the language required that any class serving as a virtual base class must define a default constructor.","pos":[996,1299]},{"content":"It is that default constructor that would be invoked by any subsequent virtual derivation.","pos":[1300,1390]},{"content":"The problem of a virtual base class hierarchy is that responsibility for the initialization of the shared virtual sub-object shifts with each subsequent derivation.","pos":[1397,1561]},{"content":"For example, if I define a base class for which initialization requires the allocation of a buffer, the user-specified size of that buffer might be passed as an argument to the constructor.","pos":[1562,1751]},{"content":"If I then provide two subsequent virtual derivations, call them <ph id=\"ph1\">`inputb`</ph> and <ph id=\"ph2\">`outputb`</ph>, each provides a particular value to the base class constructor.","pos":[1752,1903],"source":" If I then provide two subsequent virtual derivations, call them `inputb` and `outputb`, each provides a particular value to the base class constructor."},{"content":"Now, when I derived an <ph id=\"ph1\">`in_out`</ph> class from both <ph id=\"ph2\">`inputb`</ph> and <ph id=\"ph3\">`outputb`</ph>, neither of those values to the shared virtual base class sub-object can sensibly be allowed to evaluate.","pos":[1904,2080],"source":" Now, when I derived an `in_out` class from both `inputb` and `outputb`, neither of those values to the shared virtual base class sub-object can sensibly be allowed to evaluate."},{"content":"Therefore, in the original language design, Stroustrup disallowed the explicit initialization of a virtual base class within the member initialization list of the derived class constructor.","pos":[2087,2276]},{"content":"While this solved the problem, in practice the inability to direct the initialization of the virtual base class proved impracticable.","pos":[2277,2410]},{"content":"Keith Gorlen of the National Institute of Health, who had implemented a freeware version of the SmallTalk collection library called nihcl, was a principle voice in convincing Stroustrup that he had to come up with a more flexible language design.","pos":[2411,2657]},{"content":"A principle of Object-Oriented hierarchical design holds that a derived class should concern itself only with the non-private implementation of its immediate base classes.","pos":[2664,2835]},{"content":"In order to support a flexible initialization design for virtual inheritance, Stroustrup had to violate this principle.","pos":[2836,2955]},{"content":"The most derived class in a hierarchy assumes responsibility for all virtual sub-object initialization regardless of how deep into the hierarchy it occurs.","pos":[2956,3111]},{"content":"For example, <ph id=\"ph1\">`inputb`</ph> and <ph id=\"ph2\">`outputb`</ph> are both responsible for explicitly initializing their immediate virtual base class.","pos":[3112,3232],"source":" For example, `inputb` and `outputb` are both responsible for explicitly initializing their immediate virtual base class."},{"content":"When <ph id=\"ph1\">`in_out`</ph> derives from both <ph id=\"ph2\">`inputb`</ph> and <ph id=\"ph3\">`outputb`</ph>, <ph id=\"ph4\">`in_out`</ph> becomes responsible for the initialization of the once removed virtual base class, and the initialization made explicit within <ph id=\"ph5\">`inputb`</ph> and <ph id=\"ph6\">`outputb`</ph> is suppressed.","pos":[3233,3462],"source":" When `in_out` derives from both `inputb` and `outputb`, `in_out` becomes responsible for the initialization of the once removed virtual base class, and the initialization made explicit within `inputb` and `outputb` is suppressed."},{"content":"This provides the flexibility required by language developers, but at the cost of a complicated semantics.","pos":[3469,3575]},{"content":"This burden of complication is stripped away if we restrict a virtual base class to be without state and simply allow it to specify an interface.","pos":[3576,3721]},{"content":"This is a recommended design idiom within C++.","pos":[3722,3768]},{"content":"Within CLR programming, it is raised to policy with the Interface type.","pos":[3769,3840]},{"content":"Here is a simple code sample– and in this case, the explicit boxing is unnecessary:","pos":[3847,3930]},{"content":"As you can see, there is a whole lot of boxing going on.","pos":[4304,4360]},{"content":"Under <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>, value type boxing is implicit:","pos":[4361,4470],"source":" Under [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)], value type boxing is implicit:"},{"content":"See Also","pos":[4750,4758]},{"content":"Value Types and Their Behaviors (C++/CLI)","pos":[4763,4804]},{"content":"Boxing","pos":[4865,4871]}],"content":"---\ntitle: \"Implicit Boxing of Value Types | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"boxing, Visual C++\"\n  - \"__box keyword\"\n  - \"boxing\"\n  - \"boxing, __box keyword\"\n  - \"value types, boxed\"\nms.assetid: 9597c92f-a3fe-44af-ad80-f9d656847a35\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Implicit Boxing of Value Types\nThe boxing of value types has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n In language design, we imposed a philosophical position in lieu of practical experience with the feature and, in practice, it was a mistake. As an analogy, in the original multiple inheritance language design, Stroustrup decided that a virtual base class sub-object could not be initialized within a derived class constructor, and therefore the language required that any class serving as a virtual base class must define a default constructor. It is that default constructor that would be invoked by any subsequent virtual derivation.  \n  \n The problem of a virtual base class hierarchy is that responsibility for the initialization of the shared virtual sub-object shifts with each subsequent derivation. For example, if I define a base class for which initialization requires the allocation of a buffer, the user-specified size of that buffer might be passed as an argument to the constructor. If I then provide two subsequent virtual derivations, call them `inputb` and `outputb`, each provides a particular value to the base class constructor. Now, when I derived an `in_out` class from both `inputb` and `outputb`, neither of those values to the shared virtual base class sub-object can sensibly be allowed to evaluate.  \n  \n Therefore, in the original language design, Stroustrup disallowed the explicit initialization of a virtual base class within the member initialization list of the derived class constructor. While this solved the problem, in practice the inability to direct the initialization of the virtual base class proved impracticable. Keith Gorlen of the National Institute of Health, who had implemented a freeware version of the SmallTalk collection library called nihcl, was a principle voice in convincing Stroustrup that he had to come up with a more flexible language design.  \n  \n A principle of Object-Oriented hierarchical design holds that a derived class should concern itself only with the non-private implementation of its immediate base classes. In order to support a flexible initialization design for virtual inheritance, Stroustrup had to violate this principle. The most derived class in a hierarchy assumes responsibility for all virtual sub-object initialization regardless of how deep into the hierarchy it occurs. For example, `inputb` and `outputb` are both responsible for explicitly initializing their immediate virtual base class. When `in_out` derives from both `inputb` and `outputb`, `in_out` becomes responsible for the initialization of the once removed virtual base class, and the initialization made explicit within `inputb` and `outputb` is suppressed.  \n  \n This provides the flexibility required by language developers, but at the cost of a complicated semantics. This burden of complication is stripped away if we restrict a virtual base class to be without state and simply allow it to specify an interface. This is a recommended design idiom within C++. Within CLR programming, it is raised to policy with the Interface type.  \n  \n Here is a simple code sample– and in this case, the explicit boxing is unnecessary:  \n  \n```  \n// Managed Extensions for C++ requires explicit __box operation  \nint my1DIntArray __gc[] = { 1, 2, 3, 4, 5 };  \nObject* myObjArray __gc[] = {   \n   __box(26), __box(27), __box(28), __box(29), __box(30)  \n};  \n  \nConsole::WriteLine( \"{0}\\t{1}\\t{2}\", __box(0),  \n   __box(my1DIntArray->GetLowerBound(0)),  \n   __box(my1DIntArray->GetUpperBound(0)) );  \n```  \n  \n As you can see, there is a whole lot of boxing going on. Under [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)], value type boxing is implicit:  \n  \n```  \n// new syntax makes boxing implicit  \narray<int>^ my1DIntArray = {1,2,3,4,5};  \narray<Object^>^ myObjArray = {26,27,28,29,30};  \n  \nConsole::WriteLine( \"{0}\\t{1}\\t{2}\", 0,   \n   my1DIntArray->GetLowerBound( 0 ),   \n   my1DIntArray->GetUpperBound( 0 ) );  \n```  \n  \n## See Also  \n [Value Types and Their Behaviors (C++/CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)   \n [Boxing](../windows/boxing-cpp-component-extensions.md)"}