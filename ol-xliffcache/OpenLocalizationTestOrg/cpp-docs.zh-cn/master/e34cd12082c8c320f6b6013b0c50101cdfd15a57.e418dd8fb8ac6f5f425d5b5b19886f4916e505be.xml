{"nodes":[{"pos":[12,68],"content":"Determining Which Linking Method to Use | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Determining Which Linking Method to Use | Microsoft Docs","pos":[0,56]}]},{"content":"Determining Which Linking Method to Use","pos":[628,667]},{"content":"There are two types of linking: implicit linking and explicit linking.","pos":[668,738]},{"content":"Implicit Linking","pos":[747,763]},{"content":"<bpt id=\"p1\">[</bpt>Implicit linking<ept id=\"p1\">](../build/linking-implicitly.md)</ept> occurs when an application's code calls an exported DLL function.","pos":[767,883],"source":"[Implicit linking](../build/linking-implicitly.md) occurs when an application's code calls an exported DLL function."},{"content":"When the source code for the calling executable is compiled or assembled, the DLL function call generates an external function reference in the object code.","pos":[884,1040]},{"content":"To resolve this external reference, the application must link with the import library (.lib file) provided by the maker of the DLL.","pos":[1041,1172]},{"content":"The import library only contains code to load the DLL and to implement calls to functions in the DLL.","pos":[1179,1280]},{"content":"Finding an external function in an import library informs the linker that the code for that function is in a DLL.","pos":[1281,1394]},{"content":"To resolve external references to DLLs, the linker simply adds information to the executable file that tells the system where to find the DLL code when the process starts up.","pos":[1395,1569]},{"content":"When the system starts a program that contains dynamically linked references, it uses the information in the program's executable file to locate the required DLLs.","pos":[1576,1739]},{"content":"If it cannot locate the DLL, the system terminates the process and displays a dialog box that reports the error.","pos":[1740,1852]},{"content":"Otherwise, the system maps the DLL modules into the process's address space.","pos":[1853,1929]},{"content":"If any of the DLLs has an entry-point function (for initialization and termination code), the operating system calls the function.","pos":[1936,2066]},{"content":"One of the parameters passed to the entry-point function specifies a code that indicates the DLL is attaching to the process.","pos":[2067,2192]},{"content":"If the entry-point function does not return TRUE, the system terminates the process and reports the error.","pos":[2193,2299]},{"content":"Finally, the system modifies the executable code of the process to provide starting addresses for the DLL functions.","pos":[2306,2422]},{"content":"Like the rest of a program's code, DLL code is mapped into the address space of the process when the process starts up and it is loaded into memory only when needed.","pos":[2429,2594]},{"content":"As a result, the <bpt id=\"p1\">**</bpt>PRELOAD<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>LOADONCALL<ept id=\"p2\">**</ept> code attributes used by .def files to control loading in previous versions of Windows no longer have meaning.","pos":[2595,2752],"source":" As a result, the **PRELOAD** and **LOADONCALL** code attributes used by .def files to control loading in previous versions of Windows no longer have meaning."},{"content":"Explicit Linking","pos":[2761,2777]},{"content":"Most applications use implicit linking because it is the easiest linking method to use.","pos":[2781,2868]},{"content":"However, there are times when <bpt id=\"p1\">[</bpt>explicit linking<ept id=\"p1\">](../build/linking-explicitly.md)</ept> is necessary.","pos":[2869,2963],"source":" However, there are times when [explicit linking](../build/linking-explicitly.md) is necessary."},{"content":"Here are some common reasons to use explicit linking:","pos":[2964,3017]},{"content":"The application does not know the name of a DLL that it will have to load until run time.","pos":[3027,3116]},{"content":"For example, the application might need to obtain the name of the DLL and the exported functions from a configuration file.","pos":[3117,3240]},{"content":"A process using implicit linking is terminated by the operating system if the DLL is not found at process startup.","pos":[3250,3364]},{"content":"A process using explicit linking is not terminated in this situation and can attempt to recover from the error.","pos":[3365,3476]},{"content":"For example, the process could notify the user of the error and have the user specify another path to the DLL.","pos":[3477,3587]},{"content":"A process using implicit linking is also terminated if any of the DLLs it is linked to have a <ph id=\"ph1\">`DllMain`</ph> function that fails.","pos":[3597,3721],"source":"A process using implicit linking is also terminated if any of the DLLs it is linked to have a `DllMain` function that fails."},{"content":"A process using explicit linking is not terminated in this situation.","pos":[3722,3791]},{"content":"An application that implicitly links to many DLLs can be slow to start because Windows loads all the DLLs when the application loads.","pos":[3801,3934]},{"content":"To improve startup performance, an application can implicitly link to those DLLs needed immediately after loading and wait to explicitly link to the other DLLs when they are needed.","pos":[3935,4116]},{"content":"Explicit linking eliminates the need to link the application with an import library.","pos":[4126,4210]},{"content":"If changes in the DLL cause the export ordinals to change, applications using explicit linking do not have to relink (assuming they are calling <bpt id=\"p1\">**</bpt>GetProcAddress<ept id=\"p1\">**</ept> with a name of a function and not with an ordinal value), whereas applications using implicit linking must relink to the new import library.","pos":[4211,4514],"source":" If changes in the DLL cause the export ordinals to change, applications using explicit linking do not have to relink (assuming they are calling **GetProcAddress** with a name of a function and not with an ordinal value), whereas applications using implicit linking must relink to the new import library."},{"content":"Here are two hazards of explicit linking to be aware of:","pos":[4521,4577]},{"content":"If the DLL has a <ph id=\"ph1\">`DllMain`</ph> entry point function, the operating system calls the function in the context of the thread that called <bpt id=\"p1\">**</bpt>LoadLibrary<ept id=\"p1\">**</ept>.","pos":[4587,4733],"source":"If the DLL has a `DllMain` entry point function, the operating system calls the function in the context of the thread that called **LoadLibrary**."},{"content":"The entry-point function is not called if the DLL is already attached to the process because of a previous call to <bpt id=\"p1\">**</bpt>LoadLibrary<ept id=\"p1\">**</ept> with no corresponding call to the <bpt id=\"p2\">**</bpt>FreeLibrary<ept id=\"p2\">**</ept> function.","pos":[4734,4924],"source":" The entry-point function is not called if the DLL is already attached to the process because of a previous call to **LoadLibrary** with no corresponding call to the **FreeLibrary** function."},{"content":"Explicit linking can cause problems if the DLL is using a <ph id=\"ph1\">`DllMain`</ph> function to perform initialization for each thread of a process because threads existing when <bpt id=\"p1\">**</bpt>LoadLibrary<ept id=\"p1\">**</ept> (or <ph id=\"ph2\">`AfxLoadLibrary`</ph>) is called will not be initialized.","pos":[4925,5159],"source":" Explicit linking can cause problems if the DLL is using a `DllMain` function to perform initialization for each thread of a process because threads existing when **LoadLibrary** (or `AfxLoadLibrary`) is called will not be initialized."},{"content":"If a DLL declares static-extent data as <bpt id=\"p1\">**</bpt>__declspec(thread)<ept id=\"p1\">**</ept>, it can cause a protection fault if explicitly linked.","pos":[5169,5286],"source":"If a DLL declares static-extent data as **__declspec(thread)**, it can cause a protection fault if explicitly linked."},{"content":"After the DLL is loaded with <bpt id=\"p1\">**</bpt>LoadLibrary<ept id=\"p1\">**</ept>, it causes a protection fault whenever the code references this data.","pos":[5287,5401],"source":" After the DLL is loaded with **LoadLibrary**, it causes a protection fault whenever the code references this data."},{"content":"(Static-extent data includes both global and local static items.) Therefore, when you create a DLL, you should either avoid using thread-local storage or inform DLL users about potential pitfalls (in case they attempt dynamic loading).","pos":[5402,5637]},{"content":"What do you want to do?","pos":[5646,5669]},{"content":"Link implicitly","pos":[5680,5695]},{"content":"Link explicitly","pos":[5739,5754]},{"content":"What do you want to know more about?","pos":[5796,5832]},{"content":"The search path used by Windows to locate a DLL","pos":[5843,5890]},{"content":"LoadLibrary and AfxLoadLibrary","pos":[5959,5989]},{"content":"GetProcAddress","pos":[6045,6059]},{"content":"FreeLibrary and AfxFreeLibrary","pos":[6099,6129]},{"content":"Using thread local storage in a dynamic-link library (Windows SDK)","pos":[6185,6251]},{"content":"See Also","pos":[6321,6329]},{"content":"Linking an Executable to a DLL","pos":[6334,6364]}],"content":"---\ntitle: \"Determining Which Linking Method to Use | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"implicit linking [C++]\"\n  - \"explicit linking [C++]\"\nms.assetid: 6b6d3fec-4711-4a30-af5b-354b965ecaec\ncaps.latest.revision: 9\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Determining Which Linking Method to Use\nThere are two types of linking: implicit linking and explicit linking.  \n  \n## Implicit Linking  \n [Implicit linking](../build/linking-implicitly.md) occurs when an application's code calls an exported DLL function. When the source code for the calling executable is compiled or assembled, the DLL function call generates an external function reference in the object code. To resolve this external reference, the application must link with the import library (.lib file) provided by the maker of the DLL.  \n  \n The import library only contains code to load the DLL and to implement calls to functions in the DLL. Finding an external function in an import library informs the linker that the code for that function is in a DLL. To resolve external references to DLLs, the linker simply adds information to the executable file that tells the system where to find the DLL code when the process starts up.  \n  \n When the system starts a program that contains dynamically linked references, it uses the information in the program's executable file to locate the required DLLs. If it cannot locate the DLL, the system terminates the process and displays a dialog box that reports the error. Otherwise, the system maps the DLL modules into the process's address space.  \n  \n If any of the DLLs has an entry-point function (for initialization and termination code), the operating system calls the function. One of the parameters passed to the entry-point function specifies a code that indicates the DLL is attaching to the process. If the entry-point function does not return TRUE, the system terminates the process and reports the error.  \n  \n Finally, the system modifies the executable code of the process to provide starting addresses for the DLL functions.  \n  \n Like the rest of a program's code, DLL code is mapped into the address space of the process when the process starts up and it is loaded into memory only when needed. As a result, the **PRELOAD** and **LOADONCALL** code attributes used by .def files to control loading in previous versions of Windows no longer have meaning.  \n  \n## Explicit Linking  \n Most applications use implicit linking because it is the easiest linking method to use. However, there are times when [explicit linking](../build/linking-explicitly.md) is necessary. Here are some common reasons to use explicit linking:  \n  \n-   The application does not know the name of a DLL that it will have to load until run time. For example, the application might need to obtain the name of the DLL and the exported functions from a configuration file.  \n  \n-   A process using implicit linking is terminated by the operating system if the DLL is not found at process startup. A process using explicit linking is not terminated in this situation and can attempt to recover from the error. For example, the process could notify the user of the error and have the user specify another path to the DLL.  \n  \n-   A process using implicit linking is also terminated if any of the DLLs it is linked to have a `DllMain` function that fails. A process using explicit linking is not terminated in this situation.  \n  \n-   An application that implicitly links to many DLLs can be slow to start because Windows loads all the DLLs when the application loads. To improve startup performance, an application can implicitly link to those DLLs needed immediately after loading and wait to explicitly link to the other DLLs when they are needed.  \n  \n-   Explicit linking eliminates the need to link the application with an import library. If changes in the DLL cause the export ordinals to change, applications using explicit linking do not have to relink (assuming they are calling **GetProcAddress** with a name of a function and not with an ordinal value), whereas applications using implicit linking must relink to the new import library.  \n  \n Here are two hazards of explicit linking to be aware of:  \n  \n-   If the DLL has a `DllMain` entry point function, the operating system calls the function in the context of the thread that called **LoadLibrary**. The entry-point function is not called if the DLL is already attached to the process because of a previous call to **LoadLibrary** with no corresponding call to the **FreeLibrary** function. Explicit linking can cause problems if the DLL is using a `DllMain` function to perform initialization for each thread of a process because threads existing when **LoadLibrary** (or `AfxLoadLibrary`) is called will not be initialized.  \n  \n-   If a DLL declares static-extent data as **__declspec(thread)**, it can cause a protection fault if explicitly linked. After the DLL is loaded with **LoadLibrary**, it causes a protection fault whenever the code references this data. (Static-extent data includes both global and local static items.) Therefore, when you create a DLL, you should either avoid using thread-local storage or inform DLL users about potential pitfalls (in case they attempt dynamic loading).  \n  \n## What do you want to do?  \n  \n-   [Link implicitly](../build/linking-implicitly.md)  \n  \n-   [Link explicitly](../build/linking-explicitly.md)  \n  \n## What do you want to know more about?  \n  \n-   [The search path used by Windows to locate a DLL](../build/search-path-used-by-windows-to-locate-a-dll.md)  \n  \n-   [LoadLibrary and AfxLoadLibrary](../build/loadlibrary-and-afxloadlibrary.md)  \n  \n-   [GetProcAddress](../build/getprocaddress.md)  \n  \n-   [FreeLibrary and AfxFreeLibrary](../build/freelibrary-and-afxfreelibrary.md)  \n  \n-   [Using thread local storage in a dynamic-link library (Windows SDK)](http://msdn.microsoft.com/library/windows/desktop/ms686997)  \n  \n## See Also  \n [Linking an Executable to a DLL](../build/linking-an-executable-to-a-dll.md)"}