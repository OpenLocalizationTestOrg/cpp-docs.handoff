{"nodes":[{"pos":[12,58],"content":"&lt;type_traits&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"type_traits<ph id=\"ph1\">&amp;gt;</ph> functions | Microsoft Docs","pos":[4,46],"source":"type_traits&gt; functions | Microsoft Docs"}]},{"content":"type_traits<ph id=\"ph1\">&amp;gt;</ph> functions","pos":[265,290],"source":"type_traits&gt; functions"},{"content":"is_assignable","pos":[310,323]},{"content":"is_copy_assignable","pos":[342,360]},{"content":"is_copy_constructible","pos":[384,405]},{"content":"is_default_constructible","pos":[436,460]},{"content":"is_move_assignable","pos":[490,508]},{"content":"is_move_constructible","pos":[532,553]},{"content":"is_nothrow_move_assignable","pos":[584,610]},{"content":"is_trivially_copy_assignable","pos":[642,670]},{"content":"is_trivially_move_assignable","pos":[704,732]},{"content":"is_trivially_move_constructible","pos":[770,801]},{"pos":[877,890],"content":"is_assignable"},{"pos":[894,962],"content":"Tests whether a value of <ph id=\"ph1\">`From`</ph> type can be assigned to a <ph id=\"ph2\">`To`</ph> type.","source":"Tests whether a value of `From` type can be assigned to a `To` type."},{"content":"Parameters","pos":[1045,1055]},{"content":"To","pos":[1059,1061]},{"content":"The type of the object that receives the assignment.","pos":[1065,1117]},{"content":"From","pos":[1124,1128]},{"content":"The type of the object that provides the value.","pos":[1132,1179]},{"content":"Remarks","pos":[1189,1196]},{"content":"The unevaluated expression <ph id=\"ph1\">`declval&lt;To&gt;() = declval&lt;From&gt;()`</ph> must be well-formed.","pos":[1200,1281],"source":"The unevaluated expression `declval<To>() = declval<From>()` must be well-formed."},{"content":"Both <ph id=\"ph1\">`From`</ph> and <ph id=\"ph2\">`To`</ph> must be complete types, <ph id=\"ph3\">`void`</ph>, or arrays of unknown bound.","pos":[1282,1362],"source":" Both `From` and `To` must be complete types, `void`, or arrays of unknown bound."},{"pos":[1407,1425],"content":"is_copy_assignable"},{"content":"Tests whether type has can be copied on assignment.","pos":[1429,1480]},{"content":"Parameters","pos":[1556,1566]},{"content":"The type to query.","pos":[1578,1596]},{"content":"Remarks","pos":[1606,1613]},{"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`Ty`</ph> is a class that has a copy assignment operator, otherwise it holds false.","pos":[1617,1752],"source":"An instance of the type predicate holds true if the type `Ty` is a class that has a copy assignment operator, otherwise it holds false."},{"content":"Equivalent to is_assignable<ph id=\"ph1\">\\&lt;</ph>Ty&amp;, const Ty&amp;&gt;.","pos":[1753,1798],"source":" Equivalent to is_assignable\\<Ty&, const Ty&>."},{"pos":[1846,1867],"content":"is_copy_constructible"},{"content":"Tests if type has a copy constructor.","pos":[1871,1908]},{"content":"Parameters","pos":[1987,1997]},{"content":"The type to query.","pos":[2009,2027]},{"content":"Remarks","pos":[2037,2044]},{"pos":[2048,2175],"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`Ty`</ph> is a class that has a copy constructor, otherwise it holds false.","source":"An instance of the type predicate holds true if the type `Ty` is a class that has a copy constructor, otherwise it holds false."},{"content":"Example","pos":[2185,2192]},{"pos":[2908,2932],"content":"is_default_constructible"},{"content":"Tests if a type has a default constructor.","pos":[2936,2978]},{"content":"Parameters","pos":[3060,3070]},{"content":"The type to query.","pos":[3081,3099]},{"content":"Remarks","pos":[3109,3116]},{"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`T`</ph> is a class type that has a default constructor, otherwise it holds false.","pos":[3120,3254],"source":"An instance of the type predicate holds true if the type `T` is a class type that has a default constructor, otherwise it holds false."},{"content":"This is equivalent to the predicate <ph id=\"ph1\">`is_constructible&lt;T&gt;`</ph>.","pos":[3255,3313],"source":" This is equivalent to the predicate `is_constructible<T>`."},{"content":"Type <ph id=\"ph1\">`T`</ph> must be a complete type, <ph id=\"ph2\">`void`</ph>, or an array of unknown bound.","pos":[3314,3385],"source":" Type `T` must be a complete type, `void`, or an array of unknown bound."},{"content":"Example","pos":[3395,3402]},{"pos":[4119,4137],"content":"is_move_assignable"},{"content":"Tests if the type can be move assigned.","pos":[4141,4180]},{"content":"Parameters","pos":[4255,4265]},{"content":"The type to query.","pos":[4276,4294]},{"content":"Remarks","pos":[4304,4311]},{"content":"A type is move assignable if an rvalue reference to the type can be assigned to a reference to the type.","pos":[4315,4419]},{"content":"The type predicate is equivalent to <ph id=\"ph1\">`is_assignable&lt;T&amp;, T&amp;&amp;&gt;`</ph>.","pos":[4420,4481],"source":" The type predicate is equivalent to `is_assignable<T&, T&&>`."},{"content":"Move assignable types include referenceable scalar types and class types that have either compiler-generated or user-defined move assignment operators.","pos":[4482,4633]},{"pos":[4681,4702],"content":"is_move_constructible"},{"content":"Tests whether the type has a move constructor.","pos":[4706,4752]},{"content":"Parameters","pos":[4830,4840]},{"content":"T","pos":[4844,4845]},{"content":"The type to be evaluated","pos":[4849,4873]},{"content":"Remarks","pos":[4883,4890]},{"content":"A type predicate that evaluates to true if the type <ph id=\"ph1\">`T`</ph> can be constructed by using a move operation.","pos":[4894,4995],"source":"A type predicate that evaluates to true if the type `T` can be constructed by using a move operation."},{"content":"This predicate is equivalent to <ph id=\"ph1\">`is_constructible&lt;T, T&amp;&amp;&gt;`</ph>.","pos":[4996,5055],"source":" This predicate is equivalent to `is_constructible<T, T&&>`."},{"pos":[5108,5134],"content":"is_nothrow_move_assignable"},{"pos":[5138,5200],"content":"Tests whether type has a <bpt id=\"p1\">**</bpt>nothrow<ept id=\"p1\">**</ept> move assignment operator.","source":"Tests whether type has a **nothrow** move assignment operator."},{"content":"Parameters","pos":[5284,5294]},{"content":"The type to query.","pos":[5306,5324]},{"content":"Remarks","pos":[5334,5341]},{"pos":[5345,5472],"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`Ty`</ph> has a nothrow move assignment operator, otherwise it holds false.","source":"An instance of the type predicate holds true if the type `Ty` has a nothrow move assignment operator, otherwise it holds false."},{"pos":[5527,5555],"content":"is_trivially_copy_assignable"},{"content":"Tests whether the type has a trivial copy assignment operator.","pos":[5559,5621]},{"content":"Parameters","pos":[5707,5717]},{"content":"The type to query.","pos":[5728,5746]},{"content":"Remarks","pos":[5756,5763]},{"pos":[5767,5909],"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`T`</ph> is a class that has a trivial copy assignment operator, otherwise it holds false.","source":"An instance of the type predicate holds true if the type `T` is a class that has a trivial copy assignment operator, otherwise it holds false."},{"pos":[5916,6279],"content":"An assignment constructor for a class <ph id=\"ph1\">`T`</ph> is trivial if it is implicitly provided, the class <ph id=\"ph2\">`T`</ph> has no virtual functions, the class <ph id=\"ph3\">`T`</ph> has no virtual bases, the classes of all the non-static data members of class type have trivial assignment operators, and the classes of all the non-static data members of type array of class have trivial assignment operators.","source":"An assignment constructor for a class `T` is trivial if it is implicitly provided, the class `T` has no virtual functions, the class `T` has no virtual bases, the classes of all the non-static data members of class type have trivial assignment operators, and the classes of all the non-static data members of type array of class have trivial assignment operators."},{"pos":[6334,6362],"content":"is_trivially_move_assignable"},{"content":"Tests whether the type has a trivial move assignment operator.","pos":[6366,6428]},{"content":"Parameters","pos":[6514,6524]},{"content":"The type to query.","pos":[6536,6554]},{"content":"Remarks","pos":[6564,6571]},{"pos":[6575,6718],"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`Ty`</ph> is a class that has a trivial move assignment operator, otherwise it holds false.","source":"An instance of the type predicate holds true if the type `Ty` is a class that has a trivial move assignment operator, otherwise it holds false."},{"pos":[6725,6783],"content":"A move assignment operator for a class <ph id=\"ph1\">`Ty`</ph> is trivial if:","source":"A move assignment operator for a class `Ty` is trivial if:"},{"content":"it is implicitly provided","pos":[6790,6815]},{"pos":[6822,6861],"content":"the class <ph id=\"ph1\">`Ty`</ph> has no virtual functions","source":"the class `Ty` has no virtual functions"},{"pos":[6868,6903],"content":"the class <ph id=\"ph1\">`Ty`</ph> has no virtual bases","source":"the class `Ty` has no virtual bases"},{"content":"the classes of all the non-static data members of class type have trivial move assignment operators","pos":[6910,7009]},{"content":"the classes of all the non-static data members of type array of class have trivial move assignment operators","pos":[7016,7124]},{"pos":[7182,7213],"content":"is_trivially_move_constructible"},{"content":"Tests if type has trivial move constructor.","pos":[7217,7260]},{"content":"Parameters","pos":[7349,7359]},{"content":"The type to query.","pos":[7371,7389]},{"content":"Remarks","pos":[7399,7406]},{"pos":[7410,7545],"content":"An instance of the type predicate holds true if the type <ph id=\"ph1\">`Ty`</ph> is a class that has a trivial move constructor, otherwise it holds false.","source":"An instance of the type predicate holds true if the type `Ty` is a class that has a trivial move constructor, otherwise it holds false."},{"pos":[7552,7602],"content":"A move constructor for a class <ph id=\"ph1\">`Ty`</ph> is trivial if:","source":"A move constructor for a class `Ty` is trivial if:"},{"content":"it is implicitly declared","pos":[7609,7634]},{"content":"its parameter types are equivalent to those of an implicit declaration","pos":[7641,7711]},{"pos":[7718,7757],"content":"the class <ph id=\"ph1\">`Ty`</ph> has no virtual functions","source":"the class `Ty` has no virtual functions"},{"pos":[7764,7799],"content":"the class <ph id=\"ph1\">`Ty`</ph> has no virtual bases","source":"the class `Ty` has no virtual bases"},{"content":"the class has no volatile non-static data members","pos":[7806,7855]},{"pos":[7862,7931],"content":"all the direct bases of the class <ph id=\"ph1\">`Ty`</ph> have trivial move constructors","source":"all the direct bases of the class `Ty` have trivial move constructors"},{"content":"the classes of all the non-static data members of class type have trivial move constructors","pos":[7938,8029]},{"content":"the classes of all the non-static data members of type array of class have trivial move constructors","pos":[8036,8136]},{"content":"See Also","pos":[8145,8153]},{"content":"&lt;type_traits&gt;","pos":[8158,8171],"source":"<type_traits>"}],"content":"---\ntitle: \"&lt;type_traits&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: dce4492f-f3e4-4d5e-bdb4-5875321254ec\ncaps.latest.revision: 13\nmanager: \"ghogen\"\n---\n# &lt;type_traits&gt; functions\n||||  \n|-|-|-|  \n|[is_assignable](#is_assignable)|[is_copy_assignable](#is_copy_assignable)|[is_copy_constructible](#is_copy_constructible)|  \n|[is_default_constructible](#is_default_constructible)|[is_move_assignable](#is_move_assignable)|[is_move_constructible](#is_move_constructible)|  \n|[is_nothrow_move_assignable](#is_nothrow_move_assignable)|[is_trivially_copy_assignable](#is_trivially_copy_assignable)|[is_trivially_move_assignable](#is_trivially_move_assignable)|  \n|[is_trivially_move_constructible](#is_trivially_move_constructible)|  \n  \n##  <a name=\"is_assignable\"></a>  is_assignable  \n Tests whether a value of `From` type can be assigned to a `To` type.  \n  \n```  \ntemplate <class To, class From>  \nstruct is_assignable;  \n```  \n  \n### Parameters  \n To  \n The type of the object that receives the assignment.  \n  \n From  \n The type of the object that provides the value.  \n  \n### Remarks  \n The unevaluated expression `declval<To>() = declval<From>()` must be well-formed. Both `From` and `To` must be complete types, `void`, or arrays of unknown bound.  \n  \n##  <a name=\"is_copy_assignable\"></a>  is_copy_assignable  \n Tests whether type has can be copied on assignment.  \n  \n```  \ntemplate <class Ty>  \nstruct is_copy_assignable;  \n```  \n  \n### Parameters  \n `Ty`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `Ty` is a class that has a copy assignment operator, otherwise it holds false. Equivalent to is_assignable\\<Ty&, const Ty&>.  \n  \n##  <a name=\"is_copy_constructible\"></a>  is_copy_constructible  \n Tests if type has a copy constructor.  \n  \n```  \ntemplate <class Ty>  \nstruct is_copy_constructible;  \n```  \n  \n### Parameters  \n `Ty`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `Ty` is a class that has a copy constructor, otherwise it holds false.  \n  \n### Example  \n  \n```cpp  \n#include <type_traits>   \n#include <iostream>   \n  \nstruct Copyable  \n{  \n    int val;  \n};  \n  \nstruct NotCopyable  \n{  \n   NotCopyable(const NotCopyable&) = delete;  \n   int val;  \n  \n};  \n  \nint main()  \n{  \n    std::cout << \"is_copy_constructible<Copyable> == \" << std::boolalpha  \n        << std::is_copy_constructible<Copyable>::value << std::endl;  \n    std::cout << \"is_copy_constructible<NotCopyable> == \" << std::boolalpha  \n        << std::is_copy_constructible<NotCopyable>::value << std::endl;  \n  \n    return (0);  \n}  \n  \n```  \n  \n```Output  \nis_copy_constructible<Copyable> == true  \nis_copy_constructible<NotCopyable > == false  \n```  \n  \n##  <a name=\"is_default_constructible\"></a>  is_default_constructible  \n Tests if a type has a default constructor.  \n  \n```  \ntemplate <class Ty>  \nstruct is_default_constructible;  \n```  \n  \n### Parameters  \n `T`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `T` is a class type that has a default constructor, otherwise it holds false. This is equivalent to the predicate `is_constructible<T>`. Type `T` must be a complete type, `void`, or an array of unknown bound.  \n  \n### Example  \n  \n```cpp  \n  \n#include <type_traits>   \n#include <iostream>   \n  \nstruct Simple  \n{  \n    Simple() : val(0) {}  \n    int val;  \n};  \n  \nstruct Simple2  \n{  \n    Simple2(int v) : val(v) {}  \n    int val;  \n};  \n  \nint main()  \n{  \n    std::cout << \"is_default_constructible<Simple> == \" << std::boolalpha  \n        << std::is_default_constructible<Simple>::value << std::endl;  \n    std::cout << \"is_default_constructible<Simple2> == \" << std::boolalpha  \n        << std::is_default_constructible<Simple2>::value << std::endl;  \n  \n    return (0);  \n}  \n  \n```  \n  \n```Output  \nis_default_constructible<Simple> == true  \nis_default_constructible<Simple2> == false  \n```  \n  \n##  <a name=\"is_move_assignable\"></a>  is_move_assignable  \n Tests if the type can be move assigned.  \n  \n```  \ntemplate <class T>  \nstruct is_move_assignable;  \n```  \n  \n### Parameters  \n `T`  \n The type to query.  \n  \n### Remarks  \n A type is move assignable if an rvalue reference to the type can be assigned to a reference to the type. The type predicate is equivalent to `is_assignable<T&, T&&>`. Move assignable types include referenceable scalar types and class types that have either compiler-generated or user-defined move assignment operators.  \n  \n##  <a name=\"is_move_constructible\"></a>  is_move_constructible  \n Tests whether the type has a move constructor.  \n  \n```  \ntemplate <class T>  \nstruct is_move_constructible;  \n```  \n  \n### Parameters  \n T  \n The type to be evaluated  \n  \n### Remarks  \n A type predicate that evaluates to true if the type `T` can be constructed by using a move operation. This predicate is equivalent to `is_constructible<T, T&&>`.  \n  \n##  <a name=\"is_nothrow_move_assignable\"></a>  is_nothrow_move_assignable  \n Tests whether type has a **nothrow** move assignment operator.  \n  \n```  \ntemplate <class Ty>  \nstruct is_nothrow_move_assignable;  \n```  \n  \n### Parameters  \n `Ty`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `Ty` has a nothrow move assignment operator, otherwise it holds false.  \n  \n##  <a name=\"is_trivially_copy_assignable\"></a>  is_trivially_copy_assignable  \n Tests whether the type has a trivial copy assignment operator.  \n  \n```  \ntemplate <class Ty>  \nstruct is_trivially_copy_assignable;  \n```  \n  \n### Parameters  \n `T`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `T` is a class that has a trivial copy assignment operator, otherwise it holds false.  \n  \n An assignment constructor for a class `T` is trivial if it is implicitly provided, the class `T` has no virtual functions, the class `T` has no virtual bases, the classes of all the non-static data members of class type have trivial assignment operators, and the classes of all the non-static data members of type array of class have trivial assignment operators.  \n  \n##  <a name=\"is_trivially_move_assignable\"></a>  is_trivially_move_assignable  \n Tests whether the type has a trivial move assignment operator.  \n  \n```  \ntemplate <class Ty>  \nstruct is_trivially_move_assignable;  \n```  \n  \n### Parameters  \n `Ty`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `Ty` is a class that has a trivial move assignment operator, otherwise it holds false.  \n  \n A move assignment operator for a class `Ty` is trivial if:  \n  \n it is implicitly provided  \n  \n the class `Ty` has no virtual functions  \n  \n the class `Ty` has no virtual bases  \n  \n the classes of all the non-static data members of class type have trivial move assignment operators  \n  \n the classes of all the non-static data members of type array of class have trivial move assignment operators  \n  \n##  <a name=\"is_trivially_move_constructible\"></a>  is_trivially_move_constructible  \n Tests if type has trivial move constructor.  \n  \n```  \ntemplate <class Ty>  \nstruct is_trivially_move_constructible;  \n```  \n  \n### Parameters  \n `Ty`  \n The type to query.  \n  \n### Remarks  \n An instance of the type predicate holds true if the type `Ty` is a class that has a trivial move constructor, otherwise it holds false.  \n  \n A move constructor for a class `Ty` is trivial if:  \n  \n it is implicitly declared  \n  \n its parameter types are equivalent to those of an implicit declaration  \n  \n the class `Ty` has no virtual functions  \n  \n the class `Ty` has no virtual bases  \n  \n the class has no volatile non-static data members  \n  \n all the direct bases of the class `Ty` have trivial move constructors  \n  \n the classes of all the non-static data members of class type have trivial move constructors  \n  \n the classes of all the non-static data members of type array of class have trivial move constructors  \n  \n## See Also  \n [<type_traits>](../standard-library/type-traits.md)\n\n"}