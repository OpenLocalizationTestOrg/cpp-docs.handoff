{"nodes":[{"pos":[12,89],"content":"Left Shift and Right Shift Operators (&gt;&gt; and &lt;&lt;) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Left Shift and Right Shift Operators (<ph id=\"ph1\">&amp;gt;&amp;gt;</ph> and <ph id=\"ph2\">&amp;lt;&amp;lt;</ph>) | Microsoft Docs","pos":[0,77],"source":"Left Shift and Right Shift Operators (&gt;&gt; and &lt;&lt;) | Microsoft Docs"}]},{"content":"Left Shift and Right Shift Operators (<ph id=\"ph1\">&amp;gt;&amp;gt;</ph> and <ph id=\"ph2\">&amp;lt;&amp;lt;</ph>)","pos":[830,890],"source":"Left Shift and Right Shift Operators (&gt;&gt; and &lt;&lt;)"},{"content":"The bitwise shift operators are the right-shift operator (<ph id=\"ph1\">`&gt;&gt;`</ph>), which moves the bits of <ph id=\"ph2\">`shift_expression`</ph> to the right, and the left-shift operator (<ph id=\"ph3\">`&lt;&lt;`</ph>), which moves the bits of <ph id=\"ph4\">`shift_expression`</ph> to the left.","pos":[891,1104],"source":"The bitwise shift operators are the right-shift operator (`>>`), which moves the bits of `shift_expression` to the right, and the left-shift operator (`<<`), which moves the bits of `shift_expression` to the left."},{"content":"1","pos":[1110,1111]},{"content":"Syntax","pos":[1126,1132]},{"content":"Remarks","pos":[1249,1256]},{"pos":[1264,1713],"content":"[!IMPORTANT]\n The following descriptions and examples are valid on Windows for X86 and x64 architectures. The implementation of left-shift and right-shift operators is significantly different on Windows RT for ARM devices. For more information, see the \"Shift Operators\" section of the [Hello ARM](http://blogs.msdn.com/b/vcblog/archive/2012/10/25/hello-arm-exploring-undefined-unspecified-and-implementation-defined-behavior-in-c.aspx) blog post.","leadings":["","> "],"nodes":[{"content":" The following descriptions and examples are valid on Windows for X86 and x64 architectures. The implementation of left-shift and right-shift operators is significantly different on Windows RT for ARM devices. For more information, see the \"Shift Operators\" section of the [Hello ARM](http://blogs.msdn.com/b/vcblog/archive/2012/10/25/hello-arm-exploring-undefined-unspecified-and-implementation-defined-behavior-in-c.aspx) blog post.","pos":[13,447],"nodes":[{"content":"The following descriptions and examples are valid on Windows for X86 and x64 architectures.","pos":[1,92]},{"content":"The implementation of left-shift and right-shift operators is significantly different on Windows RT for ARM devices.","pos":[93,209]},{"content":"For more information, see the \"Shift Operators\" section of the <bpt id=\"p1\">[</bpt>Hello ARM<ept id=\"p1\">](http://blogs.msdn.com/b/vcblog/archive/2012/10/25/hello-arm-exploring-undefined-unspecified-and-implementation-defined-behavior-in-c.aspx)</ept> blog post.","pos":[210,434],"source":" For more information, see the \"Shift Operators\" section of the [Hello ARM](http://blogs.msdn.com/b/vcblog/archive/2012/10/25/hello-arm-exploring-undefined-unspecified-and-implementation-defined-behavior-in-c.aspx) blog post."}]}]},{"content":"Left Shifts","pos":[1722,1733]},{"content":"The left-shift operator causes the bits in <ph id=\"ph1\">`shift-expression`</ph> to be shifted to the left by the number of positions specified by <ph id=\"ph2\">`additive-expression`</ph>.","pos":[1737,1887],"source":"The left-shift operator causes the bits in `shift-expression` to be shifted to the left by the number of positions specified by `additive-expression`."},{"content":"The bit positions that have been vacated by the shift operation are zero-filled.","pos":[1888,1968]},{"content":"A left shift is a logical shift (the bits that are shifted off the end are discarded, including the sign bit).","pos":[1969,2079]},{"content":"For more information about the kinds of bitwise shifts, see <bpt id=\"p1\">[</bpt>Bitwise shifts<ept id=\"p1\">](http://en.wikipedia.org/wiki/Bitwise_shift)</ept>.","pos":[2080,2201],"source":" For more information about the kinds of bitwise shifts, see [Bitwise shifts](http://en.wikipedia.org/wiki/Bitwise_shift)."},{"content":"The following example shows left-shift operations using unsigned numbers.","pos":[2208,2281]},{"content":"The example shows what is happening to the bits by representing the value as a bitset.","pos":[2282,2368]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>bitset Class<ept id=\"p1\">](../standard-library/bitset-class.md)</ept>.","pos":[2369,2447],"source":" For more information, see [bitset Class](../standard-library/bitset-class.md)."},{"content":"If you left-shift a signed number so that the sign bit is affected, the result is undefined.","pos":[3048,3140]},{"content":"The following example shows what happens in Visual C++ when a 1 bit is left-shifted into the sign bit position.","pos":[3141,3252]},{"content":"Right Shifts","pos":[3798,3810]},{"content":"The right-shift operator causes the bit pattern in <ph id=\"ph1\">`shift-expression`</ph> to be shifted to the right by the number of positions specified by <ph id=\"ph2\">`additive-expression`</ph>.","pos":[3814,3973],"source":"The right-shift operator causes the bit pattern in `shift-expression` to be shifted to the right by the number of positions specified by `additive-expression`."},{"content":"For unsigned numbers, the bit positions that have been vacated by the shift operation are zero-filled.","pos":[3974,4076]},{"content":"For signed numbers, the sign bit is used to fill the vacated bit positions.","pos":[4077,4152]},{"content":"In other words, if the number is positive, 0 is used, and if the number is negative, 1 is used.","pos":[4153,4248]},{"pos":[4256,4486],"content":"[!IMPORTANT]\n The result of a right-shift of a signed negative number is implementation-dependent. Although Visual C++ uses the sign bit to fill vacated bit positions, there is no guarantee that other implementations also do so.","leadings":["","> "],"nodes":[{"content":" The result of a right-shift of a signed negative number is implementation-dependent. Although Visual C++ uses the sign bit to fill vacated bit positions, there is no guarantee that other implementations also do so.","pos":[13,228],"nodes":[{"content":"The result of a right-shift of a signed negative number is implementation-dependent.","pos":[1,85]},{"content":"Although Visual C++ uses the sign bit to fill vacated bit positions, there is no guarantee that other implementations also do so.","pos":[86,215]}]}]},{"content":"This example shows right-shift operations using unsigned numbers:","pos":[4493,4558]},{"content":"The next example shows right-shift operations with positive signed numbers.","pos":[5242,5317]},{"content":"The next example shows right-shift operations with negative signed integers.","pos":[5815,5891]},{"content":"Shifts and Promotions","pos":[6574,6595]},{"content":"The expressions on both sides of a shift operator must be integral types.","pos":[6599,6672]},{"content":"Integral promotions are performed according to the rules described in <bpt id=\"p1\">[</bpt>Standard Conversions<ept id=\"p1\">](standard-conversions.md)</ept>.","pos":[6673,6791],"source":" Integral promotions are performed according to the rules described in [Standard Conversions](standard-conversions.md)."},{"content":"The type of the result is the same as the type of the promoted <ph id=\"ph1\">`shift-expression`</ph>.","pos":[6792,6874],"source":" The type of the result is the same as the type of the promoted `shift-expression`."},{"pos":[6881,6957],"content":"In the following example, a variable of type <ph id=\"ph1\">`char`</ph> is promoted to an <ph id=\"ph2\">`int`</ph>.","source":"In the following example, a variable of type `char` is promoted to an `int`."},{"content":"Additional Details","pos":[7308,7326]},{"content":"The result of a shift operation is undefined if <ph id=\"ph1\">`additive-expression`</ph> is negative or if <ph id=\"ph2\">`additive-expression`</ph> is greater than or equal to the number of bits in the (promoted) <ph id=\"ph3\">`shift-expression`</ph>.","pos":[7330,7524],"source":"The result of a shift operation is undefined if `additive-expression` is negative or if `additive-expression` is greater than or equal to the number of bits in the (promoted) `shift-expression`."},{"content":"No shift operation is performed if <ph id=\"ph1\">`additive-expression`</ph> is 0.","pos":[7525,7587],"source":" No shift operation is performed if `additive-expression` is 0."},{"content":"Footnotes","pos":[8408,8417]},{"content":"1 The following is the description of the shift operators in the C++ ISO specification (INCITS/ISO/IEC 14882-2011[2012]), sections 5.8.2 and 5.8.3.","pos":[8421,8568]},{"content":"The value of <ph id=\"ph1\">`E1 &lt;&lt; E2`</ph> is <ph id=\"ph2\">`E1`</ph> left-shifted <ph id=\"ph3\">`E2`</ph> bit positions; vacated bits are zero-filled.","pos":[8575,8669],"source":"The value of `E1 << E2` is `E1` left-shifted `E2` bit positions; vacated bits are zero-filled."},{"content":"If <ph id=\"ph1\">`E1`</ph> has an unsigned type, the value of the result is <ph id=\"ph2\">`E1 × 2`&lt;sup&gt;</ph>E2<ph id=\"ph3\">&lt;/sup&gt;</ph>, reduced modulo one more than the maximum value representable in the result type.","pos":[8670,8830],"source":" If `E1` has an unsigned type, the value of the result is `E1 × 2`<sup>E2</sup>, reduced modulo one more than the maximum value representable in the result type."},{"content":"Otherwise, if <ph id=\"ph1\">`E1`</ph> has a signed type and non-negative value, and <ph id=\"ph2\">`E1 × 2`&lt;sup&gt;</ph>E2<ph id=\"ph3\">&lt;/sup&gt;</ph> is representable in the corresponding unsigned type of the result type, then that value, converted to the result type, is the resulting value; otherwise, the behavior is undefined.","pos":[8831,9098],"source":" Otherwise, if `E1` has a signed type and non-negative value, and `E1 × 2`<sup>E2</sup> is representable in the corresponding unsigned type of the result type, then that value, converted to the result type, is the resulting value; otherwise, the behavior is undefined."},{"content":"The value of <ph id=\"ph1\">`E1 &gt;&gt; E2`</ph> is <ph id=\"ph2\">`E1`</ph> right-shifted <ph id=\"ph3\">`E2`</ph> bit positions.","pos":[9105,9170],"source":"The value of `E1 >> E2` is `E1` right-shifted `E2` bit positions."},{"content":"If <ph id=\"ph1\">`E1`</ph> has an unsigned type or if <ph id=\"ph2\">`E1`</ph> has a signed type and a non-negative value, the value of the result is the integral part of the quotient of <ph id=\"ph3\">`E1/2`&lt;sup&gt;</ph>E2<ph id=\"ph4\">&lt;/sup&gt;</ph>.","pos":[9171,9339],"source":" If `E1` has an unsigned type or if `E1` has a signed type and a non-negative value, the value of the result is the integral part of the quotient of `E1/2`<sup>E2</sup>."},{"content":"If <ph id=\"ph1\">`E1`</ph> has a signed type and a negative value, the resulting value is implementation-defined.","pos":[9340,9434],"source":" If `E1` has a signed type and a negative value, the resulting value is implementation-defined."},{"content":"See Also","pos":[9443,9451]},{"content":"Expressions with Binary Operators","pos":[9456,9489]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[9541,9593]}],"content":"---\ntitle: \"Left Shift and Right Shift Operators (&gt;&gt; and &lt;&lt;) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"<<\"\n  - \">>\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"<< operator, with specific objects\"\n  - \"left shift operators\"\n  - \"right shift operators\"\n  - \"bitwise-shift operators\"\n  - \">> operator\"\n  - \"shift operators\"\n  - \"operators [C++], shift\"\nms.assetid: 25fa0cbb-5fdd-4657-8745-b35f7d8f1606\ncaps.latest.revision: 18\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Left Shift and Right Shift Operators (&gt;&gt; and &lt;&lt;)\nThe bitwise shift operators are the right-shift operator (`>>`), which moves the bits of `shift_expression` to the right, and the left-shift operator (`<<`), which moves the bits of `shift_expression` to the left. <sup>1</sup>  \n  \n## Syntax  \n  \n```  \n  \n      shift-expression << additive-expression  \nshift-expression >> additive-expression  \n```  \n  \n## Remarks  \n  \n> [!IMPORTANT]\n>  The following descriptions and examples are valid on Windows for X86 and x64 architectures. The implementation of left-shift and right-shift operators is significantly different on Windows RT for ARM devices. For more information, see the \"Shift Operators\" section of the [Hello ARM](http://blogs.msdn.com/b/vcblog/archive/2012/10/25/hello-arm-exploring-undefined-unspecified-and-implementation-defined-behavior-in-c.aspx) blog post.  \n  \n## Left Shifts  \n The left-shift operator causes the bits in `shift-expression` to be shifted to the left by the number of positions specified by `additive-expression`. The bit positions that have been vacated by the shift operation are zero-filled. A left shift is a logical shift (the bits that are shifted off the end are discarded, including the sign bit). For more information about the kinds of bitwise shifts, see [Bitwise shifts](http://en.wikipedia.org/wiki/Bitwise_shift).  \n  \n The following example shows left-shift operations using unsigned numbers. The example shows what is happening to the bits by representing the value as a bitset. For more information, see [bitset Class](../standard-library/bitset-class.md).  \n  \n```cpp  \n#include <iostream>  \n#include <bitset>  \nusing namespace std;  \n  \nint main() {  \n    unsigned short short1 = 4;      \n    bitset<16> bitset1{short1};   // the bitset representation of 4  \n    cout << bitset1 << endl;  // 0000000000000100  \n  \n    unsigned short short2 = short1 << 1;     // 4 left-shifted by 1 = 8  \n    bitset<16> bitset2{short2};  \n    cout << bitset2 << endl;  // 0000000000001000  \n  \n    unsigned short short3 = short1 << 2;     // 4 left-shifted by 2 = 16  \n    bitset<16> bitset3{short3};  \n    cout << bitset3 << endl;  // 0000000000010000  \n}  \n  \n```  \n  \n If you left-shift a signed number so that the sign bit is affected, the result is undefined. The following example shows what happens in Visual C++ when a 1 bit is left-shifted into the sign bit position.  \n  \n```cpp  \n#include <iostream>  \n#include <bitset>  \nusing namespace std;  \n  \nint main() {  \n    short short1 = 16384;      \n    bitset<16> bitset1{short2};  \n    cout << bitset1 << endl;  // 0100000000000000   \n  \n    short short3 = short1 << 1;  \n    bitset<16> bitset3{short3};  // 16384 left-shifted by 1 = -32768  \n    cout << bitset3 << endl;  // 100000000000000  \n  \n    short short4 = short1 << 14;  \n    bitset<16> bitset4{short4};  // 4 left-shifted by 14 = 0  \n    cout << bitset4 << endl;  // 000000000000000    \n}  \n```  \n  \n## Right Shifts  \n The right-shift operator causes the bit pattern in `shift-expression` to be shifted to the right by the number of positions specified by `additive-expression`. For unsigned numbers, the bit positions that have been vacated by the shift operation are zero-filled. For signed numbers, the sign bit is used to fill the vacated bit positions. In other words, if the number is positive, 0 is used, and if the number is negative, 1 is used.  \n  \n> [!IMPORTANT]\n>  The result of a right-shift of a signed negative number is implementation-dependent. Although Visual C++ uses the sign bit to fill vacated bit positions, there is no guarantee that other implementations also do so.  \n  \n This example shows right-shift operations using unsigned numbers:  \n  \n```cpp  \n#include <iostream>  \n#include <bitset>  \nusing namespace std;  \n  \nint main() {  \n    unsigned short short11 = 1024;  \n    bitset<16> bitset11{short11};  \n    cout << bitset11 << endl;     // 0000010000000000  \n  \n    unsigned short short12 = short11 >> 1;  // 512  \n    bitset<16> bitset12{short12};  \n    cout << bitset12 << endl;     // 0000001000000000  \n  \n    unsigned short short13 = short11 >> 10;  // 1  \n    bitset<16> bitset13{short13};  \n    cout << bitset13 << endl;     // 0000000000000001  \n  \n    unsigned short short14 = short11 >> 11;  // 0  \n    bitset<16> bitset14{short14};  \n    cout << bitset14 << endl;     // 0000000000000000}  \n}  \n```  \n  \n The next example shows right-shift operations with positive signed numbers.  \n  \n```cpp  \n#include <iostream>  \n#include <bitset>  \nusing namespace std;  \n  \nint main() {  \n    short short1 = 1024;  \n    bitset<16> bitset1{short1};  \n    cout << bitset1 << endl;     // 0000010000000000  \n  \n    short short2 = short1 >> 1;  // 512  \n    bitset<16> bitset2{short2};  \n    cout << bitset2 << endl;     // 0000001000000000  \n  \n    short short3 = short1 >> 11;  // 0  \n    bitset<16> bitset3{short3};     \n    cout << bitset3 << endl;     // 0000000000000000  \n}  \n```  \n  \n The next example shows right-shift operations with negative signed integers.  \n  \n```cpp  \n#include <iostream>  \n#include <bitset>  \nusing namespace std;  \n  \nint main() {  \n    short neg1 = -16;  \n    bitset<16> bn1{neg1};  \n    cout << bn1 << endl;  // 1111111111110000  \n  \n    short neg2 = neg1 >> 1; // -8  \n    bitset<16> bn2{neg2};  \n    cout << bn2 << endl;  // 1111111111111000  \n  \n    short neg3 = neg1 >> 2; // -4  \n    bitset<16> bn3{neg3};  \n    cout << bn3 << endl;  // 1111111111111100  \n  \n    short neg4 = neg1 >> 4; // -1  \n    bitset<16> bn4{neg4};      \n    cout << bn4 << endl;  // 1111111111111111  \n  \n    short neg5 = neg1 >> 5; // -1   \n    bitset<16> bn5{neg5};      \n    cout << bn5 << endl;  // 1111111111111111  \n}  \n```  \n  \n## Shifts and Promotions  \n The expressions on both sides of a shift operator must be integral types. Integral promotions are performed according to the rules described in [Standard Conversions](standard-conversions.md). The type of the result is the same as the type of the promoted `shift-expression`.  \n  \n In the following example, a variable of type `char` is promoted to an `int`.  \n  \n```cpp  \n#include <iostream>  \n#include <typeinfo>  \n  \nusing namespace std;  \n  \nint main() {  \n    char char1 = 'a';  \n  \n    auto promoted1 = char1 << 1;  // 194  \n    cout << typeid(promoted1).name() << endl;  // int  \n  \n    auto promoted2 = char1 << 10;  // 99328  \n    cout << typeid(promoted2).name() << endl;   // int  \n}  \n```  \n  \n## Additional Details  \n The result of a shift operation is undefined if `additive-expression` is negative or if `additive-expression` is greater than or equal to the number of bits in the (promoted) `shift-expression`. No shift operation is performed if `additive-expression` is 0.  \n  \n```cpp  \n#include <iostream>  \n#include <bitset>  \nusing namespace std;  \n  \nint main() {  \n    unsigned int int1 = 4;  \n    bitset<32> b1{int1};  \n    cout << b1 << endl;    // 00000000000000000000000000000100  \n  \n    unsigned int int2 = int1 << -3;  // C4293: '<<' : shift count negative or too big, undefined behavior  \n    unsigned int int3 = int1 >> -3;  // C4293: '>>' : shift count negative or too big, undefined behavior  \n  \n    unsigned int int4 = int1 << 32;  // C4293: '<<' : shift count negative or too big, undefined behavior  \n  \n    unsigned int int5 = int1 >> 32;  // C4293: '>>' : shift count negative or too big, undefined behavior  \n  \n    unsigned int int6 = int1 << 0;  \n    bitset<32> b6{int6};  \n    cout << b6 << endl;    // 00000000000000000000000000000100 (no change)}  \n}  \n```  \n  \n## Footnotes  \n 1 The following is the description of the shift operators in the C++ ISO specification (INCITS/ISO/IEC 14882-2011[2012]), sections 5.8.2 and 5.8.3.  \n  \n The value of `E1 << E2` is `E1` left-shifted `E2` bit positions; vacated bits are zero-filled. If `E1` has an unsigned type, the value of the result is `E1 × 2`<sup>E2</sup>, reduced modulo one more than the maximum value representable in the result type. Otherwise, if `E1` has a signed type and non-negative value, and `E1 × 2`<sup>E2</sup> is representable in the corresponding unsigned type of the result type, then that value, converted to the result type, is the resulting value; otherwise, the behavior is undefined.  \n  \n The value of `E1 >> E2` is `E1` right-shifted `E2` bit positions. If `E1` has an unsigned type or if `E1` has a signed type and a non-negative value, the value of the result is the integral part of the quotient of `E1/2`<sup>E2</sup>. If `E1` has a signed type and a negative value, the resulting value is implementation-defined.  \n  \n## See Also  \n [Expressions with Binary Operators](../cpp/expressions-with-binary-operators.md)   \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)"}