{"nodes":[{"pos":[12,40],"content":"align (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"align (C++) | Microsoft Docs","pos":[0,28]}]},{"content":"align (C++)","pos":[665,676]},{"content":"In Visual Studio 2015 and later, use the C++11 standard <ph id=\"ph1\">`alignas`</ph> specifier to control alignment.","pos":[677,774],"source":"In Visual Studio 2015 and later, use the C++11 standard `alignas` specifier to control alignment."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Alignment<ept id=\"p1\">](../cpp/alignment-cpp-declarations.md)</ept>.","pos":[775,851],"source":" For more information, see [Alignment](../cpp/alignment-cpp-declarations.md)."},{"content":"Microsoft Specific","pos":[860,878]},{"pos":[887,1036],"content":"Use <ph id=\"ph1\">`__declspec(align(#))`</ph> to precisely control the alignment of user-defined data (for example, static allocations or automatic data in a function).","source":"Use `__declspec(align(#))` to precisely control the alignment of user-defined data (for example, static allocations or automatic data in a function)."},{"content":"Syntax","pos":[1045,1051]},{"content":"Remarks","pos":[1113,1120]},{"content":"Writing applications that use the latest processor instructions introduces some new constraints and issues.","pos":[1124,1231]},{"content":"In particular, many new instructions require that data must be aligned to 16-byte boundaries.","pos":[1232,1325]},{"content":"Additionally, by aligning frequently used data to the cache line size of a specific processor, you improve cache performance.","pos":[1326,1451]},{"content":"For example, if you define a structure whose size is less than 32 bytes, you may want to align it to 32 bytes to make sure that objects of that structure type are efficiently cached.","pos":[1452,1634]},{"content":"is the alignment value.","pos":[1644,1667]},{"content":"Valid entries are integer powers of two from 1 to 8192 (bytes), such as 2, 4, 8, 16, 32, or 64.","pos":[1668,1763]},{"content":"is the data that you are declaring as aligned.","pos":[1777,1823]},{"content":"For information about how to return a value of type <ph id=\"ph1\">`size_t`</ph> that is the alignment requirement of the type, see <bpt id=\"p1\">[</bpt>__alignof<ept id=\"p1\">](../cpp/alignof-operator.md)</ept>.","pos":[1830,1982],"source":"For information about how to return a value of type `size_t` that is the alignment requirement of the type, see [__alignof](../cpp/alignof-operator.md)."},{"content":"For information about how to declare unaligned pointers when targeting 64-bit processors, see <bpt id=\"p1\">[</bpt>__unaligned<ept id=\"p1\">](../cpp/unaligned.md)</ept>.","pos":[1983,2112],"source":" For information about how to declare unaligned pointers when targeting 64-bit processors, see [__unaligned](../cpp/unaligned.md)."},{"pos":[2119,2234],"content":"You can use <ph id=\"ph1\">`__declspec(align(#))`</ph> when you define a <ph id=\"ph2\">`struct`</ph>, <ph id=\"ph3\">`union`</ph>, or <ph id=\"ph4\">`class`</ph>, or when you declare a variable.","source":"You can use `__declspec(align(#))` when you define a `struct`, `union`, or `class`, or when you declare a variable."},{"content":"The compiler does not guarantee or attempt to preserve the alignment attribute of data during a copy or data transform operation.","pos":[2241,2370]},{"content":"For example, <bpt id=\"p1\">[</bpt>memcpy<ept id=\"p1\">](../c-runtime-library/reference/memcpy-wmemcpy.md)</ept> can copy a struct declared with <ph id=\"ph1\">`__declspec(align(#))`</ph> to any location.","pos":[2371,2514],"source":" For example, [memcpy](../c-runtime-library/reference/memcpy-wmemcpy.md) can copy a struct declared with `__declspec(align(#))` to any location."},{"content":"Note that ordinary allocators—for example, <bpt id=\"p1\">[</bpt>malloc<ept id=\"p1\">](../c-runtime-library/reference/malloc.md)</ept>, C++ <bpt id=\"p2\">[</bpt>operator new<ept id=\"p2\">](new-operator-cpp.md)</ept>, and the Win32 allocators—return memory that is usually not sufficiently aligned for <ph id=\"ph1\">`__declspec(align(#))`</ph> structures or arrays of structures.","pos":[2515,2793],"source":" Note that ordinary allocators—for example, [malloc](../c-runtime-library/reference/malloc.md), C++ [operator new](new-operator-cpp.md), and the Win32 allocators—return memory that is usually not sufficiently aligned for `__declspec(align(#))` structures or arrays of structures."},{"content":"To guarantee that the destination of a copy or data transformation operation is correctly aligned, use <bpt id=\"p1\">[</bpt>_aligned_malloc<ept id=\"p1\">](../c-runtime-library/reference/aligned-malloc.md)</ept>, or write your own allocator.","pos":[2794,2994],"source":" To guarantee that the destination of a copy or data transformation operation is correctly aligned, use [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md), or write your own allocator."},{"content":"You cannot specify alignment for function parameters.","pos":[3001,3054]},{"content":"When data that has an alignment attribute is passed by value on the stack, its alignment is controlled by the calling convention.","pos":[3055,3184]},{"content":"If data alignment is important in the called function, copy the parameter into correctly aligned memory before use.","pos":[3185,3300]},{"content":"Without <ph id=\"ph1\">`__declspec(align(#))`</ph>, Visual C++ generally aligns data on natural boundaries based on the target processor and the size of the data, up to 4-byte boundaries on 32-bit processors, and 8-byte boundaries on 64-bit processors.","pos":[3307,3539],"source":"Without `__declspec(align(#))`, Visual C++ generally aligns data on natural boundaries based on the target processor and the size of the data, up to 4-byte boundaries on 32-bit processors, and 8-byte boundaries on 64-bit processors."},{"content":"Data in classes or structures is aligned in the class or structure at the minimum of its natural alignment and the current packing setting (from #pragma <ph id=\"ph1\">`pack`</ph> or the <bpt id=\"p1\">**</bpt>/Zp<ept id=\"p1\">**</ept> compiler option).","pos":[3540,3732],"source":" Data in classes or structures is aligned in the class or structure at the minimum of its natural alignment and the current packing setting (from #pragma `pack` or the **/Zp** compiler option)."},{"pos":[3739,3799],"content":"This example demonstrates the use of <ph id=\"ph1\">`__declspec(align(#))`</ph>:","source":"This example demonstrates the use of `__declspec(align(#))`:"},{"content":"This type now has a 32-byte alignment attribute.","pos":[3887,3935]},{"content":"This means that all static and automatic instances start on a 32-byte boundary.","pos":[3936,4015]},{"content":"Additional structure types declared with this type as a member preserve this type's alignment attribute, that is, any structure with <ph id=\"ph1\">`Str1`</ph> as an element will have an alignment attribute of at least 32.","pos":[4016,4218],"source":" Additional structure types declared with this type as a member preserve this type's alignment attribute, that is, any structure with `Str1` as an element will have an alignment attribute of at least 32."},{"content":"Note that <ph id=\"ph1\">`sizeof(struct Str1)`</ph> is equal to 32.","pos":[4225,4272],"source":"Note that `sizeof(struct Str1)` is equal to 32."},{"content":"This implies that if an array of Str1 objects is created, and the base of the array is 32-byte aligned, each member of the array is also 32-byte aligned.","pos":[4273,4426]},{"content":"To create an array whose base is correctly aligned in dynamic memory, use <bpt id=\"p1\">[</bpt>_aligned_malloc<ept id=\"p1\">](../c-runtime-library/reference/aligned-malloc.md)</ept>, or write your own allocator.","pos":[4427,4598],"source":" To create an array whose base is correctly aligned in dynamic memory, use [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md), or write your own allocator."},{"pos":[4605,4835],"content":"The <ph id=\"ph1\">`sizeof`</ph> value for any structure is the offset of the final member, plus that member's size, rounded up to the nearest multiple of the largest member alignment value or the whole structure alignment value, whichever is larger.","source":"The `sizeof` value for any structure is the offset of the final member, plus that member's size, rounded up to the nearest multiple of the largest member alignment value or the whole structure alignment value, whichever is larger."},{"content":"The compiler uses these rules for structure alignment:","pos":[4842,4896]},{"pos":[4906,5047],"content":"Unless overridden with <ph id=\"ph1\">`__declspec(align(#))`</ph>, the alignment of a scalar structure member is the minimum of its size and the current packing.","source":"Unless overridden with `__declspec(align(#))`, the alignment of a scalar structure member is the minimum of its size and the current packing."},{"pos":[5057,5194],"content":"Unless overridden with <ph id=\"ph1\">`__declspec(align(#))`</ph>, the alignment of a structure is the maximum of the individual alignments of its member(s).","source":"Unless overridden with `__declspec(align(#))`, the alignment of a structure is the maximum of the individual alignments of its member(s)."},{"content":"A structure member is placed at an offset from the start of its parent structure which is the smallest multiple of its alignment greater than or equal to the offset of the end of the previous member.","pos":[5204,5403]},{"content":"The size of a structure is the smallest multiple of its alignment greater than or equal to the offset of the end of its last member.","pos":[5413,5545]},{"pos":[5575,5616],"content":"can only increase alignment restrictions."},{"content":"For more information, see:","pos":[5623,5649]},{"content":"align Examples","pos":[5660,5674]},{"content":"Defining New Types with __declspec(align(#))","pos":[5707,5751]},{"content":"Aligning Data in Thread Local Storage","pos":[5792,5829]},{"content":"How align Works with Data Packing","pos":[5877,5910]},{"pos":[5957,6050],"content":"<bpt id=\"p1\">[</bpt>Examples of Structure Alignment<ept id=\"p1\">](../build/examples-of-structure-alignment.md)</ept> (x64 specific)","source":"[Examples of Structure Alignment](../build/examples-of-structure-alignment.md) (x64 specific)"},{"pos":[6094,6108],"content":"align Examples"},{"content":"The following examples show how <ph id=\"ph1\">`__declspec(align(#))`</ph> affects the size and alignment of data structures.","pos":[6112,6217],"source":"The following examples show how `__declspec(align(#))` affects the size and alignment of data structures."},{"content":"The examples assume the following definitions:","pos":[6218,6264]},{"content":"In this example, the <ph id=\"ph1\">`S1`</ph> structure is defined by using <ph id=\"ph2\">`__declspec(align(32))`</ph>.","pos":[6363,6443],"source":"In this example, the `S1` structure is defined by using `__declspec(align(32))`."},{"content":"All uses of <ph id=\"ph1\">`S1`</ph> for a variable definition or in other type declarations are 32-byte aligned.","pos":[6444,6537],"source":" All uses of `S1` for a variable definition or in other type declarations are 32-byte aligned."},{"content":"returns 32, and <ph id=\"ph1\">`S1`</ph> has 16 padding bytes following the 16 bytes required to hold the four integers.","pos":[6558,6658],"source":" returns 32, and `S1` has 16 padding bytes following the 16 bytes required to hold the four integers."},{"content":"Each <ph id=\"ph1\">`int`</ph> member requires 4-byte alignment, but the alignment of the structure itself is declared to be 32.","pos":[6659,6767],"source":" Each `int` member requires 4-byte alignment, but the alignment of the structure itself is declared to be 32."},{"content":"Therefore, the overall alignment is 32.","pos":[6768,6807]},{"pos":[6965,7142],"content":"In this example, <ph id=\"ph1\">`sizeof(struct S2)`</ph> returns 16, which is exactly the sum of the member sizes, because that is a multiple of the largest alignment requirement (a multiple of 8).","source":"In this example, `sizeof(struct S2)` returns 16, which is exactly the sum of the member sizes, because that is a multiple of the largest alignment requirement (a multiple of 8)."},{"pos":[7225,7282],"content":"In the following example, <ph id=\"ph1\">`sizeof(struct S3)`</ph> returns 64.","source":"In the following example, `sizeof(struct S3)` returns 64."},{"content":"In this example, notice that <ph id=\"ph1\">`a`</ph> has the alignment of its natural type, in this case, 4 bytes.","pos":[7542,7636],"source":"In this example, notice that `a` has the alignment of its natural type, in this case, 4 bytes."},{"content":"However, <ph id=\"ph1\">`S1`</ph> must be 32-byte aligned.","pos":[7637,7675],"source":" However, `S1` must be 32-byte aligned."},{"content":"Twenty-eight bytes of padding follow <ph id=\"ph1\">`a`</ph>, so that <ph id=\"ph2\">`s1`</ph> starts at offset 32.","pos":[7676,7751],"source":" Twenty-eight bytes of padding follow `a`, so that `s1` starts at offset 32."},{"content":"then inherits the alignment requirement of <ph id=\"ph1\">`S1`</ph>, because it is the largest alignment requirement in the structure.","pos":[7757,7871],"source":" then inherits the alignment requirement of `S1`, because it is the largest alignment requirement in the structure."},{"content":"returns 64.","pos":[7892,7903]},{"content":"The following three variable declarations also use <ph id=\"ph1\">`__declspec(align(#))`</ph>.","pos":[8055,8129],"source":"The following three variable declarations also use `__declspec(align(#))`."},{"content":"In each case, the variable must be 32-byte aligned.","pos":[8130,8181]},{"content":"In the case of the array, the base address of the array, not each array member, is 32-byte aligned.","pos":[8182,8281]},{"content":"The <ph id=\"ph1\">`sizeof`</ph> value for each array member is not affected when you use <ph id=\"ph2\">`__declspec(align(#))`</ph>.","pos":[8282,8375],"source":" The `sizeof` value for each array member is not affected when you use `__declspec(align(#))`."},{"content":"To align each member of an array, code such as this should be used:","pos":[8475,8542]},{"content":"In this example, notice that aligning the structure itself and aligning the first element have the same effect:","pos":[8624,8735]},{"pos":[8887,8959],"content":"and <ph id=\"ph1\">`S7`</ph> have identical alignment, allocation, and size characteristics.","source":" and `S7` have identical alignment, allocation, and size characteristics."},{"content":"In this example, the alignment of the starting addresses of a, b, c, and d are 4, 1, 4, and 1, respectively.","pos":[8966,9074]},{"content":"The alignment when memory is allocated on the heap depends on which allocation function is called.","pos":[9170,9268]},{"content":"For example, if you use <ph id=\"ph1\">`malloc`</ph>, the result depends on the operand size.","pos":[9270,9343],"source":"  For example, if you use `malloc`, the result depends on the operand size."},{"content":"If <bpt id=\"p1\">*</bpt>arg<ept id=\"p1\">*</ept> &gt;= 8, the memory returned is 8 byte aligned.","pos":[9344,9397],"source":" If *arg* >= 8, the memory returned is 8 byte aligned."},{"content":"If <bpt id=\"p1\">*</bpt>arg<ept id=\"p1\">*</ept> &lt; 8, the alignment of the memory returned is the first power of 2 less than <bpt id=\"p2\">*</bpt>arg<ept id=\"p2\">*</ept>.","pos":[9398,9489],"source":" If *arg* < 8, the alignment of the memory returned is the first power of 2 less than *arg*."},{"content":"For example, if you use malloc(7), the alignment is 4 bytes.","pos":[9490,9550]},{"pos":[9602,9646],"content":"Defining New Types with __declspec(align(#))"},{"content":"You can define a type with an alignment characteristic.","pos":[9650,9705]},{"pos":[9712,9784],"content":"For example, you can define a <ph id=\"ph1\">`struct`</ph> with an alignment value this way:","source":"For example, you can define a `struct` with an alignment value this way:"},{"pos":[9890,9997],"content":"Now, <ph id=\"ph1\">`aType`</ph> and <ph id=\"ph2\">`bType`</ph> are the same size (8 bytes) but variables of type <ph id=\"ph3\">`bType`</ph> will be 32-byte aligned.","source":"Now, `aType` and `bType` are the same size (8 bytes) but variables of type `bType` will be 32-byte aligned."},{"pos":[10056,10093],"content":"Aligning Data in Thread Local Storage"},{"content":"Static thread-local storage (TLS) created with the <ph id=\"ph1\">`__declspec(thread)`</ph> attribute and put in the TLS section in the image works for alignment exactly like normal static data.","pos":[10097,10271],"source":"Static thread-local storage (TLS) created with the `__declspec(thread)` attribute and put in the TLS section in the image works for alignment exactly like normal static data."},{"content":"To create TLS data, the operating system allocates memory the size of the TLS section and respects the TLS section alignment attribute.","pos":[10272,10407]},{"content":"This example shows various ways to place aligned data into thread local storage.","pos":[10414,10494]},{"pos":[10995,11028],"content":"How align Works with Data Packing"},{"content":"The <bpt id=\"p1\">**</bpt>/Zp<ept id=\"p1\">**</ept> compiler option and the <ph id=\"ph1\">`pack`</ph> pragma have the effect of packing data for structure and union members.","pos":[11032,11146],"source":"The **/Zp** compiler option and the `pack` pragma have the effect of packing data for structure and union members."},{"content":"This example shows how <bpt id=\"p1\">**</bpt>/Zp<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`__declspec(align(#))`</ph> work together:","pos":[11147,11219],"source":" This example shows how **/Zp** and `__declspec(align(#))` work together:"},{"pos":[11356,11492],"content":"The following table lists the offset of each member under a variety of <bpt id=\"p1\">**</bpt>/Zp<ept id=\"p1\">**</ept> (or #pragma <ph id=\"ph1\">`pack`</ph>) values, showing how the two interact.","source":"The following table lists the offset of each member under a variety of **/Zp** (or #pragma `pack`) values, showing how the two interact."},{"content":"Variable","pos":[11499,11507]},{"content":"/Zp1","pos":[11508,11512]},{"content":"/Zp2","pos":[11513,11517]},{"content":"/Zp4","pos":[11518,11522]},{"content":"/Zp8","pos":[11523,11527]},{"content":"a","pos":[11599,11600]},{"content":"0","pos":[11601,11602]},{"content":"0","pos":[11603,11604]},{"content":"0","pos":[11605,11606]},{"content":"0","pos":[11607,11608]},{"content":"b","pos":[11613,11614]},{"content":"1","pos":[11615,11616]},{"content":"2","pos":[11617,11618]},{"content":"2","pos":[11619,11620]},{"content":"2","pos":[11621,11622]},{"content":"c","pos":[11627,11628]},{"content":"3","pos":[11629,11630]},{"content":"4","pos":[11631,11632]},{"content":"4","pos":[11633,11634]},{"content":"8","pos":[11635,11636]},{"content":"d","pos":[11641,11642]},{"content":"32","pos":[11643,11645]},{"content":"32","pos":[11646,11648]},{"content":"32","pos":[11649,11651]},{"content":"32","pos":[11652,11654]},{"content":"e","pos":[11659,11660]},{"content":"40","pos":[11661,11663]},{"content":"40","pos":[11664,11666]},{"content":"40","pos":[11667,11669]},{"content":"40","pos":[11670,11672]},{"content":"f","pos":[11677,11678]},{"content":"41","pos":[11679,11681]},{"content":"42","pos":[11682,11684]},{"content":"44","pos":[11685,11687]},{"content":"48","pos":[11688,11690]},{"content":"sizeof(S)","pos":[11695,11704]},{"content":"64","pos":[11705,11707]},{"content":"64","pos":[11708,11710]},{"content":"64","pos":[11711,11713]},{"content":"64","pos":[11714,11716]},{"pos":[11724,11832],"content":"For more information, see <bpt id=\"p1\">[</bpt>/Zp (Struct Member Alignment)<ept id=\"p1\">](../build/reference/zp-struct-member-alignment.md)</ept>.","source":"For more information, see [/Zp (Struct Member Alignment)](../build/reference/zp-struct-member-alignment.md)."},{"pos":[11839,12126],"content":"The offset of an object is based on the offset of the previous object and the current packing setting, unless the object has a <ph id=\"ph1\">`__declspec(align(#))`</ph> attribute, in which case the alignment is based on the offset of the previous object and the <ph id=\"ph2\">`__declspec(align(#))`</ph> value for the object.","source":"The offset of an object is based on the offset of the previous object and the current packing setting, unless the object has a `__declspec(align(#))` attribute, in which case the alignment is based on the offset of the previous object and the `__declspec(align(#))` value for the object."},{"content":"END Microsoft Specific","pos":[12136,12158]},{"content":"See Also","pos":[12167,12175]},{"content":"__declspec","pos":[12180,12190]},{"content":"Overview of ARM ABI Conventions","pos":[12217,12248]},{"content":"Overview of x64 Calling Conventions","pos":[12300,12335]}],"content":"---\ntitle: \"align (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"align\"\n  - \"align_cpp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"align __declspec keyword\"\n  - \"__declspec keyword [C++], align\"\nms.assetid: 9cb63f58-658b-4425-ac47-af8eabfc5878\ncaps.latest.revision: 22\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# align (C++)\nIn Visual Studio 2015 and later, use the C++11 standard `alignas` specifier to control alignment. For more information, see [Alignment](../cpp/alignment-cpp-declarations.md).  \n  \n **Microsoft Specific**  \n  \n Use `__declspec(align(#))` to precisely control the alignment of user-defined data (for example, static allocations or automatic data in a function).  \n  \n## Syntax  \n  \n```  \n__declspec( align( # ) ) declarator  \n```  \n  \n## Remarks  \n Writing applications that use the latest processor instructions introduces some new constraints and issues. In particular, many new instructions require that data must be aligned to 16-byte boundaries. Additionally, by aligning frequently used data to the cache line size of a specific processor, you improve cache performance. For example, if you define a structure whose size is less than 32 bytes, you may want to align it to 32 bytes to make sure that objects of that structure type are efficiently cached.  \n  \n \\# is the alignment value. Valid entries are integer powers of two from 1 to 8192 (bytes), such as 2, 4, 8, 16, 32, or 64. `declarator` is the data that you are declaring as aligned.  \n  \n For information about how to return a value of type `size_t` that is the alignment requirement of the type, see [__alignof](../cpp/alignof-operator.md). For information about how to declare unaligned pointers when targeting 64-bit processors, see [__unaligned](../cpp/unaligned.md).  \n  \n You can use `__declspec(align(#))` when you define a `struct`, `union`, or `class`, or when you declare a variable.  \n  \n The compiler does not guarantee or attempt to preserve the alignment attribute of data during a copy or data transform operation. For example, [memcpy](../c-runtime-library/reference/memcpy-wmemcpy.md) can copy a struct declared with `__declspec(align(#))` to any location. Note that ordinary allocators—for example, [malloc](../c-runtime-library/reference/malloc.md), C++ [operator new](new-operator-cpp.md), and the Win32 allocators—return memory that is usually not sufficiently aligned for `__declspec(align(#))` structures or arrays of structures. To guarantee that the destination of a copy or data transformation operation is correctly aligned, use [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md), or write your own allocator.  \n  \n You cannot specify alignment for function parameters. When data that has an alignment attribute is passed by value on the stack, its alignment is controlled by the calling convention. If data alignment is important in the called function, copy the parameter into correctly aligned memory before use.  \n  \n Without `__declspec(align(#))`, Visual C++ generally aligns data on natural boundaries based on the target processor and the size of the data, up to 4-byte boundaries on 32-bit processors, and 8-byte boundaries on 64-bit processors. Data in classes or structures is aligned in the class or structure at the minimum of its natural alignment and the current packing setting (from #pragma `pack` or the **/Zp** compiler option).  \n  \n This example demonstrates the use of `__declspec(align(#))`:  \n  \n```  \n__declspec(align(32)) struct Str1{  \n   int a, b, c, d, e;  \n};  \n```  \n  \n This type now has a 32-byte alignment attribute. This means that all static and automatic instances start on a 32-byte boundary. Additional structure types declared with this type as a member preserve this type's alignment attribute, that is, any structure with `Str1` as an element will have an alignment attribute of at least 32.  \n  \n Note that `sizeof(struct Str1)` is equal to 32. This implies that if an array of Str1 objects is created, and the base of the array is 32-byte aligned, each member of the array is also 32-byte aligned. To create an array whose base is correctly aligned in dynamic memory, use [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md), or write your own allocator.  \n  \n The `sizeof` value for any structure is the offset of the final member, plus that member's size, rounded up to the nearest multiple of the largest member alignment value or the whole structure alignment value, whichever is larger.  \n  \n The compiler uses these rules for structure alignment:  \n  \n-   Unless overridden with `__declspec(align(#))`, the alignment of a scalar structure member is the minimum of its size and the current packing.  \n  \n-   Unless overridden with `__declspec(align(#))`, the alignment of a structure is the maximum of the individual alignments of its member(s).  \n  \n-   A structure member is placed at an offset from the start of its parent structure which is the smallest multiple of its alignment greater than or equal to the offset of the end of the previous member.  \n  \n-   The size of a structure is the smallest multiple of its alignment greater than or equal to the offset of the end of its last member.  \n  \n `__declspec(align(#))` can only increase alignment restrictions.  \n  \n For more information, see:  \n  \n-   [align Examples](#vclrfalignexamples)  \n  \n-   [Defining New Types with __declspec(align(#))](#vclrf_declspecaligntypedef)  \n  \n-   [Aligning Data in Thread Local Storage](#vclrfthreadlocalstorageallocation)  \n  \n-   [How align Works with Data Packing](#vclrfhowalignworkswithdatapacking)  \n  \n-   [Examples of Structure Alignment](../build/examples-of-structure-alignment.md) (x64 specific)  \n  \n##  <a name=\"vclrfalignexamples\"></a> align Examples  \n The following examples show how `__declspec(align(#))` affects the size and alignment of data structures. The examples assume the following definitions:  \n  \n```  \n#define CACHE_LINE  32  \n#define CACHE_ALIGN __declspec(align(CACHE_LINE))  \n```  \n  \n In this example, the `S1` structure is defined by using `__declspec(align(32))`. All uses of `S1` for a variable definition or in other type declarations are 32-byte aligned. `sizeof(struct S1)` returns 32, and `S1` has 16 padding bytes following the 16 bytes required to hold the four integers. Each `int` member requires 4-byte alignment, but the alignment of the structure itself is declared to be 32. Therefore, the overall alignment is 32.  \n  \n```  \nstruct CACHE_ALIGN S1 { // cache align all instances of S1  \n   int a, b, c, d;  \n};  \nstruct S1 s1;   // s1 is 32-byte cache aligned  \n```  \n  \n In this example, `sizeof(struct S2)` returns 16, which is exactly the sum of the member sizes, because that is a multiple of the largest alignment requirement (a multiple of 8).  \n  \n```  \n__declspec(align(8)) struct S2 {  \n   int a, b, c, d;  \n};  \n```  \n  \n In the following example, `sizeof(struct S3)` returns 64.  \n  \n```  \nstruct S3 {  \n   struct S1 s1;   // S3 inherits cache alignment requirement  \n                  // from S1 declaration  \n   int a;         // a is now cache aligned because of s1  \n                  // 28 bytes of trailing padding  \n};  \n```  \n  \n In this example, notice that `a` has the alignment of its natural type, in this case, 4 bytes. However, `S1` must be 32-byte aligned. Twenty-eight bytes of padding follow `a`, so that `s1` starts at offset 32. `S4` then inherits the alignment requirement of `S1`, because it is the largest alignment requirement in the structure. `sizeof(struct S4)` returns 64.  \n  \n```  \nstruct S4 {  \n   int a;  \n   // 28 bytes padding  \n    struct S1 s1;      // S4 inherits cache alignment requirement of S1  \n};  \n```  \n  \n The following three variable declarations also use `__declspec(align(#))`. In each case, the variable must be 32-byte aligned. In the case of the array, the base address of the array, not each array member, is 32-byte aligned. The `sizeof` value for each array member is not affected when you use `__declspec(align(#))`.  \n  \n```  \nCACHE_ALIGN int i;  \nCACHE_ALIGN int array[128];  \nCACHE_ALIGN struct s2 s;  \n```  \n  \n To align each member of an array, code such as this should be used:  \n  \n```  \ntypedef CACHE_ALIGN struct { int a; } S5;  \nS5 array[10];  \n```  \n  \n In this example, notice that aligning the structure itself and aligning the first element have the same effect:  \n  \n```  \nCACHE_ALIGN struct S6 {  \n   int a;  \n   int b;  \n};  \n  \nstruct S7 {  \n   CACHE_ALIGN int a;  \n               int b;  \n};  \n```  \n  \n `S6` and `S7` have identical alignment, allocation, and size characteristics.  \n  \n In this example, the alignment of the starting addresses of a, b, c, and d are 4, 1, 4, and 1, respectively.  \n  \n```  \nvoid fn() {   \n   int a;  \n   char b;  \n   long c;  \n   char d[10]  \n}   \n```  \n  \n The alignment when memory is allocated on the heap depends on which allocation function is called.  For example, if you use `malloc`, the result depends on the operand size. If *arg* >= 8, the memory returned is 8 byte aligned. If *arg* < 8, the alignment of the memory returned is the first power of 2 less than *arg*. For example, if you use malloc(7), the alignment is 4 bytes.  \n  \n##  <a name=\"vclrf_declspecaligntypedef\"></a> Defining New Types with __declspec(align(#))  \n You can define a type with an alignment characteristic.  \n  \n For example, you can define a `struct` with an alignment value this way:  \n  \n```  \nstruct aType {int a; int b;};  \ntypedef __declspec(align(32)) struct aType bType;  \n```  \n  \n Now, `aType` and `bType` are the same size (8 bytes) but variables of type `bType` will be 32-byte aligned.  \n  \n##  <a name=\"vclrfthreadlocalstorageallocation\"></a> Aligning Data in Thread Local Storage  \n Static thread-local storage (TLS) created with the `__declspec(thread)` attribute and put in the TLS section in the image works for alignment exactly like normal static data. To create TLS data, the operating system allocates memory the size of the TLS section and respects the TLS section alignment attribute.  \n  \n This example shows various ways to place aligned data into thread local storage.  \n  \n```  \n// put an aligned integer in TLS  \n__declspec(thread) __declspec(align(32)) int a;     \n  \n// define an aligned structure and put a variable of the struct type  \n// into TLS  \n__declspec(thread) __declspec(align(32)) struct F1 { int a; int b; } a;  \n  \n// create an aligned structure   \nstruct CACHE_ALIGN S9 {  \n   int a;  \n   int b;  \n};  \n// put a variable of the structure type into TLS  \n__declspec(thread) struct S9 a;  \n```  \n  \n##  <a name=\"vclrfhowalignworkswithdatapacking\"></a> How align Works with Data Packing  \n The **/Zp** compiler option and the `pack` pragma have the effect of packing data for structure and union members. This example shows how **/Zp** and `__declspec(align(#))` work together:  \n  \n```  \nstruct S {  \n   char a;  \n   short b;  \n   double c;  \n   CACHE_ALIGN double d;  \n   char e;  \n   double f;  \n};  \n```  \n  \n The following table lists the offset of each member under a variety of **/Zp** (or #pragma `pack`) values, showing how the two interact.  \n  \n|Variable|/Zp1|/Zp2|/Zp4|/Zp8|  \n|--------------|-----------|-----------|-----------|-----------|  \n|a|0|0|0|0|  \n|b|1|2|2|2|  \n|c|3|4|4|8|  \n|d|32|32|32|32|  \n|e|40|40|40|40|  \n|f|41|42|44|48|  \n|sizeof(S)|64|64|64|64|  \n  \n For more information, see [/Zp (Struct Member Alignment)](../build/reference/zp-struct-member-alignment.md).  \n  \n The offset of an object is based on the offset of the previous object and the current packing setting, unless the object has a `__declspec(align(#))` attribute, in which case the alignment is based on the offset of the previous object and the `__declspec(align(#))` value for the object.  \n  \n### END Microsoft Specific  \n  \n## See Also  \n [__declspec](../cpp/declspec.md)   \n [Overview of ARM ABI Conventions](../build/overview-of-arm-abi-conventions.md)   \n [Overview of x64 Calling Conventions](../build/overview-of-x64-calling-conventions.md)"}