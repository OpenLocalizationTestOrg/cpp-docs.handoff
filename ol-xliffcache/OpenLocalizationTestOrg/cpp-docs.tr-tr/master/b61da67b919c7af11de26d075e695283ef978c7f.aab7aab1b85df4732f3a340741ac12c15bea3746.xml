{"nodes":[{"pos":[12,46],"content":"pin_ptr (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"pin_ptr (C++-CLI) | Microsoft Docs","pos":[0,34]}]},{"content":"pin_ptr (C++/CLI)","pos":[689,706]},{"pos":[707,789],"content":"Declares a <bpt id=\"p1\">*</bpt>pinning pointer<ept id=\"p1\">*</ept>, which is used only with the common language runtime.","source":"Declares a *pinning pointer*, which is used only with the common language runtime."},{"content":"All Runtimes","pos":[798,810]},{"content":"(There are no remarks for this language feature that apply to all runtimes.)","pos":[814,890]},{"content":"Windows Runtime","pos":[899,914]},{"content":"(This language feature is not supported in the Windows Runtime.)","pos":[918,982]},{"content":"Common Language Runtime","pos":[991,1014]},{"content":"A <bpt id=\"p1\">*</bpt>pinning pointer<ept id=\"p1\">*</ept> is an interior pointer that prevents the object pointed to from moving on the garbage-collected heap.","pos":[1018,1139],"source":"A *pinning pointer* is an interior pointer that prevents the object pointed to from moving on the garbage-collected heap."},{"content":"That is, the value of a pinning pointer is not changed by the common language runtime.","pos":[1140,1226]},{"content":"This is required when you pass the address of a managed class to an unmanaged function so that the address will not change unexpectedly during resolution of the unmanaged function call.","pos":[1227,1412]},{"content":"Syntax","pos":[1422,1428]},{"content":"Parameters","pos":[1510,1520]},{"content":"cv_qualifier","pos":[1525,1537]},{"content":"or <ph id=\"ph1\">`volatile`</ph> qualifiers.","pos":[1550,1575],"source":" or `volatile` qualifiers."},{"content":"By default, a pinning pointer is <ph id=\"ph1\">`volatile`</ph>.","pos":[1576,1620],"source":" By default, a pinning pointer is `volatile`."},{"content":"It is redundant but not an error to declare a pinning pointer <ph id=\"ph1\">`volatile`</ph>.","pos":[1621,1694],"source":" It is redundant but not an error to declare a pinning pointer `volatile`."},{"content":"type","pos":[1702,1706]},{"content":"The type of <ph id=\"ph1\">`initializer`</ph>.","pos":[1711,1737],"source":" The type of `initializer`."},{"content":"var","pos":[1745,1748]},{"content":"The name of the <ph id=\"ph1\">`pin_ptr`</ph> variable.","pos":[1753,1788],"source":" The name of the `pin_ptr` variable."},{"content":"initializer","pos":[1796,1807]},{"content":"A member of a reference type, element of a managed array, or any other object that you can assign to a native pointer.","pos":[1812,1930]},{"content":"Remarks","pos":[1940,1947]},{"content":"A <ph id=\"ph1\">`pin_ptr`</ph> represents a superset of the functionality of a native pointer.","pos":[1951,2026],"source":"A `pin_ptr` represents a superset of the functionality of a native pointer."},{"content":"Therefore, anything that can be assigned to a native pointer can also be assigned to a <ph id=\"ph1\">`pin_ptr`</ph>.","pos":[2027,2124],"source":" Therefore, anything that can be assigned to a native pointer can also be assigned to a `pin_ptr`."},{"content":"An interior pointer is permitted to perform the same set of operations as native pointers, including comparison and pointer arithmetic.","pos":[2125,2260]},{"content":"An object or sub-object of a managed class can be pinned, in which case the common language runtime will not move it during garbage collection.","pos":[2267,2410]},{"content":"The principal use of this is to pass a pointer to managed data as an actual parameter of an unmanaged function call.","pos":[2411,2527]},{"content":"During a collection cycle, the runtime will inspect the metadata created for the pinning pointer and will not move the item it points to.","pos":[2528,2665]},{"content":"Pinning an object also pins its value fields; that is, fields of primitive or value type.","pos":[2672,2761]},{"content":"However, fields declared by tracking handle (<ph id=\"ph1\">`%`</ph>) are not pinned.","pos":[2762,2827],"source":" However, fields declared by tracking handle (`%`) are not pinned."},{"content":"Pinning a sub-object defined in a managed object has the effect of pinning the whole object.","pos":[2834,2926]},{"content":"If the pinning pointer is reassigned to point to a new value, the previous instance pointed to is no longer considered pinned.","pos":[2933,3059]},{"content":"An object is pinned only while a <ph id=\"ph1\">`pin_ptr`</ph> points to it.","pos":[3066,3122],"source":"An object is pinned only while a `pin_ptr` points to it."},{"content":"The object is no longer pinned when its pinning pointer goes out of scope, or is set to <bpt id=\"p1\">[</bpt>nullptr<ept id=\"p1\">](../windows/nullptr-cpp-component-extensions.md)</ept>.","pos":[3123,3269],"source":" The object is no longer pinned when its pinning pointer goes out of scope, or is set to [nullptr](../windows/nullptr-cpp-component-extensions.md)."},{"content":"After the <ph id=\"ph1\">`pin_ptr`</ph> goes out of scope, the object that was pinned can be moved in the heap by the garbage collector.","pos":[3270,3386],"source":" After the `pin_ptr` goes out of scope, the object that was pinned can be moved in the heap by the garbage collector."},{"content":"Any native pointers that still point to the object will not be updated, and de-referencing one of them could raise an unrecoverable exception.","pos":[3387,3529]},{"pos":[3536,3782],"content":"If no pinning pointers point to the object (all pinning pointers went out of scope, were reassigned to point to other objects, or were assigned <bpt id=\"p1\">[</bpt>nullptr<ept id=\"p1\">](../windows/nullptr-cpp-component-extensions.md)</ept>), the object is guaranteed not to be pinned.","source":"If no pinning pointers point to the object (all pinning pointers went out of scope, were reassigned to point to other objects, or were assigned [nullptr](../windows/nullptr-cpp-component-extensions.md)), the object is guaranteed not to be pinned."},{"content":"A pinning pointer can point to a reference handle, value type or boxed type handle, member of a managed type, or an element of a managed array.","pos":[3789,3932]},{"content":"It cannot point to a reference type.","pos":[3933,3969]},{"pos":[3976,4067],"content":"Taking the address of a <ph id=\"ph1\">`pin_ptr`</ph> that points to a native object causes undefined behavior.","source":"Taking the address of a `pin_ptr` that points to a native object causes undefined behavior."},{"content":"Pinning pointers can only be declared as non-static local variables on the stack.","pos":[4074,4155]},{"content":"Pinning pointers cannot be used as:","pos":[4162,4197]},{"content":"function parameters","pos":[4207,4226]},{"content":"the return type of a function","pos":[4236,4265]},{"content":"a member of a class","pos":[4275,4294]},{"content":"the target type of a cast.","pos":[4304,4330]},{"content":"is in the <ph id=\"ph1\">`cli`</ph> namespace.","pos":[4347,4373],"source":" is in the `cli` namespace."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform, default, and cli Namespaces<ept id=\"p1\">](../windows/platform-default-and-cli-namespaces-cpp-component-extensions.md)</ept>.","pos":[4374,4516],"source":" For more information, see [Platform, default, and cli Namespaces](../windows/platform-default-and-cli-namespaces-cpp-component-extensions.md)."},{"pos":[4523,4634],"content":"For more information about interior pointers, see <bpt id=\"p1\">[</bpt>interior_ptr (C++/CLI)<ept id=\"p1\">](../windows/interior-ptr-cpp-cli.md)</ept>.","source":"For more information about interior pointers, see [interior_ptr (C++/CLI)](../windows/interior-ptr-cpp-cli.md)."},{"pos":[4641,4888],"content":"For more information about pinning pointers, see <bpt id=\"p1\">[</bpt>How to: Pin Pointers and Arrays<ept id=\"p1\">](../windows/how-to-pin-pointers-and-arrays.md)</ept> and <bpt id=\"p2\">[</bpt>How to: Declare Pinning Pointers and Value Types<ept id=\"p2\">](../windows/how-to-declare-pinning-pointers-and-value-types.md)</ept>.","source":"For more information about pinning pointers, see [How to: Pin Pointers and Arrays](../windows/how-to-pin-pointers-and-arrays.md) and [How to: Declare Pinning Pointers and Value Types](../windows/how-to-declare-pinning-pointers-and-value-types.md)."},{"content":"Requirements","pos":[4898,4910]},{"pos":[4914,4939],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[4949,4957]},{"content":"Example","pos":[4963,4970]},{"pos":[4979,5075],"content":"The following example uses <ph id=\"ph1\">`pin_ptr`</ph> to constrain the position of the first element of an array.","source":"The following example uses `pin_ptr` to constrain the position of the first element of an array."},{"content":"Output","pos":[6033,6039]},{"content":"Example","pos":[6076,6083]},{"pos":[6092,6305],"content":"The following example shows that an interior pointer can be converted to a pinning pointer, and that the return type of the address-of operator (<ph id=\"ph1\">`&amp;`</ph>) is an interior pointer when the operand is on the managed heap.","source":"The following example shows that an interior pointer can be converted to a pinning pointer, and that the return type of the address-of operator (`&`) is an interior pointer when the operand is on the managed heap."},{"content":"Output","pos":[6809,6815]},{"content":"Example","pos":[6851,6858]},{"content":"The following example shows that a pinning pointer can be cast to another type.","pos":[6867,6946]},{"content":"Output","pos":[7319,7325]}],"content":"---\ntitle: \"pin_ptr (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"pin_ptr_cpp\"\n  - \"stdcli::language::pin_ptr\"\n  - \"pin_ptr\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"pinning pointers\"\n  - \"pin_ptr keyword [C++]\"\nms.assetid: 6c2e6c73-4ec2-4dce-8e1f-ccf3a9f9d0aa\ncaps.latest.revision: 28\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# pin_ptr (C++/CLI)\nDeclares a *pinning pointer*, which is used only with the common language runtime.  \n  \n## All Runtimes  \n (There are no remarks for this language feature that apply to all runtimes.)  \n  \n## Windows Runtime  \n (This language feature is not supported in the Windows Runtime.)  \n  \n## Common Language Runtime  \n A *pinning pointer* is an interior pointer that prevents the object pointed to from moving on the garbage-collected heap. That is, the value of a pinning pointer is not changed by the common language runtime. This is required when you pass the address of a managed class to an unmanaged function so that the address will not change unexpectedly during resolution of the unmanaged function call.  \n  \n### Syntax  \n  \n```cpp  \n[cli::]pin_ptr<cv_qualifiertype>var = &initializer;  \n```  \n  \n### Parameters  \n *cv_qualifier*  \n `const` or `volatile` qualifiers. By default, a pinning pointer is `volatile`. It is redundant but not an error to declare a pinning pointer `volatile`.  \n  \n *type*  \n The type of `initializer`.  \n  \n *var*  \n The name of the `pin_ptr` variable.  \n  \n *initializer*  \n A member of a reference type, element of a managed array, or any other object that you can assign to a native pointer.  \n  \n### Remarks  \n A `pin_ptr` represents a superset of the functionality of a native pointer. Therefore, anything that can be assigned to a native pointer can also be assigned to a `pin_ptr`. An interior pointer is permitted to perform the same set of operations as native pointers, including comparison and pointer arithmetic.  \n  \n An object or sub-object of a managed class can be pinned, in which case the common language runtime will not move it during garbage collection. The principal use of this is to pass a pointer to managed data as an actual parameter of an unmanaged function call. During a collection cycle, the runtime will inspect the metadata created for the pinning pointer and will not move the item it points to.  \n  \n Pinning an object also pins its value fields; that is, fields of primitive or value type. However, fields declared by tracking handle (`%`) are not pinned.  \n  \n Pinning a sub-object defined in a managed object has the effect of pinning the whole object.  \n  \n If the pinning pointer is reassigned to point to a new value, the previous instance pointed to is no longer considered pinned.  \n  \n An object is pinned only while a `pin_ptr` points to it. The object is no longer pinned when its pinning pointer goes out of scope, or is set to [nullptr](../windows/nullptr-cpp-component-extensions.md). After the `pin_ptr` goes out of scope, the object that was pinned can be moved in the heap by the garbage collector. Any native pointers that still point to the object will not be updated, and de-referencing one of them could raise an unrecoverable exception.  \n  \n If no pinning pointers point to the object (all pinning pointers went out of scope, were reassigned to point to other objects, or were assigned [nullptr](../windows/nullptr-cpp-component-extensions.md)), the object is guaranteed not to be pinned.  \n  \n A pinning pointer can point to a reference handle, value type or boxed type handle, member of a managed type, or an element of a managed array. It cannot point to a reference type.  \n  \n Taking the address of a `pin_ptr` that points to a native object causes undefined behavior.  \n  \n Pinning pointers can only be declared as non-static local variables on the stack.  \n  \n Pinning pointers cannot be used as:  \n  \n-   function parameters  \n  \n-   the return type of a function  \n  \n-   a member of a class  \n  \n-   the target type of a cast.  \n  \n `pin_ptr` is in the `cli` namespace. For more information, see [Platform, default, and cli Namespaces](../windows/platform-default-and-cli-namespaces-cpp-component-extensions.md).  \n  \n For more information about interior pointers, see [interior_ptr (C++/CLI)](../windows/interior-ptr-cpp-cli.md).  \n  \n For more information about pinning pointers, see [How to: Pin Pointers and Arrays](../windows/how-to-pin-pointers-and-arrays.md) and [How to: Declare Pinning Pointers and Value Types](../windows/how-to-declare-pinning-pointers-and-value-types.md).  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n The following example uses `pin_ptr` to constrain the position of the first element of an array.  \n  \n```  \n// pin_ptr_1.cpp  \n// compile with: /clr   \nusing namespace System;  \n#define SIZE 10  \n  \n#pragma unmanaged  \n// native function that initializes an array  \nvoid native_function(int* p) {  \n   for(int i = 0 ; i < 10 ; i++)  \n    p[i] = i;  \n}  \n#pragma managed  \n  \npublic ref class A {  \nprivate:  \n   array<int>^ arr;   // CLR integer array  \n  \npublic:  \n   A() {  \n      arr = gcnew array<int>(SIZE);  \n   }  \n  \n   void load() {  \n   pin_ptr<int> p = &arr[0];   // pin pointer to first element in arr  \n   int* np = p;   // pointer to the first element in arr  \n   native_function(np);   // pass pointer to native function  \n   }  \n  \n   int sum() {  \n      int total = 0;  \n      for (int i = 0 ; i < SIZE ; i++)  \n         total += arr[i];  \n      return total;  \n   }  \n};  \n  \nint main() {  \n   A^ a = gcnew A;  \n   a->load();   // initialize managed array using the native function  \n   Console::WriteLine(a->sum());  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n45  \n```  \n  \n **Example**  \n  \n The following example shows that an interior pointer can be converted to a pinning pointer, and that the return type of the address-of operator (`&`) is an interior pointer when the operand is on the managed heap.  \n  \n```  \n// pin_ptr_2.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref struct G {  \n   G() : i(1) {}  \n   int i;  \n};  \n  \nref struct H {  \n   H() : j(2) {}  \n   int j;  \n};  \n  \nint main() {  \n   G ^ g = gcnew G;   // g is a whole reference object pointer  \n   H ^ h = gcnew H;  \n  \n   interior_ptr<int> l = &(g->i);   // l is interior pointer  \n  \n   pin_ptr<int> k = &(h->j);   // k is a pinning interior pointer  \n  \n   k = l;   // ok  \n   Console::WriteLine(*k);  \n};  \n```  \n  \n **Output**  \n  \n```Output  \n1  \n```  \n  \n **Example**  \n  \n The following example shows that a pinning pointer can be cast to another type.  \n  \n```  \n// pin_ptr_3.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref class ManagedType {  \npublic:  \n   int i;  \n};  \n  \nint main() {  \n   ManagedType ^mt = gcnew ManagedType;  \n   pin_ptr< int > pt = &mt->i;  \n   *pt = 8;  \n   Console::WriteLine(mt->i);  \n  \n   char *pc = ( char* ) pt;  \n   *pc = 255;  \n   Console::WriteLine(mt->i);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n8  \n255  \n```"}