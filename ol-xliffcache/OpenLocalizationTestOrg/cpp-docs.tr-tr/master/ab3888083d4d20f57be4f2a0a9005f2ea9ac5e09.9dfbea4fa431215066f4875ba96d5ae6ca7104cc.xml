{"nodes":[{"pos":[12,52],"content":"ATL Copy Policy Classes | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"ATL Copy Policy Classes | Microsoft Docs","pos":[0,40]}]},{"content":"ATL Copy Policy Classes","pos":[713,736]},{"content":"Copy policy classes are <bpt id=\"p1\">[</bpt>utility classes<ept id=\"p1\">](../atl/utility-classes.md)</ept> used to initialize, copy, and delete data.","pos":[737,848],"source":"Copy policy classes are [utility classes](../atl/utility-classes.md) used to initialize, copy, and delete data."},{"content":"Copy policy classes allow you to define copy semantics for any type of data, and to define conversions between different data types.","pos":[849,981]},{"content":"ATL uses copy policy classes in its implementations of the following templates:","pos":[988,1067]},{"content":"CComEnumImpl","pos":[1078,1090]},{"content":"IEnumOnSTLImpl","pos":[1142,1156]},{"content":"ICollectionOnSTLImpl","pos":[1210,1230]},{"content":"By encapsulating the information needed to copy or convert data in a copy policy class that can be passed as a template argument, the ATL developers have provided for extreme reusability of these classes.","pos":[1286,1490]},{"content":"For example, if you need to implement a collection using any arbitrary data type, all you need to provide is the appropriate copy policy; you never have to touch the code that implements the collection.","pos":[1491,1693]},{"content":"Definition","pos":[1702,1712]},{"content":"By definition, a class that provides the following static functions is a copy policy class:","pos":[1716,1807]},{"pos":[2009,2117],"content":"You can replace the types <ph id=\"ph1\">`DestinationType`</ph> and <bpt id=\"p1\">*</bpt>SourceType<ept id=\"p1\">*</ept> with arbitrary data types for each copy policy.","source":"You can replace the types `DestinationType` and *SourceType* with arbitrary data types for each copy policy."},{"pos":[2125,2469],"content":"[!NOTE]\n Although you can define copy policy classes for any arbitrary data types, use of the classes in ATL code should limit the types that make sense. For example, when using a copy policy class with ATL's collection or enumerator implementations, `DestinationType` must be a type that can be used as a parameter in a COM interface method.","leadings":["","> "],"nodes":[{"content":" Although you can define copy policy classes for any arbitrary data types, use of the classes in ATL code should limit the types that make sense. For example, when using a copy policy class with ATL's collection or enumerator implementations, `DestinationType` must be a type that can be used as a parameter in a COM interface method.","pos":[8,342],"nodes":[{"content":"Although you can define copy policy classes for any arbitrary data types, use of the classes in ATL code should limit the types that make sense.","pos":[1,145]},{"content":"For example, when using a copy policy class with ATL's collection or enumerator implementations, <ph id=\"ph1\">`DestinationType`</ph> must be a type that can be used as a parameter in a COM interface method.","pos":[146,334],"source":" For example, when using a copy policy class with ATL's collection or enumerator implementations, `DestinationType` must be a type that can be used as a parameter in a COM interface method."}]}]},{"content":"Use <bpt id=\"p1\">**</bpt>init<ept id=\"p1\">**</ept> to initialize data, <bpt id=\"p2\">**</bpt>copy<ept id=\"p2\">**</ept> to copy data, and <bpt id=\"p3\">**</bpt>destroy<ept id=\"p3\">**</ept> to free the data.","pos":[2476,2565],"source":"Use **init** to initialize data, **copy** to copy data, and **destroy** to free the data."},{"content":"The precise meaning of initialization, copying, and destruction are the domain of the copy policy class and will vary depending on the data types involved.","pos":[2566,2721]},{"content":"There are two requirements on the use and implementation of a copy policy class:","pos":[2728,2808]},{"pos":[2818,2938],"content":"The first parameter to <bpt id=\"p1\">**</bpt>copy<ept id=\"p1\">**</ept> must only receive a pointer to data that you have previously initialized using <bpt id=\"p2\">**</bpt>init<ept id=\"p2\">**</ept>.","source":"The first parameter to **copy** must only receive a pointer to data that you have previously initialized using **init**."},{"pos":[2948,3076],"content":"<bpt id=\"p1\">**</bpt>destroy<ept id=\"p1\">**</ept> must only ever receive a pointer to data that you have previously initialized using <bpt id=\"p2\">**</bpt>init<ept id=\"p2\">**</ept> or copied via <bpt id=\"p3\">**</bpt>copy<ept id=\"p3\">**</ept>.","source":"**destroy** must only ever receive a pointer to data that you have previously initialized using **init** or copied via **copy**."},{"content":"Standard Implementations","pos":[3085,3109]},{"pos":[3113,3219],"content":"ATL provides two copy policy classes in the form of the <bpt id=\"p1\">**</bpt>_Copy<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>_CopyInterface<ept id=\"p2\">**</ept> template classes:","source":"ATL provides two copy policy classes in the form of the **_Copy** and **_CopyInterface** template classes:"},{"content":"The <bpt id=\"p1\">**</bpt>_Copy<ept id=\"p1\">**</ept> class allows homogeneous copying only (not conversion between data types) since it only offers a single template parameter to specify both <ph id=\"ph1\">`DestinationType`</ph> and <bpt id=\"p2\">*</bpt>SourceType<ept id=\"p2\">*</ept>.","pos":[3229,3417],"source":"The **_Copy** class allows homogeneous copying only (not conversion between data types) since it only offers a single template parameter to specify both `DestinationType` and *SourceType*."},{"content":"The generic implementation of this template contains no initialization or destruction code and uses <ph id=\"ph1\">`memcpy`</ph> to copy the data.","pos":[3418,3544],"source":" The generic implementation of this template contains no initialization or destruction code and uses `memcpy` to copy the data."},{"content":"ATL also provides specializations of <bpt id=\"p1\">**</bpt>_Copy<ept id=\"p1\">**</ept> for <bpt id=\"p2\">**</bpt>VARIANT<ept id=\"p2\">**</ept>, <ph id=\"ph1\">`LPOLESTR`</ph>, <bpt id=\"p3\">**</bpt>OLEVERB<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>CONNECTDATA<ept id=\"p4\">**</ept> data types.","pos":[3545,3665],"source":" ATL also provides specializations of **_Copy** for **VARIANT**, `LPOLESTR`, **OLEVERB**, and **CONNECTDATA** data types."},{"content":"The <bpt id=\"p1\">**</bpt>_CopyInterface<ept id=\"p1\">**</ept> class provides an implementation for copying interface pointers following standard COM rules.","pos":[3675,3791],"source":"The **_CopyInterface** class provides an implementation for copying interface pointers following standard COM rules."},{"content":"Once again this class allows only homogeneous copying, so it uses simple assignment and a call to <ph id=\"ph1\">`AddRef`</ph> to perform the copy.","pos":[3792,3919],"source":" Once again this class allows only homogeneous copying, so it uses simple assignment and a call to `AddRef` to perform the copy."},{"content":"Custom Implementations","pos":[3928,3950]},{"content":"Typically, you'll need to define your own copy policy classes for heterogeneous copying (that is, conversion between data types).","pos":[3954,4083]},{"content":"For some examples of custom copy policy classes, look at the files VCUE_Copy.h and VCUE_CopyString.h in the <bpt id=\"p1\">[</bpt>ATLCollections<ept id=\"p1\">](../visual-cpp-samples.md)</ept> sample.","pos":[4084,4242],"source":" For some examples of custom copy policy classes, look at the files VCUE_Copy.h and VCUE_CopyString.h in the [ATLCollections](../visual-cpp-samples.md) sample."},{"content":"These files contain two template copy policy classes, <ph id=\"ph1\">`GenericCopy`</ph> and <ph id=\"ph2\">`MapCopy`</ph>, plus a number of specializations of <ph id=\"ph3\">`GenericCopy`</ph> for different data types.","pos":[4243,4401],"source":" These files contain two template copy policy classes, `GenericCopy` and `MapCopy`, plus a number of specializations of `GenericCopy` for different data types."},{"content":"GenericCopy","pos":[4411,4422]},{"content":"allows you to specify the <bpt id=\"p1\">*</bpt>SourceType<ept id=\"p1\">*</ept> and <ph id=\"ph1\">`DestinationType`</ph> as template arguments.","pos":[4440,4523],"source":" allows you to specify the *SourceType* and `DestinationType` as template arguments."},{"content":"Here's the most general form of the <ph id=\"ph1\">`GenericCopy`</ph> class from VCUE_Copy.h:","pos":[4524,4597],"source":" Here's the most general form of the `GenericCopy` class from VCUE_Copy.h:"},{"pos":[4615,4629],"content":"NVC_ATL_COM#30"},{"content":"VCUE_Copy.h also contains the following specializations of this class: <ph id=\"ph1\">`GenericCopy&lt;BSTR&gt;`</ph>, <ph id=\"ph2\">`GenericCopy&lt;VARIANT, BSTR&gt;`</ph>, <ph id=\"ph3\">`GenericCopy&lt;BSTR, VARIANT&gt;`</ph>.","pos":[4690,4841],"source":"VCUE_Copy.h also contains the following specializations of this class: `GenericCopy<BSTR>`, `GenericCopy<VARIANT, BSTR>`, `GenericCopy<BSTR, VARIANT>`."},{"content":"VCUE_CopyString.h contains specializations for copying from <bpt id=\"p1\">**</bpt>std::string<ept id=\"p1\">**</ept>s: <ph id=\"ph1\">`GenericCopy&lt;std::string&gt;`</ph>, <ph id=\"ph2\">`GenericCopy&lt;VARIANT, std::string&gt;`</ph>, and <ph id=\"ph3\">`GenericCopy&lt;BSTR, std::string&gt;`</ph>.","pos":[4842,5022],"source":" VCUE_CopyString.h contains specializations for copying from **std::string**s: `GenericCopy<std::string>`, `GenericCopy<VARIANT, std::string>`, and `GenericCopy<BSTR, std::string>`."},{"content":"You could enhance <ph id=\"ph1\">`GenericCopy`</ph> by providing further specializations of your own.","pos":[5023,5104],"source":" You could enhance `GenericCopy` by providing further specializations of your own."},{"content":"MapCopy","pos":[5114,5121]},{"content":"assumes that the data being copied is stored into an STL-style map, so it allows you to specify the type of map in which the data is stored and the destination type.","pos":[5135,5300]},{"content":"The implementation of the class just uses the typedefs supplied by the <bpt id=\"p1\">*</bpt>MapType<ept id=\"p1\">*</ept> class to determine the type of the source data and to call the appropriate <ph id=\"ph1\">`GenericCopy`</ph> class.","pos":[5301,5477],"source":" The implementation of the class just uses the typedefs supplied by the *MapType* class to determine the type of the source data and to call the appropriate `GenericCopy` class."},{"content":"No specializations of this class are needed.","pos":[5478,5522]},{"pos":[5540,5554],"content":"NVC_ATL_COM#31"},{"content":"See Also","pos":[5617,5625]},{"content":"Implementing an STL-Based Collection","pos":[5630,5666]},{"content":"ATLCollections Sample","pos":[5721,5742]}],"content":"---\ntitle: \"ATL Copy Policy Classes | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"data [C++], ATL\"\n  - \"classes [C++], copy policy\"\n  - \"copy policy classes [C++]\"\n  - \"_Copy class\"\n  - \"_CopyInterface class\"\nms.assetid: 06704b68-d318-4c5d-a65b-71457fe9d00d\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# ATL Copy Policy Classes\nCopy policy classes are [utility classes](../atl/utility-classes.md) used to initialize, copy, and delete data. Copy policy classes allow you to define copy semantics for any type of data, and to define conversions between different data types.  \n  \n ATL uses copy policy classes in its implementations of the following templates:  \n  \n-   [CComEnumImpl](../atl/reference/ccomenumimpl-class.md)  \n  \n-   [IEnumOnSTLImpl](../atl/reference/ienumonstlimpl-class.md)  \n  \n-   [ICollectionOnSTLImpl](../atl/reference/icollectiononstlimpl-class.md)  \n  \n By encapsulating the information needed to copy or convert data in a copy policy class that can be passed as a template argument, the ATL developers have provided for extreme reusability of these classes. For example, if you need to implement a collection using any arbitrary data type, all you need to provide is the appropriate copy policy; you never have to touch the code that implements the collection.  \n  \n## Definition  \n By definition, a class that provides the following static functions is a copy policy class:  \n  \n `static void init(` `DestinationType` `* p);`  \n  \n `static HRESULT copy(` `DestinationType` `* pTo, const`  `SourceType` `* pFrom);`  \n  \n `static void destroy(` `DestinationType` `* p);`  \n  \n You can replace the types `DestinationType` and *SourceType* with arbitrary data types for each copy policy.  \n  \n> [!NOTE]\n>  Although you can define copy policy classes for any arbitrary data types, use of the classes in ATL code should limit the types that make sense. For example, when using a copy policy class with ATL's collection or enumerator implementations, `DestinationType` must be a type that can be used as a parameter in a COM interface method.  \n  \n Use **init** to initialize data, **copy** to copy data, and **destroy** to free the data. The precise meaning of initialization, copying, and destruction are the domain of the copy policy class and will vary depending on the data types involved.  \n  \n There are two requirements on the use and implementation of a copy policy class:  \n  \n-   The first parameter to **copy** must only receive a pointer to data that you have previously initialized using **init**.  \n  \n-   **destroy** must only ever receive a pointer to data that you have previously initialized using **init** or copied via **copy**.  \n  \n## Standard Implementations  \n ATL provides two copy policy classes in the form of the **_Copy** and **_CopyInterface** template classes:  \n  \n-   The **_Copy** class allows homogeneous copying only (not conversion between data types) since it only offers a single template parameter to specify both `DestinationType` and *SourceType*. The generic implementation of this template contains no initialization or destruction code and uses `memcpy` to copy the data. ATL also provides specializations of **_Copy** for **VARIANT**, `LPOLESTR`, **OLEVERB**, and **CONNECTDATA** data types.  \n  \n-   The **_CopyInterface** class provides an implementation for copying interface pointers following standard COM rules. Once again this class allows only homogeneous copying, so it uses simple assignment and a call to `AddRef` to perform the copy.  \n  \n## Custom Implementations  \n Typically, you'll need to define your own copy policy classes for heterogeneous copying (that is, conversion between data types). For some examples of custom copy policy classes, look at the files VCUE_Copy.h and VCUE_CopyString.h in the [ATLCollections](../visual-cpp-samples.md) sample. These files contain two template copy policy classes, `GenericCopy` and `MapCopy`, plus a number of specializations of `GenericCopy` for different data types.  \n  \n### GenericCopy  \n `GenericCopy` allows you to specify the *SourceType* and `DestinationType` as template arguments. Here's the most general form of the `GenericCopy` class from VCUE_Copy.h:  \n  \n [!code-cpp[NVC_ATL_COM#30](../atl/codesnippet/cpp/atl-copy-policy-classes_1.h)]  \n  \n VCUE_Copy.h also contains the following specializations of this class: `GenericCopy<BSTR>`, `GenericCopy<VARIANT, BSTR>`, `GenericCopy<BSTR, VARIANT>`. VCUE_CopyString.h contains specializations for copying from **std::string**s: `GenericCopy<std::string>`, `GenericCopy<VARIANT, std::string>`, and `GenericCopy<BSTR, std::string>`. You could enhance `GenericCopy` by providing further specializations of your own.  \n  \n### MapCopy  \n `MapCopy` assumes that the data being copied is stored into an STL-style map, so it allows you to specify the type of map in which the data is stored and the destination type. The implementation of the class just uses the typedefs supplied by the *MapType* class to determine the type of the source data and to call the appropriate `GenericCopy` class. No specializations of this class are needed.  \n  \n [!code-cpp[NVC_ATL_COM#31](../atl/codesnippet/cpp/atl-copy-policy-classes_2.h)]  \n  \n## See Also  \n [Implementing an STL-Based Collection](../atl/implementing-an-stl-based-collection.md)   \n [ATLCollections Sample](../visual-cpp-samples.md)\n\n"}