{"nodes":[{"pos":[12,61],"content":".netmodule Files as Linker Input | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":".netmodule Files as Linker Input | Microsoft Docs","pos":[0,49]}]},{"content":".netmodule Files as Linker Input","pos":[656,688]},{"content":"link.exe now accepts MSIL .obj and .netmodules as input.","pos":[689,745]},{"content":"The output file produced by the linker will be an assembly or a .netmodule with no run-time dependency on any of the .obj or .netmodules that were input to the linker.","pos":[746,913]},{"content":".netmodules are created by the Visual C++ compiler with <bpt id=\"p1\">[</bpt>/LN (Create MSIL Module)<ept id=\"p1\">](../../build/reference/ln-create-msil-module.md)</ept> or by the linker with <bpt id=\"p2\">[</bpt>/NOASSEMBLY (Create a MSIL Module)<ept id=\"p2\">](../../build/reference/noassembly-create-a-msil-module.md)</ept>.","pos":[920,1168],"source":".netmodules are created by the Visual C++ compiler with [/LN (Create MSIL Module)](../../build/reference/ln-create-msil-module.md) or by the linker with [/NOASSEMBLY (Create a MSIL Module)](../../build/reference/noassembly-create-a-msil-module.md)."},{"content":".objs are always created in a Visual C++ compilation.","pos":[1169,1222]},{"content":"For other Visual Studio compilers, use the <bpt id=\"p1\">**</bpt>/target:module<ept id=\"p1\">**</ept> compiler option.","pos":[1223,1301],"source":" For other Visual Studio compilers, use the **/target:module** compiler option."},{"content":"In most cases, you will need to pass to the linker the .obj file from the Visual C++ compilation that created the .netmodule, unless the .netmodule was created with <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../../build/reference/clr-common-language-runtime-compilation.md)</ept>.","pos":[1308,1584],"source":"In most cases, you will need to pass to the linker the .obj file from the Visual C++ compilation that created the .netmodule, unless the .netmodule was created with [/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md)."},{"content":"MSIL .netmodules used as input to the linker must be pure MSIL, which can be produced by the Visual C++ compiler using <bpt id=\"p1\">**</bpt>/clr:safe<ept id=\"p1\">**</ept>.","pos":[1585,1718],"source":" MSIL .netmodules used as input to the linker must be pure MSIL, which can be produced by the Visual C++ compiler using **/clr:safe**."},{"content":"Other Visual Studio compilers produce pure MSIL modules by default.","pos":[1719,1786]},{"pos":[1793,2102],"content":"For information on how to invoke the linker from the command line, see <bpt id=\"p1\">[</bpt>Linker Command-Line Syntax<ept id=\"p1\">](../../build/reference/linker-command-line-syntax.md)</ept> and <bpt id=\"p2\">[</bpt>Setting the Path and Environment Variables for Command-Line Builds<ept id=\"p2\">](../../build/setting-the-path-and-environment-variables-for-command-line-builds.md)</ept>.","source":"For information on how to invoke the linker from the command line, see [Linker Command-Line Syntax](../../build/reference/linker-command-line-syntax.md) and [Setting the Path and Environment Variables for Command-Line Builds](../../build/setting-the-path-and-environment-variables-for-command-line-builds.md)."},{"content":"Passing a .netmodule or .dll file to the linker that was compiled by the Visual C++ compiler with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> or with <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept> can result in a linker error.","pos":[2109,2267],"source":"Passing a .netmodule or .dll file to the linker that was compiled by the Visual C++ compiler with **/clr** or with **/clr:pure** can result in a linker error."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Choosing the Format of .netmodule Input Files<ept id=\"p1\">](../../build/reference/choosing-the-format-of-netmodule-input-files.md)</ept>.","pos":[2268,2413],"source":" For more information, see [Choosing the Format of .netmodule Input Files](../../build/reference/choosing-the-format-of-netmodule-input-files.md)."},{"content":"The linker accepts native .obj files as well as MSIL .obj files compiled with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>/clr:safe<ept id=\"p3\">**</ept>.","pos":[2420,2540],"source":"The linker accepts native .obj files as well as MSIL .obj files compiled with **/clr**, **/clr:pure**, or **/clr:safe**."},{"content":"When passing mixed .objs in the same build, the verifiability of the resulting output file will, by default, be equal to the lowest level of verifiability of the input modules.","pos":[2541,2717]},{"content":"For example, if you pass a safe and pure .obj to the linker, the output file will be pure.","pos":[2718,2808]},{"content":"<bpt id=\"p1\">[</bpt>/CLRIMAGETYPE (Specify Type of CLR Image)<ept id=\"p1\">](../../build/reference/clrimagetype-specify-type-of-clr-image.md)</ept> lets you specify a lower level of verifiability, if that is what you need.","pos":[2809,2992],"source":"[/CLRIMAGETYPE (Specify Type of CLR Image)](../../build/reference/clrimagetype-specify-type-of-clr-image.md) lets you specify a lower level of verifiability, if that is what you need."},{"content":"If you currently have an application that is composed of two or more assemblies and you want the application to be contained in one assembly, you must recompile the assemblies and then link the .objs or .netmodules to produce a single assembly.","pos":[2999,3243]},{"pos":[3250,3403],"content":"You must specify an entry point using <bpt id=\"p1\">[</bpt>/ENTRY (Entry-Point Symbol)<ept id=\"p1\">](../../build/reference/entry-entry-point-symbol.md)</ept> when creating an executable image.","source":"You must specify an entry point using [/ENTRY (Entry-Point Symbol)](../../build/reference/entry-entry-point-symbol.md) when creating an executable image."},{"pos":[3410,3661],"content":"When linking with an MSIL .obj or .netmodule file, use <bpt id=\"p1\">[</bpt>/LTCG (Link-time Code Generation)<ept id=\"p1\">](../../build/reference/ltcg-link-time-code-generation.md)</ept>, otherwise when the linker encounters the MSIL .obj or .netmodule, it will restart the link with /LTCG.","source":"When linking with an MSIL .obj or .netmodule file, use [/LTCG (Link-time Code Generation)](../../build/reference/ltcg-link-time-code-generation.md), otherwise when the linker encounters the MSIL .obj or .netmodule, it will restart the link with /LTCG."},{"content":"MSIL .obj or .netmodule files can also be passed to cl.exe.","pos":[3668,3727]},{"content":"Input MSIL .obj or .netmodule files cannot have embedded resources.","pos":[3734,3801]},{"content":"A resource is embedded in an output file (module or assembly) with <bpt id=\"p1\">[</bpt>/ASSEMBLYRESOURCE (Embed a Managed Resource)<ept id=\"p1\">](../../build/reference/assemblyresource-embed-a-managed-resource.md)</ept> linker option or with the <bpt id=\"p2\">**</bpt>/resource<ept id=\"p2\">**</ept> compiler option in other Visual Studio compilers.","pos":[3802,4073],"source":" A resource is embedded in an output file (module or assembly) with [/ASSEMBLYRESOURCE (Embed a Managed Resource)](../../build/reference/assemblyresource-embed-a-managed-resource.md) linker option or with the **/resource** compiler option in other Visual Studio compilers."},{"content":"When performing MSIL linking, and if you do not also specify <bpt id=\"p1\">[</bpt>/LTCG (Link-time Code Generation)<ept id=\"p1\">](../../build/reference/ltcg-link-time-code-generation.md)</ept>, you will see an informational message reporting that the link is restarting.","pos":[4080,4311],"source":"When performing MSIL linking, and if you do not also specify [/LTCG (Link-time Code Generation)](../../build/reference/ltcg-link-time-code-generation.md), you will see an informational message reporting that the link is restarting."},{"content":"This message can be ignored, but to improve linker performance with MSIL linking, explicitly specify <bpt id=\"p1\">**</bpt>/LTCG<ept id=\"p1\">**</ept>.","pos":[4312,4423],"source":" This message can be ignored, but to improve linker performance with MSIL linking, explicitly specify **/LTCG**."},{"content":"Example","pos":[4432,4439]},{"content":"In C++ code the catch block of a corresponding try will be invoked for a non System exception.","pos":[4443,4537]},{"content":"However, by default, the CLR wraps non System exceptions with &lt;xref:System.Runtime.CompilerServices.RuntimeWrappedException&gt;.","pos":[4538,4663],"source":" However, by default, the CLR wraps non System exceptions with <xref:System.Runtime.CompilerServices.RuntimeWrappedException>."},{"content":"When an assembly is created from Visual C++ and non Visual C++ modules and you want a catch block in C++ code to be invoked from its corresponding try clause when the try block throws a non System exception, you must add the","pos":[4664,4888]},{"content":"[assembly:System::Runtime::CompilerServices::RuntimeCompatibility(WrapNonExceptionThrows=false)] attribute to the source code for the non C++ modules.","pos":[4895,5045]},{"content":"Example","pos":[5429,5436]},{"content":"By changing the Boolean value of the WrapNonExceptionThrows attribute, you modify the ability of the Visual C++ code to catch a non System exception.","pos":[5440,5589]},{"content":"See Also","pos":[6298,6306]},{"content":"LINK Input Files","pos":[6311,6327]},{"content":"Linker Options","pos":[6377,6391]}],"content":"---\ntitle: \".netmodule Files as Linker Input | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"MSIL linking\"\n  - \"linking [C++], modules\"\n  - \".netmodules\"\n  - \"modules, Visual C++\"\nms.assetid: a4bcbe8a-4255-451d-853b-f88cfd82f4e1\ncaps.latest.revision: 22\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# .netmodule Files as Linker Input\nlink.exe now accepts MSIL .obj and .netmodules as input. The output file produced by the linker will be an assembly or a .netmodule with no run-time dependency on any of the .obj or .netmodules that were input to the linker.  \n  \n .netmodules are created by the Visual C++ compiler with [/LN (Create MSIL Module)](../../build/reference/ln-create-msil-module.md) or by the linker with [/NOASSEMBLY (Create a MSIL Module)](../../build/reference/noassembly-create-a-msil-module.md). .objs are always created in a Visual C++ compilation. For other Visual Studio compilers, use the **/target:module** compiler option.  \n  \n In most cases, you will need to pass to the linker the .obj file from the Visual C++ compilation that created the .netmodule, unless the .netmodule was created with [/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md). MSIL .netmodules used as input to the linker must be pure MSIL, which can be produced by the Visual C++ compiler using **/clr:safe**. Other Visual Studio compilers produce pure MSIL modules by default.  \n  \n For information on how to invoke the linker from the command line, see [Linker Command-Line Syntax](../../build/reference/linker-command-line-syntax.md) and [Setting the Path and Environment Variables for Command-Line Builds](../../build/setting-the-path-and-environment-variables-for-command-line-builds.md).  \n  \n Passing a .netmodule or .dll file to the linker that was compiled by the Visual C++ compiler with **/clr** or with **/clr:pure** can result in a linker error. For more information, see [Choosing the Format of .netmodule Input Files](../../build/reference/choosing-the-format-of-netmodule-input-files.md).  \n  \n The linker accepts native .obj files as well as MSIL .obj files compiled with **/clr**, **/clr:pure**, or **/clr:safe**. When passing mixed .objs in the same build, the verifiability of the resulting output file will, by default, be equal to the lowest level of verifiability of the input modules. For example, if you pass a safe and pure .obj to the linker, the output file will be pure. [/CLRIMAGETYPE (Specify Type of CLR Image)](../../build/reference/clrimagetype-specify-type-of-clr-image.md) lets you specify a lower level of verifiability, if that is what you need.  \n  \n If you currently have an application that is composed of two or more assemblies and you want the application to be contained in one assembly, you must recompile the assemblies and then link the .objs or .netmodules to produce a single assembly.  \n  \n You must specify an entry point using [/ENTRY (Entry-Point Symbol)](../../build/reference/entry-entry-point-symbol.md) when creating an executable image.  \n  \n When linking with an MSIL .obj or .netmodule file, use [/LTCG (Link-time Code Generation)](../../build/reference/ltcg-link-time-code-generation.md), otherwise when the linker encounters the MSIL .obj or .netmodule, it will restart the link with /LTCG.  \n  \n MSIL .obj or .netmodule files can also be passed to cl.exe.  \n  \n Input MSIL .obj or .netmodule files cannot have embedded resources. A resource is embedded in an output file (module or assembly) with [/ASSEMBLYRESOURCE (Embed a Managed Resource)](../../build/reference/assemblyresource-embed-a-managed-resource.md) linker option or with the **/resource** compiler option in other Visual Studio compilers.  \n  \n When performing MSIL linking, and if you do not also specify [/LTCG (Link-time Code Generation)](../../build/reference/ltcg-link-time-code-generation.md), you will see an informational message reporting that the link is restarting. This message can be ignored, but to improve linker performance with MSIL linking, explicitly specify **/LTCG**.  \n  \n## Example  \n In C++ code the catch block of a corresponding try will be invoked for a non System exception. However, by default, the CLR wraps non System exceptions with <xref:System.Runtime.CompilerServices.RuntimeWrappedException>. When an assembly is created from Visual C++ and non Visual C++ modules and you want a catch block in C++ code to be invoked from its corresponding try clause when the try block throws a non System exception, you must add the  \n  \n [assembly:System::Runtime::CompilerServices::RuntimeCompatibility(WrapNonExceptionThrows=false)] attribute to the source code for the non C++ modules.  \n  \n```  \n// MSIL_linking.cpp  \n// compile with: /c /clr  \nvalue struct V {};  \n  \nref struct MCPP {  \n   static void Test() {  \n      try {  \n         throw (gcnew V);  \n      }  \n      catch (V ^) {  \n         System::Console::WriteLine(\"caught non System exception in C++ source code file\");  \n      }  \n   }  \n};  \n  \n/*  \nint main() {  \n   MCPP::Test();  \n}  \n*/  \n```  \n  \n## Example  \n By changing the Boolean value of the WrapNonExceptionThrows attribute, you modify the ability of the Visual C++ code to catch a non System exception.  \n  \n```  \n// MSIL_linking_2.cs  \n// compile with: /target:module /addmodule:MSIL_linking.obj  \n// post-build command: link /LTCG MSIL_linking.obj MSIL_linking_2.netmodule /entry:MLinkTest.Main /out:MSIL_linking_2.exe /subsystem:console  \nusing System.Runtime.CompilerServices;  \n  \n// enable non System exceptions  \n[assembly:RuntimeCompatibility(WrapNonExceptionThrows=false)]  \n  \nclass MLinkTest {  \n   public static void Main() {  \n      try {  \n         MCPP.Test();  \n      }  \n      catch (RuntimeWrappedException) {  \n         System.Console.WriteLine(\"caught a wrapped exception in C#\");  \n      }  \n   }  \n}  \n```  \n  \n```Output  \ncaught non System exception in C++ source code file  \n```  \n  \n## See Also  \n [LINK Input Files](../../build/reference/link-input-files.md)   \n [Linker Options](../../build/reference/linker-options.md)"}