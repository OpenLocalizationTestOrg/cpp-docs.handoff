{"nodes":[{"pos":[12,57],"content":"Sample Multithread C Program | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Sample Multithread C Program | Microsoft Docs","pos":[0,45]}]},{"content":"Sample Multithread C Program","pos":[538,566]},{"content":"Bounce.c is a sample multithread program that creates a new thread each time the letter <bpt id=\"p1\">**</bpt>a<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>A<ept id=\"p2\">**</ept> is typed.","pos":[567,679],"source":"Bounce.c is a sample multithread program that creates a new thread each time the letter **a** or **A** is typed."},{"content":"Each thread bounces a happy face of a different color around the screen.","pos":[680,752]},{"content":"Up to 32 threads can be created.","pos":[753,785]},{"content":"The program's normal termination occurs when <ph id=\"ph1\">`q`</ph> or <bpt id=\"p1\">**</bpt>Q<ept id=\"p1\">**</ept> is typed.","pos":[786,853],"source":" The program's normal termination occurs when `q` or **Q** is typed."},{"content":"For information about compiling and linking Bounce.c, see <bpt id=\"p1\">[</bpt>Compiling and Linking Multithread Programs<ept id=\"p1\">](../parallel/compiling-and-linking-multithread-programs.md)</ept>.","pos":[854,1016],"source":" For information about compiling and linking Bounce.c, see [Compiling and Linking Multithread Programs](../parallel/compiling-and-linking-multithread-programs.md)."},{"content":"Example","pos":[1025,1032]},{"content":"Code","pos":[1042,1046]},{"content":"Input","pos":[7099,7104]},{"content":"See Also","pos":[7136,7144]},{"content":"Multithreading with C and Win32","pos":[7149,7180]}],"content":"---\ntitle: \"Sample Multithread C Program | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 4706f6cd-ff9c-4dbf-99a2-1c999b568f17\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Sample Multithread C Program\nBounce.c is a sample multithread program that creates a new thread each time the letter **a** or **A** is typed. Each thread bounces a happy face of a different color around the screen. Up to 32 threads can be created. The program's normal termination occurs when `q` or **Q** is typed. For information about compiling and linking Bounce.c, see [Compiling and Linking Multithread Programs](../parallel/compiling-and-linking-multithread-programs.md).  \n  \n## Example  \n  \n### Code  \n  \n```  \n// sample_multithread_c_program.c  \n// compile with: /c  \n//  \n//  Bounce - Creates a new thread each time the letter 'a' is typed.  \n//  Each thread bounces a happy face of a different color around  \n//  the screen. All threads are terminated when the letter 'Q' is  \n//  entered.  \n//  \n  \n#include <windows.h>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <stdio.h>  \n#include <conio.h>  \n#include <process.h>  \n  \n#define MAX_THREADS  32  \n  \n// The function getrandom returns a random number between   \n// min and max, which must be in integer range.  \n#define getrandom( min, max ) (SHORT)((rand() % (int)(((max) + 1) - \\  \n                               (min))) + (min))  \n  \nint main( void );                    // Thread 1: main   \nvoid KbdFunc( void  );               // Keyboard input, thread dispatch  \nvoid BounceProc( void * MyID );      // Threads 2 to n: display   \nvoid ClearScreen( void );            // Screen clear   \nvoid ShutDown( void );               // Program shutdown   \nvoid WriteTitle( int ThreadNum );    // Display title bar information   \n  \nHANDLE  hConsoleOut;                 // Handle to the console   \nHANDLE  hRunMutex;                   // \"Keep Running\" mutex   \nHANDLE  hScreenMutex;                // \"Screen update\" mutex  \nint     ThreadNr;                    // Number of threads started   \nCONSOLE_SCREEN_BUFFER_INFO csbiInfo; // Console information  \n  \nint main() // Thread One   \n{  \n    // Get display screen information & clear the screen.  \n    hConsoleOut = GetStdHandle( STD_OUTPUT_HANDLE );  \n    GetConsoleScreenBufferInfo( hConsoleOut, &csbiInfo );  \n    ClearScreen();  \n    WriteTitle( 0 );  \n  \n    // Create the mutexes and reset thread count.  \n    hScreenMutex = CreateMutex( NULL, FALSE, NULL );  // Cleared   \n    hRunMutex = CreateMutex( NULL, TRUE, NULL );      // Set   \n    ThreadNr = 0;  \n  \n    // Start waiting for keyboard input to dispatch threads or exit.  \n    KbdFunc();  \n  \n    // All threads done. Clean up handles.  \n    CloseHandle( hScreenMutex );  \n    CloseHandle( hRunMutex );  \n    CloseHandle( hConsoleOut );  \n}  \n  \nvoid ShutDown( void ) // Shut down threads   \n{  \n    while ( ThreadNr > 0 )  \n    {  \n        // Tell thread to die and record its death.  \n        ReleaseMutex( hRunMutex );  \n        ThreadNr--;     \n    }  \n  \n    // Clean up display when done  \n    WaitForSingleObject( hScreenMutex, INFINITE );  \n    ClearScreen();  \n}  \n  \nvoid KbdFunc( void ) // Dispatch and count threads.  \n{  \n    int         KeyInfo;  \n  \n    do  \n    {  \n        KeyInfo = _getch();  \n        if ( tolower( KeyInfo ) == 'a' &&   \n             ThreadNr < MAX_THREADS )  \n        {  \n            ThreadNr++;  \n            _beginthread( BounceProc, 0, &ThreadNr );  \n            WriteTitle( ThreadNr );  \n        }  \n    } while( tolower( KeyInfo ) != 'q' );  \n  \n    ShutDown();  \n}  \n  \nvoid BounceProc( void *pMyID )  \n{  \n    char    MyCell, OldCell;  \n    WORD    MyAttrib, OldAttrib;  \n    char    BlankCell = 0x20;  \n    COORD   Coords, Delta;  \n    COORD   Old = {0,0};  \n    DWORD   Dummy;  \n    char    *MyID = (char*)pMyID;  \n  \n    // Generate update increments and initial   \n    // display coordinates.  \n    srand( (unsigned int) *MyID * 3 );  \n  \n    Coords.X = getrandom( 0, csbiInfo.dwSize.X - 1 );  \n    Coords.Y = getrandom( 0, csbiInfo.dwSize.Y - 1 );  \n    Delta.X = getrandom( -3, 3 );  \n    Delta.Y = getrandom( -3, 3 );  \n  \n    // Set up \"happy face\" & generate color   \n    // attribute from thread number.  \n    if( *MyID > 16)  \n        MyCell = 0x01;          // outline face   \n    else  \n        MyCell = 0x02;          // solid face   \n    MyAttrib =  *MyID & 0x0F;   // force black background   \n  \n    do  \n    {  \n        // Wait for display to be available, then lock it.  \n        WaitForSingleObject( hScreenMutex, INFINITE );  \n  \n        // If we still occupy the old screen position, blank it out.   \n        ReadConsoleOutputCharacter( hConsoleOut, &OldCell, 1,   \n                                    Old, &Dummy );  \n        ReadConsoleOutputAttribute( hConsoleOut, &OldAttrib, 1,   \n                                    Old, &Dummy );  \n        if (( OldCell == MyCell ) && (OldAttrib == MyAttrib))  \n            WriteConsoleOutputCharacter( hConsoleOut, &BlankCell, 1,  \n                                         Old, &Dummy );  \n  \n        // Draw new face, then clear screen lock   \n        WriteConsoleOutputCharacter( hConsoleOut, &MyCell, 1,   \n                                     Coords, &Dummy );  \n        WriteConsoleOutputAttribute( hConsoleOut, &MyAttrib, 1,   \n                                     Coords, &Dummy );  \n        ReleaseMutex( hScreenMutex );  \n  \n        // Increment the coordinates for next placement of the block.   \n        Old.X = Coords.X;  \n        Old.Y = Coords.Y;  \n        Coords.X += Delta.X;  \n        Coords.Y += Delta.Y;  \n  \n        // If we are about to go off the screen, reverse direction   \n        if( Coords.X < 0 || Coords.X >= csbiInfo.dwSize.X )  \n        {  \n            Delta.X = -Delta.X;  \n            Beep( 400, 50 );  \n        }  \n        if( Coords.Y < 0 || Coords.Y > csbiInfo.dwSize.Y )  \n        {  \n            Delta.Y = -Delta.Y;  \n            Beep( 600, 50 );  \n        }  \n    }  \n    // Repeat while RunMutex is still taken.   \n    while ( WaitForSingleObject( hRunMutex, 75L ) == WAIT_TIMEOUT );  \n}  \n  \nvoid WriteTitle( int ThreadNum )  \n{  \n    enum {   \n        sizeOfNThreadMsg = 80   \n    };  \n    char    NThreadMsg[sizeOfNThreadMsg];  \n  \n    sprintf_s( NThreadMsg, sizeOfNThreadMsg,   \n               \"Threads running: %02d.  Press 'A' \"  \n               \"to start a thread,'Q' to quit.\", ThreadNum );  \n    SetConsoleTitle( NThreadMsg );  \n}  \n  \nvoid ClearScreen( void )  \n{  \n    DWORD    dummy;  \n    COORD    Home = { 0, 0 };  \n    FillConsoleOutputCharacter( hConsoleOut, ' ',   \n                                csbiInfo.dwSize.X * csbiInfo.dwSize.Y,   \n                                Home, &dummy );  \n}  \n```  \n  \n### Input  \n  \n```  \na  \nq  \n```  \n  \n## See Also  \n [Multithreading with C and Win32](../parallel/multithreading-with-c-and-win32.md)"}