{"nodes":[{"pos":[12,59],"content":"Creating an Updatable Provider | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Creating an Updatable Provider | Microsoft Docs","pos":[0,47]}]},{"content":"Creating an Updatable Provider","pos":[671,701]},{"content":"Visual C++ 6.0 supported only read-only providers.","pos":[702,752]},{"content":"Visual C++ .NET supports updatable providers or providers that can update (write to) the data store.","pos":[753,853]},{"content":"This topic discusses how to create updatable providers using OLE DB templates.","pos":[854,932]},{"content":"This topic assumes that you are starting with a workable provider.","pos":[939,1005]},{"content":"There are two steps to creating an updatable provider.","pos":[1006,1060]},{"content":"You must first decide how the provider will make changes to the data store; specifically, whether changes are to be done immediately or deferred until an update command is issued.","pos":[1061,1240]},{"content":"The section \"<bpt id=\"p1\">[</bpt>Making Providers Updatable<ept id=\"p1\">](#vchowmakingprovidersupdatable)</ept>\" describes the changes and settings you need to do in the provider code.","pos":[1241,1387],"source":" The section \"[Making Providers Updatable](#vchowmakingprovidersupdatable)\" describes the changes and settings you need to do in the provider code."},{"content":"Next, you must make sure your provider contains all the functionality to support anything the consumer might request of it.","pos":[1394,1517]},{"content":"If the consumer wants to update the data store, the provider has to contain code that persists data to the data store.","pos":[1518,1636]},{"content":"For example, you might use the C Run-Time Library or MFC to perform such operations on your data source.","pos":[1637,1741]},{"content":"The section \"<bpt id=\"p1\">[</bpt>Writing to the Data Source<ept id=\"p1\">](#vchowwritingtothedatasource)</ept>\" describes how to write to the data source, deal with <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept> and default values, and set column flags.","pos":[1742,1918],"source":" The section \"[Writing to the Data Source](#vchowwritingtothedatasource)\" describes how to write to the data source, deal with **NULL** and default values, and set column flags."},{"pos":[1926,2044],"content":"[!NOTE]\n UpdatePV is an example of an updatable provider. UpdatePV is the same as MyProv but with updatable support.","leadings":["","> "],"nodes":[{"content":" UpdatePV is an example of an updatable provider. UpdatePV is the same as MyProv but with updatable support.","pos":[8,116],"nodes":[{"content":"UpdatePV is an example of an updatable provider.","pos":[1,49]},{"content":"UpdatePV is the same as MyProv but with updatable support.","pos":[50,108]}]}]},{"pos":[2099,2125],"content":"Making Providers Updatable"},{"content":"The key to making a provider updatable is understanding what operations you want your provider to perform on the data store and how you want the provider to carry out those operations.","pos":[2129,2313]},{"content":"Specifically, the major issue is whether updates to the data store are to be done immediately or deferred (batched) until an update command is issued.","pos":[2314,2464]},{"content":"You must first decide whether to inherit from <ph id=\"ph1\">`IRowsetChangeImpl`</ph> or <ph id=\"ph2\">`IRowsetUpdateImpl`</ph> in your rowset class.","pos":[2471,2581],"source":"You must first decide whether to inherit from `IRowsetChangeImpl` or `IRowsetUpdateImpl` in your rowset class."},{"content":"Depending on which of these you choose to implement, the functionality of three methods will be affected: <ph id=\"ph1\">`SetData`</ph>, <bpt id=\"p1\">**</bpt>InsertRows<ept id=\"p1\">**</ept>, and <ph id=\"ph2\">`DeleteRows`</ph>.","pos":[2582,2732],"source":" Depending on which of these you choose to implement, the functionality of three methods will be affected: `SetData`, **InsertRows**, and `DeleteRows`."},{"pos":[2742,2891],"content":"If you inherit from <bpt id=\"p1\">[</bpt>IRowsetChangeImpl<ept id=\"p1\">](../../data/oledb/irowsetchangeimpl-class.md)</ept>, calling these three methods immediately changes the data store.","source":"If you inherit from [IRowsetChangeImpl](../../data/oledb/irowsetchangeimpl-class.md), calling these three methods immediately changes the data store."},{"content":"If you inherit from <bpt id=\"p1\">[</bpt>IRowsetUpdateImpl<ept id=\"p1\">](../../data/oledb/irowsetupdateimpl-class.md)</ept>, the methods defer changes to the data store until you call <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept>, <ph id=\"ph1\">`GetOriginalData`</ph>, or <bpt id=\"p3\">**</bpt>Undo<ept id=\"p3\">**</ept>.","pos":[2901,3089],"source":"If you inherit from [IRowsetUpdateImpl](../../data/oledb/irowsetupdateimpl-class.md), the methods defer changes to the data store until you call **Update**, `GetOriginalData`, or **Undo**."},{"content":"If the update involves several changes, they are performed in batch mode (note that batching changes can add considerable memory overhead).","pos":[3090,3229]},{"content":"Note that <ph id=\"ph1\">`IRowsetUpdateImpl`</ph> derives from <ph id=\"ph2\">`IRowsetChangeImpl`</ph>.","pos":[3236,3299],"source":"Note that `IRowsetUpdateImpl` derives from `IRowsetChangeImpl`."},{"content":"Thus, <ph id=\"ph1\">`IRowsetUpdateImpl`</ph> gives you change capability plus batch capability.","pos":[3300,3376],"source":" Thus, `IRowsetUpdateImpl` gives you change capability plus batch capability."},{"content":"To support updatability in your provider","pos":[3387,3427]},{"content":"In your rowset class, inherit from <ph id=\"ph1\">`IRowsetChangeImpl`</ph> or <ph id=\"ph2\">`IRowsetUpdateImpl`</ph>.","pos":[3437,3515],"source":"In your rowset class, inherit from `IRowsetChangeImpl` or `IRowsetUpdateImpl`."},{"content":"These classes provide appropriate interfaces for changing the data store:","pos":[3516,3589]},{"content":"Adding IRowsetChange","pos":[3602,3622]},{"pos":[3635,3701],"content":"Add <ph id=\"ph1\">`IRowsetChangeImpl`</ph> to your inheritance chain using this form:","source":"Add `IRowsetChangeImpl` to your inheritance chain using this form:"},{"pos":[3788,3886],"content":"Also add <ph id=\"ph1\">`COM_INTERFACE_ENTRY(IRowsetChange)`</ph> to the <ph id=\"ph2\">`BEGIN_COM_MAP`</ph> section in your rowset class.","source":"Also add `COM_INTERFACE_ENTRY(IRowsetChange)` to the `BEGIN_COM_MAP` section in your rowset class."},{"content":"Adding IRowsetUpdate","pos":[3899,3919]},{"pos":[3932,3994],"content":"Add <ph id=\"ph1\">`IRowsetUpdate`</ph> to your inheritance chain using this form:","source":"Add `IRowsetUpdate` to your inheritance chain using this form:"},{"pos":[4076,4270],"content":"[!NOTE]\n You should remove the `IRowsetChangeImpl` line from your inheritance chain. This one exception to the directive previously mentioned must include the code for `IRowsetChangeImpl`.","leadings":["","    > "],"nodes":[{"content":" You should remove the `IRowsetChangeImpl` line from your inheritance chain. This one exception to the directive previously mentioned must include the code for `IRowsetChangeImpl`.","pos":[8,188],"nodes":[{"content":"You should remove the <ph id=\"ph1\">`IRowsetChangeImpl`</ph> line from your inheritance chain.","pos":[1,76],"source":" You should remove the `IRowsetChangeImpl` line from your inheritance chain."},{"content":"This one exception to the directive previously mentioned must include the code for <ph id=\"ph1\">`IRowsetChangeImpl`</ph>.","pos":[77,180],"source":" This one exception to the directive previously mentioned must include the code for `IRowsetChangeImpl`."}]}]},{"pos":[4280,4350],"content":"Add the following to your COM map (<bpt id=\"p1\">**</bpt>BEGIN_COM_MAP ... END_COM_MAP<ept id=\"p1\">**</ept>):","source":"Add the following to your COM map (**BEGIN_COM_MAP ... END_COM_MAP**):"},{"content":"If you implement","pos":[4361,4377]},{"content":"Add to COM map","pos":[4378,4392]},{"pos":[4619,4723],"content":"In your command, add the following to your property set map (<bpt id=\"p1\">**</bpt>BEGIN_PROPSET_MAP ... END_PROPSET_MAP<ept id=\"p1\">**</ept>):","source":"In your command, add the following to your property set map (**BEGIN_PROPSET_MAP ... END_PROPSET_MAP**):"},{"content":"If you implement","pos":[4734,4750]},{"content":"Add to property set map","pos":[4751,4774]},{"content":"In your property set map, you should also include all of the following settings as they appear below:","pos":[5073,5174]},{"content":"You can find the values used in these macro calls by looking in Atldb.h for the property IDs and values (if Atldb.h differs from the online documentation, Atldb.h supersedes the documentation).","pos":[6048,6241]},{"pos":[6253,6470],"content":"[!NOTE]\n Many of the **VARIANT_FALSE** and `VARIANT_TRUE` settings are required by the OLE DB templates; the OLE DB specification says they can be read/write, but the OLE DB templates can only support one value.","leadings":["","    > "],"nodes":[{"content":"Many of the <bpt id=\"p1\">**</bpt>VARIANT_FALSE<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`VARIANT_TRUE`</ph> settings are required by the OLE DB templates; the OLE DB specification says they can be read/write, but the OLE DB templates can only support one value.","pos":[9,211],"source":" Many of the **VARIANT_FALSE** and `VARIANT_TRUE` settings are required by the OLE DB templates; the OLE DB specification says they can be read/write, but the OLE DB templates can only support one value."}]},{"content":"If you implement IRowsetChangeImpl","pos":[6483,6517]},{"content":"If you implement <ph id=\"ph1\">`IRowsetChangeImpl`</ph>, you must set the following properties on your provider.","pos":[6530,6623],"source":"If you implement `IRowsetChangeImpl`, you must set the following properties on your provider."},{"content":"These properties are primarily used to request interfaces through <bpt id=\"p1\">**</bpt>ICommandProperties::SetProperties<ept id=\"p1\">**</ept>.","pos":[6624,6728],"source":" These properties are primarily used to request interfaces through **ICommandProperties::SetProperties**."},{"pos":[6764,6823],"content":": Setting this automatically sets <bpt id=\"p1\">**</bpt>DBPROP_IRowsetChange<ept id=\"p1\">**</ept>.","source":": Setting this automatically sets **DBPROP_IRowsetChange**."},{"pos":[6858,6963],"content":": A bitmask specifying the supported methods on <ph id=\"ph1\">`IRowsetChange`</ph>: <ph id=\"ph2\">`SetData`</ph>, <ph id=\"ph3\">`DeleteRows`</ph>, or <ph id=\"ph4\">`InsertRow`</ph>.","source":": A bitmask specifying the supported methods on `IRowsetChange`: `SetData`, `DeleteRows`, or `InsertRow`."},{"pos":[7004,7091],"content":": Consumer can call <bpt id=\"p1\">**</bpt>IRowsetChange::DeleteRows<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`SetData`</ph> for newly inserted rows.","source":": Consumer can call **IRowsetChange::DeleteRows** or `SetData` for newly inserted rows."},{"pos":[7126,7177],"content":": Rowset will not reorder inserted or updated rows."},{"content":"If you implement IRowsetUpdateImpl","pos":[7190,7224]},{"pos":[7237,7415],"content":"If you implement <ph id=\"ph1\">`IRowsetUpdateImpl`</ph>, you must set the following properties on your provider, in addition to setting all the properties for <ph id=\"ph2\">`IRowsetChangeImpl`</ph> previously listed:","source":"If you implement `IRowsetUpdateImpl`, you must set the following properties on your provider, in addition to setting all the properties for `IRowsetChangeImpl` previously listed:"},{"pos":[7451,7452],"content":"."},{"pos":[7484,7521],"content":": Must be READ_ONLY AND VARIANT_TRUE."},{"pos":[7559,7596],"content":": Must be READ_ONLY AND VARIANT_TRUE."},{"pos":[7630,7667],"content":": Must be READ_ONLY AND VARIANT_TRUE."},{"pos":[7707,7744],"content":": Must be READ_ONLY AND VARIANT_TRUE."},{"pos":[7780,7817],"content":": Must be READ_ONLY AND VARIANT_TRUE."},{"pos":[7854,7855],"content":"."},{"pos":[7871,8022],"content":"[!NOTE]\n If you support notifications, you might also have some other properties as well; see the section on `IRowsetNotifyCP` for this list.","leadings":["","        > "],"nodes":[{"content":"If you support notifications, you might also have some other properties as well; see the section on <ph id=\"ph1\">`IRowsetNotifyCP`</ph> for this list.","pos":[9,141],"source":" If you support notifications, you might also have some other properties as well; see the section on `IRowsetNotifyCP` for this list."}]},{"pos":[8033,8221],"content":"For example of how the properties are set, see the property set map in <bpt id=\"p1\">**</bpt>CUpdateCommand<ept id=\"p1\">**</ept> (in Rowset.h) in <bpt id=\"p2\">[</bpt>UpdatePV<ept id=\"p2\">](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f)</ept>.","source":"For example of how the properties are set, see the property set map in **CUpdateCommand** (in Rowset.h) in [UpdatePV](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f)."},{"pos":[8274,8300],"content":"Writing to the Data Source"},{"content":"To read from the data source, call the <bpt id=\"p1\">**</bpt>Execute<ept id=\"p1\">**</ept> function.","pos":[8304,8364],"source":"To read from the data source, call the **Execute** function."},{"content":"To write to the data source, call the <ph id=\"ph1\">`FlushData`</ph> function.","pos":[8365,8424],"source":" To write to the data source, call the `FlushData` function."},{"content":"(In a general sense, flush means to save modifications you make to a table or index to disk.)","pos":[8425,8518]},{"content":"The row handle (<bpt id=\"p1\">*</bpt>HROW<ept id=\"p1\">*</ept>) and accessor handle (<bpt id=\"p2\">*</bpt>HACCESSOR<ept id=\"p2\">*</ept>) arguments allow you to specify the region to write.","pos":[8570,8679],"source":"The row handle (*HROW*) and accessor handle (*HACCESSOR*) arguments allow you to specify the region to write."},{"content":"Typically, you write a single data field at a time.","pos":[8680,8731]},{"content":"The <ph id=\"ph1\">`FlushData`</ph> method writes data in the format in which it was originally stored.","pos":[8738,8821],"source":"The `FlushData` method writes data in the format in which it was originally stored."},{"content":"If you do not override this function, your provider will function correctly but changes will not be flushed to the data store.","pos":[8822,8948]},{"content":"When to Flush","pos":[8958,8971]},{"pos":[8975,9153],"content":"The provider templates call <ph id=\"ph1\">`FlushData`</ph> whenever data needs to be written to the data store; this usually (but not always) occurs as a result of calls to the following functions:","source":"The provider templates call `FlushData` whenever data needs to be written to the data store; this usually (but not always) occurs as a result of calls to the following functions:"},{"content":"IRowsetChange::DeleteRows","pos":[9165,9190]},{"content":"IRowsetChange::SetData","pos":[9204,9226]},{"pos":[9238,9311],"content":"<bpt id=\"p1\">**</bpt>IRowsetChange::InsertRows<ept id=\"p1\">**</ept> (if there is new data to insert in the row)","source":"**IRowsetChange::InsertRows** (if there is new data to insert in the row)"},{"content":"IRowsetUpdate::Update","pos":[9323,9344]},{"content":"How It Works","pos":[9356,9368]},{"pos":[9372,9514],"content":"The consumer makes a call that requires a flush (such as <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>) and this call is passed to the provider, which always does the following:","source":"The consumer makes a call that requires a flush (such as **Update**) and this call is passed to the provider, which always does the following:"},{"pos":[9524,9653],"content":"Calls <ph id=\"ph1\">`SetDBStatus`</ph> whenever you have a status value bound (see <bpt id=\"p1\">*</bpt>OLE DB Programmers Reference<ept id=\"p1\">*</ept>, Chapter 6, <bpt id=\"p2\">*</bpt>Data Parts: Status<ept id=\"p2\">*</ept>).","source":"Calls `SetDBStatus` whenever you have a status value bound (see *OLE DB Programmers Reference*, Chapter 6, *Data Parts: Status*)."},{"content":"Checks column flags.","pos":[9663,9683]},{"pos":[9693,9717],"content":"Calls <ph id=\"ph1\">`IsUpdateAllowed`</ph>.","source":"Calls `IsUpdateAllowed`."},{"content":"These three steps help provide security.","pos":[9724,9764]},{"content":"Then the provider calls <ph id=\"ph1\">`FlushData`</ph>.","pos":[9765,9801],"source":" Then the provider calls `FlushData`."},{"content":"How to Implement FlushData","pos":[9811,9837]},{"pos":[9841,9912],"content":"To implement <ph id=\"ph1\">`FlushData`</ph>, you need to take into account several issues:","source":"To implement `FlushData`, you need to take into account several issues:"},{"content":"Making sure that the data store can handle changes.","pos":[9922,9973]},{"pos":[9983,10008],"content":"Handling <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> values.","source":"Handling **NULL** values."},{"content":"Handling default values.","pos":[10018,10042]},{"pos":[10049,10103],"content":"To implement your own <ph id=\"ph1\">`FlushData`</ph> method, you need to:","source":"To implement your own `FlushData` method, you need to:"},{"content":"Go to your rowset class.","pos":[10113,10137]},{"content":"In the rowset class put the declaration of:","pos":[10147,10190]},{"pos":[10324,10365],"content":"Provide an implementation of <ph id=\"ph1\">`FlushData`</ph>.","source":"Provide an implementation of `FlushData`."},{"content":"A good implementation of <ph id=\"ph1\">`FlushData`</ph> stores only the rows and columns that are actually updated.","pos":[10372,10468],"source":"A good implementation of `FlushData` stores only the rows and columns that are actually updated."},{"content":"You can use the <bpt id=\"p1\">*</bpt>HROW<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>HACCESSOR<ept id=\"p2\">*</ept> parameters to determine the current row and column being stored for optimization.","pos":[10469,10589],"source":" You can use the *HROW* and *HACCESSOR* parameters to determine the current row and column being stored for optimization."},{"content":"Typically, the biggest challenge is working with your own native data store.","pos":[10596,10672]},{"content":"If possible, try to:","pos":[10673,10693]},{"content":"Keep the method of writing to your data store as simple as possible.","pos":[10703,10771]},{"pos":[10781,10827],"content":"Handle <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> values (optional but advised).","source":"Handle **NULL** values (optional but advised)."},{"content":"Handle default values (optional but advised).","pos":[10837,10882]},{"content":"The best thing to do is to have actual specified values in your data store for <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> and default values.","pos":[10889,10996],"source":"The best thing to do is to have actual specified values in your data store for **NULL** and default values."},{"content":"It is best if you can extrapolate this data.","pos":[10997,11041]},{"content":"If not, you are advised not to allow <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> and default values.","pos":[11042,11107],"source":" If not, you are advised not to allow **NULL** and default values."},{"pos":[11114,11331],"content":"The following example shows how <ph id=\"ph1\">`FlushData`</ph> is implemented in the <ph id=\"ph2\">`RUpdateRowset`</ph> class in the <bpt id=\"p1\">[</bpt>UpdatePV<ept id=\"p1\">](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f)</ept> sample (see Rowset.h in the sample code):","source":"The following example shows how `FlushData` is implemented in the `RUpdateRowset` class in the [UpdatePV](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f) sample (see Rowset.h in the sample code):"},{"content":"Handling Changes","pos":[13842,13858]},{"content":"For your provider to handle changes, you first need to make sure your data store (such as a text file or video file) has facilities that enable you to make changes on it.","pos":[13862,14032]},{"content":"If it does not, you should create that code separately from the provider project.","pos":[14033,14114]},{"content":"Handling NULL Data","pos":[14124,14142]},{"content":"It is possible that an end user will send <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> data.","pos":[14146,14202],"source":"It is possible that an end user will send **NULL** data."},{"content":"When you write <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> values to fields in the data source, there can be potential problems.","pos":[14203,14296],"source":" When you write **NULL** values to fields in the data source, there can be potential problems."},{"content":"Imagine an order-taking application that accepts values for city and postal code; it could accept either or both values, but not neither, because in that case delivery would be impossible.","pos":[14297,14485]},{"content":"You therefore have to restrict certain combinations of <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> values in fields that make sense for your application.","pos":[14486,14604],"source":" You therefore have to restrict certain combinations of **NULL** values in fields that make sense for your application."},{"content":"As the provider developer, you have to consider how you will store that data, how you will read that data from the data store, and how you specify that to the user.","pos":[14611,14775]},{"content":"Specifically, you must consider how to change the data status of rowset data in the data source (for example, DataStatus = <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>).","pos":[14776,14909],"source":" Specifically, you must consider how to change the data status of rowset data in the data source (for example, DataStatus = **NULL**)."},{"content":"You decide what value to return when a consumer accesses a field containing a <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> value.","pos":[14910,15003],"source":" You decide what value to return when a consumer accesses a field containing a **NULL** value."},{"content":"Look at the code in the <bpt id=\"p1\">[</bpt>UpdatePV<ept id=\"p1\">](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f)</ept> sample; it illustrates how a provider can handle <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept> data.","pos":[15010,15178],"source":"Look at the code in the [UpdatePV](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f) sample; it illustrates how a provider can handle **NULL** data."},{"content":"In UpdatePV, the provider stores <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> data by writing the string \"NULL\" in the data store.","pos":[15179,15273],"source":" In UpdatePV, the provider stores **NULL** data by writing the string \"NULL\" in the data store."},{"content":"When it reads <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> data from the data store, it sees that string and then empties the buffer, creating a <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept> string.","pos":[15274,15399],"source":" When it reads **NULL** data from the data store, it sees that string and then empties the buffer, creating a **NULL** string."},{"content":"It also has an override of <ph id=\"ph1\">`IRowsetImpl::GetDBStatus`</ph> in which it returns <bpt id=\"p1\">**</bpt>DBSTATUS_S_ISNULL<ept id=\"p1\">**</ept> if that data value is empty.","pos":[15400,15524],"source":" It also has an override of `IRowsetImpl::GetDBStatus` in which it returns **DBSTATUS_S_ISNULL** if that data value is empty."},{"content":"Marking Nullable Columns","pos":[15534,15558]},{"pos":[15562,15799],"content":"If you also implement schema rowsets (see <ph id=\"ph1\">`IDBSchemaRowsetImpl`</ph>), your implementation should specify in the <bpt id=\"p1\">**</bpt>DBSCHEMA_COLUMNS<ept id=\"p1\">**</ept> rowset (usually marked in your provider by <bpt id=\"p2\">**</bpt>C<ept id=\"p2\">**</ept><bpt id=\"p3\">*</bpt>xxx<ept id=\"p3\">*</ept><bpt id=\"p4\">**</bpt>SchemaColSchemaRowset<ept id=\"p4\">**</ept>) that the column is nullable.","source":"If you also implement schema rowsets (see `IDBSchemaRowsetImpl`), your implementation should specify in the **DBSCHEMA_COLUMNS** rowset (usually marked in your provider by **C***xxx***SchemaColSchemaRowset**) that the column is nullable."},{"pos":[15806,15943],"content":"You also need to specify that all nullable columns contain the <bpt id=\"p1\">**</bpt>DBCOLUMNFLAGS_ISNULLABLE<ept id=\"p1\">**</ept> value in your version of the <ph id=\"ph1\">`GetColumnInfo`</ph>.","source":"You also need to specify that all nullable columns contain the **DBCOLUMNFLAGS_ISNULLABLE** value in your version of the `GetColumnInfo`."},{"content":"In the OLE DB templates implementation, if you fail to mark columns as nullable, the provider assumes that they must contain a value and will not allow the consumer to send it null values.","pos":[15950,16138]},{"content":"The following example shows how the <bpt id=\"p1\">**</bpt>CommonGetColInfo<ept id=\"p1\">**</ept> function is implemented in <bpt id=\"p2\">**</bpt>CUpdateCommand<ept id=\"p2\">**</ept> (see UpProvRS.cpp) in UpdatePV.","pos":[16145,16279],"source":"The following example shows how the **CommonGetColInfo** function is implemented in **CUpdateCommand** (see UpProvRS.cpp) in UpdatePV."},{"content":"Note how the columns have this <bpt id=\"p1\">**</bpt>DBCOLUMNFLAGS_ISNULLABLE<ept id=\"p1\">**</ept> for nullable columns.","pos":[16280,16361],"source":" Note how the columns have this **DBCOLUMNFLAGS_ISNULLABLE** for nullable columns."},{"content":"Default Values","pos":[18373,18387]},{"pos":[18391,18479],"content":"As with <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> data, you have the responsibility to deal with changing default values.","source":"As with **NULL** data, you have the responsibility to deal with changing default values."},{"content":"The default of <ph id=\"ph1\">`FlushData`</ph> and <bpt id=\"p1\">**</bpt>Execute<ept id=\"p1\">**</ept> is to return <ph id=\"ph2\">`S_OK`</ph>.","pos":[18486,18549],"source":"The default of `FlushData` and **Execute** is to return `S_OK`."},{"content":"Therefore, if you do not override this function, the changes appear to succeed (<ph id=\"ph1\">`S_OK`</ph> will be returned), but they will not be transmitted to the data store.","pos":[18550,18707],"source":" Therefore, if you do not override this function, the changes appear to succeed (`S_OK` will be returned), but they will not be transmitted to the data store."},{"pos":[18714,18883],"content":"In the <bpt id=\"p1\">[</bpt>UpdatePV<ept id=\"p1\">](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f)</ept> sample (in Rowset.h), the <ph id=\"ph1\">`SetDBStatus`</ph> method handles default values as follows:","source":"In the [UpdatePV](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f) sample (in Rowset.h), the `SetDBStatus` method handles default values as follows:"},{"content":"Column Flags","pos":[19900,19912]},{"content":"If you support default values on your columns, you need to set it using metadata in the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\&lt;</ph><ept id=\"p1\">**</ept><bpt id=\"p2\">*</bpt>provider class<ept id=\"p2\">*</ept><bpt id=\"p3\">**</bpt>&gt;SchemaRowset<ept id=\"p3\">**</ept> class.","pos":[19916,20050],"source":"If you support default values on your columns, you need to set it using metadata in the **\\<***provider class***>SchemaRowset** class."},{"content":"Set <bpt id=\"p1\">*</bpt>m_bColumnHasDefault<ept id=\"p1\">*</ept><ph id=\"ph1\"> = `VARIANT_TRUE`</ph>.","pos":[20051,20094],"source":" Set *m_bColumnHasDefault* = `VARIANT_TRUE`."},{"content":"You also have the responsibility to set the column flags, which are specified using the <bpt id=\"p1\">**</bpt>DBCOLUMNFLAGS<ept id=\"p1\">**</ept> enumerated type.","pos":[20101,20223],"source":"You also have the responsibility to set the column flags, which are specified using the **DBCOLUMNFLAGS** enumerated type."},{"content":"The column flags describe column characteristics.","pos":[20224,20273]},{"pos":[20280,20474],"content":"For example, in the <ph id=\"ph1\">`CUpdateSessionColSchemaRowset`</ph> class in <bpt id=\"p1\">[</bpt>UpdatePV<ept id=\"p1\">](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f)</ept> (in Session.h), the first column is set up this way:","source":"For example, in the `CUpdateSessionColSchemaRowset` class in [UpdatePV](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f) (in Session.h), the first column is set up this way:"},{"content":"This code specifies, among other things, that the column supports a default value of 0, that it be writeable, and that all data in the column have the same length.","pos":[20916,21079]},{"content":"If you want the data in a column to have variable length, you would not set this flag.","pos":[21080,21166]},{"content":"See Also","pos":[21175,21183]},{"content":"Creating an OLE DB Provider","pos":[21188,21215]}],"content":"---\ntitle: \"Creating an Updatable Provider | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"OLE DB providers, updatable\"\n  - \"notifications, support in providers\"\n  - \"OLE DB providers, creating\"\nms.assetid: bdfd5c9f-1c6f-4098-822c-dd650e70ab82\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Creating an Updatable Provider\nVisual C++ 6.0 supported only read-only providers. Visual C++ .NET supports updatable providers or providers that can update (write to) the data store. This topic discusses how to create updatable providers using OLE DB templates.  \n  \n This topic assumes that you are starting with a workable provider. There are two steps to creating an updatable provider. You must first decide how the provider will make changes to the data store; specifically, whether changes are to be done immediately or deferred until an update command is issued. The section \"[Making Providers Updatable](#vchowmakingprovidersupdatable)\" describes the changes and settings you need to do in the provider code.  \n  \n Next, you must make sure your provider contains all the functionality to support anything the consumer might request of it. If the consumer wants to update the data store, the provider has to contain code that persists data to the data store. For example, you might use the C Run-Time Library or MFC to perform such operations on your data source. The section \"[Writing to the Data Source](#vchowwritingtothedatasource)\" describes how to write to the data source, deal with **NULL** and default values, and set column flags.  \n  \n> [!NOTE]\n>  UpdatePV is an example of an updatable provider. UpdatePV is the same as MyProv but with updatable support.  \n  \n##  <a name=\"vchowmakingprovidersupdatable\"></a> Making Providers Updatable  \n The key to making a provider updatable is understanding what operations you want your provider to perform on the data store and how you want the provider to carry out those operations. Specifically, the major issue is whether updates to the data store are to be done immediately or deferred (batched) until an update command is issued.  \n  \n You must first decide whether to inherit from `IRowsetChangeImpl` or `IRowsetUpdateImpl` in your rowset class. Depending on which of these you choose to implement, the functionality of three methods will be affected: `SetData`, **InsertRows**, and `DeleteRows`.  \n  \n-   If you inherit from [IRowsetChangeImpl](../../data/oledb/irowsetchangeimpl-class.md), calling these three methods immediately changes the data store.  \n  \n-   If you inherit from [IRowsetUpdateImpl](../../data/oledb/irowsetupdateimpl-class.md), the methods defer changes to the data store until you call **Update**, `GetOriginalData`, or **Undo**. If the update involves several changes, they are performed in batch mode (note that batching changes can add considerable memory overhead).  \n  \n Note that `IRowsetUpdateImpl` derives from `IRowsetChangeImpl`. Thus, `IRowsetUpdateImpl` gives you change capability plus batch capability.  \n  \n#### To support updatability in your provider  \n  \n1.  In your rowset class, inherit from `IRowsetChangeImpl` or `IRowsetUpdateImpl`. These classes provide appropriate interfaces for changing the data store:  \n  \n     **Adding IRowsetChange**  \n  \n     Add `IRowsetChangeImpl` to your inheritance chain using this form:  \n  \n    ```  \n    IRowsetChangeImpl< rowset-name, storage-name >  \n    ```  \n  \n     Also add `COM_INTERFACE_ENTRY(IRowsetChange)` to the `BEGIN_COM_MAP` section in your rowset class.  \n  \n     **Adding IRowsetUpdate**  \n  \n     Add `IRowsetUpdate` to your inheritance chain using this form:  \n  \n    ```  \n    IRowsetUpdateImpl< rowset-name, storage>  \n    ```  \n  \n    > [!NOTE]\n    >  You should remove the `IRowsetChangeImpl` line from your inheritance chain. This one exception to the directive previously mentioned must include the code for `IRowsetChangeImpl`.  \n  \n2.  Add the following to your COM map (**BEGIN_COM_MAP ... END_COM_MAP**):  \n  \n    |If you implement|Add to COM map|  \n    |----------------------|--------------------|  \n    |`IRowsetChangeImpl`|`COM_INTERFACE_ENTRY(IRowsetChange)`|  \n    |`IRowsetUpdateImpl`|`COM_INTERFACE_ENTRY(IRowsetChange)COM_INTERFACE_ENTRY(IRowsetUpdate)`|  \n  \n3.  In your command, add the following to your property set map (**BEGIN_PROPSET_MAP ... END_PROPSET_MAP**):  \n  \n    |If you implement|Add to property set map|  \n    |----------------------|-----------------------------|  \n    |`IRowsetChangeImpl`|`PROPERTY_INFO_ENTRY_VALUE(IRowsetChange, VARIANT_FALSE)`|  \n    |`IRowsetUpdateImpl`|`PROPERTY_INFO_ENTRY_VALUE(IRowsetChange, VARIANT_FALSE)PROPERTY_INFO_ENTRY_VALUE(IRowsetUpdate, VARIANT_FALSE)`|  \n  \n4.  In your property set map, you should also include all of the following settings as they appear below:  \n  \n    ```  \n    PROPERTY_INFO_ENTRY_VALUE(UPDATABILITY, DBPROPVAL_UP_CHANGE |   \n      DBPROPVAL_UP_INSERT | DBPROPVAL_UP_DELETE)  \n    PROPERTY_INFO_ENTRY_VALUE(CHANGEINSERTEDROWS, VARIANT_TRUE)  \n    PROPERTY_INFO_ENTRY_VALUE(IMMOBILEROWS, VARIANT_TRUE)  \n  \n    PROPERTY_INFO_ENTRY_EX(OWNINSERT, VT_BOOL, DBPROPFLAGS_ROWSET |   \n      DBPROPFLAGS_READ, VARIANT_TRUE, 0)  \n    PROPERTY_INFO_ENTRY_EX(OWNUPDATEDELETE, VT_BOOL, DBPROPFLAGS_ROWSET |   \n      DBPROPFLAGS_READ, VARIANT_TRUE, 0)  \n    PROPERTY_INFO_ENTRY_EX(OTHERINSERT, VT_BOOL, DBPROPFLAGS_ROWSET |   \n      DBPROPFLAGS_READ, VARIANT_TRUE, 0)  \n    PROPERTY_INFO_ENTRY_EX(OTHERUPDATEDELETE, VT_BOOL, DBPROPFLAGS_ROWSET |   \n      DBPROPFLAGS_READ, VARIANT_TRUE, 0)  \n    PROPERTY_INFO_ENTRY_EX(REMOVEDELETED, VT_BOOL, DBPROPFLAGS_ROWSET |   \n      DBPROPFLAGS_READ, VARIANT_FALSE, 0)  \n    ```  \n  \n     You can find the values used in these macro calls by looking in Atldb.h for the property IDs and values (if Atldb.h differs from the online documentation, Atldb.h supersedes the documentation).  \n  \n    > [!NOTE]\n    >  Many of the **VARIANT_FALSE** and `VARIANT_TRUE` settings are required by the OLE DB templates; the OLE DB specification says they can be read/write, but the OLE DB templates can only support one value.  \n  \n     **If you implement IRowsetChangeImpl**  \n  \n     If you implement `IRowsetChangeImpl`, you must set the following properties on your provider. These properties are primarily used to request interfaces through **ICommandProperties::SetProperties**.  \n  \n    -   `DBPROP_IRowsetChange`: Setting this automatically sets **DBPROP_IRowsetChange**.  \n  \n    -   `DBPROP_UPDATABILITY`: A bitmask specifying the supported methods on `IRowsetChange`: `SetData`, `DeleteRows`, or `InsertRow`.  \n  \n    -   `DBPROP_CHANGEINSERTEDROWS`: Consumer can call **IRowsetChange::DeleteRows** or `SetData` for newly inserted rows.  \n  \n    -   `DBPROP_IMMOBILEROWS`: Rowset will not reorder inserted or updated rows.  \n  \n     **If you implement IRowsetUpdateImpl**  \n  \n     If you implement `IRowsetUpdateImpl`, you must set the following properties on your provider, in addition to setting all the properties for `IRowsetChangeImpl` previously listed:  \n  \n    -   `DBPROP_IRowsetUpdate`.  \n  \n    -   `DBPROP_OWNINSERT`: Must be READ_ONLY AND VARIANT_TRUE.  \n  \n    -   `DBPROP_OWNUPDATEDELETE`: Must be READ_ONLY AND VARIANT_TRUE.  \n  \n    -   `DBPROP_OTHERINSERT`: Must be READ_ONLY AND VARIANT_TRUE.  \n  \n    -   `DBPROP_OTHERUPDATEDELETE`: Must be READ_ONLY AND VARIANT_TRUE.  \n  \n    -   `DBPROP_REMOVEDELETED`: Must be READ_ONLY AND VARIANT_TRUE.  \n  \n    -   `DBPROP_MAXPENDINGROWS`.  \n  \n        > [!NOTE]\n        >  If you support notifications, you might also have some other properties as well; see the section on `IRowsetNotifyCP` for this list.  \n  \n     For example of how the properties are set, see the property set map in **CUpdateCommand** (in Rowset.h) in [UpdatePV](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f).  \n  \n##  <a name=\"vchowwritingtothedatasource\"></a> Writing to the Data Source  \n To read from the data source, call the **Execute** function. To write to the data source, call the `FlushData` function. (In a general sense, flush means to save modifications you make to a table or index to disk.)  \n  \n```  \nFlushData(HROW, HACCESSOR);  \n```  \n  \n The row handle (*HROW*) and accessor handle (*HACCESSOR*) arguments allow you to specify the region to write. Typically, you write a single data field at a time.  \n  \n The `FlushData` method writes data in the format in which it was originally stored. If you do not override this function, your provider will function correctly but changes will not be flushed to the data store.  \n  \n### When to Flush  \n The provider templates call `FlushData` whenever data needs to be written to the data store; this usually (but not always) occurs as a result of calls to the following functions:  \n  \n-   **IRowsetChange::DeleteRows**  \n  \n-   **IRowsetChange::SetData**  \n  \n-   **IRowsetChange::InsertRows** (if there is new data to insert in the row)  \n  \n-   **IRowsetUpdate::Update**  \n  \n### How It Works  \n The consumer makes a call that requires a flush (such as **Update**) and this call is passed to the provider, which always does the following:  \n  \n-   Calls `SetDBStatus` whenever you have a status value bound (see *OLE DB Programmers Reference*, Chapter 6, *Data Parts: Status*).  \n  \n-   Checks column flags.  \n  \n-   Calls `IsUpdateAllowed`.  \n  \n These three steps help provide security. Then the provider calls `FlushData`.  \n  \n### How to Implement FlushData  \n To implement `FlushData`, you need to take into account several issues:  \n  \n-   Making sure that the data store can handle changes.  \n  \n-   Handling **NULL** values.  \n  \n-   Handling default values.  \n  \n To implement your own `FlushData` method, you need to:  \n  \n-   Go to your rowset class.  \n  \n-   In the rowset class put the declaration of:  \n  \n```  \nHRESULT FlushData(HROW, HACCESSOR)  \n{  \n    // Insert your implementation here and return an HRESULT.  \n}  \n```  \n  \n-   Provide an implementation of `FlushData`.  \n  \n A good implementation of `FlushData` stores only the rows and columns that are actually updated. You can use the *HROW* and *HACCESSOR* parameters to determine the current row and column being stored for optimization.  \n  \n Typically, the biggest challenge is working with your own native data store. If possible, try to:  \n  \n-   Keep the method of writing to your data store as simple as possible.  \n  \n-   Handle **NULL** values (optional but advised).  \n  \n-   Handle default values (optional but advised).  \n  \n The best thing to do is to have actual specified values in your data store for **NULL** and default values. It is best if you can extrapolate this data. If not, you are advised not to allow **NULL** and default values.  \n  \n The following example shows how `FlushData` is implemented in the `RUpdateRowset` class in the [UpdatePV](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f) sample (see Rowset.h in the sample code):  \n  \n```  \n///////////////////////////////////////////////////////////////////////////  \n// class RUpdateRowset (in rowset.h)  \n...  \nHRESULT FlushData(HROW, HACCESSOR)  \n{  \n    ATLTRACE2(atlTraceDBProvider, 0, \"RUpdateRowset::FlushData\\n\");  \n  \n    USES_CONVERSION;  \n    enum {  \n        sizeOfString = 256,  \n        sizeOfFileName = MAX_PATH  \n    };  \n    FILE*    pFile = NULL;  \n    TCHAR    szString[sizeOfString];  \n    TCHAR    szFile[sizeOfFileName];  \n    errcode  err = 0;  \n  \n    ObjectLock lock(this);  \n  \n    // From a filename, passed in as a command text,   \n    // scan the file placing data in the data array.  \n    if (m_strCommandText == (BSTR)NULL)  \n    {  \n        ATLTRACE( \"RRowsetUpdate::FlushData -- \"  \n                  \"No filename specified\\n\");  \n        return E_FAIL;  \n    }  \n  \n    // Open the file  \n    _tcscpy_s(szFile, sizeOfFileName, OLE2T(m_strCommandText));  \n    if ((szFile[0] == _T('\\0')) ||   \n        ((err = _tfopen_s(&pFile, &szFile[0], _T(\"w\"))) != 0))  \n    {  \n        ATLTRACE(\"RUpdateRowset::FlushData -- Could not open file\\n\");  \n        return DB_E_NOTABLE;  \n    }  \n  \n    // Iterate through the row data and store it.  \n    for (long l=0; l<m_rgRowData.GetSize(); l++)  \n    {  \n        CAgentMan am = m_rgRowData[l];  \n  \n        _putw((int)am.dwFixed, pFile);  \n  \n        if (_tcscmp(&am.szCommand[0], _T(\"\")) != 0)  \n            _stprintf_s(&szString[0], _T(\"%s\\n\"), am.szCommand);  \n        else  \n            _stprintf_s(&szString[0], _T(\"%s\\n\"), _T(\"NULL\"));  \n        _fputts(szString, pFile);  \n  \n        if (_tcscmp(&am.szText[0], _T(\"\")) != 0)  \n            _stprintf_s(&szString[0], _T(\"%s\\n\"), am.szText);  \n        else  \n            _stprintf_s(&szString[0], _T(\"%s\\n\"), _T(\"NULL\"));  \n        _fputts(szString, pFile);  \n  \n        if (_tcscmp(&am.szCommand2[0], _T(\"\")) != 0)  \n            _stprintf_s(&szString[0], _T(\"%s\\n\"), am.szCommand2);  \n        else  \n            _stprintf_s(&szString[0], _T(\"%s\\n\"), _T(\"NULL\"));  \n        _fputts(szString, pFile);  \n  \n        if (_tcscmp(&am.szText2[0], _T(\"\")) != 0)  \n            _stprintf_s(&szString[0], _T(\"%s\\n\"), am.szText2);  \n        else  \n            _stprintf_s(&szString[0], _T(\"%s\\n\"), _T(\"NULL\"));  \n        _fputts(szString, pFile);  \n    }  \n  \n    if (fflush(pFile) == EOF || fclose(pFile) == EOF)  \n    {  \n        ATLTRACE(\"RRowsetUpdate::FlushData -- \"  \n                 \"Couldn't flush or close file\\n\");  \n    }  \n  \n    return S_OK;  \n}  \n```  \n  \n### Handling Changes  \n For your provider to handle changes, you first need to make sure your data store (such as a text file or video file) has facilities that enable you to make changes on it. If it does not, you should create that code separately from the provider project.  \n  \n### Handling NULL Data  \n It is possible that an end user will send **NULL** data. When you write **NULL** values to fields in the data source, there can be potential problems. Imagine an order-taking application that accepts values for city and postal code; it could accept either or both values, but not neither, because in that case delivery would be impossible. You therefore have to restrict certain combinations of **NULL** values in fields that make sense for your application.  \n  \n As the provider developer, you have to consider how you will store that data, how you will read that data from the data store, and how you specify that to the user. Specifically, you must consider how to change the data status of rowset data in the data source (for example, DataStatus = **NULL**). You decide what value to return when a consumer accesses a field containing a **NULL** value.  \n  \n Look at the code in the [UpdatePV](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f) sample; it illustrates how a provider can handle **NULL** data. In UpdatePV, the provider stores **NULL** data by writing the string \"NULL\" in the data store. When it reads **NULL** data from the data store, it sees that string and then empties the buffer, creating a **NULL** string. It also has an override of `IRowsetImpl::GetDBStatus` in which it returns **DBSTATUS_S_ISNULL** if that data value is empty.  \n  \n### Marking Nullable Columns  \n If you also implement schema rowsets (see `IDBSchemaRowsetImpl`), your implementation should specify in the **DBSCHEMA_COLUMNS** rowset (usually marked in your provider by **C***xxx***SchemaColSchemaRowset**) that the column is nullable.  \n  \n You also need to specify that all nullable columns contain the **DBCOLUMNFLAGS_ISNULLABLE** value in your version of the `GetColumnInfo`.  \n  \n In the OLE DB templates implementation, if you fail to mark columns as nullable, the provider assumes that they must contain a value and will not allow the consumer to send it null values.  \n  \n The following example shows how the **CommonGetColInfo** function is implemented in **CUpdateCommand** (see UpProvRS.cpp) in UpdatePV. Note how the columns have this **DBCOLUMNFLAGS_ISNULLABLE** for nullable columns.  \n  \n```  \n/////////////////////////////////////////////////////////////////////////////  \n// CUpdateCommand (in UpProvRS.cpp)  \n  \nATLCOLUMNINFO* CommonGetColInfo(IUnknown* pPropsUnk, ULONG* pcCols, bool bBookmark)  \n{  \n    static ATLCOLUMNINFO _rgColumns[6];  \n    ULONG ulCols = 0;  \n  \n    if (bBookmark)  \n    {  \n        ADD_COLUMN_ENTRY_EX(ulCols, OLESTR(\"Bookmark\"), 0,  \n                            sizeof(DWORD), DBTYPE_BYTES,  \n                            0, 0, GUID_NULL, CAgentMan, dwBookmark,  \n                            DBCOLUMNFLAGS_ISBOOKMARK)  \n        ulCols++;  \n    }  \n  \n    // Next set the other columns up.  \n    // Add a fixed length entry for OLE DB conformance testing purposes  \n    ADD_COLUMN_ENTRY_EX(ulCols, OLESTR(\"Fixed\"), 1, 4, DBTYPE_UI4,  \n                        10, 255, GUID_NULL, CAgentMan, dwFixed,   \n                        DBCOLUMNFLAGS_WRITE |   \n                        DBCOLUMNFLAGS_ISFIXEDLENGTH)  \n    ulCols++;  \n  \n    ADD_COLUMN_ENTRY_EX(ulCols, OLESTR(\"Command\"), 2, 16, DBTYPE_STR,  \n                        255, 255, GUID_NULL, CAgentMan, szCommand,  \n                        DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE)  \n    ulCols++;  \n    ADD_COLUMN_ENTRY_EX(ulCols, OLESTR(\"Text\"), 3, 16, DBTYPE_STR,   \n                        255, 255, GUID_NULL, CAgentMan, szText,   \n                        DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE)  \n    ulCols++;  \n  \n    ADD_COLUMN_ENTRY_EX(ulCols, OLESTR(\"Command2\"), 4, 16, DBTYPE_STR,  \n                        255, 255, GUID_NULL, CAgentMan, szCommand2,   \n                        DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE)  \n    ulCols++;  \n    ADD_COLUMN_ENTRY_EX(ulCols, OLESTR(\"Text2\"), 5, 16, DBTYPE_STR,  \n                        255, 255, GUID_NULL, CAgentMan, szText2,   \n                        DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE)  \n    ulCols++;  \n  \n    if (pcCols != NULL)  \n    {  \n        *pcCols = ulCols;  \n    }  \n  \n    return _rgColumns;  \n}  \n```  \n  \n### Default Values  \n As with **NULL** data, you have the responsibility to deal with changing default values.  \n  \n The default of `FlushData` and **Execute** is to return `S_OK`. Therefore, if you do not override this function, the changes appear to succeed (`S_OK` will be returned), but they will not be transmitted to the data store.  \n  \n In the [UpdatePV](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f) sample (in Rowset.h), the `SetDBStatus` method handles default values as follows:  \n  \n```  \nvirtual HRESULT SetDBStatus(DBSTATUS* pdbStatus, CSimpleRow* pRow,  \n                            ATLCOLUMNINFO* pColInfo)  \n{  \n    ATLASSERT(pRow != NULL && pColInfo != NULL && pdbStatus != NULL);  \n  \n    void* pData = NULL;  \n    char* pDefaultData = NULL;  \n    DWORD* pFixedData = NULL;  \n  \n    switch (*pdbStatus)  \n    {  \n        case DBSTATUS_S_DEFAULT:  \n            pData = (void*)&m_rgRowData[pRow->m_iRowset];  \n            if (pColInfo->wType == DBTYPE_STR)  \n            {  \n                pDefaultData = (char*)pData + pColInfo->cbOffset;  \n                strcpy_s(pDefaultData, \"Default\");  \n            }  \n            else  \n            {  \n                pFixedData = (DWORD*)((BYTE*)pData +   \n                                          pColInfo->cbOffset);  \n                *pFixedData = 0;  \n                return S_OK;  \n            }  \n            break;  \n        case DBSTATUS_S_ISNULL:  \n        default:  \n            break;  \n    }  \n    return S_OK;  \n}  \n```  \n  \n### Column Flags  \n If you support default values on your columns, you need to set it using metadata in the **\\<***provider class***>SchemaRowset** class. Set *m_bColumnHasDefault* = `VARIANT_TRUE`.  \n  \n You also have the responsibility to set the column flags, which are specified using the **DBCOLUMNFLAGS** enumerated type. The column flags describe column characteristics.  \n  \n For example, in the `CUpdateSessionColSchemaRowset` class in [UpdatePV](http://msdn.microsoft.com/en-us/c8bed873-223c-4a7d-af55-f90138c6f38f) (in Session.h), the first column is set up this way:  \n  \n```  \n// Set up column 1  \ntrData[0].m_ulOrdinalPosition = 1;  \ntrData[0].m_bIsNullable = VARIANT_FALSE;  \ntrData[0].m_bColumnHasDefault = VARIANT_TRUE;  \ntrData[0].m_nDataType = DBTYPE_UI4;  \ntrData[0].m_nNumericPrecision = 10;  \ntrData[0].m_ulColumnFlags = DBCOLUMNFLAGS_WRITE |  \n                            DBCOLUMNFLAGS_ISFIXEDLENGTH;  \nlstrcpyW(trData[0].m_szColumnDefault, OLESTR(\"0\"));  \nm_rgRowData.Add(trData[0]);  \n```  \n  \n This code specifies, among other things, that the column supports a default value of 0, that it be writeable, and that all data in the column have the same length. If you want the data in a column to have variable length, you would not set this flag.  \n  \n## See Also  \n [Creating an OLE DB Provider](../../data/oledb/creating-an-ole-db-provider.md)"}