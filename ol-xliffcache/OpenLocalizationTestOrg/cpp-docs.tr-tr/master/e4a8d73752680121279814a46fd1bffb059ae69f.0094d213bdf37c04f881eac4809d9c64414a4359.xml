{"nodes":[{"pos":[12,47],"content":"strstreambuf Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"strstreambuf Class | Microsoft Docs","pos":[0,35]}]},{"content":"strstreambuf Class","pos":[655,673]},{"pos":[674,810],"content":"Describes a stream buffer that controls the transmission of elements to and from a sequence of elements stored in a <ph id=\"ph1\">`char`</ph> array object.","source":"Describes a stream buffer that controls the transmission of elements to and from a sequence of elements stored in a `char` array object."},{"content":"Syntax","pos":[819,825]},{"content":"Remarks","pos":[889,896]},{"content":"Depending on how the object is constructed, it can be allocated, extended, and freed as necessary to accommodate changes in the sequence.","pos":[900,1037]},{"content":"An object of class <ph id=\"ph1\">`strstreambuf`</ph> stores several bits of mode information as its <ph id=\"ph2\">`strstreambuf`</ph> mode.","pos":[1044,1145],"source":"An object of class `strstreambuf` stores several bits of mode information as its `strstreambuf` mode."},{"content":"These bits indicate whether the controlled sequence:","pos":[1146,1198]},{"content":"Has been allocated and needs to be freed eventually.","pos":[1208,1260]},{"content":"Is modifiable.","pos":[1270,1284]},{"content":"Is extendable by reallocating storage.","pos":[1294,1332]},{"content":"Has been frozen and hence needs to be unfrozen before the object is destroyed, or freed (if allocated) by an agency other than the object.","pos":[1342,1480]},{"content":"A controlled sequence that is frozen cannot be modified or extended, regardless of the state of these separate mode bits.","pos":[1487,1608]},{"content":"The object also stores pointers to two functions that control <ph id=\"ph1\">`strstreambuf`</ph> allocation.","pos":[1615,1703],"source":"The object also stores pointers to two functions that control `strstreambuf` allocation."},{"content":"If these are null pointers, the object devises its own method of allocating and freeing storage for the controlled sequence.","pos":[1704,1828]},{"pos":[1836,2027],"content":"[!NOTE]\n This class is deprecated. Consider using [stringbuf](../standard-library/sstream-typedefs.md#stringbuf) or [wstringbuf](../standard-library/sstream-typedefs.md#wstringbuf) instead.","leadings":["","> "],"nodes":[{"content":" This class is deprecated. Consider using [stringbuf](../standard-library/sstream-typedefs.md#stringbuf) or [wstringbuf](../standard-library/sstream-typedefs.md#wstringbuf) instead.","pos":[8,189],"nodes":[{"content":"This class is deprecated.","pos":[1,26]},{"content":"Consider using <bpt id=\"p1\">[</bpt>stringbuf<ept id=\"p1\">](../standard-library/sstream-typedefs.md#stringbuf)</ept> or <bpt id=\"p2\">[</bpt>wstringbuf<ept id=\"p2\">](../standard-library/sstream-typedefs.md#wstringbuf)</ept> instead.","pos":[27,181],"source":" Consider using [stringbuf](../standard-library/sstream-typedefs.md#stringbuf) or [wstringbuf](../standard-library/sstream-typedefs.md#wstringbuf) instead."}]}]},{"content":"Constructors","pos":[2037,2049]},{"content":"strstreambuf","pos":[2071,2083]},{"pos":[2114,2158],"content":"Constructs an object of type <ph id=\"ph1\">`strstreambuf`</ph>.","source":"Constructs an object of type `strstreambuf`."},{"content":"Member Functions","pos":[2169,2185]},{"content":"freeze","pos":[2207,2213]},{"content":"Causes a stream buffer to be unavailable through stream buffer operations.","pos":[2238,2312]},{"content":"overflow","pos":[2318,2326]},{"content":"A protected virtual function that can be called when a new character is inserted into a full buffer.","pos":[2353,2453]},{"content":"pbackfail","pos":[2459,2468]},{"content":"A protected virtual member function that tries to put back an element into the input stream, and then make it the current element (pointed to by the next pointer).","pos":[2496,2659]},{"content":"pcount","pos":[2665,2671]},{"content":"Returns a count of the number of elements written to the controlled sequence.","pos":[2696,2773]},{"content":"seekoff","pos":[2779,2786]},{"content":"A protected virtual member function that tries to alter the current positions for the controlled streams.","pos":[2812,2917]},{"content":"seekpos","pos":[2923,2930]},{"content":"A protected virtual member function that tries to alter the current positions for the controlled streams.","pos":[2956,3061]},{"content":"str","pos":[3067,3070]},{"pos":[3092,3202],"content":"Calls <bpt id=\"p1\">[</bpt>freeze<ept id=\"p1\">](#strstreambuf__freeze)</ept>, and then returns a pointer to the beginning of the controlled sequence.","source":"Calls [freeze](#strstreambuf__freeze), and then returns a pointer to the beginning of the controlled sequence."},{"content":"underflow","pos":[3208,3217]},{"content":"A protected virtual function to extract the current element from the input stream.","pos":[3245,3327]},{"content":"Requirements","pos":[3337,3349]},{"pos":[3353,3377],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>strstream&gt;","source":"**Header:** \\<strstream>"},{"pos":[3384,3402],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[3449,3469],"content":"strstreambuf::freeze"},{"content":"Causes a stream buffer to be unavailable through stream buffer operations.","pos":[3473,3547]},{"content":"Parameters","pos":[3608,3618]},{"content":"A <ph id=\"ph1\">`bool`</ph> indicating whether you want the stream to be frozen.","pos":[3637,3698],"source":" A `bool` indicating whether you want the stream to be frozen."},{"content":"Remarks","pos":[3708,3715]},{"content":"If <ph id=\"ph1\">`_Freezeit`</ph> is true, the function alters the stored <ph id=\"ph2\">`strstreambuf`</ph> mode to make the controlled sequence frozen.","pos":[3719,3833],"source":"If `_Freezeit` is true, the function alters the stored `strstreambuf` mode to make the controlled sequence frozen."},{"content":"Otherwise, it makes the controlled sequence not frozen.","pos":[3834,3889]},{"pos":[3896,3939],"content":"<bpt id=\"p1\">[</bpt>str<ept id=\"p1\">](#strstreambuf__str)</ept> implies <ph id=\"ph1\">`freeze`</ph>.","source":"[str](#strstreambuf__str) implies `freeze`."},{"pos":[3947,4098],"content":"[!NOTE]\n A frozen buffer will not be freed during `strstreambuf` destruction. You must unfreeze the buffer before it is freed to avoid a memory leak.","leadings":["","> "],"nodes":[{"content":" A frozen buffer will not be freed during `strstreambuf` destruction. You must unfreeze the buffer before it is freed to avoid a memory leak.","pos":[8,149],"nodes":[{"content":"A frozen buffer will not be freed during <ph id=\"ph1\">`strstreambuf`</ph> destruction.","pos":[1,69],"source":" A frozen buffer will not be freed during `strstreambuf` destruction."},{"content":"You must unfreeze the buffer before it is freed to avoid a memory leak.","pos":[70,141]}]}]},{"content":"Example","pos":[4108,4115]},{"pos":[5501,5523],"content":"strstreambuf::overflow"},{"content":"A protected virtual function that can be called when a new character is inserted into a full buffer.","pos":[5527,5627]},{"content":"Parameters","pos":[5691,5701]},{"content":"The character to insert into the buffer, or <ph id=\"ph1\">`EOF`</ph>.","pos":[5716,5766],"source":" The character to insert into the buffer, or `EOF`."},{"content":"Return Value","pos":[5776,5788]},{"content":"If the function cannot succeed, it returns <ph id=\"ph1\">`EOF`</ph>.","pos":[5792,5841],"source":"If the function cannot succeed, it returns `EOF`."},{"content":"Otherwise, if _ <bpt id=\"p1\">*</bpt>Meta<ept id=\"p1\">*</ept><ph id=\"ph1\"> == `EOF`</ph>, it returns some value other than <ph id=\"ph2\">`EOF`</ph>.","pos":[5842,5914],"source":" Otherwise, if _ *Meta* == `EOF`, it returns some value other than `EOF`."},{"content":"Otherwise, it returns <ph id=\"ph1\">\\_</ph> <bpt id=\"p1\">*</bpt>Meta<ept id=\"p1\">*</ept>.","pos":[5915,5947],"source":" Otherwise, it returns \\_ *Meta*."},{"content":"Remarks","pos":[5957,5964]},{"content":"If _ <bpt id=\"p1\">*</bpt>Meta<ept id=\"p1\">*</ept> != <ph id=\"ph1\">`EOF`</ph>, the protected virtual member function tries to insert the element ( <ph id=\"ph2\">`char`</ph>)<ph id=\"ph3\">\\_</ph> <bpt id=\"p2\">*</bpt>Meta<ept id=\"p2\">*</ept> into the output buffer.","pos":[5968,6098],"source":"If _ *Meta* != `EOF`, the protected virtual member function tries to insert the element ( `char`)\\_ *Meta* into the output buffer."},{"content":"It can do so in various ways:","pos":[6099,6128]},{"content":"If a write position is available, it can store the element into the write position and increment the next pointer for the output buffer.","pos":[6138,6274]},{"content":"If the stored strstreambuf mode says the controlled sequence is modifiable, extendable, and not frozen, the function can make a write position available by allocating new for the output buffer.","pos":[6284,6477]},{"content":"Extending the output buffer this way also extends any associated input buffer.","pos":[6478,6556]},{"pos":[6606,6629],"content":"strstreambuf::pbackfail"},{"content":"A protected virtual member function that tries to put back an element into the input stream, and then makes it the current element (pointed to by the next pointer).","pos":[6633,6797]},{"content":"Parameters","pos":[6862,6872]},{"content":"The character to insert into the buffer, or <ph id=\"ph1\">`EOF`</ph>.","pos":[6887,6937],"source":" The character to insert into the buffer, or `EOF`."},{"content":"Return Value","pos":[6947,6959]},{"content":"If the function cannot succeed, it returns <ph id=\"ph1\">`EOF`</ph>.","pos":[6963,7012],"source":"If the function cannot succeed, it returns `EOF`."},{"content":"Otherwise, if _ <bpt id=\"p1\">*</bpt>Meta<ept id=\"p1\">*</ept><ph id=\"ph1\"> == `EOF`</ph>, it returns some value other than <ph id=\"ph2\">`EOF`</ph>.","pos":[7013,7085],"source":" Otherwise, if _ *Meta* == `EOF`, it returns some value other than `EOF`."},{"content":"Otherwise, it returns <ph id=\"ph1\">\\_</ph> <bpt id=\"p1\">*</bpt>Meta<ept id=\"p1\">*</ept>.","pos":[7086,7118],"source":" Otherwise, it returns \\_ *Meta*."},{"content":"Remarks","pos":[7128,7135]},{"content":"The protected virtual member function tries to put back an element into the input buffer, and then make it the current element (pointed to by the next pointer).","pos":[7139,7299]},{"content":"If _ <bpt id=\"p1\">*</bpt>Meta<ept id=\"p1\">*</ept><ph id=\"ph1\"> == `EOF`</ph>, the element to push back is effectively the one already in the stream before the current element.","pos":[7306,7425],"source":"If _ *Meta* == `EOF`, the element to push back is effectively the one already in the stream before the current element."},{"content":"Otherwise, that element is replaced by <bpt id=\"p1\">**</bpt>ch<ept id=\"p1\">**</ept> = ( <ph id=\"ph1\">`char`</ph>)<ph id=\"ph2\">\\_</ph> <bpt id=\"p2\">*</bpt>Meta<ept id=\"p2\">*</ept>.","pos":[7426,7493],"source":" Otherwise, that element is replaced by **ch** = ( `char`)\\_ *Meta*."},{"content":"The function can put back an element in various ways:","pos":[7494,7547]},{"pos":[7557,7703],"content":"If a putback position is available, and the element stored there compares equal to <bpt id=\"p1\">**</bpt>ch<ept id=\"p1\">**</ept>, it can decrement the next pointer for the input buffer.","source":"If a putback position is available, and the element stored there compares equal to **ch**, it can decrement the next pointer for the input buffer."},{"pos":[7713,7930],"content":"If a putback position is available, and if the strstreambuf mode says the controlled sequence is modifiable, the function can store <bpt id=\"p1\">**</bpt>ch<ept id=\"p1\">**</ept> into the putback position and decrement the next pointer for the input buffer.","source":"If a putback position is available, and if the strstreambuf mode says the controlled sequence is modifiable, the function can store **ch** into the putback position and decrement the next pointer for the input buffer."},{"pos":[7977,7997],"content":"strstreambuf::pcount"},{"content":"Returns a count of the number of elements written to the controlled sequence.","pos":[8001,8078]},{"content":"Return Value","pos":[8130,8142]},{"content":"A count of the number of elements written to the controlled sequence.","pos":[8146,8215]},{"content":"Remarks","pos":[8225,8232]},{"content":"Specifically, if <bpt id=\"p1\">[</bpt>pptr<ept id=\"p1\">](../standard-library/basic-streambuf-class.md#basic_streambuf__pptr)</ept> is a null pointer, the function returns zero.","pos":[8236,8373],"source":"Specifically, if [pptr](../standard-library/basic-streambuf-class.md#basic_streambuf__pptr) is a null pointer, the function returns zero."},{"content":"Otherwise, it returns <ph id=\"ph1\">`pptr`</ph> – <bpt id=\"p1\">[</bpt>pbase<ept id=\"p1\">](../standard-library/basic-streambuf-class.md#basic_streambuf__pbase)</ept>.","pos":[8374,8482],"source":" Otherwise, it returns `pptr` – [pbase](../standard-library/basic-streambuf-class.md#basic_streambuf__pbase)."},{"content":"Example","pos":[8492,8499]},{"pos":[8856,8877],"content":"strstreambuf::seekoff"},{"content":"A protected virtual member function that tries to alter the current positions for the controlled streams.","pos":[8881,8986]},{"content":"Parameters","pos":[9144,9154]},{"content":"The position to seek for relative to <ph id=\"ph1\">`_Way`</ph>.","pos":[9168,9212],"source":" The position to seek for relative to `_Way`."},{"content":"The starting point for offset operations.","pos":[9229,9270]},{"content":"See <bpt id=\"p1\">[</bpt>seekdir<ept id=\"p1\">](../standard-library/ios-base-class.md#ios_base__seekdir)</ept> for possible values.","pos":[9271,9362],"source":" See [seekdir](../standard-library/ios-base-class.md#ios_base__seekdir) for possible values."},{"content":"Specifies the mode for the pointer position.","pos":[9381,9425]},{"content":"The default is to allow you to modify the read and write positions.","pos":[9426,9493]},{"content":"Return Value","pos":[9503,9515]},{"content":"If the function succeeds in altering either or both stream positions, it returns the resultant stream position.","pos":[9519,9630]},{"content":"Otherwise, it fails and returns an invalid stream position.","pos":[9631,9690]},{"content":"Remarks","pos":[9700,9707]},{"content":"The protected virtual member function endeavors to alter the current positions for the controlled streams.","pos":[9711,9817]},{"content":"For an object of class strstreambuf, a stream position consists purely of a stream offset.","pos":[9818,9908]},{"content":"Offset zero designates the first element of the controlled sequence.","pos":[9909,9977]},{"content":"The new position is determined as follows:","pos":[9984,10026]},{"pos":[10036,10127],"content":"If <ph id=\"ph1\">`_Way` == `ios_base::beg`</ph>, the new position is the beginning of the stream plus _ <bpt id=\"p1\">*</bpt>Off<ept id=\"p1\">*</ept>.","source":"If `_Way` == `ios_base::beg`, the new position is the beginning of the stream plus _ *Off*."},{"pos":[10137,10228],"content":"If <ph id=\"ph1\">`_Way` == `ios_base::cur`</ph>, the new position is the current stream position plus _ <bpt id=\"p1\">*</bpt>Off<ept id=\"p1\">*</ept>.","source":"If `_Way` == `ios_base::cur`, the new position is the current stream position plus _ *Off*."},{"pos":[10238,10323],"content":"If <ph id=\"ph1\">`_Way` == `ios_base::end`</ph>, the new position is the end of the stream plus _ <bpt id=\"p1\">*</bpt>Off<ept id=\"p1\">*</ept>.","source":"If `_Way` == `ios_base::end`, the new position is the end of the stream plus _ *Off*."},{"content":"If <ph id=\"ph1\">`_Which` &amp; </ph><bpt id=\"p1\">**</bpt>ios_base::in<ept id=\"p1\">**</ept> is nonzero and the input buffer exist, the function alters the next position to read in the input buffer.","pos":[10330,10466],"source":"If `_Which` & **ios_base::in** is nonzero and the input buffer exist, the function alters the next position to read in the input buffer."},{"content":"If <ph id=\"ph1\">`_Which` &amp; </ph><bpt id=\"p1\">**</bpt>ios_base::out<ept id=\"p1\">**</ept> is also nonzero, <ph id=\"ph2\">`_Way`</ph> != <bpt id=\"p2\">**</bpt>ios_base::cur<ept id=\"p2\">**</ept>, and the output buffer exists, the function also sets the next position to write to match the next position to read.","pos":[10467,10660],"source":" If `_Which` & **ios_base::out** is also nonzero, `_Way` != **ios_base::cur**, and the output buffer exists, the function also sets the next position to write to match the next position to read."},{"content":"Otherwise, if <ph id=\"ph1\">`_Which` &amp; `ios_base::out`</ph> is nonzero and the output buffer exists, the function alters the next position to write in the output buffer.","pos":[10667,10817],"source":"Otherwise, if `_Which` & `ios_base::out` is nonzero and the output buffer exists, the function alters the next position to write in the output buffer."},{"content":"Otherwise, the positioning operation fails.","pos":[10818,10861]},{"content":"For a positioning operation to succeed, the resulting stream position must lie within the controlled sequence.","pos":[10862,10972]},{"pos":[11020,11041],"content":"strstreambuf::seekpos"},{"content":"A protected virtual member function that tries to alter the current positions for the controlled streams.","pos":[11045,11150]},{"content":"Parameters","pos":[11275,11285]},{"content":"The position to seek for.","pos":[11298,11323]},{"content":"Specifies the mode for the pointer position.","pos":[11342,11386]},{"content":"The default is to allow you to modify the read and write positions.","pos":[11387,11454]},{"content":"Return Value","pos":[11464,11476]},{"content":"If the function succeeds in altering either or both stream positions, it returns the resultant stream position.","pos":[11480,11591]},{"content":"Otherwise, it fails and returns an invalid stream position.","pos":[11592,11651]},{"content":"To determine if the stream position is invalid, compare the return value with <ph id=\"ph1\">`pos_type(off_type(-1))`</ph>.","pos":[11652,11755],"source":" To determine if the stream position is invalid, compare the return value with `pos_type(off_type(-1))`."},{"content":"Remarks","pos":[11765,11772]},{"content":"The protected virtual member function endeavors to alter the current positions for the controlled streams.","pos":[11776,11882]},{"content":"For an object of class strstreambuf, a stream position consists purely of a stream offset.","pos":[11883,11973]},{"content":"Offset zero designates the first element of the controlled sequence.","pos":[11974,12042]},{"content":"The new position is determined by _ <bpt id=\"p1\">*</bpt>Sp<ept id=\"p1\">*</ept>.","pos":[12043,12084],"source":" The new position is determined by _ *Sp*."},{"content":"If <ph id=\"ph1\">`_Which` &amp; </ph><bpt id=\"p1\">**</bpt>ios_base::in<ept id=\"p1\">**</ept> is nonzero and the input buffer exists, the function alters the next position to read in the input buffer.","pos":[12091,12228],"source":"If `_Which` & **ios_base::in** is nonzero and the input buffer exists, the function alters the next position to read in the input buffer."},{"content":"If <ph id=\"ph1\">`_Which` &amp; `ios_base::out`</ph> is nonzero and the output buffer exists, the function also sets the next position to write to match the next position to read.","pos":[12229,12385],"source":" If `_Which` & `ios_base::out` is nonzero and the output buffer exists, the function also sets the next position to write to match the next position to read."},{"content":"Otherwise, if <ph id=\"ph1\">`_Which` &amp; `ios_base::out`</ph> is nonzero and the output buffer exists, the function alters the next position to write in the output buffer.","pos":[12386,12536],"source":" Otherwise, if `_Which` & `ios_base::out` is nonzero and the output buffer exists, the function alters the next position to write in the output buffer."},{"content":"Otherwise, the positioning operation fails.","pos":[12537,12580]},{"content":"For a positioning operation to succeed, the resulting stream position must lie within the controlled sequence.","pos":[12581,12691]},{"pos":[12735,12752],"content":"strstreambuf::str"},{"pos":[12756,12866],"content":"Calls <bpt id=\"p1\">[</bpt>freeze<ept id=\"p1\">](#strstreambuf__freeze)</ept>, and then returns a pointer to the beginning of the controlled sequence.","source":"Calls [freeze](#strstreambuf__freeze), and then returns a pointer to the beginning of the controlled sequence."},{"content":"Return Value","pos":[12904,12916]},{"content":"A pointer to the beginning of the controlled sequence.","pos":[12920,12974]},{"content":"Remarks","pos":[12984,12991]},{"content":"No terminating null element exists, unless you explicitly insert one.","pos":[12995,13064]},{"content":"Example","pos":[13074,13081]},{"pos":[13086,13167],"content":"See <bpt id=\"p1\">[</bpt>strstreambuf::freeze<ept id=\"p1\">](#strstreambuf__freeze)</ept> for a sample that uses <bpt id=\"p2\">**</bpt>str<ept id=\"p2\">**</ept>.","source":"See [strstreambuf::freeze](#strstreambuf__freeze) for a sample that uses **str**."},{"pos":[13220,13246],"content":"strstreambuf::strstreambuf"},{"pos":[13250,13294],"content":"Constructs an object of type <ph id=\"ph1\">`strstreambuf`</ph>.","source":"Constructs an object of type `strstreambuf`."},{"content":"Parameters","pos":[13886,13896]},{"content":"_Allocfunc","pos":[13901,13911]},{"content":"The function used to allocate buffer memory.","pos":[13916,13960]},{"content":"Determines the length of the buffer pointed to by <ph id=\"ph1\">`_Getptr`</ph>.","pos":[13979,14039],"source":" Determines the length of the buffer pointed to by `_Getptr`."},{"content":"If <ph id=\"ph1\">`_Getptr`</ph> is not an argument (first constructor form), a suggested allocation size for the buffers.","pos":[14040,14142],"source":" If `_Getptr` is not an argument (first constructor form), a suggested allocation size for the buffers."},{"content":"_Freefunc","pos":[14150,14159]},{"content":"The function used to free buffer memory.","pos":[14164,14204]},{"content":"A buffer used for input.","pos":[14224,14248]},{"content":"A buffer used for output.","pos":[14268,14293]},{"content":"Remarks","pos":[14303,14310]},{"content":"The first constructor stores a null pointer in all the pointers controlling the input buffer, the output buffer, and strstreambuf allocation.","pos":[14314,14455]},{"content":"It sets the stored strstreambuf mode to make the controlled sequence modifiable and extendable.","pos":[14456,14551]},{"content":"It also accepts <ph id=\"ph1\">` count`</ph> as a suggested initial allocation size.","pos":[14552,14616],"source":" It also accepts ` count` as a suggested initial allocation size."},{"pos":[14623,14843],"content":"The second constructor behaves like the first, except that it stores _ <bpt id=\"p1\">*</bpt>Allocfunc<ept id=\"p1\">*</ept> as the pointer to the function to call to allocate storage and <ph id=\"ph1\">\\_</ph> <bpt id=\"p2\">*</bpt>Freefunc<ept id=\"p2\">*</ept> as the pointer to the function to call to free that storage.","source":"The second constructor behaves like the first, except that it stores _ *Allocfunc* as the pointer to the function to call to allocate storage and \\_ *Freefunc* as the pointer to the function to call to free that storage."},{"content":"The three constructors:","pos":[14850,14873]},{"content":"also behave like the first, except that <ph id=\"ph1\">`_Getptr`</ph> designates the array object used to hold the controlled sequence.","pos":[15156,15271],"source":"also behave like the first, except that `_Getptr` designates the array object used to hold the controlled sequence."},{"content":"(Hence, it must not be a null pointer.) The number of elements <bpt id=\"p1\">*</bpt>N<ept id=\"p1\">*</ept> in the array is determined as follows:","pos":[15272,15377],"source":" (Hence, it must not be a null pointer.) The number of elements *N* in the array is determined as follows:"},{"pos":[15387,15429],"content":"If ( <ph id=\"ph1\">` count`</ph> &gt; 0), then <bpt id=\"p1\">*</bpt>N<ept id=\"p1\">*</ept> is <bpt id=\"p2\">**</bpt>count<ept id=\"p2\">**</ept>.","source":"If ( ` count` > 0), then *N* is **count**."},{"pos":[15439,15516],"content":"If <ph id=\"ph1\">`(`` count`</ph> == 0), then <bpt id=\"p1\">*</bpt>N<ept id=\"p1\">*</ept> is <ph id=\"ph2\">`strlen`</ph>( ( <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept><ph id=\"ph3\">`char`</ph> *) <ph id=\"ph4\">`_Getptr`</ph> ).","source":"If `(`` count` == 0), then *N* is `strlen`( ( **const**`char` *) `_Getptr` )."},{"pos":[15526,15570],"content":"If ( <ph id=\"ph1\">` count`</ph> &lt; 0), then <bpt id=\"p1\">*</bpt>N<ept id=\"p1\">*</ept> is <bpt id=\"p2\">**</bpt>INT_MAX<ept id=\"p2\">**</ept>.","source":"If ( ` count` < 0), then *N* is **INT_MAX**."},{"pos":[15577,15668],"content":"If <ph id=\"ph1\">`_Putptr`</ph> is a null pointer, the function establishes just an input buffer by executing:","source":"If `_Putptr` is a null pointer, the function establishes just an input buffer by executing:"},{"content":"Otherwise, it establishes both input and output buffers by executing:","pos":[15735,15804]},{"pos":[15900,15978],"content":"In this case, <ph id=\"ph1\">`_Putptr`</ph> must be in the interval [ <ph id=\"ph2\">`_Getptr`</ph>, <ph id=\"ph3\">`_Getptr` + </ph><bpt id=\"p1\">*</bpt>N<ept id=\"p1\">*</ept>].","source":"In this case, `_Putptr` must be in the interval [ `_Getptr`, `_Getptr` + *N*]."},{"content":"Finally, the three constructors:","pos":[15985,16017]},{"content":"all behave the same as:","pos":[16238,16261]},{"content":"except that the stored mode makes the controlled sequence neither modifiable nor extendable.","pos":[16318,16410]},{"pos":[16460,16483],"content":"strstreambuf::underflow"},{"content":"A protected virtual function to extract the current element from the input stream.","pos":[16487,16569]},{"content":"Return Value","pos":[16619,16631]},{"content":"If the function cannot succeed, it returns <ph id=\"ph1\">`EOF`</ph>.","pos":[16635,16684],"source":"If the function cannot succeed, it returns `EOF`."},{"content":"Otherwise, it returns the current element in the input stream, converted as described above.","pos":[16685,16777]},{"content":"Remarks","pos":[16787,16794]},{"content":"The protected virtual member function endeavors to extract the current element <bpt id=\"p1\">**</bpt>ch<ept id=\"p1\">**</ept> from the input buffer, then advance the current stream position, and return the element as ( <ph id=\"ph1\">`int`</ph>)( <ph id=\"ph2\">`unsigned``char`</ph>) <bpt id=\"p2\">**</bpt>ch<ept id=\"p2\">**</ept>.","pos":[16798,17010],"source":"The protected virtual member function endeavors to extract the current element **ch** from the input buffer, then advance the current stream position, and return the element as ( `int`)( `unsigned``char`) **ch**."},{"content":"It can do so in only one way: if a read position is available, it takes <bpt id=\"p1\">**</bpt>ch<ept id=\"p1\">**</ept> as the element stored in the read position and advances the next pointer for the input buffer.","pos":[17011,17184],"source":" It can do so in only one way: if a read position is available, it takes **ch** as the element stored in the read position and advances the next pointer for the input buffer."},{"content":"See Also","pos":[17193,17201]},{"content":"streambuf","pos":[17206,17215]},{"content":"Thread Safety in the C++ Standard Library","pos":[17275,17316]},{"content":"iostream Programming","pos":[17389,17409]},{"content":"iostreams Conventions","pos":[17461,17482]}],"content":"---\ntitle: \"strstreambuf Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std.strstreambuf\"\n  - \"strstreambuf\"\n  - \"std::strstreambuf\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"strstreambuf class\"\nms.assetid: b040b8ea-0669-4eba-8908-6a9cc159c54b\ncaps.latest.revision: 25\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# strstreambuf Class\nDescribes a stream buffer that controls the transmission of elements to and from a sequence of elements stored in a `char` array object.  \n  \n## Syntax  \n  \n```  \nclass strstreambuf : public streambuf  \n```  \n  \n## Remarks  \n Depending on how the object is constructed, it can be allocated, extended, and freed as necessary to accommodate changes in the sequence.  \n  \n An object of class `strstreambuf` stores several bits of mode information as its `strstreambuf` mode. These bits indicate whether the controlled sequence:  \n  \n-   Has been allocated and needs to be freed eventually.  \n  \n-   Is modifiable.  \n  \n-   Is extendable by reallocating storage.  \n  \n-   Has been frozen and hence needs to be unfrozen before the object is destroyed, or freed (if allocated) by an agency other than the object.  \n  \n A controlled sequence that is frozen cannot be modified or extended, regardless of the state of these separate mode bits.  \n  \n The object also stores pointers to two functions that control `strstreambuf` allocation. If these are null pointers, the object devises its own method of allocating and freeing storage for the controlled sequence.  \n  \n> [!NOTE]\n>  This class is deprecated. Consider using [stringbuf](../standard-library/sstream-typedefs.md#stringbuf) or [wstringbuf](../standard-library/sstream-typedefs.md#wstringbuf) instead.  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[strstreambuf](#strstreambuf__strstreambuf)|Constructs an object of type `strstreambuf`.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[freeze](#strstreambuf__freeze)|Causes a stream buffer to be unavailable through stream buffer operations.|  \n|[overflow](#strstreambuf__overflow)|A protected virtual function that can be called when a new character is inserted into a full buffer.|  \n|[pbackfail](#strstreambuf__pbackfail)|A protected virtual member function that tries to put back an element into the input stream, and then make it the current element (pointed to by the next pointer).|  \n|[pcount](#strstreambuf__pcount)|Returns a count of the number of elements written to the controlled sequence.|  \n|[seekoff](#strstreambuf__seekoff)|A protected virtual member function that tries to alter the current positions for the controlled streams.|  \n|[seekpos](#strstreambuf__seekpos)|A protected virtual member function that tries to alter the current positions for the controlled streams.|  \n|[str](#strstreambuf__str)|Calls [freeze](#strstreambuf__freeze), and then returns a pointer to the beginning of the controlled sequence.|  \n|[underflow](#strstreambuf__underflow)|A protected virtual function to extract the current element from the input stream.|  \n  \n## Requirements  \n **Header:** \\<strstream>  \n  \n **Namespace:** std  \n  \n##  <a name=\"strstreambuf__freeze\"></a>  strstreambuf::freeze  \n Causes a stream buffer to be unavailable through stream buffer operations.  \n  \n```  \nvoid freeze(bool _Freezeit = true);\n```  \n  \n### Parameters  \n `_Freezeit`  \n A `bool` indicating whether you want the stream to be frozen.  \n  \n### Remarks  \n If `_Freezeit` is true, the function alters the stored `strstreambuf` mode to make the controlled sequence frozen. Otherwise, it makes the controlled sequence not frozen.  \n  \n [str](#strstreambuf__str) implies `freeze`.  \n  \n> [!NOTE]\n>  A frozen buffer will not be freed during `strstreambuf` destruction. You must unfreeze the buffer before it is freed to avoid a memory leak.  \n  \n### Example  \n  \n```cpp  \n// strstreambuf_freeze.cpp  \n// compile with: /EHsc  \n  \n#include <iostream>  \n#include <strstream>  \n  \nusing namespace std;  \n  \nvoid report(strstream &x)  \n{  \n    if (!x.good())  \n        cout << \"stream bad\" << endl;  \n    else  \n        cout << \"stream good\" << endl;  \n}  \n  \nint main()  \n{  \n    strstream x;  \n  \n    x << \"test1\";  \n    cout << \"before freeze: \";  \n    report(x);  \n  \n    // Calling str freezes stream.  \n    cout.write(x.rdbuf()->str(), 5) << endl;  \n    cout << \"after freeze: \";  \n    report(x);  \n  \n    // Stream is bad now, wrote on frozen stream  \n    x << \"test1.5\";  \n    cout << \"after write to frozen stream: \";  \n    report(x);  \n  \n    // Unfreeze stream, but it is still bad  \n    x.rdbuf()->freeze(false);  \n    cout << \"after unfreezing stream: \";  \n    report(x);  \n  \n    // Clear stream  \n    x.clear();  \n    cout << \"after clearing stream: \";  \n    report(x);  \n  \n    x << \"test3\";  \n    cout.write(x.rdbuf()->str(), 10) << endl;  \n  \n    // Clean up.  Failure to unfreeze stream will cause a  \n    // memory leak.  \n    x.rdbuf()->freeze(false);  \n}  \n```  \n  \n```Output  \nbefore freeze: stream good  \ntest1  \nafter freeze: stream good  \nafter write to frozen stream: stream bad  \nafter unfreezing stream: stream bad  \nafter clearing stream: stream good  \ntest1test3  \n```  \n  \n##  <a name=\"strstreambuf__overflow\"></a>  strstreambuf::overflow  \n A protected virtual function that can be called when a new character is inserted into a full buffer.  \n  \n```  \nvirtual int overflow(int _Meta = EOF);\n```  \n  \n### Parameters  \n `_Meta`  \n The character to insert into the buffer, or `EOF`.  \n  \n### Return Value  \n If the function cannot succeed, it returns `EOF`. Otherwise, if _ *Meta* == `EOF`, it returns some value other than `EOF`. Otherwise, it returns \\_ *Meta*.  \n  \n### Remarks  \n If _ *Meta* != `EOF`, the protected virtual member function tries to insert the element ( `char`)\\_ *Meta* into the output buffer. It can do so in various ways:  \n  \n-   If a write position is available, it can store the element into the write position and increment the next pointer for the output buffer.  \n  \n-   If the stored strstreambuf mode says the controlled sequence is modifiable, extendable, and not frozen, the function can make a write position available by allocating new for the output buffer. Extending the output buffer this way also extends any associated input buffer.  \n  \n##  <a name=\"strstreambuf__pbackfail\"></a>  strstreambuf::pbackfail  \n A protected virtual member function that tries to put back an element into the input stream, and then makes it the current element (pointed to by the next pointer).  \n  \n```  \nvirtual int pbackfail(int _Meta = EOF);\n```  \n  \n### Parameters  \n `_Meta`  \n The character to insert into the buffer, or `EOF`.  \n  \n### Return Value  \n If the function cannot succeed, it returns `EOF`. Otherwise, if _ *Meta* == `EOF`, it returns some value other than `EOF`. Otherwise, it returns \\_ *Meta*.  \n  \n### Remarks  \n The protected virtual member function tries to put back an element into the input buffer, and then make it the current element (pointed to by the next pointer).  \n  \n If _ *Meta* == `EOF`, the element to push back is effectively the one already in the stream before the current element. Otherwise, that element is replaced by **ch** = ( `char`)\\_ *Meta*. The function can put back an element in various ways:  \n  \n-   If a putback position is available, and the element stored there compares equal to **ch**, it can decrement the next pointer for the input buffer.  \n  \n-   If a putback position is available, and if the strstreambuf mode says the controlled sequence is modifiable, the function can store **ch** into the putback position and decrement the next pointer for the input buffer.  \n  \n##  <a name=\"strstreambuf__pcount\"></a>  strstreambuf::pcount  \n Returns a count of the number of elements written to the controlled sequence.  \n  \n```  \nstreamsize pcount() const;\n```  \n  \n### Return Value  \n A count of the number of elements written to the controlled sequence.  \n  \n### Remarks  \n Specifically, if [pptr](../standard-library/basic-streambuf-class.md#basic_streambuf__pptr) is a null pointer, the function returns zero. Otherwise, it returns `pptr` – [pbase](../standard-library/basic-streambuf-class.md#basic_streambuf__pbase).  \n  \n### Example  \n  \n```cpp  \n// strstreambuf_pcount.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <strstream>  \nusing namespace std;  \n  \nint main( )  \n{  \n   strstream x;  \n   x << \"test1\";  \n   cout << x.rdbuf( )->pcount( ) << endl;  \n   x << \"test2\";  \n   cout << x.rdbuf( )->pcount( ) << endl;  \n}  \n```  \n  \n##  <a name=\"strstreambuf__seekoff\"></a>  strstreambuf::seekoff  \n A protected virtual member function that tries to alter the current positions for the controlled streams.  \n  \n```  \nvirtual streampos seekoff(streamoff _Off,\n    ios_base::seekdir _Way,\n    ios_base::openmode _Which = ios_base::in | ios_base::out);\n```  \n  \n### Parameters  \n `_Off`  \n The position to seek for relative to `_Way`.  \n  \n `_Way`  \n The starting point for offset operations. See [seekdir](../standard-library/ios-base-class.md#ios_base__seekdir) for possible values.  \n  \n `_Which`  \n Specifies the mode for the pointer position. The default is to allow you to modify the read and write positions.  \n  \n### Return Value  \n If the function succeeds in altering either or both stream positions, it returns the resultant stream position. Otherwise, it fails and returns an invalid stream position.  \n  \n### Remarks  \n The protected virtual member function endeavors to alter the current positions for the controlled streams. For an object of class strstreambuf, a stream position consists purely of a stream offset. Offset zero designates the first element of the controlled sequence.  \n  \n The new position is determined as follows:  \n  \n-   If `_Way` == `ios_base::beg`, the new position is the beginning of the stream plus _ *Off*.  \n  \n-   If `_Way` == `ios_base::cur`, the new position is the current stream position plus _ *Off*.  \n  \n-   If `_Way` == `ios_base::end`, the new position is the end of the stream plus _ *Off*.  \n  \n If `_Which` & **ios_base::in** is nonzero and the input buffer exist, the function alters the next position to read in the input buffer. If `_Which` & **ios_base::out** is also nonzero, `_Way` != **ios_base::cur**, and the output buffer exists, the function also sets the next position to write to match the next position to read.  \n  \n Otherwise, if `_Which` & `ios_base::out` is nonzero and the output buffer exists, the function alters the next position to write in the output buffer. Otherwise, the positioning operation fails. For a positioning operation to succeed, the resulting stream position must lie within the controlled sequence.  \n  \n##  <a name=\"strstreambuf__seekpos\"></a>  strstreambuf::seekpos  \n A protected virtual member function that tries to alter the current positions for the controlled streams.  \n  \n```  \nvirtual streampos seekpos(streampos _Sp, ios_base::openmode _Which = ios_base::in | ios_base::out);\n```  \n  \n### Parameters  \n `_Sp`  \n The position to seek for.  \n  \n `_Which`  \n Specifies the mode for the pointer position. The default is to allow you to modify the read and write positions.  \n  \n### Return Value  \n If the function succeeds in altering either or both stream positions, it returns the resultant stream position. Otherwise, it fails and returns an invalid stream position. To determine if the stream position is invalid, compare the return value with `pos_type(off_type(-1))`.  \n  \n### Remarks  \n The protected virtual member function endeavors to alter the current positions for the controlled streams. For an object of class strstreambuf, a stream position consists purely of a stream offset. Offset zero designates the first element of the controlled sequence. The new position is determined by _ *Sp*.  \n  \n If `_Which` & **ios_base::in** is nonzero and the input buffer exists, the function alters the next position to read in the input buffer. If `_Which` & `ios_base::out` is nonzero and the output buffer exists, the function also sets the next position to write to match the next position to read. Otherwise, if `_Which` & `ios_base::out` is nonzero and the output buffer exists, the function alters the next position to write in the output buffer. Otherwise, the positioning operation fails. For a positioning operation to succeed, the resulting stream position must lie within the controlled sequence.  \n  \n##  <a name=\"strstreambuf__str\"></a>  strstreambuf::str  \n Calls [freeze](#strstreambuf__freeze), and then returns a pointer to the beginning of the controlled sequence.  \n  \n```  \nchar *str();\n```  \n  \n### Return Value  \n A pointer to the beginning of the controlled sequence.  \n  \n### Remarks  \n No terminating null element exists, unless you explicitly insert one.  \n  \n### Example  \n  See [strstreambuf::freeze](#strstreambuf__freeze) for a sample that uses **str**.  \n  \n##  <a name=\"strstreambuf__strstreambuf\"></a>  strstreambuf::strstreambuf  \n Constructs an object of type `strstreambuf`.  \n  \n```  \nexplicit strstreambuf(streamsize count = 0);\n\nstrstreambuf(void (* _Allocfunc)(size_t),\n    void (* _Freefunc)(void*));\n\nstrstreambuf(char* _Getptr,\n    streamsize count,\n    char* _Putptr = 0);\n\nstrstreambuf(signed char* _Getptr,\n    streamsize count,\n    signed char* _Putptr = 0);\n\nstrstreambuf(unsigned char* _Getptr,\n    streamsize count,\n    unsigned char* _Putptr = 0);\n\nstrstreambuf(const char* _Getptr,\n    streamsize count);\n\nstrstreambuf(const signed char* _Getptr,\n    streamsize count);\n\nstrstreambuf(const unsigned char* _Getptr,\n    streamsize count);\n```  \n  \n### Parameters  \n *_Allocfunc*  \n The function used to allocate buffer memory.  \n  \n ` count`  \n Determines the length of the buffer pointed to by `_Getptr`. If `_Getptr` is not an argument (first constructor form), a suggested allocation size for the buffers.  \n  \n *_Freefunc*  \n The function used to free buffer memory.  \n  \n `_Getptr`  \n A buffer used for input.  \n  \n `_Putptr`  \n A buffer used for output.  \n  \n### Remarks  \n The first constructor stores a null pointer in all the pointers controlling the input buffer, the output buffer, and strstreambuf allocation. It sets the stored strstreambuf mode to make the controlled sequence modifiable and extendable. It also accepts ` count` as a suggested initial allocation size.  \n  \n The second constructor behaves like the first, except that it stores _ *Allocfunc* as the pointer to the function to call to allocate storage and \\_ *Freefunc* as the pointer to the function to call to free that storage.  \n  \n The three constructors:  \n  \n```  \n \n    strstreambuf(char *_Getptr,\n    streamsize count,  \nchar *putptr = 0);\n\n    strstreambuf(signed char *_Getptr,\n    streamsize count,  \nsigned char *putptr = 0);\n\n    strstreambuf(unsigned char *_Getptr,\n    streamsize count,  \nunsigned char *putptr = 0);\n```  \n  \n also behave like the first, except that `_Getptr` designates the array object used to hold the controlled sequence. (Hence, it must not be a null pointer.) The number of elements *N* in the array is determined as follows:  \n  \n-   If ( ` count` > 0), then *N* is **count**.  \n  \n-   If `(`` count` == 0), then *N* is `strlen`( ( **const**`char` *) `_Getptr` ).  \n  \n-   If ( ` count` < 0), then *N* is **INT_MAX**.  \n  \n If `_Putptr` is a null pointer, the function establishes just an input buffer by executing:  \n  \n```  \nsetg(_Getptr,\n    _Getptr,\n    _Getptr + N);\n```  \n  \n Otherwise, it establishes both input and output buffers by executing:  \n  \n```  \nsetg(_Getptr,\n    _Getptr,\n    _Putptr);\n\nsetp(_Putptr,\n    _Getptr + N);\n```  \n  \n In this case, `_Putptr` must be in the interval [ `_Getptr`, `_Getptr` + *N*].  \n  \n Finally, the three constructors:  \n  \n```  \n \nstrstreambuf(const char *_Getptr,\n    streamsize count);\n\n    strstreambuf(const signed char *_Getptr,\n    streamsize count);\n\n    strstreambuf(const unsigned char *_Getptr,\n    streamsize count);\n```  \n  \n all behave the same as:  \n  \n```  \nstreambuf((char *)_Getptr, count);\n```  \n  \n except that the stored mode makes the controlled sequence neither modifiable nor extendable.  \n  \n##  <a name=\"strstreambuf__underflow\"></a>  strstreambuf::underflow  \n A protected virtual function to extract the current element from the input stream.  \n  \n```  \nvirtual int underflow();\n```  \n  \n### Return Value  \n If the function cannot succeed, it returns `EOF`. Otherwise, it returns the current element in the input stream, converted as described above.  \n  \n### Remarks  \n The protected virtual member function endeavors to extract the current element **ch** from the input buffer, then advance the current stream position, and return the element as ( `int`)( `unsigned``char`) **ch**. It can do so in only one way: if a read position is available, it takes **ch** as the element stored in the read position and advances the next pointer for the input buffer.  \n  \n## See Also  \n [streambuf](../standard-library/streambuf-typedefs.md#streambuf)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [iostream Programming](../standard-library/iostream-programming.md)   \n [iostreams Conventions](../standard-library/iostreams-conventions.md)\n\n"}