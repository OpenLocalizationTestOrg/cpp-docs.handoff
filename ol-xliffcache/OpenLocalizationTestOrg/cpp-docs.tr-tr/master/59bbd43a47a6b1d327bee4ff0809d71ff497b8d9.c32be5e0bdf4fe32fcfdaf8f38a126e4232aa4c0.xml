{"nodes":[{"pos":[12,49],"content":"Using setjmp-longjmp | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Using setjmp-longjmp | Microsoft Docs","pos":[0,37]}]},{"content":"Using setjmp/longjmp","pos":[787,807]},{"content":"When <bpt id=\"p1\">[</bpt>setjmp<ept id=\"p1\">](../c-runtime-library/reference/setjmp.md)</ept> and <bpt id=\"p2\">[</bpt>longjmp<ept id=\"p2\">](../c-runtime-library/reference/longjmp.md)</ept> are used together, they provide a way to execute a non-local <ph id=\"ph1\">`goto`</ph>.","pos":[808,989],"source":"When [setjmp](../c-runtime-library/reference/setjmp.md) and [longjmp](../c-runtime-library/reference/longjmp.md) are used together, they provide a way to execute a non-local `goto`."},{"content":"They are typically used to pass execution control to error-handling or recovery code in a previously called routine without using the standard calling or return conventions.","pos":[990,1163]},{"pos":[1171,1466],"content":"[!CAUTION]\n However, because `setjmp` and `longjmp` do not support C++ object semantics, and because they might degrade performance by preventing optimization on local variables, we recommend that you do not use them in C++ programs. We recommend that you use `try`/`catch` constructs instead.","leadings":["","> "],"nodes":[{"content":" However, because `setjmp` and `longjmp` do not support C++ object semantics, and because they might degrade performance by preventing optimization on local variables, we recommend that you do not use them in C++ programs. We recommend that you use `try`/`catch` constructs instead.","pos":[11,293],"nodes":[{"content":"However, because <ph id=\"ph1\">`setjmp`</ph> and <ph id=\"ph2\">`longjmp`</ph> do not support C++ object semantics, and because they might degrade performance by preventing optimization on local variables, we recommend that you do not use them in C++ programs.","pos":[1,222],"source":" However, because `setjmp` and `longjmp` do not support C++ object semantics, and because they might degrade performance by preventing optimization on local variables, we recommend that you do not use them in C++ programs."},{"content":"We recommend that you use <ph id=\"ph1\">`try`/`catch`</ph> constructs instead.","pos":[223,282],"source":" We recommend that you use `try`/`catch` constructs instead."}]}]},{"content":"If you decide to use <ph id=\"ph1\">`setjmp`/`longjmp`</ph> in a C++ program, also include SETJMP.H or SETJMPEX.H to assure correct interaction between the functions and C++ exception handling.","pos":[1473,1646],"source":"If you decide to use `setjmp`/`longjmp` in a C++ program, also include SETJMP.H or SETJMPEX.H to assure correct interaction between the functions and C++ exception handling."},{"content":"If you use <bpt id=\"p1\">[</bpt>/EH<ept id=\"p1\">](../build/reference/eh-exception-handling-model.md)</ept> to compile, destructors for local objects are called during the stack unwind.","pos":[1647,1792],"source":" If you use [/EH](../build/reference/eh-exception-handling-model.md) to compile, destructors for local objects are called during the stack unwind."},{"content":"If you use <bpt id=\"p1\">**</bpt>/EHs<ept id=\"p1\">**</ept> to compile, and one of your functions calls a function that uses <bpt id=\"p2\">[</bpt>nothrow<ept id=\"p2\">](../cpp/nothrow-cpp.md)</ept> and the function that uses <ph id=\"ph1\">`nothrow`</ph> calls <ph id=\"ph2\">`longjmp`</ph>, then the destructor unwind might not occur, depending on the optimizer.","pos":[1793,2036],"source":" If you use **/EHs** to compile, and one of your functions calls a function that uses [nothrow](../cpp/nothrow-cpp.md) and the function that uses `nothrow` calls `longjmp`, then the destructor unwind might not occur, depending on the optimizer."},{"pos":[2043,2182],"content":"In portable code, when a non-local <ph id=\"ph1\">`goto`</ph> that calls <ph id=\"ph2\">`longjmp`</ph> is executed, correct destruction of frame-based objects might be unreliable.","source":"In portable code, when a non-local `goto` that calls `longjmp` is executed, correct destruction of frame-based objects might be unreliable."},{"content":"See Also","pos":[2191,2199]},{"content":"Mixing C (Structured) and C++ Exceptions","pos":[2204,2244]}],"content":"---\ntitle: \"Using setjmp-longjmp | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"longjmp\"\n  - \"setjmp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C++ exception handling, setjmp/longjmp functions\"\n  - \"SETJMPEX.H\"\n  - \"longjmp function in C++ programs\"\n  - \"SETJMP.H\"\n  - \"setjmp function\"\n  - \"setjmp function, C++ programs\"\nms.assetid: 96be8816-f6f4-4567-9a9c-0c3c720e37c5\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Using setjmp/longjmp\nWhen [setjmp](../c-runtime-library/reference/setjmp.md) and [longjmp](../c-runtime-library/reference/longjmp.md) are used together, they provide a way to execute a non-local `goto`. They are typically used to pass execution control to error-handling or recovery code in a previously called routine without using the standard calling or return conventions.  \n  \n> [!CAUTION]\n>  However, because `setjmp` and `longjmp` do not support C++ object semantics, and because they might degrade performance by preventing optimization on local variables, we recommend that you do not use them in C++ programs. We recommend that you use `try`/`catch` constructs instead.  \n  \n If you decide to use `setjmp`/`longjmp` in a C++ program, also include SETJMP.H or SETJMPEX.H to assure correct interaction between the functions and C++ exception handling. If you use [/EH](../build/reference/eh-exception-handling-model.md) to compile, destructors for local objects are called during the stack unwind. If you use **/EHs** to compile, and one of your functions calls a function that uses [nothrow](../cpp/nothrow-cpp.md) and the function that uses `nothrow` calls `longjmp`, then the destructor unwind might not occur, depending on the optimizer.  \n  \n In portable code, when a non-local `goto` that calls `longjmp` is executed, correct destruction of frame-based objects might be unreliable.  \n  \n## See Also  \n [Mixing C (Structured) and C++ Exceptions](../cpp/mixing-c-structured-and-cpp-exceptions.md)"}