{"nodes":[{"pos":[12,65],"content":"How to: Marshal Arrays Using PInvoke | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Marshal Arrays Using PInvoke | Microsoft Docs","pos":[0,53]}]},{"content":"How to: Marshal Arrays Using PInvoke","pos":[711,747]},{"content":"This topic explains how native functions that accept C-style strings can be called using the CLR string type &lt;xref:System.String&gt; using .NET Framework Platform Invoke support.","pos":[748,923],"source":"This topic explains how native functions that accept C-style strings can be called using the CLR string type <xref:System.String> using .NET Framework Platform Invoke support."},{"content":"Visual C++ programmers are encouraged to use the C++ Interop features instead (when possible) because P/Invoke provides little compile-time error reporting, is not type-safe, and can be tedious to implement.","pos":[924,1131]},{"content":"If the unmanaged API is packaged as a DLL and the source code is not available, P/Invoke is the only option (otherwise, see <bpt id=\"p1\">[</bpt>Using C++ Interop (Implicit PInvoke)<ept id=\"p1\">](../dotnet/using-cpp-interop-implicit-pinvoke.md)</ept>).","pos":[1132,1345],"source":" If the unmanaged API is packaged as a DLL and the source code is not available, P/Invoke is the only option (otherwise, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md))."},{"content":"Example","pos":[1354,1361]},{"content":"Because native and managed arrays are laid out differently in memory, passing them successfully across the managed/unmanaged boundary requires conversion, or marshaling.","pos":[1365,1534]},{"content":"This topic demonstrates how an array of simple (blitable) items can be passed to native functions from managed code.","pos":[1535,1651]},{"content":"As is true of managed/unmanaged data marshaling in general, the &lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt; attribute is used to create a managed entry point for each native function that will be used.","pos":[1658,1872],"source":"As is true of managed/unmanaged data marshaling in general, the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute is used to create a managed entry point for each native function that will be used."},{"content":"In the case of functions that take arrays as arguments, the &lt;xref:System.Runtime.InteropServices.MarshalAsAttribute&gt; attribute must be used as well to specify to the compiler how the data will be marshaled.","pos":[1873,2079],"source":" In the case of functions that take arrays as arguments, the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute must be used as well to specify to the compiler how the data will be marshaled."},{"content":"In the following example, the &lt;xref:System.Runtime.InteropServices.UnmanagedType&gt; enumeration is used to indicate that the managed array will be marshaled as a C-style array.","pos":[2080,2254],"source":" In the following example, the <xref:System.Runtime.InteropServices.UnmanagedType> enumeration is used to indicate that the managed array will be marshaled as a C-style array."},{"content":"The following code consists of an unmanaged and a managed module.","pos":[2261,2326]},{"content":"The unmanaged module is a DLL that defines a function that accepts an array of integers.","pos":[2327,2415]},{"content":"The second module is a managed command-line application that imports this function, but defines it in terms of a managed array, and uses the &lt;xref:System.Runtime.InteropServices.MarshalAsAttribute&gt; attribute to specify that the array should be converted to a native array when called.","pos":[2416,2700],"source":" The second module is a managed command-line application that imports this function, but defines it in terms of a managed array, and uses the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute to specify that the array should be converted to a native array when called."},{"content":"The managed module is compiled with /clr, but /clr:pure works as well.","pos":[2707,2777]},{"content":"Note that no portion of the DLL is exposed to the managed code through the traditional #include directive.","pos":[3887,3993]},{"content":"In fact, because the DLL is accessed at run time only, problems with functions imported with &lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt; will not be detected at compile time.","pos":[3994,4181],"source":" In fact, because the DLL is accessed at run time only, problems with functions imported with <xref:System.Runtime.InteropServices.DllImportAttribute> will not be detected at compile time."},{"content":"See Also","pos":[4190,4198]},{"content":"Using Explicit PInvoke in C++ (DllImport Attribute)","pos":[4203,4254]}],"content":"---\ntitle: \"How to: Marshal Arrays Using PInvoke | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"marshaling [C++], arrays\"\n  - \"platform invoke [C++], arrays\"\n  - \"interop [C++], arrays\"\n  - \"data marshaling [C++], arrays\"\nms.assetid: a1237797-a2da-4df4-984a-6333ed3af406\ncaps.latest.revision: 20\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Marshal Arrays Using PInvoke\nThis topic explains how native functions that accept C-style strings can be called using the CLR string type <xref:System.String> using .NET Framework Platform Invoke support. Visual C++ programmers are encouraged to use the C++ Interop features instead (when possible) because P/Invoke provides little compile-time error reporting, is not type-safe, and can be tedious to implement. If the unmanaged API is packaged as a DLL and the source code is not available, P/Invoke is the only option (otherwise, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)).  \n  \n## Example  \n Because native and managed arrays are laid out differently in memory, passing them successfully across the managed/unmanaged boundary requires conversion, or marshaling. This topic demonstrates how an array of simple (blitable) items can be passed to native functions from managed code.  \n  \n As is true of managed/unmanaged data marshaling in general, the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute is used to create a managed entry point for each native function that will be used. In the case of functions that take arrays as arguments, the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute must be used as well to specify to the compiler how the data will be marshaled. In the following example, the <xref:System.Runtime.InteropServices.UnmanagedType> enumeration is used to indicate that the managed array will be marshaled as a C-style array.  \n  \n The following code consists of an unmanaged and a managed module. The unmanaged module is a DLL that defines a function that accepts an array of integers. The second module is a managed command-line application that imports this function, but defines it in terms of a managed array, and uses the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute to specify that the array should be converted to a native array when called.  \n  \n The managed module is compiled with /clr, but /clr:pure works as well.  \n  \n```  \n// TraditionalDll4.cpp  \n// compile with: /LD /EHsc  \n#include <iostream>  \n  \n#define TRADITIONALDLL_EXPORTS  \n#ifdef TRADITIONALDLL_EXPORTS  \n#define TRADITIONALDLL_API __declspec(dllexport)  \n#else  \n#define TRADITIONALDLL_API __declspec(dllimport)  \n#endif  \n  \nextern \"C\" {  \n   TRADITIONALDLL_API void TakesAnArray(int len, int[]);  \n}  \n  \nvoid TakesAnArray(int len, int a[]) {  \n   printf_s(\"[unmanaged]\\n\");  \n   for (int i=0; i<len; i++)  \n      printf(\"%d = %d\\n\", i, a[i]);  \n}  \n```  \n  \n```  \n// MarshalBlitArray.cpp  \n// compile with: /clr  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \nvalue struct TraditionalDLL {  \n   [DllImport(\"TraditionalDLL4.dll\")]  \n   static public void TakesAnArray(  \n   int len,[MarshalAs(UnmanagedType::LPArray)]array<int>^);  \n};  \n  \nint main() {  \n   array<int>^ b = gcnew array<int>(3);  \n   b[0] = 11;  \n   b[1] = 33;  \n   b[2] = 55;  \n   TraditionalDLL::TakesAnArray(3, b);  \n  \n   Console::WriteLine(\"[managed]\");  \n   for (int i=0; i<3; i++)  \n      Console::WriteLine(\"{0} = {1}\", i, b[i]);  \n}  \n```  \n  \n Note that no portion of the DLL is exposed to the managed code through the traditional #include directive. In fact, because the DLL is accessed at run time only, problems with functions imported with <xref:System.Runtime.InteropServices.DllImportAttribute> will not be detected at compile time.  \n  \n## See Also  \n [Using Explicit PInvoke in C++ (DllImport Attribute)](../dotnet/using-explicit-pinvoke-in-cpp-dllimport-attribute.md)"}