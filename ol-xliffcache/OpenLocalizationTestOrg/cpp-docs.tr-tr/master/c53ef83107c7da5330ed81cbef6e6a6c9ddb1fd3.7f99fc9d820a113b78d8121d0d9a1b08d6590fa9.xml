{"nodes":[{"pos":[12,76],"content":"A.14   Using the flush Directive without a List | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"A.14   Using the flush Directive without a List | Microsoft Docs","pos":[0,64]}]},{"content":"A.14   Using the flush Directive without a List","pos":[556,603]},{"pos":[604,831],"content":"The following example (for <bpt id=\"p1\">[</bpt>Section 2.6.5<ept id=\"p1\">](../../parallel/openmp/2-6-5-flush-directive.md)</ept> on page 20) distinguishes the shared objects affected by a <ph id=\"ph1\">`flush`</ph> directive with no list from the shared objects that are not affected:","source":"The following example (for [Section 2.6.5](../../parallel/openmp/2-6-5-flush-directive.md) on page 20) distinguishes the shared objects affected by a `flush` directive with no list from the shared objects that are not affected:"},{"content":"Example","pos":[840,847]},{"content":"Code","pos":[857,861]}],"content":"---\ntitle: \"A.14   Using the flush Directive without a List | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 9e63141a-d0c6-43a5-ac16-b0bd7c89b871\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# A.14   Using the flush Directive without a List\nThe following example (for [Section 2.6.5](../../parallel/openmp/2-6-5-flush-directive.md) on page 20) distinguishes the shared objects affected by a `flush` directive with no list from the shared objects that are not affected:  \n  \n## Example  \n  \n### Code  \n  \n```  \n// omp_flush_without_list.c  \n#include <omp.h>  \n  \nint x, *p = &x;  \n  \nvoid f1(int *q)  \n{  \n    *q = 1;  \n    #pragma omp flush  \n    // x, p, and *q are flushed  \n    //   because they are shared and accessible  \n    // q is not flushed because it is not shared.  \n}  \n  \nvoid f2(int *q)  \n{  \n    #pragma omp barrier  \n    *q = 2;  \n  \n    #pragma omp barrier  \n    // a barrier implies a flush  \n    // x, p, and *q are flushed  \n    //   because they are shared and accessible  \n    // q is not flushed because it is not shared.  \n}  \n  \nint g(int n)  \n{  \n    int i = 1, j, sum = 0;  \n    *p = 1;  \n  \n    #pragma omp parallel reduction(+: sum) num_threads(10)  \n    {  \n        f1(&j);  \n        // i, n and sum were not flushed  \n        //   because they were not accessible in f1  \n        // j was flushed because it was accessible  \n        sum += j;  \n        f2(&j);  \n        // i, n, and sum were not flushed  \n        //   because they were not accessible in f2  \n        // j was flushed because it was accessible  \n        sum += i + j + *p + n;  \n    }  \n    return sum;  \n}  \n  \nint main()  \n{  \n}  \n```"}