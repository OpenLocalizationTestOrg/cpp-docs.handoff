{"nodes":[{"pos":[12,40],"content":"fenv_access | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"fenv_access | Microsoft Docs","pos":[0,28]}]},{"content":"fenv_access","pos":[667,678]},{"content":"Disables (ON) or enables (OFF) optimizations that could change flag tests and mode changes.","pos":[679,770]},{"content":"Syntax","pos":[779,785]},{"content":"Remarks","pos":[842,849]},{"pos":[853,886],"content":"By default, <ph id=\"ph1\">`fenv_access`</ph> is OFF.","source":"By default, `fenv_access` is OFF."},{"pos":[893,1044],"content":"For more information on floating-point behavior, see <bpt id=\"p1\">[</bpt>/fp (Specify Floating-Point Behavior)<ept id=\"p1\">](../build/reference/fp-specify-floating-point-behavior.md)</ept>.","source":"For more information on floating-point behavior, see [/fp (Specify Floating-Point Behavior)](../build/reference/fp-specify-floating-point-behavior.md)."},{"pos":[1051,1116],"content":"The kinds of optimizations that are subject to <ph id=\"ph1\">`fenv_access`</ph> are:","source":"The kinds of optimizations that are subject to `fenv_access` are:"},{"content":"Global common subexpression elimination","pos":[1126,1165]},{"content":"Code motion","pos":[1175,1186]},{"content":"Constant folding","pos":[1196,1212]},{"content":"Other floating-point pragmas include:","pos":[1219,1256]},{"content":"float_control","pos":[1267,1280]},{"content":"fp_contract","pos":[1326,1337]},{"content":"Example","pos":[1379,1386]},{"content":"Example","pos":[1958,1965]},{"content":"The following sample is for compiler producing output files for Itanium processors.","pos":[1969,2052]},{"content":"<bpt id=\"p1\">**</bpt>/fp:precise<ept id=\"p1\">**</ept> keeps the intermediate results in extended precision where values greater than FLT_MAX (3.402823466e+38F) can be calculated and as a result of that sum will have 1.0 result, as it should if manually calculated.","pos":[2053,2279],"source":"**/fp:precise** keeps the intermediate results in extended precision where values greater than FLT_MAX (3.402823466e+38F) can be calculated and as a result of that sum will have 1.0 result, as it should if manually calculated."},{"content":"<bpt id=\"p1\">**</bpt>/fp:strict<ept id=\"p1\">**</ept> keeps intermediate results in their source precision (float) so the first addition produces infinity, which is kept throughout the expression.","pos":[2280,2437],"source":"**/fp:strict** keeps intermediate results in their source precision (float) so the first addition produces infinity, which is kept throughout the expression."},{"content":"Example","pos":[2996,3003]},{"pos":[3007,3201],"content":"When commenting out <ph id=\"ph1\">`#pragma fenv_access (on)`</ph> from the previous sample, note that the output is different because the compiler does compile-time evaluation, which does not use the control mode.","source":"When commenting out `#pragma fenv_access (on)` from the previous sample, note that the output is different because the compiler does compile-time evaluation, which does not use the control mode."},{"content":"See Also","pos":[3703,3711]},{"content":"Pragma Directives and the __Pragma Keyword","pos":[3716,3758]}],"content":"---\ntitle: \"fenv_access | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc-pragma.fenv_access\"\n  - \"fenv_access_CPP\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"pragmas, fenv_access\"\n  - \"fenv_access pragma\"\nms.assetid: 2ccea292-0ae4-42ce-9c67-cc189299857b\ncaps.latest.revision: 12\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# fenv_access\nDisables (ON) or enables (OFF) optimizations that could change flag tests and mode changes.  \n  \n## Syntax  \n  \n```  \n#pragma fenv_access [ON | OFF]  \n```  \n  \n## Remarks  \n By default, `fenv_access` is OFF.  \n  \n For more information on floating-point behavior, see [/fp (Specify Floating-Point Behavior)](../build/reference/fp-specify-floating-point-behavior.md).  \n  \n The kinds of optimizations that are subject to `fenv_access` are:  \n  \n-   Global common subexpression elimination  \n  \n-   Code motion  \n  \n-   Constant folding  \n  \n Other floating-point pragmas include:  \n  \n-   [float_control](../preprocessor/float-control.md)  \n  \n-   [fp_contract](../preprocessor/fp-contract.md)  \n  \n## Example  \n  \n```  \n// pragma_directive_fenv_access_x86.cpp  \n// compile with: /O2  \n// processor: x86  \n#include <stdio.h>  \n#include <float.h>   \n#include <errno.h>  \n#pragma fenv_access (on)  \n  \nint main() {  \n   double z, b = 0.1, t = 0.1;  \n   unsigned int currentControl;  \n   errno_t err;  \n  \n   err = _controlfp_s(&currentControl, _PC_24, _MCW_PC);  \n   if (err != 0) {  \n      printf_s(\"The function _controlfp_s failed!\\n\");  \n      return -1;  \n   }  \n   z = b * t;  \n   printf_s (\"out=%.15e\\n\",z);  \n}  \n```  \n  \n```Output  \nout=9.999999776482582e-003  \n```  \n  \n## Example  \n The following sample is for compiler producing output files for Itanium processors. **/fp:precise** keeps the intermediate results in extended precision where values greater than FLT_MAX (3.402823466e+38F) can be calculated and as a result of that sum will have 1.0 result, as it should if manually calculated. **/fp:strict** keeps intermediate results in their source precision (float) so the first addition produces infinity, which is kept throughout the expression.  \n  \n```  \n// pragma_directive_fenv_access_IPF.cpp  \n// compile with: /O2 /fp:precise  \n// processor: IPF  \n// compiling with /fp:precise prints 1.0F  \n// compile with /fp:strict to print infinity  \n  \n#include <stdio.h>  \nfloat arr[5] = {3.402823465e+38F,   \n               3.402823462e+38F,  \n               3.402823464e+38F,  \n               3.402823463e+38F,  \n               1.0F};  \n  \nint main() {  \n   float sum = 0;  \n   sum = arr[0] + arr[1] - arr[2] - arr[3] + arr[4];  \n   printf_s(\"%f\\n\", sum);  \n}  \n```  \n  \n```Output  \n1.000000  \n```  \n  \n## Example  \n When commenting out `#pragma fenv_access (on)` from the previous sample, note that the output is different because the compiler does compile-time evaluation, which does not use the control mode.  \n  \n```  \n// pragma_directive_fenv_access_2.cpp  \n// compile with: /O2  \n#include <stdio.h>  \n#include <float.h>   \n  \nint main() {  \n   double z, b = 0.1, t = 0.1;  \n   unsigned int currentControl;  \n   errno_t err;  \n  \n   err = _controlfp_s(&currentControl, _PC_24, _MCW_PC);  \n   if (err != 0) {  \n      printf_s(\"The function _controlfp_s failed!\\n\");  \n      return -1;  \n   }  \n   z = b * t;  \n   printf_s (\"out=%.15e\\n\",z);  \n}  \n```  \n  \n```Output  \nout=1.000000000000000e-002  \n```  \n  \n## See Also  \n [Pragma Directives and the __Pragma Keyword](../preprocessor/pragma-directives-and-the-pragma-keyword.md)"}