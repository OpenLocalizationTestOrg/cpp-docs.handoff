{"nodes":[{"pos":[12,53],"content":"Collection Class Helpers | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Collection Class Helpers | Microsoft Docs","pos":[0,41]}]},{"pos":[779,803],"content":"Collection Class Helpers","linkify":"Collection Class Helpers","nodes":[{"content":"Collection Class Helpers","pos":[0,24]}]},{"content":"The collection classes <ph id=\"ph1\">`CMap`</ph>, <ph id=\"ph2\">`CList`</ph>, and <ph id=\"ph3\">`CArray`</ph> use templated global helper functions for such purposes as comparing, copying, and serializing elements.","pos":[804,961],"source":"The collection classes `CMap`, `CList`, and `CArray` use templated global helper functions for such purposes as comparing, copying, and serializing elements."},{"content":"As part of your implementation of classes based on <ph id=\"ph1\">`CMap`</ph>, <ph id=\"ph2\">`CList`</ph>, and <ph id=\"ph3\">`CArray`</ph>, you must override these functions as necessary with versions tailored to the type of data stored in your map, list, or array.","pos":[962,1169],"source":" As part of your implementation of classes based on `CMap`, `CList`, and `CArray`, you must override these functions as necessary with versions tailored to the type of data stored in your map, list, or array."},{"content":"For information on overriding helper functions such as <ph id=\"ph1\">`SerializeElements`</ph>, see the article <bpt id=\"p1\">[</bpt>Collections: How to Make a Type-Safe Collection<ept id=\"p1\">](../../mfc/how-to-make-a-type-safe-collection.md)</ept>.","pos":[1170,1361],"source":" For information on overriding helper functions such as `SerializeElements`, see the article [Collections: How to Make a Type-Safe Collection](../../mfc/how-to-make-a-type-safe-collection.md)."},{"content":"Note that <bpt id=\"p1\">**</bpt>ConstructElements<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>DestructElements<ept id=\"p2\">**</ept> have been deprecated.","pos":[1362,1440],"source":" Note that **ConstructElements** and **DestructElements** have been deprecated."},{"content":"The Microsoft Foundation Class Library provides the following global functions to help you customize your collection classes:","pos":[1447,1572]},{"pos":[1582,1606],"content":"Collection Class Helpers","linkify":"Collection Class Helpers","nodes":[{"content":"Collection Class Helpers","pos":[0,24]}]},{"pos":[1627,1662],"content":"<bpt id=\"p1\">[</bpt>CompareElements<ept id=\"p1\">](#compareelements)</ept>","source":"[CompareElements](#compareelements)"},{"content":"Indicates whether elements are the same.","pos":[1663,1703]},{"pos":[1708,1737],"content":"<bpt id=\"p1\">[</bpt>CopyElements<ept id=\"p1\">](#copyelements)</ept>","source":"[CopyElements](#copyelements)"},{"content":"Copies elements from one array to another.","pos":[1738,1780]},{"pos":[1785,1814],"content":"<bpt id=\"p1\">[</bpt>DumpElements<ept id=\"p1\">](#dumpelements)</ept>","source":"[DumpElements](#dumpelements)"},{"content":"Provides stream-oriented diagnostic output.","pos":[1815,1858]},{"pos":[1863,1882],"content":"<bpt id=\"p1\">[</bpt>HashKey<ept id=\"p1\">](#hashkey)</ept>","source":"[HashKey](#hashkey)"},{"content":"Calculates a hash key.","pos":[1883,1905]},{"pos":[1910,1949],"content":"<bpt id=\"p1\">[</bpt>SerializeElements<ept id=\"p1\">](#serializeelements)</ept>","source":"[SerializeElements](#serializeelements)"},{"content":"Stores or retrieves elements to or from an archive.","pos":[1950,2001]},{"pos":[2012,2059],"content":"<bpt id=\"p1\">&lt;a name=\"compareelements\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CompareElements","linkify":"<a name=\"compareelements\"></a>  CompareElements","source":"<a name=\"compareelements\"></a>  CompareElements"},{"pos":[2063,2262],"content":"Called directly by [CList::Find](clist-class.md#not_found.md#clist__find and indirectly by <bpt id=\"p1\">[</bpt>cmap__lookup<ept id=\"p1\">](cmap-class.md#cmap__lookup)</ept> and <bpt id=\"p2\">[</bpt>cmap__operator &amp;#91;&amp;#93;<ept id=\"p2\">](cmap-class.md#cmap__operator_at)</ept>.","source":"Called directly by [CList::Find](clist-class.md#not_found.md#clist__find and indirectly by [cmap__lookup](cmap-class.md#cmap__lookup) and [cmap__operator &#91;&#93;](cmap-class.md#cmap__operator_at)."},{"pos":[2423,2433],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept>","pos":[2437,2443],"source":"*TYPE*"},{"content":"The type of the first element to be compared.","pos":[2447,2492]},{"content":"Pointer to the first element to be compared.","pos":[2514,2558]},{"content":"The type of the second element to be compared.","pos":[2579,2625]},{"content":"Pointer to the second element to be compared.","pos":[2647,2692]},{"pos":[2702,2714],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[2718,2828],"content":"Nonzero if the object pointed to by <ph id=\"ph1\">`pElement1`</ph> is equal to the object pointed to by <ph id=\"ph2\">`pElement2`</ph>; otherwise 0.","source":"Nonzero if the object pointed to by `pElement1` is equal to the object pointed to by `pElement2`; otherwise 0."},{"pos":[2838,2845],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[2849,2921],"content":"The <ph id=\"ph1\">`CMap`</ph> calls use the <ph id=\"ph2\">`CMap`</ph> template parameters <bpt id=\"p1\">*</bpt>KEY<ept id=\"p1\">*</ept> and <ph id=\"ph3\">`ARG_KEY`</ph>.","source":"The `CMap` calls use the `CMap` template parameters *KEY* and `ARG_KEY`."},{"content":"The default implementation returns the result of the comparison of <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\*</ph>pElement1<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt><ph id=\"ph2\">\\*</ph>pElement2<ept id=\"p2\">*</ept>.","pos":[2928,3027],"source":"The default implementation returns the result of the comparison of *\\*pElement1* and *\\*pElement2*."},{"content":"Override this function so that it compares the elements in a way that is appropriate for your application.","pos":[3028,3134]},{"content":"The C++ language defines the comparison operator ( <ph id=\"ph1\">`==`</ph>) for simple types ( <ph id=\"ph2\">`char`</ph>, <ph id=\"ph3\">`int`</ph>, <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>, and so on) but does not define a comparison operator for classes and structures.","pos":[3141,3323],"source":"The C++ language defines the comparison operator ( `==`) for simple types ( `char`, `int`, **float**, and so on) but does not define a comparison operator for classes and structures."},{"content":"If you want to use <ph id=\"ph1\">`CompareElements`</ph> or to instantiate one of the collection classes that uses it, you must either define the comparison operator or overload <ph id=\"ph2\">`CompareElements`</ph> with a version that returns appropriate values.","pos":[3324,3547],"source":" If you want to use `CompareElements` or to instantiate one of the collection classes that uses it, you must either define the comparison operator or overload `CompareElements` with a version that returns appropriate values."},{"pos":[3557,3598],"content":"<bpt id=\"p1\">&lt;a name=\"copyelements\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CopyElements","linkify":"<a name=\"copyelements\"></a>  CopyElements","source":"<a name=\"copyelements\"></a>  CopyElements"},{"pos":[3602,3736],"content":"This function is called directly by <bpt id=\"p1\">[</bpt>CArray::Append<ept id=\"p1\">](carray-class.md#carray__append)</ept> and <bpt id=\"p2\">[</bpt>CArray::Copy<ept id=\"p2\">](carray-class.md#carray__copy)</ept>.","source":"This function is called directly by [CArray::Append](carray-class.md#carray__append) and [CArray::Copy](carray-class.md#carray__copy)."},{"pos":[3879,3889],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept>","pos":[3893,3899],"source":"*TYPE*"},{"content":"Template parameter specifying the type of elements to be copied.","pos":[3903,3967]},{"content":"Pointer to the destination where the elements will be copied.","pos":[3985,4046]},{"content":"Pointer to the source of the elements to be copied.","pos":[4063,4114]},{"content":"Number of elements to be copied.","pos":[4133,4165]},{"pos":[4175,4182],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The default implementation uses the simple assignment operator ( <bpt id=\"p1\">**</bpt><ph id=\"ph1\">=</ph><ept id=\"p1\">**</ept> ) to perform the copy operation.","pos":[4186,4289],"source":"The default implementation uses the simple assignment operator ( **=** ) to perform the copy operation."},{"content":"If the type being copied does not have an overloaded operator=, then the default implementation performs a bitwise copy.","pos":[4290,4410]},{"pos":[4417,4590],"content":"For information on implementing this and other helper functions, see the article <bpt id=\"p1\">[</bpt>Collections: How to Make a Type-Safe Collection<ept id=\"p1\">](../how-to-make-a-type-safe-collection.md)</ept>.","source":"For information on implementing this and other helper functions, see the article [Collections: How to Make a Type-Safe Collection](../how-to-make-a-type-safe-collection.md)."},{"pos":[4600,4641],"content":"<bpt id=\"p1\">&lt;a name=\"dumpelements\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  DumpElements","linkify":"<a name=\"dumpelements\"></a>  DumpElements","source":"<a name=\"dumpelements\"></a>  DumpElements"},{"content":"Provides stream-oriented diagnostic output in text form for the elements of your collection when overridden.","pos":[4645,4753]},{"pos":[4907,4917],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Dump context for dumping elements.","pos":[4929,4963]},{"content":"<bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept>","pos":[4970,4976],"source":"*TYPE*"},{"content":"Template parameter specifying the type of the elements.","pos":[4980,5035]},{"content":"Pointer to the elements to be dumped.","pos":[5057,5094]},{"content":"Number of elements to be dumped.","pos":[5113,5145]},{"pos":[5155,5162],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5166,5287],"content":"The <bpt id=\"p1\">**</bpt>CArray::Dump<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>CList::Dump<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>CMap::Dump<ept id=\"p3\">**</ept> functions call this if the depth of the dump is greater than 0.","source":"The **CArray::Dump**, **CList::Dump**, and **CMap::Dump** functions call this if the depth of the dump is greater than 0."},{"content":"The default implementation does nothing.","pos":[5294,5334]},{"content":"If the elements of your collection are derived from <ph id=\"ph1\">`CObject`</ph>, your override will typically iterate through the collection's elements, calling <ph id=\"ph2\">`Dump`</ph> for each element in turn.","pos":[5335,5510],"source":" If the elements of your collection are derived from `CObject`, your override will typically iterate through the collection's elements, calling `Dump` for each element in turn."},{"pos":[5521,5552],"content":"<bpt id=\"p1\">&lt;a name=\"hashkey\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  HashKey","linkify":"<a name=\"hashkey\"></a>  HashKey","source":"<a name=\"hashkey\"></a>  HashKey"},{"content":"Calculates a hash value for the given key.","pos":[5556,5598]},{"pos":[5696,5706],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Template parameter specifying the data type used to access map keys.","pos":[5723,5791]},{"content":"The key whose hash value is to be calculated.","pos":[5807,5852]},{"pos":[5862,5874],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The key's hash value.","pos":[5878,5899]},{"pos":[5909,5916],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5920,6131],"content":"This function is called directly by <bpt id=\"p1\">[</bpt>CMap::RemoveKey<ept id=\"p1\">](cmap-class.md#cmap__removekey)</ept> and indirectly by <bpt id=\"p2\">[</bpt>CMap::Lookup<ept id=\"p2\">](cmap-class.md#cmap__lookup)</ept> and <bpt id=\"p3\">[</bpt>CMap::Operator &amp;#91;&amp;#93;<ept id=\"p3\">](cmap-class.md#cmap__operator_at)</ept>.","source":"This function is called directly by [CMap::RemoveKey](cmap-class.md#cmap__removekey) and indirectly by [CMap::Lookup](cmap-class.md#cmap__lookup) and [CMap::Operator &#91;&#93;](cmap-class.md#cmap__operator_at)."},{"content":"The default implementation creates a hash value by shifting <ph id=\"ph1\">`key`</ph> right by four positions.","pos":[6136,6226],"source":"The default implementation creates a hash value by shifting `key` right by four positions."},{"content":"Override this function so that it returns hash values appropriate for your application.","pos":[6227,6314]},{"pos":[6324,6331],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6553,6604],"content":"<bpt id=\"p1\">&lt;a name=\"serializeelements\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  SerializeElements","linkify":"<a name=\"serializeelements\"></a>  SerializeElements","source":"<a name=\"serializeelements\"></a>  SerializeElements"},{"pos":[6608,6727],"content":"<bpt id=\"p1\">[</bpt>CArray<ept id=\"p1\">](carray-class.md)</ept>, <bpt id=\"p2\">[</bpt>CList<ept id=\"p2\">](clist-class.md)</ept>, and <bpt id=\"p3\">[</bpt>CMap<ept id=\"p3\">](cmap-class.md)</ept> call this function to serialize elements.","source":"[CArray](carray-class.md), [CList](clist-class.md), and [CMap](cmap-class.md) call this function to serialize elements."},{"pos":[6858,6868],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept>","pos":[6872,6878],"source":"*TYPE*"},{"content":"Template parameter specifying the type of the elements.","pos":[6882,6937]},{"content":"An archive object to archive to or from.","pos":[6952,6992]},{"content":"Pointer to the elements being archived.","pos":[7014,7053]},{"content":"Number of elements being archived","pos":[7072,7105]},{"pos":[7115,7122],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The default implementation does a bitwise read or write.","pos":[7126,7182]},{"pos":[7189,7362],"content":"For information on implementing this and other helper functions, see the article <bpt id=\"p1\">[</bpt>Collections: How to Make a Type-Safe Collection<ept id=\"p1\">](../how-to-make-a-type-safe-collection.md)</ept>.","source":"For information on implementing this and other helper functions, see the article [Collections: How to Make a Type-Safe Collection](../how-to-make-a-type-safe-collection.md)."},{"pos":[7372,7379],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[7383,7506],"content":"See the example in the article <bpt id=\"p1\">[</bpt>Collections: How to Make a Type-Safe Collection<ept id=\"p1\">](../how-to-make-a-type-safe-collection.md)</ept>.","source":"See the example in the article [Collections: How to Make a Type-Safe Collection](../how-to-make-a-type-safe-collection.md)."},{"pos":[7515,7523],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Macros and Globals<ept id=\"p1\">](mfc-macros-and-globals.md)</ept><ph id=\"ph1\"> </ph>","pos":[7527,7575],"source":"[Macros and Globals](mfc-macros-and-globals.md) "},{"content":"<bpt id=\"p1\"> [</bpt>CMap Class<ept id=\"p1\">](cmap-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[7578,7607],"source":" [CMap Class](cmap-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>CList Class<ept id=\"p1\">](clist-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[7610,7641],"source":" [CList Class](clist-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>CArray Class<ept id=\"p1\">](carray-class.md)</ept>","pos":[7644,7676],"source":" [CArray Class](carray-class.md)"}],"content":"---\ntitle: \"Collection Class Helpers | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mfc.macros.classes\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"DestructElements function\"\n  - \"ConstructElements function\"\n  - \"SerializeElements function\"\n  - \"collection classes, helper functions\"\n  - \"helper functions collection class\"\nms.assetid: bc3a2368-9edd-4748-9e6a-13cba79517ca\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Collection Class Helpers\nThe collection classes `CMap`, `CList`, and `CArray` use templated global helper functions for such purposes as comparing, copying, and serializing elements. As part of your implementation of classes based on `CMap`, `CList`, and `CArray`, you must override these functions as necessary with versions tailored to the type of data stored in your map, list, or array. For information on overriding helper functions such as `SerializeElements`, see the article [Collections: How to Make a Type-Safe Collection](../../mfc/how-to-make-a-type-safe-collection.md). Note that **ConstructElements** and **DestructElements** have been deprecated.  \n  \n The Microsoft Foundation Class Library provides the following global functions to help you customize your collection classes:  \n  \n### Collection Class Helpers  \n  \n|||  \n|-|-|  \n|[CompareElements](#compareelements)|Indicates whether elements are the same.|  \n|[CopyElements](#copyelements)|Copies elements from one array to another.|  \n|[DumpElements](#dumpelements)|Provides stream-oriented diagnostic output.|  \n|[HashKey](#hashkey)|Calculates a hash key.|  \n|[SerializeElements](#serializeelements)|Stores or retrieves elements to or from an archive.|  \n  \n##  <a name=\"compareelements\"></a>  CompareElements  \n Called directly by [CList::Find](clist-class.md#not_found.md#clist__find and indirectly by [cmap__lookup](cmap-class.md#cmap__lookup) and [cmap__operator &#91;&#93;](cmap-class.md#cmap__operator_at).  \n  \n```  \n \ntemplate<class TYPE, class ARG_TYPE>  \nBOOL AFXAPI  \nCompareElements(\n    const TYPE* pElement1,  \n    const ARG_TYPE* pElement2);\n\n \n```  \n  \n### Parameters  \n *TYPE*  \n The type of the first element to be compared.  \n  \n `pElement1`  \n Pointer to the first element to be compared.  \n  \n `ARG_TYPE`  \n The type of the second element to be compared.  \n  \n `pElement2`  \n Pointer to the second element to be compared.  \n  \n### Return Value  \n Nonzero if the object pointed to by `pElement1` is equal to the object pointed to by `pElement2`; otherwise 0.  \n  \n### Remarks  \n The `CMap` calls use the `CMap` template parameters *KEY* and `ARG_KEY`.  \n  \n The default implementation returns the result of the comparison of *\\*pElement1* and *\\*pElement2*. Override this function so that it compares the elements in a way that is appropriate for your application.  \n  \n The C++ language defines the comparison operator ( `==`) for simple types ( `char`, `int`, **float**, and so on) but does not define a comparison operator for classes and structures. If you want to use `CompareElements` or to instantiate one of the collection classes that uses it, you must either define the comparison operator or overload `CompareElements` with a version that returns appropriate values.  \n  \n##  <a name=\"copyelements\"></a>  CopyElements  \n This function is called directly by [CArray::Append](carray-class.md#carray__append) and [CArray::Copy](carray-class.md#carray__copy).  \n  \n```  \n \ntemplate<class TYPE>  \nvoid AFXAPI CopyElements(\n    TYPE* pDest,  \n    const TYPE* pSrc,  \n    INT_PTR nCount);\n\n \n```  \n  \n### Parameters  \n *TYPE*  \n Template parameter specifying the type of elements to be copied.  \n  \n `pDest`  \n Pointer to the destination where the elements will be copied.  \n  \n `pSrc`  \n Pointer to the source of the elements to be copied.  \n  \n `nCount`  \n Number of elements to be copied.  \n  \n### Remarks  \n The default implementation uses the simple assignment operator ( **=** ) to perform the copy operation. If the type being copied does not have an overloaded operator=, then the default implementation performs a bitwise copy.  \n  \n For information on implementing this and other helper functions, see the article [Collections: How to Make a Type-Safe Collection](../how-to-make-a-type-safe-collection.md).  \n  \n##  <a name=\"dumpelements\"></a>  DumpElements  \n Provides stream-oriented diagnostic output in text form for the elements of your collection when overridden.  \n  \n```  \n \ntemplate<class TYPE>  \nvoid  AFXAPI DumpElements(\n    CDumpContext& dc,  \n    const TYPE* pElements,  \n    INT_PTR nCount);\n\n \n```  \n  \n### Parameters  \n `dc`  \n Dump context for dumping elements.  \n  \n *TYPE*  \n Template parameter specifying the type of the elements.  \n  \n `pElements`  \n Pointer to the elements to be dumped.  \n  \n `nCount`  \n Number of elements to be dumped.  \n  \n### Remarks  \n The **CArray::Dump**, **CList::Dump**, and **CMap::Dump** functions call this if the depth of the dump is greater than 0.  \n  \n The default implementation does nothing. If the elements of your collection are derived from `CObject`, your override will typically iterate through the collection's elements, calling `Dump` for each element in turn.  \n  \n\n##  <a name=\"hashkey\"></a>  HashKey  \n Calculates a hash value for the given key.  \n  \n```  \ntemplate<class ARG_KEY>  \nAFX_INLINE UINT AFXAPI HashKey(ARG_KEY  key); \n```  \n  \n### Parameters  \n `ARG_KEY`  \n Template parameter specifying the data type used to access map keys.  \n  \n `key`  \n The key whose hash value is to be calculated.  \n  \n### Return Value  \n The key's hash value.  \n  \n### Remarks  \n This function is called directly by [CMap::RemoveKey](cmap-class.md#cmap__removekey) and indirectly by [CMap::Lookup](cmap-class.md#cmap__lookup) and [CMap::Operator &#91;&#93;](cmap-class.md#cmap__operator_at).\n  \n The default implementation creates a hash value by shifting `key` right by four positions. Override this function so that it returns hash values appropriate for your application.  \n  \n### Example\n ```cpp  \ntemplate <> UINT AFXAPI HashKey(unsigned __int64 key)\n{\n   // Generate the hash value by XORing the lower 32 bits of the number \n   // with the upper 32 bits\n   return(UINT(key) ^ UINT(key >> 32));\n}\n ```\n \n##  <a name=\"serializeelements\"></a>  SerializeElements  \n [CArray](carray-class.md), [CList](clist-class.md), and [CMap](cmap-class.md) call this function to serialize elements.  \n  \n```  \n \ntemplate<class TYPE>  \nvoid AFXAPI SerializeElements(CArchive& ar, TYPE* pElements, INT_PTR nCount);\n\n \n```  \n  \n### Parameters  \n *TYPE*  \n Template parameter specifying the type of the elements.  \n  \n `ar`  \n An archive object to archive to or from.  \n  \n `pElements`  \n Pointer to the elements being archived.  \n  \n `nCount`  \n Number of elements being archived  \n  \n### Remarks  \n The default implementation does a bitwise read or write.  \n  \n For information on implementing this and other helper functions, see the article [Collections: How to Make a Type-Safe Collection](../how-to-make-a-type-safe-collection.md).  \n  \n### Example  \n See the example in the article [Collections: How to Make a Type-Safe Collection](../how-to-make-a-type-safe-collection.md).  \n  \n## See Also  \n [Macros and Globals](mfc-macros-and-globals.md)   \n [CMap Class](cmap-class.md)   \n [CList Class](clist-class.md)   \n [CArray Class](carray-class.md)"}