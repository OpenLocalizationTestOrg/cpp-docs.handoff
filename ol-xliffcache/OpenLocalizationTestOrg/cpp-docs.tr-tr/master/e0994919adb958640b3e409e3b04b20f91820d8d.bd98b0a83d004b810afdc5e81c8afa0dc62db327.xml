{"nodes":[{"pos":[12,56],"content":"Asynchronous Message Blocks | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Asynchronous Message Blocks | Microsoft Docs","pos":[0,44]}]},{"content":"Asynchronous Message Blocks","pos":[703,730]},{"content":"The Agents Library provides several message-block types that enable you to propagate messages among application components in a thread-safe manner.","pos":[732,879]},{"content":"These message-block types are often used with the various message-passing routines, such as <bpt id=\"p1\">[</bpt>concurrency::send<ept id=\"p1\">](reference/concurrency-namespace-functions.md#send)</ept>, <bpt id=\"p2\">[</bpt>concurrency::asend<ept id=\"p2\">](reference/concurrency-namespace-functions.md#asend)</ept>, <bpt id=\"p3\">[</bpt>concurrency::receive<ept id=\"p3\">](reference/concurrency-namespace-functions.md#receive)</ept>, and <bpt id=\"p4\">[</bpt>concurrency::try_receive<ept id=\"p4\">](reference/concurrency-namespace-functions.md#try_receive)</ept>.","pos":[880,1285],"source":" These message-block types are often used with the various message-passing routines, such as [concurrency::send](reference/concurrency-namespace-functions.md#send), [concurrency::asend](reference/concurrency-namespace-functions.md#asend), [concurrency::receive](reference/concurrency-namespace-functions.md#receive), and [concurrency::try_receive](reference/concurrency-namespace-functions.md#try_receive)."},{"content":"For more information about the message passing routines that are defined by the Agents Library, see <bpt id=\"p1\">[</bpt>Message Passing Functions<ept id=\"p1\">](../../parallel/concrt/message-passing-functions.md)</ept>.","pos":[1286,1466],"source":" For more information about the message passing routines that are defined by the Agents Library, see [Message Passing Functions](../../parallel/concrt/message-passing-functions.md)."},{"pos":[1495,1503],"content":"Sections"},{"content":"This topic contains the following sections:","pos":[1507,1550]},{"content":"Sources and Targets","pos":[1559,1578]},{"content":"Message Propagation","pos":[1610,1629]},{"content":"Overview of Message Block Types","pos":[1653,1684]},{"content":"unbounded_buffer Class","pos":[1705,1727]},{"content":"overwrite_buffer Class","pos":[1756,1778]},{"content":"single_assignment Class","pos":[1807,1830]},{"content":"call Class","pos":[1860,1870]},{"content":"transformer Class","pos":[1887,1904]},{"content":"choice Class","pos":[1928,1940]},{"content":"join and multitype_join Classes","pos":[1959,1990]},{"content":"timer Class","pos":[2007,2018]},{"content":"Message Filtering","pos":[2036,2053]},{"content":"Message Reservation","pos":[2075,2094]},{"pos":[2154,2173],"content":"Sources and Targets"},{"content":"Sources and targets are two important participants in message passing.","pos":[2177,2247]},{"content":"A <bpt id=\"p1\">*</bpt>source<ept id=\"p1\">*</ept> refers to an endpoint of communication that sends messages.","pos":[2248,2318],"source":" A *source* refers to an endpoint of communication that sends messages."},{"content":"A <bpt id=\"p1\">*</bpt>target<ept id=\"p1\">*</ept> refers to an endpoint of communication that receives messages.","pos":[2319,2392],"source":" A *target* refers to an endpoint of communication that receives messages."},{"content":"You can think of a source as an endpoint that you read from and a target as an endpoint that you write to.","pos":[2393,2499]},{"content":"Applications connect sources and targets together to form <bpt id=\"p1\">*</bpt>messaging networks<ept id=\"p1\">*</ept>.","pos":[2500,2579],"source":" Applications connect sources and targets together to form *messaging networks*."},{"content":"The Agents Library uses two abstract classes to represent sources and targets: <bpt id=\"p1\">[</bpt>concurrency::ISource<ept id=\"p1\">](../../parallel/concrt/reference/isource-class.md)</ept> and <bpt id=\"p2\">[</bpt>concurrency::ITarget<ept id=\"p2\">](../../parallel/concrt/reference/itarget-class.md)</ept>.","pos":[2586,2815],"source":"The Agents Library uses two abstract classes to represent sources and targets: [concurrency::ISource](../../parallel/concrt/reference/isource-class.md) and [concurrency::ITarget](../../parallel/concrt/reference/itarget-class.md)."},{"content":"Message block types that act as sources derive from <ph id=\"ph1\">`ISource`</ph>; message block types that act as targets derive from <ph id=\"ph2\">`ITarget`</ph>.","pos":[2816,2941],"source":" Message block types that act as sources derive from `ISource`; message block types that act as targets derive from `ITarget`."},{"content":"Message block types that act as sources and targets derive from both <ph id=\"ph1\">`ISource`</ph> and <ph id=\"ph2\">`ITarget`</ph>.","pos":[2942,3035],"source":" Message block types that act as sources and targets derive from both `ISource` and `ITarget`."},{"pos":[3042,3055],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[3092,3111],"content":"Message Propagation"},{"content":"<bpt id=\"p1\">*</bpt>Message propagation<ept id=\"p1\">*</ept> is the act of sending a message from one component to another.","pos":[3115,3199],"source":"*Message propagation* is the act of sending a message from one component to another."},{"content":"When a message block is offered a message, it can accept, decline, or postpone that message.","pos":[3200,3292]},{"content":"Every message block type stores and transmits messages in different ways.","pos":[3293,3366]},{"content":"For example, the <ph id=\"ph1\">`unbounded_buffer`</ph> class stores an unlimited number of messages, the <ph id=\"ph2\">`overwrite_buffer`</ph> class stores a single message at a time, and the transformer class stores an altered version of each message.","pos":[3367,3581],"source":" For example, the `unbounded_buffer` class stores an unlimited number of messages, the `overwrite_buffer` class stores a single message at a time, and the transformer class stores an altered version of each message."},{"content":"These message block types are described in more detail later in this document.","pos":[3582,3660]},{"content":"When a message block accepts a message, it can optionally perform work and, if the message block is a source, pass the resulting message to another member of the network.","pos":[3667,3837]},{"content":"A message block can use a filter function to decline messages that it does not want to receive.","pos":[3838,3933]},{"content":"Filters are described in more detail later in this topic, in the section <bpt id=\"p1\">[</bpt>Message Filtering<ept id=\"p1\">](#filtering)</ept>.","pos":[3934,4039],"source":" Filters are described in more detail later in this topic, in the section [Message Filtering](#filtering)."},{"content":"A message block that postpones a message can reserve that message and consume it later.","pos":[4040,4127]},{"content":"Message reservation is described in more detail later in this topic, in the section <bpt id=\"p1\">[</bpt>Message Reservation<ept id=\"p1\">](#reservation)</ept>.","pos":[4128,4248],"source":" Message reservation is described in more detail later in this topic, in the section [Message Reservation](#reservation)."},{"content":"The Agents Library enables message blocks to asynchronously or synchronously pass messages.","pos":[4255,4346]},{"content":"When you pass a message to a message block synchronously, for example, by using the <ph id=\"ph1\">`send`</ph> function, the runtime blocks the current context until the target block either accepts or rejects the message.","pos":[4347,4548],"source":" When you pass a message to a message block synchronously, for example, by using the `send` function, the runtime blocks the current context until the target block either accepts or rejects the message."},{"content":"When you pass a message to a message block asynchronously, for example, by using the <ph id=\"ph1\">`asend`</ph> function, the runtime offers the message to the target, and if the target accepts the message, the runtime schedules an asynchronous task that propagates the message to the receiver.","pos":[4549,4824],"source":" When you pass a message to a message block asynchronously, for example, by using the `asend` function, the runtime offers the message to the target, and if the target accepts the message, the runtime schedules an asynchronous task that propagates the message to the receiver."},{"content":"The runtime uses lightweight tasks to propagate messages in a cooperative manner.","pos":[4825,4906]},{"content":"For more information about lightweight tasks, see <bpt id=\"p1\">[</bpt>Task Scheduler<ept id=\"p1\">](../../parallel/concrt/task-scheduler-concurrency-runtime.md)</ept>.","pos":[4907,5035],"source":" For more information about lightweight tasks, see [Task Scheduler](../../parallel/concrt/task-scheduler-concurrency-runtime.md)."},{"content":"Applications connect sources and targets together to form messaging networks.","pos":[5043,5120]},{"content":"Typically, you link the network and call <ph id=\"ph1\">`send`</ph> or <ph id=\"ph2\">`asend`</ph> to pass data to the network.","pos":[5121,5208],"source":" Typically, you link the network and call `send` or `asend` to pass data to the network."},{"content":"To connect a source message block to a target, call the <bpt id=\"p1\">[</bpt>concurrency::ISource::link_target<ept id=\"p1\">](reference/isource-class.md#link_target)</ept> method.","pos":[5209,5348],"source":" To connect a source message block to a target, call the [concurrency::ISource::link_target](reference/isource-class.md#link_target) method."},{"content":"To disconnect a source block from a target, call the <bpt id=\"p1\">[</bpt>concurrency::ISource::unlink_target<ept id=\"p1\">](reference/isource-class.md#unlink_target)</ept> method.","pos":[5349,5489],"source":" To disconnect a source block from a target, call the [concurrency::ISource::unlink_target](reference/isource-class.md#unlink_target) method."},{"content":"To disconnect a source block from all of its targets, call the <bpt id=\"p1\">[</bpt>concurrency::ISource::unlink_targets<ept id=\"p1\">](reference/isource-class.md#unlink_targets)</ept> method.","pos":[5490,5642],"source":" To disconnect a source block from all of its targets, call the [concurrency::ISource::unlink_targets](reference/isource-class.md#unlink_targets) method."},{"content":"When one of the predefined message block types leaves scope or is destroyed, it automatically disconnects itself from any target blocks.","pos":[5643,5779]},{"content":"Some message block types restrict the maximum number of targets that they can write to.","pos":[5780,5867]},{"content":"The following section describes the restrictions that apply to the predefined message block types.","pos":[5868,5966]},{"pos":[5973,5986],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[6020,6051],"content":"Overview of Message Block Types"},{"content":"The following table briefly describes the role of the important message-block types.","pos":[6055,6139]},{"content":"unbounded_buffer","pos":[6147,6163]},{"content":"Stores a queue of messages.","pos":[6187,6214]},{"content":"overwrite_buffer","pos":[6222,6238]},{"content":"Stores one message that can be written to and read from multiple times.","pos":[6262,6333]},{"content":"single_assignment","pos":[6341,6358]},{"content":"Stores one message that can be written to one time and read from multiple times.","pos":[6383,6463]},{"content":"call","pos":[6471,6475]},{"content":"Performs work when it receives a message.","pos":[6487,6528]},{"content":"transformer","pos":[6536,6547]},{"content":"Performs work when it receives data and sends the result of that work to another target block.","pos":[6566,6660]},{"content":"The <ph id=\"ph1\">`transformer`</ph> class can act on different input and output types.","pos":[6661,6729],"source":" The `transformer` class can act on different input and output types."},{"content":"choice","pos":[6737,6743]},{"content":"Selects the first available message from a set of sources.","pos":[6757,6815]},{"content":"join and multitype join","pos":[6823,6846]},{"content":"Wait for all messages to be received from a set of sources and then combine the messages into one message for another message block.","pos":[6858,6990]},{"content":"timer","pos":[6998,7003]},{"content":"Sends a message to a target block on a regular interval.","pos":[7016,7072]},{"content":"These message-block types have different characteristics that make them useful for different situations.","pos":[7079,7183]},{"content":"These are some of the characteristics:","pos":[7184,7222]},{"pos":[7230,7330],"content":"<bpt id=\"p1\">*</bpt>Propagation type<ept id=\"p1\">*</ept>: Whether the message block acts as a source of data, a receiver of data, or both.","source":"*Propagation type*: Whether the message block acts as a source of data, a receiver of data, or both."},{"content":"<bpt id=\"p1\">*</bpt>Message ordering<ept id=\"p1\">*</ept>: Whether the message block maintains the original order in which messages are sent or received.","pos":[7338,7452],"source":"*Message ordering*: Whether the message block maintains the original order in which messages are sent or received."},{"content":"Each predefined message block type maintains the original order in which it sends or receives messages.","pos":[7453,7556]},{"pos":[7564,7647],"content":"<bpt id=\"p1\">*</bpt>Source count<ept id=\"p1\">*</ept>: The maximum number of sources that the message block can read from.","source":"*Source count*: The maximum number of sources that the message block can read from."},{"pos":[7655,7737],"content":"<bpt id=\"p1\">*</bpt>Target count<ept id=\"p1\">*</ept>: The maximum number of targets that the message block can write to.","source":"*Target count*: The maximum number of targets that the message block can write to."},{"content":"The following table shows how these characteristics relate to the various message-block types.","pos":[7744,7838]},{"content":"Message block type","pos":[7845,7863]},{"content":"Propagation type (Source, Target, or Both)","pos":[7864,7906]},{"content":"Message ordering (Ordered or Unordered)","pos":[7907,7946]},{"content":"Source count","pos":[7947,7959]},{"content":"Target count","pos":[7960,7972]},{"content":"Both","pos":[8162,8166]},{"content":"Ordered","pos":[8167,8174]},{"content":"Unbounded","pos":[8175,8184]},{"content":"Unbounded","pos":[8185,8194]},{"content":"Both","pos":[8218,8222]},{"content":"Ordered","pos":[8223,8230]},{"content":"Unbounded","pos":[8231,8240]},{"content":"Unbounded","pos":[8241,8250]},{"content":"Both","pos":[8275,8279]},{"content":"Ordered","pos":[8280,8287]},{"content":"Unbounded","pos":[8288,8297]},{"content":"Unbounded","pos":[8298,8307]},{"content":"Target","pos":[8319,8325]},{"content":"Ordered","pos":[8326,8333]},{"content":"Unbounded","pos":[8334,8343]},{"content":"Not Applicable","pos":[8344,8358]},{"content":"Both","pos":[8377,8381]},{"content":"Ordered","pos":[8382,8389]},{"content":"Unbounded","pos":[8390,8399]},{"content":"1","pos":[8400,8401]},{"content":"Both","pos":[8415,8419]},{"content":"Ordered","pos":[8420,8427]},{"content":"10","pos":[8428,8430]},{"content":"1","pos":[8431,8432]},{"content":"Both","pos":[8444,8448]},{"content":"Ordered","pos":[8449,8456]},{"content":"Unbounded","pos":[8457,8466]},{"content":"1","pos":[8467,8468]},{"content":"Both","pos":[8490,8494]},{"content":"Ordered","pos":[8495,8502]},{"content":"10","pos":[8503,8505]},{"content":"1","pos":[8506,8507]},{"content":"Source","pos":[8520,8526]},{"content":"Not Applicable","pos":[8527,8541]},{"content":"Not Applicable","pos":[8542,8556]},{"content":"1","pos":[8557,8558]},{"content":"The following sections describe the message-block types in more detail.","pos":[8566,8637]},{"pos":[8644,8657],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[8699,8721],"content":"unbounded_buffer Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::unbounded_buffer<ept id=\"p1\">](reference/unbounded-buffer-class.md)</ept> class represents a general-purpose asynchronous messaging structure.","pos":[8725,8866],"source":"The [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) class represents a general-purpose asynchronous messaging structure."},{"content":"This class stores a first in, first out (FIFO) queue of messages that can be written to by multiple sources or read from by multiple targets.","pos":[8867,9008]},{"content":"When a target receives a message from an <ph id=\"ph1\">`unbounded_buffer`</ph> object, that message is removed from the message queue.","pos":[9009,9124],"source":" When a target receives a message from an `unbounded_buffer` object, that message is removed from the message queue."},{"content":"Therefore, although an <ph id=\"ph1\">`unbounded_buffer`</ph> object can have multiple targets, only one target will receive each message.","pos":[9125,9243],"source":" Therefore, although an `unbounded_buffer` object can have multiple targets, only one target will receive each message."},{"content":"The <ph id=\"ph1\">`unbounded_buffer`</ph> class is useful when you want to pass multiple messages to another component, and that component must receive each message.","pos":[9244,9390],"source":" The `unbounded_buffer` class is useful when you want to pass multiple messages to another component, and that component must receive each message."},{"content":"Example","pos":[9400,9407]},{"content":"The following example shows the basic structure of how to work with the <ph id=\"ph1\">`unbounded_buffer`</ph> class.","pos":[9411,9508],"source":"The following example shows the basic structure of how to work with the `unbounded_buffer` class."},{"content":"This example sends three values to an <ph id=\"ph1\">`unbounded_buffer`</ph> object and then reads those values back from the same object.","pos":[9509,9627],"source":" This example sends three values to an `unbounded_buffer` object and then reads those values back from the same object."},{"pos":[9645,9680],"content":"concrt-unbounded_buffer-structure#1"},{"content":"This example produces the following output:","pos":[9762,9805]},{"pos":[9842,10054],"content":"For a complete example that shows how to use the <ph id=\"ph1\">`unbounded_buffer`</ph> class, see <bpt id=\"p1\">[</bpt>How to: Implement Various Producer-Consumer Patterns<ept id=\"p1\">](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md)</ept>.","source":"For a complete example that shows how to use the `unbounded_buffer` class, see [How to: Implement Various Producer-Consumer Patterns](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md)."},{"pos":[10061,10074],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[10116,10138],"content":"overwrite_buffer Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::overwrite_buffer<ept id=\"p1\">](../../parallel/concrt/reference/overwrite-buffer-class.md)</ept> class resembles the <ph id=\"ph1\">`unbounded_buffer`</ph> class, except that an <ph id=\"ph2\">`overwrite_buffer`</ph> object stores just one message.","pos":[10142,10348],"source":"The [concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) class resembles the `unbounded_buffer` class, except that an `overwrite_buffer` object stores just one message."},{"content":"In addition, when a target receives a message from an <ph id=\"ph1\">`overwrite_buffer`</ph> object, that message is not removed from the buffer.","pos":[10349,10474],"source":" In addition, when a target receives a message from an `overwrite_buffer` object, that message is not removed from the buffer."},{"content":"Therefore, multiple targets receive a copy of the message.","pos":[10475,10533]},{"content":"The <ph id=\"ph1\">`overwrite_buffer`</ph> class is useful when you want to pass multiple messages to another component, but that component needs only the most recent value.","pos":[10540,10693],"source":"The `overwrite_buffer` class is useful when you want to pass multiple messages to another component, but that component needs only the most recent value."},{"content":"This class is also useful when you want to broadcast a message to multiple components.","pos":[10694,10780]},{"content":"Example","pos":[10790,10797]},{"content":"The following example shows the basic structure of how to work with the <ph id=\"ph1\">`overwrite_buffer`</ph> class.","pos":[10801,10898],"source":"The following example shows the basic structure of how to work with the `overwrite_buffer` class."},{"content":"This example sends three values to an <ph id=\"ph1\">`overwrite _buffer`</ph> object and then reads the current value from the same object three times.","pos":[10899,11030],"source":" This example sends three values to an `overwrite _buffer` object and then reads the current value from the same object three times."},{"content":"This example is similar to the example for the <ph id=\"ph1\">`unbounded_buffer`</ph> class.","pos":[11031,11103],"source":" This example is similar to the example for the `unbounded_buffer` class."},{"content":"However, the <ph id=\"ph1\">`overwrite_buffer`</ph> class stores just one message.","pos":[11104,11166],"source":" However, the `overwrite_buffer` class stores just one message."},{"content":"In addition, the runtime does not remove the message from an <ph id=\"ph1\">`overwrite_buffer`</ph> object after it is read.","pos":[11167,11271],"source":" In addition, the runtime does not remove the message from an `overwrite_buffer` object after it is read."},{"pos":[11289,11324],"content":"concrt-overwrite_buffer-structure#1"},{"content":"This example produces the following output:","pos":[11406,11449]},{"pos":[11486,11698],"content":"For a complete example that shows how to use the <ph id=\"ph1\">`overwrite_buffer`</ph> class, see <bpt id=\"p1\">[</bpt>How to: Implement Various Producer-Consumer Patterns<ept id=\"p1\">](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md)</ept>.","source":"For a complete example that shows how to use the `overwrite_buffer` class, see [How to: Implement Various Producer-Consumer Patterns](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md)."},{"pos":[11705,11718],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[11761,11784],"content":"single_assignment Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::single_assignment<ept id=\"p1\">](../../parallel/concrt/reference/single-assignment-class.md)</ept> class resembles the <ph id=\"ph1\">`overwrite_buffer`</ph> class, except that a <ph id=\"ph2\">`single_assignment`</ph> object can be written to one time only.","pos":[11788,12004],"source":"The [concurrency::single_assignment](../../parallel/concrt/reference/single-assignment-class.md) class resembles the `overwrite_buffer` class, except that a `single_assignment` object can be written to one time only."},{"content":"Like the <ph id=\"ph1\">`overwrite_buffer`</ph> class, when a target receives a message from a <ph id=\"ph2\">`single_assignment`</ph> object, that message is not removed from that object.","pos":[12005,12153],"source":" Like the `overwrite_buffer` class, when a target receives a message from a `single_assignment` object, that message is not removed from that object."},{"content":"Therefore, multiple targets receive a copy of the message.","pos":[12154,12212]},{"content":"The <ph id=\"ph1\">`single_assignment`</ph> class is useful when you want to broadcast one message to multiple components.","pos":[12213,12315],"source":" The `single_assignment` class is useful when you want to broadcast one message to multiple components."},{"content":"Example","pos":[12325,12332]},{"content":"The following example shows the basic structure of how to work with the <ph id=\"ph1\">`single_assignment`</ph> class.","pos":[12336,12434],"source":"The following example shows the basic structure of how to work with the `single_assignment` class."},{"content":"This example sends three values to a <ph id=\"ph1\">`single_assignment`</ph> object and then reads the current value from the same object three times.","pos":[12435,12565],"source":" This example sends three values to a `single_assignment` object and then reads the current value from the same object three times."},{"content":"This example is similar to the example for the <ph id=\"ph1\">`overwrite_buffer`</ph> class.","pos":[12566,12638],"source":" This example is similar to the example for the `overwrite_buffer` class."},{"content":"Although both the <ph id=\"ph1\">`overwrite_buffer`</ph> and <ph id=\"ph2\">`single_assignment`</ph> classes store a single message, the <ph id=\"ph3\">`single_assignment`</ph> class can be written to one time only.","pos":[12639,12794],"source":" Although both the `overwrite_buffer` and `single_assignment` classes store a single message, the `single_assignment` class can be written to one time only."},{"pos":[12812,12848],"content":"concrt-single_assignment-structure#1"},{"content":"This example produces the following output:","pos":[12930,12973]},{"pos":[13010,13185],"content":"For a complete example that shows how to use the <ph id=\"ph1\">`single_assignment`</ph> class, see <bpt id=\"p1\">[</bpt>Walkthrough: Implementing Futures<ept id=\"p1\">](../../parallel/concrt/walkthrough-implementing-futures.md)</ept>.","source":"For a complete example that shows how to use the `single_assignment` class, see [Walkthrough: Implementing Futures](../../parallel/concrt/walkthrough-implementing-futures.md)."},{"pos":[13192,13205],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[13235,13245],"content":"call Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::call<ept id=\"p1\">](../../parallel/concrt/reference/call-class.md)</ept> class acts as a message receiver that performs a work function when it receives data.","pos":[13249,13405],"source":"The [concurrency::call](../../parallel/concrt/reference/call-class.md) class acts as a message receiver that performs a work function when it receives data."},{"content":"This work function can be a lambda expression, a function object, or a function pointer.","pos":[13406,13494]},{"content":"A <ph id=\"ph1\">`call`</ph> object behaves differently than an ordinary function call because it acts in parallel to other components that send messages to it.","pos":[13495,13635],"source":" A `call` object behaves differently than an ordinary function call because it acts in parallel to other components that send messages to it."},{"content":"If a <ph id=\"ph1\">`call`</ph> object is performing work when it receives a message, it adds that message to a queue.","pos":[13636,13734],"source":" If a `call` object is performing work when it receives a message, it adds that message to a queue."},{"content":"Every <ph id=\"ph1\">`call`</ph> object processes queued messages in the order in which they are received.","pos":[13735,13821],"source":" Every `call` object processes queued messages in the order in which they are received."},{"content":"Example","pos":[13831,13838]},{"content":"The following example shows the basic structure of how to work with the <ph id=\"ph1\">`call`</ph> class.","pos":[13842,13927],"source":"The following example shows the basic structure of how to work with the `call` class."},{"content":"This example creates a <ph id=\"ph1\">`call`</ph> object that prints each value that it receives to the console.","pos":[13928,14020],"source":" This example creates a `call` object that prints each value that it receives to the console."},{"content":"The example then sends three values to the <ph id=\"ph1\">`call`</ph> object.","pos":[14021,14078],"source":" The example then sends three values to the `call` object."},{"content":"Because the <ph id=\"ph1\">`call`</ph> object processes messages on a separate thread, this example also uses a counter variable and an <bpt id=\"p1\">[</bpt>event<ept id=\"p1\">](../../parallel/concrt/reference/event-class.md)</ept> object to ensure that the <ph id=\"ph2\">`call`</ph> object processes all messages before the <ph id=\"ph3\">`wmain`</ph> function returns.","pos":[14079,14350],"source":" Because the `call` object processes messages on a separate thread, this example also uses a counter variable and an [event](../../parallel/concrt/reference/event-class.md) object to ensure that the `call` object processes all messages before the `wmain` function returns."},{"pos":[14368,14391],"content":"concrt-call-structure#1"},{"content":"This example produces the following output:","pos":[14473,14516]},{"pos":[14553,14781],"content":"For a complete example that shows how to use the <ph id=\"ph1\">`call`</ph> class, see <bpt id=\"p1\">[</bpt>How to: Provide Work Functions to the call and transformer Classes<ept id=\"p1\">](../../parallel/concrt/how-to-provide-work-functions-to-the-call-and-transformer-classes.md)</ept>.","source":"For a complete example that shows how to use the `call` class, see [How to: Provide Work Functions to the call and transformer Classes](../../parallel/concrt/how-to-provide-work-functions-to-the-call-and-transformer-classes.md)."},{"pos":[14788,14801],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[14838,14855],"content":"transformer Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::transformer<ept id=\"p1\">](../../parallel/concrt/reference/transformer-class.md)</ept> class acts as both a message receiver and as a message sender.","pos":[14859,15006],"source":"The [concurrency::transformer](../../parallel/concrt/reference/transformer-class.md) class acts as both a message receiver and as a message sender."},{"content":"The <ph id=\"ph1\">`transformer`</ph> class resembles the <ph id=\"ph2\">`call`</ph> class because it performs a user-defined work function when it receives data.","pos":[15007,15129],"source":" The `transformer` class resembles the `call` class because it performs a user-defined work function when it receives data."},{"content":"However, the <ph id=\"ph1\">`transformer`</ph> class also sends the result of the work function to receiver objects.","pos":[15130,15226],"source":" However, the `transformer` class also sends the result of the work function to receiver objects."},{"content":"Like a <ph id=\"ph1\">`call`</ph> object, a <ph id=\"ph2\">`transformer`</ph> object acts in parallel to other components that send messages to it.","pos":[15227,15334],"source":" Like a `call` object, a `transformer` object acts in parallel to other components that send messages to it."},{"content":"If a <ph id=\"ph1\">`transformer`</ph> object is performing work when it receives a message, it adds that message to a queue.","pos":[15335,15440],"source":" If a `transformer` object is performing work when it receives a message, it adds that message to a queue."},{"content":"Every <ph id=\"ph1\">`transformer`</ph> object processes its queued messages in the order in which they are received.","pos":[15441,15538],"source":" Every `transformer` object processes its queued messages in the order in which they are received."},{"content":"The <ph id=\"ph1\">`transformer`</ph> class sends its message to one target.","pos":[15545,15601],"source":"The `transformer` class sends its message to one target."},{"content":"If you set the <ph id=\"ph1\">`_PTarget`</ph> parameter in the constructor to <ph id=\"ph2\">`NULL`</ph>, you can later specify the target by calling the <bpt id=\"p1\">[</bpt>concurrency::link_target<ept id=\"p1\">](reference/source-block-class.md#link_target)</ept> method.","pos":[15602,15795],"source":" If you set the `_PTarget` parameter in the constructor to `NULL`, you can later specify the target by calling the [concurrency::link_target](reference/source-block-class.md#link_target) method."},{"content":"Unlike all other asynchronous message block types that are provided by the Agents Library, the <ph id=\"ph1\">`transformer`</ph> class can act on different input and output types.","pos":[15802,15961],"source":"Unlike all other asynchronous message block types that are provided by the Agents Library, the `transformer` class can act on different input and output types."},{"content":"This ability to transform data from one type to another makes the <ph id=\"ph1\">`transformer`</ph> class a key component in many concurrent networks.","pos":[15962,16092],"source":" This ability to transform data from one type to another makes the `transformer` class a key component in many concurrent networks."},{"content":"In addition, you can add more fine-grained parallel functionality in the work function of a <ph id=\"ph1\">`transformer`</ph> object.","pos":[16093,16206],"source":" In addition, you can add more fine-grained parallel functionality in the work function of a `transformer` object."},{"content":"Example","pos":[16216,16223]},{"content":"The following example shows the basic structure of how to work with the <ph id=\"ph1\">`transformer`</ph> class.","pos":[16227,16319],"source":"The following example shows the basic structure of how to work with the `transformer` class."},{"content":"This example creates a <ph id=\"ph1\">`transformer`</ph> object that multiples each input <ph id=\"ph2\">`int`</ph> value by 0.33 in order to produce a <ph id=\"ph3\">`double`</ph> value as output.","pos":[16320,16457],"source":" This example creates a `transformer` object that multiples each input `int` value by 0.33 in order to produce a `double` value as output."},{"content":"The example then receives the transformed values from the same <ph id=\"ph1\">`transformer`</ph> object and prints them to the console.","pos":[16458,16573],"source":" The example then receives the transformed values from the same `transformer` object and prints them to the console."},{"pos":[16591,16621],"content":"concrt-transformer-structure#1"},{"content":"This example produces the following output:","pos":[16703,16746]},{"pos":[16792,16979],"content":"For a complete example that shows how to use the <ph id=\"ph1\">`transformer`</ph> class, see <bpt id=\"p1\">[</bpt>How to: Use transformer in a Data Pipeline<ept id=\"p1\">](../../parallel/concrt/how-to-use-transformer-in-a-data-pipeline.md)</ept>.","source":"For a complete example that shows how to use the `transformer` class, see [How to: Use transformer in a Data Pipeline](../../parallel/concrt/how-to-use-transformer-in-a-data-pipeline.md)."},{"pos":[16986,16999],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[17031,17043],"content":"choice Class"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::choice<ept id=\"p1\">](../../parallel/concrt/reference/choice-class.md)</ept> class selects the first available message from a set of sources.","pos":[17047,17186],"source":"The [concurrency::choice](../../parallel/concrt/reference/choice-class.md) class selects the first available message from a set of sources."},{"content":"The <ph id=\"ph1\">`choice`</ph> class represents a control-flow mechanism instead of a dataflow mechanism (the topic <bpt id=\"p1\">[</bpt>Asynchronous Agents Library<ept id=\"p1\">](../../parallel/concrt/asynchronous-agents-library.md)</ept> describes the differences between dataflow and control-flow).","pos":[17187,17430],"source":" The `choice` class represents a control-flow mechanism instead of a dataflow mechanism (the topic [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md) describes the differences between dataflow and control-flow)."},{"content":"Reading from a choice object resembles calling the Windows API function <ph id=\"ph1\">`WaitForMultipleObjects`</ph> when it has the <ph id=\"ph2\">`bWaitAll`</ph> parameter set to <ph id=\"ph3\">`FALSE`</ph>.","pos":[17437,17586],"source":"Reading from a choice object resembles calling the Windows API function `WaitForMultipleObjects` when it has the `bWaitAll` parameter set to `FALSE`."},{"content":"However, the <ph id=\"ph1\">`choice`</ph> class binds data to the event itself instead of to an external synchronization object.","pos":[17587,17695],"source":" However, the `choice` class binds data to the event itself instead of to an external synchronization object."},{"content":"Typically, you use the <ph id=\"ph1\">`choice`</ph> class together with the <bpt id=\"p1\">[</bpt>concurrency::receive<ept id=\"p1\">](reference/concurrency-namespace-functions.md#receive)</ept> function to drive control-flow in your application.","pos":[17703,17887],"source":"Typically, you use the `choice` class together with the [concurrency::receive](reference/concurrency-namespace-functions.md#receive) function to drive control-flow in your application."},{"content":"Use the <ph id=\"ph1\">`choice`</ph> class when you have to select among message buffers that have different types.","pos":[17888,17983],"source":" Use the `choice` class when you have to select among message buffers that have different types."},{"content":"Use the <ph id=\"ph1\">`single_assignment`</ph> class when you have to select among message buffers that have the same type.","pos":[17984,18088],"source":" Use the `single_assignment` class when you have to select among message buffers that have the same type."},{"content":"The order in which you link sources to a <ph id=\"ph1\">`choice`</ph> object is important because it can determine which message is selected.","pos":[18096,18217],"source":"The order in which you link sources to a `choice` object is important because it can determine which message is selected."},{"content":"For example, consider the case where you link multiple message buffers that already contain a message to a <ph id=\"ph1\">`choice`</ph> object.","pos":[18218,18341],"source":" For example, consider the case where you link multiple message buffers that already contain a message to a `choice` object."},{"content":"The <ph id=\"ph1\">`choice`</ph> object selects the message from the first source that it is linked to.","pos":[18342,18425],"source":" The `choice` object selects the message from the first source that it is linked to."},{"content":"After you link all sources, the <ph id=\"ph1\">`choice`</ph> object preserves the order in which each source receives a message.","pos":[18426,18534],"source":" After you link all sources, the `choice` object preserves the order in which each source receives a message."},{"content":"Example","pos":[18544,18551]},{"content":"The following example shows the basic structure of how to work with the <ph id=\"ph1\">`choice`</ph> class.","pos":[18556,18643],"source":"The following example shows the basic structure of how to work with the `choice` class."},{"content":"This example uses the <bpt id=\"p1\">[</bpt>concurrency::make_choice<ept id=\"p1\">](reference/concurrency-namespace-functions.md#make_choice)</ept> function to create a <ph id=\"ph1\">`choice`</ph> object that selects among three message blocks.","pos":[18644,18828],"source":" This example uses the [concurrency::make_choice](reference/concurrency-namespace-functions.md#make_choice) function to create a `choice` object that selects among three message blocks."},{"content":"The example then computes various Fibonacci numbers and stores each result in a different message block.","pos":[18829,18933]},{"content":"The example then prints to the console a message that is based on the operation that finished first.","pos":[18934,19034]},{"pos":[19053,19078],"content":"concrt-choice-structure#1"},{"content":"This example produces the following sample output:","pos":[19160,19210]},{"pos":[19289,19428],"content":"Because the task that computes the 35<ph id=\"ph1\">&lt;sup&gt;</ph>th<ph id=\"ph2\">&lt;/sup&gt;</ph> Fibonacci number is not guaranteed to finish first, the output of this example can vary.","source":"Because the task that computes the 35<sup>th</sup> Fibonacci number is not guaranteed to finish first, the output of this example can vary."},{"content":"This example uses the <bpt id=\"p1\">[</bpt>concurrency::parallel_invoke<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_invoke)</ept> algorithm to compute the Fibonacci numbers in parallel.","pos":[19436,19606],"source":"This example uses the [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) algorithm to compute the Fibonacci numbers in parallel."},{"content":"For more information about <ph id=\"ph1\">`parallel_invoke`</ph>, see <bpt id=\"p1\">[</bpt>Parallel Algorithms<ept id=\"p1\">](../../parallel/concrt/parallel-algorithms.md)</ept>.","pos":[19607,19725],"source":" For more information about `parallel_invoke`, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)."},{"pos":[19732,19902],"content":"For a complete example that shows how to use the <ph id=\"ph1\">`choice`</ph> class, see <bpt id=\"p1\">[</bpt>How to: Select Among Completed Tasks<ept id=\"p1\">](../../parallel/concrt/how-to-select-among-completed-tasks.md)</ept>.","source":"For a complete example that shows how to use the `choice` class, see [How to: Select Among Completed Tasks](../../parallel/concrt/how-to-select-among-completed-tasks.md)."},{"pos":[19909,19922],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[19952,19983],"content":"join and multitype_join Classes"},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::join<ept id=\"p1\">](../../parallel/concrt/reference/join-class.md)</ept> and <bpt id=\"p2\">[</bpt>concurrency::multitype_join<ept id=\"p2\">](../../parallel/concrt/reference/multitype-join-class.md)</ept> classes let you wait for each member of a set of sources to receive a message.","pos":[19987,20227],"source":"The [concurrency::join](../../parallel/concrt/reference/join-class.md) and [concurrency::multitype_join](../../parallel/concrt/reference/multitype-join-class.md) classes let you wait for each member of a set of sources to receive a message."},{"content":"The <ph id=\"ph1\">`join`</ph> class acts on source objects that have a common message type.","pos":[20228,20300],"source":" The `join` class acts on source objects that have a common message type."},{"content":"The <ph id=\"ph1\">`multitype_join`</ph> class acts on source objects that can have different message types.","pos":[20301,20389],"source":" The `multitype_join` class acts on source objects that can have different message types."},{"content":"Reading from a <ph id=\"ph1\">`join`</ph> or <ph id=\"ph2\">`multitype_join`</ph> object resembles calling the Windows API function <ph id=\"ph3\">`WaitForMultipleObjects`</ph> when it has the <ph id=\"ph4\">`bWaitAll`</ph> parameter set to <ph id=\"ph5\">`TRUE`</ph>.","pos":[20396,20564],"source":"Reading from a `join` or `multitype_join` object resembles calling the Windows API function `WaitForMultipleObjects` when it has the `bWaitAll` parameter set to `TRUE`."},{"content":"However, just like a <ph id=\"ph1\">`choice`</ph> object, <ph id=\"ph2\">`join`</ph> and <ph id=\"ph3\">`multitype_join`</ph> objects use an event mechanism that binds data to the event itself instead of to an external synchronization object.","pos":[20565,20747],"source":" However, just like a `choice` object, `join` and `multitype_join` objects use an event mechanism that binds data to the event itself instead of to an external synchronization object."},{"content":"Reading from a <ph id=\"ph1\">`join`</ph> object produces a std::<bpt id=\"p1\">[</bpt>vector<ept id=\"p1\">](../../standard-library/vector-class.md)</ept> object.","pos":[20754,20855],"source":"Reading from a `join` object produces a std::[vector](../../standard-library/vector-class.md) object."},{"content":"Reading from a <ph id=\"ph1\">`multitype_join`</ph> object produces a std::<bpt id=\"p1\">[</bpt>tuple<ept id=\"p1\">](../../standard-library/tuple-class.md)</ept> object.","pos":[20856,20965],"source":" Reading from a `multitype_join` object produces a std::[tuple](../../standard-library/tuple-class.md) object."},{"content":"Elements appear in these objects in the same order as their corresponding source buffers are linked to the <ph id=\"ph1\">`join`</ph> or <ph id=\"ph2\">`multitype_join`</ph> object.","pos":[20966,21107],"source":" Elements appear in these objects in the same order as their corresponding source buffers are linked to the `join` or `multitype_join` object."},{"content":"Because the order in which you link source buffers to a <ph id=\"ph1\">`join`</ph> or <ph id=\"ph2\">`multitype_join`</ph> object is associated with the order of elements in the resulting <ph id=\"ph3\">`vector`</ph> or <ph id=\"ph4\">`tuple`</ph> object, we recommend that you do not unlink an existing source buffer from a join.","pos":[21108,21358],"source":" Because the order in which you link source buffers to a `join` or `multitype_join` object is associated with the order of elements in the resulting `vector` or `tuple` object, we recommend that you do not unlink an existing source buffer from a join."},{"content":"Doing so can result in unspecified behavior.","pos":[21359,21403]},{"content":"Greedy Versus Non-Greedy Joins","pos":[21413,21443]},{"content":"The <ph id=\"ph1\">`join`</ph> and <ph id=\"ph2\">`multitype_join`</ph> classes support the concept of greedy and non-greedy joins.","pos":[21447,21538],"source":"The `join` and `multitype_join` classes support the concept of greedy and non-greedy joins."},{"content":"A <bpt id=\"p1\">*</bpt>greedy join<ept id=\"p1\">*</ept> accepts a message from each of its sources as messages become available until all message are available.","pos":[21539,21659],"source":" A *greedy join* accepts a message from each of its sources as messages become available until all message are available."},{"content":"A <bpt id=\"p1\">*</bpt>non-greedy join<ept id=\"p1\">*</ept> receives messages in two phases.","pos":[21660,21712],"source":" A *non-greedy join* receives messages in two phases."},{"content":"First, a non-greedy join waits until it is offered a message from each of its sources.","pos":[21713,21799]},{"content":"Second, after all source messages are available, a non-greedy join attempts to reserve each of those messages.","pos":[21800,21910]},{"content":"If it can reserve each message, it consumes all messages and propagates them to its target.","pos":[21911,22002]},{"content":"Otherwise, it releases, or cancels, the message reservations and again waits for each source to receive a message.","pos":[22003,22117]},{"content":"Greedy joins perform better than non-greedy joins because they accept messages immediately.","pos":[22124,22215]},{"content":"However, in rare cases, greedy joins can lead to deadlocks.","pos":[22216,22275]},{"content":"Use a non-greedy join when you have multiple joins that contain one or more shared source objects.","pos":[22276,22374]},{"content":"Example","pos":[22384,22391]},{"content":"The following example shows the basic structure of how to work with the <ph id=\"ph1\">`join`</ph> class.","pos":[22396,22481],"source":"The following example shows the basic structure of how to work with the `join` class."},{"content":"This example uses the <bpt id=\"p1\">[</bpt>concurrency::make_join<ept id=\"p1\">](reference/concurrency-namespace-functions.md#make_join)</ept> function to create a <ph id=\"ph1\">`join`</ph> object that receives from three <ph id=\"ph2\">`single_assignment`</ph> objects.","pos":[22482,22673],"source":" This example uses the [concurrency::make_join](reference/concurrency-namespace-functions.md#make_join) function to create a `join` object that receives from three `single_assignment` objects."},{"content":"This example computes various Fibonacci numbers, stores each result in a different <ph id=\"ph1\">`single_assignment`</ph> object, and then prints to the console each result that the <ph id=\"ph2\">`join`</ph> object holds.","pos":[22674,22857],"source":" This example computes various Fibonacci numbers, stores each result in a different `single_assignment` object, and then prints to the console each result that the `join` object holds."},{"content":"This example is similar to the example for the <ph id=\"ph1\">`choice`</ph> class, except that the <ph id=\"ph2\">`join`</ph> class waits for all source message blocks to receive a message.","pos":[22858,23007],"source":" This example is similar to the example for the `choice` class, except that the `join` class waits for all source message blocks to receive a message."},{"pos":[23025,23048],"content":"concrt-join-structure#1"},{"content":"This example produces the following output:","pos":[23130,23173]},{"content":"This example uses the <bpt id=\"p1\">[</bpt>concurrency::parallel_invoke<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_invoke)</ept> algorithm to compute the Fibonacci numbers in parallel.","pos":[23261,23431],"source":"This example uses the [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) algorithm to compute the Fibonacci numbers in parallel."},{"content":"For more information about <ph id=\"ph1\">`parallel_invoke`</ph>, see <bpt id=\"p1\">[</bpt>Parallel Algorithms<ept id=\"p1\">](../../parallel/concrt/parallel-algorithms.md)</ept>.","pos":[23432,23550],"source":" For more information about `parallel_invoke`, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)."},{"pos":[23557,23842],"content":"For complete examples that show how to use the <ph id=\"ph1\">`join`</ph> class, see <bpt id=\"p1\">[</bpt>How to: Select Among Completed Tasks<ept id=\"p1\">](../../parallel/concrt/how-to-select-among-completed-tasks.md)</ept> and <bpt id=\"p2\">[</bpt>Walkthrough: Using join to Prevent Deadlock<ept id=\"p2\">](../../parallel/concrt/walkthrough-using-join-to-prevent-deadlock.md)</ept>.","source":"For complete examples that show how to use the `join` class, see [How to: Select Among Completed Tasks](../../parallel/concrt/how-to-select-among-completed-tasks.md) and [Walkthrough: Using join to Prevent Deadlock](../../parallel/concrt/walkthrough-using-join-to-prevent-deadlock.md)."},{"pos":[23849,23862],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[23893,23904],"content":"timer Class"},{"content":"The concurrency::<bpt id=\"p1\">[</bpt>timer class<ept id=\"p1\">](../../parallel/concrt/reference/timer-class.md)</ept> acts as a message source.","pos":[23908,24012],"source":"The concurrency::[timer class](../../parallel/concrt/reference/timer-class.md) acts as a message source."},{"content":"A <ph id=\"ph1\">`timer`</ph> object sends a message to a target after a specified period of time has elapsed.","pos":[24013,24103],"source":" A `timer` object sends a message to a target after a specified period of time has elapsed."},{"content":"The <ph id=\"ph1\">`timer`</ph> class is useful when you must delay sending a message or you want to send a message at a regular interval.","pos":[24104,24222],"source":" The `timer` class is useful when you must delay sending a message or you want to send a message at a regular interval."},{"content":"The <ph id=\"ph1\">`timer`</ph> class sends its message to just one target.","pos":[24230,24285],"source":"The `timer` class sends its message to just one target."},{"content":"If you set the <ph id=\"ph1\">`_PTarget`</ph> parameter in the constructor to <ph id=\"ph2\">`NULL`</ph>, you can later specify the target by calling the <bpt id=\"p1\">[</bpt>concurrency::ISource::link_target<ept id=\"p1\">](reference/source-block-class.md#link_target)</ept> method.","pos":[24286,24488],"source":" If you set the `_PTarget` parameter in the constructor to `NULL`, you can later specify the target by calling the [concurrency::ISource::link_target](reference/source-block-class.md#link_target) method."},{"content":"A <ph id=\"ph1\">`timer`</ph> object can be repeating or non-repeating.","pos":[24496,24547],"source":"A `timer` object can be repeating or non-repeating."},{"content":"To create a repeating timer, pass <ph id=\"ph1\">`true`</ph> for the <ph id=\"ph2\">`_Repeating`</ph> parameter when you call the constructor.","pos":[24548,24650],"source":" To create a repeating timer, pass `true` for the `_Repeating` parameter when you call the constructor."},{"content":"Otherwise, pass <ph id=\"ph1\">`false`</ph> for the <ph id=\"ph2\">`_Repeating`</ph> parameter to create a non-repeating timer.","pos":[24651,24738],"source":" Otherwise, pass `false` for the `_Repeating` parameter to create a non-repeating timer."},{"content":"If the timer is repeating, it sends the same message to its target after each interval.","pos":[24739,24826]},{"content":"The Agents Library creates <ph id=\"ph1\">`timer`</ph> objects in the non-started state.","pos":[24833,24901],"source":"The Agents Library creates `timer` objects in the non-started state."},{"content":"To start a timer object, call the <bpt id=\"p1\">[</bpt>concurrency::timer::start<ept id=\"p1\">](reference/timer-class.md#start)</ept> method.","pos":[24902,25003],"source":" To start a timer object, call the [concurrency::timer::start](reference/timer-class.md#start) method."},{"content":"To stop a <ph id=\"ph1\">`timer`</ph> object, destroy the object or call the <bpt id=\"p1\">[</bpt>concurrency::timer::stop<ept id=\"p1\">](reference/timer-class.md#stop)</ept> method.","pos":[25004,25126],"source":" To stop a `timer` object, destroy the object or call the [concurrency::timer::stop](reference/timer-class.md#stop) method."},{"content":"To pause a repeating timer, call the <bpt id=\"p1\">[</bpt>concurrency::timer::pause<ept id=\"p1\">](reference/timer-class.md#pause)</ept> method.","pos":[25127,25231],"source":" To pause a repeating timer, call the [concurrency::timer::pause](reference/timer-class.md#pause) method."},{"content":"Example","pos":[25241,25248]},{"content":"The following example shows the basic structure of how to work with the <ph id=\"ph1\">`timer`</ph> class.","pos":[25252,25338],"source":"The following example shows the basic structure of how to work with the `timer` class."},{"content":"The example uses <ph id=\"ph1\">`timer`</ph> and <ph id=\"ph2\">`call`</ph> objects to report the progress of a lengthy operation.","pos":[25339,25429],"source":" The example uses `timer` and `call` objects to report the progress of a lengthy operation."},{"pos":[25447,25471],"content":"concrt-timer-structure#1"},{"content":"This example produces the following sample output:","pos":[25553,25603]},{"pos":[25720,25905],"content":"For a complete example that shows how to use the <ph id=\"ph1\">`timer`</ph> class, see <bpt id=\"p1\">[</bpt>How to: Send a Message at a Regular Interval<ept id=\"p1\">](../../parallel/concrt/how-to-send-a-message-at-a-regular-interval.md)</ept>.","source":"For a complete example that shows how to use the `timer` class, see [How to: Send a Message at a Regular Interval](../../parallel/concrt/how-to-send-a-message-at-a-regular-interval.md)."},{"pos":[25912,25925],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[25960,25977],"content":"Message Filtering"},{"content":"When you create a message block object, you can supply a <bpt id=\"p1\">*</bpt>filter function<ept id=\"p1\">*</ept> that determines whether the message block accepts or rejects a message.","pos":[25981,26127],"source":"When you create a message block object, you can supply a *filter function* that determines whether the message block accepts or rejects a message."},{"content":"A filter function is a useful way to guarantee that a message block receives only certain values.","pos":[26128,26225]},{"content":"The following example shows how to create an <ph id=\"ph1\">`unbounded_buffer`</ph> object that uses a filter function to accept only even numbers.","pos":[26232,26359],"source":"The following example shows how to create an `unbounded_buffer` object that uses a filter function to accept only even numbers."},{"content":"The <ph id=\"ph1\">`unbounded_buffer`</ph> object rejects odd numbers, and therefore does not propagate odd numbers to its target blocks.","pos":[26360,26477],"source":" The `unbounded_buffer` object rejects odd numbers, and therefore does not propagate odd numbers to its target blocks."},{"pos":[26495,26519],"content":"concrt-filter-function#1"},{"content":"This example produces the following output:","pos":[26601,26644]},{"content":"A filter function can be a lambda function, a function pointer, or a function object.","pos":[26684,26769]},{"content":"Every filter function takes one of the following forms.","pos":[26770,26825]},{"content":"To eliminate the unnecessary copying of data, use the second form when you have an aggregate type that is propagated by value.","pos":[26883,27009]},{"content":"Message filtering supports the <bpt id=\"p1\">*</bpt>dataflow<ept id=\"p1\">*</ept> programming model, in which components perform computations when they receive data.","pos":[27016,27141],"source":"Message filtering supports the *dataflow* programming model, in which components perform computations when they receive data."},{"content":"For examples that use filter functions to control the flow of data in a message passing network, see <bpt id=\"p1\">[</bpt>How to: Use a Message Block Filter<ept id=\"p1\">](../../parallel/concrt/how-to-use-a-message-block-filter.md)</ept>, <bpt id=\"p2\">[</bpt>Walkthrough: Creating a Dataflow Agent<ept id=\"p2\">](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md)</ept>, and <bpt id=\"p3\">[</bpt>Walkthrough: Creating an Image-Processing Network<ept id=\"p3\">](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)</ept>.","pos":[27142,27578],"source":" For examples that use filter functions to control the flow of data in a message passing network, see [How to: Use a Message Block Filter](../../parallel/concrt/how-to-use-a-message-block-filter.md), [Walkthrough: Creating a Dataflow Agent](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md), and [Walkthrough: Creating an Image-Processing Network](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)."},{"pos":[27585,27598],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[27635,27654],"content":"Message Reservation"},{"content":"<bpt id=\"p1\">*</bpt>Message reservation<ept id=\"p1\">*</ept> enables a message block to reserve a message for later use.","pos":[27658,27739],"source":"*Message reservation* enables a message block to reserve a message for later use."},{"content":"Typically, message reservation is not used directly.","pos":[27740,27792]},{"content":"However, understanding message reservation can help you better understand the behavior of some of the predefined message block types.","pos":[27793,27926]},{"content":"Consider non-greedy and greedy joins.","pos":[27933,27970]},{"content":"Both of these use message reservation to reserve messages for later use.","pos":[27971,28043]},{"content":"A described earlier, a non-greedy join receives messages in two phases.","pos":[28044,28115]},{"content":"During the first phase, a non-greedy <ph id=\"ph1\">`join`</ph> object waits for each of its sources to receive a message.","pos":[28116,28218],"source":" During the first phase, a non-greedy `join` object waits for each of its sources to receive a message."},{"content":"A non-greedy join then attempts to reserve each of those messages.","pos":[28219,28285]},{"content":"If it can reserve each message, it consumes all messages and propagates them to its target.","pos":[28286,28377]},{"content":"Otherwise, it releases, or cancels, the message reservations and again waits for each source to receive a message.","pos":[28378,28492]},{"content":"A greedy join, which also reads input messages from a number of sources, uses message reservation to read additional messages while it waits to receive a message from each source.","pos":[28499,28678]},{"content":"For example, consider a greedy join that receives messages from message blocks <ph id=\"ph1\">`A`</ph> and <ph id=\"ph2\">`B`</ph>.","pos":[28679,28770],"source":" For example, consider a greedy join that receives messages from message blocks `A` and `B`."},{"content":"If the greedy join receives two messages from B but has not yet received a message from <ph id=\"ph1\">`A`</ph>, the greedy join saves the unique message identifier for the second message from <ph id=\"ph2\">`B`</ph>.","pos":[28771,28948],"source":" If the greedy join receives two messages from B but has not yet received a message from `A`, the greedy join saves the unique message identifier for the second message from `B`."},{"content":"After the greedy join receives a message from <ph id=\"ph1\">`A`</ph> and propagates out these messages, it uses the saved message identifier to see if the second message from <ph id=\"ph2\">`B`</ph> is still available.","pos":[28949,29128],"source":" After the greedy join receives a message from `A` and propagates out these messages, it uses the saved message identifier to see if the second message from `B` is still available."},{"content":"You can use message reservation when you implement your own custom message block types.","pos":[29135,29222]},{"content":"For an example about how to create a custom message block type, see <bpt id=\"p1\">[</bpt>Walkthrough: Creating a Custom Message Block<ept id=\"p1\">](../../parallel/concrt/walkthrough-creating-a-custom-message-block.md)</ept>.","pos":[29223,29408],"source":" For an example about how to create a custom message block type, see [Walkthrough: Creating a Custom Message Block](../../parallel/concrt/walkthrough-creating-a-custom-message-block.md)."},{"pos":[29415,29428],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"content":"See Also","pos":[29437,29445]},{"content":"Asynchronous Agents Library","pos":[29450,29477]}],"content":"---\ntitle: \"Asynchronous Message Blocks | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"non-greedy join [Concurrency Runtime]\"\n  - \"asynchronous message blocks\"\n  - \"greedy join [Concurrency Runtime]\"\nms.assetid: 79c456c0-1692-480c-bb67-98f2434c1252\ncaps.latest.revision: 36\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Asynchronous Message Blocks\n\nThe Agents Library provides several message-block types that enable you to propagate messages among application components in a thread-safe manner. These message-block types are often used with the various message-passing routines, such as [concurrency::send](reference/concurrency-namespace-functions.md#send), [concurrency::asend](reference/concurrency-namespace-functions.md#asend), [concurrency::receive](reference/concurrency-namespace-functions.md#receive), and [concurrency::try_receive](reference/concurrency-namespace-functions.md#try_receive). For more information about the message passing routines that are defined by the Agents Library, see [Message Passing Functions](../../parallel/concrt/message-passing-functions.md).  \n  \n##  <a name=\"top\"></a> Sections  \n This topic contains the following sections:  \n  \n- [Sources and Targets](#sources_and_targets)  \n  \n- [Message Propagation](#propagation)  \n  \n- [Overview of Message Block Types](#overview)  \n  \n- [unbounded_buffer Class](#unbounded_buffer)  \n  \n- [overwrite_buffer Class](#overwrite_buffer)  \n  \n- [single_assignment Class](#single_assignment)  \n  \n- [call Class](#call)  \n  \n- [transformer Class](#transformer)  \n  \n- [choice Class](#choice)  \n  \n- [join and multitype_join Classes](#join)  \n  \n- [timer Class](#timer)  \n  \n- [Message Filtering](#filtering)  \n  \n- [Message Reservation](#reservation)  \n  \n##  <a name=\"sources_and_targets\"></a> Sources and Targets  \n Sources and targets are two important participants in message passing. A *source* refers to an endpoint of communication that sends messages. A *target* refers to an endpoint of communication that receives messages. You can think of a source as an endpoint that you read from and a target as an endpoint that you write to. Applications connect sources and targets together to form *messaging networks*.  \n  \n The Agents Library uses two abstract classes to represent sources and targets: [concurrency::ISource](../../parallel/concrt/reference/isource-class.md) and [concurrency::ITarget](../../parallel/concrt/reference/itarget-class.md). Message block types that act as sources derive from `ISource`; message block types that act as targets derive from `ITarget`. Message block types that act as sources and targets derive from both `ISource` and `ITarget`.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"propagation\"></a> Message Propagation  \n *Message propagation* is the act of sending a message from one component to another. When a message block is offered a message, it can accept, decline, or postpone that message. Every message block type stores and transmits messages in different ways. For example, the `unbounded_buffer` class stores an unlimited number of messages, the `overwrite_buffer` class stores a single message at a time, and the transformer class stores an altered version of each message. These message block types are described in more detail later in this document.  \n  \n When a message block accepts a message, it can optionally perform work and, if the message block is a source, pass the resulting message to another member of the network. A message block can use a filter function to decline messages that it does not want to receive. Filters are described in more detail later in this topic, in the section [Message Filtering](#filtering). A message block that postpones a message can reserve that message and consume it later. Message reservation is described in more detail later in this topic, in the section [Message Reservation](#reservation).  \n  \n The Agents Library enables message blocks to asynchronously or synchronously pass messages. When you pass a message to a message block synchronously, for example, by using the `send` function, the runtime blocks the current context until the target block either accepts or rejects the message. When you pass a message to a message block asynchronously, for example, by using the `asend` function, the runtime offers the message to the target, and if the target accepts the message, the runtime schedules an asynchronous task that propagates the message to the receiver. The runtime uses lightweight tasks to propagate messages in a cooperative manner. For more information about lightweight tasks, see [Task Scheduler](../../parallel/concrt/task-scheduler-concurrency-runtime.md).  \n  \n\n Applications connect sources and targets together to form messaging networks. Typically, you link the network and call `send` or `asend` to pass data to the network. To connect a source message block to a target, call the [concurrency::ISource::link_target](reference/isource-class.md#link_target) method. To disconnect a source block from a target, call the [concurrency::ISource::unlink_target](reference/isource-class.md#unlink_target) method. To disconnect a source block from all of its targets, call the [concurrency::ISource::unlink_targets](reference/isource-class.md#unlink_targets) method. When one of the predefined message block types leaves scope or is destroyed, it automatically disconnects itself from any target blocks. Some message block types restrict the maximum number of targets that they can write to. The following section describes the restrictions that apply to the predefined message block types.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"overview\"></a> Overview of Message Block Types  \n The following table briefly describes the role of the important message-block types.  \n  \n [unbounded_buffer](#unbounded_buffer)  \n Stores a queue of messages.  \n  \n [overwrite_buffer](#overwrite_buffer)  \n Stores one message that can be written to and read from multiple times.  \n  \n [single_assignment](#single_assignment)  \n Stores one message that can be written to one time and read from multiple times.  \n  \n [call](#call)  \n Performs work when it receives a message.  \n  \n [transformer](#transformer)  \n Performs work when it receives data and sends the result of that work to another target block. The `transformer` class can act on different input and output types.  \n  \n [choice](#choice)  \n Selects the first available message from a set of sources.  \n  \n [join and multitype join](#join)  \n Wait for all messages to be received from a set of sources and then combine the messages into one message for another message block.  \n  \n [timer](#timer)  \n Sends a message to a target block on a regular interval.  \n  \n These message-block types have different characteristics that make them useful for different situations. These are some of the characteristics:  \n  \n- *Propagation type*: Whether the message block acts as a source of data, a receiver of data, or both.  \n  \n- *Message ordering*: Whether the message block maintains the original order in which messages are sent or received. Each predefined message block type maintains the original order in which it sends or receives messages.  \n  \n- *Source count*: The maximum number of sources that the message block can read from.  \n  \n- *Target count*: The maximum number of targets that the message block can write to.  \n  \n The following table shows how these characteristics relate to the various message-block types.  \n  \n|Message block type|Propagation type (Source, Target, or Both)|Message ordering (Ordered or Unordered)|Source count|Target count|  \n|------------------------|--------------------------------------------------|-----------------------------------------------|------------------|------------------|  \n|`unbounded_buffer`|Both|Ordered|Unbounded|Unbounded|  \n|`overwrite_buffer`|Both|Ordered|Unbounded|Unbounded|  \n|`single_assignment`|Both|Ordered|Unbounded|Unbounded|  \n|`call`|Target|Ordered|Unbounded|Not Applicable|  \n|`transformer`|Both|Ordered|Unbounded|1|  \n|`choice`|Both|Ordered|10|1|  \n|`join`|Both|Ordered|Unbounded|1|  \n|`multitype_join`|Both|Ordered|10|1|  \n|`timer`|Source|Not Applicable|Not Applicable|1|  \n  \n The following sections describe the message-block types in more detail.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"unbounded_buffer\"></a> unbounded_buffer Class  \n The [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) class represents a general-purpose asynchronous messaging structure. This class stores a first in, first out (FIFO) queue of messages that can be written to by multiple sources or read from by multiple targets. When a target receives a message from an `unbounded_buffer` object, that message is removed from the message queue. Therefore, although an `unbounded_buffer` object can have multiple targets, only one target will receive each message. The `unbounded_buffer` class is useful when you want to pass multiple messages to another component, and that component must receive each message.  \n  \n### Example  \n The following example shows the basic structure of how to work with the `unbounded_buffer` class. This example sends three values to an `unbounded_buffer` object and then reads those values back from the same object.  \n  \n [!code-cpp[concrt-unbounded_buffer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_1.cpp)]  \n  \n This example produces the following output:  \n  \n```Output  \n334455  \n```  \n  \n For a complete example that shows how to use the `unbounded_buffer` class, see [How to: Implement Various Producer-Consumer Patterns](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"overwrite_buffer\"></a> overwrite_buffer Class  \n The [concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) class resembles the `unbounded_buffer` class, except that an `overwrite_buffer` object stores just one message. In addition, when a target receives a message from an `overwrite_buffer` object, that message is not removed from the buffer. Therefore, multiple targets receive a copy of the message.  \n  \n The `overwrite_buffer` class is useful when you want to pass multiple messages to another component, but that component needs only the most recent value. This class is also useful when you want to broadcast a message to multiple components.  \n  \n### Example  \n The following example shows the basic structure of how to work with the `overwrite_buffer` class. This example sends three values to an `overwrite _buffer` object and then reads the current value from the same object three times. This example is similar to the example for the `unbounded_buffer` class. However, the `overwrite_buffer` class stores just one message. In addition, the runtime does not remove the message from an `overwrite_buffer` object after it is read.  \n  \n [!code-cpp[concrt-overwrite_buffer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_2.cpp)]  \n  \n This example produces the following output:  \n  \n```Output  \n555555  \n```  \n  \n For a complete example that shows how to use the `overwrite_buffer` class, see [How to: Implement Various Producer-Consumer Patterns](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"single_assignment\"></a> single_assignment Class  \n The [concurrency::single_assignment](../../parallel/concrt/reference/single-assignment-class.md) class resembles the `overwrite_buffer` class, except that a `single_assignment` object can be written to one time only. Like the `overwrite_buffer` class, when a target receives a message from a `single_assignment` object, that message is not removed from that object. Therefore, multiple targets receive a copy of the message. The `single_assignment` class is useful when you want to broadcast one message to multiple components.  \n  \n### Example  \n The following example shows the basic structure of how to work with the `single_assignment` class. This example sends three values to a `single_assignment` object and then reads the current value from the same object three times. This example is similar to the example for the `overwrite_buffer` class. Although both the `overwrite_buffer` and `single_assignment` classes store a single message, the `single_assignment` class can be written to one time only.  \n  \n [!code-cpp[concrt-single_assignment-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_3.cpp)]  \n  \n This example produces the following output:  \n  \n```Output  \n333333  \n```  \n  \n For a complete example that shows how to use the `single_assignment` class, see [Walkthrough: Implementing Futures](../../parallel/concrt/walkthrough-implementing-futures.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"call\"></a> call Class  \n The [concurrency::call](../../parallel/concrt/reference/call-class.md) class acts as a message receiver that performs a work function when it receives data. This work function can be a lambda expression, a function object, or a function pointer. A `call` object behaves differently than an ordinary function call because it acts in parallel to other components that send messages to it. If a `call` object is performing work when it receives a message, it adds that message to a queue. Every `call` object processes queued messages in the order in which they are received.  \n  \n### Example  \n The following example shows the basic structure of how to work with the `call` class. This example creates a `call` object that prints each value that it receives to the console. The example then sends three values to the `call` object. Because the `call` object processes messages on a separate thread, this example also uses a counter variable and an [event](../../parallel/concrt/reference/event-class.md) object to ensure that the `call` object processes all messages before the `wmain` function returns.  \n  \n [!code-cpp[concrt-call-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_4.cpp)]  \n  \n This example produces the following output:  \n  \n```Output  \n334455  \n```  \n  \n For a complete example that shows how to use the `call` class, see [How to: Provide Work Functions to the call and transformer Classes](../../parallel/concrt/how-to-provide-work-functions-to-the-call-and-transformer-classes.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"transformer\"></a> transformer Class  \n The [concurrency::transformer](../../parallel/concrt/reference/transformer-class.md) class acts as both a message receiver and as a message sender. The `transformer` class resembles the `call` class because it performs a user-defined work function when it receives data. However, the `transformer` class also sends the result of the work function to receiver objects. Like a `call` object, a `transformer` object acts in parallel to other components that send messages to it. If a `transformer` object is performing work when it receives a message, it adds that message to a queue. Every `transformer` object processes its queued messages in the order in which they are received.  \n  \n The `transformer` class sends its message to one target. If you set the `_PTarget` parameter in the constructor to `NULL`, you can later specify the target by calling the [concurrency::link_target](reference/source-block-class.md#link_target) method.  \n  \n Unlike all other asynchronous message block types that are provided by the Agents Library, the `transformer` class can act on different input and output types. This ability to transform data from one type to another makes the `transformer` class a key component in many concurrent networks. In addition, you can add more fine-grained parallel functionality in the work function of a `transformer` object.  \n  \n### Example  \n The following example shows the basic structure of how to work with the `transformer` class. This example creates a `transformer` object that multiples each input `int` value by 0.33 in order to produce a `double` value as output. The example then receives the transformed values from the same `transformer` object and prints them to the console.  \n  \n [!code-cpp[concrt-transformer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_5.cpp)]  \n  \n This example produces the following output:  \n  \n```Output  \n10.8914.5218.15  \n```  \n  \n For a complete example that shows how to use the `transformer` class, see [How to: Use transformer in a Data Pipeline](../../parallel/concrt/how-to-use-transformer-in-a-data-pipeline.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"choice\"></a> choice Class  \n The [concurrency::choice](../../parallel/concrt/reference/choice-class.md) class selects the first available message from a set of sources. The `choice` class represents a control-flow mechanism instead of a dataflow mechanism (the topic [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md) describes the differences between dataflow and control-flow).  \n  \n Reading from a choice object resembles calling the Windows API function `WaitForMultipleObjects` when it has the `bWaitAll` parameter set to `FALSE`. However, the `choice` class binds data to the event itself instead of to an external synchronization object.  \n  \n\n Typically, you use the `choice` class together with the [concurrency::receive](reference/concurrency-namespace-functions.md#receive) function to drive control-flow in your application. Use the `choice` class when you have to select among message buffers that have different types. Use the `single_assignment` class when you have to select among message buffers that have the same type.  \n\n  \n The order in which you link sources to a `choice` object is important because it can determine which message is selected. For example, consider the case where you link multiple message buffers that already contain a message to a `choice` object. The `choice` object selects the message from the first source that it is linked to. After you link all sources, the `choice` object preserves the order in which each source receives a message.  \n  \n### Example  \n\n The following example shows the basic structure of how to work with the `choice` class. This example uses the [concurrency::make_choice](reference/concurrency-namespace-functions.md#make_choice) function to create a `choice` object that selects among three message blocks. The example then computes various Fibonacci numbers and stores each result in a different message block. The example then prints to the console a message that is based on the operation that finished first.  \n\n  \n [!code-cpp[concrt-choice-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_6.cpp)]  \n  \n This example produces the following sample output:  \n  \n```Output  \nfib35 received its value first. Result = 9227465  \n```  \n  \n Because the task that computes the 35<sup>th</sup> Fibonacci number is not guaranteed to finish first, the output of this example can vary.  \n  \n\n This example uses the [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) algorithm to compute the Fibonacci numbers in parallel. For more information about `parallel_invoke`, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md).  \n  \n For a complete example that shows how to use the `choice` class, see [How to: Select Among Completed Tasks](../../parallel/concrt/how-to-select-among-completed-tasks.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"join\"></a> join and multitype_join Classes  \n The [concurrency::join](../../parallel/concrt/reference/join-class.md) and [concurrency::multitype_join](../../parallel/concrt/reference/multitype-join-class.md) classes let you wait for each member of a set of sources to receive a message. The `join` class acts on source objects that have a common message type. The `multitype_join` class acts on source objects that can have different message types.  \n  \n Reading from a `join` or `multitype_join` object resembles calling the Windows API function `WaitForMultipleObjects` when it has the `bWaitAll` parameter set to `TRUE`. However, just like a `choice` object, `join` and `multitype_join` objects use an event mechanism that binds data to the event itself instead of to an external synchronization object.  \n  \n Reading from a `join` object produces a std::[vector](../../standard-library/vector-class.md) object. Reading from a `multitype_join` object produces a std::[tuple](../../standard-library/tuple-class.md) object. Elements appear in these objects in the same order as their corresponding source buffers are linked to the `join` or `multitype_join` object. Because the order in which you link source buffers to a `join` or `multitype_join` object is associated with the order of elements in the resulting `vector` or `tuple` object, we recommend that you do not unlink an existing source buffer from a join. Doing so can result in unspecified behavior.  \n  \n### Greedy Versus Non-Greedy Joins  \n The `join` and `multitype_join` classes support the concept of greedy and non-greedy joins. A *greedy join* accepts a message from each of its sources as messages become available until all message are available. A *non-greedy join* receives messages in two phases. First, a non-greedy join waits until it is offered a message from each of its sources. Second, after all source messages are available, a non-greedy join attempts to reserve each of those messages. If it can reserve each message, it consumes all messages and propagates them to its target. Otherwise, it releases, or cancels, the message reservations and again waits for each source to receive a message.  \n  \n Greedy joins perform better than non-greedy joins because they accept messages immediately. However, in rare cases, greedy joins can lead to deadlocks. Use a non-greedy join when you have multiple joins that contain one or more shared source objects.  \n  \n### Example  \n\n The following example shows the basic structure of how to work with the `join` class. This example uses the [concurrency::make_join](reference/concurrency-namespace-functions.md#make_join) function to create a `join` object that receives from three `single_assignment` objects. This example computes various Fibonacci numbers, stores each result in a different `single_assignment` object, and then prints to the console each result that the `join` object holds. This example is similar to the example for the `choice` class, except that the `join` class waits for all source message blocks to receive a message.  \n  \n [!code-cpp[concrt-join-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_7.cpp)]  \n  \n This example produces the following output:  \n  \n```Output  \nfib35 = 9227465fib37 = 24157817half_of_fib42 = 1.33957e+008  \n```  \n\n This example uses the [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) algorithm to compute the Fibonacci numbers in parallel. For more information about `parallel_invoke`, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md).  \n  \n For complete examples that show how to use the `join` class, see [How to: Select Among Completed Tasks](../../parallel/concrt/how-to-select-among-completed-tasks.md) and [Walkthrough: Using join to Prevent Deadlock](../../parallel/concrt/walkthrough-using-join-to-prevent-deadlock.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"timer\"></a> timer Class  \n The concurrency::[timer class](../../parallel/concrt/reference/timer-class.md) acts as a message source. A `timer` object sends a message to a target after a specified period of time has elapsed. The `timer` class is useful when you must delay sending a message or you want to send a message at a regular interval.  \n  \n\n The `timer` class sends its message to just one target. If you set the `_PTarget` parameter in the constructor to `NULL`, you can later specify the target by calling the [concurrency::ISource::link_target](reference/source-block-class.md#link_target) method.  \n\n  \n A `timer` object can be repeating or non-repeating. To create a repeating timer, pass `true` for the `_Repeating` parameter when you call the constructor. Otherwise, pass `false` for the `_Repeating` parameter to create a non-repeating timer. If the timer is repeating, it sends the same message to its target after each interval.  \n  \n The Agents Library creates `timer` objects in the non-started state. To start a timer object, call the [concurrency::timer::start](reference/timer-class.md#start) method. To stop a `timer` object, destroy the object or call the [concurrency::timer::stop](reference/timer-class.md#stop) method. To pause a repeating timer, call the [concurrency::timer::pause](reference/timer-class.md#pause) method.  \n  \n### Example  \n The following example shows the basic structure of how to work with the `timer` class. The example uses `timer` and `call` objects to report the progress of a lengthy operation.  \n  \n [!code-cpp[concrt-timer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_8.cpp)]  \n  \n This example produces the following sample output:  \n  \n```Output  \nComputing fib(42)..................................................result is 267914296  \n```  \n  \n For a complete example that shows how to use the `timer` class, see [How to: Send a Message at a Regular Interval](../../parallel/concrt/how-to-send-a-message-at-a-regular-interval.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"filtering\"></a> Message Filtering  \n When you create a message block object, you can supply a *filter function* that determines whether the message block accepts or rejects a message. A filter function is a useful way to guarantee that a message block receives only certain values.  \n  \n The following example shows how to create an `unbounded_buffer` object that uses a filter function to accept only even numbers. The `unbounded_buffer` object rejects odd numbers, and therefore does not propagate odd numbers to its target blocks.  \n  \n [!code-cpp[concrt-filter-function#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_9.cpp)]  \n  \n This example produces the following output:  \n  \n```Output  \n0 2 4 6 8  \n```  \n  \n A filter function can be a lambda function, a function pointer, or a function object. Every filter function takes one of the following forms.  \n  \n```Output  \nbool (T)  \nbool (T const &)  \n```  \n  \n To eliminate the unnecessary copying of data, use the second form when you have an aggregate type that is propagated by value.  \n  \n Message filtering supports the *dataflow* programming model, in which components perform computations when they receive data. For examples that use filter functions to control the flow of data in a message passing network, see [How to: Use a Message Block Filter](../../parallel/concrt/how-to-use-a-message-block-filter.md), [Walkthrough: Creating a Dataflow Agent](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md), and [Walkthrough: Creating an Image-Processing Network](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).  \n  \n [[Top](#top)]  \n  \n##  <a name=\"reservation\"></a> Message Reservation  \n *Message reservation* enables a message block to reserve a message for later use. Typically, message reservation is not used directly. However, understanding message reservation can help you better understand the behavior of some of the predefined message block types.  \n  \n Consider non-greedy and greedy joins. Both of these use message reservation to reserve messages for later use. A described earlier, a non-greedy join receives messages in two phases. During the first phase, a non-greedy `join` object waits for each of its sources to receive a message. A non-greedy join then attempts to reserve each of those messages. If it can reserve each message, it consumes all messages and propagates them to its target. Otherwise, it releases, or cancels, the message reservations and again waits for each source to receive a message.  \n  \n A greedy join, which also reads input messages from a number of sources, uses message reservation to read additional messages while it waits to receive a message from each source. For example, consider a greedy join that receives messages from message blocks `A` and `B`. If the greedy join receives two messages from B but has not yet received a message from `A`, the greedy join saves the unique message identifier for the second message from `B`. After the greedy join receives a message from `A` and propagates out these messages, it uses the saved message identifier to see if the second message from `B` is still available.  \n  \n You can use message reservation when you implement your own custom message block types. For an example about how to create a custom message block type, see [Walkthrough: Creating a Custom Message Block](../../parallel/concrt/walkthrough-creating-a-custom-message-block.md).  \n  \n [[Top](#top)]  \n  \n## See Also  \n [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md)\n\n"}