<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="tr-tr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ce92fe7ee86264e773b564c68737f8fec895aba9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\data\odbc\recordset-working-with-large-data-items-odbc.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e643b09b9f57b7ef6995765cd0d9d3daa4ff0f74</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f2f05c14a14fd1b61cd8f2ba4c410d8521399162</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Recordset: Working with Large Data Items (ODBC) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Recordset: Working with Large Data Items (ODBC)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This topic applies to both the MFC ODBC classes and the MFC DAO classes.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>If you are using the MFC DAO classes, manage your large data items with class <bpt id="p1">[</bpt>CByteArray<ept id="p1">](../../mfc/reference/cbytearray-class.md)</ept> rather than class <bpt id="p2">[</bpt>CLongBinary<ept id="p2">](../../mfc/reference/clongbinary-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>If you are using the MFC ODBC classes with bulk row fetching, use <ph id="ph1">`CLongBinary`</ph> rather than <ph id="ph2">`CByteArray`</ph>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For more information about bulk row fetching, see <bpt id="p1">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id="p1">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Suppose your database can store large pieces of data, such as bitmaps (employee photographs, maps, pictures of products, OLE objects, and so on).</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This kind of data is often referred to as a Binary Large Object (or BLOB) because:</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Each field value is large.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Unlike numbers and other simple data types, it has no predictable size.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The data is formless from the perspective of your program.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This topic explains what support the database classes provide for working with such objects.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Managing Large Objects</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Recordsets have two ways to solve the special difficulty of managing binary large objects.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You can use class <bpt id="p1">[</bpt>CByteArray<ept id="p1">](../../mfc/reference/cbytearray-class.md)</ept> or you can use class <bpt id="p2">[</bpt>CLongBinary<ept id="p2">](../../mfc/reference/clongbinary-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In general, <ph id="ph1">`CByteArray`</ph> is the preferred way to manage large binary data.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>requires more overhead than <ph id="ph1">`CLongBinary`</ph> but is more capable, as described in <bpt id="p1">[</bpt>The CByteArray Class<ept id="p1">](#_core_the_cbytearray_class)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>is described briefly in <bpt id="p1">[</bpt>The CLongBinary Class<ept id="p1">](#_core_the_clongbinary_class)</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For detailed information about using <ph id="ph1">`CByteArray`</ph> to work with large data items, see <bpt id="p1">[</bpt>Technical Note 45<ept id="p1">](../../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>CByteArray Class</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>is one of the MFC collection classes.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`CByteArray`</ph> object stores a dynamic array of bytes â€” the array can grow if needed.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The class provides fast access by index, as with built-in C++ arrays.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>objects can be serialized and dumped for diagnostic purposes.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The class supplies member functions for getting and setting specified bytes, inserting and appending bytes, and removing one byte or all bytes.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>These facilities make parsing the binary data easier.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For example, if the binary object is an OLE object, you might have to work through some header bytes to reach the actual object.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Using CByteArray in Recordsets</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>By giving a field data member of your recordset the type <ph id="ph1">`CByteArray`</ph>, you provide a fixed base from which <bpt id="p1">[</bpt>RFX<ept id="p1">](../../data/odbc/record-field-exchange-rfx.md)</ept> can manage the transfer of such an object between your recordset and the data source and through which you can manipulate the data inside the object.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>RFX needs a specific site for retrieved data, and you need a way to access the underlying data.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For detailed information about using <ph id="ph1">`CByteArray`</ph> to work with large data items, see <bpt id="p1">[</bpt>Technical Note 45<ept id="p1">](../../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>CLongBinary Class</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>CLongBinary<ept id="p1">](../../mfc/reference/clongbinary-class.md)</ept> object is a simple shell around an <ph id="ph1">`HGLOBAL`</ph> handle to a block of storage allocated on the heap.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>When it binds a table column containing a binary large object, RFX allocates the <ph id="ph1">`HGLOBAL`</ph> handle when it needs to transfer the data to the recordset and stores the handle in the <ph id="ph2">`CLongBinary`</ph> field of the recordset.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In turn, you use the <ph id="ph1">`HGLOBAL`</ph> handle, <ph id="ph2">`m_hData`</ph>, to work with the data itself, operating on it as you would on any handle data.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This is where <bpt id="p1">[</bpt>CByteArray<ept id="p1">](../../mfc/reference/cbytearray-class.md)</ept> adds capabilities.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>CLongBinary objects cannot be used as parameters in function calls.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In addition, their implementation, which calls <bpt id="p1">**</bpt>::SQLGetData<ept id="p1">**</ept>, necessarily slows scrolling performance for a scrollable snapshot.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This might also be true when you use an <bpt id="p1">**</bpt>::SQLGetData<ept id="p1">**</ept> call yourself to retrieve dynamic schema columns.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Recordset (ODBC)</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Recordset: Obtaining SUMs and Other Aggregate Results (ODBC)</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Record Field Exchange (RFX)</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>