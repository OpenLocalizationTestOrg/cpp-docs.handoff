{"nodes":[{"pos":[12,75],"content":"TN016: Using C++ Multiple Inheritance with MFC | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN016: Using C++ Multiple Inheritance with MFC | Microsoft Docs","pos":[0,63]}]},{"content":"TN016: Using C++ Multiple Inheritance with MFC","pos":[701,747]},{"content":"This note describes how to use multiple inheritance (MI) with the Microsoft Foundation Classes.","pos":[748,843]},{"content":"The use of MI is not required with MFC.","pos":[844,883]},{"content":"MI is not used in any MFC classes and is not required to write a class library.","pos":[884,963]},{"content":"The following subtopics describe how MI affects the use of common MFC idioms as well as covering some of the restrictions of MI.","pos":[970,1098]},{"content":"Some of these restrictions are general C++ restrictions.","pos":[1099,1155]},{"content":"Others are imposed by the MFC architecture.","pos":[1156,1199]},{"content":"At the end of this technical note you will find a complete MFC application that uses MI.","pos":[1206,1294]},{"content":"CRuntimeClass","pos":[1303,1316]},{"content":"The persistence and dynamic object creation mechanisms of MFC use the <bpt id=\"p1\">[</bpt>CRuntimeClass<ept id=\"p1\">](../mfc/reference/cruntimeclass-structure.md)</ept> data structure to uniquely identify classes.","pos":[1320,1495],"source":"The persistence and dynamic object creation mechanisms of MFC use the [CRuntimeClass](../mfc/reference/cruntimeclass-structure.md) data structure to uniquely identify classes."},{"content":"MFC associates one of these structures with each dynamic and/or serializable class in your application.","pos":[1496,1599]},{"content":"These structures are initialized when the application starts by using a special static object of type <ph id=\"ph1\">`AFX_CLASSINIT`</ph>.","pos":[1600,1718],"source":" These structures are initialized when the application starts by using a special static object of type `AFX_CLASSINIT`."},{"content":"The current implementation of <ph id=\"ph1\">`CRuntimeClass`</ph> does not support MI runtime type information.","pos":[1725,1816],"source":"The current implementation of `CRuntimeClass` does not support MI runtime type information."},{"content":"This does not mean you cannot use MI in your MFC application.","pos":[1817,1878]},{"content":"However, you will have certain responsibilities when you work with objects that have more than one base class.","pos":[1879,1989]},{"content":"The <bpt id=\"p1\">[</bpt>CObject::IsKindOf<ept id=\"p1\">](../mfc/reference/cobject-class.md#cobject__iskindof)</ept> method will not correctly determine the type of an object if it has multiple base classes.","pos":[1996,2163],"source":"The [CObject::IsKindOf](../mfc/reference/cobject-class.md#cobject__iskindof) method will not correctly determine the type of an object if it has multiple base classes."},{"content":"Therefore, you cannot use <bpt id=\"p1\">[</bpt>CObject<ept id=\"p1\">](../mfc/reference/cobject-class.md)</ept> as a virtual base class, and all calls to <ph id=\"ph1\">`CObject`</ph> member functions such as <bpt id=\"p2\">[</bpt>CObject::Serialize<ept id=\"p2\">](../mfc/reference/cobject-class.md#cobject__serialize)</ept> and <bpt id=\"p3\">[</bpt>CObject::operator new<ept id=\"p3\">](../mfc/reference/cobject-class.md#cobject__operator_new)</ept> must have scope qualifiers so that C++ can disambiguate the appropriate function call.","pos":[2164,2558],"source":" Therefore, you cannot use [CObject](../mfc/reference/cobject-class.md) as a virtual base class, and all calls to `CObject` member functions such as [CObject::Serialize](../mfc/reference/cobject-class.md#cobject__serialize) and [CObject::operator new](../mfc/reference/cobject-class.md#cobject__operator_new) must have scope qualifiers so that C++ can disambiguate the appropriate function call."},{"content":"When a program uses MI within MFC, the class that contains the <ph id=\"ph1\">`CObject`</ph> base class needs to be the left-most class in the list of base classes.","pos":[2559,2703],"source":" When a program uses MI within MFC, the class that contains the `CObject` base class needs to be the left-most class in the list of base classes."},{"content":"An alternative is to use the <ph id=\"ph1\">`dynamic_cast`</ph> operator.","pos":[2710,2763],"source":"An alternative is to use the `dynamic_cast` operator."},{"content":"Casting an object with MI to one of its base classes will force the compiler to use the functions in the supplied base class.","pos":[2764,2889]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>dynamic_cast Operator<ept id=\"p1\">](../cpp/dynamic-cast-operator.md)</ept>.","pos":[2890,2973],"source":" For more information, see [dynamic_cast Operator](../cpp/dynamic-cast-operator.md)."},{"content":"CObject - The Root of all Classes","pos":[2982,3015]},{"content":"All significant classes derive directly or indirectly from class <ph id=\"ph1\">`CObject`</ph>.","pos":[3019,3094],"source":"All significant classes derive directly or indirectly from class `CObject`."},{"content":"does not have any member data, but it does have some default functionality.","pos":[3105,3180]},{"content":"When you use MI, you will typically inherit from two or more <ph id=\"ph1\">`CObject`</ph>-derived classes.","pos":[3181,3268],"source":" When you use MI, you will typically inherit from two or more `CObject`-derived classes."},{"content":"The following example illustrates how a class can inherit from a <bpt id=\"p1\">[</bpt>CFrameWnd<ept id=\"p1\">](../mfc/reference/cframewnd-class.md)</ept> and a <bpt id=\"p2\">[</bpt>CObList<ept id=\"p2\">](../mfc/reference/coblist-class.md)</ept>:","pos":[3269,3434],"source":" The following example illustrates how a class can inherit from a [CFrameWnd](../mfc/reference/cframewnd-class.md) and a [CObList](../mfc/reference/coblist-class.md):"},{"content":"In this case <ph id=\"ph1\">`CObject`</ph> is included two times.","pos":[3546,3591],"source":"In this case `CObject` is included two times."},{"content":"This means that you need a way to disambiguate any reference to <ph id=\"ph1\">`CObject`</ph> methods or operators.","pos":[3592,3687],"source":" This means that you need a way to disambiguate any reference to `CObject` methods or operators."},{"content":"The <ph id=\"ph1\">`operator new`</ph> and <bpt id=\"p1\">[</bpt>operator delete<ept id=\"p1\">](../mfc/reference/cobject-class.md#cobject__operator_delete)</ept> are two operators that must be disambiguated.","pos":[3688,3834],"source":" The `operator new` and [operator delete](../mfc/reference/cobject-class.md#cobject__operator_delete) are two operators that must be disambiguated."},{"content":"As another example, the following code causes an error at compile time:","pos":[3835,3906]},{"content":"Reimplementing CObject Methods","pos":[4015,4045]},{"content":"When you create a new class that has two or more <ph id=\"ph1\">`CObject`</ph> derived base classes, you should reimplement the <ph id=\"ph2\">`CObject`</ph> methods that you want other people to use.","pos":[4049,4209],"source":"When you create a new class that has two or more `CObject` derived base classes, you should reimplement the `CObject` methods that you want other people to use."},{"content":"Operators <ph id=\"ph1\">`new`</ph> and <ph id=\"ph2\">`delete`</ph> are mandatory and <bpt id=\"p1\">[</bpt>Dump<ept id=\"p1\">](../mfc/reference/cobject-class.md#cobject__dump)</ept> is recommended.","pos":[4210,4328],"source":" Operators `new` and `delete` are mandatory and [Dump](../mfc/reference/cobject-class.md#cobject__dump) is recommended."},{"content":"The following example reimplements the <ph id=\"ph1\">`new`</ph> and <ph id=\"ph2\">`delete`</ph> operators and the <ph id=\"ph3\">`Dump`</ph> method:","pos":[4329,4419],"source":" The following example reimplements the `new` and `delete` operators and the `Dump` method:"},{"content":"Virtual Inheritance of CObject","pos":[4772,4802]},{"content":"It might seem that virtually inheriting <ph id=\"ph1\">`CObject`</ph> would solve the problem of function ambiguity, but that is not the case.","pos":[4806,4928],"source":"It might seem that virtually inheriting `CObject` would solve the problem of function ambiguity, but that is not the case."},{"content":"Because there is no member data in <ph id=\"ph1\">`CObject`</ph>, you do not need virtual inheritance to prevent multiple copies of a base class member data.","pos":[4929,5066],"source":" Because there is no member data in `CObject`, you do not need virtual inheritance to prevent multiple copies of a base class member data."},{"content":"In the first example that was shown earlier, the <ph id=\"ph1\">`Dump`</ph> virtual method is still ambiguous because it is implemented differently in <ph id=\"ph2\">`CFrameWnd`</ph> and <ph id=\"ph3\">`CObList`</ph>.","pos":[5067,5224],"source":" In the first example that was shown earlier, the `Dump` virtual method is still ambiguous because it is implemented differently in `CFrameWnd` and `CObList`."},{"content":"The best way to remove ambiguity is to follow the recommendations presented in the previous section.","pos":[5225,5325]},{"content":"CObject::IsKindOf and Run-Time Typing","pos":[5334,5371]},{"content":"The run-time typing mechanism supported by MFC in <ph id=\"ph1\">`CObject`</ph> uses the macros <ph id=\"ph2\">`DECLARE_DYNAMIC`</ph>, <ph id=\"ph3\">`IMPLEMENT_DYNAMIC`</ph>, <ph id=\"ph4\">`DECLARE_DYNCREATE`</ph>, <ph id=\"ph5\">`IMPLEMENT_DYNCREATE`</ph>, <ph id=\"ph6\">`DECLARE_SERIAL`</ph> and <ph id=\"ph7\">`IMPLEMENT_SERIAL`</ph>.","pos":[5375,5575],"source":"The run-time typing mechanism supported by MFC in `CObject` uses the macros `DECLARE_DYNAMIC`, `IMPLEMENT_DYNAMIC`, `DECLARE_DYNCREATE`, `IMPLEMENT_DYNCREATE`, `DECLARE_SERIAL` and `IMPLEMENT_SERIAL`."},{"content":"These macros can perform a run-time type check to guarantee safe downcasts.","pos":[5576,5651]},{"content":"These macros support only a single base class and will work in a limited way for multiply inherited classes.","pos":[5658,5766]},{"content":"The base class you specify in <ph id=\"ph1\">`IMPLEMENT_DYNAMIC`</ph> or <ph id=\"ph2\">`IMPLEMENT_SERIAL`</ph> should be the first (or left-most) base class.","pos":[5767,5885],"source":" The base class you specify in `IMPLEMENT_DYNAMIC` or `IMPLEMENT_SERIAL` should be the first (or left-most) base class."},{"content":"This placement will enable you to do type checking for the left-most base class only.","pos":[5886,5971]},{"content":"The run-time type system will know nothing about additional base classes.","pos":[5972,6045]},{"content":"In the following example, the run-time systems will do type checking against <ph id=\"ph1\">`CFrameWnd`</ph>, but will know nothing about <ph id=\"ph2\">`CObList`</ph>.","pos":[6046,6174],"source":" In the following example, the run-time systems will do type checking against `CFrameWnd`, but will know nothing about `CObList`."},{"content":"CWnd and Message Maps","pos":[6346,6367]},{"content":"For the MFC message map system to work correctly, there are two additional requirements:","pos":[6371,6459]},{"pos":[6469,6518],"content":"There must be only one <ph id=\"ph1\">`CWnd`</ph>-derived base class.","source":"There must be only one `CWnd`-derived base class."},{"pos":[6528,6602],"content":"The <ph id=\"ph1\">`CWnd`</ph>-derived base class must be the first (or left-most) base class.","source":"The `CWnd`-derived base class must be the first (or left-most) base class."},{"content":"Here are some examples that will not work:","pos":[6609,6651]},{"content":"A Sample Program using MI","pos":[6894,6919]},{"content":"The following sample is a stand-alone application that consists of one class derived from <ph id=\"ph1\">`CFrameWnd`</ph> and <bpt id=\"p1\">[</bpt>CWinApp<ept id=\"p1\">](../mfc/reference/cwinapp-class.md)</ept>.","pos":[6923,7074],"source":"The following sample is a stand-alone application that consists of one class derived from `CFrameWnd` and [CWinApp](../mfc/reference/cwinapp-class.md)."},{"content":"We do not recommend that you structure an application in this manner, but this is an example of the smallest MFC application that has one class.","pos":[7075,7219]},{"content":"See Also","pos":[8937,8945]},{"content":"Technical Notes by Number","pos":[8950,8975]},{"content":"Technical Notes by Category","pos":[9019,9046]}],"content":"---\ntitle: \"TN016: Using C++ Multiple Inheritance with MFC | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.inheritance\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"TN016\"\n  - \"MI (Multiple Inheritance)\"\n  - \"multiple inheritance, MFC support for\"\nms.assetid: 4ee27ae1-1410-43a5-b111-b6af9b84535d\ncaps.latest.revision: 22\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN016: Using C++ Multiple Inheritance with MFC\nThis note describes how to use multiple inheritance (MI) with the Microsoft Foundation Classes. The use of MI is not required with MFC. MI is not used in any MFC classes and is not required to write a class library.  \n  \n The following subtopics describe how MI affects the use of common MFC idioms as well as covering some of the restrictions of MI. Some of these restrictions are general C++ restrictions. Others are imposed by the MFC architecture.  \n  \n At the end of this technical note you will find a complete MFC application that uses MI.  \n  \n## CRuntimeClass  \n The persistence and dynamic object creation mechanisms of MFC use the [CRuntimeClass](../mfc/reference/cruntimeclass-structure.md) data structure to uniquely identify classes. MFC associates one of these structures with each dynamic and/or serializable class in your application. These structures are initialized when the application starts by using a special static object of type `AFX_CLASSINIT`.  \n  \n The current implementation of `CRuntimeClass` does not support MI runtime type information. This does not mean you cannot use MI in your MFC application. However, you will have certain responsibilities when you work with objects that have more than one base class.  \n  \n The [CObject::IsKindOf](../mfc/reference/cobject-class.md#cobject__iskindof) method will not correctly determine the type of an object if it has multiple base classes. Therefore, you cannot use [CObject](../mfc/reference/cobject-class.md) as a virtual base class, and all calls to `CObject` member functions such as [CObject::Serialize](../mfc/reference/cobject-class.md#cobject__serialize) and [CObject::operator new](../mfc/reference/cobject-class.md#cobject__operator_new) must have scope qualifiers so that C++ can disambiguate the appropriate function call. When a program uses MI within MFC, the class that contains the `CObject` base class needs to be the left-most class in the list of base classes.  \n  \n An alternative is to use the `dynamic_cast` operator. Casting an object with MI to one of its base classes will force the compiler to use the functions in the supplied base class. For more information, see [dynamic_cast Operator](../cpp/dynamic-cast-operator.md).  \n  \n## CObject - The Root of all Classes  \n All significant classes derive directly or indirectly from class `CObject`. `CObject` does not have any member data, but it does have some default functionality. When you use MI, you will typically inherit from two or more `CObject`-derived classes. The following example illustrates how a class can inherit from a [CFrameWnd](../mfc/reference/cframewnd-class.md) and a [CObList](../mfc/reference/coblist-class.md):  \n  \n```  \nclass CListWnd : public CFrameWnd, public CObList  \n{  \n ...  \n};  \nCListWnd myListWnd;  \n```  \n  \n In this case `CObject` is included two times. This means that you need a way to disambiguate any reference to `CObject` methods or operators. The `operator new` and [operator delete](../mfc/reference/cobject-class.md#cobject__operator_delete) are two operators that must be disambiguated. As another example, the following code causes an error at compile time:  \n  \n```  \nmyListWnd.Dump(afxDump);\n*// compile time error, CFrameWnd::Dump or CObList::Dump   \n```  \n  \n## Reimplementing CObject Methods  \n When you create a new class that has two or more `CObject` derived base classes, you should reimplement the `CObject` methods that you want other people to use. Operators `new` and `delete` are mandatory and [Dump](../mfc/reference/cobject-class.md#cobject__dump) is recommended. The following example reimplements the `new` and `delete` operators and the `Dump` method:  \n  \n```  \nclass CListWnd : public CFrameWnd, public CObList  \n{  \npublic:  \n    void* operator new(size_t nSize)  \n { return CFrameWnd:: operator new(nSize);\n\n}  \n    void operator delete(void* p)  \n { CFrameWnd:: operator delete(p);\n\n}  \n \n    void Dump(CDumpContent& dc)  \n { CFrameWnd::Dump(dc);\n\n    CObList::Dump(dc);\n\n} \n ...  \n};  \n```  \n  \n## Virtual Inheritance of CObject  \n It might seem that virtually inheriting `CObject` would solve the problem of function ambiguity, but that is not the case. Because there is no member data in `CObject`, you do not need virtual inheritance to prevent multiple copies of a base class member data. In the first example that was shown earlier, the `Dump` virtual method is still ambiguous because it is implemented differently in `CFrameWnd` and `CObList`. The best way to remove ambiguity is to follow the recommendations presented in the previous section.  \n  \n## CObject::IsKindOf and Run-Time Typing  \n The run-time typing mechanism supported by MFC in `CObject` uses the macros `DECLARE_DYNAMIC`, `IMPLEMENT_DYNAMIC`, `DECLARE_DYNCREATE`, `IMPLEMENT_DYNCREATE`, `DECLARE_SERIAL` and `IMPLEMENT_SERIAL`. These macros can perform a run-time type check to guarantee safe downcasts.  \n  \n These macros support only a single base class and will work in a limited way for multiply inherited classes. The base class you specify in `IMPLEMENT_DYNAMIC` or `IMPLEMENT_SERIAL` should be the first (or left-most) base class. This placement will enable you to do type checking for the left-most base class only. The run-time type system will know nothing about additional base classes. In the following example, the run-time systems will do type checking against `CFrameWnd`, but will know nothing about `CObList`.  \n  \n```  \nclass CListWnd : public CFrameWnd,\n    public CObList  \n{  \n    DECLARE_DYNAMIC(CListWnd) \n ...  \n};  \nIMPLEMENT_DYNAMIC(CListWnd,\n    CFrameWnd)  \n```  \n  \n## CWnd and Message Maps  \n For the MFC message map system to work correctly, there are two additional requirements:  \n  \n-   There must be only one `CWnd`-derived base class.  \n  \n-   The `CWnd`-derived base class must be the first (or left-most) base class.  \n  \n Here are some examples that will not work:  \n  \n```  \nclass CTwoWindows : public CFrameWnd,\n    public CEdit  \n { ... }; *// error : two copies of CWnd  \n \nclass CListEdit : public CObList,\n    public CEdit  \n { ... }; *// error : CEdit (derived from CWnd) must be first  \n```  \n  \n## A Sample Program using MI  \n The following sample is a stand-alone application that consists of one class derived from `CFrameWnd` and [CWinApp](../mfc/reference/cwinapp-class.md). We do not recommend that you structure an application in this manner, but this is an example of the smallest MFC application that has one class.  \n  \n```  \n#include <afxwin.h>  \n  \nclass CHelloAppAndFrame : public CFrameWnd, public CWinApp  \n{   \npublic:  \n    CHelloAppAndFrame()  \n        { }  \n  \n    // Necessary because of MI disambiguity  \n    void* operator new(size_t nSize)  \n        { return CFrameWnd::operator new(nSize); }  \n    void operator delete(void* p)  \n        { CFrameWnd::operator delete(p); }  \n  \n    // Implementation  \n    // CWinApp overrides  \n    virtual BOOL InitInstance();  \n    // CFrameWnd overrides  \n    virtual void PostNcDestroy();  \n    afx_msg void OnPaint();  \n  \n    DECLARE_MESSAGE_MAP()  \n  \n};  \n  \nBEGIN_MESSAGE_MAP(CHelloAppAndFrame, CFrameWnd)  \n    ON_WM_PAINT()  \nEND_MESSAGE_MAP()  \n  \n// because the frame window is not allocated on the heap, we must  \n// override PostNCDestroy not to delete the frame object  \nvoid CHelloAppAndFrame::PostNcDestroy()  \n{  \n    // do nothing (do not call base class)  \n}  \n  \nvoid CHelloAppAndFrame::OnPaint()  \n{  \n    CPaintDC dc(this);  \n    CRect rect;  \n    GetClientRect(rect);  \n  \n    CString s = \"Hello, Windows!\";  \n    dc.SetTextAlign(TA_BASELINE | TA_CENTER);  \n    dc.SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));  \n    dc.SetBkMode(TRANSPARENT);  \n    dc.TextOut(rect.right / 2, rect.bottom / 2, s);  \n}  \n  \n// Application initialization  \nBOOL CHelloAppAndFrame::InitInstance()  \n{  \n    // first create the main frame  \n    if (!CFrameWnd::Create(NULL, \"Multiple Inheritance Sample\",  \n        WS_OVERLAPPEDWINDOW, rectDefault))  \n        return FALSE;  \n  \n    // the application object is also a frame window  \n    m_pMainWnd = this;            \n    ShowWindow(m_nCmdShow);  \n    return TRUE;  \n}  \n  \nCHelloAppAndFrame theHelloAppAndFrame;  \n```  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}