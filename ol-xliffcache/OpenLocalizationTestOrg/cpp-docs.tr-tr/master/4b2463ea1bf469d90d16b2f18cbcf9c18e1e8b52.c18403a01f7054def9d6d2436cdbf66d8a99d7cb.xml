{"nodes":[{"pos":[12,78],"content":"Using and Preserving Registers in Inline Assembly | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Using and Preserving Registers in Inline Assembly | Microsoft Docs","pos":[0,66]}]},{"content":"Using and Preserving Registers in Inline Assembly","pos":[716,765]},{"content":"Microsoft Specific","pos":[769,787]},{"content":"In general, you should not assume that a register will have a given value when an <ph id=\"ph1\">`__asm`</ph> block begins.","pos":[791,894],"source":"In general, you should not assume that a register will have a given value when an `__asm` block begins."},{"content":"Register values are not guaranteed to be preserved across separate <ph id=\"ph1\">`__asm`</ph> blocks.","pos":[895,977],"source":" Register values are not guaranteed to be preserved across separate `__asm` blocks."},{"content":"If you end a block of inline code and begin another, you cannot rely on the registers in the second block to retain their values from the first block.","pos":[978,1128]},{"content":"An <ph id=\"ph1\">`__asm`</ph> block inherits whatever register values result from the normal flow of control.","pos":[1129,1219],"source":" An `__asm` block inherits whatever register values result from the normal flow of control."},{"content":"If you use the <ph id=\"ph1\">`__fastcall`</ph> calling convention, the compiler passes function arguments in registers instead of on the stack.","pos":[1226,1350],"source":"If you use the `__fastcall` calling convention, the compiler passes function arguments in registers instead of on the stack."},{"content":"This can create problems in functions with <ph id=\"ph1\">`__asm`</ph> blocks because a function has no way to tell which parameter is in which register.","pos":[1351,1484],"source":" This can create problems in functions with `__asm` blocks because a function has no way to tell which parameter is in which register."},{"content":"If the function happens to receive a parameter in EAX and immediately stores something else in EAX, the original parameter is lost.","pos":[1485,1616]},{"content":"In addition, you must preserve the ECX register in any function declared with <ph id=\"ph1\">`__fastcall`</ph>.","pos":[1617,1708],"source":" In addition, you must preserve the ECX register in any function declared with `__fastcall`."},{"content":"To avoid such register conflicts, don't use the <ph id=\"ph1\">`__fastcall`</ph> convention for functions that contain an <ph id=\"ph2\">`__asm`</ph> block.","pos":[1715,1831],"source":"To avoid such register conflicts, don't use the `__fastcall` convention for functions that contain an `__asm` block."},{"content":"If you specify the <ph id=\"ph1\">`__fastcall`</ph> convention globally with the /Gr compiler option, declare every function containing an <ph id=\"ph2\">`__asm`</ph> block with <ph id=\"ph3\">`__cdecl`</ph> or <ph id=\"ph4\">`__stdcall`</ph>.","pos":[1832,1995],"source":" If you specify the `__fastcall` convention globally with the /Gr compiler option, declare every function containing an `__asm` block with `__cdecl` or `__stdcall`."},{"content":"(The <ph id=\"ph1\">`__cdecl`</ph> attribute tells the compiler to use the C calling convention for that function.) If you are not compiling with /Gr, avoid declaring the function with the <ph id=\"ph2\">`__fastcall`</ph> attribute.","pos":[1996,2188],"source":" (The `__cdecl` attribute tells the compiler to use the C calling convention for that function.) If you are not compiling with /Gr, avoid declaring the function with the `__fastcall` attribute."},{"content":"When using <ph id=\"ph1\">`__asm`</ph> to write assembly language in C/C++ functions, you don't need to preserve the EAX, EBX, ECX, EDX, ESI, or EDI registers.","pos":[2195,2334],"source":"When using `__asm` to write assembly language in C/C++ functions, you don't need to preserve the EAX, EBX, ECX, EDX, ESI, or EDI registers."},{"content":"For example, in the POWER2.C example in <bpt id=\"p1\">[</bpt>Writing Functions with Inline Assembly<ept id=\"p1\">](../../assembler/inline/writing-functions-with-inline-assembly.md)</ept>, the <ph id=\"ph1\">`power2`</ph> function doesn't preserve the value in the EAX register.","pos":[2335,2552],"source":" For example, in the POWER2.C example in [Writing Functions with Inline Assembly](../../assembler/inline/writing-functions-with-inline-assembly.md), the `power2` function doesn't preserve the value in the EAX register."},{"content":"However, using these registers will affect code quality because the register allocator cannot use them to store values across <ph id=\"ph1\">`__asm`</ph> blocks.","pos":[2553,2694],"source":" However, using these registers will affect code quality because the register allocator cannot use them to store values across `__asm` blocks."},{"content":"In addition, by using EBX, ESI or EDI in inline assembly code, you force the compiler to save and restore those registers in the function prologue and epilogue.","pos":[2695,2855]},{"content":"You should preserve other registers you use (such as DS, SS, SP, BP, and flags registers) for the scope of the <ph id=\"ph1\">`__asm`</ph> block.","pos":[2862,2987],"source":"You should preserve other registers you use (such as DS, SS, SP, BP, and flags registers) for the scope of the `__asm` block."},{"content":"You should preserve the ESP and EBP registers unless you have some reason to change them (to switch stacks, for example).","pos":[2988,3109]},{"content":"Also see <bpt id=\"p1\">[</bpt>Optimizing Inline Assembly<ept id=\"p1\">](../../assembler/inline/optimizing-inline-assembly.md)</ept>.","pos":[3110,3202],"source":" Also see [Optimizing Inline Assembly](../../assembler/inline/optimizing-inline-assembly.md)."},{"content":"Some SSE types require eight-byte stack alignment, forcing the compiler to emit dynamic stack-alignment code.","pos":[3209,3318]},{"content":"To be able to access both the local variables and the function parameters after the alignment, the compiler maintains two frame pointers.","pos":[3319,3456]},{"content":"If the compiler performs frame pointer omission (FPO), it will use EBP and ESP.","pos":[3458,3537]},{"content":"If the compiler does not perform FPO, it will use EBX and EBP.","pos":[3539,3601]},{"content":"To ensure code runs correctly, do not modify EBX in asm code if the function requires dynamic stack alignment as it could modify the frame pointer.","pos":[3602,3749]},{"content":"Either move the eight-byte aligned types out of the function, or avoid using EBX.","pos":[3750,3831]},{"pos":[3839,3989],"content":"[!NOTE]\n If your inline assembly code changes the direction flag using the STD or CLD instructions, you must restore the flag to its original value.","leadings":["","> "],"nodes":[{"content":"If your inline assembly code changes the direction flag using the STD or CLD instructions, you must restore the flag to its original value.","pos":[9,148]}]},{"content":"END Microsoft Specific","pos":[3998,4020]},{"content":"See Also","pos":[4031,4039]},{"content":"Inline Assembler","pos":[4044,4060]}],"content":"---\ntitle: \"Using and Preserving Registers in Inline Assembly | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__asm keyword [C++], register values\"\n  - \"inline assembly, registers\"\n  - \"registers, inline assembly\"\n  - \"preserving registers\"\nms.assetid: dbcd7360-6f3e-4b22-9ee2-9f65ca6f2543\ncaps.latest.revision: 8\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Using and Preserving Registers in Inline Assembly\n## Microsoft Specific  \n In general, you should not assume that a register will have a given value when an `__asm` block begins. Register values are not guaranteed to be preserved across separate `__asm` blocks. If you end a block of inline code and begin another, you cannot rely on the registers in the second block to retain their values from the first block. An `__asm` block inherits whatever register values result from the normal flow of control.  \n  \n If you use the `__fastcall` calling convention, the compiler passes function arguments in registers instead of on the stack. This can create problems in functions with `__asm` blocks because a function has no way to tell which parameter is in which register. If the function happens to receive a parameter in EAX and immediately stores something else in EAX, the original parameter is lost. In addition, you must preserve the ECX register in any function declared with `__fastcall`.  \n  \n To avoid such register conflicts, don't use the `__fastcall` convention for functions that contain an `__asm` block. If you specify the `__fastcall` convention globally with the /Gr compiler option, declare every function containing an `__asm` block with `__cdecl` or `__stdcall`. (The `__cdecl` attribute tells the compiler to use the C calling convention for that function.) If you are not compiling with /Gr, avoid declaring the function with the `__fastcall` attribute.  \n  \n When using `__asm` to write assembly language in C/C++ functions, you don't need to preserve the EAX, EBX, ECX, EDX, ESI, or EDI registers. For example, in the POWER2.C example in [Writing Functions with Inline Assembly](../../assembler/inline/writing-functions-with-inline-assembly.md), the `power2` function doesn't preserve the value in the EAX register. However, using these registers will affect code quality because the register allocator cannot use them to store values across `__asm` blocks. In addition, by using EBX, ESI or EDI in inline assembly code, you force the compiler to save and restore those registers in the function prologue and epilogue.  \n  \n You should preserve other registers you use (such as DS, SS, SP, BP, and flags registers) for the scope of the `__asm` block. You should preserve the ESP and EBP registers unless you have some reason to change them (to switch stacks, for example). Also see [Optimizing Inline Assembly](../../assembler/inline/optimizing-inline-assembly.md).  \n  \n Some SSE types require eight-byte stack alignment, forcing the compiler to emit dynamic stack-alignment code. To be able to access both the local variables and the function parameters after the alignment, the compiler maintains two frame pointers.  If the compiler performs frame pointer omission (FPO), it will use EBP and ESP.  If the compiler does not perform FPO, it will use EBX and EBP. To ensure code runs correctly, do not modify EBX in asm code if the function requires dynamic stack alignment as it could modify the frame pointer. Either move the eight-byte aligned types out of the function, or avoid using EBX.  \n  \n> [!NOTE]\n>  If your inline assembly code changes the direction flag using the STD or CLD instructions, you must restore the flag to its original value.  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [Inline Assembler](../../assembler/inline/inline-assembler.md)"}