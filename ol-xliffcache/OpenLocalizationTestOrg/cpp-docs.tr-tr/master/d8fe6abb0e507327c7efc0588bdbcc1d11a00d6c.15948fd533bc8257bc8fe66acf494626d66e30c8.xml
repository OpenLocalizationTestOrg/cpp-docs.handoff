{"nodes":[{"pos":[12,48],"content":"match_results Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"match_results Class | Microsoft Docs","pos":[0,36]}]},{"pos":[675,694],"content":"match_results Class","linkify":"match_results Class","nodes":[{"content":"match_results Class","pos":[0,19]}]},{"content":"Holds a sequence of submatches.","pos":[695,726]},{"pos":[735,741],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[2209,2219],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type for submatches.","pos":[2234,2267]},{"content":"The type of an allocator for managing storage.","pos":[2285,2331]},{"pos":[2340,2347],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template class describes an object that controls a non-modifiable sequence of elements of type <ph id=\"ph1\">`sub_match&lt;BidIt&gt;`</ph> generated by a regular expression search.","pos":[2351,2510],"source":"The template class describes an object that controls a non-modifiable sequence of elements of type `sub_match<BidIt>` generated by a regular expression search."},{"content":"Each element points to the subsequence that matched the capture group corresponding to that element.","pos":[2511,2611]},{"pos":[2620,2632],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[2636,2656],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>regex&gt;","source":"**Header:** \\<regex>"},{"pos":[2663,2681],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[2691,2766],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__allocator_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::allocator_type","linkify":"<a name=\"match_results__allocator_type\"></a>  match_results::allocator_type","source":"<a name=\"match_results__allocator_type\"></a>  match_results::allocator_type"},{"content":"The type of an allocator for managing storage.","pos":[2770,2816]},{"pos":[2873,2880],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[2884,2943],"content":"The typedef is a synonym for the template argument <ph id=\"ph1\">`Alloc`</ph>.","source":"The typedef is a synonym for the template argument `Alloc`."},{"pos":[2953,2960],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6234,6291],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__begin\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::begin","linkify":"<a name=\"match_results__begin\"></a>  match_results::begin","source":"<a name=\"match_results__begin\"></a>  match_results::begin"},{"content":"Designates beginning of submatch sequence.","pos":[6295,6337]},{"pos":[6392,6399],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns a random access iterator that points at the first element of the sequence (or just beyond the end of an empty sequence).","pos":[6403,6551]},{"pos":[6561,6568],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9833,9898],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__char_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::char_type","linkify":"<a name=\"match_results__char_type\"></a>  match_results::char_type","source":"<a name=\"match_results__char_type\"></a>  match_results::char_type"},{"content":"The type of an element.","pos":[9902,9925]},{"pos":[10015,10022],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[10026,10172],"content":"The typedef is a synonym for the type <ph id=\"ph1\">`iterator_traits&lt;BidIt&gt;::value_type`</ph>, which is the element type of the character sequence that was searched.","source":"The typedef is a synonym for the type `iterator_traits<BidIt>::value_type`, which is the element type of the character sequence that was searched."},{"pos":[10182,10189],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[13458,13533],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__const_iterator\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::const_iterator","linkify":"<a name=\"match_results__const_iterator\"></a>  match_results::const_iterator","source":"<a name=\"match_results__const_iterator\"></a>  match_results::const_iterator"},{"content":"The const iterator type for submatches.","pos":[13537,13576]},{"pos":[13630,13637],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The typedef describes an object that can serve as a constant random-access iterator for the controlled sequence.","pos":[13641,13753]},{"pos":[13763,13770],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[17044,17121],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__const_reference\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::const_reference","linkify":"<a name=\"match_results__const_reference\"></a>  match_results::const_reference","source":"<a name=\"match_results__const_reference\"></a>  match_results::const_reference"},{"content":"The type of an element const reference.","pos":[17125,17164]},{"pos":[17254,17261],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The typedef describes an object that can serve as a constant reference to an element of the controlled sequence.","pos":[17265,17377]},{"pos":[17387,17394],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[20669,20746],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__difference_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::difference_type","linkify":"<a name=\"match_results__difference_type\"></a>  match_results::difference_type","source":"<a name=\"match_results__difference_type\"></a>  match_results::difference_type"},{"content":"The type of an iterator difference.","pos":[20750,20785]},{"pos":[20886,20893],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[20897,21111],"content":"The typedef is a synonym for the type <ph id=\"ph1\">`iterator_traits&lt;BidIt&gt;::difference_type`</ph>; it describes an object that can represent the difference between any two iterators that point at elements of the controlled sequence.","source":"The typedef is a synonym for the type `iterator_traits<BidIt>::difference_type`; it describes an object that can represent the difference between any two iterators that point at elements of the controlled sequence."},{"pos":[21121,21128],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[24403,24460],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__empty\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::empty","linkify":"<a name=\"match_results__empty\"></a>  match_results::empty","source":"<a name=\"match_results__empty\"></a>  match_results::empty"},{"content":"Tests for no submatches.","pos":[24464,24488]},{"pos":[24533,24540],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns true only if the regular expression search failed.","pos":[24544,24622]},{"pos":[24632,24639],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[27904,27957],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__end\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::end","linkify":"<a name=\"match_results__end\"></a>  match_results::end","source":"<a name=\"match_results__end\"></a>  match_results::end"},{"content":"Designates end of submatch sequence.","pos":[27961,27997]},{"pos":[28050,28057],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns an iterator that points just beyond the end of the sequence.","pos":[28061,28149]},{"pos":[28159,28166],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[31429,31488],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__format\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::format","linkify":"<a name=\"match_results__format\"></a>  match_results::format","source":"<a name=\"match_results__format\"></a>  match_results::format"},{"content":"Formats submatches.","pos":[31492,31511]},{"pos":[31755,31765],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The output iterator type.","pos":[31780,31805]},{"content":"The output stream to write to.","pos":[31821,31851]},{"content":"The format string.","pos":[31867,31885]},{"content":"The format flags.","pos":[31903,31920]},{"pos":[31930,31937],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Each member function generates formatted text under the control of the format <ph id=\"ph1\">`fmt`</ph>.","pos":[31941,32025],"source":"Each member function generates formatted text under the control of the format `fmt`."},{"content":"The first member function writes the formatted text to the sequence defined by its argument <ph id=\"ph1\">`out`</ph> and returns <ph id=\"ph2\">`out`</ph>.","pos":[32026,32142],"source":" The first member function writes the formatted text to the sequence defined by its argument `out` and returns `out`."},{"content":"The second member function returns a string object holding a copy of the formatted text.","pos":[32143,32231]},{"content":"To generate formatted text.","pos":[32238,32265]},{"content":"literal text in the format string is ordinarily copied to the target sequence.","pos":[32266,32344]},{"content":"Each escape sequence in the format string is replaced by the text that it represents.","pos":[32345,32430]},{"content":"The details of the copying and replacement are controlled by the format flags passed to the function.","pos":[32431,32532]},{"pos":[32542,32549],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[35811,35884],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__get_allocator\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::get_allocator","linkify":"<a name=\"match_results__get_allocator\"></a>  match_results::get_allocator","source":"<a name=\"match_results__get_allocator\"></a>  match_results::get_allocator"},{"content":"Returns the stored allocator.","pos":[35888,35917]},{"pos":[35980,35987],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[35991,36102],"content":"The member function returns a copy of the allocator object used by <ph id=\"ph1\">`*this`</ph> to allocate its <ph id=\"ph2\">`sub_match`</ph> objects.","source":"The member function returns a copy of the allocator object used by `*this` to allocate its `sub_match` objects."},{"pos":[36112,36119],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[39392,39455],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__iterator\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::iterator","linkify":"<a name=\"match_results__iterator\"></a>  match_results::iterator","source":"<a name=\"match_results__iterator\"></a>  match_results::iterator"},{"content":"The iterator type for submatches.","pos":[39459,39492]},{"pos":[39552,39559],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The type describes an object that can serve as a random-access iterator for the controlled sequence.","pos":[39563,39663]},{"pos":[39673,39680],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[42948,43007],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__length\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::length","linkify":"<a name=\"match_results__length\"></a>  match_results::length","source":"<a name=\"match_results__length\"></a>  match_results::length"},{"content":"Returns length of a submatch.","pos":[43011,43040]},{"pos":[43114,43124],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The index of the submatch.","pos":[43137,43163]},{"pos":[43173,43180],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[43184,43236],"content":"The member function returns <ph id=\"ph1\">`(*this)[sub].length()`</ph>.","source":"The member function returns `(*this)[sub].length()`."},{"pos":[43246,43253],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[46519,46592],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__match_results\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::match_results","linkify":"<a name=\"match_results__match_results\"></a>  match_results::match_results","source":"<a name=\"match_results__match_results\"></a>  match_results::match_results"},{"content":"Constructs the object.","pos":[46596,46618]},{"pos":[46741,46751],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The allocator object to store.","pos":[46766,46796]},{"content":"The match_results object to copy.","pos":[46814,46847]},{"pos":[46857,46864],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first constructor constructs a <ph id=\"ph1\">`match_results`</ph> object that holds no submatches.","pos":[46868,46951],"source":"The first constructor constructs a `match_results` object that holds no submatches."},{"content":"The second constructor constructs a <ph id=\"ph1\">`match_results`</ph> object that is a copy of <ph id=\"ph2\">`right`</ph>.","pos":[46952,47037],"source":" The second constructor constructs a `match_results` object that is a copy of `right`."},{"pos":[47047,47054],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[50323,50386],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__max_size\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::max_size","linkify":"<a name=\"match_results__max_size\"></a>  match_results::max_size","source":"<a name=\"match_results__max_size\"></a>  match_results::max_size"},{"content":"Gets largest number of submatches.","pos":[50390,50424]},{"pos":[50477,50484],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns the length of the longest sequence that the object can control.","pos":[50488,50579]},{"pos":[50589,50596],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[53864,53931],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__operator_eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::operator=","linkify":"<a name=\"match_results__operator_eq\"></a>  match_results::operator=","source":"<a name=\"match_results__operator_eq\"></a>  match_results::operator="},{"content":"Copy a match_results object.","pos":[53935,53963]},{"pos":[54042,54052],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The match_results object to copy.","pos":[54067,54100]},{"pos":[54110,54117],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[54121,54235],"content":"The member operator replaces the sequence controlled by <ph id=\"ph1\">`*this`</ph> with a copy of the sequence controlled by <ph id=\"ph2\">`right`</ph>.","source":"The member operator replaces the sequence controlled by `*this` with a copy of the sequence controlled by `right`."},{"pos":[54245,54252],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[57523,57591],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__operator_at\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::operator[]","linkify":"<a name=\"match_results__operator_at\"></a>  match_results::operator[]","source":"<a name=\"match_results__operator_at\"></a>  match_results::operator[]"},{"content":"Access a subobject.","pos":[57595,57614]},{"pos":[57686,57696],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Index of the submatch.","pos":[57707,57729]},{"pos":[57739,57746],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[57750,57946],"content":"The member function returns a reference to element <ph id=\"ph1\">`n`</ph> of the controlled sequence, or a reference to an empty <ph id=\"ph2\">`sub_match`</ph> object if <ph id=\"ph3\">`size() &lt;= n`</ph> or if capture group <ph id=\"ph4\">`n`</ph> was not part of the match.","source":"The member function returns a reference to element `n` of the controlled sequence, or a reference to an empty `sub_match` object if `size() <= n` or if capture group `n` was not part of the match."},{"pos":[57956,57963],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[61234,61297],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__position\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::position","linkify":"<a name=\"match_results__position\"></a>  match_results::position","source":"<a name=\"match_results__position\"></a>  match_results::position"},{"content":"Get starting offset of a subgroup.","pos":[61301,61335]},{"pos":[61411,61421],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Index of the submatch.","pos":[61434,61456]},{"pos":[61466,61473],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[61477,61720],"content":"The member function returns <ph id=\"ph1\">`std::distance(prefix().first, (*this)[sub].first)`</ph>, that is, the distance from the first character in the target sequence to the first character in the submatch pointed to by element <ph id=\"ph2\">`n`</ph> of the controlled sequence.","source":"The member function returns `std::distance(prefix().first, (*this)[sub].first)`, that is, the distance from the first character in the target sequence to the first character in the submatch pointed to by element `n` of the controlled sequence."},{"pos":[61730,61737],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[65005,65064],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__prefix\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::prefix","linkify":"<a name=\"match_results__prefix\"></a>  match_results::prefix","source":"<a name=\"match_results__prefix\"></a>  match_results::prefix"},{"content":"Gets sequence before first submatch.","pos":[65068,65104]},{"pos":[65161,65168],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[65172,65439],"content":"The member function returns a reference to an object of type <ph id=\"ph1\">`sub_match&lt;BidIt&gt;`</ph> that points to the character sequence that begins at the start of the target sequence and ends at <ph id=\"ph2\">`(*this)[0].first`</ph>, that is, it points to the text that precedes the matched subsequence.","source":"The member function returns a reference to an object of type `sub_match<BidIt>` that points to the character sequence that begins at the start of the target sequence and ends at `(*this)[0].first`, that is, it points to the text that precedes the matched subsequence."},{"pos":[65449,65456],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[68722,68787],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__reference\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::reference","linkify":"<a name=\"match_results__reference\"></a>  match_results::reference","source":"<a name=\"match_results__reference\"></a>  match_results::reference"},{"content":"The type of an element reference.","pos":[68791,68824]},{"pos":[68886,68893],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[68897,68950],"content":"The type is a synonym for the type <ph id=\"ph1\">`const_reference`</ph>.","source":"The type is a synonym for the type `const_reference`."},{"pos":[68960,68967],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[72236,72291],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__size\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::size","linkify":"<a name=\"match_results__size\"></a>  match_results::size","source":"<a name=\"match_results__size\"></a>  match_results::size"},{"content":"Counts number of submatches.","pos":[72295,72323]},{"pos":[72372,72379],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns one more than the number of capture groups in the regular expression that was used for the search, or zero if no search has been made.","pos":[72383,72545]},{"pos":[72555,72562],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[75826,75891],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__size_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::size_type","linkify":"<a name=\"match_results__size_type\"></a>  match_results::size_type","source":"<a name=\"match_results__size_type\"></a>  match_results::size_type"},{"content":"The type of a submatch count.","pos":[75895,75924]},{"pos":[75996,76003],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[76007,76061],"content":"The type is a synonym for the type <ph id=\"ph1\">`Alloc::size_type`</ph>.","source":"The type is a synonym for the type `Alloc::size_type`."},{"pos":[76071,76078],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[79347,79400],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__str\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::str","linkify":"<a name=\"match_results__str\"></a>  match_results::str","source":"<a name=\"match_results__str\"></a>  match_results::str"},{"content":"Returns a submatch.","pos":[79404,79423]},{"pos":[79490,79500],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Index of the submatch.","pos":[79513,79535]},{"pos":[79545,79552],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[79556,79612],"content":"The member function returns <ph id=\"ph1\">`string_type((*this)[sub])`</ph>.","source":"The member function returns `string_type((*this)[sub])`."},{"pos":[79622,79629],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[82892,82961],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__string_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::string_type","linkify":"<a name=\"match_results__string_type\"></a>  match_results::string_type","source":"<a name=\"match_results__string_type\"></a>  match_results::string_type"},{"content":"The type of a string.","pos":[82965,82986]},{"pos":[83058,83065],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[83069,83130],"content":"The type is a synonym for the type <ph id=\"ph1\">`basic_string&lt;char_type&gt;`</ph>.","source":"The type is a synonym for the type `basic_string<char_type>`."},{"pos":[83140,83147],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[86418,86477],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__suffix\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::suffix","linkify":"<a name=\"match_results__suffix\"></a>  match_results::suffix","source":"<a name=\"match_results__suffix\"></a>  match_results::suffix"},{"content":"Gets sequence after last submatch.","pos":[86481,86515]},{"pos":[86572,86579],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[86583,86857],"content":"The member function returns a reference to an object of type <ph id=\"ph1\">`sub_match&lt;BidIt&gt;`</ph> that points to the character sequence that begins at <ph id=\"ph2\">`(*this)[size() - 1].second`</ph> and ends at the end of the target sequence, that is, it points to the text that follows the matched subsequence.","source":"The member function returns a reference to an object of type `sub_match<BidIt>` that points to the character sequence that begins at `(*this)[size() - 1].second` and ends at the end of the target sequence, that is, it points to the text that follows the matched subsequence."},{"pos":[86867,86874],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[90140,90195],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__swap\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::swap","linkify":"<a name=\"match_results__swap\"></a>  match_results::swap","source":"<a name=\"match_results__swap\"></a>  match_results::swap"},{"content":"Swaps two match_results objects.","pos":[90199,90231]},{"pos":[90303,90313],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The match_results object to swap with.","pos":[90328,90366]},{"pos":[90376,90383],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[90387,90496],"content":"The member function swaps the contents of <ph id=\"ph1\">`*this`</ph> and <ph id=\"ph2\">`right`</ph> in constant time and does not throw exceptions.","source":"The member function swaps the contents of `*this` and `right` in constant time and does not throw exceptions."},{"pos":[90506,90513],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[93777,93844],"content":"<bpt id=\"p1\">&lt;a name=\"match_results__value_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  match_results::value_type","linkify":"<a name=\"match_results__value_type\"></a>  match_results::value_type","source":"<a name=\"match_results__value_type\"></a>  match_results::value_type"},{"content":"The type of a submatch.","pos":[93848,93871]},{"pos":[93935,93942],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[93946,94003],"content":"The typedef is a synonym for the type <ph id=\"ph1\">`sub_match&lt;BidIt&gt;`</ph>.","source":"The typedef is a synonym for the type `sub_match<BidIt>`."},{"pos":[94013,94020],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[97289,97297],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[97301,97341],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>regex&gt;<ept id=\"p1\">](../standard-library/regex.md)</ept>","source":"[\\<regex>](../standard-library/regex.md)"}],"content":"---\ntitle: \"match_results Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std.tr1.match_results\"\n  - \"match_results\"\n  - \"std::tr1::match_results\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"match_results class [TR1]\"\nms.assetid: b504fdca-e5dd-429d-9960-6e27c9167fa6\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# match_results Class\nHolds a sequence of submatches.  \n  \n## Syntax  \n```  \nclass match_results {  \n   public:  \n   explicit match_results(const Alloc& alloc = Alloc());\n   match_results(const match_results& right);\n   match_results& operator=(const match_results& right);\n   difference_type position(size_type sub = 0) const;\n   difference_type length(size_type sub = 0) const;\n   string_type str(size_type sub = 0) const;\n   const_reference operator[](size_type n) const;\n   const_reference prefix() const;\n   const_reference suffix() const;\n   const_iterator begin() const;\n   const_iterator end() const;\n   template <class OutIt>  \n   OutIt format(OutIt out,  \n   const string_type& fmt, match_flag_type flags = format_default) const;\n   string_type format(const string_type& fmt,  \n   match_flag_type flags = format_default) const;\n   allocator_type get_allocator() const;\n   void swap(const match_results& other) throw();\n   size_type size() const;\n   size_type max_size() const;\n   bool empty() const;\n   typedef sub_match<BidIt>  \n   value_type;  \n   typedef const typename Alloc::const_reference const_reference;  \n   typedef const_reference reference;  \n   typedef T0 const_iterator;  \n   typedef const_iterator iterator;  \n   typedef typename iterator_traits<BidIt>::difference_type difference_type;  \n   typedef typename Alloc::size_type size_type;  \n   typedef Alloc allocator_type;  \n   typedef typename iterator_traits<BidIt>::value_type char_type;  \n   typedef basic_string<char_type> string_type;  \n   };  \n```  \n#### Parameters  \n `BidIt`  \n The iterator type for submatches.  \n  \n `Alloc`  \n The type of an allocator for managing storage.  \n  \n## Remarks  \n The template class describes an object that controls a non-modifiable sequence of elements of type `sub_match<BidIt>` generated by a regular expression search. Each element points to the subsequence that matched the capture group corresponding to that element.  \n  \n## Requirements  \n **Header:** \\<regex>  \n  \n **Namespace:** std  \n  \n##  <a name=\"match_results__allocator_type\"></a>  match_results::allocator_type  \n The type of an allocator for managing storage.  \n  \n```  \ntypedef Alloc allocator_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for the template argument `Alloc`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_allocator_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__begin\"></a>  match_results::begin  \n Designates beginning of submatch sequence.  \n  \n```  \nconst_iterator begin() const;\n```  \n  \n### Remarks  \n The member function returns a random access iterator that points at the first element of the sequence (or just beyond the end of an empty sequence).  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_begin.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__char_type\"></a>  match_results::char_type  \n The type of an element.  \n  \n```  \ntypedef typename iterator_traits<BidIt>::value_type char_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for the type `iterator_traits<BidIt>::value_type`, which is the element type of the character sequence that was searched.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_char_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__const_iterator\"></a>  match_results::const_iterator  \n The const iterator type for submatches.  \n  \n```  \ntypedef T0 const_iterator;  \n```  \n  \n### Remarks  \n The typedef describes an object that can serve as a constant random-access iterator for the controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_const_iterator.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__const_reference\"></a>  match_results::const_reference  \n The type of an element const reference.  \n  \n```  \ntypedef const typename Alloc::const_reference const_reference;  \n```  \n  \n### Remarks  \n The typedef describes an object that can serve as a constant reference to an element of the controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_const_reference.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__difference_type\"></a>  match_results::difference_type  \n The type of an iterator difference.  \n  \n```  \ntypedef typename iterator_traits<BidIt>::difference_type difference_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for the type `iterator_traits<BidIt>::difference_type`; it describes an object that can represent the difference between any two iterators that point at elements of the controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_difference_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__empty\"></a>  match_results::empty  \n Tests for no submatches.  \n  \n```  \nbool empty() const;\n```  \n  \n### Remarks  \n The member function returns true only if the regular expression search failed.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_empty.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__end\"></a>  match_results::end  \n Designates end of submatch sequence.  \n  \n```  \nconst_iterator end() const;\n```  \n  \n### Remarks  \n The member function returns an iterator that points just beyond the end of the sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_end.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__format\"></a>  match_results::format  \n Formats submatches.  \n  \n```  \ntemplate <class OutIt>  \nOutIt format(OutIt out,  \n    const string_type& fmt, match_flag_type flags = format_default) const;\n\n \nstring_type format(const string_type& fmt, match_flag_type flags = format_default) const;\n```  \n  \n### Parameters  \n `OutIt`  \n The output iterator type.  \n  \n `out`  \n The output stream to write to.  \n  \n `fmt`  \n The format string.  \n  \n `flags`  \n The format flags.  \n  \n### Remarks  \n Each member function generates formatted text under the control of the format `fmt`. The first member function writes the formatted text to the sequence defined by its argument `out` and returns `out`. The second member function returns a string object holding a copy of the formatted text.  \n  \n To generate formatted text. literal text in the format string is ordinarily copied to the target sequence. Each escape sequence in the format string is replaced by the text that it represents. The details of the copying and replacement are controlled by the format flags passed to the function.  \n  \n### Example  \n  \n```cpp  \n// std__regex__match_results_format.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__get_allocator\"></a>  match_results::get_allocator  \n Returns the stored allocator.  \n  \n```  \nallocator_type get_allocator() const;\n```  \n  \n### Remarks  \n The member function returns a copy of the allocator object used by `*this` to allocate its `sub_match` objects.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_get_allocator.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__iterator\"></a>  match_results::iterator  \n The iterator type for submatches.  \n  \n```  \ntypedef const_iterator iterator;  \n```  \n  \n### Remarks  \n The type describes an object that can serve as a random-access iterator for the controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_iterator.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__length\"></a>  match_results::length  \n Returns length of a submatch.  \n  \n```  \ndifference_type length(size_type sub = 0) const;\n```  \n  \n### Parameters  \n `sub`  \n The index of the submatch.  \n  \n### Remarks  \n The member function returns `(*this)[sub].length()`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_length.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__match_results\"></a>  match_results::match_results  \n Constructs the object.  \n  \n```  \nexplicit match_results(const Alloc& alloc = Alloc());\n\nmatch_results(const match_results& right);\n```  \n  \n### Parameters  \n `alloc`  \n The allocator object to store.  \n  \n `right`  \n The match_results object to copy.  \n  \n### Remarks  \n The first constructor constructs a `match_results` object that holds no submatches. The second constructor constructs a `match_results` object that is a copy of `right`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_construct.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__max_size\"></a>  match_results::max_size  \n Gets largest number of submatches.  \n  \n```  \nsize_type max_size() const;\n```  \n  \n### Remarks  \n The member function returns the length of the longest sequence that the object can control.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_max_size.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__operator_eq\"></a>  match_results::operator=  \n Copy a match_results object.  \n  \n```  \nmatch_results& operator=(const match_results& right);\n```  \n  \n### Parameters  \n `right`  \n The match_results object to copy.  \n  \n### Remarks  \n The member operator replaces the sequence controlled by `*this` with a copy of the sequence controlled by `right`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_operator_as.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__operator_at\"></a>  match_results::operator[]  \n Access a subobject.  \n  \n```  \nconst_reference operator[](size_type n) const;\n```  \n  \n### Parameters  \n `n`  \n Index of the submatch.  \n  \n### Remarks  \n The member function returns a reference to element `n` of the controlled sequence, or a reference to an empty `sub_match` object if `size() <= n` or if capture group `n` was not part of the match.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_operator_br.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__position\"></a>  match_results::position  \n Get starting offset of a subgroup.  \n  \n```  \ndifference_type position(size_type sub = 0) const;\n```  \n  \n### Parameters  \n `sub`  \n Index of the submatch.  \n  \n### Remarks  \n The member function returns `std::distance(prefix().first, (*this)[sub].first)`, that is, the distance from the first character in the target sequence to the first character in the submatch pointed to by element `n` of the controlled sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_position.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__prefix\"></a>  match_results::prefix  \n Gets sequence before first submatch.  \n  \n```  \nconst_reference prefix() const;\n```  \n  \n### Remarks  \n The member function returns a reference to an object of type `sub_match<BidIt>` that points to the character sequence that begins at the start of the target sequence and ends at `(*this)[0].first`, that is, it points to the text that precedes the matched subsequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_prefix.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__reference\"></a>  match_results::reference  \n The type of an element reference.  \n  \n```  \ntypedef const_reference reference;  \n```  \n  \n### Remarks  \n The type is a synonym for the type `const_reference`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_reference.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__size\"></a>  match_results::size  \n Counts number of submatches.  \n  \n```  \nsize_type size() const;\n```  \n  \n### Remarks  \n The member function returns one more than the number of capture groups in the regular expression that was used for the search, or zero if no search has been made.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_size.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__size_type\"></a>  match_results::size_type  \n The type of a submatch count.  \n  \n```  \ntypedef typename Alloc::size_type size_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the type `Alloc::size_type`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_size_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__str\"></a>  match_results::str  \n Returns a submatch.  \n  \n```  \nstring_type str(size_type sub = 0) const;\n```  \n  \n### Parameters  \n `sub`  \n Index of the submatch.  \n  \n### Remarks  \n The member function returns `string_type((*this)[sub])`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_str.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__string_type\"></a>  match_results::string_type  \n The type of a string.  \n  \n```  \ntypedef basic_string<char_type> string_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the type `basic_string<char_type>`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_string_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__suffix\"></a>  match_results::suffix  \n Gets sequence after last submatch.  \n  \n```  \nconst_reference suffix() const;\n```  \n  \n### Remarks  \n The member function returns a reference to an object of type `sub_match<BidIt>` that points to the character sequence that begins at `(*this)[size() - 1].second` and ends at the end of the target sequence, that is, it points to the text that follows the matched subsequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_suffix.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__swap\"></a>  match_results::swap  \n Swaps two match_results objects.  \n  \n```  \nvoid swap(const match_results& right) throw();\n```  \n  \n### Parameters  \n `right`  \n The match_results object to swap with.  \n  \n### Remarks  \n The member function swaps the contents of `*this` and `right` in constant time and does not throw exceptions.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_swap.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n##  <a name=\"match_results__value_type\"></a>  match_results::value_type  \n The type of a submatch.  \n  \n```  \ntypedef sub_match<BidIt> value_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for the type `sub_match<BidIt>`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__match_results_value_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::cout << \"prefix: matched == \" << std::boolalpha   \n        << mr.prefix().matched   \n        << \", value == \" << mr.prefix() << std::endl;   \n    std::cout << \"whole match: \" << mr.length() << \" chars, value == \"   \n        << mr.str() << std::endl;   \n    std::cout << \"suffix: matched == \" << std::boolalpha   \n        << mr.suffix().matched   \n        << \", value == \" << mr.suffix() << std::endl;   \n    std::cout << std::endl;   \n  \n    std::string fmt(\"\\\"c(a*)|(b)\\\" matched \\\"$0\\\"\\n\"   \n        \"\\\"(a*)\\\" matched \\\"$1\\\"\\n\"   \n        \"\\\"(b)\\\" matched \\\"$2\\\"\\n\");   \n    std::cout << mr.format(fmt) << std::endl;   \n    std::cout << std::endl;   \n  \n// index through submatches   \n    for (size_t n = 0; n < mr.size(); ++n)   \n        {   \n        std::cout << \"submatch[\" << n << \"]: matched == \" << std::boolalpha   \n            << mr[n].matched <<   \n            \" at position \" << mr.position(n) << std::endl;   \n        std::cout << \"  \" << mr.length(n)   \n            << \" chars, value == \" << mr[n] << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// iterate through submatches   \n    for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)   \n        {   \n        std::cout << \"next submatch: matched == \" << std::boolalpha   \n            << it->matched << std::endl;   \n        std::cout << \"  \" << it->length()   \n            << \" chars, value == \" << *it << std::endl;   \n        }   \n    std::cout << std::endl;   \n  \n// other members   \n    std::cmatch mr1(mr);   \n    mr = mr1;   \n    mr.swap(mr1);   \n  \n    char buf[10];   \n *mr.format(&buf[0], \"<$0>\") = '\\0';   \n    std::cout << &buf[0] << std::endl;   \n    std::cout << \"empty == \" << std::boolalpha << mr.empty() << std::endl;   \n  \n    std::cmatch::allocator_type al = mr.get_allocator();   \n    std::cmatch::string_type str = std::string(\"x\");   \n    std::cmatch::size_type maxsiz = mr.max_size();   \n    std::cmatch::char_type ch = 'x';   \n    std::cmatch::difference_type dif = mr.begin() - mr.end();   \n    std::cmatch::const_iterator cit = mr.begin();   \n    std::cmatch::value_type val = *cit;   \n    std::cmatch::const_reference cref = val;   \n    std::cmatch::reference ref = val;   \n  \n    maxsiz = maxsiz;  // to quiet \"unused\" warnings   \n    if (ref == cref)   \n        ch = ch;   \n    dif = dif;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nprefix: matched == true, value == x  \nwhole match: 4 chars, value == caaa  \nsuffix: matched == true, value == y  \n  \n\"c(a*)|(b)\" matched \"caaa\"  \n\"(a*)\" matched \"aaa\"  \n\"(b)\" matched \"\"  \n  \nsubmatch[0]: matched == true at position 1  \n  4 chars, value == caaa  \nsubmatch[1]: matched == true at position 2  \n  3 chars, value == aaa  \nsubmatch[2]: matched == false at position 6  \n  0 chars, value ==   \n  \nnext submatch: matched == true  \n  4 chars, value == caaa  \nnext submatch: matched == true  \n  3 chars, value == aaa  \nnext submatch: matched == false  \n  0 chars, value ==   \n  \n<caaa>  \nempty == false  \n```  \n  \n## See Also  \n [\\<regex>](../standard-library/regex.md)\n\n\n"}