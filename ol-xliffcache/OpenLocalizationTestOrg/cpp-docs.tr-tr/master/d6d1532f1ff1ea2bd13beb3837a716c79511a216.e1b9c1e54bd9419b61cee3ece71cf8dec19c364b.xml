{"nodes":[{"pos":[12,81],"content":"How to: Expose an STL-CLR Container from an Assembly | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Expose an STL-CLR Container from an Assembly | Microsoft Docs","pos":[0,69]}]},{"content":"How to: Expose an STL/CLR Container from an Assembly","pos":[658,710]},{"content":"STL/CLR containers such as <ph id=\"ph1\">`list`</ph> and <ph id=\"ph2\">`map`</ph> are implemented as template ref classes.","pos":[711,795],"source":"STL/CLR containers such as `list` and `map` are implemented as template ref classes."},{"content":"Because C++ templates are instantiated at compile time, two template classes that have exactly the same signature but are in different assemblies are actually different types.","pos":[796,971]},{"content":"This means that template classes cannot be used across assembly boundaries.","pos":[972,1047]},{"content":"To make cross-assembly sharing possible, STL/CLR containers implement the generic interface &lt;xref:System.Collections.Generic.ICollection%601&gt;.","pos":[1054,1196],"source":"To make cross-assembly sharing possible, STL/CLR containers implement the generic interface <xref:System.Collections.Generic.ICollection%601>."},{"content":"By using this generic interface, all languages that support generics, including C++, C#, and Visual Basic, can access STL/CLR containers.","pos":[1197,1334]},{"content":"This topic shows you how to display the elements of several STL/CLR containers written in a C++ assembly named <ph id=\"ph1\">`StlClrClassLibrary`</ph>.","pos":[1341,1473],"source":"This topic shows you how to display the elements of several STL/CLR containers written in a C++ assembly named `StlClrClassLibrary`."},{"content":"We show two assemblies to access <ph id=\"ph1\">`StlClrClassLibrary`</ph>.","pos":[1474,1528],"source":" We show two assemblies to access `StlClrClassLibrary`."},{"content":"The first assembly is written in C++, and the second in C#.","pos":[1529,1588]},{"content":"If both assemblies are written in C++, you can access the generic interface of a container by using its <ph id=\"ph1\">`generic_container`</ph> typedef.","pos":[1595,1727],"source":"If both assemblies are written in C++, you can access the generic interface of a container by using its `generic_container` typedef."},{"content":"For example, if you have a container of type <ph id=\"ph1\">`cliext::vector&lt;int&gt;`</ph>, then its generic interface is: <ph id=\"ph2\">`cliext::vector&lt;int&gt;::generic_container`</ph>.","pos":[1728,1868],"source":" For example, if you have a container of type `cliext::vector<int>`, then its generic interface is: `cliext::vector<int>::generic_container`."},{"content":"Similarly, you can get an iterator over the generic interface by using the <ph id=\"ph1\">`generic_iterator`</ph> typedef, as in: <ph id=\"ph2\">`cliext::vector&lt;int&gt;::generic_iterator`</ph>.","pos":[1869,2019],"source":" Similarly, you can get an iterator over the generic interface by using the `generic_iterator` typedef, as in: `cliext::vector<int>::generic_iterator`."},{"content":"Since these typedefs are declared in C++ header files, assemblies written in other languages cannot use them.","pos":[2026,2135]},{"content":"Therefore, to access the generic interface for <ph id=\"ph1\">`cliext::vector&lt;int&gt;`</ph> in C# or any other .NET language, use <ph id=\"ph2\">`System.Collections.Generic.ICollection&lt;int&gt;`</ph>.","pos":[2136,2289],"source":" Therefore, to access the generic interface for `cliext::vector<int>` in C# or any other .NET language, use `System.Collections.Generic.ICollection<int>`."},{"content":"To iterate over this collection, use a <ph id=\"ph1\">`foreach`</ph> loop.","pos":[2290,2344],"source":" To iterate over this collection, use a `foreach` loop."},{"content":"The following table lists the generic interface that each STL/CLR container implements:","pos":[2351,2438]},{"content":"STL/CLR container","pos":[2445,2462]},{"content":"Generic interface","pos":[2463,2480]},{"content":"deque&lt;T","pos":[2538,2545],"source":"deque<T"},{"content":"ICollection&lt;T","pos":[2548,2561],"source":"ICollection<T"},{"content":"hash_map&lt;K, V&gt;","pos":[2568,2582],"source":"hash_map<K, V>"},{"content":"IDictionary&lt;K, V&gt;","pos":[2583,2600],"source":"IDictionary<K, V>"},{"content":"hash_multimap&lt;K, V&gt;","pos":[2605,2624],"source":"hash_multimap<K, V>"},{"content":"IDictionary&lt;K, V&gt;","pos":[2625,2642],"source":"IDictionary<K, V>"},{"content":"hash_multiset&lt;T","pos":[2647,2662],"source":"hash_multiset<T"},{"content":"ICollection&lt;T","pos":[2665,2678],"source":"ICollection<T"},{"content":"hash_set&lt;T","pos":[2685,2695],"source":"hash_set<T"},{"content":"ICollection&lt;T","pos":[2698,2711],"source":"ICollection<T"},{"content":"list&lt;T","pos":[2718,2724],"source":"list<T"},{"content":"ICollection&lt;T","pos":[2727,2740],"source":"ICollection<T"},{"content":"map&lt;K, V&gt;","pos":[2747,2756],"source":"map<K, V>"},{"content":"IDictionary&lt;K, V&gt;","pos":[2757,2774],"source":"IDictionary<K, V>"},{"content":"multimap&lt;K, V&gt;","pos":[2779,2793],"source":"multimap<K, V>"},{"content":"IDictionary&lt;K, V&gt;","pos":[2794,2811],"source":"IDictionary<K, V>"},{"content":"multiset&lt;T","pos":[2816,2826],"source":"multiset<T"},{"content":"ICollection&lt;T","pos":[2829,2842],"source":"ICollection<T"},{"content":"set&lt;T","pos":[2849,2854],"source":"set<T"},{"content":"ICollection&lt;T","pos":[2857,2870],"source":"ICollection<T"},{"content":"vector&lt;T","pos":[2877,2885],"source":"vector<T"},{"content":"ICollection&lt;T","pos":[2888,2901],"source":"ICollection<T"},{"pos":[2912,3090],"content":"[!NOTE]\n Because the `queue`, `priority_queue`, and `stack` containers do not support iterators, they do not implement generic interfaces and cannot be accessed cross-assembly.","leadings":["","> "],"nodes":[{"content":"Because the <ph id=\"ph1\">`queue`</ph>, <ph id=\"ph2\">`priority_queue`</ph>, and <ph id=\"ph3\">`stack`</ph> containers do not support iterators, they do not implement generic interfaces and cannot be accessed cross-assembly.","pos":[9,176],"source":" Because the `queue`, `priority_queue`, and `stack` containers do not support iterators, they do not implement generic interfaces and cannot be accessed cross-assembly."}]},{"content":"Example 1","pos":[3099,3108]},{"content":"Description","pos":[3118,3129]},{"content":"In this example, we declare a C++ class that contains private STL/CLR member data.","pos":[3133,3215]},{"content":"We then declare public methods to grant access to the private collections of the class.","pos":[3216,3303]},{"content":"We do it in two different ways, one for C++ clients and one for other .NET clients.","pos":[3304,3387]},{"content":"Code","pos":[3397,3401]},{"pos":[3431,3432],"content":"0"},{"content":"Example 2","pos":[3463,3472]},{"content":"Description","pos":[3482,3493]},{"content":"In this example, we implement the class declared in Example 1.","pos":[3497,3559]},{"content":"In order for clients to use this class library, we use the manifest tool <bpt id=\"p1\">**</bpt>mt.exe<ept id=\"p1\">**</ept> to embed the manifest file into the DLL.","pos":[3560,3684],"source":" In order for clients to use this class library, we use the manifest tool **mt.exe** to embed the manifest file into the DLL."},{"content":"For details, see the code comments.","pos":[3685,3720]},{"pos":[3727,3947],"content":"For more information on the manifest tool and side-by-side assemblies, see <bpt id=\"p1\">[</bpt>Building C/C++ Isolated Applications and Side-by-side Assemblies<ept id=\"p1\">](../build/building-c-cpp-isolated-applications-and-side-by-side-assemblies.md)</ept>.","source":"For more information on the manifest tool and side-by-side assemblies, see [Building C/C++ Isolated Applications and Side-by-side Assemblies](../build/building-c-cpp-isolated-applications-and-side-by-side-assemblies.md)."},{"content":"Code","pos":[3957,3961]},{"pos":[3991,3992],"content":"1"},{"content":"Example 3","pos":[4023,4032]},{"content":"Description","pos":[4042,4053]},{"content":"In this example, we create a C++ client that uses the class library created in Examples 1 and 2.","pos":[4057,4153]},{"content":"This client uses the <ph id=\"ph1\">`generic_container`</ph> typedefs of the STL/CLR containers to iterate over the containers and to display their contents.","pos":[4154,4291],"source":" This client uses the `generic_container` typedefs of the STL/CLR containers to iterate over the containers and to display their contents."},{"content":"Code","pos":[4301,4305]},{"pos":[4335,4336],"content":"2"},{"content":"Output","pos":[4368,4374]},{"pos":[4404,4405],"content":"3"},{"content":"Example 4","pos":[4436,4445]},{"content":"Description","pos":[4455,4466]},{"content":"In this example, we create a C# client that uses the class library created in Examples 1 and 2.","pos":[4470,4565]},{"content":"This client uses the &lt;xref:System.Collections.Generic.ICollection%601&gt; methods of the STL/CLR containers to iterate over the containers and to display their contents.","pos":[4566,4732],"source":" This client uses the <xref:System.Collections.Generic.ICollection%601> methods of the STL/CLR containers to iterate over the containers and to display their contents."},{"content":"Code","pos":[4742,4746]},{"content":"Output","pos":[6657,6663]},{"content":"See Also","pos":[6903,6911]},{"content":"STL/CLR Library Reference","pos":[6916,6941]}],"content":"---\ntitle: \"How to: Expose an STL-CLR Container from an Assembly | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"STL/CLR Containers [STL/CLR]\"\n  - \"STL/CLR, cross-assembly issues\"\nms.assetid: 87efb41b-3db3-4498-a2e7-f3ef8a99f04d\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Expose an STL/CLR Container from an Assembly\nSTL/CLR containers such as `list` and `map` are implemented as template ref classes. Because C++ templates are instantiated at compile time, two template classes that have exactly the same signature but are in different assemblies are actually different types. This means that template classes cannot be used across assembly boundaries.  \n  \n To make cross-assembly sharing possible, STL/CLR containers implement the generic interface <xref:System.Collections.Generic.ICollection%601>. By using this generic interface, all languages that support generics, including C++, C#, and Visual Basic, can access STL/CLR containers.  \n  \n This topic shows you how to display the elements of several STL/CLR containers written in a C++ assembly named `StlClrClassLibrary`. We show two assemblies to access `StlClrClassLibrary`. The first assembly is written in C++, and the second in C#.  \n  \n If both assemblies are written in C++, you can access the generic interface of a container by using its `generic_container` typedef. For example, if you have a container of type `cliext::vector<int>`, then its generic interface is: `cliext::vector<int>::generic_container`. Similarly, you can get an iterator over the generic interface by using the `generic_iterator` typedef, as in: `cliext::vector<int>::generic_iterator`.  \n  \n Since these typedefs are declared in C++ header files, assemblies written in other languages cannot use them. Therefore, to access the generic interface for `cliext::vector<int>` in C# or any other .NET language, use `System.Collections.Generic.ICollection<int>`. To iterate over this collection, use a `foreach` loop.  \n  \n The following table lists the generic interface that each STL/CLR container implements:  \n  \n|STL/CLR container|Generic interface|  \n|------------------------|-----------------------|  \n|deque<T\\>|ICollection<T\\>|  \n|hash_map<K, V>|IDictionary<K, V>|  \n|hash_multimap<K, V>|IDictionary<K, V>|  \n|hash_multiset<T\\>|ICollection<T\\>|  \n|hash_set<T\\>|ICollection<T\\>|  \n|list<T\\>|ICollection<T\\>|  \n|map<K, V>|IDictionary<K, V>|  \n|multimap<K, V>|IDictionary<K, V>|  \n|multiset<T\\>|ICollection<T\\>|  \n|set<T\\>|ICollection<T\\>|  \n|vector<T\\>|ICollection<T\\>|  \n  \n> [!NOTE]\n>  Because the `queue`, `priority_queue`, and `stack` containers do not support iterators, they do not implement generic interfaces and cannot be accessed cross-assembly.  \n  \n## Example 1  \n  \n### Description  \n In this example, we declare a C++ class that contains private STL/CLR member data. We then declare public methods to grant access to the private collections of the class. We do it in two different ways, one for C++ clients and one for other .NET clients.  \n  \n### Code  \n  \n<CodeContentPlaceHolder>0</CodeContentPlaceHolder>  \n## Example 2  \n  \n### Description  \n In this example, we implement the class declared in Example 1. In order for clients to use this class library, we use the manifest tool **mt.exe** to embed the manifest file into the DLL. For details, see the code comments.  \n  \n For more information on the manifest tool and side-by-side assemblies, see [Building C/C++ Isolated Applications and Side-by-side Assemblies](../build/building-c-cpp-isolated-applications-and-side-by-side-assemblies.md).  \n  \n### Code  \n  \n<CodeContentPlaceHolder>1</CodeContentPlaceHolder>  \n## Example 3  \n  \n### Description  \n In this example, we create a C++ client that uses the class library created in Examples 1 and 2. This client uses the `generic_container` typedefs of the STL/CLR containers to iterate over the containers and to display their contents.  \n  \n### Code  \n  \n<CodeContentPlaceHolder>2</CodeContentPlaceHolder>  \n### Output  \n  \n<CodeContentPlaceHolder>3</CodeContentPlaceHolder>  \n## Example 4  \n  \n### Description  \n In this example, we create a C# client that uses the class library created in Examples 1 and 2. This client uses the <xref:System.Collections.Generic.ICollection%601> methods of the STL/CLR containers to iterate over the containers and to display their contents.  \n  \n### Code  \n  \n```  \n// CsConsoleApp.cs  \n// compile with: /r:Microsoft.VisualC.STLCLR.dll /r:StlClrClassLibrary.dll /r:System.dll  \n  \nusing System;  \nusing System.Collections.Generic;  \nusing StlClrClassLibrary;  \nusing cliext;  \n  \nnamespace CsConsoleApp  \n{  \n    class Program  \n    {  \n        static int Main(string[] args)  \n        {  \n            StlClrClass theClass = new StlClrClass();  \n  \n            Console.WriteLine(\"cliext::deque contents:\");  \n            ICollection<char> iCollChar = theClass.GetDequeCs();  \n            foreach (char c in iCollChar)  \n            {  \n                Console.WriteLine(c);  \n            }  \n            Console.WriteLine();  \n  \n            Console.WriteLine(\"cliext::list contents:\");  \n            ICollection<float> iCollFloat = theClass.GetListCs();  \n            foreach (float f in iCollFloat)  \n            {  \n                Console.WriteLine(f);  \n            }  \n            Console.WriteLine();  \n  \n            Console.WriteLine(\"cliext::map contents:\");  \n            IDictionary<int, string> iDict = theClass.GetMapCs();  \n            foreach (KeyValuePair<int, string> kvp in iDict)  \n            {  \n                Console.WriteLine(\"{0} {1}\", kvp.Key, kvp.Value);  \n            }  \n            Console.WriteLine();  \n  \n            Console.WriteLine(\"cliext::set contents:\");  \n            ICollection<double> iCollDouble = theClass.GetSetCs();  \n            foreach (double d in iCollDouble)  \n            {  \n                Console.WriteLine(d);  \n            }  \n            Console.WriteLine();  \n  \n            Console.WriteLine(\"cliext::vector contents:\");  \n            ICollection<int> iCollInt = theClass.GetVectorCs();  \n            foreach (int i in iCollInt)  \n            {  \n                Console.WriteLine(i);  \n            }  \n            Console.WriteLine();  \n  \n            return 0;  \n        }  \n    }  \n}  \n```  \n  \n### Output  \n  \n```  \ncliext::deque contents:  \na  \nb  \n  \ncliext::list contents:  \n3.14159  \n2.71828  \n  \ncliext::map contents:  \n0 Hello  \n1 World  \n  \ncliext::set contents:  \n2.71828  \n3.14159  \n  \ncliext::vector contents:  \n10  \n20  \n```  \n  \n## See Also  \n [STL/CLR Library Reference](../dotnet/stl-clr-library-reference.md)"}