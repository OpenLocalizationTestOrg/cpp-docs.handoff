{"nodes":[{"pos":[12,49],"content":"Exception Processing | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Exception Processing | Microsoft Docs","pos":[0,37]}]},{"content":"Exception Processing","pos":[858,878]},{"content":"When a program executes, a number of abnormal conditions and errors called \"exceptions\" can occur.","pos":[879,977]},{"content":"These may include running out of memory, resource allocation errors, and failure to find files.","pos":[978,1073]},{"content":"The Microsoft Foundation Class Library uses an exception-handling scheme that is modeled closely after the one proposed by the ANSI standards committee for C++.","pos":[1080,1240]},{"content":"An exception handler must be set up before calling a function that may encounter an abnormal situation.","pos":[1241,1344]},{"content":"If the function encounters an abnormal condition, it throws an exception and control is passed to the exception handler.","pos":[1345,1465]},{"content":"Several macros included with the Microsoft Foundation Class Library will set up exception handlers.","pos":[1472,1571]},{"content":"A number of other global functions help to throw specialized exceptions and terminate programs, if necessary.","pos":[1572,1681]},{"content":"These macros and global functions fall into the following categories:","pos":[1682,1751]},{"content":"Exception macros, which structure your exception handler.","pos":[1759,1816]},{"content":"Exception-throwing functions), which generate exceptions of specific types.","pos":[1824,1899]},{"content":"Termination functions, which cause program termination.","pos":[1907,1962]},{"pos":[1969,2069],"content":"For examples and more details, see the article <bpt id=\"p1\">[</bpt>Exceptions<ept id=\"p1\">](../../mfc/exception-handling-in-mfc.md)</ept>.","source":"For examples and more details, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md)."},{"content":"Exception Macros","pos":[2079,2095]},{"content":"TRY","pos":[2117,2120]},{"content":"Designates a block of code for exception processing.","pos":[2128,2180]},{"content":"CATCH","pos":[2186,2191]},{"pos":[2201,2287],"content":"Designates a block of code for catching an exception from the preceding <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block.","source":"Designates a block of code for catching an exception from the preceding **TRY** block."},{"content":"CATCH_ALL","pos":[2293,2302]},{"pos":[2316,2404],"content":"Designates a block of code for catching all exceptions from the preceding <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block.","source":"Designates a block of code for catching all exceptions from the preceding **TRY** block."},{"content":"AND_CATCH","pos":[2410,2419]},{"pos":[2433,2533],"content":"Designates a block of code for catching additional exception types from the preceding <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block.","source":"Designates a block of code for catching additional exception types from the preceding **TRY** block."},{"content":"AND_CATCH_ALL","pos":[2539,2552]},{"pos":[2570,2683],"content":"Designates a block of code for catching all other additional exception types thrown in a preceding <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block.","source":"Designates a block of code for catching all other additional exception types thrown in a preceding **TRY** block."},{"content":"END_CATCH","pos":[2689,2698]},{"pos":[2712,2762],"content":"Ends the last <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`AND_CATCH`</ph> code block.","source":"Ends the last **CATCH** or `AND_CATCH` code block."},{"content":"END_CATCH_ALL","pos":[2768,2781]},{"pos":[2799,2836],"content":"Ends the last <ph id=\"ph1\">`CATCH_ALL`</ph> code block.","source":"Ends the last `CATCH_ALL` code block."},{"content":"THROW","pos":[2842,2847]},{"content":"Throws a specified exception.","pos":[2857,2886]},{"content":"THROW_LAST","pos":[2892,2902]},{"content":"Throws the currently handled exception to the next outer handler.","pos":[2917,2982]},{"content":"Exception-Throwing Functions","pos":[2993,3021]},{"content":"AfxThrowArchiveException","pos":[3043,3067]},{"content":"Throws an archive exception.","pos":[3096,3124]},{"content":"AfxThrowFileException","pos":[3130,3151]},{"content":"Throws a file exception.","pos":[3177,3201]},{"content":"AfxThrowMemoryException","pos":[3207,3230]},{"content":"Throws a memory exception.","pos":[3258,3284]},{"content":"AfxThrowNotSupportedException","pos":[3290,3319]},{"content":"Throws a not-supported exception.","pos":[3353,3386]},{"content":"AfxThrowResourceException","pos":[3392,3417]},{"content":"Throws a Windows resource-not-found exception.","pos":[3447,3493]},{"content":"AfxThrowUserException","pos":[3499,3520]},{"content":"Throws an exception in a user-initiated program action.","pos":[3546,3601]},{"content":"MFC provides two exception-throwing functions specifically for OLE exceptions:","pos":[3609,3687]},{"content":"OLE Exception Functions","pos":[3697,3720]},{"content":"AfxThrowOleDispatchException","pos":[3742,3770]},{"content":"Throws an exception within an OLE automation function.","pos":[3803,3857]},{"content":"AfxThrowOleException","pos":[3863,3883]},{"content":"Throws an OLE exception.","pos":[3908,3932]},{"pos":[3940,4112],"content":"To support database exceptions, the database classes provide two exception classes, <ph id=\"ph1\">`CDBException`</ph> and <ph id=\"ph2\">`CDaoException`</ph>, and global functions to support the exception types:","source":"To support database exceptions, the database classes provide two exception classes, `CDBException` and `CDaoException`, and global functions to support the exception types:"},{"content":"DAO Exception Functions","pos":[4122,4145]},{"content":"AfxThrowDAOException","pos":[4167,4187]},{"pos":[4212,4300],"content":"Throws a <bpt id=\"p1\">[</bpt>CDaoException<ept id=\"p1\">](../../mfc/reference/cdaoexception-class.md)</ept> from your own code.","source":"Throws a [CDaoException](../../mfc/reference/cdaoexception-class.md) from your own code."},{"content":"AfxThrowDBException","pos":[4306,4325]},{"pos":[4349,4435],"content":"Throws a <bpt id=\"p1\">[</bpt>CDBException<ept id=\"p1\">](../../mfc/reference/cdbexception-class.md)</ept> from your own code.","source":"Throws a [CDBException](../../mfc/reference/cdbexception-class.md) from your own code."},{"content":"MFC provides the following termination function:","pos":[4443,4491]},{"content":"Termination Functions","pos":[4501,4522]},{"content":"AfxAbort","pos":[4544,4552]},{"content":"Called to terminate an application when a fatal error occurs.","pos":[4565,4626]},{"pos":[4657,4660],"content":"TRY"},{"pos":[4664,4688],"content":"Sets up a <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block.","source":"Sets up a **TRY** block."},{"content":"Remarks","pos":[4721,4728]},{"content":"A <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block identifies a block of code that might throw exceptions.","pos":[4732,4803],"source":"A **TRY** block identifies a block of code that might throw exceptions."},{"content":"Those exceptions are handled in the following <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`AND_CATCH`</ph> blocks.","pos":[4804,4883],"source":" Those exceptions are handled in the following **CATCH** and `AND_CATCH` blocks."},{"content":"Recursion is allowed: exceptions may be passed to an outer <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block, either by ignoring them or by using the <ph id=\"ph1\">`THROW_LAST`</ph> macro.","pos":[4884,5017],"source":" Recursion is allowed: exceptions may be passed to an outer **TRY** block, either by ignoring them or by using the `THROW_LAST` macro."},{"content":"End the <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block with an <ph id=\"ph1\">`END_CATCH`</ph> or <ph id=\"ph2\">`END_CATCH_ALL`</ph> macro.","pos":[5018,5085],"source":" End the **TRY** block with an `END_CATCH` or `END_CATCH_ALL` macro."},{"pos":[5092,5183],"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Exceptions<ept id=\"p1\">](../../mfc/exception-handling-in-mfc.md)</ept>.","source":"For more information, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md)."},{"content":"Example","pos":[5193,5200]},{"pos":[5204,5240],"content":"See the example for <bpt id=\"p1\">[</bpt>CATCH<ept id=\"p1\">](#catch)</ept>.","source":"See the example for [CATCH](#catch)."},{"pos":[5272,5277],"content":"CATCH"},{"pos":[5281,5381],"content":"Defines a block of code that catches the first exception type thrown in the preceding <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block.","source":"Defines a block of code that catches the first exception type thrown in the preceding **TRY** block."},{"content":"Parameters","pos":[5465,5475]},{"content":"exception_class","pos":[5480,5495]},{"content":"Specifies the exception type to test for.","pos":[5500,5541]},{"content":"For a list of standard exception classes, see class <bpt id=\"p1\">[</bpt>CException<ept id=\"p1\">](../../mfc/reference/cexception-class.md)</ept>.","pos":[5542,5648],"source":" For a list of standard exception classes, see class [CException](../../mfc/reference/cexception-class.md)."},{"content":"exception_object_pointer_name","pos":[5656,5685]},{"content":"Specifies a name for an exception-object pointer that will be created by the macro.","pos":[5690,5773]},{"content":"You can use the pointer name to access the exception object within the <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> block.","pos":[5774,5861],"source":" You can use the pointer name to access the exception object within the **CATCH** block."},{"content":"This variable is declared for you.","pos":[5862,5896]},{"content":"Remarks","pos":[5906,5913]},{"content":"The exception-processing code can interrogate the exception object, if appropriate, to get more information about the specific cause of the exception.","pos":[5917,6067]},{"content":"Invoke the <ph id=\"ph1\">`THROW_LAST`</ph> macro to shift processing to the next outer exception frame.","pos":[6068,6152],"source":" Invoke the `THROW_LAST` macro to shift processing to the next outer exception frame."},{"content":"End the <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block with an <ph id=\"ph1\">`END_CATCH`</ph> macro.","pos":[6153,6201],"source":" End the **TRY** block with an `END_CATCH` macro."},{"content":"If <bpt id=\"p1\">*</bpt>exception_class<ept id=\"p1\">*</ept> is the class <ph id=\"ph1\">`CException`</ph>, then all exception types will be caught.","pos":[6208,6296],"source":"If *exception_class* is the class `CException`, then all exception types will be caught."},{"content":"You can use the <bpt id=\"p1\">[</bpt>CObject::IsKindOf<ept id=\"p1\">](../../mfc/reference/cobject-class.md#cobject__iskindof)</ept> member function to determine which specific exception was thrown.","pos":[6297,6454],"source":" You can use the [CObject::IsKindOf](../../mfc/reference/cobject-class.md#cobject__iskindof) member function to determine which specific exception was thrown."},{"content":"A better way to catch several kinds of exceptions is to use sequential <ph id=\"ph1\">`AND_CATCH`</ph> statements, each with a different exception type.","pos":[6455,6587],"source":" A better way to catch several kinds of exceptions is to use sequential `AND_CATCH` statements, each with a different exception type."},{"content":"The exception object pointer is created by the macro.","pos":[6594,6647]},{"content":"You do not need to declare it yourself.","pos":[6648,6687]},{"pos":[6695,6911],"content":"[!NOTE]\n The **CATCH** block is defined as a C++ scope delineated by braces. If you declare variables in this scope, they are accessible only within that scope. This also applies to *exception_object_pointer_name*.","leadings":["","> "],"nodes":[{"content":" The **CATCH** block is defined as a C++ scope delineated by braces. If you declare variables in this scope, they are accessible only within that scope. This also applies to *exception_object_pointer_name*.","pos":[8,214],"nodes":[{"content":"The <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> block is defined as a C++ scope delineated by braces.","pos":[1,68],"source":" The **CATCH** block is defined as a C++ scope delineated by braces."},{"content":"If you declare variables in this scope, they are accessible only within that scope.","pos":[69,152]},{"content":"This also applies to <bpt id=\"p1\">*</bpt>exception_object_pointer_name<ept id=\"p1\">*</ept>.","pos":[153,206],"source":" This also applies to *exception_object_pointer_name*."}]}]},{"pos":[6918,7047],"content":"For more information on exceptions and the <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> macro, see the article <bpt id=\"p2\">[</bpt>Exceptions<ept id=\"p2\">](../../mfc/exception-handling-in-mfc.md)</ept>.","source":"For more information on exceptions and the **CATCH** macro, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md)."},{"content":"Example","pos":[7057,7064]},{"pos":[7079,7099],"content":"NVC_MFCExceptions#26"},{"pos":[7191,7200],"content":"CATCH_ALL"},{"pos":[7204,7299],"content":"Defines a block of code that catches all exception types thrown in the preceding <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block.","source":"Defines a block of code that catches all exception types thrown in the preceding **TRY** block."},{"content":"Parameters","pos":[7369,7379]},{"content":"exception_object_pointer_name","pos":[7384,7413]},{"content":"Specifies a name for an exception-object pointer that will be created by the macro.","pos":[7418,7501]},{"content":"You can use the pointer name to access the exception object within the <ph id=\"ph1\">`CATCH_ALL`</ph> block.","pos":[7502,7591],"source":" You can use the pointer name to access the exception object within the `CATCH_ALL` block."},{"content":"This variable is declared for you.","pos":[7592,7626]},{"content":"Remarks","pos":[7636,7643]},{"content":"The exception-processing code can interrogate the exception object, if appropriate, to get more information about the specific cause of the exception.","pos":[7647,7797]},{"content":"Invoke the <ph id=\"ph1\">`THROW_LAST`</ph> macro to shift processing to the next outer exception frame.","pos":[7798,7882],"source":" Invoke the `THROW_LAST` macro to shift processing to the next outer exception frame."},{"content":"If you use <ph id=\"ph1\">`CATCH_ALL`</ph>, end the <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block with an <ph id=\"ph2\">`END_CATCH_ALL`</ph> macro.","pos":[7883,7959],"source":" If you use `CATCH_ALL`, end the **TRY** block with an `END_CATCH_ALL` macro."},{"pos":[7967,8131],"content":"[!NOTE]\n The `CATCH_ALL` block is defined as a C++ scope delineated by braces. If you declare variables in this scope, they are accessible only within that scope.","leadings":["","> "],"nodes":[{"content":" The `CATCH_ALL` block is defined as a C++ scope delineated by braces. If you declare variables in this scope, they are accessible only within that scope.","pos":[8,162],"nodes":[{"content":"The <ph id=\"ph1\">`CATCH_ALL`</ph> block is defined as a C++ scope delineated by braces.","pos":[1,70],"source":" The `CATCH_ALL` block is defined as a C++ scope delineated by braces."},{"content":"If you declare variables in this scope, they are accessible only within that scope.","pos":[71,154]}]}]},{"pos":[8138,8243],"content":"For more information on exceptions, see the article <bpt id=\"p1\">[</bpt>Exceptions<ept id=\"p1\">](../../mfc/exception-handling-in-mfc.md)</ept>.","source":"For more information on exceptions, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md)."},{"content":"Example","pos":[8253,8260]},{"pos":[8264,8348],"content":"See the example for <bpt id=\"p1\">[</bpt>CFile::Abort<ept id=\"p1\">](../../mfc/reference/cfile-class.md#cfile__abort)</ept>.","source":"See the example for [CFile::Abort](../../mfc/reference/cfile-class.md#cfile__abort)."},{"pos":[8384,8393],"content":"AND_CATCH"},{"pos":[8397,8497],"content":"Defines a block of code for catching additional exception types thrown in a preceding <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block.","source":"Defines a block of code for catching additional exception types thrown in a preceding **TRY** block."},{"content":"Parameters","pos":[8584,8594]},{"content":"exception_class","pos":[8599,8614]},{"content":"Specifies the exception type to test for.","pos":[8619,8660]},{"content":"For a list of standard exception classes, see class <bpt id=\"p1\">[</bpt>CException<ept id=\"p1\">](../../mfc/reference/cexception-class.md)</ept>.","pos":[8661,8767],"source":" For a list of standard exception classes, see class [CException](../../mfc/reference/cexception-class.md)."},{"content":"exception_object_pointer_name","pos":[8775,8804]},{"content":"A name for an exception-object pointer that will be created by the macro.","pos":[8809,8882]},{"content":"You can use the pointer name to access the exception object within the <ph id=\"ph1\">`AND_CATCH`</ph> block.","pos":[8883,8972],"source":" You can use the pointer name to access the exception object within the `AND_CATCH` block."},{"content":"This variable is declared for you.","pos":[8973,9007]},{"content":"Remarks","pos":[9017,9024]},{"content":"Use the <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> macro to catch one exception type, then the <ph id=\"ph1\">`AND_CATCH`</ph> macro to catch each subsequent type.","pos":[9028,9138],"source":"Use the **CATCH** macro to catch one exception type, then the `AND_CATCH` macro to catch each subsequent type."},{"content":"End the <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block with an <ph id=\"ph1\">`END_CATCH`</ph> macro.","pos":[9139,9187],"source":" End the **TRY** block with an `END_CATCH` macro."},{"content":"The exception-processing code can interrogate the exception object, if appropriate, to get more information about the specific cause of the exception.","pos":[9194,9344]},{"content":"Call the <ph id=\"ph1\">`THROW_LAST`</ph> macro within the <ph id=\"ph2\">`AND_CATCH`</ph> block to shift processing to the next outer exception frame.","pos":[9345,9456],"source":" Call the `THROW_LAST` macro within the `AND_CATCH` block to shift processing to the next outer exception frame."},{"content":"marks the end of the preceding <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`AND_CATCH`</ph> block.","pos":[9469,9531],"source":" marks the end of the preceding **CATCH** or `AND_CATCH` block."},{"pos":[9539,9792],"content":"[!NOTE]\n The `AND_CATCH` block is defined as a C++ scope (delineated by curly braces). If you declare variables in this scope, remember that they are accessible only within that scope. This also applies to the *exception_object_pointer_name* variable.","leadings":["","> "],"nodes":[{"content":" The `AND_CATCH` block is defined as a C++ scope (delineated by curly braces). If you declare variables in this scope, remember that they are accessible only within that scope. This also applies to the *exception_object_pointer_name* variable.","pos":[8,251],"nodes":[{"content":"The <ph id=\"ph1\">`AND_CATCH`</ph> block is defined as a C++ scope (delineated by curly braces).","pos":[1,78],"source":" The `AND_CATCH` block is defined as a C++ scope (delineated by curly braces)."},{"content":"If you declare variables in this scope, remember that they are accessible only within that scope.","pos":[79,176]},{"content":"This also applies to the <bpt id=\"p1\">*</bpt>exception_object_pointer_name<ept id=\"p1\">*</ept> variable.","pos":[177,243],"source":" This also applies to the *exception_object_pointer_name* variable."}]}]},{"content":"Example","pos":[9802,9809]},{"pos":[9813,9849],"content":"See the example for <bpt id=\"p1\">[</bpt>CATCH<ept id=\"p1\">](#catch)</ept>.","source":"See the example for [CATCH](#catch)."},{"pos":[9889,9902],"content":"AND_CATCH_ALL"},{"pos":[9906,10006],"content":"Defines a block of code for catching additional exception types thrown in a preceding <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block.","source":"Defines a block of code for catching additional exception types thrown in a preceding **TRY** block."},{"content":"Parameters","pos":[10079,10089]},{"content":"exception_object_pointer_name","pos":[10094,10123]},{"content":"A name for an exception-object pointer that will be created by the macro.","pos":[10128,10201]},{"content":"You can use the pointer name to access the exception object within the <ph id=\"ph1\">`AND_CATCH_ALL`</ph> block.","pos":[10202,10295],"source":" You can use the pointer name to access the exception object within the `AND_CATCH_ALL` block."},{"content":"This variable is declared for you.","pos":[10296,10330]},{"content":"Remarks","pos":[10340,10347]},{"content":"Use the <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> macro to catch one exception type, then the <ph id=\"ph1\">`AND_CATCH_ALL`</ph> macro to catch all other subsequent types.","pos":[10351,10471],"source":"Use the **CATCH** macro to catch one exception type, then the `AND_CATCH_ALL` macro to catch all other subsequent types."},{"content":"If you use <ph id=\"ph1\">`AND_CATCH_ALL`</ph>, end the <bpt id=\"p1\">**</bpt>TRY<ept id=\"p1\">**</ept> block with an <ph id=\"ph2\">`END_CATCH_ALL`</ph> macro.","pos":[10472,10552],"source":" If you use `AND_CATCH_ALL`, end the **TRY** block with an `END_CATCH_ALL` macro."},{"content":"The exception-processing code can interrogate the exception object, if appropriate, to get more information about the specific cause of the exception.","pos":[10559,10709]},{"content":"Call the <ph id=\"ph1\">`THROW_LAST`</ph> macro within the <ph id=\"ph2\">`AND_CATCH_ALL`</ph> block to shift processing to the next outer exception frame.","pos":[10710,10825],"source":" Call the `THROW_LAST` macro within the `AND_CATCH_ALL` block to shift processing to the next outer exception frame."},{"content":"marks the end of the preceding <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`AND_CATCH_ALL`</ph> block.","pos":[10842,10908],"source":" marks the end of the preceding **CATCH** or `AND_CATCH_ALL` block."},{"pos":[10916,11100],"content":"[!NOTE]\n The `AND_CATCH_ALL` block is defined as a C++ scope (delineated by braces). If you declare variables in this scope, remember that they are accessible only within that scope.","leadings":["","> "],"nodes":[{"content":" The `AND_CATCH_ALL` block is defined as a C++ scope (delineated by braces). If you declare variables in this scope, remember that they are accessible only within that scope.","pos":[8,182],"nodes":[{"content":"The <ph id=\"ph1\">`AND_CATCH_ALL`</ph> block is defined as a C++ scope (delineated by braces).","pos":[1,76],"source":" The `AND_CATCH_ALL` block is defined as a C++ scope (delineated by braces)."},{"content":"If you declare variables in this scope, remember that they are accessible only within that scope.","pos":[77,174]}]}]},{"pos":[11136,11145],"content":"END_CATCH"},{"pos":[11149,11206],"content":"Marks the end of the last <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`AND_CATCH`</ph> block.","source":"Marks the end of the last **CATCH** or `AND_CATCH` block."},{"content":"Remarks","pos":[11244,11251]},{"pos":[11255,11371],"content":"For more information on the <ph id=\"ph1\">`END_CATCH`</ph> macro, see the article <bpt id=\"p1\">[</bpt>Exceptions<ept id=\"p1\">](../../mfc/exception-handling-in-mfc.md)</ept>.","source":"For more information on the `END_CATCH` macro, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md)."},{"pos":[11411,11424],"content":"END_CATCH_ALL"},{"pos":[11428,11491],"content":"Marks the end of the last <ph id=\"ph1\">`CATCH_ALL`</ph> or <ph id=\"ph2\">`AND_CATCH_ALL`</ph> block.","source":"Marks the end of the last `CATCH_ALL` or `AND_CATCH_ALL` block."},{"pos":[11555,11566],"content":"THROW (MFC)"},{"content":"Throws the specified exception.","pos":[11570,11601]},{"content":"Parameters","pos":[11660,11670]},{"content":"exception_object_pointer","pos":[11675,11699]},{"content":"Points to an exception object derived from <ph id=\"ph1\">`CException`</ph>.","pos":[11704,11760],"source":" Points to an exception object derived from `CException`."},{"content":"Remarks","pos":[11770,11777]},{"content":"<bpt id=\"p1\">**</bpt>THROW<ept id=\"p1\">**</ept> interrupts program execution, passing control to the associated <bpt id=\"p2\">**</bpt>CATCH<ept id=\"p2\">**</ept> block in your program.","pos":[11781,11887],"source":"**THROW** interrupts program execution, passing control to the associated **CATCH** block in your program."},{"content":"If you have not provided the <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> block, then control is passed to a Microsoft Foundation Class Library module that prints an error message and exits.","pos":[11888,12043],"source":" If you have not provided the **CATCH** block, then control is passed to a Microsoft Foundation Class Library module that prints an error message and exits."},{"pos":[12050,12141],"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Exceptions<ept id=\"p1\">](../../mfc/exception-handling-in-mfc.md)</ept>.","source":"For more information, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md)."},{"pos":[12178,12188],"content":"THROW_LAST"},{"pos":[12192,12252],"content":"Throws the exception back to the next outer <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> block.","source":"Throws the exception back to the next outer **CATCH** block."},{"content":"Remarks","pos":[12294,12301]},{"content":"This macro allows you to throw a locally created exception.","pos":[12305,12364]},{"content":"If you try to throw an exception that you have just caught, it will normally go out of scope and be deleted.","pos":[12365,12473]},{"content":"With <ph id=\"ph1\">`THROW_LAST`</ph>, the exception is passed correctly to the next <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> handler.","pos":[12474,12557],"source":" With `THROW_LAST`, the exception is passed correctly to the next **CATCH** handler."},{"pos":[12564,12655],"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Exceptions<ept id=\"p1\">](../../mfc/exception-handling-in-mfc.md)</ept>.","source":"For more information, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md)."},{"content":"Example","pos":[12665,12672]},{"pos":[12676,12760],"content":"See the example for <bpt id=\"p1\">[</bpt>CFile::Abort<ept id=\"p1\">](../../mfc/reference/cfile-class.md#cfile__abort)</ept>.","source":"See the example for [CFile::Abort](../../mfc/reference/cfile-class.md#cfile__abort)."},{"pos":[12811,12835],"content":"AfxThrowArchiveException"},{"content":"Throws an archive exception.","pos":[12839,12867]},{"content":"Parameters","pos":[12962,12972]},{"content":"Specifies an integer that indicates the reason for the exception.","pos":[12987,13052]},{"content":"For a list of the possible values, see <bpt id=\"p1\">[</bpt>CArchiveException::m_cause<ept id=\"p1\">](../../mfc/reference/carchiveexception-class.md#carchiveexception__m_cause)</ept>.","pos":[13053,13196],"source":" For a list of the possible values, see [CArchiveException::m_cause](../../mfc/reference/carchiveexception-class.md#carchiveexception__m_cause)."},{"content":"Points to a string containing the name of the <ph id=\"ph1\">`CArchive`</ph> object that caused the exception (if available).","pos":[13224,13329],"source":" Points to a string containing the name of the `CArchive` object that caused the exception (if available)."},{"pos":[13377,13398],"content":"AfxThrowFileException"},{"content":"Throws a file exception.","pos":[13402,13426]},{"content":"Parameters","pos":[13558,13568]},{"content":"Specifies an integer that indicates the reason for the exception.","pos":[13583,13648]},{"content":"For a list of the possible values, see <bpt id=\"p1\">[</bpt>CFileException::m_cause<ept id=\"p1\">](../../mfc/reference/cfileexception-class.md#cfileexception__m_cause)</ept>.","pos":[13649,13783],"source":" For a list of the possible values, see [CFileException::m_cause](../../mfc/reference/cfileexception-class.md#cfileexception__m_cause)."},{"content":"Contains the operating-system error number (if available) that states the reason for the exception.","pos":[13804,13903]},{"content":"See your operating-system manual for a listing of error codes.","pos":[13904,13966]},{"content":"Points to a string containing the name of the file that caused the exception (if available).","pos":[13991,14083]},{"content":"Remarks","pos":[14093,14100]},{"content":"You are responsible for determining the cause based on the operating-system error code.","pos":[14104,14191]},{"pos":[14241,14264],"content":"AfxThrowMemoryException"},{"content":"Throws a memory exception.","pos":[14268,14294]},{"content":"Remarks","pos":[14353,14360]},{"content":"Call this function if calls to underlying system memory allocators (such as <ph id=\"ph1\">`malloc`</ph> and the <bpt id=\"p1\">[</bpt>GlobalAlloc<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/aa366574)</ept> Windows function) fail.","pos":[14364,14554],"source":"Call this function if calls to underlying system memory allocators (such as `malloc` and the [GlobalAlloc](http://msdn.microsoft.com/library/windows/desktop/aa366574) Windows function) fail."},{"content":"You do not need to call it for <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> because <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> will throw a memory exception automatically if the memory allocation fails.","pos":[14555,14685],"source":" You do not need to call it for **new** because **new** will throw a memory exception automatically if the memory allocation fails."},{"pos":[14741,14770],"content":"AfxThrowNotSupportedException"},{"content":"Throws an exception that is the result of a request for an unsupported feature.","pos":[14774,14853]},{"pos":[14959,14984],"content":"AfxThrowResourceException"},{"content":"Throws a resource exception.","pos":[14988,15016]},{"content":"Remarks","pos":[15078,15085]},{"content":"This function is normally called when a Windows resource cannot be loaded.","pos":[15089,15163]},{"pos":[15211,15232],"content":"AfxThrowUserException"},{"content":"Throws an exception to stop an end-user operation.","pos":[15236,15286]},{"content":"Remarks","pos":[15343,15350]},{"pos":[15354,15455],"content":"This function is normally called immediately after <ph id=\"ph1\">`AfxMessageBox`</ph> has reported an error to the user.","source":"This function is normally called immediately after `AfxMessageBox` has reported an error to the user."},{"pos":[15510,15538],"content":"AfxThrowOleDispatchException"},{"content":"Use this function to throw an exception within an OLE automation function.","pos":[15542,15616]},{"content":"Parameters","pos":[15869,15879]},{"content":"An error code specific to your application.","pos":[15894,15937]},{"content":"Verbal description of the error.","pos":[15965,15997]},{"content":"Resource ID for the verbal error description.","pos":[16024,16069]},{"content":"A help context for your application's help (.HLP) file.","pos":[16089,16144]},{"content":"Remarks","pos":[16154,16161]},{"content":"The information provided to this function can be displayed by the driving application (Microsoft Visual Basic or another OLE automation client application).","pos":[16165,16321]},{"content":"Example","pos":[16331,16338]},{"pos":[16353,16373],"content":"NVC_MFCExceptions#25"},{"pos":[16476,16496],"content":"AfxThrowOleException"},{"pos":[16500,16566],"content":"Creates an object of type <ph id=\"ph1\">`COleException`</ph> and throws an exception.","source":"Creates an object of type `COleException` and throws an exception."},{"content":"Parameters","pos":[16681,16691]},{"content":"An OLE status code that indicates the reason for the exception.","pos":[16703,16766]},{"content":"Handle to a result code that indicates the reason for the exception.","pos":[16781,16849]},{"content":"Remarks","pos":[16859,16866]},{"content":"The version that takes an <ph id=\"ph1\">`HRESULT`</ph> as an argument converts that result code into the corresponding <ph id=\"ph2\">`SCODE`</ph>.","pos":[16870,16978],"source":"The version that takes an `HRESULT` as an argument converts that result code into the corresponding `SCODE`."},{"content":"For more information on <ph id=\"ph1\">`HRESULT`</ph> and <ph id=\"ph2\">`SCODE`</ph>, see <bpt id=\"p1\">[</bpt>Structure of COM Error Codes<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms690088)</ept> in the <ph id=\"ph3\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[16979,17180],"source":" For more information on `HRESULT` and `SCODE`, see [Structure of COM Error Codes](http://msdn.microsoft.com/library/windows/desktop/ms690088) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[17227,17247],"content":"AfxThrowDaoException"},{"pos":[17251,17379],"content":"Call this function to throw an exception of type <bpt id=\"p1\">[</bpt>CDaoException<ept id=\"p1\">](../../mfc/reference/cdaoexception-class.md)</ept> from your own code.","source":"Call this function to throw an exception of type [CDaoException](../../mfc/reference/cdaoexception-class.md) from your own code."},{"content":"Parameters","pos":[17508,17518]},{"content":"An integer value representing a DAO extended error code, which can be one of the values listed under <bpt id=\"p1\">[</bpt>CDaoException::m_nAfxDaoError<ept id=\"p1\">](../../mfc/reference/cdaoexception-class.md#cdaoexception__m_nafxdaoerror)</ept>.","pos":[17540,17747],"source":" An integer value representing a DAO extended error code, which can be one of the values listed under [CDaoException::m_nAfxDaoError](../../mfc/reference/cdaoexception-class.md#cdaoexception__m_nafxdaoerror)."},{"content":"scode","pos":[17755,17760]},{"content":"An OLE error code from DAO, of type <ph id=\"ph1\">`SCODE`</ph>.","pos":[17765,17809],"source":" An OLE error code from DAO, of type `SCODE`."},{"content":"For information, see <bpt id=\"p1\">[</bpt>CDaoException::m_scode<ept id=\"p1\">](../../mfc/reference/cdaoexception-class.md#cdaoexception__m_scode)</ept>.","pos":[17810,17923],"source":" For information, see [CDaoException::m_scode](../../mfc/reference/cdaoexception-class.md#cdaoexception__m_scode)."},{"content":"Remarks","pos":[17933,17940]},{"content":"The framework also calls <ph id=\"ph1\">`AfxThrowDaoException`</ph>.","pos":[17944,17992],"source":"The framework also calls `AfxThrowDaoException`."},{"content":"In your call, you can pass one of the parameters or both.","pos":[17993,18050]},{"content":"For example, if you want to raise one of the errors defined in <bpt id=\"p1\">**</bpt>CDaoException::nAfxDaoError<ept id=\"p1\">**</ept> but you do not care about the <bpt id=\"p2\">*</bpt>scode<ept id=\"p2\">*</ept> parameter, pass a valid code in the <ph id=\"ph1\">`nAfxDaoError`</ph> parameter and accept the default value for <bpt id=\"p3\">*</bpt>scode<ept id=\"p3\">*</ept>.","pos":[18051,18286],"source":" For example, if you want to raise one of the errors defined in **CDaoException::nAfxDaoError** but you do not care about the *scode* parameter, pass a valid code in the `nAfxDaoError` parameter and accept the default value for *scode*."},{"pos":[18293,18492],"content":"For information about exceptions related to the MFC DAO classes, see class <ph id=\"ph1\">`CDaoException`</ph> in this book and the article <bpt id=\"p1\">[</bpt>Exceptions: Database Exceptions<ept id=\"p1\">](../../mfc/exceptions-database-exceptions.md)</ept>.","source":"For information about exceptions related to the MFC DAO classes, see class `CDaoException` in this book and the article [Exceptions: Database Exceptions](../../mfc/exceptions-database-exceptions.md)."},{"pos":[18538,18557],"content":"AfxThrowDBException"},{"pos":[18561,18644],"content":"Call this function to throw an exception of type <ph id=\"ph1\">`CDBException`</ph> from your own code.","source":"Call this function to throw an exception of type `CDBException` from your own code."},{"content":"Parameters","pos":[18762,18772]},{"content":"A value of type <bpt id=\"p1\">**</bpt>RETCODE<ept id=\"p1\">**</ept>, defining the type of error that caused the exception to be thrown.","pos":[18790,18885],"source":" A value of type **RETCODE**, defining the type of error that caused the exception to be thrown."},{"content":"A pointer to the <ph id=\"ph1\">`CDatabase`</ph> object that represents the data source connection with which the exception is associated.","pos":[18901,19019],"source":" A pointer to the `CDatabase` object that represents the data source connection with which the exception is associated."},{"content":"An ODBC <bpt id=\"p1\">**</bpt>HSTMT<ept id=\"p1\">**</ept> handle that specifies the statement handle with which the exception is associated.","pos":[19037,19137],"source":" An ODBC **HSTMT** handle that specifies the statement handle with which the exception is associated."},{"content":"Remarks","pos":[19147,19154]},{"content":"The framework calls <ph id=\"ph1\">`AfxThrowDBException`</ph> when it receives an ODBC <bpt id=\"p1\">**</bpt>RETCODE<ept id=\"p1\">**</ept> from a call to an ODBC API function and interprets the <bpt id=\"p2\">**</bpt>RETCODE<ept id=\"p2\">**</ept> as an exceptional condition rather than an expectable error.","pos":[19158,19364],"source":"The framework calls `AfxThrowDBException` when it receives an ODBC **RETCODE** from a call to an ODBC API function and interprets the **RETCODE** as an exceptional condition rather than an expectable error."},{"content":"For example, a data access operation might fail because of a disk read error.","pos":[19365,19442]},{"content":"For information about the <bpt id=\"p1\">**</bpt>RETCODE<ept id=\"p1\">**</ept> values defined by ODBC, see Chapter 8, \"Retrieving Status and Error Information,\" in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[19449,19628],"source":"For information about the **RETCODE** values defined by ODBC, see Chapter 8, \"Retrieving Status and Error Information,\" in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"For information about MFC extensions to these codes, see class <bpt id=\"p1\">[</bpt>CDBException<ept id=\"p1\">](../../mfc/reference/cdbexception-class.md)</ept>.","pos":[19629,19750],"source":" For information about MFC extensions to these codes, see class [CDBException](../../mfc/reference/cdbexception-class.md)."},{"pos":[19785,19793],"content":"AfxAbort"},{"content":"The default termination function supplied by MFC.","pos":[19797,19846]},{"content":"Remarks","pos":[19891,19898]},{"content":"is called internally by MFC member functions when there is a fatal error, such as an uncaught exception that cannot be handled.","pos":[19913,20040]},{"content":"You can call <ph id=\"ph1\">`AfxAbort`</ph> in the rare case when you encounter a catastrophic error from which you cannot recover.","pos":[20041,20152],"source":" You can call `AfxAbort` in the rare case when you encounter a catastrophic error from which you cannot recover."},{"content":"Example","pos":[20162,20169]},{"pos":[20173,20209],"content":"See the example for <bpt id=\"p1\">[</bpt>CATCH<ept id=\"p1\">](#catch)</ept>.","source":"See the example for [CATCH](#catch)."},{"content":"See Also","pos":[20218,20226]},{"content":"Macros and Globals","pos":[20231,20249]},{"content":"CException Class","pos":[20303,20319]}],"content":"---\ntitle: \"Exception Processing | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mfc.macros.exceptions\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"macros, exception handling\"\n  - \"DAO (Data Access Objects), exceptions\"\n  - \"OLE exceptions, MFC functions\"\n  - \"exceptions, processing\"\n  - \"exception macros\"\n  - \"termination functions, MFC\"\n  - \"MFC, exceptions\"\n  - \"exceptions, MFC throwing functions\"\nms.assetid: 26d4457c-8350-48f5-916e-78f919787c30\ncaps.latest.revision: 16\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Exception Processing\nWhen a program executes, a number of abnormal conditions and errors called \"exceptions\" can occur. These may include running out of memory, resource allocation errors, and failure to find files.  \n  \n The Microsoft Foundation Class Library uses an exception-handling scheme that is modeled closely after the one proposed by the ANSI standards committee for C++. An exception handler must be set up before calling a function that may encounter an abnormal situation. If the function encounters an abnormal condition, it throws an exception and control is passed to the exception handler.  \n  \n Several macros included with the Microsoft Foundation Class Library will set up exception handlers. A number of other global functions help to throw specialized exceptions and terminate programs, if necessary. These macros and global functions fall into the following categories:  \n  \n- Exception macros, which structure your exception handler.  \n  \n- Exception-throwing functions), which generate exceptions of specific types.  \n  \n- Termination functions, which cause program termination.  \n  \n For examples and more details, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md).  \n  \n### Exception Macros  \n  \n|||  \n|-|-|  \n|[TRY](#try)|Designates a block of code for exception processing.|  \n|[CATCH](#catch)|Designates a block of code for catching an exception from the preceding **TRY** block.|  \n|[CATCH_ALL](#catch_all)|Designates a block of code for catching all exceptions from the preceding **TRY** block.|  \n|[AND_CATCH](#and_catch)|Designates a block of code for catching additional exception types from the preceding **TRY** block.|  \n|[AND_CATCH_ALL](#and_catch_all)|Designates a block of code for catching all other additional exception types thrown in a preceding **TRY** block.|  \n|[END_CATCH](#end_catch)|Ends the last **CATCH** or `AND_CATCH` code block.|  \n|[END_CATCH_ALL](#end_catch_all)|Ends the last `CATCH_ALL` code block.|  \n|[THROW](#throw)|Throws a specified exception.|  \n|[THROW_LAST](#throw_last)|Throws the currently handled exception to the next outer handler.|  \n  \n### Exception-Throwing Functions  \n  \n|||  \n|-|-|  \n|[AfxThrowArchiveException](#afxthrowarchiveexception)|Throws an archive exception.|  \n|[AfxThrowFileException](#afxthrowfileexception)|Throws a file exception.|  \n|[AfxThrowMemoryException](#afxthrowmemoryexception)|Throws a memory exception.|  \n|[AfxThrowNotSupportedException](#afxthrownotsupportedexception)|Throws a not-supported exception.|  \n|[AfxThrowResourceException](#afxthrowresourceexception)|Throws a Windows resource-not-found exception.|  \n|[AfxThrowUserException](#afxthrowuserexception)|Throws an exception in a user-initiated program action.|  \n  \n MFC provides two exception-throwing functions specifically for OLE exceptions:  \n  \n### OLE Exception Functions  \n  \n|||  \n|-|-|  \n|[AfxThrowOleDispatchException](#afxthrowoledispatchexception)|Throws an exception within an OLE automation function.|  \n|[AfxThrowOleException](#afxthrowoleexception)|Throws an OLE exception.|  \n  \n To support database exceptions, the database classes provide two exception classes, `CDBException` and `CDaoException`, and global functions to support the exception types:  \n  \n### DAO Exception Functions  \n  \n|||  \n|-|-|  \n|[AfxThrowDAOException](#afxthrowdaoexception)|Throws a [CDaoException](../../mfc/reference/cdaoexception-class.md) from your own code.|  \n|[AfxThrowDBException](#afxthrowdbexception)|Throws a [CDBException](../../mfc/reference/cdbexception-class.md) from your own code.|  \n  \n MFC provides the following termination function:  \n  \n### Termination Functions  \n  \n|||  \n|-|-|  \n|[AfxAbort](#afxabort)|Called to terminate an application when a fatal error occurs.|  \n  \n##  <a name=\"try\"></a>  TRY  \n Sets up a **TRY** block.  \n  \n```   \nTRY   \n```  \n  \n### Remarks  \n A **TRY** block identifies a block of code that might throw exceptions. Those exceptions are handled in the following **CATCH** and `AND_CATCH` blocks. Recursion is allowed: exceptions may be passed to an outer **TRY** block, either by ignoring them or by using the `THROW_LAST` macro. End the **TRY** block with an `END_CATCH` or `END_CATCH_ALL` macro.  \n  \n For more information, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md).  \n  \n### Example  \n See the example for [CATCH](#catch).  \n  \n##  <a name=\"catch\"></a>  CATCH  \n Defines a block of code that catches the first exception type thrown in the preceding **TRY** block.  \n  \n```   \nCATCH(exception_class, exception_object_pointer_name)  \n \n```  \n  \n### Parameters  \n *exception_class*  \n Specifies the exception type to test for. For a list of standard exception classes, see class [CException](../../mfc/reference/cexception-class.md).  \n  \n *exception_object_pointer_name*  \n Specifies a name for an exception-object pointer that will be created by the macro. You can use the pointer name to access the exception object within the **CATCH** block. This variable is declared for you.  \n  \n### Remarks  \n The exception-processing code can interrogate the exception object, if appropriate, to get more information about the specific cause of the exception. Invoke the `THROW_LAST` macro to shift processing to the next outer exception frame. End the **TRY** block with an `END_CATCH` macro.  \n  \n If *exception_class* is the class `CException`, then all exception types will be caught. You can use the [CObject::IsKindOf](../../mfc/reference/cobject-class.md#cobject__iskindof) member function to determine which specific exception was thrown. A better way to catch several kinds of exceptions is to use sequential `AND_CATCH` statements, each with a different exception type.  \n  \n The exception object pointer is created by the macro. You do not need to declare it yourself.  \n  \n> [!NOTE]\n>  The **CATCH** block is defined as a C++ scope delineated by braces. If you declare variables in this scope, they are accessible only within that scope. This also applies to *exception_object_pointer_name*.  \n  \n For more information on exceptions and the **CATCH** macro, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md).  \n  \n### Example  \n [!code-cpp[NVC_MFCExceptions#26](../../mfc/codesnippet/cpp/exception-processing_1.cpp)]  \n  \n##  <a name=\"catch_all\"></a>  CATCH_ALL  \n Defines a block of code that catches all exception types thrown in the preceding **TRY** block.  \n  \n```   \nCATCH_ALL(exception_object_pointer_name)   \n```  \n  \n### Parameters  \n *exception_object_pointer_name*  \n Specifies a name for an exception-object pointer that will be created by the macro. You can use the pointer name to access the exception object within the `CATCH_ALL` block. This variable is declared for you.  \n  \n### Remarks  \n The exception-processing code can interrogate the exception object, if appropriate, to get more information about the specific cause of the exception. Invoke the `THROW_LAST` macro to shift processing to the next outer exception frame. If you use `CATCH_ALL`, end the **TRY** block with an `END_CATCH_ALL` macro.  \n  \n> [!NOTE]\n>  The `CATCH_ALL` block is defined as a C++ scope delineated by braces. If you declare variables in this scope, they are accessible only within that scope.  \n  \n For more information on exceptions, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md).  \n  \n### Example  \n See the example for [CFile::Abort](../../mfc/reference/cfile-class.md#cfile__abort).  \n  \n##  <a name=\"and_catch\"></a>  AND_CATCH  \n Defines a block of code for catching additional exception types thrown in a preceding **TRY** block.  \n  \n```   \nAND_CATCH(exception_class, exception_object_pointer_name)   \n```  \n  \n### Parameters  \n *exception_class*  \n Specifies the exception type to test for. For a list of standard exception classes, see class [CException](../../mfc/reference/cexception-class.md).  \n  \n *exception_object_pointer_name*  \n A name for an exception-object pointer that will be created by the macro. You can use the pointer name to access the exception object within the `AND_CATCH` block. This variable is declared for you.  \n  \n### Remarks  \n Use the **CATCH** macro to catch one exception type, then the `AND_CATCH` macro to catch each subsequent type. End the **TRY** block with an `END_CATCH` macro.  \n  \n The exception-processing code can interrogate the exception object, if appropriate, to get more information about the specific cause of the exception. Call the `THROW_LAST` macro within the `AND_CATCH` block to shift processing to the next outer exception frame. `AND_CATCH` marks the end of the preceding **CATCH** or `AND_CATCH` block.  \n  \n> [!NOTE]\n>  The `AND_CATCH` block is defined as a C++ scope (delineated by curly braces). If you declare variables in this scope, remember that they are accessible only within that scope. This also applies to the *exception_object_pointer_name* variable.  \n  \n### Example  \n See the example for [CATCH](#catch).  \n  \n##  <a name=\"and_catch_all\"></a>  AND_CATCH_ALL  \n Defines a block of code for catching additional exception types thrown in a preceding **TRY** block.  \n  \n```   \nAND_CATCH_ALL(exception_object_pointer_name)  \n```  \n  \n### Parameters  \n *exception_object_pointer_name*  \n A name for an exception-object pointer that will be created by the macro. You can use the pointer name to access the exception object within the `AND_CATCH_ALL` block. This variable is declared for you.  \n  \n### Remarks  \n Use the **CATCH** macro to catch one exception type, then the `AND_CATCH_ALL` macro to catch all other subsequent types. If you use `AND_CATCH_ALL`, end the **TRY** block with an `END_CATCH_ALL` macro.  \n  \n The exception-processing code can interrogate the exception object, if appropriate, to get more information about the specific cause of the exception. Call the `THROW_LAST` macro within the `AND_CATCH_ALL` block to shift processing to the next outer exception frame. `AND_CATCH_ALL` marks the end of the preceding **CATCH** or `AND_CATCH_ALL` block.  \n  \n> [!NOTE]\n>  The `AND_CATCH_ALL` block is defined as a C++ scope (delineated by braces). If you declare variables in this scope, remember that they are accessible only within that scope.  \n  \n##  <a name=\"end_catch\"></a>  END_CATCH  \n Marks the end of the last **CATCH** or `AND_CATCH` block.  \n  \n```   \nEND_CATCH  \n```  \n  \n### Remarks  \n For more information on the `END_CATCH` macro, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md).  \n  \n##  <a name=\"end_catch_all\"></a>  END_CATCH_ALL  \n Marks the end of the last `CATCH_ALL` or `AND_CATCH_ALL` block.  \n  \n```   \nEND_CATCH_ALL  \n```  \n  \n##  <a name=\"throw\"></a>  THROW (MFC)  \n Throws the specified exception.  \n  \n```   \nTHROW(exception_object_pointer) \n```  \n  \n### Parameters  \n *exception_object_pointer*  \n Points to an exception object derived from `CException`.  \n  \n### Remarks  \n **THROW** interrupts program execution, passing control to the associated **CATCH** block in your program. If you have not provided the **CATCH** block, then control is passed to a Microsoft Foundation Class Library module that prints an error message and exits.  \n  \n For more information, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md).  \n  \n##  <a name=\"throw_last\"></a>  THROW_LAST  \n Throws the exception back to the next outer **CATCH** block.  \n  \n```   \nTHROW_LAST()   \n```  \n  \n### Remarks  \n This macro allows you to throw a locally created exception. If you try to throw an exception that you have just caught, it will normally go out of scope and be deleted. With `THROW_LAST`, the exception is passed correctly to the next **CATCH** handler.  \n  \n For more information, see the article [Exceptions](../../mfc/exception-handling-in-mfc.md).  \n  \n### Example  \n See the example for [CFile::Abort](../../mfc/reference/cfile-class.md#cfile__abort).  \n  \n##  <a name=\"afxthrowarchiveexception\"></a>  AfxThrowArchiveException  \n Throws an archive exception.  \n  \n```   \nvoid  AfxThrowArchiveException(int cause, LPCTSTR lpszArchiveName); \n```  \n  \n### Parameters  \n `cause`  \n Specifies an integer that indicates the reason for the exception. For a list of the possible values, see [CArchiveException::m_cause](../../mfc/reference/carchiveexception-class.md#carchiveexception__m_cause).  \n  \n `lpszArchiveName`  \n Points to a string containing the name of the `CArchive` object that caused the exception (if available).  \n  \n##  <a name=\"afxthrowfileexception\"></a>  AfxThrowFileException  \n Throws a file exception.  \n  \n```   \nvoid AfxThrowFileException(\n    int cause,  \n    LONG lOsError = -1,  \n    LPCTSTR lpszFileName = NULL); \n```  \n  \n### Parameters  \n `cause`  \n Specifies an integer that indicates the reason for the exception. For a list of the possible values, see [CFileException::m_cause](../../mfc/reference/cfileexception-class.md#cfileexception__m_cause).  \n  \n `lOsError`  \n Contains the operating-system error number (if available) that states the reason for the exception. See your operating-system manual for a listing of error codes.  \n  \n `lpszFileName`  \n Points to a string containing the name of the file that caused the exception (if available).  \n  \n### Remarks  \n You are responsible for determining the cause based on the operating-system error code.  \n  \n##  <a name=\"afxthrowmemoryexception\"></a>  AfxThrowMemoryException  \n Throws a memory exception.  \n  \n```   \nvoid AfxThrowMemoryException(); \n```  \n  \n### Remarks  \n Call this function if calls to underlying system memory allocators (such as `malloc` and the [GlobalAlloc](http://msdn.microsoft.com/library/windows/desktop/aa366574) Windows function) fail. You do not need to call it for **new** because **new** will throw a memory exception automatically if the memory allocation fails.  \n  \n##  <a name=\"afxthrownotsupportedexception\"></a>  AfxThrowNotSupportedException  \n Throws an exception that is the result of a request for an unsupported feature.  \n  \n```  \nvoid AfxThrowNotSupportedException(); \n```  \n  \n##  <a name=\"afxthrowresourceexception\"></a>  AfxThrowResourceException  \n Throws a resource exception.  \n  \n```   \nvoid  AfxThrowResourceException(); \n```  \n  \n### Remarks  \n This function is normally called when a Windows resource cannot be loaded.  \n  \n##  <a name=\"afxthrowuserexception\"></a>  AfxThrowUserException  \n Throws an exception to stop an end-user operation.  \n  \n```   \nvoid AfxThrowUserException(); \n```  \n  \n### Remarks  \n This function is normally called immediately after `AfxMessageBox` has reported an error to the user.  \n  \n##  <a name=\"afxthrowoledispatchexception\"></a>  AfxThrowOleDispatchException  \n Use this function to throw an exception within an OLE automation function.  \n  \n```   \nvoid AFXAPI AfxThrowOleDispatchException(\n    WORD wCode ,  \n    LPCSTR lpszDescription,  \n    UINT nHelpID = 0);\n\nvoid AFXAPI AfxThrowOleDispatchException(\n    WORD wCode,  \n    UINT nDescriptionID,  \n    UINT nHelpID = -1); \n```  \n  \n### Parameters  \n `wCode`  \n An error code specific to your application.  \n  \n `lpszDescription`  \n Verbal description of the error.  \n  \n `nDescriptionID`  \n Resource ID for the verbal error description.  \n  \n `nHelpID`  \n A help context for your application's help (.HLP) file.  \n  \n### Remarks  \n The information provided to this function can be displayed by the driving application (Microsoft Visual Basic or another OLE automation client application).  \n  \n### Example  \n [!code-cpp[NVC_MFCExceptions#25](../../mfc/codesnippet/cpp/exception-processing_2.cpp)]  \n  \n##  <a name=\"afxthrowoleexception\"></a>  AfxThrowOleException  \n Creates an object of type `COleException` and throws an exception.  \n  \n``` \nvoid AFXAPI AfxThrowOleException(SCODE sc);\nvoid AFXAPI AfxThrowOleException(HRESULT hr); \n```  \n  \n### Parameters  \n `sc`  \n An OLE status code that indicates the reason for the exception.  \n  \n `hr`  \n Handle to a result code that indicates the reason for the exception.  \n  \n### Remarks  \n The version that takes an `HRESULT` as an argument converts that result code into the corresponding `SCODE`. For more information on `HRESULT` and `SCODE`, see [Structure of COM Error Codes](http://msdn.microsoft.com/library/windows/desktop/ms690088) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"afxthrowdaoexception\"></a>  AfxThrowDaoException  \n Call this function to throw an exception of type [CDaoException](../../mfc/reference/cdaoexception-class.md) from your own code.  \n  \n```   \nvoid AFXAPI AfxThrowDaoException(\n    int nAfxDaoError = NO_AFX_DAO_ERROR,  \n    SCODE scode = S_OK); \n```  \n  \n### Parameters  \n `nAfxDaoError`  \n An integer value representing a DAO extended error code, which can be one of the values listed under [CDaoException::m_nAfxDaoError](../../mfc/reference/cdaoexception-class.md#cdaoexception__m_nafxdaoerror).  \n  \n *scode*  \n An OLE error code from DAO, of type `SCODE`. For information, see [CDaoException::m_scode](../../mfc/reference/cdaoexception-class.md#cdaoexception__m_scode).  \n  \n### Remarks  \n The framework also calls `AfxThrowDaoException`. In your call, you can pass one of the parameters or both. For example, if you want to raise one of the errors defined in **CDaoException::nAfxDaoError** but you do not care about the *scode* parameter, pass a valid code in the `nAfxDaoError` parameter and accept the default value for *scode*.  \n  \n For information about exceptions related to the MFC DAO classes, see class `CDaoException` in this book and the article [Exceptions: Database Exceptions](../../mfc/exceptions-database-exceptions.md).  \n  \n##  <a name=\"afxthrowdbexception\"></a>  AfxThrowDBException  \n Call this function to throw an exception of type `CDBException` from your own code.  \n  \n```  \nvoid AfxThrowDBException(\n    RETCODE nRetCode,  \n    CDatabase* pdb,  \n    HSTMT hstmt);\n\n \n```  \n  \n### Parameters  \n `nRetCode`  \n A value of type **RETCODE**, defining the type of error that caused the exception to be thrown.  \n  \n `pdb`  \n A pointer to the `CDatabase` object that represents the data source connection with which the exception is associated.  \n  \n `hstmt`  \n An ODBC **HSTMT** handle that specifies the statement handle with which the exception is associated.  \n  \n### Remarks  \n The framework calls `AfxThrowDBException` when it receives an ODBC **RETCODE** from a call to an ODBC API function and interprets the **RETCODE** as an exceptional condition rather than an expectable error. For example, a data access operation might fail because of a disk read error.  \n  \n For information about the **RETCODE** values defined by ODBC, see Chapter 8, \"Retrieving Status and Error Information,\" in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. For information about MFC extensions to these codes, see class [CDBException](../../mfc/reference/cdbexception-class.md).  \n  \n##  <a name=\"afxabort\"></a>  AfxAbort  \n The default termination function supplied by MFC.  \n  \n```   \nvoid  AfxAbort(); \n```  \n  \n### Remarks  \n `AfxAbort` is called internally by MFC member functions when there is a fatal error, such as an uncaught exception that cannot be handled. You can call `AfxAbort` in the rare case when you encounter a catastrophic error from which you cannot recover.  \n  \n### Example  \n See the example for [CATCH](#catch).  \n  \n## See Also  \n [Macros and Globals](../../mfc/reference/mfc-macros-and-globals.md)   \n [CException Class](../../mfc/reference/cexception-class.md)\n"}