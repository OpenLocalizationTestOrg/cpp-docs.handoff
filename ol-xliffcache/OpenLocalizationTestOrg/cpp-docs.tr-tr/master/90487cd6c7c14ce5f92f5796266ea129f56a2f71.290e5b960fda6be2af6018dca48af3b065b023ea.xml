{"nodes":[{"pos":[12,50],"content":"Class Member Overview | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Class Member Overview | Microsoft Docs","pos":[0,38]}]},{"content":"Class Member Overview","pos":[665,686]},{"content":"A class or struct consists of its members.","pos":[687,729]},{"content":"The work that a class does is performed by its member functions.","pos":[730,794]},{"content":"The state that it maintains is stored in its data members.","pos":[795,853]},{"content":"Initialization of members is done by constructors, and cleanup work such as freeing of memory and releasing of resources is done by constructors.","pos":[854,999]},{"content":"In C++11 and later, data members can (and usually should) be initialized at the point of declaration.","pos":[1000,1101]},{"content":"Kinds of class members","pos":[1110,1132]},{"content":"The full list of member categories is as follows:","pos":[1136,1185]},{"content":"Special Member functions.","pos":[1195,1220]},{"pos":[1230,1294],"content":"<bpt id=\"p1\">[</bpt>Overview of Member Functions<ept id=\"p1\">](overview-of-member-functions.md)</ept>.","source":"[Overview of Member Functions](overview-of-member-functions.md)."},{"pos":[1304,1396],"content":"<bpt id=\"p1\">[</bpt>Data members<ept id=\"p1\">](static-members-cpp.md)</ept> including built-in types and other user defined types.","source":"[Data members](static-members-cpp.md) including built-in types and other user defined types."},{"content":"Operators","pos":[1406,1415]},{"pos":[1425,1488],"content":"<bpt id=\"p1\">[</bpt>Nested Class Declarations<ept id=\"p1\">](nested-class-declarations.md)</ept> and.)","source":"[Nested Class Declarations](nested-class-declarations.md) and.)"},{"content":"Unions","pos":[1499,1505]},{"pos":[1527,1570],"content":"<bpt id=\"p1\">[</bpt>Enumerations<ept id=\"p1\">](../cpp/enumerations-cpp.md)</ept>.","source":"[Enumerations](../cpp/enumerations-cpp.md)."},{"pos":[1580,1619],"content":"<bpt id=\"p1\">[</bpt>Bit fields<ept id=\"p1\">](../cpp/cpp-bit-fields.md)</ept>.","source":"[Bit fields](../cpp/cpp-bit-fields.md)."},{"pos":[1629,1661],"content":"<bpt id=\"p1\">[</bpt>Friends<ept id=\"p1\">](../cpp/friend-cpp.md)</ept>.","source":"[Friends](../cpp/friend-cpp.md)."},{"pos":[1671,1730],"content":"<bpt id=\"p1\">[</bpt>Aliases and typedefs<ept id=\"p1\">](../cpp/aliases-and-typedefs-cpp.md)</ept>.","source":"[Aliases and typedefs](../cpp/aliases-and-typedefs-cpp.md)."},{"pos":[1742,1942],"content":"[!NOTE]\n Friends are included in the preceding list because they are contained in the class declaration. However, they are not true class members, because they are not in the scope of the class.","leadings":["","    > "],"nodes":[{"content":" Friends are included in the preceding list because they are contained in the class declaration. However, they are not true class members, because they are not in the scope of the class.","pos":[8,194],"nodes":[{"content":"Friends are included in the preceding list because they are contained in the class declaration.","pos":[1,96]},{"content":"However, they are not true class members, because they are not in the scope of the class.","pos":[97,186]}]}]},{"content":"Example class declaration","pos":[1951,1976]},{"content":"The following example shows a simple class declaration:","pos":[1980,2035]},{"content":"Member accessibility","pos":[3079,3099]},{"content":"The members of a class are declared in the member list.","pos":[3103,3158]},{"content":"The member list of a class may be divided into any number of <ph id=\"ph1\">`private`</ph>, <ph id=\"ph2\">`protected`</ph> and <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> sections using keywords known as access specifiers.","pos":[3159,3309],"source":" The member list of a class may be divided into any number of `private`, `protected` and **public** sections using keywords known as access specifiers."},{"content":"A colon <bpt id=\"p1\">**</bpt>:<ept id=\"p1\">**</ept> must follow the access specifier.","pos":[3311,3358],"source":"  A colon **:** must follow the access specifier."},{"content":"These sections need not be contiguous, that is, any of these keywords may appear several times in the member list.","pos":[3360,3474]},{"content":"The keyword designates the access of all members up until the next access specifier or the closing brace.","pos":[3476,3581]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Member Access Control (C++)<ept id=\"p1\">](../cpp/member-access-control-cpp.md)</ept>.","pos":[3582,3675],"source":" For more information, see [Member Access Control (C++)](../cpp/member-access-control-cpp.md)."},{"content":"Static members","pos":[3684,3698]},{"content":"A data member may be declared as static, which means all objects of the class have access to the same copy of it.","pos":[3702,3815]},{"content":"A member function may be declared as static, in which case it can only access static data members of the class (and has no <bpt id=\"p1\">*</bpt>this<ept id=\"p1\">*</ept> pointer).","pos":[3816,3955],"source":" A member function may be declared as static, in which case it can only access static data members of the class (and has no *this* pointer)."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Static Data Members<ept id=\"p1\">](../cpp/static-members-cpp.md)</ept>.","pos":[3956,4034],"source":" For more information, see [Static Data Members](../cpp/static-members-cpp.md)."},{"content":"Special member functions","pos":[4043,4067]},{"content":"Special member functions are functions that are automatically provided by the compiler if you do not specify them in your source code.","pos":[4071,4205]},{"content":"Default constructor","pos":[4215,4234]},{"content":"Copy constructor","pos":[4244,4260]},{"pos":[4270,4298],"content":"<bpt id=\"p1\">**</bpt>(C++11)<ept id=\"p1\">**</ept> Move constructor","source":"**(C++11)** Move constructor"},{"content":"Copy assignment operator","pos":[4308,4332]},{"pos":[4342,4378],"content":"<bpt id=\"p1\">**</bpt>(C++11)<ept id=\"p1\">**</ept> Move assignment operator","source":"**(C++11)** Move assignment operator"},{"content":"Destructor","pos":[4388,4398]},{"content":"Memberwise initialization","pos":[4407,4432]},{"content":"In C++11 and later, non-static member declarators can contain initializers.","pos":[4436,4511]},{"content":"If a member is assigned a value in a constructor, that value overwrites the value with which the member was initialized at the point of declaration.","pos":[4954,5102]},{"content":"There is only one shared copy of static data members for all objects of a given class type.","pos":[5109,5200]},{"content":"Static data members must be defined and can be initialized at file scope.","pos":[5201,5274]},{"content":"(For more information about static data members, see <bpt id=\"p1\">[</bpt>Static Data Members<ept id=\"p1\">](../cpp/static-members-cpp.md)</ept>.) The following example shows how to perform these initializations:","pos":[5275,5447],"source":" (For more information about static data members, see [Static Data Members](../cpp/static-members-cpp.md).) The following example shows how to perform these initializations:"},{"pos":[5991,6117],"content":"[!NOTE]\n The class name, `CanInit2`, must precede `i` to specify that the `i` being defined is a member of class `CanInit2`.","leadings":["","> "],"nodes":[{"content":"The class name, <ph id=\"ph1\">`CanInit2`</ph>, must precede <ph id=\"ph2\">`i`</ph> to specify that the <ph id=\"ph3\">`i`</ph> being defined is a member of class <ph id=\"ph4\">`CanInit2`</ph>.","pos":[9,124],"source":" The class name, `CanInit2`, must precede `i` to specify that the `i` being defined is a member of class `CanInit2`."}]},{"content":"See Also","pos":[6126,6134]},{"content":"Classes and Structs","pos":[6139,6158]}],"content":"---\ntitle: \"Class Member Overview | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"members, types of class members\"\n  - \"members\"\n  - \"class members, types of\"\n  - \"class members\"\nms.assetid: 8802cfa9-705d-4f37-acde-245d6838010c\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Class Member Overview\nA class or struct consists of its members. The work that a class does is performed by its member functions. The state that it maintains is stored in its data members. Initialization of members is done by constructors, and cleanup work such as freeing of memory and releasing of resources is done by constructors. In C++11 and later, data members can (and usually should) be initialized at the point of declaration.  \n  \n## Kinds of class members  \n The full list of member categories is as follows:  \n  \n-   Special Member functions.  \n  \n-   [Overview of Member Functions](overview-of-member-functions.md).  \n  \n-   [Data members](static-members-cpp.md) including built-in types and other user defined types.  \n  \n-   Operators  \n  \n-   [Nested Class Declarations](nested-class-declarations.md) and.)  \n  \n-   [Unions](unions.md)  \n  \n-   [Enumerations](../cpp/enumerations-cpp.md).  \n  \n-   [Bit fields](../cpp/cpp-bit-fields.md).  \n  \n-   [Friends](../cpp/friend-cpp.md).  \n  \n-   [Aliases and typedefs](../cpp/aliases-and-typedefs-cpp.md).  \n  \n    > [!NOTE]\n    >  Friends are included in the preceding list because they are contained in the class declaration. However, they are not true class members, because they are not in the scope of the class.  \n  \n## Example class declaration  \n The following example shows a simple class declaration:  \n  \n```  \n// TestRun.h  \n  \nclass TestRun  \n{  \n    // Start member list.  \n  \n    //The class interface accessible to all callers.  \npublic:  \n    // Use compiler-generated default constructor:  \n    TestRun() = default;   \n    // Don't generate a copy constructor:  \n    TestRun(const TestRun&) = delete;    \n    TestRun(std::string name);  \n    void DoSomething();  \n    int Calculate(int a, double d);  \n    virtual ~TestRun();  \n    enum class State { Active, Suspended };  \n  \n    // Accessible to this class and derived classes only.  \nprotected:  \n    virtual void Initialize();  \n    virtual void Suspend();  \n    State GetState();  \n  \n    // Accessible to this class only.  \nprivate:  \n    // Default brace-initialization of instance members:  \n    State _state{ State::Suspended };   \n    std::string _testName{ \"\" };   \n    int _index{ 0 };  \n  \n    // Non-const static member:  \n    static int _instances;  \n    // End member list.  \n};  \n  \n// Define and initialize static member.  \nint TestRun::_instances{ 0 };  \n```  \n  \n## Member accessibility  \n The members of a class are declared in the member list. The member list of a class may be divided into any number of `private`, `protected` and **public** sections using keywords known as access specifiers.  A colon **:** must follow the access specifier.  These sections need not be contiguous, that is, any of these keywords may appear several times in the member list.  The keyword designates the access of all members up until the next access specifier or the closing brace. For more information, see [Member Access Control (C++)](../cpp/member-access-control-cpp.md).  \n  \n## Static members  \n A data member may be declared as static, which means all objects of the class have access to the same copy of it. A member function may be declared as static, in which case it can only access static data members of the class (and has no *this* pointer). For more information, see [Static Data Members](../cpp/static-members-cpp.md).  \n  \n## Special member functions  \n Special member functions are functions that are automatically provided by the compiler if you do not specify them in your source code.  \n  \n1.  Default constructor  \n  \n2.  Copy constructor  \n  \n3.  **(C++11)** Move constructor  \n  \n4.  Copy assignment operator  \n  \n5.  **(C++11)** Move assignment operator  \n  \n6.  Destructor  \n  \n## Memberwise initialization  \n In C++11 and later, non-static member declarators can contain initializers.  \n  \n```  \n  \nclass CanInit  \n{  \npublic:  \n    long num {7};       // OK in C++11  \n    int k = 9;          // OK in C++11  \n    static int i = 9; // Error: must be defined and initialized  \n                      // outside of class declaration.  \n  \n    // initializes num to 7 and k to 9  \n    CanInit(){}  \n  \n    // overwrites original initialized value of num:  \n    CanInit(int val) : num(val) {}  \n};  \nint main()  \n{  \n}  \n```  \n  \n If a member is assigned a value in a constructor, that value overwrites the value with which the member was initialized at the point of declaration.  \n  \n There is only one shared copy of static data members for all objects of a given class type. Static data members must be defined and can be initialized at file scope. (For more information about static data members, see [Static Data Members](../cpp/static-members-cpp.md).) The following example shows how to perform these initializations:  \n  \n```  \n// class_members2.cpp  \nclass CanInit2  \n{  \npublic:  \n    CanInit2() {} // Initializes num to 7 when new objects of type   \n                 //  CanInit are created.  \n    long     num {7};  \n    static int i;  \n    static int j;  \n};  \n  \n// At file scope:  \n  \n// i is defined at file scope and initialized to 15.  \n// The initializer is evaluated in the scope of CanInit.  \nint CanInit2::i = 15;  \n  \n// The right side of the initializer is in the scope   \n// of the object being initialized  \nint CanInit2::j = i;  \n```  \n  \n> [!NOTE]\n>  The class name, `CanInit2`, must precede `i` to specify that the `i` being defined is a member of class `CanInit2`.  \n  \n## See Also  \n [Classes and Structs](../cpp/classes-and-structs-cpp.md)"}