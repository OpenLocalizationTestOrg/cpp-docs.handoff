{"nodes":[{"pos":[12,53],"content":"ew and delete Operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"ew and delete Operators | Microsoft Docs","pos":[0,40]}]},{"content":"new and delete Operators","pos":[735,759]},{"content":"C++ supports dynamic allocation and deallocation of objects using the <bpt id=\"p1\">[</bpt>new<ept id=\"p1\">](../cpp/new-operator-cpp.md)</ept> and <bpt id=\"p2\">[</bpt>delete<ept id=\"p2\">](../cpp/delete-operator-cpp.md)</ept> operators.","pos":[761,919],"source":"C++ supports dynamic allocation and deallocation of objects using the [new](../cpp/new-operator-cpp.md) and [delete](../cpp/delete-operator-cpp.md) operators."},{"content":"These operators allocate memory for objects from a pool called the free store.","pos":[920,998]},{"content":"The <ph id=\"ph1\">`new`</ph> operator calls the special function <bpt id=\"p1\">[</bpt>operator new<ept id=\"p1\">](../cpp/new-operator-cpp.md)</ept>, and the <ph id=\"ph2\">`delete`</ph> operator calls the special function <bpt id=\"p2\">[</bpt>operator delete<ept id=\"p2\">](../cpp/delete-operator-cpp.md)</ept>.","pos":[999,1191],"source":" The `new` operator calls the special function [operator new](../cpp/new-operator-cpp.md), and the `delete` operator calls the special function [operator delete](../cpp/delete-operator-cpp.md)."},{"content":"In <ph id=\"ph1\">[!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)]</ph> .NET 2002, the <ph id=\"ph2\">`new`</ph> function in the Standard C++ Library will support the behavior specified in the C++ standard, which is to throw a std::bad_alloc exception if the memory allocation fails.","pos":[1198,1443],"source":"In [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)] .NET 2002, the `new` function in the Standard C++ Library will support the behavior specified in the C++ standard, which is to throw a std::bad_alloc exception if the memory allocation fails."},{"content":"If you still want the non-throwing version of <ph id=\"ph1\">`new`</ph>, link your program with nothrownew.obj.","pos":[1444,1535],"source":" If you still want the non-throwing version of `new`, link your program with nothrownew.obj."},{"content":"However, when you link with nothrownew.obj, the default <ph id=\"ph1\">`operator new`</ph> in the Standard C++ Library no longer functions.","pos":[1536,1655],"source":" However, when you link with nothrownew.obj, the default `operator new` in the Standard C++ Library no longer functions."},{"pos":[1662,1833],"content":"For a list of the library files that comprise the C Runtime Library and the Standard C++ Library, see <bpt id=\"p1\">[</bpt>CRT Library Features<ept id=\"p1\">](../c-runtime-library/crt-library-features.md)</ept>.","source":"For a list of the library files that comprise the C Runtime Library and the Standard C++ Library, see [CRT Library Features](../c-runtime-library/crt-library-features.md)."},{"pos":[1870,1886],"content":"The new operator"},{"pos":[1890,2015],"content":"When a statement such as the following is encountered in a program, it translates into a call to the function <ph id=\"ph1\">`operator new`</ph>:","source":"When a statement such as the following is encountered in a program, it translates into a call to the function `operator new`:"},{"content":"If the request is for zero bytes of storage, <bpt id=\"p1\">**</bpt>operator new<ept id=\"p1\">**</ept> returns a pointer to a distinct object (that is, repeated calls to <bpt id=\"p2\">**</bpt>operator new<ept id=\"p2\">**</ept> return different pointers).","pos":[2076,2249],"source":"If the request is for zero bytes of storage, **operator new** returns a pointer to a distinct object (that is, repeated calls to **operator new** return different pointers)."},{"content":"If there is insufficient memory for the allocation request, <bpt id=\"p1\">**</bpt>operator new<ept id=\"p1\">**</ept> throws a std::bad_alloc exception, or returns <bpt id=\"p2\">**</bpt>nullptr<ept id=\"p2\">**</ept> if you have linked in non-throwing <ph id=\"ph1\">`operator new`</ph> support.","pos":[2250,2443],"source":" If there is insufficient memory for the allocation request, **operator new** throws a std::bad_alloc exception, or returns **nullptr** if you have linked in non-throwing `operator new` support."},{"content":"You can write a routine that attempts to free memory and retry the allocation; see <bpt id=\"p1\">[</bpt>_set_new_handler<ept id=\"p1\">](../c-runtime-library/reference/set-new-handler.md)</ept> for more information.","pos":[2449,2623],"source":"You can write a routine that attempts to free memory and retry the allocation; see [_set_new_handler](../c-runtime-library/reference/set-new-handler.md) for more information."},{"content":"For more details on the recovery scheme, see the Handling insufficient memory section of this topic.","pos":[2624,2724]},{"pos":[2731,2812],"content":"The two scopes for <ph id=\"ph1\">`operator new`</ph> functions are described in the following table.","source":"The two scopes for `operator new` functions are described in the following table."},{"content":"Scope for operator new Functions","pos":[2822,2854]},{"content":"Operator","pos":[2861,2869]},{"content":"Scope","pos":[2870,2875]},{"content":"::operator new","pos":[2913,2927]},{"content":"Global","pos":[2930,2936]},{"pos":[2941,2972],"content":"<bpt id=\"p1\">*</bpt>class-name<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt>::operator new<ept id=\"p2\">**</ept>","source":"*class-name* **::operator new**"},{"content":"Class","pos":[2973,2978]},{"pos":[2986,3124],"content":"The first argument to <bpt id=\"p1\">**</bpt>operator new<ept id=\"p1\">**</ept> must be of type <bpt id=\"p2\">**</bpt>size_t<ept id=\"p2\">**</ept> (a type defined in STDDEF.H), and the return type is always <bpt id=\"p3\">**</bpt>void <ph id=\"ph1\">\\*</ph><ept id=\"p3\">**</ept>.","source":"The first argument to **operator new** must be of type **size_t** (a type defined in STDDEF.H), and the return type is always **void \\***."},{"content":"The global <bpt id=\"p1\">**</bpt>operator new<ept id=\"p1\">**</ept> function is called when the <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> operator is used to allocate objects of built-in types, objects of class type that do not contain user-defined <bpt id=\"p3\">**</bpt>operator new<ept id=\"p3\">**</ept> functions, and arrays of any type.","pos":[3131,3357],"source":"The global **operator new** function is called when the **new** operator is used to allocate objects of built-in types, objects of class type that do not contain user-defined **operator new** functions, and arrays of any type."},{"content":"When the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator is used to allocate objects of a class type where an <bpt id=\"p2\">**</bpt>operator new<ept id=\"p2\">**</ept> is defined, that class's <bpt id=\"p3\">**</bpt>operator new<ept id=\"p3\">**</ept> is called.","pos":[3358,3506],"source":" When the **new** operator is used to allocate objects of a class type where an **operator new** is defined, that class's **operator new** is called."},{"content":"An <bpt id=\"p1\">**</bpt>operator new<ept id=\"p1\">**</ept> function defined for a class is a static member function (which cannot, therefore, be virtual) that hides the global <bpt id=\"p2\">**</bpt>operator new<ept id=\"p2\">**</ept> function for objects of that class type.","pos":[3513,3707],"source":"An **operator new** function defined for a class is a static member function (which cannot, therefore, be virtual) that hides the global **operator new** function for objects of that class type."},{"content":"Consider the case where <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> is used to allocate and set memory to a given value:","pos":[3708,3792],"source":" Consider the case where **new** is used to allocate and set memory to a given value:"},{"content":"The argument supplied in parentheses to <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> is passed to <ph id=\"ph1\">`Blanks::operator new`</ph> as the <ph id=\"ph2\">`chInit`</ph> argument.","pos":[4510,4619],"source":"The argument supplied in parentheses to **new** is passed to `Blanks::operator new` as the `chInit` argument."},{"content":"However, the global <bpt id=\"p1\">**</bpt>operator new<ept id=\"p1\">**</ept> function is hidden, causing code such as the following to generate an error:","pos":[4620,4733],"source":" However, the global **operator new** function is hidden, causing code such as the following to generate an error:"},{"pos":[4793,4992],"content":"In Visual C++ 5.0 and earlier, nonclass types and all arrays (regardless of whether they were of <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept> type) allocated using the <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> operator always used the global <bpt id=\"p3\">**</bpt>operator new<ept id=\"p3\">**</ept> function.","source":"In Visual C++ 5.0 and earlier, nonclass types and all arrays (regardless of whether they were of **class** type) allocated using the **new** operator always used the global **operator new** function."},{"content":"Beginning with Visual C++ 5.0, the compiler supports member array <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> operators in a class declaration.","pos":[4999,5121],"source":"Beginning with Visual C++ 5.0, the compiler supports member array **new** and **delete** operators in a class declaration."},{"content":"For example:","pos":[5122,5134]},{"content":"Handling insufficient memory","pos":[5450,5478]},{"content":"Testing for failed memory allocation can be done with code such as the following:","pos":[5482,5563]},{"pos":[5880,6136],"content":"There is another ways to handle failed memory allocation requests: write a custom recovery routine to handle such a failure, then register your function by calling the <bpt id=\"p1\">[</bpt>_set_new_handler<ept id=\"p1\">](../c-runtime-library/reference/set-new-handler.md)</ept> run-time function.","source":"There is another ways to handle failed memory allocation requests: write a custom recovery routine to handle such a failure, then register your function by calling the [_set_new_handler](../c-runtime-library/reference/set-new-handler.md) run-time function."},{"pos":[6176,6195],"content":"The delete operator"},{"content":"Memory that is dynamically allocated using the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator can be freed using the <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> operator.","pos":[6199,6306],"source":"Memory that is dynamically allocated using the **new** operator can be freed using the **delete** operator."},{"content":"The delete operator calls the <bpt id=\"p1\">**</bpt>operator delete<ept id=\"p1\">**</ept> function, which frees memory back to the available pool.","pos":[6307,6413],"source":" The delete operator calls the **operator delete** function, which frees memory back to the available pool."},{"content":"Using the <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> operator also causes the class destructor (if there is one) to be called.","pos":[6414,6508],"source":" Using the **delete** operator also causes the class destructor (if there is one) to be called."},{"content":"There are global and class-scoped <bpt id=\"p1\">**</bpt>operator delete<ept id=\"p1\">**</ept> functions.","pos":[6515,6579],"source":"There are global and class-scoped **operator delete** functions."},{"content":"Only one <bpt id=\"p1\">**</bpt>operator delete<ept id=\"p1\">**</ept> function can be defined for a given class; if defined, it hides the global <bpt id=\"p2\">**</bpt>operator delete<ept id=\"p2\">**</ept> function.","pos":[6580,6713],"source":" Only one **operator delete** function can be defined for a given class; if defined, it hides the global **operator delete** function."},{"content":"The global <bpt id=\"p1\">**</bpt>operator delete<ept id=\"p1\">**</ept> function is always called for arrays of any type.","pos":[6714,6794],"source":" The global **operator delete** function is always called for arrays of any type."},{"content":"The global <bpt id=\"p1\">**</bpt>operator delete<ept id=\"p1\">**</ept> function.","pos":[6801,6841],"source":"The global **operator delete** function."},{"content":"Two forms exist for the  global <bpt id=\"p1\">**</bpt>operator delete<ept id=\"p1\">**</ept>  and class-member <bpt id=\"p2\">**</bpt>operator delete<ept id=\"p2\">**</ept> functions:","pos":[6842,6942],"source":" Two forms exist for the  global **operator delete**  and class-member **operator delete** functions:"},{"content":"Only one of the preceding two forms can be present for a given class.","pos":[7043,7112]},{"content":"The first form takes a single argument of type <bpt id=\"p1\">**</bpt>void <ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept>, which contains a pointer to the object to deallocate.","pos":[7113,7226],"source":" The first form takes a single argument of type **void \\***, which contains a pointer to the object to deallocate."},{"content":"The second form—sized deallocation—takes two arguments, the first of which is a pointer to the memory block to deallocate and the second of which is the number of bytes to deallocate.","pos":[7227,7410]},{"content":"The return type of both forms is <ph id=\"ph1\">`void`</ph> (<bpt id=\"p1\">**</bpt>operator delete<ept id=\"p1\">**</ept> cannot return a value).","pos":[7411,7495],"source":" The return type of both forms is `void` (**operator delete** cannot return a value)."},{"pos":[7502,7831],"content":"The intent of the second form is to speed up searching for the correct size category of the object to be deleted, which is often not stored near the allocation itself and likely uncached; the second form is particularly useful when an <bpt id=\"p1\">**</bpt>operator delete<ept id=\"p1\">**</ept> function from a base class is used to delete an object of a derived class.","source":"The intent of the second form is to speed up searching for the correct size category of the object to be deleted, which is often not stored near the allocation itself and likely uncached; the second form is particularly useful when an **operator delete** function from a base class is used to delete an object of a derived class."},{"content":"The <bpt id=\"p1\">**</bpt>operator delete<ept id=\"p1\">**</ept> function is static; therefore, it cannot be virtual.","pos":[7838,7914],"source":"The **operator delete** function is static; therefore, it cannot be virtual."},{"content":"The <ph id=\"ph1\">`operator delete`</ph> function obeys access control, as described in <bpt id=\"p1\">[</bpt>Member-Access Control<ept id=\"p1\">](../cpp/member-access-control-cpp.md)</ept>.","pos":[7915,8045],"source":" The `operator delete` function obeys access control, as described in [Member-Access Control](../cpp/member-access-control-cpp.md)."},{"pos":[8052,8200],"content":"The following example shows user-defined <bpt id=\"p1\">**</bpt>operator new<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>operator delete<ept id=\"p2\">**</ept> functions designed to log allocations and deallocations of memory:","source":"The following example shows user-defined **operator new** and **operator delete** functions designed to log allocations and deallocations of memory:"},{"content":"The preceding code can be used to detect \"memory leakage\" — that is, memory that is allocated on the free store but never freed.","pos":[9534,9662]},{"content":"To perform this detection, the global <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> operators are redefined to count allocation and deallocation of memory.","pos":[9663,9795],"source":" To perform this detection, the global **new** and **delete** operators are redefined to count allocation and deallocation of memory."},{"content":"Beginning with Visual C++ 5.0, the compiler supports member array <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> operators in a class declaration.","pos":[9802,9924],"source":"Beginning with Visual C++ 5.0, the compiler supports member array **new** and **delete** operators in a class declaration."},{"content":"For example:","pos":[9925,9937]}],"content":"---\ntitle: \"new and delete Operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"delete_cpp\"\n  - \"new_cpp\"\n  - \"new\"\n  - \"delete\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"new keyword [C++], dynamic allocation of objects\"\n  - \"nothrownew.obj\"\n  - \"delete keyword [C++], syntax\"\nms.assetid: fa721b9e-0374-4f04-bb87-032ea775bcc8\ncaps.latest.revision: 16\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# new and delete Operators\n\nC++ supports dynamic allocation and deallocation of objects using the [new](../cpp/new-operator-cpp.md) and [delete](../cpp/delete-operator-cpp.md) operators. These operators allocate memory for objects from a pool called the free store. The `new` operator calls the special function [operator new](../cpp/new-operator-cpp.md), and the `delete` operator calls the special function [operator delete](../cpp/delete-operator-cpp.md).  \n  \n In [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)] .NET 2002, the `new` function in the Standard C++ Library will support the behavior specified in the C++ standard, which is to throw a std::bad_alloc exception if the memory allocation fails. If you still want the non-throwing version of `new`, link your program with nothrownew.obj. However, when you link with nothrownew.obj, the default `operator new` in the Standard C++ Library no longer functions.  \n  \n For a list of the library files that comprise the C Runtime Library and the Standard C++ Library, see [CRT Library Features](../c-runtime-library/crt-library-features.md).  \n  \n##  <a id=\"new_operator\"> </a> The new operator  \n When a statement such as the following is encountered in a program, it translates into a call to the function `operator new`:  \n  \n```cpp  \nchar *pch = new char[BUFFER_SIZE];  \n```  \n  \nIf the request is for zero bytes of storage, **operator new** returns a pointer to a distinct object (that is, repeated calls to **operator new** return different pointers). If there is insufficient memory for the allocation request, **operator new** throws a std::bad_alloc exception, or returns **nullptr** if you have linked in non-throwing `operator new` support.  \n  \nYou can write a routine that attempts to free memory and retry the allocation; see [_set_new_handler](../c-runtime-library/reference/set-new-handler.md) for more information. For more details on the recovery scheme, see the Handling insufficient memory section of this topic.  \n\n  \nThe two scopes for `operator new` functions are described in the following table.  \n  \n### Scope for operator new Functions  \n  \n|Operator|Scope|  \n|--------------|-----------|  \n|**::operator new**|Global|  \n|*class-name* **::operator new**|Class|  \n  \n The first argument to **operator new** must be of type **size_t** (a type defined in STDDEF.H), and the return type is always **void \\***.  \n  \n The global **operator new** function is called when the **new** operator is used to allocate objects of built-in types, objects of class type that do not contain user-defined **operator new** functions, and arrays of any type. When the **new** operator is used to allocate objects of a class type where an **operator new** is defined, that class's **operator new** is called.  \n  \n An **operator new** function defined for a class is a static member function (which cannot, therefore, be virtual) that hides the global **operator new** function for objects of that class type. Consider the case where **new** is used to allocate and set memory to a given value:  \n  \n```cpp  \n// spec1_the_operator_new_function1.cpp  \n#include <malloc.h>  \n#include <memory.h>  \n  \nclass Blanks  \n{  \npublic:  \n    Blanks(){}  \n    void *operator new( size_t stAllocateBlock, char chInit );  \n};  \nvoid *Blanks::operator new( size_t stAllocateBlock, char chInit )  \n{  \n    void *pvTemp = malloc( stAllocateBlock );  \n    if( pvTemp != 0 )  \n        memset( pvTemp, chInit, stAllocateBlock );  \n    return pvTemp;  \n}  \n// For discrete objects of type Blanks, the global operator new function  \n// is hidden. Therefore, the following code allocates an object of type  \n// Blanks and initializes it to 0xa5  \nint main()  \n{  \n   Blanks *a5 = new(0xa5) Blanks;  \n   return a5 != 0;  \n}  \n```  \n  \n The argument supplied in parentheses to **new** is passed to `Blanks::operator new` as the `chInit` argument. However, the global **operator new** function is hidden, causing code such as the following to generate an error:  \n  \n```cpp  \nBlanks *SomeBlanks = new Blanks;  \n```  \n  \n In Visual C++ 5.0 and earlier, nonclass types and all arrays (regardless of whether they were of **class** type) allocated using the **new** operator always used the global **operator new** function.  \n  \n Beginning with Visual C++ 5.0, the compiler supports member array **new** and **delete** operators in a class declaration. For example:  \n  \n```cpp  \n// spec1_the_operator_new_function2.cpp  \nclass MyClass  \n{  \npublic:  \n   void * operator new[] (size_t)  \n   {  \n      return 0;  \n   }  \n   void   operator delete[] (void*)  \n   {  \n   }  \n};  \n  \nint main()   \n{  \n   MyClass *pMyClass = new MyClass[5];  \n   delete [] pMyClass;  \n}  \n```  \n  \n### Handling insufficient memory  \n Testing for failed memory allocation can be done with code such as the following:  \n  \n```cpp  \n// insufficient_memory_conditions.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n#define BIG_NUMBER 100000000  \nint main() {  \n   int *pI = new int[BIG_NUMBER];  \n   if( pI == 0x0 ) {  \n      cout << \"Insufficient memory\" << endl;  \n      return -1;  \n   }  \n}  \n```  \n  \n There is another ways to handle failed memory allocation requests: write a custom recovery routine to handle such a failure, then register your function by calling the [_set_new_handler](../c-runtime-library/reference/set-new-handler.md) run-time function.  \n  \n##  <a id=\"delete_operator\"> </a> The delete operator  \n Memory that is dynamically allocated using the **new** operator can be freed using the **delete** operator. The delete operator calls the **operator delete** function, which frees memory back to the available pool. Using the **delete** operator also causes the class destructor (if there is one) to be called.  \n  \n There are global and class-scoped **operator delete** functions. Only one **operator delete** function can be defined for a given class; if defined, it hides the global **operator delete** function. The global **operator delete** function is always called for arrays of any type.  \n  \n The global **operator delete** function. Two forms exist for the  global **operator delete**  and class-member **operator delete** functions:  \n  \n```cpp  \nvoid operator delete( void * );  \nvoid operator delete( void *, size_t );  \n```  \n  \n Only one of the preceding two forms can be present for a given class. The first form takes a single argument of type **void \\***, which contains a pointer to the object to deallocate. The second form—sized deallocation—takes two arguments, the first of which is a pointer to the memory block to deallocate and the second of which is the number of bytes to deallocate. The return type of both forms is `void` (**operator delete** cannot return a value).  \n  \n The intent of the second form is to speed up searching for the correct size category of the object to be deleted, which is often not stored near the allocation itself and likely uncached; the second form is particularly useful when an **operator delete** function from a base class is used to delete an object of a derived class.  \n  \n The **operator delete** function is static; therefore, it cannot be virtual. The `operator delete` function obeys access control, as described in [Member-Access Control](../cpp/member-access-control-cpp.md).  \n  \n The following example shows user-defined **operator new** and **operator delete** functions designed to log allocations and deallocations of memory:  \n  \n```cpp  \n// spec1_the_operator_delete_function1.cpp  \n// compile with: /EHsc  \n// arguments: 3  \n#include <iostream>  \nusing namespace std;  \n  \nint fLogMemory = 0;      // Perform logging (0=no; nonzero=yes)?  \nint cBlocksAllocated = 0;  // Count of blocks allocated.  \n  \n// User-defined operator new.  \nvoid *operator new( size_t stAllocateBlock ) {  \n   static int fInOpNew = 0;   // Guard flag.  \n  \n   if ( fLogMemory && !fInOpNew ) {  \n      fInOpNew = 1;  \n      clog << \"Memory block \" << ++cBlocksAllocated  \n          << \" allocated for \" << stAllocateBlock  \n          << \" bytes\\n\";  \n      fInOpNew = 0;  \n   }  \n   return malloc( stAllocateBlock );  \n}  \n  \n// User-defined operator delete.  \nvoid operator delete( void *pvMem ) {  \n   static int fInOpDelete = 0;   // Guard flag.  \n   if ( fLogMemory && !fInOpDelete ) {  \n      fInOpDelete = 1;  \n      clog << \"Memory block \" << cBlocksAllocated--  \n          << \" deallocated\\n\";  \n      fInOpDelete = 0;  \n   }  \n  \n   free( pvMem );  \n}  \n  \nint main( int argc, char *argv[] ) {  \n   fLogMemory = 1;   // Turn logging on  \n   if( argc > 1 )  \n      for( int i = 0; i < atoi( argv[1] ); ++i ) {  \n         char *pMem = new char[10];  \n         delete[] pMem;  \n      }  \n   fLogMemory = 0;  // Turn logging off.  \n   return cBlocksAllocated;  \n}  \n```  \n  \n The preceding code can be used to detect \"memory leakage\" — that is, memory that is allocated on the free store but never freed. To perform this detection, the global **new** and **delete** operators are redefined to count allocation and deallocation of memory.  \n  \n Beginning with Visual C++ 5.0, the compiler supports member array **new** and **delete** operators in a class declaration. For example:  \n  \n```cpp  \n// spec1_the_operator_delete_function2.cpp  \n// compile with: /c  \nclass X  {  \npublic:  \n   void * operator new[] (size_t) {  \n      return 0;  \n   }  \n   void operator delete[] (void*) {}  \n};  \n  \nvoid f() {  \n   X *pX = new X[5];  \n   delete [] pX;  \n}  \n```  \n\n"}