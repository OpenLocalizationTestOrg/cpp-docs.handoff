{"nodes":[{"pos":[12,55],"content":"Declaration of a CLR Array | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Declaration of a CLR Array | Microsoft Docs","pos":[0,43]}]},{"content":"Declaration of a CLR Array","pos":[583,609]},{"pos":[610,803],"content":"The syntax for declaring, instantiating, and initializing a managed array has changed from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"The syntax for declaring, instantiating, and initializing a managed array has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"pos":[810,1073],"content":"The declaration of a CLR array object in Managed Extensions was an extension of the standard array declaration in which a <ph id=\"ph1\">`__gc`</ph> keyword was placed between the name of the array object and its possibly comma-filled dimension, as in the following pair of examples:","source":"The declaration of a CLR array object in Managed Extensions was an extension of the standard array declaration in which a `__gc` keyword was placed between the name of the array object and its possibly comma-filled dimension, as in the following pair of examples:"},{"content":"This has been simplified in the new syntax, in which we use a template-like declaration similar to the STL <ph id=\"ph1\">`vector`</ph> declaration.","pos":[1179,1307],"source":"This has been simplified in the new syntax, in which we use a template-like declaration similar to the STL `vector` declaration."},{"content":"The first parameter indicates the element type.","pos":[1308,1355]},{"content":"The second parameter specifies the array dimension (with a default value of 1, so only multiple dimensions require a second argument).","pos":[1356,1490]},{"content":"The array object itself is a tracking handle, and so must be given a hat.","pos":[1491,1564]},{"content":"If the element type is also a reference type, it also requires a hat.","pos":[1565,1634]},{"content":"For example, the above example, when expressed in the new syntax, looks as follows:","pos":[1635,1718]},{"content":"Because a reference type is a tracking handle rather than an object, it is possible to specify a CLR array as the return type of a function.","pos":[1828,1968]},{"content":"(In contrast, it is not possible to specify the native array as the return type of a function.) The syntax for doing this in Managed Extensions was somewhat non-intuitive.","pos":[1969,2140]},{"content":"For example:","pos":[2141,2153]},{"content":"In <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>, the declaration is much simpler.","pos":[2216,2324],"source":"In [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)], the declaration is much simpler."},{"content":"For example,","pos":[2325,2337]},{"content":"The shorthand initialization of a local managed array is supported in both versions of the language.","pos":[2406,2506]},{"content":"For example:","pos":[2507,2519]},{"pos":[2733,2998],"content":"is considerably simplified in the new syntax (note that because boxing is implicit in the new syntax, the <ph id=\"ph1\">`__box`</ph> operator has been eliminated – see <bpt id=\"p1\">[</bpt>Value Types and Their Behaviors (C++/CLI)<ept id=\"p1\">](../dotnet/value-types-and-their-behaviors-cpp-cli.md)</ept> for a discussion):","source":"is considerably simplified in the new syntax (note that because boxing is implicit in the new syntax, the `__box` operator has been eliminated – see [Value Types and Their Behaviors (C++/CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md) for a discussion):"},{"content":"Because an array is a CLR reference type, the declaration of each array object is a tracking handle.","pos":[3154,3254]},{"content":"Therefore, array objects must be allocated on the CLR heap.","pos":[3255,3314]},{"content":"(The shorthand notation hides the managed heap allocation.) Here is the explicit form of an array object initialization under Managed Extensions:","pos":[3315,3460]},{"content":"Under the new syntax, the <ph id=\"ph1\">`new`</ph> expression is replaced with <ph id=\"ph2\">`gcnew`</ph>.","pos":[3559,3627],"source":"Under the new syntax, the `new` expression is replaced with `gcnew`."},{"content":"The dimension sizes are passed as parameters to the <ph id=\"ph1\">`gcnew`</ph> expression, as follows:","pos":[3628,3711],"source":" The dimension sizes are passed as parameters to the `gcnew` expression, as follows:"},{"content":"In the new syntax, an explicit initialization list can follow the <ph id=\"ph1\">`gcnew`</ph> expression; this was not supported in Managed Extensions.","pos":[3843,3974],"source":"In the new syntax, an explicit initialization list can follow the `gcnew` expression; this was not supported in Managed Extensions."},{"content":"For example:","pos":[3975,3987]},{"content":"See Also","pos":[4180,4188]},{"content":"Managed Types (C++/CL)","pos":[4193,4215]},{"content":"Arrays","pos":[4257,4263]}],"content":"---\ntitle: \"Declaration of a CLR Array | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"array keyword [C++]\"\nms.assetid: 36a8883c-2663-43f0-a90c-28f27035e036\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Declaration of a CLR Array\nThe syntax for declaring, instantiating, and initializing a managed array has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n The declaration of a CLR array object in Managed Extensions was an extension of the standard array declaration in which a `__gc` keyword was placed between the name of the array object and its possibly comma-filled dimension, as in the following pair of examples:  \n  \n```  \nvoid PrintValues( Object* myArr __gc[]);  \nvoid PrintValues( int myArr __gc[,,]);  \n```  \n  \n This has been simplified in the new syntax, in which we use a template-like declaration similar to the STL `vector` declaration. The first parameter indicates the element type. The second parameter specifies the array dimension (with a default value of 1, so only multiple dimensions require a second argument). The array object itself is a tracking handle, and so must be given a hat. If the element type is also a reference type, it also requires a hat. For example, the above example, when expressed in the new syntax, looks as follows:  \n  \n```  \nvoid PrintValues( array<Object^>^ myArr );  \nvoid PrintValues( array<int,3>^ myArr );  \n```  \n  \n Because a reference type is a tracking handle rather than an object, it is possible to specify a CLR array as the return type of a function. (In contrast, it is not possible to specify the native array as the return type of a function.) The syntax for doing this in Managed Extensions was somewhat non-intuitive. For example:  \n  \n```  \nInt32 f() [];  \nint GetArray() __gc[];  \n```  \n  \n In [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)], the declaration is much simpler. For example,  \n  \n```  \narray<Int32>^ f();  \narray<int>^ GetArray();  \n```  \n  \n The shorthand initialization of a local managed array is supported in both versions of the language. For example:  \n  \n```  \nint GetArray() __gc[] {  \n   int a1 __gc[] = { 1, 2, 3, 4, 5 };  \n   Object* myObjArray __gc[] = {   \n      __box(26), __box(27), __box(28), __box(29), __box(30)  \n   };  \n   return a1;  \n}  \n```  \n  \n is considerably simplified in the new syntax (note that because boxing is implicit in the new syntax, the `__box` operator has been eliminated – see [Value Types and Their Behaviors (C++/CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md) for a discussion):  \n  \n```  \narray<int>^ GetArray() {  \n   array<int>^ a1 = {1,2,3,4,5};  \n   array<Object^>^ myObjArray = {26,27,28,29,30};  \n   return a1;  \n}  \n```  \n  \n Because an array is a CLR reference type, the declaration of each array object is a tracking handle. Therefore, array objects must be allocated on the CLR heap. (The shorthand notation hides the managed heap allocation.) Here is the explicit form of an array object initialization under Managed Extensions:  \n  \n```  \nObject* myArray[] = new Object*[2];  \nString* myMat[,] = new String*[4,4];  \n```  \n  \n Under the new syntax, the `new` expression is replaced with `gcnew`. The dimension sizes are passed as parameters to the `gcnew` expression, as follows:  \n  \n```  \narray<Object^>^ myArray = gcnew array<Object^>(2);  \narray<String^,2>^ myMat = gcnew array<String^,2>(4,4);  \n```  \n  \n In the new syntax, an explicit initialization list can follow the `gcnew` expression; this was not supported in Managed Extensions. For example:  \n  \n```  \n// explicit initialization list following gcnew   \n// was not supported in Managed Extensions  \narray<Object^>^ myArray =   \n   gcnew array<Object^>(4){ 1, 1, 2, 3 };  \n```  \n  \n## See Also  \n [Managed Types (C++/CL)](../dotnet/managed-types-cpp-cl.md)   \n [Arrays](../windows/arrays-cpp-component-extensions.md)"}