{"nodes":[{"pos":[12,49],"content":"onstandard Behavior | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"onstandard Behavior | Microsoft Docs","pos":[0,36]}]},{"content":"Nonstandard Behavior","pos":[721,741]},{"content":"The following sections list some of the places where the Visual C++ implementation of C++ does not comply with the C++ standard.","pos":[742,870]},{"content":"The section numbers given below refer to the section numbers in the C++ 11 standard (ISO/IEC 14882:2011(E)).","pos":[871,979]},{"pos":[986,1122],"content":"The list of compiler limits that differ from those defined in the C++ standard is given in <bpt id=\"p1\">[</bpt>Compiler Limits<ept id=\"p1\">](../cpp/compiler-limits.md)</ept>.","source":"The list of compiler limits that differ from those defined in the C++ standard is given in [Compiler Limits](../cpp/compiler-limits.md)."},{"content":"Covariant Return Types","pos":[1131,1153]},{"content":"Virtual base classes are not supported as covariant return types when the virtual function has a variable number of arguments.","pos":[1157,1283]},{"content":"This does not comply with section 10.3, paragraph 7 of the C++ ISO specification.","pos":[1284,1365]},{"content":"The following sample does not compile, giving compiler error <bpt id=\"p1\">[</bpt>C2688<ept id=\"p1\">](../error-messages/compiler-errors-2/compiler-error-c2688.md)</ept>","pos":[1366,1495],"source":" The following sample does not compile, giving compiler error [C2688](../error-messages/compiler-errors-2/compiler-error-c2688.md)"},{"content":"Binding Nondependent Names in Templates","pos":[1693,1732]},{"content":"The Visual C++ compiler does not currently support binding nondependent names when initially parsing a template.","pos":[1736,1848]},{"content":"This does not comply with section 14.6.3 of the C++ ISO specification.","pos":[1849,1919]},{"content":"This can cause overloads declared after the template (but before the template is instantiated) to be seen.","pos":[1920,2026]},{"content":"Function Exception Specifiers","pos":[2395,2424]},{"content":"Function exception specifiers other than <ph id=\"ph1\">`throw()`</ph> are parsed but not used.","pos":[2428,2503],"source":"Function exception specifiers other than `throw()` are parsed but not used."},{"content":"This does not comply with section 15.4 of the ISO C++ specification.","pos":[2504,2572]},{"content":"For example:","pos":[2573,2585]},{"pos":[2698,2825],"content":"For more information on exception specifications, see <bpt id=\"p1\">[</bpt>Exception Specifications<ept id=\"p1\">](../cpp/exception-specifications-throw-cpp.md)</ept>.","source":"For more information on exception specifications, see [Exception Specifications](../cpp/exception-specifications-throw-cpp.md)."},{"content":"char_traits::eof()","pos":[2834,2852]},{"content":"The C++ standard states that <bpt id=\"p1\">[</bpt>char_traits::eof<ept id=\"p1\">](http://msdn.microsoft.com/Library/3eef7544-48e4-49c0-9501-d3c5a8e43a70)</ept> must not correspond to a valid <ph id=\"ph1\">`char_type`</ph> value.","pos":[2856,3025],"source":"The C++ standard states that [char_traits::eof](http://msdn.microsoft.com/Library/3eef7544-48e4-49c0-9501-d3c5a8e43a70) must not correspond to a valid `char_type` value."},{"content":"The Visual C++ compiler enforces this constraint for type <ph id=\"ph1\">`char`</ph>, but not for type <ph id=\"ph2\">`wchar_t`</ph>.","pos":[3026,3119],"source":" The Visual C++ compiler enforces this constraint for type `char`, but not for type `wchar_t`."},{"content":"This does not comply with the requirement in Table 62 in section 12.1.1 of the C++ ISO specification.","pos":[3120,3221]},{"content":"The example below demonstrates this.","pos":[3222,3258]},{"content":"Storage Location of Objects","pos":[3657,3684]},{"content":"The C++ standard (section 1.8 paragraph 6) requires complete C++ objects to have unique storage locations.","pos":[3688,3794]},{"content":"However with Visual C++, there are cases where types without data members will share a storage location with other types for the lifetime of the object.","pos":[3795,3947]}],"content":"---\ntitle: \"Nonstandard Behavior | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"compatibility and compliance, nonstandard behavior\"\n  - \"Microsoft-specific, compiler behavior\"\n  - \"nonstandard behavior, compliance and compatibility\"\nms.assetid: a57dea27-dc79-4f64-8a83-017e84841773\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Nonstandard Behavior\nThe following sections list some of the places where the Visual C++ implementation of C++ does not comply with the C++ standard. The section numbers given below refer to the section numbers in the C++ 11 standard (ISO/IEC 14882:2011(E)).  \n  \n The list of compiler limits that differ from those defined in the C++ standard is given in [Compiler Limits](../cpp/compiler-limits.md).  \n  \n## Covariant Return Types  \n Virtual base classes are not supported as covariant return types when the virtual function has a variable number of arguments. This does not comply with section 10.3, paragraph 7 of the C++ ISO specification. The following sample does not compile, giving compiler error [C2688](../error-messages/compiler-errors-2/compiler-error-c2688.md)  \n  \n```cpp  \n// CovariantReturn.cpp  \nclass A   \n{  \n   virtual A* f(int c, ...);   // remove ...  \n};  \n  \nclass B : virtual A  \n{  \n   B* f(int c, ...);   // C2688 remove ...  \n};  \n```  \n  \n## Binding Nondependent Names in Templates  \n The Visual C++ compiler does not currently support binding nondependent names when initially parsing a template. This does not comply with section 14.6.3 of the C++ ISO specification. This can cause overloads declared after the template (but before the template is instantiated) to be seen.  \n  \n```cpp  \n#include <iostream>  \nusing namespace std;  \n  \nnamespace N {  \n   void f(int) { cout << \"f(int)\" << endl;}  \n}  \n  \ntemplate <class T> void g(T) {  \n    N::f('a');   // calls f(char), should call f(int)  \n}  \n  \nnamespace N {  \n    void f(char) { cout << \"f(char)\" << endl;}  \n}  \n  \nint main() {  \n    g('c');  \n}  \n// Output: f(char)  \n  \n```  \n  \n## Function Exception Specifiers  \n Function exception specifiers other than `throw()` are parsed but not used. This does not comply with section 15.4 of the ISO C++ specification. For example:  \n  \n```cpp  \nvoid f() throw(int); // parsed but not used  \nvoid g() throw();    // parsed and used  \n```  \n  \n For more information on exception specifications, see [Exception Specifications](../cpp/exception-specifications-throw-cpp.md).  \n  \n## char_traits::eof()  \n The C++ standard states that [char_traits::eof](http://msdn.microsoft.com/Library/3eef7544-48e4-49c0-9501-d3c5a8e43a70) must not correspond to a valid `char_type` value. The Visual C++ compiler enforces this constraint for type `char`, but not for type `wchar_t`. This does not comply with the requirement in Table 62 in section 12.1.1 of the C++ ISO specification. The example below demonstrates this.  \n  \n```cpp  \n#include <iostream>  \n  \nint main()  \n{  \n    using namespace std;  \n  \n    char_traits<char>::int_type int2 = char_traits<char>::eof();  \n    cout << \"The eof marker for char_traits<char> is: \" << int2 << endl;  \n  \n    char_traits<wchar_t>::int_type int3 = char_traits<wchar_t>::eof();  \n    cout << \"The eof marker for char_traits<wchar_t> is: \" << int3 << endl;  \n}  \n```  \n  \n## Storage Location of Objects  \n The C++ standard (section 1.8 paragraph 6) requires complete C++ objects to have unique storage locations. However with Visual C++, there are cases where types without data members will share a storage location with other types for the lifetime of the object."}