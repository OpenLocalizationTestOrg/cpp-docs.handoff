{"nodes":[{"pos":[12,50],"content":"dynamic_cast Operator | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"dynamic_cast Operator | Microsoft Docs","pos":[0,38]}]},{"content":"dynamic_cast Operator","pos":[653,674]},{"pos":[675,740],"content":"Converts the operand <ph id=\"ph1\">`expression`</ph> to an object of type <ph id=\"ph2\">`type-id`</ph>.","source":"Converts the operand `expression` to an object of type `type-id`."},{"content":"Syntax","pos":[749,755]},{"content":"Remarks","pos":[824,831]},{"content":"The <ph id=\"ph1\">`type-id`</ph> must be a pointer or a reference to a previously defined class type or a \"pointer to void\".","pos":[835,940],"source":"The `type-id` must be a pointer or a reference to a previously defined class type or a \"pointer to void\"."},{"content":"The type of <ph id=\"ph1\">`expression`</ph> must be a pointer if <ph id=\"ph2\">`type-id`</ph> is a pointer, or an l-value if <ph id=\"ph3\">`type-id`</ph> is a reference.","pos":[941,1053],"source":" The type of `expression` must be a pointer if `type-id` is a pointer, or an l-value if `type-id` is a reference."},{"pos":[1060,1234],"content":"See <bpt id=\"p1\">[</bpt>static_cast<ept id=\"p1\">](../cpp/static-cast-operator.md)</ept> for an explanation of the difference between static and dynamic casting conversions, and when it is appropriate to use each.","source":"See [static_cast](../cpp/static-cast-operator.md) for an explanation of the difference between static and dynamic casting conversions, and when it is appropriate to use each."},{"pos":[1241,1322],"content":"There are two breaking changes in the behavior of <ph id=\"ph1\">`dynamic_cast`</ph> in managed code:","source":"There are two breaking changes in the behavior of `dynamic_cast` in managed code:"},{"pos":[1347,1466],"content":"to a pointer to the underlying type of a boxed enum will fail at runtime, returning 0 instead of the converted pointer."},{"content":"will no longer throw an exception when <ph id=\"ph1\">`type-id`</ph> is an interior pointer to a value type, with the cast failing at runtime.","pos":[1491,1613],"source":" will no longer throw an exception when `type-id` is an interior pointer to a value type, with the cast failing at runtime."},{"content":"The cast will now return the 0 pointer value instead of throwing.","pos":[1615,1680]},{"content":"If <ph id=\"ph1\">`type-id`</ph> is a pointer to an unambiguous accessible direct or indirect base class of <ph id=\"ph2\">`expression`</ph>, a pointer to the unique subobject of type <ph id=\"ph3\">`type-id`</ph> is the result.","pos":[1687,1855],"source":"If `type-id` is a pointer to an unambiguous accessible direct or indirect base class of `expression`, a pointer to the unique subobject of type `type-id` is the result."},{"content":"For example:","pos":[1856,1868]},{"content":"This type of conversion is called an \"upcast\" because it moves a pointer up a class hierarchy, from a derived class to a class it is derived from.","pos":[2312,2458]},{"content":"An upcast is an implicit conversion.","pos":[2459,2495]},{"content":"If <ph id=\"ph1\">`type-id`</ph> is void*, a run-time check is made to determine the actual type of <ph id=\"ph2\">`expression`</ph>.","pos":[2502,2595],"source":"If `type-id` is void*, a run-time check is made to determine the actual type of `expression`."},{"content":"The result is a pointer to the complete object pointed to by <ph id=\"ph1\">`expression`</ph>.","pos":[2596,2670],"source":" The result is a pointer to the complete object pointed to by `expression`."},{"content":"For example:","pos":[2671,2683]},{"pos":[3046,3199],"content":"If <ph id=\"ph1\">`type-id`</ph> is not void*, a run-time check is made to see if the object pointed to by <ph id=\"ph2\">`expression`</ph> can be converted to the type pointed to by <ph id=\"ph3\">`type-id`</ph>.","source":"If `type-id` is not void*, a run-time check is made to see if the object pointed to by `expression` can be converted to the type pointed to by `type-id`."},{"content":"If the type of <ph id=\"ph1\">`expression`</ph> is a base class of the type of <ph id=\"ph2\">`type-id`</ph>, a run-time check is made to see if <ph id=\"ph3\">`expression`</ph> actually points to a complete object of the type of <ph id=\"ph4\">`type-id`</ph>.","pos":[3206,3386],"source":"If the type of `expression` is a base class of the type of `type-id`, a run-time check is made to see if `expression` actually points to a complete object of the type of `type-id`."},{"content":"If this is true, the result is a pointer to a complete object of the type of <ph id=\"ph1\">`type-id`</ph>.","pos":[3387,3474],"source":" If this is true, the result is a pointer to a complete object of the type of `type-id`."},{"content":"For example:","pos":[3475,3487]},{"content":"This type of conversion is called a \"downcast\" because it moves a pointer down a class hierarchy, from a given class to a class derived from it.","pos":[3854,3998]},{"content":"In cases of multiple inheritance, possibilities for ambiguity are introduced.","pos":[4005,4082]},{"content":"Consider the class hierarchy shown in the following figure.","pos":[4083,4142]},{"pos":[4149,4362],"content":"For CLR types, <ph id=\"ph1\">`dynamic_cast`</ph> results in either a no-op if the conversion can be performed implicitly, or an MSIL <ph id=\"ph2\">`isinst`</ph> instruction, which performs a dynamic check and returns <ph id=\"ph3\">`nullptr`</ph> if the conversion fails.","source":"For CLR types, `dynamic_cast` results in either a no-op if the conversion can be performed implicitly, or an MSIL `isinst` instruction, which performs a dynamic check and returns `nullptr` if the conversion fails."},{"pos":[4369,4468],"content":"The following sample uses <ph id=\"ph1\">`dynamic_cast`</ph> to determine if a class is an instance of particular type:","source":"The following sample uses `dynamic_cast` to determine if a class is an instance of particular type:"},{"content":"Class hierarchy that shows multiple inheritance","pos":[4908,4955]},{"content":"Class Hierarchy Showing Multiple Inheritance","pos":[4995,5039]},{"content":"A pointer to an object of type <ph id=\"ph1\">`D`</ph> can be safely cast to <ph id=\"ph2\">`B`</ph> or <ph id=\"ph3\">`C`</ph>.","pos":[5046,5114],"source":"A pointer to an object of type `D` can be safely cast to `B` or `C`."},{"content":"However, if <ph id=\"ph1\">`D`</ph> is cast to point to an <ph id=\"ph2\">`A`</ph> object, which instance of <ph id=\"ph3\">`A`</ph> would result?","pos":[5115,5201],"source":" However, if `D` is cast to point to an `A` object, which instance of `A` would result?"},{"content":"This would result in an ambiguous casting error.","pos":[5202,5250]},{"content":"To get around this problem, you can perform two unambiguous casts.","pos":[5251,5317]},{"content":"For example:","pos":[5318,5330]},{"content":"Further ambiguities can be introduced when you use virtual base classes.","pos":[5659,5731]},{"content":"Consider the class hierarchy shown in the following figure.","pos":[5732,5791]},{"content":"Class hierarchy that shows virtual base classes","pos":[5800,5847]},{"content":"Class Hierarchy Showing Virtual Base Classes","pos":[5887,5931]},{"content":"In this hierarchy, <ph id=\"ph1\">`A`</ph> is a virtual base class.","pos":[5938,5985],"source":"In this hierarchy, `A` is a virtual base class."},{"content":"Given an instance of class <ph id=\"ph1\">`E`</ph> and a pointer to the <ph id=\"ph2\">`A`</ph> subobject, a <ph id=\"ph3\">`dynamic_cast`</ph> to a pointer to <ph id=\"ph4\">`B`</ph> will fail due to ambiguity.","pos":[5986,6117],"source":" Given an instance of class `E` and a pointer to the `A` subobject, a `dynamic_cast` to a pointer to `B` will fail due to ambiguity."},{"content":"You must first cast back to the complete <ph id=\"ph1\">`E`</ph> object, then work your way back up the hierarchy, in an unambiguous manner, to reach the correct <ph id=\"ph2\">`B`</ph> object.","pos":[6118,6271],"source":" You must first cast back to the complete `E` object, then work your way back up the hierarchy, in an unambiguous manner, to reach the correct `B` object."},{"content":"Consider the class hierarchy shown in the following figure.","pos":[6278,6337]},{"content":"Class hierarchy that shows duplicate base classes","pos":[6346,6395]},{"content":"Class Hierarchy Showing Duplicate Base Classes","pos":[6435,6481]},{"content":"Given an object of type <ph id=\"ph1\">`E`</ph> and a pointer to the <ph id=\"ph2\">`D`</ph> subobject, to navigate from the <ph id=\"ph3\">`D`</ph> subobject to the left-most <ph id=\"ph4\">`A`</ph> subobject, three conversions can be made.","pos":[6488,6649],"source":"Given an object of type `E` and a pointer to the `D` subobject, to navigate from the `D` subobject to the left-most `A` subobject, three conversions can be made."},{"content":"You can perform a <ph id=\"ph1\">`dynamic_cast`</ph> conversion from the <ph id=\"ph2\">`D`</ph> pointer to an <ph id=\"ph3\">`E`</ph> pointer, then a conversion (either <ph id=\"ph4\">`dynamic_cast`</ph> or an implicit conversion) from <ph id=\"ph5\">`E`</ph> to <ph id=\"ph6\">`B`</ph>, and finally an implicit conversion from <ph id=\"ph7\">`B`</ph> to <ph id=\"ph8\">`A`</ph>.","pos":[6650,6870],"source":" You can perform a `dynamic_cast` conversion from the `D` pointer to an `E` pointer, then a conversion (either `dynamic_cast` or an implicit conversion) from `E` to `B`, and finally an implicit conversion from `B` to `A`."},{"content":"For example:","pos":[6871,6883]},{"content":"The <ph id=\"ph1\">`dynamic_cast`</ph> operator can also be used to perform a \"cross cast.\"","pos":[7307,7378],"source":"The `dynamic_cast` operator can also be used to perform a \"cross cast.\""},{"content":"Using the same class hierarchy, it is possible to cast a pointer, for example, from the <ph id=\"ph1\">`B`</ph> subobject to the <ph id=\"ph2\">`D`</ph> subobject, as long as the complete object is of type <ph id=\"ph3\">`E`</ph>.","pos":[7379,7549],"source":" Using the same class hierarchy, it is possible to cast a pointer, for example, from the `B` subobject to the `D` subobject, as long as the complete object is of type `E`."},{"content":"Considering cross casts, it is actually possible to do the conversion from a pointer to <ph id=\"ph1\">`D`</ph> to a pointer to the left-most <ph id=\"ph2\">`A`</ph> subobject in just two steps.","pos":[7556,7710],"source":"Considering cross casts, it is actually possible to do the conversion from a pointer to `D` to a pointer to the left-most `A` subobject in just two steps."},{"content":"You can perform a cross cast from <ph id=\"ph1\">`D`</ph> to <ph id=\"ph2\">`B`</ph>, then an implicit conversion from <ph id=\"ph3\">`B`</ph> to <ph id=\"ph4\">`A`</ph>.","pos":[7711,7801],"source":" You can perform a cross cast from `D` to `B`, then an implicit conversion from `B` to `A`."},{"content":"For example:","pos":[7802,7814]},{"pos":[8204,8306],"content":"A null pointer value is converted to the null pointer value of the destination type by <ph id=\"ph1\">`dynamic_cast`</ph>.","source":"A null pointer value is converted to the null pointer value of the destination type by `dynamic_cast`."},{"content":"When you use <ph id=\"ph1\">`dynamic_cast &lt; type-id &gt; ( expression )`</ph>, if <ph id=\"ph2\">`expression`</ph> cannot be safely converted to type <ph id=\"ph3\">`type-id`</ph>, the run-time check causes the cast to fail.","pos":[8313,8474],"source":"When you use `dynamic_cast < type-id > ( expression )`, if `expression` cannot be safely converted to type `type-id`, the run-time check causes the cast to fail."},{"content":"For example:","pos":[8475,8487]},{"content":"The value of a failed cast to pointer type is the null pointer.","pos":[8758,8821]},{"content":"A failed cast to reference type throws a <bpt id=\"p1\">[</bpt>bad_cast Exception<ept id=\"p1\">](../cpp/bad-cast-exception.md)</ept>.","pos":[8822,8914],"source":" A failed cast to reference type throws a [bad_cast Exception](../cpp/bad-cast-exception.md)."},{"content":"If <ph id=\"ph1\">`expression`</ph> does not point to or reference a valid object, a <ph id=\"ph2\">`__non_rtti_object`</ph> exception is thrown.","pos":[8917,9022],"source":"   If `expression` does not point to or reference a valid object, a `__non_rtti_object` exception is thrown."},{"pos":[9029,9125],"content":"See <bpt id=\"p1\">[</bpt>typeid<ept id=\"p1\">](../cpp/typeid-operator.md)</ept> for an explanation of the <ph id=\"ph1\">`__non_rtti_object`</ph> exception.","source":"See [typeid](../cpp/typeid-operator.md) for an explanation of the `__non_rtti_object` exception."},{"content":"Example","pos":[9134,9141]},{"content":"The following sample creates the base class (struct A) pointer, to an object (struct C).","pos":[9145,9233]},{"content":"This, plus the fact there are virtual functions, enables runtime polymorphism.","pos":[9235,9313]},{"content":"The sample also calls a non-virtual function in the hierarchy.","pos":[9320,9382]},{"content":"See Also","pos":[10580,10588]},{"content":"Casting Operators","pos":[10593,10610]},{"content":"Keywords","pos":[10646,10654]}],"content":"---\ntitle: \"dynamic_cast Operator | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"dynamic_cast\"\n  - \"dynamic_cast_cpp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"dynamic_cast keyword [C++]\"\nms.assetid: f380ada8-6a18-4547-93c9-63407f19856b\ncaps.latest.revision: 20\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# dynamic_cast Operator\nConverts the operand `expression` to an object of type `type-id`.  \n  \n## Syntax  \n  \n```  \n  \ndynamic_cast < type-id > ( expression )  \n```  \n  \n## Remarks  \n The `type-id` must be a pointer or a reference to a previously defined class type or a \"pointer to void\". The type of `expression` must be a pointer if `type-id` is a pointer, or an l-value if `type-id` is a reference.  \n  \n See [static_cast](../cpp/static-cast-operator.md) for an explanation of the difference between static and dynamic casting conversions, and when it is appropriate to use each.  \n  \n There are two breaking changes in the behavior of `dynamic_cast` in managed code:  \n  \n-   `dynamic_cast` to a pointer to the underlying type of a boxed enum will fail at runtime, returning 0 instead of the converted pointer.  \n  \n-   `dynamic_cast` will no longer throw an exception when `type-id` is an interior pointer to a value type, with the cast failing at runtime.  The cast will now return the 0 pointer value instead of throwing.  \n  \n If `type-id` is a pointer to an unambiguous accessible direct or indirect base class of `expression`, a pointer to the unique subobject of type `type-id` is the result. For example:  \n  \n```  \n// dynamic_cast_1.cpp  \n// compile with: /c  \nclass B { };  \nclass C : public B { };  \nclass D : public C { };  \n  \nvoid f(D* pd) {  \n   C* pc = dynamic_cast<C*>(pd);   // ok: C is a direct base class  \n                                   // pc points to C subobject of pd   \n   B* pb = dynamic_cast<B*>(pd);   // ok: B is an indirect base class  \n                                   // pb points to B subobject of pd  \n}  \n```  \n  \n This type of conversion is called an \"upcast\" because it moves a pointer up a class hierarchy, from a derived class to a class it is derived from. An upcast is an implicit conversion.  \n  \n If `type-id` is void*, a run-time check is made to determine the actual type of `expression`. The result is a pointer to the complete object pointed to by `expression`. For example:  \n  \n```  \n// dynamic_cast_2.cpp  \n// compile with: /c /GR  \nclass A {virtual void f();};  \nclass B {virtual void f();};  \n  \nvoid f() {  \n   A* pa = new A;  \n   B* pb = new B;  \n   void* pv = dynamic_cast<void*>(pa);  \n   // pv now points to an object of type A  \n  \n   pv = dynamic_cast<void*>(pb);  \n   // pv now points to an object of type B  \n}  \n```  \n  \n If `type-id` is not void*, a run-time check is made to see if the object pointed to by `expression` can be converted to the type pointed to by `type-id`.  \n  \n If the type of `expression` is a base class of the type of `type-id`, a run-time check is made to see if `expression` actually points to a complete object of the type of `type-id`. If this is true, the result is a pointer to a complete object of the type of `type-id`. For example:  \n  \n```  \n// dynamic_cast_3.cpp  \n// compile with: /c /GR  \nclass B {virtual void f();};  \nclass D : public B {virtual void f();};  \n  \nvoid f() {  \n   B* pb = new D;   // unclear but ok  \n   B* pb2 = new B;  \n  \n   D* pd = dynamic_cast<D*>(pb);   // ok: pb actually points to a D  \n   D* pd2 = dynamic_cast<D*>(pb2);   // pb2 points to a B not a D  \n}  \n```  \n  \n This type of conversion is called a \"downcast\" because it moves a pointer down a class hierarchy, from a given class to a class derived from it.  \n  \n In cases of multiple inheritance, possibilities for ambiguity are introduced. Consider the class hierarchy shown in the following figure.  \n  \n For CLR types, `dynamic_cast` results in either a no-op if the conversion can be performed implicitly, or an MSIL `isinst` instruction, which performs a dynamic check and returns `nullptr` if the conversion fails.  \n  \n The following sample uses `dynamic_cast` to determine if a class is an instance of particular type:  \n  \n```  \n// dynamic_cast_clr.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nvoid PrintObjectType( Object^o ) {  \n   if( dynamic_cast<String^>(o) )  \n      Console::WriteLine(\"Object is a String\");  \n   else if( dynamic_cast<int^>(o) )  \n      Console::WriteLine(\"Object is an int\");  \n}  \n  \nint main() {  \n   Object^o1 = \"hello\";  \n   Object^o2 = 10;  \n  \n   PrintObjectType(o1);  \n   PrintObjectType(o2);  \n}  \n```  \n  \n ![Class hierarchy that shows multiple inheritance](../cpp/media/vc39011.gif \"vc39011\")  \nClass Hierarchy Showing Multiple Inheritance  \n  \n A pointer to an object of type `D` can be safely cast to `B` or `C`. However, if `D` is cast to point to an `A` object, which instance of `A` would result? This would result in an ambiguous casting error. To get around this problem, you can perform two unambiguous casts. For example:  \n  \n```  \n// dynamic_cast_4.cpp  \n// compile with: /c /GR  \nclass A {virtual void f();};  \nclass B {virtual void f();};  \nclass D : public B {virtual void f();};  \n  \nvoid f() {  \n   D* pd = new D;  \n   B* pb = dynamic_cast<B*>(pd);   // first cast to B  \n   A* pa2 = dynamic_cast<A*>(pb);   // ok: unambiguous  \n}  \n```  \n  \n Further ambiguities can be introduced when you use virtual base classes. Consider the class hierarchy shown in the following figure.  \n  \n ![Class hierarchy that shows virtual base classes](../cpp/media/vc39012.gif \"vc39012\")  \nClass Hierarchy Showing Virtual Base Classes  \n  \n In this hierarchy, `A` is a virtual base class. Given an instance of class `E` and a pointer to the `A` subobject, a `dynamic_cast` to a pointer to `B` will fail due to ambiguity. You must first cast back to the complete `E` object, then work your way back up the hierarchy, in an unambiguous manner, to reach the correct `B` object.  \n  \n Consider the class hierarchy shown in the following figure.  \n  \n ![Class hierarchy that shows duplicate base classes](../cpp/media/vc39013.gif \"vc39013\")  \nClass Hierarchy Showing Duplicate Base Classes  \n  \n Given an object of type `E` and a pointer to the `D` subobject, to navigate from the `D` subobject to the left-most `A` subobject, three conversions can be made. You can perform a `dynamic_cast` conversion from the `D` pointer to an `E` pointer, then a conversion (either `dynamic_cast` or an implicit conversion) from `E` to `B`, and finally an implicit conversion from `B` to `A`. For example:  \n  \n```  \n// dynamic_cast_5.cpp  \n// compile with: /c /GR  \nclass A {virtual void f();};  \nclass B : public A {virtual void f();};  \nclass C : public A { };  \nclass D {virtual void f();};  \nclass E : public B, public C, public D {virtual void f();};  \n  \nvoid f(D* pd) {  \n   E* pe = dynamic_cast<E*>(pd);  \n   B* pb = pe;   // upcast, implicit conversion  \n   A* pa = pb;   // upcast, implicit conversion  \n}  \n```  \n  \n The `dynamic_cast` operator can also be used to perform a \"cross cast.\" Using the same class hierarchy, it is possible to cast a pointer, for example, from the `B` subobject to the `D` subobject, as long as the complete object is of type `E`.  \n  \n Considering cross casts, it is actually possible to do the conversion from a pointer to `D` to a pointer to the left-most `A` subobject in just two steps. You can perform a cross cast from `D` to `B`, then an implicit conversion from `B` to `A`. For example:  \n  \n```  \n// dynamic_cast_6.cpp  \n// compile with: /c /GR  \nclass A {virtual void f();};  \nclass B : public A {virtual void f();};  \nclass C : public A { };  \nclass D {virtual void f();};  \nclass E : public B, public C, public D {virtual void f();};  \n  \nvoid f(D* pd) {  \n   B* pb = dynamic_cast<B*>(pd);   // cross cast  \n   A* pa = pb;   // upcast, implicit conversion  \n}  \n```  \n  \n A null pointer value is converted to the null pointer value of the destination type by `dynamic_cast`.  \n  \n When you use `dynamic_cast < type-id > ( expression )`, if `expression` cannot be safely converted to type `type-id`, the run-time check causes the cast to fail. For example:  \n  \n```  \n// dynamic_cast_7.cpp  \n// compile with: /c /GR  \nclass A {virtual void f();};  \nclass B {virtual void f();};  \n  \nvoid f() {  \n   A* pa = new A;  \n   B* pb = dynamic_cast<B*>(pa);   // fails at runtime, not safe;  \n   // B not derived from A  \n}  \n```  \n  \n The value of a failed cast to pointer type is the null pointer. A failed cast to reference type throws a [bad_cast Exception](../cpp/bad-cast-exception.md).   If `expression` does not point to or reference a valid object, a `__non_rtti_object` exception is thrown.  \n  \n See [typeid](../cpp/typeid-operator.md) for an explanation of the `__non_rtti_object` exception.  \n  \n## Example  \n The following sample creates the base class (struct A) pointer, to an object (struct C).  This, plus the fact there are virtual functions, enables runtime polymorphism.  \n  \n The sample also calls a non-virtual function in the hierarchy.  \n  \n```  \n// dynamic_cast_8.cpp  \n// compile with: /GR /EHsc  \n#include <stdio.h>  \n#include <iostream>  \n  \nstruct A {  \n    virtual void test() {  \n        printf_s(\"in A\\n\");  \n   }  \n};  \n  \nstruct B : A {  \n    virtual void test() {  \n        printf_s(\"in B\\n\");  \n    }  \n  \n    void test2() {  \n        printf_s(\"test2 in B\\n\");  \n    }  \n};  \n  \nstruct C : B {  \n    virtual void test() {  \n        printf_s(\"in C\\n\");  \n    }  \n  \n    void test2() {  \n        printf_s(\"test2 in C\\n\");  \n    }  \n};  \n  \nvoid Globaltest(A& a) {  \n    try {  \n        C &c = dynamic_cast<C&>(a);  \n        printf_s(\"in GlobalTest\\n\");  \n    }  \n    catch(std::bad_cast) {  \n        printf_s(\"Can't cast to C\\n\");  \n    }  \n}  \n  \nint main() {  \n    A *pa = new C;  \n    A *pa2 = new B;  \n  \n    pa->test();  \n  \n    B * pb = dynamic_cast<B *>(pa);  \n    if (pb)  \n        pb->test2();  \n  \n    C * pc = dynamic_cast<C *>(pa2);  \n    if (pc)  \n        pc->test2();  \n  \n    C ConStack;  \n    Globaltest(ConStack);  \n  \n   // will fail because B knows nothing about C  \n    B BonStack;  \n    Globaltest(BonStack);  \n}  \n```  \n  \n```Output  \nin C  \ntest2 in B  \nin GlobalTest  \nCan't cast to C  \n```  \n  \n## See Also  \n [Casting Operators](../cpp/casting-operators.md)   \n [Keywords](../cpp/keywords-cpp.md)"}