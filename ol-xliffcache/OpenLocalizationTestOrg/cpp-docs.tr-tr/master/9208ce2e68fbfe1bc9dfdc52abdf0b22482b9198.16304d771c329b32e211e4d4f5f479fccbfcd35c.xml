{"nodes":[{"pos":[12,44],"content":"comment (C-C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"comment (C-C++) | Microsoft Docs","pos":[0,32]}]},{"content":"comment (C/C++)","pos":[716,731]},{"content":"Places a comment record into an object file or executable file.","pos":[732,795]},{"content":"Syntax","pos":[804,810]},{"content":"Remarks","pos":[890,897]},{"content":"The <bpt id=\"p1\">*</bpt>comment-type<ept id=\"p1\">*</ept> is one of the predefined identifiers, described below, that specifies the type of comment record.","pos":[901,1017],"source":"The *comment-type* is one of the predefined identifiers, described below, that specifies the type of comment record."},{"content":"The optional <ph id=\"ph1\">`commentstring`</ph> is a string literal that provides additional information for some comment types.","pos":[1018,1127],"source":" The optional `commentstring` is a string literal that provides additional information for some comment types."},{"content":"Because <ph id=\"ph1\">`commentstring`</ph> is a string literal, it obeys all the rules for string literals with respect to escape characters, embedded quotation marks (<bpt id=\"p1\">**</bpt>\"<ept id=\"p1\">**</ept>), and concatenation.","pos":[1128,1303],"source":" Because `commentstring` is a string literal, it obeys all the rules for string literals with respect to escape characters, embedded quotation marks (**\"**), and concatenation."},{"content":"compiler","pos":[1312,1320]},{"content":"Places the name and version number of the compiler in the object file.","pos":[1326,1396]},{"content":"This comment record is ignored by the linker.","pos":[1397,1442]},{"content":"If you supply a <ph id=\"ph1\">`commentstring`</ph> parameter for this record type, the compiler generates a warning.","pos":[1443,1540],"source":" If you supply a `commentstring` parameter for this record type, the compiler generates a warning."},{"content":"exestr","pos":[1549,1555]},{"content":"Places <ph id=\"ph1\">`commentstring`</ph> in the object file.","pos":[1561,1603],"source":" Places `commentstring` in the object file."},{"content":"At link time this string is placed in the executable file.","pos":[1604,1662]},{"content":"The string is not loaded into memory when the executable file is loaded; however, it can be found with a program that finds printable strings in files.","pos":[1663,1814]},{"content":"One use for this comment-record type is to embed a version number or similar information in an executable file.","pos":[1815,1926]},{"pos":[1942,2044],"content":"is deprecated and will be removed in a future release; the linker does not process the comment record."},{"content":"lib","pos":[2053,2056]},{"content":"Places a library-search record in the object file.","pos":[2062,2112]},{"content":"This comment type must be accompanied by a <ph id=\"ph1\">`commentstring`</ph> parameter containing the name (and possibly the path) of the library that you want the linker to search.","pos":[2113,2276],"source":" This comment type must be accompanied by a `commentstring` parameter containing the name (and possibly the path) of the library that you want the linker to search."},{"content":"The library name follows the default library-search records in the object file; the linker searches for this library just as if you had named it on the command line provided that the library is not specified with <bpt id=\"p1\">[</bpt>/nodefaultlib<ept id=\"p1\">](../build/reference/nodefaultlib-ignore-libraries.md)</ept>.","pos":[2277,2559],"source":" The library name follows the default library-search records in the object file; the linker searches for this library just as if you had named it on the command line provided that the library is not specified with [/nodefaultlib](../build/reference/nodefaultlib-ignore-libraries.md)."},{"content":"You can place multiple library-search records in the same source file; each record appears in the object file in the same order in which it is encountered in the source file.","pos":[2560,2734]},{"content":"If the order of the default library and an added library is important, compiling with the <bpt id=\"p1\">[</bpt>/Zl<ept id=\"p1\">](../build/reference/zl-omit-default-library-name.md)</ept> switch will prevent the default library name from being placed in the object module.","pos":[2741,2973],"source":"If the order of the default library and an added library is important, compiling with the [/Zl](../build/reference/zl-omit-default-library-name.md) switch will prevent the default library name from being placed in the object module."},{"content":"A second comment pragma then can be used to insert the name of the default library after the added library.","pos":[2974,3081]},{"content":"The libraries listed with these pragmas will appear in the object module in the same order they are found in the source code.","pos":[3082,3207]},{"content":"linker","pos":[3216,3222]},{"content":"Places a <bpt id=\"p1\">[</bpt>linker option<ept id=\"p1\">](../build/reference/linker-options.md)</ept> in the object file.","pos":[3228,3310],"source":" Places a [linker option](../build/reference/linker-options.md) in the object file."},{"content":"You can use this comment-type to specify a linker option instead of passing it to the command line or specifying it in the development environment.","pos":[3311,3458]},{"content":"For example, you can specify the /include option to force the inclusion of a symbol:","pos":[3459,3543]},{"pos":[3614,3717],"content":"Only the following (<bpt id=\"p1\">*</bpt>comment-type<ept id=\"p1\">*</ept>) linker options are available to be passed to the linker identifier:","source":"Only the following (*comment-type*) linker options are available to be passed to the linker identifier:"},{"content":"/DEFAULTLIB","pos":[3728,3739]},{"content":"/EXPORT","pos":[3809,3816]},{"content":"/INCLUDE","pos":[3877,3885]},{"content":"/MANIFESTDEPENDENCY","pos":[3952,3971]},{"content":"/MERGE","pos":[4055,4061]},{"content":"/SECTION","pos":[4119,4127]},{"pos":[4193,4359],"content":"**user**  \nPlaces a general comment in the object file. The `commentstring` parameter contains the text of the comment. This comment record is ignored by the linker.","leadings":[""," "],"nodes":[{"content":"user","pos":[2,6]},{"content":"Places a general comment in the object file. The `commentstring` parameter contains the text of the comment. This comment record is ignored by the linker.","pos":[11,165],"nodes":[{"content":"Places a general comment in the object file.","pos":[0,44]},{"content":"The <ph id=\"ph1\">`commentstring`</ph> parameter contains the text of the comment.","pos":[45,108],"source":" The `commentstring` parameter contains the text of the comment."},{"content":"This comment record is ignored by the linker.","pos":[109,154]}]}]},{"content":"The following pragma causes the linker to search for the EMAPI.LIB library while linking.","pos":[4366,4455]},{"content":"The linker searches first in the current working directory and then in the path specified in the LIB environment variable.","pos":[4456,4578]},{"content":"The following pragma causes the compiler to place the name and version number of the compiler in the object file:","pos":[4634,4747]},{"pos":[4800,5141],"content":"[!NOTE]\n For comments that take a `commentstring` parameter, you can use a macro in any place where you would use a string literal, provided that the macro expands to a string literal. You can also concatenate any combination of string literals and macros that expand to string literals. For example, the following statement is acceptable:","leadings":["","> "],"nodes":[{"content":" For comments that take a `commentstring` parameter, you can use a macro in any place where you would use a string literal, provided that the macro expands to a string literal. You can also concatenate any combination of string literals and macros that expand to string literals. For example, the following statement is acceptable:","pos":[8,339],"nodes":[{"content":"For comments that take a <ph id=\"ph1\">`commentstring`</ph> parameter, you can use a macro in any place where you would use a string literal, provided that the macro expands to a string literal.","pos":[1,176],"source":" For comments that take a `commentstring` parameter, you can use a macro in any place where you would use a string literal, provided that the macro expands to a string literal."},{"content":"You can also concatenate any combination of string literals and macros that expand to string literals.","pos":[177,279]},{"content":"For example, the following statement is acceptable:","pos":[280,331]}]}]},{"content":"See Also","pos":[5233,5241]},{"content":"Pragma Directives and the __Pragma Keyword","pos":[5246,5288]}],"content":"---\ntitle: \"comment (C-C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc-pragma.comment\"\n  - \"comment_CPP\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"annotations [C++]\"\n  - \"comments [C++], compiled files\"\n  - \"pragmas, comment\"\n  - \"comment pragma\"\nms.assetid: 20f099ff-6303-49b3-9c03-a94b6aa69b85\ncaps.latest.revision: 11\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# comment (C/C++)\nPlaces a comment record into an object file or executable file.  \n  \n## Syntax  \n  \n```  \n  \n#pragma comment( comment-type [,\"commentstring\"] )  \n```  \n  \n## Remarks  \n The *comment-type* is one of the predefined identifiers, described below, that specifies the type of comment record. The optional `commentstring` is a string literal that provides additional information for some comment types. Because `commentstring` is a string literal, it obeys all the rules for string literals with respect to escape characters, embedded quotation marks (**\"**), and concatenation.  \n  \n **compiler**  \n Places the name and version number of the compiler in the object file. This comment record is ignored by the linker. If you supply a `commentstring` parameter for this record type, the compiler generates a warning.  \n  \n **exestr**  \n Places `commentstring` in the object file. At link time this string is placed in the executable file. The string is not loaded into memory when the executable file is loaded; however, it can be found with a program that finds printable strings in files. One use for this comment-record type is to embed a version number or similar information in an executable file.  \n  \n `exestr` is deprecated and will be removed in a future release; the linker does not process the comment record.  \n  \n **lib**  \n Places a library-search record in the object file. This comment type must be accompanied by a `commentstring` parameter containing the name (and possibly the path) of the library that you want the linker to search. The library name follows the default library-search records in the object file; the linker searches for this library just as if you had named it on the command line provided that the library is not specified with [/nodefaultlib](../build/reference/nodefaultlib-ignore-libraries.md). You can place multiple library-search records in the same source file; each record appears in the object file in the same order in which it is encountered in the source file.  \n  \n If the order of the default library and an added library is important, compiling with the [/Zl](../build/reference/zl-omit-default-library-name.md) switch will prevent the default library name from being placed in the object module. A second comment pragma then can be used to insert the name of the default library after the added library. The libraries listed with these pragmas will appear in the object module in the same order they are found in the source code.  \n  \n **linker**  \n Places a [linker option](../build/reference/linker-options.md) in the object file. You can use this comment-type to specify a linker option instead of passing it to the command line or specifying it in the development environment. For example, you can specify the /include option to force the inclusion of a symbol:  \n  \n```  \n#pragma comment(linker, \"/include:__mySymbol\")  \n```  \n  \n Only the following (*comment-type*) linker options are available to be passed to the linker identifier:  \n  \n-   [/DEFAULTLIB](../build/reference/defaultlib-specify-default-library.md)  \n  \n-   [/EXPORT](../build/reference/export-exports-a-function.md)  \n  \n-   [/INCLUDE](../build/reference/include-force-symbol-references.md)  \n  \n-   [/MANIFESTDEPENDENCY](../build/reference/manifestdependency-specify-manifest-dependencies.md)  \n  \n-   [/MERGE](../build/reference/merge-combine-sections.md)  \n  \n-   [/SECTION](../build/reference/section-specify-section-attributes.md)  \n  \n **user**  \n Places a general comment in the object file. The `commentstring` parameter contains the text of the comment. This comment record is ignored by the linker.  \n  \n The following pragma causes the linker to search for the EMAPI.LIB library while linking. The linker searches first in the current working directory and then in the path specified in the LIB environment variable.  \n  \n```  \n#pragma comment( lib, \"emapi\" )  \n```  \n  \n The following pragma causes the compiler to place the name and version number of the compiler in the object file:  \n  \n```  \n#pragma comment( compiler )  \n```  \n  \n> [!NOTE]\n>  For comments that take a `commentstring` parameter, you can use a macro in any place where you would use a string literal, provided that the macro expands to a string literal. You can also concatenate any combination of string literals and macros that expand to string literals. For example, the following statement is acceptable:  \n  \n```  \n#pragma comment( user, \"Compiled on \" __DATE__ \" at \" __TIME__ )   \n```  \n  \n## See Also  \n [Pragma Directives and the __Pragma Keyword](../preprocessor/pragma-directives-and-the-pragma-keyword.md)"}