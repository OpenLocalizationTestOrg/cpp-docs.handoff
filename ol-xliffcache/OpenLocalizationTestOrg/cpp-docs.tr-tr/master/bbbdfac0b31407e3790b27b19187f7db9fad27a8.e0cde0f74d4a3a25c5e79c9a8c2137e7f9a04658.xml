{"nodes":[{"pos":[12,63],"content":"String  (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"String  (C++ Component Extensions) | Microsoft Docs","pos":[0,51]}]},{"content":"String  (C++ Component Extensions)","pos":[657,691]},{"content":"The Visual C++ compiler supports <bpt id=\"p1\">*</bpt>strings<ept id=\"p1\">*</ept>, which are objects that represent text as a sequence of characters.","pos":[692,802],"source":"The Visual C++ compiler supports *strings*, which are objects that represent text as a sequence of characters."},{"content":"Visual C++ supports string variables, whose value is implicit, and literals, whose value is an explicit quoted string.","pos":[803,921]},{"content":"All Runtimes","pos":[930,942]},{"content":"The Windows Runtime and common language runtime represent strings as objects whose allocated memory is managed automatically.","pos":[946,1071]},{"content":"That is, you are not required to explicitly discard the memory for a string when the string variable goes out of scope or your application ends.","pos":[1072,1216]},{"content":"To indicate that the lifetime of a string object is to be managed automatically, declare the string type with the <bpt id=\"p1\">[</bpt>handle-to-object (^)<ept id=\"p1\">](../windows/handle-to-object-operator-hat-cpp-component-extensions.md)</ept> modifier.","pos":[1217,1433],"source":" To indicate that the lifetime of a string object is to be managed automatically, declare the string type with the [handle-to-object (^)](../windows/handle-to-object-operator-hat-cpp-component-extensions.md) modifier."},{"content":"Windows Runtime","pos":[1442,1457]},{"content":"The Windows Runtime architecture requires Visual C++ to implement the <ph id=\"ph1\">`String`</ph> data type in the <ph id=\"ph2\">`Platform`</ph> namespace.","pos":[1461,1578],"source":"The Windows Runtime architecture requires Visual C++ to implement the `String` data type in the `Platform` namespace."},{"content":"For your convenience, Visual C++ also provides the <ph id=\"ph1\">`string`</ph> data type, which is a synonym for <ph id=\"ph2\">`Platform::String`</ph>, in the <ph id=\"ph3\">`default`</ph> namespace.","pos":[1579,1720],"source":" For your convenience, Visual C++ also provides the `string` data type, which is a synonym for `Platform::String`, in the `default` namespace."},{"content":"Syntax","pos":[1730,1736]},{"content":"Remarks","pos":[2001,2008]},{"pos":[2012,2192],"content":"For more information and examples about strings, see <bpt id=\"p1\">[</bpt>Platform::String, std::wstring, and Literals (Platform)<ept id=\"p1\">](http://msdn.microsoft.com/en-us/ec92fbc6-edf3-4137-a85e-8e29bdb857a8)</ept>","source":"For more information and examples about strings, see [Platform::String, std::wstring, and Literals (Platform)](http://msdn.microsoft.com/en-us/ec92fbc6-edf3-4137-a85e-8e29bdb857a8)"},{"content":"Requirements","pos":[2202,2214]},{"pos":[2218,2242],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Common Language Runtime","pos":[2251,2274]},{"content":"This topic discusses how the Visual C++ compiler processes string literals when you run it by using the <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> compiler option.","pos":[2278,2407],"source":"This topic discusses how the Visual C++ compiler processes string literals when you run it by using the **/clr** compiler option."},{"content":"To use <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>, you must also use the common language runtime (CLR), C++/CLI syntax and managed objects.","pos":[2408,2513],"source":" To use **/clr**, you must also use the common language runtime (CLR), C++/CLI syntax and managed objects."},{"content":"For more information about <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>, see <bpt id=\"p2\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p2\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>.","pos":[2514,2663],"source":" For more information about **/clr**, see [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md)."},{"content":"When compiling with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>, the compiler will convert string literals to strings of type &lt;xref:System.String&gt;.","pos":[2670,2782],"source":"When compiling with **/clr**, the compiler will convert string literals to strings of type <xref:System.String>."},{"content":"To preserve backward compatibility with existing code there are two exceptions to this:","pos":[2783,2870]},{"content":"Exception handling.","pos":[2880,2899]},{"content":"When a string literal is thrown, the compiler will catch it as a string literal.","pos":[2900,2980]},{"content":"Template deduction.","pos":[2990,3009]},{"content":"When a string literal is passed as a template argument, the compiler will not convert it to a &lt;xref:System.String&gt;.","pos":[3010,3125],"source":" When a string literal is passed as a template argument, the compiler will not convert it to a <xref:System.String>."},{"content":"Note, string literals passed as a generic argument will be promoted to &lt;xref:System.String&gt;.","pos":[3126,3218],"source":" Note, string literals passed as a generic argument will be promoted to <xref:System.String>."},{"content":"The compiler also has built-in support for three operators, which you can override to customize their behavior:","pos":[3225,3336]},{"content":"System::String ^ operator +( System::String, System::String);","pos":[3346,3407]},{"content":"System::String ^ operator +( System::Object, System::String);","pos":[3417,3478]},{"content":"System::String ^ operator +( System::String, System::Object);","pos":[3488,3549]},{"content":"When passed a &lt;xref:System.String&gt;, the compiler will box, if necessary, and then concatenate the object (with ToString) with the string.","pos":[3556,3693],"source":"When passed a <xref:System.String>, the compiler will box, if necessary, and then concatenate the object (with ToString) with the string."},{"pos":[3701,3805],"content":"[!NOTE]\n The caret (\"^\") indicates that the declared variable is a handle to a C++/CLI managed object.","leadings":["","> "],"nodes":[{"content":"The caret (\"^\") indicates that the declared variable is a handle to a C++/CLI managed object.","pos":[9,102]}]},{"pos":[3812,3914],"content":"For more information see <bpt id=\"p1\">[</bpt>String and Character Literals<ept id=\"p1\">](../cpp/string-and-character-literals-cpp.md)</ept>.","source":"For more information see [String and Character Literals](../cpp/string-and-character-literals-cpp.md)."},{"content":"Requirements","pos":[3924,3936]},{"pos":[3940,3965],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[3975,3983]},{"content":"Example","pos":[3989,3996]},{"content":"The following code example demonstrates concatenating and comparing strings.","pos":[4005,4081]},{"content":"Output","pos":[5552,5558]},{"content":"Example","pos":[5777,5784]},{"content":"The following sample shows that you can overload the compiler-provided operators, and that the compiler will find a function overload based on the &lt;xref:System.String&gt; type.","pos":[5793,5966],"source":"The following sample shows that you can overload the compiler-provided operators, and that the compiler will find a function overload based on the <xref:System.String> type."},{"content":"Output","pos":[7166,7172]},{"content":"Example","pos":[7366,7373]},{"content":"The following sample shows that the compiler distinguishes between native strings and &lt;xref:System.String&gt; strings.","pos":[7382,7497],"source":"The following sample shows that the compiler distinguishes between native strings and <xref:System.String> strings."},{"content":"Output","pos":[8180,8186]},{"content":"See Also","pos":[8282,8290]},{"content":"Component Extensions for Runtime Platforms","pos":[8295,8337]},{"content":"String and Character Literals","pos":[8402,8431]},{"content":"/clr (Common Language Runtime Compilation)","pos":[8483,8525]}],"content":"---\ntitle: \"String  (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"string support with /clr\"\n  - \"/clr compiler option [C++], string support\"\nms.assetid: c695f965-9be0-4e20-9661-373bfee6557e\ncaps.latest.revision: 19\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# String  (C++ Component Extensions)\nThe Visual C++ compiler supports *strings*, which are objects that represent text as a sequence of characters. Visual C++ supports string variables, whose value is implicit, and literals, whose value is an explicit quoted string.  \n  \n## All Runtimes  \n The Windows Runtime and common language runtime represent strings as objects whose allocated memory is managed automatically. That is, you are not required to explicitly discard the memory for a string when the string variable goes out of scope or your application ends. To indicate that the lifetime of a string object is to be managed automatically, declare the string type with the [handle-to-object (^)](../windows/handle-to-object-operator-hat-cpp-component-extensions.md) modifier.  \n  \n## Windows Runtime  \n The Windows Runtime architecture requires Visual C++ to implement the `String` data type in the `Platform` namespace. For your convenience, Visual C++ also provides the `string` data type, which is a synonym for `Platform::String`, in the `default` namespace.  \n  \n### Syntax  \n  \n```cpp  \n  \n// compile with /ZW  \nusing namespace Platform;  \nusing namespace default;  \n   Platform::String^ MyString1 = \"The quick brown fox\";  \n   String^ MyString2 = \"jumped over the lazy dog.\";  \n   String^ MyString3 = \"Hello, world!\";  \n  \n```  \n  \n### Remarks  \n For more information and examples about strings, see [Platform::String, std::wstring, and Literals (Platform)](http://msdn.microsoft.com/en-us/ec92fbc6-edf3-4137-a85e-8e29bdb857a8)  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## Common Language Runtime  \n This topic discusses how the Visual C++ compiler processes string literals when you run it by using the **/clr** compiler option. To use **/clr**, you must also use the common language runtime (CLR), C++/CLI syntax and managed objects. For more information about **/clr**, see [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md).  \n  \n When compiling with **/clr**, the compiler will convert string literals to strings of type <xref:System.String>. To preserve backward compatibility with existing code there are two exceptions to this:  \n  \n-   Exception handling. When a string literal is thrown, the compiler will catch it as a string literal.  \n  \n-   Template deduction. When a string literal is passed as a template argument, the compiler will not convert it to a <xref:System.String>. Note, string literals passed as a generic argument will be promoted to <xref:System.String>.  \n  \n The compiler also has built-in support for three operators, which you can override to customize their behavior:  \n  \n-   System::String ^ operator +( System::String, System::String);  \n  \n-   System::String ^ operator +( System::Object, System::String);  \n  \n-   System::String ^ operator +( System::String, System::Object);  \n  \n When passed a <xref:System.String>, the compiler will box, if necessary, and then concatenate the object (with ToString) with the string.  \n  \n> [!NOTE]\n>  The caret (\"^\") indicates that the declared variable is a handle to a C++/CLI managed object.  \n  \n For more information see [String and Character Literals](../cpp/string-and-character-literals-cpp.md).  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n The following code example demonstrates concatenating and comparing strings.  \n  \n```cpp  \n// string_operators.cpp  \n// compile with: /clr  \n// In the following code, the caret (\"^\") indicates that the   \n// declared variable is a handle to a C++/CLI managed object.  \nusing namespace System;  \n  \nint main() {  \n   String ^ a = gcnew String(\"abc\");  \n   String ^ b = \"def\";   // same as gcnew form  \n   Object ^ c = gcnew String(\"ghi\");  \n  \n   char d[100] = \"abc\";  \n  \n   // variables of System::String returning a System::String  \n   Console::WriteLine(a + b);  \n   Console::WriteLine(a + c);  \n   Console::WriteLine(c + a);  \n  \n   // accessing a character in the string  \n   Console::WriteLine(a[2]);  \n  \n   // concatenation of three System::Strings  \n   Console::WriteLine(a + b + c);  \n  \n   // concatenation of a System::String and string literal  \n   Console::WriteLine(a + \"zzz\");  \n  \n   // you can append to a System::String ^  \n   Console::WriteLine(a + 1);  \n   Console::WriteLine(a + 'a');  \n   Console::WriteLine(a + 3.1);  \n  \n   // test System::String ^ for equality  \n   a += b;  \n   Console::WriteLine(a);  \n   a = b;  \n   if (a == b)  \n      Console::WriteLine(\"a and b are equal\");  \n  \n   a = \"abc\";  \n   if (a != b)  \n      Console::WriteLine(\"a and b are not equal\");  \n  \n   // System:String ^ and tracking reference  \n   String^% rstr1 = a;  \n   Console::WriteLine(rstr1);  \n  \n   // testing an empty System::String ^  \n   String ^ n;  \n   if (n == nullptr)  \n      Console::WriteLine(\"n is empty\");  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nabcdef  \n  \nabcghi  \n  \nghiabc  \n  \nc  \n  \nabcdefghi  \n  \nabczzz  \n  \nabc1  \n  \nabc97  \n  \nabc3.1  \n  \nabcdef  \n  \na and b are equal  \n  \na and b are not equal  \n  \nabc  \n  \nn is empty  \n```  \n  \n **Example**  \n  \n The following sample shows that you can overload the compiler-provided operators, and that the compiler will find a function overload based on the <xref:System.String> type.  \n  \n```cpp  \n// string_operators_2.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \n// a string^ overload will be favored when calling with a String  \nvoid Test_Overload(const char * a) {   \n   Console::WriteLine(\"const char * a\");   \n}  \nvoid Test_Overload(String ^ a) {   \n   Console::WriteLine(\"String ^ a\");   \n}  \n  \n// overload will be called instead of compiler defined operator  \nString ^ operator +(String ^ a, String ^ b) {  \n   return (\"overloaded +(String ^ a, String ^ b)\");  \n}  \n  \n// overload will be called instead of compiler defined operator  \nString ^ operator +(Object ^ a, String ^ b) {  \n   return (\"overloaded +(Object ^ a, String ^ b)\");  \n}  \n  \n// overload will be called instead of compiler defined operator  \nString ^ operator +(String ^ a, Object ^ b) {  \n   return (\"overloaded +(String ^ a, Object ^ b)\");  \n}  \n  \nint main() {  \n   String ^ a = gcnew String(\"abc\");  \n   String ^ b = \"def\";   // same as gcnew form  \n   Object ^ c = gcnew String(\"ghi\");  \n  \n   char d[100] = \"abc\";  \n  \n   Console::WriteLine(a + b);  \n   Console::WriteLine(a + c);  \n   Console::WriteLine(c + a);  \n  \n   Test_Overload(\"hello\");  \n   Test_Overload(d);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \noverloaded +(String ^ a, String ^ b)   \n  \noverloaded +(String ^ a, Object ^ b)   \n  \noverloaded +(Object ^ a, String ^ b)   \n  \nString ^ a  \n  \nconst char * a  \n```  \n  \n **Example**  \n  \n The following sample shows that the compiler distinguishes between native strings and <xref:System.String> strings.  \n  \n```cpp  \n// string_operators_3.cpp  \n// compile with: /clr  \nusing namespace System;  \nint func() {  \n   throw \"simple string\";   // const char *  \n};  \n  \nint func2() {  \n   throw \"string\" + \"string\";   // returns System::String  \n};  \n  \ntemplate<typename T>  \nvoid func3(T t) {  \n   Console::WriteLine(T::typeid);  \n}  \n  \nint main() {  \n   try {  \n      func();  \n   }  \n   catch(char * e) {  \n      Console::WriteLine(\"char *\");  \n   }  \n  \n   try {  \n      func2();  \n   }  \n   catch(String^ str) {  \n      Console::WriteLine(\"String^ str\");  \n   }  \n  \n   func3(\"string\");   // const char *  \n   func3(\"string\" + \"string\");   // returns System::String  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nchar *  \n  \nString^ str  \n  \nSystem.SByte*  \n  \nSystem.String  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)   \n [String and Character Literals](../cpp/string-and-character-literals-cpp.md)   \n [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md)"}