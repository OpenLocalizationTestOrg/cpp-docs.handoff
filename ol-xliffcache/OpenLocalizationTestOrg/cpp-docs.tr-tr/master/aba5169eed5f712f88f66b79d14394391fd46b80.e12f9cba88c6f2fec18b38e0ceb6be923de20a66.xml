{"nodes":[{"pos":[12,51],"content":"Sample Container Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Sample Container Class | Microsoft Docs","pos":[0,39]}]},{"pos":[578,600],"content":"Sample Container Class","linkify":"Sample Container Class","nodes":[{"content":"Sample Container Class","pos":[0,22]}]},{"pos":[603,817],"content":"[!NOTE]\n This topic is in the Visual C++ documentation as a nonfunctional example of containers used in the Standard C++ Library. For more information, see [STL Containers](../standard-library/stl-containers.md).","leadings":["","> "],"nodes":[{"content":" This topic is in the Visual C++ documentation as a nonfunctional example of containers used in the Standard C++ Library. For more information, see [STL Containers](../standard-library/stl-containers.md).","pos":[8,212],"nodes":[{"content":"This topic is in the Visual C++ documentation as a nonfunctional example of containers used in the Standard C++ Library.","pos":[1,121]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>STL Containers<ept id=\"p1\">](../standard-library/stl-containers.md)</ept>.","pos":[122,204],"source":" For more information, see [STL Containers](../standard-library/stl-containers.md)."}]}]},{"content":"Describes an object that controls a varying-length sequence of elements, typically of type <bpt id=\"p1\">**</bpt>Ty<ept id=\"p1\">**</ept>.","pos":[824,922],"source":"Describes an object that controls a varying-length sequence of elements, typically of type **Ty**."},{"content":"The sequence is stored in different ways, depending on the actual container.","pos":[923,999]},{"content":"A container constructor or member function may find occasion to call the constructor <bpt id=\"p1\">**</bpt>Ty<ept id=\"p1\">**</ept>(<bpt id=\"p2\">**</bpt>const Ty&amp;<ept id=\"p2\">**</ept>) or the function <bpt id=\"p3\">**</bpt>Ty::operator=<ept id=\"p3\">**</ept>(<bpt id=\"p4\">**</bpt>const Ty&amp;<ept id=\"p4\">**</ept>).","pos":[1006,1162],"source":"A container constructor or member function may find occasion to call the constructor **Ty**(**const Ty&**) or the function **Ty::operator=**(**const Ty&**)."},{"content":"If such a call throws an exception, the container object is obliged to maintain its integrity, and to rethrow any exception it catches.","pos":[1163,1298]},{"content":"You can safely swap, assign to, erase, or destroy a container object after it throws one of these exceptions.","pos":[1299,1408]},{"content":"In general, however, you cannot otherwise predict the state of the sequence controlled by the container object.","pos":[1409,1520]},{"content":"A few additional caveats:","pos":[1527,1552]},{"pos":[1562,1666],"content":"If the expression <bpt id=\"p1\">**</bpt>~Ty<ept id=\"p1\">**</ept> throws an exception, the resulting state of the container object is undefined.","source":"If the expression **~Ty** throws an exception, the resulting state of the container object is undefined."},{"pos":[1676,1867],"content":"If the container stores an allocator object <bpt id=\"p1\">*</bpt>al<ept id=\"p1\">*</ept>, and <bpt id=\"p2\">*</bpt>al<ept id=\"p2\">*</ept> throws an exception other than as a result of a call to <bpt id=\"p3\">*</bpt>al<ept id=\"p3\">*</ept><bpt id=\"p4\">**</bpt>.allocate<ept id=\"p4\">**</ept>, the resulting state of the container object is undefined.","source":"If the container stores an allocator object *al*, and *al* throws an exception other than as a result of a call to *al***.allocate**, the resulting state of the container object is undefined."},{"pos":[1877,2079],"content":"If the container stores a function object <bpt id=\"p1\">*</bpt>comp<ept id=\"p1\">*</ept>, to determine how to order the controlled sequence, and <bpt id=\"p2\">*</bpt>comp<ept id=\"p2\">*</ept> throws an exception of any kind, the resulting state of the container object is undefined.","source":"If the container stores a function object *comp*, to determine how to order the controlled sequence, and *comp* throws an exception of any kind, the resulting state of the container object is undefined."},{"content":"The container classes defined by STL satisfy several additional requirements, as described in the following paragraphs.","pos":[2086,2205]},{"content":"Container template class <bpt id=\"p1\">[</bpt>list<ept id=\"p1\">](../standard-library/list-class.md)</ept> provides deterministic, and useful, behavior even in the presence of the exceptions described above.","pos":[2212,2379],"source":"Container template class [list](../standard-library/list-class.md) provides deterministic, and useful, behavior even in the presence of the exceptions described above."},{"content":"For example, if an exception is thrown during the insertion of one or more elements, the container is left unaltered and the exception is rethrown.","pos":[2380,2527]},{"pos":[2534,2655],"content":"For <bpt id=\"p1\">*</bpt>all<ept id=\"p1\">*</ept> the container classes defined by STL, if an exception is thrown during calls to the following member functions:","source":"For *all* the container classes defined by STL, if an exception is thrown during calls to the following member functions:"},{"content":"the container is left unaltered and the exception is rethrown.","pos":[2848,2910]},{"pos":[2917,3035],"content":"For <bpt id=\"p1\">*</bpt>all<ept id=\"p1\">*</ept> the container classes defined by STL, no exception is thrown during calls to the following member functions:","source":"For *all* the container classes defined by STL, no exception is thrown during calls to the following member functions:"},{"pos":[3153,3326],"content":"The member function <bpt id=\"p1\">[</bpt>erase<ept id=\"p1\">](../standard-library/container-class-erase.md)</ept> throws an exception only if a copy operation (assignment or copy construction) throws an exception.","source":"The member function [erase](../standard-library/container-class-erase.md) throws an exception only if a copy operation (assignment or copy construction) throws an exception."},{"content":"Moreover, no exception is thrown while copying an iterator returned by a member function.","pos":[3333,3422]},{"pos":[3429,3570],"content":"The member function <bpt id=\"p1\">[</bpt>swap<ept id=\"p1\">](../standard-library/container-class-swap.md)</ept> makes additional promises for <bpt id=\"p2\">*</bpt>all<ept id=\"p2\">*</ept> container classes defined by STL:","source":"The member function [swap](../standard-library/container-class-swap.md) makes additional promises for *all* container classes defined by STL:"},{"pos":[3580,3714],"content":"The member function throws an exception only if the container stores an allocator object al, and <ph id=\"ph1\">`al`</ph> throws an exception when copied.","source":"The member function throws an exception only if the container stores an allocator object al, and `al` throws an exception when copied."},{"content":"References, pointers, and iterators that designate elements of the controlled sequences being swapped remain valid.","pos":[3724,3839]},{"content":"An object of a container class defined by STL allocates and frees storage for the sequence it controls through a stored object of type <ph id=\"ph1\">`Alloc`</ph>, which is typically a template parameter.","pos":[3846,4030],"source":"An object of a container class defined by STL allocates and frees storage for the sequence it controls through a stored object of type `Alloc`, which is typically a template parameter."},{"content":"Such an allocator object must have the same external interface as an object of class <bpt id=\"p1\">**</bpt>allocator<ph id=\"ph1\">\\&lt;</ph>Ty&gt;<ept id=\"p1\">**</ept>.","pos":[4031,4135],"source":" Such an allocator object must have the same external interface as an object of class **allocator\\<Ty>**."},{"content":"In particular, <ph id=\"ph1\">`Alloc`</ph> must be the same type as <bpt id=\"p1\">**</bpt>Alloc::rebind&lt;value_type&gt;::other<ept id=\"p1\">**</ept>","pos":[4136,4220],"source":" In particular, `Alloc` must be the same type as **Alloc::rebind<value_type>::other**"},{"content":"For <bpt id=\"p1\">*</bpt>all<ept id=\"p1\">*</ept> container classes defined by STL, the member function <bpt id=\"p2\">**</bpt>Alloc get_allocator const;<ept id=\"p2\">**</ept> returns a copy of the stored allocator object.","pos":[4227,4368],"source":"For *all* container classes defined by STL, the member function **Alloc get_allocator const;** returns a copy of the stored allocator object."},{"content":"Note that the stored allocator object is <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> copied when the container object is assigned.","pos":[4369,4461],"source":" Note that the stored allocator object is *not* copied when the container object is assigned."},{"content":"All constructors initialize the value stored in <bpt id=\"p1\">**</bpt>allocator<ept id=\"p1\">**</ept>, to <ph id=\"ph1\">`Alloc`</ph> if the constructor contains no allocator parameter.","pos":[4462,4587],"source":" All constructors initialize the value stored in **allocator**, to `Alloc` if the constructor contains no allocator parameter."},{"content":"According to the C++ Standard, a container class defined by STL can assume that:","pos":[4594,4674]},{"pos":[4684,4727],"content":"All objects of class <ph id=\"ph1\">`Alloc`</ph> compare equal.","source":"All objects of class `Alloc` compare equal."},{"pos":[4737,4798],"content":"Type <bpt id=\"p1\">**</bpt>Alloc::const_pointer<ept id=\"p1\">**</ept> is the same as <bpt id=\"p2\">**</bpt>const Ty <ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept>.","source":"Type **Alloc::const_pointer** is the same as **const Ty \\***."},{"pos":[4808,4869],"content":"Type <bpt id=\"p1\">**</bpt>Alloc::const_reference<ept id=\"p1\">**</ept> is the same as <bpt id=\"p2\">**</bpt>const Ty&amp;<ept id=\"p2\">**</ept>.","source":"Type **Alloc::const_reference** is the same as **const Ty&**."},{"pos":[4879,4928],"content":"Type <bpt id=\"p1\">**</bpt>Alloc::pointer<ept id=\"p1\">**</ept> is the same as <bpt id=\"p2\">**</bpt>Ty <ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept>.","source":"Type **Alloc::pointer** is the same as **Ty \\***."},{"pos":[4938,4987],"content":"Type <bpt id=\"p1\">**</bpt>Alloc::reference<ept id=\"p1\">**</ept> is the same as <bpt id=\"p2\">**</bpt>Ty&amp;<ept id=\"p2\">**</ept>.","source":"Type **Alloc::reference** is the same as **Ty&**."},{"content":"In this implementation, however, containers do not make such simplifying assumptions.","pos":[4994,5079]},{"content":"Thus, they work properly with allocator objects that are more ambitious:","pos":[5080,5152]},{"content":"All objects of class <ph id=\"ph1\">`Alloc`</ph> does not need to compare equal.","pos":[5162,5222],"source":"All objects of class `Alloc` does not need to compare equal."},{"content":"(You can maintain multiple pools of storage.)","pos":[5223,5268]},{"content":"Type <bpt id=\"p1\">**</bpt>Alloc::const_pointer<ept id=\"p1\">**</ept> does not need to be the same as <bpt id=\"p2\">**</bpt>const Ty <ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept>.","pos":[5278,5356],"source":"Type **Alloc::const_pointer** does not need to be the same as **const Ty \\***."},{"content":"(A const pointer can be a class.)","pos":[5357,5390]},{"content":"Type <bpt id=\"p1\">**</bpt>Alloc::pointer<ept id=\"p1\">**</ept> does not need to be the same as <bpt id=\"p2\">**</bpt>Ty <ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept>.","pos":[5400,5466],"source":"Type **Alloc::pointer** does not need to be the same as **Ty \\***."},{"content":"(A pointer can be a class.)","pos":[5467,5494]},{"pos":[5503,5515],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[5519,5550],"content":"<bpt id=\"p1\">**</bpt>Header<ept id=\"p1\">**</ept>: <ph id=\"ph1\">\\&lt;</ph>sample container&gt;","source":"**Header**: \\<sample container>"},{"pos":[5559,5567],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[5571,5633],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>sample container&gt;<ept id=\"p1\">](../standard-library/sample-container.md)</ept>","source":"[\\<sample container>](../standard-library/sample-container.md)"}],"content":"---\ntitle: \"Sample Container Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"container classes\"\nms.assetid: 5b1451f2-c708-45da-bbf0-9e42fd687a1a\ncaps.latest.revision: 10\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Sample Container Class\n> [!NOTE]\n>  This topic is in the Visual C++ documentation as a nonfunctional example of containers used in the Standard C++ Library. For more information, see [STL Containers](../standard-library/stl-containers.md).  \n  \n Describes an object that controls a varying-length sequence of elements, typically of type **Ty**. The sequence is stored in different ways, depending on the actual container.  \n  \n A container constructor or member function may find occasion to call the constructor **Ty**(**const Ty&**) or the function **Ty::operator=**(**const Ty&**). If such a call throws an exception, the container object is obliged to maintain its integrity, and to rethrow any exception it catches. You can safely swap, assign to, erase, or destroy a container object after it throws one of these exceptions. In general, however, you cannot otherwise predict the state of the sequence controlled by the container object.  \n  \n A few additional caveats:  \n  \n-   If the expression **~Ty** throws an exception, the resulting state of the container object is undefined.  \n  \n-   If the container stores an allocator object *al*, and *al* throws an exception other than as a result of a call to *al***.allocate**, the resulting state of the container object is undefined.  \n  \n-   If the container stores a function object *comp*, to determine how to order the controlled sequence, and *comp* throws an exception of any kind, the resulting state of the container object is undefined.  \n  \n The container classes defined by STL satisfy several additional requirements, as described in the following paragraphs.  \n  \n Container template class [list](../standard-library/list-class.md) provides deterministic, and useful, behavior even in the presence of the exceptions described above. For example, if an exception is thrown during the insertion of one or more elements, the container is left unaltered and the exception is rethrown.  \n  \n For *all* the container classes defined by STL, if an exception is thrown during calls to the following member functions:  \n  \n```  \n<A NAME=\"vclrfcontainerinsert\"></A>insert // single element inserted  \n<A NAME=\"vclrfcontainerpushback\"></A>push_back  \n<A NAME=\"vclrfcontainerpushfront\"></A>push_front  \n```  \n  \n the container is left unaltered and the exception is rethrown.  \n  \n For *all* the container classes defined by STL, no exception is thrown during calls to the following member functions:  \n  \n```  \n<A NAME=\"vclrfcontainerpopback\"></A>pop_back  \n<A NAME=\"vclrfcontainerpopfront\"></A>pop_front  \n```  \n  \n The member function [erase](../standard-library/container-class-erase.md) throws an exception only if a copy operation (assignment or copy construction) throws an exception.  \n  \n Moreover, no exception is thrown while copying an iterator returned by a member function.  \n  \n The member function [swap](../standard-library/container-class-swap.md) makes additional promises for *all* container classes defined by STL:  \n  \n-   The member function throws an exception only if the container stores an allocator object al, and `al` throws an exception when copied.  \n  \n-   References, pointers, and iterators that designate elements of the controlled sequences being swapped remain valid.  \n  \n An object of a container class defined by STL allocates and frees storage for the sequence it controls through a stored object of type `Alloc`, which is typically a template parameter. Such an allocator object must have the same external interface as an object of class **allocator\\<Ty>**. In particular, `Alloc` must be the same type as **Alloc::rebind<value_type>::other**  \n  \n For *all* container classes defined by STL, the member function **Alloc get_allocator const;** returns a copy of the stored allocator object. Note that the stored allocator object is *not* copied when the container object is assigned. All constructors initialize the value stored in **allocator**, to `Alloc` if the constructor contains no allocator parameter.  \n  \n According to the C++ Standard, a container class defined by STL can assume that:  \n  \n-   All objects of class `Alloc` compare equal.  \n  \n-   Type **Alloc::const_pointer** is the same as **const Ty \\***.  \n  \n-   Type **Alloc::const_reference** is the same as **const Ty&**.  \n  \n-   Type **Alloc::pointer** is the same as **Ty \\***.  \n  \n-   Type **Alloc::reference** is the same as **Ty&**.  \n  \n In this implementation, however, containers do not make such simplifying assumptions. Thus, they work properly with allocator objects that are more ambitious:  \n  \n-   All objects of class `Alloc` does not need to compare equal. (You can maintain multiple pools of storage.)  \n  \n-   Type **Alloc::const_pointer** does not need to be the same as **const Ty \\***. (A const pointer can be a class.)  \n  \n-   Type **Alloc::pointer** does not need to be the same as **Ty \\***. (A pointer can be a class.)  \n  \n## Requirements  \n **Header**: \\<sample container>  \n  \n## See Also  \n [\\<sample container>](../standard-library/sample-container.md)\n\n"}