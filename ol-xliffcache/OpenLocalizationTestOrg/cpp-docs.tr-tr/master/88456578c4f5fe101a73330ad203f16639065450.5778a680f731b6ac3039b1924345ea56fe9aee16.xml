{"nodes":[{"pos":[12,35],"content":"Unions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Unions | Microsoft Docs","pos":[0,23]}]},{"content":"Unions","pos":[646,652]},{"content":"A <ph id=\"ph1\">`union`</ph> is a user-defined type in which all members share the same memory location.","pos":[653,738],"source":"A `union` is a user-defined type in which all members share the same memory location."},{"content":"This means that at any given time a union can contain no more than one object from its list of members.","pos":[739,842]},{"content":"It also means that no matter how many members a union has, it always uses only enough memory to store the largest member.","pos":[843,964]},{"content":"Unions can be useful for conserving memory when you have lots of objects and/or limited memory.","pos":[971,1066]},{"content":"However they require extra care to use correctly because you are responsible for ensuring that you always access the last member that was written to.","pos":[1067,1216]},{"content":"If any member types have a non-trivial constructor, then you must write additional code to explicitly construct and destroy that member.","pos":[1217,1353]},{"content":"Before using a union, consider whether the problem you are trying to solve could be better expressed by using a base class and derived classes.","pos":[1354,1497]},{"content":"Syntax","pos":[1506,1512]},{"content":"Parameters","pos":[1574,1584]},{"content":"The type name given to the union.","pos":[1598,1631]},{"content":"Members that the union can contain.","pos":[1655,1690]},{"content":"See Remarks.","pos":[1691,1703]},{"content":"Remarks","pos":[1712,1719]},{"content":"Declaring a Union","pos":[1728,1745]},{"pos":[1749,1852],"content":"Begin the declaration of a union with the <ph id=\"ph1\">`union`</ph> keyword, and enclose the member list in curly braces:","source":"Begin the declaration of a union with the `union` keyword, and enclose the member list in curly braces:"},{"content":"Using unions","pos":[2185,2197]},{"content":"In the previous example, any code that accesses the union needs to know which member is holding the data.","pos":[2201,2306]},{"content":"The most common solution to this problem is to enclose the union in a struct along with an additional enum member that indicates the type of the data currently being stored in the union.","pos":[2307,2493]},{"content":"This is called a <bpt id=\"p1\">*</bpt>discriminated union<ept id=\"p1\">*</ept> and the following example shows the basic pattern.","pos":[2494,2583],"source":" This is called a *discriminated union* and the following example shows the basic pattern."},{"content":"In the previous example, note that the union in the Input struct has no name.","pos":[4116,4193]},{"content":"This is an anonymous union and its members can be accessed as if they were direct members of the struct.","pos":[4194,4298]},{"content":"For more information about anonymous unions, see the section below.","pos":[4299,4366]},{"content":"Of course, the previous example shows a problem that could also be solved by using classes that derive from a common base class, and branching your code based on the runtime type of each object in the container.","pos":[4373,4584]},{"content":"This may result in code that easier to maintain and understand, but it might also be slower than using unions.","pos":[4585,4695]},{"content":"Also, with a union, you can store completely unrelated types, and dynamically change the type of the value that is stored without changing the type of the union variable itself.","pos":[4696,4873]},{"content":"Thus you can create a heterogeneous array of MyUnionType whose elements store different values of different types.","pos":[4874,4988]},{"content":"Note that the <ph id=\"ph1\">`Input`</ph> struct in the preceding example can be easily misused.","pos":[4995,5071],"source":"Note that the `Input` struct in the preceding example can be easily misused."},{"content":"It is completely up to the user to use the discriminator correctly to access the member that holds the data.","pos":[5072,5180]},{"content":"You can protect against misuse by making the union private and providing special access functions, as shown in the next example.","pos":[5181,5309]},{"content":"Unrestricted Unions (C++11)","pos":[5318,5345]},{"content":"In C++03 and earlier a union can contain non-static data members with class type as long as the type has no user provided constructors, destructors or assignment operators.","pos":[5349,5521]},{"content":"In C++11, these restrictions are removed.","pos":[5522,5563]},{"content":"If you include such a member in your union then the compiler will automatically mark any special member functions that are not user provided as deleted.","pos":[5564,5716]},{"content":"If the union is an anonymous union inside a class or struct, then any special member functions of the class or struct that are not user provided are marked as deleted.","pos":[5717,5884]},{"content":"The following example shows how to handle the case where one of the members of the union has a member that requires this special treatment:","pos":[5885,6024]},{"content":"Unions cannot store references.","pos":[15219,15250]},{"content":"Unions donâ€™t support inheritance, therefore a union itself cannot be used as a base class, or inherit from another class, or have virtual functions.","pos":[15251,15399]},{"content":"Initializing unions","pos":[15408,15427]},{"content":"You can declare and initialize a union in the same statement by assigning an expression enclosed in braces.","pos":[15431,15538]},{"content":"The expression is evaluated and assigned to the first field of the union.","pos":[15539,15612]},{"pos":[16022,16116],"content":"The <ph id=\"ph1\">`NumericType`</ph> union is arranged in memory (conceptually) as shown in the following figure.","source":"The `NumericType` union is arranged in memory (conceptually) as shown in the following figure."},{"content":"Storage of data in a numeric type union","pos":[16125,16164]},{"content":"Storage of Data in NumericType Union","pos":[16204,16240]},{"pos":[16281,16297],"content":"Anonymous unions"},{"pos":[16301,16391],"content":"Anonymous unions are unions that are declared without a <bpt id=\"p1\">*</bpt>class-name<ept id=\"p1\">*</ept> or <bpt id=\"p2\">*</bpt>declarator-list<ept id=\"p2\">*</ept>.","source":"Anonymous unions are unions that are declared without a *class-name* or *declarator-list*."},{"content":"Names declared in an anonymous union are used directly, like nonmember variables.","pos":[16444,16525]},{"content":"Therefore, the names declared in an anonymous union must be unique in the surrounding scope.","pos":[16526,16618]},{"content":"In addition to the restrictions for named unions, anonymous unions are subject to these additional restrictions:","pos":[16624,16736]},{"pos":[16746,16826],"content":"They must also be declared as <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> if declared in file or namespace scope.","source":"They must also be declared as **static** if declared in file or namespace scope."},{"content":"They can have only public members; private and protected members in anonymous unions generate errors.","pos":[16836,16937]},{"content":"They cannot have member functions.","pos":[16947,16981]},{"content":"See Also","pos":[16990,16998]},{"content":"Classes and Structs","pos":[17003,17022]},{"content":"Keywords","pos":[17064,17072]},{"content":"class","pos":[17103,17108]},{"content":"struct","pos":[17136,17142]}],"content":"---\ntitle: \"Unions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"union_cpp\"\n  - \"union\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"class types, unions as\"\n  - \"union keyword [C++]\"\nms.assetid: 25c4e219-fcbb-4b7b-9b64-83f3252a92ca\ncaps.latest.revision: 16\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Unions\nA `union` is a user-defined type in which all members share the same memory location. This means that at any given time a union can contain no more than one object from its list of members. It also means that no matter how many members a union has, it always uses only enough memory to store the largest member.  \n  \n Unions can be useful for conserving memory when you have lots of objects and/or limited memory. However they require extra care to use correctly because you are responsible for ensuring that you always access the last member that was written to. If any member types have a non-trivial constructor, then you must write additional code to explicitly construct and destroy that member. Before using a union, consider whether the problem you are trying to solve could be better expressed by using a base class and derived classes.  \n  \n## Syntax  \n  \n```cpp  \nunion [name]  { member-list };  \n```  \n  \n#### Parameters  \n `name`  \n The type name given to the union.  \n  \n `member-list`  \n Members that the union can contain. See Remarks.  \n  \n## Remarks  \n  \n## Declaring a Union  \n Begin the declaration of a union with the `union` keyword, and enclose the member list in curly braces:  \n  \n```cpp  \n// declaring_a_union.cpp  \nunion RecordType    // Declare a simple union type  \n{  \n    char   ch;  \n    int    i;  \n    long   l;  \n    float  f;  \n    double d;  \n    int *int_ptr;  \n};   \nint main()  \n{  \n    RecordType t;  \n    t.i = 5; // t holds an int  \n    t.f = 7.25 // t now holds a float   \n}  \n```  \n  \n## Using unions  \n In the previous example, any code that accesses the union needs to know which member is holding the data. The most common solution to this problem is to enclose the union in a struct along with an additional enum member that indicates the type of the data currently being stored in the union. This is called a *discriminated union* and the following example shows the basic pattern.  \n  \n```cpp  \n  \n#include \"stdafx.h\"  \n#include <queue>  \n  \nusing namespace std;  \n  \nenum class WeatherDataType  \n{  \n    Temperature, Wind  \n};  \n  \nstruct TempData  \n{  \n    int StationId;  \n    time_t time;  \n    double current;  \n    double max;  \n    double min;  \n};  \n  \nstruct WindData  \n{  \n    int StationId;  \n    time_t time;  \n    int speed;  \n    short direction;  \n};  \n  \nstruct Input  \n{  \n    WeatherDataType type;  \n    union  \n    {  \n        TempData temp;  \n        WindData wind;  \n    };  \n};  \n  \n// Functions that are specific to data types  \nvoid Process_Temp(TempData t) {}  \nvoid Process_Wind(WindData w) {}  \n  \n// Container for all the data records  \nqueue<Input> inputs;  \nvoid Initialize();  \n  \nint main(int argc, char* argv[])  \n{  \n    Initialize();  \n    while (!inputs.empty())  \n    {  \n        Input i = inputs.front();  \n        switch (i.type)  \n        {  \n        case WeatherDataType::Temperature:  \n            Process_Temp(i.temp);  \n            break;  \n        case WeatherDataType::Wind:  \n            Process_Wind(i.wind);  \n            break;  \n        default:  \n            break;  \n        }  \n        inputs.pop();  \n  \n    }  \n    return 0;  \n}  \n  \nvoid Initialize()  \n{  \n    Input first, second;  \n    first.type = WeatherDataType::Temperature;  \n    first.temp = { 101, 1418855664, 91.8, 108.5, 67.2 };  \n    inputs.push(first);  \n  \n    second.type = WeatherDataType::Wind;  \n    second.wind = { 204,1418859354, 14, 27 };  \n    inputs.push(second);  \n}  \n  \n```  \n  \n In the previous example, note that the union in the Input struct has no name. This is an anonymous union and its members can be accessed as if they were direct members of the struct. For more information about anonymous unions, see the section below.  \n  \n Of course, the previous example shows a problem that could also be solved by using classes that derive from a common base class, and branching your code based on the runtime type of each object in the container. This may result in code that easier to maintain and understand, but it might also be slower than using unions. Also, with a union, you can store completely unrelated types, and dynamically change the type of the value that is stored without changing the type of the union variable itself. Thus you can create a heterogeneous array of MyUnionType whose elements store different values of different types.  \n  \n Note that the `Input` struct in the preceding example can be easily misused. It is completely up to the user to use the discriminator correctly to access the member that holds the data. You can protect against misuse by making the union private and providing special access functions, as shown in the next example.  \n  \n## Unrestricted Unions (C++11)  \n In C++03 and earlier a union can contain non-static data members with class type as long as the type has no user provided constructors, destructors or assignment operators. In C++11, these restrictions are removed. If you include such a member in your union then the compiler will automatically mark any special member functions that are not user provided as deleted. If the union is an anonymous union inside a class or struct, then any special member functions of the class or struct that are not user provided are marked as deleted. The following example shows how to handle the case where one of the members of the union has a member that requires this special treatment:  \n  \n```cpp  \n// for MyVariant  \n#include <crtdbg.h>  \n#include <new>  \n#include <utility>  \n  \n// for sample objects and output  \n#include <string>  \n#include <vector>  \n#include <iostream>  \n  \nusing namespace std;  \n  \nstruct A   \n{  \n    A() = default;  \n    A(int i, const string& str) : num(i), name(str) {}  \n  \n    int num;  \n    string name;  \n    //...  \n};  \n  \nstruct B   \n{  \n    B() = default;  \n    B(int i, const string& str) : num(i), name(str) {}  \n  \n    int num;  \n    string name;  \n    vector<int> vec;  \n    // ...  \n};  \n  \nenum class Kind { None, A, B, Integer };  \n  \n#pragma warning (push)  \n#pragma warning(disable:4624)  \nclass MyVariant  \n{  \npublic:  \n    MyVariant()  \n        : kind_(Kind::None)  \n    {  \n    }  \n  \n    MyVariant(Kind kind)  \n        : kind_(kind)  \n    {  \n        switch (kind_)  \n        {  \n        case Kind::None:  \n            break;  \n        case Kind::A:  \n            new (&a_) A();  \n            break;  \n        case Kind::B:  \n            new (&b_) B();  \n            break;  \n        case Kind::Integer:  \n            i_ = 0;  \n            break;  \n        default:  \n            _ASSERT(false);  \n            break;  \n        }  \n    }  \n  \n    ~MyVariant()  \n    {  \n        switch (kind_)  \n        {  \n        case Kind::None:  \n            break;  \n        case Kind::A:  \n            a_.~A();  \n            break;  \n        case Kind::B:  \n            b_.~B();  \n            break;  \n        case Kind::Integer:  \n            break;  \n        default:  \n            _ASSERT(false);  \n            break;  \n        }  \n        kind_ = Kind::None;  \n    }  \n  \n    MyVariant(const MyVariant& other)  \n        : kind_(other.kind_)  \n    {  \n        switch (kind_)  \n        {  \n        case Kind::None:  \n            break;  \n        case Kind::A:  \n            new (&a_) A(other.a_);  \n            break;  \n        case Kind::B:  \n            new (&b_) B(other.b_);  \n            break;  \n        case Kind::Integer:  \n            i_ = other.i_;  \n            break;  \n        default:  \n            _ASSERT(false);  \n            break;  \n        }  \n    }  \n  \n    MyVariant(MyVariant&& other)  \n        : kind_(other.kind_)  \n    {  \n        switch (kind_)  \n        {  \n        case Kind::None:  \n            break;  \n        case Kind::A:  \n            new (&a_) A(move(other.a_));  \n            break;  \n        case Kind::B:  \n            new (&b_) B(move(other.b_));  \n            break;  \n        case Kind::Integer:  \n            i_ = other.i_;  \n            break;  \n        default:  \n            _ASSERT(false);  \n            break;  \n        }  \n        other.kind_ = Kind::None;  \n    }  \n  \n    MyVariant& operator=(const MyVariant& other)  \n    {  \n        if (&other != this)  \n        {  \n            switch (other.kind_)  \n            {  \n            case Kind::None:  \n                this->~MyVariant();  \n                break;  \n            case Kind::A:  \n                *this = other.a_;  \n                break;  \n            case Kind::B:  \n                *this = other.b_;  \n                break;  \n            case Kind::Integer:  \n                *this = other.i_;  \n                break;  \n            default:  \n                _ASSERT(false);  \n                break;  \n            }  \n        }  \n        return *this;  \n    }  \n  \n    MyVariant& operator=(MyVariant&& other)  \n    {  \n        _ASSERT(this != &other);  \n        switch (other.kind_)  \n        {  \n        case Kind::None:  \n            this->~MyVariant();  \n            break;  \n        case Kind::A:  \n            *this = move(other.a_);  \n            break;  \n        case Kind::B:  \n            *this = move(other.b_);  \n            break;  \n        case Kind::Integer:  \n            *this = other.i_;  \n            break;  \n        default:  \n            _ASSERT(false);  \n            break;  \n        }  \n        other.kind_ = Kind::None;  \n        return *this;  \n    }  \n  \n    MyVariant(const A& a)  \n        : kind_(Kind::A), a_(a)  \n    {  \n    }  \n  \n    MyVariant(A&& a)  \n        : kind_(Kind::A), a_(move(a))  \n    {  \n    }  \n  \n    MyVariant& operator=(const A& a)  \n    {  \n        if (kind_ != Kind::A)  \n        {  \n            this->~MyVariant();  \n            new (this) MyVariant(a);  \n        }  \n        else  \n        {  \n            a_ = a;  \n        }  \n        return *this;  \n    }  \n  \n    MyVariant& operator=(A&& a)  \n    {  \n        if (kind_ != Kind::A)  \n        {  \n            this->~MyVariant();  \n            new (this) MyVariant(move(a));  \n        }  \n        else  \n        {  \n            a_ = move(a);  \n        }  \n        return *this;  \n    }  \n  \n    MyVariant(const B& b)  \n        : kind_(Kind::B), b_(b)  \n    {  \n    }  \n  \n    MyVariant(B&& b)  \n        : kind_(Kind::B), b_(move(b))  \n    {  \n    }  \n  \n    MyVariant& operator=(const B& b)  \n    {  \n        if (kind_ != Kind::B)  \n        {  \n            this->~MyVariant();  \n            new (this) MyVariant(b);  \n        }  \n        else  \n        {  \n            b_ = b;  \n        }  \n        return *this;  \n    }  \n  \n    MyVariant& operator=(B&& b)  \n    {  \n        if (kind_ != Kind::B)  \n        {  \n            this->~MyVariant();  \n            new (this) MyVariant(move(b));  \n        }  \n        else  \n        {  \n            b_ = move(b);  \n        }  \n        return *this;  \n    }  \n  \n    MyVariant(int i)  \n        : kind_(Kind::Integer), i_(i)  \n    {  \n    }  \n  \n    MyVariant& operator=(int i)  \n    {  \n        if (kind_ != Kind::Integer)  \n        {  \n            this->~MyVariant();  \n            new (this) MyVariant(i);  \n        }  \n        else  \n        {  \n            i_ = i;  \n        }  \n        return *this;  \n    }  \n  \n    Kind GetKind() const  \n    {  \n        return kind_;  \n    }  \n  \n    A& GetA()  \n    {  \n        _ASSERT(kind_ == Kind::A);  \n        return a_;  \n    }  \n  \n    const A& GetA() const  \n    {  \n        _ASSERT(kind_ == Kind::A);  \n        return a_;  \n    }  \n  \n    B& GetB()  \n    {  \n        _ASSERT(kind_ == Kind::B);  \n        return b_;  \n    }  \n  \n    const B& GetB() const  \n    {  \n        _ASSERT(kind_ == Kind::B);  \n        return b_;  \n    }  \n  \n    int& GetInteger()  \n    {  \n        _ASSERT(kind_ == Kind::Integer);  \n        return i_;  \n    }  \n  \n    const int& GetInteger() const  \n    {  \n        _ASSERT(kind_ == Kind::Integer);  \n        return i_;  \n    }  \n  \nprivate:  \n    Kind kind_;  \n    union  \n    {  \n        A a_;  \n        B b_;  \n        int i_;  \n    };  \n};  \n#pragma warning (pop)  \n  \nint main()  \n{  \n    A a(1, \"Hello from A\");  \n    B b(2, \"Hello from B\");  \n  \n    MyVariant mv_1 = a;  \n  \n    cout << \"mv_1 = a: \" << mv_1.GetA().name << endl;  \n    mv_1 = b;  \n    cout << \"mv_1 = b: \" << mv_1.GetB().name << endl;  \n    mv_1 = A(3, \"hello again from A\");  \n    cout << R\"aaa(mv_1 = A(3, \"hello again from A\"): )aaa\" << mv_1.GetA().name << endl;  \n    mv_1 = 42;  \n    cout << \"mv_1 = 42: \" << mv_1.GetInteger() << endl;  \n  \n    b.vec = { 10,20,30,40,50 };  \n  \n    mv_1 = move(b);  \n    cout << \"After move, mv_1 = b: vec.size = \" << mv_1.GetB().vec.size() << endl;  \n  \n    cout << endl << \"Press a letter\" << endl;  \n    char c;  \n    cin >> c;  \n}  \n#include <queue>  \n#include <iostream>  \nusing namespace std;  \n  \nenum class WeatherDataType  \n{  \n    Temperature, Wind  \n};  \n  \nstruct TempData  \n{  \n    TempData() : StationId(\"\"), time(0), current(0), maxTemp(0), minTemp(0) {}  \n    TempData(string id, time_t t, double cur, double max, double min)  \n        : StationId(id), time(t), current(cur), maxTemp(max), minTemp(0) {}  \n    string StationId;  \n    time_t time = 0;  \n    double current;  \n    double maxTemp;  \n    double minTemp;  \n};  \n  \nstruct WindData  \n{  \n    int StationId;  \n    time_t time;  \n    int speed;  \n    short direction;  \n};  \n  \nstruct Input  \n{  \n    Input() {}  \n    Input(const Input&) {}  \n  \n    ~Input()  \n    {  \n        if (type == WeatherDataType::Temperature)  \n        {  \n            temp.StationId.~string();  \n        }  \n    }  \n  \n    WeatherDataType type;  \n    void SetTemp(const TempData& td)  \n    {  \n        type = WeatherDataType::Temperature;  \n  \n        // must use placement new because of string member!  \n        new(&temp) TempData(td);  \n    }  \n  \n    TempData GetTemp()  \n    {  \n        if (type == WeatherDataType::Temperature)  \n            return temp;  \n        else  \n            throw logic_error(\"Can't return TempData when Input holds a WindData\");  \n    }  \n    void SetWind(WindData wd)  \n    {  \n        // Explicitly delete struct member that has a   \n        // non-trivial constructor  \n        if (type == WeatherDataType::Temperature)  \n        {  \n            temp.StationId.~string();  \n        }  \n        wind = wd; //placement new not required.  \n    }  \n    WindData GetWind()  \n    {  \n        if (type == WeatherDataType::Wind)  \n        {  \n            return wind;  \n        }  \n        else  \n            throw logic_error(\"Can't return WindData when Input holds a TempData\");  \n    }  \n  \nprivate:  \n  \n    union  \n    {  \n        TempData temp;  \n        WindData wind;  \n    };  \n};  \n  \n```  \n  \n Unions cannot store references. Unions donâ€™t support inheritance, therefore a union itself cannot be used as a base class, or inherit from another class, or have virtual functions.  \n  \n## Initializing unions  \n You can declare and initialize a union in the same statement by assigning an expression enclosed in braces. The expression is evaluated and assigned to the first field of the union.  \n  \n```cpp  \n#include <iostream>  \nusing namespace std;  \n  \nunion NumericType  \n{  \n    short       iValue;  \n    long        lValue;    \n    double      dValue;    \n};  \n  \nint main()  \n{  \n    union NumericType Values = { 10 };   // iValue = 10  \n    cout << Values.iValue << endl;  \n    Values.dValue = 3.1416;  \n    cout << Values.dValue) << endl;  \n}  \n/* Output:  \n 10  \n 3.141600  \n*/  \n  \n```  \n  \n The `NumericType` union is arranged in memory (conceptually) as shown in the following figure.  \n  \n ![Storage of data in a numeric type union](../cpp/media/vc38ul1.png \"vc38UL1\")  \nStorage of Data in NumericType Union  \n  \n## <a name=\"anonymous_unions\"></a> Anonymous unions  \n Anonymous unions are unions that are declared without a *class-name* or *declarator-list*.  \n  \n```cpp  \nunion  {  member-list  }    \n```  \n  \nNames declared in an anonymous union are used directly, like nonmember variables. Therefore, the names declared in an anonymous union must be unique in the surrounding scope.  \n  \nIn addition to the restrictions for named unions, anonymous unions are subject to these additional restrictions:  \n  \n-   They must also be declared as **static** if declared in file or namespace scope.  \n  \n-   They can have only public members; private and protected members in anonymous unions generate errors.  \n  \n-   They cannot have member functions.  \n  \n## See Also  \n [Classes and Structs](../cpp/classes-and-structs-cpp.md)   \n [Keywords](../cpp/keywords-cpp.md)   \n [class](../cpp/class-cpp.md)   \n [struct](../cpp/struct-cpp.md)"}