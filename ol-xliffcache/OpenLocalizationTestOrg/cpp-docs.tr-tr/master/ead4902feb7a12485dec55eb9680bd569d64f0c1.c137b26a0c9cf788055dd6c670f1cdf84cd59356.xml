{"nodes":[{"pos":[12,61],"content":"Multithreading: Programming Tips | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Multithreading: Programming Tips | Microsoft Docs","pos":[0,49]}]},{"content":"Multithreading: Programming Tips","pos":[1056,1088]},{"content":"Multithreaded applications require stricter care than single-threaded applications when accessing data.","pos":[1089,1192]},{"content":"Because there are multiple, independent paths of execution in use simultaneously in multithreaded applications, either the algorithms, the data, or both must be aware that data could be used by more than one thread at a time.","pos":[1193,1418]},{"content":"This topic explains techniques for avoiding potential problems when programming multithreaded applications with the Microsoft Foundation Class (MFC) library.","pos":[1419,1576]},{"content":"Accessing Objects from Multiple Threads","pos":[1587,1626]},{"content":"Accessing MFC Objects from Non-MFC Threads","pos":[1686,1728]},{"content":"Windows Handle Maps","pos":[1794,1813]},{"content":"Communicating Between Threads","pos":[1853,1882]},{"pos":[1992,2031],"content":"Accessing Objects from Multiple Threads"},{"content":"For size and performance reasons, MFC objects are not thread-safe at the object level, only at the class level.","pos":[2035,2146]},{"content":"This means that you can have two separate threads manipulating two different <ph id=\"ph1\">`CString`</ph> objects, but not two threads manipulating the same <ph id=\"ph2\">`CString`</ph> object.","pos":[2147,2302],"source":" This means that you can have two separate threads manipulating two different `CString` objects, but not two threads manipulating the same `CString` object."},{"content":"If you absolutely must have multiple threads manipulating the same object, protect such access with appropriate Win32 synchronization mechanisms, such as critical sections.","pos":[2303,2475]},{"content":"For more information about critical sections and other related objects, see <bpt id=\"p1\">[</bpt>Synchronization<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms686353)</ept> in the <ph id=\"ph1\">[!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]</ph>.","pos":[2476,2717],"source":" For more information about critical sections and other related objects, see [Synchronization](http://msdn.microsoft.com/library/windows/desktop/ms686353) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]."},{"content":"The class library uses critical sections internally to protect global data structures, such as those used by the debug memory allocation.","pos":[2724,2861]},{"pos":[2938,2980],"content":"Accessing MFC Objects from Non-MFC Threads"},{"content":"If you have a multithreaded application that creates a thread in a way other than using a <bpt id=\"p1\">[</bpt>CWinThread<ept id=\"p1\">](../mfc/reference/cwinthread-class.md)</ept> object, you cannot access other MFC objects from that thread.","pos":[2984,3186],"source":"If you have a multithreaded application that creates a thread in a way other than using a [CWinThread](../mfc/reference/cwinthread-class.md) object, you cannot access other MFC objects from that thread."},{"content":"In other words, if you want to access any MFC object from a secondary thread, you must create that thread with one of the methods described in <bpt id=\"p1\">[</bpt>Multithreading: Creating User-Interface Threads<ept id=\"p1\">](../parallel/multithreading-creating-user-interface-threads.md)</ept> or <bpt id=\"p2\">[</bpt>Multithreading: Creating Worker Threads<ept id=\"p2\">](../parallel/multithreading-creating-worker-threads.md)</ept>.","pos":[3187,3543],"source":" In other words, if you want to access any MFC object from a secondary thread, you must create that thread with one of the methods described in [Multithreading: Creating User-Interface Threads](../parallel/multithreading-creating-user-interface-threads.md) or [Multithreading: Creating Worker Threads](../parallel/multithreading-creating-worker-threads.md)."},{"content":"These methods are the only ones that allow the class library to initialize the internal variables necessary to handle multithreaded applications.","pos":[3544,3689]},{"pos":[3740,3759],"content":"Windows Handle Maps"},{"content":"As a general rule, a thread can access only MFC objects that it created.","pos":[3763,3835]},{"content":"This is because temporary and permanent Windows handle maps are kept in thread local storage to help maintain protection from simultaneous access from multiple threads.","pos":[3836,4004]},{"content":"For example, a worker thread cannot perform a calculation and then call a document's <ph id=\"ph1\">`UpdateAllViews`</ph> member function to have the windows that contain views on the new data modified.","pos":[4005,4187],"source":" For example, a worker thread cannot perform a calculation and then call a document's `UpdateAllViews` member function to have the windows that contain views on the new data modified."},{"content":"This has no effect at all, because the map from <ph id=\"ph1\">`CWnd`</ph> objects to <ph id=\"ph2\">`HWND`</ph>s is local to the primary thread.","pos":[4188,4293],"source":" This has no effect at all, because the map from `CWnd` objects to `HWND`s is local to the primary thread."},{"content":"This means that one thread might have a mapping from a Windows handle to a C++ object, but another thread might map that same handle to a different C++ object.","pos":[4294,4453]},{"content":"Changes made in one thread would not be reflected in the other.","pos":[4454,4517]},{"content":"There are several ways around this problem.","pos":[4524,4567]},{"content":"The first is to pass individual handles (such as an <ph id=\"ph1\">`HWND`</ph>) rather than C++ objects to the worker thread.","pos":[4568,4673],"source":" The first is to pass individual handles (such as an `HWND`) rather than C++ objects to the worker thread."},{"content":"The worker thread then adds these objects to its temporary map by calling the appropriate <ph id=\"ph1\">`FromHandle`</ph> member function.","pos":[4674,4793],"source":" The worker thread then adds these objects to its temporary map by calling the appropriate `FromHandle` member function."},{"content":"You could also add the object to the thread's permanent map by calling <bpt id=\"p1\">**</bpt>Attach<ept id=\"p1\">**</ept>, but this should be done only if you are guaranteed that the object will exist longer than the thread.","pos":[4794,4978],"source":" You could also add the object to the thread's permanent map by calling **Attach**, but this should be done only if you are guaranteed that the object will exist longer than the thread."},{"content":"Another method is to create new user-defined messages corresponding to the different tasks your worker threads will be performing and post these messages to the application's main window using <bpt id=\"p1\">**</bpt>::PostMessage<ept id=\"p1\">**</ept>.","pos":[4985,5196],"source":"Another method is to create new user-defined messages corresponding to the different tasks your worker threads will be performing and post these messages to the application's main window using **::PostMessage**."},{"content":"This method of communication is similar to two different applications conversing except that both threads are executing in the same address space.","pos":[5197,5343]},{"content":"For more information about handle maps, see <bpt id=\"p1\">[</bpt>Technical Note 3<ept id=\"p1\">](../mfc/tn003-mapping-of-windows-handles-to-objects.md)</ept>.","pos":[5350,5468],"source":"For more information about handle maps, see [Technical Note 3](../mfc/tn003-mapping-of-windows-handles-to-objects.md)."},{"content":"For more information about thread local storage, see <bpt id=\"p1\">[</bpt>Thread Local Storage<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms686749)</ept> and <bpt id=\"p2\">[</bpt>Using Thread Local Storage<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms686991)</ept> in the <ph id=\"ph1\">[!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]</ph>.","pos":[5469,5785],"source":" For more information about thread local storage, see [Thread Local Storage](http://msdn.microsoft.com/library/windows/desktop/ms686749) and [Using Thread Local Storage](http://msdn.microsoft.com/library/windows/desktop/ms686991) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]."},{"pos":[5846,5875],"content":"Communicating Between Threads"},{"content":"MFC provides a number of classes that allow threads to synchronize access to objects to maintain thread safety.","pos":[5879,5990]},{"content":"Usage of these classes is described in <bpt id=\"p1\">[</bpt>Multithreading: How to Use the Synchronization Classes<ept id=\"p1\">](../parallel/multithreading-how-to-use-the-synchronization-classes.md)</ept> and <bpt id=\"p2\">[</bpt>Multithreading: When to Use the Synchronization Classes<ept id=\"p2\">](../parallel/multithreading-when-to-use-the-synchronization-classes.md)</ept>.","pos":[5991,6290],"source":" Usage of these classes is described in [Multithreading: How to Use the Synchronization Classes](../parallel/multithreading-how-to-use-the-synchronization-classes.md) and [Multithreading: When to Use the Synchronization Classes](../parallel/multithreading-when-to-use-the-synchronization-classes.md)."},{"content":"For more information about these objects, see <bpt id=\"p1\">[</bpt>Synchronization<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms686353)</ept> in the <ph id=\"ph1\">[!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]</ph>.","pos":[6291,6502],"source":" For more information about these objects, see [Synchronization](http://msdn.microsoft.com/library/windows/desktop/ms686353) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]."},{"content":"See Also","pos":[6511,6519]},{"content":"Multithreading with C++ and MFC","pos":[6524,6555]}],"content":"---\ntitle: \"Multithreading: Programming Tips | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"multithreading [C++], programming tips\"\n  - \"handle maps [C++]\"\n  - \"access control [C++], multithreading\"\n  - \"objects [C++], multiple threads and\"\n  - \"non-MFC threads [C++]\"\n  - \"threading [MFC], programming tips\"\n  - \"critical sections [C++]\"\n  - \"synchronization [C++], multithreading\"\n  - \"programming [C++], multithreaded\"\n  - \"communications [C++], between threads\"\n  - \"threading [C++], best practices\"\n  - \"troubleshooting [C++], multithreading\"\n  - \"Windows handle maps [C++]\"\nms.assetid: ad14cc70-c91c-4c24-942f-13a75e58bf8a\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Multithreading: Programming Tips\nMultithreaded applications require stricter care than single-threaded applications when accessing data. Because there are multiple, independent paths of execution in use simultaneously in multithreaded applications, either the algorithms, the data, or both must be aware that data could be used by more than one thread at a time. This topic explains techniques for avoiding potential problems when programming multithreaded applications with the Microsoft Foundation Class (MFC) library.  \n  \n-   [Accessing Objects from Multiple Threads](#_core_accessing_objects_from_multiple_threads)  \n  \n-   [Accessing MFC Objects from Non-MFC Threads](#_core_accessing_mfc_objects_from_non.2d.mfc_threads)  \n  \n-   [Windows Handle Maps](#_core_windows_handle_maps)  \n  \n-   [Communicating Between Threads](#_core_communicating_between_threads)  \n  \n##  <a name=\"_core_accessing_objects_from_multiple_threads\"></a> Accessing Objects from Multiple Threads  \n For size and performance reasons, MFC objects are not thread-safe at the object level, only at the class level. This means that you can have two separate threads manipulating two different `CString` objects, but not two threads manipulating the same `CString` object. If you absolutely must have multiple threads manipulating the same object, protect such access with appropriate Win32 synchronization mechanisms, such as critical sections. For more information about critical sections and other related objects, see [Synchronization](http://msdn.microsoft.com/library/windows/desktop/ms686353) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)].  \n  \n The class library uses critical sections internally to protect global data structures, such as those used by the debug memory allocation.  \n  \n##  <a name=\"_core_accessing_mfc_objects_from_non.2d.mfc_threads\"></a> Accessing MFC Objects from Non-MFC Threads  \n If you have a multithreaded application that creates a thread in a way other than using a [CWinThread](../mfc/reference/cwinthread-class.md) object, you cannot access other MFC objects from that thread. In other words, if you want to access any MFC object from a secondary thread, you must create that thread with one of the methods described in [Multithreading: Creating User-Interface Threads](../parallel/multithreading-creating-user-interface-threads.md) or [Multithreading: Creating Worker Threads](../parallel/multithreading-creating-worker-threads.md). These methods are the only ones that allow the class library to initialize the internal variables necessary to handle multithreaded applications.  \n  \n##  <a name=\"_core_windows_handle_maps\"></a> Windows Handle Maps  \n As a general rule, a thread can access only MFC objects that it created. This is because temporary and permanent Windows handle maps are kept in thread local storage to help maintain protection from simultaneous access from multiple threads. For example, a worker thread cannot perform a calculation and then call a document's `UpdateAllViews` member function to have the windows that contain views on the new data modified. This has no effect at all, because the map from `CWnd` objects to `HWND`s is local to the primary thread. This means that one thread might have a mapping from a Windows handle to a C++ object, but another thread might map that same handle to a different C++ object. Changes made in one thread would not be reflected in the other.  \n  \n There are several ways around this problem. The first is to pass individual handles (such as an `HWND`) rather than C++ objects to the worker thread. The worker thread then adds these objects to its temporary map by calling the appropriate `FromHandle` member function. You could also add the object to the thread's permanent map by calling **Attach**, but this should be done only if you are guaranteed that the object will exist longer than the thread.  \n  \n Another method is to create new user-defined messages corresponding to the different tasks your worker threads will be performing and post these messages to the application's main window using **::PostMessage**. This method of communication is similar to two different applications conversing except that both threads are executing in the same address space.  \n  \n For more information about handle maps, see [Technical Note 3](../mfc/tn003-mapping-of-windows-handles-to-objects.md). For more information about thread local storage, see [Thread Local Storage](http://msdn.microsoft.com/library/windows/desktop/ms686749) and [Using Thread Local Storage](http://msdn.microsoft.com/library/windows/desktop/ms686991) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)].  \n  \n##  <a name=\"_core_communicating_between_threads\"></a> Communicating Between Threads  \n MFC provides a number of classes that allow threads to synchronize access to objects to maintain thread safety. Usage of these classes is described in [Multithreading: How to Use the Synchronization Classes](../parallel/multithreading-how-to-use-the-synchronization-classes.md) and [Multithreading: When to Use the Synchronization Classes](../parallel/multithreading-when-to-use-the-synchronization-classes.md). For more information about these objects, see [Synchronization](http://msdn.microsoft.com/library/windows/desktop/ms686353) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)].  \n  \n## See Also  \n [Multithreading with C++ and MFC](../parallel/multithreading-with-cpp-and-mfc.md)"}