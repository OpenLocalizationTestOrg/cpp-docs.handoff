{"nodes":[{"pos":[12,69],"content":"How to: Marshal Arrays Using C++ Interop | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Marshal Arrays Using C++ Interop | Microsoft Docs","pos":[0,57]}]},{"content":"How to: Marshal Arrays Using C++ Interop","pos":[736,776]},{"content":"This topic demonstrates one facet of Visual C++ interoperability.","pos":[777,842]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using C++ Interop (Implicit PInvoke)<ept id=\"p1\">](../dotnet/using-cpp-interop-implicit-pinvoke.md)</ept>.","pos":[843,957],"source":" For more information, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)."},{"content":"The following code examples use the <bpt id=\"p1\">[</bpt>managed, unmanaged<ept id=\"p1\">](../preprocessor/managed-unmanaged.md)</ept> #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files.","pos":[964,1222],"source":"The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files."},{"content":"Files containing only unmanaged functions do not need to be compiled with <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>.","pos":[1223,1405],"source":" Files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md)."},{"content":"Example","pos":[1414,1421]},{"content":"The following example demonstrates how to pass a managed array to an unmanaged function.","pos":[1425,1513]},{"content":"The managed function uses <bpt id=\"p1\">[</bpt>pin_ptr (C++/CLI)<ept id=\"p1\">](../windows/pin-ptr-cpp-cli.md)</ept> to suppress garbage collection for the array before calling the unmanaged function.","pos":[1514,1674],"source":" The managed function uses [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md) to suppress garbage collection for the array before calling the unmanaged function."},{"content":"By providing the unmanaged function with a pinned pointer into the GC heap, the overhead of making a copy of the array can be avoided.","pos":[1675,1809]},{"content":"To demonstrate that the unmanaged function is accessing GC heap memory, it modifies the contents of the array and the changes are reflected when the managed function resumes control.","pos":[1810,1992]},{"content":"Example","pos":[3162,3169]},{"content":"The following example demonstrates passing an unmanaged array to a managed function.","pos":[3173,3257]},{"content":"The managed function accesses the array memory directly (as opposed to creating a managed array and copying the array content), which allows changes made by the managed function to be reflected in the unmanaged function when it regains control.","pos":[3258,3502]},{"content":"See Also","pos":[4458,4466]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[4471,4507]}],"content":"---\ntitle: \"How to: Marshal Arrays Using C++ Interop | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"arrays [C++], marshaling\"\n  - \"marshaling [C++], arrays\"\n  - \"interop [C++], arrays\"\n  - \"C++ Interop, arrays\"\n  - \"data marshaling [C++], arrays\"\nms.assetid: c2b37ab1-8acf-4855-ad3c-7d2864826b14\ncaps.latest.revision: 18\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Marshal Arrays Using C++ Interop\nThis topic demonstrates one facet of Visual C++ interoperability. For more information, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md).  \n  \n The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files. Files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md).  \n  \n## Example  \n The following example demonstrates how to pass a managed array to an unmanaged function. The managed function uses [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md) to suppress garbage collection for the array before calling the unmanaged function. By providing the unmanaged function with a pinned pointer into the GC heap, the overhead of making a copy of the array can be avoided. To demonstrate that the unmanaged function is accessing GC heap memory, it modifies the contents of the array and the changes are reflected when the managed function resumes control.  \n  \n```  \n// PassArray1.cpp  \n// compile with: /clr  \n#ifndef _CRT_RAND_S  \n#define _CRT_RAND_S  \n#endif  \n  \n#include <iostream>  \n#include <stdlib.h>  \nusing namespace std;  \n  \nusing namespace System;  \n  \n#pragma unmanaged  \n  \nvoid TakesAnArray(int* a, int c) {  \n   cout << \"(unmanaged) array received:\\n\";  \n   for (int i=0; i<c; i++)  \n      cout << \"a[\" << i << \"] = \" << a[i] << \"\\n\";  \n  \n   unsigned int number;  \n   errno_t err;  \n  \n   cout << \"(unmanaged) modifying array contents...\\n\";  \n   for (int i=0; i<c; i++) {  \n      err = rand_s( &number );  \n      if ( err == 0 )  \n         a[i] = number % 100;  \n   }  \n}  \n  \n#pragma managed  \n  \nint main() {  \n   array<int>^ nums = gcnew array<int>(5);  \n  \n   nums[0] = 0;  \n   nums[1] = 1;  \n   nums[2] = 2;  \n   nums[3] = 3;  \n   nums[4] = 4;  \n  \n   Console::WriteLine(\"(managed) array created:\");  \n   for (int i=0; i<5; i++)  \n      Console::WriteLine(\"a[{0}] = {1}\", i, nums[i]);  \n  \n   pin_ptr<int> pp = &nums[0];  \n   TakesAnArray(pp, 5);  \n  \n   Console::WriteLine(\"(managed) contents:\");  \n   for (int i=0; i<5; i++)  \n      Console::WriteLine(\"a[{0}] = {1}\", i, nums[i]);  \n}  \n```  \n  \n## Example  \n The following example demonstrates passing an unmanaged array to a managed function. The managed function accesses the array memory directly (as opposed to creating a managed array and copying the array content), which allows changes made by the managed function to be reflected in the unmanaged function when it regains control.  \n  \n```  \n// PassArray2.cpp  \n// compile with: /clr   \n#include <iostream>  \nusing namespace std;  \n  \nusing namespace System;  \n  \n#pragma managed  \n  \nvoid ManagedTakesAnArray(int* a, int c) {  \n   Console::WriteLine(\"(managed) array received:\");  \n   for (int i=0; i<c; i++)  \n      Console::WriteLine(\"a[{0}] = {1}\", i, a[i]);  \n  \n   cout << \"(managed) modifying array contents...\\n\";  \n   Random^ r = gcnew Random(DateTime::Now.Second);  \n   for (int i=0; i<c; i++)  \n      a[i] = r->Next(100);  \n}  \n  \n#pragma unmanaged  \n  \nvoid NativeFunc() {  \n   int nums[5] = { 0, 1, 2, 3, 4 };  \n  \n   printf_s(\"(unmanaged) array created:\\n\");  \n   for (int i=0; i<5; i++)  \n      printf_s(\"a[%d] = %d\\n\", i, nums[i]);  \n  \n   ManagedTakesAnArray(nums, 5);  \n  \n   printf_s(\"(ummanaged) contents:\\n\");  \n   for (int i=0; i<5; i++)  \n      printf_s(\"a[%d] = %d\\n\", i, nums[i]);  \n}  \n  \n#pragma managed  \n  \nint main() {  \n   NativeFunc();  \n}  \n```  \n  \n## See Also  \n [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)"}