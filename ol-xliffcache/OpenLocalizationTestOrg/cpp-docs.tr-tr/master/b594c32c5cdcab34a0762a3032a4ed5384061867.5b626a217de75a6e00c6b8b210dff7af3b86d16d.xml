{"nodes":[{"pos":[12,72],"content":"Auto-Parallelization and Auto-Vectorization | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Auto-Parallelization and Auto-Vectorization | Microsoft Docs","pos":[0,60]}]},{"content":"Auto-Parallelization and Auto-Vectorization","pos":[553,596]},{"content":"Auto-Parallelizer and Auto-Vectorizer are designed to provide automatic performance gains for loops in your code.","pos":[597,710]},{"content":"Auto-Parallelizer","pos":[719,736]},{"content":"The <bpt id=\"p1\">[</bpt>/Qpar<ept id=\"p1\">](../build/reference/qpar-auto-parallelizer.md)</ept> compiler switch enables <bpt id=\"p2\">*</bpt>automatic parallelization<ept id=\"p2\">*</ept> of loops in your code.","pos":[740,872],"source":"The [/Qpar](../build/reference/qpar-auto-parallelizer.md) compiler switch enables *automatic parallelization* of loops in your code."},{"content":"When you specify this flag without changing your existing code, the compiler evaluates the code to find loops that might benefit from parallelization.","pos":[873,1023]},{"content":"Because it might find loops that don't do much work and therefore won't benefit from parallelization, and because every unnecessary parallelization can engender the spawning of a thread pool, extra synchronization, or other processing that would tend to slow performance instead of improving it, the compiler is conservative in selecting the loops that it parallelizes.","pos":[1024,1393]},{"content":"For example, consider the following example in which the upper bound of the loop is not known at compile time:","pos":[1394,1504]},{"content":"Because <ph id=\"ph1\">`u`</ph> could be a small value, the compiler won’t automatically parallelize this loop.","pos":[1619,1710],"source":"Because `u` could be a small value, the compiler won’t automatically parallelize this loop."},{"content":"However, you might still want it parallelized because you know that <ph id=\"ph1\">`u`</ph> will always be large.","pos":[1711,1804],"source":" However, you might still want it parallelized because you know that `u` will always be large."},{"content":"To enable the auto-parallelization, specify <bpt id=\"p1\">[</bpt>#pragma loop(hint_parallel(n))<ept id=\"p1\">](../preprocessor/loop.md)</ept>, where <ph id=\"ph1\">`n`</ph> is the number of threads to parallelize across.","pos":[1805,1965],"source":" To enable the auto-parallelization, specify [#pragma loop(hint_parallel(n))](../preprocessor/loop.md), where `n` is the number of threads to parallelize across."},{"content":"In the following example, the compiler will attempt to parallelize the loop across 8 threads.","pos":[1966,2059]},{"pos":[2207,2382],"content":"As with all <bpt id=\"p1\">[</bpt>pragma directives<ept id=\"p1\">](../preprocessor/pragma-directives-and-the-pragma-keyword.md)</ept>, the alternate pragma syntax <ph id=\"ph1\">`__pragma(loop(hint_parallel(n)))`</ph> is also supported.","source":"As with all [pragma directives](../preprocessor/pragma-directives-and-the-pragma-keyword.md), the alternate pragma syntax `__pragma(loop(hint_parallel(n)))` is also supported."},{"content":"There are some loops that the compiler can’t parallelize even if you want it to.","pos":[2389,2469]},{"content":"Here's an example:","pos":[2470,2488]},{"content":"The function <ph id=\"ph1\">`upper_bound()`</ph> might change every time it's called.","pos":[2613,2678],"source":"The function `upper_bound()` might change every time it's called."},{"content":"Because the upper bound cannot be known, the compiler can emit a diagnostic message that explains why it can’t parallelize this loop.","pos":[2679,2812]},{"content":"The following example demonstrates a loop that can be parallelized, a loop that cannot be parallelized, the compiler syntax to use at the command prompt, and the compiler output for each command line option:","pos":[2813,3020]},{"content":"Compiling by using this command:","pos":[3262,3294]},{"content":"cl d:\\myproject\\mylooptest.cpp /O2 /Qpar /Qpar-report:1","pos":[3303,3358]},{"content":"yields this output:","pos":[3367,3386]},{"content":"--- Analyzing function: void __cdecl test(void)","pos":[3395,3442]},{"content":"d:\\myproject\\mytest.cpp(4) : loop parallelized","pos":[3451,3497]},{"content":"Compiling by using this command:","pos":[3506,3538]},{"content":"cl d:\\myproject\\mylooptest.cpp /O2 /Qpar /Qpar-report:2","pos":[3547,3602]},{"content":"yields this output:","pos":[3611,3630]},{"content":"--- Analyzing function: void __cdecl test(void)","pos":[3639,3686]},{"content":"d:\\myproject\\mytest.cpp(4) : loop parallelized","pos":[3695,3741]},{"content":"d:\\myproject\\mytest.cpp(4) : loop not parallelized due to reason '1008'","pos":[3750,3821]},{"content":"Notice the difference in output between the two different <bpt id=\"p1\">[</bpt>/Qpar-report (Auto-Parallelizer Reporting Level)<ept id=\"p1\">](../build/reference/qpar-report-auto-parallelizer-reporting-level.md)</ept> options.","pos":[3830,4016],"source":"Notice the difference in output between the two different [/Qpar-report (Auto-Parallelizer Reporting Level)](../build/reference/qpar-report-auto-parallelizer-reporting-level.md) options."},{"content":"<bpt id=\"p1\">**</bpt>/Qpar-report:1<ept id=\"p1\">**</ept> outputs parallelizer messages only for loops that are successfully parallelized.","pos":[4017,4116],"source":"**/Qpar-report:1** outputs parallelizer messages only for loops that are successfully parallelized."},{"content":"<bpt id=\"p1\">**</bpt>/Qpar-report:2<ept id=\"p1\">**</ept> outputs parallelizer messages for both successful and unsuccessful loop parallelizations.","pos":[4117,4225],"source":"**/Qpar-report:2** outputs parallelizer messages for both successful and unsuccessful loop parallelizations."},{"pos":[4232,4400],"content":"For more information about reason codes and messages, see <bpt id=\"p1\">[</bpt>Vectorizer and Parallelizer Messages<ept id=\"p1\">](../error-messages/tool-errors/vectorizer-and-parallelizer-messages.md)</ept>.","source":"For more information about reason codes and messages, see [Vectorizer and Parallelizer Messages](../error-messages/tool-errors/vectorizer-and-parallelizer-messages.md)."},{"content":"Auto-Vectorizer","pos":[4409,4424]},{"content":"The Auto-Vectorizer analyzes loops in your code, and uses the vector registers and instructions on the target computer to execute them, if it can.","pos":[4428,4574]},{"content":"This can improve the performance of your code.","pos":[4575,4621]},{"content":"The compiler targets the SSE2, AVX, and AVX2 instructions in Intel or AMD processors, or the NEON instructions on ARM processors, according to the <bpt id=\"p1\">[</bpt>/arch<ept id=\"p1\">](../build/reference/arch-minimum-cpu-architecture.md)</ept> switch.","pos":[4622,4837],"source":" The compiler targets the SSE2, AVX, and AVX2 instructions in Intel or AMD processors, or the NEON instructions on ARM processors, according to the [/arch](../build/reference/arch-minimum-cpu-architecture.md) switch."},{"content":"The Auto-Vectorizer may generate different instructions than specified by the <bpt id=\"p1\">**</bpt>/arch<ept id=\"p1\">**</ept> switch.","pos":[4844,4939],"source":"The Auto-Vectorizer may generate different instructions than specified by the **/arch** switch."},{"content":"These instructions are guarded by a runtime check to make sure that code still runs correctly.","pos":[4940,5034]},{"content":"For example, when you compile <bpt id=\"p1\">**</bpt>/arch:SSE2<ept id=\"p1\">**</ept>, SSE4.2 instructions may be emitted.","pos":[5035,5116],"source":" For example, when you compile **/arch:SSE2**, SSE4.2 instructions may be emitted."},{"content":"A runtime check verifies that SSE4.2 is available on the target processor and jumps to a non-SSE4.2 version of the loop if the processor does not support those instructions.","pos":[5117,5290]},{"content":"By default, the Auto-Vectorizer is enabled.","pos":[5297,5340]},{"content":"If you want to compare the performance of your code under vectorization, you can use <bpt id=\"p1\">[</bpt>#pragma loop(no_vector)<ept id=\"p1\">](../preprocessor/loop.md)</ept> to disable vectorization of any given loop.","pos":[5341,5520],"source":" If you want to compare the performance of your code under vectorization, you can use [#pragma loop(no_vector)](../preprocessor/loop.md) to disable vectorization of any given loop."},{"pos":[5638,5806],"content":"As with all <bpt id=\"p1\">[</bpt>pragma directives<ept id=\"p1\">](../preprocessor/pragma-directives-and-the-pragma-keyword.md)</ept>, the alternate pragma syntax <ph id=\"ph1\">`__pragma(loop(no_vector))`</ph> is also supported.","source":"As with all [pragma directives](../preprocessor/pragma-directives-and-the-pragma-keyword.md), the alternate pragma syntax `__pragma(loop(no_vector))` is also supported."},{"pos":[5813,6148],"content":"As with the Auto-Parallelizer, you can specify the <bpt id=\"p1\">[</bpt>/Qvec-report (Auto-Vectorizer Reporting Level)<ept id=\"p1\">](../build/reference/qvec-report-auto-vectorizer-reporting-level.md)</ept> command-line option to report either successfully vectorized loops only—<bpt id=\"p2\">**</bpt>/Qvec-report:1<ept id=\"p2\">**</ept>—or both successfully and unsuccessfully vectorized loops—<bpt id=\"p3\">**</bpt>/Qvec-report:2<ept id=\"p3\">**</ept>).","source":"As with the Auto-Parallelizer, you can specify the [/Qvec-report (Auto-Vectorizer Reporting Level)](../build/reference/qvec-report-auto-vectorizer-reporting-level.md) command-line option to report either successfully vectorized loops only—**/Qvec-report:1**—or both successfully and unsuccessfully vectorized loops—**/Qvec-report:2**)."},{"pos":[6155,6323],"content":"For more information about reason codes and messages, see <bpt id=\"p1\">[</bpt>Vectorizer and Parallelizer Messages<ept id=\"p1\">](../error-messages/tool-errors/vectorizer-and-parallelizer-messages.md)</ept>.","source":"For more information about reason codes and messages, see [Vectorizer and Parallelizer Messages](../error-messages/tool-errors/vectorizer-and-parallelizer-messages.md)."},{"pos":[6330,6502],"content":"For an example showing how the vectorizer works in practice, see <bpt id=\"p1\">[</bpt>Project Austin Part 2 of 6: Page Curling<ept id=\"p1\">](http://blogs.msdn.com/b/vcblog/archive/2012/09/27/10348494.aspx)</ept>","source":"For an example showing how the vectorizer works in practice, see [Project Austin Part 2 of 6: Page Curling](http://blogs.msdn.com/b/vcblog/archive/2012/09/27/10348494.aspx)"},{"content":"See Also","pos":[6511,6519]},{"content":"loop","pos":[6524,6528]},{"content":"Parallel Programming in Native Code","pos":[6560,6595]},{"content":"/Qpar (Auto-Parallelizer)","pos":[6649,6674]},{"content":"/Qpar-report (Auto-Parallelizer Reporting Level)","pos":[6727,6775]},{"content":"/Qvec-report (Auto-Vectorizer Reporting Level)","pos":[6851,6897]},{"content":"Vectorizer and Parallelizer Messages","pos":[6971,7007]}],"content":"---\ntitle: \"Auto-Parallelization and Auto-Vectorization | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: ec71583a-287b-4599-8767-1d255e080fe3\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Auto-Parallelization and Auto-Vectorization\nAuto-Parallelizer and Auto-Vectorizer are designed to provide automatic performance gains for loops in your code.  \n  \n## Auto-Parallelizer  \n The [/Qpar](../build/reference/qpar-auto-parallelizer.md) compiler switch enables *automatic parallelization* of loops in your code. When you specify this flag without changing your existing code, the compiler evaluates the code to find loops that might benefit from parallelization. Because it might find loops that don't do much work and therefore won't benefit from parallelization, and because every unnecessary parallelization can engender the spawning of a thread pool, extra synchronization, or other processing that would tend to slow performance instead of improving it, the compiler is conservative in selecting the loops that it parallelizes. For example, consider the following example in which the upper bound of the loop is not known at compile time:  \n  \n```cpp  \n  \nvoid loop_test(int u) {  \n   for (int i=0; i<u; ++i)  \n      A[i] = B[i] * C[i];  \n}  \n```  \n  \n Because `u` could be a small value, the compiler won’t automatically parallelize this loop. However, you might still want it parallelized because you know that `u` will always be large. To enable the auto-parallelization, specify [#pragma loop(hint_parallel(n))](../preprocessor/loop.md), where `n` is the number of threads to parallelize across. In the following example, the compiler will attempt to parallelize the loop across 8 threads.  \n  \n```cpp  \n  \nvoid loop_test(int u) {  \n#pragma loop(hint_parallel(8))  \n   for (int i=0; i<u; ++i)  \n      A[i] = B[i] * C[i];  \n}  \n```  \n  \n As with all [pragma directives](../preprocessor/pragma-directives-and-the-pragma-keyword.md), the alternate pragma syntax `__pragma(loop(hint_parallel(n)))` is also supported.  \n  \n There are some loops that the compiler can’t parallelize even if you want it to. Here's an example:  \n  \n```cpp  \n  \n#pragma loop(hint_parallel(8))  \nfor (int i=0; i<upper_bound(); ++i)  \n    A[i] = B[i] * C[i];  \n```  \n  \n The function `upper_bound()` might change every time it's called. Because the upper bound cannot be known, the compiler can emit a diagnostic message that explains why it can’t parallelize this loop. The following example demonstrates a loop that can be parallelized, a loop that cannot be parallelized, the compiler syntax to use at the command prompt, and the compiler output for each command line option:  \n  \n```cpp  \nint A[1000];  \nvoid test() {  \n#pragma loop(hint_parallel(0))  \n    for (int i=0; i<1000; ++i) {  \n        A[i] = A[i] + 1;  \n    }  \n  \n    for (int i=1000; i<2000; ++i) {  \n        A[i] = A[i] + 1;  \n    }  \n}  \n  \n```  \n  \n Compiling by using this command:  \n  \n **cl d:\\myproject\\mylooptest.cpp /O2 /Qpar /Qpar-report:1**  \n  \n yields this output:  \n  \n **--- Analyzing function: void __cdecl test(void)**   \n **d:\\myproject\\mytest.cpp(4) : loop parallelized**  \n  \n Compiling by using this command:  \n  \n **cl d:\\myproject\\mylooptest.cpp /O2 /Qpar /Qpar-report:2**  \n  \n yields this output:  \n  \n **--- Analyzing function: void __cdecl test(void)**   \n **d:\\myproject\\mytest.cpp(4) : loop parallelized**   \n **d:\\myproject\\mytest.cpp(4) : loop not parallelized due to reason '1008'**  \n  \n Notice the difference in output between the two different [/Qpar-report (Auto-Parallelizer Reporting Level)](../build/reference/qpar-report-auto-parallelizer-reporting-level.md) options. **/Qpar-report:1** outputs parallelizer messages only for loops that are successfully parallelized. **/Qpar-report:2** outputs parallelizer messages for both successful and unsuccessful loop parallelizations.  \n  \n For more information about reason codes and messages, see [Vectorizer and Parallelizer Messages](../error-messages/tool-errors/vectorizer-and-parallelizer-messages.md).  \n  \n## Auto-Vectorizer  \n The Auto-Vectorizer analyzes loops in your code, and uses the vector registers and instructions on the target computer to execute them, if it can. This can improve the performance of your code. The compiler targets the SSE2, AVX, and AVX2 instructions in Intel or AMD processors, or the NEON instructions on ARM processors, according to the [/arch](../build/reference/arch-minimum-cpu-architecture.md) switch.  \n  \n The Auto-Vectorizer may generate different instructions than specified by the **/arch** switch. These instructions are guarded by a runtime check to make sure that code still runs correctly. For example, when you compile **/arch:SSE2**, SSE4.2 instructions may be emitted. A runtime check verifies that SSE4.2 is available on the target processor and jumps to a non-SSE4.2 version of the loop if the processor does not support those instructions.  \n  \n By default, the Auto-Vectorizer is enabled. If you want to compare the performance of your code under vectorization, you can use [#pragma loop(no_vector)](../preprocessor/loop.md) to disable vectorization of any given loop.  \n  \n```  \n  \n      #pragma loop(no_vector)  \nfor (int i = 0; i < 1000; ++i)  \n   A[i] = B[i] + C[i];  \n  \n```  \n  \n As with all [pragma directives](../preprocessor/pragma-directives-and-the-pragma-keyword.md), the alternate pragma syntax `__pragma(loop(no_vector))` is also supported.  \n  \n As with the Auto-Parallelizer, you can specify the [/Qvec-report (Auto-Vectorizer Reporting Level)](../build/reference/qvec-report-auto-vectorizer-reporting-level.md) command-line option to report either successfully vectorized loops only—**/Qvec-report:1**—or both successfully and unsuccessfully vectorized loops—**/Qvec-report:2**).  \n  \n For more information about reason codes and messages, see [Vectorizer and Parallelizer Messages](../error-messages/tool-errors/vectorizer-and-parallelizer-messages.md).  \n  \n For an example showing how the vectorizer works in practice, see [Project Austin Part 2 of 6: Page Curling](http://blogs.msdn.com/b/vcblog/archive/2012/09/27/10348494.aspx)  \n  \n## See Also  \n [loop](../preprocessor/loop.md)   \n [Parallel Programming in Native Code](http://go.microsoft.com/fwlink/?linkid=263662)   \n [/Qpar (Auto-Parallelizer)](../build/reference/qpar-auto-parallelizer.md)   \n [/Qpar-report (Auto-Parallelizer Reporting Level)](../build/reference/qpar-report-auto-parallelizer-reporting-level.md)   \n [/Qvec-report (Auto-Vectorizer Reporting Level)](../build/reference/qvec-report-auto-vectorizer-reporting-level.md)   \n [Vectorizer and Parallelizer Messages](../error-messages/tool-errors/vectorizer-and-parallelizer-messages.md)"}