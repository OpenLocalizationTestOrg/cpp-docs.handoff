{"nodes":[{"pos":[12,76],"content":"_InterlockedCompareExchange Intrinsic Functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_InterlockedCompareExchange Intrinsic Functions | Microsoft Docs","pos":[0,64]}]},{"content":"_InterlockedCompareExchange Intrinsic Functions","pos":[2459,2506]},{"content":"Microsoft Specific","pos":[2509,2527]},{"content":"Performs an interlocked compare and exchange.","pos":[2536,2581]},{"content":"Syntax","pos":[2590,2596]},{"content":"Parameters","pos":[5379,5389]},{"content":"[in, out]","pos":[5393,5402]},{"content":"Pointer to the destination value.","pos":[5420,5453]},{"content":"The sign is ignored.","pos":[5454,5474]},{"content":"[in]","pos":[5481,5485]},{"content":"Exchange value.","pos":[5500,5515]},{"content":"The sign is ignored.","pos":[5516,5536]},{"content":"[in]","pos":[5543,5547]},{"content":"Value to compare to destination.","pos":[5563,5595]},{"content":"The sign is ignored.","pos":[5596,5616]},{"content":"Return Value","pos":[5625,5637]},{"pos":[5641,5708],"content":"The return value is the initial value of the <ph id=\"ph1\">`Destination`</ph> pointer.","source":"The return value is the initial value of the `Destination` pointer."},{"content":"Requirements","pos":[5717,5729]},{"content":"Intrinsic","pos":[5736,5745]},{"content":"Architecture","pos":[5746,5758]},{"content":"Header","pos":[5759,5765]},{"pos":[5851,5917],"content":", <ph id=\"ph1\">`_InterlockedCompareExchange8`</ph>, <ph id=\"ph2\">`_InterlockedCompareExchange16`</ph>,","source":", `_InterlockedCompareExchange8`, `_InterlockedCompareExchange16`, "},{"pos":[5950,5959],"content":"x86, ARM,"},{"content":"intrin.h&gt;","pos":[6026,6035],"source":"intrin.h>"},{"pos":[6073,6435],"content":", <ph id=\"ph1\">`_InterlockedCompareExchange_rel`</ph>, <ph id=\"ph2\">`_InterlockedCompareExchange8_acq`</ph>, <ph id=\"ph3\">`_InterlockedCompareExchange8_nf`</ph>, <ph id=\"ph4\">`_InterlockedCompareExchange8_rel`</ph>,<ph id=\"ph5\">`_InterlockedCompareExchange16_acq`</ph>, <ph id=\"ph6\">`_InterlockedCompareExchange16_nf`</ph>, <ph id=\"ph7\">`_InterlockedCompareExchange16_rel`</ph>, <ph id=\"ph8\">`_InterlockedCompareExchange64_acq`</ph>, <ph id=\"ph9\">`_InterlockedCompareExchange64_nf`</ph>, <ph id=\"ph10\">`_InterlockedCompareExchange64_rel`</ph>,","source":", `_InterlockedCompareExchange_rel`, `_InterlockedCompareExchange8_acq`, `_InterlockedCompareExchange8_nf`, `_InterlockedCompareExchange8_rel`,`_InterlockedCompareExchange16_acq`, `_InterlockedCompareExchange16_nf`, `_InterlockedCompareExchange16_rel`, `_InterlockedCompareExchange64_acq`, `_InterlockedCompareExchange64_nf`, `_InterlockedCompareExchange64_rel`,"},{"content":"ARM","pos":[6436,6439]},{"content":"intrin.h&gt;","pos":[6442,6451],"source":"intrin.h>"},{"pos":[6488,6525],"content":", <ph id=\"ph1\">`_InterlockedCompareExchange16_np`</ph>,","source":", `_InterlockedCompareExchange16_np`, "},{"content":"intrin.h&gt;","pos":[6627,6636],"source":"intrin.h>"},{"pos":[6681,6768],"content":", <ph id=\"ph1\">`_InterlockedCompareExchange_HLERelease`</ph>, <ph id=\"ph2\">`_InterlockedCompareExchange64_HLEAcquire`</ph>,","source":", `_InterlockedCompareExchange_HLERelease`, `_InterlockedCompareExchange64_HLEAcquire`, "},{"pos":[6812,6816],"content":"x86,"},{"content":"immintrin.h&gt;","pos":[6883,6895],"source":"immintrin.h>"},{"content":"Remarks","pos":[6905,6912]},{"content":"performs an atomic comparison of the <ph id=\"ph1\">`Destination`</ph> value with the <ph id=\"ph2\">`Comparand`</ph> value.","pos":[6946,7030],"source":" performs an atomic comparison of the `Destination` value with the `Comparand` value."},{"content":"If the <ph id=\"ph1\">`Destination`</ph> value is equal to the <ph id=\"ph2\">`Comparand`</ph> value, the <ph id=\"ph3\">`Exchange`</ph> value is stored in the address specified by <ph id=\"ph4\">`Destination`</ph>.","pos":[7031,7166],"source":" If the `Destination` value is equal to the `Comparand` value, the `Exchange` value is stored in the address specified by `Destination`."},{"content":"Otherwise, no operation is performed.","pos":[7167,7204]},{"pos":[7241,7458],"content":"provides compiler intrinsic support for the Win32 <ph id=\"ph1\">[!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]</ph> <bpt id=\"p1\">[</bpt>InterlockedCompareExchange<ept id=\"p1\">](http://msdn.microsoft.com/library/ms683560.aspx)</ept> function.","source":" provides compiler intrinsic support for the Win32 [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)] [InterlockedCompareExchange](http://msdn.microsoft.com/library/ms683560.aspx) function."},{"pos":[7465,7642],"content":"There are several variations on <ph id=\"ph1\">`_InterlockedCompareExchange`</ph> that vary based on the data types they involve and whether processor-specific acquire or release semantics is used.","source":"There are several variations on `_InterlockedCompareExchange` that vary based on the data types they involve and whether processor-specific acquire or release semantics is used."},{"pos":[7649,7931],"content":"While the <ph id=\"ph1\">`_InterlockedCompareExchange`</ph> function operates on long integer values, <ph id=\"ph2\">`_InterlockedCompareExchange8`</ph> operates on 8-bit integer values, <ph id=\"ph3\">`_InterlockedCompareExchange16`</ph> operates on short integer values and <ph id=\"ph4\">`_InterlockedCompareExchange64`</ph> operates on 64-bit integer values.","source":"While the `_InterlockedCompareExchange` function operates on long integer values, `_InterlockedCompareExchange8` operates on 8-bit integer values, `_InterlockedCompareExchange16` operates on short integer values and `_InterlockedCompareExchange64` operates on 64-bit integer values."},{"content":"On ARM platforms, use the intrinsics with <ph id=\"ph1\">`_acq`</ph> and <ph id=\"ph2\">`_rel`</ph> suffixes for acquire and release semantics, such as at the beginning and end of a critical section.","pos":[7938,8097],"source":"On ARM platforms, use the intrinsics with `_acq` and `_rel` suffixes for acquire and release semantics, such as at the beginning and end of a critical section."},{"content":"The ARM intrinsics with an <ph id=\"ph1\">`_nf`</ph> (\"no fence\") suffix do not act as a memory barrier.","pos":[8098,8182],"source":" The ARM intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier."},{"pos":[8189,8315],"content":"The intrinsics with an <ph id=\"ph1\">`_np`</ph> (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler.","source":"The intrinsics with an `_np` (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler."},{"content":"On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with <ph id=\"ph1\">`_HLEAcquire`</ph> and <ph id=\"ph2\">`_HLERelease`</ph> suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware.","pos":[8322,8566],"source":"On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware."},{"content":"If these intrinsics are called on platforms that do not support HLE, the hint is ignored.","pos":[8567,8656]},{"content":"These routines are only available as intrinsics.","pos":[8663,8711]},{"content":"Example","pos":[8720,8727]},{"content":"In the following example, <ph id=\"ph1\">`_InterlockedCompareExchange`</ph> is used for simple low-level thread synchronization.","pos":[8731,8839],"source":"In the following example, `_InterlockedCompareExchange` is used for simple low-level thread synchronization."},{"content":"The approach has its limitations as a basis for multithreaded programming; it is presented to illustrate the typical use of the interlocked intrinsics.","pos":[8840,8991]},{"content":"For best results, use the Windows API.","pos":[8992,9030]},{"content":"For further information about multithreaded programming, see <bpt id=\"p1\">[</bpt>Writing a Multithreaded Win32 Program<ept id=\"p1\">](../parallel/writing-a-multithreaded-win32-program.md)</ept>.","pos":[9031,9186],"source":" For further information about multithreaded programming, see [Writing a Multithreaded Win32 Program](../parallel/writing-a-multithreaded-win32-program.md)."},{"content":"END Microsoft Specific","pos":[14520,14542]},{"content":"See Also","pos":[14551,14559]},{"content":"_InterlockedCompareExchange128","pos":[14564,14594]},{"content":"_InterlockedCompareExchangePointer Intrinsic Functions","pos":[14649,14703]},{"content":"Compiler Intrinsics","pos":[14782,14801]},{"content":"Keywords","pos":[14846,14854]},{"content":"Conflicts with the x86 Compiler","pos":[14885,14916]}],"content":"---\ntitle: \"_InterlockedCompareExchange Intrinsic Functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_InterlockedCompareExchange_HLERelease\"\n  - \"_InterlockedCompareExchange8_nf\"\n  - \"_InterlockedCompareExchange16_acq_cpp\"\n  - \"_InterlockedCompareExchange_acq_cpp\"\n  - \"_InterlockedCompareExchange16_rel_cpp\"\n  - \"_InterlockedCompareExchange64_rel_cpp\"\n  - \"_InterlockedCompareExchange_cpp\"\n  - \"_InterlockedCompareExchange16_cpp\"\n  - \"_InterlockedCompareExchange64_acq_cpp\"\n  - \"_InterlockedCompareExchange_acq\"\n  - \"_InterlockedCompareExchange64_rel\"\n  - \"_InterlockedCompareExchange64_nf\"\n  - \"_InterlockedCompareExchange_rel_cpp\"\n  - \"_InterlockedCompareExchange16_nf\"\n  - \"_InterlockedCompareExchange8\"\n  - \"_InterlockedCompareExchange64_np\"\n  - \"_InterlockedCompareExchange16_rel\"\n  - \"_InterlockedCompareExchange64_acq\"\n  - \"_InterlockedCompareExchange8_rel\"\n  - \"_InterlockedCompareExchange_HLEAcquire\"\n  - \"_InterlockedCompareExchange64_HLERelease\"\n  - \"_InterlockedCompareExchange64_cpp\"\n  - \"_InterlockedCompareExchange_np\"\n  - \"_InterlockedCompareExchange8_acq\"\n  - \"_InterlockedCompareExchange16_acq\"\n  - \"_InterlockedCompareExchange_rel\"\n  - \"_InterlockedCompareExchange64_HLEAcquire\"\n  - \"_InterlockedCompareExchange64\"\n  - \"_InterlockedCompareExchange16\"\n  - \"_InterlockedCompareExchange\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"_InterlockedCompareExchange16 intrinsic\"\n  - \"_InterlockedCompareExchange_acq intrinsic\"\n  - \"InterlockedCompareExchange_acq intrinsic\"\n  - \"_InterlockedCompareExchange intrinsic\"\n  - \"InterlockedCompareExchange64 intrinsic\"\n  - \"_InterlockedCompareExchange64_acq intrinsic\"\n  - \"InterlockedCompareExchange16 intrinsic\"\n  - \"_InterlockedCompareExchange_rel intrinsic\"\n  - \"InterlockedCompareExchange intrinsic\"\n  - \"InterlockedCompareExchange64_acq intrinsic\"\n  - \"InterlockedCompareExchange_rel intrinsic\"\n  - \"_InterlockedCompareExchange64 intrinsic\"\n  - \"InterlockedCompareExchange64_rel intrinsic\"\n  - \"_InterlockedCompareExchange64_rel intrinsic\"\nms.assetid: c3ad79c0-a523-4930-a3a4-69a65d7d5c81\ncaps.latest.revision: 26\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _InterlockedCompareExchange Intrinsic Functions\n**Microsoft Specific**  \n  \n Performs an interlocked compare and exchange.  \n  \n## Syntax  \n  \n```  \nlong _InterlockedCompareExchange(  \n   long volatile * Destination,  \n   long Exchange,  \n   long Comparand  \n);  \nlong _InterlockedCompareExchange_acq(  \n   long volatile * Destination,  \n   long Exchange,  \n   long Comparand  \n);  \nlong _InterlockedCompareExchange_HLEAcquire(  \n   long volatile * Destination,  \n   long Exchange,  \n   long Comparand  \n);  \nlong _InterlockedCompareExchange_HLERelease(  \n   long volatile * Destination,  \n   long Exchange,  \n   long Comparand  \n);  \nlong _InterlockedCompareExchange_np(  \n   long volatile * Destination,  \n   long Exchange,  \n   long Comparand  \n);  \nlong _InterlockedCompareExchange_rel(  \n   long volatile * Destination,  \n   long Exchange,  \n   long Comparand  \n);  \nchar _InterlockedCompareExchange8(  \n   char volatile * Destination,  \n   char Exchange,  \n   char Comparand  \n);  \nchar _InterlockedCompareExchange8_acq(  \n   char volatile * Destination,  \n   char Exchange,  \n   char Comparand  \n);  \nchar _InterlockedCompareExchange8_nf(  \n   char volatile * Destination,  \n   char Exchange,  \n   char Comparand  \n);  \nchar _InterlockedCompareExchange8_rel(  \n   char volatile * Destination,  \n   char Exchange,  \n   char Comparand  \n);  \nshort _InterlockedCompareExchange16(  \n   short volatile * Destination,  \n   short Exchange,  \n   short Comparand  \n);  \nshort _InterlockedCompareExchange16_acq(  \n   short volatile * Destination,  \n   short Exchange,  \n   short Comparand  \n);  \nshort _InterlockedCompareExchange16_nf(  \n   short volatile * Destination,  \n   short Exchange,  \n   short Comparand  \n);  \nshort _InterlockedCompareExchange16_np(  \n   short volatile * Destination,  \n   short Exchange,  \n   short Comparand  \n);  \nshort _InterlockedCompareExchange16_rel(  \n   short volatile * Destination,  \n   short Exchange,  \n   short Comparand  \n);  \n__int64 _InterlockedCompareExchange64(  \n   __int64 volatile * Destination,  \n   __int64 Exchange,  \n   __int64 Comparand  \n);  \n__int64 _InterlockedCompareExchange64_acq(  \n   __int64 volatile * Destination,  \n   __int64 Exchange,  \n   __int64 Comparand  \n);  \n__int64 _InterlockedCompareExchange64_HLEAcquire (  \n   __int64 volatile * Destination,  \n   __int64 Exchange,  \n   __int64 Comparand  \n);  \n__int64 _InterlockedCompareExchange64_HLERelease(  \n   __int64 volatile * Destination,  \n   __int64 Exchange,  \n   __int64 Comparand  \n);  \n__int64 _InterlockedCompareExchange64_nf(  \n   __int64 volatile * Destination,  \n   __int64 Exchange,  \n   __int64 Comparand  \n);  \n__int64 _InterlockedCompareExchange64_np(  \n   __int64 volatile * Destination,  \n   __int64 Exchange,  \n   __int64 Comparand  \n);  \n__int64 _InterlockedCompareExchange64_rel(  \n   __int64 volatile * Destination,  \n   __int64 Exchange,  \n   __int64 Comparand  \n);  \n```  \n  \n#### Parameters  \n [in, out] `Destination`  \n Pointer to the destination value. The sign is ignored.  \n  \n [in] `Exchange`  \n Exchange value. The sign is ignored.  \n  \n [in] `Comparand`  \n Value to compare to destination. The sign is ignored.  \n  \n## Return Value  \n The return value is the initial value of the `Destination` pointer.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|Header|  \n|---------------|------------------|------------|  \n|`_InterlockedCompareExchange`, `_InterlockedCompareExchange8`, `_InterlockedCompareExchange16`, `_InterlockedCompareExchange64`|x86, ARM, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_InterlockedCompareExchange_acq`, `_InterlockedCompareExchange_rel`, `_InterlockedCompareExchange8_acq`, `_InterlockedCompareExchange8_nf`, `_InterlockedCompareExchange8_rel`,`_InterlockedCompareExchange16_acq`, `_InterlockedCompareExchange16_nf`, `_InterlockedCompareExchange16_rel`, `_InterlockedCompareExchange64_acq`, `_InterlockedCompareExchange64_nf`, `_InterlockedCompareExchange64_rel`,|ARM|\\<intrin.h>|  \n|`_InterlockedCompareExchange_np`, `_InterlockedCompareExchange16_np`, `_InterlockedCompareExchange64_np`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_InterlockedCompareExchange_HLEAcquire`, `_InterlockedCompareExchange_HLERelease`, `_InterlockedCompareExchange64_HLEAcquire`, `_InterlockedCompareExchange64_HLERelease`|x86, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<immintrin.h>|  \n  \n## Remarks  \n `_InterlockedCompareExchange` performs an atomic comparison of the `Destination` value with the `Comparand` value. If the `Destination` value is equal to the `Comparand` value, the `Exchange` value is stored in the address specified by `Destination`. Otherwise, no operation is performed.  \n  \n `_InterlockedCompareExchange` provides compiler intrinsic support for the Win32 [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)] [InterlockedCompareExchange](http://msdn.microsoft.com/library/ms683560.aspx) function.  \n  \n There are several variations on `_InterlockedCompareExchange` that vary based on the data types they involve and whether processor-specific acquire or release semantics is used.  \n  \n While the `_InterlockedCompareExchange` function operates on long integer values, `_InterlockedCompareExchange8` operates on 8-bit integer values, `_InterlockedCompareExchange16` operates on short integer values and `_InterlockedCompareExchange64` operates on 64-bit integer values.  \n  \n On ARM platforms, use the intrinsics with `_acq` and `_rel` suffixes for acquire and release semantics, such as at the beginning and end of a critical section. The ARM intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier.  \n  \n The intrinsics with an `_np` (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler.  \n  \n On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware. If these intrinsics are called on platforms that do not support HLE, the hint is ignored.  \n  \n These routines are only available as intrinsics.  \n  \n## Example  \n In the following example, `_InterlockedCompareExchange` is used for simple low-level thread synchronization. The approach has its limitations as a basis for multithreaded programming; it is presented to illustrate the typical use of the interlocked intrinsics. For best results, use the Windows API. For further information about multithreaded programming, see [Writing a Multithreaded Win32 Program](../parallel/writing-a-multithreaded-win32-program.md).  \n  \n```  \n// intrinExample.cpp  \n// compile with: /EHsc /O2  \n// Simple example of using _Interlocked* intrinsics to  \n// do manual synchronization  \n//  \n// Add [-DSKIP_LOCKING] to the command line to disable  \n// the locking. This will cause the threads to execute out  \n// of sequence.  \n  \n#define _CRT_RAND_S  \n  \n#include \"windows.h\"  \n  \n#include <iostream>  \n#include <queue>  \n#include <intrin.h>  \n  \nusing namespace std;  \n  \n// --------------------------------------------------------------------  \n  \n// if defined, will not do any locking on shared data  \n//#define SKIP_LOCKING  \n  \n// A common way of locking using _InterlockedCompareExchange.  \n// Please refer to other sources for a discussion of the many issues  \n// involved. For example, this particular locking scheme performs well   \n// when lock contention is low, as the while loop overhead is small and  \n// locks are acquired very quickly, but degrades as many callers want  \n// the lock and most threads are doing a lot of interlocked spinning.  \n// There are also no guarantees that a caller will ever acquire the  \n// lock.  \nnamespace MyInterlockedIntrinsicLock  \n{  \n    typedef unsigned LOCK, *PLOCK;  \n  \n#pragma intrinsic(_InterlockedCompareExchange, _InterlockedExchange)  \n  \n    enum {LOCK_IS_FREE = 0, LOCK_IS_TAKEN = 1};  \n  \n    void Lock(PLOCK pl)   \n    {  \n#if !defined(SKIP_LOCKING)  \n        // If *pl == LOCK_IS_FREE, it is set to LOCK_IS_TAKEN  \n        // atomically, so only 1 caller gets the lock.  \n        // If *pl == LOCK_IS_TAKEN,  \n        // the result is LOCK_IS_TAKEN, and the while loop keeps spinning.  \n        while (_InterlockedCompareExchange((long *)pl,  \n                                           LOCK_IS_TAKEN, // exchange  \n                                           LOCK_IS_FREE)  // comparand  \n               == LOCK_IS_TAKEN)  \n        {  \n            // spin!  \n        }  \n        // This will also work.  \n        //while (_InterlockedExchange(pl, LOCK_IS_TAKEN) ==   \n        //                             LOCK_IS_TAKEN)  \n        //{  \n        //    // spin!  \n        //}  \n  \n        // At this point, the lock is acquired.  \n#endif  \n    }  \n  \n    void Unlock(PLOCK pl) {  \n#if !defined(SKIP_LOCKING)  \n        _InterlockedExchange((long *)pl, LOCK_IS_FREE);  \n#endif  \n    }  \n}  \n  \n// ------------------------------------------------------------------  \n  \n// Data shared by threads  \n  \nqueue<int> SharedQueue;  \nMyInterlockedIntrinsicLock::LOCK SharedLock;  \nint TicketNumber;  \n  \n// ------------------------------------------------------------------  \n  \nDWORD WINAPI  \nProducerThread(  \n    LPVOID unused  \n    )  \n{  \n    unsigned int randValue;  \n    while (1) {  \n        // Acquire shared data. Enter critical section.  \n        MyInterlockedIntrinsicLock::Lock(&SharedLock);  \n  \n        //cout << \">\" << TicketNumber << endl;  \n        SharedQueue.push(TicketNumber++);  \n  \n        // Release shared data. Leave critical section.  \n        MyInterlockedIntrinsicLock::Unlock(&SharedLock);  \n  \n        rand_s(&randValue);  \n        Sleep(randValue % 20);  \n    }  \n  \n    return 0;  \n}  \n  \nDWORD WINAPI  \nConsumerThread(  \n    LPVOID unused  \n    )  \n{  \n    while (1) {  \n        // Acquire shared data. Enter critical section  \n        MyInterlockedIntrinsicLock::Lock(&SharedLock);  \n  \n        if (!SharedQueue.empty()) {  \n            int x = SharedQueue.front();  \n            cout << \"<\" << x << endl;  \n            SharedQueue.pop();  \n        }  \n  \n        // Release shared data. Leave critical section  \n        MyInterlockedIntrinsicLock::Unlock(&SharedLock);  \n  \n        unsigned int randValue;  \n        rand_s(&randValue);  \n        Sleep(randValue % 20);  \n    }  \n    return 0;  \n}  \n  \nint main(  \n    void  \n    )  \n{  \n    const int timeoutTime = 500;  \n    int unused1, unused2;  \n    HANDLE threads[4];  \n  \n    // The program creates 4 threads:  \n    // two producer threads adding to the queue  \n    // and two consumers taking data out and printing it.  \n    threads[0] = CreateThread(NULL,  \n                              0,  \n                              ProducerThread,  \n                              &unused1,  \n                              0,  \n                              (LPDWORD)&unused2);  \n  \n    threads[1] = CreateThread(NULL,  \n                              0,  \n                              ConsumerThread,  \n                              &unused1,  \n                              0,  \n                              (LPDWORD)&unused2);  \n  \n    threads[2] = CreateThread(NULL,  \n                              0,  \n                              ProducerThread,  \n                              &unused1,  \n                              0,  \n                              (LPDWORD)&unused2);  \n  \n    threads[3] = CreateThread(NULL,  \n                              0,  \n                              ConsumerThread,  \n                              &unused1,  \n                              0,  \n                              (LPDWORD)&unused2);  \n  \n    WaitForMultipleObjects(4, threads, TRUE, timeoutTime);  \n  \n    return 0;  \n}  \n```  \n  \n```Output  \n<0  \n<1  \n<2  \n<3  \n<4  \n<5  \n<6  \n<7  \n<8  \n<9  \n<10  \n<11  \n<12  \n<13  \n<14  \n<15  \n<16  \n<17  \n<18  \n<19  \n<20  \n<21  \n<22  \n<23  \n<24  \n<25  \n<26  \n<27  \n<28  \n<29  \n```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [_InterlockedCompareExchange128](../intrinsics/interlockedcompareexchange128.md)   \n [_InterlockedCompareExchangePointer Intrinsic Functions](../intrinsics/interlockedcompareexchangepointer-intrinsic-functions.md)   \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)   \n [Keywords](../cpp/keywords-cpp.md)   \n [Conflicts with the x86 Compiler](../build/conflicts-with-the-x86-compiler.md)"}