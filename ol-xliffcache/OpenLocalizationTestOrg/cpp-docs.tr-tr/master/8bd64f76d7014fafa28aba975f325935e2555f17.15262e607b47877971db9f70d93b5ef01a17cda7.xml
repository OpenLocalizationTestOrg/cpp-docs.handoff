{"nodes":[{"pos":[12,71],"content":"Pragma Directives and the __Pragma Keyword | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Pragma Directives and the __Pragma Keyword | Microsoft Docs","pos":[0,59]}]},{"content":"Pragma Directives and the __Pragma Keyword","pos":[812,854]},{"content":"Pragma directives specify machine- or operating-specific compiler features.","pos":[855,930]},{"content":"The <ph id=\"ph1\">`__pragma`</ph> keyword, which is specific to the Microsoft compiler, enables you to code pragma directives within macro definitions.","pos":[931,1063],"source":" The `__pragma` keyword, which is specific to the Microsoft compiler, enables you to code pragma directives within macro definitions."},{"content":"Syntax","pos":[1072,1078]},{"content":"Remarks","pos":[1159,1166]},{"content":"Each implementation of C and C++ supports some features unique to its host machine or operating system.","pos":[1170,1273]},{"content":"Some programs, for example, must exercise precise control over the memory areas where data is put or to control the way certain functions receive parameters.","pos":[1274,1431]},{"content":"The <ph id=\"ph1\">`#pragma`</ph> directives offer a way for each compiler to offer machine- and operating system-specific features while retaining overall compatibility with the C and C++ languages.","pos":[1432,1611],"source":" The `#pragma` directives offer a way for each compiler to offer machine- and operating system-specific features while retaining overall compatibility with the C and C++ languages."},{"content":"Pragmas are machine- or operating system-specific by definition, and are usually different for every compiler.","pos":[1618,1728]},{"content":"Pragmas can be used in conditional statements, to provide new preprocessor functionality, or to provide implementation-defined information to the compiler.","pos":[1729,1884]},{"content":"The <ph id=\"ph1\">`token-string`</ph> is a series of characters that gives a specific compiler instruction and arguments, if any.","pos":[1891,2001],"source":"The `token-string` is a series of characters that gives a specific compiler instruction and arguments, if any."},{"content":"The number sign (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">#</ph><ept id=\"p1\">**</ept>) must be the first non-white-space character on the line that contains the pragma; white-space characters can separate the number sign and the word \"pragma\".","pos":[2002,2182],"source":" The number sign (**#**) must be the first non-white-space character on the line that contains the pragma; white-space characters can separate the number sign and the word \"pragma\"."},{"content":"Following <ph id=\"ph1\">`#pragma`</ph>, write any text that the translator can parse as preprocessing tokens.","pos":[2183,2273],"source":" Following `#pragma`, write any text that the translator can parse as preprocessing tokens."},{"content":"The argument to <ph id=\"ph1\">`#pragma`</ph> is subject to macro expansion.","pos":[2274,2330],"source":" The argument to `#pragma` is subject to macro expansion."},{"content":"If the compiler finds a pragma that it does not recognize, it issues a warning and continues compilation.","pos":[2337,2442]},{"content":"The Microsoft C and C++ compilers recognize the following pragmas:","pos":[2449,2515]},{"content":"alloc_text","pos":[2540,2550]},{"content":"auto_inline","pos":[2584,2595]},{"content":"bss_seg","pos":[2630,2637]},{"content":"check_stack","pos":[2672,2683]},{"content":"code_seg","pos":[2718,2726]},{"content":"comment","pos":[2758,2765]},{"content":"component","pos":[2806,2815]},{"pos":[2847,2891],"content":"<bpt id=\"p1\">[</bpt>conform<ept id=\"p1\">](../preprocessor/conform.md)</ept> <ph id=\"ph1\">&lt;sup&gt;</ph>1","source":"[conform](../preprocessor/conform.md) <sup>1"},{"content":"const_seg","pos":[2899,2908]},{"content":"data_seg","pos":[2945,2953]},{"content":"deprecated","pos":[2985,2995]},{"content":"detect_mismatch","pos":[3035,3050]},{"content":"fenv_access","pos":[3093,3104]},{"content":"float_control","pos":[3139,3152]},{"content":"fp_contract","pos":[3189,3200]},{"content":"function","pos":[3239,3247]},{"content":"hdrstop","pos":[3285,3292]},{"content":"include_alias","pos":[3323,3336]},{"pos":[3376,3422],"content":"<bpt id=\"p1\">[</bpt>init_seg<ept id=\"p1\">](../preprocessor/init-seg.md)</ept> <ph id=\"ph1\">&lt;sup&gt;</ph>1","source":"[init_seg](../preprocessor/init-seg.md) <sup>1"},{"content":"inline_depth","pos":[3430,3442]},{"content":"inline_recursion","pos":[3478,3494]},{"content":"intrinsic","pos":[3538,3547]},{"pos":[3579,3617],"content":"<bpt id=\"p1\">[</bpt>loop<ept id=\"p1\">](../preprocessor/loop.md)</ept> <ph id=\"ph1\">&lt;sup&gt;</ph>1","source":"[loop](../preprocessor/loop.md) <sup>1"},{"content":"make_public","pos":[3625,3636]},{"content":"managed","pos":[3675,3682]},{"content":"message","pos":[3723,3730]},{"content":"omp","pos":[3766,3769]},{"content":"once","pos":[3796,3800]},{"content":"optimize","pos":[3833,3841]},{"content":"pack","pos":[3873,3877]},{"pos":[3904,3972],"content":"<bpt id=\"p1\">[</bpt>pointers_to_members<ept id=\"p1\">](../preprocessor/pointers-to-members.md)</ept> <ph id=\"ph1\">&lt;sup&gt;</ph>1","source":"[pointers_to_members](../preprocessor/pointers-to-members.md) <sup>1"},{"content":"pop_macro","pos":[3984,3993]},{"content":"push_macro","pos":[4026,4036]},{"content":"region, endregion","pos":[4070,4087]},{"content":"runtime_checks","pos":[4131,4145]},{"content":"section","pos":[4183,4190]},{"content":"setlocale","pos":[4221,4230]},{"content":"strict_gs_check","pos":[4267,4282]},{"content":"unmanaged","pos":[4321,4330]},{"pos":[4370,4416],"content":"<bpt id=\"p1\">[</bpt>vtordisp<ept id=\"p1\">](../preprocessor/vtordisp.md)</ept> <ph id=\"ph1\">&lt;sup&gt;</ph>1","source":"[vtordisp](../preprocessor/vtordisp.md) <sup>1"},{"content":"warning","pos":[4428,4435]},{"content":"Supported only by the C++ compiler.","pos":[4477,4512]},{"content":"Pragmas and Compiler Options","pos":[4521,4549]},{"content":"Some pragmas provide the same functionality as compiler options.","pos":[4553,4617]},{"content":"When a pragma is encountered in source code, it overrides the behavior specified by the compiler option.","pos":[4618,4722]},{"content":"For example, if you specified <bpt id=\"p1\">[</bpt>/Zp8<ept id=\"p1\">](../build/reference/zp-struct-member-alignment.md)</ept>, you can override this compiler setting for specific sections of the code with <bpt id=\"p2\">[</bpt>pack<ept id=\"p2\">](../preprocessor/pack.md)</ept>:","pos":[4723,4921],"source":" For example, if you specified [/Zp8](../build/reference/zp-struct-member-alignment.md), you can override this compiler setting for specific sections of the code with [pack](../preprocessor/pack.md):"},{"content":"The __pragma() Keyword","pos":[5092,5114]},{"content":"Microsoft specific","pos":[5120,5138]},{"content":"The compiler also supports the <ph id=\"ph1\">`__pragma`</ph> keyword, which has the same functionality as the <ph id=\"ph2\">`#pragma`</ph> directive, but can be used inline in a macro definition.","pos":[5147,5304],"source":"The compiler also supports the `__pragma` keyword, which has the same functionality as the `#pragma` directive, but can be used inline in a macro definition."},{"content":"The <ph id=\"ph1\">`#pragma`</ph> directive cannot be used in a macro definition because the compiler interprets the number sign character ('#') in the directive to be the <bpt id=\"p1\">[</bpt>stringizing operator (#)<ept id=\"p1\">](../preprocessor/stringizing-operator-hash.md)</ept>.","pos":[5305,5530],"source":" The `#pragma` directive cannot be used in a macro definition because the compiler interprets the number sign character ('#') in the directive to be the [stringizing operator (#)](../preprocessor/stringizing-operator-hash.md)."},{"content":"The following code example demonstrates how the <ph id=\"ph1\">`__pragma`</ph> keyword can be used in a macro.","pos":[5537,5627],"source":"The following code example demonstrates how the `__pragma` keyword can be used in a macro."},{"content":"This code is excerpted from the mfcdual.h header in the ACDUAL sample in \"Compiler COM Support Samples\":","pos":[5628,5732]},{"content":"End Microsoft specific","pos":[6130,6152]},{"content":"See Also","pos":[6163,6171]},{"content":"C/C++ Preprocessor Reference","pos":[6176,6204]},{"content":"C Pragmas","pos":[6260,6269]},{"content":"Keywords","pos":[6304,6312]}],"content":"---\ntitle: \"Pragma Directives and the __Pragma Keyword | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"#pragma\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"#pragma directives, C/C++\"\n  - \"__pragma keyword\"\n  - \"pragma directives, C/C++\"\n  - \"pragmas, C/C++\"\n  - \"preprocessor\"\n  - \"pragmas\"\n  - \"preprocessor, pragmas\"\n  - \"pragma directives (#pragma)\"\nms.assetid: 9867b438-ac64-4e10-973f-c3955209873f\ncaps.latest.revision: 20\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Pragma Directives and the __Pragma Keyword\nPragma directives specify machine- or operating-specific compiler features. The `__pragma` keyword, which is specific to the Microsoft compiler, enables you to code pragma directives within macro definitions.  \n  \n## Syntax  \n  \n```  \n  \n      #pragma token-string  \n__pragma(token-string)  \n```  \n  \n## Remarks  \n Each implementation of C and C++ supports some features unique to its host machine or operating system. Some programs, for example, must exercise precise control over the memory areas where data is put or to control the way certain functions receive parameters. The `#pragma` directives offer a way for each compiler to offer machine- and operating system-specific features while retaining overall compatibility with the C and C++ languages.  \n  \n Pragmas are machine- or operating system-specific by definition, and are usually different for every compiler. Pragmas can be used in conditional statements, to provide new preprocessor functionality, or to provide implementation-defined information to the compiler.  \n  \n The `token-string` is a series of characters that gives a specific compiler instruction and arguments, if any. The number sign (**#**) must be the first non-white-space character on the line that contains the pragma; white-space characters can separate the number sign and the word \"pragma\". Following `#pragma`, write any text that the translator can parse as preprocessing tokens. The argument to `#pragma` is subject to macro expansion.  \n  \n If the compiler finds a pragma that it does not recognize, it issues a warning and continues compilation.  \n  \n The Microsoft C and C++ compilers recognize the following pragmas:  \n  \n||||  \n|-|-|-|  \n|[alloc_text](../preprocessor/alloc-text.md)|[auto_inline](../preprocessor/auto-inline.md)|[bss_seg](../preprocessor/bss-seg.md)|  \n|[check_stack](../preprocessor/check-stack.md)|[code_seg](../preprocessor/code-seg.md)|[comment](../preprocessor/comment-c-cpp.md)|  \n|[component](../preprocessor/component.md)|[conform](../preprocessor/conform.md) <sup>1</sup>|[const_seg](../preprocessor/const-seg.md)|  \n|[data_seg](../preprocessor/data-seg.md)|[deprecated](../preprocessor/deprecated-c-cpp.md)|[detect_mismatch](../preprocessor/detect-mismatch.md)|  \n|[fenv_access](../preprocessor/fenv-access.md)|[float_control](../preprocessor/float-control.md)|[fp_contract](../preprocessor/fp-contract.md)|  \n|[function](../preprocessor/function-c-cpp.md)|[hdrstop](../preprocessor/hdrstop.md)|[include_alias](../preprocessor/include-alias.md)|  \n|[init_seg](../preprocessor/init-seg.md) <sup>1</sup>|[inline_depth](../preprocessor/inline-depth.md)|[inline_recursion](../preprocessor/inline-recursion.md)|  \n|[intrinsic](../preprocessor/intrinsic.md)|[loop](../preprocessor/loop.md) <sup>1</sup>|[make_public](../preprocessor/make-public.md)|  \n|[managed](../preprocessor/managed-unmanaged.md)|[message](../preprocessor/message.md)||  \n|[omp](../preprocessor/omp.md)|[once](../preprocessor/once.md)||  \n|[optimize](../preprocessor/optimize.md)|[pack](../preprocessor/pack.md)|[pointers_to_members](../preprocessor/pointers-to-members.md) <sup>1</sup>|  \n|[pop_macro](../preprocessor/pop-macro.md)|[push_macro](../preprocessor/push-macro.md)|[region, endregion](../preprocessor/region-endregion.md)|  \n|[runtime_checks](../preprocessor/runtime-checks.md)|[section](../preprocessor/section.md)|[setlocale](../preprocessor/setlocale.md)|  \n|[strict_gs_check](../preprocessor/strict-gs-check.md)|[unmanaged](../preprocessor/managed-unmanaged.md)|[vtordisp](../preprocessor/vtordisp.md) <sup>1</sup>|  \n|[warning](../preprocessor/warning.md)|||  \n  \n 1. Supported only by the C++ compiler.  \n  \n## Pragmas and Compiler Options  \n Some pragmas provide the same functionality as compiler options. When a pragma is encountered in source code, it overrides the behavior specified by the compiler option. For example, if you specified [/Zp8](../build/reference/zp-struct-member-alignment.md), you can override this compiler setting for specific sections of the code with [pack](../preprocessor/pack.md):  \n  \n```  \ncl /Zp8 ...  \n  \n<file> - packing is 8  \n// ...  \n#pragma pack(push, 1) - packing is now 1  \n// ...  \n#pragma pack(pop) - packing is 8  \n</file>  \n```  \n  \n## The __pragma() Keyword  \n **Microsoft specific**  \n  \n The compiler also supports the `__pragma` keyword, which has the same functionality as the `#pragma` directive, but can be used inline in a macro definition. The `#pragma` directive cannot be used in a macro definition because the compiler interprets the number sign character ('#') in the directive to be the [stringizing operator (#)](../preprocessor/stringizing-operator-hash.md).  \n  \n The following code example demonstrates how the `__pragma` keyword can be used in a macro. This code is excerpted from the mfcdual.h header in the ACDUAL sample in \"Compiler COM Support Samples\":  \n  \n```  \n#define CATCH_ALL_DUAL \\  \nCATCH(COleException, e) \\  \n{ \\  \n_hr = e->m_sc; \\  \n} \\  \nAND_CATCH_ALL(e) \\  \n{ \\  \n__pragma(warning(push)) \\  \n__pragma(warning(disable:6246)) /*disable _ctlState prefast warning*/ \\  \nAFX_MANAGE_STATE(pThis->m_pModuleState); \\  \n__pragma(warning(pop)) \\  \n_hr = DualHandleException(_riidSource, e); \\  \n} \\  \nEND_CATCH_ALL \\  \nreturn _hr; \\  \n```  \n  \n **End Microsoft specific**  \n  \n## See Also  \n [C/C++ Preprocessor Reference](../preprocessor/c-cpp-preprocessor-reference.md)   \n [C Pragmas](../c-language/c-pragmas.md)   \n [Keywords](../cpp/keywords-cpp.md)"}