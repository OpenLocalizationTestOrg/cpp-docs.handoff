{"nodes":[{"pos":[12,76],"content":"How to: Marshal Function Pointers Using PInvoke | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Marshal Function Pointers Using PInvoke | Microsoft Docs","pos":[0,64]}]},{"content":"How to: Marshal Function Pointers Using PInvoke","pos":[790,837]},{"content":"This topic explains how managed delegates can be used in place of function pointers when interoperating with unmanaged functions using .NET Framework P/Invoke features.","pos":[838,1006]},{"content":"However, Visual C++ programmers are encouraged to use the C++ Interop features instead (when possible) because P/Invoke provides little compile-time error reporting, is not type-safe, and can be tedious to implement.","pos":[1007,1223]},{"content":"If the unmanaged API is packaged as a DLL and the source code is not available, P/Invoke is the only option.","pos":[1224,1332]},{"content":"Otherwise, see the following topics:","pos":[1333,1369]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[1380,1416]},{"content":"How to: Marshal Callbacks and Delegates By Using C++ Interop","pos":[1477,1537]},{"content":"Unmanaged APIs that take functions pointers as arguments can be called from managed code with a managed delegate in place of the native function pointer.","pos":[1619,1772]},{"content":"The compiler automatically marshals the delegate to unmanaged functions as a function pointer and inserts the necessary managed/unmanaged transition code.","pos":[1773,1927]},{"content":"Example","pos":[1936,1943]},{"content":"The following code consists of an unmanaged and a managed module.","pos":[1947,2012]},{"content":"The unmanaged module is a DLL that defines a function called TakesCallback that accepts a function pointer.","pos":[2013,2120]},{"content":"This address is used to execute the function.","pos":[2121,2166]},{"content":"The managed module defines a delegate that is marshaled to the native code as a function pointer and uses the &lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt; attribute to expose the native TakesCallback function to the managed code.","pos":[2173,2414],"source":"The managed module defines a delegate that is marshaled to the native code as a function pointer and uses the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to expose the native TakesCallback function to the managed code."},{"content":"In the main function, an instance of the delegate is created and passed to the TakesCallback function.","pos":[2415,2517]},{"content":"The program output demonstrates that this function gets executed by the native TakesCallback function.","pos":[2518,2620]},{"content":"The managed function suppresses garbage collection for the managed delegate to prevent .NET Framework garbage collection from relocating the delegate while the native function executes.","pos":[2627,2812]},{"content":"The managed module is compiled with /clr, but /clr:pure works as well.","pos":[2819,2889]},{"content":"Note that no portion of the DLL is exposed to the managed code using the traditional #include directive.","pos":[4331,4435]},{"content":"In fact, the DLL is accessed at run time only, so problems with functions imported with &lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt; will not be detected at compile time.","pos":[4436,4618],"source":" In fact, the DLL is accessed at run time only, so problems with functions imported with <xref:System.Runtime.InteropServices.DllImportAttribute> will not be detected at compile time."},{"content":"See Also","pos":[4627,4635]},{"content":"Using Explicit PInvoke in C++ (DllImport Attribute)","pos":[4640,4691]}],"content":"---\ntitle: \"How to: Marshal Function Pointers Using PInvoke | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"data marshaling [C++], callbacks and delegates\"\n  - \"interop [C++], callbacks and delegates\"\n  - \"platform invoke [C++], callbacks and delegates\"\n  - \"marshaling [C++], callbacks and delegates\"\nms.assetid: dcf396fd-a91d-49c0-ab0b-1ea160668a89\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Marshal Function Pointers Using PInvoke\nThis topic explains how managed delegates can be used in place of function pointers when interoperating with unmanaged functions using .NET Framework P/Invoke features. However, Visual C++ programmers are encouraged to use the C++ Interop features instead (when possible) because P/Invoke provides little compile-time error reporting, is not type-safe, and can be tedious to implement. If the unmanaged API is packaged as a DLL and the source code is not available, P/Invoke is the only option. Otherwise, see the following topics:  \n  \n-   [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)  \n  \n-   [How to: Marshal Callbacks and Delegates By Using C++ Interop](../dotnet/how-to-marshal-callbacks-and-delegates-by-using-cpp-interop.md)  \n  \n Unmanaged APIs that take functions pointers as arguments can be called from managed code with a managed delegate in place of the native function pointer. The compiler automatically marshals the delegate to unmanaged functions as a function pointer and inserts the necessary managed/unmanaged transition code.  \n  \n## Example  \n The following code consists of an unmanaged and a managed module. The unmanaged module is a DLL that defines a function called TakesCallback that accepts a function pointer. This address is used to execute the function.  \n  \n The managed module defines a delegate that is marshaled to the native code as a function pointer and uses the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to expose the native TakesCallback function to the managed code. In the main function, an instance of the delegate is created and passed to the TakesCallback function. The program output demonstrates that this function gets executed by the native TakesCallback function.  \n  \n The managed function suppresses garbage collection for the managed delegate to prevent .NET Framework garbage collection from relocating the delegate while the native function executes.  \n  \n The managed module is compiled with /clr, but /clr:pure works as well.  \n  \n```  \n// TraditionalDll5.cpp  \n// compile with: /LD /EHsc  \n#include <iostream>  \n#define TRADITIONALDLL_EXPORTS  \n#ifdef TRADITIONALDLL_EXPORTS  \n#define TRADITIONALDLL_API __declspec(dllexport)  \n#else  \n#define TRADITIONALDLL_API __declspec(dllimport)  \n#endif  \n  \nextern \"C\" {  \n   /* Declare an unmanaged function type that takes two int arguments  \n      Note the use of __stdcall for compatibility with managed code */  \n   typedef int (__stdcall *CALLBACK)(int);  \n   TRADITIONALDLL_API int TakesCallback(CALLBACK fp, int);  \n}  \n  \nint TakesCallback(CALLBACK fp, int n) {  \n   printf_s(\"[unmanaged] got callback address, calling it...\\n\");  \n   return fp(n);  \n}  \n```  \n  \n```  \n// MarshalDelegate.cpp  \n// compile with: /clr  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \npublic delegate int GetTheAnswerDelegate(int);  \npublic value struct TraditionalDLL {  \n   [DllImport(\"TraditionalDLL5.dll\")]  \n   static public int TakesCallback(GetTheAnswerDelegate^ pfn, int n);  \n};  \n  \nint GetNumber(int n) {  \n   Console::WriteLine(\"[managed] callback!\");  \n   static int x = 0;  \n   ++x;  \n   return x + n;  \n}  \n  \nint main() {  \n   GetTheAnswerDelegate^ fp = gcnew GetTheAnswerDelegate(GetNumber);  \n   pin_ptr<GetTheAnswerDelegate^> pp = &fp;  \n   Console::WriteLine(\"[managed] sending delegate as callback...\");  \n  \n   int answer = TraditionalDLL::TakesCallback(fp, 42);  \n}  \n```  \n  \n Note that no portion of the DLL is exposed to the managed code using the traditional #include directive. In fact, the DLL is accessed at run time only, so problems with functions imported with <xref:System.Runtime.InteropServices.DllImportAttribute> will not be detected at compile time.  \n  \n## See Also  \n [Using Explicit PInvoke in C++ (DllImport Attribute)](../dotnet/using-explicit-pinvoke-in-cpp-dllimport-attribute.md)"}