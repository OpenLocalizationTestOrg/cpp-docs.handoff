{"nodes":[{"pos":[12,77],"content":"Exporting from a DLL Using __declspec(dllexport) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Exporting from a DLL Using __declspec(dllexport) | Microsoft Docs","pos":[0,65]}]},{"content":"Exporting from a DLL Using __declspec(dllexport)","pos":[791,839]},{"content":"Microsoft introduced <bpt id=\"p1\">**</bpt>__export<ept id=\"p1\">**</ept> in the 16-bit compiler version of Visual C++ to allow the compiler to generate the export names automatically and place them in a .lib file.","pos":[840,1014],"source":"Microsoft introduced **__export** in the 16-bit compiler version of Visual C++ to allow the compiler to generate the export names automatically and place them in a .lib file."},{"content":"This .lib file can then be used just like a static .lib to link with a DLL.","pos":[1015,1090]},{"content":"In newer compiler versions, you can export data, functions, classes, or class member functions from a DLL using the <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> keyword.","pos":[1097,1247],"source":"In newer compiler versions, you can export data, functions, classes, or class member functions from a DLL using the **__declspec(dllexport)** keyword."},{"content":"<bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> adds the export directive to the object file so you do not need to use a .def file.","pos":[1248,1357],"source":"**__declspec(dllexport)** adds the export directive to the object file so you do not need to use a .def file."},{"content":"This convenience is most apparent when trying to export decorated C++ function names.","pos":[1364,1449]},{"content":"Because there is no standard specification for name decoration, the name of an exported function might change between compiler versions.","pos":[1450,1586]},{"content":"If you use <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept>, recompiling the DLL and dependent .exe files is necessary only to account for any naming convention changes.","pos":[1587,1733],"source":" If you use **__declspec(dllexport)**, recompiling the DLL and dependent .exe files is necessary only to account for any naming convention changes."},{"content":"Many export directives, such as ordinals, NONAME, and PRIVATE, can be made only in a .def file, and there is no way to specify these attributes without a .def file.","pos":[1740,1904]},{"content":"However, using <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> in addition to using a .def file does not cause build errors.","pos":[1905,2007],"source":" However, using **__declspec(dllexport)** in addition to using a .def file does not cause build errors."},{"content":"To export functions, the <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> keyword must appear to the left of the calling-convention keyword, if a keyword is specified.","pos":[2014,2158],"source":"To export functions, the **__declspec(dllexport)** keyword must appear to the left of the calling-convention keyword, if a keyword is specified."},{"content":"For example:","pos":[2159,2171]},{"content":"To export all of the public data members and member functions in a class, the keyword must appear to the left of the class name as follows:","pos":[2247,2386]},{"pos":[2503,2610],"content":"[!NOTE]\n `__declspec(dllexport)` cannot be applied to a function with the `__clrcall` calling convention.","leadings":["","> "],"nodes":[{"content":"cannot be applied to a function with the <ph id=\"ph1\">`__clrcall`</ph> calling convention.","pos":[33,105],"source":" cannot be applied to a function with the `__clrcall` calling convention."}]},{"content":"When building your DLL, you typically create a header file that contains the function prototypes and/or classes you are exporting and add <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> to the declarations in the header file.","pos":[2617,2820],"source":"When building your DLL, you typically create a header file that contains the function prototypes and/or classes you are exporting and add **__declspec(dllexport)** to the declarations in the header file."},{"content":"To make your code more readable, define a macro for <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> and use the macro with each symbol you are exporting:","pos":[2821,2952],"source":" To make your code more readable, define a macro for **__declspec(dllexport)** and use the macro with each symbol you are exporting:"},{"content":"<bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept> stores function names in the DLL's export table.","pos":[3021,3095],"source":"**__declspec(dllexport)** stores function names in the DLL's export table."},{"content":"If you want to optimize the table's size, see <bpt id=\"p1\">[</bpt>Exporting Functions from a DLL by Ordinal Rather Than by Name<ept id=\"p1\">](../build/exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md)</ept>.","pos":[3096,3281],"source":" If you want to optimize the table's size, see [Exporting Functions from a DLL by Ordinal Rather Than by Name](../build/exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md)."},{"pos":[3289,3419],"content":"[!NOTE]\n When porting DLL source code from Win16 to Win32, replace each instance of **__export** with **__declspec(dllexport)**.","leadings":["","> "],"nodes":[{"content":"When porting DLL source code from Win16 to Win32, replace each instance of <bpt id=\"p1\">**</bpt>__export<ept id=\"p1\">**</ept> with <bpt id=\"p2\">**</bpt>__declspec(dllexport)<ept id=\"p2\">**</ept>.","pos":[9,128],"source":" When porting DLL source code from Win16 to Win32, replace each instance of **__export** with **__declspec(dllexport)**."}]},{"content":"As a reference, search through the Win32 Winbase.h header file.","pos":[3426,3489]},{"content":"It contains examples of <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> usage.","pos":[3490,3546],"source":" It contains examples of **__declspec(dllimport)** usage."},{"content":"What do you want to do?","pos":[3555,3578]},{"content":"Export from a DLL using .def files","pos":[3589,3623]},{"content":"Export and import using AFX_EXT_CLASS","pos":[3685,3722]},{"content":"Export C++ functions for use in C-language executables","pos":[3791,3845]},{"content":"Export C functions for use in C or C++-language executables","pos":[3928,3987]},{"content":"Determine which exporting method to use","pos":[4075,4114]},{"content":"Import into an application using __declspec(dllimport)","pos":[4181,4235]},{"content":"Initialize a DLL","pos":[4315,4331]},{"content":"What do you want to know more about?","pos":[4373,4409]},{"content":"The __declspec keyword","pos":[4420,4442]},{"content":"Importing and exporting inline functions","pos":[4474,4514]},{"content":"Mutual imports","pos":[4580,4594]},{"content":"See Also","pos":[4632,4640]},{"content":"Exporting from a DLL","pos":[4645,4665]}],"content":"---\ntitle: \"Exporting from a DLL Using __declspec(dllexport) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"dllexport\"\n  - \"__declspec\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__declspec(dllexport) keyword [C++]\"\n  - \"names [C++], DLL exports by\"\n  - \"export directives [C++]\"\n  - \"exporting DLLs [C++], __declspec(dllexport) keyword\"\nms.assetid: a35e25e8-7263-4a04-bad4-00b284458679\ncaps.latest.revision: 11\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Exporting from a DLL Using __declspec(dllexport)\nMicrosoft introduced **__export** in the 16-bit compiler version of Visual C++ to allow the compiler to generate the export names automatically and place them in a .lib file. This .lib file can then be used just like a static .lib to link with a DLL.  \n  \n In newer compiler versions, you can export data, functions, classes, or class member functions from a DLL using the **__declspec(dllexport)** keyword. **__declspec(dllexport)** adds the export directive to the object file so you do not need to use a .def file.  \n  \n This convenience is most apparent when trying to export decorated C++ function names. Because there is no standard specification for name decoration, the name of an exported function might change between compiler versions. If you use **__declspec(dllexport)**, recompiling the DLL and dependent .exe files is necessary only to account for any naming convention changes.  \n  \n Many export directives, such as ordinals, NONAME, and PRIVATE, can be made only in a .def file, and there is no way to specify these attributes without a .def file. However, using **__declspec(dllexport)** in addition to using a .def file does not cause build errors.  \n  \n To export functions, the **__declspec(dllexport)** keyword must appear to the left of the calling-convention keyword, if a keyword is specified. For example:  \n  \n```  \n__declspec(dllexport) void __cdecl Function1(void);  \n```  \n  \n To export all of the public data members and member functions in a class, the keyword must appear to the left of the class name as follows:  \n  \n```  \nclass __declspec(dllexport) CExampleExport : public CObject  \n{ ... class definition ... };  \n```  \n  \n> [!NOTE]\n>  `__declspec(dllexport)` cannot be applied to a function with the `__clrcall` calling convention.  \n  \n When building your DLL, you typically create a header file that contains the function prototypes and/or classes you are exporting and add **__declspec(dllexport)** to the declarations in the header file. To make your code more readable, define a macro for **__declspec(dllexport)** and use the macro with each symbol you are exporting:  \n  \n```  \n#define DllExport   __declspec( dllexport )   \n```  \n  \n **__declspec(dllexport)** stores function names in the DLL's export table. If you want to optimize the table's size, see [Exporting Functions from a DLL by Ordinal Rather Than by Name](../build/exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md).  \n  \n> [!NOTE]\n>  When porting DLL source code from Win16 to Win32, replace each instance of **__export** with **__declspec(dllexport)**.  \n  \n As a reference, search through the Win32 Winbase.h header file. It contains examples of **__declspec(dllimport)** usage.  \n  \n## What do you want to do?  \n  \n-   [Export from a DLL using .def files](../build/exporting-from-a-dll-using-def-files.md)  \n  \n-   [Export and import using AFX_EXT_CLASS](../build/exporting-and-importing-using-afx-ext-class.md)  \n  \n-   [Export C++ functions for use in C-language executables](../build/exporting-cpp-functions-for-use-in-c-language-executables.md)  \n  \n-   [Export C functions for use in C or C++-language executables](../build/exporting-c-functions-for-use-in-c-or-cpp-language-executables.md)  \n  \n-   [Determine which exporting method to use](../build/determining-which-exporting-method-to-use.md)  \n  \n-   [Import into an application using __declspec(dllimport)](../build/importing-into-an-application-using-declspec-dllimport.md)  \n  \n-   [Initialize a DLL](../build/initializing-a-dll.md)  \n  \n## What do you want to know more about?  \n  \n-   [The __declspec keyword](../cpp/declspec.md)  \n  \n-   [Importing and exporting inline functions](../build/importing-and-exporting-inline-functions.md)  \n  \n-   [Mutual imports](../build/mutual-imports.md)  \n  \n## See Also  \n [Exporting from a DLL](../build/exporting-from-a-dll.md)"}