{"nodes":[{"pos":[12,57],"content":"_beginthread, _beginthreadex | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_beginthread, _beginthreadex | Microsoft Docs","pos":[0,45]}]},{"content":"_beginthread, _beginthreadex","pos":[1149,1177]},{"content":"Creates a thread.","pos":[1178,1195]},{"content":"Syntax","pos":[1204,1210]},{"content":"Parameters","pos":[1954,1964]},{"content":"Start address of a routine that begins execution of a new thread.","pos":[1987,2052]},{"content":"For <ph id=\"ph1\">`_beginthread`</ph>, the calling convention is either <bpt id=\"p1\">[</bpt>__cdecl<ept id=\"p1\">](../../cpp/cdecl.md)</ept> (for native code) or <bpt id=\"p2\">[</bpt>__clrcall<ept id=\"p2\">](../../cpp/clrcall.md)</ept> (for managed code); for <ph id=\"ph2\">`_beginthreadex`</ph>, it is either <bpt id=\"p3\">[</bpt>__stdcall<ept id=\"p3\">](../../cpp/stdcall.md)</ept> (for native code) or <bpt id=\"p4\">[</bpt>__clrcall<ept id=\"p4\">](../../cpp/clrcall.md)</ept> (for managed code).","pos":[2053,2354],"source":" For `_beginthread`, the calling convention is either [__cdecl](../../cpp/cdecl.md) (for native code) or [__clrcall](../../cpp/clrcall.md) (for managed code); for `_beginthreadex`, it is either [__stdcall](../../cpp/stdcall.md) (for native code) or [__clrcall](../../cpp/clrcall.md) (for managed code)."},{"content":"Stack size for a new thread, or 0.","pos":[2377,2411]},{"content":"Argument list to be passed to a new thread, or NULL.","pos":[2431,2483]},{"content":"Pointer to a <bpt id=\"p1\">[</bpt>SECURITY_ATTRIBUTES<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/aa379560)</ept> structure that determines whether the returned handle can be inherited by child processes.","pos":[2504,2689],"source":" Pointer to a [SECURITY_ATTRIBUTES](http://msdn.microsoft.com/library/windows/desktop/aa379560) structure that determines whether the returned handle can be inherited by child processes."},{"content":"If <ph id=\"ph1\">`Security`</ph> is NULL, the handle cannot be inherited.","pos":[2690,2744],"source":" If `Security` is NULL, the handle cannot be inherited."},{"content":"Must be NULL for Windows 95 applications.","pos":[2745,2786]},{"content":"Flags that control the initial state of a new thread.","pos":[2807,2860]},{"content":"Set <ph id=\"ph1\">`initflag`</ph> to <ph id=\"ph2\">`0`</ph> to run immediately, or to <ph id=\"ph3\">`CREATE_SUSPENDED`</ph> to create the thread in a suspended state; use <bpt id=\"p1\">[</bpt>ResumeThread<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms685086.aspx)</ept> to execute the thread.","pos":[2861,3077],"source":" Set `initflag` to `0` to run immediately, or to `CREATE_SUSPENDED` to create the thread in a suspended state; use [ResumeThread](http://msdn.microsoft.com/library/windows/desktop/ms685086.aspx) to execute the thread."},{"content":"Set <ph id=\"ph1\">`initflag`</ph> to <ph id=\"ph2\">`STACK_SIZE_PARAM_IS_A_RESERVATION`</ph> flag to use <ph id=\"ph3\">`stack_size`</ph> as the initial reserve size of the stack in bytes; if this flag is not specified, <ph id=\"ph4\">`stack_size`</ph> specifies the commit size.","pos":[3078,3278],"source":" Set `initflag` to `STACK_SIZE_PARAM_IS_A_RESERVATION` flag to use `stack_size` as the initial reserve size of the stack in bytes; if this flag is not specified, `stack_size` specifies the commit size."},{"content":"Points to a 32-bit variable that receives the thread identifier.","pos":[3299,3363]},{"content":"If it's NULL, it's not used.","pos":[3364,3392]},{"content":"Return Value","pos":[3401,3413]},{"content":"If successful, each of these functions returns a handle to the newly created thread; however, if the newly created thread exits too quickly, <ph id=\"ph1\">`_beginthread`</ph> might not return a valid handle.","pos":[3417,3605],"source":"If successful, each of these functions returns a handle to the newly created thread; however, if the newly created thread exits too quickly, `_beginthread` might not return a valid handle."},{"content":"(See the discussion in the Remarks section.) On an error, <ph id=\"ph1\">`_beginthread`</ph> returns -1L, and <ph id=\"ph2\">`errno`</ph> is set to <ph id=\"ph3\">`EAGAIN`</ph> if there are too many threads, to <ph id=\"ph4\">`EINVAL`</ph> if the argument is invalid or the stack size is incorrect, or to <ph id=\"ph5\">`EACCES`</ph> if there are insufficient resources (such as memory).","pos":[3606,3893],"source":" (See the discussion in the Remarks section.) On an error, `_beginthread` returns -1L, and `errno` is set to `EAGAIN` if there are too many threads, to `EINVAL` if the argument is invalid or the stack size is incorrect, or to `EACCES` if there are insufficient resources (such as memory)."},{"content":"On an error, <ph id=\"ph1\">`_beginthreadex`</ph> returns 0, and <ph id=\"ph2\">`errno`</ph> and <ph id=\"ph3\">`_doserrno`</ph> are set.","pos":[3894,3971],"source":" On an error, `_beginthreadex` returns 0, and `errno` and `_doserrno` are set."},{"content":"If <ph id=\"ph1\">`startaddress`</ph> is NULL, the invalid parameter handler is invoked, as described in <bpt id=\"p1\">[</bpt>Parameter Validation<ept id=\"p1\">](../../c-runtime-library/parameter-validation.md)</ept>.","pos":[3978,4135],"source":"If `startaddress` is NULL, the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md)."},{"content":"If execution is allowed to continue, these functions set <ph id=\"ph1\">`errno`</ph> to <ph id=\"ph2\">`EINVAL`</ph> and return -1.","pos":[4136,4227],"source":" If execution is allowed to continue, these functions set `errno` to `EINVAL` and return -1."},{"pos":[4234,4411],"content":"For more information about these and other return codes, see <bpt id=\"p1\">[</bpt>errno, _doserrno, _sys_errlist, and _sys_nerr<ept id=\"p1\">](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)</ept>.","source":"For more information about these and other return codes, see [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)."},{"pos":[4418,4522],"content":"For more information about <ph id=\"ph1\">`uintptr_t`</ph>, see <bpt id=\"p1\">[</bpt>Standard Types<ept id=\"p1\">](../../c-runtime-library/standard-types.md)</ept>.","source":"For more information about `uintptr_t`, see [Standard Types](../../c-runtime-library/standard-types.md)."},{"content":"Remarks","pos":[4531,4538]},{"content":"The <ph id=\"ph1\">`_beginthread`</ph> function creates a thread that begins execution of a routine at <ph id=\"ph2\">`start_address`</ph>.","pos":[4542,4641],"source":"The `_beginthread` function creates a thread that begins execution of a routine at `start_address`."},{"content":"The routine at <ph id=\"ph1\">`start_address`</ph> must use the <ph id=\"ph2\">`__cdecl`</ph> (for native code) or <ph id=\"ph3\">`__clrcall`</ph> (for managed code) calling convention and should have no return value.","pos":[4642,4799],"source":" The routine at `start_address` must use the `__cdecl` (for native code) or `__clrcall` (for managed code) calling convention and should have no return value."},{"content":"When the thread returns from that routine, it is terminated automatically.","pos":[4800,4874]},{"content":"For more information about threads, see <bpt id=\"p1\">[</bpt>Multithreading Support for Older Code (Visual C++)<ept id=\"p1\">](../../parallel/multithreading-support-for-older-code-visual-cpp.md)</ept>.","pos":[4875,5036],"source":" For more information about threads, see [Multithreading Support for Older Code (Visual C++)](../../parallel/multithreading-support-for-older-code-visual-cpp.md)."},{"content":"resembles the Win32 <bpt id=\"p1\">[</bpt>CreateThread<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682453.aspx)</ept> API more closely than <ph id=\"ph1\">`_beginthread`</ph> does.","pos":[5060,5202],"source":" resembles the Win32 [CreateThread](http://msdn.microsoft.com/library/windows/desktop/ms682453.aspx) API more closely than `_beginthread` does."},{"content":"differs from <ph id=\"ph1\">`_beginthread`</ph> in the following ways:","pos":[5220,5270],"source":" differs from `_beginthread` in the following ways:"},{"content":"has three additional parameters: <ph id=\"ph1\">`initflag`</ph>, <ph id=\"ph2\">`security`</ph>, and <ph id=\"ph3\">`threadaddr`</ph>.","pos":[5297,5371],"source":" has three additional parameters: `initflag`, `security`, and `threadaddr`."},{"content":"The new thread can be created in a suspended state, with a specified security, and can be accessed by using <ph id=\"ph1\">`thrdaddr`</ph>, which is the thread identifier.","pos":[5372,5523],"source":" The new thread can be created in a suspended state, with a specified security, and can be accessed by using `thrdaddr`, which is the thread identifier."},{"pos":[5533,5729],"content":"The routine at <ph id=\"ph1\">`start_address`</ph> that's passed to <ph id=\"ph2\">`_beginthreadex`</ph> must use the <ph id=\"ph3\">`__stdcall`</ph> (for native code) or <ph id=\"ph4\">`__clrcall`</ph> (for managed code) calling convention and must return a thread exit code.","source":"The routine at `start_address` that's passed to `_beginthreadex` must use the `__stdcall` (for native code) or `__clrcall` (for managed code) calling convention and must return a thread exit code."},{"pos":[5756,5794],"content":"returns 0 on failure, rather than -1L."},{"pos":[5804,5956],"content":"A thread that's created by using <ph id=\"ph1\">`_beginthreadex`</ph> is terminated by a call to <bpt id=\"p1\">[</bpt>_endthreadex<ept id=\"p1\">](../../c-runtime-library/reference/endthread-endthreadex.md)</ept>.","source":"A thread that's created by using `_beginthreadex` is terminated by a call to [_endthreadex](../../c-runtime-library/reference/endthread-endthreadex.md)."},{"content":"The <ph id=\"ph1\">`_beginthreadex`</ph> function gives you more control over how the thread is created than <ph id=\"ph2\">`_beginthread`</ph> does.","pos":[5963,6072],"source":"The `_beginthreadex` function gives you more control over how the thread is created than `_beginthread` does."},{"content":"The <ph id=\"ph1\">`_endthreadex`</ph> function is also more flexible.","pos":[6073,6123],"source":" The `_endthreadex` function is also more flexible."},{"content":"For example, with <ph id=\"ph1\">`_beginthreadex`</ph>, you can use security information, set the initial state of the thread (running or suspended), and get the thread identifier of the newly created thread.","pos":[6124,6312],"source":" For example, with `_beginthreadex`, you can use security information, set the initial state of the thread (running or suspended), and get the thread identifier of the newly created thread."},{"content":"You can also use the thread handle that's returned by <ph id=\"ph1\">`_beginthreadex`</ph> with the synchronization APIs, which you cannot do with <ph id=\"ph2\">`_beginthread`</ph>.","pos":[6313,6455],"source":" You can also use the thread handle that's returned by `_beginthreadex` with the synchronization APIs, which you cannot do with `_beginthread`."},{"content":"It's safer to use <ph id=\"ph1\">`_beginthreadex`</ph> than <ph id=\"ph2\">`_beginthread`</ph>.","pos":[6462,6517],"source":"It's safer to use `_beginthreadex` than `_beginthread`."},{"content":"If the thread that's generated by <ph id=\"ph1\">`_beginthread`</ph> exits quickly, the handle that's returned to the caller of <ph id=\"ph2\">`_beginthread`</ph> might be invalid or point to another thread.","pos":[6518,6685],"source":" If the thread that's generated by `_beginthread` exits quickly, the handle that's returned to the caller of `_beginthread` might be invalid or point to another thread."},{"content":"However, the handle that's returned by <ph id=\"ph1\">`_beginthreadex`</ph> has to be closed by the caller of <ph id=\"ph2\">`_beginthreadex`</ph>, so it is guaranteed to be a valid handle if <ph id=\"ph3\">`_beginthreadex`</ph> did not return an error.","pos":[6686,6879],"source":" However, the handle that's returned by `_beginthreadex` has to be closed by the caller of `_beginthreadex`, so it is guaranteed to be a valid handle if `_beginthreadex` did not return an error."},{"content":"You can call <bpt id=\"p1\">[</bpt>_endthread<ept id=\"p1\">](../../c-runtime-library/reference/endthread-endthreadex.md)</ept> or <ph id=\"ph1\">`_endthreadex`</ph> explicitly to terminate a thread; however, <ph id=\"ph2\">`_endthread`</ph> or <ph id=\"ph3\">`_endthreadex`</ph> is called automatically when the thread returns from the routine that's passed as a parameter.","pos":[6886,7158],"source":"You can call [_endthread](../../c-runtime-library/reference/endthread-endthreadex.md) or `_endthreadex` explicitly to terminate a thread; however, `_endthread` or `_endthreadex` is called automatically when the thread returns from the routine that's passed as a parameter."},{"content":"Terminating a thread with a call to <ph id=\"ph1\">`_endthread`</ph> or <ph id=\"ph2\">`_endthreadex`</ph> helps ensure correct recovery of resources that are allocated for the thread.","pos":[7159,7303],"source":" Terminating a thread with a call to `_endthread` or `_endthreadex` helps ensure correct recovery of resources that are allocated for the thread."},{"content":"automatically closes the thread handle, whereas <ph id=\"ph1\">`_endthreadex`</ph> does not.","pos":[7323,7395],"source":" automatically closes the thread handle, whereas `_endthreadex` does not."},{"content":"Therefore, when you use <ph id=\"ph1\">`_beginthread`</ph> and <ph id=\"ph2\">`_endthread`</ph>, do not explicitly close the thread handle by calling the Win32 <bpt id=\"p1\">[</bpt>CloseHandle<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms724211.aspx)</ept> API.","pos":[7396,7599],"source":" Therefore, when you use `_beginthread` and `_endthread`, do not explicitly close the thread handle by calling the Win32 [CloseHandle](http://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) API."},{"content":"This behavior differs from the Win32 <bpt id=\"p1\">[</bpt>ExitThread<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682659.aspx)</ept> API.","pos":[7600,7719],"source":" This behavior differs from the Win32 [ExitThread](http://msdn.microsoft.com/library/windows/desktop/ms682659.aspx) API."},{"pos":[7727,8001],"content":"[!NOTE]\n For an executable file linked with Libcmt.lib, do not call the Win32 `ExitThread` API so that you don't prevent the run-time system from reclaiming allocated resources. `_endthread` and `_endthreadex` reclaim allocated thread resources and then call `ExitThread`.","leadings":["","> "],"nodes":[{"content":" For an executable file linked with Libcmt.lib, do not call the Win32 `ExitThread` API so that you don't prevent the run-time system from reclaiming allocated resources. `_endthread` and `_endthreadex` reclaim allocated thread resources and then call `ExitThread`.","pos":[8,272],"nodes":[{"content":"For an executable file linked with Libcmt.lib, do not call the Win32 <ph id=\"ph1\">`ExitThread`</ph> API so that you don't prevent the run-time system from reclaiming allocated resources.","pos":[1,169],"source":" For an executable file linked with Libcmt.lib, do not call the Win32 `ExitThread` API so that you don't prevent the run-time system from reclaiming allocated resources."},{"content":"and <ph id=\"ph1\">`_endthreadex`</ph> reclaim allocated thread resources and then call <ph id=\"ph2\">`ExitThread`</ph>.","pos":[183,264],"source":" and `_endthreadex` reclaim allocated thread resources and then call `ExitThread`."}]}]},{"content":"The operating system handles the allocation of the stack when either <ph id=\"ph1\">`_beginthread`</ph> or <ph id=\"ph2\">`_beginthreadex`</ph> is called; you don't have to pass the address of the thread stack to either of these functions.","pos":[8008,8207],"source":"The operating system handles the allocation of the stack when either `_beginthread` or `_beginthreadex` is called; you don't have to pass the address of the thread stack to either of these functions."},{"content":"In addition, the <ph id=\"ph1\">`stack_size`</ph> argument can be 0, in which case the operating system uses the same value as the stack that's specified for the main thread.","pos":[8208,8362],"source":" In addition, the `stack_size` argument can be 0, in which case the operating system uses the same value as the stack that's specified for the main thread."},{"content":"is a parameter to be passed to the newly created thread.","pos":[8379,8435]},{"content":"Typically, it is the address of a data item, such as a character string.","pos":[8436,8508]},{"content":"can be NULL if it is not needed, but <ph id=\"ph1\">`_beginthread`</ph> and <ph id=\"ph2\">`_beginthreadex`</ph> must be given some value to pass to the new thread.","pos":[8519,8643],"source":" can be NULL if it is not needed, but `_beginthread` and `_beginthreadex` must be given some value to pass to the new thread."},{"content":"All threads are terminated if any thread calls <ph id=\"ph1\">`abort`</ph>, <ph id=\"ph2\">`exit`</ph>, <ph id=\"ph3\">`_exit`</ph>, or <ph id=\"ph4\">`ExitProcess`</ph>.","pos":[8644,8734],"source":" All threads are terminated if any thread calls `abort`, `exit`, `_exit`, or `ExitProcess`."},{"content":"The locale of the new thread is inherited from its parent thread.","pos":[8741,8806]},{"content":"If per-thread locale is enabled by a call to <bpt id=\"p1\">[</bpt>_configthreadlocale<ept id=\"p1\">](../../c-runtime-library/reference/configthreadlocale.md)</ept> (either globally or for new threads only), the thread can change its locale independently from its parent by calling <ph id=\"ph1\">`setlocale`</ph> or <ph id=\"ph2\">`_wsetlocale`</ph>.","pos":[8807,9077],"source":" If per-thread locale is enabled by a call to [_configthreadlocale](../../c-runtime-library/reference/configthreadlocale.md) (either globally or for new threads only), the thread can change its locale independently from its parent by calling `setlocale` or `_wsetlocale`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Locale<ept id=\"p1\">](../../c-runtime-library/locale.md)</ept>.","pos":[9078,9148],"source":" For more information, see [Locale](../../c-runtime-library/locale.md)."},{"content":"For mixed and pure code, <ph id=\"ph1\">`_beginthread`</ph> and <ph id=\"ph2\">`_beginthreadex`</ph> each have two overloads—one takes a native calling-convention function pointer, the other takes a <ph id=\"ph3\">`__clrcall`</ph> function pointer.","pos":[9155,9343],"source":"For mixed and pure code, `_beginthread` and `_beginthreadex` each have two overloads—one takes a native calling-convention function pointer, the other takes a `__clrcall` function pointer."},{"content":"The first overload is not application domain-safe and never will be.","pos":[9344,9412]},{"content":"If you are writing mixed or pure code you must ensure that the new thread enters the correct application domain before it accesses managed resources.","pos":[9413,9562]},{"content":"You can do this, for example, by using <bpt id=\"p1\">[</bpt>call_in_appdomain Function<ept id=\"p1\">](../../dotnet/call-in-appdomain-function.md)</ept>.","pos":[9563,9675],"source":" You can do this, for example, by using [call_in_appdomain Function](../../dotnet/call-in-appdomain-function.md)."},{"content":"The second overload is application domain-safe; the newly created thread will always end up in the application domain of the caller of <ph id=\"ph1\">`_beginthread`</ph> or <ph id=\"ph2\">`_beginthreadex`</ph>.","pos":[9676,9846],"source":" The second overload is application domain-safe; the newly created thread will always end up in the application domain of the caller of `_beginthread` or `_beginthreadex`."},{"content":"Requirements","pos":[9855,9867]},{"content":"Routine","pos":[9874,9881]},{"content":"Required header","pos":[9882,9897]},{"content":"process.h&gt;","pos":[9959,9969],"source":"process.h>"},{"content":"process.h&gt;","pos":[9993,10003],"source":"process.h>"},{"pos":[10011,10109],"content":"For more compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept>.","source":"For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md)."},{"content":"Libraries","pos":[10118,10127]},{"pos":[10131,10238],"content":"Multithreaded versions of the <bpt id=\"p1\">[</bpt>C run-time libraries<ept id=\"p1\">](../../c-runtime-library/crt-library-features.md)</ept> only.","source":"Multithreaded versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md) only."},{"pos":[10245,10365],"content":"To use <ph id=\"ph1\">`_beginthread`</ph> or <ph id=\"ph2\">`_beginthreadex`</ph>, the application must link with one of the multithreaded C run-time libraries.","source":"To use `_beginthread` or `_beginthreadex`, the application must link with one of the multithreaded C run-time libraries."},{"content":"Example","pos":[10374,10381]},{"pos":[10385,10444],"content":"The following example uses <ph id=\"ph1\">`_beginthread`</ph> and <ph id=\"ph2\">`_endthread`</ph>.","source":"The following example uses `_beginthread` and `_endthread`."},{"content":"Press any key to end the sample application.","pos":[14330,14374]},{"content":"Example","pos":[14383,14390]},{"content":"The following sample code demonstrates how you can use the thread handle that's returned by <ph id=\"ph1\">`_beginthreadex`</ph> with the synchronization API <bpt id=\"p1\">[</bpt>WaitForSingleObject<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms687032.aspx)</ept>.","pos":[14394,14619],"source":"The following sample code demonstrates how you can use the thread handle that's returned by `_beginthreadex` with the synchronization API [WaitForSingleObject](http://msdn.microsoft.com/library/windows/desktop/ms687032.aspx)."},{"content":"The main thread waits for the second thread to terminate before it continues.","pos":[14620,14697]},{"content":"When the second thread calls <ph id=\"ph1\">`_endthreadex`</ph>, it causes its thread object to go to the signaled state.","pos":[14698,14799],"source":" When the second thread calls `_endthreadex`, it causes its thread object to go to the signaled state."},{"content":"This allows the primary thread to continue running.","pos":[14800,14851]},{"content":"This cannot be done with <ph id=\"ph1\">`_beginthread`</ph> and <ph id=\"ph2\">`_endthread`</ph>, because <ph id=\"ph3\">`_endthread`</ph> calls <ph id=\"ph4\">`CloseHandle`</ph>, which destroys the thread object before it can be set to the signaled state.","pos":[14852,15028],"source":" This cannot be done with `_beginthread` and `_endthread`, because `_endthread` calls `CloseHandle`, which destroys the thread object before it can be set to the signaled state."},{"content":".NET Framework Equivalent","pos":[16190,16215]},{"content":"System::Threading::Thread::Start","pos":[16220,16252]},{"content":"See Also","pos":[16339,16347]},{"content":"Process and Environment Control","pos":[16352,16383]},{"content":"_endthread, _endthreadex","pos":[16450,16474]},{"content":"abort","pos":[16541,16546]},{"content":"exit, _Exit, _exit","pos":[16597,16615]},{"content":"GetExitCodeThread","pos":[16675,16692]}],"content":"---\ntitle: \"_beginthread, _beginthreadex | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_beginthread\"\n  - \"_beginthreadex\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\n  - \"api-ms-win-crt-runtime-l1-1-0.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"beginthread\"\n  - \"_beginthread\"\n  - \"beginthreadex\"\n  - \"_beginthreadex\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"_beginthread function\"\n  - \"threading [C++], creating threads\"\n  - \"beginthreadex function\"\n  - \"_beginthreadex function\"\n  - \"beginthread function\"\nms.assetid: 0df64740-a978-4358-a88f-fb0702720091\ncaps.latest.revision: 36\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _beginthread, _beginthreadex\nCreates a thread.  \n  \n## Syntax  \n  \n```  \nuintptr_t _beginthread( // NATIVE CODE  \n   void( __cdecl *start_address )( void * ),  \n   unsigned stack_size,  \n   void *arglist   \n);  \nuintptr_t _beginthread( // MANAGED CODE  \n   void( __clrcall *start_address )( void * ),  \n   unsigned stack_size,  \n   void *arglist   \n);  \nuintptr_t _beginthreadex( // NATIVE CODE  \n   void *security,  \n   unsigned stack_size,  \n   unsigned ( __stdcall *start_address )( void * ),  \n   void *arglist,  \n   unsigned initflag,  \n   unsigned *thrdaddr   \n);  \nuintptr_t _beginthreadex( // MANAGED CODE  \n   void *security,  \n   unsigned stack_size,  \n   unsigned ( __clrcall *start_address )( void * ),  \n   void *arglist,  \n   unsigned initflag,  \n   unsigned *thrdaddr   \n);  \n```  \n  \n#### Parameters  \n `start_address`  \n Start address of a routine that begins execution of a new thread. For `_beginthread`, the calling convention is either [__cdecl](../../cpp/cdecl.md) (for native code) or [__clrcall](../../cpp/clrcall.md) (for managed code); for `_beginthreadex`, it is either [__stdcall](../../cpp/stdcall.md) (for native code) or [__clrcall](../../cpp/clrcall.md) (for managed code).  \n  \n `stack_size`  \n Stack size for a new thread, or 0.  \n  \n `arglist`  \n Argument list to be passed to a new thread, or NULL.  \n  \n `Security`  \n Pointer to a [SECURITY_ATTRIBUTES](http://msdn.microsoft.com/library/windows/desktop/aa379560) structure that determines whether the returned handle can be inherited by child processes. If `Security` is NULL, the handle cannot be inherited. Must be NULL for Windows 95 applications.  \n  \n `initflag`  \n Flags that control the initial state of a new thread. Set `initflag` to `0` to run immediately, or to `CREATE_SUSPENDED` to create the thread in a suspended state; use [ResumeThread](http://msdn.microsoft.com/library/windows/desktop/ms685086.aspx) to execute the thread. Set `initflag` to `STACK_SIZE_PARAM_IS_A_RESERVATION` flag to use `stack_size` as the initial reserve size of the stack in bytes; if this flag is not specified, `stack_size` specifies the commit size.  \n  \n `thrdaddr`  \n Points to a 32-bit variable that receives the thread identifier. If it's NULL, it's not used.  \n  \n## Return Value  \n If successful, each of these functions returns a handle to the newly created thread; however, if the newly created thread exits too quickly, `_beginthread` might not return a valid handle. (See the discussion in the Remarks section.) On an error, `_beginthread` returns -1L, and `errno` is set to `EAGAIN` if there are too many threads, to `EINVAL` if the argument is invalid or the stack size is incorrect, or to `EACCES` if there are insufficient resources (such as memory). On an error, `_beginthreadex` returns 0, and `errno` and `_doserrno` are set.  \n  \n If `startaddress` is NULL, the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md). If execution is allowed to continue, these functions set `errno` to `EINVAL` and return -1.  \n  \n For more information about these and other return codes, see [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).  \n  \n For more information about `uintptr_t`, see [Standard Types](../../c-runtime-library/standard-types.md).  \n  \n## Remarks  \n The `_beginthread` function creates a thread that begins execution of a routine at `start_address`. The routine at `start_address` must use the `__cdecl` (for native code) or `__clrcall` (for managed code) calling convention and should have no return value. When the thread returns from that routine, it is terminated automatically. For more information about threads, see [Multithreading Support for Older Code (Visual C++)](../../parallel/multithreading-support-for-older-code-visual-cpp.md).  \n  \n `_beginthreadex` resembles the Win32 [CreateThread](http://msdn.microsoft.com/library/windows/desktop/ms682453.aspx) API more closely than `_beginthread` does. `_beginthreadex` differs from `_beginthread` in the following ways:  \n  \n-   `_beginthreadex` has three additional parameters: `initflag`, `security`, and `threadaddr`. The new thread can be created in a suspended state, with a specified security, and can be accessed by using `thrdaddr`, which is the thread identifier.  \n  \n-   The routine at `start_address` that's passed to `_beginthreadex` must use the `__stdcall` (for native code) or `__clrcall` (for managed code) calling convention and must return a thread exit code.  \n  \n-   `_beginthreadex` returns 0 on failure, rather than -1L.  \n  \n-   A thread that's created by using `_beginthreadex` is terminated by a call to [_endthreadex](../../c-runtime-library/reference/endthread-endthreadex.md).  \n  \n The `_beginthreadex` function gives you more control over how the thread is created than `_beginthread` does. The `_endthreadex` function is also more flexible. For example, with `_beginthreadex`, you can use security information, set the initial state of the thread (running or suspended), and get the thread identifier of the newly created thread. You can also use the thread handle that's returned by `_beginthreadex` with the synchronization APIs, which you cannot do with `_beginthread`.  \n  \n It's safer to use `_beginthreadex` than `_beginthread`. If the thread that's generated by `_beginthread` exits quickly, the handle that's returned to the caller of `_beginthread` might be invalid or point to another thread. However, the handle that's returned by `_beginthreadex` has to be closed by the caller of `_beginthreadex`, so it is guaranteed to be a valid handle if `_beginthreadex` did not return an error.  \n  \n You can call [_endthread](../../c-runtime-library/reference/endthread-endthreadex.md) or `_endthreadex` explicitly to terminate a thread; however, `_endthread` or `_endthreadex` is called automatically when the thread returns from the routine that's passed as a parameter. Terminating a thread with a call to `_endthread` or `_endthreadex` helps ensure correct recovery of resources that are allocated for the thread.  \n  \n `_endthread` automatically closes the thread handle, whereas `_endthreadex` does not. Therefore, when you use `_beginthread` and `_endthread`, do not explicitly close the thread handle by calling the Win32 [CloseHandle](http://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) API. This behavior differs from the Win32 [ExitThread](http://msdn.microsoft.com/library/windows/desktop/ms682659.aspx) API.  \n  \n> [!NOTE]\n>  For an executable file linked with Libcmt.lib, do not call the Win32 `ExitThread` API so that you don't prevent the run-time system from reclaiming allocated resources. `_endthread` and `_endthreadex` reclaim allocated thread resources and then call `ExitThread`.  \n  \n The operating system handles the allocation of the stack when either `_beginthread` or `_beginthreadex` is called; you don't have to pass the address of the thread stack to either of these functions. In addition, the `stack_size` argument can be 0, in which case the operating system uses the same value as the stack that's specified for the main thread.  \n  \n `arglist` is a parameter to be passed to the newly created thread. Typically, it is the address of a data item, such as a character string. `arglist` can be NULL if it is not needed, but `_beginthread` and `_beginthreadex` must be given some value to pass to the new thread. All threads are terminated if any thread calls `abort`, `exit`, `_exit`, or `ExitProcess`.  \n  \n The locale of the new thread is inherited from its parent thread. If per-thread locale is enabled by a call to [_configthreadlocale](../../c-runtime-library/reference/configthreadlocale.md) (either globally or for new threads only), the thread can change its locale independently from its parent by calling `setlocale` or `_wsetlocale`. For more information, see [Locale](../../c-runtime-library/locale.md).  \n  \n For mixed and pure code, `_beginthread` and `_beginthreadex` each have two overloads—one takes a native calling-convention function pointer, the other takes a `__clrcall` function pointer. The first overload is not application domain-safe and never will be. If you are writing mixed or pure code you must ensure that the new thread enters the correct application domain before it accesses managed resources. You can do this, for example, by using [call_in_appdomain Function](../../dotnet/call-in-appdomain-function.md). The second overload is application domain-safe; the newly created thread will always end up in the application domain of the caller of `_beginthread` or `_beginthreadex`.  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`_beginthread`|\\<process.h>|  \n|`_beginthreadex`|\\<process.h>|  \n  \n For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md).  \n  \n## Libraries  \n Multithreaded versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md) only.  \n  \n To use `_beginthread` or `_beginthreadex`, the application must link with one of the multithreaded C run-time libraries.  \n  \n## Example  \n The following example uses `_beginthread` and `_endthread`.  \n  \n```  \n// crt_BEGTHRD.C  \n// compile with: /MT /D \"_X86_\" /c  \n// processor: x86  \n#include <windows.h>  \n#include <process.h>    /* _beginthread, _endthread */  \n#include <stddef.h>  \n#include <stdlib.h>  \n#include <conio.h>  \n  \nvoid Bounce( void * );  \nvoid CheckKey( void * );  \n  \n// GetRandom returns a random integer between min and max.  \n#define GetRandom( min, max ) ((rand() % (int)(((max) + 1) - (min))) + (min))  \n// GetGlyph returns a printable ASCII character value  \n#define GetGlyph( val ) ((char)((val + 32) % 93 + 33))  \n  \nBOOL repeat = TRUE;                 // Global repeat flag   \nHANDLE hStdOut;                     // Handle for console window  \nCONSOLE_SCREEN_BUFFER_INFO csbi;    // Console information structure  \n  \nint main()  \n{  \n    int param = 0;  \n    int * pparam = &param;  \n  \n    // Get display screen's text row and column information.  \n    hStdOut = GetStdHandle( STD_OUTPUT_HANDLE );  \n    GetConsoleScreenBufferInfo( hStdOut, &csbi );  \n  \n    // Launch CheckKey thread to check for terminating keystroke.  \n    _beginthread( CheckKey, 0, NULL );  \n  \n    // Loop until CheckKey terminates program or 1000 threads created.   \n    while( repeat && param < 1000 )  \n    {  \n        // launch another character thread.  \n        _beginthread( Bounce, 0, (void *) pparam );  \n  \n        // increment the thread parameter  \n        param++;  \n  \n        // Wait one second between loops.  \n        Sleep( 1000L );  \n    }  \n}  \n  \n// CheckKey - Thread to wait for a keystroke, then clear repeat flag.  \nvoid CheckKey( void * ignored )  \n{  \n    _getch();  \n    repeat = 0;    // _endthread implied  \n}  \n  \n// Bounce - Thread to create and and control a colored letter that moves  \n// around on the screen.  \n//  \n// Params: parg - the value to create the character from  \nvoid Bounce( void * parg )  \n{  \n    char       blankcell = 0x20;  \n    CHAR_INFO  ci;  \n    COORD      oldcoord, cellsize, origin;  \n    DWORD      result;  \n    SMALL_RECT region;  \n  \n    cellsize.X = cellsize.Y = 1;  \n    origin.X = origin.Y = 0;  \n  \n    // Generate location, letter and color attribute from thread argument.  \n    srand( _threadid );  \n    oldcoord.X = region.Left = region.Right =   \n        GetRandom(csbi.srWindow.Left, csbi.srWindow.Right - 1);  \n    oldcoord.Y = region.Top = region.Bottom =   \n        GetRandom(csbi.srWindow.Top, csbi.srWindow.Bottom - 1);  \n    ci.Char.AsciiChar = GetGlyph(*((int *)parg));  \n    ci.Attributes = GetRandom(1, 15);  \n  \n    while (repeat)  \n    {  \n        // Pause between loops.  \n        Sleep( 100L );  \n  \n        // Blank out our old position on the screen, and draw new letter.  \n        WriteConsoleOutputCharacterA(hStdOut, &blankcell, 1, oldcoord, &result);  \n        WriteConsoleOutputA(hStdOut, &ci, cellsize, origin, &region);  \n  \n        // Increment the coordinate for next placement of the block.  \n        oldcoord.X = region.Left;  \n        oldcoord.Y = region.Top;  \n        region.Left = region.Right += GetRandom(-1, 1);  \n        region.Top = region.Bottom += GetRandom(-1, 1);  \n  \n        // Correct placement (and beep) if about to go off the screen.  \n        if (region.Left < csbi.srWindow.Left)  \n            region.Left = region.Right = csbi.srWindow.Left + 1;  \n        else if (region.Right >= csbi.srWindow.Right)  \n            region.Left = region.Right = csbi.srWindow.Right - 2;  \n        else if (region.Top < csbi.srWindow.Top)  \n            region.Top = region.Bottom = csbi.srWindow.Top + 1;  \n        else if (region.Bottom >= csbi.srWindow.Bottom)  \n            region.Top = region.Bottom = csbi.srWindow.Bottom - 2;  \n  \n        // If not at a screen border, continue, otherwise beep.  \n        else  \n            continue;  \n        Beep((ci.Char.AsciiChar - 'A') * 100, 175);  \n    }  \n    // _endthread given to terminate  \n    _endthread();  \n}  \n```  \n  \n Press any key to end the sample application.  \n  \n## Example  \n The following sample code demonstrates how you can use the thread handle that's returned by `_beginthreadex` with the synchronization API [WaitForSingleObject](http://msdn.microsoft.com/library/windows/desktop/ms687032.aspx). The main thread waits for the second thread to terminate before it continues. When the second thread calls `_endthreadex`, it causes its thread object to go to the signaled state. This allows the primary thread to continue running. This cannot be done with `_beginthread` and `_endthread`, because `_endthread` calls `CloseHandle`, which destroys the thread object before it can be set to the signaled state.  \n  \n```  \n// crt_begthrdex.cpp  \n// compile with: /MT  \n#include <windows.h>  \n#include <stdio.h>  \n#include <process.h>  \n  \nunsigned Counter;   \nunsigned __stdcall SecondThreadFunc( void* pArguments )  \n{  \n    printf( \"In second thread...\\n\" );  \n  \n    while ( Counter < 1000000 )  \n        Counter++;  \n  \n    _endthreadex( 0 );  \n    return 0;  \n}   \n  \nint main()  \n{   \n    HANDLE hThread;  \n    unsigned threadID;  \n  \n    printf( \"Creating second thread...\\n\" );  \n  \n    // Create the second thread.  \n    hThread = (HANDLE)_beginthreadex( NULL, 0, &SecondThreadFunc, NULL, 0, &threadID );  \n  \n    // Wait until second thread terminates. If you comment out the line  \n    // below, Counter will not be correct because the thread has not  \n    // terminated, and Counter most likely has not been incremented to  \n    // 1000000 yet.  \n    WaitForSingleObject( hThread, INFINITE );  \n    printf( \"Counter should be 1000000; it is-> %d\\n\", Counter );  \n    // Destroy the thread object.  \n    CloseHandle( hThread );  \n}  \n```  \n  \n```Output  \nCreating second thread...  \nIn second thread...  \nCounter should be 1000000; it is-> 1000000  \n```  \n  \n## .NET Framework Equivalent  \n [System::Threading::Thread::Start](https://msdn.microsoft.com/en-us/library/system.threading.thread.start.aspx)  \n  \n## See Also  \n [Process and Environment Control](../../c-runtime-library/process-and-environment-control.md)   \n [_endthread, _endthreadex](../../c-runtime-library/reference/endthread-endthreadex.md)   \n [abort](../../c-runtime-library/reference/abort.md)   \n [exit, _Exit, _exit](../../c-runtime-library/reference/exit-exit-exit.md)   \n [GetExitCodeThread](http://msdn.microsoft.com/library/windows/desktop/ms683190)"}