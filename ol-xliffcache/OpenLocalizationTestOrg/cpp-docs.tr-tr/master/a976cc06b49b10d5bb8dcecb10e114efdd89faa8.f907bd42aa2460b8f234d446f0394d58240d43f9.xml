{"nodes":[{"pos":[12,66],"content":"Concurrency namespace functions (AMP) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Concurrency namespace functions (AMP) | Microsoft Docs","pos":[0,54]}]},{"content":"Concurrency namespace functions (AMP)","pos":[308,345]},{"content":"all_memory_fence","pos":[365,381]},{"content":"amp_uninitialize","pos":[403,419]},{"content":"atomic_compare_exchange","pos":[441,464]},{"content":"atomic_exchange Function (C++ AMP)","pos":[497,531]},{"content":"atomic_fetch_add Function (C++ AMP)","pos":[552,587]},{"content":"atomic_fetch_and Function (C++ AMP)","pos":[609,644]},{"content":"atomic_fetch_dec","pos":[670,686]},{"content":"atomic_fetch_inc","pos":[708,724]},{"content":"atomic_fetch_max","pos":[746,762]},{"content":"atomic_fetch_min","pos":[788,804]},{"content":"atomic_fetch_or Function (C++ AMP)","pos":[826,860]},{"content":"atomic_fetch_sub Function (C++ AMP)","pos":[881,916]},{"content":"atomic_fetch_xor Function (C++ AMP)","pos":[942,977]},{"content":"copy","pos":[999,1003]},{"content":"copy_async","pos":[1013,1023]},{"content":"direct3d_abort","pos":[1043,1057]},{"content":"direct3d_errorf","pos":[1077,1092]},{"content":"direct3d_printf","pos":[1113,1128]},{"content":"global_memory_fence","pos":[1153,1172]},{"content":"parallel_for_each Function (C++ AMP)","pos":[1197,1233]},{"content":"tile_static_memory_fence","pos":[1256,1280]},{"pos":[1352,1368],"content":"all_memory_fence"},{"content":"Blocks execution of all threads in a tile until all memory accesses have been completed.","pos":[1372,1460]},{"content":"This ensures that all memory accesses are visible to other threads in the thread tile, and are executed in program order.","pos":[1461,1582]},{"content":"Parameters","pos":[1681,1691]},{"content":"A <ph id=\"ph1\">`tile_barrier`</ph> object.","pos":[1709,1733],"source":" A `tile_barrier` object."},{"pos":[1776,1792],"content":"amp_uninitialize"},{"content":"Uninitializes the C++ AMP runtime.","pos":[1796,1830]},{"content":"It is legal to call this function multiple times during an applications lifetime.","pos":[1831,1912]},{"content":"Calling any C++ AMP API afer calling this function will reinitialize the C++ AMP runtime.","pos":[1913,2002]},{"content":"Note that it is illegal to use C++ AMP objects across calls to this function and doing so will result in undefined behavior.","pos":[2003,2127]},{"content":"Also, concurrently calling this function and any other AMP APIs is illegal and would result in undefined behavior.","pos":[2128,2242]},{"pos":[2340,2363],"content":"atomic_compare_exchange"},{"content":"Atomically compares the value stored at a memory location specified in the first argument for equality with the value of the second specified argument, and if the values are the same, the value at the memory location is changed to that of the third specified argument.","pos":[2367,2635]},{"content":"Parameters","pos":[2960,2970]},{"content":"The location from which one of the values to be compared is read, and to which the new value, if any, is to be stored.","pos":[2985,3103]},{"content":"The location from which the second value to be compared is read.","pos":[3131,3195]},{"content":"The value to be stored to the memory location specified in by <ph id=\"ph1\">`_Dest`</ph> if <ph id=\"ph2\">`_Dest`</ph> is equal to <ph id=\"ph3\">`_Expected_value`</ph>.","pos":[3213,3324],"source":" The value to be stored to the memory location specified in by `_Dest` if `_Dest` is equal to `_Expected_value`."},{"content":"Return Value","pos":[3334,3346]},{"pos":[3357,3408],"content":"if the operation is successful; otherwise, <ph id=\"ph1\">`false`</ph>.","source":" if the operation is successful; otherwise, `false`."},{"pos":[3451,3485],"content":"atomic_exchange Function (C++ AMP)"},{"content":"Sets the value of destination location as an atomic operation.","pos":[3489,3551]},{"content":"Parameters","pos":[3885,3895]},{"content":"Pointer to the destionation location.","pos":[3910,3947]},{"content":"The new value.","pos":[3965,3979]},{"content":"Return Value","pos":[3989,4001]},{"content":"The original value of the destination location.","pos":[4005,4052]},{"pos":[4096,4131],"content":"atomic_fetch_add Function (C++ AMP)"},{"content":"Atomically add a value to the value of a memory location.","pos":[4135,4192]},{"content":"Parameters","pos":[4429,4439]},{"content":"Pointer to the memory location.","pos":[4454,4485]},{"content":"The value to be added.","pos":[4503,4525]},{"content":"Return Value","pos":[4535,4547]},{"content":"The original value of the memory location.","pos":[4551,4593]},{"pos":[4636,4671],"content":"atomic_fetch_and Function (C++ AMP)"},{"content":"Atomically performs a bitwise AND operation of a value and the value of a memory location.","pos":[4675,4765]},{"content":"Parameters","pos":[5002,5012]},{"content":"Pointer to the memory location.","pos":[5027,5058]},{"content":"The value to use in the bitwise AND calculation.","pos":[5076,5124]},{"content":"Return Value","pos":[5134,5146]},{"content":"The original value of the memory location.","pos":[5150,5192]},{"pos":[5235,5251],"content":"atomic_fetch_dec"},{"content":"Atomically decrements the value stored at the specified memory location.","pos":[5255,5327]},{"content":"Parameters","pos":[5505,5515]},{"content":"The location in memory of the value to be decremented.","pos":[5530,5584]},{"content":"Return Value","pos":[5594,5606]},{"content":"The original value stored at the memory location.","pos":[5610,5659]},{"pos":[5702,5718],"content":"atomic_fetch_inc"},{"content":"Atomically increments the value stored at the specified memory location.","pos":[5722,5794]},{"content":"Parameters","pos":[5966,5976]},{"content":"The location in memory of the value to be incremented.","pos":[5991,6045]},{"content":"Return Value","pos":[6055,6067]},{"content":"The original value stored at the memory location.","pos":[6071,6120]},{"pos":[6163,6179],"content":"atomic_fetch_max"},{"content":"Atomically computes the maximum value between the value stored at the memory location specified in the first argument and the value specified in the second argument, and stores it at the same memory location.","pos":[6183,6391]},{"content":"Parameters","pos":[6628,6638]},{"content":"The location from which one of the values to be compared is read, and to which the maximum of the two values is to be stored.","pos":[6653,6778]},{"content":"The value to be compared to the value at the specified location.","pos":[6796,6860]},{"content":"Return Value","pos":[6870,6882]},{"content":"The original value stored at the specified location location.","pos":[6886,6947]},{"pos":[6990,7006],"content":"atomic_fetch_min"},{"content":"Atomically computes the minimum value between the value stored at the memory location specified in the first argument and the value specified in the second argument, and stores it at the same memory location.","pos":[7010,7218]},{"content":"Parameters","pos":[7455,7465]},{"content":"The location from which one of the values to be compared is read, and to which the minimum of the two values is to be stored.","pos":[7480,7605]},{"content":"The value to be compared to the value at the specified location.","pos":[7623,7687]},{"content":"Return Value","pos":[7697,7709]},{"content":"The original value stored at the specified location location.","pos":[7713,7774]},{"pos":[7816,7850],"content":"atomic_fetch_or Function (C++ AMP)"},{"content":"Atomically performs a bitwise OR operation with a value and the value of a memory location.","pos":[7854,7945]},{"content":"Parameters","pos":[8180,8190]},{"content":"Pointer to the memory location.","pos":[8205,8236]},{"content":"The value to use in the bitwise OR calculation.","pos":[8254,8301]},{"content":"Return Value","pos":[8311,8323]},{"content":"The original value of the memory location.","pos":[8327,8369]},{"pos":[8412,8447],"content":"atomic_fetch_sub Function (C++ AMP)"},{"content":"Atomically subtracts a value from a memory location.","pos":[8451,8503]},{"content":"Parameters","pos":[8740,8750]},{"content":"Pointer to the destionation location.","pos":[8765,8802]},{"content":"The value to be subtracted.","pos":[8820,8847]},{"content":"Return Value","pos":[8857,8869]},{"content":"The original value of the memory location.","pos":[8873,8915]},{"pos":[8958,8993],"content":"atomic_fetch_xor Function (C++ AMP)"},{"content":"Atomically peforms an bitwise XOR operation of a value and a memory location.","pos":[8997,9074]},{"content":"Parameters","pos":[9311,9321]},{"content":"Pointer to the memory location.","pos":[9336,9367]},{"content":"The value to use in the XOR calculation.","pos":[9385,9425]},{"content":"Return Value","pos":[9435,9447]},{"content":"The original value of the memory location.","pos":[9451,9493]},{"pos":[9524,9528],"content":"copy"},{"content":"Copies a C++ AMP object.","pos":[9532,9556]},{"content":"All synchronous data transfer requirements are met.","pos":[9557,9608]},{"content":"You can't copy data when running code on an accelerator.","pos":[9609,9665]},{"content":"The general form of this function is <ph id=\"ph1\">`copy(src, dest)`</ph>.","pos":[9666,9721],"source":" The general form of this function is `copy(src, dest)`."},{"content":"Parameters","pos":[11619,11629]},{"content":"The object to copy to.","pos":[11644,11666]},{"content":"An output iterator to the beginning position at destination.","pos":[11688,11748]},{"content":"The type of the input interator.","pos":[11774,11806]},{"content":"The type of the output iterator.","pos":[11833,11865]},{"content":"The rank of the object to copy from or the object to copy to.","pos":[11883,11944]},{"content":"To object to copy.","pos":[11961,11979]},{"content":"A beginning iterator into the source container.","pos":[12001,12048]},{"content":"An ending iterator into the source container.","pos":[12069,12114]},{"content":"The data type of the elements that are copied.","pos":[12137,12183]},{"pos":[12220,12230],"content":"copy_async"},{"content":"Copies a C++ AMP object and returns a <bpt id=\"p1\">[</bpt>completion_future<ept id=\"p1\">](completion-future-class.md)</ept> object that can be waited on.","pos":[12234,12349],"source":"Copies a C++ AMP object and returns a [completion_future](completion-future-class.md) object that can be waited on."},{"content":"You can't copy data when running code on an accelerator.","pos":[12350,12406]},{"content":"The general form of this function is <ph id=\"ph1\">`copy(src, dest)`</ph>.","pos":[12408,12463],"source":"  The general form of this function is `copy(src, dest)`."},{"content":"Parameters","pos":[14707,14717]},{"content":"The object to copy to.","pos":[14732,14754]},{"content":"An output iterator to the beginning position at destination.","pos":[14776,14836]},{"content":"The type of the input interator.","pos":[14862,14894]},{"content":"The type of the output iterator.","pos":[14921,14953]},{"content":"The rank of the object to copy from or the object to copy to.","pos":[14971,15032]},{"content":"To object to copy.","pos":[15049,15067]},{"content":"A beginning iterator into the source container.","pos":[15089,15136]},{"content":"An ending iterator into the source container.","pos":[15157,15202]},{"content":"The data type of the elements that are copied.","pos":[15225,15271]},{"content":"Return Value","pos":[15281,15293]},{"pos":[15297,15336],"content":"A <ph id=\"ph1\">`future&lt;void&gt;`</ph> that can be waited on.","source":"A `future<void>` that can be waited on."},{"pos":[15377,15391],"content":"direct3d_abort"},{"content":"Aborts the execution of a function with the <ph id=\"ph1\">`restrict(amp)`</ph> restriction clause.","pos":[15395,15474],"source":"Aborts the execution of a function with the `restrict(amp)` restriction clause."},{"content":"When the AMP runtime detects the call, it raises a <bpt id=\"p1\">[</bpt>runtime_exception<ept id=\"p1\">](runtime-exception-class.md)</ept> exception with the error message \"Reference Rasterizer: Shader abort instruction hit\".","pos":[15475,15660],"source":" When the AMP runtime detects the call, it raises a [runtime_exception](runtime-exception-class.md) exception with the error message \"Reference Rasterizer: Shader abort instruction hit\"."},{"pos":[15754,15769],"content":"direct3d_errorf"},{"content":"Prints a formatted string to the Visual Studio output window.","pos":[15773,15834]},{"content":"It is called from a function with the <ph id=\"ph1\">`restrict(amp)`</ph> restriction clause.","pos":[15835,15908],"source":" It is called from a function with the `restrict(amp)` restriction clause."},{"content":"When the AMP runtime detects the call, it raises a <bpt id=\"p1\">[</bpt>runtime_exception<ept id=\"p1\">](runtime-exception-class.md)</ept> exception with the same formatting string.","pos":[15909,16050],"source":" When the AMP runtime detects the call, it raises a [runtime_exception](runtime-exception-class.md) exception with the same formatting string."},{"pos":[16170,16185],"content":"direct3d_printf"},{"content":"Prints a formatted string to the Visual Studio output window.","pos":[16189,16250]},{"content":"It is called from a function with the <ph id=\"ph1\">`restrict(amp)`</ph> restriction clause.","pos":[16251,16324],"source":" It is called from a function with the `restrict(amp)` restriction clause."},{"pos":[16448,16467],"content":"global_memory_fence"},{"content":"Blocks execution of all threads in a tile until all global memory accesses have been completed.","pos":[16471,16566]},{"content":"This ensures that global memory accesses are visible to other threads in the thread tile, and are executed in program order.","pos":[16567,16691]},{"content":"Parameters","pos":[16793,16803]},{"content":"A tile_barrier object","pos":[16821,16842]},{"pos":[16886,16922],"content":"parallel_for_each Function (C++ AMP)"},{"content":"Runs a function across the compute domain.","pos":[16926,16968]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>C++ AMP Overview<ept id=\"p1\">](../../../parallel/amp/cpp-amp-overview.md)</ept>.","pos":[16969,17057],"source":" For more information, see [C++ AMP Overview](../../../parallel/amp/cpp-amp-overview.md)."},{"content":"Parameters","pos":[18596,18606]},{"content":"The <ph id=\"ph1\">`accelerator_view`</ph> object to run the parallel computation on.","pos":[18626,18691],"source":" The `accelerator_view` object to run the parallel computation on."},{"content":"An <ph id=\"ph1\">`extent`</ph> object that contains the data for the computation.","pos":[18719,18781],"source":" An `extent` object that contains the data for the computation."},{"content":"The dimension of the <ph id=\"ph1\">`tiled_extent`</ph> object.","pos":[18799,18842],"source":" The dimension of the `tiled_extent` object."},{"content":"The dimension of the <ph id=\"ph1\">`tiled_extent`</ph> object.","pos":[18860,18903],"source":" The dimension of the `tiled_extent` object."},{"content":"The dimension of the <ph id=\"ph1\">`tiled_extent`</ph> object.","pos":[18921,18964],"source":" The dimension of the `tiled_extent` object."},{"content":"A lambda or function object that takes an argument of type \"index<ph id=\"ph1\">\\&lt;</ph>_Rank&gt;\" and performs the parallel computation.","pos":[18984,19097],"source":" A lambda or function object that takes an argument of type \"index\\<_Rank>\" and performs the parallel computation."},{"content":"A lambda or functor.","pos":[19122,19142]},{"content":"The rank of the extent.","pos":[19160,19183]},{"pos":[19234,19258],"content":"tile_static_memory_fence"},{"content":"Blocks execution of all threads in a tile until all outstanding <ph id=\"ph1\">`tile_static`</ph> memory accesses have been completed.","pos":[19262,19376],"source":"Blocks execution of all threads in a tile until all outstanding `tile_static` memory accesses have been completed."},{"content":"This ensures that <ph id=\"ph1\">`tile_static`</ph> memory accesses are visible to other threads in the thread tile, and that accesses are executed in program order.","pos":[19377,19522],"source":" This ensures that `tile_static` memory accesses are visible to other threads in the thread tile, and that accesses are executed in program order."},{"content":"Parameters","pos":[19629,19639]},{"content":"A tile_barrier object.","pos":[19657,19679]},{"content":"See Also","pos":[19688,19696]},{"content":"Concurrency Namespace (C++ AMP)","pos":[19701,19732]}],"content":"---\ntitle: \"Concurrency namespace functions (AMP) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 2bef0985-cb90-4ece-90b9-66529aec73c9\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\n---\n# Concurrency namespace functions (AMP)\n||||  \n|-|-|-|  \n|[all_memory_fence](#all_memory_fence)|[amp_uninitialize](#amp_uninitialize)|[atomic_compare_exchange](#atomic_compare_exchange)|  \n|[atomic_exchange Function (C++ AMP)](#atomic_exchange)|[atomic_fetch_add Function (C++ AMP)](#atomic_fetch_add)|[atomic_fetch_and Function (C++ AMP)](#atomic_fetch_and)|  \n|[atomic_fetch_dec](#atomic_fetch_dec)|[atomic_fetch_inc](#atomic_fetch_inc)|[atomic_fetch_max](#atomic_fetch_max)|  \n|[atomic_fetch_min](#atomic_fetch_min)|[atomic_fetch_or Function (C++ AMP)](#atomic_fetch_or)|[atomic_fetch_sub Function (C++ AMP)](#atomic_fetch_sub)|  \n|[atomic_fetch_xor Function (C++ AMP)](#atomic_fetch_xor)|[copy](#copy)|[copy_async](#copy_async)|  \n|[direct3d_abort](#direct3d_abort)|[direct3d_errorf](#direct3d_errorf)|[direct3d_printf](#direct3d_printf)|  \n|[global_memory_fence](#global_memory_fence)|[parallel_for_each Function (C++ AMP)](#parallel_for_each)|[tile_static_memory_fence](#tile_static_memory_fence)|  \n  \n##  <a name=\"all_memory_fence\"></a>  all_memory_fence  \n Blocks execution of all threads in a tile until all memory accesses have been completed. This ensures that all memory accesses are visible to other threads in the thread tile, and are executed in program order.  \n  \n```  \ninline void all_memory_fence(const tile_barrier& _Barrier) restrict(amp);\n```  \n  \n### Parameters  \n `_Barrier`  \n A `tile_barrier` object.  \n  \n##  <a name=\"amp_uninitialize\"></a>  amp_uninitialize  \n Uninitializes the C++ AMP runtime. It is legal to call this function multiple times during an applications lifetime. Calling any C++ AMP API afer calling this function will reinitialize the C++ AMP runtime. Note that it is illegal to use C++ AMP objects across calls to this function and doing so will result in undefined behavior. Also, concurrently calling this function and any other AMP APIs is illegal and would result in undefined behavior.  \n  \n```  \nvoid __cdecl amp_uninitialize();\n```  \n  \n##  <a name=\"atomic_compare_exchange\"></a>  atomic_compare_exchange  \n Atomically compares the value stored at a memory location specified in the first argument for equality with the value of the second specified argument, and if the values are the same, the value at the memory location is changed to that of the third specified argument.  \n  \n```  \ninline bool atomic_compare_exchange(\n    _Inout_ int* _Dest,  \n    _Inout_ int* _Expected_value,  \n    int value  \n    ) restrict(amp)\n\n \ninline bool atomic_compare_exchange(\n    _Inout_ unsigned int* _Dest,  \n    _Inout_ unsigned int* _Expected_value,  \n    unsigned int value  \n    ) restrict(amp)\n```  \n  \n### Parameters  \n `_Dest`  \n The location from which one of the values to be compared is read, and to which the new value, if any, is to be stored.  \n  \n `_Expected_value`  \n The location from which the second value to be compared is read.  \n  \n `value`  \n The value to be stored to the memory location specified in by `_Dest` if `_Dest` is equal to `_Expected_value`.  \n  \n### Return Value  \n `true` if the operation is successful; otherwise, `false`.  \n  \n\n##  <a name=\"atomic_exchange\"></a>  atomic_exchange Function (C++ AMP)  \n Sets the value of destination location as an atomic operation.  \n  \n```  \ninline int atomic_exchange(\n    _Inout_ int* _Dest,  \n    int value  \n    ) restrict(amp)\n\n \ninline unsigned int atomic_exchange(\n    _Inout_ unsigned int* _Dest,  \n    unsigned int value  \n    ) restrict(amp)\n\n \ninline float atomic_exchange(\n    _Inout_ float* _Dest,  \n    float value  \n    ) restrict(amp)\n```  \n  \n### Parameters  \n `_Dest`  \n Pointer to the destionation location.  \n  \n `value`  \n The new value.  \n  \n### Return Value  \n The original value of the destination location.  \n  \n\n##  <a name=\"atomic_fetch_add\"></a>  atomic_fetch_add Function (C++ AMP)  \n Atomically add a value to the value of a memory location.  \n  \n```  \ninline int atomic_fetch_add(\n    _Inout_ int* _Dest,  \n    int value  \n    ) restrict(amp)\n\n \ninline unsigned int atomic_fetch_add(\n    _Inout_ unsigned int* _Dest,  \n    unsigned int value  \n    ) restrict(amp)\n```  \n  \n### Parameters  \n `_Dest`  \n Pointer to the memory location.  \n  \n `value`  \n The value to be added.  \n  \n### Return Value  \n The original value of the memory location.  \n  \n##  <a name=\"atomic_fetch_and\"></a>  atomic_fetch_and Function (C++ AMP)  \n Atomically performs a bitwise AND operation of a value and the value of a memory location.  \n  \n```  \ninline int atomic_fetch_and(\n    _Inout_ int* _Dest,  \n    int value  \n    ) restrict(amp)\n\n \ninline unsigned int atomic_fetch_and(\n    _Inout_ unsigned int* _Dest,  \n    unsigned int value  \n    ) restrict(amp)\n```  \n  \n### Parameters  \n `_Dest`  \n Pointer to the memory location.  \n  \n `value`  \n The value to use in the bitwise AND calculation.  \n  \n### Return Value  \n The original value of the memory location.  \n  \n##  <a name=\"atomic_fetch_dec\"></a>  atomic_fetch_dec  \n Atomically decrements the value stored at the specified memory location.  \n  \n```  \ninline int atomic_fetch_dec(_Inout_ int* _Dest  \n    ) restrict(amp)\n\n \ninline unsigned int atomic_fetch_dec(_Inout_ unsigned int* _Dest) restrict(amp);\n```  \n  \n### Parameters  \n `_Dest`  \n The location in memory of the value to be decremented.  \n  \n### Return Value  \n The original value stored at the memory location.  \n  \n##  <a name=\"atomic_fetch_inc\"></a>  atomic_fetch_inc  \n Atomically increments the value stored at the specified memory location.  \n  \n```  \ninline int atomic_fetch_inc(_Inout_ int* _Dest) restrict(amp);\n\n \ninline unsigned int atomic_fetch_inc(_Inout_ unsigned int* _Dest) restrict(amp);\n```  \n  \n### Parameters  \n `_Dest`  \n The location in memory of the value to be incremented.  \n  \n### Return Value  \n The original value stored at the memory location.  \n  \n##  <a name=\"atomic_fetch_max\"></a>  atomic_fetch_max  \n Atomically computes the maximum value between the value stored at the memory location specified in the first argument and the value specified in the second argument, and stores it at the same memory location.  \n  \n```  \ninline int atomic_fetch_max(\n    _Inout_ int* _Dest,  \n    int value  \n    ) restrict(amp)\n\n \ninline unsigned int atomic_fetch_max(\n    _Inout_ unsigned int* _Dest,  \n    unsigned int value  \n    ) restrict(amp)\n```  \n  \n### Parameters  \n `_Dest`  \n The location from which one of the values to be compared is read, and to which the maximum of the two values is to be stored.  \n  \n `value`  \n The value to be compared to the value at the specified location.  \n  \n### Return Value  \n The original value stored at the specified location location.  \n  \n##  <a name=\"atomic_fetch_min\"></a>  atomic_fetch_min  \n Atomically computes the minimum value between the value stored at the memory location specified in the first argument and the value specified in the second argument, and stores it at the same memory location.  \n  \n```  \ninline int atomic_fetch_min(\n    _Inout_ int* _Dest,  \n    int value  \n    ) restrict(amp)\n\n \ninline unsigned int atomic_fetch_min(\n    _Inout_ unsigned int* _Dest,  \n    unsigned int value  \n    ) restrict(amp)\n```  \n  \n### Parameters  \n `_Dest`  \n The location from which one of the values to be compared is read, and to which the minimum of the two values is to be stored.  \n  \n `value`  \n The value to be compared to the value at the specified location.  \n  \n### Return Value  \n The original value stored at the specified location location.  \n  \n##  <a name=\"atomic_fetch_or\"></a>  atomic_fetch_or Function (C++ AMP)  \n Atomically performs a bitwise OR operation with a value and the value of a memory location.  \n  \n```  \ninline int atomic_fetch_or(\n    _Inout_ int* _Dest,  \n    int value  \n    ) restrict(amp)\n\n \ninline unsigned int atomic_fetch_or(\n    _Inout_ unsigned int* _Dest,  \n    unsigned int value  \n    ) restrict(amp)\n```  \n  \n### Parameters  \n `_Dest`  \n Pointer to the memory location.  \n  \n `value`  \n The value to use in the bitwise OR calculation.  \n  \n### Return Value  \n The original value of the memory location.  \n  \n##  <a name=\"atomic_fetch_sub\"></a>  atomic_fetch_sub Function (C++ AMP)  \n Atomically subtracts a value from a memory location.  \n  \n```  \ninline int atomic_fetch_sub(\n    _Inout_ int* _Dest,  \n    int value  \n    ) restrict(amp)\n\n \ninline unsigned int atomic_fetch_sub(\n    _Inout_ unsigned int* _Dest,  \n    unsigned int value  \n    ) restrict(amp)\n```  \n  \n### Parameters  \n `_Dest`  \n Pointer to the destionation location.  \n  \n `value`  \n The value to be subtracted.  \n  \n### Return Value  \n The original value of the memory location.  \n  \n##  <a name=\"atomic_fetch_xor\"></a>  atomic_fetch_xor Function (C++ AMP)  \n Atomically peforms an bitwise XOR operation of a value and a memory location.  \n  \n```  \ninline int atomic_fetch_xor(\n    _Inout_ int* _Dest,  \n    int value  \n    ) restrict(amp)\n\n \ninline unsigned int atomic_fetch_xor(\n    _Inout_ unsigned int* _Dest,  \n    unsigned int value  \n    ) restrict(amp)\n```  \n  \n### Parameters  \n `_Dest`  \n Pointer to the memory location.  \n  \n `value`  \n The value to use in the XOR calculation.  \n  \n### Return Value  \n The original value of the memory location.  \n  \n##  <a name=\"copy\"></a>  copy  \n Copies a C++ AMP object. All synchronous data transfer requirements are met. You can't copy data when running code on an accelerator. The general form of this function is `copy(src, dest)`.  \n  \n```  \ntemplate <typename value_type, int _Rank>  \nvoid copy(\n    const array<value_type, _Rank>& _Src,  \n    array<value_type, _Rank>& _Dest);\n\n \ntemplate <typename InputIterator, typename value_type, int _Rank>  \nvoid copy(\n    InputIterator _SrcFirst,\n    InputIterator _SrcLast,  \n    array<value_type, _Rank>& _Dest);\n\n \ntemplate <typename InputIterator, typename value_type, int _Rank>  \nvoid copy(\n    InputIterator _SrcFirst,  \n    array<value_type, _Rank>& _Dest);\n\n \ntemplate <typename OutputIterator, typename value_type, int _Rank>  \nvoid copy(\n    const array<value_type, _Rank>& _Src,\n     OutputIterator _DestIter);\n\n \ntemplate <typename value_type, int _Rank>  \nvoid copy(\n    const array<value_type, _Rank>& _Src,  \n    array_view<value_type, _Rank>& _Dest);\n\n \ntemplate <typename value_type, int _Rank>  \nvoid copy(\n    const array_view<const value_type, _Rank>& _Src,  \n    array<value_type, _Rank>& _Dest);\n\n \ntemplate <typename value_type, int _Rank>  \nvoid copy(\n    const array_view<value_type, _Rank>& _Src,  \n    array<value_type, _Rank>& _Dest);\n\n \ntemplate <typename value_type, int _Rank>  \nvoid copy(\n    const array_view<const value_type, _Rank>& _Src,  \n    array_view<value_type, _Rank>& _Dest);\n\n \ntemplate <typename value_type, int _Rank>  \nvoid copy(\n    const array_view<value_type, _Rank>& _Src,  \n    array_view<value_type, _Rank>& _Dest);\n\n \ntemplate <typename InputIterator, typename value_type, int _Rank>  \nvoid copy(\n    InputIterator _SrcFirst, \n    InputIterator _SrcLast,  \n    array_view<value_type, _Rank>& _Dest);\n\n \ntemplate <typename InputIterator, typename value_type, int _Rank>  \nvoid copy(\n    InputIterator _SrcFirst,  \n    array_view<value_type, _Rank>& _Dest);\n\n \ntemplate <typename OutputIterator, typename value_type, int _Rank>  \nvoid copy(\n    const array_view<value_type, _Rank>& _Src,\n    OutputIterator _DestIter);\n```  \n  \n### Parameters  \n `_Dest`  \n The object to copy to.  \n  \n `_DestIter`  \n An output iterator to the beginning position at destination.  \n  \n `InputIterator`  \n The type of the input interator.  \n  \n `OutputIterator`  \n The type of the output iterator.  \n  \n `_Rank`  \n The rank of the object to copy from or the object to copy to.  \n  \n `_Src`  \n To object to copy.  \n  \n `_SrcFirst`  \n A beginning iterator into the source container.  \n  \n `_SrcLast`  \n An ending iterator into the source container.  \n  \n `value_type`  \n The data type of the elements that are copied.  \n  \n##  <a name=\"copy_async\"></a>  copy_async  \n Copies a C++ AMP object and returns a [completion_future](completion-future-class.md) object that can be waited on. You can't copy data when running code on an accelerator.  The general form of this function is `copy(src, dest)`.  \n  \n```  \ntemplate <typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(\n    const array<value_type, _Rank>& _Src,  \n    array<value_type, _Rank>& _Dest);\n\n \ntemplate <typename InputIterator, typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(InputIterator _SrcFirst, InputIterator _SrcLast,  \n    array<value_type, _Rank>& _Dest);\n\n \ntemplate <typename InputIterator, typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(InputIterator _SrcFirst,  \n    array<value_type, _Rank>& _Dest);\n\n \ntemplate <typename OutputIterator, typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(\n    const array<value_type, _Rank>& _Src, OutputIterator _DestIter);\n\n \ntemplate <typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(\n    const array<value_type, _Rank>& _Src,  \n    array_view<value_type, _Rank>& _Dest);\n\n \ntemplate <typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(\n    const array_view<const value_type, _Rank>& _Src,  \n    array<value_type, _Rank>& _Dest);\n\n \ntemplate <typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(\n    const array_view<value_type, _Rank>& _Src,  \n    array<value_type, _Rank>& _Dest);\n\n \ntemplate <typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(\n    const array_view<const value_type, _Rank>& _Src,  \n    array_view<value_type, _Rank>& _Dest);\n\n \ntemplate <typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(\n    const array_view<value_type, _Rank>& _Src,  \n    array_view<value_type, _Rank>& _Dest);\n\n \ntemplate <typename InputIterator, typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(InputIterator _SrcFirst, InputIterator _SrcLast,  \n    array_view<value_type, _Rank>& _Dest);\n\n \ntemplate <typename InputIterator, typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(InputIterator _SrcFirst,  \n    array_view<value_type, _Rank>& _Dest);\n\n \ntemplate <typename OutputIterator, typename value_type, int _Rank>  \nconcurrency::completion_future copy_async(\n    const array_view<value_type, _Rank>& _Src, OutputIterator _DestIter);\n```  \n  \n### Parameters  \n `_Dest`  \n The object to copy to.  \n  \n `_DestIter`  \n An output iterator to the beginning position at destination.  \n  \n `InputIterator`  \n The type of the input interator.  \n  \n `OutputIterator`  \n The type of the output iterator.  \n  \n `_Rank`  \n The rank of the object to copy from or the object to copy to.  \n  \n `_Src`  \n To object to copy.  \n  \n `_SrcFirst`  \n A beginning iterator into the source container.  \n  \n `_SrcLast`  \n An ending iterator into the source container.  \n  \n `value_type`  \n The data type of the elements that are copied.  \n  \n### Return Value  \n A `future<void>` that can be waited on.  \n  \n##  <a name=\"direct3d_abort\"></a>  direct3d_abort  \n Aborts the execution of a function with the `restrict(amp)` restriction clause. When the AMP runtime detects the call, it raises a [runtime_exception](runtime-exception-class.md) exception with the error message \"Reference Rasterizer: Shader abort instruction hit\".  \n  \n```  \nvoid direct3d_abort() restrict(amp);\n```  \n  \n##  <a name=\"direct3d_errorf\"></a>  direct3d_errorf  \n Prints a formatted string to the Visual Studio output window. It is called from a function with the `restrict(amp)` restriction clause. When the AMP runtime detects the call, it raises a [runtime_exception](runtime-exception-class.md) exception with the same formatting string.  \n  \n```  \nvoid direct3d_errorf(\n    const char *,  \n ...) restrict(amp);\n```  \n  \n##  <a name=\"direct3d_printf\"></a>  direct3d_printf  \n Prints a formatted string to the Visual Studio output window. It is called from a function with the `restrict(amp)` restriction clause.  \n  \n```  \nvoid direct3d_printf(\n    const char *,  \n ...) restrict(amp);\n```  \n  \n##  <a name=\"global_memory_fence\"></a>  global_memory_fence  \n Blocks execution of all threads in a tile until all global memory accesses have been completed. This ensures that global memory accesses are visible to other threads in the thread tile, and are executed in program order.  \n  \n```  \ninline void global_memory_fence(const tile_barrier& _Barrier) restrict(amp);\n```  \n  \n### Parameters  \n `_Barrier`  \n A tile_barrier object  \n  \n##  <a name=\"parallel_for_each\"></a>  parallel_for_each Function (C++ AMP)  \n Runs a function across the compute domain. For more information, see [C++ AMP Overview](../../../parallel/amp/cpp-amp-overview.md).  \n  \n```  \ntemplate <int _Rank, typename _Kernel_type>  \nvoid parallel_for_each(\n    const extent<_Rank>& _Compute_domain,  \n    const _Kernel_type& _Kernel);\n\n \ntemplate <int _Dim0, int _Dim1, int _Dim2, typename _Kernel_type>  \nvoid parallel_for_each(\n    const tiled_extent<_Dim0, _Dim1, _Dim2>& _Compute_domain,\n     const _Kernel_type& _Kernel);\n\n \ntemplate <int _Dim0, int _Dim1, typename _Kernel_type>  \nvoid parallel_for_each(\n    const tiled_extent<_Dim0, _Dim1>& _Compute_domain,\n    const _Kernel_type& _Kernel);\n\n \ntemplate <int _Dim0, typename _Kernel_type>  \nvoid parallel_for_each(\n    const tiled_extent<_Dim0>& _Compute_domain,  \n    const _Kernel_type& _Kernel);\n\n \ntemplate <int _Rank, typename _Kernel_type>  \nvoid parallel_for_each(\n    const accelerator_view& _Accl_view,  \n    const extent<_Rank>& _Compute_domain,  \n    const _Kernel_type& _Kernel);\n\n \ntemplate <int _Dim0, int _Dim1, int _Dim2, typename _Kernel_type>  \nvoid parallel_for_each(\n    const accelerator_view& _Accl_view,  \n    const tiled_extent<_Dim0, _Dim1, _Dim2>& _Compute_domain,  \n    const _Kernel_type& _Kernel);\n\n \ntemplate <int _Dim0, int _Dim1, typename _Kernel_type>  \nvoid parallel_for_each(\n    const accelerator_view& _Accl_view,  \n    const tiled_extent<_Dim0, _Dim1>& _Compute_domain,  \n    const _Kernel_type& _Kernel);\n\n \ntemplate <int _Dim0, typename _Kernel_type>  \nvoid parallel_for_each(\n    const accelerator_view& _Accl_view,  \n    const tiled_extent<_Dim0>& _Compute_domain,  \n    const _Kernel_type& _Kernel);\n```  \n  \n### Parameters  \n `_Accl_view`  \n The `accelerator_view` object to run the parallel computation on.  \n  \n `_Compute_domain`  \n An `extent` object that contains the data for the computation.  \n  \n `_Dim0`  \n The dimension of the `tiled_extent` object.  \n  \n `_Dim1`  \n The dimension of the `tiled_extent` object.  \n  \n `_Dim2`  \n The dimension of the `tiled_extent` object.  \n  \n `_Kernel`  \n A lambda or function object that takes an argument of type \"index\\<_Rank>\" and performs the parallel computation.  \n  \n `_Kernel_type`  \n A lambda or functor.  \n  \n `_Rank`  \n The rank of the extent.  \n  \n##  <a name=\"tile_static_memory_fence\"></a>  tile_static_memory_fence  \n Blocks execution of all threads in a tile until all outstanding `tile_static` memory accesses have been completed. This ensures that `tile_static` memory accesses are visible to other threads in the thread tile, and that accesses are executed in program order.  \n  \n```  \ninline void tile_static_memory_fence(const tile_barrier& _Barrier) restrict(amp);\n```  \n  \n### Parameters  \n `_Barrier`  \n A tile_barrier object.  \n  \n## See Also  \n [Concurrency Namespace (C++ AMP)](concurrency-namespace-cpp-amp.md)\n"}