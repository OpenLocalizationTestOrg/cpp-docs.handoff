{"nodes":[{"pos":[12,45],"content":"References (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"References (C++) | Microsoft Docs","pos":[0,33]}]},{"content":"References (C++)","pos":[743,759]},{"content":"A reference, like a pointer, stores the address of an object that is located elsewhere in memory.","pos":[760,857]},{"content":"Unlike a pointer, a reference after it is initialized cannot be made to refer to a different object or set to null.","pos":[858,973]},{"content":"There are two kinds of references: lvalue references which refer to a named variable and rvalue references which refer to a <bpt id=\"p1\">[</bpt>temporary object<ept id=\"p1\">](../cpp/temporary-objects.md)</ept>.","pos":[974,1146],"source":" There are two kinds of references: lvalue references which refer to a named variable and rvalue references which refer to a [temporary object](../cpp/temporary-objects.md)."},{"content":"The &amp; operator signifies an lvalue reference and the &amp;&amp; operator signifies either an rvalue reference, or a universal reference (either rvalue or lvalue) depending on the context.","pos":[1147,1326],"source":" The & operator signifies an lvalue reference and the && operator signifies either an rvalue reference, or a universal reference (either rvalue or lvalue) depending on the context."},{"content":"References may be declared using the following syntax:","pos":[1333,1387]},{"content":"Any valid declarator specifying a reference may be used.","pos":[1514,1570]},{"content":"Unless the reference is a reference to function or array type, the following simplified syntax applies:","pos":[1571,1674]},{"content":"References are declared using the following sequence:","pos":[1813,1866]},{"content":"The declaration specifiers:","pos":[1876,1903]},{"content":"An optional storage class specifier.","pos":[1913,1949]},{"pos":[1959,2007],"content":"Optional <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and/or <ph id=\"ph1\">`volatile`</ph> qualifiers.","source":"Optional **const** and/or `volatile` qualifiers."},{"content":"The type specifier: the name of a type.","pos":[2017,2056]},{"content":"The declarator:","pos":[2069,2084]},{"content":"An optional Microsoft specific modifier.","pos":[2094,2134]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Microsoft-Specific Modifiers<ept id=\"p1\">](../cpp/microsoft-specific-modifiers.md)</ept>.","pos":[2135,2232],"source":" For more information, see [Microsoft-Specific Modifiers](../cpp/microsoft-specific-modifiers.md)."},{"content":"The &amp; operator or &amp;&amp; operator.","pos":[2242,2272],"source":"The & operator or && operator."},{"pos":[2282,2329],"content":"Optional <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and/or <ph id=\"ph1\">`volatile`</ph> qualifers.","source":"Optional **const** and/or `volatile` qualifers."},{"content":"The identifier.","pos":[2339,2354]},{"content":"An optional initializer.","pos":[2364,2388]},{"pos":[2395,2643],"content":"The more complex declarator forms for pointers to arrays and functions also apply to references to arrays and functions, see <bpt id=\"p1\">[</bpt>pointers<ept id=\"p1\">](../cpp/pointers-cpp.md)</ept> and <bpt id=\"p2\">[</bpt>declarators<ept id=\"p2\">](http://msdn.microsoft.com/en-us/8a7b9b51-92bd-4ac0-b3fe-0c4abe771838)</ept>.","source":"The more complex declarator forms for pointers to arrays and functions also apply to references to arrays and functions, see [pointers](../cpp/pointers-cpp.md) and [declarators](http://msdn.microsoft.com/en-us/8a7b9b51-92bd-4ac0-b3fe-0c4abe771838)."},{"content":"Multiple declarators and initializers may appear in a comma-separated list following a single declaration specifier.","pos":[2650,2766]},{"content":"For example:","pos":[2767,2779]},{"content":"References, pointers and objects may be declared together:","pos":[2827,2885]},{"content":"A reference holds the address of an object, but behaves syntactically like an object.","pos":[2929,3014]},{"pos":[3021,3173],"content":"In the following program, notice that the name of the object, <ph id=\"ph1\">`Today`</ph>, and the reference to the object, <ph id=\"ph2\">`TodayRef`</ph>, can be used identically in programs:","source":"In the following program, notice that the name of the object, `Today`, and the reference to the object, `TodayRef`, can be used identically in programs:"},{"content":"Example","pos":[3182,3189]},{"content":"Comment","pos":[3582,3589]},{"content":"Topics in this section:","pos":[3593,3616]},{"content":"Reference-Type Function Arguments","pos":[3627,3660]},{"content":"Reference-Type Function Returns","pos":[3717,3748]},{"content":"References to Pointers","pos":[3803,3825]}],"content":"---\ntitle: \"References (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"objects [C++], referencing\"\n  - \"references\"\n  - \"references, to pointers\"\n  - \"declarations, references\"\n  - \"references, declaring\"\n  - \"referencing objects, declarator syntax\"\nms.assetid: 68156f7f-97a0-4b66-b26d-b25ade5e3bd8\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# References (C++)\nA reference, like a pointer, stores the address of an object that is located elsewhere in memory. Unlike a pointer, a reference after it is initialized cannot be made to refer to a different object or set to null. There are two kinds of references: lvalue references which refer to a named variable and rvalue references which refer to a [temporary object](../cpp/temporary-objects.md). The & operator signifies an lvalue reference and the && operator signifies either an rvalue reference, or a universal reference (either rvalue or lvalue) depending on the context.  \n  \n References may be declared using the following syntax:  \n  \n```  \n[storage-class-specifiers] [cv-qualifiers] type-specifiers   \n[ms-modifier] declarator [= expression];  \n```  \n  \n Any valid declarator specifying a reference may be used. Unless the reference is a reference to function or array type, the following simplified syntax applies:  \n  \n```  \n[storage-class-specifiers] [cv-qualifiers] type-specifiers [& or &&]   \n[cv-qualifiers] identifier [= expression];  \n```  \n  \n References are declared using the following sequence:  \n  \n 1. The declaration specifiers:  \n  \n-   An optional storage class specifier.  \n  \n-   Optional **const** and/or `volatile` qualifiers.  \n  \n-   The type specifier: the name of a type.  \n  \n-   2. The declarator:  \n  \n-   An optional Microsoft specific modifier. For more information, see [Microsoft-Specific Modifiers](../cpp/microsoft-specific-modifiers.md).  \n  \n-   The & operator or && operator.  \n  \n-   Optional **const** and/or `volatile` qualifers.  \n  \n-   The identifier.  \n  \n 3. An optional initializer.  \n  \n The more complex declarator forms for pointers to arrays and functions also apply to references to arrays and functions, see [pointers](../cpp/pointers-cpp.md) and [declarators](http://msdn.microsoft.com/en-us/8a7b9b51-92bd-4ac0-b3fe-0c4abe771838).  \n  \n Multiple declarators and initializers may appear in a comma-separated list following a single declaration specifier. For example:  \n  \n```  \nint &i;   \nint &i, &j;   \n```  \n  \n References, pointers and objects may be declared together:  \n  \n```  \nint &ref, *ptr, k;   \n```  \n  \n A reference holds the address of an object, but behaves syntactically like an object.  \n  \n In the following program, notice that the name of the object, `Today`, and the reference to the object, `TodayRef`, can be used identically in programs:  \n  \n## Example  \n  \n```  \n// references.cpp  \n#include <stdio.h>  \nstruct S {  \n   short i;  \n};  \n  \nint main() {  \n   S  s;   // Declare the object.  \n   S& SRef = s;   // Declare the reference.  \n   s.i = 3;  \n  \n   printf_s(\"%d\\n\", s.i);  \n   printf_s(\"%d\\n\", SRef.i);  \n  \n   SRef.i = 4;  \n   printf_s(\"%d\\n\", s.i);  \n   printf_s(\"%d\\n\", SRef.i);  \n}  \n```  \n  \n```Output  \n3  \n3  \n4  \n4  \n```  \n  \n## Comment  \n Topics in this section:  \n  \n-   [Reference-Type Function Arguments](../cpp/reference-type-function-arguments.md)  \n  \n-   [Reference-Type Function Returns](../cpp/reference-type-function-returns.md)  \n  \n-   [References to Pointers](../cpp/references-to-pointers.md)  \n  \n"}