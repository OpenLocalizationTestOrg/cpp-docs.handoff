{"nodes":[{"pos":[12,66],"content":"C++ compiler conformance improvements | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"C++ compiler conformance improvements | Microsoft Docs","pos":[0,54]}]},{"pos":[534,565],"content":"C++ conformance improvements in"},{"content":"New language features","pos":[624,645]},{"content":"With support for generalized constexpr and NSDMI for aggregates, the compiler is now complete for features added in the C++14 Standard.","pos":[648,783]},{"content":"Note that the compiler still lacks a few features from the C++11 and C++98 Standards.","pos":[784,869]},{"content":"C++11:","pos":[875,881]},{"content":"<bpt id=\"p1\">**</bpt>Expression SFINAE support in more libraries<ept id=\"p1\">**</ept> The Visual C++ compiler continues to improve its support for expression SFINAE, which is required for template argument deduction and substitution where decltype and constexpr expressions may appear as template parameters.","pos":[882,1153],"source":"**Expression SFINAE support in more libraries** \nThe Visual C++ compiler continues to improve its support for expression SFINAE, which is required for template argument deduction and substitution where decltype and constexpr expressions may appear as template parameters."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Expression SFINAE improvements in Visual Studio 2017 RC<ept id=\"p1\">](https://blogs.msdn.microsoft.com/vcblog/2016/06/07/expression-sfinae-improvements-in-vs-2015-update-3)</ept>.","pos":[1154,1341],"source":" For more information, see [Expression SFINAE improvements in Visual Studio 2017 RC](https://blogs.msdn.microsoft.com/vcblog/2016/06/07/expression-sfinae-improvements-in-vs-2015-update-3)."},{"content":"C++ 14:","pos":[1349,1356]},{"content":"<bpt id=\"p1\">**</bpt>NSDMI for Aggregates<ept id=\"p1\">**</ept> An aggregate is an array or a class with no user-provided constructor, no private or protected non-static data members, no base classes, and no virtual functions.","pos":[1357,1544],"source":"**NSDMI for Aggregates**\nAn aggregate is an array or a class with no user-provided constructor, no private or protected non-static data members, no base classes, and no virtual functions."},{"content":"Beginning in C++14 aggregates may contain member initializers.","pos":[1545,1607]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Member initializers and aggregates<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3605.html)</ept>.","pos":[1608,1739],"source":" For more information, see [Member initializers and aggregates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3605.html)."},{"content":"<bpt id=\"p1\">**</bpt>Extended constexpr<ept id=\"p1\">**</ept> Expressions declared as constexpr are now allowed to contain certain kinds of declarations, if and switch statements, loop statements, and mutation of objects whose lifetime began within the constexpr expression evaluation.","pos":[1741,1987],"source":"**Extended constexpr**\nExpressions declared as constexpr are now allowed to contain certain kinds of declarations, if and switch statements, loop statements, and mutation of objects whose lifetime began within the constexpr expression evaluation."},{"content":"Also, there is no longer a requirement that a constexpr non-static member function be implicitly const.","pos":[1988,2091]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Relaxing constraints on constexpr functions<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html)</ept>.","pos":[2092,2232],"source":" For more information, see [Relaxing constraints on constexpr functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html)."},{"content":"C++17:","pos":[2239,2245]},{"content":"<bpt id=\"p1\">**</bpt>Terse static_assert<ept id=\"p1\">**</ept>  (available with /std:c++latest) In C++17 the message parameter for static_assert is optional.","pos":[2246,2364],"source":"**Terse static_assert**  (available with /std:c++latest)\nIn C++17 the message parameter for static_assert is optional."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Extending static_assert, v2<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3928.pdf)</ept>.","pos":[2365,2488],"source":" For more information, see [Extending static_assert, v2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3928.pdf)."},{"content":"<bpt id=\"p1\">**</bpt>[[fallthrough]] attribute<ept id=\"p1\">**</ept>  (available with /std:c++latest) The [[fallthrough]] attribute can be used in the context of switch statements as a hint to the compiler that the fall-through behavior is intended.","pos":[2491,2701],"source":"**[[fallthrough]] attribute**  (available with /std:c++latest)\nThe [[fallthrough]] attribute can be used in the context of switch statements as a hint to the compiler that the fall-through behavior is intended."},{"content":"This prevents the compiler from issuing warnings in such cases.","pos":[2702,2765]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Wording for [[fallthrough]] attribute<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r0.pdf)</ept>.","pos":[2766,2901],"source":" For more information, see [Wording for [[fallthrough]] attribute](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r0.pdf)."},{"content":"<bpt id=\"p1\">**</bpt>Generalized range-based for loops<ept id=\"p1\">**</ept> (no compiler switch required) Range-based for loops no longer require that begin() and end() return objects of the same type.","pos":[2904,3067],"source":"**Generalized range-based for loops** (no compiler switch required)\nRange-based for loops no longer require that begin() and end() return objects of the same type."},{"content":"This enables end() to return a sentinel object such as used by ranges as defined in the Ranges-V3 proposal.","pos":[3068,3175]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Generalizing the Range-Based For Loop<ept id=\"p1\">](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0184r0.html)</ept> and the <bpt id=\"p2\">[</bpt>range-v3 library on GitHub<ept id=\"p2\">](https://github.com/ericniebler/range-v3)</ept>.","pos":[3176,3390],"source":" For more information, see [Generalizing the Range-Based For Loop](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0184r0.html) and the [range-v3 library on GitHub](https://github.com/ericniebler/range-v3)."},{"pos":[3394,3587],"content":"For the complete list of conformance improvements up through Visual Studio 2015, Update 3, see <bpt id=\"p1\">[</bpt>Visual C++ What's New 2003 through 2015<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/mt723604.aspx)</ept>.","source":"For the complete list of conformance improvements up through Visual Studio 2015, Update 3, see [Visual C++ What's New 2003 through 2015](https://msdn.microsoft.com/en-us/library/mt723604.aspx)."},{"content":"Bug fixes","pos":[3592,3601]},{"content":"Copy-list-initialization","pos":[3606,3630]},{"content":"Visual Studio 2017 correctly raises compiler errors related to object creation using initializer lists that were not caught in Visual Studio 2015 and could lead to crashes or undefined runtime behavior.","pos":[3631,3833]},{"content":"As per N4594 13.3.1.7p1, in copy-list-initialization, the compiler is required to consider an explicit constructor for overload resolution, but must raise an error if that overload is actually chosen.","pos":[3835,4035]},{"content":"The following two examples compile in Visual Studio 2015 but not in Visual Studio 2017.","pos":[4038,4125]},{"content":"To correct the error, use direct initialization:","pos":[4408,4456]},{"content":"In Visual Studio 2015, the compiler erroneously treated copy-list-initialization in the same way as regular copy-initialization; it considered only converting constructors for overload resolution.","pos":[4498,4694]},{"content":"In the following example, Visual Studio 2015 chooses MyInt(23) but Visual Studio 2017 correctly raises the error.","pos":[4695,4808]},{"content":"This example is similar to the previous one but raises a different error.","pos":[5251,5324]},{"content":"It succeeds in Visual Studio 2015 and fails in Visual Studio 2017 with C2668.","pos":[5325,5402]},{"content":"Deprecated typedefs","pos":[5617,5636]},{"content":"Visual Studio 2017 now issues the correct warning for deprecated typedefs that are declared in a class or struct.","pos":[5637,5750]},{"content":"The following example compiles without warnings in Visual Studio 2015 but produces C4996 in Visual Studio 2017.","pos":[5751,5862]},{"content":"constexpr","pos":[6060,6069]},{"content":"Visual Studio 2017 correctly raises an error when the left-hand operand of a conditionally evaluating operation is not valid in a constexpr context.","pos":[6070,6218]},{"content":"The following code compiles in Visual Studio 2015 but not in Visual Studio 2017:","pos":[6219,6299]},{"content":"To correct the error, either declare the array::size() function as constexpr or remove the constexpr qualifier from f.","pos":[6522,6640]},{"content":"Class types passed to variadic functions","pos":[6647,6687]},{"content":"In Visual Studio 2017, classes or structs that are passed to a variadic function such as printf must be trivially copyable.","pos":[6688,6811]},{"content":"When passing such objects, the compiler simply makes a bitwise copy and does not call the constructor or destructor.","pos":[6812,6928]},{"content":"To correct the error, you can call a member function that returns a trivially copyable type,","pos":[7827,7919]},{"content":"or else perform a static cast to convert the object before passing it:","pos":[7990,8060]},{"content":"For strings built and managed using CStringW, the provided ‘operator LPCWSTR()’ should be used to cast a CStringW object to the C pointer expected by the format string.","pos":[8149,8317]},{"content":"cv-qualifiers in class construction","pos":[8410,8445]},{"content":"In Visual Studio 2015, the compiler sometimes incorrectly ignores the cv-qualifier when generating a class object via a constructor call.","pos":[8446,8583]},{"content":"This can potentially cause a crash or unexpected runtime behavior.","pos":[8584,8650]},{"content":"The following example compiles in Visual Studio 2015 but raises a compiler error in Visual Studio 2017:","pos":[8651,8754]},{"content":"To correct the error, declare operator int() as const.","pos":[8850,8904]},{"content":"Access checking on qualified names in templates","pos":[8911,8958]},{"content":"Previous versions of the compiler did not perform access checking on qualified names in some template contexts.","pos":[8959,9070]},{"content":"This can interfere with expected SFINAE behavior where the substitution is expected to fail due to the inaccessibility of a name.","pos":[9071,9200]},{"content":"This could have potentially caused a crash or unexpected behavior at runtime due to the compiler incorrectly calling the wrong overload of the operator.","pos":[9201,9353]},{"content":"In Visual Studio 2017, a compiler error is raised.","pos":[9354,9404]},{"content":"The specific error might vary but typically it is \"C2672 no matching overloaded function found\".","pos":[9405,9501]},{"content":"The following code compiles in Visual Studio 2015 but raises an error in Visual Studio 2017:","pos":[9502,9594]},{"content":"Missing template argument lists","pos":[9884,9915]},{"content":"In Visual Studio 2015 and earlier, the compiler did not diagnose missing template argument lists when the template appeared in a template parameter list (for example as part of a default template argument or a non-type template parameter).","pos":[9916,10155]},{"content":"This can result in unpredictable behavior, including compiler crashes or unexpected runtime behavior.","pos":[10156,10257]},{"content":"The following code compiles in Visual Studio 2015 but produces an error in Visual Studio 2017.","pos":[10258,10352]},{"content":"Expression-SFINAE","pos":[10729,10746]},{"content":"To support expression-SFINAE, the compiler now parses decltype arguments when the templates are declared rather than instantiated.","pos":[10747,10877]},{"content":"Consequently, if a non-dependent specialization is found in the decltype argument, it will not be deferred to instantiation-time and will be processed immediately and any resulting errors will be diagnosed at that time.","pos":[10878,11097]},{"content":"The following example shows such a compiler error that is raised at the point of declaration:","pos":[11101,11194]},{"content":"Default initializers for value class members (C++/CLI)","pos":[11798,11852]},{"content":"In Visual Studio 2015 and earlier, the compiler permitted (but ignored) a default member initializer for a member of a value class.","pos":[11853,11984]},{"content":"Default initialization of a value class always zero-initializes the members; a default constructor is not permitted.","pos":[11986,12102]},{"content":"In Visual Studio 2017, default member initializers raise a compiler error, as shown in this example:","pos":[12104,12204]},{"content":"Default Indexers (C++/CLI)","pos":[12381,12407]},{"content":"In Visual Studio 2015 and earlier, the compiler in some cases misidentified a default property as a default indexer.","pos":[12408,12524]},{"content":"It was possible to work around the issue by using the identifier \"default\" to access the property.","pos":[12525,12623]},{"content":"The workaround itself became problematic after default was introduced as a keyword in C++11.","pos":[12624,12716]},{"content":"Therefore, in Visual Studio 2017 the bugs that required the workaround were fixed, and the compiler now raises an error when \"default\" is used to access the default property for a class.","pos":[12717,12903]},{"content":"In Visual Studio 2017, you can access both Value properties by their name:","pos":[13597,13671]}],"content":"---\ntitle: \"C++ compiler conformance improvements | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/16/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n    - \"vs-ide-general\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 8801dbdb-ca0b-491f-9e33-01618bff5ae9\nauthor: \"BrianPeek\"\nms.author: \"brpeek\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n    - \"cs-cz\"\n    - \"de-de\"\n    - \"es-es\"\n    - \"fr-fr\"\n    - \"it-it\"\n    - \"ja-jp\"\n    - \"ko-kr\"\n    - \"pl-pl\"\n    - \"pt-br\"\n    - \"ru-ru\"\n    - \"tr-tr\"\n    - \"zh-cn\"\n    - \"zh-tw\"\n---\n  \n# C++ conformance improvements in [!INCLUDE[vs_dev15_md](misc/includes/vs_dev15_md.md)]\n\n## New language features  \nWith support for generalized constexpr and NSDMI for aggregates, the compiler is now complete for features added in the C++14 Standard. Note that the compiler still lacks a few features from the C++11 and C++98 Standards.\n\n### C++11:\n**Expression SFINAE support in more libraries** \nThe Visual C++ compiler continues to improve its support for expression SFINAE, which is required for template argument deduction and substitution where decltype and constexpr expressions may appear as template parameters. For more information, see [Expression SFINAE improvements in Visual Studio 2017 RC](https://blogs.msdn.microsoft.com/vcblog/2016/06/07/expression-sfinae-improvements-in-vs-2015-update-3). \n\n\n### C++ 14:\n**NSDMI for Aggregates**\nAn aggregate is an array or a class with no user-provided constructor, no private or protected non-static data members, no base classes, and no virtual functions. Beginning in C++14 aggregates may contain member initializers. For more information, see [Member initializers and aggregates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3605.html).\n\n**Extended constexpr**\nExpressions declared as constexpr are now allowed to contain certain kinds of declarations, if and switch statements, loop statements, and mutation of objects whose lifetime began within the constexpr expression evaluation. Also, there is no longer a requirement that a constexpr non-static member function be implicitly const. For more information, see [Relaxing constraints on constexpr functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html). \n\n### C++17:\n**Terse static_assert**  (available with /std:c++latest)\nIn C++17 the message parameter for static_assert is optional. For more information, see [Extending static_assert, v2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3928.pdf). \n\n**[[fallthrough]] attribute**  (available with /std:c++latest)\nThe [[fallthrough]] attribute can be used in the context of switch statements as a hint to the compiler that the fall-through behavior is intended. This prevents the compiler from issuing warnings in such cases. For more information, see [Wording for [[fallthrough]] attribute](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r0.pdf). \n\n**Generalized range-based for loops** (no compiler switch required)\nRange-based for loops no longer require that begin() and end() return objects of the same type. This enables end() to return a sentinel object such as used by ranges as defined in the Ranges-V3 proposal. For more information, see [Generalizing the Range-Based For Loop](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0184r0.html) and the [range-v3 library on GitHub](https://github.com/ericniebler/range-v3). \n\n\nFor the complete list of conformance improvements up through Visual Studio 2015, Update 3, see [Visual C++ What's New 2003 through 2015](https://msdn.microsoft.com/en-us/library/mt723604.aspx).\n\n## Bug fixes\n### Copy-list-initialization\nVisual Studio 2017 correctly raises compiler errors related to object creation using initializer lists that were not caught in Visual Studio 2015 and could lead to crashes or undefined runtime behavior.  As per N4594 13.3.1.7p1, in copy-list-initialization, the compiler is required to consider an explicit constructor for overload resolution, but must raise an error if that overload is actually chosen. \n\nThe following two examples compile in Visual Studio 2015 but not in Visual Studio 2017.\n```cpp\nstruct A\n{\n    explicit A(int) {} \n    A(double) {}\n};\n\nint main()\n{\n    A a1 = { 1 }; // error C3445: copy-list-initialization of 'A' cannot use an explicit constructor\n    const A& a2 = { 1 }; // error C2440: 'initializing': cannot convert from 'int' to 'const A &'\n\n}\n```\nTo correct the error, use direct initialization:\n```cpp\nA a1{ 1 };\nconst A& a2{ 1 };\n```\n\nIn Visual Studio 2015, the compiler erroneously treated copy-list-initialization in the same way as regular copy-initialization; it considered only converting constructors for overload resolution. In the following example, Visual Studio 2015 chooses MyInt(23) but Visual Studio 2017 correctly raises the error. \n\n```cpp\n// From http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1228\nstruct MyList {\n       explicit MyStore(int initialCapacity);\n};\n\nstruct MyInt {\n       MyInt(int i);\n};\n\nstruct Printer {\n       void operator()(MyStore const& s);\n       void operator()(MyInt const& i);\n};\n\nvoid f() {\n       Printer p;\n       p({ 23 }); // C3066: there are multiple ways that an object of this type can be called with these arguments\n}\n```\n\nThis example is similar to the previous one but raises a different error. It succeeds in Visual Studio 2015 and fails in Visual Studio 2017 with C2668. \n\n```cpp\nstruct A {\n    explicit A(int) {}\n};\n\nstruct B {\n    B(int) {}\n};\n\nvoid f(const A&) {}\nvoid f(const B&) {}\n\nint main()\n{\n    f({ 1 }); // error C2668: 'f': ambiguous call to overloaded function\n}\n```\n\n### Deprecated typedefs\nVisual Studio 2017 now issues the correct warning for deprecated typedefs that are declared in a class or struct. The following example compiles without warnings in Visual Studio 2015 but produces C4996 in Visual Studio 2017.\n\n```cpp\nstruct A \n{\n    // also for __declspec(deprecated) \n    [[deprecated]] typedef int inttype;\n};\n\nint main()\n{\n    A::inttype a = 0; // C4996 'A::inttype': was declared deprecated\n}\n```\n\n### constexpr\nVisual Studio 2017 correctly raises an error when the left-hand operand of a conditionally evaluating operation is not valid in a constexpr context. The following code compiles in Visual Studio 2015 but not in Visual Studio 2017:\n\n```cpp  \ntemplate<int N>\nstruct array \n{\n       int size() const { return N; }\n};\n\nconstexpr bool f(const array<1> &arr)\n{\n       return arr.size() == 10 || arr.size() == 11; // error starting in Visual Studio 2017\n}\n```\nTo correct the error, either declare the array::size() function as constexpr or remove the constexpr qualifier from f. \n\n### Class types passed to variadic functions\nIn Visual Studio 2017, classes or structs that are passed to a variadic function such as printf must be trivially copyable. When passing such objects, the compiler simply makes a bitwise copy and does not call the constructor or destructor. \n\n```cpp\n#include <atomic>\n#include <memory>\n#include <stdio.h>\n\nint main()\n{\n    std::atomic<int> i(0);\n    printf(\"%i\\n\", i); // error C4839: non-standard use of class 'std::atomic<int>'\n                        // as an argument to a variadic function\n                        // note: the constructor and destructor will not be called; \n                        // a bitwise copy of the class will be passed as the argument\n                        // error C2280: 'std::atomic<int>::atomic(const std::atomic<int> &)':\n                        // attempting to reference a deleted function\n\n    struct S {\n        S(int i) : i(i) {}\n        S(const S& other) : i(other.i) {}\n        operator int() { return i; }\n    private:\n        int i;\n    } s(0);\n    printf(\"%i\\n\", s); // warning C4840 : non-portable use of class 'main::S'\n                      // as an argument to a variadic function\n}\n```\nTo correct the error, you can call a member function that returns a trivially copyable type, \n\n```cpp\n    std::atomic<int> i(0);\n    printf(\"%i\\n\", i.load());\n```\nor else perform a static cast to convert the object before passing it:\n```cpp\n    struct S {/* as before */} s(0);\n    printf(\"%i\\n\", static_cast<int>(s))\n```\nFor strings built and managed using CStringW, the provided ‘operator LPCWSTR()’ should be used to cast a CStringW object to the C pointer expected by the format string.\n\n```cpp\nCStringW str1;\nCStringW str2;\nstr1.Format(… , static_cast<LPCWSTR>(str2));\n```\n\n### cv-qualifiers in class construction\nIn Visual Studio 2015, the compiler sometimes incorrectly ignores the cv-qualifier when generating a class object via a constructor call. This can potentially cause a crash or unexpected runtime behavior. The following example compiles in Visual Studio 2015 but raises a compiler error in Visual Studio 2017:\n\n```cpp\nstruct S \n{\n    S(int);\n    operator int();\n};\n\nint i = (const S)0; // error C2440\n```\nTo correct the error, declare operator int() as const. \n\n### Access checking on qualified names in templates\nPrevious versions of the compiler did not perform access checking on qualified names in some template contexts. This can interfere with expected SFINAE behavior where the substitution is expected to fail due to the inaccessibility of a name. This could have potentially caused a crash or unexpected behavior at runtime due to the compiler incorrectly calling the wrong overload of the operator. In Visual Studio 2017, a compiler error is raised. The specific error might vary but typically it is \"C2672 no matching overloaded function found\". The following code compiles in Visual Studio 2015 but raises an error in Visual Studio 2017:\n\n```cpp\n#include <type_traits>\n\ntemplate <class T> class S {\n       typedef typename T type;\n};\n\ntemplate <class T, std::enable_if<std::is_integral<typename S<T>::type>::value, T> * = 0>\nbool f(T x);\n\nint main()\n{\n       f(10); // C2672: No matching overloaded function found. \n}\n```\n\n### Missing template argument lists\nIn Visual Studio 2015 and earlier, the compiler did not diagnose missing template argument lists when the template appeared in a template parameter list (for example as part of a default template argument or a non-type template parameter). This can result in unpredictable behavior, including compiler crashes or unexpected runtime behavior. The following code compiles in Visual Studio 2015 but produces an error in Visual Studio 2017.\n\n```cpp\ntemplate <class T> class ListNode;\ntemplate <class T> using ListNodeMember = ListNode<T> T::*;\ntemplate <class T, ListNodeMember M> class ListHead; // C2955: 'ListNodeMember': use of alias \n                                                     // template requires template argument list\n\n// correct:  template <class T, ListNodeMember<T> M> class ListHead;  \n```\n\n### Expression-SFINAE\nTo support expression-SFINAE, the compiler now parses decltype arguments when the templates are declared rather than instantiated. Consequently, if a non-dependent specialization is found in the decltype argument, it will not be deferred to instantiation-time and will be processed immediately and any resulting errors will be diagnosed at that time.  \n\nThe following example shows such a compiler error that is raised at the point of declaration:\n\n```cpp\n#include <utility>\ntemplate <class T, class ReturnT, class... ArgsT> class IsCallable\n{\npublic:\n       struct BadType {};\n       template <class U>\n       static decltype(std::declval<T>()(std::declval<ArgsT>()...)) Test(int); //C2064. Should be declval<U>\n       template <class U>\n       static BadType Test(...);\n       static constexpr bool value = std::is_convertible<decltype(Test<T>(0)), ReturnT>::value;\n};\n\nconstexpr bool test1 = IsCallable<int(), int>::value;\nstatic_assert(test1, \"PASS1\");\nconstexpr bool test2 = !IsCallable<int*, int>::value;\nstatic_assert(test2, \"PASS2\");\n```\n\n### Default initializers for value class members (C++/CLI)\nIn Visual Studio 2015 and earlier, the compiler permitted (but ignored) a default member initializer for a member of a value class.  Default initialization of a value class always zero-initializes the members; a default constructor is not permitted.  In Visual Studio 2017, default member initializers raise a compiler error, as shown in this example:\n\n```cpp\nvalue struct V\n{\n       int i = 0; // error C3446: 'V::i': a default member initializer  \n                  // is not allowed for a member of a value class\n};\n```\n\n### Default Indexers (C++/CLI)\nIn Visual Studio 2015 and earlier, the compiler in some cases misidentified a default property as a default indexer. It was possible to work around the issue by using the identifier \"default\" to access the property. The workaround itself became problematic after default was introduced as a keyword in C++11. Therefore, in Visual Studio 2017 the bugs that required the workaround were fixed, and the compiler now raises an error when \"default\" is used to access the default property for a class.\n\n```cpp\n//class1.cs\n\nusing System.Reflection;\nusing System.Runtime.InteropServices;\n\nnamespace ClassLibrary1\n{\n    [DefaultMember(\"Value\")]\n    public class Class1\n    {\n        public int Value\n        {\n            // using attribute on the return type triggers the compiler bug\n            [return: MarshalAs(UnmanagedType.I4)]\n            get;\n        }\n    }\n    [DefaultMember(\"Value\")]\n    public class Class2\n    {\n        public int Value\n        {\n            get;\n        }\n    }\n}\n\n \n// code.cpp\n#using \"class1.dll\"\n\nvoid f(ClassLibrary1::Class1 ^r1, ClassLibrary1::Class2 ^r2)\n{\n       r1->Value; // error\n       r1->default;\n       r2->Value;\n       r2->default; // error\n}\n```\n\nIn Visual Studio 2017, you can access both Value properties by their name:\n\n```cpp\n#using \"class1.dll\"\n\nvoid f(ClassLibrary1::Class1 ^r1, ClassLibrary1::Class2 ^r2)\n{\n       r1->Value;\n       r2->Value;\n}\n```\n\n\n"}