{"nodes":[{"pos":[12,51],"content":"CComObjectRootEx Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CComObjectRootEx Class | Microsoft Docs","pos":[0,39]}]},{"content":"CComObjectRootEx Class","pos":[754,776]},{"content":"This class provides methods to handle object reference count management for both nonaggregated and aggregated objects.","pos":[777,895]},{"content":"Syntax","pos":[904,910]},{"content":"Parameters","pos":[1014,1024]},{"content":"The class whose methods implement the desired threading model.","pos":[1045,1107]},{"content":"You can explicitly choose the threading model by setting <ph id=\"ph1\">`ThreadModel`</ph> to <bpt id=\"p1\">[</bpt>CComSingleThreadModel<ept id=\"p1\">](../../atl/reference/ccomsinglethreadmodel-class.md)</ept>, <bpt id=\"p2\">[</bpt>CComMultiThreadModel<ept id=\"p2\">](../../atl/reference/ccommultithreadmodel-class.md)</ept>, or <bpt id=\"p3\">[</bpt>CComMultiThreadModelNoCS<ept id=\"p3\">](../../atl/reference/ccommultithreadmodelnocs-class.md)</ept>.","pos":[1108,1419],"source":" You can explicitly choose the threading model by setting `ThreadModel` to [CComSingleThreadModel](../../atl/reference/ccomsinglethreadmodel-class.md), [CComMultiThreadModel](../../atl/reference/ccommultithreadmodel-class.md), or [CComMultiThreadModelNoCS](../../atl/reference/ccommultithreadmodelnocs-class.md)."},{"content":"You can accept the server's default thread model by setting <ph id=\"ph1\">`ThreadModel`</ph> to <bpt id=\"p1\">[</bpt>CComObjectThreadModel<ept id=\"p1\">](atl-typedefs.md#ccomobjectthreadmodel)</ept> or <bpt id=\"p2\">[</bpt>CComGlobalsThreadModel<ept id=\"p2\">](atl-typedefs.md#ccomglobalsthreadmodel)</ept>.","pos":[1420,1628],"source":" You can accept the server's default thread model by setting `ThreadModel` to [CComObjectThreadModel](atl-typedefs.md#ccomobjectthreadmodel) or [CComGlobalsThreadModel](atl-typedefs.md#ccomglobalsthreadmodel)."},{"content":"Members","pos":[1638,1645]},{"content":"Methods","pos":[1655,1662]},{"content":"CComObjectRootEx","pos":[1684,1700]},{"content":"Constructor.","pos":[1739,1751]},{"content":"InternalAddRef","pos":[1757,1771]},{"content":"Increments the reference count for a nonaggregated object.","pos":[1808,1866]},{"content":"InternalRelease","pos":[1872,1887]},{"content":"Decrements the reference count for a nonaggregated object.","pos":[1925,1983]},{"content":"Lock","pos":[1989,1993]},{"content":"If the thread model is multithreaded, obtains ownership of a critical section object.","pos":[2020,2105]},{"content":"Unlock","pos":[2111,2117]},{"content":"If the thread model is multithreaded, releases ownership of a critical section object.","pos":[2146,2232]},{"content":"CComObjectRootBase Methods","pos":[2243,2269]},{"content":"FinalConstruct","pos":[2291,2305]},{"content":"Override in your class to perform any initialization required by your object.","pos":[2342,2419]},{"content":"FinalRelease","pos":[2425,2437]},{"content":"Override in your class to perform any cleanup required by your object.","pos":[2472,2542]},{"content":"OuterAddRef","pos":[2548,2559]},{"content":"Increments the reference count for an aggregated object.","pos":[2593,2649]},{"content":"OuterQueryInterface","pos":[2655,2674]},{"pos":[2716,2776],"content":"Delegates to the outer <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> of an aggregated object.","source":"Delegates to the outer **IUnknown** of an aggregated object."},{"content":"OuterRelease","pos":[2782,2794]},{"content":"Decrements the reference count for an aggregated object.","pos":[2829,2885]},{"content":"Static Functions","pos":[2896,2912]},{"content":"InternalQueryInterface","pos":[2934,2956]},{"pos":[3001,3057],"content":"Delegates to the <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> of a nonaggregated object.","source":"Delegates to the **IUnknown** of a nonaggregated object."},{"content":"ObjectMain","pos":[3063,3073]},{"content":"Called during module initialization and termination for derived classes listed in the object map.","pos":[3106,3203]},{"content":"Data Members","pos":[3214,3226]},{"content":"m_dwRef","pos":[3248,3255]},{"content":"With <ph id=\"ph1\">`m_pOuterUnknown`</ph>, part of a union.","pos":[3285,3325],"source":"With `m_pOuterUnknown`, part of a union."},{"content":"Used when the object is not aggregated to hold the reference count of <ph id=\"ph1\">`AddRef`</ph> and <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept>.","pos":[3326,3421],"source":" Used when the object is not aggregated to hold the reference count of `AddRef` and **Release**."},{"content":"m_pOuterUnknown","pos":[3427,3442]},{"content":"With <ph id=\"ph1\">`m_dwRef`</ph>, part of a union.","pos":[3480,3512],"source":"With `m_dwRef`, part of a union."},{"content":"Used when the object is aggregated to hold a pointer to the outer unknown.","pos":[3513,3587]},{"content":"Remarks","pos":[3597,3604]},{"content":"handles object reference count management for both nonaggregated and aggregated objects.","pos":[3627,3715]},{"content":"It holds the object reference count if your object is not being aggregated, and holds the pointer to the outer unknown if your object is being aggregated.","pos":[3716,3870]},{"content":"For aggregated objects, <ph id=\"ph1\">`CComObjectRootEx`</ph> methods can be used to handle the failure of the inner object to construct, and to protect the outer object from deletion when inner interfaces are released or the inner object is deleted.","pos":[3871,4102],"source":" For aggregated objects, `CComObjectRootEx` methods can be used to handle the failure of the inner object to construct, and to protect the outer object from deletion when inner interfaces are released or the inner object is deleted."},{"pos":[4109,4248],"content":"A class that implements a COM server must inherit from <ph id=\"ph1\">`CComObjectRootEx`</ph> or <bpt id=\"p1\">[</bpt>CComObjectRoot<ept id=\"p1\">](../../atl/reference/ccomobjectroot-class.md)</ept>.","source":"A class that implements a COM server must inherit from `CComObjectRootEx` or [CComObjectRoot](../../atl/reference/ccomobjectroot-class.md)."},{"content":"If your class definition specifies the <bpt id=\"p1\">[</bpt>DECLARE_POLY_AGGREGATABLE<ept id=\"p1\">](http://msdn.microsoft.com/library/7569e738-cfbc-4404-ba1d-78dcefa3bdb3)</ept> macro, ATL creates an instance of <bpt id=\"p2\">**</bpt>CComPolyObject<ph id=\"ph1\">\\&lt;</ph>CYourClass&gt;<ept id=\"p2\">**</ept> when <bpt id=\"p3\">**</bpt>IClassFactory::CreateInstance<ept id=\"p3\">**</ept> is called.","pos":[4255,4509],"source":"If your class definition specifies the [DECLARE_POLY_AGGREGATABLE](http://msdn.microsoft.com/library/7569e738-cfbc-4404-ba1d-78dcefa3bdb3) macro, ATL creates an instance of **CComPolyObject\\<CYourClass>** when **IClassFactory::CreateInstance** is called."},{"content":"During creation, the value of the outer unknown is checked.","pos":[4510,4569]},{"content":"If it is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>IUnknown<ept id=\"p2\">**</ept> is implemented for a nonaggregated object.","pos":[4570,4644],"source":" If it is **NULL**, **IUnknown** is implemented for a nonaggregated object."},{"content":"If the outer unknown is not <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>IUnknown<ept id=\"p2\">**</ept> is implemented for an aggregated object.","pos":[4645,4736],"source":" If the outer unknown is not **NULL**, **IUnknown** is implemented for an aggregated object."},{"pos":[4743,4966],"content":"If your class does not specify the <ph id=\"ph1\">`DECLARE_POLY_AGGREGATABLE`</ph> macro, ATL creates an instance of <bpt id=\"p1\">**</bpt>CAggComObject<ph id=\"ph2\">\\&lt;</ph>CYourClass&gt;<ept id=\"p1\">**</ept> for aggregated objects or an instance of <bpt id=\"p2\">**</bpt>CComObject<ph id=\"ph3\">\\&lt;</ph>CYourClass&gt;<ept id=\"p2\">**</ept> for nonaggregated objects.","source":"If your class does not specify the `DECLARE_POLY_AGGREGATABLE` macro, ATL creates an instance of **CAggComObject\\<CYourClass>** for aggregated objects or an instance of **CComObject\\<CYourClass>** for nonaggregated objects."},{"content":"The advantage of using <ph id=\"ph1\">`CComPolyObject`</ph> is that you avoid having both <ph id=\"ph2\">`CComAggObject`</ph> and <ph id=\"ph3\">`CComObject`</ph> in your module to handle the aggregated and nonaggregated cases.","pos":[4973,5140],"source":"The advantage of using `CComPolyObject` is that you avoid having both `CComAggObject` and `CComObject` in your module to handle the aggregated and nonaggregated cases."},{"content":"A single <ph id=\"ph1\">`CComPolyObject`</ph> object handles both cases.","pos":[5141,5193],"source":" A single `CComPolyObject` object handles both cases."},{"content":"Therefore, only one copy of the vtable and one copy of the functions exist in your module.","pos":[5194,5284]},{"content":"If your vtable is large, this can substantially decrease your module size.","pos":[5285,5359]},{"content":"However, if your vtable is small, using <ph id=\"ph1\">`CComPolyObject`</ph> can result in a slightly larger module size because it is not optimized for an aggregated or nonaggregated object, as are <ph id=\"ph2\">`CComAggObject`</ph> and <ph id=\"ph3\">`CComObject`</ph>.","pos":[5360,5572],"source":" However, if your vtable is small, using `CComPolyObject` can result in a slightly larger module size because it is not optimized for an aggregated or nonaggregated object, as are `CComAggObject` and `CComObject`."},{"content":"If your object is aggregated, <bpt id=\"p1\">[</bpt>IUnknown<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> is implemented by <ph id=\"ph1\">`CComAggObject`</ph> or <ph id=\"ph2\">`CComPolyObject`</ph>.","pos":[5579,5734],"source":"If your object is aggregated, [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) is implemented by `CComAggObject` or `CComPolyObject`."},{"content":"These classes delegate <ph id=\"ph1\">`QueryInterface`</ph>, <ph id=\"ph2\">`AddRef`</ph>, and <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept> calls to <ph id=\"ph3\">`CComObjectRootEx`</ph>'s <ph id=\"ph4\">`OuterQueryInterface`</ph>, <ph id=\"ph5\">`OuterAddRef`</ph>, and <ph id=\"ph6\">`OuterRelease`</ph> to forward to the outer unknown.","pos":[5735,5921],"source":" These classes delegate `QueryInterface`, `AddRef`, and **Release** calls to `CComObjectRootEx`'s `OuterQueryInterface`, `OuterAddRef`, and `OuterRelease` to forward to the outer unknown."},{"content":"Typically, you override <ph id=\"ph1\">`CComObjectRootEx::FinalConstruct`</ph> in your class to create any aggregated objects, and override <ph id=\"ph2\">`CComObjectRootEx::FinalRelease`</ph> to free any aggregated objects.","pos":[5922,6106],"source":" Typically, you override `CComObjectRootEx::FinalConstruct` in your class to create any aggregated objects, and override `CComObjectRootEx::FinalRelease` to free any aggregated objects."},{"content":"If your object is not aggregated, <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> is implemented by <ph id=\"ph1\">`CComObject`</ph> or <ph id=\"ph2\">`CComPolyObject`</ph>.","pos":[6113,6211],"source":"If your object is not aggregated, **IUnknown** is implemented by `CComObject` or `CComPolyObject`."},{"content":"In this case, calls to <ph id=\"ph1\">`QueryInterface`</ph>, <ph id=\"ph2\">`AddRef`</ph>, and <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept> are delegated to <ph id=\"ph3\">`CComObjectRootEx`</ph>'s <ph id=\"ph4\">`InternalQueryInterface`</ph>, <ph id=\"ph5\">`InternalAddRef`</ph>, and <ph id=\"ph6\">`InternalRelease`</ph> to perform the actual operations.","pos":[6212,6416],"source":" In this case, calls to `QueryInterface`, `AddRef`, and **Release** are delegated to `CComObjectRootEx`'s `InternalQueryInterface`, `InternalAddRef`, and `InternalRelease` to perform the actual operations."},{"content":"Requirements","pos":[6425,6437]},{"pos":[6441,6461],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> atlcom.h","source":"**Header:** atlcom.h"},{"pos":[6522,6556],"content":"CComObjectRootEx::CComObjectRootEx"},{"content":"The constructor initializes the reference count to 0.","pos":[6560,6613]},{"pos":[6705,6737],"content":"CComObjectRootEx::FinalConstruct"},{"content":"You can override this method in your derived class to perform any initialization required for your object.","pos":[6741,6847]},{"content":"Return Value","pos":[6896,6908]},{"pos":[6912,6983],"content":"Return <ph id=\"ph1\">`S_OK`</ph> on success or one of the standard error <ph id=\"ph2\">`HRESULT`</ph> values.","source":"Return `S_OK` on success or one of the standard error `HRESULT` values."},{"content":"Remarks","pos":[6993,7000]},{"pos":[7004,7073],"content":"By default, <ph id=\"ph1\">`CComObjectRootEx::FinalConstruct`</ph> simply returns <ph id=\"ph2\">`S_OK`</ph>.","source":"By default, `CComObjectRootEx::FinalConstruct` simply returns `S_OK`."},{"pos":[7080,7192],"content":"There are advantages to performing initialization in <ph id=\"ph1\">`FinalConstruct`</ph> rather than the constructor of your class:","source":"There are advantages to performing initialization in `FinalConstruct` rather than the constructor of your class:"},{"content":"You cannot return a status code from a constructor, but you can return an <ph id=\"ph1\">`HRESULT`</ph> by means of <ph id=\"ph2\">`FinalConstruct`</ph>'s return value.","pos":[7202,7330],"source":"You cannot return a status code from a constructor, but you can return an `HRESULT` by means of `FinalConstruct`'s return value."},{"content":"When objects of your class are being created using the standard class factory provided by ATL, this return value is propagated back to the COM client allowing you to provide them with detailed error information.","pos":[7331,7542]},{"content":"You cannot call virtual functions through the virtual function mechanism from the constructor of a class.","pos":[7552,7657]},{"content":"Calling a virtual function from the constructor of a class results in a statically resolved call to the function as it is defined at that point in the inheritance hierarchy.","pos":[7658,7831]},{"content":"Calls to pure virtual functions result in linker errors.","pos":[7832,7888]},{"content":"Your class is not the most derived class in the inheritance hierarchy — it relies on a derived class supplied by ATL to provide some of its functionality.","pos":[7899,8053]},{"content":"There is a good chance that your initialization will need to use the features provided by that class (this is certainly true when objects of your class need to aggregate other objects), but the constructor in your class has no way to access those features.","pos":[8054,8310]},{"content":"The construction code for your class is executed before the most derived class is fully constructed.","pos":[8311,8411]},{"pos":[8422,8621],"content":"However, <ph id=\"ph1\">`FinalConstruct`</ph> is called immediately after the most derived class is fully constructed allowing you to call virtual functions and use the reference-counting implementation provided by ATL.","source":"However, `FinalConstruct` is called immediately after the most derived class is fully constructed allowing you to call virtual functions and use the reference-counting implementation provided by ATL."},{"content":"Example","pos":[8631,8638]},{"content":"Typically, override this method in the class derived from <ph id=\"ph1\">`CComObjectRootEx`</ph> to create any aggregated objects.","pos":[8642,8752],"source":"Typically, override this method in the class derived from `CComObjectRootEx` to create any aggregated objects."},{"content":"For example:","pos":[8753,8765]},{"pos":[8783,8797],"content":"NVC_ATL_COM#40"},{"content":"If the construction fails, you can return an error.","pos":[8860,8911]},{"content":"You can also use the macro <bpt id=\"p1\">[</bpt>DECLARE_PROTECT_FINAL_CONSTRUCT<ept id=\"p1\">](http://msdn.microsoft.com/library/2d2e5ddc-057a-43ca-87c8-d3477a8193a0)</ept> to protect your outer object from being deleted if, during creation, the internal aggregated object increments the reference count then decrements the count to 0.","pos":[8912,9207],"source":" You can also use the macro [DECLARE_PROTECT_FINAL_CONSTRUCT](http://msdn.microsoft.com/library/2d2e5ddc-057a-43ca-87c8-d3477a8193a0) to protect your outer object from being deleted if, during creation, the internal aggregated object increments the reference count then decrements the count to 0."},{"content":"Here is a typical way to create an aggregate:","pos":[9214,9259]},{"pos":[9269,9367],"content":"Add an <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> pointer to your class object and initialize it to <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept> in the constructor.","source":"Add an **IUnknown** pointer to your class object and initialize it to **NULL** in the constructor."},{"pos":[9377,9427],"content":"Override <ph id=\"ph1\">`FinalConstruct`</ph> to create the aggregate.","source":"Override `FinalConstruct` to create the aggregate."},{"pos":[9437,9612],"content":"Use the <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> pointer you defined as the parameter to the <bpt id=\"p2\">[</bpt>COM_INTERFACE_ENTRY_AGGREGATE<ept id=\"p2\">](http://msdn.microsoft.com/library/c671fa40-a57b-4797-ae88-c9762dabd4dc)</ept> macro.","source":"Use the **IUnknown** pointer you defined as the parameter to the [COM_INTERFACE_ENTRY_AGGREGATE](http://msdn.microsoft.com/library/c671fa40-a57b-4797-ae88-c9762dabd4dc) macro."},{"pos":[9622,9682],"content":"Override <ph id=\"ph1\">`FinalRelease`</ph> to release the <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> pointer.","source":"Override `FinalRelease` to release the **IUnknown** pointer."},{"pos":[9739,9769],"content":"CComObjectRootEx::FinalRelease"},{"content":"You can override this method in your derived class to perform any cleanup required for your object.","pos":[9773,9872]},{"content":"Remarks","pos":[9916,9923]},{"pos":[9927,9985],"content":"By default, <ph id=\"ph1\">`CComObjectRootEx::FinalRelease`</ph> does nothing.","source":"By default, `CComObjectRootEx::FinalRelease` does nothing."},{"content":"Performing cleanup in <ph id=\"ph1\">`FinalRelease`</ph> is preferable to adding code to the destructor of your class since the object is still fully constructed at the point at which <ph id=\"ph2\">`FinalRelease`</ph> is called.","pos":[9992,10181],"source":"Performing cleanup in `FinalRelease` is preferable to adding code to the destructor of your class since the object is still fully constructed at the point at which `FinalRelease` is called."},{"content":"This enables you to safely access the methods provided by the most derived class.","pos":[10182,10263]},{"content":"This is particularly important for freeing any aggregated objects before deletion.","pos":[10264,10346]},{"pos":[10405,10437],"content":"CComObjectRootEx::InternalAddRef"},{"content":"Increments the reference count of a nonaggregated object by 1.","pos":[10441,10503]},{"content":"Return Value","pos":[10550,10562]},{"content":"A value that may be useful for diagnostics and testing.","pos":[10566,10621]},{"content":"Remarks","pos":[10631,10638]},{"pos":[10642,10796],"content":"If the thread model is multithreaded, <bpt id=\"p1\">**</bpt>InterlockedIncrement<ept id=\"p1\">**</ept> is used to prevent more than one thread from changing the reference count at the same time.","source":"If the thread model is multithreaded, **InterlockedIncrement** is used to prevent more than one thread from changing the reference count at the same time."},{"pos":[10863,10903],"content":"CComObjectRootEx::InternalQueryInterface"},{"content":"Retrieves a pointer to the requested interface.","pos":[10907,10954]},{"content":"Parameters","pos":[11111,11121]},{"content":"[in] A pointer to the object that contains the COM map of interfaces exposed to <ph id=\"ph1\">`QueryInterface`</ph>.","pos":[11136,11233],"source":" [in] A pointer to the object that contains the COM map of interfaces exposed to `QueryInterface`."},{"content":"[in] A pointer to the <bpt id=\"p1\">**</bpt>_ATL_INTMAP_ENTRY<ept id=\"p1\">**</ept> structure that accesses a map of available interfaces.","pos":[11254,11352],"source":" [in] A pointer to the **_ATL_INTMAP_ENTRY** structure that accesses a map of available interfaces."},{"content":"[in] The GUID of the interface being requested.","pos":[11368,11415]},{"content":"[out] A pointer to the interface pointer specified in <ph id=\"ph1\">`iid`</ph>, or <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if the interface is not found.","pos":[11437,11540],"source":" [out] A pointer to the interface pointer specified in `iid`, or **NULL** if the interface is not found."},{"content":"Return Value","pos":[11550,11562]},{"pos":[11566,11603],"content":"One of the standard <ph id=\"ph1\">`HRESULT`</ph> values.","source":"One of the standard `HRESULT` values."},{"content":"Remarks","pos":[11613,11620]},{"content":"only handles interfaces in the COM map table.","pos":[11649,11694]},{"content":"If your object is aggregated, <ph id=\"ph1\">`InternalQueryInterface`</ph> does not delegate to the outer unknown.","pos":[11695,11789],"source":" If your object is aggregated, `InternalQueryInterface` does not delegate to the outer unknown."},{"content":"You can enter interfaces into the COM map table with the macro <bpt id=\"p1\">[</bpt>COM_INTERFACE_ENTRY<ept id=\"p1\">](http://msdn.microsoft.com/library/19dcb768-2e1f-4b8d-a618-453a01a4bd00)</ept> or one of its variants.","pos":[11790,11970],"source":" You can enter interfaces into the COM map table with the macro [COM_INTERFACE_ENTRY](http://msdn.microsoft.com/library/19dcb768-2e1f-4b8d-a618-453a01a4bd00) or one of its variants."},{"pos":[12030,12063],"content":"CComObjectRootEx::InternalRelease"},{"content":"Decrements the reference count of a nonaggregated object by 1.","pos":[12067,12129]},{"content":"Return Value","pos":[12177,12189]},{"content":"In both non-debug and debug builds, this function returns a value which may be useful for diagnostics or testing.","pos":[12193,12306]},{"content":"The exact value returned depends on many factors such as the operating system used, and may, or may not, be the reference count.","pos":[12307,12435]},{"content":"Remarks","pos":[12445,12452]},{"pos":[12456,12610],"content":"If the thread model is multithreaded, <bpt id=\"p1\">**</bpt>InterlockedDecrement<ept id=\"p1\">**</ept> is used to prevent more than one thread from changing the reference count at the same time.","source":"If the thread model is multithreaded, **InterlockedDecrement** is used to prevent more than one thread from changing the reference count at the same time."},{"pos":[12659,12681],"content":"CComObjectRootEx::Lock"},{"pos":[12685,12966],"content":"If the thread model is multithreaded, this method calls the Win32 API function <bpt id=\"p1\">[</bpt>EnterCriticalSection<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms682608)</ept>, which waits until the thread can take ownership of the critical section object obtained through a private data member.","source":"If the thread model is multithreaded, this method calls the Win32 API function [EnterCriticalSection](http://msdn.microsoft.com/library/windows/desktop/ms682608), which waits until the thread can take ownership of the critical section object obtained through a private data member."},{"content":"Remarks","pos":[13002,13009]},{"pos":[13013,13132],"content":"When the protected code finishes executing, the thread must call <ph id=\"ph1\">`Unlock`</ph> to release ownership of the critical section.","source":"When the protected code finishes executing, the thread must call `Unlock` to release ownership of the critical section."},{"content":"If the thread model is single-threaded, this method does nothing.","pos":[13139,13204]},{"pos":[13256,13281],"content":"CComObjectRootEx::m_dwRef"},{"content":"Part of a union that accesses four bytes of memory.","pos":[13285,13336]},{"content":"Remarks","pos":[13373,13380]},{"pos":[13384,13424],"content":"With <ph id=\"ph1\">`m_pOuterUnknown`</ph>, part of a union:","source":"With `m_pOuterUnknown`, part of a union:"},{"content":"If the object is not aggregated, the reference count accessed by <ph id=\"ph1\">`AddRef`</ph> and <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept> is stored in <ph id=\"ph2\">`m_dwRef`</ph>.","pos":[13523,13636],"source":"If the object is not aggregated, the reference count accessed by `AddRef` and **Release** is stored in `m_dwRef`."},{"content":"If the object is aggregated, the pointer to the outer unknown is stored in <bpt id=\"p1\">[</bpt>m_pOuterUnknown<ept id=\"p1\">](#ccomobjectrootex__m_pouterunknown)</ept>.","pos":[13637,13766],"source":" If the object is aggregated, the pointer to the outer unknown is stored in [m_pOuterUnknown](#ccomobjectrootex__m_pouterunknown)."},{"pos":[13826,13859],"content":"CComObjectRootEx::m_pOuterUnknown"},{"content":"Part of a union that accesses four bytes of memory.","pos":[13863,13914]},{"content":"Remarks","pos":[13971,13978]},{"pos":[13982,14014],"content":"With <ph id=\"ph1\">`m_dwRef`</ph>, part of a union:","source":"With `m_dwRef`, part of a union:"},{"content":"If the object is aggregated, the pointer to the outer unknown is stored in <ph id=\"ph1\">`m_pOuterUnknown`</ph>.","pos":[14113,14206],"source":"If the object is aggregated, the pointer to the outer unknown is stored in `m_pOuterUnknown`."},{"content":"If the object is not aggregated, the reference count accessed by <ph id=\"ph1\">`AddRef`</ph> and <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept> is stored in <bpt id=\"p2\">[</bpt>m_dwRef<ept id=\"p2\">](#ccomobjectrootex__m_dwref)</ept>.","pos":[14207,14348],"source":" If the object is not aggregated, the reference count accessed by `AddRef` and **Release** is stored in [m_dwRef](#ccomobjectrootex__m_dwref)."},{"pos":[14403,14431],"content":"CComObjectRootEx::ObjectMain"},{"pos":[14435,14641],"content":"For each class listed in the <bpt id=\"p1\">[</bpt>object map<ept id=\"p1\">](http://msdn.microsoft.com/en-us/b57619cc-534f-4b8f-bfd4-0c12f937202f)</ept>, this function is called once when the module is initialized, and again when it is terminated.","source":"For each class listed in the [object map](http://msdn.microsoft.com/en-us/b57619cc-534f-4b8f-bfd4-0c12f937202f), this function is called once when the module is initialized, and again when it is terminated."},{"content":"Parameters","pos":[14711,14721]},{"content":"[out] The value is <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the class is being initialized; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","pos":[14740,14823],"source":" [out] The value is **true** if the class is being initialized; otherwise **false**."},{"content":"Remarks","pos":[14833,14840]},{"content":"The value of the <ph id=\"ph1\">`bStarting`</ph> parameter indicates whether the module is being initialized or terminated.","pos":[14844,14947],"source":"The value of the `bStarting` parameter indicates whether the module is being initialized or terminated."},{"content":"The default implementation of <ph id=\"ph1\">`ObjectMain`</ph> does nothing, but you can override this function in your class to initialize or clean up resources that you want to allocate for the class.","pos":[14948,15130],"source":" The default implementation of `ObjectMain` does nothing, but you can override this function in your class to initialize or clean up resources that you want to allocate for the class."},{"content":"Note that <ph id=\"ph1\">`ObjectMain`</ph> is called before any instances of the class are requested.","pos":[15131,15212],"source":" Note that `ObjectMain` is called before any instances of the class are requested."},{"content":"is called from the entry point of the DLL, so the type of operation that the entry-point function can perform is restricted.","pos":[15232,15356]},{"content":"For more information on these restrictions, see <bpt id=\"p1\">[</bpt>Run-Time Library Behavior<ept id=\"p1\">](../../build/run-time-library-behavior.md)</ept> and <bpt id=\"p2\">[</bpt>DllMain<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms682583)</ept>.","pos":[15357,15549],"source":" For more information on these restrictions, see [Run-Time Library Behavior](../../build/run-time-library-behavior.md) and [DllMain](http://msdn.microsoft.com/library/windows/desktop/ms682583)."},{"content":"Example","pos":[15559,15566]},{"pos":[15581,15595],"content":"NVC_ATL_COM#41"},{"pos":[15707,15736],"content":"CComObjectRootEx::OuterAddRef"},{"content":"Increments the reference count of the outer unknown of an aggregation.","pos":[15740,15810]},{"content":"Return Value","pos":[15854,15866]},{"content":"A value that may be useful for diagnostics and testing.","pos":[15870,15925]},{"pos":[15989,16026],"content":"CComObjectRootEx::OuterQueryInterface"},{"content":"Retrieves an indirect pointer to the requested interface.","pos":[16030,16087]},{"content":"Parameters","pos":[16173,16183]},{"content":"[in] The GUID of the interface being requested.","pos":[16196,16243]},{"content":"[out] A pointer to the interface pointer specified in <ph id=\"ph1\">`iid`</ph>, or <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if the aggregation does not support the interface.","pos":[16265,16388],"source":" [out] A pointer to the interface pointer specified in `iid`, or **NULL** if the aggregation does not support the interface."},{"content":"Return Value","pos":[16398,16410]},{"pos":[16414,16451],"content":"One of the standard <ph id=\"ph1\">`HRESULT`</ph> values.","source":"One of the standard `HRESULT` values."},{"pos":[16508,16538],"content":"CComObjectRootEx::OuterRelease"},{"content":"Decrements the reference count of the outer unknown of an aggregation.","pos":[16542,16612]},{"content":"Return Value","pos":[16657,16669]},{"content":"In non-debug builds, always returns 0.","pos":[16673,16711]},{"content":"In debug builds, returns a value that may be useful for diagnostics or testing.","pos":[16712,16791]},{"pos":[16842,16866],"content":"CComObjectRootEx::Unlock"},{"pos":[16870,17128],"content":"If the thread model is multithreaded, this method calls the Win32 API function <bpt id=\"p1\">[</bpt>LeaveCriticalSection<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms684169)</ept>, which releases ownership of the critical section object obtained through a private data member.","source":"If the thread model is multithreaded, this method calls the Win32 API function [LeaveCriticalSection](http://msdn.microsoft.com/library/windows/desktop/ms684169), which releases ownership of the critical section object obtained through a private data member."},{"content":"Remarks","pos":[17166,17173]},{"content":"To obtain ownership, the thread must call <ph id=\"ph1\">`Lock`</ph>.","pos":[17177,17226],"source":"To obtain ownership, the thread must call `Lock`."},{"content":"Each call to <ph id=\"ph1\">`Lock`</ph> requires a corresponding call to <ph id=\"ph2\">`Unlock`</ph> to release ownership of the critical section.","pos":[17227,17334],"source":" Each call to `Lock` requires a corresponding call to `Unlock` to release ownership of the critical section."},{"content":"If the thread model is single-threaded, this method does nothing.","pos":[17341,17406]},{"content":"See Also","pos":[17415,17423]},{"content":"CComAggObject Class","pos":[17428,17447]},{"content":"CComObject Class","pos":[17498,17514]},{"content":"CComPolyObject Class","pos":[17562,17582]},{"content":"Class Overview","pos":[17634,17648]}],"content":"---\ntitle: \"CComObjectRootEx Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"ATL.CComObjectRootEx\"\n  - \"ATL::CComObjectRootEx<ThreadModel>\"\n  - \"CComObjectRootEx\"\n  - \"ATL::CComObjectRootEx\"\n  - \"ATL.CComObjectRootEx<ThreadModel>\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"reference counting\"\nms.assetid: 894a3d7c-2daf-4fd0-8fa4-e6a05bcfb631\ncaps.latest.revision: 20\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CComObjectRootEx Class\nThis class provides methods to handle object reference count management for both nonaggregated and aggregated objects.  \n  \n## Syntax  \n  \n```\ntemplate<class ThreadModel>  class CComObjectRootEx : public CComObjectRootBase\n```  \n  \n#### Parameters  \n `ThreadModel`  \n The class whose methods implement the desired threading model. You can explicitly choose the threading model by setting `ThreadModel` to [CComSingleThreadModel](../../atl/reference/ccomsinglethreadmodel-class.md), [CComMultiThreadModel](../../atl/reference/ccommultithreadmodel-class.md), or [CComMultiThreadModelNoCS](../../atl/reference/ccommultithreadmodelnocs-class.md). You can accept the server's default thread model by setting `ThreadModel` to [CComObjectThreadModel](atl-typedefs.md#ccomobjectthreadmodel) or [CComGlobalsThreadModel](atl-typedefs.md#ccomglobalsthreadmodel).  \n\n  \n## Members  \n  \n### Methods  \n  \n|||  \n|-|-|  \n|[CComObjectRootEx](#ccomobjectrootex__ccomobjectrootex)|Constructor.|  \n|[InternalAddRef](#ccomobjectrootex__internaladdref)|Increments the reference count for a nonaggregated object.|  \n|[InternalRelease](#ccomobjectrootex__internalrelease)|Decrements the reference count for a nonaggregated object.|  \n|[Lock](#ccomobjectrootex__lock)|If the thread model is multithreaded, obtains ownership of a critical section object.|  \n|[Unlock](#ccomobjectrootex__unlock)|If the thread model is multithreaded, releases ownership of a critical section object.|  \n  \n### CComObjectRootBase Methods  \n  \n|||  \n|-|-|  \n|[FinalConstruct](#ccomobjectrootex__finalconstruct)|Override in your class to perform any initialization required by your object.|  \n|[FinalRelease](#ccomobjectrootex__finalrelease)|Override in your class to perform any cleanup required by your object.|  \n|[OuterAddRef](#ccomobjectrootex__outeraddref)|Increments the reference count for an aggregated object.|  \n|[OuterQueryInterface](#ccomobjectrootex__outerqueryinterface)|Delegates to the outer **IUnknown** of an aggregated object.|  \n|[OuterRelease](#ccomobjectrootex__outerrelease)|Decrements the reference count for an aggregated object.|  \n  \n### Static Functions  \n  \n|||  \n|-|-|  \n|[InternalQueryInterface](#ccomobjectrootex__internalqueryinterface)|Delegates to the **IUnknown** of a nonaggregated object.|  \n|[ObjectMain](#ccomobjectrootex__objectmain)|Called during module initialization and termination for derived classes listed in the object map.|  \n  \n### Data Members  \n  \n|||  \n|-|-|  \n|[m_dwRef](#ccomobjectrootex__m_dwref)|With `m_pOuterUnknown`, part of a union. Used when the object is not aggregated to hold the reference count of `AddRef` and **Release**.|  \n|[m_pOuterUnknown](#ccomobjectrootex__m_pouterunknown)|With `m_dwRef`, part of a union. Used when the object is aggregated to hold a pointer to the outer unknown.|  \n  \n## Remarks  \n `CComObjectRootEx` handles object reference count management for both nonaggregated and aggregated objects. It holds the object reference count if your object is not being aggregated, and holds the pointer to the outer unknown if your object is being aggregated. For aggregated objects, `CComObjectRootEx` methods can be used to handle the failure of the inner object to construct, and to protect the outer object from deletion when inner interfaces are released or the inner object is deleted.  \n  \n A class that implements a COM server must inherit from `CComObjectRootEx` or [CComObjectRoot](../../atl/reference/ccomobjectroot-class.md).  \n  \n If your class definition specifies the [DECLARE_POLY_AGGREGATABLE](http://msdn.microsoft.com/library/7569e738-cfbc-4404-ba1d-78dcefa3bdb3) macro, ATL creates an instance of **CComPolyObject\\<CYourClass>** when **IClassFactory::CreateInstance** is called. During creation, the value of the outer unknown is checked. If it is **NULL**, **IUnknown** is implemented for a nonaggregated object. If the outer unknown is not **NULL**, **IUnknown** is implemented for an aggregated object.  \n  \n If your class does not specify the `DECLARE_POLY_AGGREGATABLE` macro, ATL creates an instance of **CAggComObject\\<CYourClass>** for aggregated objects or an instance of **CComObject\\<CYourClass>** for nonaggregated objects.  \n  \n The advantage of using `CComPolyObject` is that you avoid having both `CComAggObject` and `CComObject` in your module to handle the aggregated and nonaggregated cases. A single `CComPolyObject` object handles both cases. Therefore, only one copy of the vtable and one copy of the functions exist in your module. If your vtable is large, this can substantially decrease your module size. However, if your vtable is small, using `CComPolyObject` can result in a slightly larger module size because it is not optimized for an aggregated or nonaggregated object, as are `CComAggObject` and `CComObject`.  \n  \n If your object is aggregated, [IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509) is implemented by `CComAggObject` or `CComPolyObject`. These classes delegate `QueryInterface`, `AddRef`, and **Release** calls to `CComObjectRootEx`'s `OuterQueryInterface`, `OuterAddRef`, and `OuterRelease` to forward to the outer unknown. Typically, you override `CComObjectRootEx::FinalConstruct` in your class to create any aggregated objects, and override `CComObjectRootEx::FinalRelease` to free any aggregated objects.  \n  \n If your object is not aggregated, **IUnknown** is implemented by `CComObject` or `CComPolyObject`. In this case, calls to `QueryInterface`, `AddRef`, and **Release** are delegated to `CComObjectRootEx`'s `InternalQueryInterface`, `InternalAddRef`, and `InternalRelease` to perform the actual operations.  \n  \n## Requirements  \n **Header:** atlcom.h  \n  \n##  <a name=\"ccomobjectrootex__ccomobjectrootex\"></a>  CComObjectRootEx::CComObjectRootEx  \n The constructor initializes the reference count to 0.  \n  \n```\nCComObjectRootEx();\n```  \n  \n##  <a name=\"ccomobjectrootex__finalconstruct\"></a>  CComObjectRootEx::FinalConstruct  \n You can override this method in your derived class to perform any initialization required for your object.  \n  \n```\nHRESULT FinalConstruct();\n```  \n  \n### Return Value  \n Return `S_OK` on success or one of the standard error `HRESULT` values.  \n  \n### Remarks  \n By default, `CComObjectRootEx::FinalConstruct` simply returns `S_OK`.  \n  \n There are advantages to performing initialization in `FinalConstruct` rather than the constructor of your class:  \n  \n-   You cannot return a status code from a constructor, but you can return an `HRESULT` by means of `FinalConstruct`'s return value. When objects of your class are being created using the standard class factory provided by ATL, this return value is propagated back to the COM client allowing you to provide them with detailed error information.  \n  \n-   You cannot call virtual functions through the virtual function mechanism from the constructor of a class. Calling a virtual function from the constructor of a class results in a statically resolved call to the function as it is defined at that point in the inheritance hierarchy. Calls to pure virtual functions result in linker errors.  \n  \n     Your class is not the most derived class in the inheritance hierarchy — it relies on a derived class supplied by ATL to provide some of its functionality. There is a good chance that your initialization will need to use the features provided by that class (this is certainly true when objects of your class need to aggregate other objects), but the constructor in your class has no way to access those features. The construction code for your class is executed before the most derived class is fully constructed.  \n  \n     However, `FinalConstruct` is called immediately after the most derived class is fully constructed allowing you to call virtual functions and use the reference-counting implementation provided by ATL.  \n  \n### Example  \n Typically, override this method in the class derived from `CComObjectRootEx` to create any aggregated objects. For example:  \n  \n [!code-cpp[NVC_ATL_COM#40](../../atl/codesnippet/cpp/ccomobjectrootex-class_1.h)]  \n  \n If the construction fails, you can return an error. You can also use the macro [DECLARE_PROTECT_FINAL_CONSTRUCT](http://msdn.microsoft.com/library/2d2e5ddc-057a-43ca-87c8-d3477a8193a0) to protect your outer object from being deleted if, during creation, the internal aggregated object increments the reference count then decrements the count to 0.  \n  \n Here is a typical way to create an aggregate:  \n  \n-   Add an **IUnknown** pointer to your class object and initialize it to **NULL** in the constructor.  \n  \n-   Override `FinalConstruct` to create the aggregate.  \n  \n-   Use the **IUnknown** pointer you defined as the parameter to the [COM_INTERFACE_ENTRY_AGGREGATE](http://msdn.microsoft.com/library/c671fa40-a57b-4797-ae88-c9762dabd4dc) macro.  \n  \n-   Override `FinalRelease` to release the **IUnknown** pointer.  \n  \n##  <a name=\"ccomobjectrootex__finalrelease\"></a>  CComObjectRootEx::FinalRelease  \n You can override this method in your derived class to perform any cleanup required for your object.  \n  \n```\nvoid FinalRelease();\n```  \n  \n### Remarks  \n By default, `CComObjectRootEx::FinalRelease` does nothing.  \n  \n Performing cleanup in `FinalRelease` is preferable to adding code to the destructor of your class since the object is still fully constructed at the point at which `FinalRelease` is called. This enables you to safely access the methods provided by the most derived class. This is particularly important for freeing any aggregated objects before deletion.  \n  \n##  <a name=\"ccomobjectrootex__internaladdref\"></a>  CComObjectRootEx::InternalAddRef  \n Increments the reference count of a nonaggregated object by 1.  \n  \n```\nULONG InternalAddRef();\n```  \n  \n### Return Value  \n A value that may be useful for diagnostics and testing.  \n  \n### Remarks  \n If the thread model is multithreaded, **InterlockedIncrement** is used to prevent more than one thread from changing the reference count at the same time.  \n  \n##  <a name=\"ccomobjectrootex__internalqueryinterface\"></a>  CComObjectRootEx::InternalQueryInterface  \n Retrieves a pointer to the requested interface.  \n  \n```\nstatic HRESULT InternalQueryInterface(\n    void* pThis,\n    const _ATL_INTMAP_ENTRY* pEntries,\n    REFIID iid,\n    void** ppvObject);\n```  \n  \n### Parameters  \n `pThis`  \n [in] A pointer to the object that contains the COM map of interfaces exposed to `QueryInterface`.  \n  \n `pEntries`  \n [in] A pointer to the **_ATL_INTMAP_ENTRY** structure that accesses a map of available interfaces.  \n  \n `iid`  \n [in] The GUID of the interface being requested.  \n  \n `ppvObject`  \n [out] A pointer to the interface pointer specified in `iid`, or **NULL** if the interface is not found.  \n  \n### Return Value  \n One of the standard `HRESULT` values.  \n  \n### Remarks  \n `InternalQueryInterface` only handles interfaces in the COM map table. If your object is aggregated, `InternalQueryInterface` does not delegate to the outer unknown. You can enter interfaces into the COM map table with the macro [COM_INTERFACE_ENTRY](http://msdn.microsoft.com/library/19dcb768-2e1f-4b8d-a618-453a01a4bd00) or one of its variants.  \n  \n##  <a name=\"ccomobjectrootex__internalrelease\"></a>  CComObjectRootEx::InternalRelease  \n Decrements the reference count of a nonaggregated object by 1.  \n  \n```\nULONG InternalRelease();\n```  \n  \n### Return Value  \n In both non-debug and debug builds, this function returns a value which may be useful for diagnostics or testing. The exact value returned depends on many factors such as the operating system used, and may, or may not, be the reference count.  \n  \n### Remarks  \n If the thread model is multithreaded, **InterlockedDecrement** is used to prevent more than one thread from changing the reference count at the same time.  \n  \n##  <a name=\"ccomobjectrootex__lock\"></a>  CComObjectRootEx::Lock  \n If the thread model is multithreaded, this method calls the Win32 API function [EnterCriticalSection](http://msdn.microsoft.com/library/windows/desktop/ms682608), which waits until the thread can take ownership of the critical section object obtained through a private data member.  \n  \n```\nvoid Lock();\n```  \n  \n### Remarks  \n When the protected code finishes executing, the thread must call `Unlock` to release ownership of the critical section.  \n  \n If the thread model is single-threaded, this method does nothing.  \n  \n##  <a name=\"ccomobjectrootex__m_dwref\"></a>  CComObjectRootEx::m_dwRef  \n Part of a union that accesses four bytes of memory.  \n  \n```\nlong m_dwRef;\n```  \n  \n### Remarks  \n With `m_pOuterUnknown`, part of a union:  \n  \n `union`  \n  \n `{`  \n  \n `long m_dwRef;`  \n  \n `IUnknown* m_pOuterUnknown;`  \n  \n `};`  \n  \n If the object is not aggregated, the reference count accessed by `AddRef` and **Release** is stored in `m_dwRef`. If the object is aggregated, the pointer to the outer unknown is stored in [m_pOuterUnknown](#ccomobjectrootex__m_pouterunknown).  \n  \n##  <a name=\"ccomobjectrootex__m_pouterunknown\"></a>  CComObjectRootEx::m_pOuterUnknown  \n Part of a union that accesses four bytes of memory.  \n  \n```\nIUnknown*\n    m_pOuterUnknown;\n```     \n  \n### Remarks  \n With `m_dwRef`, part of a union:  \n  \n `union`  \n  \n `{`  \n  \n `long m_dwRef;`  \n  \n `IUnknown* m_pOuterUnknown;`  \n  \n `};`  \n  \n If the object is aggregated, the pointer to the outer unknown is stored in `m_pOuterUnknown`. If the object is not aggregated, the reference count accessed by `AddRef` and **Release** is stored in [m_dwRef](#ccomobjectrootex__m_dwref).  \n  \n##  <a name=\"ccomobjectrootex__objectmain\"></a>  CComObjectRootEx::ObjectMain  \n For each class listed in the [object map](http://msdn.microsoft.com/en-us/b57619cc-534f-4b8f-bfd4-0c12f937202f), this function is called once when the module is initialized, and again when it is terminated.  \n  \n```\nstatic void WINAPI ObjectMain(bool bStarting);\n```  \n  \n### Parameters  \n `bStarting`  \n [out] The value is **true** if the class is being initialized; otherwise **false**.  \n  \n### Remarks  \n The value of the `bStarting` parameter indicates whether the module is being initialized or terminated. The default implementation of `ObjectMain` does nothing, but you can override this function in your class to initialize or clean up resources that you want to allocate for the class. Note that `ObjectMain` is called before any instances of the class are requested.  \n  \n `ObjectMain` is called from the entry point of the DLL, so the type of operation that the entry-point function can perform is restricted. For more information on these restrictions, see [Run-Time Library Behavior](../../build/run-time-library-behavior.md) and [DllMain](http://msdn.microsoft.com/library/windows/desktop/ms682583).  \n  \n### Example  \n [!code-cpp[NVC_ATL_COM#41](../../atl/codesnippet/cpp/ccomobjectrootex-class_2.h)]  \n  \n##  <a name=\"ccomobjectrootex__outeraddref\"></a>  CComObjectRootEx::OuterAddRef  \n Increments the reference count of the outer unknown of an aggregation.  \n  \n```\nULONG OuterAddRef();\n```  \n  \n### Return Value  \n A value that may be useful for diagnostics and testing.  \n  \n##  <a name=\"ccomobjectrootex__outerqueryinterface\"></a>  CComObjectRootEx::OuterQueryInterface  \n Retrieves an indirect pointer to the requested interface.  \n  \n```\nHRESULT OuterQueryInterface(REFIID iid,\n    void** ppvObject);\n```  \n  \n### Parameters  \n `iid`  \n [in] The GUID of the interface being requested.  \n  \n `ppvObject`  \n [out] A pointer to the interface pointer specified in `iid`, or **NULL** if the aggregation does not support the interface.  \n  \n### Return Value  \n One of the standard `HRESULT` values.  \n  \n##  <a name=\"ccomobjectrootex__outerrelease\"></a>  CComObjectRootEx::OuterRelease  \n Decrements the reference count of the outer unknown of an aggregation.  \n  \n```\nULONG OuterRelease();\n```  \n  \n### Return Value  \n In non-debug builds, always returns 0. In debug builds, returns a value that may be useful for diagnostics or testing.  \n  \n##  <a name=\"ccomobjectrootex__unlock\"></a>  CComObjectRootEx::Unlock  \n If the thread model is multithreaded, this method calls the Win32 API function [LeaveCriticalSection](http://msdn.microsoft.com/library/windows/desktop/ms684169), which releases ownership of the critical section object obtained through a private data member.  \n  \n```\nvoid Unlock();\n```  \n  \n### Remarks  \n To obtain ownership, the thread must call `Lock`. Each call to `Lock` requires a corresponding call to `Unlock` to release ownership of the critical section.  \n  \n If the thread model is single-threaded, this method does nothing.  \n  \n## See Also  \n [CComAggObject Class](../../atl/reference/ccomaggobject-class.md)   \n [CComObject Class](../../atl/reference/ccomobject-class.md)   \n [CComPolyObject Class](../../atl/reference/ccompolyobject-class.md)   \n [Class Overview](../../atl/atl-class-overview.md)\n"}