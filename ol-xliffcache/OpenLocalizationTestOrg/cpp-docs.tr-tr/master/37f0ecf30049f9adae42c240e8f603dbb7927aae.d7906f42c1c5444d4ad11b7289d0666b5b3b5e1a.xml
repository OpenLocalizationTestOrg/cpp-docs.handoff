{"nodes":[{"pos":[12,58],"content":"Template Specialization (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Template Specialization (C++) | Microsoft Docs","pos":[0,46]}]},{"content":"Template Specialization (C++)","pos":[620,649]},{"content":"Class templates can be partially specialized, and the resulting class is still a template.","pos":[650,740]},{"content":"Partial specialization allows template code to be partially customized for specific types in situations, such as:","pos":[741,854]},{"content":"A template has multiple types and only some of them need to be specialized.","pos":[864,939]},{"content":"The result is a template parameterized on the remaining types.","pos":[940,1002]},{"content":"A template has only one type, but a specialization is needed for pointer, reference, pointer to member, or function pointer types.","pos":[1012,1142]},{"content":"The specialization itself is still a template on the type pointed to or referenced.","pos":[1143,1226]},{"content":"Example","pos":[1235,1242]},{"content":"Example","pos":[2523,2530]},{"content":"If you have a template collection class that takes any type <bpt id=\"p1\">**</bpt>T<ept id=\"p1\">**</ept>, you can create a partial specialization that takes any pointer type <bpt id=\"p2\">**</bpt>T<ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept>. The following code demonstrates a collection class template <ph id=\"ph2\">`Bag`</ph> and a partial specialization for pointer types in which the collection dereferences the pointer types before copying them to the array.","pos":[2534,2879],"source":"If you have a template collection class that takes any type **T**, you can create a partial specialization that takes any pointer type **T\\***. The following code demonstrates a collection class template `Bag` and a partial specialization for pointer types in which the collection dereferences the pointer types before copying them to the array."},{"content":"The collection then stores the values that are pointed to.","pos":[2880,2938]},{"content":"With the original template, only the pointers themselves would have been stored in the collection, leaving the data vulnerable to deletion or modification.","pos":[2939,3094]},{"content":"In this special pointer version of the collection, code to check for a null pointer in the <ph id=\"ph1\">`add`</ph> method is added.","pos":[3095,3208],"source":" In this special pointer version of the collection, code to check for a null pointer in the `add` method is added."},{"content":"Example","pos":[5473,5480]},{"content":"The following example defines a template class that takes pairs of any two types and then defines a partial specialization of that template class specialized so that one of the types is <ph id=\"ph1\">`int`</ph>.","pos":[5484,5676],"source":"The following example defines a template class that takes pairs of any two types and then defines a partial specialization of that template class specialized so that one of the types is `int`."},{"content":"The specialization defines an additional sort method that implements a simple bubble sort based on the integer.","pos":[5677,5788]}],"content":"---\ntitle: \"Template Specialization (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"partial specialization of class templates\"\nms.assetid: f3c67c0b-3875-434a-b8d8-bb47e99cf4f0\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Template Specialization (C++)\nClass templates can be partially specialized, and the resulting class is still a template. Partial specialization allows template code to be partially customized for specific types in situations, such as:  \n  \n-   A template has multiple types and only some of them need to be specialized. The result is a template parameterized on the remaining types.  \n  \n-   A template has only one type, but a specialization is needed for pointer, reference, pointer to member, or function pointer types. The specialization itself is still a template on the type pointed to or referenced.  \n  \n## Example  \n  \n```  \n// partial_specialization_of_class_templates.cpp  \ntemplate <class T> struct PTS {  \n   enum {  \n      IsPointer = 0,  \n      IsPointerToDataMember = 0  \n   };  \n};  \n  \ntemplate <class T> struct PTS<T*> {  \n   enum {  \n      IsPointer = 1,  \n      IsPointerToDataMember = 0  \n   };  \n};  \n  \ntemplate <class T, class U> struct PTS<T U::*> {  \n   enum {  \n      IsPointer = 0,  \n      IsPointerToDataMember = 1  \n   };  \n};  \n  \nstruct S{};  \n  \nextern \"C\" int printf_s(const char*,...);  \n  \nint main() {  \n   S s, *pS;  \n   int S::*ptm;  \n   printf_s(\"PTS<S>::IsPointer == %d PTS<S>::IsPointerToDataMember == %d\\n\",   \n           PTS<S>::IsPointer, PTS<S>:: IsPointerToDataMember);  \n   printf_s(\"PTS<S*>::IsPointer == %d PTS<S*>::IsPointerToDataMember ==%d\\n\"  \n           , PTS<S*>::IsPointer, PTS<S*>:: IsPointerToDataMember);  \n   printf_s(\"PTS<int S::*>::IsPointer == %d PTS\"  \n           \"<int S::*>::IsPointerToDataMember == %d\\n\",   \n           PTS<int S::*>::IsPointer, PTS<int S::*>::   \n           IsPointerToDataMember);  \n}  \n```  \n  \n```Output  \nPTS<S>::IsPointer == 0 PTS<S>::IsPointerToDataMember == 0  \nPTS<S*>::IsPointer == 1 PTS<S*>::IsPointerToDataMember ==0  \nPTS<int S::*>::IsPointer == 0 PTS<int S::*>::IsPointerToDataMember == 1  \n```  \n  \n## Example  \n If you have a template collection class that takes any type **T**, you can create a partial specialization that takes any pointer type **T\\***. The following code demonstrates a collection class template `Bag` and a partial specialization for pointer types in which the collection dereferences the pointer types before copying them to the array. The collection then stores the values that are pointed to. With the original template, only the pointers themselves would have been stored in the collection, leaving the data vulnerable to deletion or modification. In this special pointer version of the collection, code to check for a null pointer in the `add` method is added.  \n  \n```  \n// partial_specialization_of_class_templates2.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \n// Original template collection class.  \ntemplate <class T> class Bag {  \n   T* elem;  \n   int size;  \n   int max_size;  \n  \npublic:  \n   Bag() : elem(0), size(0), max_size(1) {}  \n   void add(T t) {  \n      T* tmp;  \n      if (size + 1 >= max_size) {  \n         max_size *= 2;  \n         tmp = new T [max_size];  \n         for (int i = 0; i < size; i++)  \n            tmp[i] = elem[i];  \n         tmp[size++] = t;  \n         delete[] elem;  \n         elem = tmp;  \n      }  \n      else  \n         elem[size++] = t;  \n   }  \n  \n   void print() {  \n      for (int i = 0; i < size; i++)  \n         cout << elem[i] << \" \";  \n      cout << endl;  \n   }  \n};  \n  \n// Template partial specialization for pointer types.  \n// The collection has been modified to check for NULL   \n// and store types pointed to.  \ntemplate <class T> class Bag<T*> {  \n   T* elem;  \n   int size;  \n   int max_size;  \n  \npublic:  \n   Bag() : elem(0), size(0), max_size(1) {}  \n   void add(T* t) {  \n      T* tmp;  \n      if (t == NULL) {   // Check for NULL  \n         cout << \"Null pointer!\" << endl;  \n         return;  \n      }  \n  \n      if (size + 1 >= max_size) {  \n         max_size *= 2;  \n         tmp = new T [max_size];  \n         for (int i = 0; i < size; i++)  \n            tmp[i] = elem[i];  \n         tmp[size++] = *t;  // Dereference  \n         delete[] elem;  \n         elem = tmp;  \n      }  \n      else  \n         elem[size++] = *t; // Dereference  \n   }  \n  \n   void print() {  \n      for (int i = 0; i < size; i++)  \n         cout << elem[i] << \" \";  \n      cout << endl;  \n   }  \n};  \n  \nint main() {  \n   Bag<int> xi;  \n   Bag<char> xc;  \n   Bag<int*> xp; // Uses partial specialization for pointer types.  \n  \n   xi.add(10);  \n   xi.add(9);  \n   xi.add(8);  \n   xi.print();  \n  \n   xc.add('a');  \n   xc.add('b');  \n   xc.add('c');  \n   xc.print();  \n  \n   int i = 3, j = 87, *p = new int[2];  \n   *p = 8;  \n   *(p + 1) = 100;  \n   xp.add(&i);  \n   xp.add(&j);  \n   xp.add(p);  \n   xp.add(p + 1);  \n   p = NULL;  \n   xp.add(p);  \n   xp.print();  \n}  \n```  \n  \n```Output  \n10 9 8   \na b c   \nNull pointer!  \n3 87 8 100   \n```  \n  \n## Example  \n The following example defines a template class that takes pairs of any two types and then defines a partial specialization of that template class specialized so that one of the types is `int`. The specialization defines an additional sort method that implements a simple bubble sort based on the integer.  \n  \n```  \n// partial_specialization_of_class_templates3.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \ntemplate <class Key, class Value> class Dictionary {  \n   Key* keys;  \n   Value* values;  \n   int size;  \n   int max_size;  \npublic:  \n   Dictionary(int initial_size) :  size(0) {  \n      max_size = 1;  \n      while (initial_size >= max_size)  \n         max_size *= 2;  \n      keys = new Key[max_size];  \n      values = new Value[max_size];  \n   }  \n   void add(Key key, Value value) {  \n      Key* tmpKey;  \n      Value* tmpVal;  \n      if (size + 1 >= max_size) {  \n         max_size *= 2;  \n         tmpKey = new Key [max_size];  \n         tmpVal = new Value [max_size];  \n         for (int i = 0; i < size; i++) {  \n            tmpKey[i] = keys[i];  \n            tmpVal[i] = values[i];  \n         }  \n         tmpKey[size] = key;  \n         tmpVal[size] = value;  \n         delete[] keys;  \n         delete[] values;  \n         keys = tmpKey;  \n         values = tmpVal;  \n      }  \n      else {  \n         keys[size] = key;  \n         values[size] = value;  \n      }  \n      size++;  \n   }  \n  \n   void print() {  \n      for (int i = 0; i < size; i++)  \n         cout << \"{\" << keys[i] << \", \" << values[i] << \"}\" << endl;  \n   }  \n};  \n  \n// Template partial specialization: Key is specified to be int.  \ntemplate <class Value> class Dictionary<int, Value> {  \n   int* keys;  \n   Value* values;  \n   int size;  \n   int max_size;  \npublic:  \n   Dictionary(int initial_size) :  size(0) {  \n      max_size = 1;  \n      while (initial_size >= max_size)  \n         max_size *= 2;  \n      keys = new int[max_size];  \n      values = new Value[max_size];  \n   }  \n   void add(int key, Value value) {  \n      int* tmpKey;  \n      Value* tmpVal;  \n      if (size + 1 >= max_size) {  \n         max_size *= 2;  \n         tmpKey = new int [max_size];  \n         tmpVal = new Value [max_size];  \n         for (int i = 0; i < size; i++) {  \n            tmpKey[i] = keys[i];  \n            tmpVal[i] = values[i];  \n         }  \n         tmpKey[size] = key;  \n         tmpVal[size] = value;  \n         delete[] keys;  \n         delete[] values;  \n         keys = tmpKey;  \n         values = tmpVal;  \n      }  \n      else {  \n         keys[size] = key;  \n         values[size] = value;  \n      }  \n      size++;  \n   }  \n  \n   void sort() {  \n      // Sort method is defined.  \n      int smallest = 0;  \n      for (int i = 0; i < size - 1; i++) {  \n         for (int j = i; j < size; j++) {  \n            if (keys[j] < keys[smallest])  \n               smallest = j;  \n         }  \n         swap(keys[i], keys[smallest]);  \n         swap(values[i], values[smallest]);  \n      }  \n   }  \n  \n   void print() {  \n      for (int i = 0; i < size; i++)  \n         cout << \"{\" << keys[i] << \", \" << values[i] << \"}\" << endl;  \n   }  \n};  \n  \nint main() {  \n   Dictionary<char*, char*>* dict = new Dictionary<char*, char*>(10);  \n   dict->print();  \n   dict->add(\"apple\", \"fruit\");  \n   dict->add(\"banana\", \"fruit\");  \n   dict->add(\"dog\", \"animal\");  \n   dict->print();  \n  \n   Dictionary<int, char*>* dict_specialized = new Dictionary<int, char*>(10);  \n   dict_specialized->print();  \n   dict_specialized->add(100, \"apple\");  \n   dict_specialized->add(101, \"banana\");  \n   dict_specialized->add(103, \"dog\");  \n   dict_specialized->add(89, \"cat\");  \n   dict_specialized->print();  \n   dict_specialized->sort();  \n   cout << endl << \"Sorted list:\" << endl;  \n   dict_specialized->print();  \n}  \n```  \n  \n```Output  \n{apple, fruit}  \n{banana, fruit}  \n{dog, animal}  \n{100, apple}  \n{101, banana}  \n{103, dog}  \n{89, cat}  \n  \nSorted list:  \n{89, cat}  \n{100, apple}  \n{101, banana}  \n{103, dog}  \n```  \n"}