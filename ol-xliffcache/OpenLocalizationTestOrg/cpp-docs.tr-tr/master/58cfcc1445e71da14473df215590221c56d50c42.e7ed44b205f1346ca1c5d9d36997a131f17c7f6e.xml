{"nodes":[{"pos":[12,51],"content":"Debug Iterator Support | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Debug Iterator Support | Microsoft Docs","pos":[0,39]}]},{"pos":[880,902],"content":"Debug Iterator Support","linkify":"Debug Iterator Support","nodes":[{"content":"Debug Iterator Support","pos":[0,22]}]},{"content":"The Visual C++ run-time library detects incorrect iterator use, and asserts and displays a dialog box at run time.","pos":[903,1017]},{"content":"To enable debug iterator support, you must use a debug version of a C run-time library to compile your program.","pos":[1018,1129]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>CRT Library Features<ept id=\"p1\">](../c-runtime-library/crt-library-features.md)</ept>.","pos":[1130,1225],"source":" For more information, see [CRT Library Features](../c-runtime-library/crt-library-features.md)."},{"content":"For information about how to use iterators, see <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept>.","pos":[1226,1336],"source":" For information about how to use iterators, see [Checked Iterators](../standard-library/checked-iterators.md)."},{"content":"The C++ standard describes how member functions might cause iterators to a container to become invalid.","pos":[1343,1446]},{"content":"Two examples are:","pos":[1447,1464]},{"content":"Erasing an element from a container causes iterators to the element to become invalid.","pos":[1474,1560]},{"pos":[1570,1705],"content":"Increasing the size of a <bpt id=\"p1\">[</bpt>vector<ept id=\"p1\">](../standard-library/vector.md)</ept> (push or insert) causes iterators into the <ph id=\"ph1\">`vector`</ph> to become invalid.","source":"Increasing the size of a [vector](../standard-library/vector.md) (push or insert) causes iterators into the `vector` to become invalid."},{"pos":[1714,1721],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"If you compile the following program in debug mode, at run time it will assert and terminate.","pos":[1725,1818]},{"pos":[2278,2285],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"You can use the symbol <bpt id=\"p1\">[</bpt>_HAS_ITERATOR_DEBUGGING<ept id=\"p1\">](../standard-library/has-iterator-debugging.md)</ept> to turn off the iterator debugging feature in a debug build.","pos":[2289,2445],"source":"You can use the symbol [_HAS_ITERATOR_DEBUGGING](../standard-library/has-iterator-debugging.md) to turn off the iterator debugging feature in a debug build."},{"content":"The following program does not assert, but still triggers undefined behavior.","pos":[2446,2523]},{"pos":[2531,2708],"content":"[!IMPORTANT]\n Use `_ITERATOR_DEBUG_LEVEL` to control `_HAS_ITERATOR_DEBUGGING`. For more information, see [_ITERATOR_DEBUG_LEVEL](../standard-library/iterator-debug-level.md).","leadings":["","> "],"nodes":[{"content":" Use `_ITERATOR_DEBUG_LEVEL` to control `_HAS_ITERATOR_DEBUGGING`. For more information, see [_ITERATOR_DEBUG_LEVEL](../standard-library/iterator-debug-level.md).","pos":[13,175],"nodes":[{"content":"Use <ph id=\"ph1\">`_ITERATOR_DEBUG_LEVEL`</ph> to control <ph id=\"ph2\">`_HAS_ITERATOR_DEBUGGING`</ph>.","pos":[1,66],"source":" Use `_ITERATOR_DEBUG_LEVEL` to control `_HAS_ITERATOR_DEBUGGING`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>_ITERATOR_DEBUG_LEVEL<ept id=\"p1\">](../standard-library/iterator-debug-level.md)</ept>.","pos":[67,162],"source":" For more information, see [_ITERATOR_DEBUG_LEVEL](../standard-library/iterator-debug-level.md)."}]}]},{"pos":[3269,3276],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"An assert also occurs if you attempt to use an iterator before it is initialized, as shown here:","pos":[3280,3376]},{"pos":[3556,3563],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following code example causes an assertion because the two iterators to the <bpt id=\"p1\">[</bpt>for_each<ept id=\"p1\">](../standard-library/algorithm-functions.md#for_each)</ept> algorithm are incompatible.","pos":[3567,3738],"source":"The following code example causes an assertion because the two iterators to the [for_each](../standard-library/algorithm-functions.md#for_each) algorithm are incompatible."},{"content":"Algorithms check to determine whether the iterators that are supplied to them are referencing the same container.","pos":[3739,3852]},{"content":"Notice that this example uses the lambda expression <ph id=\"ph1\">`[] (int&amp; elem) { elem *= 2; }`</ph> instead of a functor.","pos":[4298,4403],"source":"Notice that this example uses the lambda expression `[] (int& elem) { elem *= 2; }` instead of a functor."},{"content":"Although this choice has no bearing on the assert failure—a similar functor would cause the same failure—lambdas are a very useful way to accomplish compact function object tasks.","pos":[4404,4583]},{"content":"For more information about lambda expressions, see <bpt id=\"p1\">[</bpt>Lambda Expressions<ept id=\"p1\">](../cpp/lambda-expressions-in-cpp.md)</ept>.","pos":[4584,4693],"source":" For more information about lambda expressions, see [Lambda Expressions](../cpp/lambda-expressions-in-cpp.md)."},{"pos":[4702,4709],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[4713,4852],"content":"Debug iterator checking also causes an iterator variable that's declared in a <ph id=\"ph1\">`for`</ph> loop to be out of scope when the <ph id=\"ph2\">`for`</ph> loop scope ends.","source":"Debug iterator checking also causes an iterator variable that's declared in a `for` loop to be out of scope when the `for` loop scope ends."},{"pos":[5192,5199],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"Debug iterators have non-trivial destructors.","pos":[5203,5248]},{"content":"If a destructor does not run, for whatever reason, access violations and data corruption might occur.","pos":[5249,5350]},{"content":"Consider this example:","pos":[5351,5373]},{"pos":[5870,5878],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[5882,5950],"content":"<bpt id=\"p1\">[</bpt>STL Overview<ept id=\"p1\">](../standard-library/cpp-standard-library-overview.md)</ept>","source":"[STL Overview](../standard-library/cpp-standard-library-overview.md)"}],"content":"---\ntitle: \"Debug Iterator Support | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_HAS_ITERATOR_DEBUGGING symbol\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"Safe Libraries\"\n  - \"Safe Libraries, Standard C++ Library\"\n  - \"Safe Standard C++ Library\"\n  - \"Standard C++ Library, debug iterator support\"\n  - \"iterators, debug iterator support\"\n  - \"iterators, incompatible\"\n  - \"incompatible iterators\"\n  - \"debug iterator support\"\nms.assetid: f3f5bd15-4be8-4d64-a4d0-8bc0761c68b6\ncaps.latest.revision: 22\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Debug Iterator Support\nThe Visual C++ run-time library detects incorrect iterator use, and asserts and displays a dialog box at run time. To enable debug iterator support, you must use a debug version of a C run-time library to compile your program. For more information, see [CRT Library Features](../c-runtime-library/crt-library-features.md). For information about how to use iterators, see [Checked Iterators](../standard-library/checked-iterators.md).  \n  \n The C++ standard describes how member functions might cause iterators to a container to become invalid. Two examples are:  \n  \n-   Erasing an element from a container causes iterators to the element to become invalid.  \n  \n-   Increasing the size of a [vector](../standard-library/vector.md) (push or insert) causes iterators into the `vector` to become invalid.  \n  \n## Example  \n If you compile the following program in debug mode, at run time it will assert and terminate.  \n  \n```cpp  \n/* compile with /EHsc /MDd */  \n#include <vector>  \n#include <iostream>  \n  \nint main() {  \n   std::vector<int> v ;  \n  \n   v.push_back(10);  \n   v.push_back(15);  \n   v.push_back(20);  \n  \n   std::vector<int>::iterator i = v.begin();  \n   ++i;  \n  \n   std::vector<int>::iterator j = v.end();  \n   --j;  \n  \n   std::cout<<*j<<'\\n';  \n  \n   v.insert(i,25);   \n  \n   std::cout<<*j<<'\\n'; // Using an old iterator after an insert  \n}  \n```  \n  \n## Example  \n You can use the symbol [_HAS_ITERATOR_DEBUGGING](../standard-library/has-iterator-debugging.md) to turn off the iterator debugging feature in a debug build. The following program does not assert, but still triggers undefined behavior.  \n  \n> [!IMPORTANT]\n>  Use `_ITERATOR_DEBUG_LEVEL` to control `_HAS_ITERATOR_DEBUGGING`. For more information, see [_ITERATOR_DEBUG_LEVEL](../standard-library/iterator-debug-level.md).  \n  \n```cpp  \n// iterator_debugging.cpp  \n// compile with: /EHsc /MDd  \n#define _HAS_ITERATOR_DEBUGGING 0  \n#include <vector>  \n#include <iostream>  \n  \nint main() {  \n   std::vector<int> v ;  \n  \n   v.push_back(10);  \n   v.push_back(15);  \n   v.push_back(20);  \n  \n   std::vector<int>::iterator i = v.begin();  \n   ++i;  \n  \n   std::vector<int>::iterator j = v.end();  \n   --j;  \n  \n   std::cout<<*j<<'\\n';  \n  \n   v.insert(i,25);   \n  \n   std::cout<<*j<<'\\n'; // Using an old iterator after an insert  \n}  \n```  \n  \n```Output  \n20  \n-572662307  \n```  \n  \n## Example  \n An assert also occurs if you attempt to use an iterator before it is initialized, as shown here:  \n  \n```cpp  \n/* compile with /EHsc /MDd */  \n#include <string>  \nusing namespace std;  \nint main() {  \n   string::iterator i1, i2;  \n   if (i1 == i2)  \n      ;  \n}  \n```  \n  \n## Example  \n The following code example causes an assertion because the two iterators to the [for_each](../standard-library/algorithm-functions.md#for_each) algorithm are incompatible. Algorithms check to determine whether the iterators that are supplied to them are referencing the same container.  \n  \n```cpp  \n/* compile with /EHsc /MDd */  \n#include <algorithm>  \n#include <vector>  \nusing namespace std;  \n  \nint main()  \n{  \n    vector<int> v1;  \n    vector<int> v2;  \n  \n    v1.push_back(10);  \n    v1.push_back(20);  \n  \n    v2.push_back(10);  \n    v2.push_back(20);  \n  \n    // The next line will assert because v1 and v2 are  \n    // incompatible.  \n    for_each(v1.begin(), v2.end(), [] (int& elem) { elem *= 2; } );  \n}  \n```  \n  \n Notice that this example uses the lambda expression `[] (int& elem) { elem *= 2; }` instead of a functor. Although this choice has no bearing on the assert failure—a similar functor would cause the same failure—lambdas are a very useful way to accomplish compact function object tasks. For more information about lambda expressions, see [Lambda Expressions](../cpp/lambda-expressions-in-cpp.md).  \n  \n## Example  \n Debug iterator checking also causes an iterator variable that's declared in a `for` loop to be out of scope when the `for` loop scope ends.  \n  \n```cpp  \n// debug_iterator.cpp  \n// compile with: /EHsc /MDd  \n#include <vector>  \n#include <iostream>  \nint main() {  \n   std::vector<int> v ;  \n  \n   v.push_back(10);  \n   v.push_back(15);  \n   v.push_back(20);  \n  \n   for (std::vector<int>::iterator i = v.begin() ; i != v.end(); ++i)  \n   ;  \n   --i;   // C2065  \n}  \n```  \n  \n## Example  \n Debug iterators have non-trivial destructors. If a destructor does not run, for whatever reason, access violations and data corruption might occur. Consider this example:  \n  \n```cpp  \n/* compile with: /EHsc /MDd */  \n#include <vector>  \nstruct base {  \n   // FIX: uncomment the next line  \n   // virtual ~base() {}  \n};  \n  \nstruct derived : base {  \n   std::vector<int>::iterator m_iter;  \n   derived( std::vector<int>::iterator iter ) : m_iter( iter ) {}  \n   ~derived() {}  \n};  \n  \nint main() {  \n   std::vector<int> vect( 10 );  \n   base * pb = new derived( vect.begin() );  \n   delete pb;  // doesn't call ~derived()  \n   // access violation  \n}  \n```  \n  \n## See Also  \n [STL Overview](../standard-library/cpp-standard-library-overview.md)\n\n\n\n\n"}