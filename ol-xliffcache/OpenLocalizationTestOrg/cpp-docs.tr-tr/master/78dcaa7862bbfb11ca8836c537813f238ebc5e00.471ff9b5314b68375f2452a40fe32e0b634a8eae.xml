{"nodes":[{"pos":[12,53],"content":"condition_variable Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"condition_variable Class | Microsoft Docs","pos":[0,41]}]},{"content":"condition_variable Class","pos":[597,621]},{"content":"Use the <ph id=\"ph1\">`condition_variable`</ph> class to wait for an event when you have a <ph id=\"ph2\">`mutex`</ph> of type <ph id=\"ph3\">`unique_lock&lt;mutex&gt;`</ph>.","pos":[622,731],"source":"Use the `condition_variable` class to wait for an event when you have a `mutex` of type `unique_lock<mutex>`."},{"content":"Objects of this type may have better performance than objects of type <bpt id=\"p1\">[</bpt>condition_variable_any&lt;unique_lock<ph id=\"ph1\">\\&lt;</ph>mutex&gt;&gt;<ept id=\"p1\">](../standard-library/condition-variable-any-class.md)</ept>.","pos":[732,901],"source":" Objects of this type may have better performance than objects of type [condition_variable_any<unique_lock\\<mutex>>](../standard-library/condition-variable-any-class.md)."},{"content":"Syntax","pos":[910,916]},{"content":"Members","pos":[964,971]},{"content":"Public Constructors","pos":[981,1000]},{"content":"Name","pos":[1007,1011]},{"content":"Description","pos":[1012,1023]},{"content":"condition_variable::condition_variable Constructor","pos":[1062,1112]},{"pos":[1167,1208],"content":"Constructs a <ph id=\"ph1\">`condition_variable`</ph> object.","source":"Constructs a `condition_variable` object."},{"content":"Public Methods","pos":[1219,1233]},{"content":"Name","pos":[1240,1244]},{"content":"Description","pos":[1245,1256]},{"content":"condition_variable::native_handle Method","pos":[1295,1335]},{"content":"Returns the implementation-specific type representing the condition_variable handle.","pos":[1380,1464]},{"content":"condition_variable::notify_all","pos":[1470,1500]},{"pos":[1542,1616],"content":"Unblocks all threads that are waiting for the <ph id=\"ph1\">`condition_variable`</ph> object.","source":"Unblocks all threads that are waiting for the `condition_variable` object."},{"content":"condition_variable::notify_one","pos":[1622,1652]},{"pos":[1694,1775],"content":"Unblocks one of the threads that are waiting for the <ph id=\"ph1\">`condition_variable`</ph> object.","source":"Unblocks one of the threads that are waiting for the `condition_variable` object."},{"content":"condition_variable::wait","pos":[1781,1805]},{"content":"Blocks a thread.","pos":[1841,1857]},{"content":"condition_variable::wait_for","pos":[1863,1891]},{"content":"Blocks a thread, and sets a time interval after which the thread unblocks.","pos":[1931,2005]},{"content":"condition_variable::wait_until","pos":[2011,2041]},{"content":"Blocks a thread, and sets a maximum point in time at which the thread unblocks.","pos":[2083,2162]},{"content":"Requirements","pos":[2172,2184]},{"pos":[2188,2218],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> condition_variable","source":"**Header:** condition_variable"},{"pos":[2225,2243],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[2320,2370],"content":"condition_variable::condition_variable Constructor"},{"pos":[2374,2415],"content":"Constructs a <ph id=\"ph1\">`condition_variable`</ph> object.","source":"Constructs a `condition_variable` object."},{"content":"Remarks","pos":[2460,2467]},{"content":"If not enough memory is available, the constructor throws a <bpt id=\"p1\">[</bpt>system_error<ept id=\"p1\">](../standard-library/system-error-class.md)</ept> object that has a <ph id=\"ph1\">`not_enough_memory`</ph> error code.","pos":[2471,2638],"source":"If not enough memory is available, the constructor throws a [system_error](../standard-library/system-error-class.md) object that has a `not_enough_memory` error code."},{"content":"If the object cannot be constructed because some other resource is not available, the constructor throws a <ph id=\"ph1\">`system_error`</ph> object that has a <ph id=\"ph2\">`resource_unavailable_try_again`</ph> error code.","pos":[2639,2823],"source":" If the object cannot be constructed because some other resource is not available, the constructor throws a `system_error` object that has a `resource_unavailable_try_again` error code."},{"pos":[2890,2923],"content":"condition_variable::native_handle"},{"content":"Returns the implementation-specific type that represents the condition_variable handle.","pos":[2927,3014]},{"content":"Return Value","pos":[3073,3085]},{"pos":[3110,3182],"content":"is defined as a pointer to Concurrency Runtime internal data structures."},{"pos":[3246,3276],"content":"condition_variable::notify_all"},{"pos":[3280,3354],"content":"Unblocks all threads that are waiting for the <ph id=\"ph1\">`condition_variable`</ph> object.","source":"Unblocks all threads that are waiting for the `condition_variable` object."},{"pos":[3459,3489],"content":"condition_variable::notify_one"},{"pos":[3493,3573],"content":"Unblocks one of the threads that are waiting on the <ph id=\"ph1\">`condition_variable`</ph> object.","source":"Unblocks one of the threads that are waiting on the `condition_variable` object."},{"pos":[3672,3696],"content":"condition_variable::wait"},{"content":"Blocks a thread.","pos":[3700,3716]},{"content":"Parameters","pos":[3855,3865]},{"content":"A <bpt id=\"p1\">[</bpt>unique_lock<ph id=\"ph1\">\\&lt;</ph>mutex&gt;<ept id=\"p1\">](../standard-library/unique-lock-class.md)</ept> object.","pos":[3878,3951],"source":" A [unique_lock\\<mutex>](../standard-library/unique-lock-class.md) object."},{"content":"Any expression that returns <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[3968,4014],"source":" Any expression that returns `true` or `false`."},{"content":"Remarks","pos":[4024,4031]},{"content":"The first method blocks until the <ph id=\"ph1\">`condition_variable`</ph> object is signaled by a call to <bpt id=\"p1\">[</bpt>notify_one<ept id=\"p1\">](#condition_variable__notify_one_method)</ept> or <bpt id=\"p2\">[</bpt>notify_all<ept id=\"p2\">](#condition_variable__notify_all_method)</ept>.","pos":[4035,4231],"source":"The first method blocks until the `condition_variable` object is signaled by a call to [notify_one](#condition_variable__notify_one_method) or [notify_all](#condition_variable__notify_all_method)."},{"content":"It can also wake up spuriously.","pos":[4232,4263]},{"content":"In effect, the second method executes the following code.","pos":[4270,4327]},{"pos":[4437,4465],"content":"condition_variable::wait_for"},{"content":"Blocks a thread, and sets a time interval after which the thread unblocks.","pos":[4469,4543]},{"content":"Parameters","pos":[4872,4882]},{"content":"A <bpt id=\"p1\">[</bpt>unique_lock<ph id=\"ph1\">\\&lt;</ph>mutex&gt;<ept id=\"p1\">](../standard-library/unique-lock-class.md)</ept> object.","pos":[4895,4968],"source":" A [unique_lock\\<mutex>](../standard-library/unique-lock-class.md) object."},{"content":"A <ph id=\"ph1\">`chrono::duration`</ph> object that specifies the amount of time before the thread wakes up.","pos":[4989,5078],"source":" A `chrono::duration` object that specifies the amount of time before the thread wakes up."},{"content":"Any expression that returns <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[5095,5141],"source":" Any expression that returns `true` or `false`."},{"content":"Return Value","pos":[5151,5163]},{"content":"The first method returns <ph id=\"ph1\">`cv_status::timeout`</ph> if the wait terminates when <ph id=\"ph2\">`Rel_time`</ph> has elapsed.","pos":[5167,5264],"source":"The first method returns `cv_status::timeout` if the wait terminates when `Rel_time` has elapsed."},{"content":"Otherwise, the method returns <ph id=\"ph1\">`cv_status::no_timeout`</ph>.","pos":[5265,5319],"source":" Otherwise, the method returns `cv_status::no_timeout`."},{"pos":[5326,5372],"content":"The second method returns the value of <ph id=\"ph1\">`Pred`</ph>.","source":"The second method returns the value of `Pred`."},{"content":"Remarks","pos":[5382,5389]},{"content":"The first method blocks until the <ph id=\"ph1\">`condition_variable`</ph> object is signaled by a call to <bpt id=\"p1\">[</bpt>notify_one<ept id=\"p1\">](#condition_variable__notify_one_method)</ept> or <bpt id=\"p2\">[</bpt>notify_all<ept id=\"p2\">](#condition_variable__notify_all_method)</ept> or until the time interval <ph id=\"ph2\">`Rel_time`</ph> has elapsed.","pos":[5393,5639],"source":"The first method blocks until the `condition_variable` object is signaled by a call to [notify_one](#condition_variable__notify_one_method) or [notify_all](#condition_variable__notify_all_method) or until the time interval `Rel_time` has elapsed."},{"content":"It can also wake up spuriously.","pos":[5640,5671]},{"content":"In effect, the second method executes the following code.","pos":[5678,5735]},{"pos":[5917,5947],"content":"condition_variable::wait_until"},{"content":"Blocks a thread, and sets a maximum point in time at which the thread unblocks.","pos":[5951,6030]},{"content":"Parameters","pos":[6586,6596]},{"content":"A <bpt id=\"p1\">[</bpt>unique_lock<ph id=\"ph1\">\\&lt;</ph>mutex&gt;<ept id=\"p1\">](../standard-library/unique-lock-class.md)</ept> object.","pos":[6609,6682],"source":" A [unique_lock\\<mutex>](../standard-library/unique-lock-class.md) object."},{"content":"A <bpt id=\"p1\">[</bpt>chrono::time_point<ept id=\"p1\">](../standard-library/time-point-class.md)</ept> object.","pos":[6703,6774],"source":" A [chrono::time_point](../standard-library/time-point-class.md) object."},{"content":"Any expression that returns <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[6791,6837],"source":" Any expression that returns `true` or `false`."},{"content":"Return Value","pos":[6847,6859]},{"content":"Methods that return a <ph id=\"ph1\">`cv_status`</ph> type return <ph id=\"ph2\">`cv_status::timeout`</ph> if the wait terminates when <ph id=\"ph3\">`Abs_time`</ph> elapses.","pos":[6863,6977],"source":"Methods that return a `cv_status` type return `cv_status::timeout` if the wait terminates when `Abs_time` elapses."},{"content":"Otherwise, the methods return <ph id=\"ph1\">`cv_status::no_timeout`</ph>.","pos":[6978,7032],"source":" Otherwise, the methods return `cv_status::no_timeout`."},{"pos":[7039,7095],"content":"Methods that return a <ph id=\"ph1\">`bool`</ph> return the value of <ph id=\"ph2\">`Pred`</ph>.","source":"Methods that return a `bool` return the value of `Pred`."},{"content":"Remarks","pos":[7105,7112]},{"content":"The first method blocks until the <ph id=\"ph1\">`condition_variable`</ph> object is signaled by a call to <bpt id=\"p1\">[</bpt>notify_one<ept id=\"p1\">](#condition_variable__notify_one_method)</ept> or <bpt id=\"p2\">[</bpt>notify_all<ept id=\"p2\">](#condition_variable__notify_all_method)</ept> or until <ph id=\"ph2\">`Abs_time`</ph>.","pos":[7116,7332],"source":"The first method blocks until the `condition_variable` object is signaled by a call to [notify_one](#condition_variable__notify_one_method) or [notify_all](#condition_variable__notify_all_method) or until `Abs_time`."},{"content":"It can also wake up spuriously.","pos":[7333,7364]},{"content":"In effect, the second method executes the following code","pos":[7371,7427]},{"content":"The third and fourth methods use a pointer to an object of type <ph id=\"ph1\">`xtime`</ph> to replace the <ph id=\"ph2\">`chrono::time_point`</ph> object.","pos":[7554,7669],"source":"The third and fourth methods use a pointer to an object of type `xtime` to replace the `chrono::time_point` object."},{"content":"The <ph id=\"ph1\">`xtime`</ph> object specifies the maximum amount of time to wait for a signal.","pos":[7670,7747],"source":" The `xtime` object specifies the maximum amount of time to wait for a signal."},{"content":"See Also","pos":[7756,7764]},{"content":"Header Files Reference","pos":[7769,7791]},{"content":"&lt;condition_variable&gt;","pos":[7856,7876],"source":"<condition_variable>"}],"content":"---\ntitle: \"condition_variable Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"condition_variable/std::condition_variable\"\ndev_langs: \n  - \"C++\"\nms.assetid: 80b1295c-b73d-4d46-b664-6e183f2eec1b\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# condition_variable Class\nUse the `condition_variable` class to wait for an event when you have a `mutex` of type `unique_lock<mutex>`. Objects of this type may have better performance than objects of type [condition_variable_any<unique_lock\\<mutex>>](../standard-library/condition-variable-any-class.md).  \n  \n## Syntax  \n  \n```\nclass condition_variable;\n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[condition_variable::condition_variable Constructor](#condition_variable__condition_variable_constructor)|Constructs a `condition_variable` object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[condition_variable::native_handle Method](#condition_variable__native_handle_method)|Returns the implementation-specific type representing the condition_variable handle.|  \n|[condition_variable::notify_all](#condition_variable__notify_all_method)|Unblocks all threads that are waiting for the `condition_variable` object.|  \n|[condition_variable::notify_one](#condition_variable__notify_one_method)|Unblocks one of the threads that are waiting for the `condition_variable` object.|  \n|[condition_variable::wait](#condition_variable__wait_method)|Blocks a thread.|  \n|[condition_variable::wait_for](#condition_variable__wait_for_method)|Blocks a thread, and sets a time interval after which the thread unblocks.|  \n|[condition_variable::wait_until](#condition_variable__wait_until_method)|Blocks a thread, and sets a maximum point in time at which the thread unblocks.|  \n  \n## Requirements  \n **Header:** condition_variable  \n  \n **Namespace:** std  \n  \n##  <a name=\"condition_variable__condition_variable_constructor\"></a>  condition_variable::condition_variable Constructor  \n Constructs a `condition_variable` object.  \n  \n```\ncondition_variable();\n```  \n  \n### Remarks  \n If not enough memory is available, the constructor throws a [system_error](../standard-library/system-error-class.md) object that has a `not_enough_memory` error code. If the object cannot be constructed because some other resource is not available, the constructor throws a `system_error` object that has a `resource_unavailable_try_again` error code.  \n  \n##  <a name=\"condition_variable__native_handle_method\"></a>  condition_variable::native_handle  \n Returns the implementation-specific type that represents the condition_variable handle.  \n  \n```\nnative_handle_type native_handle();\n```  \n  \n### Return Value  \n `native_handle_type` is defined as a pointer to Concurrency Runtime internal data structures.  \n  \n##  <a name=\"condition_variable__notify_all_method\"></a>  condition_variable::notify_all  \n Unblocks all threads that are waiting for the `condition_variable` object.  \n  \n```\nvoid notify_all() noexcept;\n```  \n  \n##  <a name=\"condition_variable__notify_one_method\"></a>  condition_variable::notify_one  \n Unblocks one of the threads that are waiting on the `condition_variable` object.  \n  \n```\nvoid notify_one() noexcept;\n```  \n  \n##  <a name=\"condition_variable__wait_method\"></a>  condition_variable::wait  \n Blocks a thread.  \n  \n```\nvoid wait(unique_lock<mutex>& Lck);\n\ntemplate <class Predicate>\nvoid wait(unique_lock<mutex>& Lck, Predicate Pred);\n```  \n  \n### Parameters  \n `Lck`  \n A [unique_lock\\<mutex>](../standard-library/unique-lock-class.md) object.  \n  \n `Pred`  \n Any expression that returns `true` or `false`.  \n  \n### Remarks  \n The first method blocks until the `condition_variable` object is signaled by a call to [notify_one](#condition_variable__notify_one_method) or [notify_all](#condition_variable__notify_all_method). It can also wake up spuriously.  \n  \n In effect, the second method executes the following code.  \n  \n```cpp\nwhile(!Pred())\n    wait(Lck);\n```    \n  \n##  <a name=\"condition_variable__wait_for_method\"></a>  condition_variable::wait_for  \n Blocks a thread, and sets a time interval after which the thread unblocks.  \n  \n```\ntemplate <class Rep, class Period>\ncv_status wait_for(\n    unique_lock<mutex>& Lck,\n    const chrono::duration<Rep, Period>& Rel_time);\n\ntemplate <class Rep, class Period, class Predicate>\nbool wait_for(\n    unique_lock<mutex>& Lck,\n    const chrono::duration<Rep, Period>& Rel_time, \n    Predicate Pred);\n```  \n  \n### Parameters  \n `Lck`  \n A [unique_lock\\<mutex>](../standard-library/unique-lock-class.md) object.  \n  \n `Rel_time`  \n A `chrono::duration` object that specifies the amount of time before the thread wakes up.  \n  \n `Pred`  \n Any expression that returns `true` or `false`.  \n  \n### Return Value  \n The first method returns `cv_status::timeout` if the wait terminates when `Rel_time` has elapsed. Otherwise, the method returns `cv_status::no_timeout`.  \n  \n The second method returns the value of `Pred`.  \n  \n### Remarks  \n The first method blocks until the `condition_variable` object is signaled by a call to [notify_one](#condition_variable__notify_one_method) or [notify_all](#condition_variable__notify_all_method) or until the time interval `Rel_time` has elapsed. It can also wake up spuriously.  \n  \n In effect, the second method executes the following code.  \n  \n```cpp\nwhile(!Pred())\n    if(wait_for(Lck, Rel_time) == cv_status::timeout)\n    return Pred();\n\nreturn true;\n```  \n  \n##  <a name=\"condition_variable__wait_until_method\"></a>  condition_variable::wait_until  \n Blocks a thread, and sets a maximum point in time at which the thread unblocks.  \n  \n```\ntemplate <class Clock, class Duration>\ncv_status wait_until(\n    unique_lock<mutex>& Lck,\n    const chrono::time_point<Clock, Duration>& Abs_time);\n\ntemplate <class Clock, class Duration, class Predicate>\nbool wait_until(\n    unique_lock<mutex>& Lck,\n    const chrono::time_point<Clock, Duration>& Abs_time, \n    Predicate Pred);\n\ncv_status wait_until(\n    unique_lock<mutex>& Lck,\n    const xtime* Abs_time);\n\ntemplate <class Predicate>\nbool wait_until(\n    unique_lock<mutex>& Lck,\n    const xtime* Abs_time, \n    Predicate Pred);\n```  \n  \n### Parameters  \n `Lck`  \n A [unique_lock\\<mutex>](../standard-library/unique-lock-class.md) object.  \n  \n `Abs_time`  \n A [chrono::time_point](../standard-library/time-point-class.md) object.  \n  \n `Pred`  \n Any expression that returns `true` or `false`.  \n  \n### Return Value  \n Methods that return a `cv_status` type return `cv_status::timeout` if the wait terminates when `Abs_time` elapses. Otherwise, the methods return `cv_status::no_timeout`.  \n  \n Methods that return a `bool` return the value of `Pred`.  \n  \n### Remarks  \n The first method blocks until the `condition_variable` object is signaled by a call to [notify_one](#condition_variable__notify_one_method) or [notify_all](#condition_variable__notify_all_method) or until `Abs_time`. It can also wake up spuriously.  \n  \n In effect, the second method executes the following code  \n  \n```cpp\nwhile(!Pred())\n    if(wait_until(Lck, Abs_time) == cv_status::timeout)\n    return Pred();\n\nreturn true;\n```  \n  \n The third and fourth methods use a pointer to an object of type `xtime` to replace the `chrono::time_point` object. The `xtime` object specifies the maximum amount of time to wait for a signal.  \n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)   \n [<condition_variable>](../standard-library/condition-variable.md)\n\n\n\n"}