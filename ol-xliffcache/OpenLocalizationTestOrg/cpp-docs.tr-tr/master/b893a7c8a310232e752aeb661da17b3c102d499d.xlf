<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="tr-tr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b893a7c8a310232e752aeb661da17b3c102d499d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\relational-operators-equal-and-equal.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">808c500a05e550f7515028d5a33cddd54871046d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">09d34d4b5977662ebaf1d567a3f34ddb6f0e14e5</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Relational Operators: <ph id="ph1">&amp;lt;</ph>, <ph id="ph2">&amp;gt;</ph>, <ph id="ph3">&amp;lt;</ph>=, and <ph id="ph4">&amp;gt;</ph>= | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Relational Operators: <ph id="ph1">&amp;lt;</ph>, <ph id="ph2">&amp;gt;</ph>, <ph id="ph3">&amp;lt;</ph>=, and</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The binary relational operators determine the following relationships:</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Less than (<bpt id="p1">**</bpt><ph id="ph1">\&lt;</ph><ept id="p1">**</ept>)</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Greater than (<bpt id="p1">**</bpt><ph id="ph1">&gt;</ph><ept id="p1">**</ept>)</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Less than or equal to (<bpt id="p1">**</bpt><ph id="ph1">\&lt;=</ph><ept id="p1">**</ept>)</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Greater than or equal to (<bpt id="p1">**</bpt><ph id="ph1">&gt;=</ph><ept id="p1">**</ept>)</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The relational operators have left-to-right associativity.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Both operands of relational operators must be of arithmetic or pointer type.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>They yield values of type <ph id="ph1">`bool`</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The value returned is <bpt id="p1">**</bpt>false<ept id="p1">**</ept> (0) if the relationship in the expression is false; otherwise, the value returned is <bpt id="p2">**</bpt>true<ept id="p2">**</ept> (1).</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The expressions in the preceding example must be enclosed in parentheses because the stream insertion operator (<bpt id="p1">**</bpt><ph id="ph1">&lt;&lt;</ph><ept id="p1">**</ept>) has higher precedence than the relational operators.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Therefore, the first expression without the parentheses would be evaluated as:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The usual arithmetic conversions covered in <bpt id="p1">[</bpt>Standard Conversions<ept id="p1">](standard-conversions.md)</ept> are applied to operands of arithmetic types.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Comparing pointers</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>When two pointers to objects of the same type are compared, the result is determined by the location of the objects pointed to in the program's address space.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Pointers can also be compared to a constant expression that evaluates to 0 or to a pointer of type void *.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If a pointer comparison is made against a pointer of type void <ph id="ph1">\*</ph>, the other pointer is implicitly converted to type void <ph id="ph2">\*</ph>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Then the comparison is made.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Two pointers of different types cannot be compared unless:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>One type is a class type derived from the other type.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>At least one of the pointers is explicitly converted (cast) to type void *.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>(The other pointer is implicitly converted to type void <ph id="ph1">\*</ph> for the conversion.)</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Two pointers of the same type that point to the same object are guaranteed to compare equal.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If two pointers to nonstatic members of an object are compared, the following rules apply:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If the class type is not a union, and if the two members are not separated by an <bpt id="p1">*</bpt>access-specifier<ept id="p1">*</ept>, such as public, protected, or private, the pointer to the member declared last will compare greater than the pointer to the member declared earlier.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If the two members are separated by an <bpt id="p1">*</bpt>access-specifier<ept id="p1">*</ept>, the results are undefined.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If the class type is a union, pointers to different data members in that union compare equal.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If two pointers point to elements of the same array or to the element one beyond the end of the array, the pointer to the object with the higher subscript compares higher.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Comparison of pointers is guaranteed valid only when the pointers refer to objects in the same array or to the location one past the end of the array.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Expressions with Binary Operators</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>C++ Built-in Operators, Precedence and Associativity</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>C Relational and Equality Operators</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>