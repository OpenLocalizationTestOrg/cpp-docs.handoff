{"nodes":[{"pos":[12,43],"content":"auto_ptr Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"auto_ptr Class | Microsoft Docs","pos":[0,31]}]},{"pos":[662,676],"content":"auto_ptr Class","linkify":"auto_ptr Class","nodes":[{"content":"auto_ptr Class","pos":[0,14]}]},{"content":"Wraps a smart pointer around a resource that ensures the resource is destroyed automatically when control leaves a block.","pos":[677,798]},{"content":"The more capable <ph id=\"ph1\">`unique_ptr`</ph> class supersedes <ph id=\"ph2\">`auto_ptr`</ph>.","pos":[805,863],"source":"The more capable `unique_ptr` class supersedes `auto_ptr`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>unique_ptr Class<ept id=\"p1\">](../standard-library/unique-ptr-class.md)</ept>.","pos":[864,950],"source":" For more information, see [unique_ptr Class](../standard-library/unique-ptr-class.md)."},{"pos":[957,1103],"content":"For more information about <ph id=\"ph1\">`throw()`</ph> and exception handling, see <bpt id=\"p1\">[</bpt>Exception Specifications (throw)<ept id=\"p1\">](../cpp/exception-specifications-throw-cpp.md)</ept>.","source":"For more information about `throw()` and exception handling, see [Exception Specifications (throw)](../cpp/exception-specifications-throw-cpp.md)."},{"pos":[1112,1118],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1757,1767],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The <ph id=\"ph1\">`auto_ptr`</ph> from which to get an existing resource.","pos":[1783,1837],"source":" The `auto_ptr` from which to get an existing resource."},{"content":"The pointer specified to replace the stored pointer.","pos":[1854,1906]},{"pos":[1915,1922],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template class describes a smart pointer, called an <ph id=\"ph1\">`auto_ptr,`</ph> to an allocated object.","pos":[1926,2017],"source":"The template class describes a smart pointer, called an `auto_ptr,` to an allocated object."},{"content":"The pointer must be either null or designate an object allocated by <ph id=\"ph1\">`new`</ph>.","pos":[2018,2092],"source":" The pointer must be either null or designate an object allocated by `new`."},{"content":"The <ph id=\"ph1\">`auto_ptr`</ph> transfers ownership if its stored value is assigned to another object.","pos":[2093,2178],"source":" The `auto_ptr` transfers ownership if its stored value is assigned to another object."},{"content":"(It replaces the stored value after a transfer with a null pointer.) The destructor for <ph id=\"ph1\">`auto_ptr&lt;Type&gt;`</ph> deletes the allocated object.","pos":[2179,2313],"source":" (It replaces the stored value after a transfer with a null pointer.) The destructor for `auto_ptr<Type>` deletes the allocated object."},{"content":"The <ph id=\"ph1\">`auto_ptr&lt;Type&gt;`</ph> ensures that an allocated object is automatically deleted when control leaves a block, even through a thrown exception.","pos":[2314,2454],"source":" The `auto_ptr<Type>` ensures that an allocated object is automatically deleted when control leaves a block, even through a thrown exception."},{"content":"You should not construct two <ph id=\"ph1\">`auto_ptr&lt;Type&gt;`</ph> objects that own the same object.","pos":[2455,2534],"source":" You should not construct two `auto_ptr<Type>` objects that own the same object."},{"content":"You can pass an <ph id=\"ph1\">`auto_ptr&lt;Type&gt;`</ph> object by value as an argument to a function call.","pos":[2541,2624],"source":"You can pass an `auto_ptr<Type>` object by value as an argument to a function call."},{"content":"An <ph id=\"ph1\">`auto_ptr`</ph> cannot be an element of any Standard Library container.","pos":[2625,2694],"source":" An `auto_ptr` cannot be an element of any Standard Library container."},{"content":"You cannot reliably manage a sequence of <ph id=\"ph1\">`auto_ptr&lt;Type&gt;`</ph> objects with a Standard Template Library container.","pos":[2695,2804],"source":" You cannot reliably manage a sequence of `auto_ptr<Type>` objects with a Standard Template Library container."},{"pos":[2813,2820],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"pos":[2830,2842],"content":"Constructors","linkify":"Constructors","nodes":[{"content":"Constructors","pos":[0,12]}]},{"pos":[2863,2894],"content":"<bpt id=\"p1\">[</bpt>auto_ptr<ept id=\"p1\">](#auto_ptr__auto_ptr)</ept>","source":"[auto_ptr](#auto_ptr__auto_ptr)"},{"pos":[2895,2942],"content":"The constructor for objects of type <ph id=\"ph1\">`auto_ptr`</ph>.","source":"The constructor for objects of type `auto_ptr`."},{"pos":[2953,2961],"content":"Typedefs","linkify":"Typedefs","nodes":[{"content":"Typedefs","pos":[0,8]}]},{"pos":[2982,3021],"content":"<bpt id=\"p1\">[</bpt>element_type<ept id=\"p1\">](#auto_ptr__element_type)</ept>","source":"[element_type](#auto_ptr__element_type)"},{"pos":[3022,3078],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Type`</ph>.","source":"The type is a synonym for the template parameter `Type`."},{"pos":[3089,3105],"content":"Member Functions","linkify":"Member Functions","nodes":[{"content":"Member Functions","pos":[0,16]}]},{"pos":[3126,3147],"content":"<bpt id=\"p1\">[</bpt>get<ept id=\"p1\">](#auto_ptr__get)</ept>","source":"[get](#auto_ptr__get)"},{"pos":[3148,3203],"content":"The member function returns the stored pointer <ph id=\"ph1\">`myptr`</ph>.","source":"The member function returns the stored pointer `myptr`."},{"pos":[3208,3237],"content":"<bpt id=\"p1\">[</bpt>release<ept id=\"p1\">](#auto_ptr__release)</ept>","source":"[release](#auto_ptr__release)"},{"pos":[3238,3347],"content":"The member replaces the stored pointer <ph id=\"ph1\">`myptr`</ph> with a null pointer and returns the previously stored pointer.","source":"The member replaces the stored pointer `myptr` with a null pointer and returns the previously stored pointer."},{"pos":[3352,3377],"content":"<bpt id=\"p1\">[</bpt>reset<ept id=\"p1\">](#auto_ptr__reset)</ept>","source":"[reset](#auto_ptr__reset)"},{"content":"The member function evaluates the expression <ph id=\"ph1\">`deleteÂ myptr`</ph>, but only if the stored pointer value <ph id=\"ph2\">`myptr`</ph> changes as a result of function call.","pos":[3378,3522],"source":"The member function evaluates the expression `deleteÂ myptr`, but only if the stored pointer value `myptr` changes as a result of function call."},{"content":"It then replaces the stored pointer with <ph id=\"ph1\">`ptr`</ph>.","pos":[3523,3570],"source":" It then replaces the stored pointer with `ptr`."},{"pos":[3581,3590],"content":"Operators","linkify":"Operators","nodes":[{"content":"Operators","pos":[0,9]}]},{"pos":[3611,3646],"content":"<bpt id=\"p1\">[</bpt>operator=<ept id=\"p1\">](#auto_ptr__operator_eq)</ept>","source":"[operator=](#auto_ptr__operator_eq)"},{"pos":[3647,3733],"content":"An assignment operator that transfers ownership from one <ph id=\"ph1\">`auto_ptr`</ph> object to another.","source":"An assignment operator that transfers ownership from one `auto_ptr` object to another."},{"pos":[3738,3775],"content":"<bpt id=\"p1\">[</bpt>operator*<ept id=\"p1\">](#auto_ptr__operator_star)</ept>","source":"[operator*](#auto_ptr__operator_star)"},{"pos":[3776,3834],"content":"The dereferencing operator for objects of type <ph id=\"ph1\">`auto_ptr`</ph>.","source":"The dereferencing operator for objects of type `auto_ptr`."},{"pos":[3839,3877],"content":"<bpt id=\"p1\">[</bpt>operator-&gt;<ept id=\"p1\">](#auto_ptr__operator-_gt_)</ept>","source":"[operator->](#auto_ptr__operator-_gt_)"},{"content":"The operator for allowing member access.","pos":[3878,3918]},{"pos":[3923,3993],"content":"<bpt id=\"p1\">[</bpt>operator auto_ptr<ph id=\"ph1\">\\&lt;</ph>Other&gt;<ept id=\"p1\">](#auto_ptr__operator_auto_ptr_lt_other_gt_)</ept>","source":"[operator auto_ptr\\<Other>](#auto_ptr__operator_auto_ptr_lt_other_gt_)"},{"pos":[3994,4058],"content":"Casts from one kind of <ph id=\"ph1\">`auto_ptr`</ph> to another kind of <ph id=\"ph2\">`auto_ptr`</ph>.","source":"Casts from one kind of `auto_ptr` to another kind of `auto_ptr`."},{"pos":[4063,4141],"content":"<bpt id=\"p1\">[</bpt>operator auto_ptr_ref<ph id=\"ph1\">\\&lt;</ph>Other&gt;<ept id=\"p1\">](#auto_ptr__operator_auto_ptr_ref_lt_other_gt_)</ept>","source":"[operator auto_ptr_ref\\<Other>](#auto_ptr__operator_auto_ptr_ref_lt_other_gt_)"},{"pos":[4142,4188],"content":"Casts from an <ph id=\"ph1\">`auto_ptr`</ph> to an <ph id=\"ph2\">`auto_ptr_ref`</ph>.","source":"Casts from an `auto_ptr` to an `auto_ptr_ref`."},{"pos":[4198,4210],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[4214,4235],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>memory&gt;","source":"**Header:** \\<memory>"},{"pos":[4242,4260],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[4270,4323],"content":"<bpt id=\"p1\">&lt;a name=\"auto_ptr__auto_ptr\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  auto_ptr::auto_ptr","linkify":"<a name=\"auto_ptr__auto_ptr\"></a>  auto_ptr::auto_ptr","source":"<a name=\"auto_ptr__auto_ptr\"></a>  auto_ptr::auto_ptr"},{"pos":[4327,4374],"content":"The constructor for objects of type <ph id=\"ph1\">`auto_ptr`</ph>.","source":"The constructor for objects of type `auto_ptr`."},{"pos":[4601,4611],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The pointer to the object that <ph id=\"ph1\">`auto_ptr`</ph> encapsulates.","pos":[4625,4680],"source":" The pointer to the object that `auto_ptr` encapsulates."},{"content":"The <ph id=\"ph1\">`auto_ptr`</ph> object to be copied by the constructor.","pos":[4699,4753],"source":" The `auto_ptr` object to be copied by the constructor."},{"pos":[4763,4770],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first constructor stores <ph id=\"ph1\">` ptr`</ph> in <bpt id=\"p1\">**</bpt>myptr<ept id=\"p1\">**</ept>, the stored pointer to the allocated object.","pos":[4774,4867],"source":"The first constructor stores ` ptr` in **myptr**, the stored pointer to the allocated object."},{"content":"The second constructor transfers ownership of the pointer stored in <ph id=\"ph1\">` right`</ph>, by storing <ph id=\"ph2\">` right`</ph>.","pos":[4868,4966],"source":" The second constructor transfers ownership of the pointer stored in ` right`, by storing ` right`."},{"content":"<bpt id=\"p1\">[</bpt>release<ept id=\"p1\">](#auto_ptr__release)</ept> in <bpt id=\"p2\">**</bpt>myptr<ept id=\"p2\">**</ept>.","pos":[4967,5010],"source":"[release](#auto_ptr__release) in **myptr**."},{"content":"The third constructor behaves the same as the second, except that it stores <bpt id=\"p1\">**</bpt>right<ept id=\"p1\">**</ept>.","pos":[5017,5103],"source":"The third constructor behaves the same as the second, except that it stores **right**."},{"content":"<ph id=\"ph1\">`ref`</ph>.","pos":[5104,5110],"source":"`ref`."},{"content":"<bpt id=\"p1\">**</bpt>release<ept id=\"p1\">**</ept> in <bpt id=\"p2\">**</bpt>myptr<ept id=\"p2\">**</ept>, where <ph id=\"ph1\">`ref`</ph> is the reference stored in <ph id=\"ph2\">` right`</ph>.","pos":[5111,5185],"source":"**release** in **myptr**, where `ref` is the reference stored in ` right`."},{"pos":[5192,5351],"content":"The template constructor behaves the same as the second constructor, provided that a pointer to <bpt id=\"p1\">**</bpt>Other<ept id=\"p1\">**</ept> can be implicitly converted to a pointer to <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept>.","source":"The template constructor behaves the same as the second constructor, provided that a pointer to **Other** can be implicitly converted to a pointer to **Type**."},{"pos":[5361,5368],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6298,6359],"content":"<bpt id=\"p1\">&lt;a name=\"auto_ptr__element_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  auto_ptr::element_type","linkify":"<a name=\"auto_ptr__element_type\"></a>  auto_ptr::element_type","source":"<a name=\"auto_ptr__element_type\"></a>  auto_ptr::element_type"},{"pos":[6363,6421],"content":"The type is a synonym for the template parameter <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the template parameter **Type**."},{"pos":[6479,6522],"content":"<bpt id=\"p1\">&lt;a name=\"auto_ptr__get\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  auto_ptr::get","linkify":"<a name=\"auto_ptr__get\"></a>  auto_ptr::get","source":"<a name=\"auto_ptr__get\"></a>  auto_ptr::get"},{"pos":[6526,6583],"content":"The member function returns the stored pointer <bpt id=\"p1\">**</bpt>myptr<ept id=\"p1\">**</ept>.","source":"The member function returns the stored pointer **myptr**."},{"pos":[6636,6648],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[6652,6681],"content":"The stored pointer <bpt id=\"p1\">**</bpt>myptr<ept id=\"p1\">**</ept>.","source":"The stored pointer **myptr**."},{"pos":[6691,6698],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[7540,7597],"content":"<bpt id=\"p1\">&lt;a name=\"auto_ptr__operator_eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  auto_ptr::operator=","linkify":"<a name=\"auto_ptr__operator_eq\"></a>  auto_ptr::operator=","source":"<a name=\"auto_ptr__operator_eq\"></a>  auto_ptr::operator="},{"pos":[7601,7687],"content":"An assignment operator that transfers ownership from one <ph id=\"ph1\">`auto_ptr`</ph> object to another.","source":"An assignment operator that transfers ownership from one `auto_ptr` object to another."},{"pos":[7915,7925],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An object of type <ph id=\"ph1\">`auto_ptr`</ph>.","pos":[7941,7970],"source":" An object of type `auto_ptr`."},{"pos":[7980,7992],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[7996,8052],"content":"A reference to an object of type <ph id=\"ph1\">`auto_ptr`</ph><ph id=\"ph2\">\\&lt;</ph> <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>&gt;.","source":"A reference to an object of type `auto_ptr`\\< **Type**>."},{"pos":[8062,8069],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The assignment evaluates the expression <bpt id=\"p1\">**</bpt>delete myptr<ept id=\"p1\">**</ept>, but only if the stored pointer <bpt id=\"p2\">**</bpt>myptr<ept id=\"p2\">**</ept> changes as a result of the assignment.","pos":[8073,8210],"source":"The assignment evaluates the expression **delete myptr**, but only if the stored pointer **myptr** changes as a result of the assignment."},{"content":"It then transfers ownership of the pointer stored in _ <bpt id=\"p1\">*</bpt>Right<ept id=\"p1\">*</ept>, by storing <ph id=\"ph1\">\\_</ph> <bpt id=\"p2\">*</bpt>Right<ept id=\"p2\">*</ept>.","pos":[8211,8297],"source":" It then transfers ownership of the pointer stored in _ *Right*, by storing \\_ *Right*."},{"content":"<bpt id=\"p1\">[</bpt>release<ept id=\"p1\">](#auto_ptr__release)</ept> in <bpt id=\"p2\">**</bpt>myptr<ept id=\"p2\">**</ept>.","pos":[8298,8341],"source":"[release](#auto_ptr__release) in **myptr**."},{"content":"The function returns <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\*</ph>this<ept id=\"p1\">**</ept>.","pos":[8342,8374],"source":" The function returns **\\*this**."},{"pos":[8384,8391],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[8396,8492],"content":"For an example of the use of the member operator, see <bpt id=\"p1\">[</bpt>auto_ptr::auto_ptr<ept id=\"p1\">](#auto_ptr__auto_ptr)</ept>.","source":"For an example of the use of the member operator, see [auto_ptr::auto_ptr](#auto_ptr__auto_ptr)."},{"pos":[8502,8561],"content":"<bpt id=\"p1\">&lt;a name=\"auto_ptr__operator_star\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  auto_ptr::operator*","linkify":"<a name=\"auto_ptr__operator_star\"></a>  auto_ptr::operator*","source":"<a name=\"auto_ptr__operator_star\"></a>  auto_ptr::operator*"},{"pos":[8565,8623],"content":"The dereferencing operator for objects of type <ph id=\"ph1\">`auto_ptr`</ph>.","source":"The dereferencing operator for objects of type `auto_ptr`."},{"pos":[8682,8694],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[8698,8762],"content":"A reference to an object of type <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> that the pointer owns.","source":"A reference to an object of type **Type** that the pointer owns."},{"pos":[8772,8779],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The indirection operator returns <ph id=\"ph1\">`*`</ph><bpt id=\"p1\">[</bpt>get<ept id=\"p1\">](#auto_ptr__get)</ept>.","pos":[8783,8841],"source":"The indirection operator returns `*`[get](#auto_ptr__get)."},{"content":"Hence, the stored pointer must not be null.","pos":[8842,8885]},{"pos":[8895,8902],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[8907,9003],"content":"For an example of how to use the member function, see <bpt id=\"p1\">[</bpt>auto_ptr::auto_ptr<ept id=\"p1\">](#auto_ptr__auto_ptr)</ept>.","source":"For an example of how to use the member function, see [auto_ptr::auto_ptr](#auto_ptr__auto_ptr)."},{"pos":[9013,9076],"content":"<bpt id=\"p1\">&lt;a name=\"auto_ptr__operator-_gt_\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  auto_ptr::operator-<ph id=\"ph1\">&amp;gt;</ph>","linkify":"<a name=\"auto_ptr__operator-_gt_\"></a>  auto_ptr::operator-&gt;","source":"<a name=\"auto_ptr__operator-_gt_\"></a>  auto_ptr::operator-&gt;"},{"content":"The operator for allowing member access.","pos":[9080,9120]},{"pos":[9181,9193],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[9197,9243],"content":"A member of the object that <bpt id=\"p1\">**</bpt>auto_ptr<ept id=\"p1\">**</ept> owns.","source":"A member of the object that **auto_ptr** owns."},{"pos":[9253,9260],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The selection operator returns <bpt id=\"p1\">[</bpt>get<ept id=\"p1\">](#auto_ptr__get)</ept><ph id=\"ph1\">`( )`</ph>, so that the expression <bpt id=\"p2\">*</bpt>ap<ept id=\"p2\">*</ept><ph id=\"ph2\">-&gt; </ph><bpt id=\"p3\">**</bpt>member<ept id=\"p3\">**</ept> behaves the same as ( <bpt id=\"p4\">*</bpt>ap<ept id=\"p4\">*</ept>.","pos":[9264,9391],"source":"The selection operator returns [get](#auto_ptr__get)`( )`, so that the expression *ap*-> **member** behaves the same as ( *ap*."},{"content":"<bpt id=\"p1\">**</bpt>get<ept id=\"p1\">**</ept>( ) )-&gt; <bpt id=\"p2\">**</bpt>member<ept id=\"p2\">**</ept>, where <bpt id=\"p3\">*</bpt>ap<ept id=\"p3\">*</ept> is an object of class <ph id=\"ph1\">`auto_ptr`</ph><ph id=\"ph2\">\\&lt;</ph> <bpt id=\"p4\">**</bpt>Type<ept id=\"p4\">**</ept>&gt;.","pos":[9392,9475],"source":"**get**( ) )-> **member**, where *ap* is an object of class `auto_ptr`\\< **Type**>."},{"content":"Hence, the stored pointer must not be null, and <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> must be a class, struct, or union type with a <bpt id=\"p2\">**</bpt>member<ept id=\"p2\">**</ept> member.","pos":[9476,9597],"source":" Hence, the stored pointer must not be null, and **Type** must be a class, struct, or union type with a **member** member."},{"pos":[9607,9614],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9619,9715],"content":"For an example of how to use the member function, see <bpt id=\"p1\">[</bpt>auto_ptr::auto_ptr<ept id=\"p1\">](#auto_ptr__auto_ptr)</ept>.","source":"For an example of how to use the member function, see [auto_ptr::auto_ptr](#auto_ptr__auto_ptr)."},{"pos":[9725,9822],"content":"<bpt id=\"p1\">&lt;a name=\"auto_ptr__operator_auto_ptr_lt_other_gt_\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  auto_ptr::operator auto_ptr<ph id=\"ph1\">&amp;lt;</ph>Other<ph id=\"ph2\">&amp;gt;</ph>","linkify":"<a name=\"auto_ptr__operator_auto_ptr_lt_other_gt_\"></a>  auto_ptr::operator auto_ptr&lt;Other&gt;","source":"<a name=\"auto_ptr__operator_auto_ptr_lt_other_gt_\"></a>  auto_ptr::operator auto_ptr&lt;Other&gt;"},{"pos":[9826,9890],"content":"Casts from one kind of <ph id=\"ph1\">`auto_ptr`</ph> to another kind of <ph id=\"ph2\">`auto_ptr`</ph>.","source":"Casts from one kind of `auto_ptr` to another kind of `auto_ptr`."},{"pos":[9978,9990],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[9994,10063],"content":"The type cast operator returns <ph id=\"ph1\">`auto_ptr`</ph> <ph id=\"ph2\">\\&lt;</ph> <bpt id=\"p1\">**</bpt>Other<ept id=\"p1\">**</ept>&gt;( <bpt id=\"p2\">**</bpt><ph id=\"ph3\">\\*</ph>this<ept id=\"p2\">**</ept>).","source":"The type cast operator returns `auto_ptr` \\< **Other**>( **\\*this**)."},{"pos":[10073,10080],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[10369,10474],"content":"<bpt id=\"p1\">&lt;a name=\"auto_ptr__operator_auto_ptr_ref_lt_other_gt_\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  auto_ptr::operator auto_ptr_ref<ph id=\"ph1\">&amp;lt;</ph>Other<ph id=\"ph2\">&amp;gt;</ph>","linkify":"<a name=\"auto_ptr__operator_auto_ptr_ref_lt_other_gt_\"></a>  auto_ptr::operator auto_ptr_ref&lt;Other&gt;","source":"<a name=\"auto_ptr__operator_auto_ptr_ref_lt_other_gt_\"></a>  auto_ptr::operator auto_ptr_ref&lt;Other&gt;"},{"pos":[10478,10526],"content":"Casts from an <ph id=\"ph1\">`auto_ptr`</ph> to an <bpt id=\"p1\">**</bpt>auto_ptr_ref<ept id=\"p1\">**</ept>.","source":"Casts from an `auto_ptr` to an **auto_ptr_ref**."},{"pos":[10620,10632],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[10636,10710],"content":"The type cast operator returns <bpt id=\"p1\">**</bpt>auto_ptr_ref<ept id=\"p1\">**</ept><ph id=\"ph1\">\\&lt;</ph> <bpt id=\"p2\">**</bpt>Other<ept id=\"p2\">**</ept>&gt;( <bpt id=\"p3\">**</bpt><ph id=\"ph2\">\\*</ph>this<ept id=\"p3\">**</ept>).","source":"The type cast operator returns **auto_ptr_ref**\\< **Other**>( **\\*this**)."},{"pos":[10720,10727],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[11567,11618],"content":"<bpt id=\"p1\">&lt;a name=\"auto_ptr__release\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  auto_ptr::release","linkify":"<a name=\"auto_ptr__release\"></a>  auto_ptr::release","source":"<a name=\"auto_ptr__release\"></a>  auto_ptr::release"},{"pos":[11622,11733],"content":"The member replaces the stored pointer <bpt id=\"p1\">**</bpt>myptr<ept id=\"p1\">**</ept> with a null pointer and returns the previously stored pointer.","source":"The member replaces the stored pointer **myptr** with a null pointer and returns the previously stored pointer."},{"pos":[11784,11796],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The previously stored pointer.","pos":[11800,11830]},{"pos":[11840,11847],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[11851,11962],"content":"The member replaces the stored pointer <bpt id=\"p1\">**</bpt>myptr<ept id=\"p1\">**</ept> with a null pointer and returns the previously stored pointer.","source":"The member replaces the stored pointer **myptr** with a null pointer and returns the previously stored pointer."},{"pos":[11972,11979],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[12762,12809],"content":"<bpt id=\"p1\">&lt;a name=\"auto_ptr__reset\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  auto_ptr::reset","linkify":"<a name=\"auto_ptr__reset\"></a>  auto_ptr::reset","source":"<a name=\"auto_ptr__reset\"></a>  auto_ptr::reset"},{"content":"The member function evaluates the expression <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept>Â <bpt id=\"p2\">**</bpt>myptr<ept id=\"p2\">**</ept>, but only if the stored pointer value <bpt id=\"p3\">**</bpt>myptr<ept id=\"p3\">**</ept> changes as a result of a function call.","pos":[12813,12967],"source":"The member function evaluates the expression **delete**Â **myptr**, but only if the stored pointer value **myptr** changes as a result of a function call."},{"content":"It then replaces the stored pointer with <bpt id=\"p1\">**</bpt>ptr<ept id=\"p1\">**</ept>.","pos":[12968,13017],"source":" It then replaces the stored pointer with **ptr**."},{"pos":[13070,13080],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The pointer specified to replace the stored pointer <bpt id=\"p1\">**</bpt>myptr<ept id=\"p1\">**</ept>.","pos":[13094,13156],"source":" The pointer specified to replace the stored pointer **myptr**."},{"pos":[13166,13173],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[13955,13963],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Thread Safety in the C++ Standard Library<ept id=\"p1\">](../standard-library/thread-safety-in-the-cpp-standard-library.md)</ept><ph id=\"ph1\"> </ph>","pos":[13967,14077],"source":"[Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md) "},{"content":"<bpt id=\"p1\"> [</bpt>unique_ptr Class<ept id=\"p1\">](../standard-library/unique-ptr-class.md)</ept>","pos":[14080,14140],"source":" [unique_ptr Class](../standard-library/unique-ptr-class.md)"}],"content":"---\ntitle: \"auto_ptr Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std::auto_ptr\"\n  - \"std.auto_ptr\"\n  - \"auto_ptr\"\n  - \"memory/std::auto_ptr\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"auto_ptr class\"\nms.assetid: 7f9108b6-9eb3-4634-b615-cf7aa814f23b\ncaps.latest.revision: 26\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# auto_ptr Class\nWraps a smart pointer around a resource that ensures the resource is destroyed automatically when control leaves a block.  \n  \n The more capable `unique_ptr` class supersedes `auto_ptr`. For more information, see [unique_ptr Class](../standard-library/unique-ptr-class.md).  \n  \n For more information about `throw()` and exception handling, see [Exception Specifications (throw)](../cpp/exception-specifications-throw-cpp.md).  \n  \n## Syntax  \n ```   \nclass auto_ptr {\npublic:\n    typedef Type element_type;\n    explicit auto_ptr(Type* ptr = 0) throw();\n    auto_ptr(auto_ptr<Type>& right) throw()\n        ;\n    template <class Other>\n    operator auto_ptr<Other>() throw();\n    template <class Other>\n    auto_ptr<Type>& operator=(auto_ptr<Other>& right) throw();\n    template <class Other>\n    auto_ptr(auto_ptr<Other>& right);\n    auto_ptr<Type>& operator=(auto_ptr<Type>& right);\n    ~auto_ptr();\n    Type& operator*() const throw();\n    Type * operator->()const throw();\n    Type *get() const throw();\n    Type *release()throw();\n    void reset(Type* ptr = 0);\n};\n```  \n#### Parameters  \n ` right`  \n The `auto_ptr` from which to get an existing resource.  \n  \n ` ptr`  \n The pointer specified to replace the stored pointer.  \n  \n## Remarks  \n The template class describes a smart pointer, called an `auto_ptr,` to an allocated object. The pointer must be either null or designate an object allocated by `new`. The `auto_ptr` transfers ownership if its stored value is assigned to another object. (It replaces the stored value after a transfer with a null pointer.) The destructor for `auto_ptr<Type>` deletes the allocated object. The `auto_ptr<Type>` ensures that an allocated object is automatically deleted when control leaves a block, even through a thrown exception. You should not construct two `auto_ptr<Type>` objects that own the same object.  \n  \n You can pass an `auto_ptr<Type>` object by value as an argument to a function call. An `auto_ptr` cannot be an element of any Standard Library container. You cannot reliably manage a sequence of `auto_ptr<Type>` objects with a Standard Template Library container.  \n  \n## Members  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[auto_ptr](#auto_ptr__auto_ptr)|The constructor for objects of type `auto_ptr`.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[element_type](#auto_ptr__element_type)|The type is a synonym for the template parameter `Type`.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[get](#auto_ptr__get)|The member function returns the stored pointer `myptr`.|  \n|[release](#auto_ptr__release)|The member replaces the stored pointer `myptr` with a null pointer and returns the previously stored pointer.|  \n|[reset](#auto_ptr__reset)|The member function evaluates the expression `deleteÂ myptr`, but only if the stored pointer value `myptr` changes as a result of function call. It then replaces the stored pointer with `ptr`.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|[operator=](#auto_ptr__operator_eq)|An assignment operator that transfers ownership from one `auto_ptr` object to another.|  \n|[operator*](#auto_ptr__operator_star)|The dereferencing operator for objects of type `auto_ptr`.|  \n|[operator->](#auto_ptr__operator-_gt_)|The operator for allowing member access.|  \n|[operator auto_ptr\\<Other>](#auto_ptr__operator_auto_ptr_lt_other_gt_)|Casts from one kind of `auto_ptr` to another kind of `auto_ptr`.|  \n|[operator auto_ptr_ref\\<Other>](#auto_ptr__operator_auto_ptr_ref_lt_other_gt_)|Casts from an `auto_ptr` to an `auto_ptr_ref`.|  \n  \n## Requirements  \n **Header:** \\<memory>  \n  \n **Namespace:** std  \n  \n##  <a name=\"auto_ptr__auto_ptr\"></a>  auto_ptr::auto_ptr  \n The constructor for objects of type `auto_ptr`.  \n  \n```   \nexplicit auto_ptr(Type* ptr  = 0) throw();\n\nauto_ptr(auto_ptr<Type>& right) throw();\n\nauto_ptr(auto _ptr_ref<Type> right) throw();\n\ntemplate <class Other>  \nauto _ptr(auto _ptr<Other>& right) throw();\n```  \n  \n### Parameters  \n ` ptr`  \n The pointer to the object that `auto_ptr` encapsulates.  \n  \n ` right`  \n The `auto_ptr` object to be copied by the constructor.  \n  \n### Remarks  \n The first constructor stores ` ptr` in **myptr**, the stored pointer to the allocated object. The second constructor transfers ownership of the pointer stored in ` right`, by storing ` right`. [release](#auto_ptr__release) in **myptr**.  \n  \n The third constructor behaves the same as the second, except that it stores **right**. `ref`. **release** in **myptr**, where `ref` is the reference stored in ` right`.  \n  \n The template constructor behaves the same as the second constructor, provided that a pointer to **Other** can be implicitly converted to a pointer to **Type**.  \n  \n### Example  \n  \n```cpp  \n// auto_ptr_auto_ptr.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nclass Int   \n{  \npublic:  \n   Int(int i)   \n   {  \n      cout << \"Constructing \" << ( void* )this  << endl;   \n      x = i;  \n      bIsConstructed = true;  \n   };  \n   ~Int( )   \n   {  \n      cout << \"Destructing \" << ( void* )this << endl;   \n      bIsConstructed = false;  \n   };  \n   Int &operator++( )   \n   {  \n      x++;  \n      return *this;  \n   };  \n   int x;  \nprivate:  \n   bool bIsConstructed;  \n};  \n  \nvoid function ( auto_ptr<Int> &pi )  \n{  \n   ++( *pi );  \n   auto_ptr<Int> pi2( pi );  \n   ++( *pi2 );  \n   pi = pi2;  \n}  \n  \nint main( )   \n{  \n   auto_ptr<Int> pi ( new Int( 5 ) );  \n   cout << pi->x << endl;  \n   function( pi );  \n   cout << pi->x << endl;  \n}  \n```  \n  \n```Output  \nConstructing 00311AF8  \n5  \n7  \nDestructing 00311AF8  \n```  \n  \n##  <a name=\"auto_ptr__element_type\"></a>  auto_ptr::element_type  \n The type is a synonym for the template parameter **Type**.  \n  \n```  \n \ntypedef Type element  _type;  \n```  \n  \n##  <a name=\"auto_ptr__get\"></a>  auto_ptr::get  \n The member function returns the stored pointer **myptr**.  \n  \n```   \nType *get() const throw();\n```  \n  \n### Return Value  \n The stored pointer **myptr**.  \n  \n### Example  \n  \n```cpp  \n// auto_ptr_get.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \nusing namespace std;  \n  \nclass Int   \n{  \npublic:  \n   Int(int i)   \n   {  \n      x = i;  \n      cout << \"Constructing \" << ( void* )this  << \" Value: \" << x << endl;   \n   };  \n   ~Int( )   \n   {  \n      cout << \"Destructing \" << ( void* )this << \" Value: \" << x << endl;   \n   };  \n  \n   int x;  \n  \n};  \n  \nint main( )   \n{  \n   auto_ptr<Int> pi ( new Int( 5 ) );  \n   pi.reset( new Int( 6 ) );  \n   Int* pi2 = pi.get ( );  \n   Int* pi3 = pi.release ( );  \n   if (pi2 == pi3)  \n      cout << \"pi2 == pi3\" << endl;  \n   delete pi3;  \n}  \n```  \n  \n```Output  \nConstructing 00311AF8 Value: 5  \nConstructing 00311B88 Value: 6  \nDestructing 00311AF8 Value: 5  \npi2 == pi3  \nDestructing 00311B88 Value: 6  \n```  \n  \n##  <a name=\"auto_ptr__operator_eq\"></a>  auto_ptr::operator=  \n An assignment operator that transfers ownership from one `auto_ptr` object to another.  \n  \n```  \ntemplate <class Other>  \nauto_ptr<Type>& operator=(auto_ptr<Other>& right) throw();\nauto_ptr<Type>& operator=(auto_ptr<Type>& right) throw();\nauto_ptr<Type>& operator=(auto_ptr_ref<Type> right) throw();\n```  \n  \n### Parameters  \n ` right`  \n An object of type `auto_ptr`.  \n  \n### Return Value  \n A reference to an object of type `auto_ptr`\\< **Type**>.  \n  \n### Remarks  \n The assignment evaluates the expression **delete myptr**, but only if the stored pointer **myptr** changes as a result of the assignment. It then transfers ownership of the pointer stored in _ *Right*, by storing \\_ *Right*. [release](#auto_ptr__release) in **myptr**. The function returns **\\*this**.  \n  \n### Example  \n  For an example of the use of the member operator, see [auto_ptr::auto_ptr](#auto_ptr__auto_ptr).  \n  \n##  <a name=\"auto_ptr__operator_star\"></a>  auto_ptr::operator*  \n The dereferencing operator for objects of type `auto_ptr`.  \n  \n```   \nType& operator*() const throw();\n```  \n  \n### Return Value  \n A reference to an object of type **Type** that the pointer owns.  \n  \n### Remarks  \n The indirection operator returns `*`[get](#auto_ptr__get). Hence, the stored pointer must not be null.  \n  \n### Example  \n  For an example of how to use the member function, see [auto_ptr::auto_ptr](#auto_ptr__auto_ptr).  \n  \n##  <a name=\"auto_ptr__operator-_gt_\"></a>  auto_ptr::operator-&gt;  \n The operator for allowing member access.  \n  \n```   \nType * operator->() const throw();\n```  \n  \n### Return Value  \n A member of the object that **auto_ptr** owns.  \n  \n### Remarks  \n The selection operator returns [get](#auto_ptr__get)`( )`, so that the expression *ap*-> **member** behaves the same as ( *ap*. **get**( ) )-> **member**, where *ap* is an object of class `auto_ptr`\\< **Type**>. Hence, the stored pointer must not be null, and **Type** must be a class, struct, or union type with a **member** member.  \n  \n### Example  \n  For an example of how to use the member function, see [auto_ptr::auto_ptr](#auto_ptr__auto_ptr).  \n  \n##  <a name=\"auto_ptr__operator_auto_ptr_lt_other_gt_\"></a>  auto_ptr::operator auto_ptr&lt;Other&gt;  \n Casts from one kind of `auto_ptr` to another kind of `auto_ptr`.  \n  \n```   \ntemplate <class Other>  \noperator auto _ptr<Other>() throw();\n```  \n  \n### Return Value  \n The type cast operator returns `auto_ptr` \\< **Other**>( **\\*this**).  \n  \n### Example  \n  \n```cpp  \n// auto_ptr_op_auto_ptr.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \nint main()  \n{  \n   auto_ptr<int> pi ( new int( 5 ) );  \n   auto_ptr<const int> pc = ( auto_ptr<const int> )pi;  \n}  \n```  \n  \n##  <a name=\"auto_ptr__operator_auto_ptr_ref_lt_other_gt_\"></a>  auto_ptr::operator auto_ptr_ref&lt;Other&gt;  \n Casts from an `auto_ptr` to an **auto_ptr_ref**.  \n  \n```   \ntemplate <class Other>  \noperator auto _ptr  _ref<Other>() throw();\n```  \n  \n### Return Value  \n The type cast operator returns **auto_ptr_ref**\\< **Other**>( **\\*this**).  \n  \n### Example  \n  \n```cpp  \n// auto_ptr_op_auto_ptr_ref.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nclass C {\npublic:\n    C(int _i) : m_i(_i) {\n    }\n    ~C() {\n        cout << \"~C:  \" << m_i << \"\\n\";\n    }\n    C &operator =(const int &x) {\n        m_i = x;\n        return *this;\n    }\n    int m_i;\n};\nvoid f(auto_ptr<C> arg) {\n};\nint main()\n{\n    const auto_ptr<C> ciap(new C(1));\n    auto_ptr<C> iap(new C(2));\n\n    // Error: this implies transfer of ownership of iap's pointer  \n    // f(ciap);   \n    f(iap); // compiles, but gives up ownership of pointer  \n\n            // here, iap owns a destroyed pointer so the following is bad:  \n            // *iap = 5; // BOOM  \n\n    cout << \"main exiting\\n\";\n}\n```  \n  \n```Output  \n~C:  2  \nmain exiting  \n~C:  1  \n```  \n  \n##  <a name=\"auto_ptr__release\"></a>  auto_ptr::release  \n The member replaces the stored pointer **myptr** with a null pointer and returns the previously stored pointer.  \n  \n```   \nType *release() throw();\n```  \n  \n### Return Value  \n The previously stored pointer.  \n  \n### Remarks  \n The member replaces the stored pointer **myptr** with a null pointer and returns the previously stored pointer.  \n  \n### Example  \n  \n```cpp  \n// auto_ptr_release.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \nusing namespace std;  \n  \nclass Int\n{\npublic:\n    Int(int i)\n    {\n        x = i;\n        cout << \"Constructing \" << (void*)this << \" Value: \" << x << endl;\n    };\n    ~Int() {\n        cout << \"Destructing \" << (void*)this << \" Value: \" << x << endl;\n    };\n\n    int x;\n\n};\n\nint main()\n{\n    auto_ptr<Int> pi(new Int(5));\n    pi.reset(new Int(6));\n    Int* pi2 = pi.get();\n    Int* pi3 = pi.release();\n    if (pi2 == pi3)\n        cout << \"pi2 == pi3\" << endl;\n    delete pi3;\n}\n```  \n  \n```Output  \nConstructing 00311AF8 Value: 5  \nConstructing 00311B88 Value: 6  \nDestructing 00311AF8 Value: 5  \npi2 == pi3  \nDestructing 00311B88 Value: 6  \n```  \n  \n##  <a name=\"auto_ptr__reset\"></a>  auto_ptr::reset  \n The member function evaluates the expression **delete**Â **myptr**, but only if the stored pointer value **myptr** changes as a result of a function call. It then replaces the stored pointer with **ptr**.  \n  \n```   \nvoid reset(Type* ptr = 0);\n```  \n  \n### Parameters  \n ` ptr`  \n The pointer specified to replace the stored pointer **myptr**.  \n  \n### Example  \n  \n```cpp  \n// auto_ptr_reset.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;\n\nclass Int\n{\npublic:\n    Int(int i)\n    {\n        x = i;\n        cout << \"Constructing \" << (void*)this << \" Value: \" << x << endl;\n    };\n    ~Int()\n    {\n        cout << \"Destructing \" << (void*)this << \" Value: \" << x << endl;\n    };\n\n    int x;\n};\n\nint main()\n{\n    auto_ptr<Int> pi(new Int(5));\n    pi.reset(new Int(6));\n    Int* pi2 = pi.get();\n    Int* pi3 = pi.release();\n    if (pi2 == pi3)\n        cout << \"pi2 == pi3\" << endl;\n    delete pi3;\n}\n```  \n  \n```Output  \nConstructing 00311AF8 Value: 5  \nConstructing 00311B88 Value: 6  \nDestructing 00311AF8 Value: 5  \npi2 == pi3  \nDestructing 00311B88 Value: 6  \n```  \n  \n## See Also  \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [unique_ptr Class](../standard-library/unique-ptr-class.md)\n\n"}