{"nodes":[{"pos":[12,83],"content":"SQL: Customizing Your Recordset’s SQL Statement (ODBC) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"SQL: Customizing Your Recordset’s SQL Statement (ODBC) | Microsoft Docs","pos":[0,71]}]},{"content":"SQL: Customizing Your Recordset’s SQL Statement (ODBC)","pos":[818,872]},{"content":"This topic explains:","pos":[873,893]},{"content":"How the framework constructs a SQL statement","pos":[903,947]},{"content":"How to override the SQL statement","pos":[957,990]},{"pos":[998,1193],"content":"[!NOTE]\n This information applies to the MFC ODBC classes. If you are working with the MFC DAO classes, see the topic \"Comparison of Microsoft Jet Database Engine SQL and ANSI SQL\" in DAO Help.","leadings":["","> "],"nodes":[{"content":" This information applies to the MFC ODBC classes. If you are working with the MFC DAO classes, see the topic \"Comparison of Microsoft Jet Database Engine SQL and ANSI SQL\" in DAO Help.","pos":[8,193],"nodes":[{"content":"This information applies to the MFC ODBC classes.","pos":[1,50]},{"content":"If you are working with the MFC DAO classes, see the topic \"Comparison of Microsoft Jet Database Engine SQL and ANSI SQL\" in DAO Help.","pos":[51,185]}]}]},{"content":"SQL Statement Construction","pos":[1202,1228]},{"content":"Your recordset bases record selection primarily on a SQL <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement.","pos":[1232,1310],"source":"Your recordset bases record selection primarily on a SQL **SELECT** statement."},{"content":"When you declare your class with a wizard, it writes an overriding version of the <ph id=\"ph1\">`GetDefaultSQL`</ph> member function that looks something like this (for a recordset class called <ph id=\"ph2\">`CAuthors`</ph>).","pos":[1311,1498],"source":" When you declare your class with a wizard, it writes an overriding version of the `GetDefaultSQL` member function that looks something like this (for a recordset class called `CAuthors`)."},{"content":"By default, this override returns the table name you specified with the wizard.","pos":[1588,1667]},{"content":"In the example, the table name is \"AUTHORS.\"","pos":[1668,1712]},{"content":"When you later call the recordset's <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> member function, <bpt id=\"p2\">**</bpt>Open<ept id=\"p2\">**</ept> constructs a final <bpt id=\"p3\">**</bpt>SELECT<ept id=\"p3\">**</ept> statement of the form:","pos":[1713,1836],"source":" When you later call the recordset's **Open** member function, **Open** constructs a final **SELECT** statement of the form:"},{"content":"where <ph id=\"ph1\">`table-name`</ph> is obtained by calling <ph id=\"ph2\">`GetDefaultSQL`</ph> and <ph id=\"ph3\">`rfx-field-list`</ph> is obtained from the RFX function calls in <ph id=\"ph4\">`DoFieldExchange`</ph>.","pos":[1949,2089],"source":"where `table-name` is obtained by calling `GetDefaultSQL` and `rfx-field-list` is obtained from the RFX function calls in `DoFieldExchange`."},{"content":"This is what you get for a <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement unless you replace it with an overriding version at run time, although you can also modify the default statement with parameters or a filter.","pos":[2090,2279],"source":" This is what you get for a **SELECT** statement unless you replace it with an overriding version at run time, although you can also modify the default statement with parameters or a filter."},{"pos":[2287,2474],"content":"[!NOTE]\n If you specify a column name that contains (or could contain) spaces, you must enclose the name in square brackets. For example, the name \"First Name\" should be \"[First Name]\".","leadings":["","> "],"nodes":[{"content":" If you specify a column name that contains (or could contain) spaces, you must enclose the name in square brackets. For example, the name \"First Name\" should be \"[First Name]\".","pos":[8,185],"nodes":[{"content":"If you specify a column name that contains (or could contain) spaces, you must enclose the name in square brackets.","pos":[1,116]},{"content":"For example, the name \"First Name\" should be \"[First Name]\".","pos":[117,177]}]}]},{"content":"To override the default <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement, pass a string containing a complete <bpt id=\"p2\">**</bpt>SELECT<ept id=\"p2\">**</ept> statement when you call <bpt id=\"p3\">**</bpt>Open<ept id=\"p3\">**</ept>.","pos":[2481,2607],"source":"To override the default **SELECT** statement, pass a string containing a complete **SELECT** statement when you call **Open**."},{"content":"Instead of constructing its own default string, the recordset uses the string you supply.","pos":[2608,2697]},{"content":"If your replacement statement contains a <bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> clause, do not specify a filter in <bpt id=\"p2\">**</bpt>m_strFilter<ept id=\"p2\">**</ept> because you would then have two filter statements.","pos":[2698,2850],"source":" If your replacement statement contains a **WHERE** clause, do not specify a filter in **m_strFilter** because you would then have two filter statements."},{"content":"Similarly, if your replacement statement contains an <bpt id=\"p1\">**</bpt>ORDER BY<ept id=\"p1\">**</ept> clause, do not specify a sort in <ph id=\"ph1\">`m_strSort`</ph> so that you will not have two sort statements.","pos":[2851,3008],"source":" Similarly, if your replacement statement contains an **ORDER BY** clause, do not specify a sort in `m_strSort` so that you will not have two sort statements."},{"pos":[3016,3263],"content":"[!NOTE]\n If you use literal strings in your filters (or other parts of the SQL statement), you might have to \"quote\" (enclose in specified delimiters) such strings with a DBMS-specific literal prefix and literal suffix character (or characters).","leadings":["","> "],"nodes":[{"content":"If you use literal strings in your filters (or other parts of the SQL statement), you might have to \"quote\" (enclose in specified delimiters) such strings with a DBMS-specific literal prefix and literal suffix character (or characters).","pos":[9,245]}]},{"content":"You might also encounter special syntactic requirements for operations such as outer joins, depending on your DBMS.","pos":[3270,3385]},{"content":"Use ODBC functions to obtain this information from your driver for the DBMS.","pos":[3386,3462]},{"content":"For example, call <bpt id=\"p1\">**</bpt>::SQLGetTypeInfo<ept id=\"p1\">**</ept> for a particular data type, such as <bpt id=\"p2\">**</bpt>SQL_VARCHAR<ept id=\"p2\">**</ept>, to request the <bpt id=\"p3\">**</bpt>LITERAL_PREFIX<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>LITERAL_SUFFIX<ept id=\"p4\">**</ept> characters.","pos":[3463,3623],"source":" For example, call **::SQLGetTypeInfo** for a particular data type, such as **SQL_VARCHAR**, to request the **LITERAL_PREFIX** and **LITERAL_SUFFIX** characters."},{"content":"If you are writing database-independent code, see Appendix C in the <bpt id=\"p1\">*</bpt>ODBC SDK<ept id=\"p1\">*</ept><bpt id=\"p2\">*</bpt>Programmer's Reference<ept id=\"p2\">*</ept> on the MSDN Library CD for detailed syntax information.","pos":[3624,3782],"source":" If you are writing database-independent code, see Appendix C in the *ODBC SDK**Programmer's Reference* on the MSDN Library CD for detailed syntax information."},{"content":"A recordset object constructs the SQL statement that it uses to select records unless you pass a custom SQL statement.","pos":[3789,3907]},{"content":"How this is done depends mainly on the value you pass in the <ph id=\"ph1\">`lpszSQL`</ph> parameter of the <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> member function.","pos":[3908,4021],"source":" How this is done depends mainly on the value you pass in the `lpszSQL` parameter of the **Open** member function."},{"pos":[4028,4078],"content":"The general form of a SQL <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement is:","source":"The general form of a SQL **SELECT** statement is:"},{"content":"One way to add the <bpt id=\"p1\">**</bpt>DISTINCT<ept id=\"p1\">**</ept> keyword to your recordset's SQL statement is to embed the keyword in the first RFX function call in <ph id=\"ph1\">`DoFieldExchange`</ph>.","pos":[4220,4370],"source":"One way to add the **DISTINCT** keyword to your recordset's SQL statement is to embed the keyword in the first RFX function call in `DoFieldExchange`."},{"content":"For example:","pos":[4371,4383]},{"pos":[4475,4547],"content":"[!NOTE]\n Use this technique only with a recordset opened as read-only.","leadings":["","> "],"nodes":[{"content":"Use this technique only with a recordset opened as read-only.","pos":[9,70]}]},{"content":"Overriding the SQL Statement","pos":[4556,4584]},{"content":"The following table shows the possibilities for the <ph id=\"ph1\">`lpszSQL`</ph> parameter to <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept>.","pos":[4588,4672],"source":"The following table shows the possibilities for the `lpszSQL` parameter to **Open**."},{"content":"The cases in the table are explained following the table.","pos":[4673,4730]},{"content":"The lpszSQL Parameter and the Resulting SQL String","pos":[4739,4789]},{"content":"Case","pos":[4798,4802]},{"content":"What you pass in lpszSQL","pos":[4803,4827]},{"content":"The resulting SELECT statement","pos":[4828,4858]},{"content":"1","pos":[4946,4947]},{"content":"NULL","pos":[4950,4954]},{"content":"<bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>rfx-field-list<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt>FROM<ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt>table-name<ept id=\"p4\">*</ept>","pos":[4957,5006],"source":"**SELECT** *rfx-field-list* **FROM** *table-name*"},{"content":"calls <ph id=\"ph1\">`GetDefaultSQL`</ph> to get the table name.","pos":[5038,5082],"source":" calls `GetDefaultSQL` to get the table name."},{"content":"The resulting string is one of cases 2 through 5, depending on what <ph id=\"ph1\">`GetDefaultSQL`</ph> returns.","pos":[5083,5175],"source":" The resulting string is one of cases 2 through 5, depending on what `GetDefaultSQL` returns."},{"content":"2","pos":[5180,5181]},{"content":"A table name","pos":[5182,5194]},{"content":"<bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>rfx-field-list<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt>FROM<ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt>table-name<ept id=\"p4\">*</ept>","pos":[5195,5244],"source":"**SELECT** *rfx-field-list* **FROM** *table-name*"},{"content":"The field list is taken from the RFX statements in <ph id=\"ph1\">`DoFieldExchange`</ph>.","pos":[5257,5326],"source":" The field list is taken from the RFX statements in `DoFieldExchange`."},{"content":"If <bpt id=\"p1\">**</bpt>m_strFilter<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`m_strSort`</ph> are not empty, adds the <bpt id=\"p2\">**</bpt>WHERE<ept id=\"p2\">**</ept> and/or <bpt id=\"p3\">**</bpt>ORDER BY<ept id=\"p3\">**</ept> clauses.","pos":[5327,5424],"source":" If **m_strFilter** and `m_strSort` are not empty, adds the **WHERE** and/or **ORDER BY** clauses."},{"content":"3 *","pos":[5429,5432]},{"pos":[5433,5511],"content":"A complete <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement but without a <bpt id=\"p2\">**</bpt>WHERE<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>ORDER BY<ept id=\"p3\">**</ept> clause","source":"A complete **SELECT** statement but without a **WHERE** or **ORDER BY** clause"},{"content":"As passed.","pos":[5512,5522]},{"content":"If <bpt id=\"p1\">**</bpt>m_strFilter<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`m_strSort`</ph> are not empty, adds the <bpt id=\"p2\">**</bpt>WHERE<ept id=\"p2\">**</ept> and/or <bpt id=\"p3\">**</bpt>ORDER BY<ept id=\"p3\">**</ept> clauses.","pos":[5523,5620],"source":" If **m_strFilter** and `m_strSort` are not empty, adds the **WHERE** and/or **ORDER BY** clauses."},{"content":"4 *","pos":[5625,5628]},{"pos":[5629,5704],"content":"A complete <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement with a <bpt id=\"p2\">**</bpt>WHERE<ept id=\"p2\">**</ept> and/or <bpt id=\"p3\">**</bpt>ORDER BY<ept id=\"p3\">**</ept> clause","source":"A complete **SELECT** statement with a **WHERE** and/or **ORDER BY** clause"},{"content":"As passed.","pos":[5705,5715]},{"content":"<bpt id=\"p1\">**</bpt>m_strFilter<ept id=\"p1\">**</ept> and/or <ph id=\"ph1\">`m_strSort`</ph> must remain empty, or two filter and/or sort statements are produced.","pos":[5716,5820],"source":"**m_strFilter** and/or `m_strSort` must remain empty, or two filter and/or sort statements are produced."},{"content":"5 *","pos":[5825,5828]},{"content":"A call to a stored procedure","pos":[5829,5857]},{"content":"As passed.","pos":[5858,5868]},{"content":"must be less than or equal to the number of columns specified in the <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement.","pos":[5891,5981],"source":" must be less than or equal to the number of columns specified in the **SELECT** statement."},{"content":"The data type of each column specified in the <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement must be the same as the data type of the corresponding RFX output column.","pos":[5982,6122],"source":" The data type of each column specified in the **SELECT** statement must be the same as the data type of the corresponding RFX output column."},{"content":"Case 1   lpszSQL = NULL","pos":[6132,6155]},{"content":"The recordset selection depends on what <ph id=\"ph1\">`GetDefaultSQL`</ph> returns when <ph id=\"ph2\">`CRecordset::Open`</ph> calls it.","pos":[6159,6256],"source":"The recordset selection depends on what `GetDefaultSQL` returns when `CRecordset::Open` calls it."},{"content":"Cases 2 through 5 describe the possible strings.","pos":[6257,6305]},{"content":"Case 2   lpszSQL = a Table Name","pos":[6315,6346]},{"content":"The recordset uses record field exchange (RFX) to build the column list from the column names provided in the RFX function calls in the recordset class's override of <ph id=\"ph1\">`DoFieldExchange`</ph>.","pos":[6350,6534],"source":"The recordset uses record field exchange (RFX) to build the column list from the column names provided in the RFX function calls in the recordset class's override of `DoFieldExchange`."},{"content":"If you used a wizard to declare your recordset class, this case has the same result as case 1 (provided that you pass the same table name you specified in the wizard).","pos":[6535,6702]},{"content":"If you do not use a wizard to write your class, case 2 is the simplest way to construct the SQL statement.","pos":[6703,6809]},{"content":"The following example constructs a SQL statement that selects records from an MFC database application.","pos":[6816,6919]},{"content":"When the framework calls the <ph id=\"ph1\">`GetDefaultSQL`</ph> member function, the function returns the name of the table, <ph id=\"ph2\">`SECTION`</ph>.","pos":[6920,7036],"source":" When the framework calls the `GetDefaultSQL` member function, the function returns the name of the table, `SECTION`."},{"pos":[7128,7255],"content":"To obtain the names of the columns for the SQL <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement, the framework calls the <ph id=\"ph1\">`DoFieldExchange`</ph> member function.","source":"To obtain the names of the columns for the SQL **SELECT** statement, the framework calls the `DoFieldExchange` member function."},{"content":"When complete, the SQL statement looks like this:","pos":[7642,7691]},{"content":"Case 3   lpszSQL = a SELECT/FROM Statement","pos":[7797,7839]},{"content":"You specify the column list by hand rather than relying on RFX to construct it automatically.","pos":[7843,7936]},{"content":"You might want to do this when:","pos":[7937,7968]},{"pos":[7978,8044],"content":"You want to specify the <bpt id=\"p1\">**</bpt>DISTINCT<ept id=\"p1\">**</ept> keyword following <bpt id=\"p2\">**</bpt>SELECT<ept id=\"p2\">**</ept>.","source":"You want to specify the **DISTINCT** keyword following **SELECT**."},{"pos":[8055,8170],"content":"Your column list should match the column names and types in the same order as they are listed in <ph id=\"ph1\">`DoFieldExchange`</ph>.","source":"Your column list should match the column names and types in the same order as they are listed in `DoFieldExchange`."},{"pos":[8180,8336],"content":"You have reason to manually retrieve column values using the ODBC function <bpt id=\"p1\">**</bpt>::SQLGetData<ept id=\"p1\">**</ept> rather than relying on RFX to bind and retrieve columns for you.","source":"You have reason to manually retrieve column values using the ODBC function **::SQLGetData** rather than relying on RFX to bind and retrieve columns for you."},{"content":"You might, for example, want to accommodate new columns a customer of your application added to the database tables after the application was distributed.","pos":[8347,8501]},{"content":"You need to add these extra field data members, which were not known at the time you declared the class with a wizard.","pos":[8502,8620]},{"content":"Your column list should match the column names and types in the same order as they are listed in <ph id=\"ph1\">`DoFieldExchange`</ph>, followed by the names of the manually bound columns.","pos":[8631,8799],"source":"Your column list should match the column names and types in the same order as they are listed in `DoFieldExchange`, followed by the names of the manually bound columns."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Recordset: Dynamically Binding Data Columns (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md)</ept>.","pos":[8800,8947],"source":" For more information, see [Recordset: Dynamically Binding Data Columns (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md)."},{"pos":[8957,9034],"content":"You want to join tables by specifying multiple tables in the <bpt id=\"p1\">**</bpt>FROM<ept id=\"p1\">**</ept> clause.","source":"You want to join tables by specifying multiple tables in the **FROM** clause."},{"pos":[9045,9172],"content":"For information and an example, see <bpt id=\"p1\">[</bpt>Recordset: Performing a Join (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-performing-a-join-odbc.md)</ept>.","source":"For information and an example, see [Recordset: Performing a Join (ODBC)](../../data/odbc/recordset-performing-a-join-odbc.md)."},{"content":"Case 4   lpszSQL = SELECT/FROM Plus WHERE and/or ORDER BY","pos":[9182,9239]},{"content":"You specify everything: the column list (based on the RFX calls in <ph id=\"ph1\">`DoFieldExchange`</ph>), the table list, and the contents of a <bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> and/or an <bpt id=\"p2\">**</bpt>ORDER BY<ept id=\"p2\">**</ept> clause.","pos":[9243,9408],"source":"You specify everything: the column list (based on the RFX calls in `DoFieldExchange`), the table list, and the contents of a **WHERE** and/or an **ORDER BY** clause."},{"content":"If you specify your <bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> and/or <bpt id=\"p2\">**</bpt>ORDER BY<ept id=\"p2\">**</ept> clauses this way, do not use <bpt id=\"p3\">**</bpt>m_strFilter<ept id=\"p3\">**</ept> and/or <ph id=\"ph1\">`m_strSort`</ph>.","pos":[9409,9523],"source":" If you specify your **WHERE** and/or **ORDER BY** clauses this way, do not use **m_strFilter** and/or `m_strSort`."},{"content":"Case 5   lpszSQL = a Stored Procedure Call","pos":[9533,9575]},{"content":"If you need to call a predefined query (such as a stored procedure in a Microsoft SQL Server database), you must write a <bpt id=\"p1\">**</bpt>CALL<ept id=\"p1\">**</ept> statement in the string you pass to <ph id=\"ph1\">`lpszSQL`</ph>.","pos":[9579,9755],"source":"If you need to call a predefined query (such as a stored procedure in a Microsoft SQL Server database), you must write a **CALL** statement in the string you pass to `lpszSQL`."},{"content":"The wizards do not support declaring a recordset class for calling a predefined query.","pos":[9756,9842]},{"content":"Not all predefined queries return records.","pos":[9843,9885]},{"content":"If a predefined query does not return records, you can use the <ph id=\"ph1\">`CDatabase`</ph> member function <ph id=\"ph2\">`ExecuteSQL`</ph> directly.","pos":[9892,10005],"source":"If a predefined query does not return records, you can use the `CDatabase` member function `ExecuteSQL` directly."},{"content":"For a predefined query that does return records, you must also manually write the RFX calls in <ph id=\"ph1\">`DoFieldExchange`</ph> for any columns the procedure returns.","pos":[10006,10157],"source":" For a predefined query that does return records, you must also manually write the RFX calls in `DoFieldExchange` for any columns the procedure returns."},{"content":"The RFX calls must be in the same order and return the same types, as the predefined query.","pos":[10158,10249]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Recordset: Declaring a Class for a Predefined Query (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-declaring-a-class-for-a-predefined-query-odbc.md)</ept>.","pos":[10250,10413],"source":" For more information, see [Recordset: Declaring a Class for a Predefined Query (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-predefined-query-odbc.md)."},{"content":"See Also","pos":[10422,10430]},{"content":"SQL: SQL and C++ Data Types (ODBC)","pos":[10435,10469]},{"content":"SQL: Making Direct SQL Calls (ODBC)","pos":[10528,10563]}],"content":"---\ntitle: \"SQL: Customizing Your Recordset’s SQL Statement (ODBC) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"recordsets, SQL statements\"\n  - \"ODBC recordsets, SQL statements\"\n  - \"SQL statements, customizing\"\n  - \"SQL statements, recordset\"\n  - \"customizing SQL statements\"\n  - \"overriding, SQL statements\"\n  - \"SQL, opening recordsets\"\nms.assetid: 72293a08-cef2-4be2-aa1c-30565fcfbaf9\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# SQL: Customizing Your Recordset’s SQL Statement (ODBC)\nThis topic explains:  \n  \n-   How the framework constructs a SQL statement  \n  \n-   How to override the SQL statement  \n  \n> [!NOTE]\n>  This information applies to the MFC ODBC classes. If you are working with the MFC DAO classes, see the topic \"Comparison of Microsoft Jet Database Engine SQL and ANSI SQL\" in DAO Help.  \n  \n## SQL Statement Construction  \n Your recordset bases record selection primarily on a SQL **SELECT** statement. When you declare your class with a wizard, it writes an overriding version of the `GetDefaultSQL` member function that looks something like this (for a recordset class called `CAuthors`).  \n  \n```  \nCString CAuthors::GetDefaultSQL()  \n{  \n    return \"AUTHORS\";  \n}  \n```  \n  \n By default, this override returns the table name you specified with the wizard. In the example, the table name is \"AUTHORS.\" When you later call the recordset's **Open** member function, **Open** constructs a final **SELECT** statement of the form:  \n  \n```  \nSELECT rfx-field-list FROM table-name [WHERE m_strFilter]   \n       [ORDER BY m_strSort]  \n```  \n  \n where `table-name` is obtained by calling `GetDefaultSQL` and `rfx-field-list` is obtained from the RFX function calls in `DoFieldExchange`. This is what you get for a **SELECT** statement unless you replace it with an overriding version at run time, although you can also modify the default statement with parameters or a filter.  \n  \n> [!NOTE]\n>  If you specify a column name that contains (or could contain) spaces, you must enclose the name in square brackets. For example, the name \"First Name\" should be \"[First Name]\".  \n  \n To override the default **SELECT** statement, pass a string containing a complete **SELECT** statement when you call **Open**. Instead of constructing its own default string, the recordset uses the string you supply. If your replacement statement contains a **WHERE** clause, do not specify a filter in **m_strFilter** because you would then have two filter statements. Similarly, if your replacement statement contains an **ORDER BY** clause, do not specify a sort in `m_strSort` so that you will not have two sort statements.  \n  \n> [!NOTE]\n>  If you use literal strings in your filters (or other parts of the SQL statement), you might have to \"quote\" (enclose in specified delimiters) such strings with a DBMS-specific literal prefix and literal suffix character (or characters).  \n  \n You might also encounter special syntactic requirements for operations such as outer joins, depending on your DBMS. Use ODBC functions to obtain this information from your driver for the DBMS. For example, call **::SQLGetTypeInfo** for a particular data type, such as **SQL_VARCHAR**, to request the **LITERAL_PREFIX** and **LITERAL_SUFFIX** characters. If you are writing database-independent code, see Appendix C in the *ODBC SDK**Programmer's Reference* on the MSDN Library CD for detailed syntax information.  \n  \n A recordset object constructs the SQL statement that it uses to select records unless you pass a custom SQL statement. How this is done depends mainly on the value you pass in the `lpszSQL` parameter of the **Open** member function.  \n  \n The general form of a SQL **SELECT** statement is:  \n  \n```  \nSELECT [ALL | DISTINCT] column-list FROM table-list  \n    [WHERE search-condition][ORDER BY column-list [ASC | DESC]]  \n```  \n  \n One way to add the **DISTINCT** keyword to your recordset's SQL statement is to embed the keyword in the first RFX function call in `DoFieldExchange`. For example:  \n  \n```  \n...  \n    RFX_Text(pFX, \"DISTINCT CourseID\", m_strCourseID);  \n...  \n```  \n  \n> [!NOTE]\n>  Use this technique only with a recordset opened as read-only.  \n  \n## Overriding the SQL Statement  \n The following table shows the possibilities for the `lpszSQL` parameter to **Open**. The cases in the table are explained following the table.  \n  \n **The lpszSQL Parameter and the Resulting SQL String**  \n  \n|Case|What you pass in lpszSQL|The resulting SELECT statement|  \n|----------|------------------------------|------------------------------------|  \n|1|**NULL**|**SELECT** *rfx-field-list* **FROM** *table-name*<br /><br /> `CRecordset::Open` calls `GetDefaultSQL` to get the table name. The resulting string is one of cases 2 through 5, depending on what `GetDefaultSQL` returns.|  \n|2|A table name|**SELECT** *rfx-field-list* **FROM** *table-name*<br /><br /> The field list is taken from the RFX statements in `DoFieldExchange`. If **m_strFilter** and `m_strSort` are not empty, adds the **WHERE** and/or **ORDER BY** clauses.|  \n|3 *|A complete **SELECT** statement but without a **WHERE** or **ORDER BY** clause|As passed. If **m_strFilter** and `m_strSort` are not empty, adds the **WHERE** and/or **ORDER BY** clauses.|  \n|4 *|A complete **SELECT** statement with a **WHERE** and/or **ORDER BY** clause|As passed. **m_strFilter** and/or `m_strSort` must remain empty, or two filter and/or sort statements are produced.|  \n|5 *|A call to a stored procedure|As passed.|  \n  \n \\* `m_nFields` must be less than or equal to the number of columns specified in the **SELECT** statement. The data type of each column specified in the **SELECT** statement must be the same as the data type of the corresponding RFX output column.  \n  \n### Case 1   lpszSQL = NULL  \n The recordset selection depends on what `GetDefaultSQL` returns when `CRecordset::Open` calls it. Cases 2 through 5 describe the possible strings.  \n  \n### Case 2   lpszSQL = a Table Name  \n The recordset uses record field exchange (RFX) to build the column list from the column names provided in the RFX function calls in the recordset class's override of `DoFieldExchange`. If you used a wizard to declare your recordset class, this case has the same result as case 1 (provided that you pass the same table name you specified in the wizard). If you do not use a wizard to write your class, case 2 is the simplest way to construct the SQL statement.  \n  \n The following example constructs a SQL statement that selects records from an MFC database application. When the framework calls the `GetDefaultSQL` member function, the function returns the name of the table, `SECTION`.  \n  \n```  \nCString CEnrollSet::GetDefaultSQL()  \n{  \n    return \"SECTION\";  \n}  \n```  \n  \n To obtain the names of the columns for the SQL **SELECT** statement, the framework calls the `DoFieldExchange` member function.  \n  \n```  \nvoid CEnrollSet::DoFieldExchange(CFieldExchange* pFX)  \n{  \n    pFX->SetFieldType(CFieldExchange::outputColumn);  \n    RFX_Text(pFX, \"CourseID\", m_strCourseID);  \n    RFX_Text(pFX, \"InstructorID\", m_strInstructorID);  \n    RFX_Text(pFX, \"RoomNo\", m_strRoomNo);  \n    RFX_Text(pFX, \"Schedule\", m_strSchedule);  \n    RFX_Text(pFX, \"SectionNo\", m_strSectionNo);  \n}  \n```  \n  \n When complete, the SQL statement looks like this:  \n  \n```  \nSELECT CourseID, InstructorID, RoomNo, Schedule, SectionNo   \n    FROM SECTION  \n```  \n  \n### Case 3   lpszSQL = a SELECT/FROM Statement  \n You specify the column list by hand rather than relying on RFX to construct it automatically. You might want to do this when:  \n  \n-   You want to specify the **DISTINCT** keyword following **SELECT**.  \n  \n     Your column list should match the column names and types in the same order as they are listed in `DoFieldExchange`.  \n  \n-   You have reason to manually retrieve column values using the ODBC function **::SQLGetData** rather than relying on RFX to bind and retrieve columns for you.  \n  \n     You might, for example, want to accommodate new columns a customer of your application added to the database tables after the application was distributed. You need to add these extra field data members, which were not known at the time you declared the class with a wizard.  \n  \n     Your column list should match the column names and types in the same order as they are listed in `DoFieldExchange`, followed by the names of the manually bound columns. For more information, see [Recordset: Dynamically Binding Data Columns (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md).  \n  \n-   You want to join tables by specifying multiple tables in the **FROM** clause.  \n  \n     For information and an example, see [Recordset: Performing a Join (ODBC)](../../data/odbc/recordset-performing-a-join-odbc.md).  \n  \n### Case 4   lpszSQL = SELECT/FROM Plus WHERE and/or ORDER BY  \n You specify everything: the column list (based on the RFX calls in `DoFieldExchange`), the table list, and the contents of a **WHERE** and/or an **ORDER BY** clause. If you specify your **WHERE** and/or **ORDER BY** clauses this way, do not use **m_strFilter** and/or `m_strSort`.  \n  \n### Case 5   lpszSQL = a Stored Procedure Call  \n If you need to call a predefined query (such as a stored procedure in a Microsoft SQL Server database), you must write a **CALL** statement in the string you pass to `lpszSQL`. The wizards do not support declaring a recordset class for calling a predefined query. Not all predefined queries return records.  \n  \n If a predefined query does not return records, you can use the `CDatabase` member function `ExecuteSQL` directly. For a predefined query that does return records, you must also manually write the RFX calls in `DoFieldExchange` for any columns the procedure returns. The RFX calls must be in the same order and return the same types, as the predefined query. For more information, see [Recordset: Declaring a Class for a Predefined Query (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-predefined-query-odbc.md).  \n  \n## See Also  \n [SQL: SQL and C++ Data Types (ODBC)](../../data/odbc/sql-sql-and-cpp-data-types-odbc.md)   \n [SQL: Making Direct SQL Calls (ODBC)](../../data/odbc/sql-making-direct-sql-calls-odbc.md)\n"}