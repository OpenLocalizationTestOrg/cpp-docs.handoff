{"nodes":[{"pos":[12,69],"content":"Conversions from Unsigned Integral Types | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Conversions from Unsigned Integral Types | Microsoft Docs","pos":[0,57]}]},{"content":"Conversions from Unsigned Integral Types","pos":[807,847]},{"pos":[848,1095],"content":"An unsigned integer is converted to a shorter unsigned or signed integer by truncating the high-order bits, or to a longer unsigned or signed integer by zero-extending (see the <bpt id=\"p1\">[</bpt>Conversions from Unsigned Integral Types<ept id=\"p1\">](#_clang_table_4..3)</ept> table).","source":"An unsigned integer is converted to a shorter unsigned or signed integer by truncating the high-order bits, or to a longer unsigned or signed integer by zero-extending (see the [Conversions from Unsigned Integral Types](#_clang_table_4..3) table)."},{"content":"When the value with integral type is demoted to a signed integer with smaller size, or an unsigned integer is converted to its corresponding signed integer, the value is unchanged if it can be represented in the new type.","pos":[1102,1323]},{"content":"However, the value it represents changes if the sign bit is set, as in the following example.","pos":[1324,1417]},{"content":"If it cannot be represented, the result is implementation-defined.","pos":[1529,1595]},{"content":"See <bpt id=\"p1\">[</bpt>Type-Cast Conversions<ept id=\"p1\">](../c-language/type-cast-conversions.md)</ept> for information on the Microsoft C compiler's handling of demotion of integers.","pos":[1596,1743],"source":" See [Type-Cast Conversions](../c-language/type-cast-conversions.md) for information on the Microsoft C compiler's handling of demotion of integers."},{"content":"The same behavior results from integer conversion or from type casting the integer.","pos":[1744,1827]},{"content":"Unsigned values are converted in a way that preserves their value and is not representable directly in C. The only exception is a conversion from <ph id=\"ph1\">`unsigned long`</ph> to <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>, which loses at most the low-order bits.","pos":[1834,2049],"source":"Unsigned values are converted in a way that preserves their value and is not representable directly in C. The only exception is a conversion from `unsigned long` to **float**, which loses at most the low-order bits."},{"content":"Otherwise, value is preserved, signed or unsigned.","pos":[2050,2100]},{"content":"When a value of integral type is converted to floating, and the value is outside the range representable, the result is undefined.","pos":[2101,2231]},{"content":"(See <bpt id=\"p1\">[</bpt>Storage of Basic Types<ept id=\"p1\">](../c-language/storage-of-basic-types.md)</ept> for information about the range for integral and floating-point types.)","pos":[2232,2374],"source":" (See [Storage of Basic Types](../c-language/storage-of-basic-types.md) for information about the range for integral and floating-point types.)"},{"content":"The following table summarizes conversions from unsigned integral types.","pos":[2381,2453]},{"content":"Conversions from Unsigned Integral Types","pos":[2463,2503]},{"content":"From","pos":[2510,2514]},{"content":"To","pos":[2515,2517]},{"content":"Method","pos":[2518,2524]},{"content":"Preserve bit pattern; high-order bit becomes sign bit","pos":[2589,2642]},{"content":"short","pos":[2665,2670]},{"content":"Zero-extend","pos":[2673,2684]},{"content":"long","pos":[2707,2711]},{"content":"Zero-extend","pos":[2714,2725]},{"content":"unsigned short","pos":[2748,2762]},{"content":"Zero-extend","pos":[2765,2776]},{"content":"Zero-extend","pos":[2813,2824]},{"content":"float","pos":[2847,2852]},{"pos":[2855,2905],"content":"Convert to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>float<ept id=\"p3\">**</ept>","source":"Convert to **long**; convert **long** to **float**"},{"content":"double","pos":[2928,2934]},{"pos":[2937,2988],"content":"Convert to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept>","source":"Convert to **long**; convert **long** to **double**"},{"pos":[3023,3074],"content":"Convert to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept>","source":"Convert to **long**; convert **long** to **double**"},{"content":"unsigned short","pos":[3081,3095]},{"content":"Preserve low-order byte","pos":[3105,3128]},{"content":"unsigned short","pos":[3135,3149]},{"content":"short","pos":[3154,3159]},{"content":"Preserve bit pattern; high-order bit becomes sign bit","pos":[3162,3215]},{"content":"unsigned short","pos":[3222,3236]},{"content":"long","pos":[3241,3245]},{"content":"Zero-extend","pos":[3248,3259]},{"content":"unsigned short","pos":[3266,3280]},{"content":"Preserve low-order byte","pos":[3299,3322]},{"content":"unsigned short","pos":[3329,3343]},{"content":"Zero-extend","pos":[3362,3373]},{"content":"unsigned short","pos":[3380,3394]},{"content":"float","pos":[3399,3404]},{"pos":[3407,3457],"content":"Convert to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>float<ept id=\"p3\">**</ept>","source":"Convert to **long**; convert **long** to **float**"},{"content":"unsigned short","pos":[3464,3478]},{"content":"double","pos":[3483,3489]},{"pos":[3492,3543],"content":"Convert to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept>","source":"Convert to **long**; convert **long** to **double**"},{"content":"unsigned short","pos":[3550,3564]},{"pos":[3581,3632],"content":"Convert to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept>","source":"Convert to **long**; convert **long** to **double**"},{"content":"Preserve low-order byte","pos":[3660,3683]},{"content":"short","pos":[3706,3711]},{"content":"Preserve low-order word","pos":[3714,3737]},{"content":"long","pos":[3760,3764]},{"content":"Preserve bit pattern; high-order bit becomes sign bit","pos":[3767,3820]},{"content":"Preserve low-order byte","pos":[3857,3880]},{"content":"unsigned short","pos":[3903,3917]},{"content":"Preserve low-order word","pos":[3920,3943]},{"content":"float","pos":[3966,3971]},{"pos":[3974,4024],"content":"Convert to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>float<ept id=\"p3\">**</ept>","source":"Convert to **long**; convert **long** to **float**"},{"content":"double","pos":[4047,4053]},{"pos":[4056,4086],"content":"Convert directly to <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>","source":"Convert directly to **double**"},{"pos":[4121,4172],"content":"Convert to <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; convert <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept>","source":"Convert to **long**; convert **long** to **double**"},{"content":"Microsoft Specific","pos":[4182,4200]},{"content":"For the Microsoft 32-bit C compiler, the <ph id=\"ph1\">`unsigned int`</ph> type is equivalent to the <ph id=\"ph2\">`unsigned long`</ph> type.","pos":[4209,4312],"source":"For the Microsoft 32-bit C compiler, the `unsigned int` type is equivalent to the `unsigned long` type."},{"content":"Conversion of an <ph id=\"ph1\">`unsigned int`</ph> value proceeds in the same way as conversion of an <ph id=\"ph2\">`unsigned long`</ph>.","pos":[4313,4412],"source":" Conversion of an `unsigned int` value proceeds in the same way as conversion of an `unsigned long`."},{"content":"Conversions from <ph id=\"ph1\">`unsigned long`</ph> values to <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept> are not accurate if the value being converted is larger than the maximum positive signed <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> value.","pos":[4413,4570],"source":" Conversions from `unsigned long` values to **float** are not accurate if the value being converted is larger than the maximum positive signed **long** value."},{"content":"END Microsoft Specific","pos":[4579,4601]},{"content":"See Also","pos":[4612,4620]},{"content":"Assignment Conversions","pos":[4625,4647]}],"content":"---\ntitle: \"Conversions from Unsigned Integral Types | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"integers, converting\"\n  - \"type casts, involving integers\"\n  - \"data type conversion [C++], signed and unsigned integers\"\n  - \"type conversion [C++], signed and unsigned integers\"\n  - \"integral conversions, from unsigned\"\nms.assetid: 60fb7e10-bff9-4a13-8a48-e19f25a36a02\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Conversions from Unsigned Integral Types\nAn unsigned integer is converted to a shorter unsigned or signed integer by truncating the high-order bits, or to a longer unsigned or signed integer by zero-extending (see the [Conversions from Unsigned Integral Types](#_clang_table_4..3) table).  \n  \n When the value with integral type is demoted to a signed integer with smaller size, or an unsigned integer is converted to its corresponding signed integer, the value is unchanged if it can be represented in the new type. However, the value it represents changes if the sign bit is set, as in the following example.  \n  \n```  \nint j;  \nunsigned short k = 65533;  \n  \nj = k;  \nprintf_s( \"%hd\\n\", j );   // Prints -3  \n```  \n  \n If it cannot be represented, the result is implementation-defined. See [Type-Cast Conversions](../c-language/type-cast-conversions.md) for information on the Microsoft C compiler's handling of demotion of integers. The same behavior results from integer conversion or from type casting the integer.  \n  \n Unsigned values are converted in a way that preserves their value and is not representable directly in C. The only exception is a conversion from `unsigned long` to **float**, which loses at most the low-order bits. Otherwise, value is preserved, signed or unsigned. When a value of integral type is converted to floating, and the value is outside the range representable, the result is undefined. (See [Storage of Basic Types](../c-language/storage-of-basic-types.md) for information about the range for integral and floating-point types.)  \n  \n The following table summarizes conversions from unsigned integral types.  \n  \n### Conversions from Unsigned Integral Types  \n  \n|From|To|Method|  \n|----------|--------|------------|  \n|`unsigned char`|`char`|Preserve bit pattern; high-order bit becomes sign bit|  \n|`unsigned char`|**short**|Zero-extend|  \n|`unsigned char`|**long**|Zero-extend|  \n|`unsigned char`|**unsigned short**|Zero-extend|  \n|`unsigned char`|`unsigned long`|Zero-extend|  \n|`unsigned char`|**float**|Convert to **long**; convert **long** to **float**|  \n|`unsigned char`|**double**|Convert to **long**; convert **long** to **double**|  \n|`unsigned char`|`long double`|Convert to **long**; convert **long** to **double**|  \n|**unsigned short**|`char`|Preserve low-order byte|  \n|**unsigned short**|**short**|Preserve bit pattern; high-order bit becomes sign bit|  \n|**unsigned short**|**long**|Zero-extend|  \n|**unsigned short**|`unsigned char`|Preserve low-order byte|  \n|**unsigned short**|`unsigned long`|Zero-extend|  \n|**unsigned short**|**float**|Convert to **long**; convert **long** to **float**|  \n|**unsigned short**|**double**|Convert to **long**; convert **long** to **double**|  \n|**unsigned short**|`long double`|Convert to **long**; convert **long** to **double**|  \n|`unsigned long`|`char`|Preserve low-order byte|  \n|`unsigned long`|**short**|Preserve low-order word|  \n|`unsigned long`|**long**|Preserve bit pattern; high-order bit becomes sign bit|  \n|`unsigned long`|`unsigned char`|Preserve low-order byte|  \n|`unsigned long`|**unsigned short**|Preserve low-order word|  \n|`unsigned long`|**float**|Convert to **long**; convert **long** to **float**|  \n|`unsigned long`|**double**|Convert directly to **double**|  \n|`unsigned long`|`long double`|Convert to **long**; convert **long** to **double**|  \n  \n **Microsoft Specific**  \n  \n For the Microsoft 32-bit C compiler, the `unsigned int` type is equivalent to the `unsigned long` type. Conversion of an `unsigned int` value proceeds in the same way as conversion of an `unsigned long`. Conversions from `unsigned long` values to **float** are not accurate if the value being converted is larger than the maximum positive signed **long** value.  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [Assignment Conversions](../c-language/assignment-conversions.md)"}