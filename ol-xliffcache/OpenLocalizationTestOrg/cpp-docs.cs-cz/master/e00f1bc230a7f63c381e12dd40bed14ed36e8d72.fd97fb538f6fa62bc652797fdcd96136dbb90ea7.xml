{"nodes":[{"pos":[12,37],"content":"init_seg | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"init_seg | Microsoft Docs","pos":[0,25]}]},{"content":"init_seg","pos":[690,698]},{"content":"C++ Specific","pos":[701,713]},{"content":"Specifies a keyword or code section that affects the order in which startup code is executed.","pos":[722,815]},{"content":"Syntax","pos":[824,830]},{"content":"Remarks","pos":[934,941]},{"pos":[945,1028],"content":"The meaning of the terms <bpt id=\"p1\">*</bpt>segment<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>section<ept id=\"p2\">*</ept> are interchangeable in this topic.","source":"The meaning of the terms *segment* and *section* are interchangeable in this topic."},{"content":"Because initialization of global static objects can involve executing code, you must specify a keyword that defines when the objects are to be constructed.","pos":[1035,1190]},{"content":"It is particularly important to use the <bpt id=\"p1\">**</bpt>init_seg<ept id=\"p1\">**</ept> pragma in dynamic-link libraries (DLLs) or libraries requiring initialization.","pos":[1191,1322],"source":" It is particularly important to use the **init_seg** pragma in dynamic-link libraries (DLLs) or libraries requiring initialization."},{"pos":[1329,1372],"content":"The options to the <bpt id=\"p1\">**</bpt>init_seg<ept id=\"p1\">**</ept> pragma are:","source":"The options to the **init_seg** pragma are:"},{"content":"compiler","pos":[1381,1389]},{"content":"Reserved for Microsoft C run-time library initialization.","pos":[1395,1452]},{"content":"Objects in this group are constructed first.","pos":[1453,1497]},{"content":"lib","pos":[1506,1509]},{"content":"Available for third-party class-library vendors' initializations.","pos":[1515,1580]},{"content":"Objects in this group are constructed after those marked as <bpt id=\"p1\">**</bpt>compiler<ept id=\"p1\">**</ept> but before any others.","pos":[1581,1676],"source":" Objects in this group are constructed after those marked as **compiler** but before any others."},{"content":"user","pos":[1685,1689]},{"content":"Available to any user.","pos":[1695,1717]},{"content":"Objects in this group are constructed last.","pos":[1718,1761]},{"content":"section-name","pos":[1769,1781]},{"content":"Allows explicit specification of the initialization section.","pos":[1786,1846]},{"content":"Objects in a user-specified <bpt id=\"p1\">*</bpt>section-name<ept id=\"p1\">*</ept> are not implicitly constructed; however, their addresses are placed in the section named by <bpt id=\"p2\">*</bpt>section-name<ept id=\"p2\">*</ept>.","pos":[1847,1997],"source":" Objects in a user-specified *section-name* are not implicitly constructed; however, their addresses are placed in the section named by *section-name*."},{"content":"The section name you give will contain pointers to helper functions that will construct the global objects declared in that module after the pragma.","pos":[2004,2152]},{"pos":[2159,2296],"content":"For a list of names you should not use when creating a section, see <bpt id=\"p1\">[</bpt>/SECTION<ept id=\"p1\">](../build/reference/section-specify-section-attributes.md)</ept>.","source":"For a list of names you should not use when creating a section, see [/SECTION](../build/reference/section-specify-section-attributes.md)."},{"content":"func-name","pos":[2304,2313]},{"content":"Specifies a function to be called in place of <ph id=\"ph1\">`atexit`</ph> when the program exits.","pos":[2318,2396],"source":" Specifies a function to be called in place of `atexit` when the program exits."},{"content":"This helper function also calls <bpt id=\"p1\">[</bpt>atexit<ept id=\"p1\">](../c-runtime-library/reference/atexit.md)</ept> with a pointer to the destructor for the global object.","pos":[2397,2535],"source":" This helper function also calls [atexit](../c-runtime-library/reference/atexit.md) with a pointer to the destructor for the global object."},{"content":"If you specify a function identifier in the pragma of the form,","pos":[2536,2599]},{"content":"then your function will be called instead of the C run-time library's <ph id=\"ph1\">`atexit`</ph>.","pos":[2669,2748],"source":"then your function will be called instead of the C run-time library's `atexit`."},{"content":"This allows you to build a list of the destructors that will need to be called when you are ready to destroy the objects.","pos":[2749,2870]},{"content":"If you need to defer initialization (for example, in a DLL) you may choose to specify the section name explicitly.","pos":[2877,2991]},{"content":"You must then call the constructors for each static object.","pos":[2992,3051]},{"pos":[3058,3129],"content":"There are no quotes around the identifier for the <ph id=\"ph1\">`atexit`</ph> replacement.","source":"There are no quotes around the identifier for the `atexit` replacement."},{"content":"Your objects will still be placed in the sections defined by the other XXX_seg pragmas.","pos":[3136,3223]},{"content":"The objects that are declared in the module will not be automatically initialized by the C run-time.","pos":[3230,3330]},{"content":"You will need to do that yourself.","pos":[3331,3365]},{"content":"By default, <ph id=\"ph1\">`init_seg`</ph> sections are read only.","pos":[3372,3418],"source":"By default, `init_seg` sections are read only."},{"content":"If the section name is .CRT, the compiler will silently change the attribute to read only, even if it is marked as read, write.","pos":[3419,3546]},{"pos":[3553,3622],"content":"You cannot specify <bpt id=\"p1\">**</bpt>init_seg<ept id=\"p1\">**</ept> more than once in a translation unit.","source":"You cannot specify **init_seg** more than once in a translation unit."},{"content":"Even if your object does not have a user-defined constructor, a constructor not explicitly defined in code, the compiler may generate one (for example to bind v-table pointers).","pos":[3629,3806]},{"content":"Therefore, your code will have to call the compiler-generated constructor.","pos":[3808,3882]},{"content":"Example","pos":[3891,3898]},{"content":"See Also","pos":[5746,5754]},{"content":"Pragma Directives and the __Pragma Keyword","pos":[5759,5801]}],"content":"---\ntitle: \"init_seg | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc-pragma.init_seg\"\n  - \"init_seg_CPP\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"pragmas, init_seg\"\n  - \"init_seg pragma\"\n  - \"data segment initializing [C++]\"\nms.assetid: 40a5898a-5c85-4aa9-8d73-3d967eb13610\ncaps.latest.revision: 13\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# init_seg\n**C++ Specific**  \n  \n Specifies a keyword or code section that affects the order in which startup code is executed.  \n  \n## Syntax  \n  \n```  \n  \n#pragma init_seg({ compiler | lib | user | \"section-name\" [, func-name]} )  \n```  \n  \n## Remarks  \n The meaning of the terms *segment* and *section* are interchangeable in this topic.  \n  \n Because initialization of global static objects can involve executing code, you must specify a keyword that defines when the objects are to be constructed. It is particularly important to use the **init_seg** pragma in dynamic-link libraries (DLLs) or libraries requiring initialization.  \n  \n The options to the **init_seg** pragma are:  \n  \n **compiler**  \n Reserved for Microsoft C run-time library initialization. Objects in this group are constructed first.  \n  \n **lib**  \n Available for third-party class-library vendors' initializations. Objects in this group are constructed after those marked as **compiler** but before any others.  \n  \n **user**  \n Available to any user. Objects in this group are constructed last.  \n  \n *section-name*  \n Allows explicit specification of the initialization section. Objects in a user-specified *section-name* are not implicitly constructed; however, their addresses are placed in the section named by *section-name*.  \n  \n The section name you give will contain pointers to helper functions that will construct the global objects declared in that module after the pragma.  \n  \n For a list of names you should not use when creating a section, see [/SECTION](../build/reference/section-specify-section-attributes.md).  \n  \n *func-name*  \n Specifies a function to be called in place of `atexit` when the program exits. This helper function also calls [atexit](../c-runtime-library/reference/atexit.md) with a pointer to the destructor for the global object. If you specify a function identifier in the pragma of the form,  \n  \n```  \nint __cdecl myexit (void (__cdecl *pf)(void))  \n```  \n  \n then your function will be called instead of the C run-time library's `atexit`. This allows you to build a list of the destructors that will need to be called when you are ready to destroy the objects.  \n  \n If you need to defer initialization (for example, in a DLL) you may choose to specify the section name explicitly. You must then call the constructors for each static object.  \n  \n There are no quotes around the identifier for the `atexit` replacement.  \n  \n Your objects will still be placed in the sections defined by the other XXX_seg pragmas.  \n  \n The objects that are declared in the module will not be automatically initialized by the C run-time. You will need to do that yourself.  \n  \n By default, `init_seg` sections are read only. If the section name is .CRT, the compiler will silently change the attribute to read only, even if it is marked as read, write.  \n  \n You cannot specify **init_seg** more than once in a translation unit.  \n  \n Even if your object does not have a user-defined constructor, a constructor not explicitly defined in code, the compiler may generate one (for example to bind v-table pointers).  Therefore, your code will have to call the compiler-generated constructor.  \n  \n## Example  \n  \n```  \n// pragma_directive_init_seg.cpp  \n#include <stdio.h>  \n#pragma warning(disable : 4075)  \n  \ntypedef void (__cdecl *PF)(void);  \nint cxpf = 0;   // number of destructors we need to call  \nPF pfx[200];    // pointers to destructors.  \n  \nint myexit (PF pf) {  \n   pfx[cxpf++] = pf;  \n   return 0;  \n}  \n  \nstruct A {  \n   A() { puts(\"A()\"); }  \n   ~A() { puts(\"~A()\"); }  \n};  \n  \n// ctor & dtor called by CRT startup code   \n// because this is before the pragma init_seg  \nA aaaa;   \n  \n// The order here is important.  \n// Section names must be 8 characters or less.  \n// The sections with the same name before the $  \n// are merged into one section. The order that  \n// they are merged is determined by sorting  \n// the characters after the $.  \n// InitSegStart and InitSegEnd are used to set  \n// boundaries so we can find the real functions  \n// that we need to call for initialization.  \n  \n#pragma section(\".mine$a\", read)  \n__declspec(allocate(\".mine$a\")) const PF InitSegStart = (PF)1;  \n  \n#pragma section(\".mine$z\",read)  \n__declspec(allocate(\".mine$z\")) const PF InitSegEnd = (PF)1;  \n  \n// The comparison for 0 is important.  \n// For now, each section is 256 bytes. When they  \n// are merged, they are padded with zeros. You  \n// can't depend on the section being 256 bytes, but  \n// you can depend on it being padded with zeros.  \n  \nvoid InitializeObjects () {  \n   const PF *x = &InitSegStart;  \n   for (++x ; x < &InitSegEnd ; ++x)  \n      if (*x) (*x)();  \n}  \n  \nvoid DestroyObjects () {  \n   while (cxpf>0) {  \n      --cxpf;  \n      (pfx[cxpf])();  \n   }  \n}  \n  \n// by default, goes into a read only section  \n#pragma init_seg(\".mine$m\", myexit)  \n  \nA bbbb;   \nA cccc;  \n  \nint main () {  \n   InitializeObjects();  \n   DestroyObjects();  \n}  \n```  \n  \n```Output  \nA()  \nA()  \nA()  \n~A()  \n~A()  \n~A()  \n```  \n  \n## See Also  \n [Pragma Directives and the __Pragma Keyword](../preprocessor/pragma-directives-and-the-pragma-keyword.md)"}