{"nodes":[{"pos":[12,64],"content":"_InterlockedAnd Intrinsic Functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_InterlockedAnd Intrinsic Functions | Microsoft Docs","pos":[0,52]}]},{"content":"_InterlockedAnd Intrinsic Functions","pos":[2253,2288]},{"content":"Microsoft Specific","pos":[2291,2309]},{"content":"Used to perform an atomic bitwise AND operation on a variable shared by multiple threads.","pos":[2318,2407]},{"content":"Syntax","pos":[2416,2422]},{"content":"Parameters","pos":[4377,4387]},{"content":"[in, out]","pos":[4391,4400]},{"content":"A pointer to the first operand, to be replaced by the result.","pos":[4412,4473]},{"content":"[in]","pos":[4480,4484]},{"content":"The second operand.","pos":[4495,4514]},{"content":"Return Value","pos":[4523,4535]},{"content":"The original value of the first operand.","pos":[4539,4579]},{"content":"Requirements","pos":[4588,4600]},{"content":"Intrinsic","pos":[4607,4616]},{"content":"Architecture","pos":[4617,4629]},{"content":"Header","pos":[4630,4636]},{"pos":[4710,4752],"content":", <ph id=\"ph1\">`_InterlockedAnd8`</ph>, <ph id=\"ph2\">`_InterlockedAnd16`</ph>,","source":", `_InterlockedAnd8`, `_InterlockedAnd16`, "},{"pos":[4773,4782],"content":"x86, ARM,"},{"content":"intrin.h&gt;","pos":[4849,4858],"source":"intrin.h>"},{"pos":[4884,5124],"content":", <ph id=\"ph1\">`_InterlockedAnd_nf`</ph>, <ph id=\"ph2\">`_InterlockedAnd_rel`</ph>, <ph id=\"ph3\">`_InterlockedAnd8_acq`</ph>, <ph id=\"ph4\">`_InterlockedAnd8_nf`</ph>, <ph id=\"ph5\">`_InterlockedAnd8_rel`</ph>, <ph id=\"ph6\">`_InterlockedAnd16_acq`</ph>, <ph id=\"ph7\">`_InterlockedAnd16_nf`</ph>, <ph id=\"ph8\">`_InterlockedAnd16_rel`</ph>, <ph id=\"ph9\">`_InterlockedAnd64_acq`</ph>, <ph id=\"ph10\">`_InterlockedAnd64_nf`</ph>,","source":", `_InterlockedAnd_nf`, `_InterlockedAnd_rel`, `_InterlockedAnd8_acq`, `_InterlockedAnd8_nf`, `_InterlockedAnd8_rel`, `_InterlockedAnd16_acq`, `_InterlockedAnd16_nf`, `_InterlockedAnd16_rel`, `_InterlockedAnd64_acq`, `_InterlockedAnd64_nf`, "},{"content":"ARM","pos":[5149,5152]},{"content":"intrin.h&gt;","pos":[5155,5164],"source":"intrin.h>"},{"pos":[5189,5237],"content":", <ph id=\"ph1\">`_InterlockedAnd8_np`</ph>, <ph id=\"ph2\">`_InterlockedAnd16_np`</ph>,","source":", `_InterlockedAnd8_np`, `_InterlockedAnd16_np`, "},{"content":"intrin.h&gt;","pos":[5327,5336],"source":"intrin.h>"},{"pos":[5369,5432],"content":", <ph id=\"ph1\">`_InterlockedAnd_HLERelease`</ph>, <ph id=\"ph2\">`_InterlockedAnd64_HLEAcquire`</ph>,","source":", `_InterlockedAnd_HLERelease`, `_InterlockedAnd64_HLEAcquire`, "},{"pos":[5464,5468],"content":"x86,"},{"content":"immintrin.h&gt;","pos":[5535,5547],"source":"immintrin.h>"},{"content":"Remarks","pos":[5557,5564]},{"content":"The number in the name of each function specifies the bit size of the arguments.","pos":[5568,5648]},{"content":"On ARM platforms, use the intrinsics with <ph id=\"ph1\">`_acq`</ph> and <ph id=\"ph2\">`_rel`</ph> suffixes for acquire and release semantics, such as at the beginning and end of a critical section.","pos":[5655,5814],"source":"On ARM platforms, use the intrinsics with `_acq` and `_rel` suffixes for acquire and release semantics, such as at the beginning and end of a critical section."},{"content":"The intrinsics with an <ph id=\"ph1\">`_nf`</ph> (\"no fence\") suffix do not act as a memory barrier.","pos":[5815,5895],"source":" The intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier."},{"pos":[5902,6028],"content":"The intrinsics with an <ph id=\"ph1\">`_np`</ph> (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler.","source":"The intrinsics with an `_np` (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler."},{"content":"On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with <ph id=\"ph1\">`_HLEAcquire`</ph> and <ph id=\"ph2\">`_HLERelease`</ph> suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware.","pos":[6035,6279],"source":"On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware."},{"content":"If these intrinsics are called on platforms that do not support HLE, the hint is ignored.","pos":[6280,6369]},{"content":"Example","pos":[6378,6385]},{"content":"END Microsoft Specific","pos":[6818,6840]},{"content":"See Also","pos":[6849,6857]},{"content":"Compiler Intrinsics","pos":[6862,6881]},{"content":"Conflicts with the x86 Compiler","pos":[6926,6957]}],"content":"---\ntitle: \"_InterlockedAnd Intrinsic Functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_InterlockedAnd_rel\"\n  - \"_InterlockedAnd_cpp\"\n  - \"_InterlockedAnd8_nf\"\n  - \"_InterlockedAnd\"\n  - \"_InterlockedAnd_HLERelease\"\n  - \"_InterlockedAnd8_np\"\n  - \"_InterlockedAnd16_rel\"\n  - \"_InterlockedAnd64_np\"\n  - \"_InterlockedAnd_np\"\n  - \"_InterlockedAnd64_HLERelease\"\n  - \"_InterlockedAnd64\"\n  - \"_InterlockedAnd64_nf\"\n  - \"_InterlockedAnd64_HLEAcquire\"\n  - \"_InterlockedAnd16\"\n  - \"_InterlockedAnd16_nf\"\n  - \"_InterlockedAnd8\"\n  - \"_InterlockedAnd_HLEAcquire\"\n  - \"_InterlockedAnd_acq\"\n  - \"_InterlockedAnd16_np\"\n  - \"_InterlockedAnd64_cpp\"\n  - \"_InterlockedAnd64_acq\"\n  - \"_InterlockedAnd16_acq\"\n  - \"_InterlockedAnd8_acq\"\n  - \"_InterlockedAnd64_rel\"\n  - \"_InterlockedAnd_nf\"\n  - \"_InterlockedAnd8_rel\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"_InterlockedAnd64_np intrinsic\"\n  - \"_InterlockedAnd intrinsic\"\n  - \"_InterlockedAnd64 intrinsic\"\n  - \"_InterlockedAnd8_rel intrinsic\"\n  - \"InterlockedAnd64 intrinsic\"\n  - \"_InterlockedAnd16_np intrinsic\"\n  - \"_InterlockedAnd64_nf intrinsic\"\n  - \"_InterlockedAnd_nf intrinsic\"\n  - \"_InterlockedAnd_np intrinsic\"\n  - \"_InterlockedAnd64_HLERelease intrinsic\"\n  - \"_InterlockedAnd16_rel intrinsic\"\n  - \"_InterlockedAnd_HLERelease intrinsic\"\n  - \"_InterlockedAnd64_acq intrinsic\"\n  - \"_InterlockedAnd16 intrinsic\"\n  - \"_InterlockedAnd8_nf intrinsic\"\n  - \"_InterlockedAnd64_rel intrinsic\"\n  - \"_InterlockedAnd8_np intrinsic\"\n  - \"_InterlockedAnd_rel intrinsic\"\n  - \"InterlockedAnd intrinsic\"\n  - \"_InterlockedAnd8_acq intrinsic\"\n  - \"_InterlockedAnd_acq intrinsic\"\n  - \"_InterlockedAnd64_HLEAcquire intrinsic\"\n  - \"_InterlockedAnd16_acq intrinsic\"\n  - \"_InterlockedAnd16_nf intrinsic\"\n  - \"_InterlockedAnd8 intrinsic\"\n  - \"_InterlockedAnd_HLEAcquire intrinsic\"\nms.assetid: ad271dc3-42cd-47d0-9f65-30d5cfeb66fc\ncaps.latest.revision: 19\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _InterlockedAnd Intrinsic Functions\n**Microsoft Specific**  \n  \n Used to perform an atomic bitwise AND operation on a variable shared by multiple threads.  \n  \n## Syntax  \n  \n```  \nlong _InterlockedAnd(  \n   long volatile * value,  \n   long mask  \n);  \nlong _InterlockedAnd_acq(  \n   long volatile * value,  \n   long mask  \n);  \nlong _InterlockedAnd_HLEAcquire(  \n   long volatile * value,  \n   long mask  \n);  \nlong _InterlockedAnd_HLERelease(  \n   long volatile * value,  \n   long mask  \n);  \nlong _InterlockedAnd_nf(  \n   long volatile * value,  \n   long mask  \n);  \nlong _InterlockedAnd_np(  \n   long volatile * value,  \n   long mask  \n);  \nlong _InterlockedAnd_rel(  \n   long volatile * value,  \n   long mask  \n);  \nchar _InterlockedAnd8(  \n   char volatile * value,  \n   char mask  \n);  \nchar _InterlockedAnd8_acq(  \n   char volatile * value,  \n   char mask  \n);  \nchar _InterlockedAnd8_nf(  \n   char volatile * value,  \n   char mask  \n);  \nchar _InterlockedAnd8_np(  \n   char volatile * value,  \n   char mask  \n);  \nchar _InterlockedAnd8_rel(  \n   char volatile * value,  \n   char mask  \n);  \nshort _InterlockedAnd16(  \n   short volatile * value,  \n   short mask  \n);  \nshort _InterlockedAnd16_acq(  \n   short volatile * value,  \n   short mask  \n);  \nshort _InterlockedAnd16_nf(  \n   short volatile * value,  \n   short mask  \n);  \nshort _InterlockedAnd16_np(  \n   short volatile * value,  \n   short mask  \n);  \nshort _InterlockedAnd16_rel(  \n   short volatile * value,  \n   short mask  \n);  \n__int64 _InterlockedAnd64(  \n   __int64 volatile* value,  \n   __int64 mask  \n);  \n__int64 _InterlockedAnd64_acq(  \n   __int64 volatile* value,  \n   __int64 mask  \n);   \n__int64 _InterlockedAnd64_HLEAcquire(  \n   __int64 volatile* value,  \n   __int64 mask  \n);  \n__int64 _InterlockedAnd64_HLERelease(  \n   __int64 volatile* value,  \n   __int64 mask  \n);  \n__int64 _InterlockedAnd64_nf(  \n   __int64 volatile* value,  \n   __int64 mask  \n);  \n__int64 _InterlockedAnd64_np(  \n   __int64 volatile* value,  \n   __int64 mask  \n);  \n__int64 _InterlockedAnd64_rel(  \n   __int64 volatile* value,  \n   __int64 mask  \n);  \n```  \n  \n#### Parameters  \n [in, out] `value`  \n A pointer to the first operand, to be replaced by the result.  \n  \n [in] `mask`  \n The second operand.  \n  \n## Return Value  \n The original value of the first operand.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|Header|  \n|---------------|------------------|------------|  \n|`_InterlockedAnd`, `_InterlockedAnd8`, `_InterlockedAnd16`, `_InterlockedAnd64`|x86, ARM, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_InterlockedAnd_acq`, `_InterlockedAnd_nf`, `_InterlockedAnd_rel`, `_InterlockedAnd8_acq`, `_InterlockedAnd8_nf`, `_InterlockedAnd8_rel`, `_InterlockedAnd16_acq`, `_InterlockedAnd16_nf`, `_InterlockedAnd16_rel`, `_InterlockedAnd64_acq`, `_InterlockedAnd64_nf`, `_InterlockedAnd64_rel`|ARM|\\<intrin.h>|  \n|`_InterlockedAnd_np`, `_InterlockedAnd8_np`, `_InterlockedAnd16_np`, `_InterlockedAnd64_np`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_InterlockedAnd_HLEAcquire`, `_InterlockedAnd_HLERelease`, `_InterlockedAnd64_HLEAcquire`, `_InterlockedAnd64_HLERelease`|x86, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<immintrin.h>|  \n  \n## Remarks  \n The number in the name of each function specifies the bit size of the arguments.  \n  \n On ARM platforms, use the intrinsics with `_acq` and `_rel` suffixes for acquire and release semantics, such as at the beginning and end of a critical section. The intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier.  \n  \n The intrinsics with an `_np` (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler.  \n  \n On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware. If these intrinsics are called on platforms that do not support HLE, the hint is ignored.  \n  \n## Example  \n  \n```  \n// InterlockedAnd.cpp  \n// Compile with: /Oi  \n#include <stdio.h>  \n#include <intrin.h>  \n  \n#pragma intrinsic(_InterlockedAnd)  \n  \nint main()  \n{  \n        long data1 = 0xFF00FF00;  \n        long data2 = 0x00FFFF00;  \n        long retval;  \n        retval = _InterlockedAnd(&data1, data2);  \n        printf_s(\"0x%x 0x%x 0x%x\", data1, data2, retval);   \n}  \n```  \n  \n```Output  \n0xff00 0xffff00 0xff00ff00  \n```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)   \n [Conflicts with the x86 Compiler](../build/conflicts-with-the-x86-compiler.md)"}