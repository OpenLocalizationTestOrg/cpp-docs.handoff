{"nodes":[{"pos":[12,70],"content":"Determining Which Type of Accessor to Use | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Determining Which Type of Accessor to Use | Microsoft Docs","pos":[0,58]}]},{"content":"Determining Which Type of Accessor to Use","pos":[633,674]},{"content":"You can determine data types on a rowset at compile time or at run time.","pos":[675,747]},{"content":"If you need to determine data types at compile time, use a static accessor (such as <ph id=\"ph1\">`CAccessor`</ph>).","pos":[754,851],"source":"If you need to determine data types at compile time, use a static accessor (such as `CAccessor`)."},{"content":"You can determine the data types manually or by using the ATL OLE DB Consumer Wizard.","pos":[852,937]},{"content":"If you need to determine the data types at run time, use a dynamic (<ph id=\"ph1\">`CDynamicAccessor`</ph> or its children) or manual accessor (<ph id=\"ph2\">`CManualAccessor`</ph>).","pos":[944,1087],"source":"If you need to determine the data types at run time, use a dynamic (`CDynamicAccessor` or its children) or manual accessor (`CManualAccessor`)."},{"content":"In these cases, you can call <ph id=\"ph1\">`GetColumnInfo`</ph> on the rowset to return the column binding information, from which you can determine types.","pos":[1088,1224],"source":" In these cases, you can call `GetColumnInfo` on the rowset to return the column binding information, from which you can determine types."},{"content":"The following table lists the types of accessors provided in the consumer templates.","pos":[1231,1315]},{"content":"Each accessor has advantages and disadvantages.","pos":[1316,1363]},{"content":"Depending on your situation, one accessor type should suit your needs.","pos":[1364,1434]},{"content":"Accessor class","pos":[1441,1455]},{"content":"Binding","pos":[1456,1463]},{"content":"Parameter","pos":[1464,1473]},{"content":"Comment","pos":[1474,1481]},{"content":"Create a user record with <ph id=\"ph1\">`COLUMN_ENTRY`</ph> macros.","pos":[1567,1615],"source":"Create a user record with `COLUMN_ENTRY` macros."},{"content":"The macros bind a data member in that record to the accessor.","pos":[1616,1677]},{"content":"When the rowset is created, columns cannot be unbound.","pos":[1678,1732]},{"content":"Yes, by using a <bpt id=\"p1\">**</bpt>PARAM_MAP<ept id=\"p1\">**</ept> macro entry.","pos":[1733,1775],"source":"Yes, by using a **PARAM_MAP** macro entry."},{"content":"Once bound, parameters cannot be unbound.","pos":[1776,1817]},{"content":"Fastest accessor because of small amount of code.","pos":[1818,1867]},{"content":"Automatic.","pos":[1891,1901]},{"content":"No.","pos":[1902,1905]},{"content":"Useful if you do not know the type of data in a rowset.","pos":[1906,1961]},{"pos":[1994,2080],"content":"Automatic, but can be <bpt id=\"p1\">[</bpt>overridden<ept id=\"p1\">](../../data/oledb/overriding-a-dynamic-accessor.md)</ept>.","source":"Automatic, but can be [overridden](../../data/oledb/overriding-a-dynamic-accessor.md)."},{"content":"Yes, if the provider supports <ph id=\"ph1\">`ICommandWithParameters`</ph>.","pos":[2081,2136],"source":"Yes, if the provider supports `ICommandWithParameters`."},{"content":"Parameters bound automatically.","pos":[2137,2168]},{"pos":[2169,2249],"content":"Slower than <ph id=\"ph1\">`CDynamicAccessor`</ph> but useful for calling generic stored procedures.","source":"Slower than `CDynamicAccessor` but useful for calling generic stored procedures."},{"content":"CDynamicStringAccessor[A,W]","pos":[2256,2283]},{"content":"Automatic.","pos":[2286,2296]},{"content":"No.","pos":[2297,2300]},{"content":"Retrieves data accessed from the data store as string data.","pos":[2301,2360]},{"pos":[2383,2411],"content":"Manual using <ph id=\"ph1\">`AddBindEntry`</ph>.","source":"Manual using `AddBindEntry`."},{"pos":[2412,2447],"content":"Manually using <ph id=\"ph1\">`AddParameterEntry`</ph>.","source":"Manually using `AddParameterEntry`."},{"content":"Very fast; parameters and columns bound only once.","pos":[2448,2498]},{"content":"You determine the type of data to use.","pos":[2499,2537]},{"content":"(See <bpt id=\"p1\">[</bpt>DBVIEWER<ept id=\"p1\">](http://msdn.microsoft.com/en-us/07620f99-c347-4d09-9ebc-2459e8049832)</ept> sample for an example.) Requires more code than <ph id=\"ph1\">`CDynamicAccessor`</ph> or <ph id=\"ph2\">`CAccessor`</ph>.","pos":[2538,2706],"source":" (See [DBVIEWER](http://msdn.microsoft.com/en-us/07620f99-c347-4d09-9ebc-2459e8049832) sample for an example.) Requires more code than `CDynamicAccessor` or `CAccessor`."},{"content":"It is more like calling OLE DB directly.","pos":[2707,2747]},{"content":"Automatic.","pos":[2767,2777]},{"content":"No.","pos":[2778,2781]},{"content":"Retrieves data accessed from the data store as string data and formats it as XML-tagged data.","pos":[2782,2875]},{"content":"See Also","pos":[2885,2893]},{"content":"Using Accessors","pos":[2898,2913]}],"content":"---\ntitle: \"Determining Which Type of Accessor to Use | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"rowsets [C++], data types\"\n  - \"accessors [C++], types\"\nms.assetid: 22483dd2-f4e0-4dcb-8e4d-cd43a9c1a3db\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Determining Which Type of Accessor to Use\nYou can determine data types on a rowset at compile time or at run time.  \n  \n If you need to determine data types at compile time, use a static accessor (such as `CAccessor`). You can determine the data types manually or by using the ATL OLE DB Consumer Wizard.  \n  \n If you need to determine the data types at run time, use a dynamic (`CDynamicAccessor` or its children) or manual accessor (`CManualAccessor`). In these cases, you can call `GetColumnInfo` on the rowset to return the column binding information, from which you can determine types.  \n  \n The following table lists the types of accessors provided in the consumer templates. Each accessor has advantages and disadvantages. Depending on your situation, one accessor type should suit your needs.  \n  \n|Accessor class|Binding|Parameter|Comment|  \n|--------------------|-------------|---------------|-------------|  \n|`CAccessor`|Create a user record with `COLUMN_ENTRY` macros. The macros bind a data member in that record to the accessor. When the rowset is created, columns cannot be unbound.|Yes, by using a **PARAM_MAP** macro entry. Once bound, parameters cannot be unbound.|Fastest accessor because of small amount of code.|  \n|`CDynamicAccessor`|Automatic.|No.|Useful if you do not know the type of data in a rowset.|  \n|`CDynamicParameterAccessor`|Automatic, but can be [overridden](../../data/oledb/overriding-a-dynamic-accessor.md).|Yes, if the provider supports `ICommandWithParameters`. Parameters bound automatically.|Slower than `CDynamicAccessor` but useful for calling generic stored procedures.|  \n|**CDynamicStringAccessor[A,W]**|Automatic.|No.|Retrieves data accessed from the data store as string data.|  \n|`CManualAccessor`|Manual using `AddBindEntry`.|Manually using `AddParameterEntry`.|Very fast; parameters and columns bound only once. You determine the type of data to use. (See [DBVIEWER](http://msdn.microsoft.com/en-us/07620f99-c347-4d09-9ebc-2459e8049832) sample for an example.) Requires more code than `CDynamicAccessor` or `CAccessor`. It is more like calling OLE DB directly.|  \n|`CXMLAccessor`|Automatic.|No.|Retrieves data accessed from the data store as string data and formats it as XML-tagged data.|  \n  \n## See Also  \n [Using Accessors](../../data/oledb/using-accessors.md)"}