{"nodes":[{"pos":[12,40],"content":"stack Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"stack Class | Microsoft Docs","pos":[0,28]}]},{"content":"stack Class","pos":[645,656]},{"content":"A template container adaptor class that provides a restriction of functionality limiting access to the element most recently added to some underlying container type.","pos":[657,822]},{"content":"The stack class is used when it is important to be clear that only stack operations are being performed on the container.","pos":[823,944]},{"content":"Syntax","pos":[953,959]},{"content":"Parameters","pos":[1054,1064]},{"content":"Type","pos":[1069,1073]},{"content":"The element data type to be stored in the stack.","pos":[1078,1126]},{"content":"The type of the underlying container used to implement the stack.","pos":[1148,1213]},{"content":"The default value is the class <ph id=\"ph1\">`deque`</ph><bpt id=\"p1\">*</bpt><ph id=\"ph2\">\\&lt;</ph>Type&gt;<ept id=\"p1\">*</ept>.","pos":[1214,1262],"source":" The default value is the class `deque`*\\<Type>*."},{"content":"Remarks","pos":[1271,1278]},{"content":"The elements of class <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> stipulated in the first template parameter of a stack object are synonymous with <bpt id=\"p2\">[</bpt>value_type<ept id=\"p2\">](#stack__value_type)</ept> and must match the type of element in the underlying container class <bpt id=\"p3\">**</bpt>Container<ept id=\"p3\">**</ept> stipulated by the second template parameter.","pos":[1282,1554],"source":"The elements of class **Type** stipulated in the first template parameter of a stack object are synonymous with [value_type](#stack__value_type) and must match the type of element in the underlying container class **Container** stipulated by the second template parameter."},{"content":"The <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> must be assignable, so that it is possible to copy objects of that type and to assign values to variables of that type.","pos":[1555,1687],"source":" The **Type** must be assignable, so that it is possible to copy objects of that type and to assign values to variables of that type."},{"content":"Suitable underlying container classes for stack include <bpt id=\"p1\">[</bpt>deque<ept id=\"p1\">](../standard-library/deque-class.md)</ept>, <bpt id=\"p2\">[</bpt>list class<ept id=\"p2\">](../standard-library/list-class.md)</ept>, and <bpt id=\"p3\">[</bpt>vector class<ept id=\"p3\">](../standard-library/vector-class.md)</ept>, or any other sequence container that supports the operations of <bpt id=\"p4\">**</bpt>back<ept id=\"p4\">**</ept>, <ph id=\"ph1\">`push_back`</ph>, and <ph id=\"ph2\">`pop_back`</ph>.","pos":[1694,2003],"source":"Suitable underlying container classes for stack include [deque](../standard-library/deque-class.md), [list class](../standard-library/list-class.md), and [vector class](../standard-library/vector-class.md), or any other sequence container that supports the operations of **back**, `push_back`, and `pop_back`."},{"content":"The underlying container class is encapsulated within the container adaptor, which exposes only the limited set of the sequence container member functions as a public interface.","pos":[2004,2181]},{"pos":[2188,2400],"content":"The stack objects are equality comparable if and only if the elements of class <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> are equality comparable and are less-than comparable if and only if the elements of class <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept> are less-than comparable.","source":"The stack objects are equality comparable if and only if the elements of class **Type** are equality comparable and are less-than comparable if and only if the elements of class **Type** are less-than comparable."},{"content":"The stack class supports a last-in, first-out (LIFO) data structure.","pos":[2410,2478]},{"content":"A good analogue to keep in mind would be a stack of plates.","pos":[2479,2538]},{"content":"Elements (plates) may be inserted, inspected, or removed only from the top of the stack, which is the last element at the end of the base container.","pos":[2539,2687]},{"content":"The restriction to accessing only the top element is the reason for using the stack class.","pos":[2688,2778]},{"content":"The <bpt id=\"p1\">[</bpt>queue class<ept id=\"p1\">](../standard-library/queue-class.md)</ept> supports a first-in, first-out (FIFO) data structure.","pos":[2788,2895],"source":"The [queue class](../standard-library/queue-class.md) supports a first-in, first-out (FIFO) data structure."},{"content":"A good analogue to keep in mind would be people lining up for a bank teller.","pos":[2896,2972]},{"content":"Elements (people) may be added to the back of the line and are removed from the front of the line.","pos":[2973,3071]},{"content":"Both the front and the back of a line may be inspected.","pos":[3072,3127]},{"content":"The restriction to accessing only the front and back elements in this way is the reason fur using the queue class.","pos":[3128,3242]},{"content":"The <bpt id=\"p1\">[</bpt>priority_queue class<ept id=\"p1\">](../standard-library/priority-queue-class.md)</ept> orders its elements so that the largest element is always at the top position.","pos":[3252,3402],"source":"The [priority_queue class](../standard-library/priority-queue-class.md) orders its elements so that the largest element is always at the top position."},{"content":"It supports insertion of an element and the inspection and removal of the top element.","pos":[3403,3489]},{"content":"A good analogue to keep in mind would be people lining up where they are arranged by age, height, or some other criterion.","pos":[3490,3612]},{"content":"Constructors","pos":[3622,3634]},{"content":"stack","pos":[3656,3661]},{"pos":[3678,3758],"content":"Constructs a <ph id=\"ph1\">`stack`</ph> that is empty or that is a copy of a base container object.","source":"Constructs a `stack` that is empty or that is a copy of a base container object."},{"content":"Typedefs","pos":[3769,3777]},{"content":"container_type","pos":[3799,3813]},{"pos":[3839,3906],"content":"A type that provides the base container to be adapted by a <ph id=\"ph1\">`stack`</ph>.","source":"A type that provides the base container to be adapted by a `stack`."},{"content":"size_type","pos":[3912,3921]},{"pos":[3942,4022],"content":"An unsigned integer type that can represent the number of elements in a <ph id=\"ph1\">`stack`</ph>.","source":"An unsigned integer type that can represent the number of elements in a `stack`."},{"content":"value_type","pos":[4028,4038]},{"pos":[4060,4136],"content":"A type that represents the type of object stored as an element in a <ph id=\"ph1\">`stack`</ph>.","source":"A type that represents the type of object stored as an element in a `stack`."},{"content":"Member Functions","pos":[4147,4163]},{"content":"empty","pos":[4185,4190]},{"pos":[4207,4237],"content":"Tests if the <ph id=\"ph1\">`stack`</ph> is empty.","source":"Tests if the `stack` is empty."},{"content":"pop","pos":[4243,4246]},{"pos":[4261,4309],"content":"Removes the element from the top of the <ph id=\"ph1\">`stack`</ph>.","source":"Removes the element from the top of the `stack`."},{"content":"push","pos":[4315,4319]},{"pos":[4335,4377],"content":"Adds an element to the top of the <ph id=\"ph1\">`stack`</ph>.","source":"Adds an element to the top of the `stack`."},{"content":"size","pos":[4383,4387]},{"pos":[4403,4449],"content":"Returns the number of elements in the <ph id=\"ph1\">`stack`</ph>.","source":"Returns the number of elements in the `stack`."},{"content":"top","pos":[4455,4458]},{"pos":[4473,4533],"content":"Returns a reference to an element at the top of the <ph id=\"ph1\">`stack`</ph>.","source":"Returns a reference to an element at the top of the `stack`."},{"content":"Requirements","pos":[4543,4555]},{"pos":[4559,4579],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>stack&gt;","source":"**Header:** \\<stack>"},{"pos":[4586,4604],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[4652,4673],"content":"stack::container_type"},{"content":"A type that provides the base container to be adapted.","pos":[4677,4731]},{"content":"Remarks","pos":[4792,4799]},{"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Container`</ph>.","pos":[4803,4864],"source":"The type is a synonym for the template parameter `Container`."},{"content":"All three STL sequence container classes — the vector class, list class, and the default class deque — meet the requirements to be used as the base container for a stack object.","pos":[4865,5042]},{"content":"User-defined types satisfying these requirements may also be used.","pos":[5043,5109]},{"pos":[5116,5240],"content":"For more information on <ph id=\"ph1\">`Container`</ph>, see the Remarks section of the <bpt id=\"p1\">[</bpt>stack Class<ept id=\"p1\">](../standard-library/stack-class.md)</ept> topic.","source":"For more information on `Container`, see the Remarks section of the [stack Class](../standard-library/stack-class.md) topic."},{"content":"Example","pos":[5250,5257]},{"pos":[5262,5370],"content":"See the example for <bpt id=\"p1\">[</bpt>stack::stack<ept id=\"p1\">](#stack__stack)</ept> for an example of how to declare and use <ph id=\"ph1\">`container_type`</ph>.","source":"See the example for [stack::stack](#stack__stack) for an example of how to declare and use `container_type`."},{"pos":[5409,5421],"content":"stack::empty"},{"content":"Tests if a stack is empty.","pos":[5425,5451]},{"content":"Return Value","pos":[5496,5508]},{"pos":[5512,5579],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the stack is empty; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if the stack is nonempty.","source":"**true** if the stack is empty; **false** if the stack is nonempty."},{"content":"Example","pos":[5589,5596]},{"pos":[6251,6261],"content":"stack::pop"},{"content":"Removes the element from the top of the stack.","pos":[6265,6311]},{"content":"Remarks","pos":[6348,6355]},{"content":"The stack must be nonempty to apply the member function.","pos":[6359,6415]},{"content":"The top of the stack is the position occupied by the most recently added element and is the last element at the end of the container.","pos":[6416,6549]},{"content":"Example","pos":[6559,6566]},{"pos":[7500,7511],"content":"stack::push"},{"content":"Adds an element to the top end of the stack.","pos":[7515,7559]},{"content":"Parameters","pos":[7612,7622]},{"content":"The element added to the top of the stack.","pos":[7636,7678]},{"content":"Remarks","pos":[7688,7695]},{"content":"The top of the stack is the position occupied by the most recently added element and is the last element at the end of the container.","pos":[7699,7832]},{"content":"Example","pos":[7842,7849]},{"pos":[8438,8449],"content":"stack::size"},{"content":"Returns the number of elements in the stack.","pos":[8453,8497]},{"content":"Return Value","pos":[8546,8558]},{"content":"The current length of the stack.","pos":[8562,8594]},{"content":"Example","pos":[8604,8611]},{"pos":[9144,9160],"content":"stack::size_type"},{"content":"An unsigned integer type that can represent the number of elements in a stack.","pos":[9164,9242]},{"content":"Remarks","pos":[9318,9325]},{"pos":[9329,9410],"content":"The type is a synonym for <ph id=\"ph1\">`size_type`</ph> of the base container adapted by the stack.","source":"The type is a synonym for `size_type` of the base container adapted by the stack."},{"content":"Example","pos":[9420,9427]},{"pos":[9432,9526],"content":"See the example for <bpt id=\"p1\">[</bpt>size<ept id=\"p1\">](#stack__size)</ept> for an example of how to declare and use <ph id=\"ph1\">`size_type`</ph>.","source":"See the example for [size](#stack__size) for an example of how to declare and use `size_type`."},{"pos":[9565,9577],"content":"stack::stack"},{"content":"Constructs a stack that is empty or that is a copy of a base container class.","pos":[9581,9658]},{"content":"Parameters","pos":[9738,9748]},{"content":"The container of which the constructed stack is to be a copy.","pos":[9764,9825]},{"content":"Example","pos":[9835,9842]},{"pos":[10761,10771],"content":"stack::top"},{"content":"Returns a reference to an element at the top of the stack.","pos":[10775,10833]},{"content":"Return Value","pos":[10905,10917]},{"content":"A reference to the last element in the container at the top of the stack.","pos":[10921,10994]},{"content":"Remarks","pos":[11004,11011]},{"content":"The stack must be nonempty to apply the member function.","pos":[11015,11071]},{"content":"The top of the stack is the position occupied by the most recently added element and is the last element at the end of the container.","pos":[11072,11205]},{"content":"If the return value of <bpt id=\"p1\">**</bpt>top<ept id=\"p1\">**</ept> is assigned to a <ph id=\"ph1\">`const_reference`</ph>, the stack object cannot be modified.","pos":[11212,11315],"source":"If the return value of **top** is assigned to a `const_reference`, the stack object cannot be modified."},{"content":"If the return value of <bpt id=\"p1\">**</bpt>top<ept id=\"p1\">**</ept> is assigned to a <bpt id=\"p2\">**</bpt>reference<ept id=\"p2\">**</ept>, the stack object can be modified.","pos":[11316,11412],"source":" If the return value of **top** is assigned to a **reference**, the stack object can be modified."},{"content":"Example","pos":[11422,11429]},{"pos":[11997,12014],"content":"stack::value_type"},{"content":"A type that represents the type of object stored as an element in a stack.","pos":[12018,12092]},{"content":"Remarks","pos":[12170,12177]},{"pos":[12181,12263],"content":"The type is a synonym for <ph id=\"ph1\">`value_type`</ph> of the base container adapted by the stack.","source":"The type is a synonym for `value_type` of the base container adapted by the stack."},{"content":"Example","pos":[12273,12280]},{"content":"See Also","pos":[12860,12868]},{"content":"Thread Safety in the C++ Standard Library","pos":[12873,12914]},{"content":"C++ Standard Library Reference","pos":[12987,13017]}],"content":"---\ntitle: \"stack Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std::stack\"\n  - \"std.stack\"\n  - \"stack\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"stack, stack class\"\n  - \"stack class\"\nms.assetid: 02151c1e-eab0-41b8-be94-a839ead78ecf\ncaps.latest.revision: 22\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# stack Class\nA template container adaptor class that provides a restriction of functionality limiting access to the element most recently added to some underlying container type. The stack class is used when it is important to be clear that only stack operations are being performed on the container.  \n  \n## Syntax  \n  \n```  \ntemplate <class Type, class Container= deque <Type>>  \nclass stack  \n```  \n  \n#### Parameters  \n *Type*  \n The element data type to be stored in the stack.  \n  \n `Container`  \n The type of the underlying container used to implement the stack. The default value is the class `deque`*\\<Type>*.  \n  \n## Remarks  \n The elements of class **Type** stipulated in the first template parameter of a stack object are synonymous with [value_type](#stack__value_type) and must match the type of element in the underlying container class **Container** stipulated by the second template parameter. The **Type** must be assignable, so that it is possible to copy objects of that type and to assign values to variables of that type.  \n  \n Suitable underlying container classes for stack include [deque](../standard-library/deque-class.md), [list class](../standard-library/list-class.md), and [vector class](../standard-library/vector-class.md), or any other sequence container that supports the operations of **back**, `push_back`, and `pop_back`. The underlying container class is encapsulated within the container adaptor, which exposes only the limited set of the sequence container member functions as a public interface.  \n  \n The stack objects are equality comparable if and only if the elements of class **Type** are equality comparable and are less-than comparable if and only if the elements of class **Type** are less-than comparable.  \n  \n-   The stack class supports a last-in, first-out (LIFO) data structure. A good analogue to keep in mind would be a stack of plates. Elements (plates) may be inserted, inspected, or removed only from the top of the stack, which is the last element at the end of the base container. The restriction to accessing only the top element is the reason for using the stack class.  \n  \n-   The [queue class](../standard-library/queue-class.md) supports a first-in, first-out (FIFO) data structure. A good analogue to keep in mind would be people lining up for a bank teller. Elements (people) may be added to the back of the line and are removed from the front of the line. Both the front and the back of a line may be inspected. The restriction to accessing only the front and back elements in this way is the reason fur using the queue class.  \n  \n-   The [priority_queue class](../standard-library/priority-queue-class.md) orders its elements so that the largest element is always at the top position. It supports insertion of an element and the inspection and removal of the top element. A good analogue to keep in mind would be people lining up where they are arranged by age, height, or some other criterion.  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[stack](#stack__stack)|Constructs a `stack` that is empty or that is a copy of a base container object.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[container_type](#stack__container_type)|A type that provides the base container to be adapted by a `stack`.|  \n|[size_type](#stack__size_type)|An unsigned integer type that can represent the number of elements in a `stack`.|  \n|[value_type](#stack__value_type)|A type that represents the type of object stored as an element in a `stack`.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[empty](#stack__empty)|Tests if the `stack` is empty.|  \n|[pop](#stack__pop)|Removes the element from the top of the `stack`.|  \n|[push](#stack__push)|Adds an element to the top of the `stack`.|  \n|[size](#stack__size)|Returns the number of elements in the `stack`.|  \n|[top](#stack__top)|Returns a reference to an element at the top of the `stack`.|  \n  \n## Requirements  \n **Header:** \\<stack>  \n  \n **Namespace:** std  \n  \n##  <a name=\"stack__container_type\"></a>  stack::container_type  \n A type that provides the base container to be adapted.  \n  \n```  \ntypedef Container container_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `Container`. All three STL sequence container classes — the vector class, list class, and the default class deque — meet the requirements to be used as the base container for a stack object. User-defined types satisfying these requirements may also be used.  \n  \n For more information on `Container`, see the Remarks section of the [stack Class](../standard-library/stack-class.md) topic.  \n  \n### Example  \n  See the example for [stack::stack](#stack__stack) for an example of how to declare and use `container_type`.  \n  \n##  <a name=\"stack__empty\"></a>  stack::empty  \n Tests if a stack is empty.  \n  \n```  \nbool empty() const;\n```  \n  \n### Return Value  \n **true** if the stack is empty; **false** if the stack is nonempty.  \n  \n### Example  \n  \n```cpp  \n// stack_empty.cpp  \n// compile with: /EHsc  \n#include <stack>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   // Declares stacks with default deque base container  \n   stack <int> s1, s2;  \n  \n   s1.push( 1 );  \n  \n   if ( s1.empty( ) )  \n      cout << \"The stack s1 is empty.\" << endl;  \n   else  \n      cout << \"The stack s1 is not empty.\" << endl;  \n  \n   if ( s2.empty( ) )  \n      cout << \"The stack s2 is empty.\" << endl;  \n   else  \n      cout << \"The stack s2 is not empty.\" << endl;  \n}  \n```  \n  \n```Output  \nThe stack s1 is not empty.  \nThe stack s2 is empty.  \n```  \n  \n##  <a name=\"stack__pop\"></a>  stack::pop  \n Removes the element from the top of the stack.  \n  \n```  \nvoid pop();\n```  \n  \n### Remarks  \n The stack must be nonempty to apply the member function. The top of the stack is the position occupied by the most recently added element and is the last element at the end of the container.  \n  \n### Example  \n  \n```cpp  \n// stack_pop.cpp  \n// compile with: /EHsc  \n#include <stack>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   stack <int> s1, s2;  \n  \n   s1.push( 10 );  \n   s1.push( 20 );  \n   s1.push( 30 );  \n  \n   stack <int>::size_type i;  \n   i = s1.size( );  \n   cout << \"The stack length is \" << i << \".\" << endl;  \n  \n   i = s1.top( );  \n   cout << \"The element at the top of the stack is \"  \n        << i << \".\" << endl;  \n  \n   s1.pop( );  \n  \n   i = s1.size( );  \n   cout << \"After a pop, the stack length is \"   \n        << i << \".\" << endl;  \n  \n   i = s1.top( );  \n   cout << \"After a pop, the element at the top of the stack is \"  \n        << i << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe stack length is 3.  \nThe element at the top of the stack is 30.  \nAfter a pop, the stack length is 2.  \nAfter a pop, the element at the top of the stack is 20.  \n```  \n  \n##  <a name=\"stack__push\"></a>  stack::push  \n Adds an element to the top end of the stack.  \n  \n```  \nvoid push(const Type& val);\n```  \n  \n### Parameters  \n ` val`  \n The element added to the top of the stack.  \n  \n### Remarks  \n The top of the stack is the position occupied by the most recently added element and is the last element at the end of the container.  \n  \n### Example  \n  \n```cpp  \n// stack_push.cpp  \n// compile with: /EHsc  \n#include <stack>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   stack <int> s1;  \n  \n   s1.push( 10 );  \n   s1.push( 20 );  \n   s1.push( 30 );  \n  \n   stack <int>::size_type i;  \n   i = s1.size( );  \n   cout << \"The stack length is \" << i << \".\" << endl;  \n  \n   i = s1.top( );  \n   cout << \"The element at the top of the stack is \"  \n        << i << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe stack length is 3.  \nThe element at the top of the stack is 30.  \n```  \n  \n##  <a name=\"stack__size\"></a>  stack::size  \n Returns the number of elements in the stack.  \n  \n```  \nsize_type size() const;\n```  \n  \n### Return Value  \n The current length of the stack.  \n  \n### Example  \n  \n```cpp  \n// stack_size.cpp  \n// compile with: /EHsc  \n#include <stack>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   stack <int> s1, s2;  \n   stack <int>::size_type i;  \n  \n   s1.push( 1 );  \n   i = s1.size( );  \n   cout << \"The stack length is \" << i << \".\" << endl;  \n  \n   s1.push( 2 );  \n   i = s1.size( );  \n   cout << \"The stack length is now \" << i << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe stack length is 1.  \nThe stack length is now 2.  \n```  \n  \n##  <a name=\"stack__size_type\"></a>  stack::size_type  \n An unsigned integer type that can represent the number of elements in a stack.  \n  \n```  \ntypedef typename Container::size_type size_type;  \n```  \n  \n### Remarks  \n The type is a synonym for `size_type` of the base container adapted by the stack.  \n  \n### Example  \n  See the example for [size](#stack__size) for an example of how to declare and use `size_type`.  \n  \n##  <a name=\"stack__stack\"></a>  stack::stack  \n Constructs a stack that is empty or that is a copy of a base container class.  \n  \n```  \nstack();\n\nexplicit stack(const container_type& right);\n```  \n  \n### Parameters  \n ` right`  \n The container of which the constructed stack is to be a copy.  \n  \n### Example  \n  \n```cpp  \n// stack_stack.cpp  \n// compile with: /EHsc  \n#include <stack>  \n#include <vector>  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   // Declares stack with default deque base container  \n   stack <char> dsc1;  \n  \n   //Explicitly declares a stack with deque base container  \n   stack <char, deque<char> > dsc2;  \n  \n   // Declares a stack with vector base containers  \n   stack <int, vector<int> > vsi1;  \n  \n   // Declares a stack with list base container  \n   stack <int, list<int> > lsi;  \n  \n   // The second member function copies elements from a container  \n   vector<int> v1;  \n   v1.push_back( 1 );  \n   stack <int, vector<int> > vsi2( v1 );  \n   cout << \"The element at the top of stack vsi2 is \"  \n        << vsi2.top( ) << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe element at the top of stack vsi2 is 1.  \n```  \n  \n##  <a name=\"stack__top\"></a>  stack::top  \n Returns a reference to an element at the top of the stack.  \n  \n```  \nreference top();\n\nconst_reference top() const;\n```  \n  \n### Return Value  \n A reference to the last element in the container at the top of the stack.  \n  \n### Remarks  \n The stack must be nonempty to apply the member function. The top of the stack is the position occupied by the most recently added element and is the last element at the end of the container.  \n  \n If the return value of **top** is assigned to a `const_reference`, the stack object cannot be modified. If the return value of **top** is assigned to a **reference**, the stack object can be modified.  \n  \n### Example  \n  \n```cpp  \n// stack_top.cpp  \n// compile with: /EHsc  \n#include <stack>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   stack <int> s1;  \n  \n   s1.push( 1 );  \n   s1.push( 2 );  \n  \n   int& i = s1.top( );  \n   const int& ii = s1.top( );  \n  \n   cout << \"The top integer of the stack s1 is \"  \n        << i << \".\" << endl;  \n   i--;  \n   cout << \"The next integer down is \"<< ii << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe top integer of the stack s1 is 2.  \nThe next integer down is 1.  \n```  \n  \n##  <a name=\"stack__value_type\"></a>  stack::value_type  \n A type that represents the type of object stored as an element in a stack.  \n  \n```  \ntypedef typename Container::value_type value_type;  \n```  \n  \n### Remarks  \n The type is a synonym for `value_type` of the base container adapted by the stack.  \n  \n### Example  \n  \n```cpp  \n// stack_value_type.cpp  \n// compile with: /EHsc  \n#include <stack>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   // Declares stacks with default deque base container  \n   stack<int>::value_type AnInt;  \n  \n   AnInt = 69;  \n   cout << \"The value_type is AnInt = \" << AnInt << endl;  \n  \n   stack<int> s1;  \n   s1.push( AnInt );  \n   cout << \"The element at the top of the stack is \"  \n        << s1.top( ) << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe value_type is AnInt = 69  \nThe element at the top of the stack is 69.  \n```  \n  \n## See Also  \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)\n\n"}