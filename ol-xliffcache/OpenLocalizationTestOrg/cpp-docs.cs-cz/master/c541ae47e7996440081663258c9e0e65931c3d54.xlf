<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="cs-cz">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c541ae47e7996440081663258c9e0e65931c3d54</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\c-language\conversions-to-and-from-pointer-types.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b775eb94869be7f1d1d3ba4a0eb9a3c100f86185</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d20f2c8019f3049043a044bec4e7597cbbee4dc2</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Conversions to and from Pointer Types | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Conversions to and from Pointer Types</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A pointer to one type of value can be converted to a pointer to a different type.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>However, the result may be undefined because of the alignment requirements and sizes of different types in storage.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A pointer to an object can be converted to a pointer to an object whose type requires less or equally strict storage alignment, and back again without change.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A pointer to <ph id="ph1">`void`</ph> can be converted to or from a pointer to any type, without restriction or loss of information.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>If the result is converted back to the original type, the original pointer is recovered.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If a pointer is converted to another pointer with the same type but having different or additional qualifiers, the new pointer is the same as the old except for restrictions imposed by the new qualifier.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A pointer value can also be converted to an integral value.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The conversion path depends on the size of the pointer and the size of the integral type, according to the following rules:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If the size of the pointer is greater than or equal to the size of the integral type, the pointer behaves like an unsigned value in the conversion, except that it cannot be converted to a floating value.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>If the pointer is smaller than the integral type, the pointer is first converted to a pointer with the same size as the integral type, then converted to the integral type.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Conversely, an integral type can be converted to a pointer type according to the following rules:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If the integral type is the same size as the pointer type, the conversion simply causes the integral value to be treated as a pointer (an unsigned integer).</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If the size of the integral type is different from the size of the pointer type, the integral type is first converted to the size of the pointer, using the conversion paths given in the tables <bpt id="p1">[</bpt>Conversion from Signed Integral Types<ept id="p1">](../c-language/conversions-from-signed-integral-types.md)</ept> and <bpt id="p2">[</bpt>Conversion from Unsigned Integral Types<ept id="p2">](../c-language/conversions-from-unsigned-integral-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>It is then treated as a pointer value.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>An integral constant expression with value 0 or such an expression cast to type <bpt id="p1">**</bpt>void <ph id="ph1">\*</ph><ept id="p1">**</ept> can be converted by a type cast, by assignment, or by comparison to a pointer of any type.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This produces a null pointer that is equal to another null pointer of the same type, but this null pointer is not equal to any pointer to a function or to an object.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Integers other than the constant 0 can be converted to pointer type, but the result is not portable.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Assignment Conversions</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>