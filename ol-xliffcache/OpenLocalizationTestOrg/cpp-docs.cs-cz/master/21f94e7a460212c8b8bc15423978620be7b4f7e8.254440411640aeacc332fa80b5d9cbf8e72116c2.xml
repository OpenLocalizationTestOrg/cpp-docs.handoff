{"nodes":[{"pos":[12,50],"content":"try-finally Statement | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"try-finally Statement | Microsoft Docs","pos":[0,38]}]},{"content":"try-finally Statement","pos":[1027,1048]},{"content":"Microsoft Specific","pos":[1051,1069]},{"pos":[1078,1137],"content":"The following syntax describes the <ph id=\"ph1\">`try-finally`</ph> statement:","source":"The following syntax describes the `try-finally` statement:"},{"content":"Grammar","pos":[1239,1246]},{"content":"<bpt id=\"p1\">*</bpt>try-finally-statement<ept id=\"p1\">*</ept>:","pos":[1250,1274],"source":"*try-finally-statement*:"},{"content":"compound-statement","pos":[1287,1305]},{"pos":[1326,1344],"content":"compound-statement"},{"content":"The <ph id=\"ph1\">`try-finally`</ph> statement is a Microsoft extension to the C and C++ languages that enables target applications to guarantee execution of cleanup code when execution of a block of code is interrupted.","pos":[1352,1553],"source":"The `try-finally` statement is a Microsoft extension to the C and C++ languages that enables target applications to guarantee execution of cleanup code when execution of a block of code is interrupted."},{"content":"Cleanup consists of such tasks as deallocating memory, closing files, and releasing file handles.","pos":[1554,1651]},{"content":"The <ph id=\"ph1\">`try-finally`</ph> statement is especially useful for routines that have several places where a check is made for an error that could cause premature return from the routine.","pos":[1652,1825],"source":" The `try-finally` statement is especially useful for routines that have several places where a check is made for an error that could cause premature return from the routine."},{"content":"For related information and a code sample, see <bpt id=\"p1\">[</bpt>try-except Statement<ept id=\"p1\">](../cpp/try-except-statement.md)</ept>.","pos":[1832,1934],"source":"For related information and a code sample, see [try-except Statement](../cpp/try-except-statement.md)."},{"content":"For more information on structured exception handling in general, see <bpt id=\"p1\">[</bpt>Structured Exception Handling<ept id=\"p1\">](../cpp/structured-exception-handling-c-cpp.md)</ept>.","pos":[1935,2084],"source":" For more information on structured exception handling in general, see [Structured Exception Handling](../cpp/structured-exception-handling-c-cpp.md)."},{"content":"For more information on handling exceptions in managed applications, see <bpt id=\"p1\">[</bpt>Exception Handling under /clr<ept id=\"p1\">](../windows/exception-handling-cpp-component-extensions.md)</ept>.","pos":[2085,2249],"source":" For more information on handling exceptions in managed applications, see [Exception Handling under /clr](../windows/exception-handling-cpp-component-extensions.md)."},{"pos":[2257,2740],"content":"[!NOTE]\n Structured exception handling works with Win32 for both C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, C++ exception handling is more flexible, in that it can handle exceptions of any type. For C++ programs, it is recommended that you use the C++ exception-handling mechanism ([try, catch, and throw](../cpp/try-throw-and-catch-statements-cpp.md) statements).","leadings":["","> "],"nodes":[{"content":" Structured exception handling works with Win32 for both C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, C++ exception handling is more flexible, in that it can handle exceptions of any type. For C++ programs, it is recommended that you use the C++ exception-handling mechanism ([try, catch, and throw](../cpp/try-throw-and-catch-statements-cpp.md) statements).","pos":[8,481],"nodes":[{"content":"Structured exception handling works with Win32 for both C and C++ source files.","pos":[1,80]},{"content":"However, it is not specifically designed for C++.","pos":[81,130]},{"content":"You can ensure that your code is more portable by using C++ exception handling.","pos":[131,210]},{"content":"Also, C++ exception handling is more flexible, in that it can handle exceptions of any type.","pos":[211,303]},{"content":"For C++ programs, it is recommended that you use the C++ exception-handling mechanism (<bpt id=\"p1\">[</bpt>try, catch, and throw<ept id=\"p1\">](../cpp/try-throw-and-catch-statements-cpp.md)</ept> statements).","pos":[304,473],"source":" For C++ programs, it is recommended that you use the C++ exception-handling mechanism ([try, catch, and throw](../cpp/try-throw-and-catch-statements-cpp.md) statements)."}]}]},{"content":"The compound statement after the <ph id=\"ph1\">`__try`</ph> clause is the guarded section.","pos":[2747,2818],"source":"The compound statement after the `__try` clause is the guarded section."},{"content":"The compound statement after the <ph id=\"ph1\">`__finally`</ph> clause is the termination handler.","pos":[2819,2898],"source":" The compound statement after the `__finally` clause is the termination handler."},{"content":"The handler specifies a set of actions that execute when the guarded section is exited, regardless of whether the guarded section is exited by an exception (abnormal termination), or by standard fall through (normal termination).","pos":[2899,3128]},{"content":"Control reaches a <ph id=\"ph1\">`__try`</ph> statement by simple sequential execution (fall through).","pos":[3135,3217],"source":"Control reaches a `__try` statement by simple sequential execution (fall through)."},{"content":"When control enters the <ph id=\"ph1\">`__try`</ph>, its associated handler becomes active.","pos":[3218,3289],"source":" When control enters the `__try`, its associated handler becomes active."},{"content":"If the flow of control reaches the end of the try block, execution proceeds as follows:","pos":[3290,3377]},{"content":"The termination handler is invoked.","pos":[3387,3422]},{"content":"When the termination handler completes, execution continues after the <ph id=\"ph1\">`__finally`</ph> statement.","pos":[3432,3524],"source":"When the termination handler completes, execution continues after the `__finally` statement."},{"content":"Regardless of how the guarded section ends (for example, via a <ph id=\"ph1\">`goto`</ph> out of the guarded body or a <ph id=\"ph2\">`return`</ph> statement), the termination handler is executed <ph id=\"ph3\">`before`</ph> the flow of control moves out of the guarded section.","pos":[3525,3743],"source":" Regardless of how the guarded section ends (for example, via a `goto` out of the guarded body or a `return` statement), the termination handler is executed `before` the flow of control moves out of the guarded section."},{"pos":[3754,3842],"content":"A <bpt id=\"p1\">**</bpt>__finally<ept id=\"p1\">**</ept> statement does not block searching for an appropriate exception handler.","source":"A **__finally** statement does not block searching for an appropriate exception handler."},{"content":"If an exception occurs in the <ph id=\"ph1\">`__try`</ph> block, the operating system must find a handler for the exception or the program will fail.","pos":[3849,3978],"source":"If an exception occurs in the `__try` block, the operating system must find a handler for the exception or the program will fail."},{"content":"If a handler is found, any and all <ph id=\"ph1\">`__finally`</ph> blocks are executed and execution resumes in the handler.","pos":[3979,4083],"source":" If a handler is found, any and all `__finally` blocks are executed and execution resumes in the handler."},{"content":"For example, suppose a series of function calls links function A to function D, as shown in the following figure.","pos":[4090,4203]},{"content":"Each function has one termination handler.","pos":[4204,4246]},{"content":"If an exception is raised in function D and handled in A, the termination handlers are called in this order as the system unwinds the stack: D, C, B.","pos":[4247,4396]},{"content":"Order of termination&amp;#45;handler execution","pos":[4405,4447],"source":"Order of termination&#45;handler execution"},{"content":"Order of Termination-Handler Execution","pos":[4487,4525]},{"pos":[4533,4916],"content":"[!NOTE]\n The behavior of try-finally is different from some other languages that support the use of **finally**, such as C#.  A single `__try` may have either, but not both, of `__finally` and `__except`.  If both are to be used together, an outer try-except statement must enclose the inner try-finally statement.  The rules specifying when each block executes are also different.","leadings":["","> "],"nodes":[{"content":" The behavior of try-finally is different from some other languages that support the use of **finally**, such as C#.  A single `__try` may have either, but not both, of `__finally` and `__except`.  If both are to be used together, an outer try-except statement must enclose the inner try-finally statement.  The rules specifying when each block executes are also different.","pos":[8,381],"nodes":[{"content":"The behavior of try-finally is different from some other languages that support the use of <bpt id=\"p1\">**</bpt>finally<ept id=\"p1\">**</ept>, such as C#.","pos":[1,116],"source":" The behavior of try-finally is different from some other languages that support the use of **finally**, such as C#."},{"content":"A single <ph id=\"ph1\">`__try`</ph> may have either, but not both, of <ph id=\"ph2\">`__finally`</ph> and <ph id=\"ph3\">`__except`</ph>.","pos":[118,196],"source":"  A single `__try` may have either, but not both, of `__finally` and `__except`."},{"content":"If both are to be used together, an outer try-except statement must enclose the inner try-finally statement.","pos":[198,306]},{"content":"The rules specifying when each block executes are also different.","pos":[308,373]}]}]},{"content":"The __leave Keyword","pos":[4925,4944]},{"content":"The <ph id=\"ph1\">`__leave`</ph> keyword is valid only within the guarded section of a <ph id=\"ph2\">`try-finally`</ph> statement, and its effect is to jump to the end of the guarded section.","pos":[4948,5101],"source":"The `__leave` keyword is valid only within the guarded section of a `try-finally` statement, and its effect is to jump to the end of the guarded section."},{"content":"Execution continues at the first statement in the termination handler.","pos":[5102,5172]},{"content":"A <ph id=\"ph1\">`goto`</ph> statement can also jump out of the guarded section, but it degrades performance because it invokes stack unwinding.","pos":[5179,5303],"source":"A `goto` statement can also jump out of the guarded section, but it degrades performance because it invokes stack unwinding."},{"content":"The <ph id=\"ph1\">`__leave`</ph> statement is more efficient because it does not cause stack unwinding.","pos":[5304,5388],"source":" The `__leave` statement is more efficient because it does not cause stack unwinding."},{"content":"Abnormal Termination","pos":[5397,5417]},{"content":"Exiting a <ph id=\"ph1\">`try-finally`</ph> statement using the <bpt id=\"p1\">[</bpt>longjmp<ept id=\"p1\">](../c-runtime-library/reference/longjmp.md)</ept> run-time function is considered abnormal termination.","pos":[5421,5571],"source":"Exiting a `try-finally` statement using the [longjmp](../c-runtime-library/reference/longjmp.md) run-time function is considered abnormal termination."},{"content":"It is illegal to jump into a <ph id=\"ph1\">`__try`</ph> statement, but legal to jump out of one.","pos":[5572,5649],"source":" It is illegal to jump into a `__try` statement, but legal to jump out of one."},{"content":"All <ph id=\"ph1\">`__finally`</ph> statements that are active between the point of departure (normal termination of the <ph id=\"ph2\">`__try`</ph> block) and the destination (the <ph id=\"ph3\">`__except`</ph> block that handles the exception) must be run.","pos":[5650,5848],"source":" All `__finally` statements that are active between the point of departure (normal termination of the `__try` block) and the destination (the `__except` block that handles the exception) must be run."},{"content":"This is called a local unwind.","pos":[5849,5879]},{"content":"If a <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> block is prematurely terminated for any reason, including a jump out of the block, the system executes the associated <bpt id=\"p2\">**</bpt>finally<ept id=\"p2\">**</ept> block as a part of the process of unwinding the stack.","pos":[5886,6083],"source":"If a **try** block is prematurely terminated for any reason, including a jump out of the block, the system executes the associated **finally** block as a part of the process of unwinding the stack."},{"content":"In such cases, the <bpt id=\"p1\">[</bpt>AbnormalTermination<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms679265)</ept> function returns TRUE if called from within the <bpt id=\"p2\">**</bpt>finally<ept id=\"p2\">**</ept> block; otherwise, it returns FALSE.","pos":[6084,6280],"source":" In such cases, the [AbnormalTermination](http://msdn.microsoft.com/library/windows/desktop/ms679265) function returns TRUE if called from within the **finally** block; otherwise, it returns FALSE."},{"pos":[6287,6401],"content":"The termination handler is not called if a process is killed in the middle of executing a <ph id=\"ph1\">`try-finally`</ph> statement.","source":"The termination handler is not called if a process is killed in the middle of executing a `try-finally` statement."},{"content":"END Microsoft Specific","pos":[6410,6432]},{"content":"See Also","pos":[6443,6451]},{"content":"Writing a Termination Handler","pos":[6456,6485]},{"content":"Structured Exception Handling (C/C++)","pos":[6533,6570]},{"content":"Keywords","pos":[6624,6632]},{"content":"Termination-Handler Syntax","pos":[6663,6689]}],"content":"---\ntitle: \"try-finally Statement | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"__try\"\n  - \"__leave_cpp\"\n  - \"__leave\"\n  - \"__finally_cpp\"\n  - \"__try_cpp\"\n  - \"__finally\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__try keyword [C++]\"\n  - \"__finally keyword [C++]\"\n  - \"__leave keyword [C++]\"\n  - \"try-catch keyword [C++], try-finally keyword\"\n  - \"try-finally keyword [C++]\"\n  - \"__finally keyword [C++], try-finally statement syntax\"\n  - \"__leave keyword [C++], try-finally statement\"\n  - \"structured exception handling, try-finally\"\nms.assetid: 826e0347-ddfe-4f6e-a7bc-0398e0edc7c2\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# try-finally Statement\n**Microsoft Specific**  \n  \n The following syntax describes the `try-finally` statement:  \n  \n```  \n__try {  \n   // guarded code  \n}  \n__finally {  \n   // termination code  \n}  \n```  \n  \n## Grammar  \n *try-finally-statement*:  \n `__try` *compound-statement*  \n  \n `__finally` *compound-statement*  \n  \n The `try-finally` statement is a Microsoft extension to the C and C++ languages that enables target applications to guarantee execution of cleanup code when execution of a block of code is interrupted. Cleanup consists of such tasks as deallocating memory, closing files, and releasing file handles. The `try-finally` statement is especially useful for routines that have several places where a check is made for an error that could cause premature return from the routine.  \n  \n For related information and a code sample, see [try-except Statement](../cpp/try-except-statement.md). For more information on structured exception handling in general, see [Structured Exception Handling](../cpp/structured-exception-handling-c-cpp.md). For more information on handling exceptions in managed applications, see [Exception Handling under /clr](../windows/exception-handling-cpp-component-extensions.md).  \n  \n> [!NOTE]\n>  Structured exception handling works with Win32 for both C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, C++ exception handling is more flexible, in that it can handle exceptions of any type. For C++ programs, it is recommended that you use the C++ exception-handling mechanism ([try, catch, and throw](../cpp/try-throw-and-catch-statements-cpp.md) statements).  \n  \n The compound statement after the `__try` clause is the guarded section. The compound statement after the `__finally` clause is the termination handler. The handler specifies a set of actions that execute when the guarded section is exited, regardless of whether the guarded section is exited by an exception (abnormal termination), or by standard fall through (normal termination).  \n  \n Control reaches a `__try` statement by simple sequential execution (fall through). When control enters the `__try`, its associated handler becomes active. If the flow of control reaches the end of the try block, execution proceeds as follows:  \n  \n1.  The termination handler is invoked.  \n  \n2.  When the termination handler completes, execution continues after the `__finally` statement. Regardless of how the guarded section ends (for example, via a `goto` out of the guarded body or a `return` statement), the termination handler is executed `before` the flow of control moves out of the guarded section.  \n  \n     A **__finally** statement does not block searching for an appropriate exception handler.  \n  \n If an exception occurs in the `__try` block, the operating system must find a handler for the exception or the program will fail. If a handler is found, any and all `__finally` blocks are executed and execution resumes in the handler.  \n  \n For example, suppose a series of function calls links function A to function D, as shown in the following figure. Each function has one termination handler. If an exception is raised in function D and handled in A, the termination handlers are called in this order as the system unwinds the stack: D, C, B.  \n  \n ![Order of termination&#45;handler execution](../cpp/media/vc38cx1.gif \"vc38CX1\")  \nOrder of Termination-Handler Execution  \n  \n> [!NOTE]\n>  The behavior of try-finally is different from some other languages that support the use of **finally**, such as C#.  A single `__try` may have either, but not both, of `__finally` and `__except`.  If both are to be used together, an outer try-except statement must enclose the inner try-finally statement.  The rules specifying when each block executes are also different.  \n  \n## The __leave Keyword  \n The `__leave` keyword is valid only within the guarded section of a `try-finally` statement, and its effect is to jump to the end of the guarded section. Execution continues at the first statement in the termination handler.  \n  \n A `goto` statement can also jump out of the guarded section, but it degrades performance because it invokes stack unwinding. The `__leave` statement is more efficient because it does not cause stack unwinding.  \n  \n## Abnormal Termination  \n Exiting a `try-finally` statement using the [longjmp](../c-runtime-library/reference/longjmp.md) run-time function is considered abnormal termination. It is illegal to jump into a `__try` statement, but legal to jump out of one. All `__finally` statements that are active between the point of departure (normal termination of the `__try` block) and the destination (the `__except` block that handles the exception) must be run. This is called a local unwind.  \n  \n If a **try** block is prematurely terminated for any reason, including a jump out of the block, the system executes the associated **finally** block as a part of the process of unwinding the stack. In such cases, the [AbnormalTermination](http://msdn.microsoft.com/library/windows/desktop/ms679265) function returns TRUE if called from within the **finally** block; otherwise, it returns FALSE.  \n  \n The termination handler is not called if a process is killed in the middle of executing a `try-finally` statement.  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [Writing a Termination Handler](../cpp/writing-a-termination-handler.md)   \n [Structured Exception Handling (C/C++)](../cpp/structured-exception-handling-c-cpp.md)   \n [Keywords](../cpp/keywords-cpp.md)   \n [Termination-Handler Syntax](http://msdn.microsoft.com/library/windows/desktop/ms681393)"}