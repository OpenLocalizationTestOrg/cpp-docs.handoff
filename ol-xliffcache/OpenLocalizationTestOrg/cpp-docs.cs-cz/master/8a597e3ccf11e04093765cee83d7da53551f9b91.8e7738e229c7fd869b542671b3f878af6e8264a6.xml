{"nodes":[{"pos":[12,87],"content":"Potential Errors Passing CRT Objects Across DLL Boundaries | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Potential Errors Passing CRT Objects Across DLL Boundaries | Microsoft Docs","pos":[0,75]}]},{"content":"Potential Errors Passing CRT Objects Across DLL Boundaries","pos":[623,681]},{"content":"When you pass C Run-time (CRT) objects such as file handles, locales, and environment variables into or out of a DLL (function calls across the DLL boundary), unexpected behavior can occur if the DLL, as well as the files calling into the DLL, use different copies of the CRT libraries.","pos":[682,968]},{"content":"A related problem can occur when you allocate memory (either explicitly with <ph id=\"ph1\">`new`</ph> or <ph id=\"ph2\">`malloc`</ph>, or implicitly with <ph id=\"ph3\">`strdup`</ph>, <ph id=\"ph4\">`strstreambuf::str`</ph>, and so on) and then pass a pointer across a DLL boundary to be freed.","pos":[975,1190],"source":"A related problem can occur when you allocate memory (either explicitly with `new` or `malloc`, or implicitly with `strdup`, `strstreambuf::str`, and so on) and then pass a pointer across a DLL boundary to be freed."},{"content":"This can cause a memory access violation or heap corruption if the DLL and its users use different copies of the CRT libraries.","pos":[1191,1318]},{"content":"Another symptom of this problem can be an error in the output window during debugging such as:","pos":[1325,1419]},{"content":"HEAP[]: Invalid Address specified to RtlValidateHeap(#,#)","pos":[1426,1483]},{"content":"Causes","pos":[1492,1498]},{"content":"Each copy of the CRT library has a separate and distinct state.","pos":[1502,1565]},{"content":"As such, CRT objects such as file handles, environment variables, and locales are only valid for the copy of the CRT where these objects are allocated or set.","pos":[1566,1724]},{"content":"When a DLL and its users use different copies of the CRT library, you cannot pass these CRT objects across the DLL boundary and expect them to be picked up correctly on the other side.","pos":[1725,1909]},{"content":"Also, because each copy of the CRT library has its own heap manager, allocating memory in one CRT library and passing the pointer across a DLL boundary to be freed by a different copy of the CRT library is a potential cause for heap corruption.","pos":[1916,2160]},{"content":"If you design your DLL so that it passes CRT objects across the boundary or allocates memory and expects it to be freed outside the DLL, you restrict the DLL users to use the same copy of the CRT library as the DLL.","pos":[2167,2382]},{"content":"The DLL and its users use the same copy of the CRT library only if both are linked with the same version of the CRT DLL.","pos":[2383,2503]},{"content":"This could be a problem if you mix applications built with Visual C++ 5.0 with DLLs that are built by Visual C++ 4.1 or earlier.","pos":[2504,2632]},{"content":"Because the DLL version of the CRT library used by Visual C++ 4.1 is msvcrt40.dll and the one used by Visual 5.0 is msvcrt.dll, you cannot build your application to use the same copy of the CRT library as these DLLs.","pos":[2633,2849]},{"content":"However, there is an exception.","pos":[2856,2887]},{"content":"In US English version and some other localized versions of Windows 2000, such as German, French, and Czech, a forwarder version of the msvcrt40.dll (version 4.20) is shipped.","pos":[2888,3062]},{"content":"As a result, even though the DLL is linked with msvcrt40.dll and its user is linked with msvcrt.dll, you are still using the same copy of the CRT library because all calls made to msvcrt40.dll are forwarded to msvcrt.dll.","pos":[3063,3284]},{"content":"However this forwarder version of msvcrt40.dll is not available in some localized versions of Windows 2000, such as Japanese, Korean, and Chinese.","pos":[3291,3437]},{"content":"So, if your application targets these operating systems, you need to either obtain an upgraded version of the DLL that doesn't rely on msvcrt40.dll or alter your application to not rely on using the same copy of the CRT libraries.","pos":[3438,3668]},{"content":"If you have developed the DLL, this means rebuilding it with Visual C++ 4.2 or later.","pos":[3669,3754]},{"content":"If it is a third- party DLL, you need to contact your vendor for an upgrade.","pos":[3755,3831]},{"content":"Please note that this forwarder DLL version of msvcrt40.dll (version 4.20) cannot be redistributed.","pos":[3838,3937]},{"content":"Example","pos":[3946,3953]},{"content":"Description","pos":[3963,3974]},{"content":"This example passes a file handle across a DLL boundary.","pos":[3978,4034]},{"content":"The DLL and .exe file are built with /MD, so they share a single copy of the CRT.","pos":[4041,4122]},{"content":"If you rebuild with /MT so that they use separate copies of the CRT, running the resulting test1Main.exe results in an access violation.","pos":[4129,4265]},{"content":"Code","pos":[4275,4279]},{"content":"Code","pos":[4527,4531]},{"content":"Output","pos":[4854,4860]},{"content":"Example","pos":[4903,4910]},{"content":"Description","pos":[4920,4931]},{"content":"This example passes environment variables across a DLL boundary.","pos":[4935,4999]},{"content":"Code","pos":[5009,5013]},{"content":"Code","pos":[5494,5498]},{"content":"Output","pos":[5741,5747]},{"content":"If both the DLL and .exe file are built with /MD so that only one copy of the CRT is used, the program runs successfully and produces the following output:","pos":[5795,5950]},{"content":"See Also","pos":[6019,6027]},{"content":"CRT Library Features","pos":[6032,6052]}],"content":"---\ntitle: \"Potential Errors Passing CRT Objects Across DLL Boundaries | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"DLL conflicts [C++]\"\nms.assetid: c217ffd2-5d9a-4678-a1df-62a637a96460\ncaps.latest.revision: 9\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Potential Errors Passing CRT Objects Across DLL Boundaries\nWhen you pass C Run-time (CRT) objects such as file handles, locales, and environment variables into or out of a DLL (function calls across the DLL boundary), unexpected behavior can occur if the DLL, as well as the files calling into the DLL, use different copies of the CRT libraries.  \n  \n A related problem can occur when you allocate memory (either explicitly with `new` or `malloc`, or implicitly with `strdup`, `strstreambuf::str`, and so on) and then pass a pointer across a DLL boundary to be freed. This can cause a memory access violation or heap corruption if the DLL and its users use different copies of the CRT libraries.  \n  \n Another symptom of this problem can be an error in the output window during debugging such as:  \n  \n HEAP[]: Invalid Address specified to RtlValidateHeap(#,#)  \n  \n## Causes  \n Each copy of the CRT library has a separate and distinct state. As such, CRT objects such as file handles, environment variables, and locales are only valid for the copy of the CRT where these objects are allocated or set. When a DLL and its users use different copies of the CRT library, you cannot pass these CRT objects across the DLL boundary and expect them to be picked up correctly on the other side.  \n  \n Also, because each copy of the CRT library has its own heap manager, allocating memory in one CRT library and passing the pointer across a DLL boundary to be freed by a different copy of the CRT library is a potential cause for heap corruption.  \n  \n If you design your DLL so that it passes CRT objects across the boundary or allocates memory and expects it to be freed outside the DLL, you restrict the DLL users to use the same copy of the CRT library as the DLL. The DLL and its users use the same copy of the CRT library only if both are linked with the same version of the CRT DLL. This could be a problem if you mix applications built with Visual C++ 5.0 with DLLs that are built by Visual C++ 4.1 or earlier. Because the DLL version of the CRT library used by Visual C++ 4.1 is msvcrt40.dll and the one used by Visual 5.0 is msvcrt.dll, you cannot build your application to use the same copy of the CRT library as these DLLs.  \n  \n However, there is an exception. In US English version and some other localized versions of Windows 2000, such as German, French, and Czech, a forwarder version of the msvcrt40.dll (version 4.20) is shipped. As a result, even though the DLL is linked with msvcrt40.dll and its user is linked with msvcrt.dll, you are still using the same copy of the CRT library because all calls made to msvcrt40.dll are forwarded to msvcrt.dll.  \n  \n However this forwarder version of msvcrt40.dll is not available in some localized versions of Windows 2000, such as Japanese, Korean, and Chinese. So, if your application targets these operating systems, you need to either obtain an upgraded version of the DLL that doesn't rely on msvcrt40.dll or alter your application to not rely on using the same copy of the CRT libraries. If you have developed the DLL, this means rebuilding it with Visual C++ 4.2 or later. If it is a third- party DLL, you need to contact your vendor for an upgrade.  \n  \n Please note that this forwarder DLL version of msvcrt40.dll (version 4.20) cannot be redistributed.  \n  \n## Example  \n  \n### Description  \n This example passes a file handle across a DLL boundary.  \n  \n The DLL and .exe file are built with /MD, so they share a single copy of the CRT.  \n  \n If you rebuild with /MT so that they use separate copies of the CRT, running the resulting test1Main.exe results in an access violation.  \n  \n### Code  \n  \n```  \n// test1Dll.cpp  \n// compile with: /MD /LD  \n#include <stdio.h>  \n__declspec(dllexport) void writeFile(FILE *stream)  \n{  \n   char   s[] = \"this is a string\\n\";  \n   fprintf( stream, \"%s\", s );  \n   fclose( stream );  \n}  \n```  \n  \n### Code  \n  \n```  \n// test1Main.cpp  \n// compile with: /MD test1dll.lib  \n#include <stdio.h>  \n#include <process.h>  \nvoid writeFile(FILE *stream);  \n  \nint main(void)  \n{  \n   FILE  * stream;  \n   errno_t err = fopen_s( &stream, \"fprintf.out\", \"w\" );  \n   writeFile(stream);  \n   system( \"type fprintf.out\" );  \n}  \n```  \n  \n### Output  \n  \n```  \nthis is a string  \n```  \n  \n## Example  \n  \n### Description  \n This example passes environment variables across a DLL boundary.  \n  \n### Code  \n  \n```  \n// test2Dll.cpp  \n// compile with: /MT /LD  \n#include <stdio.h>  \n#include <stdlib.h>  \n  \n__declspec(dllexport) void readEnv()  \n{  \n   char *libvar;  \n   size_t libvarsize;  \n  \n   /* Get the value of the MYLIB environment variable. */   \n   _dupenv_s( &libvar, &libvarsize, \"MYLIB\" );  \n  \n   if( libvar != NULL )  \n      printf( \"New MYLIB variable is: %s\\n\", libvar);  \n   else  \n      printf( \"MYLIB has not been set.\\n\");  \n   free( libvar );  \n}  \n```  \n  \n### Code  \n  \n```  \n// test2Main.cpp  \n// compile with: /MT /link test2dll.lib  \n#include <stdlib.h>  \n#include <stdio.h>  \n  \nvoid readEnv();  \n  \nint main( void )  \n{  \n   _putenv( \"MYLIB=c:\\\\mylib;c:\\\\yourlib\" );  \n   readEnv();  \n}  \n```  \n  \n### Output  \n  \n```  \nMYLIB has not been set.  \n```  \n  \n If both the DLL and .exe file are built with /MD so that only one copy of the CRT is used, the program runs successfully and produces the following output:  \n  \n```  \nNew MYLIB variable is: c:\\mylib;c:\\yourlib  \n```  \n  \n## See Also  \n [CRT Library Features](../c-runtime-library/crt-library-features.md)"}