{"nodes":[{"pos":[12,48],"content":"1.3 Execution Model | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"1.3 Execution Model | Microsoft Docs","pos":[0,36]}]},{"content":"1.3 Execution Model","pos":[528,547]},{"content":"OpenMP uses the fork-join model of parallel execution.","pos":[548,602]},{"content":"Although this fork-join model can be useful for solving a variety of problems, it is somewhat tailored for large array-based applications.","pos":[603,741]},{"content":"OpenMP is intended to support programs that will execute correctly both as parallel programs (multiple threads of execution and a full OpenMP support library) and as sequential programs (directives ignored and a simple OpenMP stubs library).","pos":[742,983]},{"content":"However, it is possible and permitted to develop a program that does not behave correctly when executed sequentially.","pos":[984,1101]},{"content":"Furthermore, different degrees of parallelism may result in different numeric results because of changes in the association of numeric operations.","pos":[1102,1248]},{"content":"For example, a serial addition reduction may have a different pattern of addition associations than a parallel reduction.","pos":[1249,1370]},{"content":"These different associations may change the results of floating-point addition.","pos":[1371,1450]},{"content":"A program written with the OpenMP C/C++ API begins execution as a single thread of execution called the <bpt id=\"p1\">*</bpt>master thread<ept id=\"p1\">*</ept>.","pos":[1457,1577],"source":"A program written with the OpenMP C/C++ API begins execution as a single thread of execution called the *master thread*."},{"content":"The master thread executes in a serial region until the first parallel construct is encountered.","pos":[1578,1674]},{"content":"In the OpenMP C/C++ API, the <bpt id=\"p1\">**</bpt>parallel<ept id=\"p1\">**</ept> directive constitutes a parallel construct.","pos":[1675,1760],"source":" In the OpenMP C/C++ API, the **parallel** directive constitutes a parallel construct."},{"content":"When a parallel construct is encountered, the master thread creates a team of threads, and the master becomes master of the team.","pos":[1761,1890]},{"content":"Each thread in the team executes the statements in the dynamic extent of a parallel region, except for the work-sharing constructs.","pos":[1891,2022]},{"content":"Work-sharing constructs must be encountered by all threads in the team in the same order, and the statements within the associated structured block are executed by one or more of the threads.","pos":[2023,2214]},{"content":"The barrier implied at the end of a work-sharing construct without a <ph id=\"ph1\">`nowait`</ph> clause is executed by all threads in the team.","pos":[2215,2339],"source":" The barrier implied at the end of a work-sharing construct without a `nowait` clause is executed by all threads in the team."},{"content":"If a thread modifies a shared object, it affects not only its own execution environment, but also those of the other threads in the program.","pos":[2346,2486]},{"content":"The modification is guaranteed to be complete, from the point of view of one of the other threads, at the next sequence point (as defined in the base language) only if the object is declared to be volatile.","pos":[2487,2693]},{"content":"Otherwise, the modification is guaranteed to be complete after first the modifying thread, and then (or concurrently) the other threads, encounter a <bpt id=\"p1\">**</bpt>flush<ept id=\"p1\">**</ept> directive that specifies the object (either implicitly or explicitly).","pos":[2694,2923],"source":" Otherwise, the modification is guaranteed to be complete after first the modifying thread, and then (or concurrently) the other threads, encounter a **flush** directive that specifies the object (either implicitly or explicitly)."},{"content":"Note that when the <bpt id=\"p1\">**</bpt>flush<ept id=\"p1\">**</ept> directives that are implied by other OpenMP directives are not sufficient to ensure the desired ordering of side effects, it is the programmer's responsibility to supply additional, explicit <bpt id=\"p2\">**</bpt>flush<ept id=\"p2\">**</ept> directives.","pos":[2924,3165],"source":" Note that when the **flush** directives that are implied by other OpenMP directives are not sufficient to ensure the desired ordering of side effects, it is the programmer's responsibility to supply additional, explicit **flush** directives."},{"content":"Upon completion of the parallel construct, the threads in the team synchronize at an implicit barrier, and only the master thread continues execution.","pos":[3172,3322]},{"content":"Any number of parallel constructs can be specified in a single program.","pos":[3323,3394]},{"content":"As a result, a program may fork and join many times during execution.","pos":[3395,3464]},{"content":"The OpenMP C/C++ API allows programmers to use directives in functions called from within parallel constructs.","pos":[3471,3581]},{"content":"Directives that do not appear in the lexical extent of a parallel construct but may lie in the dynamic extent are called <bpt id=\"p1\">*</bpt>orphaned<ept id=\"p1\">*</ept> directives.","pos":[3582,3725],"source":" Directives that do not appear in the lexical extent of a parallel construct but may lie in the dynamic extent are called *orphaned* directives."},{"content":"Orphaned directives give programmers the ability to execute major portions of their program in parallel with only minimal changes to the sequential program.","pos":[3726,3882]},{"content":"With this functionality, users can code parallel constructs at the top levels of the program call tree and use directives to control execution in any of the called functions.","pos":[3883,4057]},{"content":"Unsynchronized calls to C and C++ output functions that write to the same file may result in output in which data written by different threads appears in nondeterministic order.","pos":[4064,4241]},{"content":"Similarly, unsynchronized calls to input functions that read from the same file may read data in nondeterministic order.","pos":[4242,4362]},{"content":"Unsynchronized use of I/O, such that each thread accesses a different file, produces the same results as serial execution of the I/O functions.","pos":[4363,4506]}],"content":"---\ntitle: \"1.3 Execution Model | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 85ae8bc4-5bf0-45e0-a45f-02de9adaf716\ncaps.latest.revision: 5\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# 1.3 Execution Model\nOpenMP uses the fork-join model of parallel execution. Although this fork-join model can be useful for solving a variety of problems, it is somewhat tailored for large array-based applications. OpenMP is intended to support programs that will execute correctly both as parallel programs (multiple threads of execution and a full OpenMP support library) and as sequential programs (directives ignored and a simple OpenMP stubs library). However, it is possible and permitted to develop a program that does not behave correctly when executed sequentially. Furthermore, different degrees of parallelism may result in different numeric results because of changes in the association of numeric operations. For example, a serial addition reduction may have a different pattern of addition associations than a parallel reduction. These different associations may change the results of floating-point addition.  \n  \n A program written with the OpenMP C/C++ API begins execution as a single thread of execution called the *master thread*. The master thread executes in a serial region until the first parallel construct is encountered. In the OpenMP C/C++ API, the **parallel** directive constitutes a parallel construct. When a parallel construct is encountered, the master thread creates a team of threads, and the master becomes master of the team. Each thread in the team executes the statements in the dynamic extent of a parallel region, except for the work-sharing constructs. Work-sharing constructs must be encountered by all threads in the team in the same order, and the statements within the associated structured block are executed by one or more of the threads. The barrier implied at the end of a work-sharing construct without a `nowait` clause is executed by all threads in the team.  \n  \n If a thread modifies a shared object, it affects not only its own execution environment, but also those of the other threads in the program. The modification is guaranteed to be complete, from the point of view of one of the other threads, at the next sequence point (as defined in the base language) only if the object is declared to be volatile. Otherwise, the modification is guaranteed to be complete after first the modifying thread, and then (or concurrently) the other threads, encounter a **flush** directive that specifies the object (either implicitly or explicitly). Note that when the **flush** directives that are implied by other OpenMP directives are not sufficient to ensure the desired ordering of side effects, it is the programmer's responsibility to supply additional, explicit **flush** directives.  \n  \n Upon completion of the parallel construct, the threads in the team synchronize at an implicit barrier, and only the master thread continues execution. Any number of parallel constructs can be specified in a single program. As a result, a program may fork and join many times during execution.  \n  \n The OpenMP C/C++ API allows programmers to use directives in functions called from within parallel constructs. Directives that do not appear in the lexical extent of a parallel construct but may lie in the dynamic extent are called *orphaned* directives. Orphaned directives give programmers the ability to execute major portions of their program in parallel with only minimal changes to the sequential program. With this functionality, users can code parallel constructs at the top levels of the program call tree and use directives to control execution in any of the called functions.  \n  \n Unsynchronized calls to C and C++ output functions that write to the same file may result in output in which data written by different threads appears in nondeterministic order. Similarly, unsynchronized calls to input functions that read from the same file may read data in nondeterministic order. Unsynchronized use of I/O, such that each thread accesses a different file, produces the same results as serial execution of the I/O functions."}