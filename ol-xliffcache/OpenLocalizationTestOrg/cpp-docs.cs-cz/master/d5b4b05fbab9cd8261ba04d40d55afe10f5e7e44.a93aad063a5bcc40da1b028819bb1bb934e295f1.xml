{"nodes":[{"pos":[12,60],"content":"Generic Interfaces (Visual C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Generic Interfaces (Visual C++) | Microsoft Docs","pos":[0,48]}]},{"content":"Generic Interfaces (Visual C++)","pos":[631,662]},{"pos":[663,860],"content":"The restrictions that apply to type parameters on classes are the same as those that apply to type parameters on interfaces (see <bpt id=\"p1\">[</bpt>Generic Classes (C++/CLI)<ept id=\"p1\">](../windows/generic-classes-cpp-cli.md)</ept>).","source":"The restrictions that apply to type parameters on classes are the same as those that apply to type parameters on interfaces (see [Generic Classes (C++/CLI)](../windows/generic-classes-cpp-cli.md))."},{"content":"The rules that control function overloading are the same for functions within generic classes or generic interfaces.","pos":[867,983]},{"content":"Explicit interface member implementations work with constructed interface types in the same way as with simple interface types (see the following examples).","pos":[990,1146]},{"pos":[1153,1267],"content":"For more information on interfaces, see <bpt id=\"p1\">[</bpt>interface class<ept id=\"p1\">](../windows/interface-class-cpp-component-extensions.md)</ept>.","source":"For more information on interfaces, see [interface class](../windows/interface-class-cpp-component-extensions.md)."},{"content":"Syntax","pos":[1276,1282]},{"content":"Remarks","pos":[1514,1521]},{"content":"<bpt id=\"p1\">*</bpt>attributes<ept id=\"p1\">*</ept> (optional)","pos":[1525,1548],"source":"*attributes* (optional)"},{"content":"Additional declarative information.","pos":[1552,1587]},{"content":"For more information on attributes and attribute classes, see Attributes.","pos":[1588,1661]},{"content":"class-key","pos":[1669,1678]},{"content":"<bpt id=\"p1\"> **</bpt>class<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>typename<ept id=\"p2\">**</ept>","pos":[1682,1708],"source":" **class** or **typename**"},{"content":"Comma-separated identifiers list.","pos":[1749,1782]},{"content":"Takes the form specified in <bpt id=\"p1\">[</bpt>Constraints on Generic Type Parameters (C++/CLI)<ept id=\"p1\">](../windows/constraints-on-generic-type-parameters-cpp-cli.md)</ept>","pos":[1829,1969],"source":" Takes the form specified in [Constraints on Generic Type Parameters (C++/CLI)](../windows/constraints-on-generic-type-parameters-cpp-cli.md)"},{"content":"<bpt id=\"p1\">*</bpt>accessibility-modifiers<ept id=\"p1\">*</ept> (optional)","pos":[1976,2012],"source":"*accessibility-modifiers* (optional)"},{"content":"Accessibility modifiers (e.g. <bpt id=\"p1\">**</bpt>public, private<ept id=\"p1\">**</ept>).","pos":[2016,2067],"source":" Accessibility modifiers (e.g. **public, private**)."},{"content":"identifier","pos":[2075,2085]},{"content":"The interface name.","pos":[2090,2109]},{"content":"<bpt id=\"p1\">*</bpt>base-list<ept id=\"p1\">*</ept> (optional)","pos":[2116,2138],"source":"*base-list* (optional)"},{"content":"A list that contains one or more explicit base interfaces separated by commas.","pos":[2142,2220]},{"content":"interface-body","pos":[2228,2242]},{"content":"Declarations of the interface members.","pos":[2247,2285]},{"content":"<bpt id=\"p1\">*</bpt>declarators<ept id=\"p1\">*</ept> (optional)","pos":[2292,2316],"source":"*declarators* (optional)"},{"content":"Declarations of variables based on this type.","pos":[2320,2365]},{"content":"Example","pos":[2374,2381]},{"content":"The following example demonstrates how to declare and instantiate a generic interface.","pos":[2385,2471]},{"content":"In the example, the generic interface <ph id=\"ph1\">`IList&lt;ItemType&gt;`</ph> is declared.","pos":[2472,2540],"source":" In the example, the generic interface `IList<ItemType>` is declared."},{"content":"It is then implemented by two generic classes, <ph id=\"ph1\">`List1&lt;ItemType&gt;`</ph> and <ph id=\"ph2\">`List2&lt;ItemType&gt;`</ph>, with different implementations.","pos":[2541,2660],"source":" It is then implemented by two generic classes, `List1<ItemType>` and `List2<ItemType>`, with different implementations."},{"content":"Example","pos":[6641,6648]},{"content":"This example declares a generic interface, <ph id=\"ph1\">`IMyGenIface`</ph>, and two non-generic interfaces, <ph id=\"ph2\">`IMySpecializedInt`</ph> and <ph id=\"ph3\">`ImySpecializedString`</ph>, that specialize <ph id=\"ph4\">`IMyGenIface`</ph>.","pos":[6652,6820],"source":"This example declares a generic interface, `IMyGenIface`, and two non-generic interfaces, `IMySpecializedInt` and `ImySpecializedString`, that specialize `IMyGenIface`."},{"content":"The two specialized interfaces are then implemented by two classes, <ph id=\"ph1\">`MyIntClass`</ph> and <ph id=\"ph2\">`MyStringClass`</ph>.","pos":[6821,6922],"source":" The two specialized interfaces are then implemented by two classes, `MyIntClass` and `MyStringClass`."},{"content":"The example shows how to specialize generic interfaces, instantiate generic and non-generic interfaces, and call the explicitly implemented members on the interfaces.","pos":[6923,7089]},{"content":"See Also","pos":[8956,8964]},{"content":"Generics","pos":[8969,8977]}],"content":"---\ntitle: \"Generic Interfaces (Visual C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"generic interfaces\"\n  - \"interfaces, generic [C++}\"\nms.assetid: f3da788a-ba83-4db7-9dcf-9b95a8fb9d1a\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Generic Interfaces (Visual C++)\nThe restrictions that apply to type parameters on classes are the same as those that apply to type parameters on interfaces (see [Generic Classes (C++/CLI)](../windows/generic-classes-cpp-cli.md)).  \n  \n The rules that control function overloading are the same for functions within generic classes or generic interfaces.  \n  \n Explicit interface member implementations work with constructed interface types in the same way as with simple interface types (see the following examples).  \n  \n For more information on interfaces, see [interface class](../windows/interface-class-cpp-component-extensions.md).  \n  \n## Syntax  \n  \n```  \n[attributes] generic <class-key type-parameter-identifier[, ...]>  \n[type-parameter-constraints-clauses][accesibility-modifiers] interface class identifier [: base-list] {   interface-body} [declarators] ;  \n```  \n  \n## Remarks  \n *attributes* (optional)  \n Additional declarative information. For more information on attributes and attribute classes, see Attributes.  \n  \n *class-key*  \n **class** or **typename**  \n  \n `type-parameter-identifier(s)`  \n Comma-separated identifiers list.  \n  \n `type-parameter-constraints-clauses`  \n Takes the form specified in [Constraints on Generic Type Parameters (C++/CLI)](../windows/constraints-on-generic-type-parameters-cpp-cli.md)  \n  \n *accessibility-modifiers* (optional)  \n Accessibility modifiers (e.g. **public, private**).  \n  \n *identifier*  \n The interface name.  \n  \n *base-list* (optional)  \n A list that contains one or more explicit base interfaces separated by commas.  \n  \n *interface-body*  \n Declarations of the interface members.  \n  \n *declarators* (optional)  \n Declarations of variables based on this type.  \n  \n## Example  \n The following example demonstrates how to declare and instantiate a generic interface. In the example, the generic interface `IList<ItemType>` is declared. It is then implemented by two generic classes, `List1<ItemType>` and `List2<ItemType>`, with different implementations.  \n  \n```  \n// generic_interface.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \n// An exception to be thrown by the List when  \n// attempting to access elements beyond the  \n// end of the list.  \nref class ElementNotFoundException : Exception {};  \n  \n// A generic List interface  \ngeneric <typename ItemType>  \npublic interface class IList {  \n   ItemType MoveFirst();  \n   bool Add(ItemType item);  \n   bool AtEnd();  \n   ItemType Current();  \n   void MoveNext();  \n};  \n  \n// A linked list implementation of IList  \ngeneric <typename ItemType>  \npublic ref class List1 : public IList<ItemType> {  \n   ref class Node {  \n      ItemType m_item;  \n  \n   public:  \n      ItemType get_Item() { return m_item; };  \n      void set_Item(ItemType value) { m_item = value; };  \n  \n      Node^ next;  \n  \n      Node(ItemType item) {  \n         m_item = item;  \n         next = nullptr;  \n      }  \n   };  \n  \n   Node^ first;  \n   Node^ last;  \n   Node^ current;  \n  \n   public:  \n   List1() {  \n      first = nullptr;  \n      last = first;  \n      current = first;  \n   }  \n  \n   virtual ItemType MoveFirst() {  \n      current = first;  \n      if (first != nullptr)  \n        return first->get_Item();  \n      else  \n         return ItemType();  \n   }  \n  \n   virtual bool Add(ItemType item) {  \n      if (last != nullptr) {   \n         last->next = gcnew Node(item);  \n         last = last->next;  \n      }  \n      else {  \n         first = gcnew Node(item);  \n         last = first;  \n         current = first;  \n      }  \n      return true;  \n   }  \n  \n   virtual bool AtEnd() {  \n      if (current == nullptr )  \n        return true;  \n      else   \n        return false;  \n   }  \n  \n   virtual ItemType Current() {  \n       if (current != nullptr)  \n         return current->get_Item();  \n       else  \n         throw gcnew ElementNotFoundException();  \n   }  \n  \n   virtual void MoveNext() {  \n      if (current != nullptr)  \n       current = current->next;  \n      else  \n        throw gcnew ElementNotFoundException();  \n   }  \n};  \n  \n// An array implementation of IList  \ngeneric <typename ItemType>  \nref class List2 : public IList<ItemType> {  \n   array<ItemType>^ item_array;  \n   int count;  \n   int current;  \n  \n   public:  \n  \n   List2() {  \n      // not yet possible to declare an  \n      // array of a generic type parameter  \n      item_array = gcnew array<ItemType>(256);  \n      count = current = 0;  \n   }  \n  \n   virtual ItemType MoveFirst() {  \n      current = 0;  \n      return item_array[0];  \n   }  \n  \n   virtual bool Add(ItemType item) {  \n      if (count < 256)  \n         item_array[count++] = item;  \n      else  \n        return false;  \n      return true;  \n   }  \n  \n   virtual bool AtEnd() {  \n      if (current >= count)  \n        return true;  \n      else  \n        return false;  \n   }  \n  \n   virtual ItemType Current() {  \n      if (current < count)  \n        return item_array[current];  \n      else  \n        throw gcnew ElementNotFoundException();  \n   }  \n  \n   virtual void MoveNext() {  \n      if (current < count)   \n         ++current;  \n      else  \n         throw gcnew ElementNotFoundException();  \n   }  \n};  \n  \n// Add elements to the list and display them.  \ngeneric <typename ItemType>  \nvoid AddStringsAndDisplay(IList<ItemType>^ list, ItemType item1, ItemType item2) {  \n   list->Add(item1);  \n   list->Add(item2);  \n   for (list->MoveFirst(); ! list->AtEnd(); list->MoveNext())  \n     Console::WriteLine(list->Current());  \n}  \n  \nint main() {  \n   // Instantiate both types of list.  \n  \n   List1<String^>^ list1 = gcnew List1<String^>();  \n   List2<String^>^ list2 = gcnew List2<String^>();  \n  \n   // Use the linked list implementation of IList.  \n   AddStringsAndDisplay<String^>(list1, \"Linked List\", \"List1\");  \n  \n   // Use the array implementation of the IList.  \n   AddStringsAndDisplay<String^>(list2, \"Array List\", \"List2\");  \n}  \n```  \n  \n```Output  \nLinked List  \nList1  \nArray List  \nList2  \n```  \n  \n## Example  \n This example declares a generic interface, `IMyGenIface`, and two non-generic interfaces, `IMySpecializedInt` and `ImySpecializedString`, that specialize `IMyGenIface`. The two specialized interfaces are then implemented by two classes, `MyIntClass` and `MyStringClass`. The example shows how to specialize generic interfaces, instantiate generic and non-generic interfaces, and call the explicitly implemented members on the interfaces.  \n  \n```  \n// generic_interface2.cpp  \n// compile with: /clr  \n// Specializing and implementing generic interfaces.  \nusing namespace System;  \n  \ngeneric <class ItemType>  \npublic interface class IMyGenIface {  \n   void Initialize(ItemType f);  \n};  \n  \npublic interface class IMySpecializedInt: public IMyGenIface<int> {  \n   void Display();  \n};  \n  \npublic interface class IMySpecializedString: public IMyGenIface<String^> {  \n   void Display();  \n};  \n  \npublic ref class MyIntClass: public IMySpecializedInt {  \n   int myField;  \n  \npublic:   \n   virtual void Initialize(int f) {  \n      myField = f;  \n   }  \n  \n   virtual void Display() {  \n      Console::WriteLine(\"The integer field contains: {0}\", myField);  \n   }      \n};  \n  \npublic ref struct MyStringClass: IMySpecializedString {      \n   String^ myField;  \n  \npublic:  \n   virtual void Initialize(String^ f) {  \n      myField = f;  \n    }  \n  \n   virtual void Display() {  \n      Console::WriteLine(\"The String field contains: {0}\", myField);  \n   }  \n};  \n  \nint main() {  \n   // Instantiate the generic interface.  \n   IMyGenIface<int>^ myIntObj = gcnew MyIntClass();  \n  \n   // Instantiate the specialized interface \"IMySpecializedInt.\"  \n   IMySpecializedInt^ mySpIntObj = (IMySpecializedInt^) myIntObj;  \n  \n   // Instantiate the generic interface.  \n   IMyGenIface<String^>^ myStringObj = gcnew MyStringClass();  \n  \n   // Instantiate the specialized interface \"IMySpecializedString.\"  \n   IMySpecializedString^ mySpStringObj =   \n            (IMySpecializedString^) myStringObj;  \n  \n   // Call the explicitly implemented interface members.  \n   myIntObj->Initialize(1234);  \n   mySpIntObj->Display();  \n  \n   myStringObj->Initialize(\"My string\");  \n   mySpStringObj->Display();  \n}  \n```  \n  \n```Output  \nThe integer field contains: 1234  \nThe String field contains: My string  \n```  \n  \n## See Also  \n [Generics](../windows/generics-cpp-component-extensions.md)"}