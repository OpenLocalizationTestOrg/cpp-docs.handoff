{"nodes":[{"pos":[12,40],"content":"__ll_rshift | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"__ll_rshift | Microsoft Docs","pos":[0,28]}]},{"content":"__ll_rshift","pos":[677,688]},{"content":"Microsoft Specific","pos":[691,709]},{"content":"Shifts a 64-bit value specified by the first parameter to the right by a number of bits specified by the second parameter.","pos":[718,840]},{"content":"Syntax","pos":[849,855]},{"content":"Parameters","pos":[942,952]},{"content":"[in]","pos":[956,960]},{"content":"The 64-bit integer value to shift right.","pos":[971,1011]},{"content":"[in]","pos":[1018,1022]},{"content":"The number of bits to shift, modulo 64 on x64, and modulo 32 on x86.","pos":[1033,1101]},{"content":"Return Value","pos":[1110,1122]},{"pos":[1126,1158],"content":"The mask shifted by <ph id=\"ph1\">`nBit`</ph> bits.","source":"The mask shifted by `nBit` bits."},{"content":"Requirements","pos":[1167,1179]},{"content":"Intrinsic","pos":[1186,1195]},{"content":"Architecture","pos":[1196,1208]},{"pos":[1266,1270],"content":"x86,"},{"pos":[1342,1369],"content":"<bpt id=\"p1\">**</bpt>Header file<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>intrin.h&gt;","source":"**Header file** \\<intrin.h>"},{"content":"Remarks","pos":[1378,1385]},{"content":"If the second parameter is greater than 64 on x64 (32 on x86), that number is taken modulo 64 (32 on x86) to determine the number of bits to shift.","pos":[1389,1536]},{"content":"The <ph id=\"ph1\">`ll`</ph> prefix indicates that this is an operation on <ph id=\"ph2\">`long long`</ph>, another name for <ph id=\"ph3\">`__int64`</ph>, the 64-bit signed integral type.","pos":[1537,1665],"source":" The `ll` prefix indicates that this is an operation on `long long`, another name for `__int64`, the 64-bit signed integral type."},{"content":"Example","pos":[1674,1681]},{"content":"Output","pos":[2134,2140]},{"pos":[2217,2398],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> If <ph id=\"ph1\">`_ull_rshift`</ph> has been used, the MSB of the right-shifted value would have been zero, so the desired result would not have been obtained in the case of a negative value.","source":"**Note** If `_ull_rshift` has been used, the MSB of the right-shifted value would have been zero, so the desired result would not have been obtained in the case of a negative value."},{"content":"END Microsoft Specific","pos":[2408,2430]},{"content":"See Also","pos":[2439,2447]},{"content":"Compiler Intrinsics","pos":[2452,2471]},{"content":"__ll_lshift","pos":[2516,2527]},{"content":"__ull_rshift","pos":[2562,2574]}],"content":"---\ntitle: \"__ll_rshift | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"__ll_rshift_cpp\"\n  - \"__ll_rshift\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__ll_rshift intrinsic\"\n  - \"ll_rshift intrinsic\"\nms.assetid: ef13b732-d122-44a0-add9-f5544a2c4ab2\ncaps.latest.revision: 12\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# __ll_rshift\n**Microsoft Specific**  \n  \n Shifts a 64-bit value specified by the first parameter to the right by a number of bits specified by the second parameter.  \n  \n## Syntax  \n  \n```  \n__int64 __ll_rshift(  \n   __int64 Mask,  \n   int nBit  \n);  \n```  \n  \n#### Parameters  \n [in] `Mask`  \n The 64-bit integer value to shift right.  \n  \n [in] `nBit`  \n The number of bits to shift, modulo 64 on x64, and modulo 32 on x86.  \n  \n## Return Value  \n The mask shifted by `nBit` bits.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|  \n|---------------|------------------|  \n|`__ll_rshift`|x86, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|  \n  \n **Header file** \\<intrin.h>  \n  \n## Remarks  \n If the second parameter is greater than 64 on x64 (32 on x86), that number is taken modulo 64 (32 on x86) to determine the number of bits to shift. The `ll` prefix indicates that this is an operation on `long long`, another name for `__int64`, the 64-bit signed integral type.  \n  \n## Example  \n  \n```  \n// ll_rshift.cpp  \n// compile with: /EHsc  \n// processor: x86, x64  \n#include <iostream>  \n#include <intrin.h>  \nusing namespace std;  \n  \n#pragma intrinsic(__ll_rshift)  \n  \nint main()  \n{  \n   __int64 Mask = - 0x100;  \n   int nBit = 4;  \n   cout << hex << Mask << endl;  \n   cout << \" - \" << (- Mask) << endl;  \n   Mask = __ll_rshift(Mask, nBit);  \n   cout << hex << Mask << endl;  \n   cout << \" - \" << (- Mask) << endl;  \n}  \n```  \n  \n## Output  \n  \n```  \nffffffffffffff00  \n - 100  \nfffffffffffffff0  \n - 10  \n```  \n  \n **Note** If `_ull_rshift` has been used, the MSB of the right-shifted value would have been zero, so the desired result would not have been obtained in the case of a negative value.  \n  \n### END Microsoft Specific  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)   \n [__ll_lshift](../intrinsics/ll-lshift.md)   \n [__ull_rshift](../intrinsics/ull-rshift.md)"}