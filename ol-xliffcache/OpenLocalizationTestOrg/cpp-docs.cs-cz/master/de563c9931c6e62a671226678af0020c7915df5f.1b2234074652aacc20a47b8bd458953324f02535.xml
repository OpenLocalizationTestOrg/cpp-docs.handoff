{"nodes":[{"pos":[12,47],"content":"Function Templates | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Function Templates | Microsoft Docs","pos":[0,35]}]},{"content":"Function Templates","pos":[662,680]},{"content":"Class templates define a family of related classes that are based on the type arguments passed to the class upon instantiation.","pos":[681,808]},{"content":"Function templates are similar to class templates but define a family of functions.","pos":[809,892]},{"content":"With function templates, you can specify a set of functions that are based on the same code but act on different types or classes.","pos":[893,1023]},{"content":"The following function template swaps two items:","pos":[1024,1072]},{"content":"This code defines a family of functions that swap the values of the arguments.","pos":[1235,1313]},{"content":"From this template, you can generate functions that will swap <ph id=\"ph1\">`int`</ph> and <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> types and also user-defined types.","pos":[1314,1429],"source":" From this template, you can generate functions that will swap `int` and **long** types and also user-defined types."},{"content":"will even swap classes if the class's copy constructor and assignment operator are properly defined.","pos":[1439,1539]},{"pos":[1546,1723],"content":"In addition, the function template will prevent you from swapping objects of different types, because the compiler knows the types of the <ph id=\"ph1\">`a`</ph> and <ph id=\"ph2\">`b`</ph> parameters at compile time.","source":"In addition, the function template will prevent you from swapping objects of different types, because the compiler knows the types of the `a` and `b` parameters at compile time."},{"content":"Although this function could be performed by a nontemplated function, using void pointers, the template version is typesafe.","pos":[1730,1854]},{"content":"Consider the following calls:","pos":[1855,1884]},{"content":"The second <ph id=\"ph1\">`MySwap`</ph> call triggers a compile-time error, because the compiler cannot generate a <ph id=\"ph2\">`MySwap`</ph> function with parameters of different types.","pos":[2038,2186],"source":"The second `MySwap` call triggers a compile-time error, because the compiler cannot generate a `MySwap` function with parameters of different types."},{"content":"If void pointers were used, both function calls would compile correctly, but the function would not work properly at run time.","pos":[2187,2313]},{"content":"Explicit specification of the template arguments for a function template is allowed.","pos":[2320,2404]},{"content":"For example:","pos":[2405,2417]},{"content":"When the template argument is explicitly specified, normal implicit conversions are done to convert the function argument to the type of the corresponding function template parameters.","pos":[2646,2830]},{"content":"In the above example, the compiler will convert (<ph id=\"ph1\">`char j`</ph>) to type <ph id=\"ph2\">`int`</ph>.","pos":[2831,2904],"source":" In the above example, the compiler will convert (`char j`) to type `int`."},{"content":"See Also","pos":[2913,2921]},{"content":"Templates","pos":[2926,2935]},{"content":"Function Template Instantiation","pos":[2967,2998]},{"content":"Explicit Instantiation","pos":[3048,3070]},{"content":"Explicit Specialization of Function Templates","pos":[3111,3156]}],"content":"---\ntitle: \"Function Templates | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"function templates\"\n  - \"templates, function\"\n  - \"function templates, about function templates\"\nms.assetid: 59b56a4b-0689-4161-9c07-25021562e2a7\ncaps.latest.revision: 6\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Function Templates\nClass templates define a family of related classes that are based on the type arguments passed to the class upon instantiation. Function templates are similar to class templates but define a family of functions. With function templates, you can specify a set of functions that are based on the same code but act on different types or classes. The following function template swaps two items:  \n  \n```  \n// function_templates1.cpp  \ntemplate< class T > void MySwap( T& a, T& b ) {  \n   T c(a);   \n   a = b;   \n   b = c;  \n}  \nint main() {  \n}  \n```  \n  \n This code defines a family of functions that swap the values of the arguments. From this template, you can generate functions that will swap `int` and **long** types and also user-defined types. `MySwap` will even swap classes if the class's copy constructor and assignment operator are properly defined.  \n  \n In addition, the function template will prevent you from swapping objects of different types, because the compiler knows the types of the `a` and `b` parameters at compile time.  \n  \n Although this function could be performed by a nontemplated function, using void pointers, the template version is typesafe. Consider the following calls:  \n  \n```  \nint j = 10;  \nint k = 18;  \nCString Hello = \"Hello, Windows!\";  \nMySwap( j, k );          //OK  \nMySwap( j, Hello );      //error  \n```  \n  \n The second `MySwap` call triggers a compile-time error, because the compiler cannot generate a `MySwap` function with parameters of different types. If void pointers were used, both function calls would compile correctly, but the function would not work properly at run time.  \n  \n Explicit specification of the template arguments for a function template is allowed. For example:  \n  \n```  \n// function_templates2.cpp  \ntemplate<class T> void f(T) {}  \nint main(int j) {  \n   f<char>(j);   // Generate the specialization f(char).  \n   // If not explicitly specified, f(int) would be deduced.  \n}  \n```  \n  \n When the template argument is explicitly specified, normal implicit conversions are done to convert the function argument to the type of the corresponding function template parameters. In the above example, the compiler will convert (`char j`) to type `int`.  \n  \n## See Also  \n [Templates](../cpp/templates-cpp.md)   \n [Function Template Instantiation](../cpp/function-template-instantiation.md)   \n [Explicit Instantiation](../cpp/explicit-instantiation.md)   \n [Explicit Specialization of Function Templates](../cpp/explicit-specialization-of-function-templates.md)"}