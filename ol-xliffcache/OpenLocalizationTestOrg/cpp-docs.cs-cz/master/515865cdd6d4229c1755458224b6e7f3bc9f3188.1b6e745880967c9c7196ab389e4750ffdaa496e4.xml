{"nodes":[{"pos":[12,72],"content":"Changes in Constructor Initialization Order | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Changes in Constructor Initialization Order | Microsoft Docs","pos":[0,60]}]},{"content":"Changes in Constructor Initialization Order","pos":[599,642]},{"pos":[643,813],"content":"The order of initialization for class constructors has changed from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"The order of initialization for class constructors has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"Comparison of Constructor Initialization Order","pos":[822,868]},{"content":"Under Managed Extensions for C++, constructor initialization occurred in the following order:","pos":[872,965]},{"content":"The constructor of the base class, if any, is invoked.","pos":[975,1029]},{"content":"The initialization list of the class is evaluated.","pos":[1039,1089]},{"content":"The code body of the class constructor is executed.","pos":[1099,1150]},{"content":"This order of execution follows the same conventions as in native C++ programming.","pos":[1157,1239]},{"content":"The new Visual C++ language prescribes the following execution order for CLR classes:","pos":[1240,1325]},{"content":"The initialization list of the class is evaluated.","pos":[1335,1385]},{"content":"The constructor of the base class, if any, is invoked.","pos":[1395,1449]},{"content":"The code body of the class constructor is executed.","pos":[1459,1510]},{"content":"Note this change applies only to CLR classes; native classes in <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph> still follow the previous conventions.","pos":[1517,1691],"source":"Note this change applies only to CLR classes; native classes in [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] still follow the previous conventions."},{"content":"In both cases, these rules cascade upward throughout the whole hierarchy chain of a given class.","pos":[1692,1788]},{"content":"Consider the following code example using Managed Extensions for C++:","pos":[1795,1864]},{"pos":[2084,2244],"content":"Following the constructor initialization order prescribed above, we should see the following order of execution when new instances of class <ph id=\"ph1\">`B`</ph> are constructed:","source":"Following the constructor initialization order prescribed above, we should see the following order of execution when new instances of class `B` are constructed:"},{"content":"The constructor of the base class <ph id=\"ph1\">`A`</ph> is invoked.","pos":[2254,2303],"source":"The constructor of the base class `A` is invoked."},{"content":"The <ph id=\"ph1\">`_n`</ph> member is initialized to <ph id=\"ph2\">`1`</ph>.","pos":[2304,2342],"source":" The `_n` member is initialized to `1`."},{"content":"The initialization list for class <ph id=\"ph1\">`B`</ph> is evaluated.","pos":[2352,2403],"source":"The initialization list for class `B` is evaluated."},{"content":"The <ph id=\"ph1\">`_m`</ph> member is initialized to <ph id=\"ph2\">`1`</ph>.","pos":[2404,2442],"source":" The `_m` member is initialized to `1`."},{"pos":[2452,2491],"content":"The code body of class <ph id=\"ph1\">`B`</ph> is executed.","source":"The code body of class `B` is executed."},{"content":"Now consider the same code in the new Visual C++ syntax:","pos":[2498,2554]},{"pos":[2765,2860],"content":"The order of execution when new instances of class <ph id=\"ph1\">`B`</ph> are constructed under the new syntax is:","source":"The order of execution when new instances of class `B` are constructed under the new syntax is:"},{"content":"The initialization list for class <ph id=\"ph1\">`B`</ph> is evaluated.","pos":[2870,2921],"source":"The initialization list for class `B` is evaluated."},{"content":"The <ph id=\"ph1\">`_m`</ph> member is initialized to <ph id=\"ph2\">`0`</ph> (<ph id=\"ph3\">`0`</ph> is the uninitialized value of the <ph id=\"ph4\">`_m`</ph> class member).","pos":[2922,3018],"source":" The `_m` member is initialized to `0` (`0` is the uninitialized value of the `_m` class member)."},{"content":"The constructor of the base class <ph id=\"ph1\">`A`</ph> is invoked.","pos":[3028,3077],"source":"The constructor of the base class `A` is invoked."},{"content":"The <ph id=\"ph1\">`_n`</ph> member is initialized to <ph id=\"ph2\">`1`</ph>.","pos":[3078,3116],"source":" The `_n` member is initialized to `1`."},{"pos":[3126,3165],"content":"The code body of class <ph id=\"ph1\">`B`</ph> is executed.","source":"The code body of class `B` is executed."},{"content":"Note that a similar syntax produces different results for these code examples.","pos":[3172,3250]},{"content":"The constructor of class <ph id=\"ph1\">`B`</ph> depends on a value from base class <ph id=\"ph2\">`A`</ph> to initialize its member.","pos":[3251,3344],"source":" The constructor of class `B` depends on a value from base class `A` to initialize its member."},{"content":"However, the constructor for class <ph id=\"ph1\">`A`</ph> has not yet been invoked.","pos":[3345,3409],"source":" However, the constructor for class `A` has not yet been invoked."},{"content":"Such a dependency can be especially dangerous when the inherited class depends on a memory or resource allocation to occur in the base class constructor.","pos":[3410,3563]},{"content":"What This Means Going from Managed Extensions for C++ to Visual C++ 2010","pos":[3572,3644]},{"content":"In many cases the changes to the execution order of class constructors should be transparent to the programmer because base classes have no notion of the behavior of inherited classes.","pos":[3648,3832]},{"content":"However, as these code examples illustrate, the constructors of inherited classes can be greatly affected when their initialization lists depend on the values of base class members.","pos":[3833,4014]},{"content":"When you move your code from Managed Extensions for C++ to the new syntax, consider moving such constructs to the body of the class constructor, where execution is guaranteed to occur last.","pos":[4015,4204]},{"content":"See Also","pos":[4213,4221]},{"content":"Managed Types (C++/CL)","pos":[4226,4248]},{"content":"Constructors","pos":[4290,4302]}],"content":"---\ntitle: \"Changes in Constructor Initialization Order | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"constructors, C++\"\nms.assetid: 8892c38d-6bf7-4cf7-ac8f-15e052135a79\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Changes in Constructor Initialization Order\nThe order of initialization for class constructors has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n## Comparison of Constructor Initialization Order  \n Under Managed Extensions for C++, constructor initialization occurred in the following order:  \n  \n1.  The constructor of the base class, if any, is invoked.  \n  \n2.  The initialization list of the class is evaluated.  \n  \n3.  The code body of the class constructor is executed.  \n  \n This order of execution follows the same conventions as in native C++ programming. The new Visual C++ language prescribes the following execution order for CLR classes:  \n  \n1.  The initialization list of the class is evaluated.  \n  \n2.  The constructor of the base class, if any, is invoked.  \n  \n3.  The code body of the class constructor is executed.  \n  \n Note this change applies only to CLR classes; native classes in [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] still follow the previous conventions. In both cases, these rules cascade upward throughout the whole hierarchy chain of a given class.  \n  \n Consider the following code example using Managed Extensions for C++:  \n  \n```  \n__gc class A  \n{  \npublic:  \n   A() : _n(1)  \n   {  \n   }  \n  \nprotected:  \n   int _n;  \n};  \n  \n__gc class B : public A  \n{  \npublic:  \n   B() : _m(_n)  \n   {  \n   }  \nprivate:  \n   int _m;  \n};  \n```  \n  \n Following the constructor initialization order prescribed above, we should see the following order of execution when new instances of class `B` are constructed:  \n  \n1.  The constructor of the base class `A` is invoked. The `_n` member is initialized to `1`.  \n  \n2.  The initialization list for class `B` is evaluated. The `_m` member is initialized to `1`.  \n  \n3.  The code body of class `B` is executed.  \n  \n Now consider the same code in the new Visual C++ syntax:  \n  \n```  \nref class A  \n{  \npublic:  \n   A() : _n(1)  \n   {  \n   }  \n  \nprotected:  \n   int _n;  \n};  \n  \nref class B : A  \n{  \npublic:  \n   B() : _m(_n)  \n   {  \n   }  \nprivate:  \n   int _m;  \n};  \n```  \n  \n The order of execution when new instances of class `B` are constructed under the new syntax is:  \n  \n1.  The initialization list for class `B` is evaluated. The `_m` member is initialized to `0` (`0` is the uninitialized value of the `_m` class member).  \n  \n2.  The constructor of the base class `A` is invoked. The `_n` member is initialized to `1`.  \n  \n3.  The code body of class `B` is executed.  \n  \n Note that a similar syntax produces different results for these code examples. The constructor of class `B` depends on a value from base class `A` to initialize its member. However, the constructor for class `A` has not yet been invoked. Such a dependency can be especially dangerous when the inherited class depends on a memory or resource allocation to occur in the base class constructor.  \n  \n## What This Means Going from Managed Extensions for C++ to Visual C++ 2010  \n In many cases the changes to the execution order of class constructors should be transparent to the programmer because base classes have no notion of the behavior of inherited classes. However, as these code examples illustrate, the constructors of inherited classes can be greatly affected when their initialization lists depend on the values of base class members. When you move your code from Managed Extensions for C++ to the new syntax, consider moving such constructs to the body of the class constructor, where execution is guaranteed to occur last.  \n  \n## See Also  \n [Managed Types (C++/CL)](../dotnet/managed-types-cpp-cl.md)   \n [Constructors](../cpp/constructors-cpp.md)   \n "}