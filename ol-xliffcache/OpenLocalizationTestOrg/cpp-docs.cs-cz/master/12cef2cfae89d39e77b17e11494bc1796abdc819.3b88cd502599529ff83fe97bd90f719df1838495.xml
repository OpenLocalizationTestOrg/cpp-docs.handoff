{"nodes":[{"pos":[12,51],"content":"CMemoryState Structure | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CMemoryState Structure | Microsoft Docs","pos":[0,39]}]},{"content":"CMemoryState Structure","pos":[677,699]},{"content":"Provides a convenient way to detect memory leaks in your program.","pos":[700,765]},{"content":"Syntax","pos":[774,780]},{"content":"Members","pos":[826,833]},{"content":"Public Constructors","pos":[843,862]},{"content":"Name","pos":[869,873]},{"content":"Description","pos":[874,885]},{"content":"CMemoryState::CMemoryState","pos":[924,950]},{"content":"Constructs a class-like structure that controls memory checkpoints.","pos":[981,1048]},{"content":"Public Methods","pos":[1059,1073]},{"content":"Name","pos":[1080,1084]},{"content":"Description","pos":[1085,1096]},{"content":"CMemoryState::Checkpoint","pos":[1135,1159]},{"content":"Obtains a snapshot (checkpoint) of the current memory state.","pos":[1188,1248]},{"content":"CMemoryState::Difference","pos":[1254,1278]},{"pos":[1307,1374],"content":"Computes the difference between two objects of type <ph id=\"ph1\">`CMemoryState`</ph>.","source":"Computes the difference between two objects of type `CMemoryState`."},{"content":"CMemoryState::DumpAllObjectsSince","pos":[1380,1413]},{"content":"Dumps a summary of all currently allocated objects since a previous checkpoint.","pos":[1451,1530]},{"content":"CMemoryState::DumpStatistics","pos":[1536,1564]},{"pos":[1597,1661],"content":"Prints memory allocation statistics for a <ph id=\"ph1\">`CMemoryState`</ph> object.","source":"Prints memory allocation statistics for a `CMemoryState` object."},{"content":"Remarks","pos":[1671,1678]},{"pos":[1697,1743],"content":"is a structure and does not have a base class."},{"content":"A \"memory leak\" occurs when memory for an object is allocated on the heap but not deallocated when it is no longer required.","pos":[1750,1874]},{"content":"Such memory leaks can eventually lead to out-of-memory errors.","pos":[1875,1937]},{"content":"There are several ways to allocate and deallocate memory in your program:","pos":[1938,2011]},{"pos":[2021,2096],"content":"Using the <ph id=\"ph1\">`malloc`/ </ph><bpt id=\"p1\">**</bpt>free<ept id=\"p1\">**</ept> family of functions from the run-time library.","source":"Using the `malloc`/ **free** family of functions from the run-time library."},{"pos":[2106,2223],"content":"Using the Windows API memory management functions, <bpt id=\"p1\">**</bpt>LocalAlloc<ept id=\"p1\">**</ept><ph id=\"ph1\">/ </ph><bpt id=\"p2\">**</bpt>LocalFree<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>GlobalAlloc<ept id=\"p3\">**</ept><ph id=\"ph2\">/ </ph><bpt id=\"p4\">**</bpt>GlobalFree<ept id=\"p4\">**</ept>.","source":"Using the Windows API memory management functions, **LocalAlloc**/ **LocalFree** and **GlobalAlloc**/ **GlobalFree**."},{"pos":[2233,2280],"content":"Using the C++ <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> operators.","source":"Using the C++ **new** and **delete** operators."},{"content":"The <ph id=\"ph1\">`CMemoryState`</ph> diagnostics only help detect memory leaks caused when memory allocated using the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator is not deallocated using <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept>.","pos":[2287,2440],"source":"The `CMemoryState` diagnostics only help detect memory leaks caused when memory allocated using the **new** operator is not deallocated using **delete**."},{"content":"The other two groups of memory-management functions are for non-C++ programs, and mixing them with <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> in the same program is not recommended.","pos":[2441,2602],"source":" The other two groups of memory-management functions are for non-C++ programs, and mixing them with **new** and **delete** in the same program is not recommended."},{"content":"An additional macro, <ph id=\"ph1\">`DEBUG_NEW`</ph>, is provided to replace the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator when you need file and line-number tracking of memory allocations.","pos":[2603,2747],"source":" An additional macro, `DEBUG_NEW`, is provided to replace the **new** operator when you need file and line-number tracking of memory allocations."},{"content":"is used whenever you would normally use the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator.","pos":[2760,2821],"source":" is used whenever you would normally use the **new** operator."},{"content":"As with other diagnostics, the <ph id=\"ph1\">`CMemoryState`</ph> diagnostics are only available in debug versions of your program.","pos":[2828,2939],"source":"As with other diagnostics, the `CMemoryState` diagnostics are only available in debug versions of your program."},{"content":"A debug version must have the <bpt id=\"p1\">**</bpt>_DEBUG<ept id=\"p1\">**</ept> constant defined.","pos":[2940,2998],"source":" A debug version must have the **_DEBUG** constant defined."},{"content":"If you suspect your program has a memory leak, you can use the <ph id=\"ph1\">`Checkpoint`</ph>, <bpt id=\"p1\">**</bpt>Difference<ept id=\"p1\">**</ept>, and <ph id=\"ph2\">`DumpStatistics`</ph> functions to discover the difference between the memory state (objects allocated) at two different points in program execution.","pos":[3005,3246],"source":"If you suspect your program has a memory leak, you can use the `Checkpoint`, **Difference**, and `DumpStatistics` functions to discover the difference between the memory state (objects allocated) at two different points in program execution."},{"content":"This information can be useful in determining whether a function is cleaning up all the objects it allocates.","pos":[3247,3356]},{"content":"If simply knowing where the imbalance in allocation and deallocation occurs does not provide enough information, you can use the <ph id=\"ph1\">`DumpAllObjectsSince`</ph> function to dump all objects allocated since the previous call to <ph id=\"ph2\">`Checkpoint`</ph>.","pos":[3363,3593],"source":"If simply knowing where the imbalance in allocation and deallocation occurs does not provide enough information, you can use the `DumpAllObjectsSince` function to dump all objects allocated since the previous call to `Checkpoint`."},{"content":"This dump shows the order of allocation, the source file and line where the object was allocated (if you are using <ph id=\"ph1\">`DEBUG_NEW`</ph> for allocation), and the derivation of the object, its address, and its size.","pos":[3594,3798],"source":" This dump shows the order of allocation, the source file and line where the object was allocated (if you are using `DEBUG_NEW` for allocation), and the derivation of the object, its address, and its size."},{"content":"also calls each object's <ph id=\"ph1\">`Dump`</ph> function to provide information about its current state.","pos":[3821,3909],"source":" also calls each object's `Dump` function to provide information about its current state."},{"pos":[3916,4074],"content":"For more information about how to use <ph id=\"ph1\">`CMemoryState`</ph> and other diagnostics, see <bpt id=\"p1\">[</bpt>Debugging MFC Applications<ept id=\"p1\">](/visualstudio/debugger/mfc-debugging-techniques)</ept>.","source":"For more information about how to use `CMemoryState` and other diagnostics, see [Debugging MFC Applications](/visualstudio/debugger/mfc-debugging-techniques)."},{"pos":[4082,4321],"content":"[!NOTE]\n Declarations of objects of type `CMemoryState` and calls to member functions should be bracketed by `#if defined(_DEBUG)/#endif` directives. This causes memory diagnostics to be included only in debugging builds of your program.","leadings":["","> "],"nodes":[{"content":" Declarations of objects of type `CMemoryState` and calls to member functions should be bracketed by `#if defined(_DEBUG)/#endif` directives. This causes memory diagnostics to be included only in debugging builds of your program.","pos":[8,237],"nodes":[{"content":"Declarations of objects of type <ph id=\"ph1\">`CMemoryState`</ph> and calls to member functions should be bracketed by <ph id=\"ph2\">`#if defined(_DEBUG)/#endif`</ph> directives.","pos":[1,141],"source":" Declarations of objects of type `CMemoryState` and calls to member functions should be bracketed by `#if defined(_DEBUG)/#endif` directives."},{"content":"This causes memory diagnostics to be included only in debugging builds of your program.","pos":[142,229]}]}]},{"content":"Inheritance Hierarchy","pos":[4330,4351]},{"content":"Requirements","pos":[4378,4390]},{"pos":[4394,4411],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afx.h","source":"**Header:** afx.h"},{"pos":[4462,4486],"content":"CMemoryState::Checkpoint"},{"pos":[4490,4569],"content":"Takes a snapshot summary of memory and stores it in this <ph id=\"ph1\">`CMemoryState`</ph> object.","source":"Takes a snapshot summary of memory and stores it in this `CMemoryState` object."},{"content":"Remarks","pos":[4613,4620]},{"pos":[4624,4785],"content":"The <ph id=\"ph1\">`CMemoryState`</ph> member functions <bpt id=\"p1\">[</bpt>Difference<ept id=\"p1\">](#cmemorystate__difference)</ept> and <bpt id=\"p2\">[</bpt>DumpAllObjectsSince<ept id=\"p2\">](#cmemorystate__dumpallobjectssince)</ept> use this snapshot data.","source":"The `CMemoryState` member functions [Difference](#cmemorystate__difference) and [DumpAllObjectsSince](#cmemorystate__dumpallobjectssince) use this snapshot data."},{"content":"Example","pos":[4795,4802]},{"pos":[4807,4887],"content":"See the example for the <bpt id=\"p1\">[</bpt>CMemoryState<ept id=\"p1\">](#cmemorystate__cmemorystate)</ept> constructor.","source":"See the example for the [CMemoryState](#cmemorystate__cmemorystate) constructor."},{"pos":[4940,4966],"content":"CMemoryState::CMemoryState"},{"pos":[4970,5141],"content":"Constructs an empty <ph id=\"ph1\">`CMemoryState`</ph> object that must be filled in by the <bpt id=\"p1\">[</bpt>Checkpoint<ept id=\"p1\">](#cmemorystate__checkpoint)</ept> or <bpt id=\"p2\">[</bpt>Difference<ept id=\"p2\">](#cmemorystate__difference)</ept> member function.","source":"Constructs an empty `CMemoryState` object that must be filled in by the [Checkpoint](#cmemorystate__checkpoint) or [Difference](#cmemorystate__difference) member function."},{"content":"Example","pos":[5182,5189]},{"pos":[5204,5224],"content":"NVC_MFC_Utilities#18"},{"pos":[5333,5357],"content":"CMemoryState::Difference"},{"pos":[5361,5457],"content":"Compares two <ph id=\"ph1\">`CMemoryState`</ph> objects, then stores the difference into this <ph id=\"ph2\">`CMemoryState`</ph> object.","source":"Compares two `CMemoryState` objects, then stores the difference into this `CMemoryState` object."},{"content":"Parameters","pos":[5566,5576]},{"content":"oldState","pos":[5581,5589]},{"content":"The initial memory state as defined by a <ph id=\"ph1\">`CMemoryState`</ph> checkpoint.","pos":[5594,5661],"source":" The initial memory state as defined by a `CMemoryState` checkpoint."},{"content":"newState","pos":[5669,5677]},{"content":"The new memory state as defined by a <ph id=\"ph1\">`CMemoryState`</ph> checkpoint.","pos":[5682,5745],"source":" The new memory state as defined by a `CMemoryState` checkpoint."},{"content":"Return Value","pos":[5755,5767]},{"content":"Nonzero if the two memory states are different; otherwise 0.","pos":[5771,5831]},{"content":"Remarks","pos":[5841,5848]},{"pos":[5852,5958],"content":"<bpt id=\"p1\">[</bpt>Checkpoint<ept id=\"p1\">](#cmemorystate__checkpoint)</ept> must have been called for each of the two memory-state parameters.","source":"[Checkpoint](#cmemorystate__checkpoint) must have been called for each of the two memory-state parameters."},{"content":"Example","pos":[5968,5975]},{"pos":[5980,6060],"content":"See the example for the <bpt id=\"p1\">[</bpt>CMemoryState<ept id=\"p1\">](#cmemorystate__cmemorystate)</ept> constructor.","source":"See the example for the [CMemoryState](#cmemorystate__cmemorystate) constructor."},{"pos":[6120,6153],"content":"CMemoryState::DumpAllObjectsSince"},{"pos":[6157,6375],"content":"Calls the <ph id=\"ph1\">`Dump`</ph> function for all objects of a type derived from class <ph id=\"ph2\">`CObject`</ph> that were allocated (and are still allocated) since the last <bpt id=\"p1\">[</bpt>Checkpoint<ept id=\"p1\">](#cmemorystate__checkpoint)</ept> call for this <ph id=\"ph3\">`CMemoryState`</ph> object.","source":"Calls the `Dump` function for all objects of a type derived from class `CObject` that were allocated (and are still allocated) since the last [Checkpoint](#cmemorystate__checkpoint) call for this `CMemoryState` object."},{"content":"Remarks","pos":[6437,6444]},{"pos":[6448,6568],"content":"Calling <ph id=\"ph1\">`DumpAllObjectsSince`</ph> with an uninitialized <ph id=\"ph2\">`CMemoryState`</ph> object will dump out all objects currently in memory.","source":"Calling `DumpAllObjectsSince` with an uninitialized `CMemoryState` object will dump out all objects currently in memory."},{"content":"Example","pos":[6578,6585]},{"pos":[6590,6670],"content":"See the example for the <bpt id=\"p1\">[</bpt>CMemoryState<ept id=\"p1\">](#cmemorystate__cmemorystate)</ept> constructor.","source":"See the example for the [CMemoryState](#cmemorystate__cmemorystate) constructor."},{"pos":[6725,6753],"content":"CMemoryState::DumpStatistics"},{"pos":[6757,6906],"content":"Prints a concise memory statistics report from a <ph id=\"ph1\">`CMemoryState`</ph> object that is filled by the <bpt id=\"p1\">[</bpt>Difference<ept id=\"p1\">](#cmemorystate__difference)</ept> member function.","source":"Prints a concise memory statistics report from a `CMemoryState` object that is filled by the [Difference](#cmemorystate__difference) member function."},{"content":"Remarks","pos":[6963,6970]},{"pos":[6974,7120],"content":"The report, which is printed on the <bpt id=\"p1\">[</bpt>afxDump<ept id=\"p1\">](http://msdn.microsoft.com/library/4b3cfa3f-fb75-456a-9d99-a5601acbcb11)</ept> device, shows the following:","source":"The report, which is printed on the [afxDump](http://msdn.microsoft.com/library/4b3cfa3f-fb75-456a-9d99-a5601acbcb11) device, shows the following:"},{"content":"A sample report gives information on the number (or amount) of:","pos":[7127,7190]},{"content":"free blocks","pos":[7200,7211]},{"content":"normal blocks","pos":[7221,7234]},{"content":"CRT blocks","pos":[7244,7254]},{"content":"ignore blocks","pos":[7264,7277]},{"content":"client blocks","pos":[7287,7300]},{"content":"maximum memory used by the program at any one time (in bytes)","pos":[7310,7371]},{"content":"total memory currently used by the program (in bytes)","pos":[7381,7434]},{"content":"Free blocks are the number of blocks whose deallocation was delayed if <ph id=\"ph1\">`afxMemDF`</ph> was set to <bpt id=\"p1\">**</bpt>delayFreeMemDF<ept id=\"p1\">**</ept>.","pos":[7441,7553],"source":"Free blocks are the number of blocks whose deallocation was delayed if `afxMemDF` was set to **delayFreeMemDF**."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>afxMemDF<ept id=\"p1\">](diagnostic-services.md#afxmemdf)</ept>, in the \"MFC Macros and Globals\" section.","pos":[7554,7665],"source":" For more information, see [afxMemDF](diagnostic-services.md#afxmemdf), in the \"MFC Macros and Globals\" section."},{"content":"See <bpt id=\"p1\">[</bpt>Types of Blocks on the Debug Heap<ept id=\"p1\">](http://msdn.microsoft.com/en-us/db2e7f62-0679-4b39-a23f-26f2c2f407c5)</ept> for more information on these block types.","pos":[7666,7818],"source":" See [Types of Blocks on the Debug Heap](http://msdn.microsoft.com/en-us/db2e7f62-0679-4b39-a23f-26f2c2f407c5) for more information on these block types."},{"content":"Example","pos":[7828,7835]},{"content":"The following code should be placed in <bpt id=\"p1\">*</bpt>projname<ept id=\"p1\">*</ept>App.cpp.","pos":[7840,7897],"source":"The following code should be placed in *projname*App.cpp."},{"content":"Define the following global variables:","pos":[7898,7936]},{"pos":[7954,7974],"content":"NVC_MFC_Utilities#40"},{"pos":[8039,8084],"content":"In the <ph id=\"ph1\">`InitInstance`</ph> function, add the line:","source":"In the `InitInstance` function, add the line:"},{"pos":[8102,8122],"content":"NVC_MFC_Utilities#41"},{"pos":[8187,8260],"content":"Add a handler for the <ph id=\"ph1\">`ExitInstance`</ph> function and use the following code:","source":"Add a handler for the `ExitInstance` function and use the following code:"},{"pos":[8278,8298],"content":"NVC_MFC_Utilities#42"},{"pos":[8363,8456],"content":"You can now run the program in Debug mode to see the output of the <ph id=\"ph1\">`DumpStatistics`</ph> function.","source":"You can now run the program in Debug mode to see the output of the `DumpStatistics` function."},{"content":"See Also","pos":[8465,8473]},{"content":"Hierarchy Chart","pos":[8478,8493]}],"content":"---\ntitle: \"CMemoryState Structure | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CMemoryState\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CMemoryState structure\"\n  - \"memory leaks, detecting\"\n  - \"detecting memory leaks\"\nms.assetid: 229d9de7-a6f3-4cc6-805b-5a9d9b1bfe1d\ncaps.latest.revision: 19\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CMemoryState Structure\nProvides a convenient way to detect memory leaks in your program.  \n  \n## Syntax  \n  \n```  \nstruct CMemoryState  \n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CMemoryState::CMemoryState](#cmemorystate__cmemorystate)|Constructs a class-like structure that controls memory checkpoints.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CMemoryState::Checkpoint](#cmemorystate__checkpoint)|Obtains a snapshot (checkpoint) of the current memory state.|  \n|[CMemoryState::Difference](#cmemorystate__difference)|Computes the difference between two objects of type `CMemoryState`.|  \n|[CMemoryState::DumpAllObjectsSince](#cmemorystate__dumpallobjectssince)|Dumps a summary of all currently allocated objects since a previous checkpoint.|  \n|[CMemoryState::DumpStatistics](#cmemorystate__dumpstatistics)|Prints memory allocation statistics for a `CMemoryState` object.|  \n  \n## Remarks  \n `CMemoryState` is a structure and does not have a base class.  \n  \n A \"memory leak\" occurs when memory for an object is allocated on the heap but not deallocated when it is no longer required. Such memory leaks can eventually lead to out-of-memory errors. There are several ways to allocate and deallocate memory in your program:  \n  \n-   Using the `malloc`/ **free** family of functions from the run-time library.  \n  \n-   Using the Windows API memory management functions, **LocalAlloc**/ **LocalFree** and **GlobalAlloc**/ **GlobalFree**.  \n  \n-   Using the C++ **new** and **delete** operators.  \n  \n The `CMemoryState` diagnostics only help detect memory leaks caused when memory allocated using the **new** operator is not deallocated using **delete**. The other two groups of memory-management functions are for non-C++ programs, and mixing them with **new** and **delete** in the same program is not recommended. An additional macro, `DEBUG_NEW`, is provided to replace the **new** operator when you need file and line-number tracking of memory allocations. `DEBUG_NEW` is used whenever you would normally use the **new** operator.  \n  \n As with other diagnostics, the `CMemoryState` diagnostics are only available in debug versions of your program. A debug version must have the **_DEBUG** constant defined.  \n  \n If you suspect your program has a memory leak, you can use the `Checkpoint`, **Difference**, and `DumpStatistics` functions to discover the difference between the memory state (objects allocated) at two different points in program execution. This information can be useful in determining whether a function is cleaning up all the objects it allocates.  \n  \n If simply knowing where the imbalance in allocation and deallocation occurs does not provide enough information, you can use the `DumpAllObjectsSince` function to dump all objects allocated since the previous call to `Checkpoint`. This dump shows the order of allocation, the source file and line where the object was allocated (if you are using `DEBUG_NEW` for allocation), and the derivation of the object, its address, and its size. `DumpAllObjectsSince` also calls each object's `Dump` function to provide information about its current state.  \n  \n For more information about how to use `CMemoryState` and other diagnostics, see [Debugging MFC Applications](/visualstudio/debugger/mfc-debugging-techniques).  \n  \n> [!NOTE]\n>  Declarations of objects of type `CMemoryState` and calls to member functions should be bracketed by `#if defined(_DEBUG)/#endif` directives. This causes memory diagnostics to be included only in debugging builds of your program.  \n  \n## Inheritance Hierarchy  \n `CMemoryState`  \n  \n## Requirements  \n **Header:** afx.h  \n  \n##  <a name=\"cmemorystate__checkpoint\"></a>  CMemoryState::Checkpoint  \n Takes a snapshot summary of memory and stores it in this `CMemoryState` object.  \n  \n```  \nvoid Checkpoint();\n```  \n  \n### Remarks  \n The `CMemoryState` member functions [Difference](#cmemorystate__difference) and [DumpAllObjectsSince](#cmemorystate__dumpallobjectssince) use this snapshot data.  \n  \n### Example  \n  See the example for the [CMemoryState](#cmemorystate__cmemorystate) constructor.  \n  \n##  <a name=\"cmemorystate__cmemorystate\"></a>  CMemoryState::CMemoryState  \n Constructs an empty `CMemoryState` object that must be filled in by the [Checkpoint](#cmemorystate__checkpoint) or [Difference](#cmemorystate__difference) member function.  \n  \n```  \nCMemoryState();\n```  \n  \n### Example  \n [!code-cpp[NVC_MFC_Utilities#18](../../mfc/codesnippet/cpp/cmemorystate-structure_1.cpp)]  \n  \n##  <a name=\"cmemorystate__difference\"></a>  CMemoryState::Difference  \n Compares two `CMemoryState` objects, then stores the difference into this `CMemoryState` object.  \n  \n```  \nBOOL Difference(\n    const CMemoryState& oldState,   const CMemoryState& newState);\n```  \n  \n### Parameters  \n *oldState*  \n The initial memory state as defined by a `CMemoryState` checkpoint.  \n  \n *newState*  \n The new memory state as defined by a `CMemoryState` checkpoint.  \n  \n### Return Value  \n Nonzero if the two memory states are different; otherwise 0.  \n  \n### Remarks  \n [Checkpoint](#cmemorystate__checkpoint) must have been called for each of the two memory-state parameters.  \n  \n### Example  \n  See the example for the [CMemoryState](#cmemorystate__cmemorystate) constructor.  \n  \n##  <a name=\"cmemorystate__dumpallobjectssince\"></a>  CMemoryState::DumpAllObjectsSince  \n Calls the `Dump` function for all objects of a type derived from class `CObject` that were allocated (and are still allocated) since the last [Checkpoint](#cmemorystate__checkpoint) call for this `CMemoryState` object.  \n  \n```  \nvoid DumpAllObjectsSince() const;\n\n \n```  \n  \n### Remarks  \n Calling `DumpAllObjectsSince` with an uninitialized `CMemoryState` object will dump out all objects currently in memory.  \n  \n### Example  \n  See the example for the [CMemoryState](#cmemorystate__cmemorystate) constructor.  \n  \n##  <a name=\"cmemorystate__dumpstatistics\"></a>  CMemoryState::DumpStatistics  \n Prints a concise memory statistics report from a `CMemoryState` object that is filled by the [Difference](#cmemorystate__difference) member function.  \n  \n```  \nvoid DumpStatistics() const;\n\n \n```  \n  \n### Remarks  \n The report, which is printed on the [afxDump](http://msdn.microsoft.com/library/4b3cfa3f-fb75-456a-9d99-a5601acbcb11) device, shows the following:  \n  \n A sample report gives information on the number (or amount) of:  \n  \n-   free blocks  \n  \n-   normal blocks  \n  \n-   CRT blocks  \n  \n-   ignore blocks  \n  \n-   client blocks  \n  \n-   maximum memory used by the program at any one time (in bytes)  \n  \n-   total memory currently used by the program (in bytes)  \n  \n Free blocks are the number of blocks whose deallocation was delayed if `afxMemDF` was set to **delayFreeMemDF**. For more information, see [afxMemDF](diagnostic-services.md#afxmemdf), in the \"MFC Macros and Globals\" section. See [Types of Blocks on the Debug Heap](http://msdn.microsoft.com/en-us/db2e7f62-0679-4b39-a23f-26f2c2f407c5) for more information on these block types.  \n  \n### Example  \n  The following code should be placed in *projname*App.cpp. Define the following global variables:  \n  \n [!code-cpp[NVC_MFC_Utilities#40](../../mfc/codesnippet/cpp/cmemorystate-structure_2.cpp)]  \n  \n In the `InitInstance` function, add the line:  \n  \n [!code-cpp[NVC_MFC_Utilities#41](../../mfc/codesnippet/cpp/cmemorystate-structure_3.cpp)]  \n  \n Add a handler for the `ExitInstance` function and use the following code:  \n  \n [!code-cpp[NVC_MFC_Utilities#42](../../mfc/codesnippet/cpp/cmemorystate-structure_4.cpp)]  \n  \n You can now run the program in Debug mode to see the output of the `DumpStatistics` function.  \n  \n## See Also  \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)\n\n\n\n"}