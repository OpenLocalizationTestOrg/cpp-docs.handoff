{"nodes":[{"pos":[12,45],"content":"malloc Alignment | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"malloc Alignment | Microsoft Docs","pos":[0,33]}]},{"content":"malloc Alignment","pos":[526,542]},{"content":"<bpt id=\"p1\">[</bpt>malloc<ept id=\"p1\">](../c-runtime-library/reference/malloc.md)</ept> is guaranteed to return memory that's suitably aligned for storing any object that has a fundamental alignment and that could fit in the amount of memory that's allocated.","pos":[543,765],"source":"[malloc](../c-runtime-library/reference/malloc.md) is guaranteed to return memory that's suitably aligned for storing any object that has a fundamental alignment and that could fit in the amount of memory that's allocated."},{"content":"A <bpt id=\"p1\">*</bpt>fundamental alignment<ept id=\"p1\">*</ept> is an alignment that's less than or equal to the largest alignment that's supported by the implementation without an alignment specification.","pos":[766,933],"source":" A *fundamental alignment* is an alignment that's less than or equal to the largest alignment that's supported by the implementation without an alignment specification."},{"content":"(In Visual C++, this is the alignment that's required for a <ph id=\"ph1\">`double`</ph>, or 8 bytes.","pos":[934,1015],"source":" (In Visual C++, this is the alignment that's required for a `double`, or 8 bytes."},{"content":"In code that targets 64-bit platforms, it’s 16 bytes.) For example, a four-byte allocation would be aligned on a boundary that supports any four-byte or smaller object.","pos":[1016,1184]},{"content":"Visual C++ permits types that have <bpt id=\"p1\">*</bpt>extended alignment<ept id=\"p1\">*</ept>, which are also known as <bpt id=\"p2\">*</bpt>over-aligned<ept id=\"p2\">*</ept> types.","pos":[1191,1293],"source":"Visual C++ permits types that have *extended alignment*, which are also known as *over-aligned* types."},{"content":"For example, the SSE types <bpt id=\"p1\">[</bpt>__m128<ept id=\"p1\">](../cpp/m128.md)</ept> and <ph id=\"ph1\">`__m256`</ph>, and types that are declared by using <ph id=\"ph2\">`__declspec(align(``n``))`</ph> where <ph id=\"ph3\">`n`</ph> is greater than 8, have extended alignment.","pos":[1294,1477],"source":" For example, the SSE types [__m128](../cpp/m128.md) and `__m256`, and types that are declared by using `__declspec(align(``n``))` where `n` is greater than 8, have extended alignment."},{"content":"Memory alignment on a boundary that's suitable for an object that requires extended alignment is not guaranteed by <ph id=\"ph1\">`malloc`</ph>.","pos":[1478,1602],"source":" Memory alignment on a boundary that's suitable for an object that requires extended alignment is not guaranteed by `malloc`."},{"content":"To allocate memory for over-aligned types, use <bpt id=\"p1\">[</bpt>_aligned_malloc<ept id=\"p1\">](../c-runtime-library/reference/aligned-malloc.md)</ept> and related functions.","pos":[1603,1740],"source":" To allocate memory for over-aligned types, use [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md) and related functions."},{"content":"See Also","pos":[1749,1757]},{"content":"Stack Usage","pos":[1762,1773]},{"content":"align","pos":[1805,1810]},{"content":"__declspec","pos":[1838,1848]}],"content":"---\ntitle: \"malloc Alignment | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: a8d1d1b4-5122-456f-9a64-a50e105e55a5\ncaps.latest.revision: 14\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# malloc Alignment\n[malloc](../c-runtime-library/reference/malloc.md) is guaranteed to return memory that's suitably aligned for storing any object that has a fundamental alignment and that could fit in the amount of memory that's allocated. A *fundamental alignment* is an alignment that's less than or equal to the largest alignment that's supported by the implementation without an alignment specification. (In Visual C++, this is the alignment that's required for a `double`, or 8 bytes. In code that targets 64-bit platforms, it’s 16 bytes.) For example, a four-byte allocation would be aligned on a boundary that supports any four-byte or smaller object.  \n  \n Visual C++ permits types that have *extended alignment*, which are also known as *over-aligned* types. For example, the SSE types [__m128](../cpp/m128.md) and `__m256`, and types that are declared by using `__declspec(align(``n``))` where `n` is greater than 8, have extended alignment. Memory alignment on a boundary that's suitable for an object that requires extended alignment is not guaranteed by `malloc`. To allocate memory for over-aligned types, use [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md) and related functions.  \n  \n## See Also  \n [Stack Usage](../build/stack-usage.md)   \n [align](../cpp/align-cpp.md)   \n [__declspec](../cpp/declspec.md)"}