<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="cs-cz">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b5273828bd9e541395811e20232c792424544ff3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\left-shift-and-right-shift-operators-input-and-output.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f24bad0bd4174aece1e8f6638b96f6d14637fe04</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">294c40aa0500a56fa5227be7b5da4868a0fd9d64</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Left Shift and Right Shift Operators (<ph id="ph1">&amp;gt;&amp;gt;</ph> and <ph id="ph2">&amp;lt;&amp;lt;</ph>) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Left Shift and Right Shift Operators (<ph id="ph1">&amp;gt;&amp;gt;</ph> and <ph id="ph2">&amp;lt;&amp;lt;</ph>)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The bitwise shift operators are the right-shift operator (<ph id="ph1">`&gt;&gt;`</ph>), which moves the bits of <ph id="ph2">`shift_expression`</ph> to the right, and the left-shift operator (<ph id="ph3">`&lt;&lt;`</ph>), which moves the bits of <ph id="ph4">`shift_expression`</ph> to the left.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The following descriptions and examples are valid on Windows for X86 and x64 architectures.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The implementation of left-shift and right-shift operators is significantly different on Windows RT for ARM devices.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more information, see the "Shift Operators" section of the <bpt id="p1">[</bpt>Hello ARM<ept id="p1">](http://blogs.msdn.com/b/vcblog/archive/2012/10/25/hello-arm-exploring-undefined-unspecified-and-implementation-defined-behavior-in-c.aspx)</ept> blog post.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Left Shifts</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The left-shift operator causes the bits in <ph id="ph1">`shift-expression`</ph> to be shifted to the left by the number of positions specified by <ph id="ph2">`additive-expression`</ph>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The bit positions that have been vacated by the shift operation are zero-filled.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A left shift is a logical shift (the bits that are shifted off the end are discarded, including the sign bit).</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For more information about the kinds of bitwise shifts, see <bpt id="p1">[</bpt>Bitwise shifts<ept id="p1">](http://en.wikipedia.org/wiki/Bitwise_shift)</ept>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The following example shows left-shift operations using unsigned numbers.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The example shows what is happening to the bits by representing the value as a bitset.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>bitset Class<ept id="p1">](../standard-library/bitset-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you left-shift a signed number so that the sign bit is affected, the result is undefined.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The following example shows what happens in Visual C++ when a 1 bit is left-shifted into the sign bit position.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Right Shifts</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The right-shift operator causes the bit pattern in <ph id="ph1">`shift-expression`</ph> to be shifted to the right by the number of positions specified by <ph id="ph2">`additive-expression`</ph>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For unsigned numbers, the bit positions that have been vacated by the shift operation are zero-filled.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For signed numbers, the sign bit is used to fill the vacated bit positions.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In other words, if the number is positive, 0 is used, and if the number is negative, 1 is used.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The result of a right-shift of a signed negative number is implementation-dependent.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Although Visual C++ uses the sign bit to fill vacated bit positions, there is no guarantee that other implementations also do so.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This example shows right-shift operations using unsigned numbers:</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The next example shows right-shift operations with positive signed numbers.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The next example shows right-shift operations with negative signed integers.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Shifts and Promotions</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The expressions on both sides of a shift operator must be integral types.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Integral promotions are performed according to the rules described in <bpt id="p1">[</bpt>Standard Conversions<ept id="p1">](standard-conversions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The type of the result is the same as the type of the promoted <ph id="ph1">`shift-expression`</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In the following example, a variable of type <ph id="ph1">`char`</ph> is promoted to an <ph id="ph2">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Additional Details</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The result of a shift operation is undefined if <ph id="ph1">`additive-expression`</ph> is negative or if <ph id="ph2">`additive-expression`</ph> is greater than or equal to the number of bits in the (promoted) <ph id="ph3">`shift-expression`</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>No shift operation is performed if <ph id="ph1">`additive-expression`</ph> is 0.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>1 The following is the description of the shift operators in the C++ ISO specification (INCITS/ISO/IEC 14882-2011[2012]), sections 5.8.2 and 5.8.3.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The value of <ph id="ph1">`E1 &lt;&lt; E2`</ph> is <ph id="ph2">`E1`</ph> left-shifted <ph id="ph3">`E2`</ph> bit positions; vacated bits are zero-filled.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`E1`</ph> has an unsigned type, the value of the result is <ph id="ph2">`E1 × 2`&lt;sup&gt;</ph>E2<ph id="ph3">&lt;/sup&gt;</ph>, reduced modulo one more than the maximum value representable in the result type.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Otherwise, if <ph id="ph1">`E1`</ph> has a signed type and non-negative value, and <ph id="ph2">`E1 × 2`&lt;sup&gt;</ph>E2<ph id="ph3">&lt;/sup&gt;</ph> is representable in the corresponding unsigned type of the result type, then that value, converted to the result type, is the resulting value; otherwise, the behavior is undefined.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The value of <ph id="ph1">`E1 &gt;&gt; E2`</ph> is <ph id="ph2">`E1`</ph> right-shifted <ph id="ph3">`E2`</ph> bit positions.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`E1`</ph> has an unsigned type or if <ph id="ph2">`E1`</ph> has a signed type and a non-negative value, the value of the result is the integral part of the quotient of <ph id="ph3">`E1/2`&lt;sup&gt;</ph>E2<ph id="ph4">&lt;/sup&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`E1`</ph> has a signed type and a negative value, the resulting value is implementation-defined.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Expressions with Binary Operators</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>C++ Built-in Operators, Precedence and Associativity</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>