{"nodes":[{"pos":[12,74],"content":"Why Floating-Point Numbers May Lose Precision | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Why Floating-Point Numbers May Lose Precision | Microsoft Docs","pos":[0,62]}]},{"content":"Why Floating-Point Numbers May Lose Precision","pos":[671,716]},{"content":"Floating-point decimal values generally do not have an exact binary representation.","pos":[717,800]},{"content":"This is a side effect of how the CPU represents floating point data.","pos":[801,869]},{"content":"For this reason, you may experience some loss of precision, and some floating-point operations may produce unexpected results.","pos":[870,996]},{"content":"This behavior is the result of one of the following:","pos":[1003,1055]},{"content":"The binary representation of the decimal number may not be exact.","pos":[1065,1130]},{"content":"There is a type mismatch between the numbers used (for example, mixing float and double).","pos":[1140,1229]},{"content":"To resolve the behavior, most programmers either ensure that the value is greater or less than what is needed, or they get and use a Binary Coded Decimal (BCD) library that will maintain the precision.","pos":[1236,1437]},{"content":"Binary representation of floating-point values affects the precision and accuracy of floating-point calculations.","pos":[1444,1557]},{"content":"Microsoft Visual C++ uses <bpt id=\"p1\">[</bpt>IEEE floating-point format<ept id=\"p1\">](../../build/reference/ieee-floating-point-representation.md)</ept>.","pos":[1558,1674],"source":" Microsoft Visual C++ uses [IEEE floating-point format](../../build/reference/ieee-floating-point-representation.md)."},{"content":"Example","pos":[1683,1690]},{"content":"Comments","pos":[2541,2549]},{"content":"For EPSILON, you can use the constants FLT_EPSILON, which is defined for float as 1.192092896e-07F, or DBL_EPSILON, which is defined for double as 2.2204460492503131e-016.","pos":[2553,2724]},{"content":"You need to include float.h for these constants.","pos":[2725,2773]},{"content":"These constants are defined as the smallest positive number x, such that x+1.0 is not equal to 1.0.","pos":[2774,2873]},{"content":"Because this is a very small number, you should employ user-defined tolerance for calculations involving very large numbers.","pos":[2874,2998]},{"content":"See Also","pos":[3007,3015]},{"content":"Optimizing Your Code","pos":[3020,3040]}],"content":"---\ntitle: \"Why Floating-Point Numbers May Lose Precision | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"DBL_EPSILON constant\"\n  - \"FLT_EPSILON constant\"\n  - \"floating-point numbers, precision\"\nms.assetid: 1acb1add-ac06-4134-a2fd-aff13d8c4c15\ncaps.latest.revision: 10\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Why Floating-Point Numbers May Lose Precision\nFloating-point decimal values generally do not have an exact binary representation. This is a side effect of how the CPU represents floating point data. For this reason, you may experience some loss of precision, and some floating-point operations may produce unexpected results.  \n  \n This behavior is the result of one of the following:  \n  \n-   The binary representation of the decimal number may not be exact.  \n  \n-   There is a type mismatch between the numbers used (for example, mixing float and double).  \n  \n To resolve the behavior, most programmers either ensure that the value is greater or less than what is needed, or they get and use a Binary Coded Decimal (BCD) library that will maintain the precision.  \n  \n Binary representation of floating-point values affects the precision and accuracy of floating-point calculations. Microsoft Visual C++ uses [IEEE floating-point format](../../build/reference/ieee-floating-point-representation.md).  \n  \n## Example  \n  \n```  \n// Floating-point_number_precision.c  \n// Compile options needed: none. Value of c is printed with a decimal   \n// point precision of 10 and 6 (printf rounded value by default) to   \n// show the difference  \n#include <stdio.h>  \n  \n#define EPSILON 0.0001   // Define your own tolerance  \n#define FLOAT_EQ(x,v) (((v - EPSILON) < x) && (x <( v + EPSILON)))  \n  \nint main() {  \n   float a, b, c;  \n  \n   a = 1.345f;  \n   b = 1.123f;  \n   c = a + b;  \n   // if (FLOAT_EQ(c, 2.468)) // Remove comment for correct result  \n   if (c == 2.468)            // Comment this line for correct result  \n      printf_s(\"They are equal.\\n\");  \n   else  \n      printf_s(\"They are not equal! The value of c is %13.10f \"  \n                \"or %f\",c,c);  \n}  \n```  \n  \n```Output  \nThey are not equal! The value of c is  2.4679999352 or 2.468000  \n```  \n  \n## Comments  \n For EPSILON, you can use the constants FLT_EPSILON, which is defined for float as 1.192092896e-07F, or DBL_EPSILON, which is defined for double as 2.2204460492503131e-016. You need to include float.h for these constants. These constants are defined as the smallest positive number x, such that x+1.0 is not equal to 1.0. Because this is a very small number, you should employ user-defined tolerance for calculations involving very large numbers.  \n  \n## See Also  \n [Optimizing Your Code](../../build/reference/optimizing-your-code.md)"}