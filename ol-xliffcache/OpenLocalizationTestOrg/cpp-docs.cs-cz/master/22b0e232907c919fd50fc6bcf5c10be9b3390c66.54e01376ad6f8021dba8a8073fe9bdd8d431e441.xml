{"nodes":[{"pos":[12,66],"content":"How to: Extend the Marshaling Library | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Extend the Marshaling Library | Microsoft Docs","pos":[0,54]}]},{"content":"How to: Extend the Marshaling Library","pos":[617,654]},{"content":"This topic explains how to extend the marshaling library to provide more conversions between data types.","pos":[655,759]},{"content":"Users can extend the marshaling library for any data conversions not currently supported by the library.","pos":[760,864]},{"content":"You can extend the marshaling library in one of two ways - with or without a <bpt id=\"p1\">[</bpt>marshal_context Class<ept id=\"p1\">](../dotnet/marshal-context-class.md)</ept>.","pos":[871,1008],"source":"You can extend the marshaling library in one of two ways - with or without a [marshal_context Class](../dotnet/marshal-context-class.md)."},{"content":"Review the <bpt id=\"p1\">[</bpt>Overview of Marshaling in C++<ept id=\"p1\">](../dotnet/overview-of-marshaling-in-cpp.md)</ept> topic to determine whether a new conversion requires a context.","pos":[1009,1159],"source":" Review the [Overview of Marshaling in C++](../dotnet/overview-of-marshaling-in-cpp.md) topic to determine whether a new conversion requires a context."},{"content":"In both cases, you first create a file for new marshaling conversions.","pos":[1166,1236]},{"content":"You do so to preserve the integrity of the standard marshaling library files.","pos":[1237,1314]},{"content":"If you want to port a project to another computer or to another programmer, you must copy the new marshaling file together with the rest of the project.","pos":[1315,1467]},{"content":"In this manner, the user receiving the project will be guaranteed to receive the new conversions and will not have to modify any library files.","pos":[1468,1611]},{"content":"To Extend the Marshaling Library with a Conversion that does not Require a Context","pos":[1621,1703]},{"content":"Create a file to store the new marshaling functions, for example, MyMarshal.h.","pos":[1713,1791]},{"content":"Include one or more of the marshal library files:","pos":[1801,1850]},{"content":"marshal.h for base types.","pos":[1864,1889]},{"content":"marshal_windows.h for windows data types.","pos":[1903,1944]},{"content":"marshal_cppstd.h for STL data types.","pos":[1958,1994]},{"content":"marshal_atl.h for ATL data types.","pos":[2008,2041]},{"content":"Use the code at the end of these steps to write the conversion function.","pos":[2051,2123]},{"content":"In this code, TO is the type to convert to, FROM is the type to convert from, and <ph id=\"ph1\">`from`</ph> is the parameter to be converted.","pos":[2124,2246],"source":" In this code, TO is the type to convert to, FROM is the type to convert from, and `from` is the parameter to be converted."},{"pos":[2256,2399],"content":"Replace the comment about conversion logic with code to convert the <ph id=\"ph1\">`from`</ph> parameter into an object of TO type and return the converted object.","source":"Replace the comment about conversion logic with code to convert the `from` parameter into an object of TO type and return the converted object."},{"content":"To Extend the Marshaling Library with a Conversion that Requires a Context","pos":[2640,2714]},{"content":"Create a file to store the new marshaling functions, for example, MyMarshal.h","pos":[2724,2801]},{"content":"Include one or more of the marshal library files:","pos":[2811,2860]},{"content":"marshal.h for base types.","pos":[2874,2899]},{"content":"marshal_windows.h for windows data types.","pos":[2913,2954]},{"content":"marshal_cppstd.h for STL data types.","pos":[2968,3004]},{"content":"marshal_atl.h for ATL data types.","pos":[3018,3051]},{"content":"Use the code at the end of these steps to write the conversion function.","pos":[3061,3133]},{"content":"In this code, TO is the type to convert to, FROM is the type to convert from, <ph id=\"ph1\">`toObject`</ph> is a pointer in which to store the result, and <ph id=\"ph2\">`fromObject`</ph> is the parameter to be converted.","pos":[3134,3316],"source":" In this code, TO is the type to convert to, FROM is the type to convert from, `toObject` is a pointer in which to store the result, and `fromObject` is the parameter to be converted."},{"content":"Replace the comment about initializing with code to initialize the <ph id=\"ph1\">`toPtr`</ph> to the appropriate empty value.","pos":[3326,3432],"source":"Replace the comment about initializing with code to initialize the `toPtr` to the appropriate empty value."},{"content":"For example, if it is a pointer, set it to <ph id=\"ph1\">`NULL`</ph>.","pos":[3433,3483],"source":" For example, if it is a pointer, set it to `NULL`."},{"content":"Replace the comment about conversion logic with code to convert the <ph id=\"ph1\">`from`</ph> parameter into an object of <bpt id=\"p1\">*</bpt>TO<ept id=\"p1\">*</ept> type.","pos":[3493,3606],"source":"Replace the comment about conversion logic with code to convert the `from` parameter into an object of *TO* type."},{"content":"This converted object will be stored in <ph id=\"ph1\">`toPtr`</ph>.","pos":[3607,3655],"source":" This converted object will be stored in `toPtr`."},{"pos":[3665,3763],"content":"Replace the comment about setting <ph id=\"ph1\">`toObject`</ph> with code to set <ph id=\"ph2\">`toObject`</ph> to your converted object.","source":"Replace the comment about setting `toObject` with code to set `toObject` to your converted object."},{"content":"Replace the comment about cleaning up native resources with code to free any memory allocated by <ph id=\"ph1\">`toPtr`</ph>.","pos":[3773,3878],"source":"Replace the comment about cleaning up native resources with code to free any memory allocated by `toPtr`."},{"content":"If <ph id=\"ph1\">`toPtr`</ph> allocated memory by using <ph id=\"ph2\">`new`</ph>, use <ph id=\"ph3\">`delete`</ph> to free the memory.","pos":[3879,3955],"source":" If `toPtr` allocated memory by using `new`, use `delete` to free the memory."},{"content":"Example","pos":[4692,4699]},{"content":"The following example extends the marshaling library with a conversion that does not require a context.","pos":[4703,4806]},{"content":"In this example, the code converts the employee information from a native data type to a managed data type.","pos":[4807,4914]},{"content":"In the previous example, the <ph id=\"ph1\">`marshal_as`</ph> function returns a handle to the converted data.","pos":[6151,6241],"source":"In the previous example, the `marshal_as` function returns a handle to the converted data."},{"content":"This was done in order to prevent creating an additional copy of the data.","pos":[6242,6316]},{"content":"Returning the variable directly would have an unnecessary performance cost associated with it.","pos":[6317,6411]},{"content":"Example","pos":[6529,6536]},{"content":"The following example converts the employee information from a managed data type to a native data type.","pos":[6540,6643]},{"content":"This conversion requires a marshaling context.","pos":[6644,6690]},{"content":"See Also","pos":[9332,9340]},{"content":"Overview of Marshaling in C++","pos":[9345,9374]}],"content":"---\ntitle: \"How to: Extend the Marshaling Library | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"Marshaling Library, extending\"\nms.assetid: 4c4a56d7-1d44-4118-b85f-f9686515e6e9\ncaps.latest.revision: 27\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Extend the Marshaling Library\nThis topic explains how to extend the marshaling library to provide more conversions between data types. Users can extend the marshaling library for any data conversions not currently supported by the library.  \n  \n You can extend the marshaling library in one of two ways - with or without a [marshal_context Class](../dotnet/marshal-context-class.md). Review the [Overview of Marshaling in C++](../dotnet/overview-of-marshaling-in-cpp.md) topic to determine whether a new conversion requires a context.  \n  \n In both cases, you first create a file for new marshaling conversions. You do so to preserve the integrity of the standard marshaling library files. If you want to port a project to another computer or to another programmer, you must copy the new marshaling file together with the rest of the project. In this manner, the user receiving the project will be guaranteed to receive the new conversions and will not have to modify any library files.  \n  \n### To Extend the Marshaling Library with a Conversion that does not Require a Context  \n  \n1.  Create a file to store the new marshaling functions, for example, MyMarshal.h.  \n  \n2.  Include one or more of the marshal library files:  \n  \n    -   marshal.h for base types.  \n  \n    -   marshal_windows.h for windows data types.  \n  \n    -   marshal_cppstd.h for STL data types.  \n  \n    -   marshal_atl.h for ATL data types.  \n  \n3.  Use the code at the end of these steps to write the conversion function. In this code, TO is the type to convert to, FROM is the type to convert from, and `from` is the parameter to be converted.  \n  \n4.  Replace the comment about conversion logic with code to convert the `from` parameter into an object of TO type and return the converted object.  \n  \n```  \nnamespace msclr {  \n   namespace interop {  \n      template<>  \n      inline TO marshal_as<TO, FROM> (const FROM& from) {  \n         // Insert conversion logic here, and return a TO parameter.  \n      }  \n   }  \n}  \n```  \n  \n### To Extend the Marshaling Library with a Conversion that Requires a Context  \n  \n1.  Create a file to store the new marshaling functions, for example, MyMarshal.h  \n  \n2.  Include one or more of the marshal library files:  \n  \n    -   marshal.h for base types.  \n  \n    -   marshal_windows.h for windows data types.  \n  \n    -   marshal_cppstd.h for STL data types.  \n  \n    -   marshal_atl.h for ATL data types.  \n  \n3.  Use the code at the end of these steps to write the conversion function. In this code, TO is the type to convert to, FROM is the type to convert from, `toObject` is a pointer in which to store the result, and `fromObject` is the parameter to be converted.  \n  \n4.  Replace the comment about initializing with code to initialize the `toPtr` to the appropriate empty value. For example, if it is a pointer, set it to `NULL`.  \n  \n5.  Replace the comment about conversion logic with code to convert the `from` parameter into an object of *TO* type. This converted object will be stored in `toPtr`.  \n  \n6.  Replace the comment about setting `toObject` with code to set `toObject` to your converted object.  \n  \n7.  Replace the comment about cleaning up native resources with code to free any memory allocated by `toPtr`. If `toPtr` allocated memory by using `new`, use `delete` to free the memory.  \n  \n```  \nnamespace msclr {  \n   namespace interop {  \n      template<>  \n      ref class context_node<TO, FROM> : public context_node_base  \n      {  \n      private:  \n         TO toPtr;  \n      public:  \n         context_node(TO& toObject, FROM fromObject)  \n         {  \n            // (Step 4) Initialize toPtr to the appropriate empty value.  \n            // (Step 5) Insert conversion logic here.  \n            // (Step 6) Set toObject to the converted parameter.  \n         }  \n         ~context_node()  \n         {  \n            this->!context_node();  \n         }  \n      protected:  \n         !context_node()  \n         {  \n            // (Step 7) Clean up native resources.  \n         }  \n      };  \n   }  \n}   \n```  \n  \n## Example  \n The following example extends the marshaling library with a conversion that does not require a context. In this example, the code converts the employee information from a native data type to a managed data type.  \n  \n```  \n// MyMarshalNoContext.cpp  \n// compile with: /clr  \n#include <msclr/marshal.h>  \n  \nvalue struct ManagedEmp {  \n   System::String^ name;  \n   System::String^ address;  \n   int zipCode;  \n};  \n  \nstruct NativeEmp {  \n   char* name;  \n   char* address;  \n   int zipCode;  \n};  \n  \nnamespace msclr {  \n   namespace interop {  \n      template<>  \n      inline ManagedEmp^ marshal_as<ManagedEmp^, NativeEmp> (const NativeEmp& from) {  \n         ManagedEmp^ toValue = gcnew ManagedEmp;  \n         toValue->name = marshal_as<System::String^>(from.name);  \n         toValue->address = marshal_as<System::String^>(from.address);  \n         toValue->zipCode = from.zipCode;  \n         return toValue;  \n      }  \n   }  \n}  \n  \nusing namespace System;  \nusing namespace msclr::interop;  \n  \nint main() {   \n   NativeEmp employee;  \n  \n   employee.name = \"Jeff Smith\";  \n   employee.address = \"123 Main Street\";  \n   employee.zipCode = 98111;  \n  \n   ManagedEmp^ result = marshal_as<ManagedEmp^>(employee);  \n  \n   Console::WriteLine(\"Managed name: {0}\", result->name);  \n   Console::WriteLine(\"Managed address: {0}\", result->address);  \n   Console::WriteLine(\"Managed zip code: {0}\", result->zipCode);  \n  \n   return 0;  \n}  \n```  \n  \n In the previous example, the `marshal_as` function returns a handle to the converted data. This was done in order to prevent creating an additional copy of the data. Returning the variable directly would have an unnecessary performance cost associated with it.  \n  \n```Output  \nManaged name: Jeff Smith  \nManaged address: 123 Main Street  \nManaged zip code: 98111  \n```  \n  \n## Example  \n The following example converts the employee information from a managed data type to a native data type. This conversion requires a marshaling context.  \n  \n```  \n// MyMarshalContext.cpp  \n// compile with: /clr  \n#include <stdlib.h>  \n#include <string.h>  \n#include <msclr/marshal.h>  \n  \nvalue struct ManagedEmp {  \n   System::String^ name;  \n   System::String^ address;  \n   int zipCode;  \n};  \n  \nstruct NativeEmp {  \n   const char* name;  \n   const char* address;  \n   int zipCode;  \n};  \n  \nnamespace msclr {  \n   namespace interop {  \n      template<>  \n      ref class context_node<NativeEmp*, ManagedEmp^> : public context_node_base  \n      {  \n      private:  \n         NativeEmp* toPtr;  \n         marshal_context context;  \n      public:  \n         context_node(NativeEmp*& toObject, ManagedEmp^ fromObject)  \n         {  \n            // Conversion logic starts here  \n            toPtr = NULL;  \n  \n            const char* nativeName;  \n            const char* nativeAddress;  \n  \n            // Convert the name from String^ to const char*.  \n            System::String^ tempValue = fromObject->name;  \n            nativeName = context.marshal_as<const char*>(tempValue);  \n  \n            // Convert the address from String^ to const char*.  \n            tempValue = fromObject->address;  \n            nativeAddress = context.marshal_as<const char*>(tempValue);  \n  \n            toPtr = new NativeEmp();  \n            toPtr->name = nativeName;  \n            toPtr->address = nativeAddress;  \n            toPtr->zipCode = fromObject->zipCode;  \n  \n            toObject = toPtr;  \n         }  \n         ~context_node()  \n         {  \n            this->!context_node();  \n         }  \n      protected:  \n         !context_node()  \n         {  \n            // When the context is deleted, it will free the memory  \n            // allocated for toPtr->name and toPtr->address, so toPtr  \n            // is the only memory that needs to be freed.  \n            if (toPtr != NULL) {  \n               delete toPtr;  \n               toPtr = NULL;  \n            }  \n         }  \n      };  \n   }  \n}   \n  \nusing namespace System;  \nusing namespace msclr::interop;  \n  \nint main() {  \n   ManagedEmp^ employee = gcnew ManagedEmp();  \n  \n   employee->name = gcnew String(\"Jeff Smith\");  \n   employee->address = gcnew String(\"123 Main Street\");  \n   employee->zipCode = 98111;  \n  \n   marshal_context context;  \n   NativeEmp* result = context.marshal_as<NativeEmp*>(employee);  \n  \n   if (result != NULL) {  \n      printf_s(\"Native name: %s\\nNative address: %s\\nNative zip code: %d\\n\",  \n         result->name, result->address, result->zipCode);  \n   }  \n  \n   return 0;  \n}  \n```  \n  \n```Output  \nNative name: Jeff Smith  \nNative address: 123 Main Street  \nNative zip code: 98111  \n```  \n  \n## See Also  \n [Overview of Marshaling in C++](../dotnet/overview-of-marshaling-in-cpp.md)"}