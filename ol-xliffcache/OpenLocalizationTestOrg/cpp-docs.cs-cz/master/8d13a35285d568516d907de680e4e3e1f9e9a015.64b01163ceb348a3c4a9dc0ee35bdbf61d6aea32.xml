{"nodes":[{"pos":[12,80],"content":"User-Defined Attributes  (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"User-Defined Attributes  (C++ Component Extensions) | Microsoft Docs","pos":[0,68]}]},{"content":"User-Defined Attributes  (C++ Component Extensions)","pos":[664,715]},{"content":"Custom attributes enable you to extend the metadata of an interface, class or structure, method, parameter, or enumeration.","pos":[716,839]},{"content":"All Runtimes","pos":[848,860]},{"content":"All Runtimes support custom attributes.","pos":[864,903]},{"content":"Windows Runtime","pos":[912,927]},{"content":"C++/CX attributes support only properties, but not attribute constructors or methods.","pos":[931,1016]},{"content":"Remarks","pos":[1026,1033]},{"content":"Requirements","pos":[1043,1055]},{"pos":[1059,1083],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Common Language Runtime","pos":[1092,1115]},{"content":"Custom attributes let you extend the metadata of a managed element.","pos":[1119,1186]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Attributes<ept id=\"p1\">](http://msdn.microsoft.com/Library/30386922-1e00-4602-9ebf-526b271a8b87)</ept>.","pos":[1187,1298],"source":" For more information, see [Attributes](http://msdn.microsoft.com/Library/30386922-1e00-4602-9ebf-526b271a8b87)."},{"content":"Remarks","pos":[1308,1315]},{"pos":[1319,1458],"content":"The information and syntax presented in this topic is meant to supersede the information presented in <bpt id=\"p1\">[</bpt>attribute<ept id=\"p1\">](../windows/attribute.md)</ept>.","source":"The information and syntax presented in this topic is meant to supersede the information presented in [attribute](../windows/attribute.md)."},{"content":"You can define a custom attribute by defining a type and making &lt;xref:System.Attribute&gt; a base class for the type and optionally applying the &lt;xref:System.AttributeUsageAttribute&gt; attribute.","pos":[1465,1655],"source":"You can define a custom attribute by defining a type and making <xref:System.Attribute> a base class for the type and optionally applying the <xref:System.AttributeUsageAttribute> attribute."},{"content":"For example, in Microsoft Transaction Server (MTS) 1.0, behavior with respect to transactions, synchronization, load balancing, and so on was specified through custom GUIDs inserted into the type library by using the ODL custom attribute.","pos":[1662,1900]},{"content":"Hence, a client of an MTS server could determine its characteristics by reading the type library.","pos":[1901,1998]},{"content":"In the .NET Framework, the analog of the type library is metadata, and the analog of the ODL custom attribute is custom attributes.","pos":[1999,2130]},{"content":"Also, reading the type library is analogous to using reflection on the types.","pos":[2131,2208]},{"content":"For more information, see,","pos":[2215,2241]},{"content":"Attribute Targets","pos":[2252,2269]},{"content":"Attribute Parameter Types","pos":[2339,2364]},{"pos":[2438,2611],"content":"For information on signing assemblies in Visual C++, see <bpt id=\"p1\">[</bpt>Strong Name Assemblies (Assembly Signing) (C++/CLI)<ept id=\"p1\">](../dotnet/strong-name-assemblies-assembly-signing-cpp-cli.md)</ept>.","source":"For information on signing assemblies in Visual C++, see [Strong Name Assemblies (Assembly Signing) (C++/CLI)](../dotnet/strong-name-assemblies-assembly-signing-cpp-cli.md)."},{"content":"Requirements","pos":[2621,2633]},{"pos":[2637,2662],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[2672,2680]},{"content":"Example","pos":[2686,2693]},{"content":"The following sample shows how to define a custom attribute.","pos":[2702,2762]},{"content":"Example","pos":[3034,3041]},{"content":"The following example illustrates some important features of custom attributes.","pos":[3050,3129]},{"content":"For example, this example shows a common usage of the custom attributes: instantiating a server that can fully describe itself to clients.","pos":[3130,3268]},{"content":"Output","pos":[5396,5402]},{"content":"Example","pos":[5592,5599]},{"content":"The Object^ type replaces the variant data type.","pos":[5608,5656]},{"content":"The following example defines a custom attribute that takes an array of Object^ as parameters.","pos":[5657,5751]},{"content":"Attribute arguments must be compile-time constants; in most cases, they should be constant literals.","pos":[5758,5858]},{"pos":[5865,6012],"content":"See <bpt id=\"p1\">[</bpt>typeid<ept id=\"p1\">](../windows/typeid-cpp-component-extensions.md)</ept> for information on how to return a value of System::Type from a custom attribute block.","source":"See [typeid](../windows/typeid-cpp-component-extensions.md) for information on how to return a value of System::Type from a custom attribute block."},{"content":"Example","pos":[6492,6499]},{"content":"The runtime requires that the public part of the custom attribute class must be serializable.","pos":[6508,6601]},{"content":"When authoring custom attributes, named arguments of your custom attribute are limited to compile-time constants.","pos":[6603,6716]},{"content":"(Think of it as a sequence of bits appended to your class layout in the metadata.)","pos":[6718,6800]},{"content":"See Also","pos":[7113,7121]},{"content":"Component Extensions for Runtime Platforms","pos":[7126,7168]}],"content":"---\ntitle: \"User-Defined Attributes  (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"metadata, extending\"\n  - \"custom attributes, extending metadata\"\nms.assetid: 98b29048-a3ea-4698-8441-f149cdaec9fb\ncaps.latest.revision: 27\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# User-Defined Attributes  (C++ Component Extensions)\nCustom attributes enable you to extend the metadata of an interface, class or structure, method, parameter, or enumeration.  \n  \n## All Runtimes  \n All Runtimes support custom attributes.  \n  \n## Windows Runtime  \n C++/CX attributes support only properties, but not attribute constructors or methods.  \n  \n### Remarks  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## Common Language Runtime  \n Custom attributes let you extend the metadata of a managed element. For more information, see [Attributes](http://msdn.microsoft.com/Library/30386922-1e00-4602-9ebf-526b271a8b87).  \n  \n### Remarks  \n The information and syntax presented in this topic is meant to supersede the information presented in [attribute](../windows/attribute.md).  \n  \n You can define a custom attribute by defining a type and making <xref:System.Attribute> a base class for the type and optionally applying the <xref:System.AttributeUsageAttribute> attribute.  \n  \n For example, in Microsoft Transaction Server (MTS) 1.0, behavior with respect to transactions, synchronization, load balancing, and so on was specified through custom GUIDs inserted into the type library by using the ODL custom attribute. Hence, a client of an MTS server could determine its characteristics by reading the type library. In the .NET Framework, the analog of the type library is metadata, and the analog of the ODL custom attribute is custom attributes. Also, reading the type library is analogous to using reflection on the types.  \n  \n For more information, see,  \n  \n-   [Attribute Targets](../windows/attribute-targets-cpp-component-extensions.md)  \n  \n-   [Attribute Parameter Types](../windows/attribute-parameter-types-cpp-component-extensions.md)  \n  \n For information on signing assemblies in Visual C++, see [Strong Name Assemblies (Assembly Signing) (C++/CLI)](../dotnet/strong-name-assemblies-assembly-signing-cpp-cli.md).  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n The following sample shows how to define a custom attribute.  \n  \n```cpp  \n// user_defined_attributes.cpp  \n// compile with: /clr /c  \nusing namespace System;  \n  \n[AttributeUsage(AttributeTargets::All)]  \nref struct Attr : public Attribute {  \n   Attr(bool i){}  \n   Attr(){}  \n};  \n  \n[Attr]  \nref class MyClass {};  \n```  \n  \n **Example**  \n  \n The following example illustrates some important features of custom attributes. For example, this example shows a common usage of the custom attributes: instantiating a server that can fully describe itself to clients.  \n  \n```cpp  \n// extending_metadata_b.cpp  \n// compile with: /clr  \nusing namespace System;  \nusing namespace System::Reflection;  \n  \npublic enum class Access { Read, Write, Execute };  \n  \n// Defining the Job attribute:  \n[AttributeUsage(AttributeTargets::Class, AllowMultiple=true )]  \npublic ref class Job : Attribute {  \npublic:  \n   property int Priority {  \n      void set( int value ) { m_Priority = value; }  \n      int get() { return m_Priority; }  \n   }  \n  \n   // You can overload constructors to specify Job attribute in different ways  \n   Job() { m_Access = Access::Read; }  \n   Job( Access a ) { m_Access = a; }  \n   Access m_Access;  \n  \nprotected:  \n   int m_Priority;  \n};  \n  \ninterface struct IService {  \n   void Run();  \n};  \n  \n   // Using the Job attribute:  \n   // Here we specify that QueryService is to be read only with a priority of 2.  \n   // To prevent namespace collisions, all custom attributes implicitly   \n   // end with \"Attribute\".   \n  \n[Job( Access::Read, Priority=2 )]  \nref struct QueryService : public IService {  \n   virtual void Run() {}  \n};  \n  \n// Because we said AllowMultiple=true, we can add multiple attributes   \n[Job(Access::Read, Priority=1)]  \n[Job(Access::Write, Priority=3)]  \nref struct StatsGenerator : public IService {  \n   virtual void Run( ) {}  \n};  \n  \nint main() {  \n   IService ^ pIS;  \n   QueryService ^ pQS = gcnew QueryService;  \n   StatsGenerator ^ pSG = gcnew StatsGenerator;  \n  \n   //  use QueryService  \n   pIS = safe_cast<IService ^>( pQS );  \n  \n   // use StatsGenerator  \n   pIS = safe_cast<IService ^>( pSG );  \n  \n   // Reflection  \n   MemberInfo ^ pMI = pIS->GetType();  \n   array <Object ^ > ^ pObjs = pMI->GetCustomAttributes(false);  \n  \n   // We can now quickly and easily view custom attributes for an   \n   // Object through Reflection */  \n   for( int i = 0; i < pObjs->Length; i++ ) {  \n      Console::Write(\"Service Priority = \");  \n      Console::WriteLine(static_cast<Job^>(pObjs[i])->Priority);  \n      Console::Write(\"Service Access = \");  \n      Console::WriteLine(static_cast<Job^>(pObjs[i])->m_Access);  \n   }  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nService Priority = 0  \n  \nService Access = Write  \n  \nService Priority = 3  \n  \nService Access = Write  \n  \nService Priority = 1  \n  \nService Access = Read  \n```  \n  \n **Example**  \n  \n The Object^ type replaces the variant data type. The following example defines a custom attribute that takes an array of Object^ as parameters.  \n  \n Attribute arguments must be compile-time constants; in most cases, they should be constant literals.  \n  \n See [typeid](../windows/typeid-cpp-component-extensions.md) for information on how to return a value of System::Type from a custom attribute block.  \n  \n```cpp  \n// extending_metadata_e.cpp  \n// compile with: /clr /c  \nusing namespace System;  \n[AttributeUsage(AttributeTargets::Class | AttributeTargets::Method)]  \npublic ref class AnotherAttr : public Attribute {  \npublic:  \n   AnotherAttr(array<Object^>^) {}  \n   array<Object^>^ var1;  \n};  \n  \n// applying the attribute  \n[ AnotherAttr( gcnew array<Object ^> { 3.14159, \"pi\" }, var1 = gcnew array<Object ^> { \"a\", \"b\" } ) ]  \npublic ref class SomeClass {};  \n```  \n  \n **Example**  \n  \n The runtime requires that the public part of the custom attribute class must be serializable.  When authoring custom attributes, named arguments of your custom attribute are limited to compile-time constants.  (Think of it as a sequence of bits appended to your class layout in the metadata.)  \n  \n```cpp  \n// extending_metadata_f.cpp  \n// compile with: /clr /c  \nusing namespace System;  \nref struct abc {};  \n  \n[AttributeUsage( AttributeTargets::All )]  \nref struct A : Attribute {  \n   A( Type^ ) {}  \n   A( String ^ ) {}  \n   A( int ) {}  \n};  \n  \n[A( abc::typeid )]  \nref struct B {};  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}