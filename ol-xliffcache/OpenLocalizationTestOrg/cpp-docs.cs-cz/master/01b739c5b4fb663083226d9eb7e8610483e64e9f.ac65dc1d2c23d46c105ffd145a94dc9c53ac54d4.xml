{"nodes":[{"pos":[12,49],"content":"Reflection (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Reflection (C++-CLI) | Microsoft Docs","pos":[0,37]}]},{"content":"Reflection (C++/CLI)","pos":[765,785]},{"content":"Reflection allows known data types to be inspected at runtime.","pos":[786,848]},{"content":"Reflection allows the enumeration of data types in a given assembly, and the members of a given class or value type can be discovered.","pos":[849,983]},{"content":"This is true regardless of whether the type was known or referenced at compile time.","pos":[984,1068]},{"content":"This makes reflection a useful feature for development and code management tools.","pos":[1069,1150]},{"content":"Note that the assembly name provided is the strong name (see <bpt id=\"p1\">[</bpt>Strong-Named Assemblies<ept id=\"p1\">](http://msdn.microsoft.com/Library/ffbf6d9e-4a88-4a8a-9645-4ce0ee1ee5f9)</ept>), which includes the assembly version, culture, and signing information.","pos":[1157,1388],"source":"Note that the assembly name provided is the strong name (see [Strong-Named Assemblies](http://msdn.microsoft.com/Library/ffbf6d9e-4a88-4a8a-9645-4ce0ee1ee5f9)), which includes the assembly version, culture, and signing information."},{"content":"Note also that the name of the namespace in which the data type is defined can be retrieved, along with the name of the base class.","pos":[1389,1520]},{"content":"The most common way to access reflection features is through the &lt;xref:System.Object.GetType%2A&gt; method.","pos":[1527,1631],"source":"The most common way to access reflection features is through the <xref:System.Object.GetType%2A> method."},{"content":"This method is provided by <bpt id=\"p1\">[</bpt>System::Object<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/system.object.aspx)</ept>, from which all garbage-collected classes derive.","pos":[1632,1786],"source":" This method is provided by [System::Object](https://msdn.microsoft.com/en-us/library/system.object.aspx), from which all garbage-collected classes derive."},{"content":"Reflection on an .exe built with the Visual C++ compiler is allowed if the .exe is built with the <bpt id=\"p1\">**</bpt>/clr:pure<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/clr:safe<ept id=\"p2\">**</ept> compiler options.","pos":[1793,1939],"source":"Reflection on an .exe built with the Visual C++ compiler is allowed if the .exe is built with the **/clr:pure** or **/clr:safe** compiler options."},{"content":"See <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept> for more information.","pos":[1940,2073],"source":" See [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md) for more information."},{"content":"Topics in this section:","pos":[2080,2103]},{"content":"How to: Implement a Plug-In Component Architecture using Reflection (C++/CLI)","pos":[2114,2191]},{"content":"How to: Enumerate Data Types in Assemblies using Reflection (C++/CLI)","pos":[2292,2361]},{"pos":[2450,2570],"content":"For more information, see <bpt id=\"p1\">[</bpt>System.Reflection Namespace<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/system.reflection.aspx)</ept>","source":"For more information, see [System.Reflection Namespace](https://msdn.microsoft.com/en-us/library/system.reflection.aspx)"},{"content":"Example","pos":[2579,2586]},{"content":"The <ph id=\"ph1\">`GetType`</ph> method returns a pointer to a &lt;xref:System.Type&gt; class object, which describes the type upon when the object is based.","pos":[2590,2722],"source":"The `GetType` method returns a pointer to a <xref:System.Type> class object, which describes the type upon when the object is based."},{"content":"(The <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> object does not contain any instance-specific information.) One such item is the full name of the type, which can be displayed as follows:","pos":[2723,2875],"source":" (The **Type** object does not contain any instance-specific information.) One such item is the full name of the type, which can be displayed as follows:"},{"content":"Note that the type name includes the full scope in which the type is defined, including the namespace, and that it is displayed in .NET syntax, with a dot as the scope resolution operator.","pos":[2882,3070]},{"content":"Example","pos":[3377,3384]},{"pos":[3388,3478],"content":"Value types can be used with the <ph id=\"ph1\">`GetType`</ph> function as well, but they must be boxed first.","source":"Value types can be used with the `GetType` function as well, but they must be boxed first."},{"content":"Example","pos":[3750,3757]},{"content":"As with the <ph id=\"ph1\">`GetType`</ph> method, the <bpt id=\"p1\">[</bpt>typeid<ept id=\"p1\">](../windows/typeid-cpp-component-extensions.md)</ept> operator returns a pointer to a <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept> object, so this code indicates the type name <bpt id=\"p3\">**</bpt>System.Int32<ept id=\"p3\">**</ept>.","pos":[3761,3954],"source":"As with the `GetType` method, the [typeid](../windows/typeid-cpp-component-extensions.md) operator returns a pointer to a **Type** object, so this code indicates the type name **System.Int32**."},{"content":"Displaying type names is the most basic feature of reflection, but a potentially more useful technique is to inspect or discover the valid values for enumerated types.","pos":[3955,4122]},{"content":"This can be done by using the static <bpt id=\"p1\">**</bpt>Enum::GetNames<ept id=\"p1\">**</ept> function, which returns an array of strings, each containing an enumeration value in text form.","pos":[4123,4274],"source":" This can be done by using the static **Enum::GetNames** function, which returns an array of strings, each containing an enumeration value in text form."},{"content":"The following sample retrieves an array of strings that describes the value enumeration values for the <bpt id=\"p1\">**</bpt>Options<ept id=\"p1\">**</ept> (CLR) enum and displays them in a loop.","pos":[4276,4430],"source":"  The following sample retrieves an array of strings that describes the value enumeration values for the **Options** (CLR) enum and displays them in a loop."},{"pos":[4437,4615],"content":"If a fourth option is added to the <bpt id=\"p1\">**</bpt>Options<ept id=\"p1\">**</ept> enumeration, this code will report the new option without recompilation, even if the enumeration is defined in a separate assembly.","source":"If a fourth option is added to the **Options** enumeration, this code will report the new option without recompilation, even if the enumeration is defined in a separate assembly."},{"content":"Example","pos":[5320,5327]},{"content":"The <ph id=\"ph1\">`GetType`</ph> object supports a number of members and properties that can be used to examine a type.","pos":[5331,5431],"source":"The `GetType` object supports a number of members and properties that can be used to examine a type."},{"content":"This code retrieves and displays some of this information:","pos":[5432,5490]},{"content":"Example","pos":[6425,6432]},{"content":"Reflection also allows the enumeration of types within an assembly and the members within classes.","pos":[6436,6534]},{"content":"To demonstrate this feature, define a simple class:","pos":[6535,6586]},{"content":"Example","pos":[7005,7012]},{"content":"If the code above is compiled into a DLL called vcpp_reflection_6.dll, you can then use reflection to inspect the contents of this assembly.","pos":[7016,7156]},{"content":"This involves using the static reflection API function <bpt id=\"p1\">[</bpt>Assembly::Load<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/system.reflection.assembly.load.aspx)</ept> to load the assembly.","pos":[7157,7329],"source":" This involves using the static reflection API function [Assembly::Load](https://msdn.microsoft.com/en-us/library/system.reflection.assembly.load.aspx) to load the assembly."},{"content":"This function returns the address of an <bpt id=\"p1\">**</bpt>Assembly<ept id=\"p1\">**</ept> object that can then be queried about the modules and types within.","pos":[7330,7450],"source":" This function returns the address of an **Assembly** object that can then be queried about the modules and types within."},{"content":"Once the reflection system successfully loads the assembly, an array of <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> objects is retrieved with the <bpt id=\"p2\">[</bpt>Assembly::GetTypes<ept id=\"p2\">](https://msdn.microsoft.com/en-us/library/system.reflection.assembly.gettypes.aspx)</ept> function.","pos":[7457,7681],"source":"Once the reflection system successfully loads the assembly, an array of **Type** objects is retrieved with the [Assembly::GetTypes](https://msdn.microsoft.com/en-us/library/system.reflection.assembly.gettypes.aspx) function."},{"content":"Each array element contains information about a different type, although in this case, only one class is defined.","pos":[7682,7795]},{"content":"Using a loop, each <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> in this array is queried about the type members using the <bpt id=\"p2\">**</bpt>Type::GetMembers<ept id=\"p2\">**</ept> function.","pos":[7796,7912],"source":" Using a loop, each **Type** in this array is queried about the type members using the **Type::GetMembers** function."},{"content":"This function returns an array of <bpt id=\"p1\">**</bpt>MethodInfo<ept id=\"p1\">**</ept> objects, each object containing information about the member function, data member, or property in the type.","pos":[7913,8070],"source":" This function returns an array of **MethodInfo** objects, each object containing information about the member function, data member, or property in the type."},{"content":"Note that the list of methods includes the functions explicitly defined in <bpt id=\"p1\">**</bpt>TestClass<ept id=\"p1\">**</ept> and the functions implicitly inherited from the <bpt id=\"p2\">**</bpt>System::Object<ept id=\"p2\">**</ept> class.","pos":[8077,8239],"source":"Note that the list of methods includes the functions explicitly defined in **TestClass** and the functions implicitly inherited from the **System::Object** class."},{"content":"As part of being described in .NET rather than in Visual C++ syntax, properties appear as the underlying data member accessed by the get/set functions.","pos":[8240,8391]},{"content":"The get/set functions appear in this list as regular methods.","pos":[8392,8453]},{"content":"Reflection is supported through the common language runtime, not by the Visual C++ compiler.","pos":[8454,8546]},{"content":"Although you used this code to inspect an assembly that you defined, you can also use this code to inspect .NET assemblies.","pos":[8553,8676]},{"content":"For example, if you change TestAssembly to mscorlib, then you will see a listing of every type and method defined in mscorlib.dll.","pos":[8677,8807]},{"content":"See Also","pos":[10262,10270]},{"content":".NET Programming with C++/CLI (Visual C++)","pos":[10275,10317]}],"content":"---\ntitle: \"Reflection (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"typeid keyword [C++]\"\n  - \"reflection [C++}, about reflection\"\n  - \"metadata, reflection\"\n  - \"GetType method\"\n  - \".NET Framework [C++], reflection\"\n  - \"data types [C++], reflection\"\n  - \"reflection [C++}\"\nms.assetid: 46b6ff4a-e441-4022-8892-78e69422f230\ncaps.latest.revision: 24\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Reflection (C++/CLI)\nReflection allows known data types to be inspected at runtime. Reflection allows the enumeration of data types in a given assembly, and the members of a given class or value type can be discovered. This is true regardless of whether the type was known or referenced at compile time. This makes reflection a useful feature for development and code management tools.  \n  \n Note that the assembly name provided is the strong name (see [Strong-Named Assemblies](http://msdn.microsoft.com/Library/ffbf6d9e-4a88-4a8a-9645-4ce0ee1ee5f9)), which includes the assembly version, culture, and signing information. Note also that the name of the namespace in which the data type is defined can be retrieved, along with the name of the base class.  \n  \n The most common way to access reflection features is through the <xref:System.Object.GetType%2A> method. This method is provided by [System::Object](https://msdn.microsoft.com/en-us/library/system.object.aspx), from which all garbage-collected classes derive.  \n  \n Reflection on an .exe built with the Visual C++ compiler is allowed if the .exe is built with the **/clr:pure** or **/clr:safe** compiler options. See [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md) for more information.  \n  \n Topics in this section:  \n  \n-   [How to: Implement a Plug-In Component Architecture using Reflection (C++/CLI)](../dotnet/how-to-implement-a-plug-in-component-architecture-using-reflection-cpp-cli.md)  \n  \n-   [How to: Enumerate Data Types in Assemblies using Reflection (C++/CLI)](../dotnet/how-to-enumerate-data-types-in-assemblies-using-reflection-cpp-cli.md)  \n  \n For more information, see [System.Reflection Namespace](https://msdn.microsoft.com/en-us/library/system.reflection.aspx)  \n  \n## Example  \n The `GetType` method returns a pointer to a <xref:System.Type> class object, which describes the type upon when the object is based. (The **Type** object does not contain any instance-specific information.) One such item is the full name of the type, which can be displayed as follows:  \n  \n Note that the type name includes the full scope in which the type is defined, including the namespace, and that it is displayed in .NET syntax, with a dot as the scope resolution operator.  \n  \n```  \n// vcpp_reflection.cpp  \n// compile with: /clr  \nusing namespace System;  \nint main() {  \n   String ^ s = \"sample string\";  \n   Console::WriteLine(\"full type name of '{0}' is '{1}'\", s, s->GetType());  \n}  \n```  \n  \n```Output  \nfull type name of 'sample string' is 'System.String'  \n```  \n  \n## Example  \n Value types can be used with the `GetType` function as well, but they must be boxed first.  \n  \n```  \n// vcpp_reflection_2.cpp  \n// compile with: /clr  \nusing namespace System;  \nint main() {  \n   Int32 i = 100;   \n   Object ^ o = i;  \n   Console::WriteLine(\"type of i = '{0}'\", o->GetType());  \n}  \n```  \n  \n```Output  \ntype of i = 'System.Int32'  \n```  \n  \n## Example  \n As with the `GetType` method, the [typeid](../windows/typeid-cpp-component-extensions.md) operator returns a pointer to a **Type** object, so this code indicates the type name **System.Int32**. Displaying type names is the most basic feature of reflection, but a potentially more useful technique is to inspect or discover the valid values for enumerated types. This can be done by using the static **Enum::GetNames** function, which returns an array of strings, each containing an enumeration value in text form.  The following sample retrieves an array of strings that describes the value enumeration values for the **Options** (CLR) enum and displays them in a loop.  \n  \n If a fourth option is added to the **Options** enumeration, this code will report the new option without recompilation, even if the enumeration is defined in a separate assembly.  \n  \n```  \n// vcpp_reflection_3.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nenum class Options {   // not a native enum  \n   Option1, Option2, Option3  \n};  \n  \nint main() {  \n   array<String^>^ names = Enum::GetNames(Options::typeid);  \n  \n   Console::WriteLine(\"there are {0} options in enum '{1}'\",   \n               names->Length, Options::typeid);  \n  \n   for (int i = 0 ; i < names->Length ; i++)  \n      Console::WriteLine(\"{0}: {1}\", i, names[i]);  \n  \n   Options o = Options::Option2;  \n   Console::WriteLine(\"value of 'o' is {0}\", o);  \n}  \n```  \n  \n```Output  \nthere are 3 options in enum 'Options'  \n0: Option1  \n1: Option2  \n2: Option3  \nvalue of 'o' is Option2  \n```  \n  \n## Example  \n The `GetType` object supports a number of members and properties that can be used to examine a type. This code retrieves and displays some of this information:  \n  \n```  \n// vcpp_reflection_4.cpp  \n// compile with: /clr  \nusing namespace System;  \nint main() {  \n   Console::WriteLine(\"type information for 'String':\");  \n   Type ^ t = String::typeid;  \n  \n   String ^ assemblyName = t->Assembly->FullName;  \n   Console::WriteLine(\"assembly name: {0}\", assemblyName);  \n  \n   String ^ nameSpace = t->Namespace;  \n   Console::WriteLine(\"namespace: {0}\", nameSpace);  \n  \n   String ^ baseType = t->BaseType->FullName;  \n   Console::WriteLine(\"base type: {0}\", baseType);  \n  \n   bool isArray = t->IsArray;  \n   Console::WriteLine(\"is array: {0}\", isArray);  \n  \n   bool isClass = t->IsClass;  \n   Console::WriteLine(\"is class: {0}\", isClass);  \n}  \n```  \n  \n```Output  \ntype information for 'String':  \nassembly name: mscorlib, Version=1.0.5000.0, Culture=neutral,   \nPublicKeyToken=b77a5c561934e089  \nnamespace: System  \nbase type: System.Object  \nis array: False  \nis class: True  \n```  \n  \n## Example  \n Reflection also allows the enumeration of types within an assembly and the members within classes. To demonstrate this feature, define a simple class:  \n  \n```  \n// vcpp_reflection_5.cpp  \n// compile with: /clr /LD  \nusing namespace System;  \npublic ref class TestClass {  \n   int m_i;  \npublic:  \n   TestClass() {}  \n   void SimpleTestMember1() {}  \n   String ^ SimpleMember2(String ^ s) { return s; }   \n   int TestMember(int i) { return i; }  \n   property int Member {  \n      int get() { return m_i; }  \n      void set(int i) { m_i = i; }  \n   }  \n};  \n```  \n  \n## Example  \n If the code above is compiled into a DLL called vcpp_reflection_6.dll, you can then use reflection to inspect the contents of this assembly. This involves using the static reflection API function [Assembly::Load](https://msdn.microsoft.com/en-us/library/system.reflection.assembly.load.aspx) to load the assembly. This function returns the address of an **Assembly** object that can then be queried about the modules and types within.  \n  \n Once the reflection system successfully loads the assembly, an array of **Type** objects is retrieved with the [Assembly::GetTypes](https://msdn.microsoft.com/en-us/library/system.reflection.assembly.gettypes.aspx) function. Each array element contains information about a different type, although in this case, only one class is defined. Using a loop, each **Type** in this array is queried about the type members using the **Type::GetMembers** function. This function returns an array of **MethodInfo** objects, each object containing information about the member function, data member, or property in the type.  \n  \n Note that the list of methods includes the functions explicitly defined in **TestClass** and the functions implicitly inherited from the **System::Object** class. As part of being described in .NET rather than in Visual C++ syntax, properties appear as the underlying data member accessed by the get/set functions. The get/set functions appear in this list as regular methods. Reflection is supported through the common language runtime, not by the Visual C++ compiler.  \n  \n Although you used this code to inspect an assembly that you defined, you can also use this code to inspect .NET assemblies. For example, if you change TestAssembly to mscorlib, then you will see a listing of every type and method defined in mscorlib.dll.  \n  \n```  \n// vcpp_reflection_6.cpp  \n// compile with: /clr  \nusing namespace System;  \nusing namespace System::IO;  \nusing namespace System::Reflection;  \nint main() {  \n   Assembly ^ a = nullptr;  \n   try {  \n      // load assembly -- do not use file extension  \n      // will look for .dll extension first  \n      // then .exe with the filename  \n      a = Assembly::Load(\"vcpp_reflection_5\");  \n   }  \n   catch (FileNotFoundException ^ e) {  \n      Console::WriteLine(e->Message);  \n      return -1;  \n   }  \n  \n   Console::WriteLine(\"assembly info:\");  \n   Console::WriteLine(a->FullName);  \n   array<Type^>^ typeArray = a->GetTypes();  \n  \n   Console::WriteLine(\"type info ({0} types):\", typeArray->Length);  \n  \n   int totalTypes = 0;  \n   int totalMembers = 0;  \n   for (int i = 0 ; i < typeArray->Length ; i++) {  \n      // retrieve array of member descriptions  \n      array<MemberInfo^>^ member = typeArray[i]->GetMembers();  \n  \n      Console::WriteLine(\"  members of {0} ({1} members):\",   \n      typeArray[i]->FullName, member->Length);  \n      for (int j = 0 ; j < member->Length ; j++) {  \n         Console::Write(\"       ({0})\",   \n         member[j]->MemberType.ToString() );  \n         Console::Write(\"{0}  \", member[j]);  \n         Console::WriteLine(\"\");  \n         totalMembers++;  \n      }  \n      totalTypes++;  \n   }  \n   Console::WriteLine(\"{0} total types, {1} total members\",  \n   totalTypes, totalMembers);  \n}  \n```  \n  \n## See Also  \n [.NET Programming with C++/CLI (Visual C++)](../dotnet/dotnet-programming-with-cpp-cli-visual-cpp.md)"}