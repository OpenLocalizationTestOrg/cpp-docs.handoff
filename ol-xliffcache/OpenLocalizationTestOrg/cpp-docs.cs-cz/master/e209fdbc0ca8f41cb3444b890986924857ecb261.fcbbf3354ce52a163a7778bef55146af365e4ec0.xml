{"nodes":[{"pos":[12,55],"content":"Address-of Operator: &amp; | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Address-of Operator: <ph id=\"ph1\">&amp;amp;</ph> | Microsoft Docs","pos":[0,43],"source":"Address-of Operator: &amp; | Microsoft Docs"}]},{"content":"Address-of Operator:","pos":[684,704]},{"content":"Syntax","pos":[714,720]},{"content":"Remarks","pos":[767,774]},{"content":"The unary address-of operator (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p1\">**</ept>) takes the address of its operand.","pos":[778,849],"source":"The unary address-of operator (**&**) takes the address of its operand."},{"content":"The operand of the address-of operator can be either a function designator or an l-value that designates an object that is not a bit field and is not declared with the <bpt id=\"p1\">**</bpt>register<ept id=\"p1\">**</ept> storage-class specifier.","pos":[850,1055],"source":" The operand of the address-of operator can be either a function designator or an l-value that designates an object that is not a bit field and is not declared with the **register** storage-class specifier."},{"content":"The address-of operator can only be applied to variables with fundamental, structure, class, or union types that are declared at the file-scope level, or to subscripted array references.","pos":[1062,1248]},{"content":"In these expressions, a constant expression that does not include the address-of operator can be added to or subtracted from the address-of expression.","pos":[1249,1400]},{"content":"When applied to functions or l-values, the result of the expression is a pointer type (an r-value) derived from the type of the operand.","pos":[1407,1543]},{"content":"For example, if the operand is of type <ph id=\"ph1\">`char`</ph>, the result of the expression is of type pointer to <ph id=\"ph2\">`char`</ph>.","pos":[1544,1649],"source":" For example, if the operand is of type `char`, the result of the expression is of type pointer to `char`."},{"content":"The address-of operator, applied to <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph> objects, evaluates to <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> <ph id=\"ph2\">`type`</ph> <bpt id=\"p3\">**</bpt><ph id=\"ph3\">\\*</ph><ept id=\"p3\">**</ept> or <ph id=\"ph4\">`volatile`</ph> <ph id=\"ph5\">`type`</ph> <bpt id=\"p4\">**</bpt><ph id=\"ph6\">\\*</ph><ept id=\"p4\">**</ept>, where <ph id=\"ph7\">`type`</ph> is the type of the original object.","pos":[1650,1833],"source":" The address-of operator, applied to **const** or `volatile` objects, evaluates to **const** `type` **\\*** or `volatile` `type` **\\***, where `type` is the type of the original object."},{"content":"When the address-of operator is applied to a <bpt id=\"p1\">[</bpt>qualified name<ept id=\"p1\">](http://msdn.microsoft.com/en-us/3fefb16d-8120-4627-8b3f-3d90fbdcd1df)</ept>, the result depends on whether the <bpt id=\"p2\">*</bpt>qualified-name<ept id=\"p2\">*</ept> specifies a static member.","pos":[1840,2050],"source":"When the address-of operator is applied to a [qualified name](http://msdn.microsoft.com/en-us/3fefb16d-8120-4627-8b3f-3d90fbdcd1df), the result depends on whether the *qualified-name* specifies a static member."},{"content":"If so, the result is a pointer to the type specified in the declaration of the member.","pos":[2051,2137]},{"content":"If the member is not static, the result is a pointer to the member <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> of the class indicated by <bpt id=\"p2\">*</bpt>qualified-class-name<ept id=\"p2\">*</ept>.","pos":[2138,2261],"source":" If the member is not static, the result is a pointer to the member *name* of the class indicated by *qualified-class-name*."},{"content":"(See <bpt id=\"p1\">[</bpt>Primary Expressions<ept id=\"p1\">](../cpp/primary-expressions.md)</ept> for more about <bpt id=\"p2\">*</bpt>qualified-class-name<ept id=\"p2\">*</ept>.) The following code fragment shows how the result differs, depending on whether the member is static:","pos":[2262,2460],"source":" (See [Primary Expressions](../cpp/primary-expressions.md) for more about *qualified-class-name*.) The following code fragment shows how the result differs, depending on whether the member is static:"},{"pos":[2815,2951],"content":"In this example, the expression <ph id=\"ph1\">`&amp;PTM::fValue`</ph> yields type <ph id=\"ph2\">`float *`</ph> instead of type <ph id=\"ph3\">`float PTM::*`</ph> because <ph id=\"ph4\">`fValue`</ph> is a static member.","source":"In this example, the expression `&PTM::fValue` yields type `float *` instead of type `float PTM::*` because `fValue` is a static member."},{"content":"The address of an overloaded function can be taken only when it is clear which version of the function is being referenced.","pos":[2958,3081]},{"content":"See <bpt id=\"p1\">[</bpt>Function Overloading<ept id=\"p1\">](function-overloading.md)</ept> for information about how to obtain the address of a particular overloaded function.","pos":[3082,3218],"source":" See [Function Overloading](function-overloading.md) for information about how to obtain the address of a particular overloaded function."},{"content":"Applying the address-of operator to a reference type gives the same result as applying the operator to the object to which the reference is bound.","pos":[3225,3371]},{"content":"For example:","pos":[3372,3384]},{"content":"Example","pos":[3393,3400]},{"content":"Output","pos":[3774,3780]},{"content":"The following example uses the address-of operator to pass a pointer argument to a function:","pos":[3818,3910]},{"content":"Output","pos":[4291,4297]},{"content":"See Also","pos":[4326,4334]},{"content":"Expressions with Unary Operators","pos":[4339,4371]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[4422,4474]},{"content":"Lvalue Reference Declarator: &amp;","pos":[4544,4574],"source":"Lvalue Reference Declarator: &"},{"content":"Indirection and Address-of Operators","pos":[4624,4660]}],"content":"---\ntitle: \"Address-of Operator: &amp; | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"address-of\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"address-of operator (&)\"\n  - \"& operator\"\n  - \"& operator, address-of operator\"\nms.assetid: 2828221a-15f6-4acc-87fe-25e34feebb88\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Address-of Operator: &amp;\n## Syntax  \n  \n```  \n  \n& cast-expression  \n```  \n  \n## Remarks  \n The unary address-of operator (**&**) takes the address of its operand. The operand of the address-of operator can be either a function designator or an l-value that designates an object that is not a bit field and is not declared with the **register** storage-class specifier.  \n  \n The address-of operator can only be applied to variables with fundamental, structure, class, or union types that are declared at the file-scope level, or to subscripted array references. In these expressions, a constant expression that does not include the address-of operator can be added to or subtracted from the address-of expression.  \n  \n When applied to functions or l-values, the result of the expression is a pointer type (an r-value) derived from the type of the operand. For example, if the operand is of type `char`, the result of the expression is of type pointer to `char`. The address-of operator, applied to **const** or `volatile` objects, evaluates to **const** `type` **\\*** or `volatile` `type` **\\***, where `type` is the type of the original object.  \n  \n When the address-of operator is applied to a [qualified name](http://msdn.microsoft.com/en-us/3fefb16d-8120-4627-8b3f-3d90fbdcd1df), the result depends on whether the *qualified-name* specifies a static member. If so, the result is a pointer to the type specified in the declaration of the member. If the member is not static, the result is a pointer to the member *name* of the class indicated by *qualified-class-name*. (See [Primary Expressions](../cpp/primary-expressions.md) for more about *qualified-class-name*.) The following code fragment shows how the result differs, depending on whether the member is static:  \n  \n```  \n// expre_Address_Of_Operator.cpp  \n// C2440 expected  \nclass PTM {  \npublic:  \n           int   iValue;  \n    static float fValue;  \n};  \n  \nint main() {  \n   int   PTM::*piValue = &PTM::iValue;  // OK: non-static  \n   float PTM::*pfValue = &PTM::fValue;  // C2440 error: static  \n   float *spfValue     = &PTM::fValue;  // OK  \n}  \n```  \n  \n In this example, the expression `&PTM::fValue` yields type `float *` instead of type `float PTM::*` because `fValue` is a static member.  \n  \n The address of an overloaded function can be taken only when it is clear which version of the function is being referenced. See [Function Overloading](function-overloading.md) for information about how to obtain the address of a particular overloaded function.  \n  \n Applying the address-of operator to a reference type gives the same result as applying the operator to the object to which the reference is bound. For example:  \n  \n## Example  \n  \n```  \n// expre_Address_Of_Operator2.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \nint main() {  \n   double d;        // Define an object of type double.  \n   double& rd = d;  // Define a reference to the object.  \n  \n   // Obtain and compare their addresses  \n   if( &d == &rd )  \n      cout << \"&d equals &rd\" << endl;  \n}  \n```  \n  \n## Output  \n  \n```  \n&d equals &rd  \n```  \n  \n The following example uses the address-of operator to pass a pointer argument to a function:  \n  \n```  \n// expre_Address_Of_Operator3.cpp  \n// compile with: /EHsc  \n// Demonstrate address-of operator &  \n  \n#include <iostream>  \nusing namespace std;  \n  \n// Function argument is pointer to type int  \nint square( int *n ) {  \n   return (*n) * (*n);  \n}  \n  \nint main() {  \n   int mynum = 5;  \n   cout << square( &mynum ) << endl;   // pass address of int  \n}  \n```  \n  \n## Output  \n  \n```  \n25  \n```  \n  \n## See Also  \n [Expressions with Unary Operators](../cpp/expressions-with-unary-operators.md)   \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   \n [Lvalue Reference Declarator: &](../cpp/lvalue-reference-declarator-amp.md)   \n [Indirection and Address-of Operators](../c-language/indirection-and-address-of-operators.md)"}