{"nodes":[{"pos":[12,83],"content":"Exceptions: Changes to Exception Macros in Version 3.0 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Exceptions: Changes to Exception Macros in Version 3.0 | Microsoft Docs","pos":[0,71]}]},{"content":"Exceptions: Changes to Exception Macros in Version 3.0","pos":[713,767]},{"content":"This is an advanced topic.","pos":[768,794]},{"content":"In MFC version 3.0 and later, the exception-handling macros have been changed to use C++ exceptions.","pos":[801,901]},{"content":"This article tells how those changes can affect the behavior of existing code that uses the macros.","pos":[902,1001]},{"content":"This article covers the following topics:","pos":[1008,1049]},{"content":"Exception types and the CATCH macro","pos":[1060,1095]},{"content":"Re-throwing exceptions","pos":[1151,1173]},{"pos":[1275,1310],"content":"Exception Types and the CATCH Macro"},{"content":"In earlier versions of MFC, the <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> macro used MFC run-time type information to determine an exception's type; the exception's type is determined, in other words, at the catch site.","pos":[1314,1501],"source":"In earlier versions of MFC, the **CATCH** macro used MFC run-time type information to determine an exception's type; the exception's type is determined, in other words, at the catch site."},{"content":"With C++ exceptions, however, the exception's type is always determined at the throw site by the type of the exception object that is thrown.","pos":[1502,1643]},{"content":"This will cause incompatibilities in the rare case where the type of the pointer to the thrown object differs from the type of the thrown object.","pos":[1644,1789]},{"content":"The following example illustrates the consequence of this difference between MFC version 3.0 and earlier versions:","pos":[1796,1910]},{"pos":[1928,1947],"content":"NVC_MFCExceptions#1"},{"content":"This code behaves differently in version 3.0 because control always passes to the first <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> block with a matching exception-declaration.","pos":[2040,2182],"source":"This code behaves differently in version 3.0 because control always passes to the first **catch** block with a matching exception-declaration."},{"content":"The result of the throw expression","pos":[2183,2217]},{"pos":[2235,2255],"content":"NVC_MFCExceptions#19"},{"content":"is thrown as a <bpt id=\"p1\">**</bpt>CException<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept>, even though it is constructed as a <bpt id=\"p2\">**</bpt>CCustomException<ept id=\"p2\">**</ept>.","pos":[2348,2437],"source":"is thrown as a **CException\\***, even though it is constructed as a **CCustomException**."},{"content":"The <bpt id=\"p1\">**</bpt>CATCH<ept id=\"p1\">**</ept> macro in MFC versions 2.5 and earlier uses <ph id=\"ph1\">`CObject::IsKindOf`</ph> to test the type at run time.","pos":[2438,2544],"source":" The **CATCH** macro in MFC versions 2.5 and earlier uses `CObject::IsKindOf` to test the type at run time."},{"content":"Because the expression","pos":[2545,2567]},{"pos":[2585,2605],"content":"NVC_MFCExceptions#20"},{"content":"is true, the first catch block catches the exception.","pos":[2698,2751]},{"content":"In version 3.0, which uses C++ exceptions to implement many of the exception-handling macros, the second catch block matches the thrown <ph id=\"ph1\">`CException`</ph>.","pos":[2752,2901],"source":" In version 3.0, which uses C++ exceptions to implement many of the exception-handling macros, the second catch block matches the thrown `CException`."},{"content":"Code like this is uncommon.","pos":[2908,2935]},{"content":"It usually appears when an exception object is passed to another function that accepts a generic <bpt id=\"p1\">**</bpt>CException<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept>, performs \"pre-throw\" processing, and finally throws the exception.","pos":[2936,3117],"source":" It usually appears when an exception object is passed to another function that accepts a generic **CException\\***, performs \"pre-throw\" processing, and finally throws the exception."},{"content":"To work around this problem, move the throw expression from the function to the calling code and throw an exception of the actual type known to the compiler at the time the exception is generated.","pos":[3124,3320]},{"pos":[3377,3399],"content":"Re-Throwing Exceptions"},{"content":"A catch block cannot throw the same exception pointer that it caught.","pos":[3403,3472]},{"content":"For example, this code was valid in previous versions, but will have unexpected results with version 3.0:","pos":[3479,3584]},{"pos":[3602,3621],"content":"NVC_MFCExceptions#2"},{"content":"Using <bpt id=\"p1\">**</bpt>THROW<ept id=\"p1\">**</ept> in the catch block causes the pointer <ph id=\"ph1\">`e`</ph> to be deleted, so that the outer catch site will receive an invalid pointer.","pos":[3714,3848],"source":"Using **THROW** in the catch block causes the pointer `e` to be deleted, so that the outer catch site will receive an invalid pointer."},{"content":"Use <ph id=\"ph1\">`THROW_LAST`</ph> to re-throw <ph id=\"ph2\">`e`</ph>.","pos":[3849,3882],"source":" Use `THROW_LAST` to re-throw `e`."},{"pos":[3889,4017],"content":"For more information, see <bpt id=\"p1\">[</bpt>Exceptions: Catching and Deleting Exceptions<ept id=\"p1\">](../mfc/exceptions-catching-and-deleting-exceptions.md)</ept>.","source":"For more information, see [Exceptions: Catching and Deleting Exceptions](../mfc/exceptions-catching-and-deleting-exceptions.md)."},{"content":"See Also","pos":[4026,4034]},{"content":"Exception Handling","pos":[4039,4057]}],"content":"---\ntitle: \"Exceptions: Changes to Exception Macros in Version 3.0 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C++ exception handling, upgrade considerations\"\n  - \"CATCH macro\"\n  - \"exceptions, what's changed\"\n  - \"THROW_LAST macro\"\nms.assetid: 3aa20d8c-229e-449c-995c-ab879eac84bc\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Exceptions: Changes to Exception Macros in Version 3.0\nThis is an advanced topic.  \n  \n In MFC version 3.0 and later, the exception-handling macros have been changed to use C++ exceptions. This article tells how those changes can affect the behavior of existing code that uses the macros.  \n  \n This article covers the following topics:  \n  \n-   [Exception types and the CATCH macro](#_core_exception_types_and_the_catch_macro)  \n  \n-   [Re-throwing exceptions](#_core_re.2d.throwing_exceptions)  \n  \n##  <a name=\"_core_exception_types_and_the_catch_macro\"></a> Exception Types and the CATCH Macro  \n In earlier versions of MFC, the **CATCH** macro used MFC run-time type information to determine an exception's type; the exception's type is determined, in other words, at the catch site. With C++ exceptions, however, the exception's type is always determined at the throw site by the type of the exception object that is thrown. This will cause incompatibilities in the rare case where the type of the pointer to the thrown object differs from the type of the thrown object.  \n  \n The following example illustrates the consequence of this difference between MFC version 3.0 and earlier versions:  \n  \n [!code-cpp[NVC_MFCExceptions#1](../mfc/codesnippet/cpp/exceptions-changes-to-exception-macros-in-version-3-0_1.cpp)]  \n  \n This code behaves differently in version 3.0 because control always passes to the first **catch** block with a matching exception-declaration. The result of the throw expression  \n  \n [!code-cpp[NVC_MFCExceptions#19](../mfc/codesnippet/cpp/exceptions-changes-to-exception-macros-in-version-3-0_2.cpp)]  \n  \n is thrown as a **CException\\***, even though it is constructed as a **CCustomException**. The **CATCH** macro in MFC versions 2.5 and earlier uses `CObject::IsKindOf` to test the type at run time. Because the expression  \n  \n [!code-cpp[NVC_MFCExceptions#20](../mfc/codesnippet/cpp/exceptions-changes-to-exception-macros-in-version-3-0_3.cpp)]  \n  \n is true, the first catch block catches the exception. In version 3.0, which uses C++ exceptions to implement many of the exception-handling macros, the second catch block matches the thrown `CException`.  \n  \n Code like this is uncommon. It usually appears when an exception object is passed to another function that accepts a generic **CException\\***, performs \"pre-throw\" processing, and finally throws the exception.  \n  \n To work around this problem, move the throw expression from the function to the calling code and throw an exception of the actual type known to the compiler at the time the exception is generated.  \n  \n##  <a name=\"_core_re.2d.throwing_exceptions\"></a> Re-Throwing Exceptions  \n A catch block cannot throw the same exception pointer that it caught.  \n  \n For example, this code was valid in previous versions, but will have unexpected results with version 3.0:  \n  \n [!code-cpp[NVC_MFCExceptions#2](../mfc/codesnippet/cpp/exceptions-changes-to-exception-macros-in-version-3-0_4.cpp)]  \n  \n Using **THROW** in the catch block causes the pointer `e` to be deleted, so that the outer catch site will receive an invalid pointer. Use `THROW_LAST` to re-throw `e`.  \n  \n For more information, see [Exceptions: Catching and Deleting Exceptions](../mfc/exceptions-catching-and-deleting-exceptions.md).  \n  \n## See Also  \n [Exception Handling](../mfc/exception-handling-in-mfc.md)\n\n"}