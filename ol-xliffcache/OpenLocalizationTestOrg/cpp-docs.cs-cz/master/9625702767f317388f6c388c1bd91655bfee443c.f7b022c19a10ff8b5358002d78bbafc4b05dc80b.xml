{"nodes":[{"pos":[12,63],"content":"Exported DLL Function Entry Points | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Exported DLL Function Entry Points | Microsoft Docs","pos":[0,51]}]},{"content":"Exported DLL Function Entry Points","pos":[667,701]},{"pos":[702,944],"content":"For exported functions of a DLL, use the <bpt id=\"p1\">[</bpt>AFX_MANAGE_STATE<ept id=\"p1\">](http://msdn.microsoft.com/library/620cb840-4227-4a75-b36d-f7d507f44606)</ept> macro to maintain the proper global state when switching from the DLL module to the calling application's DLL.","source":"For exported functions of a DLL, use the [AFX_MANAGE_STATE](http://msdn.microsoft.com/library/620cb840-4227-4a75-b36d-f7d507f44606) macro to maintain the proper global state when switching from the DLL module to the calling application's DLL."},{"content":"When called, this macro sets <ph id=\"ph1\">`pModuleState`</ph>, a pointer to an <ph id=\"ph2\">`AFX_MODULE_STATE`</ph> structure containing global data for the module, as the effective module state for the remainder of the containing scope of the function.","pos":[951,1168],"source":"When called, this macro sets `pModuleState`, a pointer to an `AFX_MODULE_STATE` structure containing global data for the module, as the effective module state for the remainder of the containing scope of the function."},{"content":"Upon leaving the scope containing the macro, the previous effective module state is automatically restored.","pos":[1169,1276]},{"content":"This switching is achieved by constructing an instance of an <bpt id=\"p1\">**</bpt>AFX_MODULE_STATE<ept id=\"p1\">**</ept> class on the stack.","pos":[1283,1384],"source":"This switching is achieved by constructing an instance of an **AFX_MODULE_STATE** class on the stack."},{"content":"In its constructor, this class obtains a pointer to the current module state and stores it in a member variable, and then sets <ph id=\"ph1\">`pModuleState`</ph> as the new effective module state.","pos":[1385,1561],"source":" In its constructor, this class obtains a pointer to the current module state and stores it in a member variable, and then sets `pModuleState` as the new effective module state."},{"content":"In its destructor, this class restores the pointer stored in its member variable as the effective module state.","pos":[1562,1673]},{"content":"If you have an exported function, such as one that launches a dialog box in your DLL, you need to add the following code to the beginning of the function:","pos":[1680,1834]},{"pos":[1852,1877],"content":"NVC_MFCConnectionPoints#6"},{"pos":[1951,2149],"content":"This swaps the current module state with the state returned from <bpt id=\"p1\">[</bpt>AfxGetStaticModuleState<ept id=\"p1\">](http://msdn.microsoft.com/library/8b6c7c95-9d57-4337-9378-9b65e60d5c3b)</ept> until the end of the current scope.","source":"This swaps the current module state with the state returned from [AfxGetStaticModuleState](http://msdn.microsoft.com/library/8b6c7c95-9d57-4337-9378-9b65e60d5c3b) until the end of the current scope."},{"content":"Problems with resources in DLLs will occur if the <ph id=\"ph1\">`AFX_MANAGE_STATE`</ph> macro is not used.","pos":[2156,2243],"source":"Problems with resources in DLLs will occur if the `AFX_MANAGE_STATE` macro is not used."},{"content":"By default, MFC uses the resource handle of the main application to load the resource template.","pos":[2244,2339]},{"content":"This template is actually stored in the DLL.","pos":[2340,2384]},{"content":"The root cause is that MFC's module state information has not been switched by the <ph id=\"ph1\">`AFX_MANAGE_STATE`</ph> macro.","pos":[2385,2493],"source":" The root cause is that MFC's module state information has not been switched by the `AFX_MANAGE_STATE` macro."},{"content":"The resource handle is recovered from MFC's module state.","pos":[2494,2551]},{"content":"Not switching the module state causes the wrong resource handle to be used.","pos":[2552,2627]},{"content":"does not need to be put into every function in the DLL.","pos":[2653,2708]},{"content":"For example, <ph id=\"ph1\">`InitInstance`</ph> can be called by the MFC code in the application without <ph id=\"ph2\">`AFX_MANAGE_STATE`</ph> because MFC automatically shifts the module state before <ph id=\"ph3\">`InitInstance`</ph> and then switches it back after <ph id=\"ph4\">`InitInstance`</ph> returns.","pos":[2709,2940],"source":" For example, `InitInstance` can be called by the MFC code in the application without `AFX_MANAGE_STATE` because MFC automatically shifts the module state before `InitInstance` and then switches it back after `InitInstance` returns."},{"content":"The same is true for all message-map handlers.","pos":[2941,2987]},{"content":"Regular DLLs actually have a special master window procedure that automatically switches the module state before routing any message.","pos":[2988,3121]},{"content":"See Also","pos":[3130,3138]},{"content":"Managing the State Data of MFC Modules","pos":[3143,3181]}],"content":"---\ntitle: \"Exported DLL Function Entry Points | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"exporting DLLs, functions\"\n  - \"MFC, managing state data\"\n  - \"state management, exported DLLs\"\nms.assetid: 3268666e-d24b-44f2-80e8-7c80f73b93ca\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Exported DLL Function Entry Points\nFor exported functions of a DLL, use the [AFX_MANAGE_STATE](http://msdn.microsoft.com/library/620cb840-4227-4a75-b36d-f7d507f44606) macro to maintain the proper global state when switching from the DLL module to the calling application's DLL.  \n  \n When called, this macro sets `pModuleState`, a pointer to an `AFX_MODULE_STATE` structure containing global data for the module, as the effective module state for the remainder of the containing scope of the function. Upon leaving the scope containing the macro, the previous effective module state is automatically restored.  \n  \n This switching is achieved by constructing an instance of an **AFX_MODULE_STATE** class on the stack. In its constructor, this class obtains a pointer to the current module state and stores it in a member variable, and then sets `pModuleState` as the new effective module state. In its destructor, this class restores the pointer stored in its member variable as the effective module state.  \n  \n If you have an exported function, such as one that launches a dialog box in your DLL, you need to add the following code to the beginning of the function:  \n  \n [!code-cpp[NVC_MFCConnectionPoints#6](../mfc/codesnippet/cpp/exported-dll-function-entry-points_1.cpp)]  \n  \n This swaps the current module state with the state returned from [AfxGetStaticModuleState](http://msdn.microsoft.com/library/8b6c7c95-9d57-4337-9378-9b65e60d5c3b) until the end of the current scope.  \n  \n Problems with resources in DLLs will occur if the `AFX_MANAGE_STATE` macro is not used. By default, MFC uses the resource handle of the main application to load the resource template. This template is actually stored in the DLL. The root cause is that MFC's module state information has not been switched by the `AFX_MANAGE_STATE` macro. The resource handle is recovered from MFC's module state. Not switching the module state causes the wrong resource handle to be used.  \n  \n `AFX_MANAGE_STATE` does not need to be put into every function in the DLL. For example, `InitInstance` can be called by the MFC code in the application without `AFX_MANAGE_STATE` because MFC automatically shifts the module state before `InitInstance` and then switches it back after `InitInstance` returns. The same is true for all message-map handlers. Regular DLLs actually have a special master window procedure that automatically switches the module state before routing any message.  \n  \n## See Also  \n [Managing the State Data of MFC Modules](../mfc/managing-the-state-data-of-mfc-modules.md)\n\n"}