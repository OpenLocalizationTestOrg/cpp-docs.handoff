{"nodes":[{"pos":[12,58],"content":"Scope Resolution Operator: :: | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Scope Resolution Operator: :: | Microsoft Docs","pos":[0,46]}]},{"content":"Scope Resolution Operator: ::","pos":[723,752]},{"content":"The scope resolution operator <ph id=\"ph1\">`::`</ph> is used to identify and disambiguate identifiers used in different scopes.","pos":[753,862],"source":"The scope resolution operator `::` is used to identify and disambiguate identifiers used in different scopes."},{"content":"For more information about scope, see <bpt id=\"p1\">[</bpt>Scope<ept id=\"p1\">](../cpp/scope-visual-cpp.md)</ept>.","pos":[863,937],"source":" For more information about scope, see [Scope](../cpp/scope-visual-cpp.md)."},{"content":"Syntax","pos":[946,952]},{"content":"Remarks","pos":[1100,1107]},{"pos":[1111,1183],"content":"The <ph id=\"ph1\">`identifier`</ph> can be a variable, a function, or an enumeration value.","source":"The `identifier` can be a variable, a function, or an enumeration value."},{"content":"With Classes and Namespaces","pos":[1192,1219]},{"content":"The following example shows how the scope resolution operator is used with namespaces and classes:","pos":[1223,1321]},{"content":"A scope resolution operator without a scope qualifier refers to the global namespace.","pos":[1642,1727]},{"content":"You can use the scope resolution operator to identify a member of a namespace, or to identify a namespace that nominates the member’s namespace in a using-directive.","pos":[2001,2166]},{"content":"In the example below, you can use <ph id=\"ph1\">`NamespaceC`</ph> to qualify <ph id=\"ph2\">`ClassB`</ph>, even though <ph id=\"ph3\">`ClassB`</ph> was declared in namespace <ph id=\"ph4\">`NamespaceB`</ph>, because <ph id=\"ph5\">`NamespaceB`</ph> was nominated in <ph id=\"ph6\">`NamespaceC`</ph> by a using directive.","pos":[2167,2368],"source":" In the example below, you can use `NamespaceC` to qualify `ClassB`, even though `ClassB` was declared in namespace `NamespaceB`, because `NamespaceB` was nominated in `NamespaceC` by a using directive."},{"content":"You can use chains of scope resolution operators.","pos":[2661,2710]},{"content":"In the following example, <ph id=\"ph1\">`NamespaceD::NamespaceD1`</ph> identifies the nested namespace <ph id=\"ph2\">`NamespaceD1`</ph>, and <ph id=\"ph3\">`NamespaceE::ClassE::ClassE1`</ph> identifies the nested class <ph id=\"ph4\">`ClassE1`</ph>.","pos":[2711,2882],"source":" In the following example, `NamespaceD::NamespaceD1` identifies the nested namespace `NamespaceD1`, and `NamespaceE::ClassE::ClassE1` identifies the nested class `ClassE1`."},{"content":"With Static Members","pos":[3265,3284]},{"content":"You must use the scope resolution operator to call static members of classes.","pos":[3288,3365]},{"content":"With Scoped Enumerations","pos":[3595,3619]},{"pos":[3623,3791],"content":"The scoped resolution operator is also used with the values of a scoped enumeration <bpt id=\"p1\">[</bpt>Enumeration Declarations<ept id=\"p1\">](../cpp/enumerations-cpp.md)</ept>, as in the following example:","source":"The scoped resolution operator is also used with the values of a scoped enumeration [Enumeration Declarations](../cpp/enumerations-cpp.md), as in the following example:"},{"content":"See Also","pos":[3949,3957]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[3962,4014]},{"content":"Namespaces","pos":[4084,4094]}],"content":"---\ntitle: \"Scope Resolution Operator: :: | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"::\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"scope, scope resolution operator\"\n  - \"operators [C++], scope resolution\"\n  - \"scope resolution operator\"\n  - \":: operator\"\nms.assetid: fd5de9d3-c716-4e12-bae9-03a16fd79a50\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Scope Resolution Operator: ::\nThe scope resolution operator `::` is used to identify and disambiguate identifiers used in different scopes. For more information about scope, see [Scope](../cpp/scope-visual-cpp.md).  \n  \n## Syntax  \n  \n```  \n:: identifier  \nclass-name :: identifier  \nnamespace :: identifier  \nenum class :: identifier  \nenum struct :: identifier  \n```  \n  \n## Remarks  \n The `identifier` can be a variable, a function, or an enumeration value.  \n  \n## With Classes and Namespaces  \n The following example shows how the scope resolution operator is used with namespaces and classes:  \n  \n```cpp  \nnamespace NamespaceA{  \n    int x;  \n    class ClassA {  \n    public:  \n        int x;  \n    };  \n}  \n  \nint main() {  \n  \n    // A namespace name used to disambiguate  \n    NamespaceA::x = 1;  \n  \n    // A class name used to disambiguate  \n    NamespaceA::ClassA a1;  \n    a1.x = 2;  \n  \n}  \n  \n```  \n  \n A scope resolution operator without a scope qualifier refers to the global namespace.  \n  \n```cpp  \nnamespace NamespaceA{  \n    int x;  \n}  \n  \nint x;   \n  \nint main() {  \n    int x;  \n  \n    // the x in main()  \n    x = 0;   \n    // The x in the global namespace  \n    ::x = 1;   \n  \n    // The x in the A namespace  \n    NamespaceA::x = 2;   \n}  \n```  \n  \n You can use the scope resolution operator to identify a member of a namespace, or to identify a namespace that nominates the member’s namespace in a using-directive. In the example below, you can use `NamespaceC` to qualify `ClassB`, even though `ClassB` was declared in namespace `NamespaceB`, because `NamespaceB` was nominated in `NamespaceC` by a using directive.  \n  \n```cpp  \nnamespace NamespaceB {  \n    class ClassB {  \n    public:  \n        int x;  \n    };  \n}  \n  \nnamespace NamespaceC{  \n    using namespace B;  \n  \n}  \nint main() {  \n    NamespaceB::ClassB c_b;  \n    NamespaceC::ClassB c_c;  \n  \n    c_b.x = 3;  \n    c_c.x = 4;  \n}  \n  \n```  \n  \n You can use chains of scope resolution operators. In the following example, `NamespaceD::NamespaceD1` identifies the nested namespace `NamespaceD1`, and `NamespaceE::ClassE::ClassE1` identifies the nested class `ClassE1`.  \n  \n```cpp  \nnamespace NamespaceD{  \n    namespace NamespaceD1{  \n        int x;  \n    }  \n}  \n  \nnamespace NamespaceE{  \n  \n    class ClassE{  \n    public:  \n        class ClassE1{  \n        public:  \n            int x;  \n        };  \n    };  \n}  \n  \nint main() {  \n    NamespaceD:: NamespaceD1::x = 6;  \n    NamespaceE::ClassE::ClassE1 e1;  \n    e1.x = 7  ;  \n}  \n  \n```  \n  \n## With Static Members  \n You must use the scope resolution operator to call static members of classes.  \n  \n```cpp  \nclass ClassG {  \npublic:  \n    static int get_x() { return x;}  \n    static int x;  \n};  \n  \nint ClassG::x = 6;  \n  \nint main() {  \n  \n    int gx1 = ClassG::x;  \n    int gx2 = ClassG::get_x();   \n}  \n  \n```  \n  \n## With Scoped Enumerations  \n The scoped resolution operator is also used with the values of a scoped enumeration [Enumeration Declarations](../cpp/enumerations-cpp.md), as in the following example:  \n  \n```cpp  \nenum class EnumA{  \n    First,  \n    Second,  \n    Third  \n};  \n  \nint main() {  \n  \n    EnumA enum_value = EnumA::First;  \n}  \n  \n```  \n  \n## See Also  \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   \n [Namespaces](../cpp/namespaces-cpp.md)   "}