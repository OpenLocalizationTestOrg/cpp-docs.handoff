{"nodes":[{"pos":[12,56],"content":"structured_task_group Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"structured_task_group Class | Microsoft Docs","pos":[0,44]}]},{"pos":[652,679],"content":"structured_task_group Class","linkify":"structured_task_group Class","nodes":[{"content":"structured_task_group Class","pos":[0,27]}]},{"content":"The <ph id=\"ph1\">`structured_task_group`</ph> class represents a highly structured collection of parallel work.","pos":[680,773],"source":"The `structured_task_group` class represents a highly structured collection of parallel work."},{"content":"You can queue individual parallel tasks to a <ph id=\"ph1\">`structured_task_group`</ph> using <ph id=\"ph2\">`task_handle`</ph> objects, and wait for them to complete, or cancel the task group before they have finished executing, which will abort any tasks that have not begun execution.","pos":[774,1022],"source":" You can queue individual parallel tasks to a `structured_task_group` using `task_handle` objects, and wait for them to complete, or cancel the task group before they have finished executing, which will abort any tasks that have not begun execution."},{"pos":[1031,1037],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1088,1095],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"pos":[1105,1124],"content":"Public Constructors","linkify":"Public Constructors","nodes":[{"content":"Public Constructors","pos":[0,19]}]},{"content":"Name","pos":[1131,1135]},{"content":"Description","pos":[1136,1147]},{"pos":[1185,1250],"content":"<bpt id=\"p1\">[</bpt>structured_task_group::structured_task_group Constructor<ept id=\"p1\">](#ctor)</ept>","source":"[structured_task_group::structured_task_group Constructor](#ctor)"},{"content":"Overloaded.","pos":[1251,1262]},{"content":"Constructs a new <ph id=\"ph1\">`structured_task_group`</ph> object.","pos":[1263,1311],"source":" Constructs a new `structured_task_group` object."},{"pos":[1316,1381],"content":"<bpt id=\"p1\">[</bpt>structured_task_group::~structured_task_group Destructor<ept id=\"p1\">](#dtor)</ept>","source":"[structured_task_group::~structured_task_group Destructor](#dtor)"},{"content":"Destroys a <ph id=\"ph1\">`structured_task_group`</ph> object.","pos":[1382,1424],"source":"Destroys a `structured_task_group` object."},{"content":"You are expected to call either the <ph id=\"ph1\">`wait`</ph> or <ph id=\"ph2\">`run_and_wait`</ph> method on the object prior to the destructor executing, unless the destructor is executing as a result of stack unwinding due to an exception.","pos":[1425,1628],"source":" You are expected to call either the `wait` or `run_and_wait` method on the object prior to the destructor executing, unless the destructor is executing as a result of stack unwinding due to an exception."},{"pos":[1639,1653],"content":"Public Methods","linkify":"Public Methods","nodes":[{"content":"Public Methods","pos":[0,14]}]},{"content":"Name","pos":[1660,1664]},{"content":"Description","pos":[1665,1676]},{"pos":[1714,1761],"content":"<bpt id=\"p1\">[</bpt>structured_task_group::cancel Method<ept id=\"p1\">](#cancel)</ept>","source":"[structured_task_group::cancel Method](#cancel)"},{"content":"Makes a best effort attempt to cancel the sub-tree of work rooted at this task group.","pos":[1762,1847]},{"content":"Every task scheduled on the task group will get canceled transitively if possible.","pos":[1848,1930]},{"pos":[1935,1994],"content":"<bpt id=\"p1\">[</bpt>structured_task_group::is_canceling Method<ept id=\"p1\">](#is_canceling)</ept>","source":"[structured_task_group::is_canceling Method](#is_canceling)"},{"content":"Informs the caller whether or not the task group is currently in the midst of a cancellation.","pos":[1995,2088]},{"content":"This does not necessarily indicate that the <ph id=\"ph1\">`cancel`</ph> method was called on the <ph id=\"ph2\">`structured_task_group`</ph> object (although such certainly qualifies this method to return <ph id=\"ph3\">`true`</ph>).","pos":[2089,2263],"source":" This does not necessarily indicate that the `cancel` method was called on the `structured_task_group` object (although such certainly qualifies this method to return `true`)."},{"content":"It may be the case that the <ph id=\"ph1\">`structured_task_group`</ph> object is executing inline and a task group further up in the work tree was canceled.","pos":[2264,2401],"source":" It may be the case that the `structured_task_group` object is executing inline and a task group further up in the work tree was canceled."},{"content":"In cases such as these where the runtime can determine ahead of time that cancellation will flow through this <ph id=\"ph1\">`structured_task_group`</ph> object, <ph id=\"ph2\">`true`</ph> will be returned as well.","pos":[2402,2576],"source":" In cases such as these where the runtime can determine ahead of time that cancellation will flow through this `structured_task_group` object, `true` will be returned as well."},{"pos":[2581,2622],"content":"<bpt id=\"p1\">[</bpt>structured_task_group::run Method<ept id=\"p1\">](#run)</ept>","source":"[structured_task_group::run Method](#run)"},{"content":"Overloaded.","pos":[2623,2634]},{"content":"Schedules a task on the <ph id=\"ph1\">`structured_task_group`</ph> object.","pos":[2635,2690],"source":" Schedules a task on the `structured_task_group` object."},{"content":"The caller manages the lifetime of the <ph id=\"ph1\">`task_handle`</ph> object passed in the <ph id=\"ph2\">`_Task_handle`</ph> parameter.","pos":[2691,2790],"source":" The caller manages the lifetime of the `task_handle` object passed in the `_Task_handle` parameter."},{"content":"The version that takes the parameter <ph id=\"ph1\">`_Placement`</ph> causes the task to be biased towards executing at the location specified by that parameter.","pos":[2791,2932],"source":" The version that takes the parameter `_Placement` causes the task to be biased towards executing at the location specified by that parameter."},{"pos":[2937,2996],"content":"<bpt id=\"p1\">[</bpt>structured_task_group::run_and_wait Method<ept id=\"p1\">](#run_and_wait)</ept>","source":"[structured_task_group::run_and_wait Method](#run_and_wait)"},{"content":"Overloaded.","pos":[2997,3008]},{"content":"Schedules a task to be run inline on the calling context with the assistance of the <ph id=\"ph1\">`structured_task_group`</ph> object for full cancellation support.","pos":[3009,3154],"source":" Schedules a task to be run inline on the calling context with the assistance of the `structured_task_group` object for full cancellation support."},{"content":"If a <ph id=\"ph1\">`task_handle`</ph> object is passed as a parameter to <ph id=\"ph2\">`run_and_wait`</ph>, the caller is responsible for managing the lifetime of the <ph id=\"ph3\">`task_handle`</ph> object.","pos":[3155,3305],"source":" If a `task_handle` object is passed as a parameter to `run_and_wait`, the caller is responsible for managing the lifetime of the `task_handle` object."},{"content":"The function then waits until all work on the <ph id=\"ph1\">`structured_task_group`</ph> object has either completed or been canceled.","pos":[3306,3421],"source":" The function then waits until all work on the `structured_task_group` object has either completed or been canceled."},{"pos":[3426,3469],"content":"<bpt id=\"p1\">[</bpt>structured_task_group::wait Method<ept id=\"p1\">](#wait)</ept>","source":"[structured_task_group::wait Method](#wait)"},{"pos":[3470,3551],"content":"Waits until all work on the <ph id=\"ph1\">`structured_task_group`</ph> has completed or is canceled.","source":"Waits until all work on the `structured_task_group` has completed or is canceled."},{"pos":[3561,3568],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[3572,3695],"content":"There are a number of severe restrictions placed on usage of a <ph id=\"ph1\">`structured_task_group`</ph> object in order to gain performance:","source":"There are a number of severe restrictions placed on usage of a `structured_task_group` object in order to gain performance:"},{"content":"A single <ph id=\"ph1\">`structured_task_group`</ph> object cannot be used by multiple threads.","pos":[3705,3780],"source":"A single `structured_task_group` object cannot be used by multiple threads."},{"content":"All operations on a <ph id=\"ph1\">`structured_task_group`</ph> object must be performed by the thread that created the object.","pos":[3781,3888],"source":" All operations on a `structured_task_group` object must be performed by the thread that created the object."},{"content":"The two exceptions to this rule are the member functions <ph id=\"ph1\">`cancel`</ph> and <ph id=\"ph2\">`is_canceling`</ph>.","pos":[3889,3974],"source":" The two exceptions to this rule are the member functions `cancel` and `is_canceling`."},{"content":"The object may not be in the capture list of a lambda expression and be used within a task, unless the task is using one of the cancellation operations.","pos":[3975,4127]},{"pos":[4137,4297],"content":"All tasks scheduled to a <ph id=\"ph1\">`structured_task_group`</ph> object are scheduled through the use of <ph id=\"ph2\">`task_handle`</ph> objects which you must explicitly manage the lifetime of.","source":"All tasks scheduled to a `structured_task_group` object are scheduled through the use of `task_handle` objects which you must explicitly manage the lifetime of."},{"content":"Multiple groups may only be used in absolutely nested order.","pos":[4307,4367]},{"content":"If two <ph id=\"ph1\">`structured_task_group`</ph> objects are declared, the second one being declared (the inner one) must destruct before any method except <ph id=\"ph2\">`cancel`</ph> or <ph id=\"ph3\">`is_canceling`</ph> is called on the first one (the outer one).","pos":[4368,4576],"source":" If two `structured_task_group` objects are declared, the second one being declared (the inner one) must destruct before any method except `cancel` or `is_canceling` is called on the first one (the outer one)."},{"content":"This condition holds true in both the case of simply declaring multiple <ph id=\"ph1\">`structured_task_group`</ph> objects within the same or functionally nested scopes as well as the case of a task that was queued to the <ph id=\"ph2\">`structured_task_group`</ph> via the <ph id=\"ph3\">`run`</ph> or <ph id=\"ph4\">`run_and_wait`</ph> methods.","pos":[4577,4844],"source":" This condition holds true in both the case of simply declaring multiple `structured_task_group` objects within the same or functionally nested scopes as well as the case of a task that was queued to the `structured_task_group` via the `run` or `run_and_wait` methods."},{"content":"Unlike the general <ph id=\"ph1\">`task_group`</ph> class, all states in the <ph id=\"ph2\">`structured_task_group`</ph> class are final.","pos":[4854,4951],"source":"Unlike the general `task_group` class, all states in the `structured_task_group` class are final."},{"content":"After you have queued tasks to the group and waited for them to complete, you may not use the same group again.","pos":[4952,5063]},{"pos":[5070,5181],"content":"For more information, see <bpt id=\"p1\">[</bpt>Task Parallelism<ept id=\"p1\">](../../../parallel/concrt/task-parallelism-concurrency-runtime.md)</ept>.","source":"For more information, see [Task Parallelism](../../../parallel/concrt/task-parallelism-concurrency-runtime.md)."},{"pos":[5190,5211],"content":"Inheritance Hierarchy","linkify":"Inheritance Hierarchy","nodes":[{"content":"Inheritance Hierarchy","pos":[0,21]}]},{"pos":[5247,5259],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[5263,5280],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> ppl.h","source":"**Header:** ppl.h"},{"pos":[5287,5313],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> concurrency","source":"**Namespace:** concurrency"},{"pos":[5323,5382],"content":"<bpt id=\"p1\">&lt;a name=\"cancel\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  structured_task_group::cancel Method","linkify":"<a name=\"cancel\"></a>  structured_task_group::cancel Method","source":"<a name=\"cancel\"></a>  structured_task_group::cancel Method"},{"content":"Makes a best effort attempt to cancel the sub-tree of work rooted at this task group.","pos":[5386,5471]},{"content":"Every task scheduled on the task group will get canceled transitively if possible.","pos":[5472,5554]},{"pos":[5592,5599],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5603,5732],"content":"For more information, see <bpt id=\"p1\">[</bpt>Cancellation<ept id=\"p1\">](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation)</ept>.","source":"For more information, see [Cancellation](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation)."},{"pos":[5742,5813],"content":"<bpt id=\"p1\">&lt;a name=\"is_canceling\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  structured_task_group::is_canceling Method","linkify":"<a name=\"is_canceling\"></a>  structured_task_group::is_canceling Method","source":"<a name=\"is_canceling\"></a>  structured_task_group::is_canceling Method"},{"content":"Informs the caller whether or not the task group is currently in the midst of a cancellation.","pos":[5817,5910]},{"content":"This does not necessarily indicate that the <ph id=\"ph1\">`cancel`</ph> method was called on the <ph id=\"ph2\">`structured_task_group`</ph> object (although such certainly qualifies this method to return <ph id=\"ph3\">`true`</ph>).","pos":[5911,6085],"source":" This does not necessarily indicate that the `cancel` method was called on the `structured_task_group` object (although such certainly qualifies this method to return `true`)."},{"content":"It may be the case that the <ph id=\"ph1\">`structured_task_group`</ph> object is executing inline and a task group further up in the work tree was canceled.","pos":[6086,6223],"source":" It may be the case that the `structured_task_group` object is executing inline and a task group further up in the work tree was canceled."},{"content":"In cases such as these where the runtime can determine ahead of time that cancellation will flow through this <ph id=\"ph1\">`structured_task_group`</ph> object, <ph id=\"ph2\">`true`</ph> will be returned as well.","pos":[6224,6398],"source":" In cases such as these where the runtime can determine ahead of time that cancellation will flow through this `structured_task_group` object, `true` will be returned as well."},{"pos":[6442,6454],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[6458,6585],"content":"An indication of whether the <ph id=\"ph1\">`structured_task_group`</ph> object is in the midst of a cancellation (or is guaranteed to be shortly).","source":"An indication of whether the `structured_task_group` object is in the midst of a cancellation (or is guaranteed to be shortly)."},{"pos":[6595,6602],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6606,6735],"content":"For more information, see <bpt id=\"p1\">[</bpt>Cancellation<ept id=\"p1\">](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation)</ept>.","source":"For more information, see [Cancellation](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation)."},{"pos":[6745,6798],"content":"<bpt id=\"p1\">&lt;a name=\"run\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  structured_task_group::run Method","linkify":"<a name=\"run\"></a>  structured_task_group::run Method","source":"<a name=\"run\"></a>  structured_task_group::run Method"},{"content":"Schedules a task on the <ph id=\"ph1\">`structured_task_group`</ph> object.","pos":[6802,6857],"source":"Schedules a task on the `structured_task_group` object."},{"content":"The caller manages the lifetime of the <ph id=\"ph1\">`task_handle`</ph> object passed in the <ph id=\"ph2\">`_Task_handle`</ph> parameter.","pos":[6858,6957],"source":" The caller manages the lifetime of the `task_handle` object passed in the `_Task_handle` parameter."},{"content":"The version that takes the parameter <ph id=\"ph1\">`_Placement`</ph> causes the task to be biased towards executing at the location specified by that parameter.","pos":[6958,7099],"source":" The version that takes the parameter `_Placement` causes the task to be biased towards executing at the location specified by that parameter."},{"pos":[7307,7317],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type of the function object that will be invoked to execute the body of the task handle.","pos":[7336,7428]},{"content":"A handle to the work being scheduled.","pos":[7453,7490]},{"content":"Note that the caller has responsibility for the lifetime of this object.","pos":[7491,7563]},{"content":"The runtime will continue to expect it to live until either the <ph id=\"ph1\">`wait`</ph> or <ph id=\"ph2\">`run_and_wait`</ph> method has been called on this <ph id=\"ph3\">`structured_task_group`</ph> object.","pos":[7564,7715],"source":" The runtime will continue to expect it to live until either the `wait` or `run_and_wait` method has been called on this `structured_task_group` object."},{"content":"A reference to the location where the task represented by the <ph id=\"ph1\">`_Task_handle`</ph> parameter should execute.","pos":[7738,7840],"source":" A reference to the location where the task represented by the `_Task_handle` parameter should execute."},{"pos":[7850,7857],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The runtime creates a copy of the work function that you pass to this method.","pos":[7861,7938]},{"content":"Any state changes that occur in a function object that you pass to this method will not appear in your copy of that function object.","pos":[7939,8071]},{"content":"If the <ph id=\"ph1\">`structured_task_group`</ph> destructs as the result of stack unwinding from an exception, you do not need to guarantee that a call has been made to either the <ph id=\"ph2\">`wait`</ph> or <ph id=\"ph3\">`run_and_wait`</ph> method.","pos":[8078,8272],"source":"If the `structured_task_group` destructs as the result of stack unwinding from an exception, you do not need to guarantee that a call has been made to either the `wait` or `run_and_wait` method."},{"content":"In this case, the destructor will appropriately cancel and wait for the task represented by the <ph id=\"ph1\">`_Task_handle`</ph> parameter to complete.","pos":[8273,8406],"source":" In this case, the destructor will appropriately cancel and wait for the task represented by the `_Task_handle` parameter to complete."},{"pos":[8413,8735],"content":"Throws an <bpt id=\"p1\">[</bpt>invalid_multiple_scheduling<ept id=\"p1\">](invalid-multiple-scheduling-class.md)</ept> exception if the task handle given by the <ph id=\"ph1\">`_Task_handle`</ph> parameter has already been scheduled onto a task group object via the <ph id=\"ph2\">`run`</ph> method and there has been no intervening call to either the <ph id=\"ph3\">`wait`</ph> or <ph id=\"ph4\">`run_and_wait`</ph> method on that task group.","source":"Throws an [invalid_multiple_scheduling](invalid-multiple-scheduling-class.md) exception if the task handle given by the `_Task_handle` parameter has already been scheduled onto a task group object via the `run` method and there has been no intervening call to either the `wait` or `run_and_wait` method on that task group."},{"pos":[8745,8816],"content":"<bpt id=\"p1\">&lt;a name=\"run_and_wait\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  structured_task_group::run_and_wait Method","linkify":"<a name=\"run_and_wait\"></a>  structured_task_group::run_and_wait Method","source":"<a name=\"run_and_wait\"></a>  structured_task_group::run_and_wait Method"},{"content":"Schedules a task to be run inline on the calling context with the assistance of the <ph id=\"ph1\">`structured_task_group`</ph> object for full cancellation support.","pos":[8820,8965],"source":"Schedules a task to be run inline on the calling context with the assistance of the `structured_task_group` object for full cancellation support."},{"content":"If a <ph id=\"ph1\">`task_handle`</ph> object is passed as a parameter to <ph id=\"ph2\">`run_and_wait`</ph>, the caller is responsible for managing the lifetime of the <ph id=\"ph3\">`task_handle`</ph> object.","pos":[8966,9116],"source":" If a `task_handle` object is passed as a parameter to `run_and_wait`, the caller is responsible for managing the lifetime of the `task_handle` object."},{"content":"The function then waits until all work on the <ph id=\"ph1\">`structured_task_group`</ph> object has either completed or been canceled.","pos":[9117,9232],"source":" The function then waits until all work on the `structured_task_group` object has either completed or been canceled."},{"pos":[9434,9444],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type of the function object that will be invoked to execute the task.","pos":[9463,9536]},{"content":"A handle to the task which will be run inline on the calling context.","pos":[9561,9630]},{"content":"Note that the caller has responsibility for the lifetime of this object.","pos":[9631,9703]},{"content":"The runtime will continue to expect it to live until the <ph id=\"ph1\">`run_and_wait`</ph> method finishes execution.","pos":[9704,9802],"source":" The runtime will continue to expect it to live until the `run_and_wait` method finishes execution."},{"content":"A function which will be called to invoke the body of the work.","pos":[9820,9883]},{"content":"This may be a lambda or other object which supports a version of the function call operator with the signature <ph id=\"ph1\">`void operator()()`</ph>.","pos":[9884,10015],"source":" This may be a lambda or other object which supports a version of the function call operator with the signature `void operator()()`."},{"pos":[10025,10037],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"An indication of whether the wait was satisfied or the task group was canceled, due to either an explicit cancel operation or an exception being thrown from one of its tasks.","pos":[10041,10215]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>task_group_status<ept id=\"p1\">](concurrency-namespace-enums.md)</ept>","pos":[10216,10293],"source":" For more information, see [task_group_status](concurrency-namespace-enums.md)"},{"pos":[10303,10310],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[10314,10440],"content":"Note that one or more of the tasks scheduled to this <ph id=\"ph1\">`structured_task_group`</ph> object may execute inline on the calling context.","source":"Note that one or more of the tasks scheduled to this `structured_task_group` object may execute inline on the calling context."},{"pos":[10447,10666],"content":"If one or more of the tasks scheduled to this <ph id=\"ph1\">`structured_task_group`</ph> object throws an exception, the runtime will select one such exception of its choosing and propagate it out of the call to the <ph id=\"ph2\">`run_and_wait`</ph> method.","source":"If one or more of the tasks scheduled to this `structured_task_group` object throws an exception, the runtime will select one such exception of its choosing and propagate it out of the call to the `run_and_wait` method."},{"content":"After this function returns, the <ph id=\"ph1\">`structured_task_group`</ph> object is considered in a final state and should not be used.","pos":[10673,10791],"source":"After this function returns, the `structured_task_group` object is considered in a final state and should not be used."},{"content":"Note that utilization after the <ph id=\"ph1\">`run_and_wait`</ph> method returns will result in undefined behavior.","pos":[10792,10888],"source":" Note that utilization after the `run_and_wait` method returns will result in undefined behavior."},{"pos":[10895,11066],"content":"In the non-exceptional path of execution, you have a mandate to call either this method or the <ph id=\"ph1\">`wait`</ph> method before the destructor of the <ph id=\"ph2\">`structured_task_group`</ph> executes.","source":"In the non-exceptional path of execution, you have a mandate to call either this method or the `wait` method before the destructor of the `structured_task_group` executes."},{"pos":[11076,11153],"content":"<bpt id=\"p1\">&lt;a name=\"ctor\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  structured_task_group::structured_task_group Constructor","linkify":"<a name=\"ctor\"></a>  structured_task_group::structured_task_group Constructor","source":"<a name=\"ctor\"></a>  structured_task_group::structured_task_group Constructor"},{"pos":[11157,11205],"content":"Constructs a new <ph id=\"ph1\">`structured_task_group`</ph> object.","source":"Constructs a new `structured_task_group` object."},{"pos":[11316,11326],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A cancellation token to associate with this structured task group.","pos":[11354,11420]},{"content":"The structured task group will be canceled when the token is canceled.","pos":[11421,11491]},{"pos":[11501,11508],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The constructor that takes a cancellation token creates a <ph id=\"ph1\">`structured_task_group`</ph> that will be canceled when the source associated with the token is canceled.","pos":[11512,11670],"source":"The constructor that takes a cancellation token creates a `structured_task_group` that will be canceled when the source associated with the token is canceled."},{"content":"Providing an explicit cancellation token also isolates this structured task group from participating in an implicit cancellation from a parent group with a different token or no token.","pos":[11671,11855]},{"pos":[11865,11942],"content":"<bpt id=\"p1\">&lt;a name=\"dtor\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  structured_task_group::~structured_task_group Destructor","linkify":"<a name=\"dtor\"></a>  structured_task_group::~structured_task_group Destructor","source":"<a name=\"dtor\"></a>  structured_task_group::~structured_task_group Destructor"},{"content":"Destroys a <ph id=\"ph1\">`structured_task_group`</ph> object.","pos":[11946,11988],"source":"Destroys a `structured_task_group` object."},{"content":"You are expected to call either the <ph id=\"ph1\">`wait`</ph> or <ph id=\"ph2\">`run_and_wait`</ph> method on the object prior to the destructor executing, unless the destructor is executing as a result of stack unwinding due to an exception.","pos":[11989,12192],"source":" You are expected to call either the `wait` or `run_and_wait` method on the object prior to the destructor executing, unless the destructor is executing as a result of stack unwinding due to an exception."},{"pos":[12241,12248],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[12252,12507],"content":"If the destructor runs as the result of normal execution (for example, not stack unwinding due to an exception) and neither the <ph id=\"ph1\">`wait`</ph> nor <ph id=\"ph2\">`run_and_wait`</ph> methods have been called, the destructor may throw a <bpt id=\"p1\">[</bpt>missing_wait<ept id=\"p1\">](missing-wait-class.md)</ept> exception.","source":"If the destructor runs as the result of normal execution (for example, not stack unwinding due to an exception) and neither the `wait` nor `run_and_wait` methods have been called, the destructor may throw a [missing_wait](missing-wait-class.md) exception."},{"pos":[12517,12572],"content":"<bpt id=\"p1\">&lt;a name=\"wait\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  structured_task_group::wait Method","linkify":"<a name=\"wait\"></a>  structured_task_group::wait Method","source":"<a name=\"wait\"></a>  structured_task_group::wait Method"},{"pos":[12576,12657],"content":"Waits until all work on the <ph id=\"ph1\">`structured_task_group`</ph> has completed or is canceled.","source":"Waits until all work on the `structured_task_group` has completed or is canceled."},{"pos":[12706,12718],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"An indication of whether the wait was satisfied or the task group was canceled, due to either an explicit cancel operation or an exception being thrown from one of its tasks.","pos":[12722,12896]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>task_group_status<ept id=\"p1\">](concurrency-namespace-enums.md)</ept>","pos":[12897,12974],"source":" For more information, see [task_group_status](concurrency-namespace-enums.md)"},{"pos":[12984,12991],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[12995,13121],"content":"Note that one or more of the tasks scheduled to this <ph id=\"ph1\">`structured_task_group`</ph> object may execute inline on the calling context.","source":"Note that one or more of the tasks scheduled to this `structured_task_group` object may execute inline on the calling context."},{"pos":[13128,13339],"content":"If one or more of the tasks scheduled to this <ph id=\"ph1\">`structured_task_group`</ph> object throws an exception, the runtime will select one such exception of its choosing and propagate it out of the call to the <ph id=\"ph2\">`wait`</ph> method.","source":"If one or more of the tasks scheduled to this `structured_task_group` object throws an exception, the runtime will select one such exception of its choosing and propagate it out of the call to the `wait` method."},{"content":"After this function returns, the <ph id=\"ph1\">`structured_task_group`</ph> object is considered in a final state and should not be used.","pos":[13346,13464],"source":"After this function returns, the `structured_task_group` object is considered in a final state and should not be used."},{"content":"Note that utilization after the <ph id=\"ph1\">`wait`</ph> method returns will result in undefined behavior.","pos":[13465,13553],"source":" Note that utilization after the `wait` method returns will result in undefined behavior."},{"pos":[13560,13739],"content":"In the non-exceptional path of execution, you have a mandate to call either this method or the <ph id=\"ph1\">`run_and_wait`</ph> method before the destructor of the <ph id=\"ph2\">`structured_task_group`</ph> executes.","source":"In the non-exceptional path of execution, you have a mandate to call either this method or the `run_and_wait` method before the destructor of the `structured_task_group` executes."},{"pos":[13748,13756],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>concurrency Namespace<ept id=\"p1\">](concurrency-namespace.md)</ept><ph id=\"ph1\"> </ph>","pos":[13760,13810],"source":"[concurrency Namespace](concurrency-namespace.md) "},{"content":"<bpt id=\"p1\"> [</bpt>task_group Class<ept id=\"p1\">](task-group-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[13813,13854],"source":" [task_group Class](task-group-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>task_handle Class<ept id=\"p1\">](task-handle-class.md)</ept>","pos":[13857,13899],"source":" [task_handle Class](task-handle-class.md)"}],"content":"---\ntitle: \"structured_task_group Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"ppl/concurrency::structured_task_group\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"structured_task_group class\"\nms.assetid: 742afa8c-c7b6-482c-b0ba-04c809927b22\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# structured_task_group Class\nThe `structured_task_group` class represents a highly structured collection of parallel work. You can queue individual parallel tasks to a `structured_task_group` using `task_handle` objects, and wait for them to complete, or cancel the task group before they have finished executing, which will abort any tasks that have not begun execution.  \n  \n## Syntax  \n  \n```\nclass structured_task_group;\n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[structured_task_group::structured_task_group Constructor](#ctor)|Overloaded. Constructs a new `structured_task_group` object.|  \n|[structured_task_group::~structured_task_group Destructor](#dtor)|Destroys a `structured_task_group` object. You are expected to call either the `wait` or `run_and_wait` method on the object prior to the destructor executing, unless the destructor is executing as a result of stack unwinding due to an exception.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[structured_task_group::cancel Method](#cancel)|Makes a best effort attempt to cancel the sub-tree of work rooted at this task group. Every task scheduled on the task group will get canceled transitively if possible.|  \n|[structured_task_group::is_canceling Method](#is_canceling)|Informs the caller whether or not the task group is currently in the midst of a cancellation. This does not necessarily indicate that the `cancel` method was called on the `structured_task_group` object (although such certainly qualifies this method to return `true`). It may be the case that the `structured_task_group` object is executing inline and a task group further up in the work tree was canceled. In cases such as these where the runtime can determine ahead of time that cancellation will flow through this `structured_task_group` object, `true` will be returned as well.|  \n|[structured_task_group::run Method](#run)|Overloaded. Schedules a task on the `structured_task_group` object. The caller manages the lifetime of the `task_handle` object passed in the `_Task_handle` parameter. The version that takes the parameter `_Placement` causes the task to be biased towards executing at the location specified by that parameter.|  \n|[structured_task_group::run_and_wait Method](#run_and_wait)|Overloaded. Schedules a task to be run inline on the calling context with the assistance of the `structured_task_group` object for full cancellation support. If a `task_handle` object is passed as a parameter to `run_and_wait`, the caller is responsible for managing the lifetime of the `task_handle` object. The function then waits until all work on the `structured_task_group` object has either completed or been canceled.|  \n|[structured_task_group::wait Method](#wait)|Waits until all work on the `structured_task_group` has completed or is canceled.|  \n  \n## Remarks  \n There are a number of severe restrictions placed on usage of a `structured_task_group` object in order to gain performance:  \n  \n-   A single `structured_task_group` object cannot be used by multiple threads. All operations on a `structured_task_group` object must be performed by the thread that created the object. The two exceptions to this rule are the member functions `cancel` and `is_canceling`. The object may not be in the capture list of a lambda expression and be used within a task, unless the task is using one of the cancellation operations.  \n  \n-   All tasks scheduled to a `structured_task_group` object are scheduled through the use of `task_handle` objects which you must explicitly manage the lifetime of.  \n  \n-   Multiple groups may only be used in absolutely nested order. If two `structured_task_group` objects are declared, the second one being declared (the inner one) must destruct before any method except `cancel` or `is_canceling` is called on the first one (the outer one). This condition holds true in both the case of simply declaring multiple `structured_task_group` objects within the same or functionally nested scopes as well as the case of a task that was queued to the `structured_task_group` via the `run` or `run_and_wait` methods.  \n  \n-   Unlike the general `task_group` class, all states in the `structured_task_group` class are final. After you have queued tasks to the group and waited for them to complete, you may not use the same group again.  \n  \n For more information, see [Task Parallelism](../../../parallel/concrt/task-parallelism-concurrency-runtime.md).  \n  \n## Inheritance Hierarchy  \n `structured_task_group`  \n  \n## Requirements  \n **Header:** ppl.h  \n  \n **Namespace:** concurrency  \n  \n##  <a name=\"cancel\"></a>  structured_task_group::cancel Method  \n Makes a best effort attempt to cancel the sub-tree of work rooted at this task group. Every task scheduled on the task group will get canceled transitively if possible.  \n  \n```\nvoid cancel();\n```  \n  \n### Remarks  \n For more information, see [Cancellation](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation).  \n  \n##  <a name=\"is_canceling\"></a>  structured_task_group::is_canceling Method  \n Informs the caller whether or not the task group is currently in the midst of a cancellation. This does not necessarily indicate that the `cancel` method was called on the `structured_task_group` object (although such certainly qualifies this method to return `true`). It may be the case that the `structured_task_group` object is executing inline and a task group further up in the work tree was canceled. In cases such as these where the runtime can determine ahead of time that cancellation will flow through this `structured_task_group` object, `true` will be returned as well.  \n  \n```\nbool is_canceling();\n```  \n  \n### Return Value  \n An indication of whether the `structured_task_group` object is in the midst of a cancellation (or is guaranteed to be shortly).  \n  \n### Remarks  \n For more information, see [Cancellation](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation).  \n  \n##  <a name=\"run\"></a>  structured_task_group::run Method  \n Schedules a task on the `structured_task_group` object. The caller manages the lifetime of the `task_handle` object passed in the `_Task_handle` parameter. The version that takes the parameter `_Placement` causes the task to be biased towards executing at the location specified by that parameter.  \n  \n```\ntemplate<class _Function>\nvoid run(\n    task_handle<_Function>& _Task_handle);\n\ntemplate<class _Function>\nvoid run(\n    task_handle<_Function>& _Task_handle,\n    location& _Placement);\n```  \n  \n### Parameters  \n `_Function`  \n The type of the function object that will be invoked to execute the body of the task handle.  \n  \n `_Task_handle`  \n A handle to the work being scheduled. Note that the caller has responsibility for the lifetime of this object. The runtime will continue to expect it to live until either the `wait` or `run_and_wait` method has been called on this `structured_task_group` object.  \n  \n `_Placement`  \n A reference to the location where the task represented by the `_Task_handle` parameter should execute.  \n  \n### Remarks  \n The runtime creates a copy of the work function that you pass to this method. Any state changes that occur in a function object that you pass to this method will not appear in your copy of that function object.  \n  \n If the `structured_task_group` destructs as the result of stack unwinding from an exception, you do not need to guarantee that a call has been made to either the `wait` or `run_and_wait` method. In this case, the destructor will appropriately cancel and wait for the task represented by the `_Task_handle` parameter to complete.  \n  \n Throws an [invalid_multiple_scheduling](invalid-multiple-scheduling-class.md) exception if the task handle given by the `_Task_handle` parameter has already been scheduled onto a task group object via the `run` method and there has been no intervening call to either the `wait` or `run_and_wait` method on that task group.  \n  \n##  <a name=\"run_and_wait\"></a>  structured_task_group::run_and_wait Method  \n Schedules a task to be run inline on the calling context with the assistance of the `structured_task_group` object for full cancellation support. If a `task_handle` object is passed as a parameter to `run_and_wait`, the caller is responsible for managing the lifetime of the `task_handle` object. The function then waits until all work on the `structured_task_group` object has either completed or been canceled.  \n  \n```\ntemplate<class _Function>\ntask_group_status run_and_wait(task_handle<_Function>& _Task_handle);\n\ntemplate<class _Function>\ntask_group_status run_and_wait(const _Function& _Func);\n```  \n  \n### Parameters  \n `_Function`  \n The type of the function object that will be invoked to execute the task.  \n  \n `_Task_handle`  \n A handle to the task which will be run inline on the calling context. Note that the caller has responsibility for the lifetime of this object. The runtime will continue to expect it to live until the `run_and_wait` method finishes execution.  \n  \n `_Func`  \n A function which will be called to invoke the body of the work. This may be a lambda or other object which supports a version of the function call operator with the signature `void operator()()`.  \n  \n### Return Value  \n An indication of whether the wait was satisfied or the task group was canceled, due to either an explicit cancel operation or an exception being thrown from one of its tasks. For more information, see [task_group_status](concurrency-namespace-enums.md)  \n  \n### Remarks  \n Note that one or more of the tasks scheduled to this `structured_task_group` object may execute inline on the calling context.  \n  \n If one or more of the tasks scheduled to this `structured_task_group` object throws an exception, the runtime will select one such exception of its choosing and propagate it out of the call to the `run_and_wait` method.  \n  \n After this function returns, the `structured_task_group` object is considered in a final state and should not be used. Note that utilization after the `run_and_wait` method returns will result in undefined behavior.  \n  \n In the non-exceptional path of execution, you have a mandate to call either this method or the `wait` method before the destructor of the `structured_task_group` executes.  \n  \n##  <a name=\"ctor\"></a>  structured_task_group::structured_task_group Constructor  \n Constructs a new `structured_task_group` object.  \n  \n```\nstructured_task_group();\n\nstructured_task_group(cancellation_token _CancellationToken);\n```  \n  \n### Parameters  \n `_CancellationToken`  \n A cancellation token to associate with this structured task group. The structured task group will be canceled when the token is canceled.  \n  \n### Remarks  \n The constructor that takes a cancellation token creates a `structured_task_group` that will be canceled when the source associated with the token is canceled. Providing an explicit cancellation token also isolates this structured task group from participating in an implicit cancellation from a parent group with a different token or no token.  \n  \n##  <a name=\"dtor\"></a>  structured_task_group::~structured_task_group Destructor  \n Destroys a `structured_task_group` object. You are expected to call either the `wait` or `run_and_wait` method on the object prior to the destructor executing, unless the destructor is executing as a result of stack unwinding due to an exception.  \n  \n```\n~structured_task_group();\n```  \n  \n### Remarks  \n If the destructor runs as the result of normal execution (for example, not stack unwinding due to an exception) and neither the `wait` nor `run_and_wait` methods have been called, the destructor may throw a [missing_wait](missing-wait-class.md) exception.  \n  \n##  <a name=\"wait\"></a>  structured_task_group::wait Method  \n Waits until all work on the `structured_task_group` has completed or is canceled.  \n  \n```\ntask_group_status wait();\n```  \n  \n### Return Value  \n An indication of whether the wait was satisfied or the task group was canceled, due to either an explicit cancel operation or an exception being thrown from one of its tasks. For more information, see [task_group_status](concurrency-namespace-enums.md)  \n  \n### Remarks  \n Note that one or more of the tasks scheduled to this `structured_task_group` object may execute inline on the calling context.  \n  \n If one or more of the tasks scheduled to this `structured_task_group` object throws an exception, the runtime will select one such exception of its choosing and propagate it out of the call to the `wait` method.  \n  \n After this function returns, the `structured_task_group` object is considered in a final state and should not be used. Note that utilization after the `wait` method returns will result in undefined behavior.  \n  \n In the non-exceptional path of execution, you have a mandate to call either this method or the `run_and_wait` method before the destructor of the `structured_task_group` executes.  \n  \n## See Also  \n [concurrency Namespace](concurrency-namespace.md)   \n [task_group Class](task-group-class.md)   \n [task_handle Class](task-handle-class.md)\n"}