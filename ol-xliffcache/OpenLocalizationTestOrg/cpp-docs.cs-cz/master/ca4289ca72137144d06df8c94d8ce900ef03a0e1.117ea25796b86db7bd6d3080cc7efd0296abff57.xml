{"nodes":[{"pos":[12,44],"content":"deque (STL-CLR) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"deque (STL-CLR) | Microsoft Docs","pos":[0,32]}]},{"content":"deque (STL/CLR)","pos":[680,695]},{"content":"The template class describes an object that controls a varying-length sequence of elements that has random access.","pos":[696,810]},{"content":"You use the container <ph id=\"ph1\">`deque`</ph> to manage a sequence of elements that looks like a contiguous block of storage, but which can grow or shrink at either end without the need to copy any remaining elements.","pos":[811,1012],"source":" You use the container `deque` to manage a sequence of elements that looks like a contiguous block of storage, but which can grow or shrink at either end without the need to copy any remaining elements."},{"content":"Thus it can implement efficiently a <ph id=\"ph1\">`double-ended queue`</ph>.","pos":[1013,1070],"source":" Thus it can implement efficiently a `double-ended queue`."},{"content":"(Hence the name.)","pos":[1071,1088]},{"pos":[1095,1215],"content":"In the description below, <ph id=\"ph1\">`GValue`</ph> is the same as <ph id=\"ph2\">`Value`</ph> unless the latter is a ref type, in which case it is <ph id=\"ph3\">`Value^`</ph>.","source":"In the description below, `GValue` is the same as `Value` unless the latter is a ref type, in which case it is `Value^`."},{"content":"Syntax","pos":[1224,1230]},{"content":"Parameters","pos":[1691,1701]},{"content":"GValue","pos":[1705,1711]},{"content":"The generic type of an element in the controlled sequence.","pos":[1715,1773]},{"content":"Value","pos":[1780,1785]},{"content":"The type of an element in the controlled sequence.","pos":[1789,1839]},{"content":"Members","pos":[1848,1855]},{"content":"Type Definition","pos":[1862,1877]},{"content":"Description","pos":[1878,1889]},{"content":"deque::const_iterator (STL/CLR)","pos":[1939,1970]},{"content":"The type of a constant iterator for the controlled sequence.","pos":[2015,2075]},{"content":"deque::const_reference (STL/CLR)","pos":[2081,2113]},{"content":"The type of a constant reference to an element.","pos":[2159,2206]},{"content":"deque::const_reverse_iterator (STL/CLR)","pos":[2212,2251]},{"content":"The type of a constant reverse iterator for the controlled sequence.","pos":[2304,2372]},{"content":"deque::difference_type (STL/CLR)","pos":[2378,2410]},{"content":"The type of a signed distance between two elements.","pos":[2456,2507]},{"content":"deque::generic_container (STL/CLR)","pos":[2513,2547]},{"content":"The type of the generic interface for the container.","pos":[2595,2647]},{"content":"deque::generic_iterator (STL/CLR)","pos":[2653,2686]},{"content":"The type of an iterator for the generic interface for the container.","pos":[2733,2801]},{"content":"deque::generic_reverse_iterator (STL/CLR)","pos":[2807,2848]},{"content":"The type of a reverse iterator for the generic interface for the container.","pos":[2903,2978]},{"content":"deque::generic_value (STL/CLR)","pos":[2984,3014]},{"content":"The type of an element for the generic interface for the container.","pos":[3058,3125]},{"content":"deque::iterator (STL/CLR)","pos":[3131,3156]},{"content":"The type of an iterator for the controlled sequence.","pos":[3195,3247]},{"content":"deque::reference (STL/CLR)","pos":[3253,3279]},{"content":"The type of a reference to an element.","pos":[3319,3357]},{"content":"deque::reverse_iterator (STL/CLR)","pos":[3363,3396]},{"content":"The type of a reverse iterator for the controlled sequence.","pos":[3443,3502]},{"content":"deque::size_type (STL/CLR)","pos":[3508,3534]},{"content":"The type of a signed distance between two elements.","pos":[3574,3625]},{"content":"deque::value_type (STL/CLR)","pos":[3631,3658]},{"content":"The type of an element.","pos":[3699,3722]},{"content":"Member Function","pos":[3730,3745]},{"content":"Description","pos":[3746,3757]},{"content":"deque::assign (STL/CLR)","pos":[3807,3830]},{"content":"Replaces all elements.","pos":[3867,3889]},{"content":"deque::at (STL/CLR)","pos":[3895,3914]},{"content":"Accesses an element at a specified position.","pos":[3947,3991]},{"content":"deque::back (STL/CLR)","pos":[3997,4018]},{"content":"Accesses the last element.","pos":[4053,4079]},{"content":"deque::begin (STL/CLR)","pos":[4085,4107]},{"content":"Designates the beginning of the controlled sequence.","pos":[4143,4195]},{"content":"deque::clear (STL/CLR)","pos":[4201,4223]},{"content":"Removes all elements.","pos":[4259,4280]},{"content":"deque::deque (STL/CLR)","pos":[4286,4308]},{"content":"Constructs a container object.","pos":[4344,4374]},{"content":"deque::empty (STL/CLR)","pos":[4380,4402]},{"content":"Tests whether no elements are present.","pos":[4438,4476]},{"content":"deque::end (STL/CLR)","pos":[4482,4502]},{"content":"Designates the end of the controlled sequence.","pos":[4536,4582]},{"content":"deque::erase (STL/CLR)","pos":[4588,4610]},{"content":"Removes elements at specified positions.","pos":[4646,4686]},{"content":"deque::front (STL/CLR)","pos":[4692,4714]},{"content":"Accesses the first element.","pos":[4750,4777]},{"content":"deque::insert (STL/CLR)","pos":[4783,4806]},{"content":"Adds elements at a specified position.","pos":[4843,4881]},{"content":"deque::pop_back (STL/CLR)","pos":[4887,4912]},{"content":"Removes the last element.","pos":[4951,4976]},{"content":"deque::pop_front (STL/CLR)","pos":[4982,5008]},{"content":"Removes the first element.","pos":[5048,5074]},{"content":"deque::push_back (STL/CLR)","pos":[5080,5106]},{"content":"Adds a new last element.","pos":[5146,5170]},{"content":"deque::push_front (STL/CLR)","pos":[5176,5203]},{"content":"Adds a new first element.","pos":[5244,5269]},{"content":"deque::rbegin (STL/CLR)","pos":[5275,5298]},{"content":"Designates the beginning of the reversed controlled sequence.","pos":[5335,5396]},{"content":"deque::rend (STL/CLR)","pos":[5402,5423]},{"content":"Designates the end of the reversed controlled sequence.","pos":[5458,5513]},{"content":"deque::resize (STL/CLR)","pos":[5519,5542]},{"content":"Changes the number of elements.","pos":[5579,5610]},{"content":"deque::size (STL/CLR)","pos":[5616,5637]},{"content":"Counts the number of elements.","pos":[5672,5702]},{"content":"deque::swap (STL/CLR)","pos":[5708,5729]},{"content":"Swaps the contents of two containers.","pos":[5764,5801]},{"content":"deque::to_array (STL/CLR)","pos":[5807,5832]},{"content":"Copies the controlled sequence to a new array.","pos":[5871,5917]},{"content":"Property","pos":[5925,5933]},{"content":"Description","pos":[5934,5945]},{"content":"deque::back_item (STL/CLR)","pos":[5988,6014]},{"content":"Accesses the last element.","pos":[6054,6080]},{"content":"deque::front_item (STL/CLR)","pos":[6086,6113]},{"content":"Accesses the first element.","pos":[6154,6181]},{"content":"Operator","pos":[6189,6197]},{"content":"Description","pos":[6198,6209]},{"content":"deque::operator!= (STL/CLR)","pos":[6252,6279]},{"pos":[6329,6377],"content":"Determines if two <ph id=\"ph1\">`deque`</ph> objects are not equal.","source":"Determines if two `deque` objects are not equal."},{"content":"deque::operator(STL/CLR)","pos":[6383,6407]},{"content":"Accesses an element at a specified position.","pos":[6446,6490]},{"content":"operator&lt; (deque) (STL/CLR)","pos":[6496,6523],"source":"operator< (deque) (STL/CLR)"},{"pos":[6572,6639],"content":"Determines if a <ph id=\"ph1\">`deque`</ph> object is less than another <ph id=\"ph2\">`deque`</ph> object.","source":"Determines if a `deque` object is less than another `deque` object."},{"content":"operator&lt;= (deque) (STL/CLR)","pos":[6645,6673],"source":"operator<= (deque) (STL/CLR)"},{"pos":[6726,6805],"content":"Determines if a <ph id=\"ph1\">`deque`</ph> object is less than or equal to another <ph id=\"ph2\">`deque`</ph> object.","source":"Determines if a `deque` object is less than or equal to another `deque` object."},{"content":"operator= (deque) (STL/CLR)","pos":[6811,6838]},{"content":"Replaces the controlled sequence.","pos":[6884,6917]},{"content":"operator== (deque) (STL/CLR)","pos":[6923,6951]},{"pos":[6999,7065],"content":"Determines if a <ph id=\"ph1\">`deque`</ph> object is equal to another <ph id=\"ph2\">`deque`</ph> object.","source":"Determines if a `deque` object is equal to another `deque` object."},{"content":"operator&gt; (deque) (STL/CLR)","pos":[7071,7098],"source":"operator> (deque) (STL/CLR)"},{"pos":[7150,7220],"content":"Determines if a <ph id=\"ph1\">`deque`</ph> object is greater than another <ph id=\"ph2\">`deque`</ph> object.","source":"Determines if a `deque` object is greater than another `deque` object."},{"content":"operator&gt;= (deque) (STL/CLR)","pos":[7226,7254],"source":"operator>= (deque) (STL/CLR)"},{"pos":[7310,7392],"content":"Determines if a <ph id=\"ph1\">`deque`</ph> object is greater than or equal to another <ph id=\"ph2\">`deque`</ph> object.","source":"Determines if a `deque` object is greater than or equal to another `deque` object."},{"content":"Interfaces","pos":[7402,7412]},{"content":"Interface","pos":[7419,7428]},{"content":"Description","pos":[7429,7440]},{"content":"&lt;xref:System.ICloneable&gt;","pos":[7483,7507],"source":"<xref:System.ICloneable>"},{"content":"Duplicate an object.","pos":[7508,7528]},{"content":"&lt;xref:System.Collections.IEnumerable&gt;","pos":[7533,7570],"source":"<xref:System.Collections.IEnumerable>"},{"content":"Sequence through elements.","pos":[7571,7597]},{"content":"&lt;xref:System.Collections.ICollection&gt;","pos":[7602,7639],"source":"<xref:System.Collections.ICollection>"},{"content":"Maintain group of elements.","pos":[7640,7667]},{"content":"&lt;xref:System.Collections.Generic.IEnumerable%601&gt;","pos":[7672,7721],"source":"<xref:System.Collections.Generic.IEnumerable%601>"},{"content":"Sequence through typed elements.","pos":[7722,7754]},{"content":"&lt;xref:System.Collections.Generic.ICollection%601&gt;","pos":[7759,7808],"source":"<xref:System.Collections.Generic.ICollection%601>"},{"content":"Maintain group of typed elements.","pos":[7809,7842]},{"content":"&lt;xref:System.Collections.Generic.IList%601&gt;","pos":[7847,7890],"source":"<xref:System.Collections.Generic.IList%601>"},{"content":"Maintain ordered group of typed elements.","pos":[7891,7932]},{"content":"IDeque&lt;Value","pos":[7937,7949],"source":"IDeque<Value"},{"content":"Maintain generic container.","pos":[7952,7979]},{"content":"Remarks","pos":[7989,7996]},{"content":"The object allocates and frees storage for the sequence it controls through a stored array of handles that designate blocks of <ph id=\"ph1\">`Value`</ph> elements.","pos":[8000,8144],"source":"The object allocates and frees storage for the sequence it controls through a stored array of handles that designate blocks of `Value` elements."},{"content":"The array grows on demand.","pos":[8145,8171]},{"content":"Growth occurs in such a way that the cost of either prepending or appending a new element is constant time, and no remaining elements are disturbed.","pos":[8172,8320]},{"content":"You can also remove an element at either end in constant time, and without disturbing remaining elements.","pos":[8321,8426]},{"content":"Thus, a deque is a good candidate for the underlying container for template class <bpt id=\"p1\">[</bpt>queue (STL/CLR)<ept id=\"p1\">](../dotnet/queue-stl-clr.md)</ept> or template class <bpt id=\"p2\">[</bpt>stack (STL/CLR)<ept id=\"p2\">](../dotnet/stack-stl-clr.md)</ept>.","pos":[8427,8619],"source":" Thus, a deque is a good candidate for the underlying container for template class [queue (STL/CLR)](../dotnet/queue-stl-clr.md) or template class [stack (STL/CLR)](../dotnet/stack-stl-clr.md)."},{"content":"A <ph id=\"ph1\">`deque`</ph> object supports random-access iterators, which means you can refer to an element directly given its numerical position, counting from zero for the first (front) element, to <bpt id=\"p1\">[</bpt>deque::size (STL/CLR)<ept id=\"p1\">](../dotnet/deque-size-stl-clr.md)</ept><ph id=\"ph2\">`() - 1`</ph> for the last (back) element.","pos":[8626,8902],"source":"A `deque` object supports random-access iterators, which means you can refer to an element directly given its numerical position, counting from zero for the first (front) element, to [deque::size (STL/CLR)](../dotnet/deque-size-stl-clr.md)`() - 1` for the last (back) element."},{"content":"It also means that a deque is a good candidate for the underlying container for template class <bpt id=\"p1\">[</bpt>priority_queue (STL/CLR)<ept id=\"p1\">](../dotnet/priority-queue-stl-clr.md)</ept>.","pos":[8903,9062],"source":" It also means that a deque is a good candidate for the underlying container for template class [priority_queue (STL/CLR)](../dotnet/priority-queue-stl-clr.md)."},{"content":"A deque iterator stores a handle to its associated deque object, along with the bias of the element it designates.","pos":[9069,9183]},{"content":"You can use iterators only with their associated container objects.","pos":[9184,9251]},{"content":"The bias of a deque element is <ph id=\"ph1\">`not`</ph> necessarily the same as its position.","pos":[9252,9326],"source":" The bias of a deque element is `not` necessarily the same as its position."},{"content":"The first element inserted has bias zero, the next appended element has bias 1, but the next prepended element has bias -1.","pos":[9327,9450]},{"content":"Inserting or erasing elements at either end does <ph id=\"ph1\">`not`</ph> alter the value of an element stored at any valid bias.","pos":[9457,9567],"source":"Inserting or erasing elements at either end does `not` alter the value of an element stored at any valid bias."},{"content":"Inserting or erasing an interior element, however, <ph id=\"ph1\">`can`</ph> change the element value stored at a given bias, so the value designated by an iterator can also change.","pos":[9568,9729],"source":" Inserting or erasing an interior element, however, `can` change the element value stored at a given bias, so the value designated by an iterator can also change."},{"content":"(The container may have to copy elements up or down to create a hole before an insert or to fill a hole after an erase.) Nevertheless, a deque iterator remains valid so long as its bias designates a valid element.","pos":[9730,9943]},{"content":"Moreover, a valid iterator remains dereferencable -- you can use it to access or alter the element value it designates -- so long as its bias is not equal to the bias for the iterator returned by <ph id=\"ph1\">`end()`</ph>.","pos":[9944,10148],"source":" Moreover, a valid iterator remains dereferencable -- you can use it to access or alter the element value it designates -- so long as its bias is not equal to the bias for the iterator returned by `end()`."},{"content":"Erasing or removing an element calls the destructor for its stored value.","pos":[10155,10228]},{"content":"Destroying the container erases all elements.","pos":[10229,10274]},{"content":"Thus, a container whose element type is a ref class ensures that no elements outlive the container.","pos":[10275,10374]},{"content":"Note, however, that a container of handles does <ph id=\"ph1\">`not`</ph> destroy its elements.","pos":[10375,10450],"source":" Note, however, that a container of handles does `not` destroy its elements."},{"content":"Requirements","pos":[10459,10471]},{"pos":[10475,10502],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>cliext/deque&gt;","source":"**Header:** \\<cliext/deque>"},{"pos":[10509,10530],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> cliext","source":"**Namespace:** cliext"},{"content":"See Also","pos":[10539,10547]},{"content":"list (STL/CLR)","pos":[10552,10566]},{"content":"priority_queue (STL/CLR)","pos":[10600,10624]},{"content":"queue (STL/CLR)","pos":[10668,10683]},{"content":"stack (STL/CLR)","pos":[10718,10733]},{"content":"vector (STL/CLR)","pos":[10768,10784]},{"content":"STL/CLR Library Reference","pos":[10820,10845]}],"content":"---\ntitle: \"deque (STL-CLR) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"cliext::deque\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"deque class [STL/CLR]\"\n  - \"<deque> header [STL/CLR]\"\n  - \"<cliext/deque> header [STL/CLR]\"\nms.assetid: dd669da3-3c0e-45e9-8596-f6b483720941\ncaps.latest.revision: 22\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# deque (STL/CLR)\nThe template class describes an object that controls a varying-length sequence of elements that has random access. You use the container `deque` to manage a sequence of elements that looks like a contiguous block of storage, but which can grow or shrink at either end without the need to copy any remaining elements. Thus it can implement efficiently a `double-ended queue`. (Hence the name.)  \n  \n In the description below, `GValue` is the same as `Value` unless the latter is a ref type, in which case it is `Value^`.  \n  \n## Syntax  \n  \n```  \ntemplate<typename Value>  \n    ref class deque  \n        :   public  \n        System::ICloneable,  \n        System::Collections::IEnumerable,  \n        System::Collections::ICollection,  \n        System::Collections::Generic::IEnumerable<GValue>,  \n        System::Collections::Generic::ICollection<GValue>,  \n        System::Collections::Generic::IList<GValue>,  \n        Microsoft::VisualC::StlClr::IDeque<GValue>  \n    { ..... };  \n```  \n  \n#### Parameters  \n GValue  \n The generic type of an element in the controlled sequence.  \n  \n Value  \n The type of an element in the controlled sequence.  \n  \n## Members  \n  \n|Type Definition|Description|  \n|---------------------|-----------------|  \n|[deque::const_iterator (STL/CLR)](../dotnet/deque-const-iterator-stl-clr.md)|The type of a constant iterator for the controlled sequence.|  \n|[deque::const_reference (STL/CLR)](../dotnet/deque-const-reference-stl-clr.md)|The type of a constant reference to an element.|  \n|[deque::const_reverse_iterator (STL/CLR)](../dotnet/deque-const-reverse-iterator-stl-clr.md)|The type of a constant reverse iterator for the controlled sequence.|  \n|[deque::difference_type (STL/CLR)](../dotnet/deque-difference-type-stl-clr.md)|The type of a signed distance between two elements.|  \n|[deque::generic_container (STL/CLR)](../dotnet/deque-generic-container-stl-clr.md)|The type of the generic interface for the container.|  \n|[deque::generic_iterator (STL/CLR)](../dotnet/deque-generic-iterator-stl-clr.md)|The type of an iterator for the generic interface for the container.|  \n|[deque::generic_reverse_iterator (STL/CLR)](../dotnet/deque-generic-reverse-iterator-stl-clr.md)|The type of a reverse iterator for the generic interface for the container.|  \n|[deque::generic_value (STL/CLR)](../dotnet/deque-generic-value-stl-clr.md)|The type of an element for the generic interface for the container.|  \n|[deque::iterator (STL/CLR)](../dotnet/deque-iterator-stl-clr.md)|The type of an iterator for the controlled sequence.|  \n|[deque::reference (STL/CLR)](../dotnet/deque-reference-stl-clr.md)|The type of a reference to an element.|  \n|[deque::reverse_iterator (STL/CLR)](../dotnet/deque-reverse-iterator-stl-clr.md)|The type of a reverse iterator for the controlled sequence.|  \n|[deque::size_type (STL/CLR)](../dotnet/deque-size-type-stl-clr.md)|The type of a signed distance between two elements.|  \n|[deque::value_type (STL/CLR)](../dotnet/deque-value-type-stl-clr.md)|The type of an element.|  \n  \n|Member Function|Description|  \n|---------------------|-----------------|  \n|[deque::assign (STL/CLR)](../dotnet/deque-assign-stl-clr.md)|Replaces all elements.|  \n|[deque::at (STL/CLR)](../dotnet/deque-at-stl-clr.md)|Accesses an element at a specified position.|  \n|[deque::back (STL/CLR)](../dotnet/deque-back-stl-clr.md)|Accesses the last element.|  \n|[deque::begin (STL/CLR)](../dotnet/deque-begin-stl-clr.md)|Designates the beginning of the controlled sequence.|  \n|[deque::clear (STL/CLR)](../dotnet/deque-clear-stl-clr.md)|Removes all elements.|  \n|[deque::deque (STL/CLR)](../dotnet/deque-deque-stl-clr.md)|Constructs a container object.|  \n|[deque::empty (STL/CLR)](../dotnet/deque-empty-stl-clr.md)|Tests whether no elements are present.|  \n|[deque::end (STL/CLR)](../dotnet/deque-end-stl-clr.md)|Designates the end of the controlled sequence.|  \n|[deque::erase (STL/CLR)](../dotnet/deque-erase-stl-clr.md)|Removes elements at specified positions.|  \n|[deque::front (STL/CLR)](../dotnet/deque-front-stl-clr.md)|Accesses the first element.|  \n|[deque::insert (STL/CLR)](../dotnet/deque-insert-stl-clr.md)|Adds elements at a specified position.|  \n|[deque::pop_back (STL/CLR)](../dotnet/deque-pop-back-stl-clr.md)|Removes the last element.|  \n|[deque::pop_front (STL/CLR)](../dotnet/deque-pop-front-stl-clr.md)|Removes the first element.|  \n|[deque::push_back (STL/CLR)](../dotnet/deque-push-back-stl-clr.md)|Adds a new last element.|  \n|[deque::push_front (STL/CLR)](../dotnet/deque-push-front-stl-clr.md)|Adds a new first element.|  \n|[deque::rbegin (STL/CLR)](../dotnet/deque-rbegin-stl-clr.md)|Designates the beginning of the reversed controlled sequence.|  \n|[deque::rend (STL/CLR)](../dotnet/deque-rend-stl-clr.md)|Designates the end of the reversed controlled sequence.|  \n|[deque::resize (STL/CLR)](../dotnet/deque-resize-stl-clr.md)|Changes the number of elements.|  \n|[deque::size (STL/CLR)](../dotnet/deque-size-stl-clr.md)|Counts the number of elements.|  \n|[deque::swap (STL/CLR)](../dotnet/deque-swap-stl-clr.md)|Swaps the contents of two containers.|  \n|[deque::to_array (STL/CLR)](../dotnet/deque-to-array-stl-clr.md)|Copies the controlled sequence to a new array.|  \n  \n|Property|Description|  \n|--------------|-----------------|  \n|[deque::back_item (STL/CLR)](../dotnet/deque-back-item-stl-clr.md)|Accesses the last element.|  \n|[deque::front_item (STL/CLR)](../dotnet/deque-front-item-stl-clr.md)|Accesses the first element.|  \n  \n|Operator|Description|  \n|--------------|-----------------|  \n|[deque::operator!= (STL/CLR)](../dotnet/deque-operator-inequality-stl-clr.md)|Determines if two `deque` objects are not equal.|  \n|[deque::operator(STL/CLR)](../dotnet/deque-operator-stl-clr.md)|Accesses an element at a specified position.|  \n|[operator< (deque) (STL/CLR)](../dotnet/operator-less-than-deque-stl-clr.md)|Determines if a `deque` object is less than another `deque` object.|  \n|[operator<= (deque) (STL/CLR)](../dotnet/operator-less-or-equal-deque-stl-clr.md)|Determines if a `deque` object is less than or equal to another `deque` object.|  \n|[operator= (deque) (STL/CLR)](../dotnet/operator-assign-deque-stl-clr.md)|Replaces the controlled sequence.|  \n|[operator== (deque) (STL/CLR)](../dotnet/operator-equality-deque-stl-clr.md)|Determines if a `deque` object is equal to another `deque` object.|  \n|[operator> (deque) (STL/CLR)](../dotnet/operator-greater-than-deque-stl-clr.md)|Determines if a `deque` object is greater than another `deque` object.|  \n|[operator>= (deque) (STL/CLR)](../dotnet/operator-greater-or-equal-deque-stl-clr.md)|Determines if a `deque` object is greater than or equal to another `deque` object.|  \n  \n## Interfaces  \n  \n|Interface|Description|  \n|---------------|-----------------|  \n|<xref:System.ICloneable>|Duplicate an object.|  \n|<xref:System.Collections.IEnumerable>|Sequence through elements.|  \n|<xref:System.Collections.ICollection>|Maintain group of elements.|  \n|<xref:System.Collections.Generic.IEnumerable%601>|Sequence through typed elements.|  \n|<xref:System.Collections.Generic.ICollection%601>|Maintain group of typed elements.|  \n|<xref:System.Collections.Generic.IList%601>|Maintain ordered group of typed elements.|  \n|IDeque<Value\\>|Maintain generic container.|  \n  \n## Remarks  \n The object allocates and frees storage for the sequence it controls through a stored array of handles that designate blocks of `Value` elements. The array grows on demand. Growth occurs in such a way that the cost of either prepending or appending a new element is constant time, and no remaining elements are disturbed. You can also remove an element at either end in constant time, and without disturbing remaining elements. Thus, a deque is a good candidate for the underlying container for template class [queue (STL/CLR)](../dotnet/queue-stl-clr.md) or template class [stack (STL/CLR)](../dotnet/stack-stl-clr.md).  \n  \n A `deque` object supports random-access iterators, which means you can refer to an element directly given its numerical position, counting from zero for the first (front) element, to [deque::size (STL/CLR)](../dotnet/deque-size-stl-clr.md)`() - 1` for the last (back) element. It also means that a deque is a good candidate for the underlying container for template class [priority_queue (STL/CLR)](../dotnet/priority-queue-stl-clr.md).  \n  \n A deque iterator stores a handle to its associated deque object, along with the bias of the element it designates. You can use iterators only with their associated container objects. The bias of a deque element is `not` necessarily the same as its position. The first element inserted has bias zero, the next appended element has bias 1, but the next prepended element has bias -1.  \n  \n Inserting or erasing elements at either end does `not` alter the value of an element stored at any valid bias. Inserting or erasing an interior element, however, `can` change the element value stored at a given bias, so the value designated by an iterator can also change. (The container may have to copy elements up or down to create a hole before an insert or to fill a hole after an erase.) Nevertheless, a deque iterator remains valid so long as its bias designates a valid element. Moreover, a valid iterator remains dereferencable -- you can use it to access or alter the element value it designates -- so long as its bias is not equal to the bias for the iterator returned by `end()`.  \n  \n Erasing or removing an element calls the destructor for its stored value. Destroying the container erases all elements. Thus, a container whose element type is a ref class ensures that no elements outlive the container. Note, however, that a container of handles does `not` destroy its elements.  \n  \n## Requirements  \n **Header:** \\<cliext/deque>  \n  \n **Namespace:** cliext  \n  \n## See Also  \n [list (STL/CLR)](../dotnet/list-stl-clr.md)   \n [priority_queue (STL/CLR)](../dotnet/priority-queue-stl-clr.md)   \n [queue (STL/CLR)](../dotnet/queue-stl-clr.md)   \n [stack (STL/CLR)](../dotnet/stack-stl-clr.md)   \n [vector (STL/CLR)](../dotnet/vector-stl-clr.md)   \n [STL/CLR Library Reference](../dotnet/stl-clr-library-reference.md)"}