{"nodes":[{"pos":[12,56],"content":"-GS (Buffer Security Check) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"-GS (Buffer Security Check) | Microsoft Docs","pos":[0,44]}]},{"content":"/GS (Buffer Security Check)","pos":[977,1004]},{"content":"Detects some buffer overruns that overwrite a function's return address, exception handler address, or certain types of parameters.","pos":[1005,1136]},{"content":"Causing a buffer overrun is a technique used by hackers to exploit code that does not enforce buffer size restrictions.","pos":[1137,1256]},{"content":"Syntax","pos":[1265,1271]},{"content":"Remarks","pos":[1304,1311]},{"content":"<bpt id=\"p1\">**</bpt>/GS<ept id=\"p1\">**</ept> is on by default.","pos":[1315,1340],"source":"**/GS** is on by default."},{"content":"If you expect your application to have no security exposure, use <bpt id=\"p1\">**</bpt>/GS-<ept id=\"p1\">**</ept>.","pos":[1341,1415],"source":" If you expect your application to have no security exposure, use **/GS-**."},{"content":"For more information about <bpt id=\"p1\">**</bpt>/GS<ept id=\"p1\">**</ept>, see <bpt id=\"p2\">[</bpt>Compiler Security Checks In Depth<ept id=\"p2\">](http://go.microsoft.com/fwlink/?linkid=7260)</ept>.","pos":[1416,1537],"source":" For more information about **/GS**, see [Compiler Security Checks In Depth](http://go.microsoft.com/fwlink/?linkid=7260)."},{"content":"For more information about suppressing buffer overrun detection, see <bpt id=\"p1\">[</bpt>safebuffers<ept id=\"p1\">](../../cpp/safebuffers.md)</ept>.","pos":[1538,1647],"source":" For more information about suppressing buffer overrun detection, see [safebuffers](../../cpp/safebuffers.md)."},{"content":"Security Checks","pos":[1656,1671]},{"content":"On functions that the compiler recognizes as subject to buffer overrun problems, the compiler allocates space on the stack before the return address.","pos":[1675,1824]},{"content":"On function entry, the allocated space is loaded with a <bpt id=\"p1\">*</bpt>security cookie<ept id=\"p1\">*</ept> that is computed once at module load.","pos":[1825,1936],"source":" On function entry, the allocated space is loaded with a *security cookie* that is computed once at module load."},{"content":"On function exit, and during frame unwinding on 64-bit operating systems, a helper function is called to make sure that the value of the cookie is still the same.","pos":[1937,2099]},{"content":"A different value indicates that an overwrite of the stack may have occurred.","pos":[2100,2177]},{"content":"If a different value is detected, the process is terminated.","pos":[2178,2238]},{"content":"GS Buffers","pos":[2247,2257]},{"content":"A buffer overrun security check is performed on a <bpt id=\"p1\">*</bpt>GS buffer<ept id=\"p1\">*</ept>.","pos":[2261,2323],"source":"A buffer overrun security check is performed on a *GS buffer*."},{"content":"A GS buffer can be one of these:","pos":[2324,2356]},{"content":"An array that is larger than 4 bytes, has more than two elements, and has an element type that is not a pointer type.","pos":[2366,2483]},{"content":"A data structure whose size is more than 8 bytes and contains no pointers.","pos":[2493,2567]},{"pos":[2577,2673],"content":"A buffer allocated by using the <bpt id=\"p1\">[</bpt>_alloca<ept id=\"p1\">](../../c-runtime-library/reference/alloca.md)</ept> function.","source":"A buffer allocated by using the [_alloca](../../c-runtime-library/reference/alloca.md) function."},{"content":"Any class or structure that contains a GS buffer.","pos":[2683,2732]},{"content":"For example, the following statements declare GS buffers.","pos":[2739,2796]},{"content":"However, the following statements do not declare GS buffers.","pos":[2941,3001]},{"content":"The first two declarations contain elements of pointer type.","pos":[3002,3062]},{"content":"The third and fourth statements declare arrays whose size is too small.","pos":[3063,3134]},{"content":"The fifth statement declares a structure whose size on an x86 platform is not more than 8 bytes.","pos":[3135,3231]},{"content":"Initialize the Security Cookie","pos":[3346,3376]},{"content":"The <bpt id=\"p1\">**</bpt>/GS<ept id=\"p1\">**</ept> compiler option requires that the security cookie be initialized before any function that uses the cookie is run.","pos":[3380,3505],"source":"The **/GS** compiler option requires that the security cookie be initialized before any function that uses the cookie is run."},{"content":"The security cookie must be initialized on entry to an EXE or DLL.","pos":[3506,3572]},{"content":"This is done automatically if you use the default CRT entry points (mainCRTStartup, wmainCRTStartup, WinMainCRTStartup, wWinMainCRTStartup, or _DllMainCRTStartup).","pos":[3573,3736]},{"content":"If you use an alternate entry point, you must manually initialize the security cookie by calling <bpt id=\"p1\">[</bpt>__security_init_cookie<ept id=\"p1\">](../../c-runtime-library/reference/security-init-cookie.md)</ept>.","pos":[3737,3918],"source":" If you use an alternate entry point, you must manually initialize the security cookie by calling [__security_init_cookie](../../c-runtime-library/reference/security-init-cookie.md)."},{"content":"What Is Protected","pos":[3927,3944]},{"pos":[3948,4005],"content":"The <bpt id=\"p1\">**</bpt>/GS<ept id=\"p1\">**</ept> compiler option protects the following items:","source":"The **/GS** compiler option protects the following items:"},{"content":"The return address of a function call.","pos":[4015,4053]},{"content":"The address of an exception handler for a function.","pos":[4063,4114]},{"content":"Vulnerable function parameters.","pos":[4124,4155]},{"content":"On all platforms, <bpt id=\"p1\">**</bpt>/GS<ept id=\"p1\">**</ept> attempts to detect buffer overruns into the return address.","pos":[4162,4247],"source":"On all platforms, **/GS** attempts to detect buffer overruns into the return address."},{"content":"Buffer overruns are more easily exploited on platforms such as x86 and x64, which use calling conventions that store the return address of a function call on the stack.","pos":[4248,4416]},{"content":"On x86, if a function uses an exception handler, the compiler injects a security cookie to protect the address of the exception handler.","pos":[4423,4559]},{"content":"The cookie is checked during frame unwinding.","pos":[4560,4605]},{"content":"<bpt id=\"p1\">**</bpt>/GS<ept id=\"p1\">**</ept> protects <bpt id=\"p2\">*</bpt>vulnerable parameters<ept id=\"p2\">*</ept> that are passed into a function.","pos":[4612,4685],"source":"**/GS** protects *vulnerable parameters* that are passed into a function."},{"content":"A vulnerable parameter is a pointer, a C++ reference, a C-structure (C++ POD type) that contains a pointer, or a GS buffer.","pos":[4686,4809]},{"content":"A vulnerable parameter is allocated before the cookie and local variables.","pos":[4816,4890]},{"content":"A buffer overrun can overwrite these parameters.","pos":[4891,4939]},{"content":"And code in the function that uses these parameters could cause an attack before the function returns and the security check is performed.","pos":[4940,5078]},{"content":"To minimize this danger, the compiler makes a copy of the vulnerable parameters during the function prolog and puts them below the storage area for any buffers.","pos":[5079,5239]},{"content":"The compiler does not make copies of vulnerable parameters in the following situations:","pos":[5246,5333]},{"content":"Functions that do not contain a GS buffer.","pos":[5343,5385]},{"pos":[5395,5490],"content":"Optimizations (<bpt id=\"p1\">[</bpt>/O options<ept id=\"p1\">](../../build/reference/o-options-optimize-code.md)</ept>) are not enabled.","source":"Optimizations ([/O options](../../build/reference/o-options-optimize-code.md)) are not enabled."},{"content":"Functions that have a variable argument list (...).","pos":[5500,5551]},{"pos":[5561,5624],"content":"Functions that are marked with <bpt id=\"p1\">[</bpt>naked<ept id=\"p1\">](../../cpp/naked-cpp.md)</ept>.","source":"Functions that are marked with [naked](../../cpp/naked-cpp.md)."},{"content":"Functions that contain inline assembly code in the first statement.","pos":[5634,5701]},{"content":"A parameter is used only in ways that are less likely to be exploitable in the event of a buffer overrun.","pos":[5711,5816]},{"content":"What Is Not Protected","pos":[5825,5846]},{"content":"The <bpt id=\"p1\">**</bpt>/GS<ept id=\"p1\">**</ept> compiler option does not protect against all buffer overrun security attacks.","pos":[5850,5939],"source":"The **/GS** compiler option does not protect against all buffer overrun security attacks."},{"content":"For example, if you have a buffer and a vtable in an object, a buffer overrun could corrupt the vtable.","pos":[5940,6043]},{"pos":[6050,6135],"content":"Even if you use <bpt id=\"p1\">**</bpt>/GS<ept id=\"p1\">**</ept>, always try to write secure code that has no buffer overruns.","source":"Even if you use **/GS**, always try to write secure code that has no buffer overruns."},{"content":"To set this compiler option in Visual Studio","pos":[6146,6190]},{"pos":[6200,6280],"content":"In <bpt id=\"p1\">**</bpt>Solution Explorer<ept id=\"p1\">**</ept>, right-click the project and then click <bpt id=\"p2\">**</bpt>Properties<ept id=\"p2\">**</ept>.","source":"In **Solution Explorer**, right-click the project and then click **Properties**."},{"pos":[6291,6397],"content":"For more information, see <bpt id=\"p1\">[</bpt>Working with Project Properties<ept id=\"p1\">](../../ide/working-with-project-properties.md)</ept>.","source":"For more information, see [Working with Project Properties](../../ide/working-with-project-properties.md)."},{"pos":[6407,6472],"content":"In the <bpt id=\"p1\">**</bpt>Property Pages<ept id=\"p1\">**</ept> dialog box, click the <bpt id=\"p2\">**</bpt>C/C++<ept id=\"p2\">**</ept> folder.","source":"In the **Property Pages** dialog box, click the **C/C++** folder."},{"pos":[6482,6526],"content":"Click the <bpt id=\"p1\">**</bpt>Code Generation<ept id=\"p1\">**</ept> property page.","source":"Click the **Code Generation** property page."},{"pos":[6536,6582],"content":"Modify the <bpt id=\"p1\">**</bpt>Buffer Security Check<ept id=\"p1\">**</ept> property.","source":"Modify the **Buffer Security Check** property."},{"content":"To set this compiler option programmatically","pos":[6593,6637]},{"content":"See &lt;xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.BufferSecurityCheck%2A&gt;.","pos":[6647,6737],"source":"See <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.BufferSecurityCheck%2A>."},{"content":"Example","pos":[6746,6753]},{"content":"This sample overruns a buffer.","pos":[6757,6787]},{"content":"This causes the application to fail at runtime.","pos":[6788,6835]},{"content":"See Also","pos":[7477,7485]},{"content":"Compiler Options","pos":[7490,7506]},{"content":"Setting Compiler Options","pos":[7556,7580]}],"content":"---\ntitle: \"-GS (Buffer Security Check) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"VC.Project.VCCLWCECompilerTool.BufferSecurityCheck\"\n  - \"VC.Project.VCCLCompilerTool.BufferSecurityCheck\"\n  - \"/GS\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"buffers [C++], buffer overruns\"\n  - \"buffer overruns, compiler /GS switch\"\n  - \"GS compiler option [C++]\"\n  - \"/GS compiler option [C++]\"\n  - \"security check compiler option [C++]\"\n  - \"-GS compiler option [C++]\"\n  - \"buffers [C++], avoiding overruns\"\nms.assetid: 8d8a5ea1-cd5e-42e1-bc36-66e1cd7e731e\ncaps.latest.revision: 40\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# /GS (Buffer Security Check)\nDetects some buffer overruns that overwrite a function's return address, exception handler address, or certain types of parameters. Causing a buffer overrun is a technique used by hackers to exploit code that does not enforce buffer size restrictions.  \n  \n## Syntax  \n  \n```  \n/GS[-]  \n```  \n  \n## Remarks  \n **/GS** is on by default. If you expect your application to have no security exposure, use **/GS-**. For more information about **/GS**, see [Compiler Security Checks In Depth](http://go.microsoft.com/fwlink/?linkid=7260). For more information about suppressing buffer overrun detection, see [safebuffers](../../cpp/safebuffers.md).  \n  \n## Security Checks  \n On functions that the compiler recognizes as subject to buffer overrun problems, the compiler allocates space on the stack before the return address. On function entry, the allocated space is loaded with a *security cookie* that is computed once at module load. On function exit, and during frame unwinding on 64-bit operating systems, a helper function is called to make sure that the value of the cookie is still the same. A different value indicates that an overwrite of the stack may have occurred. If a different value is detected, the process is terminated.  \n  \n## GS Buffers  \n A buffer overrun security check is performed on a *GS buffer*. A GS buffer can be one of these:  \n  \n-   An array that is larger than 4 bytes, has more than two elements, and has an element type that is not a pointer type.  \n  \n-   A data structure whose size is more than 8 bytes and contains no pointers.  \n  \n-   A buffer allocated by using the [_alloca](../../c-runtime-library/reference/alloca.md) function.  \n  \n-   Any class or structure that contains a GS buffer.  \n  \n For example, the following statements declare GS buffers.  \n  \n```  \nchar buffer[20];  \nint buffer[20];  \nstruct { int a; int b; int c; int d; } myStruct;  \nstruct { int a; char buf[20]; };  \n```  \n  \n However, the following statements do not declare GS buffers. The first two declarations contain elements of pointer type. The third and fourth statements declare arrays whose size is too small. The fifth statement declares a structure whose size on an x86 platform is not more than 8 bytes.  \n  \n```  \nchar *pBuf[20];  \nvoid *pv[20];  \nchar buf[4];  \nint buf[2];  \nstruct { int a; int b; };  \n```  \n  \n## Initialize the Security Cookie  \n The **/GS** compiler option requires that the security cookie be initialized before any function that uses the cookie is run. The security cookie must be initialized on entry to an EXE or DLL. This is done automatically if you use the default CRT entry points (mainCRTStartup, wmainCRTStartup, WinMainCRTStartup, wWinMainCRTStartup, or _DllMainCRTStartup). If you use an alternate entry point, you must manually initialize the security cookie by calling [__security_init_cookie](../../c-runtime-library/reference/security-init-cookie.md).  \n  \n## What Is Protected  \n The **/GS** compiler option protects the following items:  \n  \n-   The return address of a function call.  \n  \n-   The address of an exception handler for a function.  \n  \n-   Vulnerable function parameters.  \n  \n On all platforms, **/GS** attempts to detect buffer overruns into the return address. Buffer overruns are more easily exploited on platforms such as x86 and x64, which use calling conventions that store the return address of a function call on the stack.  \n  \n On x86, if a function uses an exception handler, the compiler injects a security cookie to protect the address of the exception handler. The cookie is checked during frame unwinding.  \n  \n **/GS** protects *vulnerable parameters* that are passed into a function. A vulnerable parameter is a pointer, a C++ reference, a C-structure (C++ POD type) that contains a pointer, or a GS buffer.  \n  \n A vulnerable parameter is allocated before the cookie and local variables. A buffer overrun can overwrite these parameters. And code in the function that uses these parameters could cause an attack before the function returns and the security check is performed. To minimize this danger, the compiler makes a copy of the vulnerable parameters during the function prolog and puts them below the storage area for any buffers.  \n  \n The compiler does not make copies of vulnerable parameters in the following situations:  \n  \n-   Functions that do not contain a GS buffer.  \n  \n-   Optimizations ([/O options](../../build/reference/o-options-optimize-code.md)) are not enabled.  \n  \n-   Functions that have a variable argument list (...).  \n  \n-   Functions that are marked with [naked](../../cpp/naked-cpp.md).  \n  \n-   Functions that contain inline assembly code in the first statement.  \n  \n-   A parameter is used only in ways that are less likely to be exploitable in the event of a buffer overrun.  \n  \n## What Is Not Protected  \n The **/GS** compiler option does not protect against all buffer overrun security attacks. For example, if you have a buffer and a vtable in an object, a buffer overrun could corrupt the vtable.  \n  \n Even if you use **/GS**, always try to write secure code that has no buffer overruns.  \n  \n#### To set this compiler option in Visual Studio  \n  \n1.  In **Solution Explorer**, right-click the project and then click **Properties**.  \n  \n     For more information, see [Working with Project Properties](../../ide/working-with-project-properties.md).  \n  \n2.  In the **Property Pages** dialog box, click the **C/C++** folder.  \n  \n3.  Click the **Code Generation** property page.  \n  \n4.  Modify the **Buffer Security Check** property.  \n  \n#### To set this compiler option programmatically  \n  \n-   See <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.BufferSecurityCheck%2A>.  \n  \n## Example  \n This sample overruns a buffer. This causes the application to fail at runtime.  \n  \n```  \n// compile with: /c /W1  \n#include <cstring>  \n#include <stdlib.h>  \n#pragma warning(disable : 4996)   // for strcpy use  \n  \n// Vulnerable function  \nvoid vulnerable(const char *str) {  \n   char buffer[10];  \n   strcpy(buffer, str); // overrun buffer !!!  \n  \n   // use a secure CRT function to help prevent buffer overruns  \n   // truncate string to fit a 10 byte buffer  \n   // strncpy_s(buffer, _countof(buffer), str, _TRUNCATE);  \n}  \n  \nint main() {  \n   // declare buffer that is bigger than expected  \n   char large_buffer[] = \"This string is longer than 10 characters!!\";  \n   vulnerable(large_buffer);  \n}  \n```  \n  \n## See Also  \n [Compiler Options](../../build/reference/compiler-options.md)   \n [Setting Compiler Options](../../build/reference/setting-compiler-options.md)"}