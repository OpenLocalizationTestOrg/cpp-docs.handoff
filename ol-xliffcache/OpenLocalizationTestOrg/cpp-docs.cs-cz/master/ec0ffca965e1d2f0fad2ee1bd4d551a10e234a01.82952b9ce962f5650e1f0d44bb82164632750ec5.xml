{"nodes":[{"pos":[12,37],"content":"_lfind_s | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_lfind_s | Microsoft Docs","pos":[0,25]}]},{"pos":[1055,1063],"content":"_lfind_s","linkify":"_lfind_s","nodes":[{"content":"_lfind_s","pos":[0,8]}]},{"content":"Performs a linear search for the specified key.","pos":[1064,1111]},{"content":"A version of <bpt id=\"p1\">[</bpt>_lfind<ept id=\"p1\">](../../c-runtime-library/reference/lfind.md)</ept> with security enhancements as described in <bpt id=\"p2\">[</bpt>Security Features in the CRT<ept id=\"p2\">](../../c-runtime-library/security-features-in-the-crt.md)</ept>.","pos":[1112,1309],"source":" A version of [_lfind](../../c-runtime-library/reference/lfind.md) with security enhancements as described in [Security Features in the CRT](../../c-runtime-library/security-features-in-the-crt.md)."},{"pos":[1318,1324],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1545,1555],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Object to search for.","pos":[1568,1589]},{"content":"Pointer to the base of search data.","pos":[1606,1641]},{"content":"Number of array elements.","pos":[1657,1682]},{"content":"Size of array elements in bytes.","pos":[1699,1731]},{"content":"Pointer to comparison routine.","pos":[1751,1781]},{"content":"The first parameter is the <ph id=\"ph1\">`context`</ph> pointer.","pos":[1782,1827],"source":" The first parameter is the `context` pointer."},{"content":"The second parameter is a pointer to key for search.","pos":[1828,1880]},{"content":"The third parameter is a pointer to array element to be compared with key.","pos":[1881,1955]},{"content":"A pointer to an object that might be accessed in the comparison function.","pos":[1975,2048]},{"pos":[2057,2069],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"If the key is found, <ph id=\"ph1\">`_lfind_s`</ph> returns a pointer to the element of the array at <ph id=\"ph2\">`base`</ph> that matches <ph id=\"ph3\">`key`</ph>.","pos":[2073,2180],"source":"If the key is found, `_lfind_s` returns a pointer to the element of the array at `base` that matches `key`."},{"content":"If the key is not found, <ph id=\"ph1\">`_lfind_s`</ph> returns <ph id=\"ph2\">`NULL`</ph>.","pos":[2181,2232],"source":" If the key is not found, `_lfind_s` returns `NULL`."},{"content":"If invalid parameters are passed to the function, the invalid parameter handler is invoked, as described in <bpt id=\"p1\">[</bpt>Parameter Validation<ept id=\"p1\">](../../c-runtime-library/parameter-validation.md)</ept>.","pos":[2239,2419],"source":"If invalid parameters are passed to the function, the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md)."},{"content":"If execution is allowed to continue, <ph id=\"ph1\">`errno`</ph> is set to <ph id=\"ph2\">`EINVAL`</ph> and the function returns <ph id=\"ph3\">`NULL`</ph>.","pos":[2420,2516],"source":" If execution is allowed to continue, `errno` is set to `EINVAL` and the function returns `NULL`."},{"pos":[2526,2542],"content":"Error Conditions","linkify":"Error Conditions","nodes":[{"content":"Error Conditions","pos":[0,16]}]},{"content":"key","pos":[2549,2552]},{"content":"base","pos":[2553,2557]},{"content":"compare","pos":[2558,2565]},{"content":"num","pos":[2566,2569]},{"content":"size","pos":[2570,2574]},{"content":"errno","pos":[2575,2580]},{"content":"any","pos":[2664,2667]},{"content":"any","pos":[2668,2671]},{"content":"any","pos":[2672,2675]},{"content":"any","pos":[2676,2679]},{"content":"any","pos":[2693,2696]},{"content":"any","pos":[2704,2707]},{"content":"!= 0","pos":[2708,2712]},{"content":"any","pos":[2713,2716]},{"content":"any","pos":[2730,2733]},{"content":"any","pos":[2734,2737]},{"content":"any","pos":[2738,2741]},{"content":"any","pos":[2742,2745]},{"content":"zero","pos":[2746,2750]},{"content":"any","pos":[2764,2767]},{"content":"any","pos":[2768,2771]},{"content":"an","pos":[2779,2781]},{"content":"any","pos":[2782,2785]},{"pos":[2804,2811],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`_lfind_s`</ph> function performs a linear search for the value <ph id=\"ph2\">`key`</ph> in an array of <ph id=\"ph3\">`num`</ph> elements, each of <ph id=\"ph4\">`width`</ph> bytes.","pos":[2815,2937],"source":"The `_lfind_s` function performs a linear search for the value `key` in an array of `num` elements, each of `width` bytes."},{"content":"Unlike <ph id=\"ph1\">`bsearch_s`</ph>, <ph id=\"ph2\">`_lfind_s`</ph> does not require the array to be sorted.","pos":[2938,3009],"source":" Unlike `bsearch_s`, `_lfind_s` does not require the array to be sorted."},{"content":"The <ph id=\"ph1\">`base`</ph> argument is a pointer to the base of the array to be searched.","pos":[3010,3083],"source":" The `base` argument is a pointer to the base of the array to be searched."},{"content":"The <ph id=\"ph1\">`compare`</ph> argument is a pointer to a user-supplied routine that compares two array elements and then returns a value specifying their relationship.","pos":[3084,3235],"source":" The `compare` argument is a pointer to a user-supplied routine that compares two array elements and then returns a value specifying their relationship."},{"content":"<ph id=\"ph1\">`_lfind_s`</ph> calls the <ph id=\"ph2\">`compare`</ph> routine one or more times during the search, passing the <ph id=\"ph3\">`context`</ph> pointer and pointers to two array elements on each call.","pos":[3236,3390],"source":"`_lfind_s` calls the `compare` routine one or more times during the search, passing the `context` pointer and pointers to two array elements on each call."},{"content":"The <ph id=\"ph1\">`compare`</ph> routine must compare the elements then return nonzero (meaning that the elements are different) or 0 (meaning the elements are identical).","pos":[3391,3543],"source":" The `compare` routine must compare the elements then return nonzero (meaning that the elements are different) or 0 (meaning the elements are identical)."},{"content":"<ph id=\"ph1\">`_lfind_s`</ph> is similar to <ph id=\"ph2\">`_lfind`</ph> except for the addition of the <ph id=\"ph3\">`context`</ph> pointer to the arguments of the comparison function and the parameter list of the function.","pos":[3550,3716],"source":"`_lfind_s` is similar to `_lfind` except for the addition of the `context` pointer to the arguments of the comparison function and the parameter list of the function."},{"content":"The <ph id=\"ph1\">`context`</ph> pointer can be useful if the searched data structure is part of an object and the <ph id=\"ph2\">`compare`</ph> function needs to access members of the object.","pos":[3717,3870],"source":" The `context` pointer can be useful if the searched data structure is part of an object and the `compare` function needs to access members of the object."},{"content":"The <ph id=\"ph1\">`compare`</ph> function can cast the void pointer into the appropriate object type and access members of that object.","pos":[3871,3987],"source":" The `compare` function can cast the void pointer into the appropriate object type and access members of that object."},{"content":"The addition of the <ph id=\"ph1\">`context`</ph> parameter makes <ph id=\"ph2\">`_lfind_s`</ph> more secure because additional context can be used to avoid reentrancy bugs associated with using static variables to make data available to the <ph id=\"ph3\">`compare`</ph> function.","pos":[3988,4209],"source":" The addition of the `context` parameter makes `_lfind_s` more secure because additional context can be used to avoid reentrancy bugs associated with using static variables to make data available to the `compare` function."},{"pos":[4218,4230],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[4237,4244]},{"content":"Required header","pos":[4245,4260]},{"content":"<ph id=\"ph1\">\\&lt;</ph>search.h&gt;","pos":[4316,4327],"source":"\\<search.h>"},{"pos":[4335,4453],"content":"For more compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept> in the Introduction.","source":"For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction."},{"pos":[4462,4469],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6664,6689],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"&lt;xref:System.Collections.ArrayList.Contains%2A&gt;","pos":[6693,6740],"source":"<xref:System.Collections.ArrayList.Contains%2A>"},{"pos":[6749,6757],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Searching and Sorting<ept id=\"p1\">](../../c-runtime-library/searching-and-sorting.md)</ept><ph id=\"ph1\"> </ph>","pos":[6761,6835],"source":"[Searching and Sorting](../../c-runtime-library/searching-and-sorting.md) "},{"content":"<bpt id=\"p1\"> [</bpt>bsearch_s<ept id=\"p1\">](../../c-runtime-library/reference/bsearch-s.md)</ept><ph id=\"ph1\"> </ph>","pos":[6838,6899],"source":" [bsearch_s](../../c-runtime-library/reference/bsearch-s.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_lsearch_s<ept id=\"p1\">](../../c-runtime-library/reference/lsearch-s.md)</ept><ph id=\"ph1\"> </ph>","pos":[6902,6964],"source":" [_lsearch_s](../../c-runtime-library/reference/lsearch-s.md) "},{"content":"<bpt id=\"p1\"> [</bpt>qsort_s<ept id=\"p1\">](../../c-runtime-library/reference/qsort-s.md)</ept><ph id=\"ph1\"> </ph>","pos":[6967,7024],"source":" [qsort_s](../../c-runtime-library/reference/qsort-s.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_lfind<ept id=\"p1\">](../../c-runtime-library/reference/lfind.md)</ept>","pos":[7027,7080],"source":" [_lfind](../../c-runtime-library/reference/lfind.md)"}],"content":"---\ntitle: \"_lfind_s | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_lfind_s\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\n  - \"api-ms-win-crt-utility-l1-1-0.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"lfind_s\"\n  - \"_lfind_s\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"linear searching\"\n  - \"keys, finding in arrays\"\n  - \"lfind_s function\"\n  - \"arrays [CRT], searching\"\n  - \"searching, linear\"\n  - \"_lfind_s function\"\nms.assetid: f1d9581d-5c9d-4222-a31c-a6dfafefa40d\ncaps.latest.revision: 26\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _lfind_s\nPerforms a linear search for the specified key. A version of [_lfind](../../c-runtime-library/reference/lfind.md) with security enhancements as described in [Security Features in the CRT](../../c-runtime-library/security-features-in-the-crt.md).  \n  \n## Syntax  \n  \n```  \nvoid *_lfind_s(  \n   const void *key,  \n   const void *base,  \n   unsigned int *num,  \n   size_t size,  \n   int (__cdecl *compare)(void *, const void *, const void *),  \n   void * context  \n);  \n```  \n  \n#### Parameters  \n `key`  \n Object to search for.  \n  \n `base`  \n Pointer to the base of search data.  \n  \n `num`  \n Number of array elements.  \n  \n `size`  \n Size of array elements in bytes.  \n  \n `compare`  \n Pointer to comparison routine. The first parameter is the `context` pointer. The second parameter is a pointer to key for search. The third parameter is a pointer to array element to be compared with key.  \n  \n `context`  \n A pointer to an object that might be accessed in the comparison function.  \n  \n## Return Value  \n If the key is found, `_lfind_s` returns a pointer to the element of the array at `base` that matches `key`. If the key is not found, `_lfind_s` returns `NULL`.  \n  \n If invalid parameters are passed to the function, the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md). If execution is allowed to continue, `errno` is set to `EINVAL` and the function returns `NULL`.  \n  \n### Error Conditions  \n  \n|key|base|compare|num|size|errno|  \n|---------|----------|-------------|---------|----------|-----------|  \n|`NULL`|any|any|any|any|`EINVAL`|  \n|any|`NULL`|any|!= 0|any|`EINVAL`|  \n|any|any|any|any|zero|`EINVAL`|  \n|any|any|`NULL`|an|any|`EINVAL`|  \n  \n## Remarks  \n The `_lfind_s` function performs a linear search for the value `key` in an array of `num` elements, each of `width` bytes. Unlike `bsearch_s`, `_lfind_s` does not require the array to be sorted. The `base` argument is a pointer to the base of the array to be searched. The `compare` argument is a pointer to a user-supplied routine that compares two array elements and then returns a value specifying their relationship. `_lfind_s` calls the `compare` routine one or more times during the search, passing the `context` pointer and pointers to two array elements on each call. The `compare` routine must compare the elements then return nonzero (meaning that the elements are different) or 0 (meaning the elements are identical).  \n  \n `_lfind_s` is similar to `_lfind` except for the addition of the `context` pointer to the arguments of the comparison function and the parameter list of the function. The `context` pointer can be useful if the searched data structure is part of an object and the `compare` function needs to access members of the object. The `compare` function can cast the void pointer into the appropriate object type and access members of that object. The addition of the `context` parameter makes `_lfind_s` more secure because additional context can be used to avoid reentrancy bugs associated with using static variables to make data available to the `compare` function.  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`_lfind_s`|\\<search.h>|  \n  \n For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction.  \n  \n## Example  \n  \n```  \n// crt_lfind_s.cpp  \n// This program uses _lfind_s to search a string array,  \n// passing a locale as the context.  \n// compile with: /EHsc  \n#include <stdlib.h>  \n#include <stdio.h>  \n#include <search.h>  \n#include <process.h>  \n#include <locale.h>  \n#include <locale>  \n#include <windows.h>  \nusing namespace std;  \n  \n// The sort order is dependent on the code page.  Use 'chcp' at the  \n// command line to change the codepage.  When executing this application,  \n// the command prompt codepage must match the codepage used here:  \n  \n#define CODEPAGE_850  \n  \n#ifdef CODEPAGE_850  \n// Codepage 850 is the OEM codepage used by the command line,  \n// so \\x00e1 is the German Sharp S  \n  \nchar *array1[] = { \"wei\\x00e1\", \"weis\", \"annehmen\", \"weizen\", \"Zeit\",  \n                   \"weit\" };  \n  \n#define GERMAN_LOCALE \"German_Germany.850\"  \n  \n#endif  \n  \n#ifdef CODEPAGE_1252  \n   // If using codepage 1252 (ISO 8859-1, Latin-1), use \\x00df  \n   // for the German Sharp S  \nchar *array1[] = { \"wei\\x00df\", \"weis\", \"annehmen\", \"weizen\", \"Zeit\",  \n                   \"weit\" };  \n  \n#define GERMAN_LOCALE \"German_Germany.1252\"  \n  \n#endif  \n  \n// The context parameter lets you create a more generic compare.  \n// Without this parameter, you would have stored the locale in a  \n// static variable, thus making it vulnerable to thread conflicts  \n// (if this were a multithreaded program).  \n  \nint compare( void *pvlocale, const void *str1, const void *str2)  \n{  \n    char *s1 = *(char**)str1;  \n    char *s2 = *(char**)str2;  \n  \n    locale& loc = *( reinterpret_cast< locale * > ( pvlocale));  \n  \n    return use_facet< collate<char> >(loc).compare(  \n       s1, s1+strlen(s1),  \n       s2, s2+strlen(s2) );  \n}  \n  \nvoid find_it( char *key, char *array[], unsigned int num, locale &loc )  \n{  \n   char **result = (char **)_lfind_s( &key, array,   \n                      &num, sizeof(char *), compare, &loc );  \n   if( result )  \n      printf( \"%s found\\n\", *result );  \n   else  \n      printf( \"%s not found\\n\", key );  \n}  \n  \nint main( )  \n{  \n   find_it( \"weit\", array1, sizeof(array1)/sizeof(char*), locale(GERMAN_LOCALE) );  \n}  \n```  \n  \n```Output  \nweit found  \n```  \n  \n## .NET Framework Equivalent  \n <xref:System.Collections.ArrayList.Contains%2A>  \n  \n## See Also  \n [Searching and Sorting](../../c-runtime-library/searching-and-sorting.md)   \n [bsearch_s](../../c-runtime-library/reference/bsearch-s.md)   \n [_lsearch_s](../../c-runtime-library/reference/lsearch-s.md)   \n [qsort_s](../../c-runtime-library/reference/qsort-s.md)   \n [_lfind](../../c-runtime-library/reference/lfind.md)"}