{"nodes":[{"pos":[12,49],"content":"Compiler Error C2664 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Error C2664 | Microsoft Docs","pos":[0,37]}]},{"pos":[598,618],"content":"Compiler Error C2664","linkify":"Compiler Error C2664","nodes":[{"content":"Compiler Error C2664","pos":[0,20]}]},{"content":"'function' : cannot convert argument n from 'type1' to 'type2'","pos":[619,681]},{"content":"This parameter conversion problem might happen if an instance of a class is created and an implicit conversion is attempted on a constructor marked with the <ph id=\"ph1\">`explicit`</ph> keyword.","pos":[688,864],"source":"This parameter conversion problem might happen if an instance of a class is created and an implicit conversion is attempted on a constructor marked with the `explicit` keyword."},{"content":"For more information about explicit conversions, see <bpt id=\"p1\">[</bpt>User-Defined Type Conversions<ept id=\"p1\">](../../cpp/user-defined-type-conversions-cpp.md)</ept>.","pos":[865,998],"source":" For more information about explicit conversions, see [User-Defined Type Conversions](../../cpp/user-defined-type-conversions-cpp.md)."},{"pos":[1005,1146],"content":"If a temporary object is passed to a function that takes a reference to an object as a parameter, that reference must be a <ph id=\"ph1\">`const`</ph> reference.","source":"If a temporary object is passed to a function that takes a reference to an object as a parameter, that reference must be a `const` reference."},{"content":"If the function is passed a parameter that is not of the type that the function expects, a temporary object is created by using the appropriate constructor.","pos":[1153,1309]},{"content":"This temporary object is then passed to the function.","pos":[1310,1363]},{"content":"In this case, the temporary object is used to initialize the reference.","pos":[1364,1435]},{"content":"In earlier versions of the language, all references could be initialized by temporary objects.","pos":[1436,1530]},{"content":"To fix C2664,","pos":[1537,1550]},{"content":"Recheck the prototype for the given function and correct the argument noted in the error message.","pos":[1560,1657]},{"content":"Supply an explicit conversion if necessary.","pos":[1667,1710]},{"content":"C2664 can also be generated if a class hides a member in one of its base classes.","pos":[1717,1798]},{"pos":[1805,1961],"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Convert System::String to wchar_t* or char<ph id=\"ph1\">\\*</ph><ept id=\"p1\">](../../dotnet/how-to-convert-system-string-to-wchar-t-star-or-char-star.md)</ept>.","source":"For more information, see [How to: Convert System::String to wchar_t* or char\\*](../../dotnet/how-to-convert-system-string-to-wchar-t-star-or-char-star.md)."},{"pos":[1970,1977],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following sample generates C2664 and shows how to fix it.","pos":[1981,2042]},{"pos":[2373,2380],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This sample also generates C2664 and shows how to fix it.","pos":[2384,2441]},{"pos":[2687,2694],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The next sample demonstrates C2664 by using a string literal to call <ph id=\"ph1\">`Test`</ph>, and shows how to fix it.","pos":[2698,2799],"source":"The next sample demonstrates C2664 by using a string literal to call `Test`, and shows how to fix it."},{"content":"Because the parameter is an <ph id=\"ph1\">`szString`</ph> reference, an object must be created by the appropriate constructor.","pos":[2800,2907],"source":" Because the parameter is an `szString` reference, an object must be created by the appropriate constructor."},{"content":"The result is a temporary object that cannot be used to initialize the reference.","pos":[2908,2989]},{"pos":[3683,3690],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The compiler enforces the C++ standard requirements for applying <ph id=\"ph1\">`const`</ph>.","pos":[3694,3767],"source":"The compiler enforces the C++ standard requirements for applying `const`."},{"content":"This sample generates C2664:","pos":[3768,3796]},{"pos":[4005,4012],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"Here's a more complex situation where C2664 is generated, including directions on how to fix it:","pos":[4016,4112]},{"pos":[5152,5159],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"An enum variable is not converted to its underlying type such that a function call will be satisfied.","pos":[5163,5264]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>enum class<ept id=\"p1\">](../../windows/enum-class-cpp-component-extensions.md)</ept>.","pos":[5265,5358],"source":" For more information, see [enum class](../../windows/enum-class-cpp-component-extensions.md)."},{"content":"The following sample generates C2664 and shows how to fix it.","pos":[5359,5420]},{"pos":[5738,5745],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"A bug in the midl compiler causes a wchar_t type to be emitted as an unsigned short in the type library.","pos":[5749,5853]},{"content":"To resolve this error, either cast the type in your C++ source code or define the type as a string in the idl file.","pos":[5854,5969]},{"content":"C2664 is also raised by using <ph id=\"ph1\">`wchar_t`</ph> when porting code from Visual C++ 6.0 to later versions.","pos":[6482,6578],"source":"C2664 is also raised by using `wchar_t` when porting code from Visual C++ 6.0 to later versions."},{"content":"In Visual C++ 6.0 and earlier, <ph id=\"ph1\">`wchar_t`</ph> was a <ph id=\"ph2\">`typedef`</ph> for <ph id=\"ph3\">`unsigned short`</ph> and was therefore implicitly convertible to that type.","pos":[6579,6711],"source":" In Visual C++ 6.0 and earlier, `wchar_t` was a `typedef` for `unsigned short` and was therefore implicitly convertible to that type."},{"content":"After Visual C++ 6.0, <ph id=\"ph1\">`wchar_t`</ph> is its own built-in type, as specified in the C++ standard, and is no longer implicitly convertible to <ph id=\"ph2\">`unsigned short`</ph>.","pos":[6712,6864],"source":" After Visual C++ 6.0, `wchar_t` is its own built-in type, as specified in the C++ standard, and is no longer implicitly convertible to `unsigned short`."},{"content":"See <bpt id=\"p1\">[</bpt>/Zc:wchar_t (wchar_t Is Native Type)<ept id=\"p1\">](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md)</ept>.","pos":[6865,6968],"source":" See [/Zc:wchar_t (wchar_t Is Native Type)](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md)."},{"pos":[6977,6984],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following sample generates C2664 and shows how to fix it.","pos":[6988,7049]},{"pos":[7422,7429],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"C2664 is also caused if the compiler cannot deduce template arguments.","pos":[7433,7503]}],"content":"---\ntitle: \"Compiler Error C2664 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C2664\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C2664\"\nms.assetid: 3595d66e-cf87-4fda-a896-c0cd81f95db4\ncaps.latest.revision: 28\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Compiler Error C2664\n'function' : cannot convert argument n from 'type1' to 'type2'  \n  \n This parameter conversion problem might happen if an instance of a class is created and an implicit conversion is attempted on a constructor marked with the `explicit` keyword. For more information about explicit conversions, see [User-Defined Type Conversions](../../cpp/user-defined-type-conversions-cpp.md).  \n  \n If a temporary object is passed to a function that takes a reference to an object as a parameter, that reference must be a `const` reference.  \n  \n If the function is passed a parameter that is not of the type that the function expects, a temporary object is created by using the appropriate constructor. This temporary object is then passed to the function. In this case, the temporary object is used to initialize the reference. In earlier versions of the language, all references could be initialized by temporary objects.  \n  \n To fix C2664,  \n  \n-   Recheck the prototype for the given function and correct the argument noted in the error message.  \n  \n-   Supply an explicit conversion if necessary.  \n  \n C2664 can also be generated if a class hides a member in one of its base classes.  \n  \n For more information, see [How to: Convert System::String to wchar_t* or char\\*](../../dotnet/how-to-convert-system-string-to-wchar-t-star-or-char-star.md).  \n  \n## Example  \n The following sample generates C2664 and shows how to fix it.  \n  \n```  \n// C2664.cpp  \n// C2664   \nstruct A {  \n   void f(int i) {};  \n};  \n  \nstruct B : public A {  \n   // To fix, uncomment the following line.  \n   // using A::f;  \n   void f(A a) {};  \n};  \n  \nint main() {  \n   B b;  \n   int i = 1;  \n   b.f(i);   // B::F hides A::f Uncomment the using declaration in B.  \n}  \n```  \n  \n## Example  \n This sample also generates C2664 and shows how to fix it.  \n  \n```  \n// C2664b.cpp  \n// C2664 expected  \nstruct A {  \n   // To fix, uncomment the following line.  \n   // A(int i){}  \n};  \n  \nvoid func( int, A ) {}  \n  \nint main() {  \n   func( 1, 1 );   // No conversion from int to A.  \n}  \n```  \n  \n## Example  \n The next sample demonstrates C2664 by using a string literal to call `Test`, and shows how to fix it. Because the parameter is an `szString` reference, an object must be created by the appropriate constructor. The result is a temporary object that cannot be used to initialize the reference.  \n  \n```  \n// C2664c.cpp  \n// compile with: /EHsc  \n// C2664 expected  \n#include <iostream>  \n#include <string.h>  \nusing namespace std;  \n  \nclass szString {  \n   int slen;  \n   char *str;  \n  \npublic:  \n   szString(const char *);  \n   int len() const {   \n      return slen;   \n   }  \n};  \n  \n// Simple reference cannot bind to temp var.  \nvoid Test(szString &a) {}  \n  \n// To fix, uncomment the following line.  \n// void Test(const szString &a) {}  \n  \nszString::szString(const char * newstr) : slen(0), str(NULL) {  \n   slen=strlen(newstr);  \n   str = new char[slen + 1];  \n   if (str)  \n      strcpy_s(str, (slen + 1), newstr);  \n}  \n  \nint main() {  \n   Test(\"hello\");  \n}  \n```  \n  \n## Example  \n The compiler enforces the C++ standard requirements for applying `const`. This sample generates C2664:  \n  \n```  \n// C2664d.cpp  \n// C2664 expected  \n#include <windows.h>  \n  \nvoid func1(LPCSTR &s)  \n{  \n  \n}  \n  \nvoid func2(LPSTR &s)  \n{  \n   func1(s);  \n}  \n  \nint main()  \n{  \n   return 0;  \n}  \n```  \n  \n## Example  \n Here's a more complex situation where C2664 is generated, including directions on how to fix it:  \n  \n```  \n// C2664e.cpp  \n// compile with: /EHsc  \n// C2664 expected  \n#define _INTL  \n#include <locale>  \n#include <iostream>  \n  \nusing namespace std;  \n#define LEN 90  \n  \nint main( ) {  \n   char* pszExt = \"This is the string to be converted!\";  \n   wchar_t pwszInt [LEN+1];  \n   memset(&pwszInt[0], 0, (sizeof(wchar_t))*(LEN+1));  \n  \n   // To fix, delete the following line.  \n   char* pszNext;  \n  \n   // To fix, uncomment the following line.  \n   // const char* pszNext;  \n  \n   wchar_t* pwszNext;  \n   mbstate_t state;  \n   locale loc(\"C\");    \n   int res = use_facet<codecvt<wchar_t, char, mbstate_t> >  \n      ( loc ).in( state,  \n      pszExt, &pszExt[strlen(pszExt)], pszNext,  \n      pwszInt, &pwszInt[strlen(pszExt)], pwszNext );  \n   // See earlier comment.  \n      pwszInt[strlen(pszExt)] = 0;  \n   wcout << ( (res!=codecvt_base::error) ?   \n                       L\"It worked! \" : L\"It didn't work! \" )  \n   << L\"The converted string is:\\n [\"  \n   << &pwszInt[0]  \n   << L\"]\" << endl;  \n  \n   exit(-1);  \n}  \n```  \n  \n## Example  \n An enum variable is not converted to its underlying type such that a function call will be satisfied. For more information, see [enum class](../../windows/enum-class-cpp-component-extensions.md). The following sample generates C2664 and shows how to fix it.  \n  \n```  \n// C2664f.cpp  \n// compile with: /clr  \nusing namespace System;  \npublic enum class A : Char {  \n   None = 0,  \n   NonSilent = 1,  \n};  \n  \nvoid Test(Char c) {}  \n  \nint main() {  \n   A aa = A::None;  \n   Test(aa);   // C2664  \n   Test(Char(aa));   // OK - fix by using a conversion cast  \n}  \n```  \n  \n## Example  \n A bug in the midl compiler causes a wchar_t type to be emitted as an unsigned short in the type library. To resolve this error, either cast the type in your C++ source code or define the type as a string in the idl file.  \n  \n```  \n// C2664g.idl  \nimport \"prsht.idl\";  \n  \n[ object, uuid(8402B8F1-BF7F-4B49-92D4-C2B9DF4543E9) ]  \n  \ninterface IMyObj1 : IUnknown {  \n   HRESULT  teststr([in, string] wchar_t *wstr);  \n   HRESULT  testarr([in, size_is(len)] wchar_t wstr[], [in] int len);  \n   HRESULT  testbstr([in] BSTR bstr);  \n};  \n  \n[  uuid(44463307-CBFC-47A6-8B4F-13CD0A83B436) ]  \nlibrary myproj1 {  \n   [  version(1.0), uuid(D8622C12-5448-42B8-8F0E-E3AD6B8470C1) ]  \n   coclass CMyObj1 { interface IMyObj1; };  \n}  \n```  \n  \n C2664 is also raised by using `wchar_t` when porting code from Visual C++ 6.0 to later versions. In Visual C++ 6.0 and earlier, `wchar_t` was a `typedef` for `unsigned short` and was therefore implicitly convertible to that type. After Visual C++ 6.0, `wchar_t` is its own built-in type, as specified in the C++ standard, and is no longer implicitly convertible to `unsigned short`. See [/Zc:wchar_t (wchar_t Is Native Type)](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md).  \n  \n## Example  \n The following sample generates C2664 and shows how to fix it.  \n  \n```  \n// C2664h.cpp  \n#import \"C2664g.tlb\"  \nusing namespace myproj1;  \n  \nint main() {  \n   IMyObj1Ptr ptr;  \n  \n   wchar_t * mybuff = 0;  \n   BSTR bstr = 0;  \n   int len;  \n   ptr->teststr(mybuff);  \n   ptr->testbstr(bstr);  \n   ptr->testarr(mybuff, len);   // C2664  \n   ptr->testarr((unsigned short *)mybuff, len);   // OK - Fix by using a cast  \n}  \n```  \n  \n## Example  \n C2664 is also caused if the compiler cannot deduce template arguments.  \n  \n```  \n// C2664i.cpp  \n#include <stdio.h>  \ntemplate <class T, int iType=0>  \nclass CTypedImg {  \npublic:  \n   CTypedImg() {}  \n   void run() {}  \n  \n   operator CTypedImg<T>& () {  \n      return *((CTypedImg<T>*)this);  \n    }  \n};  \n  \ntemplate <class t1>  \nvoid test(CTypedImg<t1>& myarg) {  \n   myarg.run();  \n}  \n  \nint main() {  \n   CTypedImg<float,2> img;  \n  \n   test((CTypedImg<float>&)img);   // OK  \n   test<float>(img);   // OK  \n   test(img);   // C2664 - qualify as above to fix  \n}  \n```"}