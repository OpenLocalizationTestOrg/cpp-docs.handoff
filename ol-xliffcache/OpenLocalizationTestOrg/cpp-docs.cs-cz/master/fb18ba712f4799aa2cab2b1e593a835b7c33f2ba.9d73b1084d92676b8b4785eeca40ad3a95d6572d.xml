{"nodes":[{"pos":[12,71],"content":"Basic Concepts in Using Managed Exceptions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Basic Concepts in Using Managed Exceptions | Microsoft Docs","pos":[0,59]}]},{"content":"Basic Concepts in Using Managed Exceptions","pos":[847,889]},{"content":"This topic discusses exception handling in managed applications.","pos":[890,954]},{"content":"That is, an application that is compiled with the <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> compiler option.","pos":[955,1030],"source":" That is, an application that is compiled with the **/clr** compiler option."},{"content":"In this topic","pos":[1039,1052]},{"content":"Throwing Exceptions Under /clr","pos":[1063,1093]},{"content":"Try/Catch Blocks for CLR Extensions","pos":[1157,1192]},{"content":"Remarks","pos":[1254,1261]},{"content":"If you compile with the <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> option, you can handle CLR exceptions as well as standard <bpt id=\"p2\">[</bpt>C++ exception handling<ept id=\"p2\">](../cpp/cpp-exception-handling.md)</ept> and <bpt id=\"p3\">[</bpt>structured exception handling<ept id=\"p3\">](../cpp/structured-exception-handling-c-cpp.md)</ept> (SEH).","pos":[1265,1504],"source":"If you compile with the **/clr** option, you can handle CLR exceptions as well as standard [C++ exception handling](../cpp/cpp-exception-handling.md) and [structured exception handling](../cpp/structured-exception-handling-c-cpp.md) (SEH)."},{"content":"A CLR exception is any exception thrown by a managed type.","pos":[1505,1563]},{"content":"The <bpt id=\"p1\">[</bpt>System::Exception<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/system.exception.aspx)</ept> class provides many useful methods for processing CLR exceptions and is recommended as a base class for user-defined exception classes.","pos":[1564,1787],"source":" The [System::Exception](https://msdn.microsoft.com/en-us/library/system.exception.aspx) class provides many useful methods for processing CLR exceptions and is recommended as a base class for user-defined exception classes."},{"content":"Catching exception types derived from an interface is not supported under <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>.","pos":[1794,1877],"source":"Catching exception types derived from an interface is not supported under **/clr**."},{"content":"Also, the common language runtime does not permit you to catch stack overflow exceptions; a stack overflow exception will terminate the process.","pos":[1878,2022]},{"pos":[2029,2278],"content":"For more information about differences in exception handling in managed and unmanaged applications, see <bpt id=\"p1\">[</bpt>Differences in Exception Handling Behavior Under Managed Extensions for C++<ept id=\"p1\">](../dotnet/differences-in-exception-handling-behavior-under-clr.md)</ept>.","source":"For more information about differences in exception handling in managed and unmanaged applications, see [Differences in Exception Handling Behavior Under Managed Extensions for C++](../dotnet/differences-in-exception-handling-behavior-under-clr.md)."},{"pos":[2353,2383],"content":"Throwing Exceptions Under /clr"},{"content":"The C++ throw expression is extended to throw a handle to a CLR type.","pos":[2387,2456]},{"content":"The following example creates a custom exception type and then throws an instance of that type:","pos":[2457,2552]},{"content":"A value type must be boxed before being thrown:","pos":[2808,2855]},{"pos":[3147,3182],"content":"Try/Catch Blocks for CLR Extensions"},{"pos":[3186,3285],"content":"The same <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept><ph id=\"ph1\">/</ph><bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> block structure can be used for catching both CLR and native exceptions:","source":"The same **try**/**catch** block structure can be used for catching both CLR and native exceptions:"},{"content":"Output","pos":[4253,4259]},{"content":"Order of Unwinding for C++ Objects","pos":[4363,4397]},{"content":"Unwinding occurs for any C++ objects with destructors that may be on the run-time stack between the throwing function and the handling function.","pos":[4401,4545]},{"content":"Because CLR types are allocated on the heap, unwinding does not apply to them.","pos":[4546,4624]},{"content":"The order of events for a thrown exception is as follows:","pos":[4631,4688]},{"content":"The runtime walks the stack looking for the appropriate catch clause, or in the case of SEH, an except filter for SEH, to catch the exception.","pos":[4698,4840]},{"content":"Catch clauses are searched first in lexical order, and then dynamically down the call stack.","pos":[4841,4933]},{"content":"Once the correct handler is found, the stack is unwound to that point.","pos":[4943,5013]},{"content":"For each function call on the stack, its local objects are destructed and __finally blocks are executed, from most nested outward.","pos":[5014,5144]},{"content":"Once the stack is unwound, the catch clause is executed.","pos":[5154,5210]},{"content":"Catching Unmanaged Types","pos":[5220,5244]},{"content":"When an unmanaged object type is thrown, it is wrapped with an exception of type <bpt id=\"p1\">[</bpt>System::Runtime.InteropServices::SEHException<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception.aspx)</ept>.","pos":[5248,5468],"source":"When an unmanaged object type is thrown, it is wrapped with an exception of type [System::Runtime.InteropServices::SEHException](https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception.aspx)."},{"content":"When searching for the appropriate <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> clause, there are two possibilities.","pos":[5469,5550],"source":" When searching for the appropriate **catch** clause, there are two possibilities."},{"content":"If a native C++ type is encountered, the exception is unwrapped and compared to the type encountered.","pos":[5560,5661]},{"content":"This comparison allows a native C++ type to be caught in the normal way.","pos":[5662,5734]},{"content":"However, if a <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> clause of type <bpt id=\"p2\">**</bpt>SEHException<ept id=\"p2\">**</ept> or any of its base classes is examined first, the clause will intercept the exception.","pos":[5744,5886],"source":"However, if a **catch** clause of type **SEHException** or any of its base classes is examined first, the clause will intercept the exception."},{"content":"Therefore, you should place all catch clauses that catch native C++ types first before any catch clauses of CLR types.","pos":[5887,6005]},{"content":"Note that","pos":[6012,6021]},{"content":"and","pos":[6060,6063]},{"content":"will both catch any thrown type including SEH exceptions.","pos":[6098,6155]},{"content":"If an unmanaged type is caught by catch(Object^), it will not destroy the thrown object.","pos":[6162,6250]},{"pos":[6257,6442],"content":"When throwing or catching unmanaged exceptions, we recommend that you use the <bpt id=\"p1\">[</bpt>/EHsc<ept id=\"p1\">](../build/reference/eh-exception-handling-model.md)</ept> compiler option instead of <bpt id=\"p2\">**</bpt>/EHs<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>/EHa<ept id=\"p3\">**</ept>.","source":"When throwing or catching unmanaged exceptions, we recommend that you use the [/EHsc](../build/reference/eh-exception-handling-model.md) compiler option instead of **/EHs** or **/EHa**."},{"content":"See Also","pos":[6451,6459]},{"content":"Exception Handling","pos":[6464,6482]},{"content":"safe_cast","pos":[6548,6557]},{"content":"Exception Handling","pos":[6614,6632]}],"content":"---\ntitle: \"Basic Concepts in Using Managed Exceptions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"try-catch exception handling, managed applications\"\n  - \"__finally keyword, managed exceptions\"\n  - \"exceptions, managed\"\n  - \"try-catch exception handling\"\n  - \"catch blocks\"\n  - \"throwing exceptions, managed exceptions\"\n  - \"Visual C++, handling managed exceptions\"\nms.assetid: 40ce8931-1ecc-491a-815f-733b23fcba35\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Basic Concepts in Using Managed Exceptions\nThis topic discusses exception handling in managed applications. That is, an application that is compiled with the **/clr** compiler option.  \n  \n## In this topic  \n  \n-   [Throwing Exceptions Under /clr](#vcconbasicconceptsinusingmanagedexceptionsanchor1)  \n  \n-   [Try/Catch Blocks for CLR Extensions](#vcconbasicconceptsinusingmanagedexceptionsanchor2)  \n  \n## Remarks  \n If you compile with the **/clr** option, you can handle CLR exceptions as well as standard [C++ exception handling](../cpp/cpp-exception-handling.md) and [structured exception handling](../cpp/structured-exception-handling-c-cpp.md) (SEH). A CLR exception is any exception thrown by a managed type. The [System::Exception](https://msdn.microsoft.com/en-us/library/system.exception.aspx) class provides many useful methods for processing CLR exceptions and is recommended as a base class for user-defined exception classes.  \n  \n Catching exception types derived from an interface is not supported under **/clr**. Also, the common language runtime does not permit you to catch stack overflow exceptions; a stack overflow exception will terminate the process.  \n  \n For more information about differences in exception handling in managed and unmanaged applications, see [Differences in Exception Handling Behavior Under Managed Extensions for C++](../dotnet/differences-in-exception-handling-behavior-under-clr.md).  \n  \n##  <a name=\"vcconbasicconceptsinusingmanagedexceptionsanchor1\"></a> Throwing Exceptions Under /clr  \n The C++ throw expression is extended to throw a handle to a CLR type. The following example creates a custom exception type and then throws an instance of that type:  \n  \n```  \n// clr_exception_handling.cpp  \n// compile with: /clr /c  \nref struct MyStruct: public System::Exception {  \npublic:  \n   int i;  \n};  \n  \nvoid GlobalFunction() {  \n   MyStruct^ pMyStruct = gcnew MyStruct;  \n   throw pMyStruct;  \n}  \n```  \n  \n A value type must be boxed before being thrown:  \n  \n```  \n// clr_exception_handling_2.cpp  \n// compile with: /clr /c  \nvalue struct MyValueStruct {  \n   int i;  \n};  \n  \nvoid GlobalFunction() {  \n   MyValueStruct v = {11};  \n   throw (MyValueStruct ^)v;  \n}  \n```  \n  \n##  <a name=\"vcconbasicconceptsinusingmanagedexceptionsanchor2\"></a> Try/Catch Blocks for CLR Extensions  \n The same **try**/**catch** block structure can be used for catching both CLR and native exceptions:  \n  \n```  \n// clr_exception_handling_3.cpp  \n// compile with: /clr  \nusing namespace System;  \nref struct MyStruct : public Exception {  \npublic:  \n   int i;  \n};  \n  \nstruct CMyClass {  \npublic:  \n   double d;  \n};  \n  \nvoid GlobalFunction() {  \n   MyStruct^ pMyStruct = gcnew MyStruct;  \n   pMyStruct->i = 11;  \n   throw pMyStruct;  \n}  \n  \nvoid GlobalFunction2() {  \n   CMyClass c = {2.0};  \n   throw c;  \n}  \n  \nint main() {  \n   for ( int i = 1; i >= 0; --i ) {  \n      try {  \n         if ( i == 1 )  \n            GlobalFunction2();  \n         if ( i == 0 )  \n            GlobalFunction();  \n      }  \n      catch ( CMyClass& catchC ) {  \n         Console::WriteLine( \"In 'catch(CMyClass& catchC)'\" );  \n         Console::WriteLine( catchC.d );  \n      }  \n      catch ( MyStruct^ catchException ) {  \n         Console::WriteLine( \"In 'catch(MyStruct^ catchException)'\" );  \n         Console::WriteLine( catchException->i );  \n      }  \n   }  \n}  \n```  \n  \n### Output  \n  \n```  \nIn 'catch(CMyClass& catchC)'  \n2  \nIn 'catch(MyStruct^ catchException)'  \n11  \n```  \n  \n### Order of Unwinding for C++ Objects  \n Unwinding occurs for any C++ objects with destructors that may be on the run-time stack between the throwing function and the handling function. Because CLR types are allocated on the heap, unwinding does not apply to them.  \n  \n The order of events for a thrown exception is as follows:  \n  \n1.  The runtime walks the stack looking for the appropriate catch clause, or in the case of SEH, an except filter for SEH, to catch the exception. Catch clauses are searched first in lexical order, and then dynamically down the call stack.  \n  \n2.  Once the correct handler is found, the stack is unwound to that point. For each function call on the stack, its local objects are destructed and __finally blocks are executed, from most nested outward.  \n  \n3.  Once the stack is unwound, the catch clause is executed.  \n  \n### Catching Unmanaged Types  \n When an unmanaged object type is thrown, it is wrapped with an exception of type [System::Runtime.InteropServices::SEHException](https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception.aspx). When searching for the appropriate **catch** clause, there are two possibilities.  \n  \n-   If a native C++ type is encountered, the exception is unwrapped and compared to the type encountered. This comparison allows a native C++ type to be caught in the normal way.  \n  \n-   However, if a **catch** clause of type **SEHException** or any of its base classes is examined first, the clause will intercept the exception. Therefore, you should place all catch clauses that catch native C++ types first before any catch clauses of CLR types.  \n  \n Note that  \n  \n```  \ncatch(Object^)  \n```  \n  \n and  \n  \n```  \ncatch(...)  \n```  \n  \n will both catch any thrown type including SEH exceptions.  \n  \n If an unmanaged type is caught by catch(Object^), it will not destroy the thrown object.  \n  \n When throwing or catching unmanaged exceptions, we recommend that you use the [/EHsc](../build/reference/eh-exception-handling-model.md) compiler option instead of **/EHs** or **/EHa**.  \n  \n## See Also  \n [Exception Handling](../windows/exception-handling-cpp-component-extensions.md)   \n [safe_cast](../windows/safe-cast-cpp-component-extensions.md)   \n [Exception Handling](../cpp/exception-handling-in-visual-cpp.md)"}