{"nodes":[{"pos":[12,50],"content":"Type-Cast Conversions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Type-Cast Conversions | Microsoft Docs","pos":[0,38]}]},{"content":"Type-Cast Conversions","pos":[785,806]},{"content":"You can use type casts to explicitly convert types.","pos":[807,858]},{"content":"Syntax","pos":[867,873]},{"content":"<bpt id=\"p1\">*</bpt>cast-expression<ept id=\"p1\">*</ept>:","pos":[882,900],"source":"*cast-expression*:"},{"content":"unary expression","pos":[905,921]},{"pos":[929,973],"content":"<bpt id=\"p1\">**</bpt>(<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>type-name<ept id=\"p2\">*</ept>  <bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>  <bpt id=\"p4\">*</bpt>cast-expression<ept id=\"p4\">*</ept>","source":"**(**  *type-name*  **)**  *cast-expression*"},{"content":"<bpt id=\"p1\">*</bpt>type-name<ept id=\"p1\">*</ept>:","pos":[980,992],"source":"*type-name*:"},{"content":"<bpt id=\"p1\"> *</bpt>specifier-qualifier-list abstract-declarator<ept id=\"p1\">*</ept> opt","pos":[995,1046],"source":" *specifier-qualifier-list abstract-declarator* opt"},{"content":"The <bpt id=\"p1\">*</bpt>type-name<ept id=\"p1\">*</ept> is a type and <bpt id=\"p2\">*</bpt>cast-expression<ept id=\"p2\">*</ept> is a value to be converted to that type.","pos":[1053,1141],"source":"The *type-name* is a type and *cast-expression* is a value to be converted to that type."},{"content":"An expression with a type cast is not an l-value.","pos":[1142,1191]},{"content":"The <bpt id=\"p1\">*</bpt>cast-expression<ept id=\"p1\">*</ept> is converted as though it had been assigned to a variable of type <bpt id=\"p2\">*</bpt>type-name<ept id=\"p2\">*</ept>.","pos":[1192,1292],"source":" The *cast-expression* is converted as though it had been assigned to a variable of type *type-name*."},{"content":"The conversion rules for assignments (outlined in <bpt id=\"p1\">[</bpt>Assignment Conversions<ept id=\"p1\">](../c-language/assignment-conversions.md)</ept>) apply to type casts as well.","pos":[1293,1438],"source":" The conversion rules for assignments (outlined in [Assignment Conversions](../c-language/assignment-conversions.md)) apply to type casts as well."},{"content":"The following table shows the types that can be cast to any given type.","pos":[1439,1510]},{"content":"Legal Type Casts","pos":[1520,1536]},{"content":"Destination Types","pos":[1543,1560]},{"content":"Potential Sources","pos":[1561,1578]},{"content":"Integral types","pos":[1635,1649]},{"content":"Any integer type or floating-point type, or pointer to an object","pos":[1650,1714]},{"content":"Floating-point","pos":[1719,1733]},{"content":"Any arithmetic type","pos":[1734,1753]},{"pos":[1758,1798],"content":"A pointer to an object, or (<bpt id=\"p1\">**</bpt>void <ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept>)","source":"A pointer to an object, or (**void \\***)"},{"pos":[1799,1877],"content":"Any integer type, (<bpt id=\"p1\">**</bpt>void <ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept>), a pointer to an object, or a function pointer","source":"Any integer type, (**void \\***), a pointer to an object, or a function pointer"},{"content":"Function pointer","pos":[1882,1898]},{"content":"Any integral type, a pointer to an object, or a function pointer","pos":[1899,1963]},{"content":"A structure, union, or array","pos":[1968,1996]},{"content":"None","pos":[1997,2001]},{"content":"Void type","pos":[2006,2015]},{"content":"Any type","pos":[2016,2024]},{"content":"Any identifier can be cast to <ph id=\"ph1\">`void`</ph> type.","pos":[2032,2074],"source":"Any identifier can be cast to `void` type."},{"content":"However, if the type specified in a type-cast expression is not <ph id=\"ph1\">`void`</ph>, then the identifier being cast to that type cannot be a <ph id=\"ph2\">`void`</ph> expression.","pos":[2075,2221],"source":" However, if the type specified in a type-cast expression is not `void`, then the identifier being cast to that type cannot be a `void` expression."},{"content":"Any expression can be cast to <ph id=\"ph1\">`void`</ph>, but an expression of type <ph id=\"ph2\">`void`</ph> cannot be cast to any other type.","pos":[2222,2326],"source":" Any expression can be cast to `void`, but an expression of type `void` cannot be cast to any other type."},{"content":"For example, a function with <ph id=\"ph1\">`void`</ph> return type cannot have its return cast to another type.","pos":[2327,2419],"source":" For example, a function with `void` return type cannot have its return cast to another type."},{"content":"Note that a <bpt id=\"p1\">**</bpt>void <ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> expression has a type pointer to <ph id=\"ph2\">`void`</ph>, not type <ph id=\"ph3\">`void`</ph>.","pos":[2426,2507],"source":"Note that a **void \\*** expression has a type pointer to `void`, not type `void`."},{"content":"If an object is cast to <ph id=\"ph1\">`void`</ph> type, the resulting expression cannot be assigned to any item.","pos":[2508,2601],"source":" If an object is cast to `void` type, the resulting expression cannot be assigned to any item."},{"content":"Similarly, a type-cast object is not an acceptable l-value, so no assignment can be made to a type-cast object.","pos":[2602,2713]},{"content":"Microsoft Specific","pos":[2722,2740]},{"content":"A type cast can be an l-value expression as long as the size of the identifier does not change.","pos":[2749,2844]},{"content":"For information on l-value expressions, see <bpt id=\"p1\">[</bpt>L-Value and R-Value Expressions<ept id=\"p1\">](../c-language/l-value-and-r-value-expressions.md)</ept>.","pos":[2845,2973],"source":" For information on l-value expressions, see [L-Value and R-Value Expressions](../c-language/l-value-and-r-value-expressions.md)."},{"content":"END Microsoft Specific","pos":[2982,3004]},{"content":"You can convert an expression to type <ph id=\"ph1\">`void`</ph> with a cast, but the resulting expression can be used only where a value is not required.","pos":[3013,3147],"source":"You can convert an expression to type `void` with a cast, but the resulting expression can be used only where a value is not required."},{"content":"An object pointer converted to <bpt id=\"p1\">**</bpt>void <ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> and back to the original type will return to its original value.","pos":[3148,3255],"source":" An object pointer converted to **void \\*** and back to the original type will return to its original value."},{"content":"See Also","pos":[3264,3272]},{"content":"Type Conversions","pos":[3277,3293]}],"content":"---\ntitle: \"Type-Cast Conversions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"data type conversion [C++], type-cast conversions\"\n  - \"conversions [C++], type-cast\"\n  - \"type casts\"\n  - \"explicit type conversions\"\n  - \"type casts [C++], about type-cast conversion\"\n  - \"type-cast conversions [C++]\"\nms.assetid: 57ab5902-f12f-4326-a2f6-6282f1d4025a\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Type-Cast Conversions\nYou can use type casts to explicitly convert types.  \n  \n **Syntax**  \n  \n *cast-expression*:  \n *unary expression*  \n  \n **(**  *type-name*  **)**  *cast-expression*  \n  \n *type-name*:  \n *specifier-qualifier-list abstract-declarator* opt  \n  \n The *type-name* is a type and *cast-expression* is a value to be converted to that type. An expression with a type cast is not an l-value. The *cast-expression* is converted as though it had been assigned to a variable of type *type-name*. The conversion rules for assignments (outlined in [Assignment Conversions](../c-language/assignment-conversions.md)) apply to type casts as well. The following table shows the types that can be cast to any given type.  \n  \n### Legal Type Casts  \n  \n|Destination Types|Potential Sources|  \n|-----------------------|-----------------------|  \n|Integral types|Any integer type or floating-point type, or pointer to an object|  \n|Floating-point|Any arithmetic type|  \n|A pointer to an object, or (**void \\***)|Any integer type, (**void \\***), a pointer to an object, or a function pointer|  \n|Function pointer|Any integral type, a pointer to an object, or a function pointer|  \n|A structure, union, or array|None|  \n|Void type|Any type|  \n  \n Any identifier can be cast to `void` type. However, if the type specified in a type-cast expression is not `void`, then the identifier being cast to that type cannot be a `void` expression. Any expression can be cast to `void`, but an expression of type `void` cannot be cast to any other type. For example, a function with `void` return type cannot have its return cast to another type.  \n  \n Note that a **void \\*** expression has a type pointer to `void`, not type `void`. If an object is cast to `void` type, the resulting expression cannot be assigned to any item. Similarly, a type-cast object is not an acceptable l-value, so no assignment can be made to a type-cast object.  \n  \n **Microsoft Specific**  \n  \n A type cast can be an l-value expression as long as the size of the identifier does not change. For information on l-value expressions, see [L-Value and R-Value Expressions](../c-language/l-value-and-r-value-expressions.md).  \n  \n **END Microsoft Specific**  \n  \n You can convert an expression to type `void` with a cast, but the resulting expression can be used only where a value is not required. An object pointer converted to **void \\*** and back to the original type will return to its original value.  \n  \n## See Also  \n [Type Conversions](../c-language/type-conversions-c.md)"}