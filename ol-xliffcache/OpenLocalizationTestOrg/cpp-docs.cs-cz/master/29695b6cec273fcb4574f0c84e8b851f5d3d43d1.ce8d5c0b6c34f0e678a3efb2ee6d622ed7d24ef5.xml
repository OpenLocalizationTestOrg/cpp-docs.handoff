{"nodes":[{"pos":[12,60],"content":"Ellipses and Variadic Templates | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Ellipses and Variadic Templates | Microsoft Docs","pos":[0,48]}]},{"content":"Ellipses and Variadic Templates","pos":[578,609]},{"content":"This article shows how to use the ellipsis (<ph id=\"ph1\">`...`</ph>) with C++ variadic templates.","pos":[610,689],"source":"This article shows how to use the ellipsis (`...`) with C++ variadic templates."},{"content":"The ellipsis has had many uses in C and C++.","pos":[690,734]},{"content":"These include variable argument lists for functions.","pos":[735,787]},{"content":"The <ph id=\"ph1\">`printf()`</ph> function from the C Runtime Library is one of the most well-known examples.","pos":[788,878],"source":" The `printf()` function from the C Runtime Library is one of the most well-known examples."},{"content":"A <bpt id=\"p1\">*</bpt>variadic template<ept id=\"p1\">*</ept> is a class or function template that supports an arbitrary number of arguments.","pos":[885,986],"source":"A *variadic template* is a class or function template that supports an arbitrary number of arguments."},{"content":"This mechanism is especially useful to C++ library developers because you can apply it to both class templates and function templates, and thereby provide a wide range of type-safe and non-trivial functionality and flexibility.","pos":[987,1214]},{"content":"Syntax","pos":[1223,1229]},{"content":"An ellipsis is used in two ways by variadic templates.","pos":[1233,1287]},{"content":"To the left of the parameter name, it signifies a <bpt id=\"p1\">*</bpt>parameter pack<ept id=\"p1\">*</ept>, and to the right of the parameter name, it expands the parameter packs into separate names.","pos":[1288,1447],"source":" To the left of the parameter name, it signifies a *parameter pack*, and to the right of the parameter name, it expands the parameter packs into separate names."},{"pos":[1454,1524],"content":"Here's a basic example of <bpt id=\"p1\">*</bpt>variadic template class<ept id=\"p1\">*</ept> definition syntax:","source":"Here's a basic example of *variadic template class* definition syntax:"},{"content":"For both parameter packs and expansions, you can add whitespace around the ellipsis, based on your preference, as shown in these examples:","pos":[1600,1738]},{"content":"Or this:","pos":[1814,1822]},{"pos":[1899,2019],"content":"Notice that this article uses the convention that's shown in the first example (the ellipsis is attached to <ph id=\"ph1\">`typename`</ph>).","source":"Notice that this article uses the convention that's shown in the first example (the ellipsis is attached to `typename`)."},{"content":"In the preceding examples, <ph id=\"ph1\">`Arguments`</ph> is a parameter pack.","pos":[2026,2085],"source":"In the preceding examples, `Arguments` is a parameter pack."},{"content":"The class <ph id=\"ph1\">`classname`</ph> can accept a variable number of arguments, as in these examples:","pos":[2086,2172],"source":" The class `classname` can accept a variable number of arguments, as in these examples:"},{"content":"By using a variadic template class definition, you can also require at least one parameter:","pos":[2405,2496]},{"pos":[2587,2649],"content":"Here's a basic example of <bpt id=\"p1\">*</bpt>variadic template function<ept id=\"p1\">*</ept> syntax:","source":"Here's a basic example of *variadic template function* syntax:"},{"pos":[2753,2877],"content":"The <ph id=\"ph1\">`Arguments`</ph> parameter pack is then expanded for use, as shown in the next section, <bpt id=\"p1\">**</bpt>Understanding variadic templates<ept id=\"p1\">**</ept>.","source":"The `Arguments` parameter pack is then expanded for use, as shown in the next section, **Understanding variadic templates**."},{"content":"Other forms of variadic template function syntax are possibleâ€”including, but not limited to, these examples:","pos":[2884,2992]},{"pos":[3259,3300],"content":"Specifiers like <ph id=\"ph1\">`const`</ph> are also allowed:","source":"Specifiers like `const` are also allowed:"},{"content":"As with variadic template class definitions, you can make functions that require at least one parameter:","pos":[3414,3518]},{"pos":[3658,3753],"content":"Variadic templates use the <ph id=\"ph1\">`sizeof...()`</ph> operator (unrelated to the older <ph id=\"ph2\">`sizeof()`</ph> operator):","source":"Variadic templates use the `sizeof...()` operator (unrelated to the older `sizeof()` operator):"},{"content":"More about ellipsis placement","pos":[4023,4052]},{"content":"Previously, this article described ellipsis placement that defines parameter packs and expansions as \"to the left of the parameter name, it signifies a parameter pack, and to the right of the parameter name, it expands the parameter packs into separate names\".","pos":[4056,4316]},{"content":"This is technically true but can be confusing in translation to code.","pos":[4317,4386]},{"content":"Consider:","pos":[4387,4396]},{"pos":[4406,4517],"content":"In a template-parameter-list (<ph id=\"ph1\">`template &lt;parameter-list&gt;`</ph>), <ph id=\"ph2\">`typename...`</ph> introduces a template parameter pack.","source":"In a template-parameter-list (`template <parameter-list>`), `typename...` introduces a template parameter pack."},{"pos":[4527,4690],"content":"In a parameter-declaration-clause (<ph id=\"ph1\">`func(parameter-list)`</ph>), a \"top-level\" ellipsis introduces a function parameter pack, and the ellipsis positioning is important:","source":"In a parameter-declaration-clause (`func(parameter-list)`), a \"top-level\" ellipsis introduces a function parameter pack, and the ellipsis positioning is important:"},{"content":"Where the ellipsis appears immediately after a parameter name, you have a parameter pack expansion.","pos":[4968,5067]},{"content":"Example","pos":[5076,5083]},{"pos":[5087,5221],"content":"A good way to illustrate the variadic template function mechanism is to use it in a re-write of some of the functionality of <ph id=\"ph1\">`printf`</ph>:","source":"A good way to illustrate the variadic template function mechanism is to use it in a re-write of some of the functionality of `printf`:"},{"content":"Output","pos":[5959,5965]},{"pos":[6047,6646],"content":"[!NOTE]\n Most implementations that incorporate variadic template functions use recursion of some form, but it's slightly different from traditional recursion.  Traditional recursion involves a function calling itself by using the same signature. (It may be overloaded or templated, but the same signature is chosen each time.) Variadic recursion involves calling a variadic function template by using differing (almost always decreasing) numbers of arguments, and thereby stamping out a different signature every time. A \"base case\" is still required, but the nature of the recursion is different.","leadings":["","> "],"nodes":[{"content":" Most implementations that incorporate variadic template functions use recursion of some form, but it's slightly different from traditional recursion.  Traditional recursion involves a function calling itself by using the same signature. (It may be overloaded or templated, but the same signature is chosen each time.) Variadic recursion involves calling a variadic function template by using differing (almost always decreasing) numbers of arguments, and thereby stamping out a different signature every time. A \"base case\" is still required, but the nature of the recursion is different.","pos":[8,597],"nodes":[{"content":"Most implementations that incorporate variadic template functions use recursion of some form, but it's slightly different from traditional recursion.","pos":[1,150]},{"content":"Traditional recursion involves a function calling itself by using the same signature.","pos":[152,237]},{"content":"(It may be overloaded or templated, but the same signature is chosen each time.) Variadic recursion involves calling a variadic function template by using differing (almost always decreasing) numbers of arguments, and thereby stamping out a different signature every time.","pos":[238,510]},{"content":"A \"base case\" is still required, but the nature of the recursion is different.","pos":[511,589]}]}]}],"content":"---\ntitle: \"Ellipses and Variadic Templates | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nms.assetid: f20967d9-c967-4fd2-b902-2bb1d5ed87e3\ncaps.latest.revision: 17\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Ellipses and Variadic Templates\nThis article shows how to use the ellipsis (`...`) with C++ variadic templates. The ellipsis has had many uses in C and C++. These include variable argument lists for functions. The `printf()` function from the C Runtime Library is one of the most well-known examples.  \n  \n A *variadic template* is a class or function template that supports an arbitrary number of arguments. This mechanism is especially useful to C++ library developers because you can apply it to both class templates and function templates, and thereby provide a wide range of type-safe and non-trivial functionality and flexibility.  \n  \n## Syntax  \n An ellipsis is used in two ways by variadic templates. To the left of the parameter name, it signifies a *parameter pack*, and to the right of the parameter name, it expands the parameter packs into separate names.  \n  \n Here's a basic example of *variadic template class* definition syntax:  \n  \n```cpp  \ntemplate<typename... Arguments> class classname;  \n```  \n  \n For both parameter packs and expansions, you can add whitespace around the ellipsis, based on your preference, as shown in these examples:  \n  \n```cpp  \ntemplate<typename ...Arguments> class classname;  \n```  \n  \n Or this:  \n  \n```cpp  \ntemplate<typename ... Arguments> class classname;  \n```  \n  \n Notice that this article uses the convention that's shown in the first example (the ellipsis is attached to `typename`).  \n  \n In the preceding examples, `Arguments` is a parameter pack. The class `classname` can accept a variable number of arguments, as in these examples:  \n  \n```cpp  \n  \ntemplate<typename... Arguments> class vtclass;  \n  \nvtclass< > vtinstance1;  \nvtclass<int> vtinstance2;  \nvtclass<float, bool> vtinstance3;  \nvtclass<long, std::vector<int>, std::string> vtinstance4;  \n  \n```  \n  \n By using a variadic template class definition, you can also require at least one parameter:  \n  \n```cpp  \ntemplate <typename First, typename... Rest> class classname;  \n  \n```  \n  \n Here's a basic example of *variadic template function* syntax:  \n  \n```cpp  \ntemplate <typename... Arguments> returntype functionname(Arguments... args);  \n```  \n  \n The `Arguments` parameter pack is then expanded for use, as shown in the next section, **Understanding variadic templates**.  \n  \n Other forms of variadic template function syntax are possibleâ€”including, but not limited to, these examples:  \n  \n```cpp  \ntemplate <typename... Arguments> returntype functionname(Arguments&... args);   \ntemplate <typename... Arguments> returntype functionname(Arguments&&... args);  \ntemplate <typename... Arguments> returntype functionname(Arguments*... args);  \n```  \n  \n Specifiers like `const` are also allowed:  \n  \n```cpp  \ntemplate <typename... Arguments> returntype functionname(const Arguments&... args);  \n  \n```  \n  \n As with variadic template class definitions, you can make functions that require at least one parameter:  \n  \n```cpp  \ntemplate <typename First, typename... Rest> returntype functionname(const First& first, const Rest&... args);  \n  \n```  \n  \n Variadic templates use the `sizeof...()` operator (unrelated to the older `sizeof()` operator):  \n  \n```cpp  \ntemplate<typename... Arguments>  \nvoid tfunc(const Arguments&... args)  \n{  \n    const unsigned numargs = sizeof...(Arguments);  \n  \n    X xobj[numargs]; // array of some previously defined type X  \n  \n    helper_func(xobj, args...);  \n}  \n  \n```  \n  \n## More about ellipsis placement  \n Previously, this article described ellipsis placement that defines parameter packs and expansions as \"to the left of the parameter name, it signifies a parameter pack, and to the right of the parameter name, it expands the parameter packs into separate names\". This is technically true but can be confusing in translation to code. Consider:  \n  \n-   In a template-parameter-list (`template <parameter-list>`), `typename...` introduces a template parameter pack.  \n  \n-   In a parameter-declaration-clause (`func(parameter-list)`), a \"top-level\" ellipsis introduces a function parameter pack, and the ellipsis positioning is important:  \n  \n    ```cpp  \n  \n    // v1 is NOT a function parameter pack:  \n    template <typename... Types> void func1(std::vector<Types...> v1);   \n  \n    // v2 IS a function parameter pack:  \n    template <typename... Types> void func2(std::vector<Types>... v2);   \n    ```  \n  \n-   Where the ellipsis appears immediately after a parameter name, you have a parameter pack expansion.  \n  \n## Example  \n A good way to illustrate the variadic template function mechanism is to use it in a re-write of some of the functionality of `printf`:  \n  \n```cpp  \n#include <iostream>  \n  \nusing namespace std;  \n  \nvoid print() {  \n    cout << endl;  \n}  \n  \ntemplate <typename T> void print(const T& t) {  \n    cout << t << endl;  \n}  \n  \ntemplate <typename First, typename... Rest> void print(const First& first, const Rest&... rest) {  \n    cout << first << \", \";  \n    print(rest...); // recursive call using pack expansion syntax  \n}  \n  \nint main()  \n{  \n    print(); // calls first overload, outputting only a newline  \n    print(1); // calls second overload  \n  \n    // these call the third overload, the variadic template,   \n    // which uses recursion as needed.  \n    print(10, 20);  \n    print(100, 200, 300);  \n    print(\"first\", 2, \"third\", 3.14159);  \n}  \n  \n```  \n  \n## Output  \n  \n```  \n  \n1  \n10, 20  \n100, 200, 300  \nfirst, 2, third, 3.14159  \n```  \n  \n> [!NOTE]\n>  Most implementations that incorporate variadic template functions use recursion of some form, but it's slightly different from traditional recursion.  Traditional recursion involves a function calling itself by using the same signature. (It may be overloaded or templated, but the same signature is chosen each time.) Variadic recursion involves calling a variadic function template by using differing (almost always decreasing) numbers of arguments, and thereby stamping out a different signature every time. A \"base case\" is still required, but the nature of the recursion is different.  \n  \n"}