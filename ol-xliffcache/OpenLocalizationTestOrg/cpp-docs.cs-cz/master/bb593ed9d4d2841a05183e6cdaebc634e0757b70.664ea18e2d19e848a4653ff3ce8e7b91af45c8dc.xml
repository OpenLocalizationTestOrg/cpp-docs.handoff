{"nodes":[{"pos":[12,80],"content":"Using the Debug Build to Check for Memory Overwrite | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Using the Debug Build to Check for Memory Overwrite | Microsoft Docs","pos":[0,68]}]},{"content":"Using the Debug Build to Check for Memory Overwrite","pos":[607,658]},{"content":"To use the debug build to check for memory overwrite, you must first rebuild your project for debug.","pos":[659,759]},{"content":"Then, go to the very beginning of your application's <ph id=\"ph1\">`InitInstance`</ph> function and add the following line:","pos":[760,864],"source":" Then, go to the very beginning of your application's `InitInstance` function and add the following line:"},{"content":"The debug memory allocator puts guard bytes around all memory allocations.","pos":[918,992]},{"content":"However, these guard bytes don't do any good unless you check whether they have been changed (which would indicate a memory overwrite).","pos":[993,1128]},{"content":"Otherwise, this just provides a buffer that might, in fact, allow you to get away with a memory overwrite.","pos":[1129,1235]},{"content":"By turning on the <ph id=\"ph1\">`checkAlwaysMemDF`</ph>, you will force MFC to make a call to the <ph id=\"ph2\">`AfxCheckMemory`</ph> function every time a call to <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> is made.","pos":[1242,1398],"source":"By turning on the `checkAlwaysMemDF`, you will force MFC to make a call to the `AfxCheckMemory` function every time a call to **new** or **delete** is made."},{"content":"If a memory overwrite was detected, it will generate a TRACE message that looks similar to the following:","pos":[1399,1504]},{"content":"If you see one of these messages, you need to step through your code to determine where the damage occurred.","pos":[1558,1666]},{"content":"To isolate more precisely where the memory overwrite occurred, you can make explicit calls to <ph id=\"ph1\">`AfxCheckMemory`</ph> yourself.","pos":[1667,1787],"source":" To isolate more precisely where the memory overwrite occurred, you can make explicit calls to `AfxCheckMemory` yourself."},{"content":"For example:","pos":[1788,1800]},{"content":"If the first ASSERT succeeds and the second one fails, it means that the memory overwrite must have occurred in the function between the two calls.","pos":[1907,2054]},{"content":"Depending on the nature of your application, you may find that <ph id=\"ph1\">`afxMemDF`</ph> causes your program to run too slowly to even test.","pos":[2061,2186],"source":"Depending on the nature of your application, you may find that `afxMemDF` causes your program to run too slowly to even test."},{"content":"The <ph id=\"ph1\">`afxMemDF`</ph> variable causes <ph id=\"ph2\">`AfxCheckMemory`</ph> to be called for every call to new and delete.","pos":[2187,2281],"source":" The `afxMemDF` variable causes `AfxCheckMemory` to be called for every call to new and delete."},{"content":"In that case, you should scatter your own calls to <ph id=\"ph1\">`AfxCheckMemory`</ph>( ) as shown above, and try to isolate the memory overwrite that way.","pos":[2282,2418],"source":" In that case, you should scatter your own calls to `AfxCheckMemory`( ) as shown above, and try to isolate the memory overwrite that way."},{"content":"See Also","pos":[2427,2435]},{"content":"Fixing Release Build Problems","pos":[2440,2469]}],"content":"---\ntitle: \"Using the Debug Build to Check for Memory Overwrite | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"memory, overwrites\"\nms.assetid: 1345eb4d-24ba-4595-b1cc-2da66986311e\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Using the Debug Build to Check for Memory Overwrite\nTo use the debug build to check for memory overwrite, you must first rebuild your project for debug. Then, go to the very beginning of your application's `InitInstance` function and add the following line:  \n  \n```  \nafxMemDF |= checkAlwaysMemDF;  \n```  \n  \n The debug memory allocator puts guard bytes around all memory allocations. However, these guard bytes don't do any good unless you check whether they have been changed (which would indicate a memory overwrite). Otherwise, this just provides a buffer that might, in fact, allow you to get away with a memory overwrite.  \n  \n By turning on the `checkAlwaysMemDF`, you will force MFC to make a call to the `AfxCheckMemory` function every time a call to **new** or **delete** is made. If a memory overwrite was detected, it will generate a TRACE message that looks similar to the following:  \n  \n```  \nDamage Occurred! Block=0x5533  \n```  \n  \n If you see one of these messages, you need to step through your code to determine where the damage occurred. To isolate more precisely where the memory overwrite occurred, you can make explicit calls to `AfxCheckMemory` yourself. For example:  \n  \n```  \nASSERT(AfxCheckMemory());  \n    DoABunchOfStuff();  \n    ASSERT(AfxCheckMemory());  \n```  \n  \n If the first ASSERT succeeds and the second one fails, it means that the memory overwrite must have occurred in the function between the two calls.  \n  \n Depending on the nature of your application, you may find that `afxMemDF` causes your program to run too slowly to even test. The `afxMemDF` variable causes `AfxCheckMemory` to be called for every call to new and delete. In that case, you should scatter your own calls to `AfxCheckMemory`( ) as shown above, and try to isolate the memory overwrite that way.  \n  \n## See Also  \n [Fixing Release Build Problems](../../build/reference/fixing-release-build-problems.md)"}