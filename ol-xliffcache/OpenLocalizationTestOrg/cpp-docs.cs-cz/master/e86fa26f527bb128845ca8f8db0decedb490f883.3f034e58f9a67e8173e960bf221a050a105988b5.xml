{"nodes":[{"pos":[12,63],"content":"A Tracking Handle to a Boxed Value | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"A Tracking Handle to a Boxed Value | Microsoft Docs","pos":[0,51]}]},{"content":"A Tracking Handle to a Boxed Value","pos":[610,644]},{"pos":[645,821],"content":"The usage of a tracking handle to reference a value type has changed from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"The usage of a tracking handle to reference a value type has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"Boxing is a peculiarity of the CLR unified type system.","pos":[828,883]},{"content":"Value types directly contain their state, while reference types are an implicit pair: the named entity is a handle to an unnamed object allocated on the managed heap.","pos":[884,1050]},{"content":"Any initialization or assignment of a value type to an <ph id=\"ph1\">`Object`</ph>, for example, requires that the value type be placed within the CLR heap – this is where the image of boxing it arises – first by allocating the associated memory, then by copying the value type’s state, and then returning the address of this anonymous Value/Reference hybrid.","pos":[1051,1391],"source":" Any initialization or assignment of a value type to an `Object`, for example, requires that the value type be placed within the CLR heap – this is where the image of boxing it arises – first by allocating the associated memory, then by copying the value type’s state, and then returning the address of this anonymous Value/Reference hybrid."},{"content":"Thus, when one writes in C","pos":[1392,1418]},{"content":"there is a great deal more going on than is made apparent by the simplicity of the code.","pos":[1482,1570]},{"content":"The design of C# hides the complexity not only of what operations are taking place under the hood, but also of the abstraction of boxing itself.","pos":[1571,1715]},{"content":"Managed Extensions for C++, on the other hand, concerned that this would lead to a false sense of efficiency, puts it in the user’s face by requiring an explicit instruction:","pos":[1716,1890]},{"pos":[1979,2073],"content":"Boxing is implicit in <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>:","source":"Boxing is implicit in [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]:"},{"content":"The <ph id=\"ph1\">`__box`</ph> keyword serves a vital service within Managed Extensions, one that is absent by design from languages such as C# and <ph id=\"ph2\">[!INCLUDE[vbprvb](../dotnet/includes/vbprvb_md.md)]</ph>: it provides both a vocabulary and tracking handle for directly manipulating a boxed instance on the managed heap.","pos":[2145,2440],"source":"The `__box` keyword serves a vital service within Managed Extensions, one that is absent by design from languages such as C# and [!INCLUDE[vbprvb](../dotnet/includes/vbprvb_md.md)]: it provides both a vocabulary and tracking handle for directly manipulating a boxed instance on the managed heap."},{"content":"For example, consider the following small program:","pos":[2441,2491]},{"pos":[2847,3121],"content":"The underlying code generated for the three invocations of <ph id=\"ph1\">`WriteLine`</ph> show the various costs of accessing the value of a boxed value type (thanks to Yves Dolce for pointing out these differences), where the indicated lines show the overhead associated with each invocation.","source":"The underlying code generated for the three invocations of `WriteLine` show the various costs of accessing the value of a boxed value type (thanks to Yves Dolce for pointing out these differences), where the indicated lines show the overhead associated with each invocation."},{"content":"Passing the boxed value type directly to <ph id=\"ph1\">`Console::WriteLine`</ph> eliminates both the boxing and the need to invoke <ph id=\"ph2\">`ToString()`</ph>.","pos":[3812,3937],"source":"Passing the boxed value type directly to `Console::WriteLine` eliminates both the boxing and the need to invoke `ToString()`."},{"content":"(Of course, there is the earlier boxing to initialize <ph id=\"ph1\">`br`</ph>, so we don’t gain anything unless we really put <ph id=\"ph2\">`br`</ph> to work.","pos":[3938,4058],"source":" (Of course, there is the earlier boxing to initialize `br`, so we don’t gain anything unless we really put `br` to work."},{"content":"In the new syntax, the support for boxed value types is considerably more elegant and integrated within the type system while retaining its power.","pos":[4065,4211]},{"content":"For example, here is the translation of the earlier small program:","pos":[4212,4278]},{"content":"See Also","pos":[4599,4607]},{"content":"Value Types and Their Behaviors (C++/CLI)","pos":[4612,4653]},{"content":"How to: Explicitly Request Boxing","pos":[4714,4747]}],"content":"---\ntitle: \"A Tracking Handle to a Boxed Value | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"boxed value types, tracking handle to\"\nms.assetid: 16c92048-5b74-47d5-8eca-dfea3d38879a\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# A Tracking Handle to a Boxed Value\nThe usage of a tracking handle to reference a value type has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n Boxing is a peculiarity of the CLR unified type system. Value types directly contain their state, while reference types are an implicit pair: the named entity is a handle to an unnamed object allocated on the managed heap. Any initialization or assignment of a value type to an `Object`, for example, requires that the value type be placed within the CLR heap – this is where the image of boxing it arises – first by allocating the associated memory, then by copying the value type’s state, and then returning the address of this anonymous Value/Reference hybrid. Thus, when one writes in C#  \n  \n```  \nobject o = 1024; // C# implicit boxing  \n```  \n  \n there is a great deal more going on than is made apparent by the simplicity of the code. The design of C# hides the complexity not only of what operations are taking place under the hood, but also of the abstraction of boxing itself. Managed Extensions for C++, on the other hand, concerned that this would lead to a false sense of efficiency, puts it in the user’s face by requiring an explicit instruction:  \n  \n```  \nObject *o = __box( 1024 ); // Managed Extensions explicit boxing  \n```  \n  \n Boxing is implicit in [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]:  \n  \n```  \nObject ^o = 1024; // new syntax implicit boxing  \n```  \n  \n The `__box` keyword serves a vital service within Managed Extensions, one that is absent by design from languages such as C# and [!INCLUDE[vbprvb](../dotnet/includes/vbprvb_md.md)]: it provides both a vocabulary and tracking handle for directly manipulating a boxed instance on the managed heap. For example, consider the following small program:  \n  \n```  \nint main() {  \n   double result = 3.14159;  \n   __box double * br = __box( result );  \n  \n   result = 2.7;   \n   *br = 2.17;     \n   Object * o = br;  \n  \n   Console::WriteLine( S\"result :: {0}\", result.ToString() ) ;  \n   Console::WriteLine( S\"result :: {0}\", __box(result) ) ;  \n   Console::WriteLine( S\"result :: {0}\", br );  \n}  \n```  \n  \n The underlying code generated for the three invocations of `WriteLine` show the various costs of accessing the value of a boxed value type (thanks to Yves Dolce for pointing out these differences), where the indicated lines show the overhead associated with each invocation.  \n  \n```  \n// Console::WriteLine( S\"result :: {0}\", result.ToString() ) ;  \nldstr      \"result :: {0}\"  \nldloca.s   result  // ToString overhead  \ncall       instance string  [mscorlib]System.Double::ToString()  // ToString overhead  \ncall       void [mscorlib]System.Console::WriteLine(string, object)  \n  \n// Console::WriteLine( S\"result :: {0}\", __box(result) ) ;  \nLdstr    \" result :: {0}\"  \nldloc.0  \nbox    [mscorlib]System.Double // box overhead  \ncall    void [mscorlib]System.Console::WriteLine(string, object)  \n  \n// Console::WriteLine( S\"result :: {0}\", br );  \nldstr    \"result :: {0}\"  \nldloc.0  \ncall     void [mscorlib]System.Console::WriteLine(string, object)  \n```  \n  \n Passing the boxed value type directly to `Console::WriteLine` eliminates both the boxing and the need to invoke `ToString()`. (Of course, there is the earlier boxing to initialize `br`, so we don’t gain anything unless we really put `br` to work.  \n  \n In the new syntax, the support for boxed value types is considerably more elegant and integrated within the type system while retaining its power. For example, here is the translation of the earlier small program:  \n  \n```  \nint main()  \n{  \n   double result = 3.14159;  \n   double^ br = result;  \n   result = 2.7;  \n   *br = 2.17;  \n   Object^ o = br;  \n   Console::WriteLine( \"result :: {0}\", result.ToString() );  \n   Console::WriteLine( \"result :: {0}\", result );  \n   Console::WriteLine( \"result :: {0}\", br );  \n}  \n```  \n  \n## See Also  \n [Value Types and Their Behaviors (C++/CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)   \n [How to: Explicitly Request Boxing](../dotnet/how-to-explicitly-request-boxing.md)"}