{"nodes":[{"pos":[12,47],"content":"&lt;functional&gt; | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"functional<ph id=\"ph1\">&amp;gt;</ph> | Microsoft Docs","pos":[4,35],"source":"functional&gt; | Microsoft Docs"}]},{"content":"functional","pos":[708,718]},{"content":"Defines Standard Library functions that help construct <bpt id=\"p1\">*</bpt>function objects<ept id=\"p1\">*</ept>—also known as functors—and their binders.","pos":[723,838],"source":"Defines Standard Library functions that help construct *function objects*—also known as functors—and their binders."},{"content":"A function object is an object of a type that defines <ph id=\"ph1\">`operator()`</ph>.","pos":[839,906],"source":" A function object is an object of a type that defines `operator()`."},{"content":"A function object can be a function pointer, but more typically, the object is used to store additional information that can be accessed during a function call.","pos":[907,1067]},{"content":"Syntax","pos":[1076,1082]},{"content":"Remarks","pos":[1130,1137]},{"content":"Algorithms require two types of function objects: unary and binary.","pos":[1141,1208]},{"content":"Unary function objects require one argument, and binary function objects require two arguments.","pos":[1209,1304]},{"content":"A function object and function pointers can be passed as a predicate to an algorithm, but function objects are also adaptable and increase the scope, flexibility, and efficiency of the STL.","pos":[1305,1494]},{"content":"If, for example, a value needed to be bound to a function before being passed to an algorithm, then a function pointer could not be used.","pos":[1495,1632]},{"content":"Function adaptors convert function pointers into adaptable function objects that can be bound to a value.","pos":[1633,1738]},{"content":"The header <ph id=\"ph1\">\\&lt;</ph>functional&gt; also contains member function adaptors that allow member functions to be called as adaptable function objects.","pos":[1739,1874],"source":" The header \\<functional> also contains member function adaptors that allow member functions to be called as adaptable function objects."},{"content":"Functions are adaptable if they have nested type declarations specifying their argument and return types.","pos":[1875,1980]},{"content":"The C++ Standard requires that this adaptability is implemented by having all standard object classes inherit from the unary_function or binary_function base classes.","pos":[1981,2147]},{"content":"Function objects and their adaptors allow the STL to upgrade existing applications and help integrate the STL into the C++ programming environment.","pos":[2148,2295]},{"content":"The <ph id=\"ph1\">[!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)]</ph> implementation of the function objects in <ph id=\"ph2\">\\&lt;</ph>functional&gt; includes <bpt id=\"p1\">*</bpt>transparent operator functors<ept id=\"p1\">*</ept>, which are specializations of standard function objects and take no template parameters, and perform perfect forwarding of the function arguments and perfect return of the result.","pos":[2302,2633],"source":"The [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)] implementation of the function objects in \\<functional> includes *transparent operator functors*, which are specializations of standard function objects and take no template parameters, and perform perfect forwarding of the function arguments and perfect return of the result."},{"content":"This feature is part of the C++14 Draft Standard specification.","pos":[2634,2697]},{"content":"These template specializations do not require that you specify argument types when you invoke arithmetic, comparison, logical, and bitwise operator functors.","pos":[2698,2855]},{"content":"You can overload arithmetic, comparison, logical, or bitwise operators for your own types, or for heterogeneous combinations of types, and then use the transparent operator functors as function arguments.","pos":[2856,3060]},{"content":"For example, if your type <bpt id=\"p1\">*</bpt>MyType<ept id=\"p1\">*</ept> implements <ph id=\"ph1\">`operator&lt;`</ph>, you can call <ph id=\"ph2\">`sort(my_collection.begin(), my_collection.end(), less&lt;&gt;())`</ph> instead of explicitly specifying the type <ph id=\"ph3\">`sort(my_collection.begin(), my_collection.end(), less&lt;MyType&gt;())`</ph>.","pos":[3061,3303],"source":" For example, if your type *MyType* implements `operator<`, you can call `sort(my_collection.begin(), my_collection.end(), less<>())` instead of explicitly specifying the type `sort(my_collection.begin(), my_collection.end(), less<MyType>())`."},{"content":"C++11/C++14 Implementation","pos":[3312,3338]},{"content":"The following features are added in the Visual C++ implementation of C++11/C++14:","pos":[3342,3423]},{"pos":[3433,3561],"content":"A <bpt id=\"p1\">*</bpt>call signature<ept id=\"p1\">*</ept> is the name of a return type followed by a parenthesized comma-separated list of zero or more argument types.","source":"A *call signature* is the name of a return type followed by a parenthesized comma-separated list of zero or more argument types."},{"pos":[3571,3764],"content":"A <bpt id=\"p1\">*</bpt>callable type<ept id=\"p1\">*</ept> is a pointer to function, a pointer to member function, a pointer to member data, or a class type whose objects can appear immediately to the left of a function call operator.","source":"A *callable type* is a pointer to function, a pointer to member function, a pointer to member data, or a class type whose objects can appear immediately to the left of a function call operator."},{"pos":[3774,3826],"content":"A <bpt id=\"p1\">*</bpt>callable object<ept id=\"p1\">*</ept> is an object of a callable type.","source":"A *callable object* is an object of a callable type."},{"pos":[3836,3956],"content":"A <bpt id=\"p1\">*</bpt>call wrapper type<ept id=\"p1\">*</ept> is a type that holds a callable object and supports a call operation that forwards to that object.","source":"A *call wrapper type* is a type that holds a callable object and supports a call operation that forwards to that object."},{"pos":[3966,4019],"content":"A <bpt id=\"p1\">*</bpt>call wrapper<ept id=\"p1\">*</ept> is an object of a call wrapper type.","source":"A *call wrapper* is an object of a call wrapper type."},{"pos":[4029,4100],"content":"A <bpt id=\"p1\">*</bpt>target object<ept id=\"p1\">*</ept> is the callable object held by a call wrapper object.","source":"A *target object* is the callable object held by a call wrapper object."},{"pos":[4107,4190],"content":"The pseudo-function <ph id=\"ph1\">`INVOKE(f, t1, t2, ..., tN)`</ph> means one of the following things:","source":"The pseudo-function `INVOKE(f, t1, t2, ..., tN)` means one of the following things:"},{"pos":[4221,4404],"content":"when <ph id=\"ph1\">`f`</ph> is a pointer to member function of class <ph id=\"ph2\">`T`</ph> and <ph id=\"ph3\">`t1`</ph> is an object of type <ph id=\"ph4\">`T`</ph> or a reference to an object of type <ph id=\"ph5\">`T`</ph> or a reference to an object of a type derived from <ph id=\"ph6\">`T`</ph>.","source":" when `f` is a pointer to member function of class `T` and `t1` is an object of type `T` or a reference to an object of type `T` or a reference to an object of a type derived from `T`."},{"pos":[4438,4556],"content":"when <ph id=\"ph1\">`f`</ph> is a pointer to member function of class <ph id=\"ph2\">`T`</ph> and <ph id=\"ph3\">`t1`</ph> is not one of the types described in the previous item.","source":" when `f` is a pointer to member function of class `T` and `t1` is not one of the types described in the previous item."},{"pos":[4572,4764],"content":"when N == 1 and <ph id=\"ph1\">`f`</ph> is a pointer to member data of a class <ph id=\"ph2\">`T`</ph> and <ph id=\"ph3\">`t1`</ph> is an object of type <ph id=\"ph4\">`T`</ph> or a reference to an object of type <ph id=\"ph5\">`T`</ph> or a reference to an object of a type derived from <ph id=\"ph6\">`T`</ph>.","source":" when N == 1 and `f` is a pointer to member data of a class `T` and `t1` is an object of type `T` or a reference to an object of type `T` or a reference to an object of a type derived from `T`."},{"pos":[4783,4910],"content":"when N == 1 and <ph id=\"ph1\">`f`</ph> is a pointer to member data of a class <ph id=\"ph2\">`T`</ph> and <ph id=\"ph3\">`t1`</ph> is not one of the types described in the previous item.","source":" when N == 1 and `f` is a pointer to member data of a class `T` and `t1` is not one of the types described in the previous item."},{"pos":[4939,4958],"content":"in all other cases."},{"pos":[4965,5080],"content":"The pseudo-function <ph id=\"ph1\">`INVOKE(f, t1, t2, ..., tN, R)`</ph> means <ph id=\"ph2\">`INVOKE(f, t1, t2, ..., tN)`</ph> implicitly converted to <ph id=\"ph3\">`R`</ph>.","source":"The pseudo-function `INVOKE(f, t1, t2, ..., tN, R)` means `INVOKE(f, t1, t2, ..., tN)` implicitly converted to `R`."},{"pos":[5087,5246],"content":"If a call wrapper has a <bpt id=\"p1\">*</bpt>weak result type<ept id=\"p1\">*</ept>, the type of its member type <ph id=\"ph1\">`result_type`</ph> is based on the type <ph id=\"ph2\">`T`</ph> of the target object of the wrapper, as follows:","source":"If a call wrapper has a *weak result type*, the type of its member type `result_type` is based on the type `T` of the target object of the wrapper, as follows:"},{"pos":[5256,5343],"content":"If <ph id=\"ph1\">`T`</ph> is a pointer to function, <ph id=\"ph2\">`result_type`</ph> is a synonym for the return type of <ph id=\"ph3\">`T`</ph>.","source":"If `T` is a pointer to function, `result_type` is a synonym for the return type of `T`."},{"pos":[5353,5447],"content":"If <ph id=\"ph1\">`T`</ph> is a pointer to member function, <ph id=\"ph2\">`result_type`</ph> is a synonym for the return type of <ph id=\"ph3\">`T`</ph>.","source":"If `T` is a pointer to member function, `result_type` is a synonym for the return type of `T`."},{"pos":[5457,5571],"content":"If <ph id=\"ph1\">`T`</ph> is a class type that has a member type <ph id=\"ph2\">`result_type`</ph>, then <ph id=\"ph3\">`result_type`</ph> is a synonym for <ph id=\"ph4\">`T::result_type`</ph>.","source":"If `T` is a class type that has a member type `result_type`, then `result_type` is a synonym for `T::result_type`."},{"pos":[5581,5625],"content":"Otherwise, there is no member <ph id=\"ph1\">`result_type`</ph>.","source":"Otherwise, there is no member `result_type`."},{"content":"Every call wrapper has a move constructor and a copy constructor.","pos":[5632,5697]},{"content":"A <bpt id=\"p1\">*</bpt>simple call wrapper<ept id=\"p1\">*</ept> is a call wrapper that has an assignment operator and whose copy constructor, move constructor, and assignment operator do not throw exceptions.","pos":[5698,5866],"source":" A *simple call wrapper* is a call wrapper that has an assignment operator and whose copy constructor, move constructor, and assignment operator do not throw exceptions."},{"content":"A <bpt id=\"p1\">*</bpt>forwarding call wrapper<ept id=\"p1\">*</ept> is a call wrapper that can be called by using an arbitrary argument list and that delivers the arguments to the wrapped callable object as references.","pos":[5867,6045],"source":" A *forwarding call wrapper* is a call wrapper that can be called by using an arbitrary argument list and that delivers the arguments to the wrapped callable object as references."},{"content":"All rvalue arguments are delivered as rvalue references, and lvalue arguments are delivered as lvalue references.","pos":[6046,6159]},{"content":"Classes","pos":[6169,6176]},{"content":"bad_function_call","pos":[6198,6215]},{"pos":[6265,6446],"content":"A class that describes an exception thrown to indicate that a call to <ph id=\"ph1\">`operator()`</ph> on a <bpt id=\"p1\">[</bpt>function<ept id=\"p1\">](../standard-library/function-class.md)</ept> object failed because the object was empty.","source":"A class that describes an exception thrown to indicate that a call to `operator()` on a [function](../standard-library/function-class.md) object failed because the object was empty."},{"content":"binary_negate","pos":[6452,6465]},{"content":"A template class providing a member function that negates the return value of a specified binary function.","pos":[6511,6617]},{"content":"binder1st","pos":[6623,6632]},{"content":"A template class providing a constructor that converts a binary function object into a unary function object by binding the first argument of the binary function to a specified value.","pos":[6674,6857]},{"content":"binder2nd","pos":[6863,6872]},{"content":"A template class providing a constructor that converts a binary function object into a unary function object by binding the second argument of the binary function to a specified value.","pos":[6914,7098]},{"content":"const_mem_fun_ref_t","pos":[7104,7123]},{"content":"An adapter class that allows a const member function that takes no arguments to be called as a unary function object when initialized with a reference argument.","pos":[7175,7335]},{"content":"const_mem_fun_t","pos":[7341,7356]},{"content":"An adapter class that allows a const member function that takes no arguments to be called as a unary function object when initialized with a pointer argument.","pos":[7404,7562]},{"content":"const_mem_fun1_ref_t","pos":[7568,7588]},{"content":"An adapter class that allows a const member function that takes a single argument to be called as a binary function object when initialized with a reference argument.","pos":[7641,7807]},{"content":"const_mem_fun1_t","pos":[7813,7829]},{"content":"An adapter class that allows a const member function that takes a single argument to be called as a binary function object when initialized with a pointer argument.","pos":[7878,8042]},{"content":"function","pos":[8048,8056]},{"content":"A class that wraps a callable object.","pos":[8097,8134]},{"content":"hash","pos":[8140,8144]},{"content":"A class that computes a hash code for a value.","pos":[8181,8227]},{"content":"is_bind_expression","pos":[8233,8251]},{"pos":[8302,8373],"content":"A class that tests if a particular type is generated by calling <ph id=\"ph1\">`bind`</ph>.","source":"A class that tests if a particular type is generated by calling `bind`."},{"content":"is_placeholder","pos":[8379,8393]},{"content":"A class that tests if a particular type is a placeholder.","pos":[8440,8497]},{"content":"mem_fun_ref_t","pos":[8503,8516]},{"pos":[8562,8730],"content":"An adapter class that allows a <bpt id=\"p1\">**</bpt>non_const<ept id=\"p1\">**</ept> member function that takes no arguments to be called as a unary function object when initialized with a reference argument.","source":"An adapter class that allows a **non_const** member function that takes no arguments to be called as a unary function object when initialized with a reference argument."},{"content":"mem_fun_t","pos":[8736,8745]},{"pos":[8787,8953],"content":"An adapter class that allows a <bpt id=\"p1\">**</bpt>non_const<ept id=\"p1\">**</ept> member function that takes no arguments to be called as a unary function object when initialized with a pointer argument.","source":"An adapter class that allows a **non_const** member function that takes no arguments to be called as a unary function object when initialized with a pointer argument."},{"content":"mem_fun1_ref_t","pos":[8959,8973]},{"pos":[9020,9194],"content":"An adapter class that allows a <bpt id=\"p1\">**</bpt>non_const<ept id=\"p1\">**</ept> member function that takes a single argument to be called as a binary function object when initialized with a reference argument.","source":"An adapter class that allows a **non_const** member function that takes a single argument to be called as a binary function object when initialized with a reference argument."},{"content":"mem_fun1_t","pos":[9200,9210]},{"pos":[9253,9425],"content":"An adapter class that allows a <bpt id=\"p1\">**</bpt>non_const<ept id=\"p1\">**</ept> member function that takes a single argument to be called as a binary function object when initialized with a pointer argument.","source":"An adapter class that allows a **non_const** member function that takes a single argument to be called as a binary function object when initialized with a pointer argument."},{"content":"pointer_to_binary_function","pos":[9431,9457]},{"content":"Converts a binary function pointer into an adaptable binary function.","pos":[9516,9585]},{"content":"pointer_to_unary_function","pos":[9591,9616]},{"content":"Converts a unary function pointer into an adaptable unary function.","pos":[9674,9741]},{"content":"reference_wrapper","pos":[9747,9764]},{"content":"A class that wraps a reference.","pos":[9814,9845]},{"content":"result_of","pos":[9851,9860]},{"content":"A struct that holds the return type of a wrapped callable object.","pos":[9903,9968]},{"content":"unary_negate","pos":[9974,9986]},{"content":"A template class providing a member function that negates the return value of a specified unary function.","pos":[10031,10136]},{"content":"Functions","pos":[10147,10156]},{"content":"bind","pos":[10178,10182]},{"content":"Binds arguments to a callable object.","pos":[10243,10280]},{"content":"bind1st","pos":[10286,10293]},{"content":"A helper template function that creates an adaptor to convert a binary function object into a unary function object by binding the first argument of the binary function to a specified value.","pos":[10357,10547]},{"content":"bind2nd","pos":[10553,10560]},{"content":"A helper template function that creates an adaptor to convert a binary function object into a unary function object by binding the second argument of the binary function to a specified value.","pos":[10624,10815]},{"content":"bit_and","pos":[10821,10828]},{"content":"Returns the bitwise logical AND (binary operator&amp;) of the two parameters.","pos":[10892,10965],"source":"Returns the bitwise logical AND (binary operator&) of the two parameters."},{"content":"bit_not","pos":[10971,10978]},{"content":"Returns the bitwise logical complement (operator~) of the parameter.","pos":[11042,11110]},{"content":"bit_or","pos":[11116,11122]},{"content":"Returns the bitwise logical OR (operator&amp;#124;) of the two parameters.","pos":[11185,11255],"source":"Returns the bitwise logical OR (operator&#124;) of the two parameters."},{"content":"bit_xor","pos":[11261,11268]},{"content":"Returns the bitwise logical XOR (operator^) of the two parameters.","pos":[11332,11398]},{"content":"cref","pos":[11404,11408]},{"pos":[11469,11525],"content":"Constructs a const <ph id=\"ph1\">`reference_wrapper`</ph> from an argument.","source":"Constructs a const `reference_wrapper` from an argument."},{"content":"mem_fn","pos":[11531,11537]},{"content":"Generates a simple call wrapper.","pos":[11600,11632]},{"content":"mem_fun","pos":[11638,11645]},{"content":"Helper template functions used to construct function object adaptors for member functions when initialized with pointer arguments.","pos":[11709,11839]},{"content":"mem_fun_ref","pos":[11845,11856]},{"content":"A helper template function used to construct function object adaptors for member functions when initialized with reference arguments.","pos":[11924,12057]},{"content":"not1","pos":[12063,12067]},{"content":"Returns the complement of a unary predicate.","pos":[12128,12172]},{"content":"not2","pos":[12178,12182]},{"content":"Returns the complement of a binary predicate.","pos":[12243,12288]},{"content":"ptr_fun","pos":[12294,12301]},{"content":"A helper template function used to convert unary and binary function pointers, respectively, into unary and binary adaptable functions.","pos":[12365,12500]},{"content":"ref","pos":[12506,12509]},{"pos":[12569,12619],"content":"Constructs a <ph id=\"ph1\">`reference_wrapper`</ph> from an argument.","source":"Constructs a `reference_wrapper` from an argument."},{"content":"swap","pos":[12625,12629]},{"pos":[12690,12719],"content":"Swaps two <ph id=\"ph1\">`function`</ph> objects.","source":"Swaps two `function` objects."},{"content":"Structs","pos":[12730,12737]},{"content":"binary_function","pos":[12759,12774]},{"content":"An empty base class that defines types that may be inherited by derived class that provides a binary function object.","pos":[12823,12940]},{"content":"divides","pos":[12946,12953]},{"content":"The class provides a predefined function object that performs the arithmetic operation of division on elements of a specified value type.","pos":[12994,13131]},{"content":"equal_to","pos":[13137,13145]},{"content":"A binary predicate that tests whether a value of a specified type is equal to another value of that type.","pos":[13187,13292]},{"content":"greater","pos":[13298,13305]},{"content":"A binary predicate that tests whether a value of a specified type is greater than another value of that type.","pos":[13346,13455]},{"content":"greater_equal","pos":[13461,13474]},{"content":"A binary predicate that tests whether a value of a specified type is greater than or equal to another value of that type.","pos":[13521,13642]},{"content":"less","pos":[13648,13652]},{"content":"A binary predicate that tests whether a value of a specified type is less than another value of that type.","pos":[13690,13796]},{"content":"less_equal","pos":[13802,13812]},{"content":"A binary predicate that tests whether a value of a specified type is less than or equal to another value of that type.","pos":[13856,13974]},{"content":"logical_and","pos":[13980,13991]},{"content":"The class provides a predefined function object that performs the logical operation of conjunction on elements of a specified value type and tests for the truth or falsity of the result.","pos":[14036,14222]},{"content":"logical_not","pos":[14228,14239]},{"content":"The class provides a predefined function object that performs the logical operation of negation on elements of a specified value type and tests for the truth or falsity of the result.","pos":[14284,14467]},{"content":"logical_or","pos":[14473,14483]},{"content":"The class provides a predefined function object that performs the logical operation of disjunction on elements of a specified value type and tests for the truth or falsity of the result.","pos":[14527,14713]},{"content":"minus","pos":[14719,14724]},{"content":"The class provides a predefined function object that performs the arithmetic operation of subtraction on elements of a specified value type.","pos":[14763,14903]},{"content":"modulus","pos":[14909,14916]},{"content":"The class provides a predefined function object that performs the arithmetic operation of modulus on elements of a specified value type.","pos":[14957,15093]},{"content":"multiplies","pos":[15099,15109]},{"content":"The class provides a predefined function object that performs the arithmetic operation of multiplication on elements of a specified value type.","pos":[15153,15296]},{"content":"negate","pos":[15302,15308]},{"content":"The class provides a predefined function object that returns the negative of an element value.","pos":[15348,15442]},{"content":"not_equal_to","pos":[15448,15460]},{"content":"A binary predicate that tests whether a value of a specified type is not equal to another value of that type.","pos":[15506,15615]},{"content":"plus","pos":[15621,15625]},{"content":"The class provides a predefined function object that performs the arithmetic operation of addition on elements of a specified value type.","pos":[15663,15800]},{"content":"unary_function","pos":[15806,15820]},{"content":"An empty base class that defines types that may be inherited by derived class that provides a unary function object.","pos":[15868,15984]},{"content":"Objects","pos":[15995,16002]},{"content":"_1.._M","pos":[16024,16030]},{"content":"Placeholders for replaceable arguments.","pos":[16065,16104]},{"content":"Operators","pos":[16115,16124]},{"content":"operator==","pos":[16146,16156]},{"content":"Disallows equality comparison of callable objects.","pos":[16218,16268]},{"content":"operator!=","pos":[16274,16284]},{"content":"Disallows inequality comparison of callable objects.","pos":[16344,16396]},{"content":"See Also","pos":[16406,16414]},{"content":"Header Files Reference","pos":[16419,16441]},{"content":"Thread Safety in the C++ Standard Library","pos":[16506,16547]},{"content":"C++ Standard Library Reference","pos":[16620,16650]}],"content":"---\ntitle: \"&lt;functional&gt; | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"<functional>\"\n  - \"functional/std::<functional>\"\n  - \"std.<functional>\"\n  - \"std::<functional>\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"functors\"\n  - \"functional header\"\nms.assetid: 7dd463e8-a29f-49bc-aedd-8fa53b54bfbc\ncaps.latest.revision: 27\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# &lt;functional&gt;\nDefines Standard Library functions that help construct *function objects*—also known as functors—and their binders. A function object is an object of a type that defines `operator()`. A function object can be a function pointer, but more typically, the object is used to store additional information that can be accessed during a function call.  \n  \n## Syntax  \n  \n```  \n#include <functional>  \n```  \n  \n## Remarks  \n Algorithms require two types of function objects: unary and binary. Unary function objects require one argument, and binary function objects require two arguments. A function object and function pointers can be passed as a predicate to an algorithm, but function objects are also adaptable and increase the scope, flexibility, and efficiency of the STL. If, for example, a value needed to be bound to a function before being passed to an algorithm, then a function pointer could not be used. Function adaptors convert function pointers into adaptable function objects that can be bound to a value. The header \\<functional> also contains member function adaptors that allow member functions to be called as adaptable function objects. Functions are adaptable if they have nested type declarations specifying their argument and return types. The C++ Standard requires that this adaptability is implemented by having all standard object classes inherit from the unary_function or binary_function base classes. Function objects and their adaptors allow the STL to upgrade existing applications and help integrate the STL into the C++ programming environment.  \n  \n The [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)] implementation of the function objects in \\<functional> includes *transparent operator functors*, which are specializations of standard function objects and take no template parameters, and perform perfect forwarding of the function arguments and perfect return of the result. This feature is part of the C++14 Draft Standard specification. These template specializations do not require that you specify argument types when you invoke arithmetic, comparison, logical, and bitwise operator functors. You can overload arithmetic, comparison, logical, or bitwise operators for your own types, or for heterogeneous combinations of types, and then use the transparent operator functors as function arguments. For example, if your type *MyType* implements `operator<`, you can call `sort(my_collection.begin(), my_collection.end(), less<>())` instead of explicitly specifying the type `sort(my_collection.begin(), my_collection.end(), less<MyType>())`.  \n  \n## C++11/C++14 Implementation  \n The following features are added in the Visual C++ implementation of C++11/C++14:  \n  \n-   A *call signature* is the name of a return type followed by a parenthesized comma-separated list of zero or more argument types.  \n  \n-   A *callable type* is a pointer to function, a pointer to member function, a pointer to member data, or a class type whose objects can appear immediately to the left of a function call operator.  \n  \n-   A *callable object* is an object of a callable type.  \n  \n-   A *call wrapper type* is a type that holds a callable object and supports a call operation that forwards to that object.  \n  \n-   A *call wrapper* is an object of a call wrapper type.  \n  \n-   A *target object* is the callable object held by a call wrapper object.  \n  \n The pseudo-function `INVOKE(f, t1, t2, ..., tN)` means one of the following things:  \n  \n- `(t1.*f)(t2, ..., tN)` when `f` is a pointer to member function of class `T` and `t1` is an object of type `T` or a reference to an object of type `T` or a reference to an object of a type derived from `T`.  \n  \n- `((*t1).*f)(t2, ..., tN)` when `f` is a pointer to member function of class `T` and `t1` is not one of the types described in the previous item.  \n  \n- `t1.*f` when N == 1 and `f` is a pointer to member data of a class `T` and `t1` is an object of type `T` or a reference to an object of type `T` or a reference to an object of a type derived from `T`.  \n  \n- `(*t1).*f` when N == 1 and `f` is a pointer to member data of a class `T` and `t1` is not one of the types described in the previous item.  \n  \n- `f(t1, t2, ..., tN)` in all other cases.  \n  \n The pseudo-function `INVOKE(f, t1, t2, ..., tN, R)` means `INVOKE(f, t1, t2, ..., tN)` implicitly converted to `R`.  \n  \n If a call wrapper has a *weak result type*, the type of its member type `result_type` is based on the type `T` of the target object of the wrapper, as follows:  \n  \n-   If `T` is a pointer to function, `result_type` is a synonym for the return type of `T`.  \n  \n-   If `T` is a pointer to member function, `result_type` is a synonym for the return type of `T`.  \n  \n-   If `T` is a class type that has a member type `result_type`, then `result_type` is a synonym for `T::result_type`.  \n  \n-   Otherwise, there is no member `result_type`.  \n  \n Every call wrapper has a move constructor and a copy constructor. A *simple call wrapper* is a call wrapper that has an assignment operator and whose copy constructor, move constructor, and assignment operator do not throw exceptions. A *forwarding call wrapper* is a call wrapper that can be called by using an arbitrary argument list and that delivers the arguments to the wrapped callable object as references. All rvalue arguments are delivered as rvalue references, and lvalue arguments are delivered as lvalue references.  \n  \n### Classes  \n  \n|||  \n|-|-|  \n|[bad_function_call](../standard-library/bad-function-call-class.md)|A class that describes an exception thrown to indicate that a call to `operator()` on a [function](../standard-library/function-class.md) object failed because the object was empty.|  \n|[binary_negate](../standard-library/binary-negate-class.md)|A template class providing a member function that negates the return value of a specified binary function.|  \n|[binder1st](../standard-library/binder1st-class.md)|A template class providing a constructor that converts a binary function object into a unary function object by binding the first argument of the binary function to a specified value.|  \n|[binder2nd](../standard-library/binder2nd-class.md)|A template class providing a constructor that converts a binary function object into a unary function object by binding the second argument of the binary function to a specified value.|  \n|[const_mem_fun_ref_t](../standard-library/const-mem-fun-ref-t-class.md)|An adapter class that allows a const member function that takes no arguments to be called as a unary function object when initialized with a reference argument.|  \n|[const_mem_fun_t](../standard-library/const-mem-fun-t-class.md)|An adapter class that allows a const member function that takes no arguments to be called as a unary function object when initialized with a pointer argument.|  \n|[const_mem_fun1_ref_t](../standard-library/const-mem-fun1-ref-t-class.md)|An adapter class that allows a const member function that takes a single argument to be called as a binary function object when initialized with a reference argument.|  \n|[const_mem_fun1_t](../standard-library/const-mem-fun1-t-class.md)|An adapter class that allows a const member function that takes a single argument to be called as a binary function object when initialized with a pointer argument.|  \n|[function](../standard-library/function-class.md)|A class that wraps a callable object.|  \n|[hash](../standard-library/hash-class.md)|A class that computes a hash code for a value.|  \n|[is_bind_expression](../standard-library/is-bind-expression-class.md)|A class that tests if a particular type is generated by calling `bind`.|  \n|[is_placeholder](../standard-library/is-placeholder-class.md)|A class that tests if a particular type is a placeholder.|  \n|[mem_fun_ref_t](../standard-library/mem-fun-ref-t-class.md)|An adapter class that allows a **non_const** member function that takes no arguments to be called as a unary function object when initialized with a reference argument.|  \n|[mem_fun_t](../standard-library/mem-fun-t-class.md)|An adapter class that allows a **non_const** member function that takes no arguments to be called as a unary function object when initialized with a pointer argument.|  \n|[mem_fun1_ref_t](../standard-library/mem-fun1-ref-t-class.md)|An adapter class that allows a **non_const** member function that takes a single argument to be called as a binary function object when initialized with a reference argument.|  \n|[mem_fun1_t](../standard-library/mem-fun1-t-class.md)|An adapter class that allows a **non_const** member function that takes a single argument to be called as a binary function object when initialized with a pointer argument.|  \n|[pointer_to_binary_function](../standard-library/pointer-to-binary-function-class.md)|Converts a binary function pointer into an adaptable binary function.|  \n|[pointer_to_unary_function](../standard-library/pointer-to-unary-function-class.md)|Converts a unary function pointer into an adaptable unary function.|  \n|[reference_wrapper](../standard-library/reference-wrapper-class.md)|A class that wraps a reference.|  \n|[result_of](../standard-library/result-of-class2.md)|A struct that holds the return type of a wrapped callable object.|  \n|[unary_negate](../standard-library/unary-negate-class.md)|A template class providing a member function that negates the return value of a specified unary function.|  \n  \n### Functions  \n  \n|||  \n|-|-|  \n|[bind](../standard-library/functional-functions.md#bind_function)|Binds arguments to a callable object.|  \n|[bind1st](../standard-library/functional-functions.md#bind1st_function)|A helper template function that creates an adaptor to convert a binary function object into a unary function object by binding the first argument of the binary function to a specified value.|  \n|[bind2nd](../standard-library/functional-functions.md#bind2nd_function)|A helper template function that creates an adaptor to convert a binary function object into a unary function object by binding the second argument of the binary function to a specified value.|  \n|[bit_and](../standard-library/functional-functions.md#bit_and_function)|Returns the bitwise logical AND (binary operator&) of the two parameters.|  \n|[bit_not](../standard-library/functional-functions.md#bit_not_function)|Returns the bitwise logical complement (operator~) of the parameter.|  \n|[bit_or](../standard-library/functional-functions.md#bit_or_function)|Returns the bitwise logical OR (operator&#124;) of the two parameters.|  \n|[bit_xor](../standard-library/functional-functions.md#bit_xor_function)|Returns the bitwise logical XOR (operator^) of the two parameters.|  \n|[cref](../standard-library/functional-functions.md#cref_function)|Constructs a const `reference_wrapper` from an argument.|  \n|[mem_fn](../standard-library/functional-functions.md#mem_fn_function)|Generates a simple call wrapper.|  \n|[mem_fun](../standard-library/functional-functions.md#mem_fun_function)|Helper template functions used to construct function object adaptors for member functions when initialized with pointer arguments.|  \n|[mem_fun_ref](../standard-library/functional-functions.md#mem_fun_ref_function)|A helper template function used to construct function object adaptors for member functions when initialized with reference arguments.|  \n|[not1](../standard-library/functional-functions.md#not1_function)|Returns the complement of a unary predicate.|  \n|[not2](../standard-library/functional-functions.md#not2_function)|Returns the complement of a binary predicate.|  \n|[ptr_fun](../standard-library/functional-functions.md#ptr_fun_function)|A helper template function used to convert unary and binary function pointers, respectively, into unary and binary adaptable functions.|  \n|[ref](../standard-library/functional-functions.md#ref_function)|Constructs a `reference_wrapper` from an argument.|  \n|[swap](../standard-library/functional-functions.md#swap_function)|Swaps two `function` objects.|  \n  \n### Structs  \n  \n|||  \n|-|-|  \n|[binary_function](../standard-library/binary-function-struct.md)|An empty base class that defines types that may be inherited by derived class that provides a binary function object.|  \n|[divides](../standard-library/divides-struct.md)|The class provides a predefined function object that performs the arithmetic operation of division on elements of a specified value type.|  \n|[equal_to](../standard-library/equal-to-struct.md)|A binary predicate that tests whether a value of a specified type is equal to another value of that type.|  \n|[greater](../standard-library/greater-struct.md)|A binary predicate that tests whether a value of a specified type is greater than another value of that type.|  \n|[greater_equal](../standard-library/greater-equal-struct.md)|A binary predicate that tests whether a value of a specified type is greater than or equal to another value of that type.|  \n|[less](../standard-library/less-struct.md)|A binary predicate that tests whether a value of a specified type is less than another value of that type.|  \n|[less_equal](../standard-library/less-equal-struct.md)|A binary predicate that tests whether a value of a specified type is less than or equal to another value of that type.|  \n|[logical_and](../standard-library/logical-and-struct.md)|The class provides a predefined function object that performs the logical operation of conjunction on elements of a specified value type and tests for the truth or falsity of the result.|  \n|[logical_not](../standard-library/logical-not-struct.md)|The class provides a predefined function object that performs the logical operation of negation on elements of a specified value type and tests for the truth or falsity of the result.|  \n|[logical_or](../standard-library/logical-or-struct.md)|The class provides a predefined function object that performs the logical operation of disjunction on elements of a specified value type and tests for the truth or falsity of the result.|  \n|[minus](../standard-library/minus-struct.md)|The class provides a predefined function object that performs the arithmetic operation of subtraction on elements of a specified value type.|  \n|[modulus](../standard-library/modulus-struct.md)|The class provides a predefined function object that performs the arithmetic operation of modulus on elements of a specified value type.|  \n|[multiplies](../standard-library/multiplies-struct.md)|The class provides a predefined function object that performs the arithmetic operation of multiplication on elements of a specified value type.|  \n|[negate](../standard-library/negate-struct.md)|The class provides a predefined function object that returns the negative of an element value.|  \n|[not_equal_to](../standard-library/not-equal-to-struct.md)|A binary predicate that tests whether a value of a specified type is not equal to another value of that type.|  \n|[plus](../standard-library/plus-struct.md)|The class provides a predefined function object that performs the arithmetic operation of addition on elements of a specified value type.|  \n|[unary_function](../standard-library/unary-function-struct.md)|An empty base class that defines types that may be inherited by derived class that provides a unary function object.|  \n  \n### Objects  \n  \n|||  \n|-|-|  \n|[_1.._M](../standard-library/1-object.md)|Placeholders for replaceable arguments.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|[operator==](../standard-library/functional-operators.md#operator_eq_eq)|Disallows equality comparison of callable objects.|  \n|[operator!=](../standard-library/functional-operators.md#operator_neq)|Disallows inequality comparison of callable objects.|  \n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)\n\n"}