{"nodes":[{"pos":[12,45],"content":"implements (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"implements (C++) | Microsoft Docs","pos":[0,33]}]},{"content":"implements (C++)","pos":[625,641]},{"content":"Specifies dispatch interfaces that are forced to be members of the IDL coclass.","pos":[642,721]},{"content":"Syntax","pos":[730,736]},{"content":"Parameters","pos":[860,870]},{"content":"interfaces","pos":[876,886]},{"content":"A comma separated list of the interfaces that will be a member of the IDL coclass.","pos":[892,974]},{"content":"A shorthand method for specifying a single interface is <bpt id=\"p1\">**</bpt>implements(<ept id=\"p1\">**</ept><bpt id=\"p2\">*</bpt>interface_name<ept id=\"p2\">*</ept><bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>.","pos":[975,1068],"source":" A shorthand method for specifying a single interface is **implements(***interface_name***)**."},{"content":"dispinterfaces","pos":[1077,1091]},{"content":"A comma separated list of the dispinterface that will be a member of the IDL coclass.","pos":[1097,1182]},{"content":"A shorthand method for specifying a single dispinterface is <bpt id=\"p1\">**</bpt>implements(dispinterfaces<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>= dispinterface_name<ept id=\"p2\">*</ept><bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>.","pos":[1183,1301],"source":" A shorthand method for specifying a single dispinterface is **implements(dispinterfaces** *= dispinterface_name***)**."},{"content":"Remarks","pos":[1310,1317]},{"content":"By default, only COM-interfaces that are base classes of the coclass are added in the IDL coclass.","pos":[1321,1419]},{"content":"<bpt id=\"p1\">**</bpt>implements<ept id=\"p1\">**</ept> lets you force other interfaces to be IDL coclass members.","pos":[1420,1493],"source":"**implements** lets you force other interfaces to be IDL coclass members."},{"content":"Requirements","pos":[1502,1514]},{"content":"Attribute Context","pos":[1524,1541]},{"content":"Applies to","pos":[1564,1574]},{"pos":[1577,1587],"content":"<bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept>,","source":"**class**, "},{"content":"Repeatable","pos":[1603,1613]},{"content":"Yes","pos":[1616,1619]},{"content":"Required attributes","pos":[1626,1645]},{"content":"None","pos":[1648,1652]},{"content":"Invalid attributes","pos":[1659,1677]},{"content":"None","pos":[1680,1684]},{"pos":[1692,1773],"content":"For more information, see <bpt id=\"p1\">[</bpt>Attribute Contexts<ept id=\"p1\">](../windows/attribute-contexts.md)</ept>.","source":"For more information, see [Attribute Contexts](../windows/attribute-contexts.md)."},{"content":"Example","pos":[1782,1789]},{"content":"The following example is in three parts: an .idl file and its associated .h file, and a C++ file.","pos":[1793,1890]},{"content":"Assume the following .idl file, which will be available to the compiler.","pos":[1897,1969]},{"content":"Example","pos":[2849,2856]},{"content":"And the following .h file, which also needs to be available to the compiler.","pos":[2860,2936]},{"content":"Example","pos":[10909,10916]},{"content":"In the following program, without implements, IBar1, IBar2, and ISna will not be in the coclass in the generated IDL.","pos":[10920,11037]},{"content":"See Also","pos":[14694,14702]},{"content":"Compiler Attributes","pos":[14707,14726]},{"content":"Class Attributes","pos":[14768,14784]},{"content":"Attributes Samples","pos":[14823,14841]}],"content":"---\ntitle: \"implements (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"vc-attr.implements\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"implements attribute\"\nms.assetid: 9cf0858b-cb7d-4d3c-81a6-97d87ed00d25\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# implements (C++)\nSpecifies dispatch interfaces that are forced to be members of the IDL coclass.  \n  \n## Syntax  \n  \n```  \n  \n      [ implements(   \n   interfaces={interfaces},  \n   dispinterfaces={dispinterfaces}  \n)]  \n```  \n  \n#### Parameters  \n **interfaces**  \n A comma separated list of the interfaces that will be a member of the IDL coclass. A shorthand method for specifying a single interface is **implements(***interface_name***)**.  \n  \n **dispinterfaces**  \n A comma separated list of the dispinterface that will be a member of the IDL coclass. A shorthand method for specifying a single dispinterface is **implements(dispinterfaces** *= dispinterface_name***)**.  \n  \n## Remarks  \n By default, only COM-interfaces that are base classes of the coclass are added in the IDL coclass. **implements** lets you force other interfaces to be IDL coclass members.  \n  \n## Requirements  \n  \n### Attribute Context  \n  \n|||  \n|-|-|  \n|**Applies to**|**class**, `struct`|  \n|**Repeatable**|Yes|  \n|**Required attributes**|None|  \n|**Invalid attributes**|None|  \n  \n For more information, see [Attribute Contexts](../windows/attribute-contexts.md).  \n  \n## Example  \n The following example is in three parts: an .idl file and its associated .h file, and a C++ file.  \n  \n Assume the following .idl file, which will be available to the compiler.  \n  \n```  \n// attr_implements.idl  \nimport \"docobj.idl\";  \n[ version(1.0), uuid(0ed71801-a1b6-3178-af3b-9431fc00185e) ]  \nlibrary odod  \n{  \n   importlib(\"stdole2.tlb\");  \n   importlib(\"olepro32.dll\");  \n  \n   [  \n      object,  \n      uuid(1AECC9BB-2104-3723-98B8-7CC54722C7DD)  \n   ]   \n   interface IBar1 {  \n      [id(1)] HRESULT bar1();  \n   };  \n  \n   [  \n      dual,  \n      uuid(1AECCABB-2104-3723-98B8-7CC54722C7DD)  \n   ]   \n   interface IBar2 {  \n      [id(1)] HRESULT bar2();  \n   };  \n  \n   [  \n      uuid(1AECC9CC-2104-3723-98B8-7CC54722C7DD)  \n   ]   \n   dispinterface ISna {  \n   properties:  \n  \n   methods:  \n      [id(1)] HRESULT sna();  \n   };  \n  \n   [  \n      uuid(159A9BBB-E5F1-33F6-BEF5-6CFAD7A5933F),  \n      version(1.0)  \n   ]   \n   coclass CBar {  \n      interface IBar1;  \n      interface IBar2;  \n      dispinterface ISna;  \n   };  \n}  \n```  \n  \n## Example  \n And the following .h file, which also needs to be available to the compiler.  \n  \n```  \n// attr_implements.h  \n// this ALWAYS GENERATED file contains definitions for the interfaces  \n  \n/* File created by MIDL compiler version 6.00.0361 */  \n/* at Mon Feb 28 16:30:53 2005 */  \n/* Compiler settings for attr_implements.idl:  \n    Oicf, W1, Zp8, env=Win32 (32b run)  \n    protocol : dce , ms_ext, c_ext, robust  \n    error checks: allocation ref bounds_check enum stub_data   \n    VC __declspec() decoration level:   \n         __declspec(uuid()), __declspec(selectany), __declspec(novtable)  \n         DECLSPEC_UUID(), MIDL_INTERFACE()  \n*/  \n//@@MIDL_FILE_HEADING(  )  \n  \n#pragma warning( disable: 4049 )  /* more than 64k source lines */  \n  \n/* verify that the <rpcndr.h> version is high enough to compile this file*/  \n#ifndef __REQUIRED_RPCNDR_H_VERSION__  \n#define __REQUIRED_RPCNDR_H_VERSION__ 475  \n#endif  \n  \n#include \"rpc.h\"  \n#include \"rpcndr.h\"  \n  \n#ifndef __RPCNDR_H_VERSION__  \n#error this stub requires an updated version of <rpcndr.h>  \n#endif // __RPCNDR_H_VERSION__  \n  \n#ifndef __attr_implements_h__  \n#define __attr_implements_h__  \n  \n#if defined(_MSC_VER) && (_MSC_VER >= 1020)  \n#pragma once  \n#endif  \n  \n/* Forward Declarations */   \n  \n#ifndef __IBar1_FWD_DEFINED__  \n#define __IBar1_FWD_DEFINED__  \ntypedef interface IBar1 IBar1;  \n#endif /* __IBar1_FWD_DEFINED__ */  \n  \n#ifndef __IBar2_FWD_DEFINED__  \n#define __IBar2_FWD_DEFINED__  \ntypedef interface IBar2 IBar2;  \n#endif /* __IBar2_FWD_DEFINED__ */  \n  \n#ifndef __ISna_FWD_DEFINED__  \n#define __ISna_FWD_DEFINED__  \ntypedef interface ISna ISna;  \n#endif /* __ISna_FWD_DEFINED__ */  \n  \n#ifndef __CBar_FWD_DEFINED__  \n#define __CBar_FWD_DEFINED__  \n  \n#ifdef __cplusplus  \ntypedef class CBar CBar;  \n#else  \ntypedef struct CBar CBar;  \n#endif /* __cplusplus */  \n  \n#endif /* __CBar_FWD_DEFINED__ */  \n  \n/* header files for imported files */  \n#include \"docobj.h\"  \n  \n#ifdef __cplusplus  \nextern \"C\"{  \n#endif   \n  \nvoid * __RPC_USER MIDL_user_allocate(size_t);  \nvoid __RPC_USER MIDL_user_free( void * );   \n  \n#ifndef __odod_LIBRARY_DEFINED__  \n#define __odod_LIBRARY_DEFINED__  \n  \n/* library odod */  \n/* [uuid][version] */   \n  \nEXTERN_C const IID LIBID_odod;  \n  \n#ifndef __IBar1_INTERFACE_DEFINED__  \n#define __IBar1_INTERFACE_DEFINED__  \n  \n/* interface IBar1 */  \n/* [uuid][object] */   \n  \nEXTERN_C const IID IID_IBar1;  \n  \n#if defined(__cplusplus) && !defined(CINTERFACE)  \n  \n    MIDL_INTERFACE(\"1AECC9BB-2104-3723-98B8-7CC54722C7DD\")  \n    IBar1  \n    {  \n    public:  \n        BEGIN_INTERFACE  \n        virtual /* [id] */ HRESULT STDMETHODCALLTYPE bar1( void) = 0;  \n  \n        END_INTERFACE  \n    };  \n  \n#else /* C style interface */  \n  \n    typedef struct IBar1Vtbl  \n    {  \n        BEGIN_INTERFACE  \n  \n        /* [id] */ HRESULT ( STDMETHODCALLTYPE *bar1 )(   \n            IBar1 * This);  \n  \n        END_INTERFACE  \n    } IBar1Vtbl;  \n  \n    interface IBar1  \n    {  \n        CONST_VTBL struct IBar1Vtbl *lpVtbl;  \n    };  \n  \n#ifdef COBJMACROS  \n  \n#define IBar1_bar1(This)\\  \n    (This)->lpVtbl -> bar1(This)  \n  \n#endif /* COBJMACROS */  \n  \n#endif /* C style interface */  \n  \n/* [id] */ HRESULT STDMETHODCALLTYPE IBar1_bar1_Proxy(   \n    IBar1 * This);  \n  \nvoid __RPC_STUB IBar1_bar1_Stub(  \n    IRpcStubBuffer *This,  \n    IRpcChannelBuffer *_pRpcChannelBuffer,  \n    PRPC_MESSAGE _pRpcMessage,  \n    DWORD *_pdwStubPhase);  \n  \n#endif /* __IBar1_INTERFACE_DEFINED__ */  \n  \n#ifndef __IBar2_INTERFACE_DEFINED__  \n#define __IBar2_INTERFACE_DEFINED__  \n  \n/* interface IBar2 */  \n/* [auto_handle][uuid][dual] */   \n  \nEXTERN_C const IID IID_IBar2;  \n  \n#if defined(__cplusplus) && !defined(CINTERFACE)  \n  \n    MIDL_INTERFACE(\"1AECCABB-2104-3723-98B8-7CC54722C7DD\")  \n    IBar2  \n    {  \n    public:  \n        BEGIN_INTERFACE  \n        virtual /* [id] */ HRESULT STDMETHODCALLTYPE bar2( void) = 0;  \n  \n        END_INTERFACE  \n    };  \n  \n#else /* C style interface */  \n  \n    typedef struct IBar2Vtbl  \n    {  \n        BEGIN_INTERFACE  \n  \n        /* [id] */ HRESULT ( STDMETHODCALLTYPE *bar2 )(   \n            IBar2 * This);  \n  \n        END_INTERFACE  \n    } IBar2Vtbl;  \n  \n    interface IBar2  \n    {  \n        CONST_VTBL struct IBar2Vtbl *lpVtbl;  \n    };  \n  \n#ifdef COBJMACROS  \n  \n#define IBar2_bar2(This)\\  \n    (This)->lpVtbl -> bar2(This)  \n  \n#endif /* COBJMACROS */  \n  \n#endif /* C style interface */  \n  \n/* [id] */ HRESULT STDMETHODCALLTYPE IBar2_bar2_Proxy(   \n    IBar2 * This);  \n  \nvoid __RPC_STUB IBar2_bar2_Stub(  \n    IRpcStubBuffer *This,  \n    IRpcChannelBuffer *_pRpcChannelBuffer,  \n    PRPC_MESSAGE _pRpcMessage,  \n    DWORD *_pdwStubPhase);  \n  \n#endif /* __IBar2_INTERFACE_DEFINED__ */  \n  \n#ifndef __ISna_DISPINTERFACE_DEFINED__  \n#define __ISna_DISPINTERFACE_DEFINED__  \n  \n/* dispinterface ISna */  \n/* [uuid] */   \n  \nEXTERN_C const IID DIID_ISna;  \n  \n#if defined(__cplusplus) && !defined(CINTERFACE)  \n  \n    MIDL_INTERFACE(\"1AECC9CC-2104-3723-98B8-7CC54722C7DD\")  \n    ISna : public IDispatch  \n    {  \n    };  \n  \n#else /* C style interface */  \n  \n    typedef struct ISnaVtbl  \n    {  \n        BEGIN_INTERFACE  \n  \n        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(   \n            ISna * This,  \n            /* [in] */ REFIID riid,  \n            /* [iid_is][out] */ void **ppvObject);  \n  \n        ULONG ( STDMETHODCALLTYPE *AddRef )(   \n            ISna * This);  \n  \n        ULONG ( STDMETHODCALLTYPE *Release )(   \n            ISna * This);  \n  \n        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(   \n            ISna * This,  \n            /* [out] */ UINT *pctinfo);  \n  \n        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(   \n            ISna * This,  \n            /* [in] */ UINT iTInfo,  \n            /* [in] */ LCID lcid,  \n            /* [out] */ ITypeInfo **ppTInfo);  \n  \n        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(   \n            ISna * This,  \n            /* [in] */ REFIID riid,  \n            /* [size_is][in] */ LPOLESTR *rgszNames,  \n            /* [in] */ UINT cNames,  \n            /* [in] */ LCID lcid,  \n            /* [size_is][out] */ DISPID *rgDispId);  \n  \n        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(   \n            ISna * This,  \n            /* [in] */ DISPID dispIdMember,  \n            /* [in] */ REFIID riid,  \n            /* [in] */ LCID lcid,  \n            /* [in] */ WORD wFlags,  \n            /* [out][in] */ DISPPARAMS *pDispParams,  \n            /* [out] */ VARIANT *pVarResult,  \n            /* [out] */ EXCEPINFO *pExcepInfo,  \n            /* [out] */ UINT *puArgErr);  \n  \n        END_INTERFACE  \n    } ISnaVtbl;  \n  \n    interface ISna  \n    {  \n        CONST_VTBL struct ISnaVtbl *lpVtbl;  \n    };  \n  \n#ifdef COBJMACROS  \n  \n#define ISna_QueryInterface(This,riid,ppvObject)\\  \n    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)  \n  \n#define ISna_AddRef(This)\\  \n    (This)->lpVtbl -> AddRef(This)  \n  \n#define ISna_Release(This)\\  \n    (This)->lpVtbl -> Release(This)  \n  \n#define ISna_GetTypeInfoCount(This,pctinfo)\\  \n    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)  \n  \n#define ISna_GetTypeInfo(This,iTInfo,lcid,ppTInfo)\\  \n    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)  \n  \n#define ISna_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)\\  \n    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \n  \n#define ISna_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)\\  \n    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)  \n  \n#endif /* COBJMACROS */  \n  \n#endif /* C style interface */  \n  \n#endif /* __ISna_DISPINTERFACE_DEFINED__ */  \n  \nEXTERN_C const CLSID CLSID_CBar;  \n  \n#ifdef __cplusplus  \n  \nclass DECLSPEC_UUID(\"159A9BBB-E5F1-33F6-BEF5-6CFAD7A5933F\")  \nCBar;  \n#endif  \n#endif /* __odod_LIBRARY_DEFINED__ */  \n  \n/* Additional Prototypes for ALL interfaces */  \n  \n/* end of Additional Prototypes */  \n  \n#ifdef __cplusplus  \n}  \n#endif  \n#endif  \n```  \n  \n## Example  \n In the following program, without implements, IBar1, IBar2, and ISna will not be in the coclass in the generated IDL.  \n  \n```  \n// attr_implements.cpp  \n// compile with: /LD /link /idlout:out.idl  \n#define _ATL_ATTRIBUTES 1  \n#include <atlbase.h>  \n#include <atlcom.h>  \n#include \"attr_implements.h\"   // IDL generated header that contains a definition of the pseudo-interface IBar and pseudo-dispinterface  ISna  \n  \n[module(name = \"MyLib\")];  \n  \n[dispinterface, uuid(\"00000000-0000-0000-0000-000000000001\")]   \n__interface IMyInterface  \n{  \n   [id(0)] long x;  \n   [id(1)] HRESULT func();  \n};  \n  \n[  \n   coclass,  \n   uuid(\"00000000-0000-0000-0000-000000000002\"),  \n   implements(interfaces={IBar1,IBar2}, dispinterfaces=ISna)  \n]   \nclass CMyClass : public IMyInterface,   \n   public IBar1,  \n      public IDispatchImpl<IBar2, &__uuidof(IBar2)>,   \n   public ISna  \n{  \n   long _x;  \npublic:  \n   long get_x() { return _x; }  \n   void put_x(long x0) { _x = x0; }  \n   HRESULT func() { return S_OK; }  \n   HRESULT __stdcall bar1() { return S_OK; }  \n   HRESULT __stdcall bar2() { return S_OK; }  \n   HRESULT __stdcall sna() { return S_OK; }  \n  \n   virtual HRESULT STDMETHODCALLTYPE ISna::Invoke(  \n            /* [in] */ DISPID dispIdMember,  \n            /* [in] */ REFIID riid,  \n            /* [in] */ LCID lcid,  \n            /* [in] */ WORD wFlags,  \n            /* [out][in] */ DISPPARAMS *pDispParams,  \n            /* [out] */ VARIANT *pVarResult,  \n            /* [out] */ EXCEPINFO *pExcepInfo,  \n            /* [out] */ UINT *puArgErr)   \n   {  \n      HRESULT hr = S_OK;  \n      if (pDispParams == 0) {  \n         return DISP_E_BADVARTYPE;  \n      }  \n      if (pDispParams->cArgs > 0) {  \n         return DISP_E_BADPARAMCOUNT;  \n      }  \n      if (pVarResult != 0) {  \n         ::VariantInit(pVarResult);  \n      }  \n      switch (dispIdMember) {  \n      case 1:  \n         {  \n            if (pDispParams->cArgs != 0) {  \n               return DISP_E_BADPARAMCOUNT;  \n            }  \n            hr = this->sna();  \n            break;  \n         }  \n      default:  \n         return DISP_E_MEMBERNOTFOUND;  \n      }  \n      return hr;  \n   }  \n   virtual HRESULT STDMETHODCALLTYPE ISna::GetIDsOfNames(  \n            /* [in] */ REFIID riid,  \n            /* [size_is][in] */ LPOLESTR *rgszNames,  \n            /* [in] */ UINT cNames,  \n            /* [in] */ LCID lcid,  \n            /* [size_is][out] */ DISPID *rgDispId)   \n   {  \n      static LPOLESTR names[] = { L\"sna\" };  \n      static DISPID dids[] = { 1 };  \n      for (unsigned int i = 0; i < cNames; ++i) {  \n         int fFoundIt = 0;  \n         for (unsigned int j = 0; j < sizeof(names)/sizeof(LPOLESTR); ++j) {  \n            if (lstrcmpiW(rgszNames[i], names[j]) == 0) {  \n               fFoundIt = 1;  \n               rgDispId[i] = dids[j];  \n               break;  \n            }  \n         }  \n         if (fFoundIt == 0) {  \n            return DISP_E_UNKNOWNNAME;  \n         }  \n      }  \n      return S_OK;  \n   }  \n   virtual HRESULT STDMETHODCALLTYPE ISna::GetTypeInfoCount(unsigned int*  pctinfo)   \n   {  \n      if (pctinfo == NULL) {  \n         return E_POINTER;  \n      }  \n      CComPtr<ITypeInfo> spTypeInfo;  \n      *pctinfo =   \n                  (SUCCEEDED(TypeInfoHelper(__uuidof(ISna), 0, &spTypeInfo))) ? 1 : 0;  \n      return S_OK;  \n   }  \n   virtual HRESULT STDMETHODCALLTYPE ISna::GetTypeInfo(unsigned int iTInfo, LCID lcid, ITypeInfo** ppTInfo)   \n   {  \n      if (iTInfo != 0) {  \n         return DISP_E_BADINDEX;  \n      }  \n      return TypeInfoHelper(__uuidof(ISna), lcid, ppTInfo);  \n   }  \n   BEGIN_COM_MAP(CMyClass)  \n      COM_INTERFACE_ENTRY(IBar1)  \n      COM_INTERFACE_ENTRY(IBar2)  \n      COM_INTERFACE_ENTRY(ISna)  \n   END_COM_MAP()  \n};  \n```  \n  \n## See Also  \n [Compiler Attributes](../windows/compiler-attributes.md)   \n [Class Attributes](../windows/class-attributes.md)   \n [Attributes Samples](http://msdn.microsoft.com/en-us/558ebdb2-082f-44dc-b442-d8d33bf7bdb8)"}