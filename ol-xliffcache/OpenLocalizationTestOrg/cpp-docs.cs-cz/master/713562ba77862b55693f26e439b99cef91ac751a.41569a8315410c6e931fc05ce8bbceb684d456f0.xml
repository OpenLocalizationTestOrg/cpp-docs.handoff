{"nodes":[{"pos":[12,75],"content":"Overload Resolution of Function Template Calls | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Overload Resolution of Function Template Calls | Microsoft Docs","pos":[0,63]}]},{"content":"Overload Resolution of Function Template Calls","pos":[634,680]},{"content":"A function template can overload nontemplate functions of the same name.","pos":[681,753]},{"content":"In this scenario, function calls are resolved by first using template argument deduction to instantiate the function template with a unique specialization.","pos":[754,909]},{"content":"If template argument deduction fails, the other function overloads are considered to resolve the call.","pos":[910,1012]},{"content":"These other overloads, also known as the candidate set, include nontemplate functions and other instantiated function templates.","pos":[1013,1141]},{"content":"If template argument deduction succeeds, then the generated function is compared with the other functions to determine the best match, following the rules for overload resolution.","pos":[1142,1321]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Function Overloading<ept id=\"p1\">](function-overloading.md)</ept>.","pos":[1322,1396],"source":" For more information, see [Function Overloading](function-overloading.md)."},{"content":"Example","pos":[1405,1412]},{"pos":[1416,1635],"content":"If a nontemplate function is an equally good match to a template function, the nontemplate function is chosen (unless the template arguments were explicitly specified), as in the call <ph id=\"ph1\">`f(1, 1)`</ph> in the following example.","source":"If a nontemplate function is an equally good match to a template function, the nontemplate function is chosen (unless the template arguments were explicitly specified), as in the call `f(1, 1)` in the following example."},{"content":"Example","pos":[2263,2270]},{"content":"The next example illustrates that the exactly matching template function is preferred if the nontemplate function requires a conversion.","pos":[2274,2410]},{"content":"See Also","pos":[2927,2935]},{"content":"Name Resolution","pos":[2940,2955]},{"content":"typename","pos":[3003,3011]}],"content":"---\ntitle: \"Overload Resolution of Function Template Calls | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"function templates overload resolution\"\nms.assetid: a2918748-2cbb-4fc6-a176-e256f120bee4\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Overload Resolution of Function Template Calls\nA function template can overload nontemplate functions of the same name. In this scenario, function calls are resolved by first using template argument deduction to instantiate the function template with a unique specialization. If template argument deduction fails, the other function overloads are considered to resolve the call. These other overloads, also known as the candidate set, include nontemplate functions and other instantiated function templates. If template argument deduction succeeds, then the generated function is compared with the other functions to determine the best match, following the rules for overload resolution. For more information, see [Function Overloading](function-overloading.md).  \n  \n## Example  \n If a nontemplate function is an equally good match to a template function, the nontemplate function is chosen (unless the template arguments were explicitly specified), as in the call `f(1, 1)` in the following example.  \n  \n```  \n// template_name_resolution9.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \nvoid f(int, int) { cout << \"f(int, int)\" << endl; }  \nvoid f(char, char) { cout << \"f(char, char)\" << endl; }  \n  \ntemplate <class T1, class T2>  \nvoid f(T1, T2)  \n{  \n   cout << \"void f(T1, T2)\" << endl;  \n};  \n  \nint main()  \n{  \n   f(1, 1);   // Equally good match; choose the nontemplate function.  \n   f('a', 1); // Chooses the template function.  \n   f<int, int>(2, 2);  // Template arguments explicitly specified.  \n}  \n```  \n  \n```Output  \nf(int, int)  \nvoid f(T1, T2)  \nvoid f(T1, T2)  \n```  \n  \n## Example  \n The next example illustrates that the exactly matching template function is preferred if the nontemplate function requires a conversion.  \n  \n```  \n// template_name_resolution10.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \nvoid f(int, int) { cout << \"f(int, int)\" << endl; }  \n  \ntemplate <class T1, class T2>  \nvoid f(T1, T2)  \n{  \n   cout << \"void f(T1, T2)\" << endl;  \n};  \n  \nint main()  \n{  \n   long l = 0;  \n   int i = 0;  \n   // Call the template function f(long, int) because f(int, int)  \n   // would require a conversion from long to int.  \n   f(l, i);  \n}  \n```  \n  \n```Output  \nvoid f(T1, T2)  \n```  \n  \n## See Also  \n [Name Resolution](../cpp/templates-and-name-resolution.md)   \n [typename](../cpp/typename.md)   \n "}