{"nodes":[{"pos":[12,65],"content":"How Catch Blocks are Evaluated (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How Catch Blocks are Evaluated (C++) | Microsoft Docs","pos":[0,53]}]},{"content":"How Catch Blocks are Evaluated (C++)","pos":[818,854]},{"content":"C++ enables you to throw exceptions of any type, although in general it is recommended to throw types that are derived from std::exception.","pos":[855,994]},{"content":"A C++ exception can be caught by a <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> handler that specifies the same type as the thrown exception, or by a handler that can catch any type of exception.","pos":[995,1155],"source":" A C++ exception can be caught by a **catch** handler that specifies the same type as the thrown exception, or by a handler that can catch any type of exception."},{"content":"If the type of thrown exception is a class, which also has a base class (or classes), it can be caught by handlers that accept base classes of the exception's type, as well as references to bases of the exception's type.","pos":[1162,1382]},{"content":"Note that when an exception is caught by a reference, it is bound to the actual thrown exception object; otherwise, it is a copy (much the same as an argument to a function).","pos":[1383,1557]},{"pos":[1564,1655],"content":"When an exception is thrown, it may be caught by the following types of <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> handlers:","source":"When an exception is thrown, it may be caught by the following types of **catch** handlers:"},{"content":"A handler that can accept any type (using the ellipsis syntax).","pos":[1665,1728]},{"pos":[1738,1869],"content":"A handler that accepts the same type as the exception object; because it is a copy, <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`volatile`</ph> modifiers are ignored.","source":"A handler that accepts the same type as the exception object; because it is a copy, **const** and `volatile` modifiers are ignored."},{"content":"A handler that accepts a reference to the same type as the exception object.","pos":[1879,1955]},{"pos":[1965,2075],"content":"A handler that accepts a reference to a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph> form of the same type as the exception object.","source":"A handler that accepts a reference to a **const** or `volatile` form of the same type as the exception object."},{"content":"A handler that accepts a base class of the same type as the exception object; since it is a copy, <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`volatile`</ph> modifiers are ignored.","pos":[2085,2230],"source":"A handler that accepts a base class of the same type as the exception object; since it is a copy, **const** and `volatile` modifiers are ignored."},{"content":"The <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> handler for a base class must not precede the <bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> handler for the derived class.","pos":[2231,2331],"source":" The **catch** handler for a base class must not precede the **catch** handler for the derived class."},{"content":"A handler that accepts a reference to a base class of the same type as the exception object.","pos":[2341,2433]},{"pos":[2443,2569],"content":"A handler that accepts a reference to a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph> form of a base class of the same type as the exception object.","source":"A handler that accepts a reference to a **const** or `volatile` form of a base class of the same type as the exception object."},{"content":"A handler that accepts a pointer to which a thrown pointer object can be converted via standard pointer conversion rules.","pos":[2579,2700]},{"content":"The order in which <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> handlers appear is significant, because handlers for a given <bpt id=\"p2\">**</bpt>try<ept id=\"p2\">**</ept> block are examined in order of their appearance.","pos":[2707,2853],"source":"The order in which **catch** handlers appear is significant, because handlers for a given **try** block are examined in order of their appearance."},{"content":"For example, it is an error to place the handler for a base class before the handler for a derived class.","pos":[2854,2959]},{"content":"After a matching <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> handler is found, subsequent handlers are not examined.","pos":[2960,3042],"source":" After a matching **catch** handler is found, subsequent handlers are not examined."},{"content":"As a result, an ellipsis <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> handler must be the last handler for its <bpt id=\"p2\">**</bpt>try<ept id=\"p2\">**</ept> block.","pos":[3043,3133],"source":" As a result, an ellipsis **catch** handler must be the last handler for its **try** block."},{"content":"For example:","pos":[3134,3146]},{"pos":[3477,3562],"content":"In this example, the ellipsis <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> handler is the only handler that is examined.","source":"In this example, the ellipsis **catch** handler is the only handler that is examined."},{"content":"See Also","pos":[3571,3579]},{"content":"C++ Exception Handling","pos":[3584,3606]}],"content":"---\ntitle: \"How Catch Blocks are Evaluated (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"try-catch keyword [C++], catchable types\"\n  - \"catch keyword [C++], types of catch handlers\"\n  - \"C++ exception handling, catch handlers\"\n  - \"exception handling, catching and deleting exceptions\"\n  - \"types [C++], exception handling\"\nms.assetid: 202dbf07-8ace-4b3b-b3ae-4b45c275e0b4\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How Catch Blocks are Evaluated (C++)\nC++ enables you to throw exceptions of any type, although in general it is recommended to throw types that are derived from std::exception. A C++ exception can be caught by a **catch** handler that specifies the same type as the thrown exception, or by a handler that can catch any type of exception.  \n  \n If the type of thrown exception is a class, which also has a base class (or classes), it can be caught by handlers that accept base classes of the exception's type, as well as references to bases of the exception's type. Note that when an exception is caught by a reference, it is bound to the actual thrown exception object; otherwise, it is a copy (much the same as an argument to a function).  \n  \n When an exception is thrown, it may be caught by the following types of **catch** handlers:  \n  \n-   A handler that can accept any type (using the ellipsis syntax).  \n  \n-   A handler that accepts the same type as the exception object; because it is a copy, **const** and `volatile` modifiers are ignored.  \n  \n-   A handler that accepts a reference to the same type as the exception object.  \n  \n-   A handler that accepts a reference to a **const** or `volatile` form of the same type as the exception object.  \n  \n-   A handler that accepts a base class of the same type as the exception object; since it is a copy, **const** and `volatile` modifiers are ignored. The **catch** handler for a base class must not precede the **catch** handler for the derived class.  \n  \n-   A handler that accepts a reference to a base class of the same type as the exception object.  \n  \n-   A handler that accepts a reference to a **const** or `volatile` form of a base class of the same type as the exception object.  \n  \n-   A handler that accepts a pointer to which a thrown pointer object can be converted via standard pointer conversion rules.  \n  \n The order in which **catch** handlers appear is significant, because handlers for a given **try** block are examined in order of their appearance. For example, it is an error to place the handler for a base class before the handler for a derived class. After a matching **catch** handler is found, subsequent handlers are not examined. As a result, an ellipsis **catch** handler must be the last handler for its **try** block. For example:  \n  \n```  \n// ...  \ntry  \n{  \n    // ...  \n}  \ncatch( ... )  \n{  \n    // Handle exception here.  \n}  \n// Error: the next two handlers are never examined.  \ncatch( const char * str )  \n{  \n    cout << \"Caught exception: \" << str << endl;  \n}  \ncatch( CExcptClass E )  \n{  \n    // Handle CExcptClass exception here.  \n}  \n```  \n  \n In this example, the ellipsis **catch** handler is the only handler that is examined.  \n  \n## See Also  \n [C++ Exception Handling](../cpp/cpp-exception-handling.md)"}