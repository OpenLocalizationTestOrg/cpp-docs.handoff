{"nodes":[{"pos":[12,68],"content":"TN061: ON_NOTIFY and WM_NOTIFY Messages | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN061: ON_NOTIFY and WM_NOTIFY Messages | Microsoft Docs","pos":[0,56]}]},{"content":"TN061: ON_NOTIFY and WM_NOTIFY Messages","pos":[820,859]},{"pos":[862,1177],"content":"[!NOTE]\n The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","leadings":["","> "],"nodes":[{"content":" The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[8,313],"nodes":[{"content":"The following technical note has not been updated since it was first included in the online documentation.","pos":[1,107]},{"content":"As a result, some procedures and topics might be out of date or incorrect.","pos":[108,182]},{"content":"For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[183,305]}]}]},{"pos":[1184,1380],"content":"This technical note provides background information on the new <bpt id=\"p1\">**</bpt>WM_NOTIFY<ept id=\"p1\">**</ept> message and describes the recommended (and most common) way of handling <bpt id=\"p2\">**</bpt>WM_NOTIFY<ept id=\"p2\">**</ept> messages in your MFC application.","source":"This technical note provides background information on the new **WM_NOTIFY** message and describes the recommended (and most common) way of handling **WM_NOTIFY** messages in your MFC application."},{"content":"Notification Messages in Windows 3.x","pos":[1389,1425]},{"content":"In Windows 3.x, controls notify their parents of events such as mouse clicks, changes in content and selection, and control background painting by sending a message to the parent.","pos":[1434,1613]},{"content":"Simple notifications are sent as special <bpt id=\"p1\">**</bpt>WM_COMMAND<ept id=\"p1\">**</ept> messages, with the notification code (such as <bpt id=\"p2\">**</bpt>BN_CLICKED<ept id=\"p2\">**</ept>) and control ID packed into <ph id=\"ph1\">`wParam`</ph> and the control's handle in <ph id=\"ph2\">`lParam`</ph>.","pos":[1614,1805],"source":" Simple notifications are sent as special **WM_COMMAND** messages, with the notification code (such as **BN_CLICKED**) and control ID packed into `wParam` and the control's handle in `lParam`."},{"content":"Note that since <ph id=\"ph1\">`wParam`</ph> and <ph id=\"ph2\">`lParam`</ph> are full, there is no way to pass any additional data — these messages can be only simple notification.","pos":[1806,1947],"source":" Note that since `wParam` and `lParam` are full, there is no way to pass any additional data — these messages can be only simple notification."},{"content":"For instance, in the <bpt id=\"p1\">**</bpt>BN_CLICKED<ept id=\"p1\">**</ept> notification, there's no way to send information about the location of the mouse cursor when the button was clicked.","pos":[1948,2100],"source":" For instance, in the **BN_CLICKED** notification, there's no way to send information about the location of the mouse cursor when the button was clicked."},{"content":"When controls in Windows 3.x need to send a notification message that includes additional data, they use a variety of special-purpose messages, including <ph id=\"ph1\">`WM_CTLCOLOR`</ph>, <ph id=\"ph2\">`WM_VSCROLL`</ph>, <ph id=\"ph3\">`WM_HSCROLL`</ph>, <ph id=\"ph4\">`WM_DRAWITEM`</ph>, <ph id=\"ph5\">`WM_MEASUREITEM`</ph>, <ph id=\"ph6\">`WM_COMPAREITEM`</ph>, <ph id=\"ph7\">`WM_DELETEITEM`</ph>, <ph id=\"ph8\">`WM_CHARTOITEM`</ph>, <ph id=\"ph9\">`WM_VKEYTOITEM`</ph>, and so on.","pos":[2107,2416],"source":"When controls in Windows 3.x need to send a notification message that includes additional data, they use a variety of special-purpose messages, including `WM_CTLCOLOR`, `WM_VSCROLL`, `WM_HSCROLL`, `WM_DRAWITEM`, `WM_MEASUREITEM`, `WM_COMPAREITEM`, `WM_DELETEITEM`, `WM_CHARTOITEM`, `WM_VKEYTOITEM`, and so on."},{"content":"These messages can be reflected back to the control that sent them.","pos":[2417,2484]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>TN062: Message Reflection for Windows Controls<ept id=\"p1\">](../mfc/tn062-message-reflection-for-windows-controls.md)</ept>.","pos":[2485,2617],"source":" For more information, see [TN062: Message Reflection for Windows Controls](../mfc/tn062-message-reflection-for-windows-controls.md)."},{"content":"Notification Messages in Win32","pos":[2626,2656]},{"content":"For controls that existed in Windows 3.1, the Win32 API uses most of the notification messages that were used in Windows 3.x.","pos":[2665,2790]},{"content":"However, Win32 also adds a number of sophisticated, complex controls to those supported in Windows 3.x.","pos":[2791,2894]},{"content":"Frequently, these controls need to send additional data with their notification messages.","pos":[2895,2984]},{"content":"Rather than adding a new <bpt id=\"p1\">**</bpt>WM_<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> message for each new notification that needs additional data, the designers of the Win32 API chose to add just one message, <bpt id=\"p2\">**</bpt>WM_NOTIFY<ept id=\"p2\">**</ept>, which can pass any amount of additional data in a standardized fashion.","pos":[2985,3230],"source":" Rather than adding a new **WM_\\*** message for each new notification that needs additional data, the designers of the Win32 API chose to add just one message, **WM_NOTIFY**, which can pass any amount of additional data in a standardized fashion."},{"content":"<bpt id=\"p1\">**</bpt>WM_NOTIFY<ept id=\"p1\">**</ept> messages contain the ID of the control sending the message in <ph id=\"ph1\">`wParam`</ph> and a pointer to a structure in <ph id=\"ph2\">`lParam`</ph>.","pos":[3237,3363],"source":"**WM_NOTIFY** messages contain the ID of the control sending the message in `wParam` and a pointer to a structure in `lParam`."},{"content":"This structure is either an <bpt id=\"p1\">**</bpt>NMHDR<ept id=\"p1\">**</ept> structure or some larger structure that has an <bpt id=\"p2\">**</bpt>NMHDR<ept id=\"p2\">**</ept> structure as its first member.","pos":[3364,3489],"source":" This structure is either an **NMHDR** structure or some larger structure that has an **NMHDR** structure as its first member."},{"content":"Note that since the <bpt id=\"p1\">**</bpt>NMHDR<ept id=\"p1\">**</ept> member is first, a pointer to this structure can be used as either a pointer to an <bpt id=\"p2\">**</bpt>NMHDR<ept id=\"p2\">**</ept> or as a pointer to the larger structure depending on how you cast it.","pos":[3490,3682],"source":" Note that since the **NMHDR** member is first, a pointer to this structure can be used as either a pointer to an **NMHDR** or as a pointer to the larger structure depending on how you cast it."},{"content":"In most cases, the pointer will point to a larger structure and you'll need to cast it when you use it.","pos":[3689,3792]},{"content":"In only a few notifications, such as the common notifications (whose names start with <bpt id=\"p1\">**</bpt>NM_<ept id=\"p1\">**</ept>) and the tool tip control's <bpt id=\"p2\">**</bpt>TTN_SHOW<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>TTN_POP<ept id=\"p3\">**</ept> notifications, is an <bpt id=\"p4\">**</bpt>NMHDR<ept id=\"p4\">**</ept> structure actually used.","pos":[3793,3999],"source":" In only a few notifications, such as the common notifications (whose names start with **NM_**) and the tool tip control's **TTN_SHOW** and **TTN_POP** notifications, is an **NMHDR** structure actually used."},{"content":"The <bpt id=\"p1\">**</bpt>NMHDR<ept id=\"p1\">**</ept> structure or initial member contains the handle and ID of the control sending the message and the notification code (such as <bpt id=\"p2\">**</bpt>TTN_SHOW<ept id=\"p2\">**</ept>).","pos":[4006,4159],"source":"The **NMHDR** structure or initial member contains the handle and ID of the control sending the message and the notification code (such as **TTN_SHOW**)."},{"content":"The format of the <bpt id=\"p1\">**</bpt>NMHDR<ept id=\"p1\">**</ept> structure is shown below:","pos":[4160,4213],"source":" The format of the **NMHDR** structure is shown below:"},{"pos":[4331,4408],"content":"For a <bpt id=\"p1\">**</bpt>TTN_SHOW<ept id=\"p1\">**</ept> message, the <bpt id=\"p2\">**</bpt>code<ept id=\"p2\">**</ept> member would be set to <bpt id=\"p3\">**</bpt>TTN_SHOW<ept id=\"p3\">**</ept>.","source":"For a **TTN_SHOW** message, the **code** member would be set to **TTN_SHOW**."},{"content":"Most notifications pass a pointer to a larger structure that contains an <bpt id=\"p1\">**</bpt>NMHDR<ept id=\"p1\">**</ept> structure as its first member.","pos":[4415,4528],"source":"Most notifications pass a pointer to a larger structure that contains an **NMHDR** structure as its first member."},{"content":"For instance, consider the structure used by the list view control's <bpt id=\"p1\">**</bpt>LVN_KEYDOWN<ept id=\"p1\">**</ept> notification message, which is sent when a key is pressed in a list view control.","pos":[4529,4695],"source":" For instance, consider the structure used by the list view control's **LVN_KEYDOWN** notification message, which is sent when a key is pressed in a list view control."},{"content":"The pointer points to an <bpt id=\"p1\">**</bpt>LV_KEYDOWN<ept id=\"p1\">**</ept> structure, which is defined as shown below:","pos":[4696,4779],"source":" The pointer points to an **LV_KEYDOWN** structure, which is defined as shown below:"},{"pos":[4910,5111],"content":"Note that since the <bpt id=\"p1\">**</bpt>NMHDR<ept id=\"p1\">**</ept> member is first in this structure, the pointer you're passed in the notification message can be cast to either a pointer to an <bpt id=\"p2\">**</bpt>NMHDR<ept id=\"p2\">**</ept> or a pointer to an <bpt id=\"p3\">**</bpt>LV_KEYDOWN<ept id=\"p3\">**</ept>.","source":"Note that since the **NMHDR** member is first in this structure, the pointer you're passed in the notification message can be cast to either a pointer to an **NMHDR** or a pointer to an **LV_KEYDOWN**."},{"content":"Notifications Common to All New Windows Controls","pos":[5120,5168]},{"content":"Some notifications are common to all of the new Windows controls.","pos":[5177,5242]},{"content":"These notifications pass a pointer to an <bpt id=\"p1\">**</bpt>NMHDR<ept id=\"p1\">**</ept> structure.","pos":[5243,5304],"source":" These notifications pass a pointer to an **NMHDR** structure."},{"content":"Notification code","pos":[5311,5328]},{"content":"Sent because","pos":[5329,5341]},{"content":"NM_CLICK","pos":[5395,5403]},{"content":"User clicked left mouse button in the control","pos":[5406,5451]},{"content":"NM_DBLCLK","pos":[5458,5467]},{"content":"User double-clicked left mouse button in the control","pos":[5470,5522]},{"content":"NM_RCLICK","pos":[5529,5538]},{"content":"User clicked right mouse button in the control","pos":[5541,5587]},{"content":"NM_RDBLCLK","pos":[5594,5604]},{"content":"User double-clicked right mouse button in the control","pos":[5607,5660]},{"content":"NM_RETURN","pos":[5667,5676]},{"content":"User pressed the ENTER key while control has input focus","pos":[5679,5735]},{"content":"NM_SETFOCUS","pos":[5742,5753]},{"content":"Control has been given input focus","pos":[5756,5790]},{"content":"NM_KILLFOCUS","pos":[5797,5809]},{"content":"Control has lost input focus","pos":[5812,5840]},{"content":"NM_OUTOFMEMORY","pos":[5847,5861]},{"content":"Control could not complete an operation because there was not enough memory available","pos":[5864,5949]},{"pos":[6047,6105],"content":"ON_NOTIFY: Handling WM_NOTIFY Messages in MFC Applications"},{"content":"The function <ph id=\"ph1\">`CWnd::OnNotify`</ph> handles notification messages.","pos":[6109,6169],"source":"The function `CWnd::OnNotify` handles notification messages."},{"content":"Its default implementation checks the message map for notification handlers to call.","pos":[6170,6254]},{"content":"In general, you do not override <ph id=\"ph1\">`OnNotify`</ph>.","pos":[6255,6298],"source":" In general, you do not override `OnNotify`."},{"content":"Instead, you provide a handler function and add a message-map entry for that handler to the message map of your owner window's class.","pos":[6299,6432]},{"content":"ClassWizard, via the ClassWizard property sheet, can create the <ph id=\"ph1\">`ON_NOTIFY`</ph> message-map entry and provide you with a skeleton handler function.","pos":[6439,6582],"source":"ClassWizard, via the ClassWizard property sheet, can create the `ON_NOTIFY` message-map entry and provide you with a skeleton handler function."},{"content":"For more information on using ClassWizard to make this easier, see <bpt id=\"p1\">[</bpt>Mapping Messages to Functions<ept id=\"p1\">](../mfc/reference/mapping-messages-to-functions.md)</ept>.","pos":[6583,6733],"source":" For more information on using ClassWizard to make this easier, see [Mapping Messages to Functions](../mfc/reference/mapping-messages-to-functions.md)."},{"pos":[6740,6799],"content":"The <ph id=\"ph1\">`ON_NOTIFY`</ph> message-map macro has the following syntax:","source":"The `ON_NOTIFY` message-map macro has the following syntax:"},{"content":"where the italicized parameters are replaced with:","pos":[6876,6926]},{"content":"The code for the notification message to be handled, such as <bpt id=\"p1\">**</bpt>LVN_KEYDOWN<ept id=\"p1\">**</ept>.","pos":[6950,7027],"source":" The code for the notification message to be handled, such as **LVN_KEYDOWN**."},{"content":"The child identifier of the control for which the notification is sent.","pos":[7042,7113]},{"content":"The member function to be called when this notification is sent.","pos":[7135,7199]},{"content":"Your member function must be declared with the following prototype:","pos":[7206,7273]},{"content":"Remarks","pos":[7373,7380]},{"content":"where the italicized parameters are:","pos":[7384,7420]},{"content":"A pointer to the notification structure, as described in the section above.","pos":[7446,7521]},{"content":"result","pos":[7529,7535]},{"content":"A pointer to the result code you'll set before you return.","pos":[7540,7598]},{"content":"Example","pos":[7607,7614]},{"pos":[7618,7828],"content":"To specify that you want the member function <ph id=\"ph1\">`OnKeydownList1`</ph> to handle <bpt id=\"p1\">**</bpt>LVN_KEYDOWN<ept id=\"p1\">**</ept> messages from the <ph id=\"ph2\">`CListCtrl`</ph> whose ID is <ph id=\"ph3\">`IDC_LIST1`</ph>, you would use ClassWizard to add the following to your message map:","source":"To specify that you want the member function `OnKeydownList1` to handle **LVN_KEYDOWN** messages from the `CListCtrl` whose ID is `IDC_LIST1`, you would use ClassWizard to add the following to your message map:"},{"content":"In the example above, the function provided by ClassWizard is:","pos":[7910,7972]},{"content":"Note that ClassWizard provides a pointer of the proper type automatically.","pos":[8218,8292]},{"content":"You can access the notification structure through either <ph id=\"ph1\">`pNMHDR`</ph> or <ph id=\"ph2\">`pLVKeyDow`</ph>.","pos":[8293,8374],"source":" You can access the notification structure through either `pNMHDR` or `pLVKeyDow`."},{"pos":[8425,8440],"content":"ON_NOTIFY_RANGE"},{"content":"If you need to process the same <bpt id=\"p1\">**</bpt>WM_NOTIFY<ept id=\"p1\">**</ept> message for a set of controls, you can use <bpt id=\"p2\">**</bpt>ON_NOTIFY_RANGE<ept id=\"p2\">**</ept> rather than <ph id=\"ph1\">`ON_NOTIFY`</ph>.","pos":[8444,8577],"source":"If you need to process the same **WM_NOTIFY** message for a set of controls, you can use **ON_NOTIFY_RANGE** rather than `ON_NOTIFY`."},{"content":"For instance, you may have a set of buttons for which you want to perform the same action for a certain notification message.","pos":[8578,8703]},{"pos":[8710,8911],"content":"When you use <bpt id=\"p1\">**</bpt>ON_NOTIFY_RANGE<ept id=\"p1\">**</ept>, you specify a contiguous range of child identifiers for which to handle the notification message by specifying the beginning and ending child identifiers of the range.","source":"When you use **ON_NOTIFY_RANGE**, you specify a contiguous range of child identifiers for which to handle the notification message by specifying the beginning and ending child identifiers of the range."},{"pos":[8918,9021],"content":"ClassWizard does not handle <bpt id=\"p1\">**</bpt>ON_NOTIFY_RANGE<ept id=\"p1\">**</ept>; to use it, you need to edit your message map yourself.","source":"ClassWizard does not handle **ON_NOTIFY_RANGE**; to use it, you need to edit your message map yourself."},{"pos":[9028,9112],"content":"The message-map entry and function prototype for <bpt id=\"p1\">**</bpt>ON_NOTIFY_RANGE<ept id=\"p1\">**</ept> are as follows:","source":"The message-map entry and function prototype for **ON_NOTIFY_RANGE** are as follows:"},{"content":"where the italicized parameters are replaced with:","pos":[9209,9259]},{"content":"The code for the notification message to be handled, such as <bpt id=\"p1\">**</bpt>LVN_KEYDOWN<ept id=\"p1\">**</ept>.","pos":[9283,9360],"source":" The code for the notification message to be handled, such as **LVN_KEYDOWN**."},{"content":"The first identifier in the contiguous range of identifiers.","pos":[9375,9435]},{"content":"The last identifier in the contiguous range of identifiers.","pos":[9454,9513]},{"content":"The member function to be called when this notification is sent.","pos":[9535,9599]},{"content":"Your member function must be declared with the following prototype:","pos":[9606,9673]},{"content":"Remarks","pos":[9795,9802]},{"content":"where the italicized parameters are:","pos":[9806,9842]},{"content":"The child identifier of the control that sent the notification.","pos":[9857,9920]},{"content":"A pointer to the notification structure, as described above.","pos":[9946,10006]},{"content":"result","pos":[10014,10020]},{"content":"A pointer to the result code you'll set before you return.","pos":[10025,10083]},{"pos":[10160,10192],"content":"ON_NOTIFY_EX, ON_NOTIFY_EX_RANGE"},{"content":"If you want more than one object in the notification routing to handle a message, you can use <bpt id=\"p1\">**</bpt>ON_NOTIFY_EX<ept id=\"p1\">**</ept> (or <bpt id=\"p2\">**</bpt>ON_NOTIFY_EX_RANGE<ept id=\"p2\">**</ept>) rather than <ph id=\"ph1\">`ON_NOTIFY`</ph> (or <bpt id=\"p3\">**</bpt>ON_NOTIFY_RANGE<ept id=\"p3\">**</ept>).","pos":[10196,10384],"source":"If you want more than one object in the notification routing to handle a message, you can use **ON_NOTIFY_EX** (or **ON_NOTIFY_EX_RANGE**) rather than `ON_NOTIFY` (or **ON_NOTIFY_RANGE**)."},{"content":"The only difference between the <bpt id=\"p1\">**</bpt>EX<ept id=\"p1\">**</ept> version and the regular version is that the member function called for the <bpt id=\"p2\">**</bpt>EX<ept id=\"p2\">**</ept> version returns a <bpt id=\"p3\">**</bpt>BOOL<ept id=\"p3\">**</ept> that indicates whether or not message processing should continue.","pos":[10385,10598],"source":" The only difference between the **EX** version and the regular version is that the member function called for the **EX** version returns a **BOOL** that indicates whether or not message processing should continue."},{"content":"Returning <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept> from this function allows you to process the same message in more than one object.","pos":[10599,10701],"source":" Returning **FALSE** from this function allows you to process the same message in more than one object."},{"pos":[10708,10858],"content":"ClassWizard does not handle <bpt id=\"p1\">**</bpt>ON_NOTIFY_EX<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>ON_NOTIFY_EX_RANGE<ept id=\"p2\">**</ept>; if you want to use either of them, you need to edit your message map yourself.","source":"ClassWizard does not handle **ON_NOTIFY_EX** or **ON_NOTIFY_EX_RANGE**; if you want to use either of them, you need to edit your message map yourself."},{"content":"The message-map entry and function prototype for <bpt id=\"p1\">**</bpt>ON_NOTIFY_EX<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>ON_NOTIFY_EX_RANGE<ept id=\"p2\">**</ept> are as follows.","pos":[10865,10973],"source":"The message-map entry and function prototype for **ON_NOTIFY_EX** and **ON_NOTIFY_EX_RANGE** are as follows."},{"content":"The meanings of the parameters are the same as for the non-<bpt id=\"p1\">**</bpt>EX<ept id=\"p1\">**</ept> versions.","pos":[10974,11049],"source":" The meanings of the parameters are the same as for the non-**EX** versions."},{"content":"The prototype for both of the above is the same:","pos":[11195,11243]},{"content":"Remarks","pos":[11365,11372]},{"pos":[11376,11465],"content":"In both cases, <ph id=\"ph1\">`id`</ph> holds the child identifier of the control that sent the notification.","source":"In both cases, `id` holds the child identifier of the control that sent the notification."},{"pos":[11472,11659],"content":"Your function must return <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept> if the notification message has been completely handled or <bpt id=\"p2\">**</bpt>FALSE<ept id=\"p2\">**</ept> if other objects in the command routing should have a chance to handle the message.","source":"Your function must return **TRUE** if the notification message has been completely handled or **FALSE** if other objects in the command routing should have a chance to handle the message."},{"content":"See Also","pos":[11668,11676]},{"content":"Technical Notes by Number","pos":[11681,11706]},{"content":"Technical Notes by Category","pos":[11750,11777]}],"content":"---\ntitle: \"TN061: ON_NOTIFY and WM_NOTIFY Messages | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"ON_NOTIFY\"\n  - \"WM_NOTIFY\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"ON_NOTIFY_EX message\"\n  - \"TN061\"\n  - \"ON_NOTIFY message\"\n  - \"ON_NOTIFY_EX_RANGE message\"\n  - \"ON_NOTIFY_RANGE message\"\n  - \"notification messages\"\n  - \"WM_NOTIFY message\"\nms.assetid: 04a96dde-7049-41df-9954-ad7bb5587caf\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# TN061: ON_NOTIFY and WM_NOTIFY Messages\n> [!NOTE]\n>  The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.  \n  \n This technical note provides background information on the new **WM_NOTIFY** message and describes the recommended (and most common) way of handling **WM_NOTIFY** messages in your MFC application.  \n  \n **Notification Messages in Windows 3.x**  \n  \n In Windows 3.x, controls notify their parents of events such as mouse clicks, changes in content and selection, and control background painting by sending a message to the parent. Simple notifications are sent as special **WM_COMMAND** messages, with the notification code (such as **BN_CLICKED**) and control ID packed into `wParam` and the control's handle in `lParam`. Note that since `wParam` and `lParam` are full, there is no way to pass any additional data — these messages can be only simple notification. For instance, in the **BN_CLICKED** notification, there's no way to send information about the location of the mouse cursor when the button was clicked.  \n  \n When controls in Windows 3.x need to send a notification message that includes additional data, they use a variety of special-purpose messages, including `WM_CTLCOLOR`, `WM_VSCROLL`, `WM_HSCROLL`, `WM_DRAWITEM`, `WM_MEASUREITEM`, `WM_COMPAREITEM`, `WM_DELETEITEM`, `WM_CHARTOITEM`, `WM_VKEYTOITEM`, and so on. These messages can be reflected back to the control that sent them. For more information, see [TN062: Message Reflection for Windows Controls](../mfc/tn062-message-reflection-for-windows-controls.md).  \n  \n **Notification Messages in Win32**  \n  \n For controls that existed in Windows 3.1, the Win32 API uses most of the notification messages that were used in Windows 3.x. However, Win32 also adds a number of sophisticated, complex controls to those supported in Windows 3.x. Frequently, these controls need to send additional data with their notification messages. Rather than adding a new **WM_\\*** message for each new notification that needs additional data, the designers of the Win32 API chose to add just one message, **WM_NOTIFY**, which can pass any amount of additional data in a standardized fashion.  \n  \n **WM_NOTIFY** messages contain the ID of the control sending the message in `wParam` and a pointer to a structure in `lParam`. This structure is either an **NMHDR** structure or some larger structure that has an **NMHDR** structure as its first member. Note that since the **NMHDR** member is first, a pointer to this structure can be used as either a pointer to an **NMHDR** or as a pointer to the larger structure depending on how you cast it.  \n  \n In most cases, the pointer will point to a larger structure and you'll need to cast it when you use it. In only a few notifications, such as the common notifications (whose names start with **NM_**) and the tool tip control's **TTN_SHOW** and **TTN_POP** notifications, is an **NMHDR** structure actually used.  \n  \n The **NMHDR** structure or initial member contains the handle and ID of the control sending the message and the notification code (such as **TTN_SHOW**). The format of the **NMHDR** structure is shown below:  \n  \n```  \ntypedef struct tagNMHDR {  \n    HWND hwndFrom;  \n    UINT idFrom;  \n    UINT code;  \n} NMHDR;  \n```  \n  \n For a **TTN_SHOW** message, the **code** member would be set to **TTN_SHOW**.  \n  \n Most notifications pass a pointer to a larger structure that contains an **NMHDR** structure as its first member. For instance, consider the structure used by the list view control's **LVN_KEYDOWN** notification message, which is sent when a key is pressed in a list view control. The pointer points to an **LV_KEYDOWN** structure, which is defined as shown below:  \n  \n```  \ntypedef struct tagLV_KEYDOWN {  \n    NMHDR hdr;     \n    WORD wVKey;    \n    UINT flags;    \n} LV_KEYDOWN;  \n```  \n  \n Note that since the **NMHDR** member is first in this structure, the pointer you're passed in the notification message can be cast to either a pointer to an **NMHDR** or a pointer to an **LV_KEYDOWN**.  \n  \n **Notifications Common to All New Windows Controls**  \n  \n Some notifications are common to all of the new Windows controls. These notifications pass a pointer to an **NMHDR** structure.  \n  \n|Notification code|Sent because|  \n|-----------------------|------------------|  \n|**NM_CLICK**|User clicked left mouse button in the control|  \n|**NM_DBLCLK**|User double-clicked left mouse button in the control|  \n|**NM_RCLICK**|User clicked right mouse button in the control|  \n|**NM_RDBLCLK**|User double-clicked right mouse button in the control|  \n|**NM_RETURN**|User pressed the ENTER key while control has input focus|  \n|**NM_SETFOCUS**|Control has been given input focus|  \n|**NM_KILLFOCUS**|Control has lost input focus|  \n|**NM_OUTOFMEMORY**|Control could not complete an operation because there was not enough memory available|  \n  \n##  <a name=\"_mfcnotes_on_notify.3a_.handling_wm_notify_messages_in_mfc_applications\"></a> ON_NOTIFY: Handling WM_NOTIFY Messages in MFC Applications  \n The function `CWnd::OnNotify` handles notification messages. Its default implementation checks the message map for notification handlers to call. In general, you do not override `OnNotify`. Instead, you provide a handler function and add a message-map entry for that handler to the message map of your owner window's class.  \n  \n ClassWizard, via the ClassWizard property sheet, can create the `ON_NOTIFY` message-map entry and provide you with a skeleton handler function. For more information on using ClassWizard to make this easier, see [Mapping Messages to Functions](../mfc/reference/mapping-messages-to-functions.md).  \n  \n The `ON_NOTIFY` message-map macro has the following syntax:  \n  \n```  \n \nON_NOTIFY(\nwNotifyCode  ,  \nid  ,\n    memberFxn)  \n \n```  \n  \n where the italicized parameters are replaced with:  \n  \n `wNotifyCode`  \n The code for the notification message to be handled, such as **LVN_KEYDOWN**.  \n  \n `id`  \n The child identifier of the control for which the notification is sent.  \n  \n `memberFxn`  \n The member function to be called when this notification is sent.  \n  \n Your member function must be declared with the following prototype:  \n  \n```  \n \nafx_msg void  \nmemberFxn  \n(NMHDR* \npNotifyStruct  , LRESULT* result);\n\n \n```  \n  \n## Remarks  \n where the italicized parameters are:  \n  \n `pNotifyStruct`  \n A pointer to the notification structure, as described in the section above.  \n  \n *result*  \n A pointer to the result code you'll set before you return.  \n  \n## Example  \n To specify that you want the member function `OnKeydownList1` to handle **LVN_KEYDOWN** messages from the `CListCtrl` whose ID is `IDC_LIST1`, you would use ClassWizard to add the following to your message map:  \n  \n```  \nON_NOTIFY(LVN_KEYDOWN,\n    IDC_LIST1,\n    OnKeydownList1)  \n```  \n  \n In the example above, the function provided by ClassWizard is:  \n  \n```  \nvoid CMessageReflectionDlg::OnKeydownList1(NMHDR* pNMHDR, LRESULT* pResult)  \n{  \n    LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR; *// TODO: Add your control notification handler *//       code here  \n \n *pResult = 0;  \n}  \n```  \n  \n Note that ClassWizard provides a pointer of the proper type automatically. You can access the notification structure through either `pNMHDR` or `pLVKeyDow`.  \n  \n##  <a name=\"_mfcnotes_on_notify_range\"></a> ON_NOTIFY_RANGE  \n If you need to process the same **WM_NOTIFY** message for a set of controls, you can use **ON_NOTIFY_RANGE** rather than `ON_NOTIFY`. For instance, you may have a set of buttons for which you want to perform the same action for a certain notification message.  \n  \n When you use **ON_NOTIFY_RANGE**, you specify a contiguous range of child identifiers for which to handle the notification message by specifying the beginning and ending child identifiers of the range.  \n  \n ClassWizard does not handle **ON_NOTIFY_RANGE**; to use it, you need to edit your message map yourself.  \n  \n The message-map entry and function prototype for **ON_NOTIFY_RANGE** are as follows:  \n  \n```  \n \nON_NOTIFY_RANGE(\nwNotifyCode  ,   \nid  ,   \nidLast  ,\n    memberFxn)  \n \n```  \n  \n where the italicized parameters are replaced with:  \n  \n `wNotifyCode`  \n The code for the notification message to be handled, such as **LVN_KEYDOWN**.  \n  \n `id`  \n The first identifier in the contiguous range of identifiers.  \n  \n `idLast`  \n The last identifier in the contiguous range of identifiers.  \n  \n `memberFxn`  \n The member function to be called when this notification is sent.  \n  \n Your member function must be declared with the following prototype:  \n  \n```  \n \nafx_msg void  \nmemberFxn  \n(UINT   \nid  ,\n    NMHDR* \npNotifyStruct  ,\n    LRESULT* result);\n\n \n```  \n  \n## Remarks  \n where the italicized parameters are:  \n  \n `id`  \n The child identifier of the control that sent the notification.  \n  \n `pNotifyStruct`  \n A pointer to the notification structure, as described above.  \n  \n *result*  \n A pointer to the result code you'll set before you return.  \n  \n##  <a name=\"_mfcnotes_tn061_on_notify_ex.2c_.on_notify_ex_range\"></a> ON_NOTIFY_EX, ON_NOTIFY_EX_RANGE  \n If you want more than one object in the notification routing to handle a message, you can use **ON_NOTIFY_EX** (or **ON_NOTIFY_EX_RANGE**) rather than `ON_NOTIFY` (or **ON_NOTIFY_RANGE**). The only difference between the **EX** version and the regular version is that the member function called for the **EX** version returns a **BOOL** that indicates whether or not message processing should continue. Returning **FALSE** from this function allows you to process the same message in more than one object.  \n  \n ClassWizard does not handle **ON_NOTIFY_EX** or **ON_NOTIFY_EX_RANGE**; if you want to use either of them, you need to edit your message map yourself.  \n  \n The message-map entry and function prototype for **ON_NOTIFY_EX** and **ON_NOTIFY_EX_RANGE** are as follows. The meanings of the parameters are the same as for the non-**EX** versions.  \n  \n```  \n \nON_NOTIFY_EX(\nnCode  ,  \nid  ,\n    memberFxn) ON_NOTIFY_EX_RANGE(\nwNotifyCode  ,   \nid  ,   \nidLast  ,\n    memberFxn)  \n \n```  \n  \n The prototype for both of the above is the same:  \n  \n```  \n \nafx_msg BOOL  \nmemberFxn  \n(UINT   \nid  ,\n    NMHDR* \npNotifyStruct  ,\n    LRESULT* result);\n\n \n```  \n  \n## Remarks  \n In both cases, `id` holds the child identifier of the control that sent the notification.  \n  \n Your function must return **TRUE** if the notification message has been completely handled or **FALSE** if other objects in the command routing should have a chance to handle the message.  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}