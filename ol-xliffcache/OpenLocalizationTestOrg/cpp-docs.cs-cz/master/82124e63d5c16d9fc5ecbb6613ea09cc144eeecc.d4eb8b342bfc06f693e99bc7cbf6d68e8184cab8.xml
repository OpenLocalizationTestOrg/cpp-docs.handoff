{"nodes":[{"pos":[12,52],"content":"How to: Migrate to -clr | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Migrate to -clr | Microsoft Docs","pos":[0,40]}]},{"content":"How to: Migrate to /clr","pos":[845,868]},{"content":"This topic discusses issues that arise when compiling native code with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> (see <bpt id=\"p2\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p2\">](../build/reference/clr-common-language-runtime-compilation.md)</ept> for more information).","pos":[869,1084],"source":"This topic discusses issues that arise when compiling native code with **/clr** (see [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md) for more information)."},{"content":"<bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> allows Visual C++ modules to invoke and be invoked from .NET assemblies while retaining compatibility with unmanaged modules.","pos":[1085,1219],"source":"**/clr** allows Visual C++ modules to invoke and be invoked from .NET assemblies while retaining compatibility with unmanaged modules."},{"content":"See <bpt id=\"p1\">[</bpt>Mixed (Native and Managed) Assemblies<ept id=\"p1\">](../dotnet/mixed-native-and-managed-assemblies.md)</ept> and <bpt id=\"p2\">[</bpt>Native and .NET Interoperability<ept id=\"p2\">](../dotnet/native-and-dotnet-interoperability.md)</ept> for more information on the advantages of compiling with <bpt id=\"p3\">**</bpt>/clr<ept id=\"p3\">**</ept>.","pos":[1220,1468],"source":" See [Mixed (Native and Managed) Assemblies](../dotnet/mixed-native-and-managed-assemblies.md) and [Native and .NET Interoperability](../dotnet/native-and-dotnet-interoperability.md) for more information on the advantages of compiling with **/clr**."},{"content":"Known Issues Compiling Library Projects with /clr","pos":[1477,1526]},{"pos":[1530,1617],"content":"Visual Studio contains some known issues when compiling library projects with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>:","source":"Visual Studio contains some known issues when compiling library projects with **/clr**:"},{"content":"Your code may query types at runtime with <bpt id=\"p1\">[</bpt>CRuntimeClass::FromName<ept id=\"p1\">](../mfc/reference/cruntimeclass-structure.md#cruntimeclass__fromname)</ept>.","pos":[1627,1764],"source":"Your code may query types at runtime with [CRuntimeClass::FromName](../mfc/reference/cruntimeclass-structure.md#cruntimeclass__fromname)."},{"content":"However, if a type is in an MSIL .dll (compiled with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>), the call to <ph id=\"ph1\">`FromName`</ph> may fail if it occurs before the static constructors run in the managed .dll (you will not see this problem if the FromName call happens after code has executed in the managed .dll).","pos":[1765,2034],"source":" However, if a type is in an MSIL .dll (compiled with **/clr**), the call to `FromName` may fail if it occurs before the static constructors run in the managed .dll (you will not see this problem if the FromName call happens after code has executed in the managed .dll)."},{"content":"To work around this problem, you can force the construction of the managed static constructor by defining a function in the managed .dll, exporting it, and invoking it from the native MFC application.","pos":[2035,2235]},{"content":"For example:","pos":[2236,2248]},{"content":"Compile with Visual C++","pos":[2503,2526]},{"pos":[2530,2650],"content":"Before using <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> on any module in your project, first compile and link your native project with Visual Studio 2010.","source":"Before using **/clr** on any module in your project, first compile and link your native project with Visual Studio 2010."},{"content":"The following steps, followed in order, provide the easiest path to a <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> compilation.","pos":[2657,2748],"source":"The following steps, followed in order, provide the easiest path to a **/clr** compilation."},{"content":"It is important to compile and run your project after each of these steps.","pos":[2749,2823]},{"content":"Versions Prior to Visual C++ 2003","pos":[2833,2866]},{"content":"If you are upgrading to Visual Studio 2010 from a version prior to Visual C++ 2003, you may see compiler errors related to the enhanced C++ standard conformance in Visual C++ 2003","pos":[2870,3049]},{"content":"Upgrading from Visual C++ 2003","pos":[3059,3089]},{"content":"Projects previous built with Visual C++ 2003 should also first be compiled without <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> as Visual Studio now has increased ANSI/ISO compliance and some breaking changes.","pos":[3093,3266],"source":"Projects previous built with Visual C++ 2003 should also first be compiled without **/clr** as Visual Studio now has increased ANSI/ISO compliance and some breaking changes."},{"content":"The change that is likely to require the most attention is <bpt id=\"p1\">[</bpt>Security Features in the CRT<ept id=\"p1\">](../c-runtime-library/security-features-in-the-crt.md)</ept>.","pos":[3267,3411],"source":" The change that is likely to require the most attention is [Security Features in the CRT](../c-runtime-library/security-features-in-the-crt.md)."},{"content":"Code that uses the CRT is very likely to produce deprecation warnings.","pos":[3412,3482]},{"content":"These warnings can be suppressed, but migrating to the new <bpt id=\"p1\">[</bpt>Security-Enhanced Versions of CRT Functions<ept id=\"p1\">](../c-runtime-library/security-enhanced-versions-of-crt-functions.md)</ept> is preferred, as they provide better security and may reveal security issues in your code.","pos":[3483,3747],"source":" These warnings can be suppressed, but migrating to the new [Security-Enhanced Versions of CRT Functions](../c-runtime-library/security-enhanced-versions-of-crt-functions.md) is preferred, as they provide better security and may reveal security issues in your code."},{"content":"Upgrading from Managed Extensions for C++","pos":[3757,3798]},{"content":"Projects built with Visual C++ .NET or Visual C++ 2003 that used Managed Extensions for C++ must be rewritten to use the new syntax, as these extensions are no longer supported.","pos":[3802,3979]},{"content":"Code written with Managed Extensions for C++ won't compile under <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>.","pos":[3980,4054],"source":" Code written with Managed Extensions for C++ won't compile under **/clr**."},{"content":"Convert C Code to C++","pos":[4063,4084]},{"content":"Although Visual Studio will compile C files, it is necessary to convert them to C++ for a <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> compilation.","pos":[4088,4199],"source":"Although Visual Studio will compile C files, it is necessary to convert them to C++ for a **/clr** compilation."},{"content":"The actual filename doesn't have to be changed; you can use <bpt id=\"p1\">**</bpt>/Tp<ept id=\"p1\">**</ept> (see <bpt id=\"p2\">[</bpt>/Tc, /Tp, /TC, /TP (Specify Source File Type)<ept id=\"p2\">](../build/reference/tc-tp-tc-tp-specify-source-file-type.md)</ept>.) Note that although C++ source code files are required for <bpt id=\"p3\">**</bpt>/clr<ept id=\"p3\">**</ept>, it is not necessary to re-factor your code to use object-oriented paradigms.","pos":[4200,4527],"source":" The actual filename doesn't have to be changed; you can use **/Tp** (see [/Tc, /Tp, /TC, /TP (Specify Source File Type)](../build/reference/tc-tp-tc-tp-specify-source-file-type.md).) Note that although C++ source code files are required for **/clr**, it is not necessary to re-factor your code to use object-oriented paradigms."},{"content":"C code is very likely to require changes when compiled as a C++ file.","pos":[4534,4603]},{"content":"The C++ type-safety rules are strict, so type conversions must be made explicit with casts.","pos":[4604,4695]},{"content":"For example, malloc returns a void pointer, but can be assigned to a pointer to any type in C with a cast:","pos":[4696,4802]},{"content":"Function pointers are also strictly type-safe in C++, so the following C code requires modification.","pos":[4926,5026]},{"content":"In C++ it's best to create a <ph id=\"ph1\">`typedef`</ph> that defines the function pointer type, and then use that type to cast function pointers:","pos":[5027,5155],"source":" In C++ it's best to create a `typedef` that defines the function pointer type, and then use that type to cast function pointers:"},{"content":"C++ also requires that functions either be prototyped or fully defined before they can be referenced or invoked.","pos":[5338,5450]},{"content":"Identifiers used in C code that happen to be keywords in C++ (such as <ph id=\"ph1\">`virtual`</ph>, <ph id=\"ph2\">`new`</ph>, <ph id=\"ph3\">`delete`</ph>, <ph id=\"ph4\">`bool`</ph>, <ph id=\"ph5\">`true`</ph>, <ph id=\"ph6\">`false`</ph>, etc.) must be renamed.","pos":[5457,5602],"source":"Identifiers used in C code that happen to be keywords in C++ (such as `virtual`, `new`, `delete`, `bool`, `true`, `false`, etc.) must be renamed."},{"content":"This can generally be done with simple search-and-replace operations.","pos":[5603,5672]},{"pos":[5679,5783],"content":"Finally, whereas C-style COM calls require explicit use of the v-table and <ph id=\"ph1\">`this`</ph> pointer, C++ does not:","source":"Finally, whereas C-style COM calls require explicit use of the v-table and `this` pointer, C++ does not:"},{"content":"Reconfigure Project Settings","pos":[5903,5931]},{"content":"After your project compiles and runs in Visual Studio 2010 you should create new project configurations for <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> rather than modifying the default configurations.","pos":[5935,6101],"source":"After your project compiles and runs in Visual Studio 2010 you should create new project configurations for **/clr** rather than modifying the default configurations."},{"content":"<bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> is incompatible with some compiler options and creating separate configurations lets you build your project as native or managed.","pos":[6102,6240],"source":"**/clr** is incompatible with some compiler options and creating separate configurations lets you build your project as native or managed."},{"content":"When <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> is selected in the property pages dialog box, project settings not compatible with <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept> are disabled (and disabled options are not automatically restored if <bpt id=\"p3\">**</bpt>/clr<ept id=\"p3\">**</ept> is subsequently unselected).","pos":[6241,6453],"source":" When **/clr** is selected in the property pages dialog box, project settings not compatible with **/clr** are disabled (and disabled options are not automatically restored if **/clr** is subsequently unselected)."},{"content":"Create New Project Configurations","pos":[6463,6496]},{"content":"You can use <bpt id=\"p1\">**</bpt>Copy Settings From<ept id=\"p1\">**</ept> option in the <bpt id=\"p2\">[</bpt>New Project Configuration Dialog Box<ept id=\"p2\">](http://msdn.microsoft.com/en-us/cca616dc-05a6-4fe3-bdc1-40c72a66f2be)</ept> to create a project configuration based on your existing project settings.","pos":[6500,6732],"source":"You can use **Copy Settings From** option in the [New Project Configuration Dialog Box](http://msdn.microsoft.com/en-us/cca616dc-05a6-4fe3-bdc1-40c72a66f2be) to create a project configuration based on your existing project settings."},{"content":"Do this once for the Debug configuration and once for Release configuration.","pos":[6733,6809]},{"content":"Subsequent changes can then be applied to the <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> -specific configurations only, leaving the original project configurations intact.","pos":[6810,6947],"source":" Subsequent changes can then be applied to the **/clr** -specific configurations only, leaving the original project configurations intact."},{"content":"Projects that use custom build rules may require extra attention.","pos":[6954,7019]},{"content":"This step has different implications for projects that use makefiles.","pos":[7026,7095]},{"content":"In this case a separate build-target can be configured, or version specific to <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> compilation can be created from a copy of the original.","pos":[7096,7239],"source":" In this case a separate build-target can be configured, or version specific to **/clr** compilation can be created from a copy of the original."},{"content":"Change Project Settings","pos":[7249,7272]},{"content":"<bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> can be selected in the development environment by following the instructions in <bpt id=\"p2\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p2\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>.","pos":[7276,7473],"source":"**/clr** can be selected in the development environment by following the instructions in [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md)."},{"content":"As mentioned previously, this step will automatically disable conflicting project settings.","pos":[7474,7565]},{"pos":[7573,8113],"content":"[!NOTE]\n When upgrading a managed library or web service project from Visual C++ 2003, the **/Zl** compiler option will added to the **Command Line** property page. This will cause LNK2001. Remove **/Zl** from the **Command Line** property page to resolve. See [/Zl (Omit Default Library Name)](../build/reference/zl-omit-default-library-name.md) and [Working with Project Properties](../ide/working-with-project-properties.md) for more information. Or, add msvcrt.lib and msvcmrt.lib to the linker's **Additional Dependencies** property.","leadings":["","> "],"nodes":[{"content":" When upgrading a managed library or web service project from Visual C++ 2003, the **/Zl** compiler option will added to the **Command Line** property page. This will cause LNK2001. Remove **/Zl** from the **Command Line** property page to resolve. See [/Zl (Omit Default Library Name)](../build/reference/zl-omit-default-library-name.md) and [Working with Project Properties](../ide/working-with-project-properties.md) for more information. Or, add msvcrt.lib and msvcmrt.lib to the linker's **Additional Dependencies** property.","pos":[8,538],"nodes":[{"content":"When upgrading a managed library or web service project from Visual C++ 2003, the <bpt id=\"p1\">**</bpt>/Zl<ept id=\"p1\">**</ept> compiler option will added to the <bpt id=\"p2\">**</bpt>Command Line<ept id=\"p2\">**</ept> property page.","pos":[1,156],"source":" When upgrading a managed library or web service project from Visual C++ 2003, the **/Zl** compiler option will added to the **Command Line** property page."},{"content":"This will cause LNK2001.","pos":[157,181]},{"content":"Remove <bpt id=\"p1\">**</bpt>/Zl<ept id=\"p1\">**</ept> from the <bpt id=\"p2\">**</bpt>Command Line<ept id=\"p2\">**</ept> property page to resolve.","pos":[182,248],"source":" Remove **/Zl** from the **Command Line** property page to resolve."},{"content":"See <bpt id=\"p1\">[</bpt>/Zl (Omit Default Library Name)<ept id=\"p1\">](../build/reference/zl-omit-default-library-name.md)</ept> and <bpt id=\"p2\">[</bpt>Working with Project Properties<ept id=\"p2\">](../ide/working-with-project-properties.md)</ept> for more information.","pos":[249,441],"source":" See [/Zl (Omit Default Library Name)](../build/reference/zl-omit-default-library-name.md) and [Working with Project Properties](../ide/working-with-project-properties.md) for more information."},{"content":"Or, add msvcrt.lib and msvcmrt.lib to the linker's <bpt id=\"p1\">**</bpt>Additional Dependencies<ept id=\"p1\">**</ept> property.","pos":[442,530],"source":" Or, add msvcrt.lib and msvcmrt.lib to the linker's **Additional Dependencies** property."}]}]},{"content":"For projects built with makefiles, incompatible compiler options must be disabled manually once <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> is added.","pos":[8120,8234],"source":"For projects built with makefiles, incompatible compiler options must be disabled manually once **/clr** is added."},{"content":"See /<bpt id=\"p1\">[</bpt>/clr Restrictions<ept id=\"p1\">](../build/reference/clr-restrictions.md)</ept> for information on compiler options that are not compatible with <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept>.","pos":[8235,8374],"source":" See /[/clr Restrictions](../build/reference/clr-restrictions.md) for information on compiler options that are not compatible with **/clr**."},{"content":"Precompiled Headers","pos":[8384,8403]},{"content":"Precompiled headers are supported under <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>.","pos":[8407,8456],"source":"Precompiled headers are supported under **/clr**."},{"content":"However, if you only compile some of your CPP files with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> (compiling the rest as native) some changes will be required because precompiled headers generated with <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept> are not compatible with those generated without <bpt id=\"p3\">**</bpt>/clr<ept id=\"p3\">**</ept>.","pos":[8457,8693],"source":" However, if you only compile some of your CPP files with **/clr** (compiling the rest as native) some changes will be required because precompiled headers generated with **/clr** are not compatible with those generated without **/clr**."},{"content":"This incompatibility is due to the fact that <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> generates and requires metadata.","pos":[8694,8780],"source":" This incompatibility is due to the fact that **/clr** generates and requires metadata."},{"content":"Modules compiled <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> can therefore not use precompiled headers that don't include metadata, and non <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept> modules can't use precompiled header files that do contain meta data.","pos":[8781,8964],"source":" Modules compiled **/clr** can therefore not use precompiled headers that don't include metadata, and non **/clr** modules can't use precompiled header files that do contain meta data."},{"content":"The easiest way to compile a project where some modules are compiled <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> is to disable precompiled headers entirely.","pos":[8971,9092],"source":"The easiest way to compile a project where some modules are compiled **/clr** is to disable precompiled headers entirely."},{"content":"(In the project Property Pages dialog, open the C/C++ node, and select Precompiled Headers.","pos":[9093,9184]},{"content":"Then change the Create/Use Precompiled Headers property to \"Not Using Precompiled Headers\".)","pos":[9185,9277]},{"content":"However, particularly for large projects, precompiled headers provide much better compilation speed, so disabling this feature is not desirable.","pos":[9284,9428]},{"content":"In this case it's best to configure the <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> and non <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept> files to use separate precompiled headers.","pos":[9429,9537],"source":" In this case it's best to configure the **/clr** and non **/clr** files to use separate precompiled headers."},{"content":"This can be done in one step by multi-selecting the modules to be compiled <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> using the Solution Explorer, right-clicking on the group, and selecting Properties.","pos":[9538,9705],"source":" This can be done in one step by multi-selecting the modules to be compiled **/clr** using the Solution Explorer, right-clicking on the group, and selecting Properties."},{"content":"Then change both the Create/Use PCH Through File and Precompiled Header File properties to use a different header file name and PCH file respectively.","pos":[9706,9856]},{"content":"Fixing Errors","pos":[9865,9878]},{"content":"Compiling with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> may result in compiler, linker or runtime errors.","pos":[9882,9955],"source":"Compiling with **/clr** may result in compiler, linker or runtime errors."},{"content":"This section discusses the most common problems.","pos":[9956,10004]},{"content":"Metadata Merge","pos":[10014,10028]},{"content":"Differing versions of data types can cause the linker to fail because the metadata generated for the two types doesn't match.","pos":[10032,10157]},{"content":"(This is usually caused when members of a type are conditionally defined, but the conditions are not the same for all CPP files that use the type.) In this case the linker fails, reporting only the symbol name and the name of the second OBJ file where the type was defined.","pos":[10158,10431]},{"content":"It is often useful to rotate the order that OBJ files are sent to the linker to discover the location of the other version of the data type.","pos":[10432,10572]},{"content":"Loader Lock Deadlock","pos":[10582,10602]},{"content":"In Visual C++ .NET and Visual C++ 2003, initialization under <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> was susceptible to non-deterministic deadlock.","pos":[10606,10722],"source":"In Visual C++ .NET and Visual C++ 2003, initialization under **/clr** was susceptible to non-deterministic deadlock."},{"content":"This issue is known as \"loader lock deadlock\".","pos":[10723,10769]},{"content":"In Visual Studio 2010, this deadlock is easier to avoid, it is detected and reported at runtime, and is no longer non-deterministic.","pos":[10770,10902]},{"content":"Encountering the loader lock problem is still possible, but now it's much easier to avoid and fix.","pos":[10903,11001]},{"content":"See <bpt id=\"p1\">[</bpt>Initialization of Mixed Assemblies<ept id=\"p1\">](../dotnet/initialization-of-mixed-assemblies.md)</ept> for detailed background, guidance, and solutions.","pos":[11002,11141],"source":" See [Initialization of Mixed Assemblies](../dotnet/initialization-of-mixed-assemblies.md) for detailed background, guidance, and solutions."},{"content":"Data Exports","pos":[11151,11163]},{"content":"Exporting DLL data is error-prone, and not recommended.","pos":[11167,11222]},{"content":"This is because the data section of a DLL is not guaranteed to be initialized until some managed portion of the DLL has been executed.","pos":[11223,11357]},{"content":"Reference metadata with <bpt id=\"p1\">[</bpt>#using Directive<ept id=\"p1\">](../preprocessor/hash-using-directive-cpp.md)</ept>.","pos":[11358,11446],"source":" Reference metadata with [#using Directive](../preprocessor/hash-using-directive-cpp.md)."},{"content":"Type Visibility","pos":[11456,11471]},{"content":"Native types are now private by default.","pos":[11475,11515]},{"content":"In Visual C++ .NET 2002 and Visual C++ 2003, native types were public by default.","pos":[11516,11597]},{"content":"This can result in a native type not being visible outside the DLL.","pos":[11598,11665]},{"content":"Resolve this error by adding <ph id=\"ph1\">`public`</ph> to these types.","pos":[11666,11719],"source":" Resolve this error by adding `public` to these types."},{"content":"Floating Point and Alignment Issues","pos":[11729,11764]},{"content":"is not supported on the common language runtime (see <bpt id=\"p1\">[</bpt>_control87, _controlfp, <ph id=\"ph1\">\\_</ph>_control87_2<ept id=\"p1\">](../c-runtime-library/reference/control87-controlfp-control87-2.md)</ept> for more information).","pos":[11782,11965],"source":" is not supported on the common language runtime (see [_control87, _controlfp, \\__control87_2](../c-runtime-library/reference/control87-controlfp-control87-2.md) for more information)."},{"content":"The CLR will also not respect <bpt id=\"p1\">[</bpt>align<ept id=\"p1\">](../cpp/align-cpp.md)</ept>.","pos":[11966,12025],"source":" The CLR will also not respect [align](../cpp/align-cpp.md)."},{"content":"COM Initialization","pos":[12035,12053]},{"content":"The Common Language Runtime initializes COM automatically when a module is initialized (when COM is initialized automatically it’s done so as MTA).","pos":[12057,12204]},{"content":"As a result, explicitly initializing COM yields return codes indicating that COM is already initialized.","pos":[12205,12309]},{"content":"Attempting to explicitly initialize COM with one threading model when the CLR has already initialized COM to another threading model can cause your application to fail.","pos":[12310,12478]},{"pos":[12485,12678],"content":"The common language runtime starts COM as MTA by default; use <bpt id=\"p1\">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id=\"p1\">](../build/reference/clrthreadattribute-set-clr-thread-attribute.md)</ept> to modify this.","source":"The common language runtime starts COM as MTA by default; use [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](../build/reference/clrthreadattribute-set-clr-thread-attribute.md) to modify this."},{"content":"Performance Issues","pos":[12688,12706]},{"content":"You may see decreased performance when native C++ methods generated to MSIL are called indirectly (virtual function calls or using function pointers).","pos":[12710,12860]},{"content":"To learn more about this, see <bpt id=\"p1\">[</bpt>Double Thunking<ept id=\"p1\">](../dotnet/double-thunking-cpp.md)</ept>.","pos":[12861,12943],"source":" To learn more about this, see [Double Thunking](../dotnet/double-thunking-cpp.md)."},{"content":"When moving from native to MSIL, you will notice an increase in the size of your working set.","pos":[12950,13043]},{"content":"This is because the common language runtime provides many features to ensure that programs run correctly.","pos":[13044,13149]},{"content":"If your <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> application is not running correctly, you may want to enable C4793 (off by default), see <bpt id=\"p2\">[</bpt>Compiler Warning (level 1 and 3) C4793<ept id=\"p2\">](../error-messages/compiler-warnings/compiler-warning-level-1-and-3-c4793.md)</ept> for more information.","pos":[13150,13395],"source":" If your **/clr** application is not running correctly, you may want to enable C4793 (off by default), see [Compiler Warning (level 1 and 3) C4793](../error-messages/compiler-warnings/compiler-warning-level-1-and-3-c4793.md) for more information."},{"content":"Program Crashes on Shutdown","pos":[13405,13432]},{"content":"In some cases, the CLR can shutdown before your managed code is finished running.","pos":[13436,13517]},{"content":"Using <ph id=\"ph1\">`std::set_terminate`</ph> and <ph id=\"ph2\">`SIGTERM`</ph> can cause this.","pos":[13518,13574],"source":" Using `std::set_terminate` and `SIGTERM` can cause this."},{"content":"See <bpt id=\"p1\">[</bpt>signal Constants<ept id=\"p1\">](../c-runtime-library/signal-constants.md)</ept> and <bpt id=\"p2\">[</bpt>set_terminate<ept id=\"p2\">](../c-runtime-library/abnormal-termination.md)</ept> for more information.","pos":[13575,13727],"source":" See [signal Constants](../c-runtime-library/signal-constants.md) and [set_terminate](../c-runtime-library/abnormal-termination.md) for more information."},{"content":"Using New Visual C++ Features","pos":[13736,13765]},{"content":"After your application compiles, links, and runs, you can begin using .NET features in any module compiled with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>.","pos":[13769,13890],"source":"After your application compiles, links, and runs, you can begin using .NET features in any module compiled with **/clr**."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Component Extensions for Runtime Platforms<ept id=\"p1\">](../windows/component-extensions-for-runtime-platforms.md)</ept>.","pos":[13891,14020],"source":" For more information, see [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)."},{"content":"If you used Managed Extensions for C++, you can convert your code to use the new syntax.","pos":[14027,14115]},{"content":"For a summary of syntactical differences, see the <bpt id=\"p1\">[</bpt>(NOTINBUILD)Managed Extensions for C++ Syntax Upgrade Checklist<ept id=\"p1\">](http://msdn.microsoft.com/en-us/edbded88-7ef3-4757-bd9d-b8f48ac2aada)</ept>.","pos":[14116,14302],"source":" For a summary of syntactical differences, see the [(NOTINBUILD)Managed Extensions for C++ Syntax Upgrade Checklist](http://msdn.microsoft.com/en-us/edbded88-7ef3-4757-bd9d-b8f48ac2aada)."},{"content":"For details on converting Managed Extensions for C++, see <bpt id=\"p1\">[</bpt>C++/CLI Migration Primer<ept id=\"p1\">](../dotnet/cpp-cli-migration-primer.md)</ept>.","pos":[14303,14427],"source":" For details on converting Managed Extensions for C++, see [C++/CLI Migration Primer](../dotnet/cpp-cli-migration-primer.md)."},{"content":"For information on .NET programming in Visual C++ see:","pos":[14434,14488]},{"content":".NET Programming with C++/CLI (Visual C++)","pos":[14499,14541]},{"content":"Native and .NET Interoperability","pos":[14610,14642]},{"content":"Component Extensions for Runtime Platforms","pos":[14703,14745]},{"content":"See Also","pos":[14813,14821]},{"content":"Mixed (Native and Managed) Assemblies","pos":[14826,14863]}],"content":"---\ntitle: \"How to: Migrate to -clr | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"upgrading Visual C++ applications, /clr compiler option\"\n  - \"compiling native code [C++]\"\n  - \"interoperability [C++], /clr compiler option\"\n  - \"interop [C++], /clr compiler option\"\n  - \"migration [C++], /clr compiler option\"\n  - \"/clr compiler option [C++], porting to\"\nms.assetid: c9290b8b-436a-4510-8b56-eae51f4a9afc\ncaps.latest.revision: 37\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Migrate to /clr\nThis topic discusses issues that arise when compiling native code with **/clr** (see [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md) for more information). **/clr** allows Visual C++ modules to invoke and be invoked from .NET assemblies while retaining compatibility with unmanaged modules. See [Mixed (Native and Managed) Assemblies](../dotnet/mixed-native-and-managed-assemblies.md) and [Native and .NET Interoperability](../dotnet/native-and-dotnet-interoperability.md) for more information on the advantages of compiling with **/clr**.  \n  \n## Known Issues Compiling Library Projects with /clr  \n Visual Studio contains some known issues when compiling library projects with **/clr**:  \n  \n-   Your code may query types at runtime with [CRuntimeClass::FromName](../mfc/reference/cruntimeclass-structure.md#cruntimeclass__fromname). However, if a type is in an MSIL .dll (compiled with **/clr**), the call to `FromName` may fail if it occurs before the static constructors run in the managed .dll (you will not see this problem if the FromName call happens after code has executed in the managed .dll). To work around this problem, you can force the construction of the managed static constructor by defining a function in the managed .dll, exporting it, and invoking it from the native MFC application. For example:  \n  \n    ```  \n    // Extension DLL Header file:  \n    __declspec( dllexport ) void EnsureManagedInitialization () {  \n       // managed code that won't be optimized away  \n       System::GC::KeepAlive(System::Int32::MaxValue);  \n    }  \n    ```  \n  \n## Compile with Visual C++  \n Before using **/clr** on any module in your project, first compile and link your native project with Visual Studio 2010.  \n  \n The following steps, followed in order, provide the easiest path to a **/clr** compilation. It is important to compile and run your project after each of these steps.  \n  \n### Versions Prior to Visual C++ 2003  \n If you are upgrading to Visual Studio 2010 from a version prior to Visual C++ 2003, you may see compiler errors related to the enhanced C++ standard conformance in Visual C++ 2003  \n  \n### Upgrading from Visual C++ 2003  \n Projects previous built with Visual C++ 2003 should also first be compiled without **/clr** as Visual Studio now has increased ANSI/ISO compliance and some breaking changes. The change that is likely to require the most attention is [Security Features in the CRT](../c-runtime-library/security-features-in-the-crt.md). Code that uses the CRT is very likely to produce deprecation warnings. These warnings can be suppressed, but migrating to the new [Security-Enhanced Versions of CRT Functions](../c-runtime-library/security-enhanced-versions-of-crt-functions.md) is preferred, as they provide better security and may reveal security issues in your code.  \n  \n### Upgrading from Managed Extensions for C++  \n Projects built with Visual C++ .NET or Visual C++ 2003 that used Managed Extensions for C++ must be rewritten to use the new syntax, as these extensions are no longer supported. Code written with Managed Extensions for C++ won't compile under **/clr**.  \n  \n## Convert C Code to C++  \n Although Visual Studio will compile C files, it is necessary to convert them to C++ for a **/clr** compilation. The actual filename doesn't have to be changed; you can use **/Tp** (see [/Tc, /Tp, /TC, /TP (Specify Source File Type)](../build/reference/tc-tp-tc-tp-specify-source-file-type.md).) Note that although C++ source code files are required for **/clr**, it is not necessary to re-factor your code to use object-oriented paradigms.  \n  \n C code is very likely to require changes when compiled as a C++ file. The C++ type-safety rules are strict, so type conversions must be made explicit with casts. For example, malloc returns a void pointer, but can be assigned to a pointer to any type in C with a cast:  \n  \n```  \nint* a = malloc(sizeof(int));   // C code  \nint* b = (int*)malloc(sizeof(int));   // C++ equivalent  \n```  \n  \n Function pointers are also strictly type-safe in C++, so the following C code requires modification. In C++ it's best to create a `typedef` that defines the function pointer type, and then use that type to cast function pointers:  \n  \n```  \nNewFunc1 = GetProcAddress( hLib, \"Func1\" );   // C code  \ntypedef int(*MYPROC)(int);   // C++ equivalent  \nNewFunc2 = (MYPROC)GetProcAddress( hLib, \"Func2\" );  \n```  \n  \n C++ also requires that functions either be prototyped or fully defined before they can be referenced or invoked.  \n  \n Identifiers used in C code that happen to be keywords in C++ (such as `virtual`, `new`, `delete`, `bool`, `true`, `false`, etc.) must be renamed. This can generally be done with simple search-and-replace operations.  \n  \n Finally, whereas C-style COM calls require explicit use of the v-table and `this` pointer, C++ does not:  \n  \n```  \nCOMObj1->lpVtbl->Method(COMObj, args);  // C code  \nCOMObj2->Method(args);  // C++ equivalent  \n```  \n  \n## Reconfigure Project Settings  \n After your project compiles and runs in Visual Studio 2010 you should create new project configurations for **/clr** rather than modifying the default configurations. **/clr** is incompatible with some compiler options and creating separate configurations lets you build your project as native or managed. When **/clr** is selected in the property pages dialog box, project settings not compatible with **/clr** are disabled (and disabled options are not automatically restored if **/clr** is subsequently unselected).  \n  \n### Create New Project Configurations  \n You can use **Copy Settings From** option in the [New Project Configuration Dialog Box](http://msdn.microsoft.com/en-us/cca616dc-05a6-4fe3-bdc1-40c72a66f2be) to create a project configuration based on your existing project settings. Do this once for the Debug configuration and once for Release configuration. Subsequent changes can then be applied to the **/clr** -specific configurations only, leaving the original project configurations intact.  \n  \n Projects that use custom build rules may require extra attention.  \n  \n This step has different implications for projects that use makefiles. In this case a separate build-target can be configured, or version specific to **/clr** compilation can be created from a copy of the original.  \n  \n### Change Project Settings  \n **/clr** can be selected in the development environment by following the instructions in [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md). As mentioned previously, this step will automatically disable conflicting project settings.  \n  \n> [!NOTE]\n>  When upgrading a managed library or web service project from Visual C++ 2003, the **/Zl** compiler option will added to the **Command Line** property page. This will cause LNK2001. Remove **/Zl** from the **Command Line** property page to resolve. See [/Zl (Omit Default Library Name)](../build/reference/zl-omit-default-library-name.md) and [Working with Project Properties](../ide/working-with-project-properties.md) for more information. Or, add msvcrt.lib and msvcmrt.lib to the linker's **Additional Dependencies** property.  \n  \n For projects built with makefiles, incompatible compiler options must be disabled manually once **/clr** is added. See /[/clr Restrictions](../build/reference/clr-restrictions.md) for information on compiler options that are not compatible with **/clr**.  \n  \n### Precompiled Headers  \n Precompiled headers are supported under **/clr**. However, if you only compile some of your CPP files with **/clr** (compiling the rest as native) some changes will be required because precompiled headers generated with **/clr** are not compatible with those generated without **/clr**. This incompatibility is due to the fact that **/clr** generates and requires metadata. Modules compiled **/clr** can therefore not use precompiled headers that don't include metadata, and non **/clr** modules can't use precompiled header files that do contain meta data.  \n  \n The easiest way to compile a project where some modules are compiled **/clr** is to disable precompiled headers entirely. (In the project Property Pages dialog, open the C/C++ node, and select Precompiled Headers. Then change the Create/Use Precompiled Headers property to \"Not Using Precompiled Headers\".)  \n  \n However, particularly for large projects, precompiled headers provide much better compilation speed, so disabling this feature is not desirable. In this case it's best to configure the **/clr** and non **/clr** files to use separate precompiled headers. This can be done in one step by multi-selecting the modules to be compiled **/clr** using the Solution Explorer, right-clicking on the group, and selecting Properties. Then change both the Create/Use PCH Through File and Precompiled Header File properties to use a different header file name and PCH file respectively.  \n  \n## Fixing Errors  \n Compiling with **/clr** may result in compiler, linker or runtime errors. This section discusses the most common problems.  \n  \n### Metadata Merge  \n Differing versions of data types can cause the linker to fail because the metadata generated for the two types doesn't match. (This is usually caused when members of a type are conditionally defined, but the conditions are not the same for all CPP files that use the type.) In this case the linker fails, reporting only the symbol name and the name of the second OBJ file where the type was defined. It is often useful to rotate the order that OBJ files are sent to the linker to discover the location of the other version of the data type.  \n  \n### Loader Lock Deadlock  \n In Visual C++ .NET and Visual C++ 2003, initialization under **/clr** was susceptible to non-deterministic deadlock. This issue is known as \"loader lock deadlock\". In Visual Studio 2010, this deadlock is easier to avoid, it is detected and reported at runtime, and is no longer non-deterministic. Encountering the loader lock problem is still possible, but now it's much easier to avoid and fix. See [Initialization of Mixed Assemblies](../dotnet/initialization-of-mixed-assemblies.md) for detailed background, guidance, and solutions.  \n  \n### Data Exports  \n Exporting DLL data is error-prone, and not recommended. This is because the data section of a DLL is not guaranteed to be initialized until some managed portion of the DLL has been executed. Reference metadata with [#using Directive](../preprocessor/hash-using-directive-cpp.md).  \n  \n### Type Visibility  \n Native types are now private by default. In Visual C++ .NET 2002 and Visual C++ 2003, native types were public by default. This can result in a native type not being visible outside the DLL. Resolve this error by adding `public` to these types.  \n  \n### Floating Point and Alignment Issues  \n `__controlfp` is not supported on the common language runtime (see [_control87, _controlfp, \\__control87_2](../c-runtime-library/reference/control87-controlfp-control87-2.md) for more information). The CLR will also not respect [align](../cpp/align-cpp.md).  \n  \n### COM Initialization  \n The Common Language Runtime initializes COM automatically when a module is initialized (when COM is initialized automatically it’s done so as MTA). As a result, explicitly initializing COM yields return codes indicating that COM is already initialized. Attempting to explicitly initialize COM with one threading model when the CLR has already initialized COM to another threading model can cause your application to fail.  \n  \n The common language runtime starts COM as MTA by default; use [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](../build/reference/clrthreadattribute-set-clr-thread-attribute.md) to modify this.  \n  \n### Performance Issues  \n You may see decreased performance when native C++ methods generated to MSIL are called indirectly (virtual function calls or using function pointers). To learn more about this, see [Double Thunking](../dotnet/double-thunking-cpp.md).  \n  \n When moving from native to MSIL, you will notice an increase in the size of your working set. This is because the common language runtime provides many features to ensure that programs run correctly. If your **/clr** application is not running correctly, you may want to enable C4793 (off by default), see [Compiler Warning (level 1 and 3) C4793](../error-messages/compiler-warnings/compiler-warning-level-1-and-3-c4793.md) for more information.  \n  \n### Program Crashes on Shutdown  \n In some cases, the CLR can shutdown before your managed code is finished running. Using `std::set_terminate` and `SIGTERM` can cause this. See [signal Constants](../c-runtime-library/signal-constants.md) and [set_terminate](../c-runtime-library/abnormal-termination.md) for more information.  \n  \n## Using New Visual C++ Features  \n After your application compiles, links, and runs, you can begin using .NET features in any module compiled with **/clr**. For more information, see [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md).  \n  \n If you used Managed Extensions for C++, you can convert your code to use the new syntax. For a summary of syntactical differences, see the [(NOTINBUILD)Managed Extensions for C++ Syntax Upgrade Checklist](http://msdn.microsoft.com/en-us/edbded88-7ef3-4757-bd9d-b8f48ac2aada). For details on converting Managed Extensions for C++, see [C++/CLI Migration Primer](../dotnet/cpp-cli-migration-primer.md).  \n  \n For information on .NET programming in Visual C++ see:  \n  \n-   [.NET Programming with C++/CLI (Visual C++)](../dotnet/dotnet-programming-with-cpp-cli-visual-cpp.md)  \n  \n-   [Native and .NET Interoperability](../dotnet/native-and-dotnet-interoperability.md)  \n  \n-   [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)  \n  \n## See Also  \n [Mixed (Native and Managed) Assemblies](../dotnet/mixed-native-and-managed-assemblies.md)"}