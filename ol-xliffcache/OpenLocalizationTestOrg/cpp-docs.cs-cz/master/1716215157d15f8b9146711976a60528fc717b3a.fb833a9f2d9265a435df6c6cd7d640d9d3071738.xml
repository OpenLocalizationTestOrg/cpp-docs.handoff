{"nodes":[{"pos":[12,49],"content":"Inheritance Keywords | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Inheritance Keywords | Microsoft Docs","pos":[0,37]}]},{"content":"Inheritance Keywords","pos":[1063,1083]},{"content":"Microsoft Specific","pos":[1086,1104]},{"content":"where:","pos":[1257,1263]},{"content":"class-name","pos":[1271,1281]},{"content":"The name of the class being declared.","pos":[1286,1323]},{"content":"C++ allows you to declare a pointer to a class member prior to the definition of the class.","pos":[1330,1421]},{"content":"For example:","pos":[1422,1434]},{"content":"In the code above, <ph id=\"ph1\">`p`</ph> is declared to be a pointer to integer member of class S. However, <ph id=\"ph2\">`class S`</ph> has not yet been defined in this code; it has only been declared.","pos":[1480,1645],"source":"In the code above, `p` is declared to be a pointer to integer member of class S. However, `class S` has not yet been defined in this code; it has only been declared."},{"content":"When the compiler encounters such a pointer, it must make a generalized representation of the pointer.","pos":[1646,1748]},{"content":"The size of the representation is dependent on the inheritance model specified.","pos":[1749,1828]},{"content":"There are four ways to specify an inheritance model to the compiler:","pos":[1829,1897]},{"pos":[1907,1960],"content":"In the IDE under <bpt id=\"p1\">**</bpt>Pointer-to-member representation<ept id=\"p1\">**</ept>","source":"In the IDE under **Pointer-to-member representation**"},{"pos":[1970,2066],"content":"At the command line using the <bpt id=\"p1\">[</bpt>/vmg<ept id=\"p1\">](../build/reference/vmb-vmg-representation-method.md)</ept> switch","source":"At the command line using the [/vmg](../build/reference/vmb-vmg-representation-method.md) switch"},{"pos":[2076,2154],"content":"Using the <bpt id=\"p1\">[</bpt>pointers_to_members<ept id=\"p1\">](../preprocessor/pointers-to-members.md)</ept> pragma","source":"Using the [pointers_to_members](../preprocessor/pointers-to-members.md) pragma"},{"content":"Using the inheritance keywords <ph id=\"ph1\">`__single_inheritance`</ph>, <ph id=\"ph2\">`__multiple_inheritance`</ph>, and <ph id=\"ph3\">`__virtual_inheritance`</ph>.","pos":[2164,2273],"source":"Using the inheritance keywords `__single_inheritance`, `__multiple_inheritance`, and `__virtual_inheritance`."},{"content":"This technique controls the inheritance model on a per-class basis.","pos":[2274,2341]},{"pos":[2353,2492],"content":"[!NOTE]\n If you always declare a pointer to a member of a class after defining the class, you don't need to use any of these options.","leadings":["","    > "],"nodes":[{"content":"If you always declare a pointer to a member of a class after defining the class, you don't need to use any of these options.","pos":[9,133]}]},{"content":"Declaring a pointer to a member of a class prior to the class definition affects the size and speed of the resulting executable file.","pos":[2499,2632]},{"content":"The more complex the inheritance used by a class, the greater the number of bytes required to represent a pointer to a member of the class and the larger the code required to interpret the pointer.","pos":[2633,2830]},{"content":"Single inheritance is least complex, and virtual inheritance is most complex.","pos":[2831,2908]},{"content":"If the example above is changed to:","pos":[2915,2950]},{"pos":[3017,3143],"content":"regardless of command-line options or pragmas, pointers to members of <ph id=\"ph1\">`class S`</ph> will use the smallest possible representation.","source":"regardless of command-line options or pragmas, pointers to members of `class S` will use the smallest possible representation."},{"pos":[3151,3400],"content":"[!NOTE]\n The same forward declaration of a class pointer-to-member representation should occur in every translation unit that declares pointers to members of that class, and the declaration should occur before the pointers to members are declared.","leadings":["","> "],"nodes":[{"content":"The same forward declaration of a class pointer-to-member representation should occur in every translation unit that declares pointers to members of that class, and the declaration should occur before the pointers to members are declared.","pos":[9,247]}]},{"content":"END Microsoft Specific","pos":[3409,3431]},{"content":"See Also","pos":[3442,3450]},{"content":"Keywords","pos":[3455,3463]}],"content":"---\ntitle: \"Inheritance Keywords | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"__multiple_inheritance\"\n  - \"__single_inheritance_cpp\"\n  - \"__virtual_inheritance_cpp\"\n  - \"__virtual_inheritance\"\n  - \"__multiple_inheritance_cpp\"\n  - \"__single_inheritance\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__single_inheritance keyword [C++]\"\n  - \"declaring derived classes\"\n  - \"keywords [C++], inheritance keywords\"\n  - \"__multiple_inheritance keyword [C++]\"\n  - \"__virtual_inheritance keyword [C++]\"\n  - \"inheritance, declaring derived classes\"\n  - \"derived classes, declaring\"\n  - \"inheritance, keywords\"\nms.assetid: bb810f56-7720-4fea-b8b6-9499edd141df\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Inheritance Keywords\n**Microsoft Specific**  \n  \n```  \n  \nclass [__single_inheritance] class-name;class [__multiple_inheritance] class-name;class [__virtual_inheritance] class-name;  \n```  \n  \n where:  \n  \n *class-name*  \n The name of the class being declared.  \n  \n C++ allows you to declare a pointer to a class member prior to the definition of the class. For example:  \n  \n```  \nclass S;  \nint S::*p;  \n```  \n  \n In the code above, `p` is declared to be a pointer to integer member of class S. However, `class S` has not yet been defined in this code; it has only been declared. When the compiler encounters such a pointer, it must make a generalized representation of the pointer. The size of the representation is dependent on the inheritance model specified. There are four ways to specify an inheritance model to the compiler:  \n  \n-   In the IDE under **Pointer-to-member representation**  \n  \n-   At the command line using the [/vmg](../build/reference/vmb-vmg-representation-method.md) switch  \n  \n-   Using the [pointers_to_members](../preprocessor/pointers-to-members.md) pragma  \n  \n-   Using the inheritance keywords `__single_inheritance`, `__multiple_inheritance`, and `__virtual_inheritance`. This technique controls the inheritance model on a per-class basis.  \n  \n    > [!NOTE]\n    >  If you always declare a pointer to a member of a class after defining the class, you don't need to use any of these options.  \n  \n Declaring a pointer to a member of a class prior to the class definition affects the size and speed of the resulting executable file. The more complex the inheritance used by a class, the greater the number of bytes required to represent a pointer to a member of the class and the larger the code required to interpret the pointer. Single inheritance is least complex, and virtual inheritance is most complex.  \n  \n If the example above is changed to:  \n  \n```  \nclass __single_inheritance S;  \nint S::*p;  \n```  \n  \n regardless of command-line options or pragmas, pointers to members of `class S` will use the smallest possible representation.  \n  \n> [!NOTE]\n>  The same forward declaration of a class pointer-to-member representation should occur in every translation unit that declares pointers to members of that class, and the declaration should occur before the pointers to members are declared.  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [Keywords](../cpp/keywords-cpp.md)"}