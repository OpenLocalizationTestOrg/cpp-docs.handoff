{"nodes":[{"pos":[12,66],"content":"_control87, _controlfp, __control87_2 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_control87, _controlfp, __control87_2 | Microsoft Docs","pos":[0,54]}]},{"content":"_control87, _controlfp, __control87_2","pos":[1367,1404]},{"content":"Gets and sets the floating-point control word.","pos":[1405,1451]},{"content":"A more secure version of <ph id=\"ph1\">`_controlfp`</ph> is available; see <bpt id=\"p1\">[</bpt>_controlfp_s<ept id=\"p1\">](../../c-runtime-library/reference/controlfp-s.md)</ept>.","pos":[1452,1573],"source":" A more secure version of `_controlfp` is available; see [_controlfp_s](../../c-runtime-library/reference/controlfp-s.md)."},{"content":"Syntax","pos":[1582,1588]},{"content":"Parameters","pos":[1901,1911]},{"content":"New control-word bit values.","pos":[1924,1952]},{"content":"Mask for new control-word bits to set.","pos":[1969,2007]},{"content":"Filled in with the control word for the x87 floating-point unit.","pos":[2026,2090]},{"content":"Pass in 0 (<ph id=\"ph1\">`NULL`</ph>) to set only the SSE2 control word.","pos":[2091,2144],"source":" Pass in 0 (`NULL`) to set only the SSE2 control word."},{"content":"Control word for the SSE floating-point unit.","pos":[2164,2209]},{"content":"Pass in 0 (<ph id=\"ph1\">`NULL`</ph>) to set only the x87 control word.","pos":[2210,2262],"source":" Pass in 0 (`NULL`) to set only the x87 control word."},{"content":"Return Value","pos":[2271,2283]},{"content":"For <ph id=\"ph1\">`_control87`</ph> and <ph id=\"ph2\">`_controlfp`</ph>, the bits in the value returned indicate the floating-point control state.","pos":[2287,2395],"source":"For `_control87` and `_controlfp`, the bits in the value returned indicate the floating-point control state."},{"content":"For a complete definition of the bits that are returned by <ph id=\"ph1\">`_control87`</ph>, see FLOAT.H.","pos":[2396,2481],"source":" For a complete definition of the bits that are returned by `_control87`, see FLOAT.H."},{"pos":[2488,2556],"content":"For <ph id=\"ph1\">`__control87_2`</ph>, the return value is 1, which indicates success.","source":"For `__control87_2`, the return value is 1, which indicates success."},{"content":"Remarks","pos":[2565,2572]},{"content":"The <ph id=\"ph1\">`_control87`</ph> function gets and sets the floating-point control word.","pos":[2576,2648],"source":"The `_control87` function gets and sets the floating-point control word."},{"content":"The floating-point control word enables the program to change the precision, rounding, and infinity modes in the floating-point math package, depending on the platform.","pos":[2649,2817]},{"content":"You can also use <ph id=\"ph1\">`_control87`</ph> to mask or unmask floating-point exceptions.","pos":[2818,2892],"source":" You can also use `_control87` to mask or unmask floating-point exceptions."},{"content":"If the value for <ph id=\"ph1\">`mask`</ph> is equal to 0, <ph id=\"ph2\">`_control87`</ph> gets the floating-point control word.","pos":[2893,2982],"source":" If the value for `mask` is equal to 0, `_control87` gets the floating-point control word."},{"content":"If <ph id=\"ph1\">`mask`</ph> is nonzero, a new value for the control word is set: For any bit that is on (that is, equal to 1) in <ph id=\"ph2\">`mask`</ph>, the corresponding bit in <ph id=\"ph3\">`new`</ph> is used to update the control word.","pos":[2983,3168],"source":" If `mask` is nonzero, a new value for the control word is set: For any bit that is on (that is, equal to 1) in `mask`, the corresponding bit in `new` is used to update the control word."},{"content":"In other words, <ph id=\"ph1\">`fpcntrl`</ph> <ph id=\"ph2\">`=`</ph> ((<ph id=\"ph3\">`fpcntrl`</ph> <ph id=\"ph4\">`&amp; ~mask`</ph>) &amp;#124; (<ph id=\"ph5\">`new &amp; mask`</ph>)) where <ph id=\"ph6\">`fpcntrl`</ph> is the floating-point control word.","pos":[3169,3296],"source":" In other words, `fpcntrl` `=` ((`fpcntrl` `& ~mask`) &#124; (`new & mask`)) where `fpcntrl` is the floating-point control word."},{"pos":[3304,3385],"content":"[!NOTE]\n By default, the run-time libraries mask all floating-point exceptions.","leadings":["","> "],"nodes":[{"content":"By default, the run-time libraries mask all floating-point exceptions.","pos":[9,79]}]},{"content":"is a platform-independent, portable version of <ph id=\"ph1\">`_control87`</ph>.","pos":[3405,3465],"source":" is a platform-independent, portable version of `_control87`."},{"content":"It is nearly identical to the <ph id=\"ph1\">`_control87`</ph> function on Intel (x86), <ph id=\"ph2\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph>, and ARM platforms.","pos":[3466,3620],"source":" It is nearly identical to the `_control87` function on Intel (x86), [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], and ARM platforms."},{"content":"If you are targeting x86, <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph>, or ARM platforms, use <ph id=\"ph2\">`_control87`</ph> or <ph id=\"ph3\">`_controlfp`</ph>.","pos":[3621,3766],"source":" If you are targeting x86, [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], or ARM platforms, use `_control87` or `_controlfp`."},{"content":"The difference between <ph id=\"ph1\">`_control87`</ph> and <ph id=\"ph2\">`_controlfp`</ph> is in how they treat DENORMAL values.","pos":[3773,3863],"source":"The difference between `_control87` and `_controlfp` is in how they treat DENORMAL values."},{"content":"For Intel (x86), <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph>, and ARM platforms, <ph id=\"ph2\">`_control87`</ph> can set and clear the DENORMAL OPERAND exception mask.","pos":[3864,4035],"source":" For Intel (x86), [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], and ARM platforms, `_control87` can set and clear the DENORMAL OPERAND exception mask."},{"content":"does not modify the DENORMAL OPERAND exception mask.","pos":[4049,4101]},{"content":"This example demonstrates the difference:","pos":[4102,4143]},{"content":"The possible values for the mask constant (<ph id=\"ph1\">`mask`</ph>) and new control values (<ph id=\"ph2\">`new`</ph>) are shown in the following Hexadecimal Values table.","pos":[4329,4463],"source":"The possible values for the mask constant (`mask`) and new control values (`new`) are shown in the following Hexadecimal Values table."},{"content":"Use the portable constants listed below (<ph id=\"ph1\">`_MCW_EM`</ph>, <ph id=\"ph2\">`_EM_INVALID`</ph>, and so forth) as arguments to these functions, rather than supplying the hexadecimal values explicitly.","pos":[4464,4634],"source":" Use the portable constants listed below (`_MCW_EM`, `_EM_INVALID`, and so forth) as arguments to these functions, rather than supplying the hexadecimal values explicitly."},{"content":"Intel (x86)-derived platforms support the DENORMAL input and output values in hardware.","pos":[4641,4728]},{"content":"The x86 behavior is to preserve DENORMAL values.","pos":[4729,4777]},{"content":"The ARM platform and the <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> platforms that have SSE2 support enable DENORMAL operands and results to be flushed, or forced to zero.","pos":[4778,4973],"source":" The ARM platform and the [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms that have SSE2 support enable DENORMAL operands and results to be flushed, or forced to zero."},{"content":"The <ph id=\"ph1\">`_controlfp`</ph> and <ph id=\"ph2\">`_control87`</ph> functions provide a mask to change this behavior.","pos":[4974,5057],"source":" The `_controlfp` and `_control87` functions provide a mask to change this behavior."},{"content":"The following example demonstrates the use of this mask.","pos":[5058,5114]},{"content":"On ARM platforms, the <ph id=\"ph1\">`_control87`</ph> and <ph id=\"ph2\">`_controlfp`</ph> functions apply to the FPSCR register.","pos":[5467,5557],"source":"On ARM platforms, the `_control87` and `_controlfp` functions apply to the FPSCR register."},{"content":"On <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> architectures, only the SSE2 control word that's stored in the MXCSR register is affected.","pos":[5558,5718],"source":" On [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, only the SSE2 control word that's stored in the MXCSR register is affected."},{"content":"On Intel (x86) platforms, <ph id=\"ph1\">`_control87`</ph> and <ph id=\"ph2\">`_controlfp`</ph> affect the control words for both the x87 and the SSE2, if present.","pos":[5719,5842],"source":" On Intel (x86) platforms, `_control87` and `_controlfp` affect the control words for both the x87 and the SSE2, if present."},{"content":"The function <ph id=\"ph1\">`__control87_2`</ph> enables both the x87 and SSE2 floating-point units to be controlled together or separately.","pos":[5843,5963],"source":" The function `__control87_2` enables both the x87 and SSE2 floating-point units to be controlled together or separately."},{"content":"If you want to affect both units, pass in the addresses of two integers to <ph id=\"ph1\">`x86_cw`</ph> and <ph id=\"ph2\">`sse2_cw`</ph>.","pos":[5964,6062],"source":" If you want to affect both units, pass in the addresses of two integers to `x86_cw` and `sse2_cw`."},{"content":"If you only want to affect one unit, pass in an address for that parameter but pass in 0 (NULL) for the other.","pos":[6063,6173]},{"content":"If 0 is passed for one of these parameters, the function has no effect on that floating-point unit.","pos":[6174,6273]},{"content":"This functionality could be useful in situations where part of the code uses the x87 floating-point unit and another part of the code uses the SSE2 floating-point unit.","pos":[6274,6442]},{"content":"If you use <ph id=\"ph1\">`__control87_2`</ph> in one part of a program and set different values for the floating-point control words, and then use <ph id=\"ph2\">`_control87`</ph> or <ph id=\"ph3\">`_controlfp`</ph> to further manipulate the control word, then <ph id=\"ph4\">`_control87`</ph> and <ph id=\"ph5\">`_controlfp`</ph> might be unable to return a single control word to represent the state of both floating-point units.","pos":[6443,6775],"source":" If you use `__control87_2` in one part of a program and set different values for the floating-point control words, and then use `_control87` or `_controlfp` to further manipulate the control word, then `_control87` and `_controlfp` might be unable to return a single control word to represent the state of both floating-point units."},{"content":"In such a case, these functions set the <ph id=\"ph1\">`EM_AMBIGUOUS`</ph> flag in the returned integer value to indicate that there is an inconsistency between the two control words.","pos":[6776,6939],"source":" In such a case, these functions set the `EM_AMBIGUOUS` flag in the returned integer value to indicate that there is an inconsistency between the two control words."},{"content":"This is a warning that the returned control word might not represent the state of both floating-point control words accurately.","pos":[6940,7067]},{"content":"On the ARM and <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> architectures, changing the infinity mode or the floating-point precision is not supported.","pos":[7074,7247],"source":"On the ARM and [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, changing the infinity mode or the floating-point precision is not supported."},{"content":"If the precision control mask is used on the <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> platform, the function raises an assertion and the invalid parameter handler is invoked, as described in <bpt id=\"p1\">[</bpt>Parameter Validation<ept id=\"p1\">](../../c-runtime-library/parameter-validation.md)</ept>.","pos":[7248,7537],"source":" If the precision control mask is used on the [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platform, the function raises an assertion and the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md)."},{"pos":[7545,7866],"content":"[!NOTE]\n `__control87_2` is not supported on the ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures. If you use `__control87_2` and compile your program for the ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, the compiler generates an error.","leadings":["","> "],"nodes":[{"content":" is not supported on the ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures. If you use `__control87_2` and compile your program for the ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, the compiler generates an error.","pos":[24,319],"nodes":[{"content":"is not supported on the ARM or <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> architectures.","pos":[1,113],"source":" is not supported on the ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures."},{"content":"If you use <ph id=\"ph1\">`__control87_2`</ph> and compile your program for the ARM or <ph id=\"ph2\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> architectures, the compiler generates an error.","pos":[114,295],"source":" If you use `__control87_2` and compile your program for the ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, the compiler generates an error."}]}]},{"pos":[7873,8144],"content":"These functions are ignored when you use <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../../build/reference/clr-common-language-runtime-compilation.md)</ept> or <ph id=\"ph1\">`/clr:pure`</ph> to compile because the common language runtime (CLR) only supports the default floating-point precision.","source":"These functions are ignored when you use [/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md) or `/clr:pure` to compile because the common language runtime (CLR) only supports the default floating-point precision."},{"content":"Hexadecimal Values","pos":[8153,8171]},{"content":"For the <ph id=\"ph1\">`_MCW_EM`</ph> mask, clearing the mask sets the exception, which allows the hardware exception; setting the mask hides the exception.","pos":[8180,8316],"source":"For the `_MCW_EM` mask, clearing the mask sets the exception, which allows the hardware exception; setting the mask hides the exception."},{"content":"If a <ph id=\"ph1\">`_EM_UNDERFLOW`</ph> or <ph id=\"ph2\">`_EM_OVERFLOW`</ph> occurs, no hardware exception is thrown until the next floating-point instruction is executed.","pos":[8317,8450],"source":" If a `_EM_UNDERFLOW` or `_EM_OVERFLOW` occurs, no hardware exception is thrown until the next floating-point instruction is executed."},{"content":"To generate a hardware exception immediately after <ph id=\"ph1\">`_EM_UNDERFLOW`</ph> or <ph id=\"ph2\">`_EM_OVERFLOW`</ph>, call the <ph id=\"ph3\">`FWAIT`</ph> MASM instruction.","pos":[8451,8571],"source":" To generate a hardware exception immediately after `_EM_UNDERFLOW` or `_EM_OVERFLOW`, call the `FWAIT` MASM instruction."},{"content":"Mask","pos":[8578,8582]},{"content":"Hex value","pos":[8583,8592]},{"content":"Constant","pos":[8593,8601]},{"content":"Hex value","pos":[8602,8611]},{"pos":[8688,8706],"content":"(Denormal control)"},{"content":"0x03000000","pos":[8707,8717]},{"content":"0x00000000","pos":[8753,8763]},{"content":"0x01000000","pos":[8776,8786]},{"pos":[8801,8827],"content":"(Interrupt exception mask)"},{"content":"0x0008001F","pos":[8828,8838]},{"content":"0x00000010","pos":[8990,9000]},{"content":"0x00080000","pos":[9013,9023]},{"content":"0x00000008","pos":[9036,9046]},{"content":"0x00000004","pos":[9059,9069]},{"content":"0x00000002","pos":[9082,9092]},{"content":"0x00000001","pos":[9105,9115]},{"content":"(Infinity control)","pos":[9130,9148]},{"content":"(Not supported on ARM or <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> platforms.)","pos":[9161,9264],"source":" (Not supported on ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms.)"},{"content":"0x00040000","pos":[9265,9275]},{"content":"0x00040000","pos":[9318,9328]},{"content":"0x00000000","pos":[9341,9351]},{"pos":[9366,9384],"content":"(Rounding control)"},{"content":"0x00000300","pos":[9385,9395]},{"content":"0x00000300","pos":[9474,9484]},{"content":"0x00000200","pos":[9497,9507]},{"content":"0x00000100","pos":[9520,9530]},{"content":"0x00000000","pos":[9543,9553]},{"content":"(Precision control)","pos":[9568,9587]},{"content":"(Not supported on ARM or <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> platforms.)","pos":[9600,9703],"source":" (Not supported on ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms.)"},{"content":"0x00030000","pos":[9704,9714]},{"content":"(24 bits)","pos":[9724,9733]},{"content":"(53 bits)","pos":[9755,9764]},{"content":"(64 bits)","pos":[9786,9795]},{"content":"0x00020000","pos":[9796,9806]},{"content":"0x00010000","pos":[9819,9829]},{"content":"0x00000000","pos":[9842,9852]},{"content":"Requirements","pos":[9862,9874]},{"content":"Routine","pos":[9881,9888]},{"content":"Required header","pos":[9889,9904]},{"pos":[9961,9976],"content":", <ph id=\"ph1\">`_controlfp`</ph>,","source":", `_controlfp`, "},{"content":"float.h&gt;","pos":[9994,10002],"source":"float.h>"},{"pos":[10010,10108],"content":"For more compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept>.","source":"For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md)."},{"content":"Example","pos":[10117,10124]},{"content":"Output","pos":[11380,11386]},{"content":".NET Framework Equivalent","pos":[11578,11603]},{"content":"Not applicable.","pos":[11607,11622]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[11623,11670],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[11671,11796],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"content":"See Also","pos":[11805,11813]},{"content":"Floating-Point Support","pos":[11818,11840]},{"content":"_clear87, _clearfp","pos":[11898,11916]},{"content":"_status87, _statusfp, _statusfp2","pos":[11977,12009]},{"content":"_controlfp_s","pos":[12082,12094]}],"content":"---\ntitle: \"_control87, _controlfp, __control87_2 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_control87\"\n  - \"_controlfp\"\n  - \"__control87_2\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\n  - \"api-ms-win-crt-runtime-l1-1-0.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"_control87\"\n  - \"__control87_2\"\n  - \"control87\"\n  - \"_controlfp\"\n  - \"controlfp\"\n  - \"control87_2\"\n  - \"_control87_2\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"floating-point numbers, control word\"\n  - \"_control87 function\"\n  - \"control87 function\"\n  - \"controlfp function\"\n  - \"_controlfp function\"\n  - \"__control87_2 function\"\n  - \"floating-point functions, setting control word\"\n  - \"floating-point functions\"\n  - \"EM_AMBIGUOUS\"\n  - \"control87_2 function\"\nms.assetid: 0d09729d-d9a0-43d6-864c-43ff25e7e0c5\ncaps.latest.revision: 34\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _control87, _controlfp, __control87_2\nGets and sets the floating-point control word. A more secure version of `_controlfp` is available; see [_controlfp_s](../../c-runtime-library/reference/controlfp-s.md).  \n  \n## Syntax  \n  \n```  \nunsigned int _control87(   \n   unsigned int new,  \n   unsigned int mask   \n);  \nunsigned int _controlfp(   \n   unsigned int new,  \n   unsigned int mask   \n);  \nint __control87_2(  \n   unsigned int new,  \n   unsigned int mask,  \n   unsigned int* x86_cw,  \n   unsigned int* sse2_cw  \n);  \n```  \n  \n#### Parameters  \n `new`  \n New control-word bit values.  \n  \n `mask`  \n Mask for new control-word bits to set.  \n  \n `x86_cw`  \n Filled in with the control word for the x87 floating-point unit. Pass in 0 (`NULL`) to set only the SSE2 control word.  \n  \n `sse2_cw`  \n Control word for the SSE floating-point unit. Pass in 0 (`NULL`) to set only the x87 control word.  \n  \n## Return Value  \n For `_control87` and `_controlfp`, the bits in the value returned indicate the floating-point control state. For a complete definition of the bits that are returned by `_control87`, see FLOAT.H.  \n  \n For `__control87_2`, the return value is 1, which indicates success.  \n  \n## Remarks  \n The `_control87` function gets and sets the floating-point control word. The floating-point control word enables the program to change the precision, rounding, and infinity modes in the floating-point math package, depending on the platform. You can also use `_control87` to mask or unmask floating-point exceptions. If the value for `mask` is equal to 0, `_control87` gets the floating-point control word. If `mask` is nonzero, a new value for the control word is set: For any bit that is on (that is, equal to 1) in `mask`, the corresponding bit in `new` is used to update the control word. In other words, `fpcntrl` `=` ((`fpcntrl` `& ~mask`) &#124; (`new & mask`)) where `fpcntrl` is the floating-point control word.  \n  \n> [!NOTE]\n>  By default, the run-time libraries mask all floating-point exceptions.  \n  \n `_controlfp` is a platform-independent, portable version of `_control87`. It is nearly identical to the `_control87` function on Intel (x86), [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], and ARM platforms. If you are targeting x86, [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], or ARM platforms, use `_control87` or `_controlfp`.  \n  \n The difference between `_control87` and `_controlfp` is in how they treat DENORMAL values. For Intel (x86), [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], and ARM platforms, `_control87` can set and clear the DENORMAL OPERAND exception mask. `_controlfp` does not modify the DENORMAL OPERAND exception mask. This example demonstrates the difference:  \n  \n```  \n_control87( _EM_INVALID, _MCW_EM );   \n// DENORMAL is unmasked by this call  \n_controlfp( _EM_INVALID, _MCW_EM );   \n// DENORMAL exception mask remains unchanged  \n```  \n  \n The possible values for the mask constant (`mask`) and new control values (`new`) are shown in the following Hexadecimal Values table. Use the portable constants listed below (`_MCW_EM`, `_EM_INVALID`, and so forth) as arguments to these functions, rather than supplying the hexadecimal values explicitly.  \n  \n Intel (x86)-derived platforms support the DENORMAL input and output values in hardware. The x86 behavior is to preserve DENORMAL values. The ARM platform and the [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms that have SSE2 support enable DENORMAL operands and results to be flushed, or forced to zero. The `_controlfp` and `_control87` functions provide a mask to change this behavior. The following example demonstrates the use of this mask.  \n  \n```  \n_controlfp(_DN_SAVE, _MCW_DN);     \n// Denormal values preserved on ARM platforms and on x64 processors with  \n// SSE2 support. NOP on x86 platforms.  \n_controlfp(_DN_FLUSH, _MCW_DN);     \n// Denormal values flushed to zero by hardware on ARM platforms   \n// and x64 processors with SSE2 support. Ignored on other x86 platforms.  \n```  \n  \n On ARM platforms, the `_control87` and `_controlfp` functions apply to the FPSCR register. On [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, only the SSE2 control word that's stored in the MXCSR register is affected. On Intel (x86) platforms, `_control87` and `_controlfp` affect the control words for both the x87 and the SSE2, if present. The function `__control87_2` enables both the x87 and SSE2 floating-point units to be controlled together or separately. If you want to affect both units, pass in the addresses of two integers to `x86_cw` and `sse2_cw`. If you only want to affect one unit, pass in an address for that parameter but pass in 0 (NULL) for the other. If 0 is passed for one of these parameters, the function has no effect on that floating-point unit. This functionality could be useful in situations where part of the code uses the x87 floating-point unit and another part of the code uses the SSE2 floating-point unit. If you use `__control87_2` in one part of a program and set different values for the floating-point control words, and then use `_control87` or `_controlfp` to further manipulate the control word, then `_control87` and `_controlfp` might be unable to return a single control word to represent the state of both floating-point units. In such a case, these functions set the `EM_AMBIGUOUS` flag in the returned integer value to indicate that there is an inconsistency between the two control words. This is a warning that the returned control word might not represent the state of both floating-point control words accurately.  \n  \n On the ARM and [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, changing the infinity mode or the floating-point precision is not supported. If the precision control mask is used on the [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platform, the function raises an assertion and the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md).  \n  \n> [!NOTE]\n>  `__control87_2` is not supported on the ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures. If you use `__control87_2` and compile your program for the ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, the compiler generates an error.  \n  \n These functions are ignored when you use [/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md) or `/clr:pure` to compile because the common language runtime (CLR) only supports the default floating-point precision.  \n  \n **Hexadecimal Values**  \n  \n For the `_MCW_EM` mask, clearing the mask sets the exception, which allows the hardware exception; setting the mask hides the exception. If a `_EM_UNDERFLOW` or `_EM_OVERFLOW` occurs, no hardware exception is thrown until the next floating-point instruction is executed. To generate a hardware exception immediately after `_EM_UNDERFLOW` or `_EM_OVERFLOW`, call the `FWAIT` MASM instruction.  \n  \n|Mask|Hex value|Constant|Hex value|  \n|----------|---------------|--------------|---------------|  \n|`_MCW_DN` (Denormal control)|0x03000000|`_DN_SAVE`<br /><br /> `_DN_FLUSH`|0x00000000<br /><br /> 0x01000000|  \n|`_MCW_EM` (Interrupt exception mask)|0x0008001F|`_EM_INVALID`<br /><br /> `_EM_DENORMAL`<br /><br /> `_EM_ZERODIVIDE`<br /><br /> `_EM_OVERFLOW`<br /><br /> `_EM_UNDERFLOW`<br /><br /> `_EM_INEXACT`|0x00000010<br /><br /> 0x00080000<br /><br /> 0x00000008<br /><br /> 0x00000004<br /><br /> 0x00000002<br /><br /> 0x00000001|  \n|`_MCW_IC` (Infinity control)<br /><br /> (Not supported on ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms.)|0x00040000|`_IC_AFFINE`<br /><br /> `_IC_PROJECTIVE`|0x00040000<br /><br /> 0x00000000|  \n|`_MCW_RC` (Rounding control)|0x00000300|`_RC_CHOP`<br /><br /> `_RC_UP`<br /><br /> `_RC_DOWN`<br /><br /> `_RC_NEAR`|0x00000300<br /><br /> 0x00000200<br /><br /> 0x00000100<br /><br /> 0x00000000|  \n|`_MCW_PC` (Precision control)<br /><br /> (Not supported on ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms.)|0x00030000|`_PC_24` (24 bits)<br /><br /> `_PC_53` (53 bits)<br /><br /> `_PC_64` (64 bits)|0x00020000<br /><br /> 0x00010000<br /><br /> 0x00000000|  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`_control87`, `_controlfp`, `_control87_2`|\\<float.h>|  \n  \n For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md).  \n  \n## Example  \n  \n```  \n  \n      // crt_cntrl87.c  \n// processor: x86  \n// This program uses __control87_2 to output the x87 control   \n// word, set the precision to 24 bits, and reset the status to   \n// the default.  \n//  \n  \n#include <stdio.h>  \n#include <float.h>  \n#pragma fenv_access (on)  \n  \nint main( void )  \n{  \n    double a = 0.1;  \n    unsigned int control_word_x87;  \n  \n    // Show original x87 control word and do calculation.  \n    control_word_x87 = __control87_2(0, 0,  \n                                     &control_word_x87, 0);  \n    printf( \"Original: 0x%.4x\\n\", control_word_x87 );  \n    printf( \"%1.1f * %1.1f = %.15e\\n\", a, a, a * a );  \n  \n    // Set precision to 24 bits and recalculate.  \n    control_word_x87 = __control87_2(_PC_24, MCW_PC,  \n                                     &control_word_x87, 0);  \n    printf( \"24-bit:   0x%.4x\\n\", control_word_x87 );  \n    printf( \"%1.1f * %1.1f = %.15e\\n\", a, a, a * a );  \n  \n    // Restore default precision-control bits and recalculate.  \n    control_word_x87 = __control87_2( _CW_DEFAULT, MCW_PC,   \n                                     &control_word_x87, 0 );  \n    printf( \"Default:  0x%.4x\\n\", control_word_x87 );  \n    printf( \"%1.1f * %1.1f = %.15e\\n\", a, a, a * a );  \n}  \n```  \n  \n## Output  \n  \n```  \nOriginal: 0x0001  \n0.1 * 0.1 = 1.000000000000000e-002  \n24-bit:   0x0001  \n0.1 * 0.1 = 9.999999776482582e-003  \nDefault:  0x0001  \n0.1 * 0.1 = 1.000000000000000e-002  \n```  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [Floating-Point Support](../../c-runtime-library/floating-point-support.md)   \n [_clear87, _clearfp](../../c-runtime-library/reference/clear87-clearfp.md)   \n [_status87, _statusfp, _statusfp2](../../c-runtime-library/reference/status87-statusfp-statusfp2.md)   \n [_controlfp_s](../../c-runtime-library/reference/controlfp-s.md)"}