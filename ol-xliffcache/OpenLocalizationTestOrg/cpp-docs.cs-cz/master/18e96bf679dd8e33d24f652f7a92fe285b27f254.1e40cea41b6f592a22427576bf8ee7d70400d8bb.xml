{"nodes":[{"pos":[12,44],"content":"enable_if Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"enable_if Class | Microsoft Docs","pos":[0,32]}]},{"pos":[744,759],"content":"enable_if Class","linkify":"enable_if Class","nodes":[{"content":"enable_if Class","pos":[0,15]}]},{"content":"Conditionally makes an instance of a type for SFINAE overload resolution.","pos":[760,833]},{"content":"The nested typedef <ph id=\"ph1\">`enable_if&lt;Condition,Type&gt;::type`</ph> exists—and is a synonym for <ph id=\"ph2\">`Type`</ph>—if and only if <ph id=\"ph3\">`Condition`</ph> is <ph id=\"ph4\">`true`</ph>.","pos":[834,959],"source":" The nested typedef `enable_if<Condition,Type>::type` exists—and is a synonym for `Type`—if and only if `Condition` is `true`."},{"pos":[968,974],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1050,1060],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The value that determines the existence of the resulting type.","pos":[1071,1133]},{"content":"The type to instantiate if <ph id=\"ph1\">`B`</ph> is true.","pos":[1147,1186],"source":" The type to instantiate if `B` is true."},{"pos":[1195,1202],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[1206,1299],"content":"If <ph id=\"ph1\">`B`</ph> is true, <ph id=\"ph2\">`enable_if&lt;B, T&gt;`</ph> has a nested typedef named \"type\" that's a synonym for <ph id=\"ph3\">`T`</ph>.","source":"If `B` is true, `enable_if<B, T>` has a nested typedef named \"type\" that's a synonym for `T`."},{"pos":[1306,1384],"content":"If <ph id=\"ph1\">`B`</ph> is false, <ph id=\"ph2\">`enable_if&lt;B, T&gt;`</ph> doesn't have a nested typedef named \"type\".","source":"If `B` is false, `enable_if<B, T>` doesn't have a nested typedef named \"type\"."},{"content":"This alias template is provided:","pos":[1391,1423]},{"content":"In C++, substitution failure of template parameters is not an error in itself—this is referred to as <bpt id=\"p1\">*</bpt>SFINAE<ept id=\"p1\">*</ept> (substitution failure is not an error).","pos":[1531,1680],"source":"In C++, substitution failure of template parameters is not an error in itself—this is referred to as *SFINAE* (substitution failure is not an error)."},{"content":"Typically, <ph id=\"ph1\">`enable_if`</ph> is used to remove candidates from overload resolution—that is, it culls the overload set—so that one definition can be rejected in favor of another.","pos":[1681,1852],"source":" Typically, `enable_if` is used to remove candidates from overload resolution—that is, it culls the overload set—so that one definition can be rejected in favor of another."},{"content":"This conforms to SFINAE behavior.","pos":[1853,1886]},{"content":"For more information about SFINAE, see <bpt id=\"p1\">[</bpt>Substitution failure is not an error<ept id=\"p1\">](http://go.microsoft.com/fwlink/LinkId=394798)</ept> on Wikipedia.","pos":[1887,2024],"source":" For more information about SFINAE, see [Substitution failure is not an error](http://go.microsoft.com/fwlink/LinkId=394798) on Wikipedia."},{"content":"Here are four example scenarios:","pos":[2031,2063]},{"content":"Scenario 1: Wrapping the return type of a function:","pos":[2073,2124]},{"content":"Scenario 2: Adding a function parameter that has a default argument:","pos":[2423,2491]},{"content":"Scenario 3: Adding a template parameter that has a default argument:","pos":[2649,2717]},{"content":"Scenario 4: If your function has a non-templated argument, you can wrap its type:","pos":[2858,2939]},{"content":"Scenario 1 doesn't work with constructors and conversion operators because they don't have return types.","pos":[3094,3198]},{"content":"Scenario 2 leaves the parameter unnamed.","pos":[3205,3245]},{"content":"You could say <ph id=\"ph1\">`::type Dummy = BAR`</ph>, but the name <ph id=\"ph2\">`Dummy`</ph> is irrelevant, and giving it a name is likely to trigger an \"unreferenced parameter\" warning.","pos":[3246,3396],"source":" You could say `::type Dummy = BAR`, but the name `Dummy` is irrelevant, and giving it a name is likely to trigger an \"unreferenced parameter\" warning."},{"content":"You have to choose a <ph id=\"ph1\">`FOO`</ph> function parameter type and <ph id=\"ph2\">`BAR`</ph> default argument.","pos":[3397,3475],"source":" You have to choose a `FOO` function parameter type and `BAR` default argument."},{"content":"You could say <ph id=\"ph1\">`int`</ph> and <ph id=\"ph2\">`0`</ph>, but then users of your code could accidentally pass to the function an extra integer that would be ignored.","pos":[3477,3613],"source":"  You could say `int` and `0`, but then users of your code could accidentally pass to the function an extra integer that would be ignored."},{"content":"Instead, we recommend that you use <ph id=\"ph1\">`void **`</ph> and either <ph id=\"ph2\">`0`</ph> or <ph id=\"ph3\">`nullptr`</ph> because almost nothing is convertible to <ph id=\"ph4\">`void **`</ph>:","pos":[3614,3738],"source":" Instead, we recommend that you use `void **` and either `0` or `nullptr` because almost nothing is convertible to `void **`:"},{"content":"Scenario 2 also works for ordinary constructors.","pos":[3903,3951]},{"content":"However, it doesn't work for conversion operators because they can't take extra parameters.","pos":[3953,4044]},{"content":"It also doesn't work for <bpt id=\"p1\">[</bpt>variadic<ept id=\"p1\">](../cpp/ellipses-and-variadic-templates.md)</ept> constructors because adding extra parameters makes the function parameter pack a non-deduced context and thereby defeats the purpose of <ph id=\"ph1\">`enable_if`</ph>.","pos":[4046,4273],"source":"  It also doesn't work for [variadic](../cpp/ellipses-and-variadic-templates.md) constructors because adding extra parameters makes the function parameter pack a non-deduced context and thereby defeats the purpose of `enable_if`."},{"content":"Scenario 3 uses the name <ph id=\"ph1\">`Dummy`</ph>, but it's optional.","pos":[4280,4332],"source":"Scenario 3 uses the name `Dummy`, but it's optional."},{"content":"Just \" <ph id=\"ph1\">`typename = typename`</ph>\" would work, but if you think that looks weird, you can use a \"dummy\" name—just don't use one that might also be used in the function definition.","pos":[4333,4507],"source":" Just \" `typename = typename`\" would work, but if you think that looks weird, you can use a \"dummy\" name—just don't use one that might also be used in the function definition."},{"content":"If you don't give a type to <ph id=\"ph1\">`enable_if`</ph>, it defaults to void, and that's perfectly reasonable because you don't care what <ph id=\"ph2\">`Dummy`</ph> is.","pos":[4508,4641],"source":" If you don't give a type to `enable_if`, it defaults to void, and that's perfectly reasonable because you don't care what `Dummy` is."},{"content":"This works for everything, including conversion operators and <bpt id=\"p1\">[</bpt>variadic<ept id=\"p1\">](../cpp/ellipses-and-variadic-templates.md)</ept> constructors.","pos":[4642,4771],"source":" This works for everything, including conversion operators and [variadic](../cpp/ellipses-and-variadic-templates.md) constructors."},{"content":"Scenario 4 works in constructors that don't have return types, and thereby solves the wrapping limitation of Scenario 1.","pos":[4778,4898]},{"content":"However, Scenario 4 is limited to non-templated function arguments, which aren't always available.","pos":[4900,4998]},{"content":"(Using Scenario 4 on a templated function argument prevents template argument deduction from working on it.)","pos":[5000,5108]},{"content":"<ph id=\"ph1\">`enable_if`</ph> is powerful, but also dangerous if it's misused.","pos":[5115,5175],"source":"`enable_if` is powerful, but also dangerous if it's misused."},{"content":"Because its purpose is to make candidates vanish before overload resolution, when it's misused, its effects can be very confusing.","pos":[5177,5307]},{"content":"Here are some recommendations:","pos":[5309,5339]},{"content":"Do not use <ph id=\"ph1\">`enable_if`</ph> to select between implementations at compile-time.","pos":[5349,5422],"source":"Do not use `enable_if` to select between implementations at compile-time."},{"content":"Don't ever write one <ph id=\"ph1\">`enable_if`</ph> for <ph id=\"ph2\">`CONDITION`</ph> and another for <ph id=\"ph3\">`!CONDITION`</ph>.","pos":[5423,5501],"source":" Don't ever write one `enable_if` for `CONDITION` and another for `!CONDITION`."},{"content":"Instead, use a <bpt id=\"p1\">*</bpt>tag dispatch<ept id=\"p1\">*</ept> pattern—for example, an algorithm that selects implementations depending on the strengths of the iterators they're given.","pos":[5503,5654],"source":"  Instead, use a *tag dispatch* pattern—for example, an algorithm that selects implementations depending on the strengths of the iterators they're given."},{"content":"Do not use <ph id=\"ph1\">`enable_if`</ph> to enforce requirements.","pos":[5664,5711],"source":"Do not use `enable_if` to enforce requirements."},{"content":"If you want to validate template parameters, and if the validation fails, cause an error instead of selecting another implementation, use <bpt id=\"p1\">[</bpt>static_assert<ept id=\"p1\">](../cpp/static-assert.md)</ept>.","pos":[5713,5892],"source":"  If you want to validate template parameters, and if the validation fails, cause an error instead of selecting another implementation, use [static_assert](../cpp/static-assert.md)."},{"content":"Use <ph id=\"ph1\">`enable_if`</ph> when you have an overload set that makes otherwise good code ambiguous.","pos":[5902,5989],"source":"Use `enable_if` when you have an overload set that makes otherwise good code ambiguous."},{"content":"Most often, this occurs in implicitly converting constructors.","pos":[5991,6053]},{"pos":[6062,6069],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6073,6227],"content":"This example explains how the STL template function <bpt id=\"p1\">[</bpt>std::make_pair()<ept id=\"p1\">](../standard-library/utility-functions.md#make_pair)</ept> takes advantage of <ph id=\"ph1\">`enable_if`</ph>.","source":"This example explains how the STL template function [std::make_pair()](../standard-library/utility-functions.md#make_pair) takes advantage of `enable_if`."},{"content":"In this example, <ph id=\"ph1\">`make_pair(\"foo\", \"bar\")`</ph> returns <ph id=\"ph2\">`pair&lt;const char *, const char *&gt;`</ph>.","pos":[6358,6444],"source":"In this example, `make_pair(\"foo\", \"bar\")` returns `pair<const char *, const char *>`."},{"content":"Overload resolution has to determine which <ph id=\"ph1\">`func()`</ph> you want.","pos":[6445,6506],"source":" Overload resolution has to determine which `func()` you want."},{"content":"<ph id=\"ph1\">`pair&lt;A, B&gt;`</ph> has an implicitly converting constructor from <ph id=\"ph2\">`pair&lt;X, Y&gt;`</ph>.","pos":[6507,6579],"source":"`pair<A, B>` has an implicitly converting constructor from `pair<X, Y>`."},{"content":"This isn't new—it was in C++98.","pos":[6581,6612]},{"content":"However, in C++98/03, the implicitly converting constructor's signature always exists, even if it's <ph id=\"ph1\">`pair&lt;int, int&gt;(const pair&lt;const char *, const char *&gt;&amp;)`</ph>.","pos":[6613,6771],"source":" However, in C++98/03, the implicitly converting constructor's signature always exists, even if it's `pair<int, int>(const pair<const char *, const char *>&)`."},{"content":"Overload resolution doesn't care that an attempt to instantiate that constructor explodes horribly because <ph id=\"ph1\">`const char *`</ph> isn't implicitly convertible to <ph id=\"ph2\">`int`</ph>; it's only looking at signatures, before function definitions are instantiated.","pos":[6773,7012],"source":"  Overload resolution doesn't care that an attempt to instantiate that constructor explodes horribly because `const char *` isn't implicitly convertible to `int`; it's only looking at signatures, before function definitions are instantiated."},{"content":"Therefore, the example code is ambiguous, because signatures exist to convert <ph id=\"ph1\">`pair&lt;const char *, const char *&gt;`</ph> to both <ph id=\"ph2\">`pair&lt;int, int&gt;`</ph> and <ph id=\"ph3\">`pair&lt;string, string&gt;`</ph>.","pos":[7014,7179],"source":"  Therefore, the example code is ambiguous, because signatures exist to convert `pair<const char *, const char *>` to both `pair<int, int>` and `pair<string, string>`."},{"content":"C++11 solved this ambiguity by using <ph id=\"ph1\">`enable_if`</ph> to make sure <ph id=\"ph2\">`pair&lt;A, B&gt;(const pair&lt;X, Y&gt;&amp;)`</ph> exists <bpt id=\"p1\">**</bpt>only<ept id=\"p1\">**</ept> when <ph id=\"ph3\">`const X&amp;`</ph> is implicitly convertible to <ph id=\"ph4\">`A`</ph> and <ph id=\"ph5\">`const Y&amp;`</ph> is implicitly convertible to <ph id=\"ph6\">`B`</ph>.","pos":[7186,7393],"source":"C++11 solved this ambiguity by using `enable_if` to make sure `pair<A, B>(const pair<X, Y>&)` exists **only** when `const X&` is implicitly convertible to `A` and `const Y&` is implicitly convertible to `B`."},{"content":"This allows overload resolution to determine that <ph id=\"ph1\">`pair&lt;const char *, const char *&gt;`</ph> is not convertible to <ph id=\"ph2\">`pair&lt;int, int&gt;`</ph> and that the overload that takes <ph id=\"ph3\">`pair&lt;string, string&gt;`</ph> is viable.","pos":[7395,7585],"source":"  This allows overload resolution to determine that `pair<const char *, const char *>` is not convertible to `pair<int, int>` and that the overload that takes `pair<string, string>` is viable."},{"pos":[7594,7606],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[7610,7635],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> &lt;type_traits&gt;","source":"**Header:** <type_traits>"},{"pos":[7642,7660],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[7669,7677],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[7681,7732],"content":"<bpt id=\"p1\">[</bpt>&lt;type_traits&gt;<ept id=\"p1\">](../standard-library/type-traits.md)</ept>","source":"[<type_traits>](../standard-library/type-traits.md)"}],"content":"---\ntitle: \"enable_if Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"enable_if\"\n  - \"std::tr1::enable_if\"\n  - \"std.tr1.enable_if\"\n  - \"std.enable_if\"\n  - \"std::enable_if\"\n  - \"type_traits/std::enable_if\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"enable_if class[TR1]\"\n  - \"enable_if\"\nms.assetid: c6b8d41c-a18f-4e30-a39e-b3aa0e8fd926\ncaps.latest.revision: 28\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# enable_if Class\nConditionally makes an instance of a type for SFINAE overload resolution. The nested typedef `enable_if<Condition,Type>::type` exists—and is a synonym for `Type`—if and only if `Condition` is `true`.  \n  \n## Syntax  \n  \n```\ntemplate <bool B, class T = void>\nstruct enable_if;\n```  \n  \n#### Parameters  \n `B`  \n The value that determines the existence of the resulting type.  \n  \n `T`  \n The type to instantiate if `B` is true.  \n  \n## Remarks  \n If `B` is true, `enable_if<B, T>` has a nested typedef named \"type\" that's a synonym for `T`.  \n  \n If `B` is false, `enable_if<B, T>` doesn't have a nested typedef named \"type\".  \n  \n This alias template is provided:  \n  \n```cpp\ntemplate <bool B, class T = void>\nusing enable_if_t = typename enable_if<B,T>::type;\n```  \n  \n In C++, substitution failure of template parameters is not an error in itself—this is referred to as *SFINAE* (substitution failure is not an error). Typically, `enable_if` is used to remove candidates from overload resolution—that is, it culls the overload set—so that one definition can be rejected in favor of another. This conforms to SFINAE behavior. For more information about SFINAE, see [Substitution failure is not an error](http://go.microsoft.com/fwlink/LinkId=394798) on Wikipedia.  \n  \n Here are four example scenarios:  \n  \n-   Scenario 1: Wrapping the return type of a function:  \n  \n ```cpp\n    template <your_stuff>  \ntypename enable_if<your_condition, your_return_type>::type\n    yourfunction(args) {// ...\n }\n// The alias template makes it more concise:\n    template <your_stuff>  \nenable_if_t<your_condition, your_return_type>  \nyourfunction(args) {// ...\n }\n```  \n  \n-   Scenario 2: Adding a function parameter that has a default argument:  \n  \n ```cpp\n\n    template <your_stuff>  \nyour_return_type_if_present\n    yourfunction(args, enable_if_t<your condition, FOO> = BAR) {// ...\n }\n```  \n  \n-   Scenario 3: Adding a template parameter that has a default argument:  \n  \n ```cpp\n\n    template <your_stuff, typename Dummy = enable_if_t<your_condition>>  \nrest_of_function_declaration_goes_here\n```  \n  \n-   Scenario 4: If your function has a non-templated argument, you can wrap its type:  \n  \n ```cpp\n\n    template <typename T>  \nvoid your_function(const T& t,\n    enable_if_t<is_something<T>::value, const string&>  \ns) {// ...\n }\n```  \n  \n Scenario 1 doesn't work with constructors and conversion operators because they don't have return types.  \n  \n Scenario 2 leaves the parameter unnamed. You could say `::type Dummy = BAR`, but the name `Dummy` is irrelevant, and giving it a name is likely to trigger an \"unreferenced parameter\" warning. You have to choose a `FOO` function parameter type and `BAR` default argument.  You could say `int` and `0`, but then users of your code could accidentally pass to the function an extra integer that would be ignored. Instead, we recommend that you use `void **` and either `0` or `nullptr` because almost nothing is convertible to `void **`:  \n  \n```cpp\ntemplate <your_stuff>  \nyour_return_type_if_present\nyourfunction(args, typename enable_if<your_condition, void **>::type = nullptr) {// ...\n}\n```  \n  \n Scenario 2 also works for ordinary constructors.  However, it doesn't work for conversion operators because they can't take extra parameters.  It also doesn't work for [variadic](../cpp/ellipses-and-variadic-templates.md) constructors because adding extra parameters makes the function parameter pack a non-deduced context and thereby defeats the purpose of `enable_if`.  \n  \n Scenario 3 uses the name `Dummy`, but it's optional. Just \" `typename = typename`\" would work, but if you think that looks weird, you can use a \"dummy\" name—just don't use one that might also be used in the function definition. If you don't give a type to `enable_if`, it defaults to void, and that's perfectly reasonable because you don't care what `Dummy` is. This works for everything, including conversion operators and [variadic](../cpp/ellipses-and-variadic-templates.md) constructors.  \n  \n Scenario 4 works in constructors that don't have return types, and thereby solves the wrapping limitation of Scenario 1.  However, Scenario 4 is limited to non-templated function arguments, which aren't always available.  (Using Scenario 4 on a templated function argument prevents template argument deduction from working on it.)  \n  \n `enable_if` is powerful, but also dangerous if it's misused.  Because its purpose is to make candidates vanish before overload resolution, when it's misused, its effects can be very confusing.  Here are some recommendations:  \n  \n-   Do not use `enable_if` to select between implementations at compile-time. Don't ever write one `enable_if` for `CONDITION` and another for `!CONDITION`.  Instead, use a *tag dispatch* pattern—for example, an algorithm that selects implementations depending on the strengths of the iterators they're given.  \n  \n-   Do not use `enable_if` to enforce requirements.  If you want to validate template parameters, and if the validation fails, cause an error instead of selecting another implementation, use [static_assert](../cpp/static-assert.md).  \n  \n-   Use `enable_if` when you have an overload set that makes otherwise good code ambiguous.  Most often, this occurs in implicitly converting constructors.  \n  \n## Example  \n This example explains how the STL template function [std::make_pair()](../standard-library/utility-functions.md#make_pair) takes advantage of `enable_if`.  \n  \n```cpp\nvoid func(const pair<int, int>&);\n\nvoid func(const pair<string, string>&);\n\nfunc(make_pair(\"foo\", \"bar\"));\n```  \n  \n  In this example, `make_pair(\"foo\", \"bar\")` returns `pair<const char *, const char *>`. Overload resolution has to determine which `func()` you want. `pair<A, B>` has an implicitly converting constructor from `pair<X, Y>`.  This isn't new—it was in C++98. However, in C++98/03, the implicitly converting constructor's signature always exists, even if it's `pair<int, int>(const pair<const char *, const char *>&)`.  Overload resolution doesn't care that an attempt to instantiate that constructor explodes horribly because `const char *` isn't implicitly convertible to `int`; it's only looking at signatures, before function definitions are instantiated.  Therefore, the example code is ambiguous, because signatures exist to convert `pair<const char *, const char *>` to both `pair<int, int>` and `pair<string, string>`.  \n  \n C++11 solved this ambiguity by using `enable_if` to make sure `pair<A, B>(const pair<X, Y>&)` exists **only** when `const X&` is implicitly convertible to `A` and `const Y&` is implicitly convertible to `B`.  This allows overload resolution to determine that `pair<const char *, const char *>` is not convertible to `pair<int, int>` and that the overload that takes `pair<string, string>` is viable.  \n  \n## Requirements  \n **Header:** <type_traits>  \n  \n **Namespace:** std  \n  \n## See Also  \n [<type_traits>](../standard-library/type-traits.md)\n\n\n\n"}