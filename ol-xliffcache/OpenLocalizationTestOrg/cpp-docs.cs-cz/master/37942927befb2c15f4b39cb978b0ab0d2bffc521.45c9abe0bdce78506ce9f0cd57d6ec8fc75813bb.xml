{"nodes":[{"pos":[12,83],"content":"Tracking Reference Operator (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Tracking Reference Operator (C++ Component Extensions) | Microsoft Docs","pos":[0,71]}]},{"content":"Tracking Reference Operator (C++ Component Extensions)","pos":[678,732]},{"pos":[733,915],"content":"A <bpt id=\"p1\">*</bpt>tracking reference<ept id=\"p1\">*</ept> (<ph id=\"ph1\">`%`</ph>) behaves like an ordinary C++ reference (<ph id=\"ph2\">`&amp;`</ph>) except that when an object is assigned to a tracking reference, the object’s reference count is incremented.","source":"A *tracking reference* (`%`) behaves like an ordinary C++ reference (`&`) except that when an object is assigned to a tracking reference, the object’s reference count is incremented."},{"content":"All Platforms","pos":[924,937]},{"content":"A tracking reference has the following characteristics.","pos":[941,996]},{"content":"Assignment of an object to a tracking reference causes the object’s reference count to be incremented.","pos":[1006,1108]},{"content":"A native reference (&amp;) is the result when you dereference a *.","pos":[1118,1180],"source":"A native reference (&) is the result when you dereference a *."},{"content":"A tracking reference (%) is the result when you dereference a ^.","pos":[1181,1245]},{"content":"As long as you have a % to an object, the object will stay alive in memory.","pos":[1246,1321]},{"pos":[1331,1409],"content":"The dot (<ph id=\"ph1\">`.`</ph>) member-access operator is used to access a member of the object.","source":"The dot (`.`) member-access operator is used to access a member of the object."},{"pos":[1419,1501],"content":"Tracking references are valid for value types and handles (for example <ph id=\"ph1\">`String^`</ph>).","source":"Tracking references are valid for value types and handles (for example `String^`)."},{"content":"A tracking reference cannot be assigned a null or <ph id=\"ph1\">`nullptr`</ph> value.","pos":[1511,1577],"source":"A tracking reference cannot be assigned a null or `nullptr` value."},{"content":"A tracking reference may be reassigned to another valid object as many times as required.","pos":[1578,1667]},{"content":"A tracking reference cannot be used as a unary take-address operator.","pos":[1677,1746]},{"content":"A tracking reference behaves like a standard C++ reference, except that a % is reference-counted.","pos":[1811,1908]},{"content":"The following snippet shows how to convert between % and ^ types:","pos":[1909,1974]},{"content":"The following example shows how to pass a ^ to a function that takes a %.","pos":[2073,2146]},{"content":"In C++/CLI, you can use a tracking reference to a handle when you bind to an object of a CLR type on the garbage-collected heap.","pos":[2512,2640]},{"content":"In the CLR, the value of a tracking reference variable is updated automatically whenever the garbage collector moves the referenced object.","pos":[2647,2786]},{"content":"A tracking reference can be declared only on the stack.","pos":[2793,2848]},{"content":"A tracking reference cannot be a member of a class.","pos":[2849,2900]},{"content":"It is not possible to have a native C++ reference to an object on the garbage-collected heap.","pos":[2907,3000]},{"content":"For more information about tracking references in C++/CLI, see:","pos":[3007,3070]},{"content":"How to: Use Tracking References in C++/CLI","pos":[3081,3123]},{"content":"Examples","pos":[3188,3196]},{"content":"Example","pos":[3202,3209]},{"content":"The following sample for C++/CLI shows how to use a tracking reference with native and managed types.","pos":[3218,3319]},{"content":"Example","pos":[4176,4183]},{"content":"The following sample for C++/CLI shows how to bind a tracking reference to an array.","pos":[4192,4276]},{"content":"Output","pos":[4576,4582]}],"content":"---\ntitle: \"Tracking Reference Operator (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"%\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"tracking references\"\n  - \"% tracking reference [C++]\"\nms.assetid: 142a7269-ab69-4b54-a6d7-833bef06228f\ncaps.latest.revision: 31\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Tracking Reference Operator (C++ Component Extensions)\nA *tracking reference* (`%`) behaves like an ordinary C++ reference (`&`) except that when an object is assigned to a tracking reference, the object’s reference count is incremented.  \n  \n## All Platforms  \n A tracking reference has the following characteristics.  \n  \n-   Assignment of an object to a tracking reference causes the object’s reference count to be incremented.  \n  \n-   A native reference (&) is the result when you dereference a *. A tracking reference (%) is the result when you dereference a ^. As long as you have a % to an object, the object will stay alive in memory.  \n  \n-   The dot (`.`) member-access operator is used to access a member of the object.  \n  \n-   Tracking references are valid for value types and handles (for example `String^`).  \n  \n-   A tracking reference cannot be assigned a null or `nullptr` value. A tracking reference may be reassigned to another valid object as many times as required.  \n  \n-   A tracking reference cannot be used as a unary take-address operator.  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n A tracking reference behaves like a standard C++ reference, except that a % is reference-counted. The following snippet shows how to convert between % and ^ types:  \n  \n```  \nFoo^ spFoo = ref new Foo();  \nFoo% srFoo = *spFoo;  \nFoo^ spFoo2 = %srFoo;  \n```  \n  \n The following example shows how to pass a ^ to a function that takes a %.  \n  \n```  \n  \nref class Foo sealed {};  \n  \n    // internal or private  \n    void UseFooHelper(Foo% f)  \n    {  \n        auto x = %f;  \n    }  \n  \n    // public method on ABI boundary  \n    void UseFoo(Foo^ f)  \n    {  \n        if (f != nullptr) { UseFooHelper(*f); }  \n    }  \n```  \n  \n## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  \n In C++/CLI, you can use a tracking reference to a handle when you bind to an object of a CLR type on the garbage-collected heap.  \n  \n In the CLR, the value of a tracking reference variable is updated automatically whenever the garbage collector moves the referenced object.  \n  \n A tracking reference can be declared only on the stack. A tracking reference cannot be a member of a class.  \n  \n It is not possible to have a native C++ reference to an object on the garbage-collected heap.  \n  \n For more information about tracking references in C++/CLI, see:  \n  \n-   [How to: Use Tracking References in C++/CLI](../dotnet/how-to-use-tracking-references-in-cpp-cli.md)\n  \n### Examples  \n **Example**  \n  \n The following sample for C++/CLI shows how to use a tracking reference with native and managed types.  \n  \n```  \n// tracking_reference_1.cpp  \n// compile with: /clr  \nref class MyClass {  \npublic:  \n   int i;  \n};  \n  \nvalue struct MyStruct {  \n   int k;  \n};  \n  \nint main() {  \n   MyClass ^ x = ref new MyClass;  \n   MyClass ^% y = x;   // tracking reference handle to reference object   \n  \n   int %ti = x->i;   // tracking reference to member of reference type  \n  \n   int j = 0;  \n   int %tj = j;   // tracking reference to object on the stack  \n  \n   int * pi = new int[2];  \n   int % ti2 = pi[0];   // tracking reference to object on native heap  \n  \n   int *% tpi = pi;   // tracking reference to native pointer  \n  \n   MyStruct ^ x2 = ref new MyStruct;  \n   MyStruct ^% y2 = x2;   // tracking reference to value object  \n  \n   MyStruct z;  \n   int %tk = z.k;   // tracking reference to member of value type  \n  \n   delete[] pi;  \n}  \n  \n```  \n  \n **Example**  \n  \n The following sample for C++/CLI shows how to bind a tracking reference to an array.  \n  \n```  \n// tracking_reference_2.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nint main() {  \n   array<int> ^ a = ref new array< Int32 >(5);  \n   a[0] = 21;  \n   Console::WriteLine(a[0]);  \n   array<int> ^% arr = a;  \n   arr[0] = 222;  \n   Console::WriteLine(a[0]);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n21  \n222  \n```"}