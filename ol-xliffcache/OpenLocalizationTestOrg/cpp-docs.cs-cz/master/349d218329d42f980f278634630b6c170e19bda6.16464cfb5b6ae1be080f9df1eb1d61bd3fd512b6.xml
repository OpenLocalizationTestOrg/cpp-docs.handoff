{"nodes":[{"pos":[12,71],"content":"How to: Define and Use Delegates (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Define and Use Delegates (C++-CLI) | Microsoft Docs","pos":[0,59]}]},{"content":"How to: Define and Use Delegates (C++/CLI)","pos":[590,632]},{"pos":[633,752],"content":"This article shows how to define and consume delegates in <ph id=\"ph1\">[!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]</ph>.","source":"This article shows how to define and consume delegates in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]."},{"content":"Although the .NET Framework provides a number of delegates, sometimes you might have to define new delegates.","pos":[759,868]},{"content":"The following code example defines a delegate that's named <ph id=\"ph1\">`MyCallback`</ph>.","pos":[875,947],"source":"The following code example defines a delegate that's named `MyCallback`."},{"content":"The event-handling code—the function that's called when this new delegate is fired—must have a return type of <ph id=\"ph1\">`void`</ph> and take a &lt;xref:System.String&gt; reference.","pos":[948,1107],"source":" The event-handling code—the function that's called when this new delegate is fired—must have a return type of `void` and take a <xref:System.String> reference."},{"content":"The main function uses a static method that's defined by <ph id=\"ph1\">`SomeClass`</ph> to instantiate the <ph id=\"ph2\">`MyCallback`</ph> delegate.","pos":[1114,1224],"source":"The main function uses a static method that's defined by `SomeClass` to instantiate the `MyCallback` delegate."},{"content":"The delegate then becomes an alternate method of calling this function, as demonstrated by sending the string \"single\" to the delegate object.","pos":[1225,1367]},{"content":"Next, additional instances of <ph id=\"ph1\">`MyCallback`</ph> are linked together and then executed by one call to the delegate object.","pos":[1368,1484],"source":" Next, additional instances of `MyCallback` are linked together and then executed by one call to the delegate object."},{"content":"Output","pos":[2473,2479]},{"content":"The next code sample shows how to associate a delegate with a member of a value class.","pos":[2696,2782]},{"content":"Output","pos":[3203,3209]},{"content":"How to compose delegates","pos":[3255,3279]},{"pos":[3283,3370],"content":"You can use the \"<ph id=\"ph1\">`-`</ph>\" operator to remove a component delegate from a composed delegate.","source":"You can use the \"`-`\" operator to remove a component delegate from a composed delegate."},{"content":"Output","pos":[4198,4204]},{"content":"Pass a delegate^ to a native function that expects a function pointer","pos":[4400,4469]},{"content":"From a managed component you can call a native function with function pointer parameters where the native function then can call the member function of the managed component's delegate.","pos":[4473,4658]},{"content":"This sample creates the .dll that exports the native function:","pos":[4665,4727]},{"content":"The next sample consumes the .dll and passes a delegate handle to the native function that expects a function pointer.","pos":[5002,5120]},{"content":"Output","pos":[5690,5696]},{"content":"To associate delegates with unmanaged functions","pos":[5755,5802]},{"pos":[5806,5963],"content":"To associate a delegate with a native function, you must wrap the native function in a managed type and declare the function to be invoked through <ph id=\"ph1\">`PInvoke`</ph>.","source":"To associate a delegate with a native function, you must wrap the native function in a managed type and declare the function to be invoked through `PInvoke`."},{"content":"Output","pos":[6520,6526]},{"content":"To use unbound delegates","pos":[6566,6590]},{"content":"You can use an unbound delegate to pass an instance of the type whose function you want to call when the delegate is called.","pos":[6594,6718]},{"pos":[6725,6927],"content":"Unbound delegates are especially useful if you want to iterate through the objects in a collection—by using <bpt id=\"p1\">[</bpt>for each, in<ept id=\"p1\">](../dotnet/for-each-in.md)</ept> keywords—and call a member function on each instance.","source":"Unbound delegates are especially useful if you want to iterate through the objects in a collection—by using [for each, in](../dotnet/for-each-in.md) keywords—and call a member function on each instance."},{"content":"Here's how to declare, instantiate, and call bound and unbound delegates:","pos":[6934,7007]},{"content":"Action","pos":[7014,7020]},{"content":"Bound Delegates","pos":[7021,7036]},{"content":"Unbound Delegates","pos":[7037,7054]},{"content":"Declare","pos":[7122,7129]},{"content":"The delegate signature must match the signature of the function you want to call through the delegate.","pos":[7130,7232]},{"content":"The first parameter of the delegate signature is the type of <ph id=\"ph1\">`this`</ph> for the object you want to call.","pos":[7233,7333],"source":"The first parameter of the delegate signature is the type of `this` for the object you want to call."},{"content":"After the first parameter, the delegate signature must match the signature of the function you want to call through the delegate.","pos":[7346,7475]},{"content":"Instantiate","pos":[7480,7491]},{"content":"When you instantiate a bound delegate, you can specify an instance function, or a global or static member function.","pos":[7492,7607]},{"content":"To specify an instance function, the first parameter is an instance of the type whose member function you want to call and the second parameter is the address of the function you want to call.","pos":[7620,7812]},{"content":"If you want to call a global or static member function, just pass the name of a global function or the name of the static member function.","pos":[7825,7963]},{"content":"When you instantiate an unbound delegate, just pass the address of the function you want to call.","pos":[7964,8061]},{"content":"Call","pos":[8066,8070]},{"content":"When you call a bound delegate, just pass the parameters that are required by the delegate signature.","pos":[8071,8172]},{"content":"Same as a bound delegate, but remember that the first parameter must be an instance of the object that contains the function you want to call.","pos":[8173,8315]},{"content":"This sample demonstrates how to declare, instantiate, and call unbound delegates:","pos":[8323,8404]},{"content":"Output","pos":[9950,9956]},{"pos":[10026,10222],"content":"The next sample shows how to use unbound delegates and the <bpt id=\"p1\">[</bpt>for each, in<ept id=\"p1\">](../dotnet/for-each-in.md)</ept> keywords to iterate through objects in a collection and call a member function on each instance.","source":"The next sample shows how to use unbound delegates and the [for each, in](../dotnet/for-each-in.md) keywords to iterate through objects in a collection and call a member function on each instance."},{"content":"This sample creates an unbound delegate to a property's accessor functions:","pos":[10851,10926]},{"content":"Output","pos":[11441,11447]},{"content":"The following sample shows how to invoke a multicast delegate, where one instance is bound and one instance is unbound.","pos":[11482,11601]},{"content":"Output","pos":[12100,12106]},{"content":"The next sample shows how to create and call an unbound generic delegate.","pos":[12159,12232]},{"content":"Output","pos":[12857,12863]},{"content":"See Also","pos":[12905,12913]},{"content":"delegate  (C++ Component Extensions)","pos":[12918,12954]}],"content":"---\ntitle: \"How to: Define and Use Delegates (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"delegates\"\nms.assetid: 1cdf3420-89c1-47c0-b796-aa984020e0f8\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Define and Use Delegates (C++/CLI)\nThis article shows how to define and consume delegates in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)].  \n  \n Although the .NET Framework provides a number of delegates, sometimes you might have to define new delegates.  \n  \n The following code example defines a delegate that's named `MyCallback`. The event-handling code—the function that's called when this new delegate is fired—must have a return type of `void` and take a <xref:System.String> reference.  \n  \n The main function uses a static method that's defined by `SomeClass` to instantiate the `MyCallback` delegate. The delegate then becomes an alternate method of calling this function, as demonstrated by sending the string \"single\" to the delegate object. Next, additional instances of `MyCallback` are linked together and then executed by one call to the delegate object.  \n  \n```  \n  \n      // use_delegate.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref class SomeClass  \n{  \npublic:  \n   static void Func(String^ str)  \n   {  \n      Console::WriteLine(\"static SomeClass::Func - {0}\", str);  \n   }  \n};  \n  \nref class OtherClass  \n{  \npublic:  \n   OtherClass( Int32 n )   \n   {  \n      num = n;  \n   }  \n  \n   void Method(String^ str)   \n   {  \n      Console::WriteLine(\"OtherClass::Method - {0}, num = {1}\",   \n         str, num);  \n   }  \n  \n   Int32 num;  \n};  \n  \ndelegate void MyCallback(String^ str);  \n  \nint main( )   \n{  \n   MyCallback^ callback = gcnew MyCallback(SomeClass::Func);     \n   callback(\"single\");   \n  \n   callback += gcnew MyCallback(SomeClass::Func);     \n  \n   OtherClass^ f = gcnew OtherClass(99);  \n   callback += gcnew MyCallback(f, &OtherClass::Method);  \n  \n   f = gcnew OtherClass(100);  \n   callback += gcnew MyCallback(f, &OtherClass::Method);  \n  \n   callback(\"chained\");  \n  \n   return 0;  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nstatic SomeClass::Func - single  \nstatic SomeClass::Func - chained  \nstatic SomeClass::Func - chained  \nOtherClass::Method - chained, num = 99  \nOtherClass::Method - chained, num = 100  \n```  \n  \n The next code sample shows how to associate a delegate with a member of a value class.  \n  \n```  \n// mcppv2_del_mem_value_class.cpp  \n// compile with: /clr  \nusing namespace System;  \npublic delegate void MyDel();  \n  \nvalue class A {  \npublic:  \n   void func1() {  \n      Console::WriteLine(\"test\");  \n   }  \n};  \n  \nint main() {  \n   A a;  \n   A^ ah = a;  \n   MyDel^ f = gcnew MyDel(a, &A::func1);   // implicit box of a  \n   f();  \n   MyDel^ f2 = gcnew MyDel(ah, &A::func1);  \n   f2();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \ntest  \ntest  \n```  \n  \n## How to compose delegates  \n You can use the \"`-`\" operator to remove a component delegate from a composed delegate.  \n  \n```  \n// mcppv2_compose_delegates.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \ndelegate void MyDelegate(String ^ s);  \n  \nref class MyClass {  \npublic:  \n   static void Hello(String ^ s) {  \n      Console::WriteLine(\"Hello, {0}!\", s);  \n   }  \n  \n   static void Goodbye(String ^ s) {  \n      Console::WriteLine(\"  Goodbye, {0}!\", s);  \n   }  \n};  \n  \nint main() {  \n  \n   MyDelegate ^ a = gcnew MyDelegate(MyClass::Hello);  \n   MyDelegate ^ b = gcnew MyDelegate(MyClass::Goodbye);  \n   MyDelegate ^ c = a + b;  \n   MyDelegate ^ d = c - a;  \n  \n   Console::WriteLine(\"Invoking delegate a:\");  \n   a(\"A\");  \n   Console::WriteLine(\"Invoking delegate b:\");  \n   b(\"B\");  \n   Console::WriteLine(\"Invoking delegate c:\");  \n   c(\"C\");  \n   Console::WriteLine(\"Invoking delegate d:\");  \n   d(\"D\");  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nInvoking delegate a:  \nHello, A!  \nInvoking delegate b:  \n  Goodbye, B!  \nInvoking delegate c:  \nHello, C!  \n  Goodbye, C!  \nInvoking delegate d:  \n  Goodbye, D!  \n```  \n  \n## Pass a delegate^ to a native function that expects a function pointer  \n From a managed component you can call a native function with function pointer parameters where the native function then can call the member function of the managed component's delegate.  \n  \n This sample creates the .dll that exports the native function:  \n  \n```  \n// delegate_to_native_function.cpp  \n// compile with: /LD  \n#include < windows.h >  \nextern \"C\" {  \n   __declspec(dllexport)  \n   void nativeFunction(void (CALLBACK *mgdFunc)(const char* str)) {  \n      mgdFunc(\"Call to Managed Function\");  \n   }  \n}  \n```  \n  \n The next sample consumes the .dll and passes a delegate handle to the native function that expects a function pointer.  \n  \n```  \n// delegate_to_native_function_2.cpp  \n// compile with: /clr  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \ndelegate void Del(String ^s);  \npublic ref class A {  \npublic:  \n   void delMember(String ^s) {  \n      Console::WriteLine(s);  \n   }  \n};  \n  \n[DllImportAttribute(\"delegate_to_native_function\", CharSet=CharSet::Ansi)]  \nextern \"C\" void nativeFunction(Del ^d);  \n  \nint main() {  \n   A ^a = gcnew A;  \n   Del ^d = gcnew Del(a, &A::delMember);  \n   nativeFunction(d);   // Call to native function  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nCall to Managed Function  \n```  \n  \n## To associate delegates with unmanaged functions  \n To associate a delegate with a native function, you must wrap the native function in a managed type and declare the function to be invoked through `PInvoke`.  \n  \n```  \n// mcppv2_del_to_umnangd_func.cpp  \n// compile with: /clr  \n#pragma unmanaged  \nextern \"C\" void printf(const char*, ...);  \nclass A {  \npublic:  \n   static void func(char* s) {  \n      printf(s);  \n   }  \n};  \n  \n#pragma managed  \npublic delegate void func(char*);   \n  \nref class B {  \n   A* ap;  \n  \npublic:  \n   B(A* ap):ap(ap) {}  \n   void func(char* s) {  \n      ap->func(s);   \n   }  \n};  \n  \nint main() {  \n   A* a = new A;  \n   B^ b = gcnew B(a);  \n   func^ f = gcnew func(b, &B::func);  \n   f(\"hello\");  \n   delete a;  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nhello  \n```  \n  \n## To use unbound delegates  \n You can use an unbound delegate to pass an instance of the type whose function you want to call when the delegate is called.  \n  \n Unbound delegates are especially useful if you want to iterate through the objects in a collection—by using [for each, in](../dotnet/for-each-in.md) keywords—and call a member function on each instance.  \n  \n Here's how to declare, instantiate, and call bound and unbound delegates:  \n  \n|Action|Bound Delegates|Unbound Delegates|  \n|------------|---------------------|-----------------------|  \n|Declare|The delegate signature must match the signature of the function you want to call through the delegate.|The first parameter of the delegate signature is the type of `this` for the object you want to call.<br /><br /> After the first parameter, the delegate signature must match the signature of the function you want to call through the delegate.|  \n|Instantiate|When you instantiate a bound delegate, you can specify an instance function, or a global or static member function.<br /><br /> To specify an instance function, the first parameter is an instance of the type whose member function you want to call and the second parameter is the address of the function you want to call.<br /><br /> If you want to call a global or static member function, just pass the name of a global function or the name of the static member function.|When you instantiate an unbound delegate, just pass the address of the function you want to call.|  \n|Call|When you call a bound delegate, just pass the parameters that are required by the delegate signature.|Same as a bound delegate, but remember that the first parameter must be an instance of the object that contains the function you want to call.|  \n  \n This sample demonstrates how to declare, instantiate, and call unbound delegates:  \n  \n```  \n// unbound_delegates.cpp  \n// compile with: /clr  \nref struct A {  \n   A(){}  \n   A(int i) : m_i(i) {}  \n   void Print(int i) { System::Console::WriteLine(m_i + i);}  \n  \nprivate:  \n   int m_i;  \n};  \n  \nvalue struct V {  \n   void Print() { System::Console::WriteLine(m_i);}  \n   int m_i;  \n};  \n  \ndelegate void Delegate1(A^, int i);  \ndelegate void Delegate2(A%, int i);  \n  \ndelegate void Delegate3(interior_ptr<V>);  \ndelegate void Delegate4(V%);  \n  \ndelegate void Delegate5(int i);  \ndelegate void Delegate6();  \n  \nint main() {  \n   A^ a1 = gcnew A(1);  \n   A% a2 = *gcnew A(2);  \n  \n   Delegate1 ^ Unbound_Delegate1 = gcnew Delegate1(&A::Print);  \n   // delegate takes a handle  \n   Unbound_Delegate1(a1, 1);  \n   Unbound_Delegate1(%a2, 1);  \n  \n   Delegate2 ^ Unbound_Delegate2 = gcnew Delegate2(&A::Print);  \n   // delegate takes a tracking reference (must deference the handle)  \n   Unbound_Delegate2(*a1, 1);  \n   Unbound_Delegate2(a2, 1);  \n  \n   // instantiate a bound delegate to an instance member function  \n   Delegate5 ^ Bound_Del = gcnew Delegate5(a1, &A::Print);  \n   Bound_Del(1);  \n  \n   // instantiate value types  \n   V v1 = {7};  \n   V v2 = {8};  \n  \n   Delegate3 ^ Unbound_Delegate3 = gcnew Delegate3(&V::Print);  \n   Unbound_Delegate3(&v1);  \n   Unbound_Delegate3(&v2);  \n  \n   Delegate4 ^ Unbound_Delegate4 = gcnew Delegate4(&V::Print);  \n   Unbound_Delegate4(v1);  \n   Unbound_Delegate4(v2);  \n  \n   Delegate6 ^ Bound_Delegate3 = gcnew Delegate6(v1, &V::Print);  \n   Bound_Delegate3();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n2  \n3  \n2  \n3  \n2  \n7  \n8  \n7  \n8  \n7  \n```  \n  \n The next sample shows how to use unbound delegates and the [for each, in](../dotnet/for-each-in.md) keywords to iterate through objects in a collection and call a member function on each instance.  \n  \n```  \n// unbound_delegates_2.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref class RefClass {  \n   String^ _Str;  \n  \npublic:  \n   RefClass( String^ str ) : _Str( str ) {}  \n   void Print() { Console::Write( _Str ); }  \n};  \n  \ndelegate void PrintDelegate( RefClass^ );  \n  \nint main() {  \n   PrintDelegate^ d = gcnew PrintDelegate( &RefClass::Print );  \n  \n   array< RefClass^ >^ a = gcnew array<RefClass^>( 10 );  \n  \n   for ( int i = 0; i < a->Length; ++i )  \n      a[i] = gcnew RefClass( i.ToString() );  \n  \n   for each ( RefClass^ R in a )  \n      d( R );  \n  \n   Console::WriteLine();  \n}  \n```  \n  \n This sample creates an unbound delegate to a property's accessor functions:  \n  \n```  \n// unbound_delegates_3.cpp  \n// compile with: /clr  \nref struct B {  \n   property int P1 {  \n      int get() { return m_i; }  \n      void set(int i) { m_i = i; }  \n   }  \n  \nprivate:  \n   int m_i;  \n};  \n  \ndelegate void DelBSet(B^, int);  \ndelegate int DelBGet(B^);  \n  \nint main() {  \n   B^ b = gcnew B;  \n  \n   DelBSet^ delBSet = gcnew DelBSet(&B::P1::set);  \n   delBSet(b, 11);  \n  \n   DelBGet^ delBGet = gcnew DelBGet(&B::P1::get);     \n   System::Console::WriteLine(delBGet(b));  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n11  \n```  \n  \n The following sample shows how to invoke a multicast delegate, where one instance is bound and one instance is unbound.  \n  \n```  \n// unbound_delegates_4.cpp  \n// compile with: /clr  \nref class R {  \npublic:  \n   R(int i) : m_i(i) {}  \n  \n   void f(R ^ r) {  \n      System::Console::WriteLine(\"in f(R ^ r)\");  \n   }  \n  \n   void f() {  \n      System::Console::WriteLine(\"in f()\");  \n   }  \n  \nprivate:  \n   int m_i;  \n};  \n  \ndelegate void Del(R ^);  \n  \nint main() {  \n   R ^r1 = gcnew R(11);  \n   R ^r2 = gcnew R(12);  \n  \n   Del^ d = gcnew Del(r1, &R::f);  \n   d += gcnew Del(&R::f);  \n   d(r2);  \n};  \n```  \n  \n **Output**  \n  \n```Output  \nin f(R ^ r)  \nin f()  \n```  \n  \n The next sample shows how to create and call an unbound generic delegate.  \n  \n```  \n// unbound_delegates_5.cpp  \n// compile with: /clr  \nref struct R {  \n   R(int i) : m_i(i) {}  \n  \n   int f(R ^) { return 999; }  \n   int f() { return m_i + 5; }  \n  \n   int m_i;  \n};  \n  \nvalue struct V {  \n   int f(V%) { return 999; }  \n   int f() { return m_i + 5; }   \n  \n   int m_i;  \n};  \n  \ngeneric <typename T>  \ndelegate int Del(T t);  \n  \ngeneric <typename T>  \ndelegate int DelV(T% t);  \n  \nint main() {     \n   R^ hr = gcnew R(7);  \n   System::Console::WriteLine((gcnew Del<R^>(&R::f))(hr));  \n  \n   V v;  \n   v.m_i = 9;  \n   System::Console::WriteLine((gcnew DelV<V >(&V::f))(v) );  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n12  \n14  \n```  \n  \n## See Also  \n [delegate  (C++ Component Extensions)](../windows/delegate-cpp-component-extensions.md)"}