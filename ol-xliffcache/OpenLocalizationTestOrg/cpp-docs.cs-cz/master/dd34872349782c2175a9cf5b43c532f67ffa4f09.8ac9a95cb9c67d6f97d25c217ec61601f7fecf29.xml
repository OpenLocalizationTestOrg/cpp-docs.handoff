{"nodes":[{"pos":[12,81],"content":"Importing Function Calls Using __declspec(dllimport) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Importing Function Calls Using __declspec(dllimport) | Microsoft Docs","pos":[0,69]}]},{"content":"Importing Function Calls Using __declspec(dllimport)","pos":[802,854]},{"content":"The following code example shows how to use <bpt id=\"p1\">**</bpt>_declspec(dllimport)<ept id=\"p1\">**</ept> to import function calls from a DLL into an application.","pos":[855,980],"source":"The following code example shows how to use **_declspec(dllimport)** to import function calls from a DLL into an application."},{"content":"Assume that <ph id=\"ph1\">`func1`</ph> is a function that resides in a DLL separate from the .exe file that contains the <bpt id=\"p1\">**</bpt>main<ept id=\"p1\">**</ept> function.","pos":[981,1101],"source":" Assume that `func1` is a function that resides in a DLL separate from the .exe file that contains the **main** function."},{"pos":[1108,1159],"content":"Without <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept>, given this code:","source":"Without **__declspec(dllimport)**, given this code:"},{"content":"the compiler generates code that looks like this:","pos":[1221,1270]},{"content":"and the linker translates the call into something like this:","pos":[1305,1365]},{"content":"If <ph id=\"ph1\">`func1`</ph> exists in another DLL, the linker cannot resolve this directly because it has no way of knowing what the address of <ph id=\"ph2\">`func1`</ph> is.","pos":[1438,1576],"source":"If `func1` exists in another DLL, the linker cannot resolve this directly because it has no way of knowing what the address of `func1` is."},{"content":"In 16-bit environments, the linker adds this code address to a list in the .exe file that the loader would patch at run time with the correct address.","pos":[1577,1727]},{"content":"In 32-bit and 64-bit environments, the linker generates a thunk of which it does know the address.","pos":[1728,1826]},{"content":"In a 32-bit environment the thunk looks like:","pos":[1827,1872]},{"content":"Here <ph id=\"ph1\">`imp_func1`</ph> is the address for the <ph id=\"ph2\">`func1`</ph> slot in the import address table of the .exe file.","pos":[1937,2035],"source":"Here `imp_func1` is the address for the `func1` slot in the import address table of the .exe file."},{"content":"All the addresses are thus known to the linker.","pos":[2036,2083]},{"content":"The loader only has to update the .exe file's import address table at load time for everything to work correctly.","pos":[2084,2197]},{"content":"Therefore, using <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> is better because the linker does not generate a thunk if it is not required.","pos":[2204,2324],"source":"Therefore, using **__declspec(dllimport)** is better because the linker does not generate a thunk if it is not required."},{"content":"Thunks make the code larger (on RISC systems, it can be several instructions) and can degrade your cache performance.","pos":[2325,2442]},{"content":"If you tell the compiler the function is in a DLL, it can generate an indirect call for you.","pos":[2443,2535]},{"content":"So now this code:","pos":[2542,2559]},{"content":"generates this instruction:","pos":[2663,2690]},{"pos":[2741,2819],"content":"There is no thunk and no <ph id=\"ph1\">`jmp`</ph> instruction, so the code is smaller and faster.","source":"There is no thunk and no `jmp` instruction, so the code is smaller and faster."},{"content":"On the other hand, for function calls inside a DLL, you do not want to have to use an indirect call.","pos":[2826,2926]},{"content":"You already know a function's address.","pos":[2927,2965]},{"content":"Because time and space are required to load and store the address of the function before an indirect call, a direct call is always faster and smaller.","pos":[2966,3116]},{"content":"You only want to use <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> when calling DLL functions from outside the DLL itself.","pos":[3117,3219],"source":" You only want to use **__declspec(dllimport)** when calling DLL functions from outside the DLL itself."},{"content":"Do not use <bpt id=\"p1\">**</bpt>__declspec(dllimport)<ept id=\"p1\">**</ept> on functions inside a DLL when building that DLL.","pos":[3220,3306],"source":" Do not use **__declspec(dllimport)** on functions inside a DLL when building that DLL."},{"content":"See Also","pos":[3315,3323]},{"content":"Importing into an Application","pos":[3328,3357]}],"content":"---\ntitle: \"Importing Function Calls Using __declspec(dllimport) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"__declspec\"\n  - \"dllimport\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"importing function calls [C++]\"\n  - \"dllimport attribute [C++], function call imports\"\n  - \"__declspec(dllimport) keyword [C++]\"\n  - \"function calls [C++], importing\"\nms.assetid: 6b53c616-0c6d-419a-8e2a-d2fff20510b3\ncaps.latest.revision: 8\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Importing Function Calls Using __declspec(dllimport)\nThe following code example shows how to use **_declspec(dllimport)** to import function calls from a DLL into an application. Assume that `func1` is a function that resides in a DLL separate from the .exe file that contains the **main** function.  \n  \n Without **__declspec(dllimport)**, given this code:  \n  \n```  \nint main(void)   \n{  \n   func1();  \n}  \n```  \n  \n the compiler generates code that looks like this:  \n  \n```  \ncall func1  \n```  \n  \n and the linker translates the call into something like this:  \n  \n```  \ncall 0x4000000         ; The address of 'func1'.  \n```  \n  \n If `func1` exists in another DLL, the linker cannot resolve this directly because it has no way of knowing what the address of `func1` is. In 16-bit environments, the linker adds this code address to a list in the .exe file that the loader would patch at run time with the correct address. In 32-bit and 64-bit environments, the linker generates a thunk of which it does know the address. In a 32-bit environment the thunk looks like:  \n  \n```  \n0x40000000:    jmp DWORD PTR __imp_func1  \n```  \n  \n Here `imp_func1` is the address for the `func1` slot in the import address table of the .exe file. All the addresses are thus known to the linker. The loader only has to update the .exe file's import address table at load time for everything to work correctly.  \n  \n Therefore, using **__declspec(dllimport)** is better because the linker does not generate a thunk if it is not required. Thunks make the code larger (on RISC systems, it can be several instructions) and can degrade your cache performance. If you tell the compiler the function is in a DLL, it can generate an indirect call for you.  \n  \n So now this code:  \n  \n```  \n__declspec(dllimport) void func1(void);  \nint main(void)   \n{  \n   func1();  \n}  \n```  \n  \n generates this instruction:  \n  \n```  \ncall DWORD PTR __imp_func1  \n```  \n  \n There is no thunk and no `jmp` instruction, so the code is smaller and faster.  \n  \n On the other hand, for function calls inside a DLL, you do not want to have to use an indirect call. You already know a function's address. Because time and space are required to load and store the address of the function before an indirect call, a direct call is always faster and smaller. You only want to use **__declspec(dllimport)** when calling DLL functions from outside the DLL itself. Do not use **__declspec(dllimport)** on functions inside a DLL when building that DLL.  \n  \n## See Also  \n [Importing into an Application](../build/importing-into-an-application.md)"}