{"nodes":[{"pos":[12,47],"content":"Message Maps (ATL) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Message Maps (ATL) | Microsoft Docs","pos":[0,35]}]},{"content":"Message Maps (ATL)","pos":[602,620]},{"content":"A message map associates a handler function with a particular message, command, or notification.","pos":[621,717]},{"content":"By using ATL's <bpt id=\"p1\">[</bpt>message map macros<ept id=\"p1\">](../atl/reference/message-map-macros-atl.md)</ept>, you can specify a message map for a window.","pos":[718,842],"source":" By using ATL's [message map macros](../atl/reference/message-map-macros-atl.md), you can specify a message map for a window."},{"content":"The window procedures in <ph id=\"ph1\">`CWindowImpl`</ph>, <ph id=\"ph2\">`CDialogImpl`</ph>, and <ph id=\"ph3\">`CContainedWindowT`</ph> direct a window's messages to its message map.","pos":[843,968],"source":" The window procedures in `CWindowImpl`, `CDialogImpl`, and `CContainedWindowT` direct a window's messages to its message map."},{"content":"The <bpt id=\"p1\">[</bpt>message handler functions<ept id=\"p1\">](../atl/message-handler-functions.md)</ept> accept an additional argument of type <ph id=\"ph1\">`BOOL&amp;`</ph>.","pos":[975,1090],"source":"The [message handler functions](../atl/message-handler-functions.md) accept an additional argument of type `BOOL&`."},{"content":"This argument indicates whether a message has been processed, and it is set to <ph id=\"ph1\">`TRUE`</ph> by default.","pos":[1091,1188],"source":" This argument indicates whether a message has been processed, and it is set to `TRUE` by default."},{"content":"A handler function can then set the argument to <ph id=\"ph1\">`FALSE`</ph> to indicate that it has not handled a message.","pos":[1189,1291],"source":" A handler function can then set the argument to `FALSE` to indicate that it has not handled a message."},{"content":"In this case, ATL will continue to look for a handler function further in the message map.","pos":[1292,1382]},{"content":"By setting this argument to <ph id=\"ph1\">`FALSE`</ph>, you can first perform some action in response to a message and then allow the default processing or another handler function to finish handling the message.","pos":[1383,1576],"source":" By setting this argument to `FALSE`, you can first perform some action in response to a message and then allow the default processing or another handler function to finish handling the message."},{"content":"Chained Message Maps","pos":[1585,1605]},{"content":"ATL also allows you to chain message maps, which directs the message handling to a message map defined in another class.","pos":[1609,1729]},{"content":"For example, you can implement common message handling in a separate class to provide uniform behavior for all windows chaining to that class.","pos":[1730,1872]},{"content":"You can chain to a base class or to a data member of your class.","pos":[1873,1937]},{"content":"ATL also supports dynamic chaining, which allows you to chain to another object's message map at run time.","pos":[1944,2050]},{"content":"To implement dynamic chaining, you must derive your class from <bpt id=\"p1\">[</bpt>CDynamicChain<ept id=\"p1\">](../atl/reference/cdynamicchain-class.md)</ept>.","pos":[2051,2171],"source":" To implement dynamic chaining, you must derive your class from [CDynamicChain](../atl/reference/cdynamicchain-class.md)."},{"content":"Then declare the <bpt id=\"p1\">[</bpt>CHAIN_MSG_MAP_DYNAMIC<ept id=\"p1\">](http://msdn.microsoft.com/library/7e5c72b7-cb31-4f3b-8a1b-6293804af220)</ept> macro in your message map.","pos":[2172,2311],"source":" Then declare the [CHAIN_MSG_MAP_DYNAMIC](http://msdn.microsoft.com/library/7e5c72b7-cb31-4f3b-8a1b-6293804af220) macro in your message map."},{"content":"requires a unique number that identifies the object and the message map to which you are chaining.","pos":[2336,2434]},{"content":"You must define this unique value through a call to <ph id=\"ph1\">`CDynamicChain::SetChainEntry`</ph>.","pos":[2435,2518],"source":" You must define this unique value through a call to `CDynamicChain::SetChainEntry`."},{"content":"You can chain to any class that declares a message map, provided the class derives from <bpt id=\"p1\">[</bpt>CMessageMap<ept id=\"p1\">](../atl/reference/cmessagemap-class.md)</ept>.","pos":[2525,2666],"source":"You can chain to any class that declares a message map, provided the class derives from [CMessageMap](../atl/reference/cmessagemap-class.md)."},{"content":"allows an object to expose its message maps to other objects.","pos":[2681,2742]},{"content":"Note that <ph id=\"ph1\">`CWindowImpl`</ph> already derives from <ph id=\"ph2\">`CMessageMap`</ph>.","pos":[2743,2802],"source":" Note that `CWindowImpl` already derives from `CMessageMap`."},{"content":"Alternate Message Maps","pos":[2811,2833]},{"content":"Finally, ATL supports alternate message maps, declared with the <bpt id=\"p1\">[</bpt>ALT_MSG_MAP<ept id=\"p1\">](http://msdn.microsoft.com/library/2c8871bf-abc0-4d52-bcf7-6b2ab9eb5af8)</ept> macro.","pos":[2837,2993],"source":"Finally, ATL supports alternate message maps, declared with the [ALT_MSG_MAP](http://msdn.microsoft.com/library/2c8871bf-abc0-4d52-bcf7-6b2ab9eb5af8) macro."},{"content":"Each alternate message map is identified by a unique number, which you pass to <ph id=\"ph1\">`ALT_MSG_MAP`</ph>.","pos":[2994,3087],"source":" Each alternate message map is identified by a unique number, which you pass to `ALT_MSG_MAP`."},{"content":"Using alternate message maps, you can handle the messages of multiple windows in one map.","pos":[3088,3177]},{"content":"Note that by default, <ph id=\"ph1\">`CWindowImpl`</ph> does not use alternate message maps.","pos":[3178,3250],"source":" Note that by default, `CWindowImpl` does not use alternate message maps."},{"content":"To add this support, override the <ph id=\"ph1\">`WindowProc`</ph> method in your <ph id=\"ph2\">`CWindowImpl`</ph>-derived class and call <ph id=\"ph3\">`ProcessWindowMessage`</ph> with the message map identifier.","pos":[3251,3405],"source":" To add this support, override the `WindowProc` method in your `CWindowImpl`-derived class and call `ProcessWindowMessage` with the message map identifier."},{"content":"See Also","pos":[3414,3422]},{"content":"Implementing a Window","pos":[3427,3448]}],"content":"---\ntitle: \"Message Maps (ATL) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"message maps, ATL\"\n  - \"ATL, message handlers\"\nms.assetid: 9e100400-65c7-4a85-8857-4e6cb6dd7340\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Message Maps (ATL)\nA message map associates a handler function with a particular message, command, or notification. By using ATL's [message map macros](../atl/reference/message-map-macros-atl.md), you can specify a message map for a window. The window procedures in `CWindowImpl`, `CDialogImpl`, and `CContainedWindowT` direct a window's messages to its message map.  \n  \n The [message handler functions](../atl/message-handler-functions.md) accept an additional argument of type `BOOL&`. This argument indicates whether a message has been processed, and it is set to `TRUE` by default. A handler function can then set the argument to `FALSE` to indicate that it has not handled a message. In this case, ATL will continue to look for a handler function further in the message map. By setting this argument to `FALSE`, you can first perform some action in response to a message and then allow the default processing or another handler function to finish handling the message.  \n  \n## Chained Message Maps  \n ATL also allows you to chain message maps, which directs the message handling to a message map defined in another class. For example, you can implement common message handling in a separate class to provide uniform behavior for all windows chaining to that class. You can chain to a base class or to a data member of your class.  \n  \n ATL also supports dynamic chaining, which allows you to chain to another object's message map at run time. To implement dynamic chaining, you must derive your class from [CDynamicChain](../atl/reference/cdynamicchain-class.md). Then declare the [CHAIN_MSG_MAP_DYNAMIC](http://msdn.microsoft.com/library/7e5c72b7-cb31-4f3b-8a1b-6293804af220) macro in your message map. `CHAIN_MSG_MAP_DYNAMIC` requires a unique number that identifies the object and the message map to which you are chaining. You must define this unique value through a call to `CDynamicChain::SetChainEntry`.  \n  \n You can chain to any class that declares a message map, provided the class derives from [CMessageMap](../atl/reference/cmessagemap-class.md). `CMessageMap` allows an object to expose its message maps to other objects. Note that `CWindowImpl` already derives from `CMessageMap`.  \n  \n## Alternate Message Maps  \n Finally, ATL supports alternate message maps, declared with the [ALT_MSG_MAP](http://msdn.microsoft.com/library/2c8871bf-abc0-4d52-bcf7-6b2ab9eb5af8) macro. Each alternate message map is identified by a unique number, which you pass to `ALT_MSG_MAP`. Using alternate message maps, you can handle the messages of multiple windows in one map. Note that by default, `CWindowImpl` does not use alternate message maps. To add this support, override the `WindowProc` method in your `CWindowImpl`-derived class and call `ProcessWindowMessage` with the message map identifier.  \n  \n## See Also  \n [Implementing a Window](../atl/implementing-a-window.md)\n\n"}