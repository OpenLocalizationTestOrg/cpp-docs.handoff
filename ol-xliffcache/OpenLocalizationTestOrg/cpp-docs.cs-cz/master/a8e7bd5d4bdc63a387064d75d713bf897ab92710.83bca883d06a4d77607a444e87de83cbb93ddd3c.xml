{"nodes":[{"pos":[12,56],"content":"Writing an Exception Filter | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Writing an Exception Filter | Microsoft Docs","pos":[0,44]}]},{"content":"Writing an Exception Filter","pos":[603,630]},{"content":"You can handle an exception either by jumping to the level of the exception handler or by continuing execution.","pos":[631,742]},{"content":"Instead of using the exception handler code to handle the exception and falling through, you can use <bpt id=\"p1\">*</bpt>filter<ept id=\"p1\">*</ept> to clean up the problem and then, by returning –1, resume normal flow without clearing the stack.","pos":[743,950],"source":" Instead of using the exception handler code to handle the exception and falling through, you can use *filter* to clean up the problem and then, by returning –1, resume normal flow without clearing the stack."},{"pos":[958,1234],"content":"[!NOTE]\n Some exceptions cannot be continued. If *filter* evaluates to –1 for such an exception, the system raises a new exception. When you call [RaiseException](http://msdn.microsoft.com/library/windows/desktop/ms680552), you determine whether the exception will continue.","leadings":["","> "],"nodes":[{"content":" Some exceptions cannot be continued. If *filter* evaluates to –1 for such an exception, the system raises a new exception. When you call [RaiseException](http://msdn.microsoft.com/library/windows/desktop/ms680552), you determine whether the exception will continue.","pos":[8,274],"nodes":[{"content":"Some exceptions cannot be continued.","pos":[1,37]},{"content":"If <bpt id=\"p1\">*</bpt>filter<ept id=\"p1\">*</ept> evaluates to –1 for such an exception, the system raises a new exception.","pos":[38,123],"source":" If *filter* evaluates to –1 for such an exception, the system raises a new exception."},{"content":"When you call <bpt id=\"p1\">[</bpt>RaiseException<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680552)</ept>, you determine whether the exception will continue.","pos":[124,266],"source":" When you call [RaiseException](http://msdn.microsoft.com/library/windows/desktop/ms680552), you determine whether the exception will continue."}]}]},{"pos":[1241,1409],"content":"For example, the following code uses a function call in the <bpt id=\"p1\">*</bpt>filter<ept id=\"p1\">*</ept> expression: this function handles the problem and then returns –1 to resume normal flow of control:","source":"For example, the following code uses a function call in the *filter* expression: this function handles the problem and then returns –1 to resume normal flow of control:"},{"content":"It is a good idea to use a function call in the <bpt id=\"p1\">*</bpt>filter<ept id=\"p1\">*</ept> expression whenever <bpt id=\"p2\">*</bpt>filter<ept id=\"p2\">*</ept> needs to do anything complex.","pos":[2021,2136],"source":"It is a good idea to use a function call in the *filter* expression whenever *filter* needs to do anything complex."},{"content":"Evaluating the expression causes execution of the function, in this case, <ph id=\"ph1\">`Eval_Exception`</ph>.","pos":[2137,2228],"source":" Evaluating the expression causes execution of the function, in this case, `Eval_Exception`."},{"content":"Note the use of <bpt id=\"p1\">[</bpt>GetExceptionCode<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms679356)</ept> to determine the exception.","pos":[2235,2357],"source":"Note the use of [GetExceptionCode](http://msdn.microsoft.com/library/windows/desktop/ms679356) to determine the exception."},{"content":"You must call this function inside the filter itself.","pos":[2358,2411]},{"content":"cannot call <bpt id=\"p1\">**</bpt>GetExceptionCode<ept id=\"p1\">**</ept>, but it must have the exception code passed to it.","pos":[2429,2512],"source":" cannot call **GetExceptionCode**, but it must have the exception code passed to it."},{"content":"This handler passes control to another handler unless the exception is an integer or floating-point overflow.","pos":[2519,2628]},{"content":"If it is, the handler calls a function (<ph id=\"ph1\">`ResetVars`</ph> is only an example, not an API function) to reset some global variables.","pos":[2629,2753],"source":" If it is, the handler calls a function (`ResetVars` is only an example, not an API function) to reset some global variables."},{"content":"<bpt id=\"p1\">*</bpt>Statement-block-2<ept id=\"p1\">*</ept>, which in this example is empty, can never be executed because <ph id=\"ph1\">`Eval_Exception`</ph> never returns EXCEPTION_EXECUTE_HANDLER (1).","pos":[2754,2898],"source":"*Statement-block-2*, which in this example is empty, can never be executed because `Eval_Exception` never returns EXCEPTION_EXECUTE_HANDLER (1)."},{"content":"Using a function call is a good general-purpose technique for dealing with complex filter expressions.","pos":[2905,3007]},{"content":"Two other C language features that are useful are:","pos":[3008,3058]},{"content":"The conditional operator","pos":[3068,3092]},{"content":"The comma operator","pos":[3102,3120]},{"content":"The conditional operator is frequently useful, because it can be used to check for a specific return code and then return one of two different values.","pos":[3127,3277]},{"content":"For example, the filter in the following code recognizes the exception only if the exception is <ph id=\"ph1\">`STATUS_INTEGER_OVERFLOW`</ph>:","pos":[3278,3400],"source":" For example, the filter in the following code recognizes the exception only if the exception is `STATUS_INTEGER_OVERFLOW`:"},{"content":"The purpose of the conditional operator in this case is mainly to provide clarity, because the following code produces the same results:","pos":[3492,3628]},{"content":"The conditional operator is more useful in situations where you might want the filter to evaluate to –1, EXCEPTION_CONTINUE_EXECUTION.","pos":[3712,3846]},{"content":"The comma operator enables you to perform multiple, independent operations inside a single expression.","pos":[3853,3955]},{"content":"The effect is roughly that of executing multiple statements and then returning the value of the last expression.","pos":[3956,4068]},{"content":"For example, the following code stores the exception code in a variable and then tests it:","pos":[4069,4159]},{"content":"See Also","pos":[4258,4266]},{"content":"Writing an Exception Handler","pos":[4271,4299]},{"content":"Structured Exception Handling (C/C++)","pos":[4346,4383]}],"content":"---\ntitle: \"Writing an Exception Filter | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"exception handling, filters\"\nms.assetid: 47fc832b-a707-4422-b60a-aaefe14189e5\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Writing an Exception Filter\nYou can handle an exception either by jumping to the level of the exception handler or by continuing execution. Instead of using the exception handler code to handle the exception and falling through, you can use *filter* to clean up the problem and then, by returning –1, resume normal flow without clearing the stack.  \n  \n> [!NOTE]\n>  Some exceptions cannot be continued. If *filter* evaluates to –1 for such an exception, the system raises a new exception. When you call [RaiseException](http://msdn.microsoft.com/library/windows/desktop/ms680552), you determine whether the exception will continue.  \n  \n For example, the following code uses a function call in the *filter* expression: this function handles the problem and then returns –1 to resume normal flow of control:  \n  \n```  \n// exceptions_Writing_an_Exception_Filter.cpp  \n#include <windows.h>  \nint main() {  \n   int Eval_Exception( int );  \n  \n   __try {}  \n  \n   __except ( Eval_Exception( GetExceptionCode( ))) {  \n      ;  \n   }  \n  \n}  \nvoid ResetVars( int ) {}  \nint Eval_Exception ( int n_except ) {  \n   if ( n_except != STATUS_INTEGER_OVERFLOW &&   \n      n_except != STATUS_FLOAT_OVERFLOW )   // Pass on most exceptions  \n   return EXCEPTION_CONTINUE_SEARCH;  \n  \n   // Execute some code to clean up problem  \n   ResetVars( 0 );   // initializes data to 0  \n   return EXCEPTION_CONTINUE_EXECUTION;  \n}  \n```  \n  \n It is a good idea to use a function call in the *filter* expression whenever *filter* needs to do anything complex. Evaluating the expression causes execution of the function, in this case, `Eval_Exception`.  \n  \n Note the use of [GetExceptionCode](http://msdn.microsoft.com/library/windows/desktop/ms679356) to determine the exception. You must call this function inside the filter itself. `Eval_Exception` cannot call **GetExceptionCode**, but it must have the exception code passed to it.  \n  \n This handler passes control to another handler unless the exception is an integer or floating-point overflow. If it is, the handler calls a function (`ResetVars` is only an example, not an API function) to reset some global variables. *Statement-block-2*, which in this example is empty, can never be executed because `Eval_Exception` never returns EXCEPTION_EXECUTE_HANDLER (1).  \n  \n Using a function call is a good general-purpose technique for dealing with complex filter expressions. Two other C language features that are useful are:  \n  \n-   The conditional operator  \n  \n-   The comma operator  \n  \n The conditional operator is frequently useful, because it can be used to check for a specific return code and then return one of two different values. For example, the filter in the following code recognizes the exception only if the exception is `STATUS_INTEGER_OVERFLOW`:  \n  \n```  \n__except( GetExceptionCode() == STATUS_INTEGER_OVERFLOW ? 1 : 0 ) {  \n```  \n  \n The purpose of the conditional operator in this case is mainly to provide clarity, because the following code produces the same results:  \n  \n```  \n__except( GetExceptionCode() == STATUS_INTEGER_OVERFLOW ) {  \n```  \n  \n The conditional operator is more useful in situations where you might want the filter to evaluate to –1, EXCEPTION_CONTINUE_EXECUTION.  \n  \n The comma operator enables you to perform multiple, independent operations inside a single expression. The effect is roughly that of executing multiple statements and then returning the value of the last expression. For example, the following code stores the exception code in a variable and then tests it:  \n  \n```  \n__except( nCode = GetExceptionCode(), nCode == STATUS_INTEGER_OVERFLOW )  \n```  \n  \n## See Also  \n [Writing an Exception Handler](../cpp/writing-an-exception-handler.md)   \n [Structured Exception Handling (C/C++)](../cpp/structured-exception-handling-c-cpp.md)"}