{"nodes":[{"pos":[12,39],"content":"list Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"list Class | Microsoft Docs","pos":[0,27]}]},{"content":"list Class","pos":[636,646]},{"content":"The STL list class is a template class of sequence containers that maintain their elements in a linear arrangement and allow efficient insertions and deletions at any location within the sequence.","pos":[647,843]},{"content":"The sequence is stored as a bidirectional linked list of elements, each containing a member of some type <bpt id=\"p1\">*</bpt>Type<ept id=\"p1\">*</ept>.","pos":[844,956],"source":" The sequence is stored as a bidirectional linked list of elements, each containing a member of some type *Type*."},{"content":"Syntax","pos":[965,971]},{"content":"Parameters","pos":[1071,1081]},{"content":"Type","pos":[1086,1090]},{"content":"The element data type to be stored in the list.","pos":[1095,1142]},{"content":"The type that represents the stored allocator object that encapsulates details about the list's allocation and deallocation of memory.","pos":[1164,1298]},{"content":"This argument is optional, and the default value is <bpt id=\"p1\">**</bpt>allocator<ept id=\"p1\">**</ept><ph id=\"ph1\">\\&lt;</ph> <bpt id=\"p2\">*</bpt>Type<ept id=\"p2\">*</ept><ph id=\"ph2\">&gt; </ph><bpt id=\"p3\">*</bpt>.<ept id=\"p3\">*</ept>","pos":[1299,1378],"source":" This argument is optional, and the default value is **allocator**\\< *Type*> *.*"},{"content":"Remarks","pos":[1387,1394]},{"content":"The choice of container type should be based in general on the type of searching and inserting required by the application.","pos":[1398,1521]},{"content":"Vectors should be the preferred container for managing a sequence when random access to any element is at a premium and insertions or deletions of elements are only required at the end of a sequence.","pos":[1522,1721]},{"content":"The performance of the class deque container is superior when random access is needed and insertions and deletions at both the beginning and the end of a sequence are at a premium.","pos":[1722,1902]},{"pos":[1909,2190],"content":"The list member functions <bpt id=\"p1\">[</bpt>merge<ept id=\"p1\">](#list__merge)</ept>, <bpt id=\"p2\">[</bpt>reverse<ept id=\"p2\">](#list__reverse)</ept>, <bpt id=\"p3\">[</bpt>unique<ept id=\"p3\">](#list__unique)</ept>, <bpt id=\"p4\">[</bpt>remove<ept id=\"p4\">](#list__remove)</ept>, and <bpt id=\"p5\">[</bpt>remove_if<ept id=\"p5\">](#list__remove_if)</ept> have been optimized for operation on list objects and offer a high-performance alternative to their generic counterparts.","source":"The list member functions [merge](#list__merge), [reverse](#list__reverse), [unique](#list__unique), [remove](#list__remove), and [remove_if](#list__remove_if) have been optimized for operation on list objects and offer a high-performance alternative to their generic counterparts."},{"content":"List reallocation occurs when a member function must insert or erase elements of the list.","pos":[2197,2287]},{"content":"In all such cases, only iterators or references that point at erased portions of the controlled sequence become invalid.","pos":[2288,2408]},{"pos":[2415,2573],"content":"Include the STL standard header <ph id=\"ph1\">\\&lt;</ph>list&gt; to define the <bpt id=\"p1\">[</bpt>container<ept id=\"p1\">](../standard-library/stl-containers.md)</ept> template class list and several supporting templates.","source":"Include the STL standard header \\<list> to define the [container](../standard-library/stl-containers.md) template class list and several supporting templates."},{"content":"Constructors","pos":[2583,2595]},{"content":"list","pos":[2617,2621]},{"pos":[2636,2773],"content":"Constructs a list of a specific size or with elements of a specific value or with a specific <ph id=\"ph1\">`allocator`</ph> or as a copy of some other list.","source":"Constructs a list of a specific size or with elements of a specific value or with a specific `allocator` or as a copy of some other list."},{"content":"Typedefs","pos":[2784,2792]},{"content":"allocator_type","pos":[2814,2828]},{"pos":[2853,2916],"content":"A type that represents the <ph id=\"ph1\">`allocator`</ph> class for a list object.","source":"A type that represents the `allocator` class for a list object."},{"content":"const_iterator","pos":[2922,2936]},{"pos":[2961,3049],"content":"A type that provides a bidirectional iterator that can read a <ph id=\"ph1\">`const`</ph> element in a list.","source":"A type that provides a bidirectional iterator that can read a `const` element in a list."},{"content":"const_pointer","pos":[3055,3068]},{"pos":[3092,3154],"content":"A type that provides a pointer to a <ph id=\"ph1\">`const`</ph> element in a list.","source":"A type that provides a pointer to a `const` element in a list."},{"content":"const_reference","pos":[3160,3175]},{"pos":[3201,3318],"content":"A type that provides a reference to a <ph id=\"ph1\">`const`</ph> element stored in a list for reading and performing <ph id=\"ph2\">`const`</ph> operations.","source":"A type that provides a reference to a `const` element stored in a list for reading and performing `const` operations."},{"content":"const_reverse_iterator","pos":[3324,3346]},{"pos":[3379,3469],"content":"A type that provides a bidirectional iterator that can read any <ph id=\"ph1\">`const`</ph> element in a list.","source":"A type that provides a bidirectional iterator that can read any `const` element in a list."},{"content":"difference_type","pos":[3475,3490]},{"content":"A type that provides the difference between two iterators that refer to elements within the same list.","pos":[3516,3618]},{"content":"iterator","pos":[3624,3632]},{"content":"A type that provides a bidirectional iterator that can read or modify any element in a list.","pos":[3651,3743]},{"content":"pointer","pos":[3749,3756]},{"content":"A type that provides a pointer to an element in a list.","pos":[3774,3829]},{"content":"reference","pos":[3835,3844]},{"pos":[3864,3981],"content":"A type that provides a reference to a <ph id=\"ph1\">`const`</ph> element stored in a list for reading and performing <ph id=\"ph2\">`const`</ph> operations.","source":"A type that provides a reference to a `const` element stored in a list for reading and performing `const` operations."},{"content":"reverse_iterator","pos":[3987,4003]},{"content":"A type that provides a bidirectional iterator that can read or modify an element in a reversed list.","pos":[4030,4130]},{"content":"size_type","pos":[4136,4145]},{"content":"A type that counts the number of elements in a list.","pos":[4165,4217]},{"content":"value_type","pos":[4223,4233]},{"content":"A type that represents the data type stored in a list.","pos":[4254,4308]},{"content":"Member Functions","pos":[4319,4335]},{"content":"assign","pos":[4357,4363]},{"content":"Erases elements from a list and copies a new set of elements to the target list.","pos":[4380,4460]},{"content":"back","pos":[4466,4470]},{"content":"Returns a reference to the last element of a list.","pos":[4485,4535]},{"content":"begin","pos":[4541,4546]},{"content":"Returns an iterator addressing the first element in a list.","pos":[4562,4621]},{"content":"list::cbegin","pos":[4627,4639]},{"content":"Returns a const iterator addressing the first element in a list.","pos":[4656,4720]},{"content":"list::cend","pos":[4726,4736]},{"content":"Returns a const iterator that addresses the location succeeding the last element in a list.","pos":[4751,4842]},{"content":"list::clear","pos":[4848,4859]},{"content":"Erases all the elements of a list.","pos":[4875,4909]},{"content":"list::crbegin","pos":[4915,4928]},{"content":"Returns a const iterator addressing the first element in a reversed list.","pos":[4946,5019]},{"content":"list::crend","pos":[5025,5036]},{"content":"Returns a const iterator that addresses the location succeeding the last element in a reversed list.","pos":[5052,5152]},{"content":"list::emplace","pos":[5158,5171]},{"content":"Inserts an element constructed in place into a list at a specified position.","pos":[5189,5265]},{"content":"list::emplace_back","pos":[5271,5289]},{"content":"Adds an element constructed in place to the end of a list.","pos":[5312,5370]},{"content":"list::emplace_front","pos":[5376,5395]},{"content":"Adds an element constructed in place to the beginning of a list.","pos":[5419,5483]},{"content":"empty","pos":[5489,5494]},{"content":"Tests if a list is empty.","pos":[5510,5535]},{"content":"end","pos":[5541,5544]},{"content":"Returns an iterator that addresses the location succeeding the last element in a list.","pos":[5558,5644]},{"content":"erase","pos":[5650,5655]},{"content":"Removes an element or a range of elements in a list from specified positions.","pos":[5671,5748]},{"content":"front","pos":[5754,5759]},{"content":"Returns a reference to the first element in a list.","pos":[5775,5826]},{"content":"get_allocator","pos":[5832,5845]},{"pos":[5869,5935],"content":"Returns a copy of the <ph id=\"ph1\">`allocator`</ph> object used to construct a list.","source":"Returns a copy of the `allocator` object used to construct a list."},{"content":"insert","pos":[5941,5947]},{"content":"Inserts an element or a number of elements or a range of elements into a list at a specified position.","pos":[5964,6066]},{"content":"max_size","pos":[6072,6080]},{"content":"Returns the maximum length of a list.","pos":[6099,6136]},{"content":"merge","pos":[6142,6147]},{"content":"Removes the elements from the argument list, inserts them into the target list, and orders the new, combined set of elements in ascending order or in some other specified order.","pos":[6163,6340]},{"content":"pop_back","pos":[6346,6354]},{"content":"Deletes the element at the end of a list.","pos":[6373,6414]},{"content":"pop_front","pos":[6420,6429]},{"content":"Deletes the element at the beginning of a list.","pos":[6449,6496]},{"content":"push_back","pos":[6502,6511]},{"content":"Adds an element to the end of a list.","pos":[6531,6568]},{"content":"push_front","pos":[6574,6584]},{"content":"Adds an element to the beginning of a list.","pos":[6605,6648]},{"content":"rbegin","pos":[6654,6660]},{"content":"Returns an iterator addressing the first element in a reversed list.","pos":[6677,6745]},{"content":"remove","pos":[6751,6757]},{"content":"Erases elements in a list that match a specified value.","pos":[6774,6829]},{"content":"remove_if","pos":[6835,6844]},{"content":"Erases elements from the list for which a specified predicate is satisfied.","pos":[6864,6939]},{"content":"rend","pos":[6945,6949]},{"content":"Returns an iterator that addresses the location succeeding the last element in a reversed list.","pos":[6964,7059]},{"content":"resize","pos":[7065,7071]},{"content":"Specifies a new size for a list.","pos":[7088,7120]},{"content":"reverse","pos":[7126,7133]},{"content":"Reverses the order in which the elements occur in a list.","pos":[7151,7208]},{"content":"size","pos":[7214,7218]},{"content":"Returns the number of elements in a list.","pos":[7233,7274]},{"content":"sort","pos":[7280,7284]},{"content":"Arranges the elements of a list in ascending order or with respect to some other order relation.","pos":[7299,7395]},{"content":"splice","pos":[7401,7407]},{"content":"Removes elements from the argument list and inserts them into the target list.","pos":[7424,7502]},{"content":"swap","pos":[7508,7512]},{"content":"Exchanges the elements of two lists.","pos":[7527,7563]},{"content":"unique","pos":[7569,7575]},{"content":"Removes adjacent duplicate elements or adjacent elements that satisfy some other binary predicate from the list.","pos":[7592,7704]},{"content":"Operators","pos":[7715,7724]},{"content":"list::operator=","pos":[7746,7761]},{"content":"Replaces the elements of the list with a copy of another list.","pos":[7783,7845]},{"content":"Requirements","pos":[7855,7867]},{"pos":[7871,7890],"content":"<bpt id=\"p1\">**</bpt>Header<ept id=\"p1\">**</ept>: <ph id=\"ph1\">\\&lt;</ph>list&gt;","source":"**Header**: \\<list>"},{"pos":[7937,7957],"content":"list::allocator_type"},{"content":"A type that represents the allocator class for a list object.","pos":[7961,8022]},{"content":"Remarks","pos":[8083,8090]},{"pos":[8111,8165],"content":"is a synonym for the template parameter <bpt id=\"p1\">**</bpt>Allocator.<ept id=\"p1\">**</ept>","source":" is a synonym for the template parameter **Allocator.**"},{"content":"Example","pos":[8175,8182]},{"pos":[8187,8245],"content":"See the example for <bpt id=\"p1\">[</bpt>get_allocator<ept id=\"p1\">](#list__get_allocator)</ept>.","source":"See the example for [get_allocator](#list__get_allocator)."},{"pos":[8284,8296],"content":"list::assign"},{"content":"Erases elements from a list and copies a new set of elements to a target list.","pos":[8300,8378]},{"content":"Parameters","pos":[8610,8620]},{"content":"Position of the first element in the range of elements to be copied from the argument list.","pos":[8635,8726]},{"content":"Position of the first element just beyond the range of elements to be copied from the argument list.","pos":[8743,8843]},{"content":"The number of copies of an element being inserted into the list.","pos":[8861,8925]},{"content":"The value of the element being inserted into the list.","pos":[8941,8995]},{"content":"The initializer_list that contains the elements to be inserted.","pos":[9013,9076]},{"content":"Remarks","pos":[9086,9093]},{"content":"After erasing any existing elements in the target list, assign either inserts a specified range of elements from the original list or from some other list into the target list or inserts copies of a new element of a specified value into the target list","pos":[9097,9349]},{"content":"Example","pos":[9359,9366]},{"pos":[10338,10348],"content":"list::back"},{"content":"Returns a reference to the last element of a list.","pos":[10352,10402]},{"content":"Return Value","pos":[10476,10488]},{"content":"The last element of the list.","pos":[10492,10521]},{"content":"If the list is empty, the return value is undefined.","pos":[10522,10574]},{"content":"Remarks","pos":[10584,10591]},{"content":"If the return value of <bpt id=\"p1\">**</bpt>back<ept id=\"p1\">**</ept> is assigned to a <ph id=\"ph1\">`const_reference`</ph>, the list object cannot be modified.","pos":[10595,10698],"source":"If the return value of **back** is assigned to a `const_reference`, the list object cannot be modified."},{"content":"If the return value of <bpt id=\"p1\">**</bpt>back<ept id=\"p1\">**</ept> is assigned to a <bpt id=\"p2\">**</bpt>reference<ept id=\"p2\">**</ept>, the list object can be modified.","pos":[10699,10795],"source":" If the return value of **back** is assigned to a **reference**, the list object can be modified."},{"content":"When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty list.","pos":[10802,10917]},{"content":"See <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept> for more information.","pos":[10919,11006],"source":"  See [Checked Iterators](../standard-library/checked-iterators.md) for more information."},{"content":"Example","pos":[11016,11023]},{"pos":[11576,11587],"content":"list::begin"},{"content":"Returns an iterator addressing the first element in a list.","pos":[11591,11650]},{"content":"Return Value","pos":[11724,11736]},{"content":"A bidirectional iterator addressing the first element in the list or to the location succeeding an empty list.","pos":[11740,11850]},{"content":"Remarks","pos":[11860,11867]},{"content":"If the return value of <bpt id=\"p1\">**</bpt>begin<ept id=\"p1\">**</ept> is assigned to a <ph id=\"ph1\">`const_iterator`</ph>, the elements in the list object cannot be modified.","pos":[11871,11990],"source":"If the return value of **begin** is assigned to a `const_iterator`, the elements in the list object cannot be modified."},{"content":"If the return value of <bpt id=\"p1\">**</bpt>begin<ept id=\"p1\">**</ept> is assigned to an <bpt id=\"p2\">**</bpt>iterator<ept id=\"p2\">**</ept>, the elements in the list object can be modified.","pos":[11991,12104],"source":" If the return value of **begin** is assigned to an **iterator**, the elements in the list object can be modified."},{"content":"Example","pos":[12114,12121]},{"pos":[12862,12874],"content":"list::cbegin"},{"pos":[12878,12951],"content":"Returns a <ph id=\"ph1\">`const`</ph> iterator that addresses the first element in the range.","source":"Returns a `const` iterator that addresses the first element in the range."},{"content":"Return Value","pos":[13007,13019]},{"pos":[13023,13207],"content":"A <ph id=\"ph1\">`const`</ph> bidirectional-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, <ph id=\"ph2\">`cbegin() == cend()`</ph>).","source":"A `const` bidirectional-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, `cbegin() == cend()`)."},{"content":"Remarks","pos":[13217,13224]},{"pos":[13228,13308],"content":"With the return value of <ph id=\"ph1\">`cbegin`</ph>, the elements in the range cannot be modified.","source":"With the return value of `cbegin`, the elements in the range cannot be modified."},{"content":"You can use this member function in place of the <ph id=\"ph1\">`begin()`</ph> member function to guarantee that the return value is <ph id=\"ph2\">`const_iterator`</ph>.","pos":[13315,13445],"source":"You can use this member function in place of the `begin()` member function to guarantee that the return value is `const_iterator`."},{"content":"Typically, it's used in conjunction with the <bpt id=\"p1\">[</bpt>auto<ept id=\"p1\">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.","pos":[13446,13576],"source":" Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example."},{"content":"In the example, consider <ph id=\"ph1\">`Container`</ph> to be a modifiable (non- <ph id=\"ph2\">`const`</ph>) container of any kind that supports <ph id=\"ph3\">`begin()`</ph> and <ph id=\"ph4\">`cbegin()`</ph>.","pos":[13577,13709],"source":" In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `begin()` and `cbegin()`."},{"pos":[13901,13911],"content":"list::cend"},{"pos":[13915,14010],"content":"Returns a <ph id=\"ph1\">`const`</ph> iterator that addresses the location just beyond the last element in a range.","source":"Returns a `const` iterator that addresses the location just beyond the last element in a range."},{"content":"Return Value","pos":[14064,14076]},{"pos":[14080,14165],"content":"A <ph id=\"ph1\">`const`</ph> bidirectional-access iterator that points just beyond the end of the range.","source":"A `const` bidirectional-access iterator that points just beyond the end of the range."},{"content":"Remarks","pos":[14175,14182]},{"pos":[14193,14261],"content":"is used to test whether an iterator has passed the end of its range."},{"content":"You can use this member function in place of the <ph id=\"ph1\">`end()`</ph> member function to guarantee that the return value is <ph id=\"ph2\">`const_iterator`</ph>.","pos":[14268,14396],"source":"You can use this member function in place of the `end()` member function to guarantee that the return value is `const_iterator`."},{"content":"Typically, it's used in conjunction with the <bpt id=\"p1\">[</bpt>auto<ept id=\"p1\">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.","pos":[14397,14527],"source":" Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example."},{"content":"In the example, consider <ph id=\"ph1\">`Container`</ph> to be a modifiable (non- <ph id=\"ph2\">`const`</ph>) container of any kind that supports <ph id=\"ph3\">`end()`</ph> and <ph id=\"ph4\">`cend()`</ph>.","pos":[14528,14656],"source":" In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `end()` and `cend()`."},{"pos":[14814,14870],"content":"The value returned by <ph id=\"ph1\">`cend`</ph> should not be dereferenced.","source":"The value returned by `cend` should not be dereferenced."},{"pos":[14908,14919],"content":"list::clear"},{"content":"Erases all the elements of a list.","pos":[14923,14957]},{"content":"Example","pos":[14996,15003]},{"pos":[15565,15585],"content":"list::const_iterator"},{"pos":[15589,15679],"content":"A type that provides a bidirectional iterator that can read a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> element in a list.","source":"A type that provides a bidirectional iterator that can read a **const** element in a list."},{"content":"Remarks","pos":[15753,15760]},{"pos":[15764,15837],"content":"A type <ph id=\"ph1\">`const_iterator`</ph> cannot be used to modify the value of an element.","source":"A type `const_iterator` cannot be used to modify the value of an element."},{"content":"Example","pos":[15847,15854]},{"pos":[15859,15899],"content":"See the example for <bpt id=\"p1\">[</bpt>back<ept id=\"p1\">](#list__back)</ept>.","source":"See the example for [back](#list__back)."},{"pos":[15945,15964],"content":"list::const_pointer"},{"pos":[15968,16018],"content":"Provides a pointer to a <ph id=\"ph1\">`const`</ph> element in a list.","source":"Provides a pointer to a `const` element in a list."},{"content":"Remarks","pos":[16101,16108]},{"pos":[16112,16184],"content":"A type <ph id=\"ph1\">`const_pointer`</ph> cannot be used to modify the value of an element.","source":"A type `const_pointer` cannot be used to modify the value of an element."},{"pos":[16191,16292],"content":"In most cases, an <bpt id=\"p1\">[</bpt>iterator<ept id=\"p1\">](#list__iterator)</ept> should be used to access the elements in a list object.","source":"In most cases, an [iterator](#list__iterator) should be used to access the elements in a list object."},{"pos":[16340,16361],"content":"list::const_reference"},{"pos":[16365,16486],"content":"A type that provides a reference to a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> element stored in a list for reading and performing <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> operations.","source":"A type that provides a reference to a **const** element stored in a list for reading and performing **const** operations."},{"content":"Remarks","pos":[16574,16581]},{"pos":[16585,16659],"content":"A type <ph id=\"ph1\">`const_reference`</ph> cannot be used to modify the value of an element.","source":"A type `const_reference` cannot be used to modify the value of an element."},{"content":"Example","pos":[16669,16676]},{"pos":[17338,17366],"content":"list::const_reverse_iterator"},{"pos":[17370,17462],"content":"A type that provides a bidirectional iterator that can read any <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> element in a list.","source":"A type that provides a bidirectional iterator that can read any **const** element in a list."},{"content":"Remarks","pos":[17559,17566]},{"pos":[17570,17691],"content":"A type <ph id=\"ph1\">`const_reverse_iterator`</ph> cannot modify the value of an element and is used to iterate through the list in reverse.","source":"A type `const_reverse_iterator` cannot modify the value of an element and is used to iterate through the list in reverse."},{"content":"Example","pos":[17701,17708]},{"pos":[17713,17757],"content":"See the example for <bpt id=\"p1\">[</bpt>rbegin<ept id=\"p1\">](#list__rbegin)</ept>.","source":"See the example for [rbegin](#list__rbegin)."},{"pos":[17797,17810],"content":"list::crbegin"},{"content":"Returns a const iterator addressing the first element in a reversed list.","pos":[17814,17887]},{"content":"Return Value","pos":[17951,17963]},{"pos":[17967,18126],"content":"A const reverse bidirectional iterator addressing the first element in a reversed list (or addressing what had been the last element in the unreversed <ph id=\"ph1\">`list`</ph>).","source":"A const reverse bidirectional iterator addressing the first element in a reversed list (or addressing what had been the last element in the unreversed `list`)."},{"content":"Remarks","pos":[18136,18143]},{"pos":[18157,18244],"content":"is used with a reversed list just as <bpt id=\"p1\">[</bpt>list::begin<ept id=\"p1\">](#list__begin)</ept> is used with a <ph id=\"ph1\">`list`</ph>.","source":" is used with a reversed list just as [list::begin](#list__begin) is used with a `list`."},{"content":"With the return value of <ph id=\"ph1\">`crbegin`</ph>, the list object cannot be modified.","pos":[18251,18322],"source":"With the return value of `crbegin`, the list object cannot be modified."},{"content":"<bpt id=\"p1\">[</bpt>list::rbegin<ept id=\"p1\">](#list__rbegin)</ept> can be used to iterate through a list backwards.","pos":[18323,18401],"source":"[list::rbegin](#list__rbegin) can be used to iterate through a list backwards."},{"content":"Example","pos":[18411,18418]},{"pos":[18931,18942],"content":"list::crend"},{"content":"Returns a const iterator that addresses the location succeeding the last element in a reversed list.","pos":[18946,19046]},{"content":"Return Value","pos":[19108,19120]},{"pos":[19124,19351],"content":"A const reverse bidirectional iterator that addresses the location succeeding the last element in a reversed <bpt id=\"p1\">[</bpt>list<ept id=\"p1\">](../standard-library/list-class.md)</ept> (the location that had preceded the first element in the unreversed <ph id=\"ph1\">`list`</ph>).","source":"A const reverse bidirectional iterator that addresses the location succeeding the last element in a reversed [list](../standard-library/list-class.md) (the location that had preceded the first element in the unreversed `list`)."},{"content":"Remarks","pos":[19361,19368]},{"pos":[19380,19463],"content":"is used with a reversed list just as <bpt id=\"p1\">[</bpt>list::end<ept id=\"p1\">](#list__end)</ept> is used with a <ph id=\"ph1\">`list`</ph>.","source":" is used with a reversed list just as [list::end](#list__end) is used with a `list`."},{"pos":[19470,19541],"content":"With the return value of <ph id=\"ph1\">`crend`</ph>, the <ph id=\"ph2\">`list`</ph> object cannot be modified.","source":"With the return value of `crend`, the `list` object cannot be modified."},{"pos":[19556,19640],"content":"can be used to test to whether a reverse iterator has reached the end of its <ph id=\"ph1\">`list`</ph>.","source":" can be used to test to whether a reverse iterator has reached the end of its `list`."},{"pos":[19647,19704],"content":"The value returned by <ph id=\"ph1\">`crend`</ph> should not be dereferenced.","source":"The value returned by `crend` should not be dereferenced."},{"content":"Example","pos":[19714,19721]},{"pos":[20383,20404],"content":"list::difference_type"},{"content":"A signed integer type that can be used to represent the number of elements of a list in a range between elements pointed to by iterators.","pos":[20408,20545]},{"content":"Remarks","pos":[20633,20640]},{"content":"The <ph id=\"ph1\">`difference_type`</ph> is the type returned when subtracting or incrementing through iterators of the container.","pos":[20644,20755],"source":"The `difference_type` is the type returned when subtracting or incrementing through iterators of the container."},{"content":"The <ph id=\"ph1\">`difference_type`</ph> is typically used to represent the number of elements in the range [ <ph id=\"ph2\">` first`</ph>, <ph id=\"ph3\">` last`</ph>) between the iterators <ph id=\"ph4\">` first`</ph> and <ph id=\"ph5\">` last`</ph>, includes the element pointed to by <ph id=\"ph6\">` first`</ph> and the range of elements up to, but not including, the element pointed to by <ph id=\"ph7\">` last`</ph>.","pos":[20756,21040],"source":" The `difference_type` is typically used to represent the number of elements in the range [ ` first`, ` last`) between the iterators ` first` and ` last`, includes the element pointed to by ` first` and the range of elements up to, but not including, the element pointed to by ` last`."},{"pos":[21047,21438],"content":"Note that although <ph id=\"ph1\">`difference_type`</ph> is available for all iterators that satisfy the requirements of an input iterator, which includes the class of bidirectional iterators supported by reversible containers like set, subtraction between iterators is only supported by random-access iterators provided by a random-access container, such as <bpt id=\"p1\">[</bpt>vector Class<ept id=\"p1\">](../standard-library/vector-class.md)</ept>.","source":"Note that although `difference_type` is available for all iterators that satisfy the requirements of an input iterator, which includes the class of bidirectional iterators supported by reversible containers like set, subtraction between iterators is only supported by random-access iterators provided by a random-access container, such as [vector Class](../standard-library/vector-class.md)."},{"content":"Example","pos":[21448,21455]},{"pos":[22560,22573],"content":"list::emplace"},{"content":"Inserts an element constructed in place into a list at a specified position.","pos":[22577,22653]},{"content":"Parameters","pos":[22725,22735]},{"content":"Parameter","pos":[22756,22765]},{"content":"Description","pos":[22766,22777]},{"pos":[22790,22895],"content":"The position in the target <bpt id=\"p1\">[</bpt>list<ept id=\"p1\">](../standard-library/list-class.md)</ept> where the first element is inserted.","source":"The position in the target [list](../standard-library/list-class.md) where the first element is inserted."},{"pos":[22907,22950],"content":"The element added to the end of the <ph id=\"ph1\">`list`</ph>.","source":"The element added to the end of the `list`."},{"content":"Remarks","pos":[22961,22968]},{"pos":[22972,23058],"content":"If an exception is thrown, the <ph id=\"ph1\">`list`</ph> is left unaltered and the exception is rethrown.","source":"If an exception is thrown, the `list` is left unaltered and the exception is rethrown."},{"content":"Example","pos":[23068,23075]},{"pos":[23494,23512],"content":"list::emplace_back"},{"content":"Adds an element constructed in place to the beginning of a list.","pos":[23516,23580]},{"content":"Parameters","pos":[23636,23646]},{"content":"Parameter","pos":[23667,23676]},{"content":"Description","pos":[23677,23688]},{"pos":[23700,23778],"content":"The element added to the end of the <bpt id=\"p1\">[</bpt>list<ept id=\"p1\">](../standard-library/list-class.md)</ept>.","source":"The element added to the end of the [list](../standard-library/list-class.md)."},{"content":"Remarks","pos":[23789,23796]},{"pos":[23800,23886],"content":"If an exception is thrown, the <ph id=\"ph1\">`list`</ph> is left unaltered and the exception is rethrown.","source":"If an exception is thrown, the `list` is left unaltered and the exception is rethrown."},{"content":"Example","pos":[23896,23903]},{"pos":[24322,24341],"content":"list::emplace_front"},{"content":"Adds an element constructed in place to the beginning of a list.","pos":[24345,24409]},{"content":"Parameters","pos":[24466,24476]},{"content":"Parameter","pos":[24497,24506]},{"content":"Description","pos":[24507,24518]},{"pos":[24530,24614],"content":"The element added to the beginning of the <bpt id=\"p1\">[</bpt>list<ept id=\"p1\">](../standard-library/list-class.md)</ept>.","source":"The element added to the beginning of the [list](../standard-library/list-class.md)."},{"content":"Remarks","pos":[24625,24632]},{"pos":[24636,24722],"content":"If an exception is thrown, the <ph id=\"ph1\">`list`</ph> is left unaltered and the exception is rethrown.","source":"If an exception is thrown, the `list` is left unaltered and the exception is rethrown."},{"content":"Example","pos":[24732,24739]},{"pos":[25153,25164],"content":"list::empty"},{"content":"Tests if a list is empty.","pos":[25168,25193]},{"content":"Return Value","pos":[25238,25250]},{"pos":[25254,25320],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the list is empty; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if the list is not empty.","source":"**true** if the list is empty; **false** if the list is not empty."},{"content":"Example","pos":[25330,25337]},{"pos":[25751,25760],"content":"list::end"},{"content":"Returns an iterator that addresses the location succeeding the last element in a list.","pos":[25764,25850]},{"content":"Return Value","pos":[25919,25931]},{"content":"A bidirectional iterator that addresses the location succeeding the last element in a list.","pos":[25935,26026]},{"content":"If the list is empty, then <ph id=\"ph1\">`list::end == list::begin`</ph>.","pos":[26027,26081],"source":" If the list is empty, then `list::end == list::begin`."},{"content":"Remarks","pos":[26091,26098]},{"pos":[26102,26178],"content":"<bpt id=\"p1\">**</bpt>end<ept id=\"p1\">**</ept> is used to test whether an iterator has reached the end of its list.","source":"**end** is used to test whether an iterator has reached the end of its list."},{"content":"Example","pos":[26188,26195]},{"pos":[27188,27199],"content":"list::erase"},{"content":"Removes an element or a range of elements in a list from specified positions.","pos":[27203,27280]},{"content":"Parameters","pos":[27384,27394]},{"content":"Position of the element to be removed from the list.","pos":[27409,27461]},{"content":"Position of the first element removed from the list.","pos":[27480,27532]},{"content":"Position just beyond the last element removed from the list.","pos":[27550,27610]},{"content":"Return Value","pos":[27620,27632]},{"content":"A bidirectional iterator that designates the first element remaining beyond any elements removed, or a pointer to the end of the list if no such element exists.","pos":[27636,27796]},{"content":"Remarks","pos":[27806,27813]},{"content":"No reallocation occurs, so iterators and references become invalid only for the erased elements.","pos":[27817,27913]},{"pos":[27920,27956],"content":"<bpt id=\"p1\">**</bpt>erase<ept id=\"p1\">**</ept> never throws an exception.","source":"**erase** never throws an exception."},{"content":"Example","pos":[27966,27973]},{"pos":[29145,29156],"content":"list::front"},{"content":"Returns a reference to the first element in a list.","pos":[29160,29211]},{"content":"Return Value","pos":[29286,29298]},{"content":"If the list is empty, the return is undefined.","pos":[29302,29348]},{"content":"Remarks","pos":[29358,29365]},{"content":"If the return value of <ph id=\"ph1\">`front`</ph> is assigned to a <ph id=\"ph2\">`const_reference`</ph>, the list object cannot be modified.","pos":[29369,29471],"source":"If the return value of `front` is assigned to a `const_reference`, the list object cannot be modified."},{"content":"If the return value of <ph id=\"ph1\">`front`</ph> is assigned to a <bpt id=\"p1\">**</bpt>reference<ept id=\"p1\">**</ept>, the list object can be modified.","pos":[29472,29567],"source":" If the return value of `front` is assigned to a **reference**, the list object can be modified."},{"content":"When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty list.","pos":[29574,29689]},{"content":"See <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept> for more information.","pos":[29691,29778],"source":"  See [Checked Iterators](../standard-library/checked-iterators.md) for more information."},{"content":"Example","pos":[29788,29795]},{"pos":[30315,30334],"content":"list::get_allocator"},{"content":"Returns a copy of the allocator object used to construct a list.","pos":[30338,30402]},{"content":"Return Value","pos":[30460,30472]},{"content":"The allocator used by the list.","pos":[30476,30507]},{"content":"Remarks","pos":[30517,30524]},{"content":"Allocators for the list class specify how the class manages storage.","pos":[30528,30596]},{"content":"The default allocators supplied with STL container classes are sufficient for most programming needs.","pos":[30597,30698]},{"content":"Writing and using your own allocator class is an advanced C++ topic.","pos":[30699,30767]},{"content":"Example","pos":[30777,30784]},{"pos":[31407,31419],"content":"list::insert"},{"content":"Inserts an element or a number of elements or a range of elements into a list at a specified position.","pos":[31423,31525]},{"content":"Parameters","pos":[31876,31886]},{"content":"Parameter","pos":[31907,31916]},{"content":"Description","pos":[31917,31928]},{"content":"The position in the target list where the first element is inserted.","pos":[31941,32009]},{"content":"The value of the element being inserted into the list.","pos":[32020,32074]},{"content":"The number of elements being inserted into the list.","pos":[32087,32139]},{"content":"The position of the first element in the range of elements in the argument list to be copied.","pos":[32152,32245]},{"content":"The position of the first element beyond the range of elements in the argument list to be copied.","pos":[32257,32354]},{"content":"Return Value","pos":[32365,32377]},{"content":"The first two insert functions return an iterator that points to the position where the new element was inserted into the list.","pos":[32381,32508]},{"content":"Example","pos":[32518,32525]},{"pos":[33978,33992],"content":"list::iterator"},{"content":"A type that provides a bidirectional iterator that can read or modify any element in a list.","pos":[33996,34088]},{"content":"Remarks","pos":[34156,34163]},{"pos":[34167,34233],"content":"A type <bpt id=\"p1\">**</bpt>iterator<ept id=\"p1\">**</ept> can be used to modify the value of an element.","source":"A type **iterator** can be used to modify the value of an element."},{"content":"Example","pos":[34243,34250]},{"pos":[34255,34297],"content":"See the example for <bpt id=\"p1\">[</bpt>begin<ept id=\"p1\">](#list__begin)</ept>.","source":"See the example for [begin](#list__begin)."},{"pos":[34334,34344],"content":"list::list"},{"content":"Constructs a list of a specific size or with elements of a specific value or with a specific allocator or as a copy of all or part of some other list.","pos":[34348,34498]},{"content":"Parameters","pos":[34986,34996]},{"content":"Parameter","pos":[35017,35026]},{"content":"Description","pos":[35027,35038]},{"content":"The allocator class to use with this object.","pos":[35048,35092]},{"content":"The number of elements in the list constructed.","pos":[35105,35152]},{"content":"The value of the elements in the list.","pos":[35163,35201]},{"content":"The list of which the constructed list is to be a copy.","pos":[35214,35269]},{"content":"The position of the first element in the range of elements to be copied.","pos":[35282,35354]},{"content":"The position of the first element beyond the range of elements to be copied.","pos":[35366,35442]},{"content":"The initializer_list that contains the elements to be copied.","pos":[35455,35516]},{"content":"Remarks","pos":[35527,35534]},{"pos":[35538,35613],"content":"All constructors store an allocator object ( <ph id=\"ph1\">`Al`</ph>) and initialize the list.","source":"All constructors store an allocator object ( `Al`) and initialize the list."},{"pos":[35620,35722],"content":"<bpt id=\"p1\">[</bpt>get_allocator<ept id=\"p1\">](#list__get_allocator)</ept> returns a copy of the allocator object used to construct a list.","source":"[get_allocator](#list__get_allocator) returns a copy of the allocator object used to construct a list."},{"pos":[35729,35847],"content":"The first two constructors specify an empty initial list, the second specifying the allocator type ( <ph id=\"ph1\">`Al`</ph>) to be used.","source":"The first two constructors specify an empty initial list, the second specifying the allocator type ( `Al`) to be used."},{"pos":[35854,35984],"content":"The third constructor specifies a repetition of a specified number ( <ph id=\"ph1\">`Count`</ph>) of elements of the default value for class <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>.","source":"The third constructor specifies a repetition of a specified number ( `Count`) of elements of the default value for class **Type**."},{"pos":[35991,36084],"content":"The fourth and fifth constructors specify a repetition of ( <ph id=\"ph1\">`Count`</ph>) elements of value <ph id=\"ph2\">`Val`</ph>.","source":"The fourth and fifth constructors specify a repetition of ( `Count`) elements of value `Val`."},{"pos":[36091,36150],"content":"The sixth constructor specifies a copy of the list <ph id=\"ph1\">`Right`</ph>.","source":"The sixth constructor specifies a copy of the list `Right`."},{"pos":[36157,36204],"content":"The seventh constructor moves the list <ph id=\"ph1\">`Right`</ph>.","source":"The seventh constructor moves the list `Right`."},{"content":"The eighth constructor uses an initializer_list to specify the elements.","pos":[36211,36283]},{"pos":[36290,36357],"content":"The next two constructors copy the range <ph id=\"ph1\">`[First, Last)`</ph> of a list.","source":"The next two constructors copy the range `[First, Last)` of a list."},{"content":"None of the constructors perform any interim reallocations.","pos":[36364,36423]},{"content":"Example","pos":[36433,36440]},{"pos":[38559,38573],"content":"list::max_size"},{"content":"Returns the maximum length of a list.","pos":[38577,38614]},{"content":"Return Value","pos":[38665,38677]},{"content":"The maximum possible length of the list.","pos":[38681,38721]},{"content":"Example","pos":[38731,38738]},{"pos":[39088,39099],"content":"list::merge"},{"content":"Removes the elements from the argument list, inserts them into the target list, and orders the new, combined set of elements in ascending order or in some other specified order.","pos":[39103,39280]},{"content":"Parameters","pos":[39429,39439]},{"content":"The argument list to be merged with the target list.","pos":[39455,39507]},{"content":"The comparison operator used to order the elements of the target list.","pos":[39525,39595]},{"content":"Remarks","pos":[39605,39612]},{"pos":[39616,39674],"content":"The argument list <ph id=\"ph1\">` right`</ph> is merged with the target list.","source":"The argument list ` right` is merged with the target list."},{"content":"Both argument and target lists must be ordered with the same comparison relation by which the resulting sequence is to be ordered.","pos":[39681,39811]},{"content":"The default order for the first member function is ascending order.","pos":[39812,39879]},{"content":"The second member function imposes the user-specified comparison operation <ph id=\"ph1\">` comp`</ph> of class <bpt id=\"p1\">**</bpt>Traits<ept id=\"p1\">**</ept>.","pos":[39880,39983],"source":" The second member function imposes the user-specified comparison operation ` comp` of class **Traits**."},{"content":"Example","pos":[39993,40000]},{"pos":[41601,41616],"content":"list::operator="},{"content":"Replaces the elements of the list with a copy of another list.","pos":[41620,41682]},{"content":"Parameters","pos":[41774,41784]},{"content":"Parameter","pos":[41805,41814]},{"content":"Description","pos":[41815,41826]},{"pos":[41840,41915],"content":"The <bpt id=\"p1\">[</bpt>list<ept id=\"p1\">](../standard-library/list-class.md)</ept> being copied into the <ph id=\"ph1\">`list`</ph>.","source":"The [list](../standard-library/list-class.md) being copied into the `list`."},{"content":"Remarks","pos":[41926,41933]},{"pos":[41937,42063],"content":"After erasing any existing elements in a <ph id=\"ph1\">`list`</ph>, the operator either copies or moves the contents of <ph id=\"ph2\">` right`</ph> into the <ph id=\"ph3\">`list`</ph>.","source":"After erasing any existing elements in a `list`, the operator either copies or moves the contents of ` right` into the `list`."},{"content":"Example","pos":[42073,42080]},{"pos":[42932,42945],"content":"list::pointer"},{"content":"Provides a pointer to an element in a list.","pos":[42949,42992]},{"content":"Remarks","pos":[43062,43069]},{"pos":[43073,43138],"content":"A type <bpt id=\"p1\">**</bpt>pointer<ept id=\"p1\">**</ept> can be used to modify the value of an element.","source":"A type **pointer** can be used to modify the value of an element."},{"pos":[43145,43246],"content":"In most cases, an <bpt id=\"p1\">[</bpt>iterator<ept id=\"p1\">](#list__iterator)</ept> should be used to access the elements in a list object.","source":"In most cases, an [iterator](#list__iterator) should be used to access the elements in a list object."},{"pos":[43287,43301],"content":"list::pop_back"},{"content":"Deletes the element at the end of a list.","pos":[43305,43346]},{"content":"Remarks","pos":[43387,43394]},{"content":"The last element must not be empty.","pos":[43398,43433]},{"content":"never throws an exception.","pos":[43445,43471]},{"content":"Example","pos":[43481,43488]},{"pos":[44180,44195],"content":"list::pop_front"},{"content":"Deletes the element at the beginning of a list.","pos":[44199,44246]},{"content":"Remarks","pos":[44288,44295]},{"content":"The first element must not be empty.","pos":[44299,44335]},{"content":"never throws an exception.","pos":[44348,44374]},{"content":"Example","pos":[44384,44391]},{"pos":[45102,45117],"content":"list::push_back"},{"content":"Adds an element to the end of a list.","pos":[45121,45158]},{"content":"Parameters","pos":[45226,45236]},{"content":"Parameter","pos":[45257,45266]},{"content":"Description","pos":[45267,45278]},{"content":"The element added to the end of the list.","pos":[45290,45331]},{"content":"Remarks","pos":[45342,45349]},{"content":"If an exception is thrown, the list is left unaltered and the exception is rethrown.","pos":[45353,45437]},{"content":"Example","pos":[45447,45454]},{"pos":[46192,46208],"content":"list::push_front"},{"content":"Adds an element to the beginning of a list.","pos":[46212,46255]},{"content":"Parameters","pos":[46343,46353]},{"content":"Parameter","pos":[46374,46383]},{"content":"Description","pos":[46384,46395]},{"content":"The element added to the beginning of the list.","pos":[46407,46454]},{"content":"Remarks","pos":[46465,46472]},{"content":"If an exception is thrown, the list is left unaltered and the exception is rethrown.","pos":[46476,46560]},{"content":"Example","pos":[46570,46577]},{"pos":[47322,47334],"content":"list::rbegin"},{"content":"Returns an iterator that addresses the first element in a reversed list.","pos":[47338,47410]},{"content":"Return Value","pos":[47500,47512]},{"content":"A reverse bidirectional iterator addressing the first element in a reversed list (or addressing what had been the last element in the unreversed list).","pos":[47516,47667]},{"content":"Remarks","pos":[47677,47684]},{"pos":[47697,47776],"content":"is used with a reversed list just as <bpt id=\"p1\">[</bpt>begin<ept id=\"p1\">](#list__begin)</ept> is used with a list.","source":" is used with a reversed list just as [begin](#list__begin) is used with a list."},{"content":"If the return value of <ph id=\"ph1\">`rbegin`</ph> is assigned to a <ph id=\"ph2\">`const_reverse_iterator`</ph>, the list object cannot be modified.","pos":[47783,47893],"source":"If the return value of `rbegin` is assigned to a `const_reverse_iterator`, the list object cannot be modified."},{"content":"If the return value of <ph id=\"ph1\">`rbegin`</ph> is assigned to a <ph id=\"ph2\">`reverse_iterator`</ph>, the list object can be modified.","pos":[47894,47995],"source":" If the return value of `rbegin` is assigned to a `reverse_iterator`, the list object can be modified."},{"pos":[48011,48059],"content":"can be used to iterate through a list backwards."},{"content":"Example","pos":[48069,48076]},{"pos":[49418,49433],"content":"list::reference"},{"content":"A type that provides a reference to an element stored in a list.","pos":[49437,49501]},{"content":"Example","pos":[49577,49584]},{"pos":[50082,50094],"content":"list::remove"},{"content":"Erases elements in a list that match a specified value.","pos":[50098,50153]},{"content":"Parameters","pos":[50207,50217]},{"content":"The value which, if held by an element, will result in that element's removal from the list.","pos":[50231,50323]},{"content":"Remarks","pos":[50333,50340]},{"content":"The order of the elements remaining is not affected.","pos":[50344,50396]},{"content":"Example","pos":[50406,50413]},{"pos":[51377,51392],"content":"list::remove_if"},{"content":"Erases elements from a list for which a specified predicate is satisfied.","pos":[51396,51469]},{"content":"Parameters","pos":[51555,51565]},{"content":"The unary predicate which, if satisfied by an element, results in the deletion of that element from the list.","pos":[51580,51689]},{"content":"Example","pos":[51699,51706]},{"pos":[52848,52858],"content":"list::rend"},{"content":"Returns an iterator that addresses the location that follows the last element in a reversed list.","pos":[52862,52959]},{"content":"Return Value","pos":[53045,53057]},{"content":"A reverse bidirectional iterator that addresses the location succeeding the last element in a reversed list (the location that had preceded the first element in the unreversed list).","pos":[53061,53243]},{"content":"Remarks","pos":[53253,53260]},{"pos":[53271,53346],"content":"is used with a reversed list just as <bpt id=\"p1\">[</bpt>end<ept id=\"p1\">](#list__end)</ept> is used with a list.","source":" is used with a reversed list just as [end](#list__end) is used with a list."},{"content":"If the return value of <ph id=\"ph1\">`rend`</ph> is assigned to a <ph id=\"ph2\">`const_reverse_iterator`</ph>, the list object cannot be modified.","pos":[53353,53461],"source":"If the return value of `rend` is assigned to a `const_reverse_iterator`, the list object cannot be modified."},{"content":"If the return value of <ph id=\"ph1\">`rend`</ph> is assigned to a <ph id=\"ph2\">`reverse_iterator`</ph>, the list object can be modified.","pos":[53462,53561],"source":" If the return value of `rend` is assigned to a `reverse_iterator`, the list object can be modified."},{"pos":[53575,53657],"content":"can be used to test to whether a reverse iterator has reached the end of its list."},{"pos":[53664,53720],"content":"The value returned by <ph id=\"ph1\">`rend`</ph> should not be dereferenced.","source":"The value returned by `rend` should not be dereferenced."},{"content":"Example","pos":[53730,53737]},{"pos":[55750,55762],"content":"list::resize"},{"content":"Specifies a new size for a list.","pos":[55766,55798]},{"content":"Parameters","pos":[55898,55908]},{"content":"The new size of the list.","pos":[55926,55951]},{"content":"The value of the new elements to be added to the list if the new size is larger that the original size.","pos":[55968,56071]},{"content":"If the value is omitted, the new elements are assigned the default value for the class.","pos":[56072,56159]},{"content":"Remarks","pos":[56169,56176]},{"pos":[56180,56311],"content":"If the list's size is less than the requested size, <ph id=\"ph1\">`_Newsize`</ph>, elements are added to the list until it reaches the requested size.","source":"If the list's size is less than the requested size, `_Newsize`, elements are added to the list until it reaches the requested size."},{"pos":[56318,56471],"content":"If the list's size is larger than the requested size, the elements closest to the end of the list are deleted until the list reaches the size <ph id=\"ph1\">`_Newsize`</ph>.","source":"If the list's size is larger than the requested size, the elements closest to the end of the list are deleted until the list reaches the size `_Newsize`."},{"content":"If the present size of the list is the same as the requested size, no action is taken.","pos":[56478,56564]},{"pos":[56571,56629],"content":"<bpt id=\"p1\">[</bpt>size<ept id=\"p1\">](#list__size)</ept> reflects the current size of the list.","source":"[size](#list__size) reflects the current size of the list."},{"content":"Example","pos":[56639,56646]},{"pos":[57644,57657],"content":"list::reverse"},{"content":"Reverses the order in which the elements occur in a list.","pos":[57661,57718]},{"content":"Example","pos":[57758,57765]},{"pos":[58483,58505],"content":"list::reverse_iterator"},{"content":"A type that provides a bidirectional iterator that can read or modify an element in a reversed list.","pos":[58509,58609]},{"content":"Remarks","pos":[58694,58701]},{"pos":[58705,58778],"content":"A type <ph id=\"ph1\">`reverse_iterator`</ph> is used to iterate through the list in reverse.","source":"A type `reverse_iterator` is used to iterate through the list in reverse."},{"content":"Example","pos":[58788,58795]},{"pos":[58800,58844],"content":"See the example for <bpt id=\"p1\">[</bpt>rbegin<ept id=\"p1\">](#list__rbegin)</ept>.","source":"See the example for [rbegin](#list__rbegin)."},{"pos":[58881,58891],"content":"list::size"},{"content":"Returns the number of elements in a list.","pos":[58895,58936]},{"content":"Return Value","pos":[58984,58996]},{"content":"The current length of the list.","pos":[59000,59031]},{"content":"Example","pos":[59041,59048]},{"pos":[59562,59577],"content":"list::size_type"},{"content":"A type that counts the number of elements in a list.","pos":[59581,59633]},{"content":"Example","pos":[59709,59716]},{"pos":[59721,59761],"content":"See the example for <bpt id=\"p1\">[</bpt>size<ept id=\"p1\">](#list__size)</ept>.","source":"See the example for [size](#list__size)."},{"pos":[59798,59808],"content":"list::sort"},{"content":"Arranges the elements of a list in ascending order or with respect to some other user-specified order.","pos":[59812,59914]},{"content":"Parameters","pos":[60002,60012]},{"content":"The comparison operator used to order successive elements.","pos":[60027,60085]},{"content":"Remarks","pos":[60095,60102]},{"content":"The first member function puts the elements in ascending order by default.","pos":[60106,60180]},{"pos":[60187,60317],"content":"The member template function orders the elements according to the user-specified comparison operation <ph id=\"ph1\">` comp`</ph> of class <bpt id=\"p1\">**</bpt>Traits<ept id=\"p1\">**</ept>.","source":"The member template function orders the elements according to the user-specified comparison operation ` comp` of class **Traits**."},{"content":"Example","pos":[60327,60334]},{"pos":[61360,61372],"content":"list::splice"},{"content":"Removes elements from a source list and inserts them into a destination list.","pos":[61376,61453]},{"content":"Parameters","pos":[62140,62150]},{"content":"The position in the destination list before which to insert.","pos":[62165,62225]},{"content":"The source list that is to be inserted into the destination list.","pos":[62244,62309]},{"content":"The element to be inserted from the source list.","pos":[62326,62374]},{"content":"The first element in the range to be inserted from the source list.","pos":[62392,62459]},{"content":"The first position beyond the last element in the range to be inserted from the source list.","pos":[62476,62568]},{"content":"Remarks","pos":[62578,62585]},{"content":"The first pair of member functions inserts all elements in the source list into the destination list before the position referred to by <ph id=\"ph1\">`Where`</ph> and removes all elements from the source list.","pos":[62589,62779],"source":"The first pair of member functions inserts all elements in the source list into the destination list before the position referred to by `Where` and removes all elements from the source list."},{"content":"( <ph id=\"ph1\">`&amp;Source`</ph> must not equal <ph id=\"ph2\">`this`</ph>.)","pos":[62780,62815],"source":" ( `&Source` must not equal `this`.)"},{"content":"The second pair of member functions inserts the element referred to by <ph id=\"ph1\">`Iter`</ph> before the position in the destination list referred to by <ph id=\"ph2\">`Where`</ph> and removes <ph id=\"ph3\">`Iter`</ph> from the source list.","pos":[62822,63007],"source":"The second pair of member functions inserts the element referred to by `Iter` before the position in the destination list referred to by `Where` and removes `Iter` from the source list."},{"content":"(If <ph id=\"ph1\">`Where == Iter || Where == ++Iter`</ph>, no change occurs.)","pos":[63008,63066],"source":" (If `Where == Iter || Where == ++Iter`, no change occurs.)"},{"content":"The third pair of member functions inserts the range designated by [ <ph id=\"ph1\">`First`</ph>, <ph id=\"ph2\">`Last`</ph>) before the element in the destination list referred to by <ph id=\"ph3\">`Where`</ph> and removes that range of elements from the source list.","pos":[63073,63281],"source":"The third pair of member functions inserts the range designated by [ `First`, `Last`) before the element in the destination list referred to by `Where` and removes that range of elements from the source list."},{"content":"(If <ph id=\"ph1\">`&amp;Source == this`</ph>, the range <ph id=\"ph2\">`[First, Last)`</ph> must not include the element pointed to by <ph id=\"ph3\">`Where`</ph>.)","pos":[63282,63383],"source":" (If `&Source == this`, the range `[First, Last)` must not include the element pointed to by `Where`.)"},{"pos":[63390,63577],"content":"If the ranged splice inserts <ph id=\"ph1\">`N`</ph> elements, and <ph id=\"ph2\">`&amp;Source != this`</ph>, an object of class <bpt id=\"p1\">[</bpt>iterator<ept id=\"p1\">](../standard-library/forward-list-class.md#forward_list__iterator)</ept> is incremented <ph id=\"ph3\">`N`</ph> times.","source":"If the ranged splice inserts `N` elements, and `&Source != this`, an object of class [iterator](../standard-library/forward-list-class.md#forward_list__iterator) is incremented `N` times."},{"content":"In all cases iterators, pointers, or references that refer to spliced elements remain valid and are transferred to the destination container.","pos":[63584,63725]},{"content":"Example","pos":[63735,63742]},{"pos":[65891,65901],"content":"list::swap"},{"content":"Exchanges the elements of two lists.","pos":[65905,65941]},{"content":"Parameters","pos":[66084,66094]},{"content":"The list providing the elements to be swapped, or the list whose elements are to be exchanged with those of the list <ph id=\"ph1\">` left`</ph>.","pos":[66110,66235],"source":" The list providing the elements to be swapped, or the list whose elements are to be exchanged with those of the list ` left`."},{"content":"A list whose elements are to be exchanged with those of the list <ph id=\"ph1\">` right`</ph>.","pos":[66253,66327],"source":" A list whose elements are to be exchanged with those of the list ` right`."},{"content":"Example","pos":[66337,66344]},{"pos":[67450,67462],"content":"list::unique"},{"content":"Removes adjacent duplicate elements or adjacent elements that satisfy some other binary predicate from a list.","pos":[67466,67576]},{"content":"Parameters","pos":[67687,67697]},{"content":"The binary predicate used to compare successive elements.","pos":[67712,67769]},{"content":"Remarks","pos":[67779,67786]},{"content":"This function assumes that the list is sorted, so that all duplicate elements are adjacent.","pos":[67790,67881]},{"content":"Duplicates that are not adjacent will not be deleted.","pos":[67882,67935]},{"content":"The first member function removes every element that compares equal to its preceding element.","pos":[67942,68035]},{"content":"The second member function removes every element that satisfies the predicate function <ph id=\"ph1\">` pred`</ph> when compared with its preceding element.","pos":[68042,68178],"source":"The second member function removes every element that satisfies the predicate function ` pred` when compared with its preceding element."},{"content":"You can use any of the binary function objects declared in the <ph id=\"ph1\">`&lt;functional&gt;`</ph>header for the argument  pred or you can create your own.","pos":[68179,68313],"source":" You can use any of the binary function objects declared in the `<functional>`header for the argument  pred or you can create your own."},{"content":"Example","pos":[68323,68330]},{"pos":[69617,69633],"content":"list::value_type"},{"content":"A type that represents the data type stored in a list.","pos":[69637,69691]},{"content":"Remarks","pos":[69769,69776]},{"pos":[69793,69842],"content":"is a synonym for the template parameter <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>.","source":" is a synonym for the template parameter **Type**."},{"content":"Example","pos":[69852,69859]},{"content":"See Also","pos":[70133,70141]},{"content":"list&gt;","pos":[70148,70153],"source":"list>"},{"content":"Thread Safety in the C++ Standard Library","pos":[70189,70230]},{"content":"C++ Standard Library Reference","pos":[70303,70333]}],"content":"---\ntitle: \"list Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std.list\"\n  - \"list\"\n  - \"std::list\"\n  - \"list/std::list\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"list class\"\nms.assetid: d3707f4a-10fd-444f-b856-f9ca2077c1cd\ncaps.latest.revision: 20\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# list Class\nThe STL list class is a template class of sequence containers that maintain their elements in a linear arrangement and allow efficient insertions and deletions at any location within the sequence. The sequence is stored as a bidirectional linked list of elements, each containing a member of some type *Type*.  \n  \n## Syntax  \n  \n```cpp  \ntemplate <class Type, class Allocator= allocator<Type>>  \nclass list  \n```  \n  \n#### Parameters  \n *Type*  \n The element data type to be stored in the list.  \n  \n `Allocator`  \n The type that represents the stored allocator object that encapsulates details about the list's allocation and deallocation of memory. This argument is optional, and the default value is **allocator**\\< *Type*> *.*  \n  \n## Remarks  \n The choice of container type should be based in general on the type of searching and inserting required by the application. Vectors should be the preferred container for managing a sequence when random access to any element is at a premium and insertions or deletions of elements are only required at the end of a sequence. The performance of the class deque container is superior when random access is needed and insertions and deletions at both the beginning and the end of a sequence are at a premium.  \n  \n The list member functions [merge](#list__merge), [reverse](#list__reverse), [unique](#list__unique), [remove](#list__remove), and [remove_if](#list__remove_if) have been optimized for operation on list objects and offer a high-performance alternative to their generic counterparts.  \n  \n List reallocation occurs when a member function must insert or erase elements of the list. In all such cases, only iterators or references that point at erased portions of the controlled sequence become invalid.  \n  \n Include the STL standard header \\<list> to define the [container](../standard-library/stl-containers.md) template class list and several supporting templates.  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[list](#list__list)|Constructs a list of a specific size or with elements of a specific value or with a specific `allocator` or as a copy of some other list.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[allocator_type](#list__allocator_type)|A type that represents the `allocator` class for a list object.|  \n|[const_iterator](#list__const_iterator)|A type that provides a bidirectional iterator that can read a `const` element in a list.|  \n|[const_pointer](#list__const_pointer)|A type that provides a pointer to a `const` element in a list.|  \n|[const_reference](#list__const_reference)|A type that provides a reference to a `const` element stored in a list for reading and performing `const` operations.|  \n|[const_reverse_iterator](#list__const_reverse_iterator)|A type that provides a bidirectional iterator that can read any `const` element in a list.|  \n|[difference_type](#list__difference_type)|A type that provides the difference between two iterators that refer to elements within the same list.|  \n|[iterator](#list__iterator)|A type that provides a bidirectional iterator that can read or modify any element in a list.|  \n|[pointer](#list__pointer)|A type that provides a pointer to an element in a list.|  \n|[reference](#list__reference)|A type that provides a reference to a `const` element stored in a list for reading and performing `const` operations.|  \n|[reverse_iterator](#list__reverse_iterator)|A type that provides a bidirectional iterator that can read or modify an element in a reversed list.|  \n|[size_type](#list__size_type)|A type that counts the number of elements in a list.|  \n|[value_type](#list__value_type)|A type that represents the data type stored in a list.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[assign](#list__assign)|Erases elements from a list and copies a new set of elements to the target list.|  \n|[back](#list__back)|Returns a reference to the last element of a list.|  \n|[begin](#list__begin)|Returns an iterator addressing the first element in a list.|  \n|[list::cbegin](#list__cbegin)|Returns a const iterator addressing the first element in a list.|  \n|[list::cend](#list__cend)|Returns a const iterator that addresses the location succeeding the last element in a list.|  \n|[list::clear](#list__clear)|Erases all the elements of a list.|  \n|[list::crbegin](#list__crbegin)|Returns a const iterator addressing the first element in a reversed list.|  \n|[list::crend](#list__crend)|Returns a const iterator that addresses the location succeeding the last element in a reversed list.|  \n|[list::emplace](#list__emplace)|Inserts an element constructed in place into a list at a specified position.|  \n|[list::emplace_back](#list__emplace_back)|Adds an element constructed in place to the end of a list.|  \n|[list::emplace_front](#list__emplace_front)|Adds an element constructed in place to the beginning of a list.|  \n|[empty](#list__empty)|Tests if a list is empty.|  \n|[end](#list__end)|Returns an iterator that addresses the location succeeding the last element in a list.|  \n|[erase](#list__erase)|Removes an element or a range of elements in a list from specified positions.|  \n|[front](#list__front)|Returns a reference to the first element in a list.|  \n|[get_allocator](#list__get_allocator)|Returns a copy of the `allocator` object used to construct a list.|  \n|[insert](#list__insert)|Inserts an element or a number of elements or a range of elements into a list at a specified position.|  \n|[max_size](#list__max_size)|Returns the maximum length of a list.|  \n|[merge](#list__merge)|Removes the elements from the argument list, inserts them into the target list, and orders the new, combined set of elements in ascending order or in some other specified order.|  \n|[pop_back](#list__pop_back)|Deletes the element at the end of a list.|  \n|[pop_front](#list__pop_front)|Deletes the element at the beginning of a list.|  \n|[push_back](#list__push_back)|Adds an element to the end of a list.|  \n|[push_front](#list__push_front)|Adds an element to the beginning of a list.|  \n|[rbegin](#list__rbegin)|Returns an iterator addressing the first element in a reversed list.|  \n|[remove](#list__remove)|Erases elements in a list that match a specified value.|  \n|[remove_if](#list__remove_if)|Erases elements from the list for which a specified predicate is satisfied.|  \n|[rend](#list__rend)|Returns an iterator that addresses the location succeeding the last element in a reversed list.|  \n|[resize](#list__resize)|Specifies a new size for a list.|  \n|[reverse](#list__reverse)|Reverses the order in which the elements occur in a list.|  \n|[size](#list__size)|Returns the number of elements in a list.|  \n|[sort](#list__sort)|Arranges the elements of a list in ascending order or with respect to some other order relation.|  \n|[splice](#list__splice)|Removes elements from the argument list and inserts them into the target list.|  \n|[swap](#list__swap)|Exchanges the elements of two lists.|  \n|[unique](#list__unique)|Removes adjacent duplicate elements or adjacent elements that satisfy some other binary predicate from the list.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|[list::operator=](#list__operator_eq)|Replaces the elements of the list with a copy of another list.|  \n  \n## Requirements  \n **Header**: \\<list>  \n  \n##  <a name=\"list__allocator_type\"></a>  list::allocator_type  \n A type that represents the allocator class for a list object.  \n  \n```  \ntypedef Allocator allocator_type;  \n```  \n  \n### Remarks  \n `allocator_type` is a synonym for the template parameter **Allocator.**  \n  \n### Example  \n  See the example for [get_allocator](#list__get_allocator).  \n  \n##  <a name=\"list__assign\"></a>  list::assign  \n Erases elements from a list and copies a new set of elements to a target list.  \n  \n```  \nvoid assign(\n    size_type Count,  \n    const Type& Val);\n\nvoid assign  \n    initializer_list<Type> IList);\n\ntemplate <class InputIterator>  \nvoid assign(\n    InputIterator First,  \n    InputIterator Last);\n```  \n  \n### Parameters  \n `First`  \n Position of the first element in the range of elements to be copied from the argument list.  \n  \n `Last`  \n Position of the first element just beyond the range of elements to be copied from the argument list.  \n  \n `Count`  \n The number of copies of an element being inserted into the list.  \n  \n `Val`  \n The value of the element being inserted into the list.  \n  \n `IList`  \n The initializer_list that contains the elements to be inserted.  \n  \n### Remarks  \n After erasing any existing elements in the target list, assign either inserts a specified range of elements from the original list or from some other list into the target list or inserts copies of a new element of a specified value into the target list  \n  \n### Example  \n  \n```cpp  \n// list_assign.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main()  \n{  \n    using namespace std;  \n    list<int> c1, c2;  \n    list<int>::const_iterator cIter;  \n  \n    c1.push_back(10);  \n    c1.push_back(20);  \n    c1.push_back(30);  \n    c2.push_back(40);  \n    c2.push_back(50);  \n    c2.push_back(60);  \n  \n    cout << \"c1 =\";  \n    for (auto c : c1)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    c1.assign(++c2.begin(), c2.end());  \n    cout << \"c1 =\";  \n    for (auto c : c1)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    c1.assign(7, 4);  \n    cout << \"c1 =\";  \n    for (auto c : c1)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    c1.assign({ 10, 20, 30, 40 });  \n    cout << \"c1 =\";  \n    for (auto c : c1)  \n        cout << \" \" << c;  \n    cout << endl;  \n}  \n```  \n  \n```Output  \nc1 = 10 20 30c1 = 50 60c1 = 4 4 4 4 4 4 4c1 = 10 20 30 40  \n```  \n  \n##  <a name=\"list__back\"></a>  list::back  \n Returns a reference to the last element of a list.  \n  \n```  \nreference back();\n\nconst_reference back() const;\n```  \n  \n### Return Value  \n The last element of the list. If the list is empty, the return value is undefined.  \n  \n### Remarks  \n If the return value of **back** is assigned to a `const_reference`, the list object cannot be modified. If the return value of **back** is assigned to a **reference**, the list object can be modified.  \n  \n When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty list.  See [Checked Iterators](../standard-library/checked-iterators.md) for more information.  \n  \n### Example  \n  \n```cpp  \n// list_back.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 11 );  \n  \n   int& i = c1.back( );  \n   const int& ii = c1.front( );  \n  \n   cout << \"The last integer of c1 is \" << i << endl;  \n   i--;  \n   cout << \"The next-to-last integer of c1 is \" << ii << endl;  \n}  \n```  \n  \n```Output  \nThe last integer of c1 is 11  \nThe next-to-last integer of c1 is 10  \n```  \n  \n##  <a name=\"list__begin\"></a>  list::begin  \n Returns an iterator addressing the first element in a list.  \n  \n```  \nconst_iterator begin() const;\n\niterator begin();\n```  \n  \n### Return Value  \n A bidirectional iterator addressing the first element in the list or to the location succeeding an empty list.  \n  \n### Remarks  \n If the return value of **begin** is assigned to a `const_iterator`, the elements in the list object cannot be modified. If the return value of **begin** is assigned to an **iterator**, the elements in the list object can be modified.  \n  \n### Example  \n  \n```cpp  \n// list_begin.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::iterator c1_Iter;  \n   list <int>::const_iterator c1_cIter;  \n  \n   c1.push_back( 1 );  \n   c1.push_back( 2 );  \n  \n   c1_Iter = c1.begin( );  \n   cout << \"The first element of c1 is \" << *c1_Iter << endl;  \n  \n *c1_Iter = 20;  \n   c1_Iter = c1.begin( );  \n   cout << \"The first element of c1 is now \" << *c1_Iter << endl;  \n  \n   // The following line would be an error because iterator is const  \n   // *c1_cIter = 200;  \n}  \n```  \n  \n```Output  \nThe first element of c1 is 1  \nThe first element of c1 is now 20  \n```  \n  \n##  <a name=\"list__cbegin\"></a>  list::cbegin  \n Returns a `const` iterator that addresses the first element in the range.  \n  \n```  \nconst_iterator cbegin() const;\n```  \n  \n### Return Value  \n A `const` bidirectional-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, `cbegin() == cend()`).  \n  \n### Remarks  \n With the return value of `cbegin`, the elements in the range cannot be modified.  \n  \n You can use this member function in place of the `begin()` member function to guarantee that the return value is `const_iterator`. Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example. In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `begin()` and `cbegin()`.  \n  \n```cpp  \n \nauto i1 = Container.begin();\n// i1 is Container<T>::iterator   \nauto i2 = Container.cbegin();\n\n// i2 is Container<T>::const_iterator  \n```  \n  \n##  <a name=\"list__cend\"></a>  list::cend  \n Returns a `const` iterator that addresses the location just beyond the last element in a range.  \n  \n```  \nconst_iterator cend() const;\n```  \n  \n### Return Value  \n A `const` bidirectional-access iterator that points just beyond the end of the range.  \n  \n### Remarks  \n `cend` is used to test whether an iterator has passed the end of its range.  \n  \n You can use this member function in place of the `end()` member function to guarantee that the return value is `const_iterator`. Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example. In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `end()` and `cend()`.  \n  \n```cpp  \n \nauto i1 = Container.end();\n// i1 is Container<T>::iterator   \nauto i2 = Container.cend();\n\n// i2 is Container<T>::const_iterator  \n```  \n  \n The value returned by `cend` should not be dereferenced.  \n  \n##  <a name=\"list__clear\"></a>  list::clear  \n Erases all the elements of a list.  \n  \n```  \nvoid clear();\n```  \n  \n### Example  \n  \n```cpp  \n// list_clear.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   list <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n  \n   cout << \"The size of the list is initially \" << c1.size( ) << endl;  \n   c1.clear( );  \n   cout << \"The size of list after clearing is \" << c1.size( ) << endl;  \n}  \n```  \n  \n```Output  \nThe size of the list is initially 3  \nThe size of list after clearing is 0  \n```  \n  \n##  <a name=\"list__const_iterator\"></a>  list::const_iterator  \n A type that provides a bidirectional iterator that can read a **const** element in a list.  \n  \n```  \ntypedef implementation-defined const_iterator;  \n```  \n  \n### Remarks  \n A type `const_iterator` cannot be used to modify the value of an element.  \n  \n### Example  \n  See the example for [back](#list__back).  \n  \n##  <a name=\"list__const_pointer\"></a>  list::const_pointer  \n Provides a pointer to a `const` element in a list.  \n  \n``` \ntypedef typename Allocator::const_pointer const_pointer;  \n```  \n  \n### Remarks  \n A type `const_pointer` cannot be used to modify the value of an element.  \n  \n In most cases, an [iterator](#list__iterator) should be used to access the elements in a list object.  \n  \n##  <a name=\"list__const_reference\"></a>  list::const_reference  \n A type that provides a reference to a **const** element stored in a list for reading and performing **const** operations.  \n  \n```  \ntypedef typename Allocator::const_reference const_reference;  \n```  \n  \n### Remarks  \n A type `const_reference` cannot be used to modify the value of an element.  \n  \n### Example  \n  \n```cpp  \n// list_const_ref.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n  \n   const list <int> c2 = c1;  \n   const int &i = c2.front( );  \n   const int &j = c2.back( );  \n   cout << \"The first element is \" << i << endl;  \n   cout << \"The second element is \" << j << endl;  \n  \n   // The following line would cause an error because c2 is const  \n   // c2.push_back( 30 );  \n}  \n```  \n  \n```Output  \nThe first element is 10  \nThe second element is 20  \n```  \n  \n##  <a name=\"list__const_reverse_iterator\"></a>  list::const_reverse_iterator  \n A type that provides a bidirectional iterator that can read any **const** element in a list.  \n  \n```  \ntypedef std::reverse_iterator<const_iterator> const_reverse_iterator;  \n```  \n  \n### Remarks  \n A type `const_reverse_iterator` cannot modify the value of an element and is used to iterate through the list in reverse.  \n  \n### Example  \n  See the example for [rbegin](#list__rbegin).  \n  \n##  <a name=\"list__crbegin\"></a>  list::crbegin  \n Returns a const iterator addressing the first element in a reversed list.  \n  \n```  \nconst_reverse_iterator rbegin() const;\n```  \n  \n### Return Value  \n A const reverse bidirectional iterator addressing the first element in a reversed list (or addressing what had been the last element in the unreversed `list`).  \n  \n### Remarks  \n `crbegin` is used with a reversed list just as [list::begin](#list__begin) is used with a `list`.  \n  \n With the return value of `crbegin`, the list object cannot be modified. [list::rbegin](#list__rbegin) can be used to iterate through a list backwards.  \n  \n### Example  \n  \n```cpp  \n// list_crbegin.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::const_reverse_iterator c1_crIter;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n   c1_crIter = c1.crbegin( );  \n   cout << \"The last element in the list is \" << *c1_crIter << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe last element in the list is 30.  \n```  \n  \n##  <a name=\"list__crend\"></a>  list::crend  \n Returns a const iterator that addresses the location succeeding the last element in a reversed list.  \n  \n```  \nconst_reverse_iterator rend() const;\n```  \n  \n### Return Value  \n A const reverse bidirectional iterator that addresses the location succeeding the last element in a reversed [list](../standard-library/list-class.md) (the location that had preceded the first element in the unreversed `list`).  \n  \n### Remarks  \n `crend` is used with a reversed list just as [list::end](#list__end) is used with a `list`.  \n  \n With the return value of `crend`, the `list` object cannot be modified.  \n  \n `crend` can be used to test to whether a reverse iterator has reached the end of its `list`.  \n  \n The value returned by `crend` should not be dereferenced.  \n  \n### Example  \n  \n```cpp  \n// list_crend.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::const_reverse_iterator c1_crIter;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n  \n   c1_crIter = c1.crend( );  \n   c1_crIter --;  // Decrementing a reverse iterator moves it forward in   \n                 // the list (to point to the first element here)  \n   cout << \"The first element in the list is: \" << *c1_crIter << endl;  \n}  \n```  \n  \n```Output  \nThe first element in the list is: 10  \n```  \n  \n##  <a name=\"list__difference_type\"></a>  list::difference_type  \n A signed integer type that can be used to represent the number of elements of a list in a range between elements pointed to by iterators.  \n  \n```  \ntypedef typename Allocator::difference_type difference_type;  \n```  \n  \n### Remarks  \n The `difference_type` is the type returned when subtracting or incrementing through iterators of the container. The `difference_type` is typically used to represent the number of elements in the range [ ` first`, ` last`) between the iterators ` first` and ` last`, includes the element pointed to by ` first` and the range of elements up to, but not including, the element pointed to by ` last`.  \n  \n Note that although `difference_type` is available for all iterators that satisfy the requirements of an input iterator, which includes the class of bidirectional iterators supported by reversible containers like set, subtraction between iterators is only supported by random-access iterators provided by a random-access container, such as [vector Class](../standard-library/vector-class.md).  \n  \n### Example  \n  \n```cpp  \n// list_diff_type.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <list>  \n#include <algorithm>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   list <int> c1;  \n   list <int>::iterator   c1_Iter, c2_Iter;  \n  \n   c1.push_back( 30 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n   c1.push_back( 10 );  \n   c1.push_back( 30 );  \n   c1.push_back( 20 );  \n  \n   c1_Iter = c1.begin( );  \n   c2_Iter = c1.end( );  \n  \n    list <int>::difference_type df_typ1, df_typ2, df_typ3;  \n  \n   df_typ1 = count( c1_Iter, c2_Iter, 10 );  \n   df_typ2 = count( c1_Iter, c2_Iter, 20 );  \n   df_typ3 = count( c1_Iter, c2_Iter, 30 );  \n   cout << \"The number '10' is in c1 collection \" << df_typ1 << \" times.\\n\";  \n   cout << \"The number '20' is in c1 collection \" << df_typ2 << \" times.\\n\";  \n   cout << \"The number '30' is in c1 collection \" << df_typ3 << \" times.\\n\";  \n}  \n```  \n  \n```Output  \nThe number '10' is in c1 collection 1 times.  \nThe number '20' is in c1 collection 2 times.  \nThe number '30' is in c1 collection 3 times.  \n```  \n  \n##  <a name=\"list__emplace\"></a>  list::emplace  \n Inserts an element constructed in place into a list at a specified position.  \n  \n```  \nvoid emplace_back(iterator Where, Type&& val);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`Where`|The position in the target [list](../standard-library/list-class.md) where the first element is inserted.|  \n|` val`|The element added to the end of the `list`.|  \n  \n### Remarks  \n If an exception is thrown, the `list` is left unaltered and the exception is rethrown.  \n  \n### Example  \n  \n```cpp  \n// list_emplace.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n#include <string>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <string> c2;  \n   string str(\"a\");  \n  \n   c2.emplace(c2.begin(), move( str ) );  \n   cout << \"Moved first element: \" << c2.back( ) << endl;  \n}  \n```  \n  \n```Output  \nMoved first element: a  \n```  \n  \n##  <a name=\"list__emplace_back\"></a>  list::emplace_back  \n Adds an element constructed in place to the beginning of a list.  \n  \n```  \nvoid emplace_back(Type&& val);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` val`|The element added to the end of the [list](../standard-library/list-class.md).|  \n  \n### Remarks  \n If an exception is thrown, the `list` is left unaltered and the exception is rethrown.  \n  \n### Example  \n  \n```cpp  \n// list_emplace_back.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n#include <string>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <string> c2;  \n   string str(\"a\");  \n  \n   c2.emplace_back( move( str ) );  \n   cout << \"Moved first element: \" << c2.back( ) << endl;  \n}  \n```  \n  \n```Output  \nMoved first element: a  \n```  \n  \n##  <a name=\"list__emplace_front\"></a>  list::emplace_front  \n Adds an element constructed in place to the beginning of a list.  \n  \n```  \nvoid emplace_front(Type&& val);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` val`|The element added to the beginning of the [list](../standard-library/list-class.md).|  \n  \n### Remarks  \n If an exception is thrown, the `list` is left unaltered and the exception is rethrown.  \n  \n### Example  \n  \n```cpp  \n// list_emplace_front.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n#include <string>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <string> c2;  \n   string str(\"a\");  \n  \n   c2.emplace_front( move( str ) );  \n   cout << \"Moved first element: \" << c2.front( ) << endl;  \n}  \n```  \n  \n```Output  \nMoved first element: a  \n```  \n  \n##  <a name=\"list__empty\"></a>  list::empty  \n Tests if a list is empty.  \n  \n```  \nbool empty() const;\n```  \n  \n### Return Value  \n **true** if the list is empty; **false** if the list is not empty.  \n  \n### Example  \n  \n```cpp  \n// list_empty.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   list <int> c1;  \n  \n   c1.push_back( 10 );  \n   if ( c1.empty( ) )  \n      cout << \"The list is empty.\" << endl;  \n   else  \n      cout << \"The list is not empty.\" << endl;  \n}  \n```  \n  \n```Output  \nThe list is not empty.  \n```  \n  \n##  <a name=\"list__end\"></a>  list::end  \n Returns an iterator that addresses the location succeeding the last element in a list.  \n  \n```  \nconst_iterator end() const;\niterator end();\n```  \n  \n### Return Value  \n A bidirectional iterator that addresses the location succeeding the last element in a list. If the list is empty, then `list::end == list::begin`.  \n  \n### Remarks  \n **end** is used to test whether an iterator has reached the end of its list.  \n  \n### Example  \n  \n```cpp  \n// list_end.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::iterator c1_Iter;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n  \n   c1_Iter = c1.end( );  \n   c1_Iter--;  \n   cout << \"The last integer of c1 is \" << *c1_Iter << endl;  \n  \n   c1_Iter--;  \n *c1_Iter = 400;  \n   cout << \"The new next-to-last integer of c1 is \"  \n        << *c1_Iter << endl;  \n  \n   // If a const iterator had been declared instead with the line:  \n   // list <int>::const_iterator c1_Iter;  \n   // an error would have resulted when inserting the 400  \n  \n   cout << \"The list is now:\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n}  \n```  \n  \n```Output  \nThe last integer of c1 is 30  \nThe new next-to-last integer of c1 is 400  \nThe list is now: 10 400 30  \n```  \n  \n##  <a name=\"list__erase\"></a>  list::erase  \n Removes an element or a range of elements in a list from specified positions.  \n  \n```  \niterator erase(iterator Where);\niterator erase(iterator first, iterator last);\n```  \n  \n### Parameters  \n `Where`  \n Position of the element to be removed from the list.  \n  \n ` first`  \n Position of the first element removed from the list.  \n  \n ` last`  \n Position just beyond the last element removed from the list.  \n  \n### Return Value  \n A bidirectional iterator that designates the first element remaining beyond any elements removed, or a pointer to the end of the list if no such element exists.  \n  \n### Remarks  \n No reallocation occurs, so iterators and references become invalid only for the erased elements.  \n  \n **erase** never throws an exception.  \n  \n### Example  \n  \n```cpp  \n// list_erase.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::iterator Iter;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n   c1.push_back( 40 );  \n   c1.push_back( 50 );  \n   cout << \"The initial list is:\";  \n   for ( Iter = c1.begin( ); Iter != c1.end( ); Iter++ )  \n      cout << \" \" << *Iter;  \n   cout << endl;  \n  \n   c1.erase( c1.begin( ) );  \n   cout << \"After erasing the first element, the list becomes:\";  \n   for ( Iter = c1.begin( ); Iter != c1.end( ); Iter++ )  \n      cout << \" \" << *Iter;  \n   cout << endl;  \n   Iter = c1.begin( );  \n   Iter++;  \n   c1.erase( Iter, c1.end( ) );  \n   cout << \"After erasing all elements but the first, the list becomes: \";  \n   for (Iter = c1.begin( ); Iter != c1.end( ); Iter++ )  \n      cout << \" \" << *Iter;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe initial list is: 10 20 30 40 50  \nAfter erasing the first element, the list becomes: 20 30 40 50  \nAfter erasing all elements but the first, the list becomes:  20  \n```  \n  \n##  <a name=\"list__front\"></a>  list::front  \n Returns a reference to the first element in a list.  \n  \n```  \nreference front();\nconst_reference front() const;\n```  \n  \n### Return Value  \n If the list is empty, the return is undefined.  \n  \n### Remarks  \n If the return value of `front` is assigned to a `const_reference`, the list object cannot be modified. If the return value of `front` is assigned to a **reference**, the list object can be modified.  \n  \n When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty list.  See [Checked Iterators](../standard-library/checked-iterators.md) for more information.  \n  \n### Example  \n  \n```cpp  \n// list_front.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   list <int> c1;  \n  \n   c1.push_back( 10 );  \n  \n   int& i = c1.front();  \n   const int& ii = c1.front();  \n  \n   cout << \"The first integer of c1 is \" << i << endl;  \n   i++;  \n   cout << \"The first integer of c1 is \" << ii << endl;  \n}  \n```  \n  \n```Output  \nThe first integer of c1 is 10  \nThe first integer of c1 is 11  \n```  \n  \n##  <a name=\"list__get_allocator\"></a>  list::get_allocator  \n Returns a copy of the allocator object used to construct a list.  \n  \n```  \nAllocator get_allocator() const;\n```  \n  \n### Return Value  \n The allocator used by the list.  \n  \n### Remarks  \n Allocators for the list class specify how the class manages storage. The default allocators supplied with STL container classes are sufficient for most programming needs. Writing and using your own allocator class is an advanced C++ topic.  \n  \n### Example  \n  \n```cpp  \n// list_get_allocator.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   // The following lines declare objects   \n   // that use the default allocator.  \n   list <int> c1;  \n   list <int, allocator<int> > c2 = list <int, allocator<int> >( allocator<int>( ) );  \n  \n   // c3 will use the same allocator class as c1  \n   list <int> c3( c1.get_allocator( ) );  \n  \n   list<int>::allocator_type xlst = c1.get_allocator( );  \n   // You can now call functions on the allocator class used by c1  \n}  \n```  \n  \n##  <a name=\"list__insert\"></a>  list::insert  \n Inserts an element or a number of elements or a range of elements into a list at a specified position.  \n  \n```  \niterator insert(iterator Where, const Type& Val);\niterator insert(iterator Where, Type&& Val);\n\nvoid insert(iterator Where, size_type Count, const Type& Val);\niterator insert(iterator Where, initializer_list<Type> IList);\n\ntemplate <class InputIterator>  \nvoid insert(iterator Where, InputIterator First, InputIterator Last);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`Where`|The position in the target list where the first element is inserted.|  \n|`Val`|The value of the element being inserted into the list.|  \n|`Count`|The number of elements being inserted into the list.|  \n|`First`|The position of the first element in the range of elements in the argument list to be copied.|  \n|`Last`|The position of the first element beyond the range of elements in the argument list to be copied.|  \n  \n### Return Value  \n The first two insert functions return an iterator that points to the position where the new element was inserted into the list.  \n  \n### Example  \n  \n```cpp  \n// list_class_insert.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n#include <string>  \n  \nint main()  \n{  \n    using namespace std;  \n    list <int> c1, c2;  \n    list <int>::iterator Iter;  \n  \n    c1.push_back(10);  \n    c1.push_back(20);  \n    c1.push_back(30);  \n    c2.push_back(40);  \n    c2.push_back(50);  \n    c2.push_back(60);  \n  \n    cout << \"c1 =\";  \n    for (auto c : c1)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    Iter = c1.begin();  \n    Iter++;  \n    c1.insert(Iter, 100);  \n    cout << \"c1 =\";  \n    for (auto c : c1)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    Iter = c1.begin();  \n    Iter++;  \n    Iter++;  \n    c1.insert(Iter, 2, 200);  \n  \n    cout << \"c1 =\";  \n    for(auto c : c1)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    c1.insert(++c1.begin(), c2.begin(), --c2.end());  \n  \n    cout << \"c1 =\";  \n    for (auto c : c1)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    // initialize a list of strings by moving  \n    list < string > c3;  \n    string str(\"a\");  \n  \n    c3.insert(c3.begin(), move(str));  \n    cout << \"Moved first element: \" << c3.front() << endl;  \n  \n    // Assign with an initializer_list  \n    list <int> c4{ {1, 2, 3, 4} };  \n    c4.insert(c4.begin(), { 5, 6, 7, 8 });  \n  \n    cout << \"c4 =\";  \n    for (auto c : c4)  \n        cout << \" \" << c;  \n    cout << endl;  \n}  \n```  \n  \n##  <a name=\"list__iterator\"></a>  list::iterator  \n A type that provides a bidirectional iterator that can read or modify any element in a list.  \n  \n```  \ntypedef implementation-defined iterator;  \n```  \n  \n### Remarks  \n A type **iterator** can be used to modify the value of an element.  \n  \n### Example  \n  See the example for [begin](#list__begin).  \n  \n##  <a name=\"list__list\"></a>  list::list  \n Constructs a list of a specific size or with elements of a specific value or with a specific allocator or as a copy of all or part of some other list.  \n  \n```  \nlist();\nexplicit list(const Allocator& Al);\nexplicit list(size_type Count);\nlist(size_type Count, const Type& Val);\nlist(size_type Count, const Type& Val, const Allocator& Al);\n\nlist(const list& Right);\nlist(list&& Right);\nlist(initializer_list<Type> IList, const Allocator& Al);\n\ntemplate <class InputIterator>  \nlist(InputIterator First, InputIterator Last);\n\ntemplate <class InputIterator>  \nlist(InputIterator First, InputIterator Last, const Allocator& Al);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`Al`|The allocator class to use with this object.|  \n|`Count`|The number of elements in the list constructed.|  \n|`Val`|The value of the elements in the list.|  \n|`Right`|The list of which the constructed list is to be a copy.|  \n|`First`|The position of the first element in the range of elements to be copied.|  \n|`Last`|The position of the first element beyond the range of elements to be copied.|  \n|`IList`|The initializer_list that contains the elements to be copied.|  \n  \n### Remarks  \n All constructors store an allocator object ( `Al`) and initialize the list.  \n  \n [get_allocator](#list__get_allocator) returns a copy of the allocator object used to construct a list.  \n  \n The first two constructors specify an empty initial list, the second specifying the allocator type ( `Al`) to be used.  \n  \n The third constructor specifies a repetition of a specified number ( `Count`) of elements of the default value for class **Type**.  \n  \n The fourth and fifth constructors specify a repetition of ( `Count`) elements of value `Val`.  \n  \n The sixth constructor specifies a copy of the list `Right`.  \n  \n The seventh constructor moves the list `Right`.  \n  \n The eighth constructor uses an initializer_list to specify the elements.  \n  \n The next two constructors copy the range `[First, Last)` of a list.  \n  \n None of the constructors perform any interim reallocations.  \n  \n### Example  \n  \n```cpp  \n// list_class_list.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main()  \n{  \n    using namespace std;  \n    // Create an empty list c0  \n    list <int> c0;  \n  \n    // Create a list c1 with 3 elements of default value 0  \n    list <int> c1(3);  \n  \n    // Create a list c2 with 5 elements of value 2  \n    list <int> c2(5, 2);  \n  \n    // Create a list c3 with 3 elements of value 1 and with the   \n    // allocator of list c2  \n    list <int> c3(3, 1, c2.get_allocator());  \n  \n    // Create a copy, list c4, of list c2  \n    list <int> c4(c2);  \n  \n    // Create a list c5 by copying the range c4[ first,  last)  \n    list <int>::iterator c4_Iter = c4.begin();  \n    c4_Iter++;  \n    c4_Iter++;  \n    list <int> c5(c4.begin(), c4_Iter);  \n  \n    // Create a list c6 by copying the range c4[ first,  last) and with   \n    // the allocator of list c2  \n    c4_Iter = c4.begin();  \n    c4_Iter++;  \n    c4_Iter++;  \n    c4_Iter++;  \n    list <int> c6(c4.begin(), c4_Iter, c2.get_allocator());  \n  \n    cout << \"c1 =\";  \n    for (auto c : c1)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    cout << \"c2 =\";  \n    for (auto c : c2)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    cout << \"c3 =\";  \n    for (auto c : c3)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    cout << \"c4 =\";  \n    for (auto c : c4)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    cout << \"c5 =\";  \n    for (auto c : c5)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    cout << \"c6 =\";  \n    for (auto c : c6)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    // Move list c6 to list c7  \n    list <int> c7(move(c6));  \n    cout << \"c7 =\";  \n    for (auto c : c7)  \n        cout << \" \" << c;  \n    cout << endl;  \n  \n    // Construct with initializer_list  \n    list<int> c8({ 1, 2, 3, 4 });  \n    cout << \"c8 =\";  \n    for (auto c : c8)  \n        cout << \" \" << c;  \n    cout << endl;  \n}  \n```  \n  \n```Output  \nc1 = 0 0 0c2 = 2 2 2 2 2c3 = 1 1 1c4 = 2 2 2 2 2c5 = 2 2c6 = 2 2 2c7 = 2 2 2c8 = 1 2 3 4  \n```  \n  \n##  <a name=\"list__max_size\"></a>  list::max_size  \n Returns the maximum length of a list.  \n  \n```\nsize_type max_size() const;\n```  \n  \n### Return Value  \n The maximum possible length of the list.  \n  \n### Example  \n  \n```cpp  \n// list_max_size.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::size_type i;  \n  \n   i = c1.max_size( );  \n   cout << \"Maximum possible length of the list is \" << i << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"list__merge\"></a>  list::merge  \n Removes the elements from the argument list, inserts them into the target list, and orders the new, combined set of elements in ascending order or in some other specified order.  \n  \n```  \nvoid merge(list<Type, Allocator>& right);\n\ntemplate <class Traits>  \nvoid merge(list<Type, Allocator>& right, Traits comp);\n```  \n  \n### Parameters  \n ` right`  \n The argument list to be merged with the target list.  \n  \n ` comp`  \n The comparison operator used to order the elements of the target list.  \n  \n### Remarks  \n The argument list ` right` is merged with the target list.  \n  \n Both argument and target lists must be ordered with the same comparison relation by which the resulting sequence is to be ordered. The default order for the first member function is ascending order. The second member function imposes the user-specified comparison operation ` comp` of class **Traits**.  \n  \n### Example  \n  \n```cpp  \n// list_merge.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1, c2, c3;  \n   list <int>::iterator c1_Iter, c2_Iter, c3_Iter;  \n  \n   c1.push_back( 3 );  \n   c1.push_back( 6 );  \n   c2.push_back( 2 );  \n   c2.push_back( 4 );  \n   c3.push_back( 5 );  \n   c3.push_back( 1 );  \n  \n   cout << \"c1 =\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   cout << \"c2 =\";  \n   for ( c2_Iter = c2.begin( ); c2_Iter != c2.end( ); c2_Iter++ )  \n      cout << \" \" << *c2_Iter;  \n   cout << endl;  \n  \n   c2.merge( c1 );  // Merge c1 into c2 in (default) ascending order  \n   c2.sort( greater<int>( ) );  \n   cout << \"After merging c1 with c2 and sorting with >: c2 =\";  \n   for ( c2_Iter = c2.begin( ); c2_Iter != c2.end( ); c2_Iter++ )  \n      cout << \" \" << *c2_Iter;  \n   cout << endl;  \n  \n   cout << \"c3 =\";  \n   for ( c3_Iter = c3.begin( ); c3_Iter != c3.end( ); c3_Iter++ )  \n      cout << \" \" << *c3_Iter;  \n   cout << endl;  \n  \n   c2.merge( c3, greater<int>( ) );  \n   cout << \"After merging c3 with c2 according to the '>' comparison relation: c2 =\";  \n   for ( c2_Iter = c2.begin( ); c2_Iter != c2.end( ); c2_Iter++ )  \n      cout << \" \" << *c2_Iter;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nc1 = 3 6  \nc2 = 2 4  \nAfter merging c1 with c2 and sorting with >: c2 = 6 4 3 2  \nc3 = 5 1  \nAfter merging c3 with c2 according to the '>' comparison relation: c2 = 6 5 4 3 2 1  \n```  \n  \n##  <a name=\"list__operator_eq\"></a>  list::operator=  \n Replaces the elements of the list with a copy of another list.  \n  \n```  \nlist& operator=(const list& right);\nlist& operator=(list&& right);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` right`|The [list](../standard-library/list-class.md) being copied into the `list`.|  \n  \n### Remarks  \n After erasing any existing elements in a `list`, the operator either copies or moves the contents of ` right` into the `list`.  \n  \n### Example  \n  \n```cpp  \n// list_operator_as.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   list<int> v1, v2, v3;  \n   list<int>::iterator iter;  \n  \n   v1.push_back(10);  \n   v1.push_back(20);  \n   v1.push_back(30);  \n   v1.push_back(40);  \n   v1.push_back(50);  \n  \n   cout << \"v1 = \" ;  \n   for (iter = v1.begin(); iter != v1.end(); iter++)  \n      cout << *iter << \" \";  \n   cout << endl;  \n  \n   v2 = v1;  \n   cout << \"v2 = \";  \n   for (iter = v2.begin(); iter != v2.end(); iter++)  \n      cout << *iter << \" \";  \n   cout << endl;  \n  \n// move v1 into v2  \n   v2.clear();  \n   v2 = forward< list<int> >(v1);  \n   cout << \"v2 = \";  \n   for (iter = v2.begin(); iter != v2.end(); iter++)  \n      cout << *iter << \" \";  \n   cout << endl;  \n}  \n```  \n  \n##  <a name=\"list__pointer\"></a>  list::pointer  \n Provides a pointer to an element in a list.  \n  \n```\ntypedef typename Allocator::pointer pointer;  \n```  \n  \n### Remarks  \n A type **pointer** can be used to modify the value of an element.  \n  \n In most cases, an [iterator](#list__iterator) should be used to access the elements in a list object.  \n  \n##  <a name=\"list__pop_back\"></a>  list::pop_back  \n Deletes the element at the end of a list.  \n  \n``` \nvoid pop_back();\n```  \n  \n### Remarks  \n The last element must not be empty. `pop_back` never throws an exception.  \n  \n### Example  \n  \n```cpp  \n// list_pop_back.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n  \n   c1.push_back( 1 );  \n   c1.push_back( 2 );  \n   cout << \"The first element is: \" << c1.front( ) << endl;  \n   cout << \"The last element is: \" << c1.back( ) << endl;  \n  \n   c1.pop_back( );  \n   cout << \"After deleting the element at the end of the list, \"  \n           \"the last element is: \" << c1.back( ) << endl;  \n}  \n```  \n  \n```Output  \nThe first element is: 1  \nThe last element is: 2  \nAfter deleting the element at the end of the list, the last element is: 1  \n```  \n  \n##  <a name=\"list__pop_front\"></a>  list::pop_front  \n Deletes the element at the beginning of a list.  \n  \n``` \nvoid pop_front();\n```  \n  \n### Remarks  \n The first element must not be empty. `pop_front` never throws an exception.  \n  \n### Example  \n  \n```cpp  \n// list_pop_front.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n  \n   c1.push_back( 1 );  \n   c1.push_back( 2 );  \n   cout << \"The first element is: \" << c1.front( ) << endl;  \n   cout << \"The second element is: \" << c1.back( ) << endl;  \n  \n   c1.pop_front( );  \n   cout << \"After deleting the element at the beginning of the list, \"  \n         \"the first element is: \" << c1.front( ) << endl;  \n}  \n```  \n  \n```Output  \nThe first element is: 1  \nThe second element is: 2  \nAfter deleting the element at the beginning of the list, the first element is: 2  \n```  \n  \n##  <a name=\"list__push_back\"></a>  list::push_back  \n Adds an element to the end of a list.  \n  \n```  \nvoid push_back(void push_back(Type&& val);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` val`|The element added to the end of the list.|  \n  \n### Remarks  \n If an exception is thrown, the list is left unaltered and the exception is rethrown.  \n  \n### Example  \n  \n```cpp  \n// list_push_back.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n#include <string>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n  \n   c1.push_back( 1 );  \n   if ( c1.size( ) != 0 )  \n      cout << \"Last element: \" << c1.back( ) << endl;  \n  \n   c1.push_back( 2 );  \n   if ( c1.size( ) != 0 )  \n      cout << \"New last element: \" << c1.back( ) << endl;  \n  \n// move initialize a list of strings  \n   list <string> c2;  \n   string str(\"a\");  \n  \n   c2.push_back( move( str ) );  \n   cout << \"Moved first element: \" << c2.back( ) << endl;  \n}  \n```  \n  \n```Output  \nLast element: 1  \nNew last element: 2  \nMoved first element: a  \n```  \n  \n##  <a name=\"list__push_front\"></a>  list::push_front  \n Adds an element to the beginning of a list.  \n  \n```  \nvoid push_front(const Type& val);\nvoid push_front(Type&& val);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` val`|The element added to the beginning of the list.|  \n  \n### Remarks  \n If an exception is thrown, the list is left unaltered and the exception is rethrown.  \n  \n### Example  \n  \n```cpp  \n// list_push_front.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n#include <string>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n  \n   c1.push_front( 1 );  \n   if ( c1.size( ) != 0 )  \n      cout << \"First element: \" << c1.front( ) << endl;  \n  \n   c1.push_front( 2 );  \n   if ( c1.size( ) != 0 )  \n      cout << \"New first element: \" << c1.front( ) << endl;  \n  \n// move initialize a list of strings  \n   list <string> c2;  \n   string str(\"a\");  \n  \n   c2.push_front( move( str ) );  \n   cout << \"Moved first element: \" << c2.front( ) << endl;  \n}  \n```  \n  \n```Output  \nFirst element: 1  \nNew first element: 2  \nMoved first element: a  \n```  \n  \n##  <a name=\"list__rbegin\"></a>  list::rbegin  \n Returns an iterator that addresses the first element in a reversed list.  \n  \n``` \nconst_reverse_iterator rbegin() const;\nreverse_iterator rbegin();\n```  \n  \n### Return Value  \n A reverse bidirectional iterator addressing the first element in a reversed list (or addressing what had been the last element in the unreversed list).  \n  \n### Remarks  \n `rbegin` is used with a reversed list just as [begin](#list__begin) is used with a list.  \n  \n If the return value of `rbegin` is assigned to a `const_reverse_iterator`, the list object cannot be modified. If the return value of `rbegin` is assigned to a `reverse_iterator`, the list object can be modified.  \n  \n `rbegin` can be used to iterate through a list backwards.  \n  \n### Example  \n  \n```cpp  \n// list_rbegin.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::iterator c1_Iter;  \n   list <int>::reverse_iterator c1_rIter;  \n  \n   // If the following line replaced the line above, *c1_rIter = 40;  \n   // (below) would be an error  \n   //list <int>::const_reverse_iterator c1_rIter;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n   c1_rIter = c1.rbegin( );  \n   cout << \"The last element in the list is \" << *c1_rIter << \".\" << endl;  \n  \n   cout << \"The list is:\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   // rbegin can be used to start an iteration through a list in   \n   // reverse order  \n   cout << \"The reversed list is:\";  \n   for ( c1_rIter = c1.rbegin( ); c1_rIter != c1.rend( ); c1_rIter++ )  \n      cout << \" \" << *c1_rIter;  \n   cout << endl;  \n  \n   c1_rIter = c1.rbegin( );  \n *c1_rIter = 40;  \n   cout << \"The last element in the list is now \" << *c1_rIter << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe last element in the list is 30.  \nThe list is: 10 20 30  \nThe reversed list is: 30 20 10  \nThe last element in the list is now 40.  \n```  \n  \n##  <a name=\"list__reference\"></a>  list::reference  \n A type that provides a reference to an element stored in a list.  \n  \n```  \ntypedef typename Allocator::reference reference;  \n```  \n  \n### Example  \n  \n```cpp  \n// list_ref.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n  \n   int &i = c1.front( );  \n   int &j = c1.back( );  \n   cout << \"The first element is \" << i << endl;  \n   cout << \"The second element is \" << j << endl;  \n}  \n```  \n  \n```Output  \nThe first element is 10  \nThe second element is 20  \n```  \n  \n##  <a name=\"list__remove\"></a>  list::remove  \n Erases elements in a list that match a specified value.  \n  \n``` \nvoid remove(const Type& val);\n```  \n  \n### Parameters  \n ` val`  \n The value which, if held by an element, will result in that element's removal from the list.  \n  \n### Remarks  \n The order of the elements remaining is not affected.  \n  \n### Example  \n  \n```cpp  \n// list_remove.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::iterator c1_Iter, c2_Iter;  \n  \n   c1.push_back( 5 );  \n   c1.push_back( 100 );  \n   c1.push_back( 5 );  \n   c1.push_back( 200 );  \n   c1.push_back( 5 );  \n   c1.push_back( 300 );  \n  \n   cout << \"The initial list is c1 =\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   list <int> c2 = c1;  \n   c2.remove( 5 );  \n   cout << \"After removing elements with value 5, the list becomes c2 =\";  \n   for ( c2_Iter = c2.begin( ); c2_Iter != c2.end( ); c2_Iter++ )  \n      cout << \" \" << *c2_Iter;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe initial list is c1 = 5 100 5 200 5 300  \nAfter removing elements with value 5, the list becomes c2 = 100 200 300  \n```  \n  \n##  <a name=\"list__remove_if\"></a>  list::remove_if  \n Erases elements from a list for which a specified predicate is satisfied.  \n  \n``` \ntemplate <class Predicate>  \nvoid remove_if(Predicate pred)  \n```  \n  \n### Parameters  \n ` pred`  \n The unary predicate which, if satisfied by an element, results in the deletion of that element from the list.  \n  \n### Example  \n  \n```cpp  \n// list_remove_if.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \ntemplate <class T> class is_odd : public std::unary_function<T, bool>   \n{  \npublic:  \n   bool operator( ) ( T& val )   \n   {  \n   return ( val % 2 ) == 1;  \n   }  \n};  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::iterator c1_Iter, c2_Iter;  \n  \n   c1.push_back( 3 );  \n   c1.push_back( 4 );  \n   c1.push_back( 5 );  \n   c1.push_back( 6 );  \n   c1.push_back( 7 );  \n   c1.push_back( 8 );  \n  \n   cout << \"The initial list is c1 =\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   list <int> c2 = c1;  \n   c2.remove_if( is_odd<int>( ) );  \n  \n   cout << \"After removing the odd elements, \"  \n        << \"the list becomes c2 =\";  \n   for ( c2_Iter = c2.begin( ); c2_Iter != c2.end( ); c2_Iter++ )  \n      cout << \" \" << *c2_Iter;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe initial list is c1 = 3 4 5 6 7 8  \nAfter removing the odd elements, the list becomes c2 = 4 6 8  \n```  \n  \n##  <a name=\"list__rend\"></a>  list::rend  \n Returns an iterator that addresses the location that follows the last element in a reversed list.  \n  \n``` \nconst_reverse_iterator rend() const;\nreverse_iterator rend();\n```  \n  \n### Return Value  \n A reverse bidirectional iterator that addresses the location succeeding the last element in a reversed list (the location that had preceded the first element in the unreversed list).  \n  \n### Remarks  \n `rend` is used with a reversed list just as [end](#list__end) is used with a list.  \n  \n If the return value of `rend` is assigned to a `const_reverse_iterator`, the list object cannot be modified. If the return value of `rend` is assigned to a `reverse_iterator`, the list object can be modified.  \n  \n `rend` can be used to test to whether a reverse iterator has reached the end of its list.  \n  \n The value returned by `rend` should not be dereferenced.  \n  \n### Example  \n  \n```cpp  \n// list_rend.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::iterator c1_Iter;  \n   list <int>::reverse_iterator c1_rIter;  \n  \n   // If the following line had replaced the line above, an error would   \n   // have resulted in the line modifying an element (commented below)  \n   // because the iterator would have been const  \n   // list <int>::const_reverse_iterator c1_rIter;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n  \n   c1_rIter = c1.rend( );  \n   c1_rIter --;  // Decrementing a reverse iterator moves it forward in   \n                 // the list (to point to the first element here)  \n   cout << \"The first element in the list is: \" << *c1_rIter << endl;  \n  \n   cout << \"The list is:\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   // rend can be used to test if an iteration is through all of the   \n   // elements of a reversed list  \n   cout << \"The reversed list is:\";  \n   for ( c1_rIter = c1.rbegin( ); c1_rIter != c1.rend( ); c1_rIter++ )  \n      cout << \" \" << *c1_rIter;  \n   cout << endl;  \n  \n   c1_rIter = c1.rend( );  \n   c1_rIter--;  // Decrementing the reverse iterator moves it backward   \n                // in the reversed list (to the last element here)  \n  \n *c1_rIter = 40;  // This modification of the last element would have   \n                    // caused an error if a const_reverse iterator had   \n                    // been declared (as noted above)  \n  \n   cout << \"The modified reversed list is:\";  \n   for ( c1_rIter = c1.rbegin( ); c1_rIter != c1.rend( ); c1_rIter++ )  \n      cout << \" \" << *c1_rIter;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe first element in the list is: 10  \nThe list is: 10 20 30  \nThe reversed list is: 30 20 10  \nThe modified reversed list is: 30 20 40  \n```  \n  \n##  <a name=\"list__resize\"></a>  list::resize  \n Specifies a new size for a list.  \n  \n``` \nvoid resize(size_type _Newsize);\nvoid resize(size_type _Newsize, Type val);\n```  \n  \n### Parameters  \n `_Newsize`  \n The new size of the list.  \n  \n ` val`  \n The value of the new elements to be added to the list if the new size is larger that the original size. If the value is omitted, the new elements are assigned the default value for the class.  \n  \n### Remarks  \n If the list's size is less than the requested size, `_Newsize`, elements are added to the list until it reaches the requested size.  \n  \n If the list's size is larger than the requested size, the elements closest to the end of the list are deleted until the list reaches the size `_Newsize`.  \n  \n If the present size of the list is the same as the requested size, no action is taken.  \n  \n [size](#list__size) reflects the current size of the list.  \n  \n### Example  \n  \n```cpp  \n// list_resize.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{   \n   using namespace std;  \n   list <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n  \n   c1.resize( 4,40 );  \n   cout << \"The size of c1 is \" << c1.size( ) << endl;  \n   cout << \"The value of the last element is \" << c1.back( ) << endl;  \n  \n   c1.resize( 5 );  \n   cout << \"The size of c1 is now \" << c1.size( ) << endl;  \n   cout << \"The value of the last element is now \" << c1.back( ) << endl;  \n  \n   c1.resize( 2 );  \n   cout << \"The reduced size of c1 is: \" << c1.size( ) << endl;  \n   cout << \"The value of the last element is now \" << c1.back( ) << endl;  \n}  \n```  \n  \n```Output  \nThe size of c1 is 4  \nThe value of the last element is 40  \nThe size of c1 is now 5  \nThe value of the last element is now 0  \nThe reduced size of c1 is: 2  \nThe value of the last element is now 20  \n```  \n  \n##  <a name=\"list__reverse\"></a>  list::reverse  \n Reverses the order in which the elements occur in a list.  \n  \n``` \nvoid reverse();\n```  \n  \n### Example  \n  \n```cpp  \n// list_reverse.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::iterator c1_Iter;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n  \n   cout << \"c1 =\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   c1.reverse( );  \n   cout << \"Reversed c1 =\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nc1 = 10 20 30  \nReversed c1 = 30 20 10  \n```  \n  \n##  <a name=\"list__reverse_iterator\"></a>  list::reverse_iterator  \n A type that provides a bidirectional iterator that can read or modify an element in a reversed list.  \n  \n```  \ntypedef std::reverse_iterator<iterator> reverse_iterator;  \n```  \n  \n### Remarks  \n A type `reverse_iterator` is used to iterate through the list in reverse.  \n  \n### Example  \n  See the example for [rbegin](#list__rbegin).  \n  \n##  <a name=\"list__size\"></a>  list::size  \n Returns the number of elements in a list.  \n  \n``` \nsize_type size() const;\n```  \n  \n### Return Value  \n The current length of the list.  \n  \n### Example  \n  \n```cpp  \n// list_size.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::size_type i;  \n  \n   c1.push_back( 5 );  \n   i = c1.size( );  \n   cout << \"List length is \" << i << \".\" << endl;  \n  \n   c1.push_back( 7 );  \n   i = c1.size( );  \n   cout << \"List length is now \" << i << \".\" << endl;  \n}  \n```  \n  \n```Output  \nList length is 1.  \nList length is now 2.  \n```  \n  \n##  <a name=\"list__size_type\"></a>  list::size_type  \n A type that counts the number of elements in a list.  \n  \n```  \ntypedef typename Allocator::size_type size_type;  \n```  \n  \n### Example  \n  See the example for [size](#list__size).  \n  \n##  <a name=\"list__sort\"></a>  list::sort  \n Arranges the elements of a list in ascending order or with respect to some other user-specified order.  \n  \n``` \nvoid sort();\n\ntemplate <class Traits>  \nvoid sort(Traits comp);\n```  \n  \n### Parameters  \n ` comp`  \n The comparison operator used to order successive elements.  \n  \n### Remarks  \n The first member function puts the elements in ascending order by default.  \n  \n The member template function orders the elements according to the user-specified comparison operation ` comp` of class **Traits**.  \n  \n### Example  \n  \n```cpp  \n// list_sort.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::iterator c1_Iter;  \n  \n   c1.push_back( 20 );  \n   c1.push_back( 10 );  \n   c1.push_back( 30 );  \n  \n   cout << \"Before sorting: c1 =\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   c1.sort( );  \n   cout << \"After sorting c1 =\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   c1.sort( greater<int>( ) );  \n   cout << \"After sorting with 'greater than' operation, c1 =\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nBefore sorting: c1 = 20 10 30  \nAfter sorting c1 = 10 20 30  \nAfter sorting with 'greater than' operation, c1 = 30 20 10  \n```  \n  \n##  <a name=\"list__splice\"></a>  list::splice  \n Removes elements from a source list and inserts them into a destination list.  \n  \n```  \n// insert the entire source list  \nvoid splice(const_iterator Where, list<Type, Allocator>& Source);\nvoid splice(const_iterator Where, list<Type, Allocator>&& Source); \n\n// insert one element of the source list  \nvoid splice(const_iterator Where, list<Type, Allocator>& Source, const_iterator Iter);\nvoid splice(const_iterator Where, list<Type, Allocator>&& Source, const_iterator Iter);\n \n// insert a range of elements from the source list  \nvoid splice(const_iterator Where, list<Type, Allocator>& Source, const_iterator First, const_iterator Last);\nvoid splice(const_iterator Where, list<Type, Allocator>&& Source, const_iterator First, const_iterator Last);\n```  \n  \n### Parameters  \n `Where`  \n The position in the destination list before which to insert.  \n  \n `Source`  \n The source list that is to be inserted into the destination list.  \n  \n `Iter`  \n The element to be inserted from the source list.  \n  \n `First`  \n The first element in the range to be inserted from the source list.  \n  \n `Last`  \n The first position beyond the last element in the range to be inserted from the source list.  \n  \n### Remarks  \n The first pair of member functions inserts all elements in the source list into the destination list before the position referred to by `Where` and removes all elements from the source list. ( `&Source` must not equal `this`.)  \n  \n The second pair of member functions inserts the element referred to by `Iter` before the position in the destination list referred to by `Where` and removes `Iter` from the source list. (If `Where == Iter || Where == ++Iter`, no change occurs.)  \n  \n The third pair of member functions inserts the range designated by [ `First`, `Last`) before the element in the destination list referred to by `Where` and removes that range of elements from the source list. (If `&Source == this`, the range `[First, Last)` must not include the element pointed to by `Where`.)  \n  \n If the ranged splice inserts `N` elements, and `&Source != this`, an object of class [iterator](../standard-library/forward-list-class.md#forward_list__iterator) is incremented `N` times.  \n  \n In all cases iterators, pointers, or references that refer to spliced elements remain valid and are transferred to the destination container.  \n  \n### Example  \n  \n```cpp  \n// list_splice.cpp  \n// compile with: /EHsc /W4  \n#include <list>  \n#include <iostream>  \n  \nusing namespace std;  \n  \ntemplate <typename S> void print(const S& s) {  \n    cout << s.size() << \" elements: \";  \n  \n    for (const auto& p : s) {  \n        cout << \"(\" << p << \") \";  \n    }  \n  \n    cout << endl;  \n}  \n  \nint main()  \n{  \n    list<int> c1{10,11};  \n    list<int> c2{20,21,22};  \n    list<int> c3{30,31};  \n    list<int> c4{40,41,42,43};  \n  \n    list<int>::iterator where_iter;  \n    list<int>::iterator first_iter;  \n    list<int>::iterator last_iter;  \n  \n    cout << \"Beginning state of lists:\" << endl;  \n    cout << \"c1 = \";  \n    print(c1);  \n    cout << \"c2 = \";  \n    print(c2);  \n    cout << \"c3 = \";  \n    print(c3);  \n    cout << \"c4 = \";  \n    print(c4);  \n  \n    where_iter = c2.begin();  \n    ++where_iter; // start at second element  \n    c2.splice(where_iter, c1);  \n    cout << \"After splicing c1 into c2:\" << endl;  \n    cout << \"c1 = \";  \n    print(c1);  \n    cout << \"c2 = \";  \n    print(c2);  \n  \n    first_iter = c3.begin();  \n    c2.splice(where_iter, c3, first_iter);  \n    cout << \"After splicing the first element of c3 into c2:\" << endl;  \n    cout << \"c3 = \";  \n    print(c3);  \n    cout << \"c2 = \";  \n    print(c2);  \n  \n    first_iter = c4.begin();  \n    last_iter = c4.end();  \n    // set up to get the middle elements  \n    ++first_iter;  \n    --last_iter;  \n    c2.splice(where_iter, c4, first_iter, last_iter);  \n    cout << \"After splicing a range of c4 into c2:\" << endl;  \n    cout << \"c4 = \";  \n    print(c4);  \n    cout << \"c2 = \";  \n    print(c2);  \n}  \n  \n```  \n  \n```Output  \nBeginning state of lists:c1 = 2 elements: (10) (11)c2 = 3 elements: (20) (21) (22)c3 = 2 elements: (30) (31)c4 = 4 elements: (40) (41) (42) (43)After splicing c1 into c2:c1 = 0 elements:c2 = 5 elements: (20) (10) (11) (21) (22)After splicing the first element of c3 into c2:c3 = 1 elements: (31)c2 = 6 elements: (20) (10) (11) (30) (21) (22)After splicing a range of c4 into c2:c4 = 2 elements: (40) (43)c2 = 8 elements: (20) (10) (11) (30) (41) (42) (21) (22)  \n```  \n  \n##  <a name=\"list__swap\"></a>  list::swap  \n Exchanges the elements of two lists.  \n  \n``` \nvoid swap(list<Type, Allocator>& right);\nfriend void swap(list<Type, Allocator>& left, list<Type, Allocator>& right)  \n```  \n  \n### Parameters  \n ` right`  \n The list providing the elements to be swapped, or the list whose elements are to be exchanged with those of the list ` left`.  \n  \n ` left`  \n A list whose elements are to be exchanged with those of the list ` right`.  \n  \n### Example  \n  \n```cpp  \n// list_swap.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   list <int> c1, c2, c3;  \n   list <int>::iterator c1_Iter;  \n  \n   c1.push_back( 1 );  \n   c1.push_back( 2 );  \n   c1.push_back( 3 );  \n   c2.push_back( 10 );  \n   c2.push_back( 20 );  \n   c3.push_back( 100 );  \n  \n   cout << \"The original list c1 is:\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   c1.swap( c2 );  \n  \n   cout << \"After swapping with c2, list c1 is:\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   swap( c1,c3 );  \n  \n   cout << \"After swapping with c3, list c1 is:\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe original list c1 is: 1 2 3  \nAfter swapping with c2, list c1 is: 10 20  \nAfter swapping with c3, list c1 is: 100  \n```  \n  \n##  <a name=\"list__unique\"></a>  list::unique  \n Removes adjacent duplicate elements or adjacent elements that satisfy some other binary predicate from a list.  \n  \n```  \nvoid unique();\n\ntemplate <class BinaryPredicate>  \nvoid unique(BinaryPredicate pred);\n```  \n  \n### Parameters  \n ` pred`  \n The binary predicate used to compare successive elements.  \n  \n### Remarks  \n This function assumes that the list is sorted, so that all duplicate elements are adjacent. Duplicates that are not adjacent will not be deleted.  \n  \n The first member function removes every element that compares equal to its preceding element.  \n  \n The second member function removes every element that satisfies the predicate function ` pred` when compared with its preceding element. You can use any of the binary function objects declared in the `<functional>`header for the argument  pred or you can create your own.  \n  \n### Example  \n  \n```cpp  \n// list_unique.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   list <int> c1;  \n   list <int>::iterator c1_Iter, c2_Iter,c3_Iter;  \n   not_equal_to<int> mypred;  \n  \n   c1.push_back( -10 );  \n   c1.push_back( 10 );  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 20 );  \n   c1.push_back( -10 );  \n  \n   cout << \"The initial list is c1 =\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   list <int> c2 = c1;  \n   c2.unique( );  \n   cout << \"After removing successive duplicate elements, c2 =\";  \n   for ( c2_Iter = c2.begin( ); c2_Iter != c2.end( ); c2_Iter++ )  \n      cout << \" \" << *c2_Iter;  \n   cout << endl;  \n  \n   list <int> c3 = c2;  \n   c3.unique( mypred );  \n   cout << \"After removing successive unequal elements, c3 =\";  \n   for ( c3_Iter = c3.begin( ); c3_Iter != c3.end( ); c3_Iter++ )  \n      cout << \" \" << *c3_Iter;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe initial list is c1 = -10 10 10 20 20 -10  \nAfter removing successive duplicate elements, c2 = -10 10 20 -10  \nAfter removing successive unequal elements, c3 = -10 -10  \n```  \n  \n##  <a name=\"list__value_type\"></a>  list::value_type  \n A type that represents the data type stored in a list.  \n  \n```  \ntypedef typename Allocator::value_type value_type;  \n```  \n  \n### Remarks  \n `value_type` is a synonym for the template parameter **Type**.  \n  \n### Example  \n  \n```cpp  \n// list_value_type.cpp  \n// compile with: /EHsc  \n#include <list>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   list<int>::value_type AnInt;  \n   AnInt = 44;  \n   cout << AnInt << endl;  \n}  \n```  \n  \n```Output  \n44  \n```  \n  \n## See Also  \n [\\<list>](../standard-library/list.md)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)\n\n"}