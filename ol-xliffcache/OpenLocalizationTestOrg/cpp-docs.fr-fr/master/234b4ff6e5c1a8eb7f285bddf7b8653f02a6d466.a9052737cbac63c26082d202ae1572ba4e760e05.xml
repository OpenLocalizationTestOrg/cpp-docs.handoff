{"nodes":[{"pos":[12,67],"content":"try, throw, and catch Statements (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"try, throw, and catch Statements (C++) | Microsoft Docs","pos":[0,55]}]},{"content":"try, throw, and catch Statements (C++)","pos":[1193,1231]},{"pos":[1232,1320],"content":"To implement exception handling in C++, you use <ph id=\"ph1\">`try`</ph>, <ph id=\"ph2\">`throw`</ph>, and <ph id=\"ph3\">`catch`</ph> expressions.","source":"To implement exception handling in C++, you use `try`, `throw`, and `catch` expressions."},{"pos":[1327,1416],"content":"First, use a <ph id=\"ph1\">`try`</ph> block to enclose one or more statements that might throw an exception.","source":"First, use a `try` block to enclose one or more statements that might throw an exception."},{"content":"A <ph id=\"ph1\">`throw`</ph> expression signals that an exceptional condition—often, an error—has occurred in a <ph id=\"ph2\">`try`</ph> block.","pos":[1423,1528],"source":"A `throw` expression signals that an exceptional condition—often, an error—has occurred in a `try` block."},{"content":"You can use an object of any type as the operand of a <ph id=\"ph1\">`throw`</ph> expression.","pos":[1529,1602],"source":" You can use an object of any type as the operand of a `throw` expression."},{"content":"Typically, this object is used to communicate information about the error.","pos":[1603,1677]},{"content":"In most cases, we recommend that you use the <bpt id=\"p1\">[</bpt>std::exception<ept id=\"p1\">](../standard-library/exception-class.md)</ept> class or one of the derived classes that are defined in the standard library.","pos":[1678,1857],"source":" In most cases, we recommend that you use the [std::exception](../standard-library/exception-class.md) class or one of the derived classes that are defined in the standard library."},{"content":"If one of those is not appropriate, we recommend that you derive your own exception class from  <ph id=\"ph1\">`std::exception`</ph>.","pos":[1858,1971],"source":" If one of those is not appropriate, we recommend that you derive your own exception class from  `std::exception`."},{"content":"To handle exceptions that may be thrown, implement one or more <ph id=\"ph1\">`catch`</ph> blocks immediately following a <ph id=\"ph2\">`try`</ph> block.","pos":[1978,2092],"source":"To handle exceptions that may be thrown, implement one or more `catch` blocks immediately following a `try` block."},{"content":"Each <ph id=\"ph1\">`catch`</ph> block specifies the type of exception it can handle.","pos":[2093,2158],"source":" Each `catch` block specifies the type of exception it can handle."},{"content":"This example shows a <ph id=\"ph1\">`try`</ph> block and its handlers.","pos":[2165,2215],"source":"This example shows a `try` block and its handlers."},{"content":"Assume that <ph id=\"ph1\">`GetNetworkResource()`</ph> acquires data over a network connection and that the two exception types are user-defined classes that derive from <ph id=\"ph2\">`std::exception`</ph>.","pos":[2216,2383],"source":" Assume that `GetNetworkResource()` acquires data over a network connection and that the two exception types are user-defined classes that derive from `std::exception`."},{"content":"Notice that the exceptions are caught by <ph id=\"ph1\">`const`</ph> reference in the <ph id=\"ph2\">`catch`</ph> statement.","pos":[2384,2468],"source":" Notice that the exceptions are caught by `const` reference in the `catch` statement."},{"content":"We recommend that you throw exceptions by value and catch them by const reference.","pos":[2469,2551]},{"content":"Example","pos":[2560,2567]},{"content":"Remarks","pos":[3347,3354]},{"content":"The code after the <ph id=\"ph1\">`try`</ph> clause is the guarded section of code.","pos":[3358,3421],"source":"The code after the `try` clause is the guarded section of code."},{"content":"The <ph id=\"ph1\">`throw`</ph> expression <bpt id=\"p1\">*</bpt>throws<ept id=\"p1\">*</ept>—that is, raises—an exception.","pos":[3422,3483],"source":" The `throw` expression *throws*—that is, raises—an exception."},{"content":"The code block after the <ph id=\"ph1\">`catch`</ph> clause is the exception handler.","pos":[3484,3549],"source":" The code block after the `catch` clause is the exception handler."},{"content":"This is the handler that <bpt id=\"p1\">*</bpt>catches<ept id=\"p1\">*</ept> the exception that's thrown if the types in the <ph id=\"ph1\">`throw`</ph> and <ph id=\"ph2\">`catch`</ph> expressions are compatible.","pos":[3550,3680],"source":" This is the handler that *catches* the exception that's thrown if the types in the `throw` and `catch` expressions are compatible."},{"content":"For a list of rules that govern type-matching in <ph id=\"ph1\">`catch`</ph> blocks, see <bpt id=\"p1\">[</bpt>How Catch Blocks are Evaluated<ept id=\"p1\">](../cpp/how-catch-blocks-are-evaluated-cpp.md)</ept>.","pos":[3681,3829],"source":" For a list of rules that govern type-matching in `catch` blocks, see [How Catch Blocks are Evaluated](../cpp/how-catch-blocks-are-evaluated-cpp.md)."},{"content":"If the <ph id=\"ph1\">`catch`</ph> statement specifies an ellipsis (...) instead of a type, the <ph id=\"ph2\">`catch`</ph> block handles every type of exception.","pos":[3830,3952],"source":" If the `catch` statement specifies an ellipsis (...) instead of a type, the `catch` block handles every type of exception."},{"content":"When you compile with the <bpt id=\"p1\">[</bpt>/EHa<ept id=\"p1\">](../build/reference/eh-exception-handling-model.md)</ept> option, these can include C structured exceptions and system-generated or application-generated asynchronous exceptions such as memory protection, divide-by-zero, and floating-point violations.","pos":[3953,4230],"source":" When you compile with the [/EHa](../build/reference/eh-exception-handling-model.md) option, these can include C structured exceptions and system-generated or application-generated asynchronous exceptions such as memory protection, divide-by-zero, and floating-point violations."},{"content":"Because <ph id=\"ph1\">`catch`</ph> blocks are processed in program order to find a matching type, an ellipsis handler must be the last handler for the associated <ph id=\"ph2\">`try`</ph> block.","pos":[4231,4386],"source":" Because `catch` blocks are processed in program order to find a matching type, an ellipsis handler must be the last handler for the associated `try` block."},{"content":"Use <ph id=\"ph1\">`catch(...)`</ph> with caution; do not allow a program to continue unless the catch block knows how to handle the specific exception that is caught.","pos":[4387,4534],"source":" Use `catch(...)` with caution; do not allow a program to continue unless the catch block knows how to handle the specific exception that is caught."},{"content":"Typically, a <ph id=\"ph1\">`catch(...)`</ph> block is used to log errors and perform special cleanup before program execution is stopped.","pos":[4535,4653],"source":" Typically, a `catch(...)` block is used to log errors and perform special cleanup before program execution is stopped."},{"content":"A <ph id=\"ph1\">`throw`</ph> expression that has no operand re-throws the exception currently being handled.","pos":[4660,4749],"source":"A `throw` expression that has no operand re-throws the exception currently being handled."},{"content":"We recommend this form when re-throwing the exception, because this preserves the original exception’s polymorphic type information.","pos":[4750,4882]},{"content":"Such an expression should only be used in a <ph id=\"ph1\">`catch`</ph> handler or in a function that's called from a <ph id=\"ph2\">`catch`</ph> handler.","pos":[4883,4997],"source":" Such an expression should only be used in a `catch` handler or in a function that's called from a `catch` handler."},{"content":"The re-thrown exception object is the original exception object, not a copy.","pos":[4998,5074]},{"content":"See Also","pos":[5356,5364]},{"content":"C++ Exception Handling","pos":[5369,5391]},{"content":"Keywords","pos":[5432,5440]},{"content":"Unhandled C++ Exceptions","pos":[5471,5495]},{"content":"__uncaught_exception","pos":[5538,5558]}],"content":"---\ntitle: \"try, throw, and catch Statements (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"catch_cpp\"\n  - \"throw\"\n  - \"try_cpp\"\n  - \"try\"\n  - \"throw_cpp\"\n  - \"catch\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"catch keyword [C++]\"\n  - \"keywords [C++], exception handling\"\n  - \"C++ exception handling, statement syntax\"\n  - \"try-catch keyword [C++], about try-catch exception handling\"\n  - \"throw keyword [C++]\"\n  - \"try-catch keyword [C++]\"\n  - \"try-catch keyword [C++], exception handling\"\n  - \"throwing exceptions, throw keyword\"\n  - \"try-catch keyword [C++], throw keyword [C++]s\"\n  - \"throwing exceptions, implementing C++ exception handling\"\n  - \"throwing exceptions\"\n  - \"throw keyword [C++], throw() vs. throw(...)\"\nms.assetid: 15e6a87b-b8a5-4032-a7ef-946c644ba12a\ncaps.latest.revision: 24\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# try, throw, and catch Statements (C++)\nTo implement exception handling in C++, you use `try`, `throw`, and `catch` expressions.  \n  \n First, use a `try` block to enclose one or more statements that might throw an exception.  \n  \n A `throw` expression signals that an exceptional condition—often, an error—has occurred in a `try` block. You can use an object of any type as the operand of a `throw` expression. Typically, this object is used to communicate information about the error. In most cases, we recommend that you use the [std::exception](../standard-library/exception-class.md) class or one of the derived classes that are defined in the standard library. If one of those is not appropriate, we recommend that you derive your own exception class from  `std::exception`.  \n  \n To handle exceptions that may be thrown, implement one or more `catch` blocks immediately following a `try` block. Each `catch` block specifies the type of exception it can handle.  \n  \n This example shows a `try` block and its handlers. Assume that `GetNetworkResource()` acquires data over a network connection and that the two exception types are user-defined classes that derive from `std::exception`. Notice that the exceptions are caught by `const` reference in the `catch` statement. We recommend that you throw exceptions by value and catch them by const reference.  \n  \n## Example  \n  \n```  \n  \nMyData md;  \ntry {  \n   // Code that could throw an exception  \n   md = GetNetworkResource();  \n}  \ncatch (const networkIOException& e) {  \n   // Code that executes when an exception of type  \n   // networkIOException is thrown in the try block  \n   // ...  \n   // Log error message in the exception object  \n   cerr << e.what();  \n}  \ncatch (const myDataFormatException& e) {  \n   // Code that handles another exception type  \n   // ...  \n   cerr << e.what();  \n}  \n  \n// The following syntax shows a throw expression  \nMyData GetNetworkResource()  \n{  \n   // ...  \n   if (IOSuccess == false)  \n      throw networkIOException(\"Unable to connect\");  \n   // ...  \n   if (readError)  \n      throw myDataFormatException(\"Format error\");   \n   // ...  \n}  \n```  \n  \n## Remarks  \n The code after the `try` clause is the guarded section of code. The `throw` expression *throws*—that is, raises—an exception. The code block after the `catch` clause is the exception handler. This is the handler that *catches* the exception that's thrown if the types in the `throw` and `catch` expressions are compatible. For a list of rules that govern type-matching in `catch` blocks, see [How Catch Blocks are Evaluated](../cpp/how-catch-blocks-are-evaluated-cpp.md). If the `catch` statement specifies an ellipsis (...) instead of a type, the `catch` block handles every type of exception. When you compile with the [/EHa](../build/reference/eh-exception-handling-model.md) option, these can include C structured exceptions and system-generated or application-generated asynchronous exceptions such as memory protection, divide-by-zero, and floating-point violations. Because `catch` blocks are processed in program order to find a matching type, an ellipsis handler must be the last handler for the associated `try` block. Use `catch(...)` with caution; do not allow a program to continue unless the catch block knows how to handle the specific exception that is caught. Typically, a `catch(...)` block is used to log errors and perform special cleanup before program execution is stopped.  \n  \n A `throw` expression that has no operand re-throws the exception currently being handled. We recommend this form when re-throwing the exception, because this preserves the original exception’s polymorphic type information. Such an expression should only be used in a `catch` handler or in a function that's called from a `catch` handler. The re-thrown exception object is the original exception object, not a copy.  \n  \n```  \ntry {  \n   throw CSomeOtherException();  \n}  \ncatch(...) {  \n   // Catch all exceptions – dangerous!!!  \n   // Respond (perhaps only partially) to the exception, then  \n   // re-throw to pass the exception to some other handler  \n   // ...  \n   throw;  \n}  \n```  \n  \n## See Also  \n [C++ Exception Handling](../cpp/cpp-exception-handling.md)   \n [Keywords](../cpp/keywords-cpp.md)   \n [Unhandled C++ Exceptions](../cpp/unhandled-cpp-exceptions.md)   \n [__uncaught_exception](../c-runtime-library/reference/uncaught-exception.md)"}