<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">19ea7bbbe47cb9217cfcdbfdc71d90b182c3d54e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\parallel\amp\graphics-cpp-amp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">65b57d28111b588ea842ede5c141d3b1c8197c55</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cf76f0d2c36893912997e53d51126db944db7a00</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Graphics (C++ AMP) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Graphics (C++ AMP)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>C++ AMP contains several APIs in the <bpt id="p1">[</bpt>Concurrency::graphics<ept id="p1">](../../parallel/amp/reference/concurrency-graphics-namespace.md)</ept> namespace that you can use to access the texture support on GPUs.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Some common scenarios are:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">[</bpt>texture<ept id="p1">](../../parallel/amp/reference/texture-class.md)</ept> class as a data container for computation and exploit the <bpt id="p2">*</bpt>spatial locality<ept id="p2">*</ept> of the texture cache and layouts of GPU hardware.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Spatial locality is the property of data elements being physically close to each other.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The runtime provides efficient interoperability with non-compute shaders.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Pixel, vertex, tessellation, and hull shaders frequently consume or produce textures that you can use in your C++ AMP computations.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The graphics APIs in C++ AMP provide alternative ways to access sub-word packed buffers.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Textures that have formats that represent <bpt id="p1">*</bpt>texels<ept id="p1">*</ept> (texture elements) that are composed of 8-bit or 16-bit scalars allow access to such packed data storage.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The norm and unorm Types</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`norm`</ph> and <ph id="ph2">`unorm`</ph> types are scalar types that limit the range of <ph id="ph3">`float`</ph> values; this is known as <bpt id="p1">*</bpt>clamping<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>These types can be explicitly constructed from other scalar types.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>In casting, the value is first cast to <ph id="ph1">`float`</ph> and then clamped to the respective region that's allowed by norm [-1.0…1.0] or unorm [0.0…1.0].</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Casting from +/- infinity returns +/-1.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Casting from NaN is undefined.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A norm can be implicitly constructed from a unorm and there is no loss of data.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The implicit conversion operator to float is defined on these types.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Binary operators are defined between these types and other built-in scalar types such as <ph id="ph1">`float`</ph> and <ph id="ph2">`int`</ph>: +, -, *, /, ==, !=, &gt;, <ph id="ph3">\&lt;</ph>, &gt;=, &lt;=.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The compound assignment operators are also supported: +=, -=, <ph id="ph1">\*</ph>=, /=.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The unary negation operator (-) is defined for norm types.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Short Vector Library</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The Short Vector Library provides some of the functionality of the <bpt id="p1">[</bpt>Vector Type<ept id="p1">](http://go.microsoft.com/fwlink/p/linkid=248500)</ept> that's defined in HLSL and is typically used to define texels.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A short vector is a data structure that holds one to four values of the same type.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The supported types are <ph id="ph1">`double`</ph>, <ph id="ph2">`float`</ph>, <ph id="ph3">`int`</ph>, <ph id="ph4">`norm`</ph>, <ph id="ph5">`uint`</ph>, and <ph id="ph6">`unorm`</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The type names are shown in the following table.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For each type, there is also a corresponding <ph id="ph1">`typedef`</ph> that doesn't have an underscore in the name.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The types that have the underscores are in the <bpt id="p1">[</bpt>Concurrency::graphics Namespace<ept id="p1">](../../parallel/amp/reference/concurrency-graphics-namespace.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The types that don't have the underscores are in the <bpt id="p1">[</bpt>Concurrency::graphics::direct3d Namespace<ept id="p1">](../../parallel/amp/reference/concurrency-graphics-direct3d-namespace.md)</ept> so that they are clearly separated from the similarly-named fundamental types such as <ph id="ph1">`__int8`</ph> and <ph id="ph2">`__int16`</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Length 2</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Length 3</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Length 4</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>double</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>double_2</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>double2</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>double_3</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>double3</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>double_4</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>double4</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>float</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>float_2</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>float2</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>float_3</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>float3</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>float_4</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>float4</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>int</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>int_2</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>int2</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>int_3</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>int3</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>int_4</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>int4</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>norm</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>norm_2</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>norm2</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>norm_3</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>norm3</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>norm_4</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>norm4</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>uint</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>uint_2</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>uint2</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>uint_3</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>uint3</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>uint_4</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>uint4</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>unorm</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>unorm_2</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>unorm2</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>unorm_3</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>unorm3</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>unorm_4</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>unorm4</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Operators</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If an operator is defined between two short vectors, then it is also defined between a short vector and a scalar.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Also, one of these must be true:</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The scalar’s type must be the same as the short vector’s element type.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The scalar’s type can be implicitly converted to the vector’s element type by using only one user-defined conversion.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The operation is carried component-wise between each component of the short vector and the scalar.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Here are the valid operators:</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Operator type</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Valid types</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Binary operators</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Valid on all types: +, -, *, /,</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Valid on integer types: %, ^, &amp;#124;, &amp;, &lt;<ph id="ph1">\&lt;</ph>, &gt;&gt;</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The two vectors must have the same size, and the result is a vector of the same size.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Relational operators</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Valid on all types: == and !=</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Compound assignment operator</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Valid on all types: +=, -=, *=, /=</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Valid on integer types: %=, ^=, &amp;#124;=, &amp;=, &lt;<ph id="ph1">\&lt;</ph>=, &gt;&gt;=</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Increment and decrement operators</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Valid on all types: ++, --</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Both prefix and postfix are valid.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Bitwise NOT operator (~)</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Valid on integer types.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Unary - operator</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Valid on all types except <ph id="ph1">`unorm`</ph> and <ph id="ph2">`uint`</ph>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Swizzling Expressions</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The Short Vector Library supports the <ph id="ph1">`vector_type.identifier`</ph> accessor construct to access the components of a short vector.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`identifier`</ph>, which is known as a <bpt id="p1">*</bpt>swizzling expression<ept id="p1">*</ept>, specifies the components of the vector.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The expression can be an l-value or an r-value.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Individual characters in the identifier may be: x, y, z, and w; or r, g, b, and a.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>"x" and "r" mean the zero-th component, "y" and "g" mean the first component, and so on.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>(Notice that "x" and "r" cannot be used in the same identifier.) Therefore, "rgba" and "xyzw" return the same result.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Single-component accessors such as "x" and "y" are scalar value types.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Multi-component accessors are short vector types.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>For example, if you construct an <ph id="ph1">`int_4`</ph> vector that's named <ph id="ph2">`fourInts`</ph> and has the values 2, 4, 6, and 8, then <ph id="ph3">`fourInts.y`</ph> returns the integer 4 and <ph id="ph4">`fourInts.rg`</ph> returns an <ph id="ph5">`int_2`</ph> object that has the values 2 and 4.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Texture Classes</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Many GPUs have hardware and caches that are optimized to fetch pixels and texels and to render images and textures.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>texture<ph id="ph1">\&lt;</ph>T,N&gt;<ept id="p1">](../../parallel/amp/reference/texture-class.md)</ept> class, which is a container class for texel objects, exposes the texture functionality of these GPUs.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>A texel can be:</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`int`</ph>, <ph id="ph2">`uint`</ph>, <ph id="ph3">`float`</ph>, <ph id="ph4">`double`</ph>, <ph id="ph5">`norm`</ph>, or <ph id="ph6">`unorm`</ph> scalar.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>A short vector that has two or four components.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The only exception is <ph id="ph1">`double_4`</ph>, which is not allowed.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`texture`</ph> object can have a rank of 1, 2, or 3.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`texture`</ph> object can be captured only by reference in the lambda of a call to <ph id="ph2">`parallel_for_each`</ph>.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The texture is stored on the GPU as Direct3D texture objects.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>For more information about textures and texels in Direct3D, see <bpt id="p1">[</bpt>Introduction to Textures in Direct3D 11<ept id="p1">](http://go.microsoft.com/fwlink/p/linkid=248502)</ept>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The texel type you use might be one of the many texture formats that are used in graphics programming.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For example, an RGBA format could use 32 bits, with 8 bits each for the R, G, B, and A scalar elements.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The texture hardware of a graphics card can access the individual elements based on the format.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For example, if you are using the RGBA format, the texture hardware can extract each 8-bit element into a 32-bit form.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>In C++ AMP, you can set the bits per scalar element of your texel so that you can automatically access the individual scalar elements in the code without using bit-shifting.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Instantiating Texture Objects</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>You can declare a texture object without initialization.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The following code example declares several texture objects.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>You can also use a constructor to declare and initialize a <ph id="ph1">`texture`</ph> object.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The following code example instantiates a <ph id="ph1">`texture`</ph> object from a vector of <ph id="ph2">`float_4`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The bits per scalar element is set to the default.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>You cannot use this constructor with <ph id="ph1">`norm`</ph>, <ph id="ph2">`unorm`</ph>, or the short vectors of <ph id="ph3">`norm`</ph> and <ph id="ph4">`unorm`</ph>, because they do not have a default bits per scalar element.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>You can also declare and initialize a <ph id="ph1">`texture`</ph> object by using a constructor overload that takes a pointer to the source data, the size of source data in bytes, and the bits per scalar element.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The textures in these examples are created on the default view of the default accelerator.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>You can use other overloads of the constructor if you want to specify an <ph id="ph1">`accelerator_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>You cannot create a texture object on a CPU accelerator.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>There are limits on the size of each dimension of the <ph id="ph1">`texture`</ph> object, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>A run-time error is generated if you exceed the limits.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Texture</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Size limitation</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>texture<ph id="ph1">\&lt;</ph>T,1&gt;</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>16384</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>texture<ph id="ph1">\&lt;</ph>T,2&gt;</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>16384</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>texture<ph id="ph1">\&lt;</ph>T,2&gt;</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>2048</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Reading from Texture Objects</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>You can read from a <ph id="ph1">`texture`</ph> object by using <bpt id="p1">[</bpt>texture::operator<ph id="ph2">\[\]</ph><ept id="p1">](reference/texture-class.md#texture__operator_at)</ept>, <bpt id="p2">[</bpt>texture::operator() Operator<ept id="p2">](reference/texture-class.md#texture__operator_call)</ept>, or <bpt id="p3">[</bpt>texture::get Method<ept id="p3">](reference/texture-class.md#get)</ept>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The two operators return a value, not a reference.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Therefore, you cannot write to a <ph id="ph1">`texture`</ph> object by using <ph id="ph2">`texture::operator\[\]`</ph>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following code example demonstrates how to store texture channels in a short vector, and then access the individual scalar elements as properties of the short vector.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The following table lists the valid bits per channel for each sort vector type.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Texture data type</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Valid bits per scalar element</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>int, int_2, int_4</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>uint, uint_2, uint_4</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>8, 16, 32</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>int_3, uint_3</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>float, float_2, float_4</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>16, 32</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>float_3</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>32</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>double, double_2</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>64</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>norm, norm_2, norm_4</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>unorm, unorm_2, unorm, 4</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>8, 16</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Writing to Texture Objects</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>texture::set<ept id="p1">](reference/texture-class.md#set)</ept> method to write to <ph id="ph1">`texture`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>A texture object can be readonly or read/write.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For a texture object to be readable and writeable, the following conditions must be true:</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>T has only one scalar component.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>(Short vectors are not allowed.)</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>T is not <ph id="ph1">`double`</ph>, <ph id="ph2">`norm`</ph>, or <ph id="ph3">`unorm`</ph>.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`texture::bits_per_scalar_element`</ph> property is 32.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>If all three are not true, then the <ph id="ph1">`texture`</ph> object is readonly.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The first two conditions are checked during compilation.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>A compilation error is generated if you have code that tries to write to a <ph id="ph1">`readonly`</ph> texture object.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The condition for <ph id="ph1">`texture::bits_per_scalar_element`</ph> is detected at run time, and the runtime generates the <bpt id="p1">[</bpt>unsupported_feature<ept id="p1">](../../parallel/amp/reference/unsupported-feature-class.md)</ept> exception if you try to write to a readonly <ph id="ph2">`texture`</ph> object.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following code example writes values to a texture object.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Copying Texture Objects</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>You can copy between texture objects by using the <bpt id="p1">[</bpt>copy<ept id="p1">](reference/concurrency-namespace-functions-amp.md#copy)</ept> function or the <bpt id="p2">[</bpt>copy_async<ept id="p2">](reference/concurrency-namespace-functions-amp.md#copy_async)</ept> function, as shown in the following code example.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>You can also copy from one texture to another by using the <bpt id="p1">[</bpt>texture::copy_to<ept id="p1">](reference/texture-class.md#copy_to)</ept> method.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The two textures can be on different accelerator_views.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>When you copy to a <ph id="ph1">`writeonly_texture_view`</ph> object, the data is copied to the underlying <ph id="ph2">`texture`</ph> object.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The bits per scalar element and the extent must be the same on the source and destination <ph id="ph1">`texture`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>If those requirements are not met, the runtime throws an exception.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Texture View Classes</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>C++ AMP introduces the <bpt id="p1">[</bpt>texture_view Class<ept id="p1">](../../parallel/amp/reference/texture-view-class.md)</ept> in <ph id="ph1">[!INCLUDE[vs_dev12](../../atl-mfc-shared/includes/vs_dev12_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Texture views support the same texel types and ranks as the <bpt id="p1">[</bpt>texture Class<ept id="p1">](../../parallel/amp/reference/texture-class.md)</ept>, but unlike textures, they provide access to additional hardware features such as texture sampling and mipmaps.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Texture views support read-only, write-only, and read-write access to the underlying texture data.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Read-only access is provided by the <ph id="ph1">`texture_view&lt;const T, N&gt;`</ph> template specialization, which supports elements that have 1, 2, or 4 components, texture sampling, and dynamic access to a range of mipmap levels that are determined when the view is instantiated.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Write-only access is provided by the non-specialized template class <ph id="ph1">`texture_view&lt;T, N&gt;`</ph>, which supports elements that have either 2 or 4 components and can access one mipmap level that's determined when the view is instantiated.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>It does not support sampling.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Read-write access is provided by the non-specialized template class <ph id="ph1">`texture_view&lt;T, N&gt;`</ph>, which, like textures, supports elements that have only one component; the view can access one mipmap level that's determined when it is instantiated.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>It does not support sampling.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Texture views are analogous to array views, but do not provide the automatic data management and movement functionality that the <bpt id="p1">[</bpt>array_view Class<ept id="p1">](../../parallel/amp/reference/array-view-class.md)</ept> provides over the <bpt id="p2">[</bpt>array class<ept id="p2">](../../parallel/amp/reference/array-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`texture_view`</ph> can only be accessed on the accelerator view where the underlying texture data resides.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>writeonly_texture_view Deprecated</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>For <ph id="ph1">[!INCLUDE[vs_dev12](../../atl-mfc-shared/includes/vs_dev12_md.md)]</ph>, C++ AMP introduces better support for hardware texture features such as sampling and mipmaps, which could not be supported by the <bpt id="p1">[</bpt>writeonly_texture_view Class<ept id="p1">](../../parallel/amp/reference/writeonly-texture-view-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The newly introduced <ph id="ph1">`texture_view`</ph> class supports a superset of the functionality in <ph id="ph2">`writeonly_texture_view`</ph>; as a result, <ph id="ph3">`writeonly_texture_view`</ph> is deprecated.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>We recommend—at least for new code—that you use <ph id="ph1">`texture_view`</ph> to access functionality that was formerly provided by <ph id="ph2">`writeonly_texture_view`</ph>.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Compare the following two code examples that write to a texture object that has two components (int_2).</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Notice that in both cases, the view, <ph id="ph1">`wo_tv4`</ph>, must be captured by value in the lambda expression.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Here is the example that uses the new <ph id="ph1">`texture_view`</ph> class:</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>And here is the deprecated <ph id="ph1">`writeonly_texture_view`</ph> class:</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>As you can see, the two code examples are nearly identical when all you are doing is writing to the primary mipmap level.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>If you used <ph id="ph1">`writeonly_texture_view`</ph> in existing code and you're not planning to enhance that code, you don't have to change it.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>However, if you're thinking about bringing that code forward, we suggest that you rewrite it to use <ph id="ph1">`texture_view`</ph> because the enhancements in it support new hardware texture features.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Read on for more information about these new capabilities.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>For more information about the deprecation of <ph id="ph1">`writeonly_texture_view`</ph>, see <bpt id="p1">[</bpt>Overview of the Texture View Design in C++ AMP<ept id="p1">](http://blogs.msdn.com/b/nativeconcurrency/archive/2013/07/25/overview-of-the-texture-view-design-in-c-amp.aspx)</ept> on the Parallel Programming in Native Code blog.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Instantiating Texture View Objects</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Declaring a <ph id="ph1">`texture_view`</ph> is similar to declaring an <ph id="ph2">`array_view`</ph> that's associated with an <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The following code example declares several <ph id="ph1">`texture`</ph> objects and <ph id="ph2">`texture_view`</ph> objects that are associated with them.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Notice how a texture view whose element type is non-const and has one component is read-write, but a texture view whose element type is non-const but has more than one componenent are write-only.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Texture views of const element types are always read-only, but if the element type is non-const, then the number of components in the element determines whether it is read-write (1 component) or write-only (multiple components).</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The element type of a <ph id="ph1">`texture_view`</ph>—its const-ness and also the number of components it has—also plays a role in determining whether the view supports texture sampling, and how mipmap levels can be accessed:</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Components</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Read</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Write</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Sampling</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Mipmap access</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>texture_view<ph id="ph1">\&lt;</ph>const T, N&gt;</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>1, 2, 4</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>No (1)</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Yes, indexable.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Range is determined at instantiation.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Texture_view<ph id="ph1">\&lt;</ph>T, N&gt;</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>2, 4</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>No (2)</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>No (1)</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>No (1)</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Yes, one level.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Level is determined at instantiation.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Yes, one level.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Level is determined at instantiation.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>From this table, you can see that read-only texture views fully support the new capabilities in exchange for not being able to write to the view.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Writable texture views are limited in that they can only access one mipmap level.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Read-write texture views are even more specialized than writable ones, because they add the requirement that the element type of the texture view has only one component.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Notice that sampling is not supported for writable texture views because it's a read-oriented operation.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Reading from Texture View Objects</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Reading unsampled texture data through a texture view is just like reading it from the texture itself, except that textures are captured by reference, whereas texture views are captured by value.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The following two code examples demonstrate; first, by using <ph id="ph1">`texture`</ph> only:</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>And here is the same example, except it now uses the <ph id="ph1">`texture_view`</ph> class:</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Texture views whose elements are based on floating-point types—for example, float, float_2, or float_4—can also be read by using texture sampling to take advantage of hardware support for various filtering modes and addressing modes.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>C++ AMP supports the two filtering modes that are most common in compute scenarios—point-filtering (nearest-neighbor) and linear-filtering (weighted average)—and four addressing modes—wrapped, mirrored, clamped, and border.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>For more information about addressing modes, see <bpt id="p1">[</bpt>address_mode Enumeration<ept id="p1">](reference/concurrency-graphics-namespace-enums.md#address_mode)</ept>.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>In addition to modes that C++ AMP supports directly, you can access other filtering modes and addressing modes of the underlying platform by using the interop APIs to adopt a texture sampler that was created by using the platform APIs directly.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>For example, Direct3D supports other filtering modes such as anisotropic filtering, and can apply a different addressing mode to each dimension of a texture.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>You could create a texture sampler whose coordinates are wrapped vertically, mirrored horizontally, and sampled with anisotropic filtering by using the Direct3D APIs, and then leverage the sampler in your C++ AMP code by using the <ph id="ph1">`make_sampler`</ph> interop API.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>For more information see <bpt id="p1">[</bpt>Texture Sampling in C++ AMP<ept id="p1">](http://blogs.msdn.com/b/nativeconcurrency/archive/2013/07/18/texture-sampling-in-c-amp.aspx)</ept> on the Parallel Programming in Native Code blog.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Texture views also support the reading of mipmaps.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Read-only texture views (those that have a const element type) offer the most flexibility because a range of mip-levels that is determined at instantiation can be dynamically sampled, and because elements that have 1, 2, or 4 components are supported.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Read-write texture views that have elements that have one component also support mipmaps, but only of a level that's determined at instantiation.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Texture with Mipmaps<ept id="p1">](http://blogs.msdn.com/b/nativeconcurrency/archive/2013/08/22/texture-with-mipmaps.aspx)</ept> on the Parallel Programming in Native Code blog.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Writing to Texture View Objects</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>texture_view::get Method<ept id="p1">](reference/texture-view-class.md#get)</ept> to write to the underlying <ph id="ph1">`texture`</ph> through the <ph id="ph2">`texture_view`</ph> object.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>A texture view can be read-only, read-write, or write-only.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>For a texture view to be writable it must have an element type that is non-const; for a texture view to be readable and writable, its element type must also have only one component.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Otherwise, the texture view is read-only.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>You can only access one mipmap level of a texture at a time through a texture view, and the level is specified when the view is instantiated.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>This example shows how to write to the second-most detailed mipmap level of a texture that has 4 mipmap levels.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>The most detailed mipmap level is level 0.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The C++ AMP runtime supports interoperability between <ph id="ph1">`texture&lt;T,1&gt;`</ph> and the <bpt id="p1">[</bpt>ID3D11Texture1D interface<ept id="p1">](http://go.microsoft.com/fwlink/p/LinkId=248503)</ept>, between <ph id="ph2">`texture&lt;T,2&gt;`</ph> and the <bpt id="p2">[</bpt>ID3D11Texture2D interface<ept id="p2">](http://go.microsoft.com/fwlink/p/LinkId=255317)</ept>, and between <ph id="ph3">`texture&lt;T,3&gt;`</ph> and the <bpt id="p3">[</bpt>ID3D11Texture3D interface<ept id="p3">](http://go.microsoft.com/fwlink/p/LinkId=255377)</ept>.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>get_texture<ept id="p1">](reference/concurrency-graphics-direct3d-namespace-functions.md#get_texture_function)</ept> method takes a <ph id="ph1">`texture`</ph> object and returns an <ph id="ph2">`IUnknown`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>make_texture<ept id="p1">](reference/concurrency-graphics-direct3d-namespace-functions.md#make_texture_function)</ept> method takes an <ph id="ph1">`IUnknown`</ph> interface and an <ph id="ph2">`accelerator_view`</ph> object and returns a <ph id="ph3">`texture`</ph> object.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>double_2 Class</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>double_3 Class</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>double_4 Class</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>float_2 Class</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>float_3 Class</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>float_4 Class</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>int_2 Class</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>int_3 Class</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>int_4 Class</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>norm_2 Class</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>norm_3 Class</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>norm_4 Class</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>short_vector Structure</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>short_vector_traits Structure</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>uint_2 Class</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>uint_3 Class</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>uint_4 Class</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>unorm_2 Class</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>unorm_3 Class</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>unorm_4 Class</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>