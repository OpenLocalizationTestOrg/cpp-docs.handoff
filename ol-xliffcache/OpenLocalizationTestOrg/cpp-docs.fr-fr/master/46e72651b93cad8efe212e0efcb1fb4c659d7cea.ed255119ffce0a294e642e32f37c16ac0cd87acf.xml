{"nodes":[{"pos":[12,62],"content":"TN011: Using MFC as Part of a DLL | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN011: Using MFC as Part of a DLL | Microsoft Docs","pos":[0,50]}]},{"content":"TN011: Using MFC as Part of a DLL","pos":[738,771]},{"content":"This note describes regular DLLs, which allow you to use the MFC library as part of a Windows dynamic-link library (DLL).","pos":[772,893]},{"content":"It assumes that you are familiar with Windows DLLs and how to build them.","pos":[894,967]},{"content":"For information about MFC extension DLLs, with which you can create extensions to the MFC library, see <bpt id=\"p1\">[</bpt>DLL Version of MFC<ept id=\"p1\">](../mfc/tn033-dll-version-of-mfc.md)</ept>.","pos":[968,1128],"source":" For information about MFC extension DLLs, with which you can create extensions to the MFC library, see [DLL Version of MFC](../mfc/tn033-dll-version-of-mfc.md)."},{"content":"DLL Interfaces","pos":[1137,1151]},{"content":"Regular DLLs assume interfaces between the application and the DLL are specified in C-like functions or explicitly exported classes.","pos":[1155,1287]},{"content":"MFC class interfaces cannot be exported.","pos":[1288,1328]},{"content":"If both a DLL and an application want to use MFC, both have a choice to either use the shared version of the MFC libraries or to statically link to a copy of the libraries.","pos":[1335,1507]},{"content":"The application and DLL may both use one of the standard versions of the MFC library.","pos":[1508,1593]},{"content":"Regular DLLs have several advantages:","pos":[1600,1637]},{"content":"The application that uses the DLL does not have to use MFC and does not have to be a Visual C++ application.","pos":[1647,1755]},{"content":"With regular DLLs that statically link to MFC, the size of the DLL depends only on the MFC and C runtime routines that are used and linked.","pos":[1765,1904]},{"content":"With regular DLLs that dynamically link to MFC, the savings in memory from using the shared version of MFC can be significant.","pos":[1914,2040]},{"content":"However, you must distribute the shared DLLs, Mfc<bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\&lt;</ph>version&gt;<ept id=\"p1\">*</ept>.dll and Msvvcrt<bpt id=\"p2\">*</bpt><ph id=\"ph2\">\\&lt;</ph>version&gt;<ept id=\"p2\">*</ept>.dll, with your DLL.","pos":[2041,2150],"source":" However, you must distribute the shared DLLs, Mfc*\\<version>*.dll and Msvvcrt*\\<version>*.dll, with your DLL."},{"content":"The DLL design is independent of how classes are implemented.","pos":[2160,2221]},{"content":"Your DLL design exports only to the APIs you want.","pos":[2222,2272]},{"content":"As a result, if the implementation changes, regular DLLs are still valid.","pos":[2273,2346]},{"content":"With regular DLLs that statically link to MFC, if both DLL and application use MFC, there are no problems with the application that wants a different version of MFC than the DLL or vice versa.","pos":[2356,2548]},{"content":"Because the MFC library is statically linked into each DLL or EXE, there is no question about which version you have.","pos":[2549,2666]},{"content":"API Limitations","pos":[2675,2690]},{"content":"Some MFC functionality does not apply to the DLL version, either because of technical limitations or because those services are usually provided by the application.","pos":[2694,2858]},{"content":"With the current version of MFC, the only function that is not applicable is <ph id=\"ph1\">`CWinApp::SetDialogBkColor`</ph>.","pos":[2859,2964],"source":" With the current version of MFC, the only function that is not applicable is `CWinApp::SetDialogBkColor`."},{"content":"Building Your DLL","pos":[2973,2990]},{"content":"When compiling regular DLLs that statically link to MFC, the symbols <ph id=\"ph1\">`_USRDLL`</ph> and <ph id=\"ph2\">`_WINDLL`</ph> must be defined.","pos":[2994,3103],"source":"When compiling regular DLLs that statically link to MFC, the symbols `_USRDLL` and `_WINDLL` must be defined."},{"content":"Your DLL code must also be compiled with the following compiler switches:","pos":[3104,3177]},{"pos":[3185,3237],"content":"<bpt id=\"p1\">**</bpt>/D_WINDLL<ept id=\"p1\">**</ept> signifies the compilation is for a DLL","source":"**/D_WINDLL** signifies the compilation is for a DLL"},{"pos":[3245,3299],"content":"<bpt id=\"p1\">**</bpt>/D_USRDLL<ept id=\"p1\">**</ept> specifies you are building a regular DLL","source":"**/D_USRDLL** specifies you are building a regular DLL"},{"content":"You must also define these symbols and use these compiler switches when you compile regular DLLs that dynamically link to MFC.","pos":[3306,3432]},{"content":"Additionally, the symbol <ph id=\"ph1\">`_AFXDLL`</ph> must be defined and your DLL code must be compiled with:","pos":[3433,3524],"source":" Additionally, the symbol `_AFXDLL` must be defined and your DLL code must be compiled with:"},{"pos":[3532,3621],"content":"<bpt id=\"p1\">**</bpt>/D_AFXDLL<ept id=\"p1\">**</ept> specifies that you are building a regular DLL that dynamically links to MFC","source":"**/D_AFXDLL** specifies that you are building a regular DLL that dynamically links to MFC"},{"content":"The interfaces (APIs) between the application and the DLL must be explicitly exported.","pos":[3628,3714]},{"content":"We recommend that you define your interfaces to be low bandwidth, and use only C interfaces if you can.","pos":[3715,3818]},{"content":"Direct C interfaces are easier to maintain than more complex C++ classes.","pos":[3819,3892]},{"content":"Place your APIs in a separate header that can be included by both C and C++ files.","pos":[3899,3981]},{"content":"See the header ScreenCap.h in the MFC Advanced Concepts sample <bpt id=\"p1\">[</bpt>DLLScreenCap<ept id=\"p1\">](../visual-cpp-samples.md)</ept> for an example.","pos":[3982,4101],"source":" See the header ScreenCap.h in the MFC Advanced Concepts sample [DLLScreenCap](../visual-cpp-samples.md) for an example."},{"content":"To export your functions, enter them in the <ph id=\"ph1\">`EXPORTS`</ph> section of your module definition file (.DEF) or include <ph id=\"ph2\">`__declspec(dllexport)`</ph> on your function definitions.","pos":[4102,4266],"source":" To export your functions, enter them in the `EXPORTS` section of your module definition file (.DEF) or include `__declspec(dllexport)` on your function definitions."},{"content":"Use <ph id=\"ph1\">`__declspec(dllimport)`</ph> to import these functions into the client executable.","pos":[4267,4348],"source":" Use `__declspec(dllimport)` to import these functions into the client executable."},{"content":"You must add the <ph id=\"ph1\">`AFX_MANAGE_STATE`</ph> macro at the beginning of all the exported functions in regular DLLs that dynamically link to MFC.","pos":[4355,4489],"source":"You must add the `AFX_MANAGE_STATE` macro at the beginning of all the exported functions in regular DLLs that dynamically link to MFC."},{"content":"This macro sets the current module state to the one for the DLL.","pos":[4490,4554]},{"content":"To use this macro, add the following line of code to the beginning of functions exported from the DLL:","pos":[4555,4657]},{"content":"WinMain -&gt; DllMain","pos":[4719,4737],"source":"WinMain -> DllMain"},{"content":"The MFC library defines the standard Win32 <ph id=\"ph1\">`DllMain`</ph> entry point that initializes your <bpt id=\"p1\">[</bpt>CWinApp<ept id=\"p1\">](../mfc/reference/cwinapp-class.md)</ept> derived object as in a typical MFC application.","pos":[4741,4920],"source":"The MFC library defines the standard Win32 `DllMain` entry point that initializes your [CWinApp](../mfc/reference/cwinapp-class.md) derived object as in a typical MFC application."},{"content":"Place all DLL-specific initialization in the <bpt id=\"p1\">[</bpt>InitInstance<ept id=\"p1\">](../mfc/reference/cwinapp-class.md#cwinapp__initinstance)</ept> method as in a typical MFC application.","pos":[4921,5077],"source":" Place all DLL-specific initialization in the [InitInstance](../mfc/reference/cwinapp-class.md#cwinapp__initinstance) method as in a typical MFC application."},{"content":"Note that the <bpt id=\"p1\">[</bpt>CWinApp::Run<ept id=\"p1\">](../mfc/reference/cwinapp-class.md#cwinapp__run)</ept> mechanism does not apply to a DLL, because the application owns the main message pump.","pos":[5084,5247],"source":"Note that the [CWinApp::Run](../mfc/reference/cwinapp-class.md#cwinapp__run) mechanism does not apply to a DLL, because the application owns the main message pump."},{"content":"If your DLL displays modeless dialogs or has a main frame window of its own, your application's main message pump must call a DLL-exported routine that calls <bpt id=\"p1\">[</bpt>CWinApp::PreTranslateMessage<ept id=\"p1\">](../mfc/reference/cwinapp-class.md#cwinapp__pretranslatemessage)</ept>.","pos":[5248,5501],"source":" If your DLL displays modeless dialogs or has a main frame window of its own, your application's main message pump must call a DLL-exported routine that calls [CWinApp::PreTranslateMessage](../mfc/reference/cwinapp-class.md#cwinapp__pretranslatemessage)."},{"content":"See the DLLScreenCap sample for use of this function.","pos":[5508,5561]},{"pos":[5568,5783],"content":"The <ph id=\"ph1\">`DllMain`</ph> function that MFC provides will call the <bpt id=\"p1\">[</bpt>CWinApp::ExitInstance<ept id=\"p1\">](../mfc/reference/cwinapp-class.md#cwinapp__exitinstance)</ept> method of your class that is derived from <ph id=\"ph2\">`CWinApp`</ph> before the DLL is unloaded.","source":"The `DllMain` function that MFC provides will call the [CWinApp::ExitInstance](../mfc/reference/cwinapp-class.md#cwinapp__exitinstance) method of your class that is derived from `CWinApp` before the DLL is unloaded."},{"content":"Linking Your DLL","pos":[5792,5808]},{"content":"With regular DLLs that statically link to MFC, you must link your DLL with Nafxcwd.lib or Nafxcw.lib and with the version of the C runtimes named Libcmt.lib.","pos":[5812,5969]},{"content":"These libraries are pre-built and may be installed by specifying them when you run Visual C++ setup.","pos":[5970,6070]},{"content":"Sample Code","pos":[6079,6090]},{"content":"See the MFC Advanced Concepts sample program DLLScreenCap for a complete sample.","pos":[6094,6174]},{"content":"Several interesting things to note in this sample are as follows:","pos":[6175,6240]},{"content":"The compiler flags of the DLL and those of the application are different.","pos":[6250,6323]},{"content":"The link lines and .DEF files for the DLL and those for the application are different.","pos":[6333,6419]},{"content":"The application that uses the DLL does not have to be in C++.","pos":[6429,6490]},{"content":"The interface between the application and the DLL is an API that is usable by C or C++ and is exported with DLLScreenCap.def.","pos":[6500,6625]},{"content":"The following example illustrates an API that is defined in a regular DLL that statically links to MFC.","pos":[6632,6735]},{"content":"In this example, the declaration is enclosed in an <ph id=\"ph1\">`extern \"C\" { }`</ph> block for C++ users.","pos":[6736,6824],"source":" In this example, the declaration is enclosed in an `extern \"C\" { }` block for C++ users."},{"content":"This has several advantages.","pos":[6825,6853]},{"content":"First, it makes your DLL APIs usable by non-C++ client applications.","pos":[6854,6922]},{"content":"Second, it reduces DLL overhead because C++ name mangling will not be applied to the exported name.","pos":[6923,7022]},{"content":"Lastly, it makes it easier to explicitly add to a .DEF file (for exporting by ordinal) without having to worry about name mangling.","pos":[7023,7154]},{"content":"The structures used by the API are not derived from MFC classes and are defined in the API header.","pos":[7396,7494]},{"content":"This reduces the complexity of the interface between the DLL and the application and makes the DLL usable by C programs.","pos":[7495,7615]},{"content":"See Also","pos":[7624,7632]},{"content":"Technical Notes by Number","pos":[7637,7662]},{"content":"Technical Notes by Category","pos":[7706,7733]}],"content":"---\ntitle: \"TN011: Using MFC as Part of a DLL | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mfc.dll\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"_USRDLL symbol\"\n  - \"USRDLLs, compiler switches\"\n  - \"TN011\"\n  - \"DLLs [C++], linking\"\n  - \"MFC DLLs [C++], linking regular DLLs to MFC\"\nms.assetid: 76753e9c-59dc-40f6-b6a7-f6bb9a7c4190\ncaps.latest.revision: 20\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN011: Using MFC as Part of a DLL\nThis note describes regular DLLs, which allow you to use the MFC library as part of a Windows dynamic-link library (DLL). It assumes that you are familiar with Windows DLLs and how to build them. For information about MFC extension DLLs, with which you can create extensions to the MFC library, see [DLL Version of MFC](../mfc/tn033-dll-version-of-mfc.md).  \n  \n## DLL Interfaces  \n Regular DLLs assume interfaces between the application and the DLL are specified in C-like functions or explicitly exported classes. MFC class interfaces cannot be exported.  \n  \n If both a DLL and an application want to use MFC, both have a choice to either use the shared version of the MFC libraries or to statically link to a copy of the libraries. The application and DLL may both use one of the standard versions of the MFC library.  \n  \n Regular DLLs have several advantages:  \n  \n-   The application that uses the DLL does not have to use MFC and does not have to be a Visual C++ application.  \n  \n-   With regular DLLs that statically link to MFC, the size of the DLL depends only on the MFC and C runtime routines that are used and linked.  \n  \n-   With regular DLLs that dynamically link to MFC, the savings in memory from using the shared version of MFC can be significant. However, you must distribute the shared DLLs, Mfc*\\<version>*.dll and Msvvcrt*\\<version>*.dll, with your DLL.  \n  \n-   The DLL design is independent of how classes are implemented. Your DLL design exports only to the APIs you want. As a result, if the implementation changes, regular DLLs are still valid.  \n  \n-   With regular DLLs that statically link to MFC, if both DLL and application use MFC, there are no problems with the application that wants a different version of MFC than the DLL or vice versa. Because the MFC library is statically linked into each DLL or EXE, there is no question about which version you have.  \n  \n## API Limitations  \n Some MFC functionality does not apply to the DLL version, either because of technical limitations or because those services are usually provided by the application. With the current version of MFC, the only function that is not applicable is `CWinApp::SetDialogBkColor`.  \n  \n## Building Your DLL  \n When compiling regular DLLs that statically link to MFC, the symbols `_USRDLL` and `_WINDLL` must be defined. Your DLL code must also be compiled with the following compiler switches:  \n  \n- **/D_WINDLL** signifies the compilation is for a DLL  \n  \n- **/D_USRDLL** specifies you are building a regular DLL  \n  \n You must also define these symbols and use these compiler switches when you compile regular DLLs that dynamically link to MFC. Additionally, the symbol `_AFXDLL` must be defined and your DLL code must be compiled with:  \n  \n- **/D_AFXDLL** specifies that you are building a regular DLL that dynamically links to MFC  \n  \n The interfaces (APIs) between the application and the DLL must be explicitly exported. We recommend that you define your interfaces to be low bandwidth, and use only C interfaces if you can. Direct C interfaces are easier to maintain than more complex C++ classes.  \n  \n Place your APIs in a separate header that can be included by both C and C++ files. See the header ScreenCap.h in the MFC Advanced Concepts sample [DLLScreenCap](../visual-cpp-samples.md) for an example. To export your functions, enter them in the `EXPORTS` section of your module definition file (.DEF) or include `__declspec(dllexport)` on your function definitions. Use `__declspec(dllimport)` to import these functions into the client executable.  \n  \n You must add the `AFX_MANAGE_STATE` macro at the beginning of all the exported functions in regular DLLs that dynamically link to MFC. This macro sets the current module state to the one for the DLL. To use this macro, add the following line of code to the beginning of functions exported from the DLL:  \n  \n `AFX_MANAGE_STATE(AfxGetStaticModuleState( ))`  \n  \n## WinMain -> DllMain  \n The MFC library defines the standard Win32 `DllMain` entry point that initializes your [CWinApp](../mfc/reference/cwinapp-class.md) derived object as in a typical MFC application. Place all DLL-specific initialization in the [InitInstance](../mfc/reference/cwinapp-class.md#cwinapp__initinstance) method as in a typical MFC application.  \n  \n Note that the [CWinApp::Run](../mfc/reference/cwinapp-class.md#cwinapp__run) mechanism does not apply to a DLL, because the application owns the main message pump. If your DLL displays modeless dialogs or has a main frame window of its own, your application's main message pump must call a DLL-exported routine that calls [CWinApp::PreTranslateMessage](../mfc/reference/cwinapp-class.md#cwinapp__pretranslatemessage).  \n  \n See the DLLScreenCap sample for use of this function.  \n  \n The `DllMain` function that MFC provides will call the [CWinApp::ExitInstance](../mfc/reference/cwinapp-class.md#cwinapp__exitinstance) method of your class that is derived from `CWinApp` before the DLL is unloaded.  \n  \n## Linking Your DLL  \n With regular DLLs that statically link to MFC, you must link your DLL with Nafxcwd.lib or Nafxcw.lib and with the version of the C runtimes named Libcmt.lib. These libraries are pre-built and may be installed by specifying them when you run Visual C++ setup.  \n  \n## Sample Code  \n See the MFC Advanced Concepts sample program DLLScreenCap for a complete sample. Several interesting things to note in this sample are as follows:  \n  \n-   The compiler flags of the DLL and those of the application are different.  \n  \n-   The link lines and .DEF files for the DLL and those for the application are different.  \n  \n-   The application that uses the DLL does not have to be in C++.  \n  \n-   The interface between the application and the DLL is an API that is usable by C or C++ and is exported with DLLScreenCap.def.  \n  \n The following example illustrates an API that is defined in a regular DLL that statically links to MFC. In this example, the declaration is enclosed in an `extern \"C\" { }` block for C++ users. This has several advantages. First, it makes your DLL APIs usable by non-C++ client applications. Second, it reduces DLL overhead because C++ name mangling will not be applied to the exported name. Lastly, it makes it easier to explicitly add to a .DEF file (for exporting by ordinal) without having to worry about name mangling.  \n  \n```  \n#ifdef __cplusplus  \nextern \"C\" {  \n#endif  /* __cplusplus */  \n \nstruct TracerData  \n{  \n    BOOL bEnabled;  \n    UINT flags;  \n};  \n \nBOOL PromptTraceFlags(TracerData FAR* lpData);\n\n \n#ifdef __cplusplus  \n}  \n#endif  \n```  \n  \n The structures used by the API are not derived from MFC classes and are defined in the API header. This reduces the complexity of the interface between the DLL and the application and makes the DLL usable by C programs.  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}