{"nodes":[{"pos":[12,72],"content":"How to: Define and consume enums in C++-CLI | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Define and consume enums in C++-CLI | Microsoft Docs","pos":[0,60]}]},{"content":"How to: Define and consume enums in C++/CLI","pos":[647,690]},{"content":"This topic discusses enums in C++/CLI.","pos":[691,729]},{"content":"Specifying the underlying type of an enum","pos":[738,779]},{"content":"By default, the underlying type of an enumeration is <ph id=\"ph1\">`int`</ph>.","pos":[783,842],"source":"By default, the underlying type of an enumeration is `int`."},{"content":"However, you can specify the type to be signed or unsigned forms of <ph id=\"ph1\">`int`</ph>, <ph id=\"ph2\">`short`</ph>, <ph id=\"ph3\">`long`</ph>, <ph id=\"ph4\">`__int32`</ph>, or <ph id=\"ph5\">`__int64`</ph>.","pos":[844,960],"source":"  However, you can specify the type to be signed or unsigned forms of `int`, `short`, `long`, `__int32`, or `__int64`."},{"content":"You can also use <ph id=\"ph1\">`char`</ph>.","pos":[962,986],"source":"  You can also use `char`."},{"content":"Output","pos":[1497,1503]},{"content":"How to convert between managed and standard enumerations","pos":[1553,1609]},{"content":"There is no standard conversion between an enum and an integral type; a cast is required.","pos":[1613,1702]},{"content":"Output","pos":[2165,2171]},{"content":"Operators and enums","pos":[2229,2248]},{"content":"The following operators are valid on enums in C++/CLI:","pos":[2252,2306]},{"content":"Operator","pos":[2313,2321]},{"content":"== != <ph id=\"ph1\">\\&lt; &gt; \\&lt;</ph>= &gt;=","pos":[2345,2362],"source":"== != \\< > \\<= >="},{"content":"+ -","pos":[2367,2370]},{"content":"&amp;#124; ^ &amp; ~","pos":[2375,2387],"source":"&#124; ^ & ~"},{"content":"++ --","pos":[2392,2397]},{"content":"sizeof","pos":[2402,2408]},{"content":"Operators &amp;#124; ^ &amp; ~ ++ -- are defined only for enumerations with integral underlying types, not including bool.","pos":[2416,2530],"source":"Operators &#124; ^ & ~ ++ -- are defined only for enumerations with integral underlying types, not including bool."},{"content":"Both operands must be of the enumeration type.","pos":[2532,2578]},{"content":"The compiler does no static or dynamic checking of the result of an enum operation; an operation may result in a value not in the range of the enum's valid enumerators.","pos":[2585,2753]},{"pos":[2761,3331],"content":"[!NOTE]\n C++11 introduces enum class types in unmanaged code which are significantly different than managed enum classes in C++/CLI. In particular, the C++11 enum class type does not support the same operators as the managed enum class type in C++/CLI, and C++/CLI source code must provide an accessibility specifier in managed enum class declarations in order to distinguish them from unmanaged (C++11) enum class declarations. For more information about enum classes in C++/CLI, C++/CX, and C++11, see [enum class](../windows/enum-class-cpp-component-extensions.md).","leadings":["","> "],"nodes":[{"content":" C++11 introduces enum class types in unmanaged code which are significantly different than managed enum classes in C++/CLI. In particular, the C++11 enum class type does not support the same operators as the managed enum class type in C++/CLI, and C++/CLI source code must provide an accessibility specifier in managed enum class declarations in order to distinguish them from unmanaged (C++11) enum class declarations. For more information about enum classes in C++/CLI, C++/CX, and C++11, see [enum class](../windows/enum-class-cpp-component-extensions.md).","pos":[8,568],"nodes":[{"content":"C++11 introduces enum class types in unmanaged code which are significantly different than managed enum classes in C++/CLI.","pos":[1,124]},{"content":"In particular, the C++11 enum class type does not support the same operators as the managed enum class type in C++/CLI, and C++/CLI source code must provide an accessibility specifier in managed enum class declarations in order to distinguish them from unmanaged (C++11) enum class declarations.","pos":[125,420]},{"content":"For more information about enum classes in C++/CLI, C++/CX, and C++11, see <bpt id=\"p1\">[</bpt>enum class<ept id=\"p1\">](../windows/enum-class-cpp-component-extensions.md)</ept>.","pos":[421,560],"source":" For more information about enum classes in C++/CLI, C++/CX, and C++11, see [enum class](../windows/enum-class-cpp-component-extensions.md)."}]}]},{"content":"Output","pos":[4028,4034]},{"content":"See Also","pos":[4081,4089]},{"content":"enum class","pos":[4094,4104]}],"content":"---\ntitle: \"How to: Define and consume enums in C++-CLI | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"enum class, specifying underlying types\"\nms.assetid: df8f2b91-b9d2-4fab-9be4-b1d58b8bc570\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# How to: Define and consume enums in C++/CLI\nThis topic discusses enums in C++/CLI.  \n  \n## Specifying the underlying type of an enum  \n By default, the underlying type of an enumeration is `int`.  However, you can specify the type to be signed or unsigned forms of `int`, `short`, `long`, `__int32`, or `__int64`.  You can also use `char`.  \n  \n```  \n// mcppv2_enum_3.cpp  \n// compile with: /clr  \npublic enum class day_char : char {sun, mon, tue, wed, thu, fri, sat};  \n  \nint main() {  \n   // fully qualified names, enumerator not injected into scope  \n   day_char d = day_char::sun, e = day_char::mon;  \n   System::Console::WriteLine(d);  \n   char f = (char)d;  \n   System::Console::WriteLine(f);  \n   f = (char)e;  \n   System::Console::WriteLine(f);  \n   e = day_char::tue;  \n   f = (char)e;  \n   System::Console::WriteLine(f);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nsun  \n0  \n1  \n2  \n```  \n  \n## How to convert between managed and standard enumerations  \n There is no standard conversion between an enum and an integral type; a cast is required.  \n  \n```  \n// mcppv2_enum_4.cpp  \n// compile with: /clr  \nenum class day {sun, mon, tue, wed, thu, fri, sat};  \nenum {sun, mon, tue, wed, thu, fri, sat} day2; // unnamed std enum  \n  \nint main() {  \n   day a = day::sun;  \n   day2 = sun;  \n   if ((int)a == day2)  \n   // or...  \n   // if (a == (day)day2)  \n      System::Console::WriteLine(\"a and day2 are the same\");  \n   else  \n      System::Console::WriteLine(\"a and day2 are not the same\");  \n}  \n```  \n  \n **Output**  \n  \n```Output  \na and day2 are the same  \n```  \n  \n## Operators and enums  \n The following operators are valid on enums in C++/CLI:  \n  \n|Operator|  \n|--------------|  \n|== != \\< > \\<= >=|  \n|+ -|  \n|&#124; ^ & ~|  \n|++ --|  \n|sizeof|  \n  \n Operators &#124; ^ & ~ ++ -- are defined only for enumerations with integral underlying types, not including bool.  Both operands must be of the enumeration type.  \n  \n The compiler does no static or dynamic checking of the result of an enum operation; an operation may result in a value not in the range of the enum's valid enumerators.  \n  \n> [!NOTE]\n>  C++11 introduces enum class types in unmanaged code which are significantly different than managed enum classes in C++/CLI. In particular, the C++11 enum class type does not support the same operators as the managed enum class type in C++/CLI, and C++/CLI source code must provide an accessibility specifier in managed enum class declarations in order to distinguish them from unmanaged (C++11) enum class declarations. For more information about enum classes in C++/CLI, C++/CX, and C++11, see [enum class](../windows/enum-class-cpp-component-extensions.md).  \n  \n```  \n// mcppv2_enum_5.cpp  \n// compile with: /clr  \nprivate enum class E { a, b } e, mask;  \nint main() {  \n   if ( e & mask )   // C2451 no E->bool conversion  \n      ;  \n  \n   if ( ( e & mask ) != 0 )   // C3063 no operator!= (E, int)  \n      ;  \n  \n   if ( ( e & mask ) != E() )   // OK  \n      ;  \n}  \n```  \n  \n```  \n// mcppv2_enum_6.cpp  \n// compile with: /clr  \nprivate enum class day : int {sun, mon};  \nenum : bool {sun = true, mon = false} day2;  \n  \nint main() {  \n   day a = day::sun, b = day::mon;  \n   day2 = sun;  \n  \n   System::Console::WriteLine(sizeof(a));  \n   System::Console::WriteLine(sizeof(day2));  \n   a++;  \n   System::Console::WriteLine(a == b);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n4  \n1  \nTrue  \n```  \n  \n## See Also  \n [enum class](../windows/enum-class-cpp-component-extensions.md)"}