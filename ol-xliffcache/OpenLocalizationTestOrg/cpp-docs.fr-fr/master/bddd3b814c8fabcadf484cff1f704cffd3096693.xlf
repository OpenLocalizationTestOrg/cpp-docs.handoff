<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bddd3b814c8fabcadf484cff1f704cffd3096693</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\function-overloading.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4b1588c704612d799f368106f9231177cd6e87f8</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5b3781f993dc1f5d3e15a88d66c9b54bcb3de8ab</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Function Overloading | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Function Overloading</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>C++ allows specification of more than one function of the same name in the same scope.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>These are called overloaded functions and are described in detail in Overloading.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Overloaded functions enable programmers to supply different semantics for a function, depending on the types and number of arguments.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, a <bpt id="p1">**</bpt>print<ept id="p1">**</ept> function that takes a string (or <bpt id="p2">**</bpt>char <ph id="ph1">\*</ph><ept id="p2">**</ept>) argument performs very different tasks than one that takes an argument of type <bpt id="p3">**</bpt>double<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Overloading permits uniform naming and prevents programmers from having to invent names such as <ph id="ph1">`print_sz`</ph> or <ph id="ph2">`print_d`</ph>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following table shows what parts of a function declaration C++ uses to differentiate between groups of functions with the same name in the same scope.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Overloading Considerations</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Function Declaration Element</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Used for Overloading?</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Function return type</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Number of arguments</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Type of arguments</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Presence or absence of ellipsis</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Use of <ph id="ph1">`typedef`</ph> names</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Unspecified array bounds</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>const<ept id="p1">**</ept> or <ph id="ph1">`volatile`</ph> (see below)</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Although functions can be distinguished on the basis of return type, they cannot be overloaded on this basis.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>or <ph id="ph1">`volatile`</ph> are only used as a basis for overloading if they are used in a class to apply to the <bpt id="p1">**</bpt>this<ept id="p1">**</ept> pointer for the class, not the function's return type.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>In other words, overloading applies only if the <bpt id="p1">**</bpt>const<ept id="p1">**</ept> or <ph id="ph1">`volatile`</ph> keyword follows the function's argument list in the declaration.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following example illustrates how overloading can be used.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The preceding code shows overloading of the <ph id="ph1">`print`</ph> function in file scope.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The default argument is not considered part of the function type.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Therefore, it is not used in selecting overloaded functions.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Two functions that differ only in their default arguments are considered multiple definitions rather than overloaded functions.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Default arguments cannot be supplied for overloaded operators.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Argument Matching</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Overloaded functions are selected for the best match of function declarations in the current scope to the arguments supplied in the function call.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If a suitable function is found, that function is called.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>"Suitable" in this context means one of the following:</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>An exact match was found.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A trivial conversion was performed.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>An integral promotion was performed.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>A standard conversion to the desired argument type exists.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>A user-defined conversion (either conversion operator or constructor) to the desired argument type exists.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Arguments represented by an ellipsis were found.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The compiler creates a set of candidate functions for each argument.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Candidate functions are functions in which the actual argument in that position can be converted to the type of the formal argument.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A set of "best matching functions" is built for each argument, and the selected function is the intersection of all the sets.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If the intersection contains more than one function, the overloading is ambiguous and generates an error.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The function that is eventually selected is always a better match than every other function in the group for at least one argument.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>If this is not the case (if there is no clear winner), the function call generates an error.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Consider the following declarations (the functions are marked <ph id="ph1">`Variant 1`</ph>, <ph id="ph2">`Variant 2`</ph>, and <ph id="ph3">`Variant 3`</ph>, for identification in the following discussion):</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Consider the following statement:</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The preceding statement builds two sets:</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Set 1: Candidate Functions That Have First Argument of Type Fraction</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Set 2: Candidate Functions Whose Second Argument Can Be Converted to Type int</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Variant 1</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Variant 1 (<ph id="ph1">`int`</ph> can be converted to <ph id="ph2">`long`</ph> using a standard conversion)</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Variant 3</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Functions in Set 2 are functions for which there are implicit conversions from actual parameter type to formal parameter type, and among such functions there is a function for which the "cost" of converting the actual parameter type to its formal parameter type is the smallest.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The intersection of these two sets is Variant 1.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>An example of an ambiguous function call is:</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The preceding function call builds the following sets:</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Set 1: Candidate Functions That Have First Argument of Type int</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Set 2: Candidate Functions That Have Second Argument of Type int</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Variant 2 (<ph id="ph1">`int`</ph> can be converted to <ph id="ph2">`long`</ph> using a standard conversion)</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Variant 1 (<ph id="ph1">`int`</ph> can be converted to <ph id="ph2">`long`</ph> using a standard conversion)</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Note that the intersection between these two sets is empty.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Therefore, the compiler generates an error message.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For argument matching, a function with <bpt id="p1">*</bpt>n<ept id="p1">*</ept> default arguments is treated as <bpt id="p2">*</bpt>n<ept id="p2">*</ept>+1 separate functions, each with a different number of arguments.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The ellipsis (...) acts as a wildcard; it matches any actual argument.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This can lead to many ambiguous sets, if you do not design your overloaded function sets with extreme care.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Ambiguity of overloaded functions cannot be determined until a function call is encountered.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>At that point, the sets are built for each argument in the function call, and you can determine whether an unambiguous overload exists.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This means that ambiguities can remain in your code until they are evoked by a particular function call.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Argument Type Differences</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Overloaded functions differentiate between argument types that take different initializers.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Therefore, an argument of a given type and a reference to that type are considered the same for the purposes of overloading.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>They are considered the same because they take the same initializers.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`max( double, double )`</ph> is considered the same as <ph id="ph2">`max( double &amp;, double &amp; )`</ph>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Declaring two such functions causes an error.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For the same reason, function arguments of a type modified by <bpt id="p1">**</bpt>const<ept id="p1">**</ept> or <ph id="ph1">`volatile`</ph> are not treated differently than the base type for the purposes of overloading.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>However, the function overloading mechanism can distinguish between references that are qualified by <bpt id="p1">**</bpt>const<ept id="p1">**</ept> and <ph id="ph1">`volatile`</ph> and references to the base type.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This makes code such as the following possible:</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Pointers to <bpt id="p1">**</bpt>const<ept id="p1">**</ept> and <ph id="ph1">`volatile`</ph> objects are also considered different from pointers to the base type for the purposes of overloading.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Argument matching and conversions</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>When the compiler tries to match actual arguments against the arguments in function declarations, it can supply standard or user-defined conversions to obtain the correct type if no exact match can be found.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The application of conversions is subject to these rules:</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Sequences of conversions that contain more than one user-defined conversion are not considered.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Sequences of conversions that can be shortened by removing intermediate conversions are not considered.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The resultant sequence of conversions, if any, is called the best matching sequence.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>There are several ways to convert an object of type <ph id="ph1">`int`</ph> to type <ph id="ph2">`unsigned long`</ph>using standard conversions (described in <bpt id="p1">[</bpt>Standard Conversions<ept id="p1">](../cpp/standard-conversions.md)</ept>):</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Convert from <ph id="ph1">`int`</ph> to <ph id="ph2">`long`</ph> and then from <ph id="ph3">`long`</ph> to <ph id="ph4">`unsigned long`</ph>.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Convert from <ph id="ph1">`int`</ph> to <ph id="ph2">`unsigned long`</ph>.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The first sequence, although it achieves the desired goal, is not the best matching sequence — a shorter sequence exists.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following table shows a group of conversions, called trivial conversions, that have a limited effect on determining which sequence is the best matching.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The instances in which trivial conversions affect choice of sequence are discussed in the list following the table.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Trivial Conversions</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Convert from Type</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Convert to Type</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>type-name</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>type-name<ept id="p1">*</ept> <bpt id="p2">**</bpt><ph id="ph1">&amp;</ph><ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>type-name<ept id="p1">*</ept> <bpt id="p2">**</bpt><ph id="ph1">&amp;</ph><ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>type-name</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>type-name<ept id="p1">*</ept> <bpt id="p2">**</bpt>[ ]<ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>type-name</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>type-name<ept id="p1">*</ept> <bpt id="p2">**</bpt>(<ept id="p2">**</ept> <bpt id="p3">*</bpt>argument-list<ept id="p3">*</ept> <bpt id="p4">**</bpt>)<ept id="p4">**</ept></source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(<ept id="p1">**</ept> <bpt id="p2">*</bpt><ph id="ph1">\*</ph>type-name<ept id="p2">*</ept> <bpt id="p3">**</bpt>) (<ept id="p3">**</ept> <bpt id="p4">*</bpt>argument-list<ept id="p4">*</ept> <bpt id="p5">**</bpt>)<ept id="p5">**</ept></source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>type-name</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>const<ept id="p1">**</ept> <bpt id="p2">*</bpt>type-name<ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>type-name</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>type-name</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>type-name</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>const<ept id="p1">**</ept> <bpt id="p2">*</bpt>type-name<ph id="ph1">\*</ph><ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>type-name</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>type-name</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The sequence in which conversions are attempted is as follows:</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Exact match.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>An exact match between the types with which the function is called and the types declared in the function prototype is always the best match.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Sequences of trivial conversions are classified as exact matches.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>However, sequences that do not make any of these conversions are considered better than sequences that convert:</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>From pointer, to pointer to <bpt id="p1">**</bpt>const<ept id="p1">**</ept> (<ph id="ph1">`type`</ph> <bpt id="p2">**</bpt><ph id="ph2">\*</ph><ept id="p2">**</ept> to <bpt id="p3">**</bpt>const<ept id="p3">**</ept> <ph id="ph3">`type`</ph> <bpt id="p4">**</bpt><ph id="ph4">\*</ph><ept id="p4">**</ept>).</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>From pointer, to pointer to <ph id="ph1">`volatile`</ph> (<ph id="ph2">`type`</ph> <bpt id="p1">**</bpt><ph id="ph3">\*</ph><ept id="p1">**</ept> to <ph id="ph4">`volatile`</ph> <ph id="ph5">`type`</ph> <bpt id="p2">**</bpt><ph id="ph6">\*</ph><ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>From reference, to reference to <bpt id="p1">**</bpt>const<ept id="p1">**</ept> (<ph id="ph1">`type`</ph> <bpt id="p2">**</bpt><ph id="ph2">&amp;</ph><ept id="p2">**</ept> to <bpt id="p3">**</bpt>const<ept id="p3">**</ept> <ph id="ph3">`type`</ph> <bpt id="p4">**</bpt><ph id="ph4">&amp;</ph><ept id="p4">**</ept>).</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>From reference, to reference to <ph id="ph1">`volatile`</ph> (<ph id="ph2">`type`</ph> <bpt id="p1">**</bpt><ph id="ph3">&amp;</ph><ept id="p1">**</ept> to <ph id="ph4">`volatile`</ph> <ph id="ph5">`type`</ph> <bpt id="p2">**</bpt><ph id="ph6">&amp;</ph><ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Match using promotions.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Any sequence not classified as an exact match that contains only integral promotions, conversions from <bpt id="p1">**</bpt>float<ept id="p1">**</ept> to <bpt id="p2">**</bpt>double<ept id="p2">**</ept>, and trivial conversions is classified as a match using promotions.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Although not as good a match as any exact match, a match using promotions is better than a match using standard conversions.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Match using standard conversions.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Any sequence not classified as an exact match or a match using promotions that contains only standard conversions and trivial conversions is classified as a match using standard conversions.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Within this category, the following rules are applied:</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Conversion from a pointer to a derived class, to a pointer to a direct or indirect base class is preferable to converting to <bpt id="p1">**</bpt>void <ph id="ph1">\*</ph><ept id="p1">**</ept> or <bpt id="p2">**</bpt>const void <ph id="ph2">\*</ph><ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Conversion from a pointer to a derived class, to a pointer to a base class produces a better match the closer the base class is to a direct base class.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Suppose the class hierarchy is as shown in the following figure.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Preferred conversions</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Graph Illustrating Preferred Conversions</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Conversion from type <ph id="ph1">`D*`</ph> to type <ph id="ph2">`C*`</ph> is preferable to conversion from type <ph id="ph3">`D*`</ph> to type <ph id="ph4">`B*`</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Similarly, conversion from type <ph id="ph1">`D*`</ph> to type <ph id="ph2">`B*`</ph> is preferable to conversion from type <ph id="ph3">`D*`</ph> to type <ph id="ph4">`A*`</ph>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>This same rule applies to reference conversions.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Conversion from type <ph id="ph1">`D&amp;`</ph> to type <ph id="ph2">`C&amp;`</ph> is preferable to conversion from type <ph id="ph3">`D&amp;`</ph> to type <ph id="ph4">`B&amp;`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>This same rule applies to pointer-to-member conversions.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Conversion from type <ph id="ph1">`T D::*`</ph> to type <ph id="ph2">`T C::*`</ph> is preferable to conversion from type <ph id="ph3">`T D::*`</ph> to type <ph id="ph4">`T B::*`</ph>, and so on (where <ph id="ph5">`T`</ph> is the type of the member).</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The preceding rule applies only along a given path of derivation.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Consider the graph shown in the following figure.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Multi&amp;#45;inheritance that shows preferred conversions</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Multiple-Inheritance Graph Illustrating Preferred Conversions</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Conversion from type <ph id="ph1">`C*`</ph> to type <ph id="ph2">`B*`</ph> is preferable to conversion from type <ph id="ph3">`C*`</ph> to type <ph id="ph4">`A*`</ph>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The reason is that they are on the same path, and <ph id="ph1">`B*`</ph> is closer.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>However, conversion from type <ph id="ph1">`C*`</ph> to type <ph id="ph2">`D*`</ph> is not preferable to conversion to type <ph id="ph3">`A*`</ph>; there is no preference because the conversions follow different paths.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Match with user-defined conversions.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>This sequence cannot be classified as an exact match, a match using promotions, or a match using standard conversions.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The sequence must contain only user-defined conversions, standard conversions, or trivial conversions to be classified as a match with user-defined conversions.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>A match with user-defined conversions is considered a better match than a match with an ellipsis but not as good a match as a match with standard conversions.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Match with an ellipsis.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Any sequence that matches an ellipsis in the declaration is classified as a match with an ellipsis.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>This is considered the weakest match.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>User-defined conversions are applied if no built-in promotion or conversion exists.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>These conversions are selected on the basis of the type of the argument being matched.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Consider the following code:</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The available user-defined conversions for class <ph id="ph1">`UDC`</ph> are from type <ph id="ph2">`int`</ph> and type <bpt id="p1">**</bpt>long<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Therefore, the compiler considers conversions for the type of the object being matched: <ph id="ph1">`UDC`</ph>.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>A conversion to <ph id="ph1">`int`</ph> exists, and it is selected.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>During the process of matching arguments, standard conversions can be applied to both the argument and the result of a user-defined conversion.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Therefore, the following code works:</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>In the preceding example, the user-defined conversion, <bpt id="p1">**</bpt>operator long<ept id="p1">**</ept>, is invoked to convert <ph id="ph1">`udc`</ph> to type <bpt id="p2">**</bpt>long<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>If no user-defined conversion to type <bpt id="p1">**</bpt>long<ept id="p1">**</ept> had been defined, the conversion would have proceeded as follows: Type <ph id="ph1">`UDC`</ph> would have been converted to type <ph id="ph2">`int`</ph> using the user-defined conversion.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Then the standard conversion from type <ph id="ph1">`int`</ph> to type <bpt id="p1">**</bpt>long<ept id="p1">**</ept> would have been applied to match the argument in the declaration.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>If any user-defined conversions are required to match an argument, the standard conversions are not used when evaluating the best match.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>This is true even if more than one candidate function requires a user-defined conversion; in such a case, the functions are considered equal.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Both versions of <ph id="ph1">`Func`</ph> require a user-defined conversion to convert type <ph id="ph2">`int`</ph> to the class type argument.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The possible conversions are:</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Convert from type <ph id="ph1">`int`</ph> to type <ph id="ph2">`UDC1`</ph> (a user-defined conversion).</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Convert from type <ph id="ph1">`int`</ph> to type <bpt id="p1">**</bpt>long<ept id="p1">**</ept>; then convert to type <ph id="ph2">`UDC2`</ph> (a two-step conversion).</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Even though the second of these requires a standard conversion, as well as the user-defined conversion, the two conversions are still considered equal.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>User-defined conversions are considered conversion by construction or conversion by initialization (conversion function).</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Both methods are considered equal when considering the best match.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Argument matching and the this pointer</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Class member functions are treated differently, depending on whether they are declared as <ph id="ph1">`static`</ph>.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Because nonstatic functions have an implicit argument that supplies the <ph id="ph1">`this`</ph> pointer, nonstatic functions are considered to have one more argument than static functions; otherwise, they are declared identically.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>These nonstatic member functions require that the implied <ph id="ph1">`this`</ph> pointer match the object type through which the function is being called, or, for overloaded operators, they require that the first argument match the object on which the operator is being applied.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>(For more information about overloaded operators, see <bpt id="p1">[</bpt>Overloaded Operators<ept id="p1">](../cpp/operator-overloading.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Unlike other arguments in overloaded functions, no temporary objects are introduced and no conversions are attempted when trying to match the <ph id="ph1">`this`</ph> pointer argument.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`– &gt;`</ph> member-selection operator is used to access a member function, the <ph id="ph2">`this`</ph> pointer argument has a type of <ph id="ph3">`class-name`</ph> <ph id="ph4">`* const`</ph>.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>If the members are declared as <ph id="ph1">`const`</ph> or <ph id="ph2">`volatile`</ph>, the types are <ph id="ph3">`const`</ph> <ph id="ph4">`class-name``* const`</ph> and <ph id="ph5">`volatile`</ph> <ph id="ph6">`class-name`</ph> <ph id="ph7">`* const`</ph>, respectively.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`.`</ph> member-selection operator works exactly the same way, except that an implicit <ph id="ph2">`&amp;`</ph> (address-of) operator is prefixed to the object name.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The following example shows how this works:</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The left operand of the <ph id="ph1">`–&gt;*`</ph> and <ph id="ph2">`.*`</ph> (pointer to member) operators are treated the same way as the <ph id="ph3">`.`</ph> and <ph id="ph4">`–&gt;`</ph> (member-selection) operators with respect to argument matching.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Restrictions</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Several restrictions govern an acceptable set of overloaded functions:</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Any two functions in a set of overloaded functions must have different argument lists.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Overloading functions with argument lists of the same types, based on return type alone, is an error.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>You can overload <bpt id="p1">**</bpt>operator new<ept id="p1">**</ept> solely on the basis of return type — specifically, on the basis of the memory-model modifier specified.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>END Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Member functions cannot be overloaded solely on the basis of one being static and the other nonstatic.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>declarations do not define new types; they introduce synonyms for existing types.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>They do not affect the overloading mechanism.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Consider the following code:</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The preceding two functions have identical argument lists.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>is a synonym for type <bpt id="p1">**</bpt>char <ph id="ph1">\*</ph><ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>In member scope, this code generates an error.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Enumerated types are distinct types and can be used to distinguish between overloaded functions.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The types "array of " and "pointer to" are considered identical for the purposes of distinguishing between overloaded functions.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>This is true only for singly dimensioned arrays.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Therefore, the following overloaded functions conflict and generate an error message:</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>For multiply dimensioned arrays, the second and all succeeding dimensions are considered part of the type.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Therefore, they are used in distinguishing between overloaded functions:</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Declaration matching</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Any two function declarations of the same name in the same scope can refer to the same function, or to two discrete functions that are overloaded.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>If the argument lists of the declarations contain arguments of equivalent types (as described in the previous section), the function declarations refer to the same function.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Otherwise, they refer to two different functions that are selected using overloading.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Class scope is strictly observed; therefore, a function declared in a base class is not in the same scope as a function declared in a derived class.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>If a function in a derived class is declared with the same name as a function in the base class, the derived-class function hides the base-class function instead of causing overloading.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Block scope is strictly observed; therefore, a function declared in file scope is not in the same scope as a function declared locally.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>If a locally declared function has the same name as a function declared in file scope, the locally declared function hides the file-scoped function instead of causing overloading.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The preceding code shows two definitions from the function <ph id="ph1">`func`</ph>.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The definition that takes an argument of type <ph id="ph1">`char *`</ph> is local to <ph id="ph2">`main`</ph> because of the <ph id="ph3">`extern`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Therefore, the definition that takes an argument of type <ph id="ph1">`int`</ph> is hidden, and the first call to <ph id="ph2">`func`</ph> is in error.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>For overloaded member functions, different versions of the function can be given different access privileges.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>They are still considered to be in the scope of the enclosing class and thus are overloaded functions.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Consider the following code, in which the member function <ph id="ph1">`Deposit`</ph> is overloaded; one version is public, the other, private.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The intent of this sample is to provide an <ph id="ph1">`Account`</ph> class in which a correct password is required to perform deposits.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>This is accomplished using overloading.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Note that the call to <ph id="ph1">`Deposit`</ph> in <ph id="ph2">`Account::Deposit`</ph> calls the private member function.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>This call is correct because <ph id="ph1">`Account::Deposit`</ph> is a member function and therefore has access to the private members of the class.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Functions (C++)</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>