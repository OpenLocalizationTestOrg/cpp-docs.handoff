<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0616949cb92bf906bef6c2293fff969619da5a8b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\new-operators.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">931f0192349f864e92cd176403214db6b08e4361</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">77e70b585641522784b21de1fec50f5c755c23c7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>new<ph id="ph1">&amp;gt;</ph> operators | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>new<ph id="ph1">&amp;gt;</ph> operators</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>operator delete</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>operator delete[]</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>operator new</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>operator new[]</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>operator delete</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The function called by a delete expression to deallocate storage for individual of objects.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The pointer whose value is to be rendered invalid by the deletion.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The first function is called by a delete expression to render the value of <ph id="ph1">`ptr`</ph> invalid.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The required behavior is to accept a value of <ph id="ph1">`ptr`</ph> that is null or that was returned by an earlier call to <bpt id="p1">[</bpt>operator new<ept id="p1">](../standard-library/new-operators.md#operator_new)</ept>( <bpt id="p2">**</bpt>size_t<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The default behavior for a null value of <ph id="ph1">`ptr`</ph> is to do nothing.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Any other value of <ph id="ph1">`ptr`</ph> must be a value returned earlier by a call as previously described.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The default behavior for such a nonnull value of <ph id="ph1">`ptr`</ph> is to reclaim storage allocated by the earlier call.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>It is unspecified under what conditions part or all of such reclaimed storage is allocated by a subsequent call to <ph id="ph1">`operator new`</ph>( <bpt id="p1">**</bpt>size_t<ept id="p1">**</ept>), or to any of <ph id="ph2">`calloc`</ph>( <bpt id="p2">**</bpt>size_t<ept id="p2">**</ept>), <ph id="ph3">`malloc`</ph>( <bpt id="p3">**</bpt>size_t<ept id="p3">**</ept>), or <ph id="ph4">`realloc`</ph>( <bpt id="p4">**</bpt>void<ph id="ph5">\*</ph><ept id="p4">**</ept>, <bpt id="p5">**</bpt>size_t<ept id="p5">**</ept>).</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The second function is called by a placement delete expression corresponding to a new expression of the form <bpt id="p1">**</bpt>new<ept id="p1">**</ept>( <bpt id="p2">**</bpt>std::size_t<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>It does nothing.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The third function is called by a placement delete expression corresponding to a new expression of the form <bpt id="p1">**</bpt>new<ept id="p1">**</ept>( <bpt id="p2">**</bpt>std::size_t<ept id="p2">**</ept>, <bpt id="p3">**</bpt>conststd::nothrow_t&amp;<ept id="p3">**</ept>).</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The required behavior is to accept a value of <ph id="ph1">`ptr`</ph> that is null or that was returned by an earlier call to <ph id="ph2">`operator new`</ph>( <bpt id="p1">**</bpt>size_t<ept id="p1">**</ept>).</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The default behavior is to evaluate <bpt id="p1">**</bpt>delete<ept id="p1">**</ept>( <ph id="ph1">`ptr`</ph>).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>operator new<ept id="p1">](../standard-library/new-operators.md#operator_new)</ept> for an example that use <ph id="ph1">`operator delete`</ph>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>operator delete[]</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The function called by a delete expression to deallocate storage for an array of objects.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The pointer whose value is to be rendered invalid by the deletion.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The first function is called by an <ph id="ph1">`delete[]`</ph> expression to render the value of <ph id="ph2">`ptr`</ph> invalid.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The function is replaceable because the program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The required behavior is to accept a value of <ph id="ph1">`ptr`</ph> that is null or that was returned by an earlier call to <bpt id="p1">[</bpt>operator new&amp;#91;&amp;#93;<ept id="p1">](../standard-library/new-operators.md#operator_new_arr)</ept>( <bpt id="p2">**</bpt>size_t<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The default behavior for a null value of <ph id="ph1">`ptr`</ph> is to do nothing.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Any other value of <ph id="ph1">`ptr`</ph> must be a value returned earlier by a call as previously described.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The default behavior for such a nonnull value of <ph id="ph1">`ptr`</ph> is to reclaim storage allocated by the earlier call.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>It is unspecified under what conditions part or all of such reclaimed storage is allocated by a subsequent call to <bpt id="p1">[</bpt>operator new<ept id="p1">](../standard-library/new-operators.md#operator_new)</ept>( <bpt id="p2">**</bpt>size_t<ept id="p2">**</ept>), or to any of <ph id="ph1">`calloc`</ph>( <bpt id="p3">**</bpt>size_t<ept id="p3">**</ept>), <ph id="ph2">`malloc`</ph>( <bpt id="p4">**</bpt>size_t<ept id="p4">**</ept>), or <ph id="ph3">`realloc`</ph>( <bpt id="p5">**</bpt>void<ph id="ph4">\*</ph><ept id="p5">**</ept>, <bpt id="p6">**</bpt>size_t<ept id="p6">**</ept>).</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The second function is called by a placement <ph id="ph1">`delete[]`</ph> expression corresponding to a <ph id="ph2">`new[]`</ph> expression of the form <ph id="ph3">`new[]`</ph>( <bpt id="p1">**</bpt>std::size_t<ept id="p1">**</ept>).</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It does nothing.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The third function is called by a placement delete expression corresponding to a <ph id="ph1">`new[]`</ph> expression of the form <ph id="ph2">`new[]`</ph>( <bpt id="p1">**</bpt>std::size_t<ept id="p1">**</ept>, <bpt id="p2">**</bpt>const std::nothrow_t&amp;<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The required behavior is to accept a value of <ph id="ph1">`ptr`</ph> that is null or that was returned by an earlier call to operator <ph id="ph2">`new[]`</ph>( <bpt id="p1">**</bpt>size_t<ept id="p1">**</ept>).</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The default behavior is to evaluate <ph id="ph1">`delete[]`</ph>( <ph id="ph2">`ptr`</ph>).</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>operator new&amp;#91;&amp;#93;<ept id="p1">](../standard-library/new-operators.md#operator_new_arr)</ept> for examples of the use of <ph id="ph1">`operator delete[]`</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>operator new</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The function called by a new-expression to allocate storage for individual objects.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The number of bytes of storage to be allocated.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The pointer to be returned.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A pointer to the lowest byte address of the newly-allocated storage.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Or</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The first function is called by a new expression to allocate <ph id="ph1">`count`</ph> bytes of storage suitably aligned to represent any object of that size.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The program can define an alternate function with this function signature that replaces the default version defined by the Standard C++ Library and so is replaceable.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The required behavior is to return a nonnull pointer only if storage can be allocated as requested.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Each such allocation yields a pointer to storage disjoint from any other allocated storage.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The order and contiguity of storage allocated by successive calls is unspecified.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The initial stored value is unspecified.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The returned pointer points to the start (lowest byte address) of the allocated storage.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If count is zero, the value returned does not compare equal to any other value returned by the function.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The default behavior is to execute a loop.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Within the loop, the function first attempts to allocate the requested storage.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Whether the attempt involves a call to <ph id="ph1">`malloc`</ph>( <bpt id="p1">**</bpt>size_t<ept id="p1">**</ept>) is unspecified.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>If the attempt is successful, the function returns a pointer to the allocated storage.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Otherwise, the function calls the designated <bpt id="p1">[</bpt>new handler<ept id="p1">](../standard-library/new-typedefs.md#new_handler)</ept>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>If the called function returns, the loop repeats.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The loop terminates when an attempt to allocate the requested storage is successful or when a called function does not return.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The required behavior of a new handler is to perform one of the following operations:</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Make more storage available for allocation and then return.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Call either <bpt id="p1">**</bpt>abort<ept id="p1">**</ept> or <bpt id="p2">**</bpt>exit<ept id="p2">**</ept>( <ph id="ph1">`int`</ph>).</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Throw an object of type <bpt id="p1">**</bpt>bad_alloc.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The default behavior of a <bpt id="p1">[</bpt>new handler<ept id="p1">](../standard-library/new-typedefs.md#new_handler)</ept> is to throw an object of type <ph id="ph1">`bad_alloc`</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>A null pointer designates the default new handler.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The order and contiguity of storage allocated by successive calls to <ph id="ph1">`operator new`</ph>( <bpt id="p1">**</bpt>size_t<ept id="p1">**</ept>) is unspecified, as are the initial values stored there.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The second function is called by a placement new expression to allocate <ph id="ph1">`count`</ph> bytes of storage suitably aligned to represent any object of that size.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The program can define an alternate function with this function signature that replaces the default version defined by the Standard C++ Library and so is replaceable.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The default behavior is to return <ph id="ph1">`operator new`</ph>( <ph id="ph2">`count`</ph>) if that function succeeds.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns a null pointer.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The third function is called by a placement <bpt id="p1">**</bpt>new<ept id="p1">**</ept> expression, of the form <bpt id="p2">**</bpt>new<ept id="p2">**</ept> ( <bpt id="p3">*</bpt>args<ept id="p3">*</ept>) T. Here, <bpt id="p4">*</bpt>args<ept id="p4">*</ept> consists of a single object pointer.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This can be useful for constructing an object at a known address.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The function returns <bpt id="p1">*</bpt>ptr<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>To free storage allocated by <ph id="ph1">`operator new`</ph>, call <bpt id="p1">[</bpt>operator delete<ept id="p1">](../standard-library/new-operators.md#operator_delete)</ept>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>For information on throwing or nonthrowing behavior of new, see <bpt id="p1">[</bpt>The new and delete Operators<ept id="p1">](../cpp/new-and-delete-operators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>operator new[]</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The allocation function called by a new expression to allocate storage for an array of objects.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The number of bytes of storage to be allocated for the array object.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The pointer to be returned.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>A pointer to the lowest byte address of the newly-allocated storage.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Or</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The first function is called by a <ph id="ph1">`new[]`</ph> expression to allocate <ph id="ph2">`count`</ph> bytes of storage suitably aligned to represent any array object of that size or smaller.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The required behavior is the same as for <bpt id="p1">[</bpt>operator new<ept id="p1">](../standard-library/new-operators.md#operator_new)</ept>( <bpt id="p2">**</bpt>size_t<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The default behavior is to return <ph id="ph1">`operator new`</ph>( <ph id="ph2">`count`</ph>).</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The second function is called by a placement <ph id="ph1">`new[]`</ph> expression to allocate <ph id="ph2">`count`</ph> bytes of storage suitably aligned to represent any array object of that size.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The program can define a function with this function signature that replaces the default version defined by the Standard C++ Library.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The default behavior is to return <bpt id="p1">**</bpt>operatornew<ept id="p1">**</ept>( <ph id="ph1">`count`</ph>) if that function succeeds.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns a null pointer.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The third function is called by a placement <ph id="ph1">`new[]`</ph> expression, of the form <bpt id="p1">**</bpt>new<ept id="p1">**</ept> ( <bpt id="p2">*</bpt>args<ept id="p2">*</ept>) <bpt id="p3">**</bpt>T<ept id="p3">**</ept>[ <bpt id="p4">**</bpt>N<ept id="p4">**</ept>].</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Here, <bpt id="p1">*</bpt>args<ept id="p1">*</ept> consists of a single object pointer.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The function returns <ph id="ph1">`ptr`</ph>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>To free storage allocated by <ph id="ph1">`operator new[]`</ph>, call <bpt id="p1">[</bpt>operator delete&amp;#91;&amp;#93;<ept id="p1">](../standard-library/new-operators.md#operator_delete_arr)</ept>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>For information on throwing or nonthrowing behavior of new, see <bpt id="p1">[</bpt>The new and delete Operators<ept id="p1">](../cpp/new-and-delete-operators.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>new&gt;</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>