{"nodes":[{"pos":[12,52],"content":"Overview of Declarators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Overview of Declarators | Microsoft Docs","pos":[0,40]}]},{"content":"Overview of Declarators","pos":[629,652]},{"content":"Declarators are the components of a declaration that specify names of objects or functions.","pos":[653,744]},{"content":"Declarators also specify whether or not the named object is an object, pointer, reference or array.","pos":[745,844]},{"content":"While declarators do not specify the base type, they do modify the type information in the basic type to specify derived types such as pointers, references, and arrays.","pos":[846,1014]},{"content":"Applied to functions, the declarator works with the type specifier to fully specify the return type of a function to be an object, pointer, or reference.","pos":[1016,1169]},{"content":"(Specifiers, discussed in <bpt id=\"p1\">[</bpt>Declarations and Definitions<ept id=\"p1\">](declarations-and-definitions-cpp.md)</ept>, convey properties such as type and storage class.","pos":[1170,1314],"source":" (Specifiers, discussed in [Declarations and Definitions](declarations-and-definitions-cpp.md), convey properties such as type and storage class."},{"content":"Modifiers, discussed in this section and in <bpt id=\"p1\">[</bpt>Microsoft-Specific Modifiers<ept id=\"p1\">](../cpp/microsoft-specific-modifiers.md)</ept>, modify declarators.) The following figure shows a complete declaration of <ph id=\"ph1\">`MyFunction`</ph>, and calls out the components of the declaration.","pos":[1315,1567],"source":" Modifiers, discussed in this section and in [Microsoft-Specific Modifiers](../cpp/microsoft-specific-modifiers.md), modify declarators.) The following figure shows a complete declaration of `MyFunction`, and calls out the components of the declaration."},{"content":"Modifiers, specifiers, and declarators","pos":[1576,1614]},{"content":"Specifiers, Modifiers, and Declarators","pos":[1654,1692]},{"content":"Microsoft Specific","pos":[1701,1719]},{"content":"Most Microsoft extended keywords can be used as modifiers to form derived types; they are not specifiers or declarators.","pos":[1728,1848]},{"content":"(See <bpt id=\"p1\">[</bpt>Microsoft-Specific Modifiers<ept id=\"p1\">](../cpp/microsoft-specific-modifiers.md)</ept>.)","pos":[1849,1926],"source":" (See [Microsoft-Specific Modifiers](../cpp/microsoft-specific-modifiers.md).)"},{"content":"END Microsoft Specific","pos":[1935,1957]},{"content":"Declarators appear in the declaration syntax after an optional list of specifiers.","pos":[1966,2048]},{"content":"These specifiers are discussed in <bpt id=\"p1\">[</bpt>Declarations.<ept id=\"p1\">](declarations-and-definitions-cpp.md)</ept>","pos":[2049,2135],"source":" These specifiers are discussed in [Declarations.](declarations-and-definitions-cpp.md)"},{"content":"A declaration can contain more than one declarator, but each declarator declares only one name.","pos":[2136,2231]},{"content":"The following sample declaration shows how specifiers and declarators are combined to form a complete declaration:","pos":[2238,2352]},{"content":"In the preceding declaration, the keywords <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`char`</ph> make up the list of specifiers.","pos":[2397,2492],"source":"In the preceding declaration, the keywords **const** and `char` make up the list of specifiers."},{"content":"Two declarators are listed: <ph id=\"ph1\">`*pch`</ph> and <ph id=\"ph2\">`ch`</ph>.","pos":[2493,2537],"source":" Two declarators are listed: `*pch` and `ch`."},{"content":"A declaration that declares multiple entities consists of a type specifier followed by a comma-separated list of declarators, terminated with a semicolon.","pos":[2539,2693]},{"content":"Declarators for Simple Objects","pos":[2702,2732]},{"content":"The declarator of a simple object such as an int or double is simply its name, with optional parentheses.","pos":[2741,2846]},{"content":"Declarators for Pointers, References and Arrays","pos":[2927,2974]},{"content":"Pointer operators inserted in front of the name cause the object to be a pointer or reference.","pos":[2983,3077]},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> operator declares the name as a pointer; the <bpt id=\"p2\">**</bpt><ph id=\"ph2\">&amp;</ph><ept id=\"p2\">**</ept> operator declares it as a reference.","pos":[3079,3177],"source":"  The **\\*** operator declares the name as a pointer; the **&** operator declares it as a reference."},{"content":"Appending <ph id=\"ph1\">`const`</ph> or <ph id=\"ph2\">`volatile`</ph> give the pointer these special properties.","pos":[3297,3371],"source":"Appending `const` or `volatile` give the pointer these special properties."},{"content":"The use of these specifiers in a declarator (as opposed to in the type specifier) modifies the properties of the pointer, not the object pointed to:","pos":[3373,3521]},{"pos":[3690,3795],"content":"Further information may be found in <bpt id=\"p1\">[</bpt>const and volatile Pointers<ept id=\"p1\">](../cpp/const-and-volatile-pointers.md)</ept>.","source":"Further information may be found in [const and volatile Pointers](../cpp/const-and-volatile-pointers.md)."},{"content":"A pointer to a member of a class or struct is declared with the appropriate nested name specifier:","pos":[3802,3900]},{"content":"Brackets enclosing an optional constant expression after the name cause the object to be an array.","pos":[4092,4190]},{"content":"Successive brackets declare additional dimensions to the array.","pos":[4192,4255]},{"content":"Declarators for Functions","pos":[4471,4496]},{"content":"Parentheses containing the argument list are used after the name to declare a function.","pos":[4505,4592]},{"content":"The following declares a function of return type <ph id=\"ph1\">`int`</ph> and three arguments of type <ph id=\"ph2\">`int`</ph>.","pos":[4594,4683],"source":"  The following declares a function of return type `int` and three arguments of type `int`."},{"pos":[4735,4868],"content":"For information on argument lists, see <bpt id=\"p1\">[</bpt>Function Declarations<ept id=\"p1\">](http://msdn.microsoft.com/en-us/3f9b4e14-60d2-47c1-acd8-4fa8fc988be7)</ept>.","source":"For information on argument lists, see [Function Declarations](http://msdn.microsoft.com/en-us/3f9b4e14-60d2-47c1-acd8-4fa8fc988be7)."},{"content":"Pointers and references to functions are declared by prepending the pointer or reference operator to the function name as shown below.","pos":[4875,5009]},{"content":"Parentheses, normally optional, are required to distinguish a pointer to a function from a function that returns a pointer:","pos":[5011,5134]},{"content":"Pointers to member functions are distinguished by nested name specifiers:","pos":[5309,5382]},{"pos":[5549,5611],"content":"See also <bpt id=\"p1\">[</bpt>Pointers to Members<ept id=\"p1\">](../cpp/pointers-to-members.md)</ept>.","source":"See also [Pointers to Members](../cpp/pointers-to-members.md)."},{"content":"Functions and objects in the same declaration","pos":[5620,5665]},{"content":"Functions and objects may be declared in the same declaration as follows:","pos":[5674,5747]},{"content":"The syntax may be misleading in some circumstances.","pos":[5840,5891]},{"content":"The following declaration","pos":[5893,5918]},{"content":"may look like the declaration of an <ph id=\"ph1\">`int`</ph> pointer and a function returning <ph id=\"ph2\">`int*`</ph>, but it is not.","pos":[6014,6111],"source":"may look like the declaration of an `int` pointer and a function returning `int*`, but it is not."},{"content":"That's because the * is part of the declarator for <ph id=\"ph1\">`i`</ph>, not part of the declarator for <ph id=\"ph2\">`f`</ph>.","pos":[6113,6204],"source":"  That's because the * is part of the declarator for `i`, not part of the declarator for `f`."},{"content":"Simplifying declarator syntax with typedef","pos":[6213,6255]},{"content":"A better technique, however, is to use a <ph id=\"ph1\">`typedef`</ph> or a combination of parentheses and the <ph id=\"ph2\">`typedef`</ph> keyword.","pos":[6264,6373],"source":"A better technique, however, is to use a `typedef` or a combination of parentheses and the `typedef` keyword."},{"content":"Consider declaring an array of pointers to functions:","pos":[6374,6427]},{"pos":[6713,6865],"content":"The equivalent declaration can be written without the <ph id=\"ph1\">`typedef`</ph> declaration, but it is so complicated that the potential for error exceeds any benefits:","source":"The equivalent declaration can be written without the `typedef` declaration, but it is so complicated that the potential for error exceeds any benefits:"},{"pos":[6930,7057],"content":"For more information on typedef, see <bpt id=\"p1\">[</bpt>typedef Specifier<ept id=\"p1\">](http://msdn.microsoft.com/en-us/cc96cf26-ba93-4179-951e-695d1f5fdcf1)</ept>.","source":"For more information on typedef, see [typedef Specifier](http://msdn.microsoft.com/en-us/cc96cf26-ba93-4179-951e-695d1f5fdcf1)."},{"content":"Pointers, references, arrays of a single base type can be combined in a single declaration (separated by commas) as","pos":[7064,7179]},{"content":"More complex declarator syntax","pos":[7233,7263]},{"content":"Pointer, reference, array, and function declarators may be combined to specify such objects as arrays of pointers to functions, pointers to arrays, etc.","pos":[7275,7427]},{"content":"The following recursive grammar describes pointer declarator syntax fully.","pos":[7437,7511]},{"pos":[7521,7557],"content":"A <ph id=\"ph1\">`declarator`</ph> is defined as one of:","source":"A `declarator` is defined as one of:"},{"pos":[7787,7820],"content":"and <bpt id=\"p1\">*</bpt>pointer-operator<ept id=\"p1\">*</ept> is one of:","source":"and *pointer-operator* is one of:"},{"content":"Because a declarator may contain declarators, it is possible to construct the more complex derived types such as arrays of pointers, functions returning arrays of function pointers, by using the above rules.","pos":[7934,8141]},{"content":"To form each step of the construction, start with the identifier representing the base data type and apply the syntax rule above with the previous expression as the <ph id=\"ph1\">`declarator`</ph>.","pos":[8143,8321],"source":"  To form each step of the construction, start with the identifier representing the base data type and apply the syntax rule above with the previous expression as the `declarator`."},{"content":"The order that you apply the syntax rules should be the reverse of the way the expression is stated in English.","pos":[8323,8434]},{"content":"If applying the <bpt id=\"p1\">*</bpt>pointer-operator<ept id=\"p1\">*</ept> syntax rule to an array or function expression, use parentheses if you want a pointer to the array or function, as in the last row in the table below.","pos":[8436,8621],"source":"  If applying the *pointer-operator* syntax rule to an array or function expression, use parentheses if you want a pointer to the array or function, as in the last row in the table below."},{"content":"The following example shows the construction of \"pointer to array of 10 pointers to int\".","pos":[8628,8717]},{"content":"Verbal expression","pos":[8724,8741]},{"content":"Declarator","pos":[8742,8752]},{"content":"Syntax Rule Applied","pos":[8753,8772]},{"content":"1","pos":[8853,8854]},{"content":"pointer(s) to","pos":[8859,8872]},{"content":"5","pos":[8878,8879]},{"content":"array of 10","pos":[8884,8895]},{"content":"4","pos":[8907,8908]},{"content":"pointer to","pos":[8913,8923]},{"content":"6 and then 5","pos":[8938,8950]},{"content":"When multiple pointer, reference, array or function modifiers are used, declarators may become quite complicated.","pos":[8958,9071]},{"content":"The topic <bpt id=\"p1\">[</bpt>Interpreting More Complex Declarators<ept id=\"p1\">](../c-language/interpreting-more-complex-declarators.md)</ept> describes how to read more complex declarator syntax.","pos":[9073,9232],"source":"  The topic [Interpreting More Complex Declarators](../c-language/interpreting-more-complex-declarators.md) describes how to read more complex declarator syntax."},{"content":"The topic is applicable to both C and C++, although in C++, anywhere the * is used to indicate a pointer, a qualified name such as MyClass::<ph id=\"ph1\">\\*</ph> may be used to specify a pointer to a member of a class.","pos":[9234,9433],"source":"  The topic is applicable to both C and C++, although in C++, anywhere the * is used to indicate a pointer, a qualified name such as MyClass::\\* may be used to specify a pointer to a member of a class."}],"content":"---\ntitle: \"Overview of Declarators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"declarators, about declarators\"\nms.assetid: 0f2e2312-80bd-4154-8345-718bd9ed2173\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Overview of Declarators\nDeclarators are the components of a declaration that specify names of objects or functions. Declarators also specify whether or not the named object is an object, pointer, reference or array.  While declarators do not specify the base type, they do modify the type information in the basic type to specify derived types such as pointers, references, and arrays.  Applied to functions, the declarator works with the type specifier to fully specify the return type of a function to be an object, pointer, or reference. (Specifiers, discussed in [Declarations and Definitions](declarations-and-definitions-cpp.md), convey properties such as type and storage class. Modifiers, discussed in this section and in [Microsoft-Specific Modifiers](../cpp/microsoft-specific-modifiers.md), modify declarators.) The following figure shows a complete declaration of `MyFunction`, and calls out the components of the declaration.  \n  \n ![Modifiers, specifiers, and declarators](../cpp/media/vc38qy1.gif \"vc38QY1\")  \nSpecifiers, Modifiers, and Declarators  \n  \n **Microsoft Specific**  \n  \n Most Microsoft extended keywords can be used as modifiers to form derived types; they are not specifiers or declarators. (See [Microsoft-Specific Modifiers](../cpp/microsoft-specific-modifiers.md).)  \n  \n **END Microsoft Specific**  \n  \n Declarators appear in the declaration syntax after an optional list of specifiers. These specifiers are discussed in [Declarations.](declarations-and-definitions-cpp.md) A declaration can contain more than one declarator, but each declarator declares only one name.  \n  \n The following sample declaration shows how specifiers and declarators are combined to form a complete declaration:  \n  \n```  \nconst char *pch, ch;  \n```  \n  \n In the preceding declaration, the keywords **const** and `char` make up the list of specifiers. Two declarators are listed: `*pch` and `ch`.  A declaration that declares multiple entities consists of a type specifier followed by a comma-separated list of declarators, terminated with a semicolon.  \n  \n **Declarators for Simple Objects**  \n  \n The declarator of a simple object such as an int or double is simply its name, with optional parentheses.  \n  \n `int i; // declarator is i`  \n  \n `int (i); // declarator is (i)`  \n  \n **Declarators for Pointers, References and Arrays**  \n  \n Pointer operators inserted in front of the name cause the object to be a pointer or reference.  The **\\*** operator declares the name as a pointer; the **&** operator declares it as a reference.  \n  \n```  \nint *i; // declarator is *i  \nint **i; // declarator is **i;  \nint &i = x; // declaratory is &i  \n```  \n  \n Appending `const` or `volatile` give the pointer these special properties.  The use of these specifiers in a declarator (as opposed to in the type specifier) modifies the properties of the pointer, not the object pointed to:  \n  \n```  \nchar *const cpc; // const pointer to char   \nconst char *pcc; // pointer to const char   \nconst char *const cpcc; // const pointer to const char  \n```  \n  \n Further information may be found in [const and volatile Pointers](../cpp/const-and-volatile-pointers.md).  \n  \n A pointer to a member of a class or struct is declared with the appropriate nested name specifier:  \n  \n```  \nint X::* pIntMember;   \nint ::X::* pIntMember; // the initial :: specifies X is in global scope  \nchar Outer::Inner::* pIntMember; // pointer to char in a nested class  \n```  \n  \n Brackets enclosing an optional constant expression after the name cause the object to be an array.  Successive brackets declare additional dimensions to the array.  \n  \n```  \nint i[5]; // array with five elements of type int numbered from 0 to 4  \nint i[]; // array of unknown size  \nchar *s[4]; // array of pointers to char  \nint i[2][2]; // two dimensional array  \n```  \n  \n **Declarators for Functions**  \n  \n Parentheses containing the argument list are used after the name to declare a function.  The following declares a function of return type `int` and three arguments of type `int`.  \n  \n```  \nint f(int a, int b, int c);  \n```  \n  \n For information on argument lists, see [Function Declarations](http://msdn.microsoft.com/en-us/3f9b4e14-60d2-47c1-acd8-4fa8fc988be7).  \n  \n Pointers and references to functions are declared by prepending the pointer or reference operator to the function name as shown below.  Parentheses, normally optional, are required to distinguish a pointer to a function from a function that returns a pointer:  \n  \n```  \nint (*pf)(int); // pointer to function returning int  \nint *f(int i); // function returning pointer to int  \nint (&pf)(int); // reference to function   \n```  \n  \n Pointers to member functions are distinguished by nested name specifiers:  \n  \n```  \nint (X::* pmf)(); // pointer to member function of X returning int  \nint* (X::* pmf)(); // pointer to member function returning pointer to int  \n```  \n  \n See also [Pointers to Members](../cpp/pointers-to-members.md).  \n  \n **Functions and objects in the same declaration**  \n  \n Functions and objects may be declared in the same declaration as follows:  \n  \n```  \nint i, *j, f(int k);  // int, pointer to int, function returning int  \n```  \n  \n The syntax may be misleading in some circumstances.  The following declaration  \n  \n```  \nint* i, f(int k);  // pointer to int, function returning int (not int*)  \n```  \n  \n may look like the declaration of an `int` pointer and a function returning `int*`, but it is not.  That's because the * is part of the declarator for `i`, not part of the declarator for `f`.  \n  \n **Simplifying declarator syntax with typedef**  \n  \n A better technique, however, is to use a `typedef` or a combination of parentheses and the `typedef` keyword. Consider declaring an array of pointers to functions:  \n  \n```  \n//  Function returning type int that takes one   \n//   argument of type char *.  \ntypedef int (*PIFN)( char * );  \n//  Declare an array of 7 pointers to functions   \n//   returning int and taking one argument of type   \n//   char *.  \nPIFN pifnDispatchArray[7];  \n```  \n  \n The equivalent declaration can be written without the `typedef` declaration, but it is so complicated that the potential for error exceeds any benefits:  \n  \n```  \nint ( *pifnDispatchArray[7] )( char * );  \n```  \n  \n For more information on typedef, see [typedef Specifier](http://msdn.microsoft.com/en-us/cc96cf26-ba93-4179-951e-695d1f5fdcf1).  \n  \n Pointers, references, arrays of a single base type can be combined in a single declaration (separated by commas) as  \n  \n```  \nint a, *b, c[5], **d, &e=a;  \n```  \n  \n **More complex declarator syntax**  \n  \n-   Pointer, reference, array, and function declarators may be combined to specify such objects as arrays of pointers to functions, pointers to arrays, etc.  \n  \n-   The following recursive grammar describes pointer declarator syntax fully.  \n  \n-   A `declarator` is defined as one of:  \n  \n```  \n1. identifier   \n2. qualified-name   \n3. declarator ( argument-list ) [cv-qualfiers] [exception-spec]  \n4. declarator [ [ constant-expression ] ]   \n  \n5. pointer-operatordeclarator   \n6. ( declarator )  \n```  \n  \n-   and *pointer-operator* is one of:  \n  \n```  \n  \n      * [cv-qualifiers]  \n& [cv-qualifiers]  \n::nested-name-specifier * [cv-qualfiers]  \n```  \n  \n Because a declarator may contain declarators, it is possible to construct the more complex derived types such as arrays of pointers, functions returning arrays of function pointers, by using the above rules.  To form each step of the construction, start with the identifier representing the base data type and apply the syntax rule above with the previous expression as the `declarator`.  The order that you apply the syntax rules should be the reverse of the way the expression is stated in English.  If applying the *pointer-operator* syntax rule to an array or function expression, use parentheses if you want a pointer to the array or function, as in the last row in the table below.  \n  \n The following example shows the construction of \"pointer to array of 10 pointers to int\".  \n  \n|Verbal expression|Declarator|Syntax Rule Applied|  \n|-----------------------|----------------|-------------------------|  \n||`i`|1|  \n|pointer(s) to|`*i`|5|  \n|array of 10|`(*i)[10]`|4|  \n|pointer to|`*((*i)[10])`|6 and then 5|  \n  \n When multiple pointer, reference, array or function modifiers are used, declarators may become quite complicated.  The topic [Interpreting More Complex Declarators](../c-language/interpreting-more-complex-declarators.md) describes how to read more complex declarator syntax.  The topic is applicable to both C and C++, although in C++, anywhere the * is used to indicate a pointer, a qualified name such as MyClass::\\* may be used to specify a pointer to a member of a class."}