{"nodes":[{"pos":[12,50],"content":"Double Thunking (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Double Thunking (C++) | Microsoft Docs","pos":[0,38]}]},{"content":"Double Thunking (C++)","pos":[752,773]},{"content":"Double thunking refers to the loss of performance you can experience when a function call in a managed context calls a Visual C++ managed function and where program execution calls the function's native entry point in order to call the managed function.","pos":[774,1027]},{"content":"This topic discusses where double thunking occurs and how you can avoid it to improve performance.","pos":[1028,1126]},{"content":"Remarks","pos":[1135,1142]},{"content":"By default, when compiling with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> (not <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept>), the definition of a managed function causes the compiler to generate a managed entry point and a native entry point.","pos":[1146,1324],"source":"By default, when compiling with **/clr** (not **/clr:pure**), the definition of a managed function causes the compiler to generate a managed entry point and a native entry point."},{"content":"This allows the managed function to be called from native and managed call sites.","pos":[1325,1406]},{"content":"However, when a native entry point exists, it can be the entry point for all calls to the function.","pos":[1407,1506]},{"content":"If a calling function is managed, the native entry point will then call the managed entry point.","pos":[1507,1603]},{"content":"In effect, two calls are required to invoke the function (hence, double thunking).","pos":[1604,1686]},{"content":"For example, virtual functions are always called through a native entry point.","pos":[1687,1765]},{"pos":[1772,1997],"content":"One resolution is to tell the compiler not to generate a native entry point for a managed function, that the function will only be called from a managed context, by using the <bpt id=\"p1\">[</bpt>__clrcall<ept id=\"p1\">](../cpp/clrcall.md)</ept> calling convention.","source":"One resolution is to tell the compiler not to generate a native entry point for a managed function, that the function will only be called from a managed context, by using the [__clrcall](../cpp/clrcall.md) calling convention."},{"content":"Similarly, if you export (<bpt id=\"p1\">[</bpt>dllexport, dllimport<ept id=\"p1\">](../cpp/dllexport-dllimport.md)</ept>) a managed function, a native entry point is generated and any function that imports and calls that function will call through the native entry point.","pos":[2004,2234],"source":"Similarly, if you export ([dllexport, dllimport](../cpp/dllexport-dllimport.md)) a managed function, a native entry point is generated and any function that imports and calls that function will call through the native entry point."},{"content":"To avoid double thunking in this situation, do not use native export/import semantics; simply reference the metadata via <ph id=\"ph1\">`#using`</ph> (see <bpt id=\"p1\">[</bpt>#using Directive<ept id=\"p1\">](../preprocessor/hash-using-directive-cpp.md)</ept>).","pos":[2235,2435],"source":" To avoid double thunking in this situation, do not use native export/import semantics; simply reference the metadata via `#using` (see [#using Directive](../preprocessor/hash-using-directive-cpp.md))."},{"content":"The compiler has been updated to reduce unnecessary double thunking.","pos":[2442,2510]},{"content":"For example, any function with a managed type in the signature (including return type) will implicitly be marked as <ph id=\"ph1\">`__clrcall`</ph>.","pos":[2511,2639],"source":" For example, any function with a managed type in the signature (including return type) will implicitly be marked as `__clrcall`."},{"content":"For more information on double thunk elimination, see <bpt id=\"p1\">[</bpt>http://msdn.microsoft.com/msdnmag/issues/05/01/COptimizations/default.aspx<ept id=\"p1\">](http://msdn.microsoft.com/msdnmag/issues/05/01/COptimizations/default.aspx)</ept>.","pos":[2640,2847],"source":" For more information on double thunk elimination, see [http://msdn.microsoft.com/msdnmag/issues/05/01/COptimizations/default.aspx](http://msdn.microsoft.com/msdnmag/issues/05/01/COptimizations/default.aspx)."},{"content":"Example","pos":[2856,2863]},{"content":"Description","pos":[2873,2884]},{"content":"The following sample demonstrates double thunking.","pos":[2888,2938]},{"content":"When compiled native (without <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>), the call to the virtual function in <ph id=\"ph1\">`main`</ph> generates one call to <ph id=\"ph2\">`T`</ph>'s copy constructor and one call to the destructor.","pos":[2939,3099],"source":" When compiled native (without **/clr**), the call to the virtual function in `main` generates one call to `T`'s copy constructor and one call to the destructor."},{"content":"Similar behavior is achieved when the virtual function is declared with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`__clrcall`</ph>.","pos":[3100,3197],"source":" Similar behavior is achieved when the virtual function is declared with **/clr** and `__clrcall`."},{"content":"However, when just compiled with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>, the function call generates a call to the copy constructor but there is another call to the copy constructor due to the native-to-managed thunk.","pos":[3198,3385],"source":" However, when just compiled with **/clr**, the function call generates a call to the copy constructor but there is another call to the copy constructor due to the native-to-managed thunk."},{"content":"Code","pos":[3395,3399]},{"content":"Sample Output","pos":[3962,3975]},{"content":"Example","pos":[4214,4221]},{"content":"Description","pos":[4231,4242]},{"content":"The previous sample demonstrated the existence of double thunking.","pos":[4246,4312]},{"content":"This sample shows its effect.","pos":[4313,4342]},{"content":"The <ph id=\"ph1\">`for`</ph> loop calls the virtual function and the program reports execution time.","pos":[4343,4424],"source":" The `for` loop calls the virtual function and the program reports execution time."},{"content":"The slowest time is reported when the program is compiled with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>.","pos":[4425,4497],"source":" The slowest time is reported when the program is compiled with **/clr**."},{"content":"The fastest times are reported when compiling without <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> or if the virtual function is declared with <ph id=\"ph1\">`__clrcall`</ph>.","pos":[4498,4617],"source":" The fastest times are reported when compiling without **/clr** or if the virtual function is declared with `__clrcall`."},{"content":"Code","pos":[4627,4631]},{"content":"Sample Output","pos":[5307,5320]},{"content":"See Also","pos":[5383,5391]},{"content":"Mixed (Native and Managed) Assemblies","pos":[5396,5433]}],"content":"---\ntitle: \"Double Thunking (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"double thunks\"\n  - \"interop [C++], double thunking\"\n  - \"mixed assemblies [C++], double thunking\"\n  - \"/clr compiler option [C++], double thunking\"\n  - \"interoperability [C++], double thunking\"\nms.assetid: a85090b2-dc3c-498a-b40c-340db229dd6f\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Double Thunking (C++)\nDouble thunking refers to the loss of performance you can experience when a function call in a managed context calls a Visual C++ managed function and where program execution calls the function's native entry point in order to call the managed function. This topic discusses where double thunking occurs and how you can avoid it to improve performance.  \n  \n## Remarks  \n By default, when compiling with **/clr** (not **/clr:pure**), the definition of a managed function causes the compiler to generate a managed entry point and a native entry point. This allows the managed function to be called from native and managed call sites. However, when a native entry point exists, it can be the entry point for all calls to the function. If a calling function is managed, the native entry point will then call the managed entry point. In effect, two calls are required to invoke the function (hence, double thunking). For example, virtual functions are always called through a native entry point.  \n  \n One resolution is to tell the compiler not to generate a native entry point for a managed function, that the function will only be called from a managed context, by using the [__clrcall](../cpp/clrcall.md) calling convention.  \n  \n Similarly, if you export ([dllexport, dllimport](../cpp/dllexport-dllimport.md)) a managed function, a native entry point is generated and any function that imports and calls that function will call through the native entry point. To avoid double thunking in this situation, do not use native export/import semantics; simply reference the metadata via `#using` (see [#using Directive](../preprocessor/hash-using-directive-cpp.md)).  \n  \n The compiler has been updated to reduce unnecessary double thunking. For example, any function with a managed type in the signature (including return type) will implicitly be marked as `__clrcall`. For more information on double thunk elimination, see [http://msdn.microsoft.com/msdnmag/issues/05/01/COptimizations/default.aspx](http://msdn.microsoft.com/msdnmag/issues/05/01/COptimizations/default.aspx).  \n  \n## Example  \n  \n### Description  \n The following sample demonstrates double thunking. When compiled native (without **/clr**), the call to the virtual function in `main` generates one call to `T`'s copy constructor and one call to the destructor. Similar behavior is achieved when the virtual function is declared with **/clr** and `__clrcall`. However, when just compiled with **/clr**, the function call generates a call to the copy constructor but there is another call to the copy constructor due to the native-to-managed thunk.  \n  \n### Code  \n  \n```  \n// double_thunking.cpp  \n// compile with: /clr  \n#include <stdio.h>  \nstruct T {  \n   T() {  \n      puts(__FUNCSIG__);  \n   }  \n  \n   T(const T&) {  \n      puts(__FUNCSIG__);  \n   }  \n  \n   ~T() {  \n      puts(__FUNCSIG__);  \n   }  \n  \n   T& operator=(const T&) {  \n      puts(__FUNCSIG__);  \n      return *this;  \n   }  \n};  \n  \nstruct S {  \n   virtual void /* __clrcall */ f(T t) {};  \n} s;  \n  \nint main() {  \n   S* pS = &s;  \n   T t;  \n  \n   printf(\"calling struct S\\n\");  \n   pS->f(t);  \n   printf(\"after calling struct S\\n\");  \n}  \n```  \n  \n### Sample Output  \n  \n```  \n__thiscall T::T(void)  \ncalling struct S  \n__thiscall T::T(const struct T &)  \n__thiscall T::T(const struct T &)  \n__thiscall T::~T(void)  \n__thiscall T::~T(void)  \nafter calling struct S  \n__thiscall T::~T(void)  \n```  \n  \n## Example  \n  \n### Description  \n The previous sample demonstrated the existence of double thunking. This sample shows its effect. The `for` loop calls the virtual function and the program reports execution time. The slowest time is reported when the program is compiled with **/clr**. The fastest times are reported when compiling without **/clr** or if the virtual function is declared with `__clrcall`.  \n  \n### Code  \n  \n```  \n// double_thunking_2.cpp  \n// compile with: /clr  \n#include <time.h>  \n#include <stdio.h>   \n  \n#pragma unmanaged  \nstruct T {  \n   T() {}  \n   T(const T&) {}  \n   ~T() {}  \n   T& operator=(const T&) { return *this; }  \n};  \n  \nstruct S {  \n   virtual void /* __clrcall */ f(T t) {};  \n} s;  \n  \nint main() {  \n   S* pS = &s;  \n   T t;  \n   clock_t start, finish;  \n   double  duration;  \n   start = clock();  \n  \n   for ( int i = 0 ; i < 1000000 ; i++ )  \n      pS->f(t);  \n  \n   finish = clock();  \n   duration = (double)(finish - start) / (CLOCKS_PER_SEC);  \n   printf( \"%2.1f seconds\\n\", duration );  \n   printf(\"after calling struct S\\n\");  \n}  \n```  \n  \n### Sample Output  \n  \n```  \n4.2 seconds  \nafter calling struct S  \n```  \n  \n## See Also  \n [Mixed (Native and Managed) Assemblies](../dotnet/mixed-native-and-managed-assemblies.md)"}