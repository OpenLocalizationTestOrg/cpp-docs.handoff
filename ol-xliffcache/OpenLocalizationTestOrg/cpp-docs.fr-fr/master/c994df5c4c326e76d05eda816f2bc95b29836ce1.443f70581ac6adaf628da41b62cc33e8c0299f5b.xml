{"nodes":[{"pos":[12,63],"content":"User-Defined Conversions (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"User-Defined Conversions (C++-CLI) | Microsoft Docs","pos":[0,51]}]},{"content":"User-Defined Conversions (C++/CLI)","pos":[603,637]},{"content":"This section discusses user-defined conversions (UDC) when one of the types in the conversion is a reference or instance of a value type or reference type.","pos":[638,793]},{"content":"Implicit and explicit conversions","pos":[802,835]},{"content":"A user-defined conversion can either be implicit or explicit.","pos":[839,900]},{"content":"A UDC should be implicit if the conversion does not result in a loss of information.","pos":[902,986]},{"content":"Otherwise an explicit UDC should be defined.","pos":[987,1031]},{"content":"A native class's constructor can be used to convert a reference or value type to a native class.","pos":[1038,1134]},{"pos":[1141,1300],"content":"For more information about conversions, see <bpt id=\"p1\">[</bpt>Boxing<ept id=\"p1\">](../windows/boxing-cpp-component-extensions.md)</ept> and <bpt id=\"p2\">[</bpt>Standard Conversions<ept id=\"p2\">](../cpp/standard-conversions.md)</ept>.","source":"For more information about conversions, see [Boxing](../windows/boxing-cpp-component-extensions.md) and [Standard Conversions](../cpp/standard-conversions.md)."},{"content":"Output","pos":[2162,2168]},{"content":"Convert-From Operators","pos":[2220,2242]},{"content":"Convert-from operators create an object of the class in which the operator is defined from an object of some other class.","pos":[2246,2367]},{"content":"Standard C++ does not support convert-from operators; standard C++ uses constructors for this purpose.","pos":[2374,2476]},{"content":"However, when using CLR types, Visual C++ provide syntactic support for calling convert-from operators.","pos":[2477,2580]},{"content":"To interoperate well with other CLS-compliant languages, you may wish to wrap each user-defined unary constructor for a given class with a corresponding convert-from operator.","pos":[2587,2762]},{"content":"Convert-from operators:","pos":[2769,2792]},{"content":"Shall be defined as static functions.","pos":[2802,2839]},{"content":"Can either be implicit (for conversions that do not lose precision such as short-to-int) or explicit, when there may be a loss of precision.","pos":[2849,2989]},{"content":"Shall return an object of the containing class.","pos":[2999,3046]},{"content":"Shall have the \"from\" type as the sole parameter type.","pos":[3056,3110]},{"content":"The following sample shows an implicit and explicit \"convert-from\", user-defined conversion (UDC) operator.","pos":[3117,3224]},{"content":"Output","pos":[4185,4191]},{"content":"Convert-to operators","pos":[4263,4283]},{"content":"Convert-to operators convert an object of the class in which the operator is defined to some other object.","pos":[4287,4393]},{"content":"The following sample shows an implicit, convert-to, user-defined conversion operator:","pos":[4394,4479]},{"content":"Output","pos":[4867,4873]},{"content":"An explicit user-defined convert-to conversion operator is appropriate for conversions that potentially lose data in some way.","pos":[4908,5034]},{"content":"To invoke an explicit convert-to operator, a cast must be used.","pos":[5035,5098]},{"content":"Output","pos":[5529,5535]},{"content":"To convert generic classes","pos":[5579,5605]},{"content":"You can convert a generic class to T.","pos":[5609,5646]},{"content":"Output","pos":[6017,6023]},{"content":"A converting constructor takes a type and uses it to create an object.","pos":[6060,6130]},{"content":"A converting constructor is called with direct initialization only; casts will not invoke converting constructors.","pos":[6132,6246]},{"content":"By default, converting constructors are explicit for CLR types.","pos":[6247,6310]},{"content":"Output","pos":[6756,6762]},{"content":"In this code sample, an implicit static conversion function does the same thing as an explicit conversion constructor.","pos":[6800,6918]},{"content":"Output","pos":[7560,7566]},{"content":"See Also","pos":[7621,7629]},{"content":"Classes and Structs","pos":[7634,7653]}],"content":"---\ntitle: \"User-Defined Conversions (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"user-defined conversions [C++]\"\nms.assetid: 8010fd59-2775-4e9a-a6ed-58055032d66f\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# User-Defined Conversions (C++/CLI)\nThis section discusses user-defined conversions (UDC) when one of the types in the conversion is a reference or instance of a value type or reference type.  \n  \n## Implicit and explicit conversions  \n A user-defined conversion can either be implicit or explicit.  A UDC should be implicit if the conversion does not result in a loss of information. Otherwise an explicit UDC should be defined.  \n  \n A native class's constructor can be used to convert a reference or value type to a native class.  \n  \n For more information about conversions, see [Boxing](../windows/boxing-cpp-component-extensions.md) and [Standard Conversions](../cpp/standard-conversions.md).  \n  \n```  \n// mcpp_User_Defined_Conversions.cpp  \n// compile with: /clr  \n#include \"stdio.h\"  \nref class R;  \nclass N;  \n  \nvalue class V {  \n   static operator V(R^) {  \n      return V();  \n   }  \n};  \n  \nref class R {  \npublic:  \n   static operator N(R^);  \n   static operator V(R^) {  \n      System::Console::WriteLine(\"in R::operator N\");  \n      return V();  \n   }  \n};  \n  \nclass N {  \npublic:  \n   N(R^) {  \n      printf(\"in N::N\\n\");  \n   }  \n};  \n  \nR::operator N(R^) {  \n   System::Console::WriteLine(\"in R::operator N\");  \n   return N(nullptr);  \n}  \n  \nint main() {  \n   // Direct initialization:  \n   R ^r2;  \n   N n2(r2);   // direct initialization, calls constructor  \n   static_cast<N>(r2);   // also direct initialization  \n  \n   R ^r3;  \n   // ambiguous V::operator V(R^) and R::operator V(R^)  \n   // static_cast<V>(r3);     \n}  \n```  \n  \n **Output**  \n  \n```Output  \nin N::N  \nin N::N  \n```  \n  \n## Convert-From Operators  \n Convert-from operators create an object of the class in which the operator is defined from an object of some other class.  \n  \n Standard C++ does not support convert-from operators; standard C++ uses constructors for this purpose. However, when using CLR types, Visual C++ provide syntactic support for calling convert-from operators.  \n  \n To interoperate well with other CLS-compliant languages, you may wish to wrap each user-defined unary constructor for a given class with a corresponding convert-from operator.  \n  \n Convert-from operators:  \n  \n-   Shall be defined as static functions.  \n  \n-   Can either be implicit (for conversions that do not lose precision such as short-to-int) or explicit, when there may be a loss of precision.  \n  \n-   Shall return an object of the containing class.  \n  \n-   Shall have the \"from\" type as the sole parameter type.  \n  \n The following sample shows an implicit and explicit \"convert-from\", user-defined conversion (UDC) operator.  \n  \n```  \n// clr_udc_convert_from.cpp  \n// compile with: /clr  \nvalue struct MyDouble {  \n   double d;  \n  \n   MyDouble(int i) {  \n      d = static_cast<double>(i);  \n      System::Console::WriteLine(\"in constructor\");  \n   }  \n  \n   // Wrap the constructor with a convert-from operator.  \n   // implicit UDC because conversion cannot lose precision  \n   static operator MyDouble (int i) {  \n      System::Console::WriteLine(\"in operator\");  \n      // call the constructor  \n      MyDouble d(i);  \n      return d;  \n   }  \n  \n   // an explicit user-defined conversion operator  \n   static explicit operator signed short int (MyDouble) {  \n      return 1;  \n   }  \n};  \n  \nint main() {  \n   int i = 10;  \n   MyDouble md = i;  \n   System::Console::WriteLine(md.d);  \n  \n   // using explicit user-defined conversion operator requires a cast    \n   unsigned short int j = static_cast<unsigned short int>(md);  \n   System::Console::WriteLine(j);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nin operator  \nin constructor  \n10  \n1  \n```  \n  \n## Convert-to operators  \n Convert-to operators convert an object of the class in which the operator is defined to some other object. The following sample shows an implicit, convert-to, user-defined conversion operator:  \n  \n```  \n// clr_udc_convert_to.cpp  \n// compile with: /clr  \nusing namespace System;  \nvalue struct MyInt {  \n   Int32 i;  \n  \n   // convert MyInt to String^  \n   static operator String^ ( MyInt val ) {  \n      return val.i.ToString();  \n   }  \n  \n   MyInt(int _i) : i(_i) {}  \n};  \n  \nint main() {  \n   MyInt mi(10);  \n   String ^s = mi;  \n   Console::WriteLine(s);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n10  \n```  \n  \n An explicit user-defined convert-to conversion operator is appropriate for conversions that potentially lose data in some way. To invoke an explicit convert-to operator, a cast must be used.  \n  \n```  \n// clr_udc_convert_to_2.cpp  \n// compile with: /clr  \nvalue struct MyDouble {  \n   double d;  \n   // convert MyDouble to Int32  \n   static explicit operator System::Int32 ( MyDouble val ) {  \n      return (int)val.d;  \n   }  \n};  \n  \nint main() {  \n   MyDouble d;  \n   d.d = 10.3;  \n   System::Console::WriteLine(d.d);  \n   int i = 0;  \n   i = static_cast<int>(d);  \n   System::Console::WriteLine(i);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n10.3  \n10  \n```  \n  \n## To convert generic classes  \n You can convert a generic class to T.  \n  \n```  \n// clr_udc_generics.cpp  \n// compile with: /clr  \ngeneric<class T>   \npublic value struct V {  \n   T mem;  \n   static operator T(V v) {  \n      return v.mem;  \n   }  \n  \n   void f(T t) {  \n      mem = t;  \n   }  \n};  \n  \nint main() {  \n   V<int> v;  \n   v.f(42);  \n   int i = v;  \n   i += v;  \n   System::Console::WriteLine(i == (42 * 2) );  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nTrue  \n```  \n  \n A converting constructor takes a type and uses it to create an object.  A converting constructor is called with direct initialization only; casts will not invoke converting constructors. By default, converting constructors are explicit for CLR types.  \n  \n```  \n// clr_udc_converting_constructors.cpp  \n// compile with: /clr  \npublic ref struct R {  \n   int m;  \n   char c;  \n  \n   R(int i) : m(i) { }  \n   R(char j) : c(j) { }  \n};  \n  \npublic value struct V {  \n   R^ ptr;  \n   int m;  \n  \n   V(R^ r) : ptr(r) { }  \n   V(int i) : m(i) { }  \n};  \n  \nint main() {   \n   R^ r = gcnew R(5);  \n  \n   System::Console::WriteLine( V(5).m);  \n   System::Console::WriteLine( V(r).ptr);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n5  \nR  \n```  \n  \n In this code sample, an implicit static conversion function does the same thing as an explicit conversion constructor.  \n  \n```  \npublic value struct V {  \n   int m;  \n   V(int i) : m(i) {}  \n   static operator V(int i) {  \n      V v(i*100);  \n      return v;  \n   }  \n};  \n  \npublic ref struct R {  \n   int m;  \n   R(int i) : m(i) {}  \n   static operator R^(int i) {  \n      return gcnew R(i*100);  \n   }  \n};  \n  \nint main() {  \n   V v(13);   // explicit  \n   R^ r = gcnew R(12);   // explicit  \n  \n   System::Console::WriteLine(v.m);  \n   System::Console::WriteLine(r->m);  \n  \n   // explicit ctor can't be called here: not ambiguous  \n   v = 5;  \n   r = 20;  \n  \n   System::Console::WriteLine(v.m);  \n   System::Console::WriteLine(r->m);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n13  \n12  \n500  \n2000  \n```  \n  \n## See Also  \n [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)"}