{"nodes":[{"pos":[12,51],"content":"_CrtIsValidHeapPointer | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_CrtIsValidHeapPointer | Microsoft Docs","pos":[0,39]}]},{"pos":[992,1014],"content":"_CrtIsValidHeapPointer","linkify":"_CrtIsValidHeapPointer","nodes":[{"content":"_CrtIsValidHeapPointer","pos":[0,22]}]},{"content":"Verifies that a specified pointer is in a heap allocated by some C run-time library, but not necessarily by the caller's CRT library.","pos":[1015,1148]},{"content":"In versions of the CRT before Visual Studio 2010, this verifies that the specified pointer is in the local heap (debug version only).","pos":[1149,1282]},{"pos":[1291,1297],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1395,1405],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Pointer to the beginning of an allocated memory block.","pos":[1423,1477]},{"pos":[1486,1498],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"<ph id=\"ph1\">`_CrtIsValidHeapPointer`</ph> returns TRUE if the specified pointer is in the heap shared by all CRT library instances.","pos":[1502,1616],"source":"`_CrtIsValidHeapPointer` returns TRUE if the specified pointer is in the heap shared by all CRT library instances."},{"content":"In versions of the CRT before Visual Studio 2010, this returns TRUE if the specified pointer is in the local heap.","pos":[1617,1731]},{"content":"Otherwise, the function returns FALSE.","pos":[1732,1770]},{"pos":[1779,1786],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"We do not recommend that you use this function.","pos":[1790,1837]},{"content":"Starting with the Visual Studio 2010 CRT library, all CRT libraries share one OS heap, the <bpt id=\"p1\">*</bpt>process heap<ept id=\"p1\">*</ept>.","pos":[1838,1944],"source":" Starting with the Visual Studio 2010 CRT library, all CRT libraries share one OS heap, the *process heap*."},{"content":"The <ph id=\"ph1\">`_CrtIsValidHeapPointer`</ph> function reports whether the pointer was allocated in a CRT heap, but not that it was allocated by the caller's CRT library.","pos":[1945,2098],"source":" The `_CrtIsValidHeapPointer` function reports whether the pointer was allocated in a CRT heap, but not that it was allocated by the caller's CRT library."},{"content":"For example, consider a block allocated by using the Visual Studio 2010 version of the CRT library.","pos":[2099,2198]},{"content":"If the <ph id=\"ph1\">`_CrtIsValidHeapPointer`</ph> function exported by the Visual Studio 2012 version of the CRT library tests the pointer, it returns TRUE.","pos":[2199,2337],"source":" If the `_CrtIsValidHeapPointer` function exported by the Visual Studio 2012 version of the CRT library tests the pointer, it returns TRUE."},{"content":"This is no longer a useful test.","pos":[2338,2370]},{"content":"In versions of the CRT library before Visual Studio 2010, the function is used to ensure that a specific memory address is within the local heap.","pos":[2371,2516]},{"content":"The local heap refers to the heap created and managed by a particular instance of the C run-time library.","pos":[2517,2622]},{"content":"If a dynamic-link library (DLL) contains a static link to the run-time library, it has its own instance of the run-time heap, and therefore its own heap, independent of the application's local heap.","pos":[2623,2821]},{"content":"When <bpt id=\"p1\">[</bpt>_DEBUG<ept id=\"p1\">](../../c-runtime-library/debug.md)</ept> is not defined, calls to <ph id=\"ph1\">`_CrtIsValidHeapPointer`</ph> are removed during preprocessing.","pos":[2822,2953],"source":" When [_DEBUG](../../c-runtime-library/debug.md) is not defined, calls to `_CrtIsValidHeapPointer` are removed during preprocessing."},{"content":"Because this function returns TRUE or FALSE, it can be passed to one of the <bpt id=\"p1\">[</bpt>_ASSERT<ept id=\"p1\">](../../c-runtime-library/reference/assert-asserte-assert-expr-macros.md)</ept> macros to create a simple debugging error handling mechanism.","pos":[2960,3179],"source":"Because this function returns TRUE or FALSE, it can be passed to one of the [_ASSERT](../../c-runtime-library/reference/assert-asserte-assert-expr-macros.md) macros to create a simple debugging error handling mechanism."},{"content":"The following example causes an assertion failure if the specified address is not located within the local heap:","pos":[3180,3292]},{"content":"For more information about how <ph id=\"ph1\">`_CrtIsValidHeapPointer`</ph> can be used with other debug functions and macros, see <bpt id=\"p1\">[</bpt>Macros for Reporting<ept id=\"p1\">](/visualstudio/debugger/macros-for-reporting)</ept>.","pos":[3364,3543],"source":"For more information about how `_CrtIsValidHeapPointer` can be used with other debug functions and macros, see [Macros for Reporting](/visualstudio/debugger/macros-for-reporting)."},{"content":"For information about how memory blocks are allocated, initialized, and managed in the debug version of the base heap, see <bpt id=\"p1\">[</bpt>CRT Debug Heap Details<ept id=\"p1\">](/visualstudio/debugger/crt-debug-heap-details)</ept>.","pos":[3544,3739],"source":" For information about how memory blocks are allocated, initialized, and managed in the debug version of the base heap, see [CRT Debug Heap Details](/visualstudio/debugger/crt-debug-heap-details)."},{"pos":[3748,3760],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[3767,3774]},{"content":"Required header","pos":[3775,3790]},{"content":"<ph id=\"ph1\">\\&lt;</ph>crtdbg.h&gt;","pos":[3860,3871],"source":"\\<crtdbg.h>"},{"pos":[3879,3997],"content":"For more compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept> in the Introduction.","source":"For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction."},{"pos":[4006,4015],"content":"Libraries","linkify":"Libraries","nodes":[{"content":"Libraries","pos":[0,9]}]},{"pos":[4019,4114],"content":"Debug versions of <bpt id=\"p1\">[</bpt>C run-time libraries<ept id=\"p1\">](../../c-runtime-library/crt-library-features.md)</ept> only.","source":"Debug versions of [C run-time libraries](../../c-runtime-library/crt-library-features.md) only."},{"pos":[4123,4130],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example demonstrates how to test whether memory is valid when it is used with C run-time libraries before Visual Studio 2010.","pos":[4134,4273]},{"content":"This example is provided for users of legacy CRT library code.","pos":[4274,4336]},{"pos":[5870,5876],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"pos":[5986,6011],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"Not applicable.","pos":[6015,6030]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[6031,6078],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[6079,6204],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[6213,6221],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[6225,6284],"content":"<bpt id=\"p1\">[</bpt>Debug Routines<ept id=\"p1\">](../../c-runtime-library/debug-routines.md)</ept>","source":"[Debug Routines](../../c-runtime-library/debug-routines.md)"}],"content":"---\ntitle: \"_CrtIsValidHeapPointer | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_CrtIsValidHeapPointer\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"CrtlsValidHeapPointer\"\n  - \"_CrtIsValidHeapPointer\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"_CrtIsValidHeapPointer function\"\n  - \"CrtIsValidHeapPointer function\"\nms.assetid: caf597ce-1b05-4764-9f37-0197a982bec5\ncaps.latest.revision: 12\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _CrtIsValidHeapPointer\nVerifies that a specified pointer is in a heap allocated by some C run-time library, but not necessarily by the caller's CRT library. In versions of the CRT before Visual Studio 2010, this verifies that the specified pointer is in the local heap (debug version only).  \n  \n## Syntax  \n  \n```  \n  \n      int _CrtIsValidHeapPointer(   \n   const void *userData   \n);  \n```  \n  \n#### Parameters  \n `userData`  \n Pointer to the beginning of an allocated memory block.  \n  \n## Return Value  \n `_CrtIsValidHeapPointer` returns TRUE if the specified pointer is in the heap shared by all CRT library instances. In versions of the CRT before Visual Studio 2010, this returns TRUE if the specified pointer is in the local heap. Otherwise, the function returns FALSE.  \n  \n## Remarks  \n We do not recommend that you use this function. Starting with the Visual Studio 2010 CRT library, all CRT libraries share one OS heap, the *process heap*. The `_CrtIsValidHeapPointer` function reports whether the pointer was allocated in a CRT heap, but not that it was allocated by the caller's CRT library. For example, consider a block allocated by using the Visual Studio 2010 version of the CRT library. If the `_CrtIsValidHeapPointer` function exported by the Visual Studio 2012 version of the CRT library tests the pointer, it returns TRUE. This is no longer a useful test. In versions of the CRT library before Visual Studio 2010, the function is used to ensure that a specific memory address is within the local heap. The local heap refers to the heap created and managed by a particular instance of the C run-time library. If a dynamic-link library (DLL) contains a static link to the run-time library, it has its own instance of the run-time heap, and therefore its own heap, independent of the application's local heap. When [_DEBUG](../../c-runtime-library/debug.md) is not defined, calls to `_CrtIsValidHeapPointer` are removed during preprocessing.  \n  \n Because this function returns TRUE or FALSE, it can be passed to one of the [_ASSERT](../../c-runtime-library/reference/assert-asserte-assert-expr-macros.md) macros to create a simple debugging error handling mechanism. The following example causes an assertion failure if the specified address is not located within the local heap:  \n  \n```  \n_ASSERTE( _CrtIsValidHeapPointer( userData ) );  \n```  \n  \n For more information about how `_CrtIsValidHeapPointer` can be used with other debug functions and macros, see [Macros for Reporting](/visualstudio/debugger/macros-for-reporting). For information about how memory blocks are allocated, initialized, and managed in the debug version of the base heap, see [CRT Debug Heap Details](/visualstudio/debugger/crt-debug-heap-details).  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`_CrtIsValidHeapPointer`|\\<crtdbg.h>|  \n  \n For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction.  \n  \n## Libraries  \n Debug versions of [C run-time libraries](../../c-runtime-library/crt-library-features.md) only.  \n  \n## Example  \n The following example demonstrates how to test whether memory is valid when it is used with C run-time libraries before Visual Studio 2010. This example is provided for users of legacy CRT library code.  \n  \n```  \n// crt_isvalid.c  \n/*  \n * This program allocates a block of memory using _malloc_dbg  \n * and then tests the validity of this memory by calling   \n * _CrtIsMemoryBlock,_CrtIsValidPointer, and _CrtIsValidHeapPointer.  \n */  \n  \n#include <stdio.h>  \n#include <string.h>  \n#include <malloc.h>  \n#include <crtdbg.h>  \n  \n#define  TRUE   1  \n#define  FALSE  0  \n  \nint main( void )  \n{  \n        char *my_pointer;  \n  \n        /*   \n         * Call _malloc_dbg to include the filename and line number  \n         * of our allocation request in the header information  \n         */  \n        my_pointer = (char *)_malloc_dbg( sizeof(char) * 10,   \n        _NORMAL_BLOCK, __FILE__, __LINE__ );  \n  \n        // Ensure that the memory got allocated correctly  \n        _CrtIsMemoryBlock((const void *)my_pointer, sizeof(char) * 10,   \n        NULL, NULL, NULL );  \n  \n         // Test for read/write accessibility  \n        if (_CrtIsValidPointer((const void *)my_pointer,   \n        sizeof(char) * 10, TRUE))  \n                printf(\"my_pointer has read and write accessibility.\\n\");  \n        else  \n                printf(\"my_pointer only has read access.\\n\");  \n  \n        // Make sure my_pointer is within the local heap  \n        if (_CrtIsValidHeapPointer((const void *)my_pointer))  \n                printf(\"my_pointer is within the local heap.\\n\");  \n        else  \n                printf(\"my_pointer is not located within the local\"  \n                       \" heap.\\n\");  \n  \n        free(my_pointer);  \n}  \n```  \n  \n## Output  \n  \n```  \nmy_pointer has read and write accessibility.  \nmy_pointer is within the local heap.  \n```  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [Debug Routines](../../c-runtime-library/debug-routines.md)"}