{"nodes":[{"pos":[12,64],"content":"_InterlockedXor Intrinsic Functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_InterlockedXor Intrinsic Functions | Microsoft Docs","pos":[0,52]}]},{"content":"_InterlockedXor Intrinsic Functions","pos":[1422,1457]},{"content":"Microsoft Specific","pos":[1460,1478]},{"content":"Perform an atomic bitwise exclusive or (XOR) operation on a variable shared by multiple threads.","pos":[1487,1583]},{"content":"Syntax","pos":[1592,1598]},{"content":"Parameters","pos":[3563,3573]},{"content":"[in, out]","pos":[3577,3586]},{"content":"A pointer to the first operand, to be replaced by the result.","pos":[3598,3659]},{"content":"[in]","pos":[3666,3670]},{"content":"The second operand.","pos":[3681,3700]},{"content":"Return Value","pos":[3709,3721]},{"content":"The original value of the first operand.","pos":[3725,3765]},{"content":"Requirements","pos":[3774,3786]},{"content":"Intrinsic","pos":[3793,3802]},{"content":"Architecture","pos":[3803,3815]},{"content":"Header","pos":[3816,3822]},{"pos":[3896,3938],"content":", <ph id=\"ph1\">`_InterlockedXor8`</ph>, <ph id=\"ph2\">`_InterlockedXor16`</ph>,","source":", `_InterlockedXor8`, `_InterlockedXor16`, "},{"pos":[3959,3968],"content":"x86, ARM,"},{"content":"intrin.h&gt;","pos":[4035,4044],"source":"intrin.h>"},{"pos":[4070,4335],"content":", <ph id=\"ph1\">`_InterlockedXor_nf`</ph>, <ph id=\"ph2\">`_InterlockedXor_rel`</ph>, <ph id=\"ph3\">`_InterlockedXor8_acq`</ph>, <ph id=\"ph4\">`_InterlockedXor8_nf`</ph>, <ph id=\"ph5\">`_InterlockedXor8_rel`</ph>, <ph id=\"ph6\">`_InterlockedXor16_acq`</ph>, <ph id=\"ph7\">`_InterlockedXor16_nf`</ph>, <ph id=\"ph8\">`_InterlockedXor16_rel`</ph>, <ph id=\"ph9\">`_InterlockedXor64_acq`</ph>, <ph id=\"ph10\">`_InterlockedXor64_nf`</ph>, <ph id=\"ph11\">`_InterlockedXor64_rel`</ph>,","source":", `_InterlockedXor_nf`, `_InterlockedXor_rel`, `_InterlockedXor8_acq`, `_InterlockedXor8_nf`, `_InterlockedXor8_rel`, `_InterlockedXor16_acq`, `_InterlockedXor16_nf`, `_InterlockedXor16_rel`, `_InterlockedXor64_acq`, `_InterlockedXor64_nf`, `_InterlockedXor64_rel`,"},{"content":"ARM","pos":[4336,4339]},{"content":"intrin.h&gt;","pos":[4342,4351],"source":"intrin.h>"},{"pos":[4376,4424],"content":", <ph id=\"ph1\">`_InterlockedXor8_np`</ph>, <ph id=\"ph2\">`_InterlockedXor16_np`</ph>,","source":", `_InterlockedXor8_np`, `_InterlockedXor16_np`, "},{"content":"intrin.h&gt;","pos":[4514,4523],"source":"intrin.h>"},{"pos":[4556,4619],"content":", <ph id=\"ph1\">`_InterlockedXor_HLERelease`</ph>, <ph id=\"ph2\">`_InterlockedXor64_HLEAcquire`</ph>,","source":", `_InterlockedXor_HLERelease`, `_InterlockedXor64_HLEAcquire`, "},{"pos":[4651,4655],"content":"x86,"},{"content":"immintrin.h&gt;","pos":[4722,4734],"source":"immintrin.h>"},{"content":"Remarks","pos":[4744,4751]},{"content":"The number in the name of each function specifies the bit size of the arguments.","pos":[4755,4835]},{"content":"On ARM platforms, use the intrinsics with <ph id=\"ph1\">`_acq`</ph> and <ph id=\"ph2\">`_rel`</ph> suffixes if you need acquire and release semantics, such as at the beginning and end of a critical section.","pos":[4842,5009],"source":"On ARM platforms, use the intrinsics with `_acq` and `_rel` suffixes if you need acquire and release semantics, such as at the beginning and end of a critical section."},{"content":"The ARM intrinsics with an <ph id=\"ph1\">`_nf`</ph> (\"no fence\") suffix do not act as a memory barrier.","pos":[5010,5094],"source":" The ARM intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier."},{"pos":[5101,5227],"content":"The intrinsics with an <ph id=\"ph1\">`_np`</ph> (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler.","source":"The intrinsics with an `_np` (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler."},{"content":"On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with <ph id=\"ph1\">`_HLEAcquire`</ph> and <ph id=\"ph2\">`_HLERelease`</ph> suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware.","pos":[5234,5478],"source":"On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware."},{"content":"If these intrinsics are called on platforms that do not support HLE, the hint is ignored.","pos":[5479,5568]},{"content":"Example","pos":[5577,5584]},{"content":"END Microsoft Specific","pos":[5999,6021]},{"content":"See Also","pos":[6030,6038]},{"content":"Compiler Intrinsics","pos":[6043,6062]},{"content":"Conflicts with the x86 Compiler","pos":[6107,6138]}],"content":"---\ntitle: \"_InterlockedXor Intrinsic Functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_InterlockedXor_nf\"\n  - \"_InterlockedXor_np\"\n  - \"_InterlockedXor64_HLERelease\"\n  - \"_InterlockedXor8_acq\"\n  - \"_InterlockedXor64_acq\"\n  - \"_InterlockedXor64_rel\"\n  - \"_InterlockedXor64_nf\"\n  - \"_InterlockedXor_acq\"\n  - \"_InterlockedXor16\"\n  - \"_InterlockedXor64_np\"\n  - \"_InterlockedXor64\"\n  - \"_InterlockedXor_HLEAcquire\"\n  - \"_InterlockedXor_HLERelease\"\n  - \"_InterlockedXor_cpp\"\n  - \"_InterlockedXor16_rel\"\n  - \"_InterlockedXor8_rel\"\n  - \"_InterlockedXor8\"\n  - \"_InterlockedXor64_HLEAcquire\"\n  - \"_InterlockedXor16_nf\"\n  - \"_InterlockedXor16_acq\"\n  - \"_InterlockedXor16_np\"\n  - \"_InterlockedXor8_fn\"\n  - \"_InterlockedXor8_np\"\n  - \"_InterlockedXor64_cpp\"\n  - \"_InterlockedXor_rel\"\n  - \"_InterlockedXor\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"InterlockedXor intrinsic\"\n  - \"_InterlockedXor64 intrinsic\"\n  - \"InterlockedXor64 intrinsic\"\n  - \"_InterlockedXor intrinsic\"\nms.assetid: faef1796-cb5a-4430-b1e2-9d5eaf9b4a91\ncaps.latest.revision: 20\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _InterlockedXor Intrinsic Functions\n**Microsoft Specific**  \n  \n Perform an atomic bitwise exclusive or (XOR) operation on a variable shared by multiple threads.  \n  \n## Syntax  \n  \n```  \nlong _InterlockedXor(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedXor_acq(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedXor_HLEAcquire(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedXor_HLERelease(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedXor_nf(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedXor_np(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedXor_rel(  \n   long volatile * Value,  \n   long Mask  \n);  \nchar _InterlockedXor8(  \n   char volatile * Value,  \n   char Mask  \n);  \nchar _InterlockedXor8_acq(  \n   char volatile * Value,  \n   char Mask  \n);  \nchar _InterlockedXor8_nf(  \n   char volatile * Value,  \n   char Mask  \n);  \nchar _InterlockedXor8_np(  \n   char volatile * Value,  \n   char Mask  \n);  \nchar _InterlockedXor8_rel(  \n   char volatile * Value,  \n   char Mask  \n);  \nshort _InterlockedXor16(  \n   short volatile * Value,  \n   short Mask  \n);  \nshort _InterlockedXor16_acq(  \n   short volatile * Value,  \n   short Mask  \n);  \nshort _InterlockedXor16_nf (  \n   short volatile * Value,  \n   short Mask  \n);  \nshort _InterlockedXor16_np (  \n   short volatile * Value,  \n   short Mask  \n);  \nshort _InterlockedXor16_rel(  \n   short volatile * Value,  \n   short Mask  \n);  \n__int64 _InterlockedXor64(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);  \n__int64 _InterlockedXor64_acq(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);   \n__int64 _InterlockedXor64_HLEAcquire(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);  \n__int64 _InterlockedXor64_HLERelease(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);   \n__int64 _InterlockedXor64_nf(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);  \n__int64 _InterlockedXor64_np(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);  \n__int64 _InterlockedXor64_rel(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);  \n```  \n  \n#### Parameters  \n [in, out] `Value`  \n A pointer to the first operand, to be replaced by the result.  \n  \n [in] `Mask`  \n The second operand.  \n  \n## Return Value  \n The original value of the first operand.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|Header|  \n|---------------|------------------|------------|  \n|`_InterlockedXor`, `_InterlockedXor8`, `_InterlockedXor16`, `_InterlockedXor64`|x86, ARM, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_InterlockedXor_acq`, `_InterlockedXor_nf`, `_InterlockedXor_rel`, `_InterlockedXor8_acq`, `_InterlockedXor8_nf`, `_InterlockedXor8_rel`, `_InterlockedXor16_acq`, `_InterlockedXor16_nf`, `_InterlockedXor16_rel`, `_InterlockedXor64_acq`, `_InterlockedXor64_nf`, `_InterlockedXor64_rel`,|ARM|\\<intrin.h>|  \n|`_InterlockedXor_np`, `_InterlockedXor8_np`, `_InterlockedXor16_np`, `_InterlockedXor64_np`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_InterlockedXor_HLEAcquire`, `_InterlockedXor_HLERelease`, `_InterlockedXor64_HLEAcquire`, `_InterlockedXor64_HLERelease`|x86, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<immintrin.h>|  \n  \n## Remarks  \n The number in the name of each function specifies the bit size of the arguments.  \n  \n On ARM platforms, use the intrinsics with `_acq` and `_rel` suffixes if you need acquire and release semantics, such as at the beginning and end of a critical section. The ARM intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier.  \n  \n The intrinsics with an `_np` (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler.  \n  \n On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware. If these intrinsics are called on platforms that do not support HLE, the hint is ignored.  \n  \n## Example  \n  \n```  \n// _InterLockedXor.cpp  \n#include <stdio.h>  \n#include <intrin.h>  \n  \n#pragma intrinsic(_InterlockedXor)  \n  \nint main()  \n{  \n        long data1 = 0xFF00FF00;  \n        long data2 = 0x00FFFF00;  \n        long retval;  \n        retval = _InterlockedXor(&data1, data2);  \n        printf_s(\"0x%x 0x%x 0x%x\", data1, data2, retval);   \n}  \n```  \n  \n```Output  \n0xffff0000 0xffff00 0xff00ff00  \n```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)   \n [Conflicts with the x86 Compiler](../build/conflicts-with-the-x86-compiler.md)"}