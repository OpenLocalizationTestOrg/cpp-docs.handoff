<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4c58b23be2c5aae5969471370e52af1c5416d32e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard-library\numeric-limits-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2533edc0eba6e3d9db7a66954905cd7572c9f888</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">eb71baf227a513d88dd45b46511f8047a9b52b9c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>numeric_limits Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>numeric_limits Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The template class describes arithmetic properties of built-in numerical types.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The fundamental element data type whose properties are being tested or queried or set.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The header defines explicit specializations for the types <ph id="ph1">`wchar_t`</ph>, <ph id="ph2">`bool`</ph>, <ph id="ph3">`char`</ph>, <ph id="ph4">`signed char`</ph>, <ph id="ph5">`unsigned char`</ph>, <ph id="ph6">`short`</ph>, <ph id="ph7">`unsigned short`</ph>, <ph id="ph8">`int`</ph>, <ph id="ph9">`unsigned int`</ph>, <ph id="ph10">`long`</ph>, <ph id="ph11">`unsigned long`</ph>, <ph id="ph12">`float`</ph>, <ph id="ph13">`double`</ph>, <ph id="ph14">`long double`</ph><bpt id="p1">**</bpt>,<ept id="p1">**</ept> <ph id="ph15">`long long`</ph>, <ph id="ph16">`unsigned long long`</ph>, <ph id="ph17">`char16_t`</ph>, and <ph id="ph18">`char32_t`</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For these explicit specializations, the member <bpt id="p1">[</bpt>numeric_limits::is_specialized<ept id="p1">](#numeric_limits__is_specialized)</ept> is <ph id="ph1">`true`</ph>, and all relevant members have meaningful values.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The program can supply additional explicit specializations.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Most member functions of the class describe or test possible implementations of <ph id="ph1">`float`</ph>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For an arbitrary specialization, no members have meaningful values.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A member object that does not have a meaningful value stores zero (or <ph id="ph1">`false`</ph>) and a member function that does not return a meaningful value returns <ph id="ph2">`Type(0)`</ph>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Static Functions and Constants</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>denorm_min</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Returns the smallest nonzero denormalized value.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>digits</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Returns the number of radix digits that the type can represent without loss of precision.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>digits10</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Returns the number of decimal digits that the type can represent without loss of precision.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>epsilon</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Returns the difference between 1 and the smallest value greater than 1 that the data type can represent.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>has_denorm</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Tests whether a type allows denormalized values.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>has_denorm_loss</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Tests whether loss of accuracy is detected as a denormalization loss rather than as an inexact result.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>has_infinity</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Tests whether a type has a representation for positive infinity.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>has_quiet_NaN</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Tests whether a type has a representation for a quiet not a number (NAN), which is nonsignaling.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>has_signaling_NaN</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Tests whether a type has a representation for signaling not a number (NAN).</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>infinity</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The representation for positive infinity for a type, if available.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>is_bounded</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Tests if the set of values that a type may represent is finite.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>is_exact</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Tests if the calculations done on a type are free of rounding errors.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>is_iec559</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Tests if a type conforms to IEC 559 standards.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>is_integer</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Tests if a type has an integer representation.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>is_modulo</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Tests if a type has a modulo representation.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>is_signed</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Tests if a type has a signed representation.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>is_specialized</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Tests if a type has an explicit specialization defined in the template class <ph id="ph1">`numeric_limits`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>lowest</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Returns the most negative finite value.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>max</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Returns the maximum finite value for a type.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>max_digits10</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Returns the number of decimal digits required to ensure that two distinct values of the type have distinct decimal representations.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>max_exponent</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>max_exponent10</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>min</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Returns the minimum normalized value for a type.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>min_exponent</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>min_exponent10</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>quiet_NaN</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Returns the representation of a quiet not a number (NAN) for the type.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>radix</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Returns the integral base, referred to as radix, used for the representation of a type.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>round_error</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Returns the maximum rounding error for the type.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>round_style</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Returns a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>signaling_NaN</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Returns the representation of a signaling not a number (NAN) for the type.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>tinyness_before</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Tests whether a type can determine that a value is too small to represent as a normalized value before rounding it.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>traps</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Tests whether trapping that reports on arithmetic exceptions is implemented for a type.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> <ph id="ph1">\&lt;</ph>limits&gt;</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Namespace:<ept id="p1">**</ept> std</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>numeric_limits::denorm_min</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Returns the smallest nonzero denormalized value.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The smallest nonzero denormalized value.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>is the same as <bpt id="p1">**</bpt>double<ept id="p1">**</ept> for the C++ compiler.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The function returns the minimum value for the type, which is the same as <bpt id="p1">[</bpt>min<ept id="p1">](#numeric_limits__min)</ept> if <bpt id="p2">[</bpt>has_denorm<ept id="p2">](#numeric_limits__has_denorm)</ept> is not equal to <bpt id="p3">**</bpt>denorm_present<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>numeric_limits::digits</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Returns the number of radix digits that the type can represent without loss of precision.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The number of radix digits that the type can represent without loss of precision.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The member stores the number of radix digits that the type can represent without change, which is the number of bits other than any sign bit for a predefined integer type, or the number of mantissa digits for a predefined floating-point type.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>numeric_limits::digits10</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Returns the number of decimal digits that the type can represent without loss of precision.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The number of decimal digits that the type can represent without loss of precision.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>numeric_limits::epsilon</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The function returns the difference between 1 and the smallest value greater than 1 that is representable for the data type.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The difference between 1 and the smallest value greater than 1 that is representable for the data type.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The value is FLT_EPSILON for type <bpt id="p1">**</bpt>float<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>for a type is the smallest positive floating-point number <bpt id="p1">*</bpt>N<ept id="p1">*</ept> such that <bpt id="p2">*</bpt>N<ept id="p2">*</ept><ph id="ph1"> + `epsilon` + </ph><bpt id="p3">*</bpt>N<ept id="p3">*</ept> is representable.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>numeric_limits::has_denorm</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Tests whether a type allows denormalized values.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>An enumeration value of type <bpt id="p1">**</bpt>const<ept id="p1">**</ept><ph id="ph1">`float_denorm_style`</ph>, indicating whether the type allows denormalized values.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The member stores <bpt id="p1">**</bpt>denorm_present<ept id="p1">**</ept> for a floating-point type that has denormalized values, effectively a variable number of exponent bits.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>numeric_limits::has_denorm_loss</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Tests whether loss of accuracy is detected as a denormalization loss rather than as an inexact result.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the loss of accuracy is detected as a denormalization loss; <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if not.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The member stores true for a type that determines whether a value has lost accuracy because it is delivered as a denormalized result (too small to represent as a normalized value) or because it is inexact (not the same as a result not subject to limitations of exponent range and precision), an option with IEC 559 floating-point representations that can affect some results.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>numeric_limits::has_infinity</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Tests whether a type has a representation for positive infinity.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the type has a representation for positive infinity; <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if not.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The member returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> if <bpt id="p2">[</bpt>is_iec559<ept id="p2">](#numeric_limits__is_iec559)</ept> is <bpt id="p3">**</bpt>true<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>numeric_limits::has_quiet_NaN</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Tests whether a type has a representation for a quiet not a number (NAN), which is nonsignaling.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the <bpt id="p2">**</bpt>type<ept id="p2">**</ept> has a representation for a quiet NAN; <bpt id="p3">**</bpt>false<ept id="p3">**</ept> if not.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>A quiet NAN is an encoding for not a number, which does not signal its presence in an expression.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The return value is <bpt id="p1">**</bpt>true<ept id="p1">**</ept> if <bpt id="p2">[</bpt>is_iec559<ept id="p2">](#numeric_limits__is_iec559)</ept> is true.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>numeric_limits::has_signaling_NaN</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Tests whether a type has a representation for signaling not a number (NAN).</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the type has a representation for a signaling NAN; <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if not.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>A signaling NAN is an encoding for not a number, which signals its presence in an expression.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The return value is <bpt id="p1">**</bpt>true<ept id="p1">**</ept><bpt id="p2">[</bpt>is_iec559<ept id="p2">](#numeric_limits__is_iec559)</ept> is true.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>numeric_limits::infinity</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The representation of positive infinity for a type, if available.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The representation of positive infinity for a type, if available.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The return value is meaningful only if <bpt id="p1">[</bpt>has_infinity<ept id="p1">](#numeric_limits__has_infinity)</ept> is <bpt id="p2">**</bpt>true<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>numeric_limits::is_bounded</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Tests if the set of values that a type may represent is finite.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the type has a bounded set of representable values; <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if not.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>All predefined types have a bounded set of representable values and return <bpt id="p1">**</bpt>true<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>numeric_limits::is_exact</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Tests if the calculations done on a type are free of rounding errors.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the calculations are free of rounding errors; <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if not.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>All predefined integer types have exact representations for their values and return <bpt id="p1">**</bpt>false<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>A fixed-point or rational representation is also considered exact, but a floating-point representation is not.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>numeric_limits::is_iec559</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Tests if a type conforms to IEC 559 standards.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the type conforms to the IEC 559 standards; <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if not.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The IEC 559 is an international standard for representing floating-point values and is also known as IEEE 754 in the USA.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>numeric_limits::is_integer</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Tests if a type has an integer representation.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the type has an integer representation; <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if not.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>All predefined integer types have an integer representation.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>numeric_limits::is_modulo</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Tests if a <bpt id="p1">**</bpt>type<ept id="p1">**</ept> has a modulo representation.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the type has a modulo representation; <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if not.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>A modulo representation is a representation where all results are reduced modulo some value.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>All predefined unsigned integer types have a modulo representation.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>numeric_limits::is_signed</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Tests if a type has a signed representation.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the type has a signed representation; <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if not.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The member stores true for a type that has a signed representation, which is the case for all predefined floating-point and signed integer types.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>numeric_limits::is_specialized</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Tests if a type has an explicit specialization defined in the template class <ph id="ph1">`numeric_limits`</ph>.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the type has an explicit specialization defined in the template class; <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if not.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>All scalar types other than pointers have an explicit specialization defined for template class <ph id="ph1">`numeric_limits`</ph>.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>numeric_limits::lowest</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Returns the most negative finite value.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Returns the most negative finite value.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Returns the most negative finite value for the type (which is typically <ph id="ph1">`min`</ph> <ph id="ph2">`()`</ph> for integer types and <ph id="ph3">`-``max`</ph> <ph id="ph4">`()`</ph> for floating-point types).</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The return value is meaningful if <ph id="ph1">`is_bounded`</ph> is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>numeric_limits::max</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Returns the maximum finite value for a type.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The maximum finite value for a type.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The maximum finite value is INT_MAX for type <ph id="ph1">`int`</ph> and FLT_MAX for type <bpt id="p1">**</bpt>float<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The return value is meaningful if <bpt id="p1">[</bpt>is_bounded<ept id="p1">](#numeric_limits__is_bounded)</ept> is <bpt id="p2">**</bpt>true<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>numeric_limits::max_digits10</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Returns the number of decimal digits required to make sure that two distinct values of the type have distinct decimal representations.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Returns the number of decimal digits that are required to make sure that two distinct values of the type have distinct decimal representations.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The member stores the number of decimal digits required to make sure that two distinct values of the type have distinct decimal representations.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>numeric_limits::max_exponent</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The maximum integral radix-based exponent representable by the type.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The member function return is meaningful only for floating-point types.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`max_exponent`</ph> is the value FLT_MAX_EXP for type <bpt id="p1">**</bpt>float<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>numeric_limits::max_exponent10</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>The maximum integral base 10 exponent representable by the type.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The member function return is meaningful only for floating-point types.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`max_exponent`</ph> is the value FLT_MAX_10 for type <bpt id="p1">**</bpt>float<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>numeric_limits::min</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Returns the minimum normalized value for a type.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The minimum normalized value for the type.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The minimum normalized value is INT_MIN for type <ph id="ph1">`int`</ph> and FLT_MIN for type <ph id="ph2">`float`</ph>.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The return value is meaningful if <bpt id="p1">[</bpt>is_bounded<ept id="p1">](#numeric_limits__is_bounded)</ept> is <ph id="ph1">`true`</ph> or if <bpt id="p2">[</bpt>is_signed<ept id="p2">](#numeric_limits__is_signed)</ept> is <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>numeric_limits::min_exponent</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The minimum integral radix-based exponent representable by the type.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The member function is meaningful only for floating-point types.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`min_exponent`</ph> is the value FLT_MIN_EXP for type <bpt id="p1">**</bpt>float<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>numeric_limits::min_exponent10</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The minimum integral base 10 exponent representable by the type.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The member function is meaningful only for floating-point types.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`min_exponent10`</ph> is the value FLT_MIN_10_EXP for type <bpt id="p1">**</bpt>float<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>numeric_limits::quiet_NaN</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Returns the representation of a quiet not a number (NAN) for the type.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The representation of a quiet NAN for the type.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>The return value is meaningful only if <bpt id="p1">[</bpt>has_quiet_NaN<ept id="p1">](#numeric_limits__has_quiet_nan)</ept> is <bpt id="p2">**</bpt>true<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>numeric_limits::radix</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Returns the integral base, referred to as radix, used for the representation of a type.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The integral base for the representation of the type.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The base is 2 for the predefined integer types, and the base to which the exponent is raised, or FLT_RADIX, for the predefined floating-point types.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>numeric_limits::round_error</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Returns the maximum rounding error for the type.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>The maximum rounding error for the type.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>numeric_limits::round_style</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Returns a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>A value from the <ph id="ph1">`float_round_style`</ph> enumeration that describes the rounding style.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>The member stores a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>The round style is hard coded in this implementation, so even if the program starts up with a different rounding mode, that value will not change.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>numeric_limits::signaling_NaN</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Returns the representation of a signaling not a number (NAN) for the type.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The representation of a signaling NAN for the type.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The return value is meaningful only if <bpt id="p1">[</bpt>has_signaling_NaN<ept id="p1">](#numeric_limits__has_signaling_nan)</ept> is <bpt id="p2">**</bpt>true<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>numeric_limits::tinyness_before</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Tests whether a type can determine that a value is too small to represent as a normalized value before rounding it.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>if the type can detect tiny values before rounding; <ph id="ph1">`false`</ph> if it cannot.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Types that can detect tinyness were included as an option with IEC 559 floating-point representations and its implementation can affect some results.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>numeric_limits::traps</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Tests whether trapping that reports on arithmetic exceptions is implemented for a type.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>true<ept id="p1">**</ept> if trapping is implemented for the type; <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if it is not.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Thread Safety in the C++ Standard Library</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>