{"nodes":[{"pos":[12,49],"content":"Function Overloading | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Function Overloading | Microsoft Docs","pos":[0,37]}]},{"content":"Function Overloading","pos":[684,704]},{"content":"C++ allows specification of more than one function of the same name in the same scope.","pos":[705,791]},{"content":"These are called overloaded functions and are described in detail in Overloading.","pos":[792,873]},{"content":"Overloaded functions enable programmers to supply different semantics for a function, depending on the types and number of arguments.","pos":[874,1007]},{"content":"For example, a <bpt id=\"p1\">**</bpt>print<ept id=\"p1\">**</ept> function that takes a string (or <bpt id=\"p2\">**</bpt>char <ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept>) argument performs very different tasks than one that takes an argument of type <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept>.","pos":[1014,1175],"source":"For example, a **print** function that takes a string (or **char \\***) argument performs very different tasks than one that takes an argument of type **double**."},{"content":"Overloading permits uniform naming and prevents programmers from having to invent names such as <ph id=\"ph1\">`print_sz`</ph> or <ph id=\"ph2\">`print_d`</ph>.","pos":[1176,1296],"source":" Overloading permits uniform naming and prevents programmers from having to invent names such as `print_sz` or `print_d`."},{"content":"The following table shows what parts of a function declaration C++ uses to differentiate between groups of functions with the same name in the same scope.","pos":[1297,1451]},{"content":"Overloading Considerations","pos":[1461,1487]},{"content":"Function Declaration Element","pos":[1494,1522]},{"content":"Used for Overloading?","pos":[1523,1544]},{"content":"Function return type","pos":[1616,1636]},{"content":"No","pos":[1637,1639]},{"content":"Number of arguments","pos":[1644,1663]},{"content":"Yes","pos":[1664,1667]},{"content":"Type of arguments","pos":[1672,1689]},{"content":"Yes","pos":[1690,1693]},{"content":"Presence or absence of ellipsis","pos":[1698,1729]},{"content":"Yes","pos":[1730,1733]},{"pos":[1738,1760],"content":"Use of <ph id=\"ph1\">`typedef`</ph> names","source":"Use of `typedef` names"},{"content":"No","pos":[1761,1763]},{"content":"Unspecified array bounds","pos":[1768,1792]},{"content":"No","pos":[1793,1795]},{"pos":[1800,1835],"content":"<bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph> (see below)","source":"**const** or `volatile` (see below)"},{"content":"Yes","pos":[1836,1839]},{"content":"Although functions can be distinguished on the basis of return type, they cannot be overloaded on this basis.","pos":[1847,1956]},{"content":"or <ph id=\"ph1\">`volatile`</ph> are only used as a basis for overloading if they are used in a class to apply to the <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> pointer for the class, not the function's return type.","pos":[1966,2128],"source":" or `volatile` are only used as a basis for overloading if they are used in a class to apply to the **this** pointer for the class, not the function's return type."},{"content":"In other words, overloading applies only if the <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph> keyword follows the function's argument list in the declaration.","pos":[2130,2266],"source":"  In other words, overloading applies only if the **const** or `volatile` keyword follows the function's argument list in the declaration."},{"content":"Example","pos":[2275,2282]},{"content":"The following example illustrates how overloading can be used.","pos":[2286,2348]},{"pos":[4263,4338],"content":"The preceding code shows overloading of the <ph id=\"ph1\">`print`</ph> function in file scope.","source":"The preceding code shows overloading of the `print` function in file scope."},{"content":"The default argument is not considered part of the function type.","pos":[4345,4410]},{"content":"Therefore, it is not used in selecting overloaded functions.","pos":[4411,4471]},{"content":"Two functions that differ only in their default arguments are considered multiple definitions rather than overloaded functions.","pos":[4472,4599]},{"content":"Default arguments cannot be supplied for overloaded operators.","pos":[4606,4668]},{"content":"Argument Matching","pos":[4680,4697]},{"content":"Overloaded functions are selected for the best match of function declarations in the current scope to the arguments supplied in the function call.","pos":[4701,4847]},{"content":"If a suitable function is found, that function is called.","pos":[4848,4905]},{"content":"\"Suitable\" in this context means one of the following:","pos":[4906,4960]},{"content":"An exact match was found.","pos":[4970,4995]},{"content":"A trivial conversion was performed.","pos":[5005,5040]},{"content":"An integral promotion was performed.","pos":[5050,5086]},{"content":"A standard conversion to the desired argument type exists.","pos":[5096,5154]},{"content":"A user-defined conversion (either conversion operator or constructor) to the desired argument type exists.","pos":[5164,5270]},{"content":"Arguments represented by an ellipsis were found.","pos":[5280,5328]},{"content":"The compiler creates a set of candidate functions for each argument.","pos":[5335,5403]},{"content":"Candidate functions are functions in which the actual argument in that position can be converted to the type of the formal argument.","pos":[5404,5536]},{"content":"A set of \"best matching functions\" is built for each argument, and the selected function is the intersection of all the sets.","pos":[5543,5668]},{"content":"If the intersection contains more than one function, the overloading is ambiguous and generates an error.","pos":[5669,5774]},{"content":"The function that is eventually selected is always a better match than every other function in the group for at least one argument.","pos":[5775,5906]},{"content":"If this is not the case (if there is no clear winner), the function call generates an error.","pos":[5907,5999]},{"pos":[6006,6159],"content":"Consider the following declarations (the functions are marked <ph id=\"ph1\">`Variant 1`</ph>, <ph id=\"ph2\">`Variant 2`</ph>, and <ph id=\"ph3\">`Variant 3`</ph>, for identification in the following discussion):","source":"Consider the following declarations (the functions are marked `Variant 1`, `Variant 2`, and `Variant 3`, for identification in the following discussion):"},{"content":"Consider the following statement:","pos":[6380,6413]},{"content":"The preceding statement builds two sets:","pos":[6457,6497]},{"content":"Set 1: Candidate Functions That Have First Argument of Type Fraction","pos":[6504,6572]},{"content":"Set 2: Candidate Functions Whose Second Argument Can Be Converted to Type int","pos":[6573,6650]},{"content":"Variant 1","pos":[6818,6827]},{"pos":[6828,6900],"content":"Variant 1 (<ph id=\"ph1\">`int`</ph> can be converted to <ph id=\"ph2\">`long`</ph> using a standard conversion)","source":"Variant 1 (`int` can be converted to `long` using a standard conversion)"},{"content":"Variant 3","pos":[6905,6914]},{"content":"Functions in Set 2 are functions for which there are implicit conversions from actual parameter type to formal parameter type, and among such functions there is a function for which the \"cost\" of converting the actual parameter type to its formal parameter type is the smallest.","pos":[6923,7201]},{"content":"The intersection of these two sets is Variant 1.","pos":[7208,7256]},{"content":"An example of an ambiguous function call is:","pos":[7257,7301]},{"content":"The preceding function call builds the following sets:","pos":[7343,7397]},{"content":"Set 1: Candidate Functions That Have First Argument of Type int","pos":[7404,7467]},{"content":"Set 2: Candidate Functions That Have Second Argument of Type int","pos":[7468,7532]},{"pos":[7682,7754],"content":"Variant 2 (<ph id=\"ph1\">`int`</ph> can be converted to <ph id=\"ph2\">`long`</ph> using a standard conversion)","source":"Variant 2 (`int` can be converted to `long` using a standard conversion)"},{"pos":[7755,7827],"content":"Variant 1 (<ph id=\"ph1\">`int`</ph> can be converted to <ph id=\"ph2\">`long`</ph> using a standard conversion)","source":"Variant 1 (`int` can be converted to `long` using a standard conversion)"},{"content":"Note that the intersection between these two sets is empty.","pos":[7835,7894]},{"content":"Therefore, the compiler generates an error message.","pos":[7895,7946]},{"pos":[7953,8096],"content":"For argument matching, a function with <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept> default arguments is treated as <bpt id=\"p2\">*</bpt>n<ept id=\"p2\">*</ept>+1 separate functions, each with a different number of arguments.","source":"For argument matching, a function with *n* default arguments is treated as *n*+1 separate functions, each with a different number of arguments."},{"content":"The ellipsis (...) acts as a wildcard; it matches any actual argument.","pos":[8103,8173]},{"content":"This can lead to many ambiguous sets, if you do not design your overloaded function sets with extreme care.","pos":[8174,8281]},{"pos":[8289,8633],"content":"[!NOTE]\n Ambiguity of overloaded functions cannot be determined until a function call is encountered. At that point, the sets are built for each argument in the function call, and you can determine whether an unambiguous overload exists. This means that ambiguities can remain in your code until they are evoked by a particular function call.","leadings":["","> "],"nodes":[{"content":" Ambiguity of overloaded functions cannot be determined until a function call is encountered. At that point, the sets are built for each argument in the function call, and you can determine whether an unambiguous overload exists. This means that ambiguities can remain in your code until they are evoked by a particular function call.","pos":[8,342],"nodes":[{"content":"Ambiguity of overloaded functions cannot be determined until a function call is encountered.","pos":[1,93]},{"content":"At that point, the sets are built for each argument in the function call, and you can determine whether an unambiguous overload exists.","pos":[94,229]},{"content":"This means that ambiguities can remain in your code until they are evoked by a particular function call.","pos":[230,334]}]}]},{"content":"Argument Type Differences","pos":[8642,8667]},{"content":"Overloaded functions differentiate between argument types that take different initializers.","pos":[8671,8762]},{"content":"Therefore, an argument of a given type and a reference to that type are considered the same for the purposes of overloading.","pos":[8763,8887]},{"content":"They are considered the same because they take the same initializers.","pos":[8888,8957]},{"content":"For example, <ph id=\"ph1\">`max( double, double )`</ph> is considered the same as <ph id=\"ph2\">`max( double &amp;, double &amp; )`</ph>.","pos":[8958,9049],"source":" For example, `max( double, double )` is considered the same as `max( double &, double & )`."},{"content":"Declaring two such functions causes an error.","pos":[9050,9095]},{"pos":[9102,9267],"content":"For the same reason, function arguments of a type modified by <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph> are not treated differently than the base type for the purposes of overloading.","source":"For the same reason, function arguments of a type modified by **const** or `volatile` are not treated differently than the base type for the purposes of overloading."},{"content":"However, the function overloading mechanism can distinguish between references that are qualified by <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`volatile`</ph> and references to the base type.","pos":[9274,9432],"source":"However, the function overloading mechanism can distinguish between references that are qualified by **const** and `volatile` and references to the base type."},{"content":"This makes code such as the following possible:","pos":[9433,9480]},{"content":"Output","pos":[10234,10240]},{"pos":[10382,10520],"content":"Pointers to <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`volatile`</ph> objects are also considered different from pointers to the base type for the purposes of overloading.","source":"Pointers to **const** and `volatile` objects are also considered different from pointers to the base type for the purposes of overloading."},{"content":"Argument matching and conversions","pos":[10529,10562]},{"content":"When the compiler tries to match actual arguments against the arguments in function declarations, it can supply standard or user-defined conversions to obtain the correct type if no exact match can be found.","pos":[10566,10773]},{"content":"The application of conversions is subject to these rules:","pos":[10774,10831]},{"content":"Sequences of conversions that contain more than one user-defined conversion are not considered.","pos":[10841,10936]},{"content":"Sequences of conversions that can be shortened by removing intermediate conversions are not considered.","pos":[10946,11049]},{"content":"The resultant sequence of conversions, if any, is called the best matching sequence.","pos":[11056,11140]},{"content":"There are several ways to convert an object of type <ph id=\"ph1\">`int`</ph> to type <ph id=\"ph2\">`unsigned long`</ph>using standard conversions (described in <bpt id=\"p1\">[</bpt>Standard Conversions<ept id=\"p1\">](../cpp/standard-conversions.md)</ept>):","pos":[11141,11319],"source":" There are several ways to convert an object of type `int` to type `unsigned long`using standard conversions (described in [Standard Conversions](../cpp/standard-conversions.md)):"},{"pos":[11329,11398],"content":"Convert from <ph id=\"ph1\">`int`</ph> to <ph id=\"ph2\">`long`</ph> and then from <ph id=\"ph3\">`long`</ph> to <ph id=\"ph4\">`unsigned long`</ph>.","source":"Convert from `int` to `long` and then from `long` to `unsigned long`."},{"pos":[11408,11446],"content":"Convert from <ph id=\"ph1\">`int`</ph> to <ph id=\"ph2\">`unsigned long`</ph>.","source":"Convert from `int` to `unsigned long`."},{"content":"The first sequence, although it achieves the desired goal, is not the best matching sequence — a shorter sequence exists.","pos":[11453,11574]},{"content":"The following table shows a group of conversions, called trivial conversions, that have a limited effect on determining which sequence is the best matching.","pos":[11581,11737]},{"content":"The instances in which trivial conversions affect choice of sequence are discussed in the list following the table.","pos":[11738,11853]},{"content":"Trivial Conversions","pos":[11863,11882]},{"content":"Convert from Type","pos":[11889,11906]},{"content":"Convert to Type","pos":[11907,11922]},{"content":"type-name","pos":[11978,11987]},{"pos":[11989,12006],"content":"<bpt id=\"p1\">*</bpt>type-name<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p2\">**</ept>","source":"*type-name* **&**"},{"pos":[12011,12028],"content":"<bpt id=\"p1\">*</bpt>type-name<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p2\">**</ept>","source":"*type-name* **&**"},{"content":"type-name","pos":[12030,12039]},{"pos":[12045,12064],"content":"<bpt id=\"p1\">*</bpt>type-name<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt>[ ]<ept id=\"p2\">**</ept>","source":"*type-name* **[ ]**"},{"content":"type-name","pos":[12066,12075]},{"pos":[12083,12122],"content":"<bpt id=\"p1\">*</bpt>type-name<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt>(<ept id=\"p2\">**</ept> <bpt id=\"p3\">*</bpt>argument-list<ept id=\"p3\">*</ept> <bpt id=\"p4\">**</bpt>)<ept id=\"p4\">**</ept>","source":"*type-name* **(** *argument-list* **)**"},{"pos":[12123,12172],"content":"<bpt id=\"p1\">**</bpt>(<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt><ph id=\"ph1\">\\*</ph>type-name<ept id=\"p2\">*</ept> <bpt id=\"p3\">**</bpt>) (<ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt>argument-list<ept id=\"p4\">*</ept> <bpt id=\"p5\">**</bpt>)<ept id=\"p5\">**</ept>","source":"**(** *\\*type-name* **) (** *argument-list* **)**"},{"content":"type-name","pos":[12178,12187]},{"pos":[12189,12210],"content":"<bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>type-name<ept id=\"p2\">*</ept>","source":"**const** *type-name*"},{"content":"type-name","pos":[12216,12225]},{"pos":[12239,12248],"content":"type-name"},{"content":"type-name","pos":[12255,12264]},{"pos":[12268,12291],"content":"<bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> <bpt id=\"p2\">*</bpt>type-name<ph id=\"ph1\">\\*</ph><ept id=\"p2\">*</ept>","source":"**const** *type-name\\**"},{"content":"type-name","pos":[12297,12306]},{"pos":[12322,12331],"content":"type-name"},{"content":"The sequence in which conversions are attempted is as follows:","pos":[12342,12404]},{"content":"Exact match.","pos":[12414,12426]},{"content":"An exact match between the types with which the function is called and the types declared in the function prototype is always the best match.","pos":[12427,12568]},{"content":"Sequences of trivial conversions are classified as exact matches.","pos":[12569,12634]},{"content":"However, sequences that do not make any of these conversions are considered better than sequences that convert:","pos":[12635,12746]},{"pos":[12760,12841],"content":"From pointer, to pointer to <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> (<ph id=\"ph1\">`type`</ph> <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\*</ph><ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>const<ept id=\"p3\">**</ept> <ph id=\"ph3\">`type`</ph> <bpt id=\"p4\">**</bpt><ph id=\"ph4\">\\*</ph><ept id=\"p4\">**</ept>).","source":"From pointer, to pointer to **const** (`type` **\\*** to **const** `type` **\\***)."},{"pos":[12855,12938],"content":"From pointer, to pointer to <ph id=\"ph1\">`volatile`</ph> (<ph id=\"ph2\">`type`</ph> <bpt id=\"p1\">**</bpt><ph id=\"ph3\">\\*</ph><ept id=\"p1\">**</ept> to <ph id=\"ph4\">`volatile`</ph> <ph id=\"ph5\">`type`</ph> <bpt id=\"p2\">**</bpt><ph id=\"ph6\">\\*</ph><ept id=\"p2\">**</ept>).","source":"From pointer, to pointer to `volatile` (`type` **\\*** to `volatile` `type` **\\***)."},{"pos":[12952,13035],"content":"From reference, to reference to <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> (<ph id=\"ph1\">`type`</ph> <bpt id=\"p2\">**</bpt><ph id=\"ph2\">&amp;</ph><ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>const<ept id=\"p3\">**</ept> <ph id=\"ph3\">`type`</ph> <bpt id=\"p4\">**</bpt><ph id=\"ph4\">&amp;</ph><ept id=\"p4\">**</ept>).","source":"From reference, to reference to **const** (`type` **&** to **const** `type` **&**)."},{"pos":[13049,13134],"content":"From reference, to reference to <ph id=\"ph1\">`volatile`</ph> (<ph id=\"ph2\">`type`</ph> <bpt id=\"p1\">**</bpt><ph id=\"ph3\">&amp;</ph><ept id=\"p1\">**</ept> to <ph id=\"ph4\">`volatile`</ph> <ph id=\"ph5\">`type`</ph> <bpt id=\"p2\">**</bpt><ph id=\"ph6\">&amp;</ph><ept id=\"p2\">**</ept>).","source":"From reference, to reference to `volatile` (`type` **&** to `volatile` `type` **&**)."},{"content":"Match using promotions.","pos":[13144,13167]},{"content":"Any sequence not classified as an exact match that contains only integral promotions, conversions from <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept> to <bpt id=\"p2\">**</bpt>double<ept id=\"p2\">**</ept>, and trivial conversions is classified as a match using promotions.","pos":[13168,13362],"source":" Any sequence not classified as an exact match that contains only integral promotions, conversions from **float** to **double**, and trivial conversions is classified as a match using promotions."},{"content":"Although not as good a match as any exact match, a match using promotions is better than a match using standard conversions.","pos":[13363,13487]},{"content":"Match using standard conversions.","pos":[13497,13530]},{"content":"Any sequence not classified as an exact match or a match using promotions that contains only standard conversions and trivial conversions is classified as a match using standard conversions.","pos":[13531,13721]},{"content":"Within this category, the following rules are applied:","pos":[13722,13776]},{"pos":[13790,13948],"content":"Conversion from a pointer to a derived class, to a pointer to a direct or indirect base class is preferable to converting to <bpt id=\"p1\">**</bpt>void <ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>const void <ph id=\"ph2\">\\*</ph><ept id=\"p2\">**</ept>.","source":"Conversion from a pointer to a derived class, to a pointer to a direct or indirect base class is preferable to converting to **void \\*** or **const void \\***."},{"content":"Conversion from a pointer to a derived class, to a pointer to a base class produces a better match the closer the base class is to a direct base class.","pos":[13962,14113]},{"content":"Suppose the class hierarchy is as shown in the following figure.","pos":[14114,14178]},{"content":"Preferred conversions","pos":[14187,14208]},{"content":"Graph Illustrating Preferred Conversions","pos":[14248,14288]},{"content":"Conversion from type <ph id=\"ph1\">`D*`</ph> to type <ph id=\"ph2\">`C*`</ph> is preferable to conversion from type <ph id=\"ph3\">`D*`</ph> to type <ph id=\"ph4\">`B*`</ph>.","pos":[14295,14390],"source":"Conversion from type `D*` to type `C*` is preferable to conversion from type `D*` to type `B*`."},{"content":"Similarly, conversion from type <ph id=\"ph1\">`D*`</ph> to type <ph id=\"ph2\">`B*`</ph> is preferable to conversion from type <ph id=\"ph3\">`D*`</ph> to type <ph id=\"ph4\">`A*`</ph>.","pos":[14391,14497],"source":" Similarly, conversion from type `D*` to type `B*` is preferable to conversion from type `D*` to type `A*`."},{"content":"This same rule applies to reference conversions.","pos":[14504,14552]},{"content":"Conversion from type <ph id=\"ph1\">`D&amp;`</ph> to type <ph id=\"ph2\">`C&amp;`</ph> is preferable to conversion from type <ph id=\"ph3\">`D&amp;`</ph> to type <ph id=\"ph4\">`B&amp;`</ph>, and so on.","pos":[14553,14659],"source":" Conversion from type `D&` to type `C&` is preferable to conversion from type `D&` to type `B&`, and so on."},{"content":"This same rule applies to pointer-to-member conversions.","pos":[14666,14722]},{"content":"Conversion from type <ph id=\"ph1\">`T D::*`</ph> to type <ph id=\"ph2\">`T C::*`</ph> is preferable to conversion from type <ph id=\"ph3\">`T D::*`</ph> to type <ph id=\"ph4\">`T B::*`</ph>, and so on (where <ph id=\"ph5\">`T`</ph> is the type of the member).","pos":[14723,14883],"source":" Conversion from type `T D::*` to type `T C::*` is preferable to conversion from type `T D::*` to type `T B::*`, and so on (where `T` is the type of the member)."},{"content":"The preceding rule applies only along a given path of derivation.","pos":[14890,14955]},{"content":"Consider the graph shown in the following figure.","pos":[14956,15005]},{"content":"Multi&amp;#45;inheritance that shows preferred conversions","pos":[15014,15068],"source":"Multi&#45;inheritance that shows preferred conversions"},{"content":"Multiple-Inheritance Graph Illustrating Preferred Conversions","pos":[15108,15169]},{"content":"Conversion from type <ph id=\"ph1\">`C*`</ph> to type <ph id=\"ph2\">`B*`</ph> is preferable to conversion from type <ph id=\"ph3\">`C*`</ph> to type <ph id=\"ph4\">`A*`</ph>.","pos":[15176,15271],"source":"Conversion from type `C*` to type `B*` is preferable to conversion from type `C*` to type `A*`."},{"content":"The reason is that they are on the same path, and <ph id=\"ph1\">`B*`</ph> is closer.","pos":[15272,15337],"source":" The reason is that they are on the same path, and `B*` is closer."},{"content":"However, conversion from type <ph id=\"ph1\">`C*`</ph> to type <ph id=\"ph2\">`D*`</ph> is not preferable to conversion to type <ph id=\"ph3\">`A*`</ph>; there is no preference because the conversions follow different paths.","pos":[15338,15502],"source":" However, conversion from type `C*` to type `D*` is not preferable to conversion to type `A*`; there is no preference because the conversions follow different paths."},{"content":"Match with user-defined conversions.","pos":[15512,15548]},{"content":"This sequence cannot be classified as an exact match, a match using promotions, or a match using standard conversions.","pos":[15549,15667]},{"content":"The sequence must contain only user-defined conversions, standard conversions, or trivial conversions to be classified as a match with user-defined conversions.","pos":[15668,15828]},{"content":"A match with user-defined conversions is considered a better match than a match with an ellipsis but not as good a match as a match with standard conversions.","pos":[15829,15987]},{"content":"Match with an ellipsis.","pos":[15997,16020]},{"content":"Any sequence that matches an ellipsis in the declaration is classified as a match with an ellipsis.","pos":[16021,16120]},{"content":"This is considered the weakest match.","pos":[16121,16158]},{"content":"User-defined conversions are applied if no built-in promotion or conversion exists.","pos":[16165,16248]},{"content":"These conversions are selected on the basis of the type of the argument being matched.","pos":[16249,16335]},{"content":"Consider the following code:","pos":[16336,16364]},{"content":"The available user-defined conversions for class <ph id=\"ph1\">`UDC`</ph> are from type <ph id=\"ph2\">`int`</ph> and type <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>.","pos":[16610,16703],"source":"The available user-defined conversions for class `UDC` are from type `int` and type **long**."},{"content":"Therefore, the compiler considers conversions for the type of the object being matched: <ph id=\"ph1\">`UDC`</ph>.","pos":[16704,16798],"source":" Therefore, the compiler considers conversions for the type of the object being matched: `UDC`."},{"content":"A conversion to <ph id=\"ph1\">`int`</ph> exists, and it is selected.","pos":[16799,16848],"source":" A conversion to `int` exists, and it is selected."},{"content":"During the process of matching arguments, standard conversions can be applied to both the argument and the result of a user-defined conversion.","pos":[16855,16998]},{"content":"Therefore, the following code works:","pos":[16999,17035]},{"content":"In the preceding example, the user-defined conversion, <bpt id=\"p1\">**</bpt>operator long<ept id=\"p1\">**</ept>, is invoked to convert <ph id=\"ph1\">`udc`</ph> to type <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept>.","pos":[17122,17241],"source":"In the preceding example, the user-defined conversion, **operator long**, is invoked to convert `udc` to type **long**."},{"content":"If no user-defined conversion to type <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> had been defined, the conversion would have proceeded as follows: Type <ph id=\"ph1\">`UDC`</ph> would have been converted to type <ph id=\"ph2\">`int`</ph> using the user-defined conversion.","pos":[17242,17440],"source":" If no user-defined conversion to type **long** had been defined, the conversion would have proceeded as follows: Type `UDC` would have been converted to type `int` using the user-defined conversion."},{"content":"Then the standard conversion from type <ph id=\"ph1\">`int`</ph> to type <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> would have been applied to match the argument in the declaration.","pos":[17441,17568],"source":" Then the standard conversion from type `int` to type **long** would have been applied to match the argument in the declaration."},{"content":"If any user-defined conversions are required to match an argument, the standard conversions are not used when evaluating the best match.","pos":[17575,17711]},{"content":"This is true even if more than one candidate function requires a user-defined conversion; in such a case, the functions are considered equal.","pos":[17712,17853]},{"content":"For example:","pos":[17854,17866]},{"content":"Both versions of <ph id=\"ph1\">`Func`</ph> require a user-defined conversion to convert type <ph id=\"ph2\">`int`</ph> to the class type argument.","pos":[18201,18308],"source":"Both versions of `Func` require a user-defined conversion to convert type `int` to the class type argument."},{"content":"The possible conversions are:","pos":[18309,18338]},{"pos":[18348,18415],"content":"Convert from type <ph id=\"ph1\">`int`</ph> to type <ph id=\"ph2\">`UDC1`</ph> (a user-defined conversion).","source":"Convert from type `int` to type `UDC1` (a user-defined conversion)."},{"pos":[18425,18519],"content":"Convert from type <ph id=\"ph1\">`int`</ph> to type <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>; then convert to type <ph id=\"ph2\">`UDC2`</ph> (a two-step conversion).","source":"Convert from type `int` to type **long**; then convert to type `UDC2` (a two-step conversion)."},{"content":"Even though the second of these requires a standard conversion, as well as the user-defined conversion, the two conversions are still considered equal.","pos":[18526,18677]},{"pos":[18685,18884],"content":"[!NOTE]\n User-defined conversions are considered conversion by construction or conversion by initialization (conversion function). Both methods are considered equal when considering the best match.","leadings":["","> "],"nodes":[{"content":" User-defined conversions are considered conversion by construction or conversion by initialization (conversion function). Both methods are considered equal when considering the best match.","pos":[8,197],"nodes":[{"content":"User-defined conversions are considered conversion by construction or conversion by initialization (conversion function).","pos":[1,122]},{"content":"Both methods are considered equal when considering the best match.","pos":[123,189]}]}]},{"content":"Argument matching and the this pointer","pos":[18893,18931]},{"content":"Class member functions are treated differently, depending on whether they are declared as <ph id=\"ph1\">`static`</ph>.","pos":[18935,19034],"source":"Class member functions are treated differently, depending on whether they are declared as `static`."},{"content":"Because nonstatic functions have an implicit argument that supplies the <ph id=\"ph1\">`this`</ph> pointer, nonstatic functions are considered to have one more argument than static functions; otherwise, they are declared identically.","pos":[19035,19248],"source":" Because nonstatic functions have an implicit argument that supplies the `this` pointer, nonstatic functions are considered to have one more argument than static functions; otherwise, they are declared identically."},{"content":"These nonstatic member functions require that the implied <ph id=\"ph1\">`this`</ph> pointer match the object type through which the function is being called, or, for overloaded operators, they require that the first argument match the object on which the operator is being applied.","pos":[19255,19517],"source":"These nonstatic member functions require that the implied `this` pointer match the object type through which the function is being called, or, for overloaded operators, they require that the first argument match the object on which the operator is being applied."},{"content":"(For more information about overloaded operators, see <bpt id=\"p1\">[</bpt>Overloaded Operators<ept id=\"p1\">](../cpp/operator-overloading.md)</ept>.)","pos":[19518,19628],"source":" (For more information about overloaded operators, see [Overloaded Operators](../cpp/operator-overloading.md).)"},{"pos":[19635,19801],"content":"Unlike other arguments in overloaded functions, no temporary objects are introduced and no conversions are attempted when trying to match the <ph id=\"ph1\">`this`</ph> pointer argument.","source":"Unlike other arguments in overloaded functions, no temporary objects are introduced and no conversions are attempted when trying to match the `this` pointer argument."},{"content":"When the <ph id=\"ph1\">`– &gt;`</ph> member-selection operator is used to access a member function, the <ph id=\"ph2\">`this`</ph> pointer argument has a type of <ph id=\"ph3\">`class-name`</ph> <ph id=\"ph4\">`* const`</ph>.","pos":[19808,19951],"source":"When the `– >` member-selection operator is used to access a member function, the `this` pointer argument has a type of `class-name` `* const`."},{"content":"If the members are declared as <ph id=\"ph1\">`const`</ph> or <ph id=\"ph2\">`volatile`</ph>, the types are <ph id=\"ph3\">`const`</ph> <ph id=\"ph4\">`class-name``* const`</ph> and <ph id=\"ph5\">`volatile`</ph> <ph id=\"ph6\">`class-name`</ph> <ph id=\"ph7\">`* const`</ph>, respectively.","pos":[19952,20102],"source":" If the members are declared as `const` or `volatile`, the types are `const` `class-name``* const` and `volatile` `class-name` `* const`, respectively."},{"content":"The <ph id=\"ph1\">`.`</ph> member-selection operator works exactly the same way, except that an implicit <ph id=\"ph2\">`&amp;`</ph> (address-of) operator is prefixed to the object name.","pos":[20109,20252],"source":"The `.` member-selection operator works exactly the same way, except that an implicit `&` (address-of) operator is prefixed to the object name."},{"content":"The following example shows how this works:","pos":[20253,20296]},{"pos":[20415,20592],"content":"The left operand of the <ph id=\"ph1\">`–&gt;*`</ph> and <ph id=\"ph2\">`.*`</ph> (pointer to member) operators are treated the same way as the <ph id=\"ph3\">`.`</ph> and <ph id=\"ph4\">`–&gt;`</ph> (member-selection) operators with respect to argument matching.","source":"The left operand of the `–>*` and `.*` (pointer to member) operators are treated the same way as the `.` and `–>` (member-selection) operators with respect to argument matching."},{"content":"Restrictions","pos":[20601,20613]},{"content":"Several restrictions govern an acceptable set of overloaded functions:","pos":[20617,20687]},{"content":"Any two functions in a set of overloaded functions must have different argument lists.","pos":[20697,20783]},{"content":"Overloading functions with argument lists of the same types, based on return type alone, is an error.","pos":[20793,20894]},{"content":"Microsoft Specific","pos":[20907,20925]},{"pos":[20934,21071],"content":"You can overload <bpt id=\"p1\">**</bpt>operator new<ept id=\"p1\">**</ept> solely on the basis of return type — specifically, on the basis of the memory-model modifier specified.","source":"You can overload **operator new** solely on the basis of return type — specifically, on the basis of the memory-model modifier specified."},{"content":"END Microsoft Specific","pos":[21080,21102]},{"content":"Member functions cannot be overloaded solely on the basis of one being static and the other nonstatic.","pos":[21112,21214]},{"content":"declarations do not define new types; they introduce synonyms for existing types.","pos":[21234,21315]},{"content":"They do not affect the overloading mechanism.","pos":[21316,21361]},{"content":"Consider the following code:","pos":[21362,21390]},{"content":"The preceding two functions have identical argument lists.","pos":[21527,21585]},{"content":"is a synonym for type <bpt id=\"p1\">**</bpt>char <ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept>.","pos":[21593,21627],"source":" is a synonym for type **char \\***."},{"content":"In member scope, this code generates an error.","pos":[21628,21674]},{"content":"Enumerated types are distinct types and can be used to distinguish between overloaded functions.","pos":[21684,21780]},{"content":"The types \"array of \" and \"pointer to\" are considered identical for the purposes of distinguishing between overloaded functions.","pos":[21790,21918]},{"content":"This is true only for singly dimensioned arrays.","pos":[21919,21967]},{"content":"Therefore, the following overloaded functions conflict and generate an error message:","pos":[21968,22053]},{"content":"For multiply dimensioned arrays, the second and all succeeding dimensions are considered part of the type.","pos":[22162,22268]},{"content":"Therefore, they are used in distinguishing between overloaded functions:","pos":[22269,22341]},{"content":"Declaration matching","pos":[22497,22517]},{"content":"Any two function declarations of the same name in the same scope can refer to the same function, or to two discrete functions that are overloaded.","pos":[22521,22667]},{"content":"If the argument lists of the declarations contain arguments of equivalent types (as described in the previous section), the function declarations refer to the same function.","pos":[22668,22841]},{"content":"Otherwise, they refer to two different functions that are selected using overloading.","pos":[22842,22927]},{"content":"Class scope is strictly observed; therefore, a function declared in a base class is not in the same scope as a function declared in a derived class.","pos":[22934,23082]},{"content":"If a function in a derived class is declared with the same name as a function in the base class, the derived-class function hides the base-class function instead of causing overloading.","pos":[23083,23268]},{"content":"Block scope is strictly observed; therefore, a function declared in file scope is not in the same scope as a function declared locally.","pos":[23275,23410]},{"content":"If a locally declared function has the same name as a function declared in file scope, the locally declared function hides the file-scoped function instead of causing overloading.","pos":[23411,23590]},{"content":"For example:","pos":[23591,23603]},{"content":"The preceding code shows two definitions from the function <ph id=\"ph1\">`func`</ph>.","pos":[24085,24151],"source":"The preceding code shows two definitions from the function `func`."},{"content":"The definition that takes an argument of type <ph id=\"ph1\">`char *`</ph> is local to <ph id=\"ph2\">`main`</ph> because of the <ph id=\"ph3\">`extern`</ph> statement.","pos":[24152,24260],"source":" The definition that takes an argument of type `char *` is local to `main` because of the `extern` statement."},{"content":"Therefore, the definition that takes an argument of type <ph id=\"ph1\">`int`</ph> is hidden, and the first call to <ph id=\"ph2\">`func`</ph> is in error.","pos":[24261,24376],"source":" Therefore, the definition that takes an argument of type `int` is hidden, and the first call to `func` is in error."},{"content":"For overloaded member functions, different versions of the function can be given different access privileges.","pos":[24383,24492]},{"content":"They are still considered to be in the scope of the enclosing class and thus are overloaded functions.","pos":[24493,24595]},{"content":"Consider the following code, in which the member function <ph id=\"ph1\">`Deposit`</ph> is overloaded; one version is public, the other, private.","pos":[24596,24721],"source":" Consider the following code, in which the member function `Deposit` is overloaded; one version is public, the other, private."},{"content":"The intent of this sample is to provide an <ph id=\"ph1\">`Account`</ph> class in which a correct password is required to perform deposits.","pos":[24728,24847],"source":"The intent of this sample is to provide an `Account` class in which a correct password is required to perform deposits."},{"content":"This is accomplished using overloading.","pos":[24848,24887]},{"content":"Note that the call to <ph id=\"ph1\">`Deposit`</ph> in <ph id=\"ph2\">`Account::Deposit`</ph> calls the private member function.","pos":[24894,24982],"source":"Note that the call to `Deposit` in `Account::Deposit` calls the private member function."},{"content":"This call is correct because <ph id=\"ph1\">`Account::Deposit`</ph> is a member function and therefore has access to the private members of the class.","pos":[24983,25113],"source":" This call is correct because `Account::Deposit` is a member function and therefore has access to the private members of the class."},{"content":"See Also","pos":[25952,25960]},{"content":"Functions (C++)","pos":[25965,25980]}],"content":"---\ntitle: \"Function Overloading | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"function overloading, about function overloading\"\n  - \"function overloading\"\n  - \"declaring functions, overloading\"\nms.assetid: 3c9884cb-1d5e-42e8-9a49-6f46141f929e\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Function Overloading\nC++ allows specification of more than one function of the same name in the same scope. These are called overloaded functions and are described in detail in Overloading. Overloaded functions enable programmers to supply different semantics for a function, depending on the types and number of arguments.  \n  \n For example, a **print** function that takes a string (or **char \\***) argument performs very different tasks than one that takes an argument of type **double**. Overloading permits uniform naming and prevents programmers from having to invent names such as `print_sz` or `print_d`. The following table shows what parts of a function declaration C++ uses to differentiate between groups of functions with the same name in the same scope.  \n  \n### Overloading Considerations  \n  \n|Function Declaration Element|Used for Overloading?|  \n|----------------------------------|---------------------------|  \n|Function return type|No|  \n|Number of arguments|Yes|  \n|Type of arguments|Yes|  \n|Presence or absence of ellipsis|Yes|  \n|Use of `typedef` names|No|  \n|Unspecified array bounds|No|  \n|**const** or `volatile` (see below)|Yes|  \n  \n Although functions can be distinguished on the basis of return type, they cannot be overloaded on this basis.  `Const` or `volatile` are only used as a basis for overloading if they are used in a class to apply to the **this** pointer for the class, not the function's return type.  In other words, overloading applies only if the **const** or `volatile` keyword follows the function's argument list in the declaration.  \n  \n## Example  \n The following example illustrates how overloading can be used.  \n  \n```  \n// function_overloading.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <math.h>  \n  \n// Prototype three print functions.  \nint print( char *s );                  // Print a string.  \nint print( double dvalue );            // Print a double.  \nint print( double dvalue, int prec );  // Print a double with a  \n//  given precision.  \nusing namespace std;  \nint main( int argc, char *argv[] )  \n{  \nconst double d = 893094.2987;  \nif( argc < 2 )  \n    {  \n// These calls to print invoke print( char *s ).  \nprint( \"This program requires one argument.\" );  \nprint( \"The argument specifies the number of\" );  \nprint( \"digits precision for the second number\" );  \nprint( \"printed.\" );  \nexit(0);  \n    }  \n  \n// Invoke print( double dvalue ).  \nprint( d );  \n  \n// Invoke print( double dvalue, int prec ).  \nprint( d, atoi( argv[1] ) );  \n}  \n  \n// Print a string.  \nint print( char *s )  \n{  \ncout << s << endl;  \nreturn cout.good();  \n}  \n  \n// Print a double in default precision.  \nint print( double dvalue )  \n{  \ncout << dvalue << endl;  \nreturn cout.good();  \n}  \n  \n// Print a double in specified precision.  \n//  Positive numbers for precision indicate how many digits  \n//  precision after the decimal point to show. Negative  \n//  numbers for precision indicate where to round the number  \n//  to the left of the decimal point.  \nint print( double dvalue, int prec )  \n{  \n// Use table-lookup for rounding/truncation.  \nstatic const double rgPow10[] = {   \n10E-7, 10E-6, 10E-5, 10E-4, 10E-3, 10E-2, 10E-1, 10E0,  \n10E1,  10E2,  10E3,  10E4, 10E5,  10E6  \n    };  \nconst int iPowZero = 6;  \n// If precision out of range, just print the number.  \nif( prec < -6 || prec > 7 )  \nreturn print( dvalue );  \n// Scale, truncate, then rescale.  \ndvalue = floor( dvalue / rgPow10[iPowZero - prec] ) *  \nrgPow10[iPowZero - prec];  \ncout << dvalue << endl;  \nreturn cout.good();  \n}  \n```  \n  \n The preceding code shows overloading of the `print` function in file scope.  \n  \n The default argument is not considered part of the function type. Therefore, it is not used in selecting overloaded functions. Two functions that differ only in their default arguments are considered multiple definitions rather than overloaded functions.  \n  \n Default arguments cannot be supplied for overloaded operators.  \n  \n  \n## Argument Matching  \n Overloaded functions are selected for the best match of function declarations in the current scope to the arguments supplied in the function call. If a suitable function is found, that function is called. \"Suitable\" in this context means one of the following:  \n  \n-   An exact match was found.  \n  \n-   A trivial conversion was performed.  \n  \n-   An integral promotion was performed.  \n  \n-   A standard conversion to the desired argument type exists.  \n  \n-   A user-defined conversion (either conversion operator or constructor) to the desired argument type exists.  \n  \n-   Arguments represented by an ellipsis were found.  \n  \n The compiler creates a set of candidate functions for each argument. Candidate functions are functions in which the actual argument in that position can be converted to the type of the formal argument.  \n  \n A set of \"best matching functions\" is built for each argument, and the selected function is the intersection of all the sets. If the intersection contains more than one function, the overloading is ambiguous and generates an error. The function that is eventually selected is always a better match than every other function in the group for at least one argument. If this is not the case (if there is no clear winner), the function call generates an error.  \n  \n Consider the following declarations (the functions are marked `Variant 1`, `Variant 2`, and `Variant 3`, for identification in the following discussion):  \n  \n```  \nFraction &Add( Fraction &f, long l );       // Variant 1  \nFraction &Add( long l, Fraction &f );       // Variant 2  \nFraction &Add( Fraction &f, Fraction &f );  // Variant 3  \n  \nFraction F1, F2;  \n```  \n  \n Consider the following statement:  \n  \n```  \nF1 = Add( F2, 23 );  \n```  \n  \n The preceding statement builds two sets:  \n  \n|Set 1: Candidate Functions That Have First Argument of Type Fraction|Set 2: Candidate Functions Whose Second Argument Can Be Converted to Type int|  \n|--------------------------------------------------------------------------|-----------------------------------------------------------------------------------|  \n|Variant 1|Variant 1 (`int` can be converted to `long` using a standard conversion)|  \n|Variant 3||  \n  \n Functions in Set 2 are functions for which there are implicit conversions from actual parameter type to formal parameter type, and among such functions there is a function for which the \"cost\" of converting the actual parameter type to its formal parameter type is the smallest.  \n  \n The intersection of these two sets is Variant 1. An example of an ambiguous function call is:  \n  \n```  \nF1 = Add( 3, 6 );  \n```  \n  \n The preceding function call builds the following sets:  \n  \n|Set 1: Candidate Functions That Have First Argument of Type int|Set 2: Candidate Functions That Have Second Argument of Type int|  \n|---------------------------------------------------------------------|----------------------------------------------------------------------|  \n|Variant 2 (`int` can be converted to `long` using a standard conversion)|Variant 1 (`int` can be converted to `long` using a standard conversion)|  \n  \n Note that the intersection between these two sets is empty. Therefore, the compiler generates an error message.  \n  \n For argument matching, a function with *n* default arguments is treated as *n*+1 separate functions, each with a different number of arguments.  \n  \n The ellipsis (...) acts as a wildcard; it matches any actual argument. This can lead to many ambiguous sets, if you do not design your overloaded function sets with extreme care.  \n  \n> [!NOTE]\n>  Ambiguity of overloaded functions cannot be determined until a function call is encountered. At that point, the sets are built for each argument in the function call, and you can determine whether an unambiguous overload exists. This means that ambiguities can remain in your code until they are evoked by a particular function call.  \n  \n## Argument Type Differences  \n Overloaded functions differentiate between argument types that take different initializers. Therefore, an argument of a given type and a reference to that type are considered the same for the purposes of overloading. They are considered the same because they take the same initializers. For example, `max( double, double )` is considered the same as `max( double &, double & )`. Declaring two such functions causes an error.  \n  \n For the same reason, function arguments of a type modified by **const** or `volatile` are not treated differently than the base type for the purposes of overloading.  \n  \n However, the function overloading mechanism can distinguish between references that are qualified by **const** and `volatile` and references to the base type. This makes code such as the following possible:  \n  \n```  \n// argument_type_differences.cpp  \n// compile with: /EHsc /W3  \n// C4521 expected  \n#include <iostream>  \n  \nusing namespace std;  \nclass Over {  \npublic:  \n   Over() { cout << \"Over default constructor\\n\"; }  \n   Over( Over &o ) { cout << \"Over&\\n\"; }  \n   Over( const Over &co ) { cout << \"const Over&\\n\"; }  \n   Over( volatile Over &vo ) { cout << \"volatile Over&\\n\"; }  \n};  \n  \nint main() {  \n   Over o1;            // Calls default constructor.  \n   Over o2( o1 );      // Calls Over( Over& ).  \n   const Over o3;      // Calls default constructor.  \n   Over o4( o3 );      // Calls Over( const Over& ).  \n   volatile Over o5;   // Calls default constructor.  \n   Over o6( o5 );      // Calls Over( volatile Over& ).  \n}  \n```  \n  \n### Output  \n  \n```  \nOver default constructor  \nOver&  \nOver default constructor  \nconst Over&  \nOver default constructor  \nvolatile Over&  \n```  \n  \n Pointers to **const** and `volatile` objects are also considered different from pointers to the base type for the purposes of overloading.  \n  \n## Argument matching and conversions  \n When the compiler tries to match actual arguments against the arguments in function declarations, it can supply standard or user-defined conversions to obtain the correct type if no exact match can be found. The application of conversions is subject to these rules:  \n  \n-   Sequences of conversions that contain more than one user-defined conversion are not considered.  \n  \n-   Sequences of conversions that can be shortened by removing intermediate conversions are not considered.  \n  \n The resultant sequence of conversions, if any, is called the best matching sequence. There are several ways to convert an object of type `int` to type `unsigned long`using standard conversions (described in [Standard Conversions](../cpp/standard-conversions.md)):  \n  \n-   Convert from `int` to `long` and then from `long` to `unsigned long`.  \n  \n-   Convert from `int` to `unsigned long`.  \n  \n The first sequence, although it achieves the desired goal, is not the best matching sequence — a shorter sequence exists.  \n  \n The following table shows a group of conversions, called trivial conversions, that have a limited effect on determining which sequence is the best matching. The instances in which trivial conversions affect choice of sequence are discussed in the list following the table.  \n  \n### Trivial Conversions  \n  \n|Convert from Type|Convert to Type|  \n|-----------------------|---------------------|  \n|*type-name*|*type-name* **&**|  \n|*type-name* **&**|*type-name*|  \n|*type-name* **[ ]**|*type-name\\**|  \n|*type-name* **(** *argument-list* **)**|**(** *\\*type-name* **) (** *argument-list* **)**|  \n|*type-name*|**const** *type-name*|  \n|*type-name*|`volatile` *type-name*|  \n|*type-name\\**|**const** *type-name\\**|  \n|*type-name\\**|`volatile` *type-name\\**|  \n  \n The sequence in which conversions are attempted is as follows:  \n  \n1.  Exact match. An exact match between the types with which the function is called and the types declared in the function prototype is always the best match. Sequences of trivial conversions are classified as exact matches. However, sequences that do not make any of these conversions are considered better than sequences that convert:  \n  \n    -   From pointer, to pointer to **const** (`type` **\\*** to **const** `type` **\\***).  \n  \n    -   From pointer, to pointer to `volatile` (`type` **\\*** to `volatile` `type` **\\***).  \n  \n    -   From reference, to reference to **const** (`type` **&** to **const** `type` **&**).  \n  \n    -   From reference, to reference to `volatile` (`type` **&** to `volatile` `type` **&**).  \n  \n2.  Match using promotions. Any sequence not classified as an exact match that contains only integral promotions, conversions from **float** to **double**, and trivial conversions is classified as a match using promotions. Although not as good a match as any exact match, a match using promotions is better than a match using standard conversions.  \n  \n3.  Match using standard conversions. Any sequence not classified as an exact match or a match using promotions that contains only standard conversions and trivial conversions is classified as a match using standard conversions. Within this category, the following rules are applied:  \n  \n    -   Conversion from a pointer to a derived class, to a pointer to a direct or indirect base class is preferable to converting to **void \\*** or **const void \\***.  \n  \n    -   Conversion from a pointer to a derived class, to a pointer to a base class produces a better match the closer the base class is to a direct base class. Suppose the class hierarchy is as shown in the following figure.  \n  \n ![Preferred conversions](../cpp/media/vc391t1.gif \"vc391T1\")  \nGraph Illustrating Preferred Conversions  \n  \n Conversion from type `D*` to type `C*` is preferable to conversion from type `D*` to type `B*`. Similarly, conversion from type `D*` to type `B*` is preferable to conversion from type `D*` to type `A*`.  \n  \n This same rule applies to reference conversions. Conversion from type `D&` to type `C&` is preferable to conversion from type `D&` to type `B&`, and so on.  \n  \n This same rule applies to pointer-to-member conversions. Conversion from type `T D::*` to type `T C::*` is preferable to conversion from type `T D::*` to type `T B::*`, and so on (where `T` is the type of the member).  \n  \n The preceding rule applies only along a given path of derivation. Consider the graph shown in the following figure.  \n  \n ![Multi&#45;inheritance that shows preferred conversions](../cpp/media/vc391t2.gif \"vc391T2\")  \nMultiple-Inheritance Graph Illustrating Preferred Conversions  \n  \n Conversion from type `C*` to type `B*` is preferable to conversion from type `C*` to type `A*`. The reason is that they are on the same path, and `B*` is closer. However, conversion from type `C*` to type `D*` is not preferable to conversion to type `A*`; there is no preference because the conversions follow different paths.  \n  \n1.  Match with user-defined conversions. This sequence cannot be classified as an exact match, a match using promotions, or a match using standard conversions. The sequence must contain only user-defined conversions, standard conversions, or trivial conversions to be classified as a match with user-defined conversions. A match with user-defined conversions is considered a better match than a match with an ellipsis but not as good a match as a match with standard conversions.  \n  \n2.  Match with an ellipsis. Any sequence that matches an ellipsis in the declaration is classified as a match with an ellipsis. This is considered the weakest match.  \n  \n User-defined conversions are applied if no built-in promotion or conversion exists. These conversions are selected on the basis of the type of the argument being matched. Consider the following code:  \n  \n```  \n// argument_matching1.cpp  \nclass UDC  \n{  \npublic:  \n   operator int()  \n   {  \n      return 0;  \n   }  \n   operator long();  \n};  \n  \nvoid Print( int i )  \n{  \n};  \n  \nUDC udc;  \n  \nint main()  \n{  \n   Print( udc );  \n}  \n```  \n  \n The available user-defined conversions for class `UDC` are from type `int` and type **long**. Therefore, the compiler considers conversions for the type of the object being matched: `UDC`. A conversion to `int` exists, and it is selected.  \n  \n During the process of matching arguments, standard conversions can be applied to both the argument and the result of a user-defined conversion. Therefore, the following code works:  \n  \n```  \nvoid LogToFile( long l );  \n...  \nUDC udc;  \nLogToFile( udc );  \n```  \n  \n In the preceding example, the user-defined conversion, **operator long**, is invoked to convert `udc` to type **long**. If no user-defined conversion to type **long** had been defined, the conversion would have proceeded as follows: Type `UDC` would have been converted to type `int` using the user-defined conversion. Then the standard conversion from type `int` to type **long** would have been applied to match the argument in the declaration.  \n  \n If any user-defined conversions are required to match an argument, the standard conversions are not used when evaluating the best match. This is true even if more than one candidate function requires a user-defined conversion; in such a case, the functions are considered equal. For example:  \n  \n```  \n// argument_matching2.cpp  \n// C2668 expected  \nclass UDC1  \n{  \npublic:  \n   UDC1( int );  // User-defined conversion from int.  \n};  \n  \nclass UDC2  \n{  \npublic:  \n   UDC2( long ); // User-defined conversion from long.  \n};  \n  \nvoid Func( UDC1 );  \nvoid Func( UDC2 );  \n  \nint main()  \n{  \n   Func( 1 );  \n}  \n```  \n  \n Both versions of `Func` require a user-defined conversion to convert type `int` to the class type argument. The possible conversions are:  \n  \n-   Convert from type `int` to type `UDC1` (a user-defined conversion).  \n  \n-   Convert from type `int` to type **long**; then convert to type `UDC2` (a two-step conversion).  \n  \n Even though the second of these requires a standard conversion, as well as the user-defined conversion, the two conversions are still considered equal.  \n  \n> [!NOTE]\n>  User-defined conversions are considered conversion by construction or conversion by initialization (conversion function). Both methods are considered equal when considering the best match.  \n  \n## Argument matching and the this pointer  \n Class member functions are treated differently, depending on whether they are declared as `static`. Because nonstatic functions have an implicit argument that supplies the `this` pointer, nonstatic functions are considered to have one more argument than static functions; otherwise, they are declared identically.  \n  \n These nonstatic member functions require that the implied `this` pointer match the object type through which the function is being called, or, for overloaded operators, they require that the first argument match the object on which the operator is being applied. (For more information about overloaded operators, see [Overloaded Operators](../cpp/operator-overloading.md).)  \n  \n Unlike other arguments in overloaded functions, no temporary objects are introduced and no conversions are attempted when trying to match the `this` pointer argument.  \n  \n When the `– >` member-selection operator is used to access a member function, the `this` pointer argument has a type of `class-name` `* const`. If the members are declared as `const` or `volatile`, the types are `const` `class-name``* const` and `volatile` `class-name` `* const`, respectively.  \n  \n The `.` member-selection operator works exactly the same way, except that an implicit `&` (address-of) operator is prefixed to the object name. The following example shows how this works:  \n  \n```  \n// Expression encountered in code  \nobj.name  \n  \n// How the compiler treats it  \n(&obj)->name  \n```  \n  \n The left operand of the `–>*` and `.*` (pointer to member) operators are treated the same way as the `.` and `–>` (member-selection) operators with respect to argument matching.  \n  \n## Restrictions  \n Several restrictions govern an acceptable set of overloaded functions:  \n  \n-   Any two functions in a set of overloaded functions must have different argument lists.  \n  \n-   Overloading functions with argument lists of the same types, based on return type alone, is an error.  \n  \n     **Microsoft Specific**  \n  \n You can overload **operator new** solely on the basis of return type — specifically, on the basis of the memory-model modifier specified.  \n  \n## END Microsoft Specific  \n  \n-   Member functions cannot be overloaded solely on the basis of one being static and the other nonstatic.  \n  \n-   `typedef` declarations do not define new types; they introduce synonyms for existing types. They do not affect the overloading mechanism. Consider the following code:  \n  \n    ```  \n    typedef char * PSTR;  \n  \n    void Print( char *szToPrint );  \n    void Print( PSTR szToPrint );  \n    ```  \n  \n     The preceding two functions have identical argument lists. `PSTR` is a synonym for type **char \\***. In member scope, this code generates an error.  \n  \n-   Enumerated types are distinct types and can be used to distinguish between overloaded functions.  \n  \n-   The types \"array of \" and \"pointer to\" are considered identical for the purposes of distinguishing between overloaded functions. This is true only for singly dimensioned arrays. Therefore, the following overloaded functions conflict and generate an error message:  \n  \n    ```  \n    void Print( char *szToPrint );  \n    void Print( char szToPrint[] );  \n    ```  \n  \n     For multiply dimensioned arrays, the second and all succeeding dimensions are considered part of the type. Therefore, they are used in distinguishing between overloaded functions:  \n  \n    ```  \n    void Print( char szToPrint[] );  \n    void Print( char szToPrint[][7] );  \n    void Print( char szToPrint[][9][42] );  \n    ```  \n  \n## Declaration matching  \n Any two function declarations of the same name in the same scope can refer to the same function, or to two discrete functions that are overloaded. If the argument lists of the declarations contain arguments of equivalent types (as described in the previous section), the function declarations refer to the same function. Otherwise, they refer to two different functions that are selected using overloading.  \n  \n Class scope is strictly observed; therefore, a function declared in a base class is not in the same scope as a function declared in a derived class. If a function in a derived class is declared with the same name as a function in the base class, the derived-class function hides the base-class function instead of causing overloading.  \n  \n Block scope is strictly observed; therefore, a function declared in file scope is not in the same scope as a function declared locally. If a locally declared function has the same name as a function declared in file scope, the locally declared function hides the file-scoped function instead of causing overloading. For example:  \n  \n```  \n// declaration_matching1.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nusing namespace std;  \nvoid func( int i )  \n{  \n    cout << \"Called file-scoped func : \" << i << endl;  \n}  \n  \nvoid func( char *sz )  \n{  \n   cout << \"Called locally declared func : \" << sz << endl;  \n}  \n  \nint main()  \n{  \n   // Declare func local to main.  \n   extern void func( char *sz );  \n  \n   func( 3 );   // C2664 Error. func( int ) is hidden.  \n   func( \"s\" );  \n}  \n```  \n  \n The preceding code shows two definitions from the function `func`. The definition that takes an argument of type `char *` is local to `main` because of the `extern` statement. Therefore, the definition that takes an argument of type `int` is hidden, and the first call to `func` is in error.  \n  \n For overloaded member functions, different versions of the function can be given different access privileges. They are still considered to be in the scope of the enclosing class and thus are overloaded functions. Consider the following code, in which the member function `Deposit` is overloaded; one version is public, the other, private.  \n  \n The intent of this sample is to provide an `Account` class in which a correct password is required to perform deposits. This is accomplished using overloading.  \n  \n Note that the call to `Deposit` in `Account::Deposit` calls the private member function. This call is correct because `Account::Deposit` is a member function and therefore has access to the private members of the class.  \n  \n```  \n// declaration_matching2.cpp  \nclass Account  \n{  \npublic:  \n   Account()  \n   {  \n   }  \n   double Deposit( double dAmount, char *szPassword );  \n  \nprivate:  \n   double Deposit( double dAmount )  \n   {  \n      return 0.0;  \n   }  \n   int Validate( char *szPassword )  \n   {  \n      return 0;  \n   }  \n  \n};  \n  \nint main()  \n{  \n    // Allocate a new object of type Account.  \n    Account *pAcct = new Account;  \n  \n    // Deposit $57.22. Error: calls a private function.  \n    // pAcct->Deposit( 57.22 );  \n  \n    // Deposit $57.22 and supply a password. OK: calls a  \n    //  public function.  \n    pAcct->Deposit( 52.77, \"pswd\" );  \n}  \n  \ndouble Account::Deposit( double dAmount, char *szPassword )  \n{  \n   if ( Validate( szPassword ) )  \n      return Deposit( dAmount );  \n   else  \n      return 0.0;  \n}  \n```  \n  \n## See Also  \n [Functions (C++)](../cpp/functions-cpp.md)"}