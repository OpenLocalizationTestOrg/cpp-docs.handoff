{"nodes":[{"pos":[12,38],"content":"__clrcall | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"__clrcall | Microsoft Docs","pos":[0,26]}]},{"content":"__clrcall","pos":[632,641]},{"content":"Microsoft Specific","pos":[644,662]},{"content":"Specifies that a function can only be called from managed code.","pos":[671,734]},{"content":"Use <ph id=\"ph1\">`__clrcall`</ph> for all virtual functions that will only be called from managed code.","pos":[736,821],"source":"  Use `__clrcall` for all virtual functions that will only be called from managed code."},{"content":"However this calling convention cannot be used for functions that will be called from native code.","pos":[822,920]},{"pos":[927,1094],"content":"Use <ph id=\"ph1\">`__clrcall`</ph> to improve performance when calling from a managed function to a virtual managed function or from managed function to managed function through pointer.","source":"Use `__clrcall` to improve performance when calling from a managed function to a virtual managed function or from managed function to managed function through pointer."},{"content":"Entry points are separate, compiler-generated functions.","pos":[1101,1157]},{"content":"If a function has both native and managed entry points, one of them will be the actual function with the function implementation.","pos":[1158,1287]},{"content":"The other function will be a separate function (a thunk) that calls into the actual function and lets the common language runtime perform PInvoke.","pos":[1288,1434]},{"content":"When marking a function as <ph id=\"ph1\">`__clrcall`</ph>, you indicate the function implementation must be MSIL and that the native entry point function will not be generated.","pos":[1435,1592],"source":" When marking a function as `__clrcall`, you indicate the function implementation must be MSIL and that the native entry point function will not be generated."},{"content":"When taking the address of a native function if <ph id=\"ph1\">`__clrcall`</ph> is not specified, the compiler uses the native entry point.","pos":[1599,1718],"source":"When taking the address of a native function if `__clrcall` is not specified, the compiler uses the native entry point."},{"content":"indicates that the function is managed and there is no need to go through the transition from managed to native.","pos":[1731,1843]},{"content":"In that case the compiler uses the managed entry point.","pos":[1844,1899]},{"content":"When <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> (not <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>/clr:safe<ept id=\"p3\">**</ept>) is used and <ph id=\"ph1\">`__clrcall`</ph> is not used, taking the address of a function always returns the address of the native entry point function.","pos":[1906,2089],"source":"When **/clr** (not **/clr:pure** or **/clr:safe**) is used and `__clrcall` is not used, taking the address of a function always returns the address of the native entry point function."},{"content":"When <ph id=\"ph1\">`__clrcall`</ph> is used, the native entry point function is not created, so you get the address of the managed function, not an entry point thunk function.","pos":[2090,2246],"source":" When `__clrcall` is used, the native entry point function is not created, so you get the address of the managed function, not an entry point thunk function."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Double Thunking<ept id=\"p1\">](../dotnet/double-thunking-cpp.md)</ept>.","pos":[2247,2325],"source":" For more information, see [Double Thunking](../dotnet/double-thunking-cpp.md)."},{"content":"<bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept> implies that all functions and function pointers are <ph id=\"ph1\">`__clrcall`</ph> and the compiler will not permit a function inside the compiland to be marked anything other than <ph id=\"ph2\">`__clrcall`</ph>.","pos":[2332,2615],"source":"[/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md) implies that all functions and function pointers are `__clrcall` and the compiler will not permit a function inside the compiland to be marked anything other than `__clrcall`."},{"content":"When <bpt id=\"p1\">**</bpt>/clr:pure<ept id=\"p1\">**</ept> is used, <ph id=\"ph1\">`__clrcall`</ph> can only be specified on function pointers and external declarations.","pos":[2616,2725],"source":" When **/clr:pure** is used, `__clrcall` can only be specified on function pointers and external declarations."},{"content":"You can directly call <ph id=\"ph1\">`__clrcall`</ph> functions from existing C++ code that was compiled by using <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> as long as that function has an MSIL implementation.","pos":[2732,2887],"source":"You can directly call `__clrcall` functions from existing C++ code that was compiled by using **/clr** as long as that function has an MSIL implementation."},{"content":"functions cannot be called directly from functions that have inline asm and call CPU-specific intrinisics, for example, even if those functions are compiled with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>.","pos":[2900,3071],"source":" functions cannot be called directly from functions that have inline asm and call CPU-specific intrinisics, for example, even if those functions are compiled with **/clr**."},{"content":"function pointers are only meant to be used in the application domain in which they were created.","pos":[3090,3187]},{"content":"Instead of passing <ph id=\"ph1\">`__clrcall`</ph> function pointers across application domains, use &lt;xref:System.CrossAppDomainDelegate&gt;.","pos":[3189,3307],"source":"  Instead of passing `__clrcall` function pointers across application domains, use <xref:System.CrossAppDomainDelegate>."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Application Domains and Visual C++<ept id=\"p1\">](../dotnet/application-domains-and-visual-cpp.md)</ept>.","pos":[3308,3420],"source":" For more information, see [Application Domains and Visual C++](../dotnet/application-domains-and-visual-cpp.md)."},{"content":"Example","pos":[3429,3436]},{"pos":[3440,3569],"content":"Note that when a function is declared with <ph id=\"ph1\">`__clrcall`</ph>, code will be generated when needed; for example, when function is called.","source":"Note that when a function is declared with `__clrcall`, code will be generated when needed; for example, when function is called."},{"content":"Example","pos":[4422,4429]},{"content":"The following sample shows that you can define a function pointer, such that, you declare that the function pointer will only be invoked from managed code.","pos":[4433,4588]},{"content":"This allows the compiler to directly call the managed function and avoid the native entry point (double thunk issue).","pos":[4589,4706]},{"content":"See Also","pos":[4967,4975]},{"content":"Argument Passing and Naming Conventions","pos":[4980,5019]},{"content":"Keywords","pos":[5077,5085]}],"content":"---\ntitle: \"__clrcall | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"__clrcall\"\n  - \"__clrcall_cpp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__clrcall keyword [C++]\"\nms.assetid: 92096695-683a-40ed-bf65-0c8443572152\ncaps.latest.revision: 17\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# __clrcall\n**Microsoft Specific**  \n  \n Specifies that a function can only be called from managed code.  Use `__clrcall` for all virtual functions that will only be called from managed code. However this calling convention cannot be used for functions that will be called from native code.  \n  \n Use `__clrcall` to improve performance when calling from a managed function to a virtual managed function or from managed function to managed function through pointer.  \n  \n Entry points are separate, compiler-generated functions. If a function has both native and managed entry points, one of them will be the actual function with the function implementation. The other function will be a separate function (a thunk) that calls into the actual function and lets the common language runtime perform PInvoke. When marking a function as `__clrcall`, you indicate the function implementation must be MSIL and that the native entry point function will not be generated.  \n  \n When taking the address of a native function if `__clrcall` is not specified, the compiler uses the native entry point. `__clrcall` indicates that the function is managed and there is no need to go through the transition from managed to native. In that case the compiler uses the managed entry point.  \n  \n When **/clr** (not **/clr:pure** or **/clr:safe**) is used and `__clrcall` is not used, taking the address of a function always returns the address of the native entry point function. When `__clrcall` is used, the native entry point function is not created, so you get the address of the managed function, not an entry point thunk function. For more information, see [Double Thunking](../dotnet/double-thunking-cpp.md).  \n  \n [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md) implies that all functions and function pointers are `__clrcall` and the compiler will not permit a function inside the compiland to be marked anything other than `__clrcall`. When **/clr:pure** is used, `__clrcall` can only be specified on function pointers and external declarations.  \n  \n You can directly call `__clrcall` functions from existing C++ code that was compiled by using **/clr** as long as that function has an MSIL implementation. `__clrcall` functions cannot be called directly from functions that have inline asm and call CPU-specific intrinisics, for example, even if those functions are compiled with **/clr**.  \n  \n `__clrcall` function pointers are only meant to be used in the application domain in which they were created.  Instead of passing `__clrcall` function pointers across application domains, use <xref:System.CrossAppDomainDelegate>. For more information, see [Application Domains and Visual C++](../dotnet/application-domains-and-visual-cpp.md).  \n  \n## Example  \n Note that when a function is declared with `__clrcall`, code will be generated when needed; for example, when function is called.  \n  \n```  \n// clrcall2.cpp  \n// compile with: /clr  \nusing namespace System;  \nint __clrcall Func1() {  \n   Console::WriteLine(\"in Func1\");  \n   return 0;  \n}  \n  \n// Func1 hasn't been used at this point (code has not been generated),   \n// so runtime returns the adddress of a stub to the function  \nint (__clrcall *pf)() = &Func1;  \n  \n// code calls the function, code generated at difference address  \nint i = pf();   // comment this line and comparison will pass  \n  \nint main() {  \n   if (&Func1 == pf)  \n      Console::WriteLine(\"&Func1 == pf, comparison succeeds\");  \n   else   \n      Console::WriteLine(\"&Func1 != pf, comparison fails\");  \n  \n   // even though comparison fails, stub and function call are correct  \n   pf();  \n   Func1();  \n}  \n```  \n  \n```Output  \nin Func1  \n&Func1 != pf, comparison fails  \nin Func1  \nin Func1  \n```  \n  \n## Example  \n The following sample shows that you can define a function pointer, such that, you declare that the function pointer will only be invoked from managed code. This allows the compiler to directly call the managed function and avoid the native entry point (double thunk issue).  \n  \n```  \n// clrcall3.cpp  \n// compile with: /clr  \nvoid Test() {  \n   System::Console::WriteLine(\"in Test\");  \n}  \n  \nint main() {  \n   void (*pTest)() = &Test;  \n   (*pTest)();  \n  \n   void (__clrcall *pTest2)() = &Test;  \n   (*pTest2)();  \n}  \n```  \n  \n## See Also  \n [Argument Passing and Naming Conventions](../cpp/argument-passing-and-naming-conventions.md)   \n [Keywords](../cpp/keywords-cpp.md)"}