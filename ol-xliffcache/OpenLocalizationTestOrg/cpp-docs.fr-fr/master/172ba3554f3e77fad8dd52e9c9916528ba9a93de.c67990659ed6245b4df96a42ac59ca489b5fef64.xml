{"nodes":[{"pos":[12,65],"content":"Data Type Specifiers and Equivalents | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Data Type Specifiers and Equivalents | Microsoft Docs","pos":[0,53]}]},{"content":"Data Type Specifiers and Equivalents","pos":[847,883]},{"content":"This book generally uses the forms of the type specifiers listed in the following table rather than the long forms, and it assumes that the <ph id=\"ph1\">`char`</ph> type is signed by default.","pos":[884,1057],"source":"This book generally uses the forms of the type specifiers listed in the following table rather than the long forms, and it assumes that the `char` type is signed by default."},{"content":"Therefore, throughout this book, <ph id=\"ph1\">`char`</ph> is equivalent to <bpt id=\"p1\">**</bpt>signed char<ept id=\"p1\">**</ept>.","pos":[1058,1131],"source":" Therefore, throughout this book, `char` is equivalent to **signed char**."},{"content":"Type Specifiers and Equivalents","pos":[1141,1172]},{"content":"Type Specifier","pos":[1179,1193]},{"content":"Equivalent(s)","pos":[1194,1207]},{"pos":[1259,1275],"content":"<bpt id=\"p1\">**</bpt>signed char<ept id=\"p1\">**</ept>1","source":"**signed char**1"},{"content":"signed int","pos":[1289,1299]},{"pos":[1302,1313],"content":"<bpt id=\"p1\">**</bpt>signed<ept id=\"p1\">**</ept>,","source":"**signed**, "},{"content":"signed short int","pos":[1326,1342]},{"pos":[1345,1355],"content":"<bpt id=\"p1\">**</bpt>short<ept id=\"p1\">**</ept>,","source":"**short**, "},{"content":"signed long int","pos":[1377,1392]},{"pos":[1395,1420],"content":"<bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>signed long<ept id=\"p2\">**</ept>","source":"**long**, **signed long**"},{"content":"—","pos":[1441,1442]},{"content":"unsigned short int","pos":[1479,1497]},{"content":"unsigned short","pos":[1502,1516]},{"content":"unsigned long int","pos":[1525,1542]},{"content":"float","pos":[1567,1572]},{"content":"—","pos":[1575,1576]},{"pos":[1594,1595],"content":"2"},{"content":"—","pos":[1596,1597]},{"pos":[1605,1747],"content":"1   When you make the <ph id=\"ph1\">`char`</ph> type unsigned by default (by specifying the /J compiler option), you cannot abbreviate <bpt id=\"p1\">**</bpt>signed char<ept id=\"p1\">**</ept> as <ph id=\"ph2\">`char`</ph>.","source":"1   When you make the `char` type unsigned by default (by specifying the /J compiler option), you cannot abbreviate **signed char** as `char`."},{"pos":[1754,1852],"content":"2   In 32-bit operating systems, the Microsoft C compiler maps <bpt id=\"p1\">**</bpt>long double<ept id=\"p1\">**</ept> to type <bpt id=\"p2\">**</bpt>double<ept id=\"p2\">**</ept>.","source":"2   In 32-bit operating systems, the Microsoft C compiler maps **long double** to type **double**."},{"content":"Microsoft Specific","pos":[1861,1879]},{"content":"You can specify the /J compiler option to change the default <ph id=\"ph1\">`char`</ph> type from signed to unsigned.","pos":[1888,1985],"source":"You can specify the /J compiler option to change the default `char` type from signed to unsigned."},{"content":"When this option is in effect, <ph id=\"ph1\">`char`</ph> means the same as <ph id=\"ph2\">`unsigned char`</ph>, and you must use the <bpt id=\"p1\">**</bpt>signed<ept id=\"p1\">**</ept> keyword to declare a signed character value.","pos":[1986,2135],"source":" When this option is in effect, `char` means the same as `unsigned char`, and you must use the **signed** keyword to declare a signed character value."},{"content":"If a <ph id=\"ph1\">`char`</ph> value is explicitly declared signed, the /J option does not affect it, and the value is sign-extended when widened to an <ph id=\"ph2\">`int`</ph> type.","pos":[2136,2280],"source":" If a `char` value is explicitly declared signed, the /J option does not affect it, and the value is sign-extended when widened to an `int` type."},{"content":"The <ph id=\"ph1\">`char`</ph> type is zero-extended when widened to <ph id=\"ph2\">`int`</ph> type.","pos":[2281,2341],"source":" The `char` type is zero-extended when widened to `int` type."},{"content":"END Microsoft Specific","pos":[2350,2372]},{"content":"See Also","pos":[2383,2391]},{"content":"C Type Specifiers","pos":[2396,2413]}],"content":"---\ntitle: \"Data Type Specifiers and Equivalents | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"type specifiers [C++], list\"\n  - \"widening integers\"\n  - \"data types [C++], equivalents\"\n  - \"sign-extending integral types\"\n  - \"zero-extending\"\n  - \"identifiers, data type\"\n  - \"data types [C++], specifiers\"\n  - \"simple types, names\"\n  - \"type names [C++], simple\"\nms.assetid: 0d4b515a-4f68-4786-83cf-a5d43c7cb6f3\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Data Type Specifiers and Equivalents\nThis book generally uses the forms of the type specifiers listed in the following table rather than the long forms, and it assumes that the `char` type is signed by default. Therefore, throughout this book, `char` is equivalent to **signed char**.  \n  \n### Type Specifiers and Equivalents  \n  \n|Type Specifier|Equivalent(s)|  \n|--------------------|---------------------|  \n|**signed char**1|`char`|  \n|**signed int**|**signed**, `int`|  \n|**signed short int**|**short**, `signed short`|  \n|**signed long int**|**long**, **signed long**|  \n|`unsigned char`|—|  \n|`unsigned int`|`unsigned`|  \n|**unsigned short int**|**unsigned short**|  \n|**unsigned long int**|`unsigned long`|  \n|**float**|—|  \n|`long double`2|—|  \n  \n 1   When you make the `char` type unsigned by default (by specifying the /J compiler option), you cannot abbreviate **signed char** as `char`.  \n  \n 2   In 32-bit operating systems, the Microsoft C compiler maps **long double** to type **double**.  \n  \n **Microsoft Specific**  \n  \n You can specify the /J compiler option to change the default `char` type from signed to unsigned. When this option is in effect, `char` means the same as `unsigned char`, and you must use the **signed** keyword to declare a signed character value. If a `char` value is explicitly declared signed, the /J option does not affect it, and the value is sign-extended when widened to an `int` type. The `char` type is zero-extended when widened to `int` type.  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [C Type Specifiers](../c-language/c-type-specifiers.md)"}