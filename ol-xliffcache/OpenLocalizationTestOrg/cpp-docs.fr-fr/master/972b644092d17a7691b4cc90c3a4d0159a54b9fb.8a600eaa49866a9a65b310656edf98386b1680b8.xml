{"nodes":[{"pos":[12,48],"content":"packaged_task Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"packaged_task Class | Microsoft Docs","pos":[0,36]}]},{"pos":[574,593],"content":"packaged_task Class","linkify":"packaged_task Class","nodes":[{"content":"packaged_task Class","pos":[0,19]}]},{"content":"Describes an <bpt id=\"p1\">*</bpt>asynchronous provider<ept id=\"p1\">*</ept> that is a call wrapper whose call signature is <ph id=\"ph1\">`Ty(ArgTypes...)`</ph>.","pos":[594,696],"source":"Describes an *asynchronous provider* that is a call wrapper whose call signature is `Ty(ArgTypes...)`."},{"content":"Its <bpt id=\"p1\">*</bpt>associated asynchronous state<ept id=\"p1\">*</ept> holds a copy of its callable object in addition to the potential result.","pos":[697,805],"source":" Its *associated asynchronous state* holds a copy of its callable object in addition to the potential result."},{"pos":[814,820],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[880,887],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"pos":[897,916],"content":"Public Constructors","linkify":"Public Constructors","nodes":[{"content":"Public Constructors","pos":[0,19]}]},{"content":"Name","pos":[923,927]},{"content":"Description","pos":[928,939]},{"pos":[977,1062],"content":"<bpt id=\"p1\">[</bpt>packaged_task::packaged_task Constructor<ept id=\"p1\">](#packaged_task__packaged_task_constructor)</ept>","source":"[packaged_task::packaged_task Constructor](#packaged_task__packaged_task_constructor)"},{"pos":[1063,1099],"content":"Constructs a <ph id=\"ph1\">`packaged_task`</ph> object.","source":"Constructs a `packaged_task` object."},{"pos":[1104,1193],"content":"<bpt id=\"p1\">[</bpt>packaged_task::~packaged_task Destructor<ept id=\"p1\">](#packaged_task___dtorpackaged_task_destructor)</ept>","source":"[packaged_task::~packaged_task Destructor](#packaged_task___dtorpackaged_task_destructor)"},{"pos":[1194,1228],"content":"Destroys a <ph id=\"ph1\">`packaged_task`</ph> object.","source":"Destroys a `packaged_task` object."},{"pos":[1239,1253],"content":"Public Methods","linkify":"Public Methods","nodes":[{"content":"Public Methods","pos":[0,14]}]},{"content":"Name","pos":[1260,1264]},{"content":"Description","pos":[1265,1276]},{"pos":[1314,1376],"content":"<bpt id=\"p1\">[</bpt>packaged_task::get_future<ept id=\"p1\">](#packaged_task__get_future_method)</ept>","source":"[packaged_task::get_future](#packaged_task__get_future_method)"},{"pos":[1377,1488],"content":"Returns a <bpt id=\"p1\">[</bpt>future<ept id=\"p1\">](../standard-library/future-class.md)</ept> object that has the same associated asynchronous state.","source":"Returns a [future](../standard-library/future-class.md) object that has the same associated asynchronous state."},{"pos":[1493,1585],"content":"<bpt id=\"p1\">[</bpt>packaged_task::make_ready_at_thread_exit<ept id=\"p1\">](#packaged_task__make_ready_at_thread_exit_method)</ept>","source":"[packaged_task::make_ready_at_thread_exit](#packaged_task__make_ready_at_thread_exit_method)"},{"content":"Calls the callable object that's stored in the associated asynchronous state and atomically stores the returned value.","pos":[1586,1704]},{"pos":[1709,1761],"content":"<bpt id=\"p1\">[</bpt>packaged_task::reset<ept id=\"p1\">](#packaged_task__reset_method)</ept>","source":"[packaged_task::reset](#packaged_task__reset_method)"},{"content":"Replaces the associated asynchronous state.","pos":[1762,1805]},{"pos":[1810,1860],"content":"<bpt id=\"p1\">[</bpt>packaged_task::swap<ept id=\"p1\">](#packaged_task__swap_method)</ept>","source":"[packaged_task::swap](#packaged_task__swap_method)"},{"content":"Exchanges the associated asynchronous state with that of a specified object.","pos":[1861,1937]},{"pos":[1942,1994],"content":"<bpt id=\"p1\">[</bpt>packaged_task::valid<ept id=\"p1\">](#packaged_task__valid_method)</ept>","source":"[packaged_task::valid](#packaged_task__valid_method)"},{"content":"Specifies whether the object has an associated asynchronous state.","pos":[1995,2061]},{"pos":[2072,2088],"content":"Public Operators","linkify":"Public Operators","nodes":[{"content":"Public Operators","pos":[0,16]}]},{"content":"Name","pos":[2095,2099]},{"content":"Description","pos":[2100,2111]},{"pos":[2149,2204],"content":"<bpt id=\"p1\">[</bpt>packaged_task::operator=<ept id=\"p1\">](#packaged_task__operator_eq)</ept>","source":"[packaged_task::operator=](#packaged_task__operator_eq)"},{"content":"Transfers an associated asynchronous state from a specified object.","pos":[2205,2272]},{"pos":[2277,2332],"content":"<bpt id=\"p1\">[</bpt>packaged_task::operator()<ept id=\"p1\">](#packaged_task__operator__)</ept>","source":"[packaged_task::operator()](#packaged_task__operator__)"},{"pos":[2333,2479],"content":"Calls the callable object that's stored in the associated asynchronous state, atomically stores the returned value, and sets the state to <bpt id=\"p1\">*</bpt>ready<ept id=\"p1\">*</ept>.","source":"Calls the callable object that's stored in the associated asynchronous state, atomically stores the returned value, and sets the state to *ready*."},{"pos":[2484,2545],"content":"<bpt id=\"p1\">[</bpt>packaged_task::operator bool<ept id=\"p1\">](#packaged_task__operator_bool)</ept>","source":"[packaged_task::operator bool](#packaged_task__operator_bool)"},{"content":"Specifies whether the object has an associated asynchronous state.","pos":[2546,2612]},{"pos":[2622,2634],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[2638,2656],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> future","source":"**Header:** future"},{"pos":[2663,2681],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[2691,2765],"content":"<bpt id=\"p1\">&lt;a name=\"packaged_task__get_future_method\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  packaged_task::get_future","linkify":"<a name=\"packaged_task__get_future_method\"></a>  packaged_task::get_future","source":"<a name=\"packaged_task__get_future_method\"></a>  packaged_task::get_future"},{"pos":[2769,2858],"content":"Returns an object of type <ph id=\"ph1\">`future&lt;Ty&gt;`</ph> that has the same <bpt id=\"p1\">*</bpt>associated asynchronous state<ept id=\"p1\">*</ept>.","source":"Returns an object of type `future<Ty>` that has the same *associated asynchronous state*."},{"pos":[2909,2916],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[2920,3114],"content":"If the <ph id=\"ph1\">`packaged_task`</ph> object does not have an associated asynchronous state, this method throws a <bpt id=\"p1\">[</bpt>future_error<ept id=\"p1\">](../standard-library/future-error-class.md)</ept> that has an error code of <ph id=\"ph2\">`no_state`</ph>.","source":"If the `packaged_task` object does not have an associated asynchronous state, this method throws a [future_error](../standard-library/future-error-class.md) that has an error code of `no_state`."},{"pos":[3121,3326],"content":"If this method has already been called for a <ph id=\"ph1\">`packaged_task`</ph> object that has the same associated asynchronous state, the method throws a <ph id=\"ph2\">`future_error`</ph> that has an error code of <ph id=\"ph3\">`future_already_retrieved`</ph>.","source":"If this method has already been called for a `packaged_task` object that has the same associated asynchronous state, the method throws a `future_error` that has an error code of `future_already_retrieved`."},{"pos":[3336,3440],"content":"<bpt id=\"p1\">&lt;a name=\"packaged_task__make_ready_at_thread_exit_method\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  packaged_task::make_ready_at_thread_exit","linkify":"<a name=\"packaged_task__make_ready_at_thread_exit_method\"></a>  packaged_task::make_ready_at_thread_exit","source":"<a name=\"packaged_task__make_ready_at_thread_exit_method\"></a>  packaged_task::make_ready_at_thread_exit"},{"pos":[3444,3564],"content":"Calls the callable object that's stored in the <bpt id=\"p1\">*</bpt>associated asynchronous state<ept id=\"p1\">*</ept> and atomically stores the returned value.","source":"Calls the callable object that's stored in the *associated asynchronous state* and atomically stores the returned value."},{"pos":[3640,3647],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[3651,3844],"content":"If the <ph id=\"ph1\">`packaged_task`</ph> object doesn't have an associated asynchronous state, this method throws a <bpt id=\"p1\">[</bpt>future_error<ept id=\"p1\">](../standard-library/future-error-class.md)</ept> that has an error code of <ph id=\"ph2\">`no_state`</ph>.","source":"If the `packaged_task` object doesn't have an associated asynchronous state, this method throws a [future_error](../standard-library/future-error-class.md) that has an error code of `no_state`."},{"pos":[3851,4138],"content":"If this method or <bpt id=\"p1\">[</bpt>make_ready_at_thread_exit<ept id=\"p1\">](#packaged_task__make_ready_at_thread_exit_method)</ept> has already been called for a <ph id=\"ph1\">`packaged_task`</ph> object that has the same associated asynchronous state, the method throws a <ph id=\"ph2\">`future_error`</ph> that has an error code of <ph id=\"ph3\">`promise_already_satisfied`</ph>.","source":"If this method or [make_ready_at_thread_exit](#packaged_task__make_ready_at_thread_exit_method) has already been called for a `packaged_task` object that has the same associated asynchronous state, the method throws a `future_error` that has an error code of `promise_already_satisfied`."},{"content":"Otherwise, this operator calls <ph id=\"ph1\">`INVOKE(fn, args..., Ty)`</ph>, where <bpt id=\"p1\">*</bpt>fn<ept id=\"p1\">*</ept> is the callable object that's stored in the associated asynchronous state.","pos":[4145,4288],"source":"Otherwise, this operator calls `INVOKE(fn, args..., Ty)`, where *fn* is the callable object that's stored in the associated asynchronous state."},{"content":"Any returned value is stored atomically as the returned result of the associated asynchronous state.","pos":[4289,4389]},{"content":"In contrast to <bpt id=\"p1\">[</bpt>packaged_task::operator()<ept id=\"p1\">](#packaged_task__operator__)</ept>, the associated asynchronous state is not set to <ph id=\"ph1\">`ready`</ph> until after all thread-local objects in the calling thread have been destroyed.","pos":[4396,4603],"source":"In contrast to [packaged_task::operator()](#packaged_task__operator__), the associated asynchronous state is not set to `ready` until after all thread-local objects in the calling thread have been destroyed."},{"content":"Typically, threads that are blocked on the associated asynchronous state are not unblocked until the calling thread exits.","pos":[4604,4726]},{"pos":[4736,4803],"content":"<bpt id=\"p1\">&lt;a name=\"packaged_task__operator_eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  packaged_task::operator=","linkify":"<a name=\"packaged_task__operator_eq\"></a>  packaged_task::operator=","source":"<a name=\"packaged_task__operator_eq\"></a>  packaged_task::operator="},{"pos":[4807,4877],"content":"Transfers the <bpt id=\"p1\">*</bpt>associated asynchronous state<ept id=\"p1\">*</ept> from a specified object.","source":"Transfers the *associated asynchronous state* from a specified object."},{"pos":[4952,4962],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A <ph id=\"ph1\">`packaged_task`</ph> object.","pos":[4977,5002],"source":" A `packaged_task` object."},{"pos":[5012,5024],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[5045,5052],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5056,5132],"content":"After the operation, <ph id=\"ph1\">`Right`</ph> no longer has an associated asynchronous state.","source":"After the operation, `Right` no longer has an associated asynchronous state."},{"pos":[5142,5209],"content":"<bpt id=\"p1\">&lt;a name=\"packaged_task__operator__\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  packaged_task::operator()","linkify":"<a name=\"packaged_task__operator__\"></a>  packaged_task::operator()","source":"<a name=\"packaged_task__operator__\"></a>  packaged_task::operator()"},{"pos":[5213,5361],"content":"Calls the callable object that's stored in the <bpt id=\"p1\">*</bpt>associated asynchronous state<ept id=\"p1\">*</ept>, atomically stores the returned value, and sets the state to <bpt id=\"p2\">*</bpt>ready<ept id=\"p2\">*</ept>.","source":"Calls the callable object that's stored in the *associated asynchronous state*, atomically stores the returned value, and sets the state to *ready*."},{"pos":[5422,5429],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5433,5626],"content":"If the <ph id=\"ph1\">`packaged_task`</ph> object doesn't have an associated asynchronous state, this method throws a <bpt id=\"p1\">[</bpt>future_error<ept id=\"p1\">](../standard-library/future-error-class.md)</ept> that has an error code of <ph id=\"ph2\">`no_state`</ph>.","source":"If the `packaged_task` object doesn't have an associated asynchronous state, this method throws a [future_error](../standard-library/future-error-class.md) that has an error code of `no_state`."},{"pos":[5633,5920],"content":"If this method or <bpt id=\"p1\">[</bpt>make_ready_at_thread_exit<ept id=\"p1\">](#packaged_task__make_ready_at_thread_exit_method)</ept> has already been called for a <ph id=\"ph1\">`packaged_task`</ph> object that has the same associated asynchronous state, the method throws a <ph id=\"ph2\">`future_error`</ph> that has an error code of <ph id=\"ph3\">`promise_already_satisfied`</ph>.","source":"If this method or [make_ready_at_thread_exit](#packaged_task__make_ready_at_thread_exit_method) has already been called for a `packaged_task` object that has the same associated asynchronous state, the method throws a `future_error` that has an error code of `promise_already_satisfied`."},{"content":"Otherwise, this operator calls <ph id=\"ph1\">`INVOKE(fn, args..., Ty)`</ph>, where <bpt id=\"p1\">*</bpt>fn<ept id=\"p1\">*</ept> is the callable object that's stored in the associated asynchronous state.","pos":[5927,6070],"source":"Otherwise, this operator calls `INVOKE(fn, args..., Ty)`, where *fn* is the callable object that's stored in the associated asynchronous state."},{"content":"Any returned value is stored atomically as the returned result of the associated asynchronous state, and the state is set to ready.","pos":[6071,6202]},{"content":"As a result, any threads that are blocked on the associated asynchronous state become unblocked.","pos":[6203,6299]},{"pos":[6309,6382],"content":"<bpt id=\"p1\">&lt;a name=\"packaged_task__operator_bool\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  packaged_task::operator bool","linkify":"<a name=\"packaged_task__operator_bool\"></a>  packaged_task::operator bool","source":"<a name=\"packaged_task__operator_bool\"></a>  packaged_task::operator bool"},{"pos":[6386,6454],"content":"Specifies whether the object has an <ph id=\"ph1\">`associated asynchronous state`</ph>.","source":"Specifies whether the object has an `associated asynchronous state`."},{"pos":[6509,6521],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[6525,6603],"content":"<ph id=\"ph1\">`true`</ph> if the object has an associated asynchronous state; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the object has an associated asynchronous state; otherwise, `false`."},{"pos":[6613,6710],"content":"<bpt id=\"p1\">&lt;a name=\"packaged_task__packaged_task_constructor\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  packaged_task::packaged_task Constructor","linkify":"<a name=\"packaged_task__packaged_task_constructor\"></a>  packaged_task::packaged_task Constructor","source":"<a name=\"packaged_task__packaged_task_constructor\"></a>  packaged_task::packaged_task Constructor"},{"pos":[6714,6750],"content":"Constructs a <ph id=\"ph1\">`packaged_task`</ph> object.","source":"Constructs a `packaged_task` object."},{"pos":[7010,7020],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A <ph id=\"ph1\">`packaged_task`</ph> object.","pos":[7035,7060],"source":" A `packaged_task` object."},{"content":"A memory allocator.","pos":[7078,7097]},{"content":"For more information, see <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>allocators&gt;<ept id=\"p1\">](../standard-library/allocators-header.md)</ept>.","pos":[7098,7182],"source":" For more information, see [\\<allocators>](../standard-library/allocators-header.md)."},{"content":"A function object.","pos":[7197,7215]},{"pos":[7225,7232],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[7236,7338],"content":"The first constructor constructs a <ph id=\"ph1\">`packaged_task`</ph> object that has no <bpt id=\"p1\">*</bpt>associated asynchronous state<ept id=\"p1\">*</ept>.","source":"The first constructor constructs a `packaged_task` object that has no *associated asynchronous state*."},{"content":"The second constructor constructs a <ph id=\"ph1\">`packaged_task`</ph> object and transfers the associated asynchronous state from <ph id=\"ph2\">`Right`</ph>.","pos":[7345,7465],"source":"The second constructor constructs a `packaged_task` object and transfers the associated asynchronous state from `Right`."},{"content":"After the operation, <ph id=\"ph1\">`Right`</ph> no longer has an associated asynchronous state.","pos":[7466,7542],"source":" After the operation, `Right` no longer has an associated asynchronous state."},{"pos":[7549,7675],"content":"The third constructor constructs a <ph id=\"ph1\">`packaged_task`</ph> object that has a copy of <ph id=\"ph2\">`fn`</ph> stored in its associated asynchronous state.","source":"The third constructor constructs a `packaged_task` object that has a copy of `fn` stored in its associated asynchronous state."},{"pos":[7682,7849],"content":"The fourth constructor constructs a <ph id=\"ph1\">`packaged_task`</ph> object that has a copy of <ph id=\"ph2\">`fn`</ph> stored in its associated asynchronous state, and uses <ph id=\"ph3\">`alloc`</ph> for memory allocation.","source":"The fourth constructor constructs a `packaged_task` object that has a copy of `fn` stored in its associated asynchronous state, and uses `alloc` for memory allocation."},{"pos":[7859,7960],"content":"<bpt id=\"p1\">&lt;a name=\"packaged_task___dtorpackaged_task_destructor\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  packaged_task::~packaged_task Destructor","linkify":"<a name=\"packaged_task___dtorpackaged_task_destructor\"></a>  packaged_task::~packaged_task Destructor","source":"<a name=\"packaged_task___dtorpackaged_task_destructor\"></a>  packaged_task::~packaged_task Destructor"},{"pos":[7964,7998],"content":"Destroys a <ph id=\"ph1\">`packaged_task`</ph> object.","source":"Destroys a `packaged_task` object."},{"pos":[8039,8046],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[8050,8379],"content":"If the <bpt id=\"p1\">*</bpt>associated asynchronous state<ept id=\"p1\">*</ept> is not <bpt id=\"p2\">*</bpt>ready<ept id=\"p2\">*</ept>, the destructor stores a <bpt id=\"p3\">[</bpt>future_error<ept id=\"p3\">](../standard-library/future-error-class.md)</ept> exception that has an error code of <ph id=\"ph1\">`broken_promise`</ph> as the result in the associated asynchronous state, and any threads that are blocked on the associated asynchronous state become unblocked.","source":"If the *associated asynchronous state* is not *ready*, the destructor stores a [future_error](../standard-library/future-error-class.md) exception that has an error code of `broken_promise` as the result in the associated asynchronous state, and any threads that are blocked on the associated asynchronous state become unblocked."},{"pos":[8389,8453],"content":"<bpt id=\"p1\">&lt;a name=\"packaged_task__reset_method\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  packaged_task::reset","linkify":"<a name=\"packaged_task__reset_method\"></a>  packaged_task::reset","source":"<a name=\"packaged_task__reset_method\"></a>  packaged_task::reset"},{"pos":[8457,8554],"content":"Uses a new <bpt id=\"p1\">*</bpt>associated asynchronous state<ept id=\"p1\">*</ept> to replace the existing associated asynchronous state.","source":"Uses a new *associated asynchronous state* to replace the existing associated asynchronous state."},{"pos":[8591,8598],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"In effect, this method executes <ph id=\"ph1\">`*this = packaged_task(move(fn))`</ph>, where <bpt id=\"p1\">*</bpt>fn<ept id=\"p1\">*</ept> is the function object that's stored in the associated asynchronous state for this object.","pos":[8602,8770],"source":"In effect, this method executes `*this = packaged_task(move(fn))`, where *fn* is the function object that's stored in the associated asynchronous state for this object."},{"content":"Therefore, the state of the object is cleared, and <bpt id=\"p1\">[</bpt>get_future<ept id=\"p1\">](#packaged_task__get_future_method)</ept>, <bpt id=\"p2\">[</bpt>operator()<ept id=\"p2\">](#packaged_task__operator__)</ept>, and <bpt id=\"p3\">[</bpt>make_ready_at_thread_exit<ept id=\"p3\">](#packaged_task__make_ready_at_thread_exit_method)</ept> can be called as if on a newly-constructed object.","pos":[8771,9045],"source":" Therefore, the state of the object is cleared, and [get_future](#packaged_task__get_future_method), [operator()](#packaged_task__operator__), and [make_ready_at_thread_exit](#packaged_task__make_ready_at_thread_exit_method) can be called as if on a newly-constructed object."},{"pos":[9055,9117],"content":"<bpt id=\"p1\">&lt;a name=\"packaged_task__swap_method\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  packaged_task::swap","linkify":"<a name=\"packaged_task__swap_method\"></a>  packaged_task::swap","source":"<a name=\"packaged_task__swap_method\"></a>  packaged_task::swap"},{"content":"Exchanges the associated asynchronous state with that of a specified object.","pos":[9121,9197]},{"pos":[9262,9272],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A <ph id=\"ph1\">`packaged_task`</ph> object.","pos":[9287,9312],"source":" A `packaged_task` object."},{"pos":[9322,9386],"content":"<bpt id=\"p1\">&lt;a name=\"packaged_task__valid_method\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  packaged_task::valid","linkify":"<a name=\"packaged_task__valid_method\"></a>  packaged_task::valid","source":"<a name=\"packaged_task__valid_method\"></a>  packaged_task::valid"},{"pos":[9390,9458],"content":"Specifies whether the object has an <ph id=\"ph1\">`associated asynchronous state`</ph>.","source":"Specifies whether the object has an `associated asynchronous state`."},{"pos":[9501,9513],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[9517,9595],"content":"<ph id=\"ph1\">`true`</ph> if the object has an associated asynchronous state; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the object has an associated asynchronous state; otherwise, `false`."},{"pos":[9604,9612],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Header Files Reference<ept id=\"p1\">](../standard-library/cpp-standard-library-header-files.md)</ept><ph id=\"ph1\"> </ph>","pos":[9616,9699],"source":"[Header Files Reference](../standard-library/cpp-standard-library-header-files.md) "},{"content":"<bpt id=\"p1\"> [</bpt><ph id=\"ph1\">\\&lt;</ph>future&gt;<ept id=\"p1\">](../standard-library/future.md)</ept>","pos":[9702,9745],"source":" [\\<future>](../standard-library/future.md)"}],"content":"---\ntitle: \"packaged_task Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"future/std::packaged_task\"\ndev_langs: \n  - \"C++\"\nms.assetid: 0a72cbe3-f22a-4bfe-8e50-dcb268c98780\ncaps.latest.revision: 9\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# packaged_task Class\nDescribes an *asynchronous provider* that is a call wrapper whose call signature is `Ty(ArgTypes...)`. Its *associated asynchronous state* holds a copy of its callable object in addition to the potential result.  \n  \n## Syntax  \n  \n```\ntemplate <class>\nclass packaged_task;\n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[packaged_task::packaged_task Constructor](#packaged_task__packaged_task_constructor)|Constructs a `packaged_task` object.|  \n|[packaged_task::~packaged_task Destructor](#packaged_task___dtorpackaged_task_destructor)|Destroys a `packaged_task` object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[packaged_task::get_future](#packaged_task__get_future_method)|Returns a [future](../standard-library/future-class.md) object that has the same associated asynchronous state.|  \n|[packaged_task::make_ready_at_thread_exit](#packaged_task__make_ready_at_thread_exit_method)|Calls the callable object that's stored in the associated asynchronous state and atomically stores the returned value.|  \n|[packaged_task::reset](#packaged_task__reset_method)|Replaces the associated asynchronous state.|  \n|[packaged_task::swap](#packaged_task__swap_method)|Exchanges the associated asynchronous state with that of a specified object.|  \n|[packaged_task::valid](#packaged_task__valid_method)|Specifies whether the object has an associated asynchronous state.|  \n  \n### Public Operators  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[packaged_task::operator=](#packaged_task__operator_eq)|Transfers an associated asynchronous state from a specified object.|  \n|[packaged_task::operator()](#packaged_task__operator__)|Calls the callable object that's stored in the associated asynchronous state, atomically stores the returned value, and sets the state to *ready*.|  \n|[packaged_task::operator bool](#packaged_task__operator_bool)|Specifies whether the object has an associated asynchronous state.|  \n  \n## Requirements  \n **Header:** future  \n  \n **Namespace:** std  \n  \n##  <a name=\"packaged_task__get_future_method\"></a>  packaged_task::get_future  \n Returns an object of type `future<Ty>` that has the same *associated asynchronous state*.  \n  \n```cpp\nfuture<Ty> get_future();\n```  \n  \n### Remarks  \n If the `packaged_task` object does not have an associated asynchronous state, this method throws a [future_error](../standard-library/future-error-class.md) that has an error code of `no_state`.  \n  \n If this method has already been called for a `packaged_task` object that has the same associated asynchronous state, the method throws a `future_error` that has an error code of `future_already_retrieved`.  \n  \n##  <a name=\"packaged_task__make_ready_at_thread_exit_method\"></a>  packaged_task::make_ready_at_thread_exit  \n Calls the callable object that's stored in the *associated asynchronous state* and atomically stores the returned value.  \n  \n```cpp\nvoid make_ready_at_thread_exit(ArgTypes... args);\n```  \n  \n### Remarks  \n If the `packaged_task` object doesn't have an associated asynchronous state, this method throws a [future_error](../standard-library/future-error-class.md) that has an error code of `no_state`.  \n  \n If this method or [make_ready_at_thread_exit](#packaged_task__make_ready_at_thread_exit_method) has already been called for a `packaged_task` object that has the same associated asynchronous state, the method throws a `future_error` that has an error code of `promise_already_satisfied`.  \n  \n Otherwise, this operator calls `INVOKE(fn, args..., Ty)`, where *fn* is the callable object that's stored in the associated asynchronous state. Any returned value is stored atomically as the returned result of the associated asynchronous state.  \n  \n In contrast to [packaged_task::operator()](#packaged_task__operator__), the associated asynchronous state is not set to `ready` until after all thread-local objects in the calling thread have been destroyed. Typically, threads that are blocked on the associated asynchronous state are not unblocked until the calling thread exits.  \n  \n##  <a name=\"packaged_task__operator_eq\"></a>  packaged_task::operator=  \n Transfers the *associated asynchronous state* from a specified object.  \n  \n```cpp\npackaged_task& operator=(packaged_task&& Right);\n```  \n  \n### Parameters  \n `Right`  \n A `packaged_task` object.  \n  \n### Return Value  \n `*this`  \n  \n### Remarks  \n After the operation, `Right` no longer has an associated asynchronous state.  \n  \n##  <a name=\"packaged_task__operator__\"></a>  packaged_task::operator()  \n Calls the callable object that's stored in the *associated asynchronous state*, atomically stores the returned value, and sets the state to *ready*.  \n  \n```cpp\nvoid operator()(ArgTypes... args);\n```  \n  \n### Remarks  \n If the `packaged_task` object doesn't have an associated asynchronous state, this method throws a [future_error](../standard-library/future-error-class.md) that has an error code of `no_state`.  \n  \n If this method or [make_ready_at_thread_exit](#packaged_task__make_ready_at_thread_exit_method) has already been called for a `packaged_task` object that has the same associated asynchronous state, the method throws a `future_error` that has an error code of `promise_already_satisfied`.  \n  \n Otherwise, this operator calls `INVOKE(fn, args..., Ty)`, where *fn* is the callable object that's stored in the associated asynchronous state. Any returned value is stored atomically as the returned result of the associated asynchronous state, and the state is set to ready. As a result, any threads that are blocked on the associated asynchronous state become unblocked.  \n  \n##  <a name=\"packaged_task__operator_bool\"></a>  packaged_task::operator bool  \n Specifies whether the object has an `associated asynchronous state`.  \n  \n```\noperator bool() const noexcept;\n```  \n  \n### Return Value  \n `true` if the object has an associated asynchronous state; otherwise, `false`.  \n  \n##  <a name=\"packaged_task__packaged_task_constructor\"></a>  packaged_task::packaged_task Constructor  \n Constructs a `packaged_task` object.  \n  \n```cpp\npackaged_task() noexcept;\npackaged_task(packaged_task&& Right) noexcept;\ntemplate <class Fn>\nexplicit packaged_task(Fn&& fn);\n\ntemplate <class Fn, class Alloc>\nexplicit packaged_task(allocator_arg_t,\n    const Alloc& alloc, Fn&& fn);\n```  \n  \n### Parameters  \n `Right`  \n A `packaged_task` object.  \n  \n `alloc`  \n A memory allocator. For more information, see [\\<allocators>](../standard-library/allocators-header.md).  \n  \n `fn`  \n A function object.  \n  \n### Remarks  \n The first constructor constructs a `packaged_task` object that has no *associated asynchronous state*.  \n  \n The second constructor constructs a `packaged_task` object and transfers the associated asynchronous state from `Right`. After the operation, `Right` no longer has an associated asynchronous state.  \n  \n The third constructor constructs a `packaged_task` object that has a copy of `fn` stored in its associated asynchronous state.  \n  \n The fourth constructor constructs a `packaged_task` object that has a copy of `fn` stored in its associated asynchronous state, and uses `alloc` for memory allocation.  \n  \n##  <a name=\"packaged_task___dtorpackaged_task_destructor\"></a>  packaged_task::~packaged_task Destructor  \n Destroys a `packaged_task` object.  \n  \n```\n~packaged_task();\n```  \n  \n### Remarks  \n If the *associated asynchronous state* is not *ready*, the destructor stores a [future_error](../standard-library/future-error-class.md) exception that has an error code of `broken_promise` as the result in the associated asynchronous state, and any threads that are blocked on the associated asynchronous state become unblocked.  \n  \n##  <a name=\"packaged_task__reset_method\"></a>  packaged_task::reset  \n Uses a new *associated asynchronous state* to replace the existing associated asynchronous state.  \n  \n```\nvoid reset();\n```  \n  \n### Remarks  \n In effect, this method executes `*this = packaged_task(move(fn))`, where *fn* is the function object that's stored in the associated asynchronous state for this object. Therefore, the state of the object is cleared, and [get_future](#packaged_task__get_future_method), [operator()](#packaged_task__operator__), and [make_ready_at_thread_exit](#packaged_task__make_ready_at_thread_exit_method) can be called as if on a newly-constructed object.  \n  \n##  <a name=\"packaged_task__swap_method\"></a>  packaged_task::swap  \n Exchanges the associated asynchronous state with that of a specified object.  \n  \n```\nvoid swap(packaged_task& Right) noexcept;\n```  \n  \n### Parameters  \n `Right`  \n A `packaged_task` object.  \n  \n##  <a name=\"packaged_task__valid_method\"></a>  packaged_task::valid  \n Specifies whether the object has an `associated asynchronous state`.  \n  \n```\nbool valid() const;\n```  \n  \n### Return Value  \n `true` if the object has an associated asynchronous state; otherwise, `false`.  \n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)   \n [\\<future>](../standard-library/future.md)\n\n\n\n"}