{"nodes":[{"pos":[12,62],"content":"va_arg, va_copy, va_end, va_start | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"va_arg, va_copy, va_end, va_start | Microsoft Docs","pos":[0,50]}]},{"pos":[1212,1245],"content":"va_arg, va_copy, va_end, va_start","linkify":"va_arg, va_copy, va_end, va_start","nodes":[{"content":"va_arg, va_copy, va_end, va_start","pos":[0,33]}]},{"content":"Accesses variable-argument lists.","pos":[1246,1279]},{"pos":[1288,1294],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1665,1675],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Type of argument to be retrieved.","pos":[1689,1722]},{"content":"Pointer to the list of arguments.","pos":[1742,1775]},{"content":"Pointer to the list of arguments to be initialized from <ph id=\"ph1\">`src`</ph>","pos":[1792,1853],"source":" Pointer to the list of arguments to be initialized from `src`"},{"content":"Pointer to the initialized list of arguments to copy to <ph id=\"ph1\">`dest`</ph>.","pos":[1869,1932],"source":" Pointer to the initialized list of arguments to copy to `dest`."},{"content":"Parameter that precedes the first optional argument.","pos":[1955,2007]},{"pos":[2016,2028],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"<ph id=\"ph1\">`va_arg`</ph> returns the current argument.","pos":[2032,2070],"source":"`va_arg` returns the current argument."},{"content":"<ph id=\"ph1\">`va_copy`</ph>, <ph id=\"ph2\">`va_start`</ph> and <ph id=\"ph3\">`va_end`</ph> do not return values.","pos":[2071,2127],"source":"`va_copy`, `va_start` and `va_end` do not return values."},{"pos":[2136,2143],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`va_arg`</ph>, <ph id=\"ph2\">`va_copy`</ph>, <ph id=\"ph3\">`va_end`</ph>, and <ph id=\"ph4\">`va_start`</ph> macros provide a portable way to access the arguments to a function when the function takes a variable number of arguments.","pos":[2147,2320],"source":"The `va_arg`, `va_copy`, `va_end`, and `va_start` macros provide a portable way to access the arguments to a function when the function takes a variable number of arguments."},{"content":"There are two versions of the macros: The macros defined in STDARG.H conform to the ISO C99 standard; the macros defined in VARARGS.H are deprecated but are retained for backward compatibility with code that was written before the ANSI C89 standard.","pos":[2321,2570]},{"content":"These macros assume that the function takes a fixed number of required arguments, followed by a variable number of optional arguments.","pos":[2577,2711]},{"content":"The required arguments are declared as ordinary parameters to the function and can be accessed through the parameter names.","pos":[2712,2835]},{"content":"The optional arguments are accessed through the macros in STDARG.H (or VARARGS.H for code that was written before the ANSI C89 standard), which sets a pointer to the first optional argument in the argument list, retrieves arguments from the list, and resets the pointer when argument processing is completed.","pos":[2836,3144]},{"content":"The C standard macros, defined in STDARG.H, are used as follows:","pos":[3151,3215]},{"content":"<ph id=\"ph1\">`va_start`</ph> sets <ph id=\"ph2\">`arg_ptr`</ph> to the first optional argument in the list of arguments that's passed to the function.","pos":[3225,3337],"source":"`va_start` sets `arg_ptr` to the first optional argument in the list of arguments that's passed to the function."},{"content":"The argument <ph id=\"ph1\">`arg_ptr`</ph> must have the <ph id=\"ph2\">`va_list`</ph> type.","pos":[3338,3390],"source":" The argument `arg_ptr` must have the `va_list` type."},{"content":"The argument <ph id=\"ph1\">`prev_param`</ph> is the name of the required parameter that immediately precedes the first optional argument in the argument list.","pos":[3391,3530],"source":" The argument `prev_param` is the name of the required parameter that immediately precedes the first optional argument in the argument list."},{"content":"If <ph id=\"ph1\">`prev_param`</ph> is declared with the register storage class, the macro's behavior is undefined.","pos":[3531,3626],"source":" If `prev_param` is declared with the register storage class, the macro's behavior is undefined."},{"content":"<ph id=\"ph1\">`va_start`</ph> must be used before <ph id=\"ph2\">`va_arg`</ph> is used for the first time.","pos":[3627,3694],"source":"`va_start` must be used before `va_arg` is used for the first time."},{"content":"<ph id=\"ph1\">`va_arg`</ph> retrieves a value of <ph id=\"ph2\">`type`</ph> from the location that's given by <ph id=\"ph3\">`arg_ptr`</ph>, and increments <ph id=\"ph4\">`arg_ptr`</ph> to point to the next argument in the list by using the size of <ph id=\"ph5\">`type`</ph> to determine where the next argument starts.","pos":[3704,3925],"source":"`va_arg` retrieves a value of `type` from the location that's given by `arg_ptr`, and increments `arg_ptr` to point to the next argument in the list by using the size of `type` to determine where the next argument starts."},{"content":"<ph id=\"ph1\">`va_arg`</ph> can be used any number of times in the function to retrieve arguments from the list.","pos":[3926,4019],"source":"`va_arg` can be used any number of times in the function to retrieve arguments from the list."},{"content":"<ph id=\"ph1\">`va_copy`</ph> makes a copy of a list of arguments in its current state.","pos":[4029,4096],"source":"`va_copy` makes a copy of a list of arguments in its current state."},{"content":"The <ph id=\"ph1\">`src`</ph> parameter must already be initialized with <ph id=\"ph2\">`va_start`</ph>; it may have been updated with <ph id=\"ph3\">`va_arg`</ph> calls, but must not have been reset with <ph id=\"ph4\">`va_end`</ph>.","pos":[4097,4251],"source":" The `src` parameter must already be initialized with `va_start`; it may have been updated with `va_arg` calls, but must not have been reset with `va_end`."},{"content":"The next argument that's retrieved by <ph id=\"ph1\">`va_arg`</ph> from <ph id=\"ph2\">`dest`</ph> is the same as the next argument that's retrieved from <ph id=\"ph3\">`src`</ph>.","pos":[4252,4372],"source":" The next argument that's retrieved by `va_arg` from `dest` is the same as the next argument that's retrieved from `src`."},{"content":"After all arguments have been retrieved, <ph id=\"ph1\">`va_end`</ph> resets the pointer to <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[4382,4463],"source":"After all arguments have been retrieved, `va_end` resets the pointer to **NULL**."},{"content":"<ph id=\"ph1\">`va_end`</ph> must be called on each argument list that's initialized with <ph id=\"ph2\">`va_start`</ph> or <ph id=\"ph3\">`va_copy`</ph> before the function returns.","pos":[4464,4586],"source":"`va_end` must be called on each argument list that's initialized with `va_start` or `va_copy` before the function returns."},{"pos":[4594,4799],"content":"[!NOTE]\n The macros in VARARGS.H are deprecated and are retained only for backwards compatibility with code that was written before the ANSI C89 standard. In all other cases, use the macros in STDARGS.H.","leadings":["","> "],"nodes":[{"content":" The macros in VARARGS.H are deprecated and are retained only for backwards compatibility with code that was written before the ANSI C89 standard. In all other cases, use the macros in STDARGS.H.","pos":[8,203],"nodes":[{"content":"The macros in VARARGS.H are deprecated and are retained only for backwards compatibility with code that was written before the ANSI C89 standard.","pos":[1,146]},{"content":"In all other cases, use the macros in STDARGS.H.","pos":[147,195]}]}]},{"content":"When they are compiled by using <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../../build/reference/clr-common-language-runtime-compilation.md)</ept>, programs that use these macros may generate unexpected results because of differences between native and common language runtime (CLR) type systems.","pos":[4806,5098],"source":"When they are compiled by using [/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md), programs that use these macros may generate unexpected results because of differences between native and common language runtime (CLR) type systems."},{"content":"Consider this program:","pos":[5099,5121]},{"content":"Notice that <ph id=\"ph1\">`testit`</ph> expects its second parameter to be either an <ph id=\"ph2\">`int`</ph> or a <ph id=\"ph3\">`char*`</ph>.","pos":[5636,5721],"source":"Notice that `testit` expects its second parameter to be either an `int` or a `char*`."},{"content":"The arguments being passed are 0xffffffff (an <ph id=\"ph1\">`unsigned int`</ph>, not an <ph id=\"ph2\">`int`</ph>) and <ph id=\"ph3\">`NULL`</ph> (actually an <ph id=\"ph4\">`int`</ph>, not a <ph id=\"ph5\">`char*`</ph>).","pos":[5722,5844],"source":" The arguments being passed are 0xffffffff (an `unsigned int`, not an `int`) and `NULL` (actually an `int`, not a `char*`)."},{"content":"When the program is compiled for native code, it produces this output:","pos":[5845,5915]},{"content":"However, when the program is compiled by using <bpt id=\"p1\">**</bpt>/clr:pure<ept id=\"p1\">**</ept>, the type mismatches cause it to generate an exception.","pos":[5960,6076],"source":"However, when the program is compiled by using **/clr:pure**, the type mismatches cause it to generate an exception."},{"content":"The solution is to use explicit casts:","pos":[6077,6115]},{"pos":[6275,6287],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[6291,6329],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>stdio.h&gt; and <ph id=\"ph2\">\\&lt;</ph>stdarg.h&gt;","source":"**Header:** \\<stdio.h> and \\<stdarg.h>"},{"pos":[6336,6371],"content":"<bpt id=\"p1\">**</bpt>Deprecated Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>varargs.h&gt;","source":"**Deprecated Header:** \\<varargs.h>"},{"pos":[6380,6389],"content":"Libraries","linkify":"Libraries","nodes":[{"content":"Libraries","pos":[0,9]}]},{"pos":[6393,6485],"content":"All versions of the <bpt id=\"p1\">[</bpt>C run-time libraries<ept id=\"p1\">](../../c-runtime-library/crt-library-features.md)</ept>.","source":"All versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md)."},{"pos":[6494,6501],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[8155,8161],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"pos":[8269,8294],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"pos":[8298,8407],"content":"<bpt id=\"p1\">[</bpt>System::ParamArrayAttribute Class<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/system.paramarrayattribute.aspx)</ept>","source":"[System::ParamArrayAttribute Class](https://msdn.microsoft.com/en-us/library/system.paramarrayattribute.aspx)"},{"pos":[8416,8424],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Argument Access<ept id=\"p1\">](../../c-runtime-library/argument-access.md)</ept><ph id=\"ph1\"> </ph>","pos":[8428,8490],"source":"[Argument Access](../../c-runtime-library/argument-access.md) "},{"content":"<bpt id=\"p1\"> [</bpt>vfprintf, _vfprintf_l, vfwprintf, _vfwprintf_l<ept id=\"p1\">](../../c-runtime-library/reference/vfprintf-vfprintf-l-vfwprintf-vfwprintf-l.md)</ept>","pos":[8493,8622],"source":" [vfprintf, _vfprintf_l, vfwprintf, _vfwprintf_l](../../c-runtime-library/reference/vfprintf-vfprintf-l-vfwprintf-vfwprintf-l.md)"}],"content":"---\ntitle: \"va_arg, va_copy, va_end, va_start | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"va_arg\"\n  - \"va_end\"\n  - \"va_copy\"\n  - \"va_start\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"va_arg\"\n  - \"va_start\"\n  - \"va_list\"\n  - \"va_alist\"\n  - \"va_dcl\"\n  - \"va_copy\"\n  - \"va_end\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"variable argument lists, accessing\"\n  - \"va_start macro\"\n  - \"va_arg macro\"\n  - \"va_end macro\"\n  - \"arguments [C++], argument lists\"\n  - \"va_list macro\"\n  - \"va_dcl macro\"\n  - \"va_alist macro\"\n  - \"va_copy macro\"\nms.assetid: a700dbbd-bfe5-4077-87b6-3a07af74a907\ncaps.latest.revision: 20\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# va_arg, va_copy, va_end, va_start\nAccesses variable-argument lists.  \n  \n## Syntax  \n  \n```  \n  \n      type va_arg(  \n   va_list arg_ptr,  \n   type   \n);void va_copy(  \n   va_list dest,  \n   va_list src  \n); // (ISO C99 and later)  \nvoid va_end(  \n   va_list arg_ptr   \n);  \nvoid va_start(  \n   va_list arg_ptr,  \n   prev_param   \n); // (ANSI C89 and later)  \nvoid va_start(  \n   arg_ptr   \n);  // (Pre-ANSI C89 standardization version)  \n```  \n  \n#### Parameters  \n `type`  \n Type of argument to be retrieved.  \n  \n `arg_ptr`  \n Pointer to the list of arguments.  \n  \n `dest`  \n Pointer to the list of arguments to be initialized from `src`  \n  \n `src`  \n Pointer to the initialized list of arguments to copy to `dest`.  \n  \n `prev_param`  \n Parameter that precedes the first optional argument.  \n  \n## Return Value  \n `va_arg` returns the current argument. `va_copy`, `va_start` and `va_end` do not return values.  \n  \n## Remarks  \n The `va_arg`, `va_copy`, `va_end`, and `va_start` macros provide a portable way to access the arguments to a function when the function takes a variable number of arguments. There are two versions of the macros: The macros defined in STDARG.H conform to the ISO C99 standard; the macros defined in VARARGS.H are deprecated but are retained for backward compatibility with code that was written before the ANSI C89 standard.  \n  \n These macros assume that the function takes a fixed number of required arguments, followed by a variable number of optional arguments. The required arguments are declared as ordinary parameters to the function and can be accessed through the parameter names. The optional arguments are accessed through the macros in STDARG.H (or VARARGS.H for code that was written before the ANSI C89 standard), which sets a pointer to the first optional argument in the argument list, retrieves arguments from the list, and resets the pointer when argument processing is completed.  \n  \n The C standard macros, defined in STDARG.H, are used as follows:  \n  \n-   `va_start` sets `arg_ptr` to the first optional argument in the list of arguments that's passed to the function. The argument `arg_ptr` must have the `va_list` type. The argument `prev_param` is the name of the required parameter that immediately precedes the first optional argument in the argument list. If `prev_param` is declared with the register storage class, the macro's behavior is undefined. `va_start` must be used before `va_arg` is used for the first time.  \n  \n-   `va_arg` retrieves a value of `type` from the location that's given by `arg_ptr`, and increments `arg_ptr` to point to the next argument in the list by using the size of `type` to determine where the next argument starts. `va_arg` can be used any number of times in the function to retrieve arguments from the list.  \n  \n-   `va_copy` makes a copy of a list of arguments in its current state. The `src` parameter must already be initialized with `va_start`; it may have been updated with `va_arg` calls, but must not have been reset with `va_end`. The next argument that's retrieved by `va_arg` from `dest` is the same as the next argument that's retrieved from `src`.  \n  \n-   After all arguments have been retrieved, `va_end` resets the pointer to **NULL**. `va_end` must be called on each argument list that's initialized with `va_start` or `va_copy` before the function returns.  \n  \n> [!NOTE]\n>  The macros in VARARGS.H are deprecated and are retained only for backwards compatibility with code that was written before the ANSI C89 standard. In all other cases, use the macros in STDARGS.H.  \n  \n When they are compiled by using [/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md), programs that use these macros may generate unexpected results because of differences between native and common language runtime (CLR) type systems. Consider this program:  \n  \n```  \n#include <stdio.h>  \n#include <stdarg.h>  \n  \nvoid testit (int i, ...)  \n{  \n    va_list argptr;  \n    va_start(argptr, i);  \n  \n    if (i == 0)  \n    {  \n        int n = va_arg(argptr, int);  \n        printf(\"%d\\n\", n);  \n    }  \n    else  \n    {  \n        char *s = va_arg(argptr, char*);  \n        printf(\"%s\\n\", s);  \n    }  \n}  \n  \nint main()  \n{  \n    testit(0, 0xFFFFFFFF); // 1st problem: 0xffffffff is not an int  \n    testit(1, NULL);       // 2nd problem: NULL is not a char*  \n}  \n```  \n  \n Notice that `testit` expects its second parameter to be either an `int` or a `char*`. The arguments being passed are 0xffffffff (an `unsigned int`, not an `int`) and `NULL` (actually an `int`, not a `char*`). When the program is compiled for native code, it produces this output:  \n  \n```Output  \n-1  \n  \n(null)  \n```  \n  \n However, when the program is compiled by using **/clr:pure**, the type mismatches cause it to generate an exception. The solution is to use explicit casts:  \n  \n```  \nint main()  \n{  \n   testit( 0, (int)0xFFFFFFFF ); // cast unsigned to int  \n   testit( 1, (char*)NULL );     // cast int to char*  \n}  \n```  \n  \n## Requirements  \n **Header:** \\<stdio.h> and \\<stdarg.h>  \n  \n **Deprecated Header:** \\<varargs.h>  \n  \n## Libraries  \n All versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md).  \n  \n## Example  \n  \n```  \n// crt_va.c  \n/* Compile with: cl /W3 /Tc crt_va.c  \n * The program below illustrates passing a variable  \n * number of arguments using the following macros:  \n *      va_start            va_arg              va_copy  \n *      va_end              va_list  \n */  \n  \n#include <stdio.h>  \n#include <stdarg.h>  \n#include <math.h>  \n  \ndouble deviation(int first, ...);  \n  \nint main( void )  \n{  \n    /* Call with 3 integers (-1 is used as terminator). */  \n    printf(\"Deviation is: %f\\n\", deviation(2, 3, 4, -1 ));  \n  \n    /* Call with 4 integers. */  \n    printf(\"Deviation is: %f\\n\", deviation(5, 7, 9, 11, -1));  \n  \n    /* Call with just -1 terminator. */  \n    printf(\"Deviation is: %f\\n\", deviation(-1));  \n}  \n  \n/* Returns the standard deviation of a variable list of integers. */  \ndouble deviation(int first, ...)  \n{  \n    int count = 0, i = first;  \n    double mean = 0.0, sum = 0.0;  \n    va_list marker;  \n    va_list copy;  \n  \n    va_start(marker, first);     /* Initialize variable arguments. */  \n    va_copy(copy, marker);       /* Copy list for the second pass */  \n    while (i != -1)  \n    {  \n        sum += i;  \n        count++;  \n        i = va_arg(marker, int);  \n    }  \n    va_end(marker);              /* Reset variable argument list. */  \n    mean = sum ? (sum / count) : 0.0;  \n  \n    i = first;                  /* reset to calculate deviation */  \n    sum = 0.0;  \n    while (i != -1)  \n    {  \n        sum += (i - mean)*(i - mean);  \n        i = va_arg(copy, int);  \n    }  \n    va_end(copy);               /* Reset copy of argument list. */  \n    return count ? sqrt(sum / count) : 0.0;  \n}  \n  \n```  \n  \n## Output  \n  \n```Output  \nDeviation is: 0.816497  \nDeviation is: 2.236068  \nDeviation is: 0.000000  \n  \n```  \n  \n## .NET Framework Equivalent  \n [System::ParamArrayAttribute Class](https://msdn.microsoft.com/en-us/library/system.paramarrayattribute.aspx)  \n  \n## See Also  \n [Argument Access](../../c-runtime-library/argument-access.md)   \n [vfprintf, _vfprintf_l, vfwprintf, _vfwprintf_l](../../c-runtime-library/reference/vfprintf-vfprintf-l-vfwprintf-vfwprintf-l.md)"}