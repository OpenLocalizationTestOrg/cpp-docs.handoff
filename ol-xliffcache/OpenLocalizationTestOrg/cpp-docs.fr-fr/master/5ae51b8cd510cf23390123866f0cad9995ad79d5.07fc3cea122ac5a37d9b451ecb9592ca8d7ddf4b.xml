{"nodes":[{"pos":[12,48],"content":"Diagnostic Services | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Diagnostic Services | Microsoft Docs","pos":[0,36]}]},{"content":"Diagnostic Services","pos":[1192,1211]},{"content":"The Microsoft Foundation Class Library supplies many diagnostic services that make debugging your programs easier.","pos":[1212,1326]},{"content":"These diagnostic services include macros and global functions that allow you to track your program's memory allocations, dump the contents of objects during run time, and print debugging messages during run time.","pos":[1327,1539]},{"content":"The macros and global functions for diagnostic services are grouped into the following categories:","pos":[1540,1638]},{"content":"General diagnostic macros","pos":[1648,1673]},{"content":"General diagnostic functions and variables","pos":[1683,1725]},{"content":"Object diagnostic functions","pos":[1735,1762]},{"content":"These macros and functions are available for all classes derived from <ph id=\"ph1\">`CObject`</ph> in the Debug and Release versions of MFC.","pos":[1769,1890],"source":"These macros and functions are available for all classes derived from `CObject` in the Debug and Release versions of MFC."},{"content":"However, all except <ph id=\"ph1\">`DEBUG_NEW`</ph> and <bpt id=\"p1\">**</bpt>VERIFY<ept id=\"p1\">**</ept> do nothing in the Release version.","pos":[1891,1972],"source":" However, all except `DEBUG_NEW` and **VERIFY** do nothing in the Release version."},{"content":"In the Debug library, all allocated memory blocks are bracketed with a series of \"guard bytes.\"","pos":[1979,2074]},{"content":"If these bytes are disturbed by an errant memory write, then the diagnostic routines can report a problem.","pos":[2075,2181]},{"content":"If you include the line:","pos":[2182,2206]},{"pos":[2224,2247],"content":"NVC_MFCCObjectSample#14"},{"content":"in your implementation file, all calls to <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> will store the filename and line number where the memory allocation took place.","pos":[2309,2438],"source":"in your implementation file, all calls to **new** will store the filename and line number where the memory allocation took place."},{"content":"The function <bpt id=\"p1\">[</bpt>CMemoryState::DumpAllObjectsSince<ept id=\"p1\">](cmemorystate-structure.md#cmemorystate__dumpallobjectssince)</ept> will display this extra information, allowing you to identify memory leaks.","pos":[2439,2624],"source":" The function [CMemoryState::DumpAllObjectsSince](cmemorystate-structure.md#cmemorystate__dumpallobjectssince) will display this extra information, allowing you to identify memory leaks."},{"content":"Refer also to the class <bpt id=\"p1\">[</bpt>CDumpContext<ept id=\"p1\">](../../mfc/reference/cdumpcontext-class.md)</ept> for additional information on diagnostic output.","pos":[2625,2755],"source":" Refer also to the class [CDumpContext](../../mfc/reference/cdumpcontext-class.md) for additional information on diagnostic output."},{"content":"In addition, the C run-time library also supports a set of diagnostic functions you can use to debug your applications.","pos":[2762,2881]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Debug Routines<ept id=\"p1\">](../../c-runtime-library/debug-routines.md)</ept> in the Run-Time Library Reference.","pos":[2882,3002],"source":" For more information, see [Debug Routines](../../c-runtime-library/debug-routines.md) in the Run-Time Library Reference."},{"content":"MFC General Diagnostic Macros","pos":[3012,3041]},{"pos":[3062,3080],"content":"<bpt id=\"p1\">[</bpt>ASSERT<ept id=\"p1\">](#assert)</ept>)","source":"[ASSERT](#assert))"},{"pos":[3081,3213],"content":"Prints a message and then aborts the program if the specified expression evaluates to <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept> in the Debug version of the library.","source":"Prints a message and then aborts the program if the specified expression evaluates to **FALSE** in the Debug version of the library."},{"content":"ASSERT_KINDOF","pos":[3219,3232]},{"content":"Tests that an object is an object of the specified class or of a class derived from the specified class.","pos":[3250,3354]},{"content":"ASSERT_VALID","pos":[3360,3372]},{"pos":[3389,3512],"content":"Tests the internal validity of an object by calling its <ph id=\"ph1\">`AssertValid`</ph> member function; typically overridden from <ph id=\"ph2\">`CObject`</ph>.","source":"Tests the internal validity of an object by calling its `AssertValid` member function; typically overridden from `CObject`."},{"content":"DEBUG_NEW","pos":[3518,3527]},{"content":"Supplies a filename and line number for all object allocations in Debug mode to help find memory leaks.","pos":[3541,3644]},{"content":"DEBUG_ONLY","pos":[3650,3660]},{"pos":[3675,3799],"content":"Similar to <bpt id=\"p1\">**</bpt>ASSERT<ept id=\"p1\">**</ept> but does not test the value of the expression; useful for code that should execute only in Debug mode.","source":"Similar to **ASSERT** but does not test the value of the expression; useful for code that should execute only in Debug mode."},{"content":"TRACE","pos":[3805,3810]},{"pos":[3820,3890],"content":"Provides <ph id=\"ph1\">`printf`</ph>-like capability in the Debug version of the library.","source":"Provides `printf`-like capability in the Debug version of the library."},{"content":"VERIFY","pos":[3896,3902]},{"pos":[3913,4034],"content":"Similar to <bpt id=\"p1\">**</bpt>ASSERT<ept id=\"p1\">**</ept> but evaluates the expression in the Release version of the library as well as in the Debug version.","source":"Similar to **ASSERT** but evaluates the expression in the Release version of the library as well as in the Debug version."},{"content":"MFC General Diagnostic Variables and Functions","pos":[4045,4091]},{"content":"afxDump","pos":[4113,4120]},{"pos":[4132,4284],"content":"Global variable that sends <bpt id=\"p1\">[</bpt>CDumpContext<ept id=\"p1\">](../../mfc/reference/cdumpcontext-class.md)</ept> information to the debugger output window or to the debug terminal.","source":"Global variable that sends [CDumpContext](../../mfc/reference/cdumpcontext-class.md) information to the debugger output window or to the debug terminal."},{"content":"afxMemDF","pos":[4290,4298]},{"content":"Global variable that controls the behavior of the debugging memory allocator.","pos":[4311,4388]},{"content":"AfxCheckError","pos":[4394,4407]},{"pos":[4425,4541],"content":"Global variable used to test the passed <bpt id=\"p1\">**</bpt>SCODE<ept id=\"p1\">**</ept> to see if it is an error and, if so, throws the appropriate error.","source":"Global variable used to test the passed **SCODE** to see if it is an error and, if so, throws the appropriate error."},{"content":"AfxCheckMemory","pos":[4547,4561]},{"content":"Checks the integrity of all currently allocated memory.","pos":[4580,4635]},{"content":"AfxDump","pos":[4641,4648]},{"content":"If called while in the debugger, dumps the state of an object while debugging.","pos":[4682,4760]},{"content":"AfxDumpStack","pos":[4766,4778]},{"content":"Generate an image of the current stack.","pos":[4795,4834]},{"content":"This function is always linked statically.","pos":[4835,4877]},{"content":"AfxEnableMemoryLeakDump","pos":[4883,4906]},{"content":"Enables the memory leak dump.","pos":[4934,4963]},{"content":"AfxEnableMemoryTracking","pos":[4969,4992]},{"content":"Turns memory tracking on and off.","pos":[5020,5053]},{"content":"AfxIsMemoryBlock","pos":[5059,5075]},{"content":"Verifies that a memory block has been properly allocated.","pos":[5096,5153]},{"content":"AfxIsValidAddress","pos":[5159,5176]},{"content":"Verifies that a memory address range is within the program's bounds.","pos":[5198,5266]},{"content":"AfxIsValidString","pos":[5272,5288]},{"content":"Determines whether a pointer to a string is valid.","pos":[5309,5359]},{"content":"AfxSetAllocHook","pos":[5365,5380]},{"content":"Enables the calling of a function on each memory allocation.","pos":[5400,5460]},{"content":"MFC Object Diagnostic Functions","pos":[5471,5502]},{"content":"AfxDoForAllClasses","pos":[5524,5542]},{"pos":[5565,5664],"content":"Performs a specified function on all <ph id=\"ph1\">`CObject`</ph>-derived classes that support run-time type checking.","source":"Performs a specified function on all `CObject`-derived classes that support run-time type checking."},{"content":"AfxDoForAllObjects","pos":[5670,5688]},{"pos":[5711,5807],"content":"Performs a specified function on all <ph id=\"ph1\">`CObject`</ph>-derived objects that were allocated with <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept>.","source":"Performs a specified function on all `CObject`-derived objects that were allocated with **new**."},{"pos":[5841,5847],"content":"ASSERT"},{"content":"Evaluates its argument.","pos":[5849,5872]},{"content":"Parameters","pos":[5927,5937]},{"content":"Specifies an expression (including pointer values) that evaluates to nonzero or 0.","pos":[5964,6046]},{"content":"Remarks","pos":[6056,6063]},{"content":"If the result is 0, the macro prints a diagnostic message and aborts the program.","pos":[6067,6148]},{"content":"If the condition is nonzero, it does nothing.","pos":[6149,6194]},{"content":"The diagnostic message has the form","pos":[6201,6236]},{"pos":[6297,6419],"content":"where <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> is the name of the source file, and <bpt id=\"p2\">*</bpt>num<ept id=\"p2\">*</ept> is the line number of the assertion that failed in the source file.","source":"where *name* is the name of the source file, and *num* is the line number of the assertion that failed in the source file."},{"content":"In the Release version of MFC, <bpt id=\"p1\">**</bpt>ASSERT<ept id=\"p1\">**</ept> does not evaluate the expression and thus will not interrupt the program.","pos":[6426,6541],"source":"In the Release version of MFC, **ASSERT** does not evaluate the expression and thus will not interrupt the program."},{"content":"If the expression must be evaluated regardless of environment, use the <bpt id=\"p1\">**</bpt>VERIFY<ept id=\"p1\">**</ept> macro in place of <bpt id=\"p2\">**</bpt>ASSERT<ept id=\"p2\">**</ept>.","pos":[6542,6653],"source":" If the expression must be evaluated regardless of environment, use the **VERIFY** macro in place of **ASSERT**."},{"pos":[6661,6732],"content":"[!NOTE]\n This function is available only in the Debug version of MFC.","leadings":["","> "],"nodes":[{"content":"This function is available only in the Debug version of MFC.","pos":[9,69]}]},{"content":"Example","pos":[6742,6749]},{"pos":[6764,6784],"content":"NVC_MFC_Utilities#44"},{"pos":[6879,6892],"content":"ASSERT_KINDOF"},{"content":"This macro asserts that the object pointed to is an object of the specified class, or is an object of a class derived from the specified class.","pos":[6896,7039]},{"content":"Parameters","pos":[7101,7111]},{"content":"classname","pos":[7116,7125]},{"content":"The name of a <ph id=\"ph1\">`CObject`</ph>-derived class.","pos":[7130,7168],"source":" The name of a `CObject`-derived class."},{"content":"pobject","pos":[7176,7183]},{"content":"A pointer to a class object.","pos":[7188,7216]},{"content":"Remarks","pos":[7226,7233]},{"content":"The <bpt id=\"p1\">*</bpt>pobject<ept id=\"p1\">*</ept> parameter should be a pointer to an object and can be <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept>.","pos":[7237,7315],"source":"The *pobject* parameter should be a pointer to an object and can be **const**."},{"content":"The object pointed to and the class must support <ph id=\"ph1\">`CObject`</ph> run-time class information.","pos":[7316,7402],"source":" The object pointed to and the class must support `CObject` run-time class information."},{"content":"As an example, to ensure that <ph id=\"ph1\">`pDocument`</ph> is a pointer to an object of the <ph id=\"ph2\">`CMyDoc`</ph> class, or any of its derivatives, you could code:","pos":[7403,7536],"source":" As an example, to ensure that `pDocument` is a pointer to an object of the `CMyDoc` class, or any of its derivatives, you could code:"},{"pos":[7554,7572],"content":"NVC_MFCDocView#194"},{"pos":[7634,7696],"content":"Using the <ph id=\"ph1\">`ASSERT_KINDOF`</ph> macro is exactly the same as coding:","source":"Using the `ASSERT_KINDOF` macro is exactly the same as coding:"},{"pos":[7714,7732],"content":"NVC_MFCDocView#195"},{"pos":[7794,7993],"content":"This function works only for classes declared with the [DECLARE_DYNAMIC](run-time-object-model-services.md#declare_dynamic or <bpt id=\"p1\">[</bpt>DECLARE_SERIAL<ept id=\"p1\">](run-time-object-model-services.md#declare_serial)</ept> macro.","source":"This function works only for classes declared with the [DECLARE_DYNAMIC](run-time-object-model-services.md#declare_dynamic or [DECLARE_SERIAL](run-time-object-model-services.md#declare_serial) macro."},{"pos":[8001,8072],"content":"[!NOTE]\n This function is available only in the Debug version of MFC.","leadings":["","> "],"nodes":[{"content":"This function is available only in the Debug version of MFC.","pos":[9,69]}]},{"pos":[8111,8123],"content":"ASSERT_VALID"},{"content":"Use to test your assumptions about the validity of an object's internal state.","pos":[8127,8205]},{"content":"Parameters","pos":[8256,8266]},{"content":"Specifies an object of a class derived from <ph id=\"ph1\">`CObject`</ph> that has an overriding version of the <ph id=\"ph2\">`AssertValid`</ph> member function.","pos":[8283,8405],"source":" Specifies an object of a class derived from `CObject` that has an overriding version of the `AssertValid` member function."},{"content":"Remarks","pos":[8415,8422]},{"pos":[8441,8518],"content":"calls the <ph id=\"ph1\">`AssertValid`</ph> member function of the object passed as its argument.","source":" calls the `AssertValid` member function of the object passed as its argument."},{"content":"In the Release version of MFC, <ph id=\"ph1\">`ASSERT_VALID`</ph> does nothing.","pos":[8525,8584],"source":"In the Release version of MFC, `ASSERT_VALID` does nothing."},{"content":"In the Debug version, it validates the pointer, checks against <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, and calls the object's own <ph id=\"ph1\">`AssertValid`</ph> member functions.","pos":[8585,8716],"source":" In the Debug version, it validates the pointer, checks against **NULL**, and calls the object's own `AssertValid` member functions."},{"content":"If any of these tests fails, an alert message is displayed in the same manner as <bpt id=\"p1\">[</bpt>ASSERT<ept id=\"p1\">](#assert)</ept>.","pos":[8717,8816],"source":" If any of these tests fails, an alert message is displayed in the same manner as [ASSERT](#assert)."},{"pos":[8824,8895],"content":"[!NOTE]\n This function is available only in the Debug version of MFC.","leadings":["","> "],"nodes":[{"content":"This function is available only in the Debug version of MFC.","pos":[9,69]}]},{"pos":[8902,9019],"content":"For more information and examples, see <bpt id=\"p1\">[</bpt>Debugging MFC Applications<ept id=\"p1\">](/visualstudio/debugger/mfc-debugging-techniques)</ept>.","source":"For more information and examples, see [Debugging MFC Applications](/visualstudio/debugger/mfc-debugging-techniques)."},{"content":"Example","pos":[9029,9036]},{"pos":[9051,9074],"content":"NVC_MFCCObjectSample#19"},{"pos":[9165,9174],"content":"DEBUG_NEW"},{"content":"Assists in finding memory leaks.","pos":[9178,9210]},{"content":"Remarks","pos":[9262,9269]},{"pos":[9273,9400],"content":"You can use <ph id=\"ph1\">`DEBUG_NEW`</ph> everywhere in your program that you would ordinarily use the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operator to allocate heap storage.","source":"You can use `DEBUG_NEW` everywhere in your program that you would ordinarily use the **new** operator to allocate heap storage."},{"content":"In debug mode (when the <bpt id=\"p1\">**</bpt>_DEBUG<ept id=\"p1\">**</ept> symbol is defined), <ph id=\"ph1\">`DEBUG_NEW`</ph> keeps track of the filename and line number for each object that it allocates.","pos":[9407,9552],"source":"In debug mode (when the **_DEBUG** symbol is defined), `DEBUG_NEW` keeps track of the filename and line number for each object that it allocates."},{"content":"Then, when you use the <bpt id=\"p1\">[</bpt>CMemoryState::DumpAllObjectsSince<ept id=\"p1\">](cmemorystate-structure.md#cmemorystate__dumpallobjectssince)</ept> member function, each object allocated with <ph id=\"ph1\">`DEBUG_NEW`</ph> is shown with the filename and line number where it was allocated.","pos":[9553,9795],"source":" Then, when you use the [CMemoryState::DumpAllObjectsSince](cmemorystate-structure.md#cmemorystate__dumpallobjectssince) member function, each object allocated with `DEBUG_NEW` is shown with the filename and line number where it was allocated."},{"pos":[9802,9876],"content":"To use <ph id=\"ph1\">`DEBUG_NEW`</ph>, insert the following directive into your source files:","source":"To use `DEBUG_NEW`, insert the following directive into your source files:"},{"pos":[9894,9917],"content":"NVC_MFCCObjectSample#14"},{"content":"Once you insert this directive, the preprocessor will insert <ph id=\"ph1\">`DEBUG_NEW`</ph> wherever you use <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept>, and MFC does the rest.","pos":[9979,10100],"source":"Once you insert this directive, the preprocessor will insert `DEBUG_NEW` wherever you use **new**, and MFC does the rest."},{"content":"When you compile a release version of your program, <ph id=\"ph1\">`DEBUG_NEW`</ph> resolves to a simple <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> operation, and the filename and line number information are not generated.","pos":[10101,10268],"source":" When you compile a release version of your program, `DEBUG_NEW` resolves to a simple **new** operation, and the filename and line number information are not generated."},{"pos":[10276,10492],"content":"[!NOTE]\n In previous versions of MFC (4.1 and earlier) you needed to put the `#define` statement after all statements that called the `IMPLEMENT_DYNCREATE` or `IMPLEMENT_SERIAL` macros. This is no longer necessary.","leadings":["","> "],"nodes":[{"content":" In previous versions of MFC (4.1 and earlier) you needed to put the `#define` statement after all statements that called the `IMPLEMENT_DYNCREATE` or `IMPLEMENT_SERIAL` macros. This is no longer necessary.","pos":[8,214],"nodes":[{"content":"In previous versions of MFC (4.1 and earlier) you needed to put the <ph id=\"ph1\">`#define`</ph> statement after all statements that called the <ph id=\"ph2\">`IMPLEMENT_DYNCREATE`</ph> or <ph id=\"ph3\">`IMPLEMENT_SERIAL`</ph> macros.","pos":[1,177],"source":" In previous versions of MFC (4.1 and earlier) you needed to put the `#define` statement after all statements that called the `IMPLEMENT_DYNCREATE` or `IMPLEMENT_SERIAL` macros."},{"content":"This is no longer necessary.","pos":[178,206]}]}]},{"pos":[10529,10539],"content":"DEBUG_ONLY"},{"pos":[10543,10634],"content":"In debug mode (when the <bpt id=\"p1\">**</bpt>_DEBUG<ept id=\"p1\">**</ept> symbol is defined), <ph id=\"ph1\">`DEBUG_ONLY`</ph> evaluates its argument.","source":"In debug mode (when the **_DEBUG** symbol is defined), `DEBUG_ONLY` evaluates its argument."},{"content":"Remarks","pos":[10686,10693]},{"content":"In a release build, <bpt id=\"p1\">**</bpt>DEBUG_ONLY<ept id=\"p1\">**</ept> does not evaluate its argument.","pos":[10697,10763],"source":"In a release build, **DEBUG_ONLY** does not evaluate its argument."},{"content":"This is useful when you have code that should be executed only in debug builds.","pos":[10764,10843]},{"pos":[10850,10951],"content":"The <ph id=\"ph1\">`DEBUG_ONLY`</ph> macro is equivalent to surrounding <bpt id=\"p1\">*</bpt>expression<ept id=\"p1\">*</ept> with <bpt id=\"p2\">**</bpt>#ifdef _DEBUG<ept id=\"p2\">**</ept> and <ph id=\"ph2\">`#endif`</ph>.","source":"The `DEBUG_ONLY` macro is equivalent to surrounding *expression* with **#ifdef _DEBUG** and `#endif`."},{"content":"Example","pos":[10961,10968]},{"pos":[10983,11003],"content":"NVC_MFC_Utilities#32"},{"pos":[11090,11095],"content":"TRACE"},{"content":"Sends the specified string to the debugger of the current application.","pos":[11099,11169]},{"content":"Remarks","pos":[11273,11280]},{"content":"See <bpt id=\"p1\">[</bpt>ATLTRACE2<ept id=\"p1\">](http://msdn.microsoft.com/library/467ff555-e7a5-4f94-bdd9-50ee27ab9986)</ept> for a description of <bpt id=\"p2\">**</bpt>TRACE<ept id=\"p2\">**</ept>.","pos":[11284,11403],"source":"See [ATLTRACE2](http://msdn.microsoft.com/library/467ff555-e7a5-4f94-bdd9-50ee27ab9986) for a description of **TRACE**."},{"content":"<bpt id=\"p1\">**</bpt>TRACE<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`ATLTRACE2`</ph> have the same behavior.","pos":[11404,11453],"source":"**TRACE** and `ATLTRACE2` have the same behavior."},{"content":"In the debug version of MFC, this macro sends the specified string to the debugger of the current application.","pos":[11460,11570]},{"content":"In a release build, this macro compiles to nothing (no code is generated at all).","pos":[11571,11652]},{"pos":[11659,11763],"content":"For more information, see <bpt id=\"p1\">[</bpt>Debugging MFC Applications<ept id=\"p1\">](/visualstudio/debugger/mfc-debugging-techniques)</ept>.","source":"For more information, see [Debugging MFC Applications](/visualstudio/debugger/mfc-debugging-techniques)."},{"pos":[11796,11802],"content":"VERIFY"},{"content":"In the Debug version of MFC, evaluates its argument.","pos":[11806,11858]},{"content":"Parameters","pos":[11913,11923]},{"content":"Specifies an expression (including pointer values) that evaluates to nonzero or 0.","pos":[11950,12032]},{"content":"Remarks","pos":[12042,12049]},{"content":"If the result is 0, the macro prints a diagnostic message and halts the program.","pos":[12053,12133]},{"content":"If the condition is nonzero, it does nothing.","pos":[12134,12179]},{"content":"The diagnostic message has the form","pos":[12186,12221]},{"pos":[12282,12403],"content":"where <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> is the name of the source file and <bpt id=\"p2\">*</bpt>num<ept id=\"p2\">*</ept> is the line number of the assertion that failed in the source file.","source":"where *name* is the name of the source file and *num* is the line number of the assertion that failed in the source file."},{"content":"In the Release version of MFC, <bpt id=\"p1\">**</bpt>VERIFY<ept id=\"p1\">**</ept> evaluates the expression but does not print or interrupt the program.","pos":[12410,12521],"source":"In the Release version of MFC, **VERIFY** evaluates the expression but does not print or interrupt the program."},{"content":"For example, if the expression is a function call, the call will be made.","pos":[12522,12595]},{"content":"Example","pos":[12605,12612]},{"pos":[12627,12645],"content":"NVC_MFCDocView#198"},{"pos":[12756,12785],"content":"afxDump (CDumpContext in MFC)"},{"content":"Provides basic object-dumping capability in your application.","pos":[12789,12850]},{"content":"Remarks","pos":[12902,12909]},{"content":"is a predefined <bpt id=\"p1\">[</bpt>CDumpContext<ept id=\"p1\">](../../mfc/reference/cdumpcontext-class.md)</ept> object that allows you to send <ph id=\"ph1\">`CDumpContext`</ph> information to the debugger output window or to a debug terminal.","pos":[12923,13108],"source":" is a predefined [CDumpContext](../../mfc/reference/cdumpcontext-class.md) object that allows you to send `CDumpContext` information to the debugger output window or to a debug terminal."},{"content":"Typically, you supply <ph id=\"ph1\">`afxDump`</ph> as a parameter to <ph id=\"ph2\">`CObject::Dump`</ph>.","pos":[13109,13175],"source":" Typically, you supply `afxDump` as a parameter to `CObject::Dump`."},{"pos":[13182,13326],"content":"Under Windows NT and all versions of Windows, <ph id=\"ph1\">`afxDump`</ph> output is sent to the Output-Debug window of Visual C++ when you debug your application.","source":"Under Windows NT and all versions of Windows, `afxDump` output is sent to the Output-Debug window of Visual C++ when you debug your application."},{"content":"This variable is defined only in the Debug version of MFC.","pos":[13333,13391]},{"content":"For more information on <ph id=\"ph1\">`afxDump`</ph>, see <bpt id=\"p1\">[</bpt>Debugging MFC Applications<ept id=\"p1\">](/visualstudio/debugger/mfc-debugging-techniques)</ept>.","pos":[13392,13509],"source":" For more information on `afxDump`, see [Debugging MFC Applications](/visualstudio/debugger/mfc-debugging-techniques)."},{"content":"Example","pos":[13519,13526]},{"pos":[13541,13561],"content":"NVC_MFC_Utilities#23"},{"pos":[13651,13659],"content":"afxMemDF"},{"content":"This variable is accessible from a debugger or your program and allows you to tune allocation diagnostics.","pos":[13663,13769]},{"content":"Remarks","pos":[13812,13819]},{"pos":[13834,13907],"content":"can have the following values as specified by the enumeration <ph id=\"ph1\">`afxMemDF`</ph>:","source":" can have the following values as specified by the enumeration `afxMemDF`:"},{"pos":[13915,13994],"content":"<bpt id=\"p1\">**</bpt>allocMemDF<ept id=\"p1\">**</ept> Turns on debugging allocator (default setting in Debug library).","source":"**allocMemDF** Turns on debugging allocator (default setting in Debug library)."},{"content":"<bpt id=\"p1\">**</bpt>delayFreeMemDF<ept id=\"p1\">**</ept> Delays freeing memory.","pos":[14002,14043],"source":"**delayFreeMemDF** Delays freeing memory."},{"content":"While your program frees a memory block, the allocator does not return that memory to the underlying operating system.","pos":[14044,14162]},{"content":"This will place maximum memory stress on your program.","pos":[14163,14217]},{"content":"<bpt id=\"p1\">**</bpt>checkAlwaysMemDF<ept id=\"p1\">**</ept> Calls <ph id=\"ph1\">`AfxCheckMemory`</ph> every time memory is allocated or freed.","pos":[14225,14309],"source":"**checkAlwaysMemDF** Calls `AfxCheckMemory` every time memory is allocated or freed."},{"content":"This will significantly slow memory allocations and deallocations.","pos":[14310,14376]},{"content":"Example","pos":[14386,14393]},{"pos":[14408,14428],"content":"NVC_MFC_Utilities#30"},{"pos":[14523,14536],"content":"AfxCheckError"},{"pos":[14540,14606],"content":"This function tests the passed <bpt id=\"p1\">**</bpt>SCODE<ept id=\"p1\">**</ept> to see if it is an error.","source":"This function tests the passed **SCODE** to see if it is an error."},{"content":"Remarks","pos":[14717,14724]},{"content":"If it is an error, the function throws an exception.","pos":[14728,14780]},{"content":"If the passed <ph id=\"ph1\">`SCODE`</ph> is <bpt id=\"p1\">**</bpt>E_OUTOFMEMORY<ept id=\"p1\">**</ept>, the function throws a <bpt id=\"p2\">[</bpt>CMemoryException<ept id=\"p2\">](../../mfc/reference/cmemoryexception-class.md)</ept> by calling <bpt id=\"p3\">[</bpt>AfxThrowMemoryException<ept id=\"p3\">](exception-processing.md#afxthrowmemoryexception)</ept>.","pos":[14781,14999],"source":" If the passed `SCODE` is **E_OUTOFMEMORY**, the function throws a [CMemoryException](../../mfc/reference/cmemoryexception-class.md) by calling [AfxThrowMemoryException](exception-processing.md#afxthrowmemoryexception)."},{"content":"Otherwise, the function throws a <bpt id=\"p1\">[</bpt>COleException<ept id=\"p1\">](../../mfc/reference/coleexception-class.md)</ept> by calling <bpt id=\"p2\">[</bpt>AfxThrowOleException<ept id=\"p2\">](exception-processing.md#afxthrowoleexception)</ept>.","pos":[15000,15173],"source":" Otherwise, the function throws a [COleException](../../mfc/reference/coleexception-class.md) by calling [AfxThrowOleException](exception-processing.md#afxthrowoleexception)."},{"content":"This function can be used to check the return values of calls to OLE functions in your application.","pos":[15180,15279]},{"content":"By testing the return value with this function in your application, you can properly react to error conditions with a minimal amount of code.","pos":[15280,15421]},{"pos":[15429,15504],"content":"[!NOTE]\n This function has the same effect in debug and non-debug builds.","leadings":["","> "],"nodes":[{"content":"This function has the same effect in debug and non-debug builds.","pos":[9,73]}]},{"content":"Example","pos":[15514,15521]},{"pos":[15536,15558],"content":"NVC_MFCOleContainer#33"},{"pos":[15655,15669],"content":"AfxCheckMemory"},{"content":"This function validates the free memory pool and prints error messages as required.","pos":[15673,15756]},{"content":"Return Value","pos":[15807,15819]},{"content":"Nonzero if no memory errors; otherwise 0.","pos":[15823,15864]},{"content":"Remarks","pos":[15874,15881]},{"content":"If the function detects no memory corruption, it prints nothing.","pos":[15885,15949]},{"content":"All memory blocks currently allocated on the heap are checked, including those allocated by <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> but not those allocated by direct calls to underlying memory allocators, such as the <ph id=\"ph1\">`malloc`</ph> function or the <bpt id=\"p2\">**</bpt>GlobalAlloc<ept id=\"p2\">**</ept> Windows function.","pos":[15956,16199],"source":"All memory blocks currently allocated on the heap are checked, including those allocated by **new** but not those allocated by direct calls to underlying memory allocators, such as the `malloc` function or the **GlobalAlloc** Windows function."},{"content":"If any block is found to be corrupted, a message is printed to the debugger output.","pos":[16200,16283]},{"content":"If you include the line","pos":[16290,16313]},{"pos":[16331,16354],"content":"NVC_MFCCObjectSample#14"},{"pos":[16416,16544],"content":"in a program module, then subsequent calls to <ph id=\"ph1\">`AfxCheckMemory`</ph> show the filename and line number where the memory was allocated.","source":"in a program module, then subsequent calls to `AfxCheckMemory` show the filename and line number where the memory was allocated."},{"pos":[16552,16722],"content":"[!NOTE]\n If your module contains one or more implementations of serializable classes, then you must put the `#define` line after the last `IMPLEMENT_SERIAL` macro call.","leadings":["","> "],"nodes":[{"content":"If your module contains one or more implementations of serializable classes, then you must put the <ph id=\"ph1\">`#define`</ph> line after the last <ph id=\"ph2\">`IMPLEMENT_SERIAL`</ph> macro call.","pos":[9,168],"source":" If your module contains one or more implementations of serializable classes, then you must put the `#define` line after the last `IMPLEMENT_SERIAL` macro call."}]},{"content":"This function works only in the Debug version of MFC.","pos":[16729,16782]},{"content":"Example","pos":[16792,16799]},{"pos":[16814,16837],"content":"NVC_MFCCObjectSample#26"},{"pos":[16933,16946],"content":"AfxDump (MFC)"},{"content":"Call this function while in the debugger to dump the state of an object while debugging.","pos":[16950,17038]},{"content":"Parameters","pos":[17099,17109]},{"content":"A pointer to an object of a class derived from <ph id=\"ph1\">`CObject`</ph>.","pos":[17122,17179],"source":" A pointer to an object of a class derived from `CObject`."},{"content":"Remarks","pos":[17189,17196]},{"content":"<bpt id=\"p1\">**</bpt>AfxDump<ept id=\"p1\">**</ept> calls an object's <ph id=\"ph1\">`Dump`</ph> member function and sends the information to the location specified by the <ph id=\"ph2\">`afxDump`</ph> variable.","pos":[17200,17331],"source":"**AfxDump** calls an object's `Dump` member function and sends the information to the location specified by the `afxDump` variable."},{"content":"<bpt id=\"p1\">**</bpt>AfxDump<ept id=\"p1\">**</ept> is available only in the Debug version of MFC.","pos":[17332,17390],"source":"**AfxDump** is available only in the Debug version of MFC."},{"pos":[17397,17521],"content":"Your program code should not call <bpt id=\"p1\">**</bpt>AfxDump<ept id=\"p1\">**</ept>, but should instead call the <ph id=\"ph1\">`Dump`</ph> member function of the appropriate object.","source":"Your program code should not call **AfxDump**, but should instead call the `Dump` member function of the appropriate object."},{"pos":[17560,17572],"content":"AfxDumpStack"},{"content":"This global function can be used to generate an image of the current stack.","pos":[17576,17651]},{"content":"Parameters","pos":[17752,17762]},{"content":"dwTarget","pos":[17767,17775]},{"content":"Indicates the target of the dump output.","pos":[17780,17820]},{"content":"Possible values, which can be combined using the bitwise-OR ( <bpt id=\"p1\">**</bpt>&amp;#124;<ept id=\"p1\">**</ept>) operator, are as follows:","pos":[17821,17920],"source":" Possible values, which can be combined using the bitwise-OR ( **&#124;**) operator, are as follows:"},{"content":"<bpt id=\"p1\">**</bpt>AFX_STACK_DUMP_TARGET_TRACE<ept id=\"p1\">**</ept> Sends output by means of the <bpt id=\"p2\">[</bpt>TRACE<ept id=\"p2\">](#trace)</ept> macro.","pos":[17928,18011],"source":"**AFX_STACK_DUMP_TARGET_TRACE** Sends output by means of the [TRACE](#trace) macro."},{"content":"The <bpt id=\"p1\">**</bpt>TRACE<ept id=\"p1\">**</ept> macro generates output in debug builds only; it generates no output in release builds.","pos":[18012,18112],"source":" The **TRACE** macro generates output in debug builds only; it generates no output in release builds."},{"content":"Also, <bpt id=\"p1\">**</bpt>TRACE<ept id=\"p1\">**</ept> can be redirected to other targets besides the debugger.","pos":[18113,18185],"source":" Also, **TRACE** can be redirected to other targets besides the debugger."},{"content":"<bpt id=\"p1\">**</bpt>AFX_STACK_DUMP_TARGET_DEFAULT<ept id=\"p1\">**</ept> Sends dump output to the default target.","pos":[18193,18267],"source":"**AFX_STACK_DUMP_TARGET_DEFAULT** Sends dump output to the default target."},{"content":"For a debug build, output goes to the <bpt id=\"p1\">**</bpt>TRACE<ept id=\"p1\">**</ept> macro.","pos":[18268,18322],"source":" For a debug build, output goes to the **TRACE** macro."},{"content":"In a release build, output goes to the Clipboard.","pos":[18323,18372]},{"content":"<bpt id=\"p1\">**</bpt>AFX_STACK_DUMP_TARGET_CLIPBOARD<ept id=\"p1\">**</ept> Sends output to the Clipboard only.","pos":[18380,18451],"source":"**AFX_STACK_DUMP_TARGET_CLIPBOARD** Sends output to the Clipboard only."},{"content":"The data is placed on the Clipboard as plain text using the <bpt id=\"p1\">**</bpt>CF_TEXT<ept id=\"p1\">**</ept> Clipboard format.","pos":[18452,18541],"source":" The data is placed on the Clipboard as plain text using the **CF_TEXT** Clipboard format."},{"pos":[18549,18653],"content":"<bpt id=\"p1\">**</bpt>AFX_STACK_DUMP_TARGET_BOTH<ept id=\"p1\">**</ept> Sends output to the Clipboard and to the <bpt id=\"p2\">**</bpt>TRACE<ept id=\"p2\">**</ept> macro, simultaneously.","source":"**AFX_STACK_DUMP_TARGET_BOTH** Sends output to the Clipboard and to the **TRACE** macro, simultaneously."},{"content":"<bpt id=\"p1\">**</bpt>AFX_STACK_DUMP_TARGET_ODS<ept id=\"p1\">**</ept> Sends output directly to the debugger by means of the Win32 function <bpt id=\"p2\">**</bpt>OutputDebugString()<ept id=\"p2\">**</ept>.","pos":[18661,18784],"source":"**AFX_STACK_DUMP_TARGET_ODS** Sends output directly to the debugger by means of the Win32 function **OutputDebugString()**."},{"content":"This option will generate debugger output in both debug and release builds when a debugger is attached to the process.","pos":[18785,18903]},{"content":"<bpt id=\"p1\">**</bpt>AFX_STACK_DUMP_TARGET_ODS<ept id=\"p1\">**</ept> always reaches the debugger (if it is attached) and cannot be redirected.","pos":[18904,19007],"source":"**AFX_STACK_DUMP_TARGET_ODS** always reaches the debugger (if it is attached) and cannot be redirected."},{"content":"Remarks","pos":[19017,19024]},{"pos":[19028,19172],"content":"The example below reflects a single line of the output generated from calling <ph id=\"ph1\">`AfxDumpStack`</ph> from a button handler in an MFC dialog application:","source":"The example below reflects a single line of the output generated from calling `AfxDumpStack` from a button handler in an MFC dialog application:"},{"content":"Each line in the output above indicates the address of the last function call, the full path name of the module that contains the function call, and the function prototype called.","pos":[20674,20853]},{"content":"If the function call on the stack does not happen at the exact address of the function, an offset of bytes is shown.","pos":[20854,20970]},{"content":"For example, the following table describes the first line of the above output:","pos":[20977,21055]},{"content":"Output","pos":[21062,21068]},{"content":"Description","pos":[21069,21080]},{"content":"The return address of the last function call.","pos":[21132,21177]},{"content":"The full path name of the module that contains the function call.","pos":[21207,21272]},{"content":"The function prototype called.","pos":[21312,21342]},{"pos":[21361,21524],"content":"The offset in bytes from the address of the function prototype (in this case, <ph id=\"ph1\">`void AfxDumpStack(unsigned long)`</ph>) to the return address (in this case, <ph id=\"ph2\">`00427D55`</ph>).","source":"The offset in bytes from the address of the function prototype (in this case, `void AfxDumpStack(unsigned long)`) to the return address (in this case, `00427D55`)."},{"content":"is available in debug and nondebug versions of the MFC libraries; however, the function is always linked statically, even when your executable file uses MFC in a shared DLL.","pos":[21547,21720]},{"content":"In shared-library implementations, the function is found in the MFCS42.LIB library (and its variants).","pos":[21721,21823]},{"content":"To use this function successfully:","pos":[21830,21864]},{"content":"The file IMAGEHLP.DLL must be on your path.","pos":[21874,21917]},{"content":"If you do not have this DLL, the function will display an error message.","pos":[21918,21990]},{"content":"See <bpt id=\"p1\">[</bpt>Image Help Library<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680321)</ept> for information on the function set provided by IMAGEHLP.","pos":[21991,22133],"source":" See [Image Help Library](http://msdn.microsoft.com/library/windows/desktop/ms680321) for information on the function set provided by IMAGEHLP."},{"content":"The modules that have frames on the stack must include debugging information.","pos":[22143,22220]},{"content":"If they do not contain debugging information, the function will still generate a stack trace, but the trace will be less detailed.","pos":[22221,22351]},{"pos":[22401,22424],"content":"AfxEnableMemoryLeakDump"},{"pos":[22428,22506],"content":"Enables and disables the memory leak dump in the <ph id=\"ph1\">`AFX_DEBUG_STATE`</ph> destructor.","source":"Enables and disables the memory leak dump in the `AFX_DEBUG_STATE` destructor."},{"content":"Parameters","pos":[22580,22590]},{"content":"[in]","pos":[22594,22598]},{"content":"indicates the memory leak dump is enabled; <ph id=\"ph1\">`FALSE`</ph> indicates the memory leak dump is disabled.","pos":[22617,22711],"source":" indicates the memory leak dump is enabled; `FALSE` indicates the memory leak dump is disabled."},{"content":"Return Value","pos":[22721,22733]},{"content":"The previous value for this flag.","pos":[22737,22770]},{"content":"Remarks","pos":[22780,22787]},{"content":"When an application unloads the MFC library, the MFC library checks for memory leaks.","pos":[22791,22876]},{"content":"At this point, any memory leaks are reported to the user through the <bpt id=\"p1\">**</bpt>Debug<ept id=\"p1\">**</ept> window of <ph id=\"ph1\">[!INCLUDE[vsprvs](../../assembler/masm/includes/vsprvs_md.md)]</ph>.","pos":[22877,23029],"source":" At this point, any memory leaks are reported to the user through the **Debug** window of [!INCLUDE[vsprvs](../../assembler/masm/includes/vsprvs_md.md)]."},{"content":"If your application loads another library before the MFC library, some memory allocations in that library will be incorrectly reported as memory leaks.","pos":[23036,23187]},{"content":"False memory leaks can cause your application to close slowly as the MFC library reports them.","pos":[23188,23282]},{"content":"In this case, use <ph id=\"ph1\">`AfxEnableMemoryLeakDump`</ph> to disable the memory leak dump.","pos":[23283,23359],"source":" In this case, use `AfxEnableMemoryLeakDump` to disable the memory leak dump."},{"pos":[23367,23616],"content":"[!NOTE]\n If you use this method to turn off the memory leak dump, you will not receive reports of valid memory leaks in your application. You should only use this method if you are confident that the memory leak report contains false memory leaks.","leadings":["","> "],"nodes":[{"content":" If you use this method to turn off the memory leak dump, you will not receive reports of valid memory leaks in your application. You should only use this method if you are confident that the memory leak report contains false memory leaks.","pos":[8,247],"nodes":[{"content":"If you use this method to turn off the memory leak dump, you will not receive reports of valid memory leaks in your application.","pos":[1,129]},{"content":"You should only use this method if you are confident that the memory leak report contains false memory leaks.","pos":[130,239]}]}]},{"pos":[23666,23689],"content":"AfxEnableMemoryTracking"},{"content":"Diagnostic memory tracking is normally enabled in the Debug version of MFC.","pos":[23693,23768]},{"content":"Parameters","pos":[23838,23848]},{"content":"bTrack","pos":[23853,23859]},{"content":"Setting this value to <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept> turns on memory tracking; <bpt id=\"p2\">**</bpt>FALSE<ept id=\"p2\">**</ept> turns it off.","pos":[23864,23944],"source":" Setting this value to **TRUE** turns on memory tracking; **FALSE** turns it off."},{"content":"Return Value","pos":[23954,23966]},{"content":"The previous setting of the tracking-enable flag.","pos":[23970,24019]},{"content":"Remarks","pos":[24029,24036]},{"content":"Use this function to disable tracking on sections of your code that you know are allocating blocks correctly.","pos":[24040,24149]},{"pos":[24156,24289],"content":"For more information on <ph id=\"ph1\">`AfxEnableMemoryTracking`</ph>, see <bpt id=\"p1\">[</bpt>Debugging MFC Applications<ept id=\"p1\">](/visualstudio/debugger/mfc-debugging-techniques)</ept>.","source":"For more information on `AfxEnableMemoryTracking`, see [Debugging MFC Applications](/visualstudio/debugger/mfc-debugging-techniques)."},{"pos":[24297,24361],"content":"[!NOTE]\n This function works only in the Debug version of MFC.","leadings":["","> "],"nodes":[{"content":"This function works only in the Debug version of MFC.","pos":[9,62]}]},{"content":"Example","pos":[24371,24378]},{"pos":[24393,24413],"content":"NVC_MFC_Utilities#24"},{"pos":[24512,24528],"content":"AfxIsMemoryBlock"},{"pos":[24532,24670],"content":"Tests a memory address to make sure it represents a currently active memory block that was allocated by the diagnostic version of <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept>.","source":"Tests a memory address to make sure it represents a currently active memory block that was allocated by the diagnostic version of **new**."},{"content":"Parameters","pos":[24795,24805]},{"content":"Points to the block of memory to be tested.","pos":[24816,24859]},{"content":"Contains the length of the memory block in bytes.","pos":[24878,24927]},{"content":"Points to a <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> integer that will be filled in with the memory block's allocation sequence number, or zero if it does not represent a currently active memory block.","pos":[24955,25124],"source":" Points to a **long** integer that will be filled in with the memory block's allocation sequence number, or zero if it does not represent a currently active memory block."},{"content":"Return Value","pos":[25134,25146]},{"content":"Nonzero if the memory block is currently allocated and the length is correct; otherwise 0.","pos":[25150,25240]},{"content":"Remarks","pos":[25250,25257]},{"content":"It also checks the specified size against the original allocated size.","pos":[25261,25331]},{"content":"If the function returns nonzero, the allocation sequence number is returned in <ph id=\"ph1\">`plRequestNumber`</ph>.","pos":[25332,25429],"source":" If the function returns nonzero, the allocation sequence number is returned in `plRequestNumber`."},{"content":"This number represents the order in which the block was allocated relative to all other <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> allocations.","pos":[25430,25538],"source":" This number represents the order in which the block was allocated relative to all other **new** allocations."},{"content":"Example","pos":[25548,25555]},{"pos":[25570,25590],"content":"NVC_MFC_Utilities#27"},{"pos":[25690,25707],"content":"AfxIsValidAddress"},{"content":"Tests any memory address to ensure that it is contained entirely within the program's memory space.","pos":[25711,25810]},{"content":"Parameters","pos":[25931,25941]},{"content":"Points to the memory address to be tested.","pos":[25953,25995]},{"content":"Contains the number of bytes of memory to be tested.","pos":[26014,26066]},{"content":"bReadWrite","pos":[26074,26084]},{"content":"Specifies whether the memory is both for reading and writing ( <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept>) or just reading ( <bpt id=\"p2\">**</bpt>FALSE<ept id=\"p2\">**</ept>).","pos":[26089,26191],"source":" Specifies whether the memory is both for reading and writing ( **TRUE**) or just reading ( **FALSE**)."},{"content":"Return Value","pos":[26201,26213]},{"content":"In debug builds, nonzero if the specified memory block is contained entirely within the program's memory space; otherwise 0.","pos":[26217,26341]},{"pos":[26348,26410],"content":"In non-debug builds, nonzero if <ph id=\"ph1\">`lp`</ph> is not NULL; otherwise 0.","source":"In non-debug builds, nonzero if `lp` is not NULL; otherwise 0."},{"content":"Remarks","pos":[26420,26427]},{"pos":[26431,26492],"content":"The address is not restricted to blocks allocated by <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept>.","source":"The address is not restricted to blocks allocated by **new**."},{"content":"Example","pos":[26502,26509]},{"pos":[26524,26544],"content":"NVC_MFC_Utilities#28"},{"pos":[26643,26659],"content":"AfxIsValidString"},{"content":"Use this function to determine whether a pointer to a string is valid.","pos":[26663,26733]},{"content":"Parameters","pos":[26826,26836]},{"content":"The pointer to test.","pos":[26850,26870]},{"content":"Specifies the length of the string to be tested, in bytes.","pos":[26890,26948]},{"content":"A value of â€“1 indicates that the string will be null-terminated.","pos":[26949,27015]},{"content":"Return Value","pos":[27025,27037]},{"content":"In debug builds, nonzero if the specified pointer points to a string of the specified size; otherwise 0.","pos":[27041,27145]},{"pos":[27152,27216],"content":"In non-debug builds, nonzero if <ph id=\"ph1\">`lpsz`</ph> is not NULL; otherwise 0.","source":"In non-debug builds, nonzero if `lpsz` is not NULL; otherwise 0."},{"content":"Example","pos":[27226,27233]},{"pos":[27248,27268],"content":"NVC_MFC_Utilities#29"},{"pos":[27366,27381],"content":"AfxSetAllocHook"},{"content":"Sets a hook that enables calling of the specified function before each memory block is allocated.","pos":[27385,27482]},{"content":"Parameters","pos":[27570,27580]},{"content":"pfnAllocHook","pos":[27585,27597]},{"content":"Specifies the name of the function to call.","pos":[27602,27645]},{"content":"See the Remarks for the prototype of an allocation function.","pos":[27646,27706]},{"content":"Return Value","pos":[27716,27728]},{"content":"Nonzero if you want to permit the allocation; otherwise 0.","pos":[27732,27790]},{"content":"Remarks","pos":[27800,27807]},{"content":"The Microsoft Foundation Class Library debug-memory allocator can call a user-defined hook function to allow the user to monitor a memory allocation and to control whether the allocation is permitted.","pos":[27811,28011]},{"content":"Allocation hook functions are prototyped as follows:","pos":[28012,28064]},{"pos":[28071,28166],"content":"<bpt id=\"p1\">**</bpt>BOOL AFXAPI AllocHook( size_t<ept id=\"p1\">**</ept> <ph id=\"ph1\">`nSize`</ph><bpt id=\"p2\">**</bpt>, BOOL<ept id=\"p2\">**</ept> <ph id=\"ph2\">`bObject`</ph><bpt id=\"p3\">**</bpt>, LONG<ept id=\"p3\">**</ept> <ph id=\"ph3\">`lRequestNumber`</ph> <bpt id=\"p4\">**</bpt>);<ept id=\"p4\">**</ept>","source":"**BOOL AFXAPI AllocHook( size_t** `nSize`**, BOOL** `bObject`**, LONG** `lRequestNumber` **);**"},{"content":"The size of the proposed memory allocation.","pos":[28184,28227]},{"content":"<bpt id=\"p1\"> **</bpt>TRUE<ept id=\"p1\">**</ept> if the allocation is for a <ph id=\"ph1\">`CObject`</ph>-derived object; otherwise <bpt id=\"p2\">**</bpt>FALSE<ept id=\"p2\">**</ept>.","pos":[28246,28329],"source":" **TRUE** if the allocation is for a `CObject`-derived object; otherwise **FALSE**."},{"content":"The memory allocation's sequence number.","pos":[28356,28396]},{"pos":[28403,28513],"content":"Note that the <bpt id=\"p1\">**</bpt>AFXAPI<ept id=\"p1\">**</ept> calling convention implies that the callee must remove the parameters from the stack.","source":"Note that the **AFXAPI** calling convention implies that the callee must remove the parameters from the stack."},{"pos":[28558,28576],"content":"AfxDoForAllClasses"},{"pos":[28580,28700],"content":"Calls the specified iteration function for all serializable <ph id=\"ph1\">`CObject`</ph>-derived classes in the application's memory space.","source":"Calls the specified iteration function for all serializable `CObject`-derived classes in the application's memory space."},{"content":"Parameters","pos":[28847,28857]},{"content":"Points to an iteration function to be called for each class.","pos":[28870,28930]},{"content":"The function arguments are a pointer to a <ph id=\"ph1\">`CRuntimeClass`</ph> object and a void pointer to extra data that the caller supplies to the function.","pos":[28931,29070],"source":" The function arguments are a pointer to a `CRuntimeClass` object and a void pointer to extra data that the caller supplies to the function."},{"content":"Points to optional data that the caller can supply to the iteration function.","pos":[29091,29168]},{"content":"This pointer can be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[29169,29198],"source":" This pointer can be **NULL**."},{"content":"Remarks","pos":[29208,29215]},{"content":"Serializable <ph id=\"ph1\">`CObject`</ph>-derived classes are classes derived using the <ph id=\"ph2\">`DECLARE_SERIAL`</ph> macro.","pos":[29219,29311],"source":"Serializable `CObject`-derived classes are classes derived using the `DECLARE_SERIAL` macro."},{"content":"The pointer that is passed to <ph id=\"ph1\">`AfxDoForAllClasses`</ph> in <ph id=\"ph2\">`pContext`</ph> is passed to the specified iteration function each time it is called.","pos":[29312,29446],"source":" The pointer that is passed to `AfxDoForAllClasses` in `pContext` is passed to the specified iteration function each time it is called."},{"pos":[29454,29518],"content":"[!NOTE]\n This function works only in the Debug version of MFC.","leadings":["","> "],"nodes":[{"content":"This function works only in the Debug version of MFC.","pos":[9,62]}]},{"content":"Example","pos":[29528,29535]},{"pos":[29550,29572],"content":"NVC_MFCCollections#113"},{"pos":[29646,29668],"content":"NVC_MFCCollections#114"},{"pos":[29769,29787],"content":"AfxDoForAllObjects"},{"pos":[29791,29910],"content":"Executes the specified iteration function for all objects derived from <ph id=\"ph1\">`CObject`</ph> that have been allocated with <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept>.","source":"Executes the specified iteration function for all objects derived from `CObject` that have been allocated with **new**."},{"content":"Parameters","pos":[30037,30047]},{"content":"Points to an iteration function to execute for each object.","pos":[30060,30119]},{"content":"The function arguments are a pointer to a <ph id=\"ph1\">`CObject`</ph> and a void pointer to extra data that the caller supplies to the function.","pos":[30120,30246],"source":" The function arguments are a pointer to a `CObject` and a void pointer to extra data that the caller supplies to the function."},{"content":"Points to optional data that the caller can supply to the iteration function.","pos":[30267,30344]},{"content":"This pointer can be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[30345,30374],"source":" This pointer can be **NULL**."},{"content":"Remarks","pos":[30384,30391]},{"content":"Stack, global, or embedded objects are not enumerated.","pos":[30395,30449]},{"content":"The pointer passed to <ph id=\"ph1\">`AfxDoForAllObjects`</ph> in <ph id=\"ph2\">`pContext`</ph> is passed to the specified iteration function each time it is called.","pos":[30450,30576],"source":" The pointer passed to `AfxDoForAllObjects` in `pContext` is passed to the specified iteration function each time it is called."},{"pos":[30584,30648],"content":"[!NOTE]\n This function works only in the Debug version of MFC.","leadings":["","> "],"nodes":[{"content":"This function works only in the Debug version of MFC.","pos":[9,62]}]},{"content":"Example","pos":[30658,30665]},{"pos":[30680,30702],"content":"NVC_MFCCollections#115"},{"pos":[30776,30798],"content":"NVC_MFCCollections#116"},{"content":"See Also","pos":[30863,30871]},{"content":"Macros and Globals","pos":[30876,30894]}],"content":"---\ntitle: \"Diagnostic Services | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mfc.macros\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"diagnosis, diagnostic services\"\n  - \"diagnostic macros, list of general MFC\"\n  - \"services, diagnostic\"\n  - \"MFC, diagnostic services\"\n  - \"general diagnostic functions and variables\"\n  - \"diagnostics, diagnostic functions and variables\"\n  - \"diagnostics, list of general MFC\"\n  - \"diagnosis, diagnostic functions and variables\"\n  - \"diagnosis, list of general MFC\"\n  - \"general diagnostic macros in MFC\"\n  - \"diagnostic macros\"\n  - \"diagnostic services\"\n  - \"object diagnostic functions in MFC\"\n  - \"diagnostics, diagnostic services\"\n  - \"diagnostic functions and variables\"\nms.assetid: 8d78454f-9fae-49c2-88c9-d3fabd5393e8\ncaps.latest.revision: 20\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Diagnostic Services\nThe Microsoft Foundation Class Library supplies many diagnostic services that make debugging your programs easier. These diagnostic services include macros and global functions that allow you to track your program's memory allocations, dump the contents of objects during run time, and print debugging messages during run time. The macros and global functions for diagnostic services are grouped into the following categories:  \n  \n-   General diagnostic macros  \n  \n-   General diagnostic functions and variables  \n  \n-   Object diagnostic functions  \n  \n These macros and functions are available for all classes derived from `CObject` in the Debug and Release versions of MFC. However, all except `DEBUG_NEW` and **VERIFY** do nothing in the Release version.  \n  \n In the Debug library, all allocated memory blocks are bracketed with a series of \"guard bytes.\" If these bytes are disturbed by an errant memory write, then the diagnostic routines can report a problem. If you include the line:  \n  \n [!code-cpp[NVC_MFCCObjectSample#14](../../mfc/codesnippet/cpp/diagnostic-services_1.cpp)]  \n  \n in your implementation file, all calls to **new** will store the filename and line number where the memory allocation took place. The function [CMemoryState::DumpAllObjectsSince](cmemorystate-structure.md#cmemorystate__dumpallobjectssince) will display this extra information, allowing you to identify memory leaks. Refer also to the class [CDumpContext](../../mfc/reference/cdumpcontext-class.md) for additional information on diagnostic output.  \n  \n In addition, the C run-time library also supports a set of diagnostic functions you can use to debug your applications. For more information, see [Debug Routines](../../c-runtime-library/debug-routines.md) in the Run-Time Library Reference.  \n  \n### MFC General Diagnostic Macros  \n  \n|||  \n|-|-|  \n|[ASSERT](#assert))|Prints a message and then aborts the program if the specified expression evaluates to **FALSE** in the Debug version of the library.|  \n|[ASSERT_KINDOF](#assert_kindof)|Tests that an object is an object of the specified class or of a class derived from the specified class.|  \n|[ASSERT_VALID](#assert_valid)|Tests the internal validity of an object by calling its `AssertValid` member function; typically overridden from `CObject`.|  \n|[DEBUG_NEW](#debug_new)|Supplies a filename and line number for all object allocations in Debug mode to help find memory leaks.|  \n|[DEBUG_ONLY](#debug_only)|Similar to **ASSERT** but does not test the value of the expression; useful for code that should execute only in Debug mode.|  \n|[TRACE](#trace)|Provides `printf`-like capability in the Debug version of the library.|  \n|[VERIFY](#verify)|Similar to **ASSERT** but evaluates the expression in the Release version of the library as well as in the Debug version.|  \n  \n### MFC General Diagnostic Variables and Functions  \n  \n|||  \n|-|-|  \n|[afxDump](#afxdump)|Global variable that sends [CDumpContext](../../mfc/reference/cdumpcontext-class.md) information to the debugger output window or to the debug terminal.|  \n|[afxMemDF](#afxmemdf)|Global variable that controls the behavior of the debugging memory allocator.|  \n|[AfxCheckError](#afxcheckerror)|Global variable used to test the passed **SCODE** to see if it is an error and, if so, throws the appropriate error.|  \n|[AfxCheckMemory](#afxcheckmemory)|Checks the integrity of all currently allocated memory.|  \n|[AfxDump](#afxdump__cdumpcontext_in_mfc_)|If called while in the debugger, dumps the state of an object while debugging.|  \n|[AfxDumpStack](#afxdumpstack)|Generate an image of the current stack. This function is always linked statically.|  \n|[AfxEnableMemoryLeakDump](#afxenablememoryleakdump)|Enables the memory leak dump.|  \n|[AfxEnableMemoryTracking](#afxenablememorytracking)|Turns memory tracking on and off.|  \n|[AfxIsMemoryBlock](#afxismemoryblock)|Verifies that a memory block has been properly allocated.|  \n|[AfxIsValidAddress](#afxisvalidaddress)|Verifies that a memory address range is within the program's bounds.|  \n|[AfxIsValidString](#afxisvalidstring)|Determines whether a pointer to a string is valid.|  \n|[AfxSetAllocHook](#afxsetallochook)|Enables the calling of a function on each memory allocation.|  \n  \n### MFC Object Diagnostic Functions  \n  \n|||  \n|-|-|  \n|[AfxDoForAllClasses](#afxdoforallclasses)|Performs a specified function on all `CObject`-derived classes that support run-time type checking.|  \n|[AfxDoForAllObjects](#afxdoforallobjects)|Performs a specified function on all `CObject`-derived objects that were allocated with **new**.|  \n  \n##  <a name=\"assert\"></a>  ASSERT\n Evaluates its argument.  \n  \n```   \nASSERT(booleanExpression)   \n```  \n  \n### Parameters  \n `booleanExpression`  \n Specifies an expression (including pointer values) that evaluates to nonzero or 0.  \n  \n### Remarks  \n If the result is 0, the macro prints a diagnostic message and aborts the program. If the condition is nonzero, it does nothing.  \n  \n The diagnostic message has the form  \n  \n `assertion failed in file <name> in line <num>`  \n  \n where *name* is the name of the source file, and *num* is the line number of the assertion that failed in the source file.  \n  \n In the Release version of MFC, **ASSERT** does not evaluate the expression and thus will not interrupt the program. If the expression must be evaluated regardless of environment, use the **VERIFY** macro in place of **ASSERT**.  \n  \n> [!NOTE]\n>  This function is available only in the Debug version of MFC.  \n  \n### Example  \n [!code-cpp[NVC_MFC_Utilities#44](../../mfc/codesnippet/cpp/diagnostic-services_2.cpp)]  \n  \n##  <a name=\"assert_kindof\"></a>  ASSERT_KINDOF  \n This macro asserts that the object pointed to is an object of the specified class, or is an object of a class derived from the specified class.  \n  \n```   \nASSERT_KINDOF(classname, pobject)  \n```  \n  \n### Parameters  \n *classname*  \n The name of a `CObject`-derived class.  \n  \n *pobject*  \n A pointer to a class object.  \n  \n### Remarks  \n The *pobject* parameter should be a pointer to an object and can be **const**. The object pointed to and the class must support `CObject` run-time class information. As an example, to ensure that `pDocument` is a pointer to an object of the `CMyDoc` class, or any of its derivatives, you could code:  \n  \n [!code-cpp[NVC_MFCDocView#194](../../mfc/codesnippet/cpp/diagnostic-services_3.cpp)]  \n  \n Using the `ASSERT_KINDOF` macro is exactly the same as coding:  \n  \n [!code-cpp[NVC_MFCDocView#195](../../mfc/codesnippet/cpp/diagnostic-services_4.cpp)]  \n  \n This function works only for classes declared with the [DECLARE_DYNAMIC](run-time-object-model-services.md#declare_dynamic or [DECLARE_SERIAL](run-time-object-model-services.md#declare_serial) macro.  \n  \n> [!NOTE]\n>  This function is available only in the Debug version of MFC.  \n  \n##  <a name=\"assert_valid\"></a>  ASSERT_VALID  \n Use to test your assumptions about the validity of an object's internal state.  \n  \n```   \nASSERT_VALID(pObject)   \n```  \n  \n### Parameters  \n `pObject`  \n Specifies an object of a class derived from `CObject` that has an overriding version of the `AssertValid` member function.  \n  \n### Remarks  \n `ASSERT_VALID` calls the `AssertValid` member function of the object passed as its argument.  \n  \n In the Release version of MFC, `ASSERT_VALID` does nothing. In the Debug version, it validates the pointer, checks against **NULL**, and calls the object's own `AssertValid` member functions. If any of these tests fails, an alert message is displayed in the same manner as [ASSERT](#assert).  \n  \n> [!NOTE]\n>  This function is available only in the Debug version of MFC.  \n  \n For more information and examples, see [Debugging MFC Applications](/visualstudio/debugger/mfc-debugging-techniques).  \n  \n### Example  \n [!code-cpp[NVC_MFCCObjectSample#19](../../mfc/codesnippet/cpp/diagnostic-services_5.cpp)]  \n  \n##  <a name=\"debug_new\"></a>  DEBUG_NEW  \n Assists in finding memory leaks.  \n  \n```   \n#define  new DEBUG_NEW   \n```  \n  \n### Remarks  \n You can use `DEBUG_NEW` everywhere in your program that you would ordinarily use the **new** operator to allocate heap storage.  \n  \n In debug mode (when the **_DEBUG** symbol is defined), `DEBUG_NEW` keeps track of the filename and line number for each object that it allocates. Then, when you use the [CMemoryState::DumpAllObjectsSince](cmemorystate-structure.md#cmemorystate__dumpallobjectssince) member function, each object allocated with `DEBUG_NEW` is shown with the filename and line number where it was allocated.  \n  \n To use `DEBUG_NEW`, insert the following directive into your source files:  \n  \n [!code-cpp[NVC_MFCCObjectSample#14](../../mfc/codesnippet/cpp/diagnostic-services_1.cpp)]  \n  \n Once you insert this directive, the preprocessor will insert `DEBUG_NEW` wherever you use **new**, and MFC does the rest. When you compile a release version of your program, `DEBUG_NEW` resolves to a simple **new** operation, and the filename and line number information are not generated.  \n  \n> [!NOTE]\n>  In previous versions of MFC (4.1 and earlier) you needed to put the `#define` statement after all statements that called the `IMPLEMENT_DYNCREATE` or `IMPLEMENT_SERIAL` macros. This is no longer necessary.  \n  \n##  <a name=\"debug_only\"></a>  DEBUG_ONLY  \n In debug mode (when the **_DEBUG** symbol is defined), `DEBUG_ONLY` evaluates its argument.  \n  \n```   \nDEBUG_ONLY(expression)   \n```  \n  \n### Remarks  \n In a release build, **DEBUG_ONLY** does not evaluate its argument. This is useful when you have code that should be executed only in debug builds.  \n  \n The `DEBUG_ONLY` macro is equivalent to surrounding *expression* with **#ifdef _DEBUG** and `#endif`.  \n  \n### Example  \n [!code-cpp[NVC_MFC_Utilities#32](../../mfc/codesnippet/cpp/diagnostic-services_6.cpp)]  \n  \n##  <a name=\"trace\"></a>  TRACE  \n Sends the specified string to the debugger of the current application.  \n  \n```   \nTRACE(exp)  \nTRACE(DWORD  category,  UINT  level, LPCSTR lpszFormat, ...)  \n \n```  \n  \n### Remarks  \n See [ATLTRACE2](http://msdn.microsoft.com/library/467ff555-e7a5-4f94-bdd9-50ee27ab9986) for a description of **TRACE**. **TRACE** and `ATLTRACE2` have the same behavior.  \n  \n In the debug version of MFC, this macro sends the specified string to the debugger of the current application. In a release build, this macro compiles to nothing (no code is generated at all).  \n  \n For more information, see [Debugging MFC Applications](/visualstudio/debugger/mfc-debugging-techniques).  \n  \n##  <a name=\"verify\"></a>  VERIFY  \n In the Debug version of MFC, evaluates its argument.  \n  \n```   \nVERIFY(booleanExpression)   \n```  \n  \n### Parameters  \n `booleanExpression`  \n Specifies an expression (including pointer values) that evaluates to nonzero or 0.  \n  \n### Remarks  \n If the result is 0, the macro prints a diagnostic message and halts the program. If the condition is nonzero, it does nothing.  \n  \n The diagnostic message has the form  \n  \n `assertion failed in file <name> in line <num>`  \n  \n where *name* is the name of the source file and *num* is the line number of the assertion that failed in the source file.  \n  \n In the Release version of MFC, **VERIFY** evaluates the expression but does not print or interrupt the program. For example, if the expression is a function call, the call will be made.  \n  \n### Example  \n [!code-cpp[NVC_MFCDocView#198](../../mfc/codesnippet/cpp/diagnostic-services_7.cpp)]  \n  \n##  <a name=\"afxdump__cdumpcontext_in_mfc_\"></a>  afxDump (CDumpContext in MFC)  \n Provides basic object-dumping capability in your application.  \n  \n```   \nCDumpContext  afxDump;   \n```  \n  \n### Remarks  \n `afxDump` is a predefined [CDumpContext](../../mfc/reference/cdumpcontext-class.md) object that allows you to send `CDumpContext` information to the debugger output window or to a debug terminal. Typically, you supply `afxDump` as a parameter to `CObject::Dump`.  \n  \n Under Windows NT and all versions of Windows, `afxDump` output is sent to the Output-Debug window of Visual C++ when you debug your application.  \n  \n This variable is defined only in the Debug version of MFC. For more information on `afxDump`, see [Debugging MFC Applications](/visualstudio/debugger/mfc-debugging-techniques).  \n  \n### Example  \n [!code-cpp[NVC_MFC_Utilities#23](../../mfc/codesnippet/cpp/diagnostic-services_8.cpp)]  \n  \n##  <a name=\"afxmemdf\"></a>  afxMemDF  \n This variable is accessible from a debugger or your program and allows you to tune allocation diagnostics.  \n  \n```   \nint  afxMemDF;  \n```  \n  \n### Remarks  \n `afxMemDF` can have the following values as specified by the enumeration `afxMemDF`:  \n  \n- **allocMemDF** Turns on debugging allocator (default setting in Debug library).  \n  \n- **delayFreeMemDF** Delays freeing memory. While your program frees a memory block, the allocator does not return that memory to the underlying operating system. This will place maximum memory stress on your program.  \n  \n- **checkAlwaysMemDF** Calls `AfxCheckMemory` every time memory is allocated or freed. This will significantly slow memory allocations and deallocations.  \n  \n### Example  \n [!code-cpp[NVC_MFC_Utilities#30](../../mfc/codesnippet/cpp/diagnostic-services_9.cpp)]  \n  \n##  <a name=\"afxcheckerror\"></a>  AfxCheckError  \n This function tests the passed **SCODE** to see if it is an error.  \n  \n```   \nvoid AFXAPI AfxCheckError(SCODE sc);\nthrow CMemoryException* \nthrow COleException*  \n```  \n  \n### Remarks  \n If it is an error, the function throws an exception. If the passed `SCODE` is **E_OUTOFMEMORY**, the function throws a [CMemoryException](../../mfc/reference/cmemoryexception-class.md) by calling [AfxThrowMemoryException](exception-processing.md#afxthrowmemoryexception). Otherwise, the function throws a [COleException](../../mfc/reference/coleexception-class.md) by calling [AfxThrowOleException](exception-processing.md#afxthrowoleexception).  \n  \n This function can be used to check the return values of calls to OLE functions in your application. By testing the return value with this function in your application, you can properly react to error conditions with a minimal amount of code.  \n  \n> [!NOTE]\n>  This function has the same effect in debug and non-debug builds.  \n  \n### Example  \n [!code-cpp[NVC_MFCOleContainer#33](../../mfc/codesnippet/cpp/diagnostic-services_10.cpp)]  \n  \n##  <a name=\"afxcheckmemory\"></a>  AfxCheckMemory  \n This function validates the free memory pool and prints error messages as required.  \n  \n```   \nBOOL  AfxCheckMemory(); \n```  \n  \n### Return Value  \n Nonzero if no memory errors; otherwise 0.  \n  \n### Remarks  \n If the function detects no memory corruption, it prints nothing.  \n  \n All memory blocks currently allocated on the heap are checked, including those allocated by **new** but not those allocated by direct calls to underlying memory allocators, such as the `malloc` function or the **GlobalAlloc** Windows function. If any block is found to be corrupted, a message is printed to the debugger output.  \n  \n If you include the line  \n  \n [!code-cpp[NVC_MFCCObjectSample#14](../../mfc/codesnippet/cpp/diagnostic-services_1.cpp)]  \n  \n in a program module, then subsequent calls to `AfxCheckMemory` show the filename and line number where the memory was allocated.  \n  \n> [!NOTE]\n>  If your module contains one or more implementations of serializable classes, then you must put the `#define` line after the last `IMPLEMENT_SERIAL` macro call.  \n  \n This function works only in the Debug version of MFC.  \n  \n### Example  \n [!code-cpp[NVC_MFCCObjectSample#26](../../mfc/codesnippet/cpp/diagnostic-services_11.cpp)]  \n  \n##  <a name=\"afxdump__mfc_\"></a>  AfxDump (MFC)  \n Call this function while in the debugger to dump the state of an object while debugging.  \n  \n```   \nvoid AfxDump(const CObject* pOb); \n```  \n  \n### Parameters  \n `pOb`  \n A pointer to an object of a class derived from `CObject`.  \n  \n### Remarks  \n **AfxDump** calls an object's `Dump` member function and sends the information to the location specified by the `afxDump` variable. **AfxDump** is available only in the Debug version of MFC.  \n  \n Your program code should not call **AfxDump**, but should instead call the `Dump` member function of the appropriate object.  \n  \n##  <a name=\"afxdumpstack\"></a>  AfxDumpStack  \n This global function can be used to generate an image of the current stack.  \n  \n```   \nvoid AFXAPI AfxDumpStack(DWORD dwTarget = AFX_STACK_DUMP_TARGET_DEFAULT); \n```  \n  \n### Parameters  \n *dwTarget*  \n Indicates the target of the dump output. Possible values, which can be combined using the bitwise-OR ( **&#124;**) operator, are as follows:  \n  \n- **AFX_STACK_DUMP_TARGET_TRACE** Sends output by means of the [TRACE](#trace) macro. The **TRACE** macro generates output in debug builds only; it generates no output in release builds. Also, **TRACE** can be redirected to other targets besides the debugger.  \n  \n- **AFX_STACK_DUMP_TARGET_DEFAULT** Sends dump output to the default target. For a debug build, output goes to the **TRACE** macro. In a release build, output goes to the Clipboard.  \n  \n- **AFX_STACK_DUMP_TARGET_CLIPBOARD** Sends output to the Clipboard only. The data is placed on the Clipboard as plain text using the **CF_TEXT** Clipboard format.  \n  \n- **AFX_STACK_DUMP_TARGET_BOTH** Sends output to the Clipboard and to the **TRACE** macro, simultaneously.  \n  \n- **AFX_STACK_DUMP_TARGET_ODS** Sends output directly to the debugger by means of the Win32 function **OutputDebugString()**. This option will generate debugger output in both debug and release builds when a debugger is attached to the process. **AFX_STACK_DUMP_TARGET_ODS** always reaches the debugger (if it is attached) and cannot be redirected.  \n  \n### Remarks  \n The example below reflects a single line of the output generated from calling `AfxDumpStack` from a button handler in an MFC dialog application:  \n  \n `=== begin AfxDumpStack output ===`  \n  \n `00427D55: DUMP2\\DEBUG\\DUMP2.EXE! void AfxDumpStack(unsigned long) + 181 bytes`  \n  \n `0040160B: DUMP2\\DEBUG\\DUMP2.EXE! void CDump2Dlg::OnClipboard(void) + 14 bytes`  \n  \n `0044F884: DUMP2\\DEBUG\\DUMP2.EXE! int _AfxDispatchCmdMsg(class CCmdTarget *,`  \n  \n `unsigned int,int,void ( CCmdTarget::*)(void),void *,unsigned int,struct AFX_CMDHANDLE`  \n  \n `0044FF7B: DUMP2\\DEBUG\\DUMP2.EXE! virtual int CCmdTarget::OnCmdMsg(unsigned`  \n  \n `int,int,void *,struct AFX_CMDHANDLERINFO *) + 626 bytes`  \n  \n `00450C71: DUMP2\\DEBUG\\DUMP2.EXE! virtual int CDialog::OnCmdMsg(unsigned`  \n  \n `int,int,void *,struct AFX_CMDHANDLERINFO *) + 36 bytes`  \n  \n `00455B27: DUMP2\\DEBUG\\DUMP2.EXE! virtual int CWnd::OnCommand(unsigned`  \n  \n `int,long) + 312 bytes`  \n  \n `00454D3D: DUMP2\\DEBUG\\DUMP2.EXE! virtual int CWnd::OnWndMsg(unsigned`  \n  \n `int,unsigned int,long,long *) + 83 bytes`  \n  \n `00454CC0: DUMP2\\DEBUG\\DUMP2.EXE! virtual long CWnd::WindowProc(unsigned`  \n  \n `int,unsigned int,long) + 46 bytes`  \n  \n `004528D9: DUMP2\\DEBUG\\DUMP2.EXE! long AfxCallWndProc(class CWnd *,struct`  \n  \n `HWND__ *,unsigned int,unsigned int,long) + 237 bytes`  \n  \n `00452D34: DUMP2\\DEBUG\\DUMP2.EXE! long AfxWndProc(struct HWND__ *,unsigned`  \n  \n `int,unsigned int,long) + 129 bytes`  \n  \n `BFF73663: WINDOWS\\SYSTEM\\KERNEL32.DLL! ThunkConnect32 + 2148 bytes`  \n  \n `BFF928E0: WINDOWS\\SYSTEM\\KERNEL32.DLL! UTUnRegister + 2492 bytes`  \n  \n `=== end AfxDumpStack() output ===`  \n  \n Each line in the output above indicates the address of the last function call, the full path name of the module that contains the function call, and the function prototype called. If the function call on the stack does not happen at the exact address of the function, an offset of bytes is shown.  \n  \n For example, the following table describes the first line of the above output:  \n  \n|Output|Description|  \n|------------|-----------------|  \n|`00427D55:`|The return address of the last function call.|  \n|`DUMP2\\DEBUG\\DUMP2.EXE!`|The full path name of the module that contains the function call.|  \n|`void AfxDumpStack(unsigned long)`|The function prototype called.|  \n|`+ 181 bytes`|The offset in bytes from the address of the function prototype (in this case, `void AfxDumpStack(unsigned long)`) to the return address (in this case, `00427D55`).|  \n  \n `AfxDumpStack` is available in debug and nondebug versions of the MFC libraries; however, the function is always linked statically, even when your executable file uses MFC in a shared DLL. In shared-library implementations, the function is found in the MFCS42.LIB library (and its variants).  \n  \n To use this function successfully:  \n  \n-   The file IMAGEHLP.DLL must be on your path. If you do not have this DLL, the function will display an error message. See [Image Help Library](http://msdn.microsoft.com/library/windows/desktop/ms680321) for information on the function set provided by IMAGEHLP.  \n  \n-   The modules that have frames on the stack must include debugging information. If they do not contain debugging information, the function will still generate a stack trace, but the trace will be less detailed.  \n  \n##  <a name=\"afxenablememoryleakdump\"></a>  AfxEnableMemoryLeakDump  \n Enables and disables the memory leak dump in the `AFX_DEBUG_STATE` destructor.  \n  \n```  \nBOOL AFXAPI AfxEnableMemoryLeakDump(BOOL bDump);\n```  \n  \n### Parameters  \n [in] `bDump`  \n `TRUE` indicates the memory leak dump is enabled; `FALSE` indicates the memory leak dump is disabled.  \n  \n### Return Value  \n The previous value for this flag.  \n  \n### Remarks  \n When an application unloads the MFC library, the MFC library checks for memory leaks. At this point, any memory leaks are reported to the user through the **Debug** window of [!INCLUDE[vsprvs](../../assembler/masm/includes/vsprvs_md.md)].  \n  \n If your application loads another library before the MFC library, some memory allocations in that library will be incorrectly reported as memory leaks. False memory leaks can cause your application to close slowly as the MFC library reports them. In this case, use `AfxEnableMemoryLeakDump` to disable the memory leak dump.  \n  \n> [!NOTE]\n>  If you use this method to turn off the memory leak dump, you will not receive reports of valid memory leaks in your application. You should only use this method if you are confident that the memory leak report contains false memory leaks.  \n  \n##  <a name=\"afxenablememorytracking\"></a>  AfxEnableMemoryTracking  \n Diagnostic memory tracking is normally enabled in the Debug version of MFC.  \n  \n```   \nBOOL AfxEnableMemoryTracking(BOOL bTrack); \n```  \n  \n### Parameters  \n *bTrack*  \n Setting this value to **TRUE** turns on memory tracking; **FALSE** turns it off.  \n  \n### Return Value  \n The previous setting of the tracking-enable flag.  \n  \n### Remarks  \n Use this function to disable tracking on sections of your code that you know are allocating blocks correctly.  \n  \n For more information on `AfxEnableMemoryTracking`, see [Debugging MFC Applications](/visualstudio/debugger/mfc-debugging-techniques).  \n  \n> [!NOTE]\n>  This function works only in the Debug version of MFC.  \n  \n### Example  \n [!code-cpp[NVC_MFC_Utilities#24](../../mfc/codesnippet/cpp/diagnostic-services_12.cpp)]  \n  \n##  <a name=\"afxismemoryblock\"></a>  AfxIsMemoryBlock  \n Tests a memory address to make sure it represents a currently active memory block that was allocated by the diagnostic version of **new**.  \n  \n```   \nBOOL AfxIsMemoryBlock(\n    const void* p,  \n    UINT nBytes,  \n    LONG* plRequestNumber = NULL); \n```  \n  \n### Parameters  \n `p`  \n Points to the block of memory to be tested.  \n  \n `nBytes`  \n Contains the length of the memory block in bytes.  \n  \n `plRequestNumber`  \n Points to a **long** integer that will be filled in with the memory block's allocation sequence number, or zero if it does not represent a currently active memory block.  \n  \n### Return Value  \n Nonzero if the memory block is currently allocated and the length is correct; otherwise 0.  \n  \n### Remarks  \n It also checks the specified size against the original allocated size. If the function returns nonzero, the allocation sequence number is returned in `plRequestNumber`. This number represents the order in which the block was allocated relative to all other **new** allocations.  \n  \n### Example  \n [!code-cpp[NVC_MFC_Utilities#27](../../mfc/codesnippet/cpp/diagnostic-services_13.cpp)]  \n  \n##  <a name=\"afxisvalidaddress\"></a>  AfxIsValidAddress  \n Tests any memory address to ensure that it is contained entirely within the program's memory space.  \n  \n```   \nBOOL AfxIsValidAddress(\n    const void* lp,  \n    UINT nBytes,  \n    BOOL bReadWrite = TRUE); \n```  \n  \n### Parameters  \n `lp`  \n Points to the memory address to be tested.  \n  \n `nBytes`  \n Contains the number of bytes of memory to be tested.  \n  \n *bReadWrite*  \n Specifies whether the memory is both for reading and writing ( **TRUE**) or just reading ( **FALSE**).  \n  \n### Return Value  \n In debug builds, nonzero if the specified memory block is contained entirely within the program's memory space; otherwise 0.  \n  \n In non-debug builds, nonzero if `lp` is not NULL; otherwise 0.  \n  \n### Remarks  \n The address is not restricted to blocks allocated by **new**.  \n  \n### Example  \n [!code-cpp[NVC_MFC_Utilities#28](../../mfc/codesnippet/cpp/diagnostic-services_14.cpp)]  \n  \n##  <a name=\"afxisvalidstring\"></a>  AfxIsValidString  \n Use this function to determine whether a pointer to a string is valid.  \n  \n```   \nBOOL  AfxIsValidString(\n    LPCSTR lpsz,  \n    int nLength = -1); \n```  \n  \n### Parameters  \n `lpsz`  \n The pointer to test.  \n  \n `nLength`  \n Specifies the length of the string to be tested, in bytes. A value of â€“1 indicates that the string will be null-terminated.  \n  \n### Return Value  \n In debug builds, nonzero if the specified pointer points to a string of the specified size; otherwise 0.  \n  \n In non-debug builds, nonzero if `lpsz` is not NULL; otherwise 0.  \n  \n### Example  \n [!code-cpp[NVC_MFC_Utilities#29](../../mfc/codesnippet/cpp/diagnostic-services_15.cpp)]  \n  \n##  <a name=\"afxsetallochook\"></a>  AfxSetAllocHook  \n Sets a hook that enables calling of the specified function before each memory block is allocated.  \n  \n```   \nAFX_ALLOC_HOOK AfxSetAllocHook(AFX_ALLOC_HOOK pfnAllocHook); \n```  \n  \n### Parameters  \n *pfnAllocHook*  \n Specifies the name of the function to call. See the Remarks for the prototype of an allocation function.  \n  \n### Return Value  \n Nonzero if you want to permit the allocation; otherwise 0.  \n  \n### Remarks  \n The Microsoft Foundation Class Library debug-memory allocator can call a user-defined hook function to allow the user to monitor a memory allocation and to control whether the allocation is permitted. Allocation hook functions are prototyped as follows:  \n  \n **BOOL AFXAPI AllocHook( size_t** `nSize`**, BOOL** `bObject`**, LONG** `lRequestNumber` **);**  \n  \n `nSize`  \n The size of the proposed memory allocation.  \n  \n `bObject`  \n **TRUE** if the allocation is for a `CObject`-derived object; otherwise **FALSE**.  \n  \n `lRequestNumber`  \n The memory allocation's sequence number.  \n  \n Note that the **AFXAPI** calling convention implies that the callee must remove the parameters from the stack.  \n  \n##  <a name=\"afxdoforallclasses\"></a>  AfxDoForAllClasses  \n Calls the specified iteration function for all serializable `CObject`-derived classes in the application's memory space.  \n  \n```   \nvoid  \nAFXAPI AfxDoForAllClasses(\n    void (* pfn)(const CRuntimeClass* pClass, void* pContext),  \n    void* pContext); \n```  \n  \n### Parameters  \n `pfn`  \n Points to an iteration function to be called for each class. The function arguments are a pointer to a `CRuntimeClass` object and a void pointer to extra data that the caller supplies to the function.  \n  \n `pContext`  \n Points to optional data that the caller can supply to the iteration function. This pointer can be **NULL**.  \n  \n### Remarks  \n Serializable `CObject`-derived classes are classes derived using the `DECLARE_SERIAL` macro. The pointer that is passed to `AfxDoForAllClasses` in `pContext` is passed to the specified iteration function each time it is called.  \n  \n> [!NOTE]\n>  This function works only in the Debug version of MFC.  \n  \n### Example  \n [!code-cpp[NVC_MFCCollections#113](../../mfc/codesnippet/cpp/diagnostic-services_16.cpp)]  \n  \n [!code-cpp[NVC_MFCCollections#114](../../mfc/codesnippet/cpp/diagnostic-services_17.cpp)]  \n  \n##  <a name=\"afxdoforallobjects\"></a>  AfxDoForAllObjects  \n Executes the specified iteration function for all objects derived from `CObject` that have been allocated with **new**.  \n  \n```   \nvoid AfxDoForAllObjects(\n    void (* pfn)(CObject* pObject, void* pContext),  \n    void* pContext); \n```  \n  \n### Parameters  \n `pfn`  \n Points to an iteration function to execute for each object. The function arguments are a pointer to a `CObject` and a void pointer to extra data that the caller supplies to the function.  \n  \n `pContext`  \n Points to optional data that the caller can supply to the iteration function. This pointer can be **NULL**.  \n  \n### Remarks  \n Stack, global, or embedded objects are not enumerated. The pointer passed to `AfxDoForAllObjects` in `pContext` is passed to the specified iteration function each time it is called.  \n  \n> [!NOTE]\n>  This function works only in the Debug version of MFC.  \n  \n### Example  \n [!code-cpp[NVC_MFCCollections#115](../../mfc/codesnippet/cpp/diagnostic-services_18.cpp)]  \n  \n [!code-cpp[NVC_MFCCollections#116](../../mfc/codesnippet/cpp/diagnostic-services_19.cpp)]  \n  \n## See Also  \n [Macros and Globals](../../mfc/reference/mfc-macros-and-globals.md)"}