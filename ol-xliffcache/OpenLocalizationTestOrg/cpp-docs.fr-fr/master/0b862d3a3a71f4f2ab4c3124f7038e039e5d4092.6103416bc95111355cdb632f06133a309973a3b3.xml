{"nodes":[{"pos":[12,64],"content":"Memory Management: Frame Allocation | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Memory Management: Frame Allocation | Microsoft Docs","pos":[0,52]}]},{"content":"Memory Management: Frame Allocation","pos":[1041,1076]},{"content":"Allocation on the frame takes its name from the \"stack frame\" that is set up whenever a function is called.","pos":[1077,1184]},{"content":"The stack frame is an area of memory that temporarily holds the arguments to the function as well as any variables that are defined local to the function.","pos":[1185,1339]},{"content":"Frame variables are often called \"automatic\" variables because the compiler automatically allocates the space for them.","pos":[1340,1459]},{"content":"There are two key characteristics of frame allocations.","pos":[1466,1521]},{"content":"First, when you define a local variable, enough space is allocated on the stack frame to hold the entire variable, even if it is a large array or data structure.","pos":[1522,1683]},{"content":"Second, frame variables are automatically deleted when they go out of scope:","pos":[1684,1760]},{"pos":[1778,1798],"content":"NVC_MFC_Utilities#10"},{"content":"For local function variables, this scope transition happens when the function exits, but the scope of a frame variable can be smaller than a function if nested braces are used.","pos":[1872,2048]},{"content":"This automatic deletion of frame variables is very important.","pos":[2049,2110]},{"content":"In the case of simple primitive types (such as <ph id=\"ph1\">`int`</ph> or <bpt id=\"p1\">**</bpt>byte<ept id=\"p1\">**</ept>), arrays, or data structures, the automatic deletion simply reclaims the memory used by the variable.","pos":[2111,2277],"source":" In the case of simple primitive types (such as `int` or **byte**), arrays, or data structures, the automatic deletion simply reclaims the memory used by the variable."},{"content":"Since the variable has gone out of scope, it cannot be accessed anyway.","pos":[2278,2349]},{"content":"In the case of C++ objects, however, the process of automatic deletion is a bit more complicated.","pos":[2350,2447]},{"content":"When an object is defined as a frame variable, its constructor is automatically invoked at the point where the definition is encountered.","pos":[2454,2591]},{"content":"When the object goes out of scope, its destructor is automatically invoked before the memory for the object is reclaimed.","pos":[2592,2713]},{"content":"This automatic construction and destruction can be very handy, but you must be aware of the automatic calls, especially to the destructor.","pos":[2714,2852]},{"content":"The key advantage of allocating objects on the frame is that they are automatically deleted.","pos":[2859,2951]},{"content":"When you allocate your objects on the frame, you don't have to worry about forgotten objects causing memory leaks.","pos":[2952,3066]},{"content":"(For details on memory leaks, see the article <bpt id=\"p1\">[</bpt>Detecting Memory Leaks in MFC<ept id=\"p1\">](http://msdn.microsoft.com/en-us/29ee8909-96e9-4246-9332-d3a8aa8d4658)</ept>.) A disadvantage of frame allocation is that frame variables cannot be used outside their scope.","pos":[3067,3311],"source":" (For details on memory leaks, see the article [Detecting Memory Leaks in MFC](http://msdn.microsoft.com/en-us/29ee8909-96e9-4246-9332-d3a8aa8d4658).) A disadvantage of frame allocation is that frame variables cannot be used outside their scope."},{"content":"Another factor in choosing frame allocation versus heap allocation is that for large structures and objects, it is often better to use the heap instead of the stack for storage since stack space is often limited.","pos":[3312,3524]},{"content":"See Also","pos":[3533,3541]},{"content":"Memory Management","pos":[3546,3563]}],"content":"---\ntitle: \"Memory Management: Frame Allocation | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"memory leaks, frame allocation\"\n  - \"memory, detecting leaks\"\n  - \"memory, reclaiming\"\n  - \"memory allocation, frames\"\n  - \"frame variables, automatic deletion of\"\n  - \"scope, frame variables\"\n  - \"heap allocation, vs. frame allocation\"\n  - \"variables, frame variables\"\n  - \"memory leaks, detecting\"\n  - \"memory, releasing\"\n  - \"stack frames\"\n  - \"memory leaks, allocating objects on the frame\"\n  - \"detecting memory leaks\"\n  - \"frame allocation\"\n  - \"frame variables\"\nms.assetid: 945a211a-6f4f-4679-bb6a-b0f2a0d4a6c1\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Memory Management: Frame Allocation\nAllocation on the frame takes its name from the \"stack frame\" that is set up whenever a function is called. The stack frame is an area of memory that temporarily holds the arguments to the function as well as any variables that are defined local to the function. Frame variables are often called \"automatic\" variables because the compiler automatically allocates the space for them.  \n  \n There are two key characteristics of frame allocations. First, when you define a local variable, enough space is allocated on the stack frame to hold the entire variable, even if it is a large array or data structure. Second, frame variables are automatically deleted when they go out of scope:  \n  \n [!code-cpp[NVC_MFC_Utilities#10](../mfc/codesnippet/cpp/memory-management-frame-allocation_1.cpp)]  \n  \n For local function variables, this scope transition happens when the function exits, but the scope of a frame variable can be smaller than a function if nested braces are used. This automatic deletion of frame variables is very important. In the case of simple primitive types (such as `int` or **byte**), arrays, or data structures, the automatic deletion simply reclaims the memory used by the variable. Since the variable has gone out of scope, it cannot be accessed anyway. In the case of C++ objects, however, the process of automatic deletion is a bit more complicated.  \n  \n When an object is defined as a frame variable, its constructor is automatically invoked at the point where the definition is encountered. When the object goes out of scope, its destructor is automatically invoked before the memory for the object is reclaimed. This automatic construction and destruction can be very handy, but you must be aware of the automatic calls, especially to the destructor.  \n  \n The key advantage of allocating objects on the frame is that they are automatically deleted. When you allocate your objects on the frame, you don't have to worry about forgotten objects causing memory leaks. (For details on memory leaks, see the article [Detecting Memory Leaks in MFC](http://msdn.microsoft.com/en-us/29ee8909-96e9-4246-9332-d3a8aa8d4658).) A disadvantage of frame allocation is that frame variables cannot be used outside their scope. Another factor in choosing frame allocation versus heap allocation is that for large structures and objects, it is often better to use the heap instead of the stack for storage since stack space is often limited.  \n  \n## See Also  \n [Memory Management](../mfc/memory-management.md)\n\n"}