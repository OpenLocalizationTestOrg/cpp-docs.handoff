{"nodes":[{"pos":[12,77],"content":"How to: Organize Project Output Files for Builds | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Organize Project Output Files for Builds | Microsoft Docs","pos":[0,65]}]},{"content":"How to: Organize Project Output Files for Builds","pos":[641,689]},{"content":"This topic describes best practices for organizing project output files.","pos":[690,762]},{"content":"Build errors can occur when you set up project output files incorrectly.","pos":[763,835]},{"content":"This topic also outlines the advantages and disadvantages of each alternative for organizing your project output files.","pos":[836,955]},{"content":"Referencing CLR Assemblies","pos":[964,990]},{"content":"To reference assemblies with #using","pos":[1001,1036]},{"content":"You can reference an assembly directly from your code by using the #using directive, such as <ph id=\"ph1\">`#using &lt;System.Data.dll&gt;`</ph>.","pos":[1046,1166],"source":"You can reference an assembly directly from your code by using the #using directive, such as `#using <System.Data.dll>`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>#using Directive<ept id=\"p1\">](../preprocessor/hash-using-directive-cpp.md)</ept>.","pos":[1167,1257],"source":" For more information, see [#using Directive](../preprocessor/hash-using-directive-cpp.md)."},{"content":"The file specified can be a .dll, .exe, .netmodule, or .obj, as long as it is in MSIL.","pos":[1268,1354]},{"content":"The referenced component can be built in any language.","pos":[1355,1409]},{"content":"Using this option, you will have access to Intellisense since the metadata will be extracted from the MSIL.","pos":[1410,1517]},{"content":"The file in question must be in the path for the project; otherwise, the project will not compile and Intellisense will not be available.","pos":[1518,1655]},{"content":"An easy way to determine whether the file is in the path is to right-click on the #using line and choose the <bpt id=\"p1\">**</bpt>Open document<ept id=\"p1\">**</ept> command.","pos":[1656,1791],"source":" An easy way to determine whether the file is in the path is to right-click on the #using line and choose the **Open document** command."},{"content":"You will be notified if the file cannot be found.","pos":[1792,1841]},{"content":"If you do not want to put the full path to the file, you can use the <bpt id=\"p1\">**</bpt>/AI<ept id=\"p1\">**</ept> compiler option to edit the search path for #using references.","pos":[1852,1991],"source":"If you do not want to put the full path to the file, you can use the **/AI** compiler option to edit the search path for #using references."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>/AI (Specify Metadata Directories)<ept id=\"p1\">](../build/reference/ai-specify-metadata-directories.md)</ept>.","pos":[1992,2110],"source":" For more information, see [/AI (Specify Metadata Directories)](../build/reference/ai-specify-metadata-directories.md)."},{"content":"To reference assemblies with /FU","pos":[2121,2153]},{"content":"Instead of referencing an assembly directly from a code file as described above, you can use the <bpt id=\"p1\">**</bpt>/FU<ept id=\"p1\">**</ept> compiler option.","pos":[2163,2284],"source":"Instead of referencing an assembly directly from a code file as described above, you can use the **/FU** compiler option."},{"content":"The advantage to this method is that you do not have to add a separate #using statement to every file that references a given assembly.","pos":[2285,2420]},{"content":"To set this option, open the <bpt id=\"p1\">**</bpt>Properties Pages<ept id=\"p1\">**</ept> for the project.","pos":[2431,2497],"source":"To set this option, open the **Properties Pages** for the project."},{"content":"Expand the <bpt id=\"p1\">**</bpt>Configuration Properties<ept id=\"p1\">**</ept> node, and then expand the <bpt id=\"p2\">**</bpt>C/C++<ept id=\"p2\">**</ept> node and select <bpt id=\"p3\">**</bpt>Advanced<ept id=\"p3\">**</ept>.","pos":[2498,2603],"source":" Expand the **Configuration Properties** node, and then expand the **C/C++** node and select **Advanced**."},{"content":"Add the desired assemblies next to <bpt id=\"p1\">**</bpt>Force #using<ept id=\"p1\">**</ept>.","pos":[2604,2656],"source":" Add the desired assemblies next to **Force #using**."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>/FU (Name Forced #using File)<ept id=\"p1\">](../build/reference/fu-name-forced-hash-using-file.md)</ept>.","pos":[2657,2769],"source":" For more information, see [/FU (Name Forced #using File)](../build/reference/fu-name-forced-hash-using-file.md)."},{"content":"To reference assemblies with Add New Reference","pos":[2780,2826]},{"content":"This is the easiest way to use CLR assemblies.","pos":[2836,2882]},{"content":"First, make sure the project is compiled with the <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> compiler option.","pos":[2883,2958],"source":" First, make sure the project is compiled with the **/clr** compiler option."},{"content":"Then, right click the project from the <bpt id=\"p1\">**</bpt>Solution Explorer<ept id=\"p1\">**</ept> and select <bpt id=\"p2\">**</bpt>Add<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>References<ept id=\"p3\">**</ept>.","pos":[2959,3055],"source":" Then, right click the project from the **Solution Explorer** and select **Add**, **References**."},{"content":"The <bpt id=\"p1\">**</bpt>Property Pages<ept id=\"p1\">**</ept> dialog will appear.","pos":[3056,3098],"source":" The **Property Pages** dialog will appear."},{"content":"From the <bpt id=\"p1\">**</bpt>Property Pages<ept id=\"p1\">**</ept> dialog, select <bpt id=\"p2\">**</bpt>Add New Reference<ept id=\"p2\">**</ept>.","pos":[3108,3173],"source":"From the **Property Pages** dialog, select **Add New Reference**."},{"content":"A dialog will appear listing all .NET, COM, and other assemblies available in the current project.","pos":[3174,3272]},{"content":"Select the desired assembly and click <bpt id=\"p1\">**</bpt>OK<ept id=\"p1\">**</ept>.","pos":[3273,3318],"source":" Select the desired assembly and click **OK**."},{"content":"Once a project reference is set, the corresponding dependencies are automatically handled.","pos":[3329,3419]},{"content":"In addition, since metadata is part of an assembly, there is no need to add a header file or prototype the elements that are being used from managed assemblies.","pos":[3420,3580]},{"content":"Referencing Native DLLs or Static Libraries","pos":[3589,3632]},{"content":"To reference native DLLs or static libraries","pos":[3643,3687]},{"content":"Reference the appropriate header file in your code using the #include directive.","pos":[3697,3777]},{"content":"The header file must be in the include path or part of the current project.","pos":[3778,3853]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>#include Directive (C/C++)<ept id=\"p1\">](../preprocessor/hash-include-directive-c-cpp.md)</ept>.","pos":[3854,3958],"source":" For more information, see [#include Directive (C/C++)](../preprocessor/hash-include-directive-c-cpp.md)."},{"content":"You can also set project dependencies.","pos":[3968,4006]},{"content":"Setting project dependencies guarantees two things.","pos":[4007,4058]},{"content":"First, it ensures that projects are built in the right order so that a project can always find the dependent files it needs.","pos":[4059,4183]},{"content":"Second, it implicitly adds the dependent project’s output directory to the path so that files can be found easily at link-time.","pos":[4184,4311]},{"content":"To deploy the application, you will need to place the DLL in an appropriate place.","pos":[4321,4403]},{"content":"This can be one of the following:","pos":[4404,4437]},{"content":"The same path as the executable.","pos":[4451,4483]},{"pos":[4497,4561],"content":"Anywhere in the system path (the <bpt id=\"p1\">**</bpt>path<ept id=\"p1\">**</ept> environment variable).","source":"Anywhere in the system path (the **path** environment variable)."},{"content":"In the side-by-side assembly.","pos":[4575,4604]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Building C/C++ Side-by-side Assemblies<ept id=\"p1\">](../build/building-c-cpp-side-by-side-assemblies.md)</ept>.","pos":[4605,4724],"source":" For more information, see [Building C/C++ Side-by-side Assemblies](../build/building-c-cpp-side-by-side-assemblies.md)."},{"content":"Working with Multiple Projects","pos":[4733,4763]},{"content":"By default, projects are built such that all output files are created in a subdirectory of the project directory.","pos":[4767,4880]},{"content":"The directory is named based on the build configuration (e.g. Debug or Release).","pos":[4881,4961]},{"content":"In order for sibling projects to refer to each other, each project must explicitly add the other project output directories to their path in order for linking to succeed.","pos":[4962,5132]},{"content":"This is done automatically when you set the project dependencies.","pos":[5133,5198]},{"content":"However, if you do not use dependencies, you must carefully handle this because builds can become very difficult to manage.","pos":[5199,5322]},{"content":"For example, when a project has Debug and Release configurations, and it includes an external library from a sibling project, it should use a different library file depending on which configuration is being built.","pos":[5323,5536]},{"content":"Thus, hard-coding these paths can be tricky.","pos":[5537,5581]},{"content":"All essential output files (such as executables, incremental linker files, and PDB files) are copied into a common solution directory.","pos":[5588,5722]},{"content":"Thus, when working with a solution that contains a number of C++ projects with equivalent configurations, all the output files are centralized for simplified linking and deployment.","pos":[5723,5904]},{"content":"You can be sure that their application/library will work as expected if they keep those files together (since the files are guaranteed to be in the path).","pos":[5905,6059]},{"content":"The location of output files can be a major issue when deploying to a production environment.","pos":[6066,6159]},{"content":"While running projects in the IDE, the paths to included libraries are not necessarily the same as in the production environment.","pos":[6160,6289]},{"content":"For example, if you have <ph id=\"ph1\">`#using \"../../lib/debug/mylib.dll\"`</ph> in your code but then deploy mylib.dll into a different relative position, the application will fail at runtime.","pos":[6290,6464],"source":" For example, if you have `#using \"../../lib/debug/mylib.dll\"` in your code but then deploy mylib.dll into a different relative position, the application will fail at runtime."},{"content":"To prevent this, you should avoid using relative paths in #include statements in your code.","pos":[6465,6556]},{"content":"It is better to ensure that the necessary files are in the project build path and similarly ensuring that the corresponding production files are properly placed.","pos":[6557,6718]},{"content":"How to specify where output files go","pos":[6729,6765]},{"content":"The location of project output settings can be found in the project's <bpt id=\"p1\">**</bpt>Property Pages<ept id=\"p1\">**</ept>.","pos":[6775,6864],"source":"The location of project output settings can be found in the project's **Property Pages**."},{"content":"Expand the node next to <bpt id=\"p1\">**</bpt>Configuration Properties<ept id=\"p1\">**</ept> and select <bpt id=\"p2\">**</bpt>General<ept id=\"p2\">**</ept>.","pos":[6865,6941],"source":" Expand the node next to **Configuration Properties** and select **General**."},{"content":"The output location is specified next to <bpt id=\"p1\">**</bpt>Output Directory<ept id=\"p1\">**</ept>.","pos":[6942,7004],"source":" The output location is specified next to **Output Directory**."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>General Property Page (Project)<ept id=\"p1\">](../ide/general-property-page-project.md)</ept>.","pos":[7005,7106],"source":" For more information, see [General Property Page (Project)](../ide/general-property-page-project.md)."},{"content":"See Also","pos":[7115,7123]},{"content":"Visual C++ Project Types","pos":[7128,7152]}],"content":"---\ntitle: \"How to: Organize Project Output Files for Builds | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"Visual C++, output files\"\n  - \"output files, organizing\"\nms.assetid: 521d95ea-2dcc-4da0-b5eb-ac3e57941446\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Organize Project Output Files for Builds\nThis topic describes best practices for organizing project output files. Build errors can occur when you set up project output files incorrectly. This topic also outlines the advantages and disadvantages of each alternative for organizing your project output files.  \n  \n## Referencing CLR Assemblies  \n  \n#### To reference assemblies with #using  \n  \n1.  You can reference an assembly directly from your code by using the #using directive, such as `#using <System.Data.dll>`. For more information, see [#using Directive](../preprocessor/hash-using-directive-cpp.md).  \n  \n     The file specified can be a .dll, .exe, .netmodule, or .obj, as long as it is in MSIL. The referenced component can be built in any language. Using this option, you will have access to Intellisense since the metadata will be extracted from the MSIL. The file in question must be in the path for the project; otherwise, the project will not compile and Intellisense will not be available. An easy way to determine whether the file is in the path is to right-click on the #using line and choose the **Open document** command. You will be notified if the file cannot be found.  \n  \n     If you do not want to put the full path to the file, you can use the **/AI** compiler option to edit the search path for #using references. For more information, see [/AI (Specify Metadata Directories)](../build/reference/ai-specify-metadata-directories.md).  \n  \n#### To reference assemblies with /FU  \n  \n1.  Instead of referencing an assembly directly from a code file as described above, you can use the **/FU** compiler option. The advantage to this method is that you do not have to add a separate #using statement to every file that references a given assembly.  \n  \n     To set this option, open the **Properties Pages** for the project. Expand the **Configuration Properties** node, and then expand the **C/C++** node and select **Advanced**. Add the desired assemblies next to **Force #using**. For more information, see [/FU (Name Forced #using File)](../build/reference/fu-name-forced-hash-using-file.md).  \n  \n#### To reference assemblies with Add New Reference  \n  \n1.  This is the easiest way to use CLR assemblies. First, make sure the project is compiled with the **/clr** compiler option. Then, right click the project from the **Solution Explorer** and select **Add**, **References**. The **Property Pages** dialog will appear.  \n  \n2.  From the **Property Pages** dialog, select **Add New Reference**. A dialog will appear listing all .NET, COM, and other assemblies available in the current project. Select the desired assembly and click **OK**.  \n  \n     Once a project reference is set, the corresponding dependencies are automatically handled. In addition, since metadata is part of an assembly, there is no need to add a header file or prototype the elements that are being used from managed assemblies.  \n  \n## Referencing Native DLLs or Static Libraries  \n  \n#### To reference native DLLs or static libraries  \n  \n1.  Reference the appropriate header file in your code using the #include directive. The header file must be in the include path or part of the current project. For more information, see [#include Directive (C/C++)](../preprocessor/hash-include-directive-c-cpp.md).  \n  \n2.  You can also set project dependencies. Setting project dependencies guarantees two things. First, it ensures that projects are built in the right order so that a project can always find the dependent files it needs. Second, it implicitly adds the dependent project’s output directory to the path so that files can be found easily at link-time.  \n  \n3.  To deploy the application, you will need to place the DLL in an appropriate place. This can be one of the following:  \n  \n    1.  The same path as the executable.  \n  \n    2.  Anywhere in the system path (the **path** environment variable).  \n  \n    3.  In the side-by-side assembly. For more information, see [Building C/C++ Side-by-side Assemblies](../build/building-c-cpp-side-by-side-assemblies.md).  \n  \n## Working with Multiple Projects  \n By default, projects are built such that all output files are created in a subdirectory of the project directory. The directory is named based on the build configuration (e.g. Debug or Release). In order for sibling projects to refer to each other, each project must explicitly add the other project output directories to their path in order for linking to succeed. This is done automatically when you set the project dependencies. However, if you do not use dependencies, you must carefully handle this because builds can become very difficult to manage. For example, when a project has Debug and Release configurations, and it includes an external library from a sibling project, it should use a different library file depending on which configuration is being built. Thus, hard-coding these paths can be tricky.  \n  \n All essential output files (such as executables, incremental linker files, and PDB files) are copied into a common solution directory. Thus, when working with a solution that contains a number of C++ projects with equivalent configurations, all the output files are centralized for simplified linking and deployment. You can be sure that their application/library will work as expected if they keep those files together (since the files are guaranteed to be in the path).  \n  \n The location of output files can be a major issue when deploying to a production environment. While running projects in the IDE, the paths to included libraries are not necessarily the same as in the production environment. For example, if you have `#using \"../../lib/debug/mylib.dll\"` in your code but then deploy mylib.dll into a different relative position, the application will fail at runtime. To prevent this, you should avoid using relative paths in #include statements in your code. It is better to ensure that the necessary files are in the project build path and similarly ensuring that the corresponding production files are properly placed.  \n  \n#### How to specify where output files go  \n  \n1.  The location of project output settings can be found in the project's **Property Pages**. Expand the node next to **Configuration Properties** and select **General**. The output location is specified next to **Output Directory**. For more information, see [General Property Page (Project)](../ide/general-property-page-project.md).  \n  \n## See Also  \n [Visual C++ Project Types](../ide/visual-cpp-project-types.md)"}