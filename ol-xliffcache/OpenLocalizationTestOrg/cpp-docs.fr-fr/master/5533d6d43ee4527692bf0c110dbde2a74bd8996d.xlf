<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5533d6d43ee4527692bf0c110dbde2a74bd8996d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\nonstandard-behavior.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b1d975f53576f5717f40055104c7d68bca59837</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d8c4e79ff4ccf2b59df350aeec1f38dc7fa12f8</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Nonstandard Behavior | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Nonstandard Behavior</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The following sections list some of the places where the Visual C++ implementation of C++ does not comply with the C++ standard.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The section numbers given below refer to the section numbers in the C++ 11 standard (ISO/IEC 14882:2011(E)).</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The list of compiler limits that differ from those defined in the C++ standard is given in <bpt id="p1">[</bpt>Compiler Limits<ept id="p1">](../cpp/compiler-limits.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Covariant Return Types</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Virtual base classes are not supported as covariant return types when the virtual function has a variable number of arguments.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This does not comply with section 10.3, paragraph 7 of the C++ ISO specification.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The following sample does not compile, giving compiler error <bpt id="p1">[</bpt>C2688<ept id="p1">](../error-messages/compiler-errors-2/compiler-error-c2688.md)</ept></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Binding Nondependent Names in Templates</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The Visual C++ compiler does not currently support binding nondependent names when initially parsing a template.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This does not comply with section 14.6.3 of the C++ ISO specification.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This can cause overloads declared after the template (but before the template is instantiated) to be seen.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Function Exception Specifiers</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Function exception specifiers other than <ph id="ph1">`throw()`</ph> are parsed but not used.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This does not comply with section 15.4 of the ISO C++ specification.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information on exception specifications, see <bpt id="p1">[</bpt>Exception Specifications<ept id="p1">](../cpp/exception-specifications-throw-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>char_traits::eof()</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The C++ standard states that <bpt id="p1">[</bpt>char_traits::eof<ept id="p1">](http://msdn.microsoft.com/Library/3eef7544-48e4-49c0-9501-d3c5a8e43a70)</ept> must not correspond to a valid <ph id="ph1">`char_type`</ph> value.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The Visual C++ compiler enforces this constraint for type <ph id="ph1">`char`</ph>, but not for type <ph id="ph2">`wchar_t`</ph>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This does not comply with the requirement in Table 62 in section 12.1.1 of the C++ ISO specification.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The example below demonstrates this.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Storage Location of Objects</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The C++ standard (section 1.8 paragraph 6) requires complete C++ objects to have unique storage locations.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>However with Visual C++, there are cases where types without data members will share a storage location with other types for the lifetime of the object.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>