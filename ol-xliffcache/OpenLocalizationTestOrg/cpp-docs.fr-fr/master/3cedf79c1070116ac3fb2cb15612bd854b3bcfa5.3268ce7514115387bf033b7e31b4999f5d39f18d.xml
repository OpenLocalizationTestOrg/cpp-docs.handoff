{"nodes":[{"pos":[12,56],"content":"Asynchronous Agents Library | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Asynchronous Agents Library | Microsoft Docs","pos":[0,44]}]},{"content":"Asynchronous Agents Library","pos":[640,667]},{"content":"The Asynchronous Agents Library (or just <bpt id=\"p1\">*</bpt>Agents Library<ept id=\"p1\">*</ept>) provides a programming model that lets you increase the robustness of concurrency-enabled application development.","pos":[668,841],"source":"The Asynchronous Agents Library (or just *Agents Library*) provides a programming model that lets you increase the robustness of concurrency-enabled application development."},{"content":"The Agents Library is a C++ template library that promotes an actor-based programming model and in-process message passing for coarse-grained dataflow and pipelining tasks.","pos":[842,1014]},{"content":"The Agents Library builds on the scheduling and resource management components of the Concurrency Runtime.","pos":[1015,1121]},{"content":"Programming Model","pos":[1130,1147]},{"content":"The Agents Library provides alternatives to shared state by letting you connect isolated components through an asynchronous communication model that is based on dataflow instead of control flow.","pos":[1151,1345]},{"content":"<bpt id=\"p1\">*</bpt>Dataflow<ept id=\"p1\">*</ept> refers to a programming model where computations are made when all required data is available; <bpt id=\"p2\">*</bpt>control flow<ept id=\"p2\">*</ept> refers to a programming model where computations are made in a predetermined order.","pos":[1346,1550],"source":"*Dataflow* refers to a programming model where computations are made when all required data is available; *control flow* refers to a programming model where computations are made in a predetermined order."},{"pos":[1557,1727],"content":"The dataflow programming model is related to the concept of <bpt id=\"p1\">*</bpt>message passing<ept id=\"p1\">*</ept>, where independent components of a program communicate with one another by sending messages.","source":"The dataflow programming model is related to the concept of *message passing*, where independent components of a program communicate with one another by sending messages."},{"content":"The Agents Library is composed of three components: <bpt id=\"p1\">*</bpt>asynchronous agents<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>asynchronous message blocks<ept id=\"p2\">*</ept>, and <bpt id=\"p3\">*</bpt>message-passing functions<ept id=\"p3\">*</ept>.","pos":[1734,1872],"source":"The Agents Library is composed of three components: *asynchronous agents*, *asynchronous message blocks*, and *message-passing functions*."},{"content":"Agents maintain state, and use message blocks and message-passing functions to communicate with one another and with external components.","pos":[1873,2010]},{"content":"Message-passing functions enable agents to send and receive messages to and from the external components.","pos":[2011,2116]},{"content":"Asynchronous message blocks hold messages and enable agents to communicate in a synchronized manner.","pos":[2117,2217]},{"content":"The following illustration shows how two agents use message blocks and message-passing functions to communicate.","pos":[2224,2336]},{"content":"In this illustration, <ph id=\"ph1\">`agent1`</ph> sends a message to <ph id=\"ph2\">`agent2`</ph> by using the <bpt id=\"p1\">[</bpt>concurrency::send<ept id=\"p1\">](reference/concurrency-namespace-functions.md#send)</ept> function and a <bpt id=\"p2\">[</bpt>concurrency::unbounded_buffer<ept id=\"p2\">](reference/unbounded-buffer-class.md)</ept> object.","pos":[2337,2571],"source":" In this illustration, `agent1` sends a message to `agent2` by using the [concurrency::send](reference/concurrency-namespace-functions.md#send) function and a [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) object."},{"content":"uses the <bpt id=\"p1\">[</bpt>concurrency::receive<ept id=\"p1\">](reference/concurrency-namespace-functions.md#receive)</ept> function to read the message.","pos":[2581,2696],"source":" uses the [concurrency::receive](reference/concurrency-namespace-functions.md#receive) function to read the message."},{"content":"uses the same method to send a message to <ph id=\"ph1\">`agent1`</ph>.","pos":[2706,2757],"source":" uses the same method to send a message to `agent1`."},{"content":"Dashed arrows represent the flow of data between agents.","pos":[2758,2814]},{"content":"Solid arrows connect the agents to the message blocks that they write to or read from.","pos":[2815,2901]},{"content":"The components of the Agents Library","pos":[2910,2946]},{"content":"A code example that implements this illustration is shown later in this topic.","pos":[3025,3103]},{"content":"The agent programming model has several advantages over other concurrency and synchronization mechanisms, for example, events.","pos":[3110,3236]},{"content":"One advantage is that by using message passing to transmit state changes between objects, you can isolate access to shared resources, and thereby improve scalability.","pos":[3237,3403]},{"content":"An advantage to message passing is that it ties synchronization to data instead of tying it to an external synchronization object.","pos":[3404,3534]},{"content":"This simplifies data transmission among components and can eliminate programming errors in your applications.","pos":[3535,3644]},{"content":"When to Use the Agents Library","pos":[3653,3683]},{"content":"Use the Agents library when you have multiple operations that must communicate with one another asynchronously.","pos":[3687,3798]},{"content":"Message blocks and message-passing functions let you write parallel applications without requiring synchronization mechanisms such as locks.","pos":[3799,3939]},{"content":"This lets you focus on application logic.","pos":[3940,3981]},{"content":"The agent programming model is often used to create <bpt id=\"p1\">*</bpt>data pipelines<ept id=\"p1\">*</ept> or <bpt id=\"p2\">*</bpt>networks<ept id=\"p2\">*</ept>.","pos":[3988,4071],"source":"The agent programming model is often used to create *data pipelines* or *networks*."},{"content":"A data pipeline is a series of components, each of which performs a specific task that contributes to a larger goal.","pos":[4072,4188]},{"content":"Every component in a dataflow pipeline performs work when it receives a message from another component.","pos":[4189,4292]},{"content":"The result of that work is passed to other components in the pipeline or network.","pos":[4293,4374]},{"content":"The components can use more fine-grained concurrency functionality from other libraries, for example, the <bpt id=\"p1\">[</bpt>Parallel Patterns Library (PPL)<ept id=\"p1\">](../../parallel/concrt/parallel-patterns-library-ppl.md)</ept>.","pos":[4375,4571],"source":" The components can use more fine-grained concurrency functionality from other libraries, for example, the [Parallel Patterns Library (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)."},{"content":"Example","pos":[4580,4587]},{"content":"The following example implements the illustration shown earlier in this topic.","pos":[4591,4669]},{"pos":[4687,4708],"content":"concrt-basic-agents#1"},{"content":"This example produces the following output:","pos":[4790,4833]},{"content":"The following topics describe the functionality used in this example.","pos":[4975,5044]},{"content":"Related Topics","pos":[5053,5067]},{"content":"Asynchronous Agents","pos":[5072,5091]},{"content":"Describes the role of asynchronous agents in solving larger computing tasks.","pos":[5142,5218]},{"content":"Asynchronous Message Blocks","pos":[5226,5253]},{"content":"Describes the various message block types that are provided by the Agents Library.","pos":[5312,5394]},{"content":"Message Passing Functions","pos":[5402,5427]},{"content":"Describes the various message passing routines that are provided by the Agents Library.","pos":[5484,5571]},{"content":"How to: Implement Various Producer-Consumer Patterns","pos":[5579,5631]},{"content":"Describes how to implement the producer-consumer pattern in your application.","pos":[5714,5791]},{"content":"How to: Provide Work Functions to the call and transformer Classes","pos":[5799,5865]},{"content":"Illustrates several ways to provide work functions to the <bpt id=\"p1\">[</bpt>concurrency::call<ept id=\"p1\">](../../parallel/concrt/reference/call-class.md)</ept> and <bpt id=\"p2\">[</bpt>concurrency::transformer<ept id=\"p2\">](../../parallel/concrt/reference/transformer-class.md)</ept> classes.","pos":[5962,6180],"source":" Illustrates several ways to provide work functions to the [concurrency::call](../../parallel/concrt/reference/call-class.md) and [concurrency::transformer](../../parallel/concrt/reference/transformer-class.md) classes."},{"content":"How to: Use transformer in a Data Pipeline","pos":[6188,6230]},{"content":"Shows how to use the <bpt id=\"p1\">[</bpt>concurrency::transformer<ept id=\"p1\">](../../parallel/concrt/reference/transformer-class.md)</ept> class in a data pipeline.","pos":[6303,6430],"source":" Shows how to use the [concurrency::transformer](../../parallel/concrt/reference/transformer-class.md) class in a data pipeline."},{"content":"How to: Select Among Completed Tasks","pos":[6438,6474]},{"content":"Shows how to use the <bpt id=\"p1\">[</bpt>concurrency::choice<ept id=\"p1\">](../../parallel/concrt/reference/choice-class.md)</ept> and <bpt id=\"p2\">[</bpt>concurrency::join<ept id=\"p2\">](../../parallel/concrt/reference/join-class.md)</ept> classes to select the first task to complete a search algorithm.","pos":[6541,6768],"source":" Shows how to use the [concurrency::choice](../../parallel/concrt/reference/choice-class.md) and [concurrency::join](../../parallel/concrt/reference/join-class.md) classes to select the first task to complete a search algorithm."},{"content":"How to: Send a Message at a Regular Interval","pos":[6776,6820]},{"content":"Shows how to use the <bpt id=\"p1\">[</bpt>concurrency::timer<ept id=\"p1\">](../../parallel/concrt/reference/timer-class.md)</ept> class to send a message at a regular interval.","pos":[6895,7031],"source":" Shows how to use the [concurrency::timer](../../parallel/concrt/reference/timer-class.md) class to send a message at a regular interval."},{"content":"How to: Use a Message Block Filter","pos":[7039,7073]},{"content":"Demonstrates how to use a filter to enable an asynchronous message block to accept or reject messages.","pos":[7138,7240]},{"content":"Parallel Patterns Library (PPL)","pos":[7248,7279]},{"content":"Describes how to use various parallel patterns, such as parallel algorithms, in your applications.","pos":[7340,7438]},{"content":"Concurrency Runtime","pos":[7446,7465]},{"content":"Describes the Concurrency Runtime, which simplifies parallel programming, and contains links to related topics.","pos":[7516,7627]}],"content":"---\ntitle: \"Asynchronous Agents Library | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"Agents Library\"\n  - \"Asynchronous Agents Library\"\nms.assetid: d2a72a31-8ba6-4220-ad7a-e403a6acaa42\ncaps.latest.revision: 33\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Asynchronous Agents Library\nThe Asynchronous Agents Library (or just *Agents Library*) provides a programming model that lets you increase the robustness of concurrency-enabled application development. The Agents Library is a C++ template library that promotes an actor-based programming model and in-process message passing for coarse-grained dataflow and pipelining tasks. The Agents Library builds on the scheduling and resource management components of the Concurrency Runtime.  \n  \n## Programming Model  \n The Agents Library provides alternatives to shared state by letting you connect isolated components through an asynchronous communication model that is based on dataflow instead of control flow. *Dataflow* refers to a programming model where computations are made when all required data is available; *control flow* refers to a programming model where computations are made in a predetermined order.  \n  \n The dataflow programming model is related to the concept of *message passing*, where independent components of a program communicate with one another by sending messages.  \n  \n The Agents Library is composed of three components: *asynchronous agents*, *asynchronous message blocks*, and *message-passing functions*. Agents maintain state, and use message blocks and message-passing functions to communicate with one another and with external components. Message-passing functions enable agents to send and receive messages to and from the external components. Asynchronous message blocks hold messages and enable agents to communicate in a synchronized manner.  \n  \n The following illustration shows how two agents use message blocks and message-passing functions to communicate. In this illustration, `agent1` sends a message to `agent2` by using the [concurrency::send](reference/concurrency-namespace-functions.md#send) function and a [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) object. `agent2` uses the [concurrency::receive](reference/concurrency-namespace-functions.md#receive) function to read the message. `agent2` uses the same method to send a message to `agent1`. Dashed arrows represent the flow of data between agents. Solid arrows connect the agents to the message blocks that they write to or read from.  \n  \n ![The components of the Agents Library](../../parallel/concrt/media/agent_librarycomp.png \"agent_librarycomp\")  \n  \n A code example that implements this illustration is shown later in this topic.  \n  \n The agent programming model has several advantages over other concurrency and synchronization mechanisms, for example, events. One advantage is that by using message passing to transmit state changes between objects, you can isolate access to shared resources, and thereby improve scalability. An advantage to message passing is that it ties synchronization to data instead of tying it to an external synchronization object. This simplifies data transmission among components and can eliminate programming errors in your applications.  \n  \n## When to Use the Agents Library  \n Use the Agents library when you have multiple operations that must communicate with one another asynchronously. Message blocks and message-passing functions let you write parallel applications without requiring synchronization mechanisms such as locks. This lets you focus on application logic.  \n  \n The agent programming model is often used to create *data pipelines* or *networks*. A data pipeline is a series of components, each of which performs a specific task that contributes to a larger goal. Every component in a dataflow pipeline performs work when it receives a message from another component. The result of that work is passed to other components in the pipeline or network. The components can use more fine-grained concurrency functionality from other libraries, for example, the [Parallel Patterns Library (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md).  \n  \n## Example  \n The following example implements the illustration shown earlier in this topic.  \n  \n [!code-cpp[concrt-basic-agents#1](../../parallel/concrt/codesnippet/cpp/asynchronous-agents-library_1.cpp)]  \n  \n This example produces the following output:  \n  \n```Output  \nagent1: sending request...  \nagent2: received 'request'.  \nagent2: sending response...  \nagent1: received '42'.  \n```  \n  \n The following topics describe the functionality used in this example.  \n  \n## Related Topics  \n [Asynchronous Agents](../../parallel/concrt/asynchronous-agents.md)  \n Describes the role of asynchronous agents in solving larger computing tasks.  \n  \n [Asynchronous Message Blocks](../../parallel/concrt/asynchronous-message-blocks.md)  \n Describes the various message block types that are provided by the Agents Library.  \n  \n [Message Passing Functions](../../parallel/concrt/message-passing-functions.md)  \n Describes the various message passing routines that are provided by the Agents Library.  \n  \n [How to: Implement Various Producer-Consumer Patterns](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md)  \n Describes how to implement the producer-consumer pattern in your application.  \n  \n [How to: Provide Work Functions to the call and transformer Classes](../../parallel/concrt/how-to-provide-work-functions-to-the-call-and-transformer-classes.md)  \n Illustrates several ways to provide work functions to the [concurrency::call](../../parallel/concrt/reference/call-class.md) and [concurrency::transformer](../../parallel/concrt/reference/transformer-class.md) classes.  \n  \n [How to: Use transformer in a Data Pipeline](../../parallel/concrt/how-to-use-transformer-in-a-data-pipeline.md)  \n Shows how to use the [concurrency::transformer](../../parallel/concrt/reference/transformer-class.md) class in a data pipeline.  \n  \n [How to: Select Among Completed Tasks](../../parallel/concrt/how-to-select-among-completed-tasks.md)  \n Shows how to use the [concurrency::choice](../../parallel/concrt/reference/choice-class.md) and [concurrency::join](../../parallel/concrt/reference/join-class.md) classes to select the first task to complete a search algorithm.  \n  \n [How to: Send a Message at a Regular Interval](../../parallel/concrt/how-to-send-a-message-at-a-regular-interval.md)  \n Shows how to use the [concurrency::timer](../../parallel/concrt/reference/timer-class.md) class to send a message at a regular interval.  \n  \n [How to: Use a Message Block Filter](../../parallel/concrt/how-to-use-a-message-block-filter.md)  \n Demonstrates how to use a filter to enable an asynchronous message block to accept or reject messages.  \n  \n [Parallel Patterns Library (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)  \n Describes how to use various parallel patterns, such as parallel algorithms, in your applications.  \n  \n [Concurrency Runtime](../../parallel/concrt/concurrency-runtime.md)  \n Describes the Concurrency Runtime, which simplifies parallel programming, and contains links to related topics.\n\n"}