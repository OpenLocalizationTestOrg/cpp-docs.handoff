{"nodes":[{"pos":[12,45],"content":"Updating Rowsets | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Updating Rowsets | Microsoft Docs","pos":[0,33]}]},{"content":"Updating Rowsets","pos":[643,659]},{"content":"A very basic database operation is to update, or write data to, the data store.","pos":[660,739]},{"content":"In OLE DB, the update mechanism is simple: your consumer application sets the values of bound data members and then writes those values to the rowset; the consumer then requests that the provider update the data store.","pos":[740,958]},{"content":"Consumers can perform the following kinds of updates on rowset data: setting column values within a row, inserting a row, and deleting a row.","pos":[965,1106]},{"content":"To perform these operations, the OLE DB Template class <bpt id=\"p1\">[</bpt>CRowset<ept id=\"p1\">](../../data/oledb/crowset-class.md)</ept> implements the <bpt id=\"p2\">[</bpt>IRowsetChange<ept id=\"p2\">](https://msdn.microsoft.com/en-us/library/ms715790.aspx)</ept> interface and overrides the following interface methods:","pos":[1107,1350],"source":" To perform these operations, the OLE DB Template class [CRowset](../../data/oledb/crowset-class.md) implements the [IRowsetChange](https://msdn.microsoft.com/en-us/library/ms715790.aspx) interface and overrides the following interface methods:"},{"pos":[1360,1494],"content":"<bpt id=\"p1\">[</bpt>SetData<ept id=\"p1\">](../../data/oledb/crowset-setdata.md)</ept> changes column values in a row of a rowset; it is equivalent to the SQL UPDATE command.","source":"[SetData](../../data/oledb/crowset-setdata.md) changes column values in a row of a rowset; it is equivalent to the SQL UPDATE command."},{"pos":[1504,1621],"content":"<bpt id=\"p1\">[</bpt>Insert<ept id=\"p1\">](../../data/oledb/crowset-insert.md)</ept> inserts a row into a rowset; it is equivalent to the SQL INSERT command.","source":"[Insert](../../data/oledb/crowset-insert.md) inserts a row into a rowset; it is equivalent to the SQL INSERT command."},{"pos":[1631,1747],"content":"<bpt id=\"p1\">[</bpt>Delete<ept id=\"p1\">](../../data/oledb/crowset-delete.md)</ept> deletes rows from a rowset; it is equivalent to the SQL DELETE command.","source":"[Delete](../../data/oledb/crowset-delete.md) deletes rows from a rowset; it is equivalent to the SQL DELETE command."},{"content":"Supporting Update Operations","pos":[1756,1784]},{"content":"When you create a consumer with the ATL OLE DB Consumer Wizard, you can support the update operations by selecting one or more of the three check boxes <bpt id=\"p1\">**</bpt>Change<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Insert<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>Delete<ept id=\"p3\">**</ept>.","pos":[1788,1979],"source":"When you create a consumer with the ATL OLE DB Consumer Wizard, you can support the update operations by selecting one or more of the three check boxes **Change**, **Insert**, and **Delete**."},{"content":"If you select these, the wizard modifies the code appropriately to support the type of changes you choose.","pos":[1980,2086]},{"content":"However, if you do not use the wizard, you need to set the following rowset properties to <ph id=\"ph1\">`VARIANT_TRUE`</ph> to support updates:","pos":[2087,2211],"source":" However, if you do not use the wizard, you need to set the following rowset properties to `VARIANT_TRUE` to support updates:"},{"pos":[2221,2291],"content":"<bpt id=\"p1\">**</bpt>DBPROPVAL_UP_CHANGE<ept id=\"p1\">**</ept> allows you to change the data values in a row.","source":"**DBPROPVAL_UP_CHANGE** allows you to change the data values in a row."},{"pos":[2301,2352],"content":"<bpt id=\"p1\">**</bpt>DBPROPVAL_UP_INSERT<ept id=\"p1\">**</ept> allows you to insert a row.","source":"**DBPROPVAL_UP_INSERT** allows you to insert a row."},{"pos":[2362,2413],"content":"<bpt id=\"p1\">**</bpt>DBPROPVAL_UP_DELETE<ept id=\"p1\">**</ept> allows you to delete a row.","source":"**DBPROPVAL_UP_DELETE** allows you to delete a row."},{"content":"You set the properties as follows:","pos":[2420,2454]},{"content":"Change, insert, or delete operations might fail if one or more columns is not writable.","pos":[2659,2746]},{"content":"Modify your cursor map to correct this.","pos":[2747,2786]},{"content":"Setting Data in Rows","pos":[2795,2815]},{"content":"<bpt id=\"p1\">[</bpt>CRowset::SetData<ept id=\"p1\">](../../data/oledb/crowset-setdata.md)</ept> sets data values in one or more columns of the current row.","pos":[2819,2934],"source":"[CRowset::SetData](../../data/oledb/crowset-setdata.md) sets data values in one or more columns of the current row."},{"content":"The following code sets the values of data members bound to the columns \"Name\" and \"Units in Stock\" of the table Products and then calls <ph id=\"ph1\">`SetData`</ph> to write those values to the 100th row of the rowset:","pos":[2935,3135],"source":" The following code sets the values of data members bound to the columns \"Name\" and \"Units in Stock\" of the table Products and then calls `SetData` to write those values to the 100th row of the rowset:"},{"content":"Inserting Rows into Rowsets","pos":[3785,3812]},{"content":"<bpt id=\"p1\">[</bpt>CRowset::Insert<ept id=\"p1\">](../../data/oledb/crowset-insert.md)</ept> creates and initializes a new row using data from the accessor.","pos":[3816,3933],"source":"[CRowset::Insert](../../data/oledb/crowset-insert.md) creates and initializes a new row using data from the accessor."},{"content":"<bpt id=\"p1\">**</bpt>Insert<ept id=\"p1\">**</ept> creates an entirely new row after the current row; you need to specify whether to increment the current row to the next row or leave it unchanged.","pos":[3934,4091],"source":"**Insert** creates an entirely new row after the current row; you need to specify whether to increment the current row to the next row or leave it unchanged."},{"content":"You do this by setting the <bpt id=\"p1\">*</bpt>bGetRow<ept id=\"p1\">*</ept> parameter:","pos":[4092,4139],"source":" You do this by setting the *bGetRow* parameter:"},{"pos":[4222,4355],"content":"<bpt id=\"p1\">**</bpt>false<ept id=\"p1\">**</ept> (the default value) specifies that the current row increment to the next row (in which case it points to the inserted row).","source":"**false** (the default value) specifies that the current row increment to the next row (in which case it points to the inserted row)."},{"pos":[4365,4424],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> specifies that the current row remain where it is.","source":"**true** specifies that the current row remain where it is."},{"content":"The following code sets the values of data members bound to the columns of the table Products and then calls <bpt id=\"p1\">**</bpt>Insert<ept id=\"p1\">**</ept> to insert a new row with those values after the 100th row of the rowset.","pos":[4431,4623],"source":"The following code sets the values of data members bound to the columns of the table Products and then calls **Insert** to insert a new row with those values after the 100th row of the rowset."},{"content":"It is recommended that you set all column values to avoid undefined data in the new row:","pos":[4624,4712]},{"pos":[6514,6601],"content":"For a more detailed example, see <bpt id=\"p1\">[</bpt>CRowset::Insert<ept id=\"p1\">](../../data/oledb/crowset-insert.md)</ept>.","source":"For a more detailed example, see [CRowset::Insert](../../data/oledb/crowset-insert.md)."},{"pos":[6608,6818],"content":"For more information about setting the status and length data members, see <bpt id=\"p1\">[</bpt>Field Status Data Members in Wizard-Generated Accessors<ept id=\"p1\">](../../data/oledb/field-status-data-members-in-wizard-generated-accessors.md)</ept>.","source":"For more information about setting the status and length data members, see [Field Status Data Members in Wizard-Generated Accessors](../../data/oledb/field-status-data-members-in-wizard-generated-accessors.md)."},{"content":"Deleting Rows from Rowsets","pos":[6827,6853]},{"content":"<bpt id=\"p1\">[</bpt>CRowset::Delete<ept id=\"p1\">](../../data/oledb/crowset-delete.md)</ept> deletes the current row from the rowset.","pos":[6857,6951],"source":"[CRowset::Delete](../../data/oledb/crowset-delete.md) deletes the current row from the rowset."},{"content":"The following code calls <bpt id=\"p1\">**</bpt>Delete<ept id=\"p1\">**</ept> to remove the 100th row of the rowset:","pos":[6952,7026],"source":" The following code calls **Delete** to remove the 100th row of the rowset:"},{"content":"Immediate and Deferred Updates","pos":[7442,7472]},{"content":"Unless you specify otherwise, calls to the <ph id=\"ph1\">`SetData`</ph>, <bpt id=\"p1\">**</bpt>Insert<ept id=\"p1\">**</ept>, and <bpt id=\"p2\">**</bpt>Delete<ept id=\"p2\">**</ept> methods update the data store immediately.","pos":[7476,7599],"source":"Unless you specify otherwise, calls to the `SetData`, **Insert**, and **Delete** methods update the data store immediately."},{"content":"You can, however, defer updates so that the consumer stores all changes in a local cache and then transfers them to the data store when you call one of the following update methods:","pos":[7600,7781]},{"pos":[7791,7945],"content":"<bpt id=\"p1\">[</bpt>CRowset::Update<ept id=\"p1\">](../../data/oledb/crowset-update.md)</ept> transfers any pending changes made to the current row since the last fetch or <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept> call on it.","source":"[CRowset::Update](../../data/oledb/crowset-update.md) transfers any pending changes made to the current row since the last fetch or **Update** call on it."},{"pos":[7955,8108],"content":"<bpt id=\"p1\">[</bpt>CRowset::UpdateAll<ept id=\"p1\">](../../data/oledb/crowset-updateall.md)</ept> transfers any pending changes made to all rows since the last fetch or <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept> call on it.","source":"[CRowset::UpdateAll](../../data/oledb/crowset-updateall.md) transfers any pending changes made to all rows since the last fetch or **Update** call on it."},{"pos":[8115,8324],"content":"Note that update, as used by the update methods, has the specific meaning of making changes on command and is not to be confused with the SQL UPDATE command (<ph id=\"ph1\">`SetData`</ph> is equivalent to the SQL UPDATE command).","source":"Note that update, as used by the update methods, has the specific meaning of making changes on command and is not to be confused with the SQL UPDATE command (`SetData` is equivalent to the SQL UPDATE command)."},{"content":"Deferred updates are useful, for example, in situations such as a series of banking transactions; if one transaction is canceled, you can undo the change, because you do not send the series of changes until after the last one is committed.","pos":[8331,8570]},{"content":"Also, the provider can bundle the changes into one network call, which is more efficient.","pos":[8571,8660]},{"pos":[8667,8821],"content":"To support deferred updates, you must set the <bpt id=\"p1\">**</bpt>DBPROP_IRowsetChange<ept id=\"p1\">**</ept> property in addition to the properties described in \"Supporting Update Operations\":","source":"To support deferred updates, you must set the **DBPROP_IRowsetChange** property in addition to the properties described in \"Supporting Update Operations\":"},{"content":"When you call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`UpdateAll`</ph>, the methods transfer changes from the local cache to the data store and then wipe out the local cache.","pos":[8896,9039],"source":"When you call **Update** or `UpdateAll`, the methods transfer changes from the local cache to the data store and then wipe out the local cache."},{"content":"Because update transfers changes only for the current row, it is important that your application keep track of which row to update and when to update it.","pos":[9040,9193]},{"content":"The following example shows how to update two consecutive rows:","pos":[9194,9257]},{"content":"To ensure that pending changes are transferred, you should call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> before moving to another row.","pos":[10351,10455],"source":"To ensure that pending changes are transferred, you should call **Update** before moving to another row."},{"content":"However, when this is tedious or inefficient, for example, when your application needs to update hundreds of rows, you can use <ph id=\"ph1\">`UpdateAll`</ph> to update all the rows at once.","pos":[10456,10626],"source":" However, when this is tedious or inefficient, for example, when your application needs to update hundreds of rows, you can use `UpdateAll` to update all the rows at once."},{"content":"For example, if the first <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> call were missing from the above code, row 100 would remain unchanged, while row 101 would be changed.","pos":[10633,10772],"source":"For example, if the first **Update** call were missing from the above code, row 100 would remain unchanged, while row 101 would be changed."},{"content":"After that point, your application would either have to call <ph id=\"ph1\">`UpdateAll`</ph> or move back to row 100 and call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> for that row to be updated.","pos":[10773,10917],"source":" After that point, your application would either have to call `UpdateAll` or move back to row 100 and call **Update** for that row to be updated."},{"content":"Finally, one main reason to defer changes is to be able to undo them.","pos":[10924,10993]},{"content":"Calling <bpt id=\"p1\">[</bpt>CRowset::Undo<ept id=\"p1\">](../../data/oledb/crowset-undo.md)</ept> rolls back the state of the local change cache to the state of the data store before any pending changes were made.","pos":[10994,11167],"source":" Calling [CRowset::Undo](../../data/oledb/crowset-undo.md) rolls back the state of the local change cache to the state of the data store before any pending changes were made."},{"content":"It is important to note that <bpt id=\"p1\">**</bpt>Undo<ept id=\"p1\">**</ept> does not roll back the state of the local cache by one step (the state before only the latest change); instead, it clears the local cache for that row.","pos":[11168,11357],"source":" It is important to note that **Undo** does not roll back the state of the local cache by one step (the state before only the latest change); instead, it clears the local cache for that row."},{"content":"Also, <bpt id=\"p1\">**</bpt>Undo<ept id=\"p1\">**</ept> affects only the current row.","pos":[11358,11402],"source":" Also, **Undo** affects only the current row."},{"content":"See Also","pos":[11411,11419]},{"content":"Working with OLE DB Consumer Templates","pos":[11424,11462]},{"content":"CRowset Class","pos":[11529,11542]},{"content":"IRowsetChange","pos":[11584,11597]}],"content":"---\ntitle: \"Updating Rowsets | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"rowsets, updating data\"\n  - \"updating data, rowsets\"\n  - \"updating rowsets\"\n  - \"rowsets\"\nms.assetid: 39588758-5c72-4254-a10d-cc2b1f473357\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Updating Rowsets\nA very basic database operation is to update, or write data to, the data store. In OLE DB, the update mechanism is simple: your consumer application sets the values of bound data members and then writes those values to the rowset; the consumer then requests that the provider update the data store.  \n  \n Consumers can perform the following kinds of updates on rowset data: setting column values within a row, inserting a row, and deleting a row. To perform these operations, the OLE DB Template class [CRowset](../../data/oledb/crowset-class.md) implements the [IRowsetChange](https://msdn.microsoft.com/en-us/library/ms715790.aspx) interface and overrides the following interface methods:  \n  \n-   [SetData](../../data/oledb/crowset-setdata.md) changes column values in a row of a rowset; it is equivalent to the SQL UPDATE command.  \n  \n-   [Insert](../../data/oledb/crowset-insert.md) inserts a row into a rowset; it is equivalent to the SQL INSERT command.  \n  \n-   [Delete](../../data/oledb/crowset-delete.md) deletes rows from a rowset; it is equivalent to the SQL DELETE command.  \n  \n## Supporting Update Operations  \n When you create a consumer with the ATL OLE DB Consumer Wizard, you can support the update operations by selecting one or more of the three check boxes **Change**, **Insert**, and **Delete**. If you select these, the wizard modifies the code appropriately to support the type of changes you choose. However, if you do not use the wizard, you need to set the following rowset properties to `VARIANT_TRUE` to support updates:  \n  \n-   **DBPROPVAL_UP_CHANGE** allows you to change the data values in a row.  \n  \n-   **DBPROPVAL_UP_INSERT** allows you to insert a row.  \n  \n-   **DBPROPVAL_UP_DELETE** allows you to delete a row.  \n  \n You set the properties as follows:  \n  \n```  \nCDBPropSet ps(DBPROPSET_ROWSET);  \nps.AddProperty(DBPROP_IRowsetChange, true)  \nps.AddProperty(DBPROP_UPDATABILITY, DBPROPVAL_UP_CHANGE | DBPROPVAL_UP_INSERT | DBPROPVAL_UP_DELETE)  \n```  \n  \n Change, insert, or delete operations might fail if one or more columns is not writable. Modify your cursor map to correct this.  \n  \n## Setting Data in Rows  \n [CRowset::SetData](../../data/oledb/crowset-setdata.md) sets data values in one or more columns of the current row. The following code sets the values of data members bound to the columns \"Name\" and \"Units in Stock\" of the table Products and then calls `SetData` to write those values to the 100th row of the rowset:  \n  \n```  \n// Instantiate a rowset based on the user record class  \nCTable<CAccessor<CProductAccessor> > product;  \nCSession session;  \n  \n// Open the rowset and move to the 100th row  \nproduct.Open(session, \"Product\", &ps, 1);  // ps is the property set  \nproduct.MoveToBookmark(&bookmark, 0);      // Assume that bookmark is set to 100th row  \n  \n// Change the values of columns \"Name\" and \"Units in Stock\" in the current row of the Product table  \n_tcscpy_s( product.m_ProductName, product.m_sizeOfProductName,  \n           _T( \"Candle\" ) );  \nproduct.m_UnitsInStock = 10000;  \n  \n// Set the data  \nHRESULT hr = product.SetData( );  \n```  \n  \n## Inserting Rows into Rowsets  \n [CRowset::Insert](../../data/oledb/crowset-insert.md) creates and initializes a new row using data from the accessor. **Insert** creates an entirely new row after the current row; you need to specify whether to increment the current row to the next row or leave it unchanged. You do this by setting the *bGetRow* parameter:  \n  \n```  \nHRESULT Insert(int nAccessor = 0, bool bGetRow = false)  \n```  \n  \n-   **false** (the default value) specifies that the current row increment to the next row (in which case it points to the inserted row).  \n  \n-   **true** specifies that the current row remain where it is.  \n  \n The following code sets the values of data members bound to the columns of the table Products and then calls **Insert** to insert a new row with those values after the 100th row of the rowset. It is recommended that you set all column values to avoid undefined data in the new row:  \n  \n```  \n// Instantiate a rowset based on the user record class  \nCTable<CAccessor<CProductAccessor> > product;  \nCSession session;  \n  \n// Open the rowset and move to the 100th row  \nproduct.Open(session, \"Product\", &ps, 1);  // ps is the property set  \nproduct.MoveToBookmark(&bookmark, 0);      // Assume that bookmark is set to 100th row  \n  \n// Set the column values for a row of the Product table, then insert the row  \nproduct.m_ProductID = 101;  \n_tcscpy_s( product.m_ProductName, product.m_sizeOfProductName,  \n           _T( \"Candle\" ) );  \nproduct.m_SupplierID = 27857;  \nproduct.m_CategoryID = 372;  \n_tcscpy_s( product.m_QuantityPerUnit, product.m_sizeOfQuantityPerUnit,  \n           _T( \"Pack of 10\" ) );  \nproduct.m_UnitPrice = 20;  \nproduct.m_UnitsInStock = 10000;  \nproduct.m_UnitsOnOrder = 5201;  \nproduct.m_ReorderLevel = 5000;  \nproduct.m_Discontinued = false;  \n  \n// You must also initialize the status and length fields before setting/inserting data  \n// Set the column status values  \nm_dwProductIDStatus = DBSTATUS_S_OK;  \nm_dwProductNameStatus = DBSTATUS_S_OK;  \nm_dwSupplierIDStatus = DBSTATUS_S_OK;  \nm_dwCategoryIDStatus = DBSTATUS_S_OK;  \nm_dwQuantityPerUnitStatus = DBSTATUS_S_OK;  \nm_dwUnitPriceStatus = DBSTATUS_S_OK;  \nm_dwUnitsInStockStatus = DBSTATUS_S_OK;  \nm_dwUnitsOnOrderStatus = DBSTATUS_S_OK;  \nm_dwReorderLevelStatus = DBSTATUS_S_OK;  \nm_dwDiscontinuedStatus = DBSTATUS_S_OK;  \n  \n// Set the column length value for column data members that are not fixed-length types.  \n// The value should be the length of the string that you are setting.  \nm_dwProductNameLength = 6;             // \"Candle\" has 6 characters  \nm_dwQuantityPerUnitLength = 10;        // \"Pack of 10\" has 10 characters  \n  \n// Insert the data  \nHRESULT hr = product.Insert( );  \n```  \n  \n For a more detailed example, see [CRowset::Insert](../../data/oledb/crowset-insert.md).  \n  \n For more information about setting the status and length data members, see [Field Status Data Members in Wizard-Generated Accessors](../../data/oledb/field-status-data-members-in-wizard-generated-accessors.md).  \n  \n## Deleting Rows from Rowsets  \n [CRowset::Delete](../../data/oledb/crowset-delete.md) deletes the current row from the rowset. The following code calls **Delete** to remove the 100th row of the rowset:  \n  \n```  \n// Instantiate a rowset based on the user record class  \nCTable<CAccessor<CProductAccessor> > product;  \nCSession session;  \n  \n// Open the rowset and move to the 100th row  \nproduct.Open(session, \"Product\", &ps, 1);  // ps is the property set  \nproduct.MoveToBookmark(&bookmark, 0);      // Assume that bookmark is set to 100th row  \n  \n// Delete the row  \nHRESULT hr = product.Delete( );  \n```  \n  \n## Immediate and Deferred Updates  \n Unless you specify otherwise, calls to the `SetData`, **Insert**, and **Delete** methods update the data store immediately. You can, however, defer updates so that the consumer stores all changes in a local cache and then transfers them to the data store when you call one of the following update methods:  \n  \n-   [CRowset::Update](../../data/oledb/crowset-update.md) transfers any pending changes made to the current row since the last fetch or **Update** call on it.  \n  \n-   [CRowset::UpdateAll](../../data/oledb/crowset-updateall.md) transfers any pending changes made to all rows since the last fetch or **Update** call on it.  \n  \n Note that update, as used by the update methods, has the specific meaning of making changes on command and is not to be confused with the SQL UPDATE command (`SetData` is equivalent to the SQL UPDATE command).  \n  \n Deferred updates are useful, for example, in situations such as a series of banking transactions; if one transaction is canceled, you can undo the change, because you do not send the series of changes until after the last one is committed. Also, the provider can bundle the changes into one network call, which is more efficient.  \n  \n To support deferred updates, you must set the **DBPROP_IRowsetChange** property in addition to the properties described in \"Supporting Update Operations\":  \n  \n```  \npPropSet->AddProperty(DBPROP_IRowsetUpdate, true);  \n```  \n  \n When you call **Update** or `UpdateAll`, the methods transfer changes from the local cache to the data store and then wipe out the local cache. Because update transfers changes only for the current row, it is important that your application keep track of which row to update and when to update it. The following example shows how to update two consecutive rows:  \n  \n```  \n// Instantiate a rowset based on the user record class  \nCTable<CAccessor<CProductAccessor> > product;  \nCSession session;  \n  \n// Open the rowset and move to the 100th row  \nproduct.Open(session, \"Product\", &ps, 1);  // ps is the property set  \nproduct.MoveToBookmark(&bookmark, 0);      // Assume that bookmark is set to 100th row  \n  \n// Change the values of columns \"Name\" and \"Units in Stock\" in the 100th row of the Product table  \n_tcscpy_s( product.m_ProductName, product.m_sizeOfProductName,  \n           _T( \"Wick\" ) );  \nproduct.m_UnitsInStock = 10000;  \nHRESULT hr = product.SetData( );  // No changes made to row 100 yet  \nproduct.Update();                 // Update row 100 now  \n  \n// Change the values of columns \"Name\" and \"Units in Stock\" in the 101st row of the Product table  \nproduct.MoveNext( );  \n_tcscpy_s( product.m_ProductName, product.m_sizeOfProductName  \n           _T( \"Wax\" ) );  \nproduct.m_UnitsInStock = 500;  \nHRESULT hr = product.SetData( );  // No changes made to row 101 yet  \nproduct.Update();                 // Update row 101 now  \n```  \n  \n To ensure that pending changes are transferred, you should call **Update** before moving to another row. However, when this is tedious or inefficient, for example, when your application needs to update hundreds of rows, you can use `UpdateAll` to update all the rows at once.  \n  \n For example, if the first **Update** call were missing from the above code, row 100 would remain unchanged, while row 101 would be changed. After that point, your application would either have to call `UpdateAll` or move back to row 100 and call **Update** for that row to be updated.  \n  \n Finally, one main reason to defer changes is to be able to undo them. Calling [CRowset::Undo](../../data/oledb/crowset-undo.md) rolls back the state of the local change cache to the state of the data store before any pending changes were made. It is important to note that **Undo** does not roll back the state of the local cache by one step (the state before only the latest change); instead, it clears the local cache for that row. Also, **Undo** affects only the current row.  \n  \n## See Also  \n [Working with OLE DB Consumer Templates](../../data/oledb/working-with-ole-db-consumer-templates.md)   \n [CRowset Class](../../data/oledb/crowset-class.md)   \n [IRowsetChange](https://msdn.microsoft.com/en-us/library/ms715790.aspx)"}