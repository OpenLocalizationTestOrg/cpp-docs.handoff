{"nodes":[{"pos":[12,85],"content":"Module States of a Regular DLL Dynamically Linked to MFC | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Module States of a Regular DLL Dynamically Linked to MFC | Microsoft Docs","pos":[0,73]}]},{"content":"Module States of a Regular DLL Dynamically Linked to MFC","pos":[794,850]},{"content":"The ability to dynamically link a regular DLL to the MFC DLL allows some configurations that are very complicated.","pos":[851,965]},{"content":"For example, a regular DLL and the executable that uses it can both dynamically link to the MFC DLL and to any extension DLLs.","pos":[966,1092]},{"pos":[1099,1238],"content":"This configuration poses a problem with regard to the MFC global data, such as the pointer to the current <ph id=\"ph1\">`CWinApp`</ph> object and handle maps.","source":"This configuration poses a problem with regard to the MFC global data, such as the pointer to the current `CWinApp` object and handle maps."},{"content":"Before MFC version 4.0, this global data resided in the MFC DLL itself and was shared by all the modules in the process.","pos":[1245,1365]},{"content":"Because each process using a Win32 DLL gets its own copy of the DLL's data, this scheme provided an easy way to track per-process data.","pos":[1366,1501]},{"content":"Also, because the AFXDLL model presumed that there would be only one <ph id=\"ph1\">`CWinApp`</ph> object and only one set of handle maps in the process, these items could be tracked in the MFC DLL itself.","pos":[1502,1687],"source":" Also, because the AFXDLL model presumed that there would be only one `CWinApp` object and only one set of handle maps in the process, these items could be tracked in the MFC DLL itself."},{"content":"But with the ability to dynamically link a regular DLL to the MFC DLL, it is now possible to have two or more <ph id=\"ph1\">`CWinApp`</ph> objects in a process — and also two or more sets of handle maps.","pos":[1694,1878],"source":"But with the ability to dynamically link a regular DLL to the MFC DLL, it is now possible to have two or more `CWinApp` objects in a process — and also two or more sets of handle maps."},{"content":"How does MFC keep track of which ones it should be using?","pos":[1879,1936]},{"content":"The solution is to give each module (application or regular DLL) its own copy of this global state information.","pos":[1943,2054]},{"content":"Thus, a call to <bpt id=\"p1\">**</bpt>AfxGetApp<ept id=\"p1\">**</ept> in the regular DLL returns a pointer to the <ph id=\"ph1\">`CWinApp`</ph> object in the DLL, not the one in the executable.","pos":[2055,2188],"source":" Thus, a call to **AfxGetApp** in the regular DLL returns a pointer to the `CWinApp` object in the DLL, not the one in the executable."},{"content":"This per-module copy of the MFC global data is known as a module state and is described in <bpt id=\"p1\">[</bpt>MFC Tech Note 58<ept id=\"p1\">](../mfc/tn058-mfc-module-state-implementation.md)</ept>.","pos":[2189,2348],"source":" This per-module copy of the MFC global data is known as a module state and is described in [MFC Tech Note 58](../mfc/tn058-mfc-module-state-implementation.md)."},{"content":"The MFC common window procedure automatically switches to the correct module state, so you do not need to worry about it in any message handlers implemented in your regular DLL.","pos":[2355,2532]},{"content":"But when your executable calls into the regular DLL, you do need to explicitly set the current module state to the one for the DLL.","pos":[2533,2664]},{"content":"To do this, use the <bpt id=\"p1\">**</bpt>AFX_MANAGE_STATE<ept id=\"p1\">**</ept> macro in every function exported from the DLL.","pos":[2665,2752],"source":" To do this, use the **AFX_MANAGE_STATE** macro in every function exported from the DLL."},{"content":"This is done by adding the following line of code to the beginning of functions exported from the DLL:","pos":[2753,2855]},{"content":"What do you want to know more about?","pos":[2926,2962]},{"content":"Managing the state data of MFC modules","pos":[2973,3011]},{"content":"Regular DLLs dynamically linked to MFC","pos":[3073,3111]},{"content":"Extension DLLs","pos":[3175,3189]},{"content":"See Also","pos":[3236,3244]},{"content":"DLLs in Visual C++","pos":[3249,3267]}],"content":"---\ntitle: \"Module States of a Regular DLL Dynamically Linked to MFC | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"regular DLLs [C++], dynamically linked to MFC\"\n  - \"module states [C++]\"\n  - \"MFC DLLs [C++], regular DLLs\"\n  - \"module states [C++], regular DLLs dynamically linked to\"\n  - \"DLLs [C++], module states\"\nms.assetid: b4493e79-d25e-4b7f-a565-60de5b32c723\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Module States of a Regular DLL Dynamically Linked to MFC\nThe ability to dynamically link a regular DLL to the MFC DLL allows some configurations that are very complicated. For example, a regular DLL and the executable that uses it can both dynamically link to the MFC DLL and to any extension DLLs.  \n  \n This configuration poses a problem with regard to the MFC global data, such as the pointer to the current `CWinApp` object and handle maps.  \n  \n Before MFC version 4.0, this global data resided in the MFC DLL itself and was shared by all the modules in the process. Because each process using a Win32 DLL gets its own copy of the DLL's data, this scheme provided an easy way to track per-process data. Also, because the AFXDLL model presumed that there would be only one `CWinApp` object and only one set of handle maps in the process, these items could be tracked in the MFC DLL itself.  \n  \n But with the ability to dynamically link a regular DLL to the MFC DLL, it is now possible to have two or more `CWinApp` objects in a process — and also two or more sets of handle maps. How does MFC keep track of which ones it should be using?  \n  \n The solution is to give each module (application or regular DLL) its own copy of this global state information. Thus, a call to **AfxGetApp** in the regular DLL returns a pointer to the `CWinApp` object in the DLL, not the one in the executable. This per-module copy of the MFC global data is known as a module state and is described in [MFC Tech Note 58](../mfc/tn058-mfc-module-state-implementation.md).  \n  \n The MFC common window procedure automatically switches to the correct module state, so you do not need to worry about it in any message handlers implemented in your regular DLL. But when your executable calls into the regular DLL, you do need to explicitly set the current module state to the one for the DLL. To do this, use the **AFX_MANAGE_STATE** macro in every function exported from the DLL. This is done by adding the following line of code to the beginning of functions exported from the DLL:  \n  \n```  \nAFX_MANAGE_STATE(AfxGetStaticModuleState( ))  \n```  \n  \n## What do you want to know more about?  \n  \n-   [Managing the state data of MFC modules](../mfc/managing-the-state-data-of-mfc-modules.md)  \n  \n-   [Regular DLLs dynamically linked to MFC](../build/regular-dlls-dynamically-linked-to-mfc.md)  \n  \n-   [Extension DLLs](../build/extension-dlls-overview.md)  \n  \n## See Also  \n [DLLs in Visual C++](../build/dlls-in-visual-cpp.md)"}