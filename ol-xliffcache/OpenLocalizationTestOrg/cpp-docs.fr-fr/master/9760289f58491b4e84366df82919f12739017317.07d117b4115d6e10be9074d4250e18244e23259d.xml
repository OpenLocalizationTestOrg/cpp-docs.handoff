{"nodes":[{"pos":[12,48],"content":"Postfix Expressions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Postfix Expressions | Microsoft Docs","pos":[0,36]}]},{"content":"Postfix Expressions","pos":[651,670]},{"content":"Postfix expressions consist of primary expressions or expressions in which postfix operators follow a primary expression.","pos":[671,792]},{"content":"The postfix operators are listed in the following table.","pos":[793,849]},{"content":"Postfix Operators","pos":[859,876]},{"content":"Operator Name","pos":[883,896]},{"content":"Operator Notation","pos":[897,914]},{"content":"Subscript operator","pos":[968,986]},{"content":"[ ]","pos":[1020,1023]},{"content":"Function call operator","pos":[1031,1053]},{"content":"( )","pos":[1098,1101]},{"content":"Explicit type conversion operator","pos":[1109,1142]},{"pos":[1196,1215],"content":"<bpt id=\"p1\">*</bpt>type-name<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt>( )<ept id=\"p2\">**</ept>","source":"*type-name* **( )**"},{"content":"Member access operator","pos":[1221,1243]},{"content":".","pos":[1290,1291]},{"content":"or <bpt id=\"p1\">**</bpt>–&gt;<ept id=\"p1\">**</ept>","pos":[1294,1303],"source":" or **–>**"},{"content":"Postfix increment operator","pos":[1309,1335]},{"content":"Postfix decrement operator","pos":[1424,1450]},{"content":"––","pos":[1531,1533]},{"content":"The following syntax describes possible postfix expressions:","pos":[1543,1603]},{"content":"The <bpt id=\"p1\">*</bpt>postfix-expression<ept id=\"p1\">*</ept> above may be a primary expression or another postfix expression.","pos":[1902,1991],"source":"The *postfix-expression* above may be a primary expression or another postfix expression."},{"content":"See <bpt id=\"p1\">**</bpt>primary expressions<ept id=\"p1\">**</ept>.","pos":[1993,2021],"source":"  See **primary expressions**."},{"content":"Postfix expressions group left to right, thus allowing the expressions to be chained together as follows:","pos":[2023,2128]},{"content":"In the above expression, func is a primary expression, func(1) is a function postfix expression, func(1)-&gt;GetData is a postfix expression specifying a member of the class, func(1)-&gt;GetData() is another function postfix expression, and the entire expression is a postfix expression incrementing the return value of GetData.","pos":[2174,2496],"source":"In the above expression, func is a primary expression, func(1) is a function postfix expression, func(1)->GetData is a postfix expression specifying a member of the class, func(1)->GetData() is another function postfix expression, and the entire expression is a postfix expression incrementing the return value of GetData."},{"content":"The meaning of the expression as a whole is \"call func passing 1 as an argument and get a pointer to a class as a return value.","pos":[2498,2625]},{"content":"Then call GetValue() on that class, then increment the value returned.","pos":[2627,2697]},{"content":"The expressions listed above are assignment expressions, meaning that the result of these expressions must be an r-value.","pos":[2704,2825]},{"content":"The postfix expression form","pos":[2832,2859]},{"content":"indicates the invocation of the constructor.","pos":[2920,2964]},{"content":"If the simple-type-name is a fundamental type, the expression list must be a single expression, and this expression indicates a cast of the expression's value to the fundamental type.","pos":[2966,3149]},{"content":"This type of cast expression mimics a constructor.","pos":[3151,3201]},{"content":"Because this form allows fundamental types and classes to be constructed using the same syntax, this form is especially useful when defining template classes.","pos":[3203,3361]},{"content":"The <bpt id=\"p1\">*</bpt>cast-keyword<ept id=\"p1\">*</ept> is one of <ph id=\"ph1\">`dynamic_cast`</ph>, <ph id=\"ph2\">`static_cast`</ph> or <ph id=\"ph3\">`reinterpret_cast`</ph>.","pos":[3368,3449],"source":"The *cast-keyword* is one of `dynamic_cast`, `static_cast` or `reinterpret_cast`."},{"content":"More information may be found in <bpt id=\"p1\">**</bpt>dynamic_cast<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>static_cast<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>reinterpet_cast<ept id=\"p3\">**</ept>.","pos":[3451,3542],"source":"  More information may be found in **dynamic_cast**, **static_cast** and **reinterpet_cast**."},{"content":"The <ph id=\"ph1\">`typeid`</ph> operator is considered a postfix expression.","pos":[3549,3606],"source":"The `typeid` operator is considered a postfix expression."},{"content":"See <bpt id=\"p1\">**</bpt>typeid operator<ept id=\"p1\">**</ept>.","pos":[3608,3632],"source":"  See **typeid operator**."},{"content":"Formal and actual arguments","pos":[3641,3668]},{"content":"Calling programs pass information to called functions in \"actual arguments.\"","pos":[3672,3748]},{"content":"The called functions access the information using corresponding \"formal arguments.\"","pos":[3749,3832]},{"content":"When a function is called, the following tasks are performed:","pos":[3839,3900]},{"content":"All actual arguments (those supplied by the caller) are evaluated.","pos":[3910,3976]},{"content":"There is no implied order in which these arguments are evaluated, but all arguments are evaluated and all side effects completed prior to entry to the function.","pos":[3977,4137]},{"content":"Each formal argument is initialized with its corresponding actual argument in the expression list.","pos":[4147,4245]},{"content":"(A formal argument is an argument that is declared in the function header and used in the body of a function.) Conversions are done as if by initialization — both standard and user-defined conversions are performed in converting an actual argument to the correct type.","pos":[4246,4514]},{"content":"The initialization performed is illustrated conceptually by the following code:","pos":[4515,4594]},{"content":"The conceptual initializations prior to the call are:","pos":[4737,4790]},{"content":"Note that the initialization is performed as if using the equal-sign syntax instead of the parentheses syntax.","pos":[4868,4978]},{"content":"A copy of <ph id=\"ph1\">`i`</ph> is made prior to passing the value to the function.","pos":[4979,5044],"source":" A copy of `i` is made prior to passing the value to the function."},{"content":"(For more information, see <bpt id=\"p1\">[</bpt>Initializers<ept id=\"p1\">](../cpp/initializers.md)</ept> and <bpt id=\"p2\">[</bpt>Conversions<ept id=\"p2\">](../cpp/user-defined-type-conversions-cpp.md)</ept>, <bpt id=\"p3\">[</bpt>Initialization Using Special Member Functions<ept id=\"p3\">](http://msdn.microsoft.com/en-us/82223d73-64cb-4923-b678-78f9568ff3ca)</ept>, and <bpt id=\"p4\">[</bpt>Explicit Initialization<ept id=\"p4\">](http://msdn.microsoft.com/en-us/c89724f8-ddd3-4d77-b86d-77fcd8bd8595)</ept>.","pos":[5045,5394],"source":" (For more information, see [Initializers](../cpp/initializers.md) and [Conversions](../cpp/user-defined-type-conversions-cpp.md), [Initialization Using Special Member Functions](http://msdn.microsoft.com/en-us/82223d73-64cb-4923-b678-78f9568ff3ca), and [Explicit Initialization](http://msdn.microsoft.com/en-us/c89724f8-ddd3-4d77-b86d-77fcd8bd8595)."},{"pos":[5405,5709],"content":"Therefore, if the function prototype (declaration) calls for an argument of type <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>, and if the calling program supplies an actual argument of type <ph id=\"ph1\">`int`</ph>, the actual argument is promoted using a standard type conversion to type <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> (see <bpt id=\"p3\">[</bpt>Standard Conversions<ept id=\"p3\">](../cpp/standard-conversions.md)</ept>).","source":"Therefore, if the function prototype (declaration) calls for an argument of type **long**, and if the calling program supplies an actual argument of type `int`, the actual argument is promoted using a standard type conversion to type **long** (see [Standard Conversions](../cpp/standard-conversions.md))."},{"content":"It is an error to supply an actual argument for which there is no standard or user-defined conversion to the type of the formal argument.","pos":[5720,5857]},{"content":"For actual arguments of class type, the formal argument is initialized by calling the class's constructor.","pos":[5868,5974]},{"content":"(See <bpt id=\"p1\">[</bpt>Constructors<ept id=\"p1\">](../cpp/constructors-cpp.md)</ept> for more about these special class member functions.)","pos":[5975,6076],"source":" (See [Constructors](../cpp/constructors-cpp.md) for more about these special class member functions.)"},{"content":"The function call is executed.","pos":[6086,6116]},{"content":"The following program fragment demonstrates a function call:","pos":[6123,6183]},{"pos":[6538,6874],"content":"When <ph id=\"ph1\">`func`</ph> is called from main, the formal parameter <ph id=\"ph2\">`param1`</ph> is initialized with the value of <ph id=\"ph3\">`i`</ph> (<ph id=\"ph4\">`i`</ph> is converted to type <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> to correspond to the correct type using a standard conversion), and the formal parameter <ph id=\"ph5\">`param2`</ph> is initialized with the value of <ph id=\"ph6\">`j`</ph> (<ph id=\"ph7\">`j`</ph> is converted to type <bpt id=\"p2\">**</bpt>double<ept id=\"p2\">**</ept> using a standard conversion).","source":"When `func` is called from main, the formal parameter `param1` is initialized with the value of `i` (`i` is converted to type **long** to correspond to the correct type using a standard conversion), and the formal parameter `param2` is initialized with the value of `j` (`j` is converted to type **double** using a standard conversion)."},{"content":"Treatment of argument types","pos":[6883,6910]},{"content":"Formal arguments declared as const types cannot be changed within the body of a function.","pos":[6914,7003]},{"content":"Functions can change any argument that is not of type <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>.","pos":[7004,7068],"source":" Functions can change any argument that is not of type **const**."},{"content":"However, the change is local to the function and does not affect the actual argument's value unless the actual argument was a reference to an object not of type <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>.","pos":[7069,7240],"source":" However, the change is local to the function and does not affect the actual argument's value unless the actual argument was a reference to an object not of type **const**."},{"content":"The following functions illustrate some of these concepts:","pos":[7247,7305]},{"content":"Ellipses and default arguments","pos":[7771,7801]},{"pos":[7805,7964],"content":"Functions can be declared to accept fewer arguments than specified in the function definition, using one of two methods: ellipsis (<ph id=\"ph1\">`...`</ph>) or default arguments.","source":"Functions can be declared to accept fewer arguments than specified in the function definition, using one of two methods: ellipsis (`...`) or default arguments."},{"content":"Ellipses denote that arguments may be required but that the number and types are not specified in the declaration.","pos":[7971,8085]},{"content":"This is normally poor C++ programming practice because it defeats one of the benefits of C++: type safety.","pos":[8086,8192]},{"content":"Different conversions are applied to functions declared with ellipses than to those functions for which the formal and actual argument types are known:","pos":[8193,8344]},{"pos":[8354,8460],"content":"If the actual argument is of type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>, it is promoted to type <bpt id=\"p2\">**</bpt>double<ept id=\"p2\">**</ept> prior to the function call.","source":"If the actual argument is of type **float**, it is promoted to type **double** prior to the function call."},{"pos":[8470,8620],"content":"Any signed or unsigned <ph id=\"ph1\">`char`</ph>, <bpt id=\"p1\">**</bpt>short<ept id=\"p1\">**</ept>, enumerated type, or bit field is converted to either a signed or an unsigned <ph id=\"ph2\">`int`</ph> using integral promotion.","source":"Any signed or unsigned `char`, **short**, enumerated type, or bit field is converted to either a signed or an unsigned `int` using integral promotion."},{"content":"Any argument of class type is passed by value as a data structure; the copy is created by binary copying instead of by invoking the class's copy constructor (if one exists).","pos":[8630,8803]},{"content":"Ellipses, if used, must be declared last in the argument list.","pos":[8810,8872]},{"content":"For more information about passing a variable number of arguments, see the discussion of <bpt id=\"p1\">[</bpt>va_arg, va_start, and va_list<ept id=\"p1\">](../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md)</ept> in the <bpt id=\"p2\">*</bpt>Run-Time Library Reference<ept id=\"p2\">*</ept>.","pos":[8873,9096],"source":" For more information about passing a variable number of arguments, see the discussion of [va_arg, va_start, and va_list](../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md) in the *Run-Time Library Reference*."},{"pos":[9103,9265],"content":"For information on default arguments in CLR programming, see <bpt id=\"p1\">[</bpt>Variable Argument Lists (...) (C++/CLI)<ept id=\"p1\">](../windows/variable-argument-lists-dot-dot-dot-cpp-cli.md)</ept>.","source":"For information on default arguments in CLR programming, see [Variable Argument Lists (...) (C++/CLI)](../windows/variable-argument-lists-dot-dot-dot-cpp-cli.md)."},{"content":"Default arguments enable you to specify the value an argument should assume if none is supplied in the function call.","pos":[9272,9389]},{"content":"The following code fragment shows how default arguments work.","pos":[9390,9451]},{"content":"For more information about restrictions on specifying default arguments, see <bpt id=\"p1\">[</bpt>Default Arguments<ept id=\"p1\">](../cpp/default-arguments.md)</ept>.","pos":[9452,9578],"source":" For more information about restrictions on specifying default arguments, see [Default Arguments](../cpp/default-arguments.md)."},{"content":"The preceding program declares a function, <ph id=\"ph1\">`print`</ph>, that takes two arguments.","pos":[10226,10303],"source":"The preceding program declares a function, `print`, that takes two arguments."},{"content":"However, the second argument, <ph id=\"ph1\">`terminator`</ph>, has a default value, <ph id=\"ph2\">`\"\\n\"`</ph>.","pos":[10304,10376],"source":" However, the second argument, `terminator`, has a default value, `\"\\n\"`."},{"content":"In <bpt id=\"p1\">**</bpt>main<ept id=\"p1\">**</ept>, the first two calls to <ph id=\"ph1\">`print`</ph> allow the default second argument to supply a new line to terminate the printed string.","pos":[10377,10508],"source":" In **main**, the first two calls to `print` allow the default second argument to supply a new line to terminate the printed string."},{"content":"The third call specifies an explicit value for the second argument.","pos":[10509,10576]},{"content":"The output from the program is","pos":[10577,10607]},{"content":"See Also","pos":[10675,10683]},{"content":"Types of Expressions","pos":[10688,10708]}],"content":"---\ntitle: \"Postfix Expressions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"operators [C++], postfix\"\n  - \"postfix expressions\"\n  - \"expressions [C++], postfix\"\nms.assetid: 7ac62a57-06df-422f-b012-a75b37d7cb9b\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Postfix Expressions\nPostfix expressions consist of primary expressions or expressions in which postfix operators follow a primary expression. The postfix operators are listed in the following table.  \n  \n### Postfix Operators  \n  \n|Operator Name|Operator Notation|  \n|-------------------|-----------------------|  \n|[Subscript operator](../cpp/subscript-operator.md)|**[ ]**|  \n|[Function call operator](../cpp/function-call-operator-parens.md)|**( )**|  \n|[Explicit type conversion operator](../cpp/explicit-type-conversion-operator-parens.md)|*type-name* **( )**|  \n|[Member access operator](../cpp/member-access-operators-dot-and.md)|**.** or **–>**|  \n|[Postfix increment operator](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|`++`|  \n|[Postfix decrement operator](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|**––**|  \n  \n The following syntax describes possible postfix expressions:  \n  \n```  \n  \n      primary-expression   \npostfix-expression[expression]postfix-expression(expression-list)simple-type-name(expression-list)postfix-expression.namepostfix-expression–>namepostfix-expression++postfix-expression––cast-keyword < typename > (expression )typeid ( typename )  \n```  \n  \n The *postfix-expression* above may be a primary expression or another postfix expression.  See **primary expressions**.  Postfix expressions group left to right, thus allowing the expressions to be chained together as follows:  \n  \n```  \nfunc(1)->GetValue()++  \n```  \n  \n In the above expression, func is a primary expression, func(1) is a function postfix expression, func(1)->GetData is a postfix expression specifying a member of the class, func(1)->GetData() is another function postfix expression, and the entire expression is a postfix expression incrementing the return value of GetData.  The meaning of the expression as a whole is \"call func passing 1 as an argument and get a pointer to a class as a return value.  Then call GetValue() on that class, then increment the value returned.  \n  \n The expressions listed above are assignment expressions, meaning that the result of these expressions must be an r-value.  \n  \n The postfix expression form  \n  \n```  \nsimple-type-name ( expression-list )  \n```  \n  \n indicates the invocation of the constructor.  If the simple-type-name is a fundamental type, the expression list must be a single expression, and this expression indicates a cast of the expression's value to the fundamental type.  This type of cast expression mimics a constructor.  Because this form allows fundamental types and classes to be constructed using the same syntax, this form is especially useful when defining template classes.  \n  \n The *cast-keyword* is one of `dynamic_cast`, `static_cast` or `reinterpret_cast`.  More information may be found in **dynamic_cast**, **static_cast** and **reinterpet_cast**.  \n  \n The `typeid` operator is considered a postfix expression.  See **typeid operator**.  \n  \n## Formal and actual arguments  \n Calling programs pass information to called functions in \"actual arguments.\" The called functions access the information using corresponding \"formal arguments.\"  \n  \n When a function is called, the following tasks are performed:  \n  \n-   All actual arguments (those supplied by the caller) are evaluated. There is no implied order in which these arguments are evaluated, but all arguments are evaluated and all side effects completed prior to entry to the function.  \n  \n-   Each formal argument is initialized with its corresponding actual argument in the expression list. (A formal argument is an argument that is declared in the function header and used in the body of a function.) Conversions are done as if by initialization — both standard and user-defined conversions are performed in converting an actual argument to the correct type. The initialization performed is illustrated conceptually by the following code:  \n  \n    ```  \n    void Func( int i ); // Function prototype  \n    ...  \n    Func( 7 );          // Execute function call  \n    ```  \n  \n     The conceptual initializations prior to the call are:  \n  \n    ```  \n    int Temp_i = 7;  \n    Func( Temp_i );  \n    ```  \n  \n     Note that the initialization is performed as if using the equal-sign syntax instead of the parentheses syntax. A copy of `i` is made prior to passing the value to the function. (For more information, see [Initializers](../cpp/initializers.md) and [Conversions](../cpp/user-defined-type-conversions-cpp.md), [Initialization Using Special Member Functions](http://msdn.microsoft.com/en-us/82223d73-64cb-4923-b678-78f9568ff3ca), and [Explicit Initialization](http://msdn.microsoft.com/en-us/c89724f8-ddd3-4d77-b86d-77fcd8bd8595).  \n  \n     Therefore, if the function prototype (declaration) calls for an argument of type **long**, and if the calling program supplies an actual argument of type `int`, the actual argument is promoted using a standard type conversion to type **long** (see [Standard Conversions](../cpp/standard-conversions.md)).  \n  \n     It is an error to supply an actual argument for which there is no standard or user-defined conversion to the type of the formal argument.  \n  \n     For actual arguments of class type, the formal argument is initialized by calling the class's constructor. (See [Constructors](../cpp/constructors-cpp.md) for more about these special class member functions.)  \n  \n-   The function call is executed.  \n  \n The following program fragment demonstrates a function call:  \n  \n```  \n// expre_Formal_and_Actual_Arguments.cpp  \nvoid func( long param1, double param2 );  \n  \nint main()  \n{  \n    long i = 1;  \n    double j = 2;  \n  \n    // Call func with actual arguments i and j.  \n    func( i, j );  \n}  \n  \n// Define func with formal parameters param1 and param2.  \nvoid func( long param1, double param2 )  \n{  \n}  \n```  \n  \n When `func` is called from main, the formal parameter `param1` is initialized with the value of `i` (`i` is converted to type **long** to correspond to the correct type using a standard conversion), and the formal parameter `param2` is initialized with the value of `j` (`j` is converted to type **double** using a standard conversion).  \n  \n## Treatment of argument types  \n Formal arguments declared as const types cannot be changed within the body of a function. Functions can change any argument that is not of type **const**. However, the change is local to the function and does not affect the actual argument's value unless the actual argument was a reference to an object not of type **const**.  \n  \n The following functions illustrate some of these concepts:  \n  \n```  \n// expre_Treatment_of_Argument_Types.cpp  \nint func1( const int i, int j, char *c ) {  \n   i = 7;   // C3892 i is const.  \n   j = i;   // value of j is lost at return  \n   *c = 'a' + j;   // changes value of c in calling function  \n   return i;  \n}  \n  \ndouble& func2( double& d, const char *c ) {  \n   d = 14.387;   // changes value of d in calling function.  \n   *c = 'a';   // C3892 c is a pointer to a const object.  \n    return d;  \n}  \n```  \n  \n## Ellipses and default arguments  \n Functions can be declared to accept fewer arguments than specified in the function definition, using one of two methods: ellipsis (`...`) or default arguments.  \n  \n Ellipses denote that arguments may be required but that the number and types are not specified in the declaration. This is normally poor C++ programming practice because it defeats one of the benefits of C++: type safety. Different conversions are applied to functions declared with ellipses than to those functions for which the formal and actual argument types are known:  \n  \n-   If the actual argument is of type **float**, it is promoted to type **double** prior to the function call.  \n  \n-   Any signed or unsigned `char`, **short**, enumerated type, or bit field is converted to either a signed or an unsigned `int` using integral promotion.  \n  \n-   Any argument of class type is passed by value as a data structure; the copy is created by binary copying instead of by invoking the class's copy constructor (if one exists).  \n  \n Ellipses, if used, must be declared last in the argument list. For more information about passing a variable number of arguments, see the discussion of [va_arg, va_start, and va_list](../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md) in the *Run-Time Library Reference*.  \n  \n For information on default arguments in CLR programming, see [Variable Argument Lists (...) (C++/CLI)](../windows/variable-argument-lists-dot-dot-dot-cpp-cli.md).  \n  \n Default arguments enable you to specify the value an argument should assume if none is supplied in the function call. The following code fragment shows how default arguments work. For more information about restrictions on specifying default arguments, see [Default Arguments](../cpp/default-arguments.md).  \n  \n```  \n// expre_Ellipses_and_Default_Arguments.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \n// Declare the function print that prints a string,  \n// then a terminator.  \nvoid print( const char *string,  \n            const char *terminator = \"\\n\" );  \n  \nint main()  \n{  \n    print( \"hello,\" );  \n    print( \"world!\" );  \n  \n    print( \"good morning\", \", \" );  \n    print( \"sunshine.\" );  \n}  \n  \nusing namespace std;  \n// Define print.  \nvoid print( const char *string, const char *terminator )  \n{  \n    if( string != NULL )  \n        cout << string;  \n  \n    if( terminator != NULL )  \n        cout << terminator;  \n}  \n```  \n  \n The preceding program declares a function, `print`, that takes two arguments. However, the second argument, `terminator`, has a default value, `\"\\n\"`. In **main**, the first two calls to `print` allow the default second argument to supply a new line to terminate the printed string. The third call specifies an explicit value for the second argument. The output from the program is  \n  \n```  \nhello,  \nworld!  \ngood morning, sunshine.  \n```  \n  \n## See Also  \n [Types of Expressions](../cpp/types-of-expressions.md)"}