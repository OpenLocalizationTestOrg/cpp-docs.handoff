{"nodes":[{"pos":[12,48],"content":"aligned_union Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"aligned_union Class | Microsoft Docs","pos":[0,36]}]},{"content":"aligned_union Class","pos":[691,710]},{"content":"Provides a POD type large enough and suitably aligned to store a union type, and the size required.","pos":[711,810]},{"content":"Syntax","pos":[819,825]},{"content":"Parameters","pos":[1038,1048]},{"content":"The alignment value for the largest type in the union.","pos":[1061,1115]},{"content":"The distinct types in the underlying union.","pos":[1133,1176]},{"content":"Remarks","pos":[1185,1192]},{"content":"Use the template class to get the alignment and size needed to store a union in uninitialized storage.","pos":[1196,1298]},{"content":"The member typedef <ph id=\"ph1\">`type`</ph> names a POD type suitable for storage of any type listed in <ph id=\"ph2\">`Types`</ph>; the minimum size is <ph id=\"ph3\">`Len`</ph>.","pos":[1299,1420],"source":" The member typedef `type` names a POD type suitable for storage of any type listed in `Types`; the minimum size is `Len`."},{"content":"The static member <ph id=\"ph1\">`alignment_value`</ph> of type <ph id=\"ph2\">`std::size_t`</ph> contains the strictest alignment required of all the types listed in <ph id=\"ph3\">`Types`</ph>.","pos":[1421,1556],"source":" The static member `alignment_value` of type `std::size_t` contains the strictest alignment required of all the types listed in `Types`."},{"content":"Example","pos":[1565,1572]},{"pos":[1576,1684],"content":"The following example shows how to use <ph id=\"ph1\">`aligned_union`</ph> to allocate an aligned stack buffer to place a union.","source":"The following example shows how to use `aligned_union` to allocate an aligned stack buffer to place a union."},{"content":"Requirements","pos":[2432,2444]},{"pos":[2448,2473],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> &lt;type_traits&gt;","source":"**Header:** <type_traits>"},{"pos":[2480,2498],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"content":"See Also","pos":[2507,2515]},{"content":"&lt;type_traits&gt;","pos":[2520,2533],"source":"<type_traits>"},{"content":"alignment_of Class","pos":[2576,2594]}],"content":"---\ntitle: \"aligned_union Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"aligned_union\"\n  - \"std.aligned_union\"\n  - \"std::aligned_union\"\n  - \"type_traits/std::aligned_union\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"aligned_union\"\nms.assetid: 9931a44d-3a67-4f29-a0f6-d47a7cf560ac\ncaps.latest.revision: 10\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# aligned_union Class\nProvides a POD type large enough and suitably aligned to store a union type, and the size required.  \n  \n## Syntax  \n  \n```  \ntemplate <std::size_t Len, class... Types>  \nstruct aligned_union;  \n \ntemplate <std::size_t Len, class... Types>  \nusing aligned_union_t = typename aligned_union<Len, Types...>::type;  \n```  \n  \n#### Parameters  \n `Len`  \n The alignment value for the largest type in the union.  \n  \n `Types`  \n The distinct types in the underlying union.  \n  \n## Remarks  \n Use the template class to get the alignment and size needed to store a union in uninitialized storage. The member typedef `type` names a POD type suitable for storage of any type listed in `Types`; the minimum size is `Len`. The static member `alignment_value` of type `std::size_t` contains the strictest alignment required of all the types listed in `Types`.  \n  \n## Example  \n The following example shows how to use `aligned_union` to allocate an aligned stack buffer to place a union.  \n  \n```  \n// std__type_traits__aligned_union.cpp  \n#include <iostream>  \n#include <type_traits>  \n  \nunion U_type  \n{  \n    int i;  \n    float f;  \n    double d;  \n    U_type(float e) : f(e) {}  \n};  \n  \ntypedef std::aligned_union<16, int, float, double>::type aligned_U_type;  \n  \nint main()  \n{  \n    // allocate memory for a U_type aligned on a 16-byte boundary  \n    aligned_U_type au;  \n    // do placement new in the aligned memory on the stack  \n    U_type* u = new (&au) U_type(1.0f);  \n    if (nullptr != u)  \n    {  \n        std::cout << \"value of u->i is \" << u->i << std::endl;  \n        // must clean up placement objects manually!  \n        u->~U_type();  \n    }  \n}  \n```  \n  \n```Output  \nvalue of u->i is 1065353216  \n```  \n  \n## Requirements  \n **Header:** <type_traits>  \n  \n **Namespace:** std  \n  \n## See Also  \n [<type_traits>](../standard-library/type-traits.md)   \n [alignment_of Class](../standard-library/alignment-of-class.md)\n"}