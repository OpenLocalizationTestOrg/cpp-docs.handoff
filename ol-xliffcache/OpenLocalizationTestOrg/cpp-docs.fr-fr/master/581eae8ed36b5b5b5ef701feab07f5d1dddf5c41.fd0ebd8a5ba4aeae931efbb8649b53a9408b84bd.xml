{"nodes":[{"pos":[12,44],"content":"Templates (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Templates (C++) | Microsoft Docs","pos":[0,32]}]},{"content":"Templates (C++)","pos":[624,639]},{"content":"Templates are the basis for generic programming in C++.","pos":[640,695]},{"content":"As a strongly-typed language, C++ requires all variables to have a specific type, either explicitly declared by the programmer or deduced by the compiler.","pos":[696,850]},{"content":"However, many data structures and algorithms look the same no matter what type they are operating on.","pos":[851,952]},{"content":"Templates enable you to define the operations of a class or function, and let the user specify what concrete types those operations should work on.","pos":[953,1100]},{"content":"Defining and using templates","pos":[1109,1137]},{"content":"A template is a construct that generates an ordinary type or function at compile time based on arguments the user supplies for the template parameters.","pos":[1141,1292]},{"content":"For example, you can define a function template like this:","pos":[1293,1351]},{"content":"The above code describes a template for a generic function with a single type parameter <ph id=\"ph1\">`T`</ph>, whose return value and call parameters (lhs and rhs) are all of this type.","pos":[1484,1651],"source":"The above code describes a template for a generic function with a single type parameter `T`, whose return value and call parameters (lhs and rhs) are all of this type."},{"content":"You can name a type parameter anything you like, but by convention single upper case letters are most commonly used.","pos":[1652,1768]},{"content":"is a template parameter; the <ph id=\"ph1\">`typename`</ph> keyword says that this parameter is a placeholder for a type.","pos":[1773,1874],"source":" is a template parameter; the `typename` keyword says that this parameter is a placeholder for a type."},{"content":"When the function is called, the compiler will replace every instance of <ph id=\"ph1\">`T`</ph> with the concrete type argument that is either specified by the user or deduced by the compiler.","pos":[1875,2048],"source":" When the function is called, the compiler will replace every instance of `T` with the concrete type argument that is either specified by the user or deduced by the compiler."},{"content":"The process in which the compiler generates a class or function from a template is referred to as  <bpt id=\"p1\">*</bpt>template instantiation<ept id=\"p1\">*</ept>;   <ph id=\"ph1\">`minimum&lt;int&gt;`</ph> is an instantiation of the template <ph id=\"ph2\">`minimum&lt;T&gt;`</ph>.","pos":[2049,2240],"source":" The process in which the compiler generates a class or function from a template is referred to as  *template instantiation*;   `minimum<int>` is an instantiation of the template `minimum<T>`."},{"content":"Elsewhere, a user can declare an instance of the template  that is specialized for int.","pos":[2247,2334]},{"content":"Assume that get_a() and get_b() are functions that return an int:","pos":[2335,2400]},{"pos":[2490,2658],"content":"However, because this is a function template and the compiler can deduce the type of <ph id=\"ph1\">`T`</ph> from the arguments <ph id=\"ph2\">`a`</ph> and <ph id=\"ph3\">`b`</ph>, you can call it just like an ordinary function:","source":"However, because this is a function template and the compiler can deduce the type of `T` from the arguments `a` and `b`, you can call it just like an ordinary function:"},{"pos":[2708,2858],"content":"When the compiler encounters that last statement, it generates a new function in which every occurrence of <bpt id=\"p1\">*</bpt>T<ept id=\"p1\">*</ept> in the template is replaced with <ph id=\"ph1\">`int`</ph>:","source":"When the compiler encounters that last statement, it generates a new function in which every occurrence of *T* in the template is replaced with `int`:"},{"content":"The rules for how the compiler performs type deduction in function templates are based on the rules for ordinary functions.","pos":[2979,3102]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Overload Resolution of Function Template Calls<ept id=\"p1\">](../cpp/overload-resolution-of-function-template-calls.md)</ept>.","pos":[3103,3236],"source":" For more information, see [Overload Resolution of Function Template Calls](../cpp/overload-resolution-of-function-template-calls.md)."},{"pos":[3274,3289],"content":"Type parameters"},{"pos":[3293,3488],"content":"In the <ph id=\"ph1\">`minimum`</ph> template above, note that the type parameter <ph id=\"ph2\">`T`</ph> is not qualified in any way until it is used in the function call parameters, where the const and reference qualifiers are added.","source":"In the `minimum` template above, note that the type parameter `T` is not qualified in any way until it is used in the function call parameters, where the const and reference qualifiers are added."},{"content":"There is no practical limit to the number of type parameters.","pos":[3495,3556]},{"content":"Separate multiple parameters by commas:","pos":[3557,3596]},{"content":"The keyword <ph id=\"ph1\">`class`</ph> is equivalent to <ph id=\"ph2\">`typename`</ph> in this context.","pos":[3685,3749],"source":"The keyword `class` is equivalent to `typename` in this context."},{"content":"You can express the previous example as:","pos":[3750,3790]},{"content":"You can use the ellipses operator (...) to define a template that takes an arbitrary number of zero or more type parameters:","pos":[3865,3989]},{"content":"Any built-in or user-defined type can be used as a type argument.","pos":[4156,4221]},{"content":"For example, you can use std::vector in the Standard Library to store ints, doubles, strings, MyClass, const MyClass*, MyClass&amp;.","pos":[4222,4350],"source":" For example, you can use std::vector in the Standard Library to store ints, doubles, strings, MyClass, const MyClass*, MyClass&."},{"content":"The primary restriction when using templates is that a type argument must support any operations that are applied to the type parameters.","pos":[4351,4488]},{"content":"For example, if we call minimum using MyClass as in this example:","pos":[4489,4554]},{"content":"A compiler error will be generated because MyClass does not provide an overload for the &lt; operator.","pos":[4815,4914],"source":"A compiler error will be generated because MyClass does not provide an overload for the < operator."},{"content":"There is no inherent requirement that the type arguments for any particular template all belong to the same object hierarchy, although you can define a template that enforces such a restriction.","pos":[4921,5115]},{"content":"You can combine object-oriented techniques with templates; for example, you can store a Derived* in a vector<ph id=\"ph1\">\\&lt;</ph>Base<ph id=\"ph2\">\\*</ph>&gt;.","pos":[5116,5234],"source":" You can combine object-oriented techniques with templates; for example, you can store a Derived* in a vector\\<Base\\*>."},{"content":"Note that the arguments must be pointers","pos":[5238,5278]},{"pos":[5513,5666],"content":"The basic requirements that vector and other standard library containers impose on elements of <ph id=\"ph1\">`T`</ph> is that <ph id=\"ph2\">`T`</ph> be copy-assignable and copy-constructible.","source":"The basic requirements that vector and other standard library containers impose on elements of `T` is that `T` be copy-assignable and copy-constructible."},{"content":"Non-type parameters","pos":[5675,5694]},{"content":"Unlike generic types in other languages such as C# and Java, C++ templates support non-type parameters, also called value parameters.","pos":[5698,5831]},{"content":"For example, you can provide a constant integral value to specify the length of an array, as with this example that is similar to the std::array class in the Standard Library:","pos":[5832,6007]},{"content":"Note the syntax in the template declaration.","pos":[6140,6184]},{"content":"The size_t value is passed in as a template argument at compile time and must be constant or a constexpr expression.","pos":[6185,6301]},{"content":"You use it like this:","pos":[6302,6323]},{"content":"Other kinds of values including pointers and references can be passed in as non-type parameters.","pos":[6377,6473]},{"content":"For example, you can pass in a pointer to a function or function object to customize some operation inside the template code.","pos":[6474,6599]},{"pos":[6641,6673],"content":"Templates as template parameters"},{"content":"A template can be a template parameter.","pos":[6677,6716]},{"content":"In this example, MyClass2 has two template parameters: a typename parameter <ph id=\"ph1\">`T`</ph> and a template parameter <ph id=\"ph2\">`Arr`</ph>:","pos":[6717,6828],"source":" In this example, MyClass2 has two template parameters: a typename parameter `T` and a template parameter `Arr`:"},{"content":"Because the <ph id=\"ph1\">`Arr`</ph> parameter itself has no body, its parameter names are not needed.","pos":[7012,7095],"source":"Because the `Arr` parameter itself has no body, its parameter names are not needed."},{"content":"In fact, it is an error to refer to <ph id=\"ph1\">`Arr`</ph>'s typename or class parameter names from within the body of <ph id=\"ph2\">`MyClass2`</ph>.","pos":[7096,7209],"source":" In fact, it is an error to refer to `Arr`'s typename or class parameter names from within the body of `MyClass2`."},{"content":"For this reason,  <ph id=\"ph1\">`Arr`</ph>'s type parameter names can be omitted, as shown in this example:","pos":[7210,7298],"source":" For this reason,  `Arr`'s type parameter names can be omitted, as shown in this example:"},{"content":"Default template arguments","pos":[7445,7471]},{"content":"Class and function templates can have default arguments.","pos":[7475,7531]},{"content":"When a template has a default argument you can leave it unspecified when you use it.","pos":[7532,7616]},{"content":"For example, the std::vector template has a default argument for the allocator:","pos":[7617,7696]},{"content":"In most cases the default std::allocator class is acceptable, so you use a vector like this:","pos":[7788,7880]},{"content":"But if necessary you can specify a custom allocator like this:","pos":[7927,7989]},{"content":"For multiple template arguments, all arguments after the first default argument must have default arguments.","pos":[8047,8155]},{"content":"When using a template whose parameters are all defaulted, use empty angle brackets:","pos":[8162,8245]},{"content":"Template specialization","pos":[8436,8459]},{"content":"In some cases, it isn’t possible or desirable for a template to define exactly the same code for any type.","pos":[8463,8569]},{"content":"For example, you might wish to define a code path to be executed only if the type argument is a pointer, or a std::wstring, or a type derived from a particular base class.","pos":[8570,8741]},{"content":"In such cases you can define a <bpt id=\"p1\">*</bpt>specialization<ept id=\"p1\">*</ept> of the template for that particular type.","pos":[8743,8832],"source":"  In such cases you can define a *specialization* of the template for that particular type."},{"content":"When a user instantiates the template with that type, the compiler uses the specialization to generate the class, and for all other types, the compiler chooses the more general template.","pos":[8833,9019]},{"content":"Specializations in which all parameters are specialized are <bpt id=\"p1\">*</bpt>complete specializations<ept id=\"p1\">*</ept>.","pos":[9020,9107],"source":" Specializations in which all parameters are specialized are *complete specializations*."},{"content":"If only some of the parameters are specialized, it is called a <bpt id=\"p1\">*</bpt>partial specialization<ept id=\"p1\">*</ept>.","pos":[9108,9196],"source":" If only some of the parameters are specialized, it is called a *partial specialization*."},{"content":"A template can have any number of specializations as long as each specialized type parameter is unique.","pos":[9523,9626]},{"content":"Only class templates may be partially specialized.","pos":[9629,9679]},{"content":"All complete and partial specializations of a template must be declared in the same namespace as the original template.","pos":[9680,9799]},{"pos":[9806,9897],"content":"For more information, see <bpt id=\"p1\">[</bpt>Template Specialization<ept id=\"p1\">](../cpp/template-specialization-cpp.md)</ept>.","source":"For more information, see [Template Specialization](../cpp/template-specialization-cpp.md)."}],"content":"---\ntitle: \"Templates (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"template\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"templates, C++\"\n  - \"templates\"\nms.assetid: 90fcc14a-2092-47af-9d2e-dba26d25b872\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Templates (C++)\nTemplates are the basis for generic programming in C++. As a strongly-typed language, C++ requires all variables to have a specific type, either explicitly declared by the programmer or deduced by the compiler. However, many data structures and algorithms look the same no matter what type they are operating on. Templates enable you to define the operations of a class or function, and let the user specify what concrete types those operations should work on.  \n  \n## Defining and using templates  \n A template is a construct that generates an ordinary type or function at compile time based on arguments the user supplies for the template parameters. For example, you can define a function template like this:  \n  \n```cpp  \ntemplate <typename T>  \nT minimum(const T& lhs, const T& rhs)  \n{  \n    return lhs < rhs ? lhs : rhs;  \n}  \n```  \n  \n The above code describes a template for a generic function with a single type parameter `T`, whose return value and call parameters (lhs and rhs) are all of this type. You can name a type parameter anything you like, but by convention single upper case letters are most commonly used. `T` is a template parameter; the `typename` keyword says that this parameter is a placeholder for a type. When the function is called, the compiler will replace every instance of `T` with the concrete type argument that is either specified by the user or deduced by the compiler. The process in which the compiler generates a class or function from a template is referred to as  *template instantiation*;   `minimum<int>` is an instantiation of the template `minimum<T>`.  \n  \n Elsewhere, a user can declare an instance of the template  that is specialized for int. Assume that get_a() and get_b() are functions that return an int:  \n  \n```  \nint a = get_a();  \nint b = get_b();  \nint i = minimum<int>(a, b);  \n```  \n  \n However, because this is a function template and the compiler can deduce the type of `T` from the arguments `a` and `b`, you can call it just like an ordinary function:  \n  \n```cpp  \nint i = minimum(a, b);  \n```  \n  \n When the compiler encounters that last statement, it generates a new function in which every occurrence of *T* in the template is replaced with `int`:  \n  \n```  \n  \n      int minimum(const int& lhs, const int& rhs)  \n{  \n    return lhs < rhs ? lhs : rhs;  \n}  \n```  \n  \n The rules for how the compiler performs type deduction in function templates are based on the rules for ordinary functions. For more information, see [Overload Resolution of Function Template Calls](../cpp/overload-resolution-of-function-template-calls.md).  \n  \n## <a id=\"type_parameters\"></a> Type parameters  \n In the `minimum` template above, note that the type parameter `T` is not qualified in any way until it is used in the function call parameters, where the const and reference qualifiers are added.  \n  \n There is no practical limit to the number of type parameters. Separate multiple parameters by commas:  \n  \n```cpp  \ntemplate <typename T, typename U, typename V> class Foo{};  \n  \n```  \n  \n The keyword `class` is equivalent to `typename` in this context. You can express the previous example as:  \n  \n```  \ntemplate <class T, class U, class V> class Foo{};   \n```  \n  \n You can use the ellipses operator (...) to define a template that takes an arbitrary number of zero or more type parameters:  \n  \n```cpp  \ntemplate<typename... Arguments> class vtclass;  \n  \nvtclass< > vtinstance1;  \nvtclass<int> vtinstance2;  \nvtclass<float, bool> vtinstance3;  \n```  \n  \n Any built-in or user-defined type can be used as a type argument. For example, you can use std::vector in the Standard Library to store ints, doubles, strings, MyClass, const MyClass*, MyClass&. The primary restriction when using templates is that a type argument must support any operations that are applied to the type parameters. For example, if we call minimum using MyClass as in this example:  \n  \n```cpp  \nclass MyClass  \n{  \npublic:  \n    int num;  \n    std::wstring description;  \n};  \n  \nint main()  \n{      \n    MyClass mc1 {1, L\"hello\"};  \n    MyClass mc2 {2, L\"goodbye\"};  \n    auto result = minimum(mc1, mc2); // Error! C2678  \n}  \n  \n```  \n  \n A compiler error will be generated because MyClass does not provide an overload for the < operator.  \n  \n There is no inherent requirement that the type arguments for any particular template all belong to the same object hierarchy, although you can define a template that enforces such a restriction. You can combine object-oriented techniques with templates; for example, you can store a Derived* in a vector\\<Base\\*>.    Note that the arguments must be pointers  \n  \n```  \nvector<MyClass*> vec;  \n   MyDerived d(3, L\"back again\", time(0));  \n   vec.push_back(&d);  \n  \n   // or more realistically:  \n   vector<shared_ptr<MyClass>> vec2;  \n   vec2.push_back(make_shared<MyDerived>());  \n```  \n  \n The basic requirements that vector and other standard library containers impose on elements of `T` is that `T` be copy-assignable and copy-constructible.  \n  \n## Non-type parameters  \n Unlike generic types in other languages such as C# and Java, C++ templates support non-type parameters, also called value parameters. For example, you can provide a constant integral value to specify the length of an array, as with this example that is similar to the std::array class in the Standard Library:  \n  \n```  \ntemplate<typename T, size_t L>  \nclass MyArray  \n{  \n    T arr[L];  \npublic:  \n    MyArray() { ... }  \n};  \n  \n```  \n  \n Note the syntax in the template declaration. The size_t value is passed in as a template argument at compile time and must be constant or a constexpr expression. You use it like this:  \n  \n```cpp  \nMyArray<MyClass*, 10> arr;  \n```  \n  \n Other kinds of values including pointers and references can be passed in as non-type parameters. For example, you can pass in a pointer to a function or function object to customize some operation inside the template code.  \n  \n## <a id=\"template_parameters\"></a> Templates as template parameters  \n A template can be a template parameter. In this example, MyClass2 has two template parameters: a typename parameter `T` and a template parameter `Arr`:  \n  \n```cpp  \ntemplate<typename T, template<typename U, int I> class Arr>  \nclass MyClass2  \n{  \n    T t; //OK  \n    Arr<T, 10> a;  \n    U u; //Error. U not in scope  \n};  \n```  \n  \n Because the `Arr` parameter itself has no body, its parameter names are not needed. In fact, it is an error to refer to `Arr`'s typename or class parameter names from within the body of `MyClass2`. For this reason,  `Arr`'s type parameter names can be omitted, as shown in this example:  \n  \n```cpp  \ntemplate<typename T, template<typename, int> class Arr>  \nclass MyClass2  \n{  \n    T t; //OK  \n    Arr<T, 10> a;  \n};  \n```  \n  \n## Default template arguments  \n Class and function templates can have default arguments. When a template has a default argument you can leave it unspecified when you use it. For example, the std::vector template has a default argument for the allocator:  \n  \n```cpp  \ntemplate <class T, class Allocator = allocator<T>> class vector;  \n```  \n  \n In most cases the default std::allocator class is acceptable, so you use a vector like this:  \n  \n```cpp  \nvector<int> myInts;  \n```  \n  \n But if necessary you can specify a custom allocator like this:  \n  \n```cpp  \nvector<int, MyAllocator> ints;  \n```  \n  \n For multiple template arguments, all arguments after the first default argument must have default arguments.  \n  \n When using a template whose parameters are all defaulted, use empty angle brackets:  \n  \n```cpp  \ntemplate<typename A = int, typename B = double>  \nclass Bar  \n{  \n    //...  \n};  \n...  \nint main()  \n{  \n    Bar<> bar; // use all default type arguments  \n}  \n  \n```  \n  \n## Template specialization  \n In some cases, it isn’t possible or desirable for a template to define exactly the same code for any type. For example, you might wish to define a code path to be executed only if the type argument is a pointer, or a std::wstring, or a type derived from a particular base class.  In such cases you can define a *specialization* of the template for that particular type. When a user instantiates the template with that type, the compiler uses the specialization to generate the class, and for all other types, the compiler chooses the more general template. Specializations in which all parameters are specialized are *complete specializations*. If only some of the parameters are specialized, it is called a *partial specialization*.  \n  \n```cpp  \ntemplate <typename K, typename V>  \nclass MyMap{/*...*/};  \n  \n// partial specialization for string keys  \ntemplate<typename V>  \nclass MyMap<string, V> {/*...*/};  \n...  \nMyMap<int, MyClass> classes; // uses original template  \nMyMap<string, MyClass> classes2; // uses the partial specialization  \n  \n```  \n  \n A template can have any number of specializations as long as each specialized type parameter is unique.   Only class templates may be partially specialized. All complete and partial specializations of a template must be declared in the same namespace as the original template.  \n  \n For more information, see [Template Specialization](../cpp/template-specialization-cpp.md)."}