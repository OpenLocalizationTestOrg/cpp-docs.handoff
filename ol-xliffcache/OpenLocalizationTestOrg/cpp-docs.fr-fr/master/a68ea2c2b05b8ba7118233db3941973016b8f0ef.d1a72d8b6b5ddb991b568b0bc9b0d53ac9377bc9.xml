{"nodes":[{"pos":[12,46],"content":"Virtual Functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Virtual Functions | Microsoft Docs","pos":[0,34]}]},{"content":"Virtual Functions","pos":[666,683]},{"content":"A virtual function is a member function that you expect to be redefined in derived classes.","pos":[684,775]},{"content":"When you refer to a derived class object using a pointer or a reference to the base class, you can call a virtual function for that object and execute the derived class's version of the function.","pos":[776,971]},{"content":"Virtual functions ensure that the correct function is called for an object, regardless of the expression used to make the function call.","pos":[978,1114]},{"content":"Suppose a base class contains a function declared as <bpt id=\"p1\">[</bpt>virtual<ept id=\"p1\">](../cpp/virtual-cpp.md)</ept> and a derived class defines the same function.","pos":[1121,1253],"source":"Suppose a base class contains a function declared as [virtual](../cpp/virtual-cpp.md) and a derived class defines the same function."},{"content":"The function from the derived class is invoked for objects of the derived class, even if it is called using a pointer or reference to the base class.","pos":[1254,1403]},{"content":"The following example shows a base class that provides an implementation of the <ph id=\"ph1\">`PrintBalance`</ph> function and two derived classes","pos":[1404,1531],"source":" The following example shows a base class that provides an implementation of the `PrintBalance` function and two derived classes"},{"content":"In the preceding code, the calls to <ph id=\"ph1\">`PrintBalance`</ph> are identical, except for the object <ph id=\"ph2\">`pAccount`</ph> points to.","pos":[2770,2879],"source":"In the preceding code, the calls to `PrintBalance` are identical, except for the object `pAccount` points to."},{"content":"Because <ph id=\"ph1\">`PrintBalance`</ph> is virtual, the version of the function defined for each object is called.","pos":[2880,2977],"source":" Because `PrintBalance` is virtual, the version of the function defined for each object is called."},{"content":"The <ph id=\"ph1\">`PrintBalance`</ph> function in the derived classes <ph id=\"ph2\">`CheckingAccount`</ph> and <ph id=\"ph3\">`SavingsAccount`</ph> \"override\" the function in the base class <ph id=\"ph4\">`Account`</ph>.","pos":[2978,3120],"source":" The `PrintBalance` function in the derived classes `CheckingAccount` and `SavingsAccount` \"override\" the function in the base class `Account`."},{"pos":[3127,3298],"content":"If a class is declared that does not provide an overriding implementation of the <ph id=\"ph1\">`PrintBalance`</ph> function, the default implementation from the base class <ph id=\"ph2\">`Account`</ph> is used.","source":"If a class is declared that does not provide an overriding implementation of the `PrintBalance` function, the default implementation from the base class `Account` is used."},{"content":"Functions in derived classes override virtual functions in base classes only if their type is the same.","pos":[3305,3408]},{"content":"A function in a derived class cannot differ from a virtual function in a base class in its return type only; the argument list must differ as well.","pos":[3409,3556]},{"content":"When calling a function using pointers or references, the following rules apply:","pos":[3563,3643]},{"content":"A call to a virtual function is resolved according to the underlying type of object for which it is called.","pos":[3653,3760]},{"content":"A call to a nonvirtual function is resolved according to the type of the pointer or reference.","pos":[3770,3864]},{"content":"The following example shows how virtual and nonvirtual functions behave when called through pointers:","pos":[3871,3972]},{"content":"Output","pos":[5296,5302]},{"content":"Note that regardless of whether the <ph id=\"ph1\">`NameOf`</ph> function is invoked through a pointer to <ph id=\"ph2\">`Base`</ph> or a pointer to <ph id=\"ph3\">`Derived`</ph>, it calls the function for <ph id=\"ph4\">`Derived`</ph>.","pos":[5399,5555],"source":"Note that regardless of whether the `NameOf` function is invoked through a pointer to `Base` or a pointer to `Derived`, it calls the function for `Derived`."},{"content":"It calls the function for <ph id=\"ph1\">`Derived`</ph> because <ph id=\"ph2\">`NameOf`</ph> is a virtual function, and both <ph id=\"ph3\">`pBase`</ph> and <ph id=\"ph4\">`pDerived`</ph> point to an object of type <ph id=\"ph5\">`Derived`</ph>.","pos":[5556,5701],"source":" It calls the function for `Derived` because `NameOf` is a virtual function, and both `pBase` and `pDerived` point to an object of type `Derived`."},{"pos":[5708,5839],"content":"Because virtual functions are called only for objects of class types, you cannot declare global or static functions as <bpt id=\"p1\">**</bpt>virtual<ept id=\"p1\">**</ept>.","source":"Because virtual functions are called only for objects of class types, you cannot declare global or static functions as **virtual**."},{"pos":[5846,6011],"content":"The <bpt id=\"p1\">**</bpt>virtual<ept id=\"p1\">**</ept> keyword can be used when declaring overriding functions in a derived class, but it is unnecessary; overrides of virtual functions are always virtual.","source":"The **virtual** keyword can be used when declaring overriding functions in a derived class, but it is unnecessary; overrides of virtual functions are always virtual."},{"content":"Virtual functions in a base class must be defined unless they are declared using the <bpt id=\"p1\">*</bpt>pure-specifier<ept id=\"p1\">*</ept>.","pos":[6018,6120],"source":"Virtual functions in a base class must be defined unless they are declared using the *pure-specifier*."},{"content":"(For more information about pure virtual functions, see <bpt id=\"p1\">[</bpt>Abstract Classes<ept id=\"p1\">](../cpp/abstract-classes-cpp.md)</ept>.)","pos":[6121,6229],"source":" (For more information about pure virtual functions, see [Abstract Classes](../cpp/abstract-classes-cpp.md).)"},{"content":"The virtual function-call mechanism can be suppressed by explicitly qualifying the function name using the scope-resolution operator (<ph id=\"ph1\">`::`</ph>).","pos":[6236,6376],"source":"The virtual function-call mechanism can be suppressed by explicitly qualifying the function name using the scope-resolution operator (`::`)."},{"content":"Consider the earlier example involving the <ph id=\"ph1\">`Account`</ph> class.","pos":[6377,6436],"source":" Consider the earlier example involving the `Account` class."},{"content":"To call <ph id=\"ph1\">`PrintBalance`</ph> in the base class, use code such as the following:","pos":[6437,6510],"source":" To call `PrintBalance` in the base class, use code such as the following:"},{"pos":[6801,6900],"content":"Both calls to <ph id=\"ph1\">`PrintBalance`</ph> in the preceding example suppress the virtual function-call mechanism.","source":"Both calls to `PrintBalance` in the preceding example suppress the virtual function-call mechanism."}],"content":"---\ntitle: \"Virtual Functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"functions [C++], virtual functions\"\n  - \"derived classes, virtual functions\"\n  - \"virtual functions\"\nms.assetid: b3e1ed88-2a90-4af8-960a-16f47deb3452\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Virtual Functions\nA virtual function is a member function that you expect to be redefined in derived classes. When you refer to a derived class object using a pointer or a reference to the base class, you can call a virtual function for that object and execute the derived class's version of the function.  \n  \n Virtual functions ensure that the correct function is called for an object, regardless of the expression used to make the function call.  \n  \n Suppose a base class contains a function declared as [virtual](../cpp/virtual-cpp.md) and a derived class defines the same function. The function from the derived class is invoked for objects of the derived class, even if it is called using a pointer or reference to the base class. The following example shows a base class that provides an implementation of the `PrintBalance` function and two derived classes  \n  \n```  \n// deriv_VirtualFunctions.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \nclass Account {  \npublic:  \n   Account( double d ) { _balance = d; }  \n   virtual double GetBalance() { return _balance; }  \n   virtual void PrintBalance() { cerr << \"Error. Balance not available for base type.\" << endl; }  \nprivate:  \n    double _balance;  \n};  \n  \nclass CheckingAccount : public Account {  \npublic:  \n   CheckingAccount(double d) : Account(d) {}  \n   void PrintBalance() { cout << \"Checking account balance: \" << GetBalance() << endl; }  \n};  \n  \nclass SavingsAccount : public Account {  \npublic:  \n   SavingsAccount(double d) : Account(d) {}  \n   void PrintBalance() { cout << \"Savings account balance: \" << GetBalance(); }  \n};  \n  \nint main() {  \n   // Create objects of type CheckingAccount and SavingsAccount.  \n   CheckingAccount *pChecking = new CheckingAccount( 100.00 ) ;  \n   SavingsAccount  *pSavings  = new SavingsAccount( 1000.00 );  \n  \n   // Call PrintBalance using a pointer to Account.  \n   Account *pAccount = pChecking;  \n   pAccount->PrintBalance();  \n  \n   // Call PrintBalance using a pointer to Account.  \n   pAccount = pSavings;  \n   pAccount->PrintBalance();     \n}  \n```  \n  \n In the preceding code, the calls to `PrintBalance` are identical, except for the object `pAccount` points to. Because `PrintBalance` is virtual, the version of the function defined for each object is called. The `PrintBalance` function in the derived classes `CheckingAccount` and `SavingsAccount` \"override\" the function in the base class `Account`.  \n  \n If a class is declared that does not provide an overriding implementation of the `PrintBalance` function, the default implementation from the base class `Account` is used.  \n  \n Functions in derived classes override virtual functions in base classes only if their type is the same. A function in a derived class cannot differ from a virtual function in a base class in its return type only; the argument list must differ as well.  \n  \n When calling a function using pointers or references, the following rules apply:  \n  \n-   A call to a virtual function is resolved according to the underlying type of object for which it is called.  \n  \n-   A call to a nonvirtual function is resolved according to the type of the pointer or reference.  \n  \n The following example shows how virtual and nonvirtual functions behave when called through pointers:  \n  \n```  \n// deriv_VirtualFunctions2.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \nclass Base {  \npublic:  \n   virtual void NameOf();   // Virtual function.  \n   void InvokingClass();   // Nonvirtual function.  \n};  \n  \n// Implement the two functions.  \nvoid Base::NameOf() {  \n   cout << \"Base::NameOf\\n\";  \n}  \n  \nvoid Base::InvokingClass() {  \n   cout << \"Invoked by Base\\n\";  \n}  \n  \nclass Derived : public Base {  \npublic:  \n   void NameOf();   // Virtual function.  \n   void InvokingClass();   // Nonvirtual function.  \n};  \n  \n// Implement the two functions.  \nvoid Derived::NameOf() {  \n   cout << \"Derived::NameOf\\n\";  \n}  \n  \nvoid Derived::InvokingClass() {  \n   cout << \"Invoked by Derived\\n\";  \n}  \n  \nint main() {  \n   // Declare an object of type Derived.  \n   Derived aDerived;  \n  \n   // Declare two pointers, one of type Derived * and the other  \n   //  of type Base *, and initialize them to point to aDerived.  \n   Derived *pDerived = &aDerived;  \n   Base    *pBase    = &aDerived;  \n  \n   // Call the functions.  \n   pBase->NameOf();           // Call virtual function.  \n   pBase->InvokingClass();    // Call nonvirtual function.  \n   pDerived->NameOf();        // Call virtual function.  \n   pDerived->InvokingClass(); // Call nonvirtual function.  \n}  \n```  \n  \n### Output  \n  \n```  \nDerived::NameOf  \nInvoked by Base  \nDerived::NameOf  \nInvoked by Derived  \n```  \n  \n Note that regardless of whether the `NameOf` function is invoked through a pointer to `Base` or a pointer to `Derived`, it calls the function for `Derived`. It calls the function for `Derived` because `NameOf` is a virtual function, and both `pBase` and `pDerived` point to an object of type `Derived`.  \n  \n Because virtual functions are called only for objects of class types, you cannot declare global or static functions as **virtual**.  \n  \n The **virtual** keyword can be used when declaring overriding functions in a derived class, but it is unnecessary; overrides of virtual functions are always virtual.  \n  \n Virtual functions in a base class must be defined unless they are declared using the *pure-specifier*. (For more information about pure virtual functions, see [Abstract Classes](../cpp/abstract-classes-cpp.md).)  \n  \n The virtual function-call mechanism can be suppressed by explicitly qualifying the function name using the scope-resolution operator (`::`). Consider the earlier example involving the `Account` class. To call `PrintBalance` in the base class, use code such as the following:  \n  \n```  \nCheckingAccount *pChecking = new CheckingAccount( 100.00 );  \n  \npChecking->Account::PrintBalance();  //  Explicit qualification.  \n  \nAccount *pAccount = pChecking;  // Call Account::PrintBalance  \n  \npAccount->Account::PrintBalance();   //  Explicit qualification.  \n```  \n  \n Both calls to `PrintBalance` in the preceding example suppress the virtual function-call mechanism.  \n  \n"}