{"nodes":[{"pos":[12,40],"content":"queue Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"queue Class | Microsoft Docs","pos":[0,28]}]},{"content":"queue Class","pos":[620,631]},{"content":"A template container adaptor class that provides a restriction of functionality for some underlying container type, limiting access to the front and back elements.","pos":[632,795]},{"content":"Elements can be added at the back or removed from the front, and elements can be inspected at either end of the queue.","pos":[796,914]},{"content":"Syntax","pos":[923,929]},{"content":"Parameters","pos":[1025,1035]},{"content":"Type","pos":[1040,1044]},{"content":"The element data type to be stored in the queue","pos":[1049,1096]},{"content":"The type of the underlying container used to implement the queue.","pos":[1118,1183]},{"content":"Remarks","pos":[1192,1199]},{"content":"The elements of class <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> stipulated in the first template parameter of a queue object are synonymous with <bpt id=\"p2\">[</bpt>value_type<ept id=\"p2\">](#queue__value_type)</ept> and must match the type of element in the underlying container class <bpt id=\"p3\">**</bpt>Container<ept id=\"p3\">**</ept> stipulated by the second template parameter.","pos":[1203,1475],"source":"The elements of class **Type** stipulated in the first template parameter of a queue object are synonymous with [value_type](#queue__value_type) and must match the type of element in the underlying container class **Container** stipulated by the second template parameter."},{"content":"The <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> must be assignable, so that it is possible to copy objects of that type and to assign values to variables of that type.","pos":[1476,1608],"source":" The **Type** must be assignable, so that it is possible to copy objects of that type and to assign values to variables of that type."},{"content":"Suitable underlying container classes for queue include <bpt id=\"p1\">[</bpt>deque<ept id=\"p1\">](../standard-library/deque-class.md)</ept> and <bpt id=\"p2\">[</bpt>list<ept id=\"p2\">](../standard-library/list-class.md)</ept>, or any other sequence container that supports the operations of <ph id=\"ph1\">`front`</ph>, <bpt id=\"p3\">**</bpt>back<ept id=\"p3\">**</ept>, <ph id=\"ph2\">`push_back`</ph>, and <ph id=\"ph3\">`pop_front`</ph>.","pos":[1615,1874],"source":"Suitable underlying container classes for queue include [deque](../standard-library/deque-class.md) and [list](../standard-library/list-class.md), or any other sequence container that supports the operations of `front`, **back**, `push_back`, and `pop_front`."},{"content":"The underlying container class is encapsulated within the container adaptor, which exposes only the limited set of the sequence container member functions as a public interface.","pos":[1875,2052]},{"pos":[2059,2272],"content":"The queue objects are equality comparable if and only if the elements of class <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> are equality comparable, and are less-than comparable if and only if the elements of class <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept> are less-than comparable.","source":"The queue objects are equality comparable if and only if the elements of class **Type** are equality comparable, and are less-than comparable if and only if the elements of class **Type** are less-than comparable."},{"content":"There are three types of container adaptors defined by the STL: stack, queue, and priority_queue.","pos":[2279,2376]},{"content":"Each restricts the functionality of some underlying container class to provide a precisely controlled interface to a standard data structure.","pos":[2377,2518]},{"content":"The <bpt id=\"p1\">[</bpt>stack class<ept id=\"p1\">](../standard-library/stack-class.md)</ept> supports a last-in, first-out (LIFO) data structure.","pos":[2528,2634],"source":"The [stack class](../standard-library/stack-class.md) supports a last-in, first-out (LIFO) data structure."},{"content":"A good analogue to keep in mind would be a stack of plates.","pos":[2635,2694]},{"content":"Elements (plates) may be inserted, inspected, or removed only from the top of the stack, which is the last element at the end of the base container.","pos":[2695,2843]},{"content":"The restriction to accessing only the top element is the reason for using the stack class.","pos":[2844,2934]},{"content":"The queue class supports a first-in, first-out (FIFO) data structure.","pos":[2944,3013]},{"content":"A good analogue to keep in mind would be people lining up for a bank teller.","pos":[3014,3090]},{"content":"Elements (people) may be added to the back of the line and are removed from the front of the line.","pos":[3091,3189]},{"content":"Both the front and the back of a line may be inspected.","pos":[3190,3245]},{"content":"The restriction to accessing only the front and back elements in this way is the reason for using the queue class.","pos":[3246,3360]},{"content":"The <bpt id=\"p1\">[</bpt>priority_queue class<ept id=\"p1\">](../standard-library/priority-queue-class.md)</ept> orders its elements so that the largest element is always at the top position.","pos":[3370,3520],"source":"The [priority_queue class](../standard-library/priority-queue-class.md) orders its elements so that the largest element is always at the top position."},{"content":"It supports insertion of an element and the inspection and removal of the top element.","pos":[3521,3607]},{"content":"A good analogue to keep in mind would be people lining up where they are arranged by age, height, or some other criterion.","pos":[3608,3730]},{"content":"Constructors","pos":[3740,3752]},{"content":"queue","pos":[3774,3779]},{"pos":[3796,3876],"content":"Constructs a <ph id=\"ph1\">`queue`</ph> that is empty or that is a copy of a base container object.","source":"Constructs a `queue` that is empty or that is a copy of a base container object."},{"content":"Typedefs","pos":[3887,3895]},{"content":"container_type","pos":[3917,3931]},{"pos":[3957,4026],"content":"A type that provides the base container to be adapted by the <ph id=\"ph1\">`queue`</ph>.","source":"A type that provides the base container to be adapted by the `queue`."},{"content":"size_type","pos":[4032,4041]},{"pos":[4062,4142],"content":"An unsigned integer type that can represent the number of elements in a <ph id=\"ph1\">`queue`</ph>.","source":"An unsigned integer type that can represent the number of elements in a `queue`."},{"content":"value_type","pos":[4148,4158]},{"pos":[4180,4256],"content":"A type that represents the type of object stored as an element in a <ph id=\"ph1\">`queue`</ph>.","source":"A type that represents the type of object stored as an element in a `queue`."},{"content":"Member Functions","pos":[4267,4283]},{"content":"back","pos":[4305,4309]},{"pos":[4325,4416],"content":"Returns a reference to the last and most recently added element at the back of the <ph id=\"ph1\">`queue`</ph>.","source":"Returns a reference to the last and most recently added element at the back of the `queue`."},{"content":"empty","pos":[4422,4427]},{"pos":[4444,4474],"content":"Tests if the <ph id=\"ph1\">`queue`</ph> is empty.","source":"Tests if the `queue` is empty."},{"content":"front","pos":[4480,4485]},{"pos":[4502,4571],"content":"Returns a reference to the first element at the front of the <ph id=\"ph1\">`queue`</ph>.","source":"Returns a reference to the first element at the front of the `queue`."},{"content":"pop","pos":[4577,4580]},{"pos":[4595,4644],"content":"Removes an element from the front of the <ph id=\"ph1\">`queue`</ph>.","source":"Removes an element from the front of the `queue`."},{"content":"push","pos":[4650,4654]},{"pos":[4670,4713],"content":"Adds an element to the back of the <ph id=\"ph1\">`queue`</ph>.","source":"Adds an element to the back of the `queue`."},{"content":"size","pos":[4719,4723]},{"pos":[4739,4785],"content":"Returns the number of elements in the <ph id=\"ph1\">`queue`</ph>.","source":"Returns the number of elements in the `queue`."},{"content":"Requirements","pos":[4795,4807]},{"pos":[4811,4831],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>queue&gt;","source":"**Header:** \\<queue>"},{"pos":[4838,4856],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[4894,4905],"content":"queue::back"},{"content":"Returns a reference to the last and most recently added element at the back of the queue.","pos":[4909,4998]},{"content":"Return Value","pos":[5072,5084]},{"content":"The last element of the queue.","pos":[5088,5118]},{"content":"If the queue is empty, the return value is undefined.","pos":[5119,5172]},{"content":"Remarks","pos":[5182,5189]},{"content":"If the return value of <bpt id=\"p1\">**</bpt>back<ept id=\"p1\">**</ept> is assigned to a <ph id=\"ph1\">`const_reference`</ph>, the queue object cannot be modified.","pos":[5193,5297],"source":"If the return value of **back** is assigned to a `const_reference`, the queue object cannot be modified."},{"content":"If the return value of <bpt id=\"p1\">**</bpt>back<ept id=\"p1\">**</ept> is assigned to a <bpt id=\"p2\">**</bpt>reference<ept id=\"p2\">**</ept>, the queue object can be modified.","pos":[5298,5395],"source":" If the return value of **back** is assigned to a **reference**, the queue object can be modified."},{"content":"When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty queue.","pos":[5402,5518]},{"content":"See <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept> for more information.","pos":[5520,5607],"source":"  See [Checked Iterators](../standard-library/checked-iterators.md) for more information."},{"content":"Example","pos":[5617,5624]},{"pos":[6134,6155],"content":"queue::container_type"},{"content":"A type that provides the base container to be adapted.","pos":[6159,6213]},{"content":"Remarks","pos":[6274,6281]},{"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Container`</ph>.","pos":[6285,6346],"source":"The type is a synonym for the template parameter `Container`."},{"content":"Two STL sequence container classes — the list class and the default deque class — meet the requirements to be used as the base container for a queue object.","pos":[6347,6503]},{"content":"User-defined types satisfying the requirements may also be used.","pos":[6504,6568]},{"pos":[6575,6699],"content":"For more information on <ph id=\"ph1\">`Container`</ph>, see the Remarks section of the <bpt id=\"p1\">[</bpt>queue Class<ept id=\"p1\">](../standard-library/queue-class.md)</ept> topic.","source":"For more information on `Container`, see the Remarks section of the [queue Class](../standard-library/queue-class.md) topic."},{"content":"Example","pos":[6709,6716]},{"pos":[6721,6822],"content":"See the example for <bpt id=\"p1\">[</bpt>queue<ept id=\"p1\">](#queue__queue)</ept> for an example of how to declare and use <ph id=\"ph1\">`container_type`</ph>.","source":"See the example for [queue](#queue__queue) for an example of how to declare and use `container_type`."},{"pos":[6861,6873],"content":"queue::empty"},{"content":"Tests if a queue is empty.","pos":[6877,6903]},{"content":"Return Value","pos":[6948,6960]},{"pos":[6964,7031],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the queue is empty; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if the queue is nonempty.","source":"**true** if the queue is empty; **false** if the queue is nonempty."},{"content":"Example","pos":[7041,7048]},{"pos":[7705,7717],"content":"queue::front"},{"content":"Returns a reference to the first element at the front of the queue.","pos":[7721,7788]},{"content":"Return Value","pos":[7864,7876]},{"content":"The first element of the queue.","pos":[7880,7911]},{"content":"If the queue is empty, the return value is undefined.","pos":[7912,7965]},{"content":"Remarks","pos":[7975,7982]},{"content":"If the return value of <ph id=\"ph1\">`front`</ph> is assigned to a <ph id=\"ph2\">`const_reference`</ph>, the queue object cannot be modified.","pos":[7986,8089],"source":"If the return value of `front` is assigned to a `const_reference`, the queue object cannot be modified."},{"content":"If the return value of <ph id=\"ph1\">`front`</ph> is assigned to a <bpt id=\"p1\">**</bpt>reference<ept id=\"p1\">**</ept>, the queue object can be modified.","pos":[8090,8186],"source":" If the return value of `front` is assigned to a **reference**, the queue object can be modified."},{"pos":[8193,8309],"content":"The member function returns a <bpt id=\"p1\">**</bpt>reference<ept id=\"p1\">**</ept> to the first element of the controlled sequence, which must be nonempty.","source":"The member function returns a **reference** to the first element of the controlled sequence, which must be nonempty."},{"content":"When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty queue.","pos":[8316,8432]},{"content":"See <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept> for more information.","pos":[8434,8521],"source":"  See [Checked Iterators](../standard-library/checked-iterators.md) for more information."},{"content":"Example","pos":[8531,8538]},{"pos":[9164,9174],"content":"queue::pop"},{"content":"Removes an element from the front of the queue.","pos":[9178,9225]},{"content":"Remarks","pos":[9262,9269]},{"content":"The queue must be nonempty to apply the member function.","pos":[9273,9329]},{"content":"The top of the queue is the position occupied by the most recently added element and is the last element at the end of the container.","pos":[9330,9463]},{"content":"Example","pos":[9473,9480]},{"pos":[10426,10437],"content":"queue::push"},{"content":"Adds an element to the back of the queue.","pos":[10441,10482]},{"content":"Parameters","pos":[10535,10545]},{"content":"The element added to the back of the queue.","pos":[10558,10601]},{"content":"Remarks","pos":[10611,10618]},{"content":"The back of the queue is the position occupied by the most recently added element and is the last element at the end of the container.","pos":[10622,10756]},{"content":"Example","pos":[10766,10773]},{"pos":[11369,11381],"content":"queue::queue"},{"content":"Constructs a queue that is empty or that is a copy of a base container object.","pos":[11385,11463]},{"content":"Parameters","pos":[11543,11553]},{"content":"The <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> container of which the constructed queue is to be a copy.","pos":[11569,11640],"source":" The **const** container of which the constructed queue is to be a copy."},{"content":"Remarks","pos":[11650,11657]},{"content":"The default base container for queue is deque.","pos":[11661,11707]},{"content":"You can also specify list as a base container, but you cannot specify vector, because it lacks the required <ph id=\"ph1\">`pop_front`</ph> member function.","pos":[11708,11844],"source":" You can also specify list as a base container, but you cannot specify vector, because it lacks the required `pop_front` member function."},{"content":"Example","pos":[11854,11861]},{"pos":[13139,13150],"content":"queue::size"},{"content":"Returns the number of elements in the queue.","pos":[13154,13198]},{"content":"Return Value","pos":[13247,13259]},{"content":"The current length of the queue.","pos":[13263,13295]},{"content":"Example","pos":[13305,13312]},{"pos":[13845,13861],"content":"queue::size_type"},{"content":"An unsigned integer type that can represent the number of elements in a queue.","pos":[13865,13943]},{"content":"Remarks","pos":[14019,14026]},{"pos":[14030,14115],"content":"The type is a synonym for the <ph id=\"ph1\">`size_type`</ph> of the base container adapted by the queue.","source":"The type is a synonym for the `size_type` of the base container adapted by the queue."},{"content":"Example","pos":[14125,14132]},{"pos":[14137,14240],"content":"See the example for <bpt id=\"p1\">[</bpt>queue::front<ept id=\"p1\">](#queue__front)</ept> for an example of how to declare and use <ph id=\"ph1\">`size_type`</ph>.","source":"See the example for [queue::front](#queue__front) for an example of how to declare and use `size_type`."},{"pos":[14284,14301],"content":"queue::value_type"},{"content":"A type that represents the type of object stored as an element in a queue.","pos":[14305,14379]},{"content":"Remarks","pos":[14457,14464]},{"pos":[14468,14554],"content":"The type is a synonym for the <ph id=\"ph1\">`value_type`</ph> of the base container adapted by the queue.","source":"The type is a synonym for the `value_type` of the base container adapted by the queue."},{"content":"Example","pos":[14564,14571]},{"content":"See Also","pos":[15155,15163]},{"content":"Thread Safety in the C++ Standard Library","pos":[15168,15209]},{"content":"C++ Standard Library Reference","pos":[15282,15312]}],"content":"---\ntitle: \"queue Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std.queue\"\n  - \"std::queue\"\n  - \"queue\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"queue class\"\nms.assetid: 28c20ab0-3a72-4185-9e0f-5a44eea0e204\ncaps.latest.revision: 21\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# queue Class\nA template container adaptor class that provides a restriction of functionality for some underlying container type, limiting access to the front and back elements. Elements can be added at the back or removed from the front, and elements can be inspected at either end of the queue.  \n  \n## Syntax  \n  \n```  \ntemplate <class Type, class Container = deque <Type>>  \nclass queue  \n```  \n  \n#### Parameters  \n *Type*  \n The element data type to be stored in the queue  \n  \n `Container`  \n The type of the underlying container used to implement the queue.  \n  \n## Remarks  \n The elements of class **Type** stipulated in the first template parameter of a queue object are synonymous with [value_type](#queue__value_type) and must match the type of element in the underlying container class **Container** stipulated by the second template parameter. The **Type** must be assignable, so that it is possible to copy objects of that type and to assign values to variables of that type.  \n  \n Suitable underlying container classes for queue include [deque](../standard-library/deque-class.md) and [list](../standard-library/list-class.md), or any other sequence container that supports the operations of `front`, **back**, `push_back`, and `pop_front`. The underlying container class is encapsulated within the container adaptor, which exposes only the limited set of the sequence container member functions as a public interface.  \n  \n The queue objects are equality comparable if and only if the elements of class **Type** are equality comparable, and are less-than comparable if and only if the elements of class **Type** are less-than comparable.  \n  \n There are three types of container adaptors defined by the STL: stack, queue, and priority_queue. Each restricts the functionality of some underlying container class to provide a precisely controlled interface to a standard data structure.  \n  \n-   The [stack class](../standard-library/stack-class.md) supports a last-in, first-out (LIFO) data structure. A good analogue to keep in mind would be a stack of plates. Elements (plates) may be inserted, inspected, or removed only from the top of the stack, which is the last element at the end of the base container. The restriction to accessing only the top element is the reason for using the stack class.  \n  \n-   The queue class supports a first-in, first-out (FIFO) data structure. A good analogue to keep in mind would be people lining up for a bank teller. Elements (people) may be added to the back of the line and are removed from the front of the line. Both the front and the back of a line may be inspected. The restriction to accessing only the front and back elements in this way is the reason for using the queue class.  \n  \n-   The [priority_queue class](../standard-library/priority-queue-class.md) orders its elements so that the largest element is always at the top position. It supports insertion of an element and the inspection and removal of the top element. A good analogue to keep in mind would be people lining up where they are arranged by age, height, or some other criterion.  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[queue](#queue__queue)|Constructs a `queue` that is empty or that is a copy of a base container object.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[container_type](#queue__container_type)|A type that provides the base container to be adapted by the `queue`.|  \n|[size_type](#queue__size_type)|An unsigned integer type that can represent the number of elements in a `queue`.|  \n|[value_type](#queue__value_type)|A type that represents the type of object stored as an element in a `queue`.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[back](#queue__back)|Returns a reference to the last and most recently added element at the back of the `queue`.|  \n|[empty](#queue__empty)|Tests if the `queue` is empty.|  \n|[front](#queue__front)|Returns a reference to the first element at the front of the `queue`.|  \n|[pop](#queue__pop)|Removes an element from the front of the `queue`.|  \n|[push](#queue__push)|Adds an element to the back of the `queue`.|  \n|[size](#queue__size)|Returns the number of elements in the `queue`.|  \n  \n## Requirements  \n **Header:** \\<queue>  \n  \n **Namespace:** std  \n  \n##  <a name=\"queue__back\"></a>  queue::back  \n Returns a reference to the last and most recently added element at the back of the queue.  \n  \n```  \nreference back();\n\nconst_reference back() const;\n```  \n  \n### Return Value  \n The last element of the queue. If the queue is empty, the return value is undefined.  \n  \n### Remarks  \n If the return value of **back** is assigned to a `const_reference`, the queue object cannot be modified. If the return value of **back** is assigned to a **reference**, the queue object can be modified.  \n  \n When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty queue.  See [Checked Iterators](../standard-library/checked-iterators.md) for more information.  \n  \n### Example  \n  \n```cpp  \n// queue_back.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   queue <int> q1;  \n  \n   q1.push( 10 );  \n   q1.push( 11 );  \n  \n   int& i = q1.back( );  \n   const int& ii = q1.front( );  \n  \n   cout << \"The integer at the back of queue q1 is \" << i   \n        << \".\" << endl;  \n   cout << \"The integer at the front of queue q1 is \" << ii   \n        << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"queue__container_type\"></a>  queue::container_type  \n A type that provides the base container to be adapted.  \n  \n```  \ntypedef Container container_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `Container`. Two STL sequence container classes — the list class and the default deque class — meet the requirements to be used as the base container for a queue object. User-defined types satisfying the requirements may also be used.  \n  \n For more information on `Container`, see the Remarks section of the [queue Class](../standard-library/queue-class.md) topic.  \n  \n### Example  \n  See the example for [queue](#queue__queue) for an example of how to declare and use `container_type`.  \n  \n##  <a name=\"queue__empty\"></a>  queue::empty  \n Tests if a queue is empty.  \n  \n```  \nbool empty() const;\n```  \n  \n### Return Value  \n **true** if the queue is empty; **false** if the queue is nonempty.  \n  \n### Example  \n  \n```cpp  \n// queue_empty.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )  \n{  \nusing namespace std;  \n  \n   // Declares queues with default deque base container  \n   queue <int> q1, q2;  \n  \n   q1.push( 1 );  \n  \n   if ( q1.empty( ) )  \n      cout << \"The queue q1 is empty.\" << endl;  \n   else  \n      cout << \"The queue q1 is not empty.\" << endl;  \n  \n   if ( q2.empty( ) )  \n      cout << \"The queue q2 is empty.\" << endl;  \n   else  \n      cout << \"The queue q2 is not empty.\" << endl;  \n}  \n```  \n  \n```Output  \nThe queue q1 is not empty.  \nThe queue q2 is empty.  \n```  \n  \n##  <a name=\"queue__front\"></a>  queue::front  \n Returns a reference to the first element at the front of the queue.  \n  \n```  \nreference front();\n\nconst_reference front() const;\n```  \n  \n### Return Value  \n The first element of the queue. If the queue is empty, the return value is undefined.  \n  \n### Remarks  \n If the return value of `front` is assigned to a `const_reference`, the queue object cannot be modified. If the return value of `front` is assigned to a **reference**, the queue object can be modified.  \n  \n The member function returns a **reference** to the first element of the controlled sequence, which must be nonempty.  \n  \n When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty queue.  See [Checked Iterators](../standard-library/checked-iterators.md) for more information.  \n  \n### Example  \n  \n```cpp  \n// queue_front.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   queue <int> q1;  \n  \n   q1.push( 10 );  \n   q1.push( 20 );  \n   q1.push( 30 );  \n  \n   queue <int>::size_type i;  \n   i = q1.size( );  \n   cout << \"The queue length is \" << i << \".\" << endl;  \n  \n   int& ii = q1.back( );  \n   int& iii = q1.front( );  \n  \n   cout << \"The integer at the back of queue q1 is \" << ii   \n        << \".\" << endl;  \n   cout << \"The integer at the front of queue q1 is \" << iii   \n        << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"queue__pop\"></a>  queue::pop  \n Removes an element from the front of the queue.  \n  \n```  \nvoid pop();\n```  \n  \n### Remarks  \n The queue must be nonempty to apply the member function. The top of the queue is the position occupied by the most recently added element and is the last element at the end of the container.  \n  \n### Example  \n  \n```cpp  \n// queue_pop.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   queue <int> q1, s2;  \n  \n   q1.push( 10 );  \n   q1.push( 20 );  \n   q1.push( 30 );  \n  \n   queue <int>::size_type i;  \n   i = q1.size( );  \n   cout << \"The queue length is \" << i << \".\" << endl;  \n  \n   i = q1.front( );  \n   cout << \"The element at the front of the queue is \"  \n        << i << \".\" << endl;  \n  \n   q1.pop( );  \n  \n   i = q1.size( );  \n   cout << \"After a pop the queue length is \"   \n        << i << \".\" << endl;  \n  \n   i = q1. front ( );  \n   cout << \"After a pop, the element at the front of the queue is \"  \n        << i << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe queue length is 3.  \nThe element at the front of the queue is 10.  \nAfter a pop the queue length is 2.  \nAfter a pop, the element at the front of the queue is 20.  \n```  \n  \n##  <a name=\"queue__push\"></a>  queue::push  \n Adds an element to the back of the queue.  \n  \n```  \nvoid push(const Type& val);\n```  \n  \n### Parameters  \n `val`  \n The element added to the back of the queue.  \n  \n### Remarks  \n The back of the queue is the position occupied by the most recently added element and is the last element at the end of the container.  \n  \n### Example  \n  \n```cpp  \n// queue_push.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   queue <int> q1;  \n  \n   q1.push( 10 );  \n   q1.push( 20 );  \n   q1.push( 30 );  \n  \n   queue <int>::size_type i;  \n   i = q1.size( );  \n   cout << \"The queue length is \" << i << \".\" << endl;  \n  \n   i = q1.front( );  \n   cout << \"The element at the front of the queue is \"  \n        << i << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe queue length is 3.  \nThe element at the front of the queue is 10.  \n```  \n  \n##  <a name=\"queue__queue\"></a>  queue::queue  \n Constructs a queue that is empty or that is a copy of a base container object.  \n  \n```  \nqueue();\n\nexplicit queue(const container_type& right);\n```  \n  \n### Parameters  \n ` right`  \n The **const** container of which the constructed queue is to be a copy.  \n  \n### Remarks  \n The default base container for queue is deque. You can also specify list as a base container, but you cannot specify vector, because it lacks the required `pop_front` member function.  \n  \n### Example  \n  \n```cpp  \n// queue_queue.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <vector>  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   // Declares queue with default deque base container  \n   queue <char> q1;  \n  \n   // Explicitly declares a queue with deque base container  \n   queue <char, deque<char> > q2;  \n  \n   // These lines don't cause an error, even though they  \n   // declares a queue with a vector base container  \n   queue <int, vector<int> > q3;  \n   q3.push( 10 );  \n   // but the following would cause an error because vector has   \n   // no pop_front member function  \n   // q3.pop( );  \n  \n   // Declares a queue with list base container  \n   queue <int, list<int> > q4;  \n  \n   // The second member function copies elements from a container  \n   list<int> li1;  \n   li1.push_back( 1 );  \n   li1.push_back( 2 );  \n   queue <int, list<int> > q5( li1 );  \n   cout << \"The element at the front of queue q5 is \"  \n        << q5.front( ) << \".\" << endl;  \n   cout << \"The element at the back of queue q5 is \"  \n        << q5.back( ) << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe element at the front of queue q5 is 1.  \nThe element at the back of queue q5 is 2.  \n```  \n  \n##  <a name=\"queue__size\"></a>  queue::size  \n Returns the number of elements in the queue.  \n  \n```  \nsize_type size() const;\n```  \n  \n### Return Value  \n The current length of the queue.  \n  \n### Example  \n  \n```cpp  \n// queue_size.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   queue <int> q1, q2;  \n   queue <int>::size_type i;  \n  \n   q1.push( 1 );  \n   i = q1.size( );  \n   cout << \"The queue length is \" << i << \".\" << endl;  \n  \n   q1.push( 2 );  \n   i = q1.size( );  \n   cout << \"The queue length is now \" << i << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe queue length is 1.  \nThe queue length is now 2.  \n```  \n  \n##  <a name=\"queue__size_type\"></a>  queue::size_type  \n An unsigned integer type that can represent the number of elements in a queue.  \n  \n```  \ntypedef typename Container::size_type size_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the `size_type` of the base container adapted by the queue.  \n  \n### Example  \n  See the example for [queue::front](#queue__front) for an example of how to declare and use `size_type`.  \n  \n##  <a name=\"queue__value_type\"></a>  queue::value_type  \n A type that represents the type of object stored as an element in a queue.  \n  \n```  \ntypedef typename Container::value_type value_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the `value_type` of the base container adapted by the queue.  \n  \n### Example  \n  \n```cpp  \n// queue_value_type.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )  \n{  \nusing namespace std;  \n  \n   // Declares queues with default deque base container  \n   queue<int>::value_type AnInt;  \n  \n   AnInt = 69;  \n   cout << \"The value_type is AnInt = \" << AnInt << endl;  \n  \n   queue<int> q1;  \n   q1.push(AnInt);  \n   cout << \"The element at the front of the queue is \"  \n        << q1.front( ) << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe value_type is AnInt = 69  \nThe element at the front of the queue is 69.  \n```  \n  \n## See Also  \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)\n\n"}