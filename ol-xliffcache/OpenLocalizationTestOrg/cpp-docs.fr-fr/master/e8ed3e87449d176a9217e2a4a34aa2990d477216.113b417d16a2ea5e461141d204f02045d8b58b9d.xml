{"nodes":[{"pos":[12,54],"content":"Generic Classes (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Generic Classes (C++-CLI) | Microsoft Docs","pos":[0,42]}]},{"content":"Generic Classes (C++/CLI)","pos":[750,775]},{"content":"A generic class is declared using the following form:","pos":[776,829]},{"content":"Syntax","pos":[838,844]},{"content":"Remarks","pos":[1075,1082]},{"content":"In the above syntax, the following terms are used:","pos":[1086,1136]},{"content":"(optional)","pos":[1156,1166]},{"content":"Additional declarative information.","pos":[1170,1205]},{"content":"For more information on attributes and attribute classes, see Attributes.","pos":[1206,1279]},{"content":"class-key","pos":[1287,1296]},{"content":"Either <ph id=\"ph1\">`class`</ph> or","pos":[1301,1318],"source":" Either `class` or "},{"content":"<bpt id=\"p1\">*</bpt>type-parameter-identifier(s)<ept id=\"p1\">*</ept>,","pos":[1336,1367],"source":"*type-parameter-identifier(s)*,"},{"content":"Comma-separated list of identifiers specifying the names of the type parameters.","pos":[1371,1451]},{"content":"constraint-clauses","pos":[1459,1477]},{"content":"A list (not comma-separated) of <bpt id=\"p1\">**</bpt>where<ept id=\"p1\">**</ept> clauses specifying the constraints for the type parameters.","pos":[1482,1583],"source":" A list (not comma-separated) of **where** clauses specifying the constraints for the type parameters."},{"content":"Takes the form:","pos":[1584,1599]},{"pos":[1615,1666],"content":"<bpt id=\"p1\">*</bpt>type-parameter-identifier<ept id=\"p1\">*</ept>  <ph id=\"ph1\">`:`</ph>  <bpt id=\"p2\">*</bpt>constraint-list<ept id=\"p2\">*</ept>","source":"*type-parameter-identifier*  `:`  *constraint-list*"},{"content":"constraint-list","pos":[1681,1696]},{"content":"<bpt id=\"p1\"> *</bpt>class-or-interface<ept id=\"p1\">*</ept>[<ph id=\"ph1\">`,`</ph> <bpt id=\"p2\">*</bpt>...<ept id=\"p2\">*</ept>]","pos":[1700,1732],"source":" *class-or-interface*[`,` *...*]"},{"content":"accessibility-modifiers","pos":[1740,1763]},{"content":"Accessibility modifiers for the generic class.","pos":[1768,1814]},{"content":"For the <ph id=\"ph1\">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph>, the only allowed modifier is <ph id=\"ph2\">`private`</ph>.","pos":[1815,1916],"source":" For the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)], the only allowed modifier is `private`."},{"content":"For the common language runtime, the allowed modifiers are <ph id=\"ph1\">`private`</ph> and <ph id=\"ph2\">`public`</ph>.","pos":[1917,1999],"source":" For the common language runtime, the allowed modifiers are `private` and `public`."},{"content":"identifier","pos":[2007,2017]},{"content":"The name of the generic class, any valid C++ identifier.","pos":[2022,2078]},{"content":"<bpt id=\"p1\">*</bpt>modifiers<ept id=\"p1\">*</ept> (optional)","pos":[2085,2107],"source":"*modifiers* (optional)"},{"content":"Allowed modifiers include <ph id=\"ph1\">`sealed`</ph> and <bpt id=\"p1\">**</bpt>abstract<ept id=\"p1\">**</ept>.","pos":[2111,2163],"source":" Allowed modifiers include `sealed` and **abstract**."},{"content":"base-list","pos":[2171,2180]},{"content":"A list that contains the one base class and any implemented interfaces, all separated by commas.","pos":[2185,2281]},{"content":"class-body","pos":[2289,2299]},{"content":"The body of the class, containing fields, member functions, etc.","pos":[2304,2368]},{"content":"declarators","pos":[2376,2387]},{"content":"Declarations of any variables of this type.","pos":[2392,2435]},{"content":"For example: <ph id=\"ph1\">`^`</ph><bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept>[<ph id=\"ph2\">`,`</ph> ...]","pos":[2436,2473],"source":" For example: `^`*identifier*[`,` ...]"},{"content":"You can declare generic classes such as these (note that the keyword <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept> may be used instead of <bpt id=\"p2\">**</bpt>typename<ept id=\"p2\">**</ept>).","pos":[2480,2596],"source":"You can declare generic classes such as these (note that the keyword **class** may be used instead of **typename**)."},{"content":"In this example, <ph id=\"ph1\">`ItemType`</ph>, <ph id=\"ph2\">`KeyType`</ph> and <ph id=\"ph3\">`ValueType`</ph> are unknown types that are specified at the point where the type.","pos":[2597,2717],"source":" In this example, `ItemType`, `KeyType` and `ValueType` are unknown types that are specified at the point where the type."},{"content":"is a constructed type of the generic type <ph id=\"ph1\">`HashTable&lt;KeyType, ValueType&gt;`</ph>.","pos":[2740,2814],"source":" is a constructed type of the generic type `HashTable<KeyType, ValueType>`."},{"content":"A number of different constructed types can be constructed from a single generic type.","pos":[2815,2901]},{"content":"Constructed types constructed from generic classes are treated like any other ref class type.","pos":[2902,2995]},{"content":"Both value types (either built-in types such as <ph id=\"ph1\">`int`</ph> or <ph id=\"ph2\">`double`</ph>, or user-defined value types) and reference types may be used as a generic type argument.","pos":[3501,3656],"source":"Both value types (either built-in types such as `int` or `double`, or user-defined value types) and reference types may be used as a generic type argument."},{"content":"The syntax within the generic definition is the same regardless.","pos":[3657,3721]},{"content":"Syntactically, the unknown type is treated as if it were a reference type.","pos":[3722,3796]},{"content":"However, the runtime is able to determine that if the type actually used is a value type and substitute the appropriate generated code for direct access to members.","pos":[3797,3961]},{"content":"Value types used as generic type arguments are not boxed and so do not suffer the performance penalty associated with boxing.","pos":[3962,4087]},{"content":"The syntax used within the body of the generic should be <bpt id=\"p1\">**</bpt>T^<ept id=\"p1\">**</ept> and '<bpt id=\"p2\">**</bpt><ph id=\"ph1\">-&gt;</ph><ept id=\"p2\">**</ept>' instead of '<bpt id=\"p3\">**</bpt>.<ept id=\"p3\">**</ept>'.","pos":[4088,4184],"source":" The syntax used within the body of the generic should be **T^** and '**->**' instead of '**.**'."},{"content":"Any use of <bpt id=\"p1\">[</bpt>ref new, gcnew<ept id=\"p1\">](../windows/ref-new-gcnew-cpp-component-extensions.md)</ept> for the type parameter will be appropriately interpreted by the runtime as the simple creation of a value type if the type argument is a value type.","pos":[4185,4415],"source":" Any use of [ref new, gcnew](../windows/ref-new-gcnew-cpp-component-extensions.md) for the type parameter will be appropriately interpreted by the runtime as the simple creation of a value type if the type argument is a value type."},{"content":"You can also declare a generic class with <bpt id=\"p1\">[</bpt>Constraints on Generic Type Parameters (C++/CLI)<ept id=\"p1\">](../windows/constraints-on-generic-type-parameters-cpp-cli.md)</ept> on the types that can be used for the type parameter.","pos":[4422,4630],"source":"You can also declare a generic class with [Constraints on Generic Type Parameters (C++/CLI)](../windows/constraints-on-generic-type-parameters-cpp-cli.md) on the types that can be used for the type parameter."},{"content":"In the following example any type used for <ph id=\"ph1\">`ItemType`</ph> must implement the <ph id=\"ph2\">`IItem`</ph> interface.","pos":[4631,4722],"source":" In the following example any type used for `ItemType` must implement the `IItem` interface."},{"content":"Attempting to use <ph id=\"ph1\">`int`</ph>, for example, which does not implement <ph id=\"ph2\">`IItem`</ph>, would produce a compile-time error because the type argument does not satisfy the constraint.","pos":[4723,4888],"source":" Attempting to use `int`, for example, which does not implement `IItem`, would produce a compile-time error because the type argument does not satisfy the constraint."},{"content":"Generic classes in the same namespace cannot be overloaded by only changing the number or the types of type parameters.","pos":[5066,5185]},{"content":"However, if each class lives in a different namespace, they can be overloaded.","pos":[5186,5264]},{"content":"For example, consider the following two classes, <ph id=\"ph1\">`MyClass`</ph> and <ph id=\"ph2\">`MyClass&lt;ItemType&gt;`</ph>, in the namespaces <ph id=\"ph3\">`A`</ph> and <ph id=\"ph4\">`B`</ph>.","pos":[5265,5379],"source":" For example, consider the following two classes, `MyClass` and `MyClass<ItemType>`, in the namespaces `A` and `B`."},{"content":"The two classes can then be overloaded in a third namespace C:","pos":[5380,5442]},{"content":"The base class and base interfaces cannot be type parameters.","pos":[5903,5964]},{"content":"However, the base class can involve the type parameter as an argument, as in the following case:","pos":[5965,6061]},{"content":"Constructors and destructors are executed once for each object instance (as usual); static constructors are executed once for each constructed type.","pos":[6280,6428]},{"content":"Fields in Generic Classes","pos":[6437,6462]},{"content":"This section demonstrates the use of instance and static fields in generic classes.","pos":[6466,6549]},{"content":"Instance Variables","pos":[6559,6577]},{"content":"Instance variables of a generic class can have types and variable initializers that include any type parameters from the enclosing class.","pos":[6581,6718]},{"content":"Example","pos":[6727,6734]},{"pos":[6738,6920],"content":"In the following example, three different instances of the generic class, MyClass<ph id=\"ph1\">\\&lt;</ph>ItemType&gt;, are created by using the appropriate type arguments (<ph id=\"ph2\">`int`</ph>, <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>, and <bpt id=\"p2\">**</bpt>string<ept id=\"p2\">**</ept>).","source":"In the following example, three different instances of the generic class, MyClass\\<ItemType>, are created by using the appropriate type arguments (`int`, **double**, and **string**)."},{"content":"Static Variables","pos":[7953,7969]},{"content":"On the creation of a new generic type, new instances of any static variables are created and any static constructor for that type is executed.","pos":[7973,8115]},{"content":"Static variables can use any type parameters from the enclosing class.","pos":[8122,8192]},{"content":"Example","pos":[8201,8208]},{"content":"The following example demonstrates using static fields and a static constructor within a generic class.","pos":[8212,8315]},{"content":"Methods in Generic Classes","pos":[9394,9420]},{"content":"Methods in generic classes can be generic themselves; non-generic methods will be implicitly parameterized by the class type parameter.","pos":[9424,9559]},{"content":"The following special rules apply to methods within generic classes:","pos":[9566,9634]},{"content":"Methods in generic classes can use type parameters as parameters, return types, or local variables.","pos":[9644,9743]},{"content":"Methods in generic classes can use open or closed constructed types as parameters, return types, or local variables.","pos":[9753,9869]},{"content":"Non-Generic Methods in Generic Classes","pos":[9879,9917]},{"content":"Methods in generic classes that have no additional type parameters are usually referred to as non-generic although they are implicitly parameterized by the enclosing generic class.","pos":[9921,10101]},{"content":"The signature of a non-generic method can include one or more type parameters of the enclosing class, either directly or in an open constructed type.","pos":[10108,10257]},{"content":"For example:","pos":[10258,10270]},{"content":"The body of such methods can also use these type parameters.","pos":[10323,10383]},{"content":"Example","pos":[10392,10399]},{"content":"The following example declares a non-generic method, <ph id=\"ph1\">`ProtectData`</ph>, inside a generic class, <ph id=\"ph2\">`MyClass&lt;ItemType&gt;`</ph>.","pos":[10403,10515],"source":"The following example declares a non-generic method, `ProtectData`, inside a generic class, `MyClass<ItemType>`."},{"content":"The method uses the class type parameter <ph id=\"ph1\">`ItemType`</ph> in its signature in an open constructed type.","pos":[10516,10613],"source":" The method uses the class type parameter `ItemType` in its signature in an open constructed type."},{"content":"Generic Methods in Generic Classes","pos":[11759,11793]},{"content":"You can declare generic methods in both generic and non-generic classes.","pos":[11797,11869]},{"content":"For example:","pos":[11870,11882]},{"content":"Example","pos":[11891,11898]},{"content":"The non-generic method is still generic in the sense that it is parameterized by the class's type parameter, but it has no additional type parameters.","pos":[12410,12560]},{"content":"All types of methods in generic classes can be generic, including static, instance, and virtual methods.","pos":[12567,12671]},{"content":"Example","pos":[12680,12687]},{"content":"The following example demonstrates declaring and using generic methods within generic classes:","pos":[12691,12785]},{"content":"Using Nested Types in Generic Classes","pos":[14149,14186]},{"content":"Just as with ordinary classes, you can declare other types inside a generic class.","pos":[14190,14272]},{"content":"The nested class declaration is implicitly parameterized by the type parameters of the outer class declaration.","pos":[14273,14384]},{"content":"Thus, a distinct nested class is defined for each constructed outer type.","pos":[14385,14458]},{"content":"For example, in the declaration,","pos":[14459,14491]},{"content":"The type Outer<ph id=\"ph1\">\\&lt;</ph>int&gt;::Inner is not the same as the type Outer<ph id=\"ph2\">\\&lt;</ph>double&gt;::Inner.","pos":[14648,14726],"source":"The type Outer\\<int>::Inner is not the same as the type Outer\\<double>::Inner."},{"content":"As with generic methods in generic classes, additional type parameters can be defined for the nested type.","pos":[14733,14839]},{"content":"If you use the same type parameter names in the inner and outer class, the inner type parameter will hide the outer type parameter.","pos":[14840,14971]},{"content":"Since there is no way to refer to the outer type parameter, the compiler will produce a warning in this situation.","pos":[15284,15398]},{"content":"When constructed nested generic types are named, the type parameter for the outer type is not included in the type parameter list for the inner type, even though the inner type is implicitly parameterized by the outer type's type parameter.","pos":[15405,15645]},{"content":"In the above case, a name of a constructed type would be Outer<ph id=\"ph1\">\\&lt;</ph>int&gt;::Inner<ph id=\"ph2\">\\&lt;</ph>string&gt;.","pos":[15646,15731],"source":" In the above case, a name of a constructed type would be Outer\\<int>::Inner\\<string>."},{"content":"The following example demonstrates building and reading a linked list using nested types in generic classes.","pos":[15738,15846]},{"content":"Example","pos":[15855,15862]},{"content":"Properties, Events, Indexers and Operators in Generic Classes","pos":[17975,18036]},{"pos":[18046,18253],"content":"Properties, events, indexers and operators can use the type parameters of the enclosing generic class as return values, parameters, or local variables, such as when <ph id=\"ph1\">`ItemType`</ph> is a type parameter of a class:","source":"Properties, events, indexers and operators can use the type parameters of the enclosing generic class as return values, parameters, or local variables, such as when `ItemType` is a type parameter of a class:"},{"content":"Properties, events, indexers and operators cannot themselves be parameterized.","pos":[18322,18400]},{"content":"Example","pos":[18409,18416]},{"content":"This example shows declarations of an instance property within a generic class.","pos":[18420,18499]},{"content":"Example","pos":[19186,19193]},{"content":"The next example shows a generic class with an event.","pos":[19197,19250]},{"content":"Generic Structs","pos":[21158,21173]},{"content":"The rules for declaring and using generic structs are the same as those for generic classes, except for the differences noted in in the Visual C++ language reference.","pos":[21177,21343]},{"content":"Example","pos":[21352,21359]},{"pos":[21363,21539],"content":"The following example declares a generic struct, <ph id=\"ph1\">`MyGenStruct`</ph>, with one field, <ph id=\"ph2\">`myField`</ph>, and assigns values of different types (<ph id=\"ph3\">`int`</ph>, <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>String^<ept id=\"p2\">**</ept>) to this field.","source":"The following example declares a generic struct, `MyGenStruct`, with one field, `myField`, and assigns values of different types (`int`, **double**, **String^**) to this field."},{"content":"See Also","pos":[22770,22778]},{"content":"Generics","pos":[22783,22791]}],"content":"---\ntitle: \"Generic Classes (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"classes [C++], generic\"\n  - \"generic classes [C++], about generic classes\"\n  - \"data types [C++], generic\"\n  - \"generic classes\"\n  - \"generics [C++], declaring generic classes\"\nms.assetid: 0beb99e1-1ec4-4fee-9836-ce9657d67a3a\ncaps.latest.revision: 33\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Generic Classes (C++/CLI)\nA generic class is declared using the following form:  \n  \n## Syntax  \n  \n```  \n[attributes]  \ngeneric <class-key type-parameter-identifier(s)>  \n[constraint-clauses]  \n[accessibility-modifiers] ref class identifier  [modifiers]  \n[: base-list]   \n{  \nclass-body  \n} [declarators] [;]  \n```  \n  \n## Remarks  \n In the above syntax, the following terms are used:  \n  \n `attributes` (optional)  \n Additional declarative information. For more information on attributes and attribute classes, see Attributes.  \n  \n *class-key*  \n Either `class` or `typename`  \n  \n *type-parameter-identifier(s)*,  \n Comma-separated list of identifiers specifying the names of the type parameters.  \n  \n *constraint-clauses*  \n A list (not comma-separated) of **where** clauses specifying the constraints for the type parameters. Takes the form:  \n  \n `where`  *type-parameter-identifier*  `:`  *constraint-list*  `...`  \n  \n *constraint-list*  \n *class-or-interface*[`,` *...*]  \n  \n *accessibility-modifiers*  \n Accessibility modifiers for the generic class. For the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)], the only allowed modifier is `private`. For the common language runtime, the allowed modifiers are `private` and `public`.  \n  \n *identifier*  \n The name of the generic class, any valid C++ identifier.  \n  \n *modifiers* (optional)  \n Allowed modifiers include `sealed` and **abstract**.  \n  \n *base-list*  \n A list that contains the one base class and any implemented interfaces, all separated by commas.  \n  \n *class-body*  \n The body of the class, containing fields, member functions, etc.  \n  \n *declarators*  \n Declarations of any variables of this type. For example: `^`*identifier*[`,` ...]  \n  \n You can declare generic classes such as these (note that the keyword **class** may be used instead of **typename**). In this example, `ItemType`, `KeyType` and `ValueType` are unknown types that are specified at the point where the type. `HashTable<int, int>` is a constructed type of the generic type `HashTable<KeyType, ValueType>`. A number of different constructed types can be constructed from a single generic type. Constructed types constructed from generic classes are treated like any other ref class type.  \n  \n```  \n// generic_classes_1.cpp  \n// compile with: /clr  \nusing namespace System;  \ngeneric <typename ItemType>  \nref struct Stack {  \n   // ItemType may be used as a type here  \n   void Add(ItemType item) {}  \n};  \n  \ngeneric <typename KeyType, typename ValueType>  \nref class HashTable {};  \n  \n// The keyword class may be used instead of typename:  \ngeneric <class ListItem>  \nref class List {};  \n  \nint main() {  \n   HashTable<int, Decimal>^ g1 = gcnew HashTable<int, Decimal>();  \n}  \n```  \n  \n Both value types (either built-in types such as `int` or `double`, or user-defined value types) and reference types may be used as a generic type argument. The syntax within the generic definition is the same regardless. Syntactically, the unknown type is treated as if it were a reference type. However, the runtime is able to determine that if the type actually used is a value type and substitute the appropriate generated code for direct access to members. Value types used as generic type arguments are not boxed and so do not suffer the performance penalty associated with boxing. The syntax used within the body of the generic should be **T^** and '**->**' instead of '**.**'. Any use of [ref new, gcnew](../windows/ref-new-gcnew-cpp-component-extensions.md) for the type parameter will be appropriately interpreted by the runtime as the simple creation of a value type if the type argument is a value type.  \n  \n You can also declare a generic class with [Constraints on Generic Type Parameters (C++/CLI)](../windows/constraints-on-generic-type-parameters-cpp-cli.md) on the types that can be used for the type parameter. In the following example any type used for `ItemType` must implement the `IItem` interface. Attempting to use `int`, for example, which does not implement `IItem`, would produce a compile-time error because the type argument does not satisfy the constraint.  \n  \n```  \n// generic_classes_2.cpp  \n// compile with: /clr /c  \ninterface class IItem {};  \ngeneric <class ItemType>  \nwhere ItemType : IItem  \nref class Stack {};  \n```  \n  \n Generic classes in the same namespace cannot be overloaded by only changing the number or the types of type parameters. However, if each class lives in a different namespace, they can be overloaded. For example, consider the following two classes, `MyClass` and `MyClass<ItemType>`, in the namespaces `A` and `B`. The two classes can then be overloaded in a third namespace C:  \n  \n```  \n// generic_classes_3.cpp  \n// compile with: /clr /c  \nnamespace A {  \n   ref class MyClass {};  \n}  \n  \nnamespace B {  \n   generic <typename ItemType>   \n   ref class MyClass2 { };  \n}  \n  \nnamespace C {  \n   using namespace A;  \n   using namespace B;  \n  \n   ref class Test {  \n      static void F() {  \n         MyClass^ m1 = gcnew MyClass();   // OK  \n         MyClass2<int>^ m2 = gcnew MyClass2<int>();   // OK  \n      }  \n   };  \n}  \n```  \n  \n The base class and base interfaces cannot be type parameters. However, the base class can involve the type parameter as an argument, as in the following case:  \n  \n```  \n// generic_classes_4.cpp  \n// compile with: /clr /c  \ngeneric <typename ItemType>  \ninterface class IInterface {};  \n  \ngeneric <typename ItemType>  \nref class MyClass : IInterface<ItemType> {};  \n```  \n  \n Constructors and destructors are executed once for each object instance (as usual); static constructors are executed once for each constructed type.  \n  \n## Fields in Generic Classes  \n This section demonstrates the use of instance and static fields in generic classes.  \n  \n### Instance Variables  \n Instance variables of a generic class can have types and variable initializers that include any type parameters from the enclosing class.  \n  \n## Example  \n In the following example, three different instances of the generic class, MyClass\\<ItemType>, are created by using the appropriate type arguments (`int`, **double**, and **string**).  \n  \n```  \n// generics_instance_fields1.cpp  \n// compile with: /clr  \n// Instance fields on generic classes  \nusing namespace System;  \n  \ngeneric <typename ItemType>  \nref class MyClass {  \n// Field of the type ItemType:  \npublic :  \n   ItemType field1;  \n   // Constructor using a parameter of the type ItemType:  \n   MyClass(ItemType p) {  \n     field1 = p;   \n   }  \n};  \n  \nint main() {  \n   // Instantiate an instance with an integer field:  \n   MyClass<int>^ myObj1 = gcnew MyClass<int>(123);  \n   Console::WriteLine(\"Integer field = {0}\", myObj1->field1);  \n  \n   // Instantiate an instance with a double field:  \n   MyClass<double>^ myObj2 = gcnew MyClass<double>(1.23);  \n   Console::WriteLine(\"Double field = {0}\", myObj2->field1);  \n  \n   // Instantiate an instance with a String field:  \n   MyClass<String^>^ myObj3 = gcnew MyClass<String^>(\"ABC\");  \n   Console::WriteLine(\"String field = {0}\", myObj3->field1);  \n   }  \n```  \n  \n```Output  \nInteger field = 123  \nDouble field = 1.23  \nString field = ABC  \n```  \n  \n## Static Variables  \n On the creation of a new generic type, new instances of any static variables are created and any static constructor for that type is executed.  \n  \n Static variables can use any type parameters from the enclosing class.  \n  \n## Example  \n The following example demonstrates using static fields and a static constructor within a generic class.  \n  \n```  \n// generics_static2.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \ninterface class ILog {  \n   void Write(String^ s);  \n};  \n  \nref class DateTimeLog : ILog {  \npublic:  \n   virtual void Write(String^ s) {  \n      Console::WriteLine( \"{0}\\t{1}\", DateTime::Now, s);  \n   }  \n};  \n  \nref class PlainLog : ILog {  \npublic:  \n   virtual void Write(String^ s) { Console::WriteLine(s); }  \n};  \n  \ngeneric <typename LogType>  \nwhere LogType : ILog  \nref class G {  \n   static LogType s_log;  \n  \npublic:  \n   G(){}  \n   void SetLog(LogType log) { s_log = log; }  \n   void F() { s_log->Write(\"Test1\"); }  \n   static G() { Console::WriteLine(\"Static constructor called.\"); }     \n};  \n  \nint main() {  \n   G<PlainLog^>^ g1 = gcnew G<PlainLog^>();  \n   g1->SetLog(gcnew PlainLog());  \n   g1->F();  \n  \n   G<DateTimeLog^>^ g2 = gcnew G<DateTimeLog^>();  \n   g2->SetLog(gcnew DateTimeLog());  \n  \n   // prints date  \n   // g2->F();  \n}  \n```  \n  \n```Output  \nStatic constructor called.  \nStatic constructor called.  \nStatic constructor called.  \nTest1  \n```  \n  \n## Methods in Generic Classes  \n Methods in generic classes can be generic themselves; non-generic methods will be implicitly parameterized by the class type parameter.  \n  \n The following special rules apply to methods within generic classes:  \n  \n-   Methods in generic classes can use type parameters as parameters, return types, or local variables.  \n  \n-   Methods in generic classes can use open or closed constructed types as parameters, return types, or local variables.  \n  \n### Non-Generic Methods in Generic Classes  \n Methods in generic classes that have no additional type parameters are usually referred to as non-generic although they are implicitly parameterized by the enclosing generic class.  \n  \n The signature of a non-generic method can include one or more type parameters of the enclosing class, either directly or in an open constructed type. For example:  \n  \n `void MyMethod(MyClass<ItemType> x) {}`  \n  \n The body of such methods can also use these type parameters.  \n  \n## Example  \n The following example declares a non-generic method, `ProtectData`, inside a generic class, `MyClass<ItemType>`. The method uses the class type parameter `ItemType` in its signature in an open constructed type.  \n  \n```  \n// generics_non_generic_methods1.cpp  \n// compile with: /clr  \n// Non-generic methods within a generic class.  \nusing namespace System;  \n  \ngeneric <typename ItemType>  \nref class MyClass {  \npublic:  \n   String^ name;  \n   ItemType data;  \n  \n   MyClass(ItemType x) {  \n      data = x;  \n   }  \n  \n   // Non-generic method using the type parameter:  \n   virtual void ProtectData(MyClass<ItemType>^ x) {  \n      data = x->data;  \n   }  \n};  \n  \n// ItemType defined as String^  \nref class MyMainClass: MyClass<String^> {  \npublic:  \n   // Passing \"123.00\" to the constructor:  \n   MyMainClass(): MyClass<String^>(\"123.00\") {  \n      name = \"Jeff Smith\";   \n   }   \n  \n   virtual void ProtectData(MyClass<String^>^ x) override {  \n      x->data = String::Format(\"${0}**\", x->data);  \n   }  \n  \n   static void Main() {  \n      MyMainClass^ x1 = gcnew MyMainClass();  \n  \n      x1->ProtectData(x1);  \n      Console::WriteLine(\"Name: {0}\", x1->name);  \n      Console::WriteLine(\"Amount: {0}\", x1->data);  \n   }  \n};  \n  \nint main() {  \n   MyMainClass::Main();  \n}  \n```  \n  \n```Output  \nName: Jeff Smith  \nAmount: $123.00**  \n```  \n  \n## Generic Methods in Generic Classes  \n You can declare generic methods in both generic and non-generic classes. For example:  \n  \n## Example  \n  \n```  \n// generics_method2.cpp  \n// compile with: /clr /c  \ngeneric <typename Type1>  \nref class G {  \npublic:  \n   // Generic method having a type parameter  \n   // from the class, Type1, and its own type  \n   // parameter, Type2  \n   generic <typename Type2>  \n   void Method1(Type1 t1, Type2 t2) { F(t1, t2); }  \n  \n   // Non-generic method:  \n   // Can use the class type param, Type1, but not Type2.  \n   void Method2(Type1 t1) { F(t1, t1); }  \n  \n   void F(Object^ o1, Object^ o2) {}  \n};  \n```  \n  \n The non-generic method is still generic in the sense that it is parameterized by the class's type parameter, but it has no additional type parameters.  \n  \n All types of methods in generic classes can be generic, including static, instance, and virtual methods.  \n  \n## Example  \n The following example demonstrates declaring and using generic methods within generic classes:  \n  \n```  \n// generics_generic_method2.cpp  \n// compile with: /clr  \nusing namespace System;  \ngeneric <class ItemType>  \nref class MyClass {  \npublic:  \n   // Declare a generic method member.  \n   generic <class Type1>  \n   String^ MyMethod(ItemType item, Type1 t) {  \n      return String::Concat(item->ToString(), t->ToString());  \n   }  \n};  \n  \nint main() {  \n   // Create instances using different types.  \n   MyClass<int>^ myObj1 = gcnew MyClass<int>();  \n   MyClass<String^>^ myObj2 = gcnew MyClass<String^>();  \n   MyClass<String^>^ myObj3 = gcnew MyClass<String^>();  \n  \n   // Calling MyMethod using two integers.  \n   Console::WriteLine(\"MyMethod returned: {0}\",  \n            myObj1->MyMethod<int>(1, 2));  \n  \n   // Calling MyMethod using an integer and a string.  \n   Console::WriteLine(\"MyMethod returned: {0}\",  \n            myObj2->MyMethod<int>(\"Hello #\", 1));  \n  \n   // Calling MyMethod using two strings.  \n   Console::WriteLine(\"MyMethod returned: {0}\",  \n       myObj3->MyMethod<String^>(\"Hello \", \"World!\"));  \n  \n   // generic methods can be called without specifying type arguments  \n   myObj1->MyMethod<int>(1, 2);  \n   myObj2->MyMethod<int>(\"Hello #\", 1);  \n   myObj3->MyMethod<String^>(\"Hello \", \"World!\");  \n}  \n```  \n  \n```Output  \nMyMethod returned: 12  \nMyMethod returned: Hello #1  \nMyMethod returned: Hello World!  \n```  \n  \n## Using Nested Types in Generic Classes  \n Just as with ordinary classes, you can declare other types inside a generic class. The nested class declaration is implicitly parameterized by the type parameters of the outer class declaration. Thus, a distinct nested class is defined for each constructed outer type. For example, in the declaration,  \n  \n```  \n// generic_classes_5.cpp  \n// compile with: /clr /c  \ngeneric <typename ItemType>  \nref struct Outer {  \n   ref class Inner {};  \n};  \n```  \n  \n The type Outer\\<int>::Inner is not the same as the type Outer\\<double>::Inner.  \n  \n As with generic methods in generic classes, additional type parameters can be defined for the nested type. If you use the same type parameter names in the inner and outer class, the inner type parameter will hide the outer type parameter.  \n  \n```  \n// generic_classes_6.cpp  \n// compile with: /clr /c  \ngeneric <typename ItemType>  \nref class Outer {  \n   ItemType outer_item;   // refers to outer ItemType  \n  \n   generic <typename ItemType>  \n   ref class Inner {  \n      ItemType inner_item;   // refers to Inner ItemType  \n   };  \n};  \n```  \n  \n Since there is no way to refer to the outer type parameter, the compiler will produce a warning in this situation.  \n  \n When constructed nested generic types are named, the type parameter for the outer type is not included in the type parameter list for the inner type, even though the inner type is implicitly parameterized by the outer type's type parameter. In the above case, a name of a constructed type would be Outer\\<int>::Inner\\<string>.  \n  \n The following example demonstrates building and reading a linked list using nested types in generic classes.  \n  \n## Example  \n  \n```  \n// generics_linked_list.cpp  \n// compile with: /clr  \nusing namespace System;  \ngeneric <class ItemType>  \nref class LinkedList {  \n// The node class:  \npublic:  \n   ref class Node {  \n   // The link field:  \n   public:  \n      Node^ next;  \n      // The data field:  \n      ItemType item;   \n   } ^first, ^current;  \n};  \n  \nref class ListBuilder {  \npublic:  \n   void BuildIt(LinkedList<double>^ list) {  \n      /* Build the list */  \n      double m[5] = {0.1, 0.2, 0.3, 0.4, 0.5};  \n      Console::WriteLine(\"Building the list:\");  \n  \n      for (int n=0; n<=4; n++) {  \n         // Create a new node:  \n         list->current = gcnew LinkedList<double>::Node();  \n  \n         // Assign a value to the data field:  \n         list->current->item = m[n];  \n  \n         // Set the link field \"next\" to be the same as   \n         // the \"first\" field:  \n         list->current->next = list->first;  \n  \n         // Redirect \"first\" to the new node:  \n         list->first = list->current;  \n  \n         // Display node's data as it builds:  \n         Console::WriteLine(list->current->item);  \n      }  \n   }  \n  \n   void ReadIt(LinkedList<double>^ list) {  \n      // Read the list  \n      // Make \"first\" the \"current\" link field:  \n      list->current = list->first;  \n      Console::WriteLine(\"Reading nodes:\");  \n  \n      // Read nodes until current == null:  \n      while (list->current != nullptr) {  \n         // Display the node's data field:  \n         Console::WriteLine(list->current->item);  \n  \n         // Move to the next node:  \n         list->current = list->current->next;  \n      }  \n   }  \n};  \n  \nint main() {  \n   // Create a list:  \n   LinkedList<double>^ aList = gcnew LinkedList<double>();  \n  \n   // Initialize first node:  \n   aList->first = nullptr;  \n  \n   // Instantiate the class, build, and read the list:   \n   ListBuilder^ myListBuilder = gcnew ListBuilder();  \n   myListBuilder->BuildIt(aList);  \n   myListBuilder->ReadIt(aList);  \n}  \n```  \n  \n```Output  \nBuilding the list:  \n0.1  \n0.2  \n0.3  \n0.4  \n0.5  \nReading nodes:  \n0.5  \n0.4  \n0.3  \n0.2  \n0.1  \n```  \n  \n## Properties, Events, Indexers and Operators in Generic Classes  \n  \n-   Properties, events, indexers and operators can use the type parameters of the enclosing generic class as return values, parameters, or local variables, such as when `ItemType` is a type parameter of a class:  \n  \n    ```  \n    public ItemType MyProperty {}  \n    ```  \n  \n-   Properties, events, indexers and operators cannot themselves be parameterized.  \n  \n## Example  \n This example shows declarations of an instance property within a generic class.  \n  \n```  \n// generics_generic_properties1.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \ngeneric <typename ItemType>  \nref class MyClass {  \nprivate:  \n   property ItemType myField;  \n  \npublic:  \n   property ItemType MyProperty {  \n      ItemType get() {  \n         return myField;   \n      }  \n      void set(ItemType value) {  \n         myField = value;  \n      }  \n   }  \n};  \n  \nint main() {  \n   MyClass<String^>^ c = gcnew MyClass<String^>();  \n   MyClass<int>^ c1 = gcnew MyClass<int>();  \n  \n   c->MyProperty = \"John\";  \n   c1->MyProperty = 234;  \n  \n   Console::Write(\"{0}, {1}\", c->MyProperty, c1->MyProperty);  \n}  \n```  \n  \n```Output  \nJohn, 234  \n```  \n  \n## Example  \n The next example shows a generic class with an event.  \n  \n```  \n// generics_generic_with_event.cpp  \n// compile with: /clr  \n// Declare a generic class with an event and  \n// invoke events.  \nusing namespace System;  \n  \n// declare delegates  \ngeneric <typename ItemType>  \ndelegate void ClickEventHandler(ItemType);  \n  \n// generic class that defines events  \ngeneric <typename ItemType>  \nref class EventSource {  \npublic:  \n   // declare the event OnClick  \n   event ClickEventHandler<ItemType>^ OnClick;   \n   void FireEvents(ItemType item) {  \n      // raises events  \n      OnClick(item);  \n   }  \n};  \n  \n// generic class that defines methods that will called when  \n// event occurs  \ngeneric <typename ItemType>  \nref class EventReceiver {  \npublic:  \n   void OnMyClick(ItemType item) {  \n     Console::WriteLine(\"OnClick: {0}\", item);  \n   }  \n};  \n  \nint main() {  \n   EventSource<String^>^ MyEventSourceString =  \n                   gcnew EventSource<String^>();  \n   EventSource<int>^ MyEventSourceInt = gcnew EventSource<int>();  \n   EventReceiver<String^>^ MyEventReceiverString =  \n                   gcnew EventReceiver<String^>();  \n   EventReceiver<int>^ MyEventReceiverInt = gcnew EventReceiver<int>();  \n  \n   // hook handler to event  \n   MyEventSourceString->OnClick += gcnew ClickEventHandler<String^>(  \n       MyEventReceiverString, &EventReceiver<String^>::OnMyClick);  \n   MyEventSourceInt->OnClick += gcnew ClickEventHandler<int>(  \n             MyEventReceiverInt, &EventReceiver<int>::OnMyClick);  \n  \n   // invoke events  \n   MyEventSourceString->FireEvents(\"Hello\");  \n   MyEventSourceInt->FireEvents(112);  \n  \n   // unhook handler to event  \n   MyEventSourceString->OnClick -= gcnew ClickEventHandler<String^>(  \n        MyEventReceiverString, &EventReceiver<String^>::OnMyClick);  \n   MyEventSourceInt->OnClick -= gcnew ClickEventHandler<int>(  \n        MyEventReceiverInt, &EventReceiver<int>::OnMyClick);  \n}  \n```  \n  \n## Generic Structs  \n The rules for declaring and using generic structs are the same as those for generic classes, except for the differences noted in in the Visual C++ language reference.  \n  \n## Example  \n The following example declares a generic struct, `MyGenStruct`, with one field, `myField`, and assigns values of different types (`int`, **double**, **String^**) to this field.  \n  \n```  \n// generics_generic_struct1.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \ngeneric <typename ItemType>  \nref struct MyGenStruct {  \npublic:  \n   ItemType myField;  \n  \n   ItemType AssignValue(ItemType item) {  \n      myField = item;  \n      return myField;  \n   }  \n};  \n  \nint main() {  \n   int myInt = 123;  \n   MyGenStruct<int>^ myIntObj = gcnew MyGenStruct<int>();  \n   myIntObj->AssignValue(myInt);  \n   Console::WriteLine(\"The field is assigned the integer value: {0}\",  \n            myIntObj->myField);  \n  \n   double myDouble = 0.123;  \n   MyGenStruct<double>^ myDoubleObj = gcnew MyGenStruct<double>();  \n   myDoubleObj->AssignValue(myDouble);  \n   Console::WriteLine(\"The field is assigned the double value: {0}\",  \n            myDoubleObj->myField);  \n  \n   String^ myString = \"Hello Generics!\";  \n   MyGenStruct<String^>^ myStringObj = gcnew MyGenStruct<String^>();  \n   myStringObj->AssignValue(myString);  \n   Console::WriteLine(\"The field is assigned the string: {0}\",  \n            myStringObj->myField);  \n}  \n```  \n  \n```Output  \nThe field is assigned the integer value: 123  \nThe field is assigned the double value: 0.123  \nThe field is assigned the string: Hello Generics!  \n```  \n  \n## See Also  \n [Generics](../windows/generics-cpp-component-extensions.md)"}