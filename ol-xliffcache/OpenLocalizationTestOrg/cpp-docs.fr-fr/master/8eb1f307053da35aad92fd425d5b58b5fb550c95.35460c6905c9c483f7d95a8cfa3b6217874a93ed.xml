{"nodes":[{"pos":[12,50],"content":"delete Operator (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"delete Operator (C++) | Microsoft Docs","pos":[0,38]}]},{"content":"delete Operator (C++)","pos":[718,739]},{"content":"Deallocates a block of memory.","pos":[740,770]},{"content":"Syntax","pos":[779,785]},{"content":"Remarks","pos":[873,880]},{"content":"The <bpt id=\"p1\">*</bpt>cast-expression<ept id=\"p1\">*</ept> argument must be a pointer to a block of memory previously allocated for an object created with the <bpt id=\"p2\">[</bpt>new operator<ept id=\"p2\">](../cpp/new-operator-cpp.md)</ept>.","pos":[884,1049],"source":"The *cast-expression* argument must be a pointer to a block of memory previously allocated for an object created with the [new operator](../cpp/new-operator-cpp.md)."},{"content":"The <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> operator has a result of type <ph id=\"ph1\">`void`</ph> and therefore does not return a value.","pos":[1050,1140],"source":" The **delete** operator has a result of type `void` and therefore does not return a value."},{"content":"For example:","pos":[1141,1153]},{"content":"Using <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> on a pointer to an object not allocated with <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> gives unpredictable results.","pos":[1247,1345],"source":"Using **delete** on a pointer to an object not allocated with **new** gives unpredictable results."},{"content":"You can, however, use <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> on a pointer with the value 0.","pos":[1346,1409],"source":" You can, however, use **delete** on a pointer with the value 0."},{"content":"This provision means that, when <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> returns 0 on failure, deleting the result of a failed <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> operation is harmless.","pos":[1410,1534],"source":" This provision means that, when **new** returns 0 on failure, deleting the result of a failed **new** operation is harmless."},{"content":"See <bpt id=\"p1\">[</bpt>The new and delete Operators<ept id=\"p1\">](../cpp/new-and-delete-operators.md)</ept> for more information.","pos":[1535,1627],"source":" See [The new and delete Operators](../cpp/new-and-delete-operators.md) for more information."},{"content":"The <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>delete<ept id=\"p2\">**</ept> operators can also be used for built-in types, including arrays.","pos":[1634,1725],"source":"The **new** and **delete** operators can also be used for built-in types, including arrays."},{"content":"If <ph id=\"ph1\">`pointer`</ph> refers to an array, place empty brackets before <ph id=\"ph2\">`pointer`</ph>:","pos":[1726,1797],"source":" If `pointer` refers to an array, place empty brackets before `pointer`:"},{"content":"Using the <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> operator on an object deallocates its memory.","pos":[1877,1943],"source":"Using the **delete** operator on an object deallocates its memory."},{"content":"A program that dereferences a pointer after the object is deleted can have unpredictable results or crash.","pos":[1944,2050]},{"pos":[2057,2235],"content":"When <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> is used to deallocate memory for a C++ class object, the object's destructor is called before the object's memory is deallocated (if the object has a destructor).","source":"When **delete** is used to deallocate memory for a C++ class object, the object's destructor is called before the object's memory is deallocated (if the object has a destructor)."},{"pos":[2242,2360],"content":"If the operand to the <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept> operator is a modifiable l-value, its value is undefined after the object is deleted.","source":"If the operand to the **delete** operator is a modifiable l-value, its value is undefined after the object is deleted."},{"content":"Using delete","pos":[2369,2381]},{"content":"There are two syntactic variants for the <bpt id=\"p1\">[</bpt>delete operator<ept id=\"p1\">](../cpp/delete-operator-cpp.md)</ept>: one for single objects and the other for arrays of objects.","pos":[2385,2535],"source":"There are two syntactic variants for the [delete operator](../cpp/delete-operator-cpp.md): one for single objects and the other for arrays of objects."},{"content":"The following code fragment shows how these differ:","pos":[2536,2587]},{"content":"The following two cases produce undefined results: using the array form of delete (delete [ ]) on an object and using the nonarray form of delete on an array.","pos":[3200,3358]},{"content":"Example","pos":[3367,3374]},{"pos":[3378,3459],"content":"For examples of using <bpt id=\"p1\">**</bpt>delete<ept id=\"p1\">**</ept>, see <bpt id=\"p2\">[</bpt>new operator<ept id=\"p2\">](../cpp/new-operator-cpp.md)</ept>.","source":"For examples of using **delete**, see [new operator](../cpp/new-operator-cpp.md)."},{"content":"How delete works","pos":[3468,3484]},{"pos":[3488,3549],"content":"The delete operator invokes the function <bpt id=\"p1\">**</bpt>operator delete<ept id=\"p1\">**</ept>.","source":"The delete operator invokes the function **operator delete**."},{"content":"For objects not of class type (<bpt id=\"p1\">[</bpt>class<ept id=\"p1\">](../cpp/class-cpp.md)</ept>, <bpt id=\"p2\">[</bpt>struct<ept id=\"p2\">](../cpp/struct-cpp.md)</ept>, or <bpt id=\"p3\">[</bpt>union<ept id=\"p3\">](../cpp/unions.md)</ept>), the global delete operator is invoked.","pos":[3556,3718],"source":"For objects not of class type ([class](../cpp/class-cpp.md), [struct](../cpp/struct-cpp.md), or [union](../cpp/unions.md)), the global delete operator is invoked."},{"content":"For objects of class type, the name of the deallocation function is resolved in global scope if the delete expression begins with the unary scope resolution operator (::).","pos":[3719,3890]},{"content":"Otherwise, the delete operator invokes the destructor for an object prior to deallocating memory (if the pointer is not null).","pos":[3891,4017]},{"content":"The delete operator can be defined on a per-class basis; if there is no such definition for a given class, the global operator delete is invoked.","pos":[4018,4163]},{"content":"If the delete expression is used to deallocate a class object whose static type has a virtual destructor, the deallocation function is resolved through the virtual destructor of the dynamic type of the object.","pos":[4164,4373]},{"content":"See Also","pos":[4382,4390]},{"content":"Expressions with Unary Operators","pos":[4395,4427]},{"content":"Keywords","pos":[4478,4486]},{"content":"new and delete Operators","pos":[4517,4541]}],"content":"---\ntitle: \"delete Operator (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"delete_cpp\"\n  - \"delete\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"delete keyword [C++], syntax\"\n  - \"delete keyword [C++], deallocating objects\"\n  - \"delete keyword [C++]\"\nms.assetid: de39c900-3f57-489c-9598-dcb73c4b3930\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# delete Operator (C++)\nDeallocates a block of memory.  \n  \n## Syntax  \n  \n```  \n[::] delete cast-expression  \n[::] delete [ ] cast-expression  \n```  \n  \n## Remarks  \n The *cast-expression* argument must be a pointer to a block of memory previously allocated for an object created with the [new operator](../cpp/new-operator-cpp.md). The **delete** operator has a result of type `void` and therefore does not return a value. For example:  \n  \n```  \nCDialog* MyDialog = new CDialog;  \n// use MyDialog  \ndelete MyDialog;  \n```  \n  \n Using **delete** on a pointer to an object not allocated with **new** gives unpredictable results. You can, however, use **delete** on a pointer with the value 0. This provision means that, when **new** returns 0 on failure, deleting the result of a failed **new** operation is harmless. See [The new and delete Operators](../cpp/new-and-delete-operators.md) for more information.  \n  \n The **new** and **delete** operators can also be used for built-in types, including arrays. If `pointer` refers to an array, place empty brackets before `pointer`:  \n  \n```  \nint* set = new int[100];  \n//use set[]  \ndelete [] set;  \n```  \n  \n Using the **delete** operator on an object deallocates its memory. A program that dereferences a pointer after the object is deleted can have unpredictable results or crash.  \n  \n When **delete** is used to deallocate memory for a C++ class object, the object's destructor is called before the object's memory is deallocated (if the object has a destructor).  \n  \n If the operand to the **delete** operator is a modifiable l-value, its value is undefined after the object is deleted.  \n  \n## Using delete  \n There are two syntactic variants for the [delete operator](../cpp/delete-operator-cpp.md): one for single objects and the other for arrays of objects. The following code fragment shows how these differ:  \n  \n```  \n// expre_Using_delete.cpp  \nstruct UDType   \n{  \n};  \n  \nint main()  \n{  \n   // Allocate a user-defined object, UDObject, and an object  \n   //  of type double on the free store using the  \n   //  new operator.  \n   UDType *UDObject = new UDType;  \n   double *dObject = new double;  \n   // Delete the two objects.  \n   delete UDObject;  \n   delete dObject;   \n   // Allocate an array of user-defined objects on the  \n   // free store using the new operator.  \n   UDType (*UDArr)[7] = new UDType[5][7];  \n   // Use the array syntax to delete the array of objects.  \n   delete [] UDArr;  \n}  \n```  \n  \n The following two cases produce undefined results: using the array form of delete (delete [ ]) on an object and using the nonarray form of delete on an array.  \n  \n## Example  \n For examples of using **delete**, see [new operator](../cpp/new-operator-cpp.md).  \n  \n## How delete works  \n The delete operator invokes the function **operator delete**.  \n  \n For objects not of class type ([class](../cpp/class-cpp.md), [struct](../cpp/struct-cpp.md), or [union](../cpp/unions.md)), the global delete operator is invoked. For objects of class type, the name of the deallocation function is resolved in global scope if the delete expression begins with the unary scope resolution operator (::). Otherwise, the delete operator invokes the destructor for an object prior to deallocating memory (if the pointer is not null). The delete operator can be defined on a per-class basis; if there is no such definition for a given class, the global operator delete is invoked. If the delete expression is used to deallocate a class object whose static type has a virtual destructor, the deallocation function is resolved through the virtual destructor of the dynamic type of the object.  \n  \n## See Also  \n [Expressions with Unary Operators](../cpp/expressions-with-unary-operators.md)   \n [Keywords](../cpp/keywords-cpp.md)   \n [new and delete Operators](../cpp/new-and-delete-operators.md)   \n \n"}