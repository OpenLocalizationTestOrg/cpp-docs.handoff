{"nodes":[{"pos":[12,81],"content":"3.2.1 omp_init_lock and omp_init_nest_lock Functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"3.2.1 omp_init_lock and omp_init_nest_lock Functions | Microsoft Docs","pos":[0,69]}]},{"content":"3.2.1 omp_init_lock and omp_init_nest_lock Functions","pos":[561,613]},{"content":"These functions provide the only means of initializing a lock.","pos":[614,676]},{"content":"Each function initializes the lock associated with the parameter <bpt id=\"p1\">*</bpt>lock<ept id=\"p1\">*</ept> for use in subsequent calls.","pos":[677,777],"source":" Each function initializes the lock associated with the parameter *lock* for use in subsequent calls."},{"content":"The format is as follows:","pos":[778,803]},{"content":"The initial state is unlocked (that is, no thread owns the lock).","pos":[934,999]},{"content":"For a nestable lock, the initial nesting count is zero.","pos":[1000,1055]},{"content":"It is noncompliant to call either of these routines with a lock variable that has already been initialized.","pos":[1056,1163]}],"content":"---\ntitle: \"3.2.1 omp_init_lock and omp_init_nest_lock Functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 098a2721-b16a-484f-bc83-4b8e281e382c\ncaps.latest.revision: 6\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# 3.2.1 omp_init_lock and omp_init_nest_lock Functions\nThese functions provide the only means of initializing a lock. Each function initializes the lock associated with the parameter *lock* for use in subsequent calls. The format is as follows:  \n  \n```  \n#include <omp.h>  \nvoid omp_init_lock(omp_lock_t *lock);  \nvoid omp_init_nest_lock(omp_nest_lock_t *lock);  \n```  \n  \n The initial state is unlocked (that is, no thread owns the lock). For a nestable lock, the initial nesting count is zero. It is noncompliant to call either of these routines with a lock variable that has already been initialized."}