{"nodes":[{"pos":[12,59],"content":"Provider Support for Bookmarks | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Provider Support for Bookmarks | Microsoft Docs","pos":[0,47]}]},{"content":"Provider Support for Bookmarks","pos":[753,783]},{"content":"The example in this topic adds the <ph id=\"ph1\">`IRowsetLocate`</ph> interface to the <ph id=\"ph2\">`CMyProviderRowset`</ph> class.","pos":[784,878],"source":"The example in this topic adds the `IRowsetLocate` interface to the `CMyProviderRowset` class."},{"content":"In almost all cases, you start by adding an interface to an existing COM object.","pos":[879,959]},{"content":"You can then test it by adding more calls from the consumer templates.","pos":[960,1030]},{"content":"The example demonstrates how to:","pos":[1031,1063]},{"content":"Add an interface to a provider.","pos":[1073,1104]},{"content":"Dynamically determine the columns to return to the consumer.","pos":[1114,1174]},{"content":"Add bookmark support.","pos":[1184,1205]},{"content":"The <ph id=\"ph1\">`IRowsetLocate`</ph> interface inherits from the <ph id=\"ph2\">`IRowset`</ph> interface.","pos":[1212,1280],"source":"The `IRowsetLocate` interface inherits from the `IRowset` interface."},{"content":"To add the <ph id=\"ph1\">`IRowsetLocate`</ph> interface, inherit <ph id=\"ph2\">`CMyProviderRowset`</ph> from <bpt id=\"p1\">[</bpt>IRowsetLocateImpl<ept id=\"p1\">](../../data/oledb/irowsetlocateimpl-class.md)</ept>.","pos":[1281,1417],"source":" To add the `IRowsetLocate` interface, inherit `CMyProviderRowset` from [IRowsetLocateImpl](../../data/oledb/irowsetlocateimpl-class.md)."},{"content":"Adding the <ph id=\"ph1\">`IRowsetLocate`</ph> interface is a bit different from most interfaces.","pos":[1424,1501],"source":"Adding the `IRowsetLocate` interface is a bit different from most interfaces."},{"content":"To make the VTABLEs line up, the OLE DB provider templates have a template parameter to handle the derived interface.","pos":[1502,1619]},{"content":"The following code shows the new inheritance list:","pos":[1620,1670]},{"content":"The fourth, fifth, and sixth parameters are all added.","pos":[2030,2084]},{"content":"This example uses the defaults for the fourth and fifth parameters but specify <ph id=\"ph1\">`IRowsetLocateImpl`</ph> as the sixth parameter.","pos":[2085,2207],"source":" This example uses the defaults for the fourth and fifth parameters but specify `IRowsetLocateImpl` as the sixth parameter."},{"content":"is an OLE DB template class that takes two template parameters: these hook up the <ph id=\"ph1\">`IRowsetLocate`</ph> interface to the <ph id=\"ph2\">`CMyProviderRowset`</ph> class.","pos":[2228,2369],"source":" is an OLE DB template class that takes two template parameters: these hook up the `IRowsetLocate` interface to the `CMyProviderRowset` class."},{"content":"To add most interfaces, you can skip this step and move to the next one.","pos":[2370,2442]},{"content":"Only the <ph id=\"ph1\">`IRowsetLocate`</ph> and <ph id=\"ph2\">`IRowsetScroll`</ph> interfaces need to be handled in this way.","pos":[2443,2530],"source":" Only the `IRowsetLocate` and `IRowsetScroll` interfaces need to be handled in this way."},{"content":"You then need to tell the <ph id=\"ph1\">`CMyProviderRowset`</ph> to call <ph id=\"ph2\">`QueryInterface`</ph> for the <ph id=\"ph3\">`IRowsetLocate`</ph> interface.","pos":[2537,2642],"source":"You then need to tell the `CMyProviderRowset` to call `QueryInterface` for the `IRowsetLocate` interface."},{"content":"Add the line <ph id=\"ph1\">`COM_INTERFACE_ENTRY(IRowsetLocate)`</ph> to the map.","pos":[2643,2704],"source":" Add the line `COM_INTERFACE_ENTRY(IRowsetLocate)` to the map."},{"content":"The interface map for <ph id=\"ph1\">`CMyProviderRowset`</ph> should appear as shown in the following code:","pos":[2705,2792],"source":" The interface map for `CMyProviderRowset` should appear as shown in the following code:"},{"content":"You also need to hook your map into the <ph id=\"ph1\">`CRowsetImpl`</ph> class.","pos":[3234,3294],"source":"You also need to hook your map into the `CRowsetImpl` class."},{"content":"Add in the COM_INTERFACE_ENTRY_CHAIN macro to hook in the <ph id=\"ph1\">`CRowsetImpl`</ph> map.","pos":[3295,3371],"source":" Add in the COM_INTERFACE_ENTRY_CHAIN macro to hook in the `CRowsetImpl` map."},{"content":"Also, create a typedef called <ph id=\"ph1\">`RowsetBaseClass`</ph> that consists of the inheritance information.","pos":[3372,3465],"source":" Also, create a typedef called `RowsetBaseClass` that consists of the inheritance information."},{"content":"This typedef is arbitrary and can be ignored.","pos":[3466,3511]},{"content":"Finally, handle the <bpt id=\"p1\">**</bpt>IColumnsInfo::GetColumnsInfo<ept id=\"p1\">**</ept> call.","pos":[3518,3576],"source":"Finally, handle the **IColumnsInfo::GetColumnsInfo** call."},{"content":"You would normally use the PROVIDER_COLUMN_ENTRY macros to do this.","pos":[3577,3644]},{"content":"However, a consumer might want to use bookmarks.","pos":[3645,3693]},{"content":"You must be able to change the columns the provider returns depending on whether the consumer asks for a bookmark.","pos":[3694,3808]},{"content":"To handle the <bpt id=\"p1\">**</bpt>IColumnsInfo::GetColumnsInfo<ept id=\"p1\">**</ept> call, delete the <bpt id=\"p2\">**</bpt>PROVIDER_COLUMN<ept id=\"p2\">**</ept> map in the <ph id=\"ph1\">`CTextData`</ph> class.","pos":[3815,3928],"source":"To handle the **IColumnsInfo::GetColumnsInfo** call, delete the **PROVIDER_COLUMN** map in the `CTextData` class."},{"content":"The PROVIDER_COLUMN_MAP macro defines a function <ph id=\"ph1\">`GetColumnInfo`</ph>.","pos":[3929,3994],"source":" The PROVIDER_COLUMN_MAP macro defines a function `GetColumnInfo`."},{"content":"You need to define your own <ph id=\"ph1\">`GetColumnInfo`</ph> function.","pos":[3995,4048],"source":" You need to define your own `GetColumnInfo` function."},{"content":"The function declaration should look like this:","pos":[4049,4096]},{"pos":[4508,4593],"content":"Then, implement the <ph id=\"ph1\">`GetColumnInfo`</ph> function in the MyProviderRS.cpp file as follows:","source":"Then, implement the `GetColumnInfo` function in the MyProviderRS.cpp file as follows:"},{"content":"first checks to see whether a property called <bpt id=\"p1\">**</bpt>DBPROP_IRowsetLocate<ept id=\"p1\">**</ept> is set.","pos":[6624,6702],"source":" first checks to see whether a property called **DBPROP_IRowsetLocate** is set."},{"content":"OLE DB has properties for each of the optional interfaces off the rowset object.","pos":[6703,6783]},{"content":"If the consumer wants to use one of these optional interfaces, it sets a property to true.","pos":[6784,6874]},{"content":"The provider can then check this property and take special action based on it.","pos":[6875,6953]},{"content":"In your implementation, you get the property by using the pointer to the command object.","pos":[6960,7048]},{"content":"The <ph id=\"ph1\">`pThis`</ph> pointer represents the rowset or command class.","pos":[7049,7108],"source":" The `pThis` pointer represents the rowset or command class."},{"content":"Because you use templates here, you have to pass this in as a <ph id=\"ph1\">`void`</ph> pointer or the code does not compile.","pos":[7109,7215],"source":" Because you use templates here, you have to pass this in as a `void` pointer or the code does not compile."},{"content":"Specify a static array to contain the column information.","pos":[7222,7279]},{"content":"If the consumer does not want the bookmark column, an entry in the array is wasted.","pos":[7280,7363]},{"content":"You can dynamically allocate this array, but you would need to make sure to destroy it properly.","pos":[7364,7460]},{"content":"This example defines and uses the macros ADD_COLUMN_ENTRY and ADD_COLUMN_ENTRY_EX to insert the information into the array.","pos":[7461,7584]},{"content":"You can add the macros to the MyProviderRS.H file as shown in the following code:","pos":[7585,7666]},{"content":"To test the code in the consumer, you need to make a few changes to the <ph id=\"ph1\">`OnRun`</ph> handler.","pos":[9103,9191],"source":"To test the code in the consumer, you need to make a few changes to the `OnRun` handler."},{"content":"The first change to the function is that you add code to add a property to the property set.","pos":[9192,9284]},{"content":"The code sets the <bpt id=\"p1\">**</bpt>DBPROP_IRowsetLocate<ept id=\"p1\">**</ept> property to true, thus telling the provider that you want the bookmark column.","pos":[9285,9406],"source":" The code sets the **DBPROP_IRowsetLocate** property to true, thus telling the provider that you want the bookmark column."},{"content":"The <ph id=\"ph1\">`OnRun`</ph> handler code should appear as follows:","pos":[9407,9457],"source":" The `OnRun` handler code should appear as follows:"},{"content":"The while loop contains code to call the <ph id=\"ph1\">`Compare`</ph> method in the <ph id=\"ph2\">`IRowsetLocate`</ph> interface.","pos":[10827,10918],"source":"The while loop contains code to call the `Compare` method in the `IRowsetLocate` interface."},{"content":"The code you have should always pass because you are comparing the exact same bookmarks.","pos":[10919,11007]},{"content":"Also, store one bookmark in a temporary variable so that you can use it after the while loop finishes to call the <ph id=\"ph1\">`MoveToBookmark`</ph> function in the consumer templates.","pos":[11008,11174],"source":" Also, store one bookmark in a temporary variable so that you can use it after the while loop finishes to call the `MoveToBookmark` function in the consumer templates."},{"content":"The <ph id=\"ph1\">`MoveToBookmark`</ph> function calls the <ph id=\"ph2\">`GetRowsAt`</ph> method in <ph id=\"ph3\">`IRowsetLocate`</ph>.","pos":[11175,11253],"source":" The `MoveToBookmark` function calls the `GetRowsAt` method in `IRowsetLocate`."},{"content":"You also need to update the user record in the consumer.","pos":[11260,11316]},{"content":"Add an entry in the class to handle a bookmark and an entry in the <bpt id=\"p1\">**</bpt>COLUMN_MAP<ept id=\"p1\">**</ept>:","pos":[11317,11399],"source":" Add an entry in the class to handle a bookmark and an entry in the **COLUMN_MAP**:"},{"pos":[11940,12060],"content":"When you have updated the code, you should be able to build and execute the provider with the <ph id=\"ph1\">`IRowsetLocate`</ph> interface.","source":"When you have updated the code, you should be able to build and execute the provider with the `IRowsetLocate` interface."},{"content":"See Also","pos":[12069,12077]},{"content":"Advanced Provider Techniques","pos":[12082,12110]}],"content":"---\ntitle: \"Provider Support for Bookmarks | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"IRowsetLocate class, provider support for bookmarks\"\n  - \"OLE DB provider templates, bookmarks\"\n  - \"bookmarks, OLE DB\"\n  - \"IRowsetLocate class\"\n  - \"OLE DB providers, bookmark support\"\nms.assetid: 1b14ccff-4f76-462e-96ab-1aada815c377\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Provider Support for Bookmarks\nThe example in this topic adds the `IRowsetLocate` interface to the `CMyProviderRowset` class. In almost all cases, you start by adding an interface to an existing COM object. You can then test it by adding more calls from the consumer templates. The example demonstrates how to:  \n  \n-   Add an interface to a provider.  \n  \n-   Dynamically determine the columns to return to the consumer.  \n  \n-   Add bookmark support.  \n  \n The `IRowsetLocate` interface inherits from the `IRowset` interface. To add the `IRowsetLocate` interface, inherit `CMyProviderRowset` from [IRowsetLocateImpl](../../data/oledb/irowsetlocateimpl-class.md).  \n  \n Adding the `IRowsetLocate` interface is a bit different from most interfaces. To make the VTABLEs line up, the OLE DB provider templates have a template parameter to handle the derived interface. The following code shows the new inheritance list:  \n  \n```  \n////////////////////////////////////////////////////////////////////////  \n// MyProviderRS.h  \n  \n// CMyProviderRowset  \nclass CMyProviderRowset : public CRowsetImpl< CMyProviderRowset,   \n      CTextData, CMyProviderCommand, CAtlArray<CTextData>,   \n      CSimpleRow,   \n          IRowsetLocateImpl<CMyProviderRowset, IRowsetLocate> >  \n```  \n  \n The fourth, fifth, and sixth parameters are all added. This example uses the defaults for the fourth and fifth parameters but specify `IRowsetLocateImpl` as the sixth parameter. `IRowsetLocateImpl` is an OLE DB template class that takes two template parameters: these hook up the `IRowsetLocate` interface to the `CMyProviderRowset` class. To add most interfaces, you can skip this step and move to the next one. Only the `IRowsetLocate` and `IRowsetScroll` interfaces need to be handled in this way.  \n  \n You then need to tell the `CMyProviderRowset` to call `QueryInterface` for the `IRowsetLocate` interface. Add the line `COM_INTERFACE_ENTRY(IRowsetLocate)` to the map. The interface map for `CMyProviderRowset` should appear as shown in the following code:  \n  \n```  \n////////////////////////////////////////////////////////////////////////  \n// MyProviderRS.h  \n  \ntypedef CRowsetImpl< CMyProviderRowset, CTextData, CMyProviderCommand, CAtlArray<CTextData>, CSimpleRow, IRowsetLocateImpl<CMyProviderRowset, IRowsetLocate> > _RowsetBaseClass;  \n  \nBEGIN_COM_MAP(CMyProviderRowset)  \n   COM_INTERFACE_ENTRY(IRowsetLocate)  \n   COM_INTERFACE_ENTRY_CHAIN(_RowsetBaseClass)  \nEND_COM_MAP()  \n```  \n  \n You also need to hook your map into the `CRowsetImpl` class. Add in the COM_INTERFACE_ENTRY_CHAIN macro to hook in the `CRowsetImpl` map. Also, create a typedef called `RowsetBaseClass` that consists of the inheritance information. This typedef is arbitrary and can be ignored.  \n  \n Finally, handle the **IColumnsInfo::GetColumnsInfo** call. You would normally use the PROVIDER_COLUMN_ENTRY macros to do this. However, a consumer might want to use bookmarks. You must be able to change the columns the provider returns depending on whether the consumer asks for a bookmark.  \n  \n To handle the **IColumnsInfo::GetColumnsInfo** call, delete the **PROVIDER_COLUMN** map in the `CTextData` class. The PROVIDER_COLUMN_MAP macro defines a function `GetColumnInfo`. You need to define your own `GetColumnInfo` function. The function declaration should look like this:  \n  \n```  \n////////////////////////////////////////////////////////////////////////  \n// MyProviderRS.H  \n  \nclass CTextData  \n{  \n   ...  \n     // NOTE: Be sure you removed the PROVIDER_COLUMN_MAP!  \n   static ATLCOLUMNINFO* GetColumnInfo(CMyProviderRowset* pThis,   \n        ULONG* pcCols);  \n   static ATLCOLUMNINFO* GetColumnInfo(CMyProviderCommand* pThis,   \n        ULONG* pcCols);  \n...  \n};  \n```  \n  \n Then, implement the `GetColumnInfo` function in the MyProviderRS.cpp file as follows:  \n  \n```  \n////////////////////////////////////////////////////////////////////  \n// MyProviderRS.cpp  \n  \ntemplate <class TInterface>  \nATLCOLUMNINFO* CommonGetColInfo(IUnknown* pPropsUnk, ULONG* pcCols)  \n{  \n   static ATLCOLUMNINFO _rgColumns[5];  \n   ULONG ulCols = 0;  \n  \n   CComQIPtr<TInterface> spProps = pPropsUnk;  \n  \n   CDBPropIDSet set(DBPROPSET_ROWSET);  \n   set.AddPropertyID(DBPROP_BOOKMARKS);  \n   DBPROPSET* pPropSet = NULL;  \n   ULONG ulPropSet = 0;  \n   HRESULT hr;  \n  \n   if (spProps)  \n      hr = spProps->GetProperties(1, &set, &ulPropSet, &pPropSet);  \n  \n   // Check the property flag for bookmarks, if it is set, set the   \n// zero ordinal entry in the column map with the bookmark   \n// information.  \n  \n   if (pPropSet)  \n   {  \n      CComVariant var = pPropSet->rgProperties[0].vValue;  \n      CoTaskMemFree(pPropSet->rgProperties);  \n      CoTaskMemFree(pPropSet);  \n  \n      if ((SUCCEEDED(hr) && (var.boolVal == VARIANT_TRUE)))  \n      {  \n         ADD_COLUMN_ENTRY_EX(ulCols, OLESTR(\"Bookmark\"), 0,   \n                     sizeof(DWORD), DBTYPE_BYTES,  \n            0, 0, GUID_NULL, CAgentMan, dwBookmark,         \n                        DBCOLUMNFLAGS_ISBOOKMARK)  \n         ulCols++;  \n      }  \n  \n   }  \n  \n   // Next set the other columns up.  \n   ADD_COLUMN_ENTRY_EX(ulCols, OLESTR(\"Field1\"), 1, 16, DBTYPE_STR,   \n          0xFF, 0xFF, GUID_NULL, CTextData, szField1)  \n   ulCols++;  \n   ADD_COLUMN_ENTRY_EX(ulCols, OLESTR(\"Field2\"), 2, 16, DBTYPE_STR,  \n       0xFF, 0xFF, GUID_NULL, CTextData, szField2)  \n   ulCols++;  \n  \n   if (pcCols != NULL)  \n      *pcCols = ulCols;  \n  \n   return _rgColumns;  \n}  \n  \nATLCOLUMNINFO* CTextData::GetColumnInfo(CMyProviderCommand* pThis,   \n     ULONG* pcCols)  \n{  \n   return CommonGetColInfo<ICommandProperties>(pThis->GetUnknown(),  \n        pcCols);  \n}  \n  \nATLCOLUMNINFO* CAgentMan::GetColumnInfo(RUpdateRowset* pThis, ULONG* pcCols)  \n{  \n   return CommonGetColInfo<IRowsetInfo>(pThis->GetUnknown(), pcCols);  \n}  \n```  \n  \n `GetColumnInfo` first checks to see whether a property called **DBPROP_IRowsetLocate** is set. OLE DB has properties for each of the optional interfaces off the rowset object. If the consumer wants to use one of these optional interfaces, it sets a property to true. The provider can then check this property and take special action based on it.  \n  \n In your implementation, you get the property by using the pointer to the command object. The `pThis` pointer represents the rowset or command class. Because you use templates here, you have to pass this in as a `void` pointer or the code does not compile.  \n  \n Specify a static array to contain the column information. If the consumer does not want the bookmark column, an entry in the array is wasted. You can dynamically allocate this array, but you would need to make sure to destroy it properly. This example defines and uses the macros ADD_COLUMN_ENTRY and ADD_COLUMN_ENTRY_EX to insert the information into the array. You can add the macros to the MyProviderRS.H file as shown in the following code:  \n  \n```  \n////////////////////////////////////////////////////////////////////////  \n// MyProviderRS.h  \n  \n#define ADD_COLUMN_ENTRY(ulCols, name, ordinal, colSize, type, precision, scale, guid, dataClass, member) \\  \n   _rgColumns[ulCols].pwszName = (LPOLESTR)name; \\  \n   _rgColumns[ulCols].pTypeInfo = (ITypeInfo*)NULL; \\  \n   _rgColumns[ulCols].iOrdinal = (ULONG)ordinal; \\  \n   _rgColumns[ulCols].dwFlags = 0; \\  \n   _rgColumns[ulCols].ulColumnSize = (ULONG)colSize; \\  \n   _rgColumns[ulCols].wType = (DBTYPE)type; \\  \n   _rgColumns[ulCols].bPrecision = (BYTE)precision; \\  \n   _rgColumns[ulCols].bScale = (BYTE)scale; \\  \n   _rgColumns[ulCols].cbOffset = offsetof(dataClass, member);  \n  \n#define ADD_COLUMN_ENTRY_EX(ulCols, name, ordinal, colSize, type, precision, scale, guid, dataClass, member, flags) \\  \n   _rgColumns[ulCols].pwszName = (LPOLESTR)name; \\  \n   _rgColumns[ulCols].pTypeInfo = (ITypeInfo*)NULL; \\  \n   _rgColumns[ulCols].iOrdinal = (ULONG)ordinal; \\  \n   _rgColumns[ulCols].dwFlags = flags; \\  \n   _rgColumns[ulCols].ulColumnSize = (ULONG)colSize; \\  \n   _rgColumns[ulCols].wType = (DBTYPE)type; \\  \n   _rgColumns[ulCols].bPrecision = (BYTE)precision; \\  \n   _rgColumns[ulCols].bScale = (BYTE)scale; \\  \n   _rgColumns[ulCols].cbOffset = offsetof(dataClass, member); \\  \n   memset(&(_rgColumns[ulCols].columnid), 0, sizeof(DBID)); \\  \n   _rgColumns[ulCols].columnid.uName.pwszName = (LPOLESTR)name;  \n```  \n  \n To test the code in the consumer, you need to make a few changes to the `OnRun` handler. The first change to the function is that you add code to add a property to the property set. The code sets the **DBPROP_IRowsetLocate** property to true, thus telling the provider that you want the bookmark column. The `OnRun` handler code should appear as follows:  \n  \n```  \n//////////////////////////////////////////////////////////////////////  \n// TestProv Consumer Application in TestProvDlg.cpp  \n  \nvoid CTestProvDlg::OnRun()   \n{  \n   CCommand<CAccessor<CProvider> > table;  \n   CDataSource source;  \n   CSession   session;  \n  \n   if (source.Open(\"MyProvider.MyProvider.1\", NULL, NULL, NULL,   \n          NULL) != S_OK)  \n      return;  \n  \n   if (session.Open(source) != S_OK)  \n      return;  \n  \n   CDBPropSet propset(DBPROPSET_ROWSET);  \n   propset.AddProperty(DBPROP_IRowsetLocate, true);  \n   if (table.Open(session, _T(\"c:\\\\public\\\\testprf2\\\\myData.txt\"),   \n          &propset) != S_OK)  \n      return;  \n  \n   CBookmark<4> tempBookmark;  \n   ULONG ulCount=0;  \n   while (table.MoveNext() == S_OK)  \n   {  \n  \n      DBCOMPARE compare;  \n      if (ulCount == 2)  \n         tempBookmark = table.bookmark;  \n      HRESULT hr = table.Compare(table.dwBookmark, table.dwBookmark,  \n                 &compare);  \n      if (FAILED(hr))  \n         ATLTRACE(_T(\"Compare failed: 0x%X\\n\"), hr);  \n      else  \n         _ASSERTE(compare == DBCOMPARE_EQ);  \n  \n      m_ctlString1.AddString(table.szField1);  \n      m_ctlString2.AddString(table.szField2);  \n      ulCount++;  \n   }  \n  \n   table.MoveToBookmark(tempBookmark);  \n   m_ctlString1.AddString(table.szField1);  \n   m_ctlString2.AddString(table.szField2);  \n}  \n```  \n  \n The while loop contains code to call the `Compare` method in the `IRowsetLocate` interface. The code you have should always pass because you are comparing the exact same bookmarks. Also, store one bookmark in a temporary variable so that you can use it after the while loop finishes to call the `MoveToBookmark` function in the consumer templates. The `MoveToBookmark` function calls the `GetRowsAt` method in `IRowsetLocate`.  \n  \n You also need to update the user record in the consumer. Add an entry in the class to handle a bookmark and an entry in the **COLUMN_MAP**:  \n  \n```  \n///////////////////////////////////////////////////////////////////////  \n// TestProvDlg.cpp  \n  \nclass CProvider  \n{  \n// Attributes  \npublic:  \n   CBookmark<4>    bookmark;  // Add this line  \n   char   szCommand[16];  \n   char   szText[256];  \n  \n   // Binding Maps  \nBEGIN_ACCESSOR_MAP(CProvider, 1)  \n   BEGIN_ACCESSOR(0, true)   // auto accessor  \n      BOOKMARK_ENTRY(bookmark)  // Add this line  \n      COLUMN_ENTRY(1, szField1)  \n      COLUMN_ENTRY(2, szField2)  \n   END_ACCESSOR()  \nEND_ACCESSOR_MAP()  \n};  \n```  \n  \n When you have updated the code, you should be able to build and execute the provider with the `IRowsetLocate` interface.  \n  \n## See Also  \n [Advanced Provider Techniques](../../data/oledb/advanced-provider-techniques.md)"}