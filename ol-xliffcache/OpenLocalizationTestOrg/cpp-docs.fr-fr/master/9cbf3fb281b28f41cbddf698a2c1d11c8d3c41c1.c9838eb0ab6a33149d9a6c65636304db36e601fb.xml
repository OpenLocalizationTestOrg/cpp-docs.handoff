{"nodes":[{"pos":[12,57],"content":"&lt;functional&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>functional<ph id=\"ph2\">&amp;gt;</ph> functions | Microsoft Docs","pos":[0,45],"source":"&lt;functional&gt; functions | Microsoft Docs"}]},{"pos":[260,288],"content":"&lt;functional&gt; functions","linkify":"&lt;functional&gt; functions","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>functional<ph id=\"ph2\">&amp;gt;</ph> functions","pos":[0,28],"source":"&lt;functional&gt; functions"}]},{"pos":[307,329],"content":"<bpt id=\"p1\">[</bpt>bind<ept id=\"p1\">](#bind_function)</ept>","source":"[bind](#bind_function)"},{"pos":[330,358],"content":"<bpt id=\"p1\">[</bpt>bind1st<ept id=\"p1\">](#bind1st_function)</ept>","source":"[bind1st](#bind1st_function)"},{"pos":[359,387],"content":"<bpt id=\"p1\">[</bpt>bind2nd<ept id=\"p1\">](#bind2nd_function)</ept>","source":"[bind2nd](#bind2nd_function)"},{"pos":[392,420],"content":"<bpt id=\"p1\">[</bpt>bit_and<ept id=\"p1\">](#bit_and_function)</ept>","source":"[bit_and](#bit_and_function)"},{"pos":[421,449],"content":"<bpt id=\"p1\">[</bpt>bit_not<ept id=\"p1\">](#bit_not_function)</ept>","source":"[bit_not](#bit_not_function)"},{"pos":[450,476],"content":"<bpt id=\"p1\">[</bpt>bit_or<ept id=\"p1\">](#bit_or_function)</ept>","source":"[bit_or](#bit_or_function)"},{"pos":[481,509],"content":"<bpt id=\"p1\">[</bpt>bit_xor<ept id=\"p1\">](#bit_xor_function)</ept>","source":"[bit_xor](#bit_xor_function)"},{"pos":[510,532],"content":"<bpt id=\"p1\">[</bpt>cref<ept id=\"p1\">](#cref_function)</ept>","source":"[cref](#cref_function)"},{"pos":[533,559],"content":"<bpt id=\"p1\">[</bpt>mem_fn<ept id=\"p1\">](#mem_fn_function)</ept>","source":"[mem_fn](#mem_fn_function)"},{"pos":[564,592],"content":"<bpt id=\"p1\">[</bpt>mem_fun<ept id=\"p1\">](#mem_fun_function)</ept>","source":"[mem_fun](#mem_fun_function)"},{"pos":[593,629],"content":"<bpt id=\"p1\">[</bpt>mem_fun_ref<ept id=\"p1\">](#mem_fun_ref_function)</ept>","source":"[mem_fun_ref](#mem_fun_ref_function)"},{"pos":[630,652],"content":"<bpt id=\"p1\">[</bpt>not1<ept id=\"p1\">](#not1_function)</ept>","source":"[not1](#not1_function)"},{"pos":[657,679],"content":"<bpt id=\"p1\">[</bpt>not2<ept id=\"p1\">](#not2_function)</ept>","source":"[not2](#not2_function)"},{"pos":[680,708],"content":"<bpt id=\"p1\">[</bpt>ptr_fun<ept id=\"p1\">](#ptr_fun_function)</ept>","source":"[ptr_fun](#ptr_fun_function)"},{"pos":[709,729],"content":"<bpt id=\"p1\">[</bpt>ref<ept id=\"p1\">](#ref_function)</ept>","source":"[ref](#ref_function)"},{"pos":[734,756],"content":"<bpt id=\"p1\">[</bpt>swap<ept id=\"p1\">](#swap_function)</ept>","source":"[swap](#swap_function)"},{"pos":[767,801],"content":"<bpt id=\"p1\">&lt;a name=\"bind_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  bind","linkify":"<a name=\"bind_function\"></a>  bind","source":"<a name=\"bind_function\"></a>  bind"},{"content":"Binds arguments to a callable object.","pos":[805,842]},{"pos":[1099,1109],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type of the object to call.","pos":[1122,1153]},{"content":"The type of the Nth call argument.","pos":[1168,1202]},{"content":"The object to call.","pos":[1217,1236]},{"content":"The Nth call argument.","pos":[1251,1273]},{"pos":[1283,1290],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[1294,1446],"content":"The types <ph id=\"ph1\">`Fty, T1, T2, ..., TN`</ph> must be copy constructible, and <ph id=\"ph2\">`INVOKE(fn, t1, ..., tN)`</ph> must be a valid expression for some values <ph id=\"ph3\">`w1, w2, ..., wN`</ph>.","source":"The types `Fty, T1, T2, ..., TN` must be copy constructible, and `INVOKE(fn, t1, ..., tN)` must be a valid expression for some values `w1, w2, ..., wN`."},{"content":"The first template function returns a forwarding call wrapper <ph id=\"ph1\">`g`</ph> with a weak result type.","pos":[1453,1543],"source":"The first template function returns a forwarding call wrapper `g` with a weak result type."},{"content":"The effect of <ph id=\"ph1\">`g(u1, u2, ..., uM)`</ph> is <ph id=\"ph2\">`INVOKE(f, v1, v2, ..., vN,`</ph> <bpt id=\"p1\">[</bpt>result_of Class<ept id=\"p1\">](../standard-library/result-of-class2.md)</ept><ph id=\"ph3\">`&lt;Fty`</ph> <ph id=\"ph4\">`cv`</ph> <ph id=\"ph5\">`(V1, V2, ..., VN)&gt;::type)`</ph>, where <ph id=\"ph6\">`cv`</ph> is the cv-qualifiers of <ph id=\"ph7\">`g`</ph> and the values and types of the bound arguments <ph id=\"ph8\">`v1, v2, ..., vN`</ph> are determined as specified below.","pos":[1544,1849],"source":" The effect of `g(u1, u2, ..., uM)` is `INVOKE(f, v1, v2, ..., vN,` [result_of Class](../standard-library/result-of-class2.md)`<Fty` `cv` `(V1, V2, ..., VN)>::type)`, where `cv` is the cv-qualifiers of `g` and the values and types of the bound arguments `v1, v2, ..., vN` are determined as specified below."},{"content":"You use it to bind arguments to a callable object to make a callable object with a tailored argument list.","pos":[1850,1956]},{"content":"The second template function returns a forwarding call wrapper <ph id=\"ph1\">`g`</ph> with a nested type <ph id=\"ph2\">`result_type`</ph> that is a synonym for <ph id=\"ph3\">`Ret`</ph>.","pos":[1963,2091],"source":"The second template function returns a forwarding call wrapper `g` with a nested type `result_type` that is a synonym for `Ret`."},{"content":"The effect of <ph id=\"ph1\">`g(u1, u2, ..., uM)`</ph> is <ph id=\"ph2\">`INVOKE(f, v1, v2, ..., vN, Ret)`</ph>, where <ph id=\"ph3\">`cv`</ph> is the cv-qualifiers of <ph id=\"ph4\">`g`</ph> and the values and types of the bound arguments <ph id=\"ph5\">`v1, v2, ..., vN`</ph> are determined as specified below.","pos":[2092,2304],"source":" The effect of `g(u1, u2, ..., uM)` is `INVOKE(f, v1, v2, ..., vN, Ret)`, where `cv` is the cv-qualifiers of `g` and the values and types of the bound arguments `v1, v2, ..., vN` are determined as specified below."},{"content":"You use it to bind arguments to a callable object to make a callable object with a tailored argument list and with a specified return type.","pos":[2305,2444]},{"pos":[2451,2702],"content":"The values of the bound arguments <ph id=\"ph1\">`v1, v2, ..., vN`</ph> and their corresponding types <ph id=\"ph2\">`V1, V2, ..., VN`</ph> depend on the type of the corresponding argument <ph id=\"ph3\">`ti`</ph> of type <ph id=\"ph4\">`Ti`</ph> in the call to <ph id=\"ph5\">`bind`</ph> and the cv-qualifiers <ph id=\"ph6\">`cv`</ph> of the call wrapper <ph id=\"ph7\">`g`</ph> as follows:","source":"The values of the bound arguments `v1, v2, ..., vN` and their corresponding types `V1, V2, ..., VN` depend on the type of the corresponding argument `ti` of type `Ti` in the call to `bind` and the cv-qualifiers `cv` of the call wrapper `g` as follows:"},{"pos":[2709,2809],"content":"if <ph id=\"ph1\">`ti`</ph> is of type <ph id=\"ph2\">`reference_wrapper&lt;T&gt;`</ph> the argument <ph id=\"ph3\">`vi`</ph> is <ph id=\"ph4\">`ti.get()`</ph> and its type <ph id=\"ph5\">`Vi`</ph> is <ph id=\"ph6\">`T&amp;`</ph>;","source":"if `ti` is of type `reference_wrapper<T>` the argument `vi` is `ti.get()` and its type `Vi` is `T&`;"},{"pos":[2816,2992],"content":"if the value of <ph id=\"ph1\">`std::is_bind_expression&lt;Ti&gt;::value`</ph> is <ph id=\"ph2\">`true`</ph> the argument <ph id=\"ph3\">`vi`</ph> is <ph id=\"ph4\">`ti(u1, u2, ..., uM)`</ph> and its type <ph id=\"ph5\">`Vi`</ph> is <ph id=\"ph6\">`result_of&lt;Ti`</ph> <ph id=\"ph7\">`cv`</ph> <ph id=\"ph8\">`(U1&amp;, U2&amp;, ..., UN&amp;&gt;::type`</ph>;","source":"if the value of `std::is_bind_expression<Ti>::value` is `true` the argument `vi` is `ti(u1, u2, ..., uM)` and its type `Vi` is `result_of<Ti` `cv` `(U1&, U2&, ..., UN&>::type`;"},{"pos":[2999,3117],"content":"if the value <ph id=\"ph1\">`j`</ph> of <ph id=\"ph2\">`std::is_placeholder&lt;Ti&gt;::value`</ph> is not zero the argument <ph id=\"ph3\">`vi`</ph> is <ph id=\"ph4\">`uj`</ph> and its type <ph id=\"ph5\">`Vi`</ph> is <ph id=\"ph6\">`Uj&amp;`</ph>;","source":"if the value `j` of `std::is_placeholder<Ti>::value` is not zero the argument `vi` is `uj` and its type `Vi` is `Uj&`;"},{"pos":[3124,3195],"content":"otherwise the argument <ph id=\"ph1\">`vi`</ph> is <ph id=\"ph2\">`ti`</ph> and its type <ph id=\"ph3\">`Vi`</ph> is <ph id=\"ph4\">`Ti`</ph> <ph id=\"ph5\">`cv`</ph> <ph id=\"ph6\">`&amp;`</ph>.","source":"otherwise the argument `vi` is `ti` and its type `Vi` is `Ti` `cv` `&`."},{"content":"For example, given a function <ph id=\"ph1\">`f(int, int)`</ph> the expression <ph id=\"ph2\">`bind(f, _1, 0)`</ph> returns a forwarding call wrapper <ph id=\"ph3\">`cw`</ph> such that <ph id=\"ph4\">`cw(x)`</ph> calls <ph id=\"ph5\">`f(x, 0)`</ph>.","pos":[3202,3351],"source":"For example, given a function `f(int, int)` the expression `bind(f, _1, 0)` returns a forwarding call wrapper `cw` such that `cw(x)` calls `f(x, 0)`."},{"content":"The expression <ph id=\"ph1\">`bind(f, 0, _1)`</ph> returns a forwarding call wrapper <ph id=\"ph2\">`cw`</ph> such that <ph id=\"ph3\">`cw(x)`</ph> calls <ph id=\"ph4\">`f(0, x)`</ph>.","pos":[3352,3457],"source":" The expression `bind(f, 0, _1)` returns a forwarding call wrapper `cw` such that `cw(x)` calls `f(0, x)`."},{"content":"The number of arguments in a call to <ph id=\"ph1\">`bind`</ph> in addition to the argument <ph id=\"ph2\">`fn`</ph> must be equal to the number of arguments that can be passed to the callable object <ph id=\"ph3\">`fn`</ph>.","pos":[3464,3629],"source":"The number of arguments in a call to `bind` in addition to the argument `fn` must be equal to the number of arguments that can be passed to the callable object `fn`."},{"content":"Thus, <ph id=\"ph1\">`bind(cos, 1.0)`</ph> is correct, and both <ph id=\"ph2\">`bind(cos)`</ph> and <ph id=\"ph3\">`bind(cos, _1, 0.0)`</ph> are incorrect.","pos":[3630,3725],"source":" Thus, `bind(cos, 1.0)` is correct, and both `bind(cos)` and `bind(cos, _1, 0.0)` are incorrect."},{"content":"The number of arguments in the function call to the call wrapper returned by <ph id=\"ph1\">`bind`</ph> must be at least as large as the highest numbered value of <ph id=\"ph2\">`is_placeholder&lt;PH&gt;::value`</ph> for all of the placeholder arguments in the call to <ph id=\"ph3\">`bind`</ph>.","pos":[3732,3962],"source":"The number of arguments in the function call to the call wrapper returned by `bind` must be at least as large as the highest numbered value of `is_placeholder<PH>::value` for all of the placeholder arguments in the call to `bind`."},{"content":"Thus, <ph id=\"ph1\">`bind(cos, _2)(0.0, 1.0)`</ph> is correct (and returns <ph id=\"ph2\">`cos(1.0)`</ph>), and <ph id=\"ph3\">`bind(cos, _2)(0.0)`</ph> is incorrect.","pos":[3963,4070],"source":" Thus, `bind(cos, _2)(0.0, 1.0)` is correct (and returns `cos(1.0)`), and `bind(cos, _2)(0.0)` is incorrect."},{"pos":[4080,4087],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[4895,4935],"content":"<bpt id=\"p1\">&lt;a name=\"bind1st_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  bind1st","linkify":"<a name=\"bind1st_function\"></a>  bind1st","source":"<a name=\"bind1st_function\"></a>  bind1st"},{"content":"A helper template function that creates an adaptor to convert a binary function object into a unary function object by binding the first argument of the binary function to a specified value.","pos":[4939,5129]},{"pos":[5268,5278],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The binary function object to be converted to a unary function object.","pos":[5292,5362]},{"content":"The value to which the first argument of the binary function object is to be bound.","pos":[5380,5463]},{"pos":[5473,5485],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[5489,5611],"content":"The unary function object that results from binding the first argument of the binary function object to the value <ph id=\"ph1\">` left.`</ph>","source":"The unary function object that results from binding the first argument of the binary function object to the value ` left.`"},{"pos":[5621,5628],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Function binders are a kind of function adaptor and, because they return function objects, can be used in certain types of function composition to construct more complicated and powerful expressions.","pos":[5632,5831]},{"pos":[5838,6089],"content":"If <ph id=\"ph1\">`func`</ph> is an object of type <ph id=\"ph2\">`Operation`</ph> and <ph id=\"ph3\">`c`</ph> is a constant, then <ph id=\"ph4\">`bind1st`</ph> ( <ph id=\"ph5\">`func`</ph>, <ph id=\"ph6\">`c`</ph>) is equivalent to the <bpt id=\"p1\">[</bpt>binder1st<ept id=\"p1\">](../standard-library/binder1st-class.md)</ept> class constructor <ph id=\"ph7\">`binder1st`</ph><ph id=\"ph8\">&lt; </ph><ph id=\"ph9\">`Operation`</ph>&gt; ( <ph id=\"ph10\">`func`</ph>, <ph id=\"ph11\">`c`</ph>) and is more convenient.","source":"If `func` is an object of type `Operation` and `c` is a constant, then `bind1st` ( `func`, `c`) is equivalent to the [binder1st](../standard-library/binder1st-class.md) class constructor `binder1st`< `Operation`> ( `func`, `c`) and is more convenient."},{"pos":[6099,6106],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[8045,8085],"content":"<bpt id=\"p1\">&lt;a name=\"bind2nd_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  bind2nd","linkify":"<a name=\"bind2nd_function\"></a>  bind2nd","source":"<a name=\"bind2nd_function\"></a>  bind2nd"},{"content":"A helper template function that creates an adaptor to convert a binary function object into a unary function object by binding the second argument of the binary function to a specified value.","pos":[8089,8280]},{"pos":[8419,8429],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The binary function object to be converted to a unary function object.","pos":[8443,8513]},{"content":"The value to which the second argument of the binary function object is to be bound.","pos":[8532,8616]},{"pos":[8626,8638],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[8642,8766],"content":"The unary function object that results from binding the second argument of the binary function object to the value <ph id=\"ph1\">` right.`</ph>","source":"The unary function object that results from binding the second argument of the binary function object to the value ` right.`"},{"pos":[8776,8783],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Function binders are a kind of function adaptor and, because they return function objects, can be used in certain types of function composition to construct more complicated and powerful expressions.","pos":[8787,8986]},{"pos":[8993,9245],"content":"If <ph id=\"ph1\">`func`</ph> is an object of type <bpt id=\"p1\">**</bpt>Operation<ept id=\"p1\">**</ept> and <ph id=\"ph2\">`c`</ph> is a constant, then <ph id=\"ph3\">`bind2nd`</ph> ( <ph id=\"ph4\">`func`</ph>, <ph id=\"ph5\">`c`</ph> ) is equivalent to the <bpt id=\"p2\">[</bpt>binder2nd<ept id=\"p2\">](../standard-library/binder2nd-class.md)</ept> class constructor <bpt id=\"p3\">**</bpt>binder2nd<ph id=\"ph6\">\\&lt;</ph>Operation&gt;<ept id=\"p3\">**</ept> ( <ph id=\"ph7\">`func`</ph>, <ph id=\"ph8\">`c`</ph> ) and more convenient.","source":"If `func` is an object of type **Operation** and `c` is a constant, then `bind2nd` ( `func`, `c` ) is equivalent to the [binder2nd](../standard-library/binder2nd-class.md) class constructor **binder2nd\\<Operation>** ( `func`, `c` ) and more convenient."},{"pos":[9255,9262],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[11211,11251],"content":"<bpt id=\"p1\">&lt;a name=\"bit_and_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  bit_and","linkify":"<a name=\"bit_and_function\"></a>  bit_and","source":"<a name=\"bit_and_function\"></a>  bit_and"},{"pos":[11255,11362],"content":"A predefined function object that performs the bitwise AND operation (binary <ph id=\"ph1\">`operator&amp;`</ph>) on its arguments.","source":"A predefined function object that performs the bitwise AND operation (binary `operator&`) on its arguments."},{"pos":[11802,11812],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<ph id=\"ph1\">`Type`</ph>, <ph id=\"ph2\">` T`</ph>, <ph id=\"ph3\">` U`</ph>","pos":[11816,11834],"source":"`Type`, ` T`, ` U`"},{"content":"Any type that supports an <ph id=\"ph1\">`operator&amp;`</ph> that takes operands of the specified or inferred types.","pos":[11838,11931],"source":" Any type that supports an `operator&` that takes operands of the specified or inferred types."},{"content":"The left operand of the bitwise AND operation.","pos":[11948,11994]},{"content":"The unspecialized template takes an lvalue reference argument of type <ph id=\"ph1\">`Type`</ph>.","pos":[11995,12072],"source":" The unspecialized template takes an lvalue reference argument of type `Type`."},{"content":"The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type <ph id=\"ph1\">` T`</ph>.","pos":[12073,12185],"source":" The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` T`."},{"content":"The right operand of the bitwise AND operation.","pos":[12203,12250]},{"content":"The unspecialized template takes an lvalue reference argument of type <ph id=\"ph1\">`Type`</ph>.","pos":[12251,12328],"source":" The unspecialized template takes an lvalue reference argument of type `Type`."},{"content":"The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type <ph id=\"ph1\">` U`</ph>.","pos":[12329,12441],"source":" The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` U`."},{"pos":[12451,12463],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The result of <ph id=\"ph1\">`Left``&amp;``Right`</ph>.","pos":[12467,12498],"source":"The result of `Left``&``Right`."},{"content":"The specialized template does perfect forwarding of the result, which has the type that's returned by <ph id=\"ph1\">`operator&amp;`</ph>.","pos":[12499,12613],"source":" The specialized template does perfect forwarding of the result, which has the type that's returned by `operator&`."},{"pos":[12623,12630],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[12634,12773],"content":"The <ph id=\"ph1\">`bit_and`</ph> functor is restricted to integral types for the basic data types, or to user-defined types that implement binary <ph id=\"ph2\">`operator&amp;`</ph>.","source":"The `bit_and` functor is restricted to integral types for the basic data types, or to user-defined types that implement binary `operator&`."},{"pos":[12783,12823],"content":"<bpt id=\"p1\">&lt;a name=\"bit_not_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  bit_not","linkify":"<a name=\"bit_not_function\"></a>  bit_not","source":"<a name=\"bit_not_function\"></a>  bit_not"},{"pos":[12827,12945],"content":"A predefined function object that performs the bitwise complement (NOT) operation (unary <ph id=\"ph1\">`operator~`</ph>) on its argument.","source":"A predefined function object that performs the bitwise complement (NOT) operation (unary `operator~`) on its argument."},{"pos":[13326,13336],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A type that supports a unary <ph id=\"ph1\">`operator~`</ph>.","pos":[13350,13391],"source":" A type that supports a unary `operator~`."},{"content":"The operand of the bitwise complement operation.","pos":[13409,13457]},{"content":"The unspecialized template takes an lvalue reference argument of type <ph id=\"ph1\">`Type`</ph>.","pos":[13458,13535],"source":" The unspecialized template takes an lvalue reference argument of type `Type`."},{"content":"The specialized template does perfect forwarding of an lvalue or rvalue reference argument of inferred type <ph id=\"ph1\">`Type`</ph>.","pos":[13536,13651],"source":" The specialized template does perfect forwarding of an lvalue or rvalue reference argument of inferred type `Type`."},{"pos":[13661,13673],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The result of <ph id=\"ph1\">`~``Right`</ph>.","pos":[13677,13702],"source":"The result of `~``Right`."},{"content":"The specialized template does perfect forwarding of the result, which has the type that's returned by <ph id=\"ph1\">`operator~`</ph>.","pos":[13703,13817],"source":" The specialized template does perfect forwarding of the result, which has the type that's returned by `operator~`."},{"pos":[13827,13834],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[13838,13977],"content":"The <ph id=\"ph1\">`bit_not`</ph> functor is restricted to integral types for the basic data types, or to user-defined types that implement binary <ph id=\"ph2\">`operator~`</ph>.","source":"The `bit_not` functor is restricted to integral types for the basic data types, or to user-defined types that implement binary `operator~`."},{"pos":[13987,14025],"content":"<bpt id=\"p1\">&lt;a name=\"bit_or_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  bit_or","linkify":"<a name=\"bit_or_function\"></a>  bit_or","source":"<a name=\"bit_or_function\"></a>  bit_or"},{"pos":[14029,14129],"content":"A predefined function object that performs the bitwise OR operation ( <ph id=\"ph1\">`operator|`</ph>) on its arguments.","source":"A predefined function object that performs the bitwise OR operation ( `operator|`) on its arguments."},{"pos":[14568,14578],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<ph id=\"ph1\">`Type`</ph>, <ph id=\"ph2\">` T`</ph>, <ph id=\"ph3\">` U`</ph>","pos":[14582,14600],"source":"`Type`, ` T`, ` U`"},{"content":"Any type that supports an <ph id=\"ph1\">`operator|`</ph> that takes operands of the specified or inferred types.","pos":[14604,14697],"source":" Any type that supports an `operator|` that takes operands of the specified or inferred types."},{"content":"The left operand of the bitwise OR operation.","pos":[14714,14759]},{"content":"The unspecialized template takes an lvalue reference argument of type <ph id=\"ph1\">`Type`</ph>.","pos":[14760,14837],"source":" The unspecialized template takes an lvalue reference argument of type `Type`."},{"content":"The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type <ph id=\"ph1\">` T`</ph>.","pos":[14838,14950],"source":" The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` T`."},{"content":"The right operand of the bitwise OR operation.","pos":[14968,15014]},{"content":"The unspecialized template takes an lvalue reference argument of type <ph id=\"ph1\">`Type`</ph>.","pos":[15015,15092],"source":" The unspecialized template takes an lvalue reference argument of type `Type`."},{"content":"The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type <ph id=\"ph1\">` U`</ph>.","pos":[15093,15205],"source":" The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` U`."},{"pos":[15215,15227],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The result of <ph id=\"ph1\">`Left``|``Right`</ph>.","pos":[15231,15262],"source":"The result of `Left``|``Right`."},{"content":"The specialized template does perfect forwarding of the result, which has the type that's returned by <ph id=\"ph1\">`operator|`</ph>.","pos":[15263,15377],"source":" The specialized template does perfect forwarding of the result, which has the type that's returned by `operator|`."},{"pos":[15387,15394],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[15398,15529],"content":"The <ph id=\"ph1\">`bit_or`</ph> functor is restricted to integral types for the basic data types, or to user-defined types that implement <ph id=\"ph2\">`operator|`</ph>.","source":"The `bit_or` functor is restricted to integral types for the basic data types, or to user-defined types that implement `operator|`."},{"pos":[15539,15579],"content":"<bpt id=\"p1\">&lt;a name=\"bit_xor_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  bit_xor","linkify":"<a name=\"bit_xor_function\"></a>  bit_xor","source":"<a name=\"bit_xor_function\"></a>  bit_xor"},{"pos":[15583,15690],"content":"A predefined function object that performs the bitwise XOR operation (binary <ph id=\"ph1\">`operator^`</ph>) on its arguments.","source":"A predefined function object that performs the bitwise XOR operation (binary `operator^`) on its arguments."},{"pos":[16130,16140],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<ph id=\"ph1\">`Type`</ph>, <ph id=\"ph2\">` T`</ph>, <ph id=\"ph3\">` U`</ph>","pos":[16144,16162],"source":"`Type`, ` T`, ` U`"},{"content":"Any type that supports an <ph id=\"ph1\">`operator^`</ph> that takes operands of the specified or inferred types.","pos":[16166,16259],"source":" Any type that supports an `operator^` that takes operands of the specified or inferred types."},{"content":"The left operand of the bitwise XOR operation.","pos":[16276,16322]},{"content":"The unspecialized template takes an lvalue reference argument of type <ph id=\"ph1\">`Type`</ph>.","pos":[16323,16400],"source":" The unspecialized template takes an lvalue reference argument of type `Type`."},{"content":"The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type <ph id=\"ph1\">` T`</ph>.","pos":[16401,16513],"source":" The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` T`."},{"content":"The right operand of the bitwise XOR operation.","pos":[16531,16578]},{"content":"The unspecialized template takes an lvalue reference argument of type <ph id=\"ph1\">`Type`</ph>.","pos":[16579,16656],"source":" The unspecialized template takes an lvalue reference argument of type `Type`."},{"content":"The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type <ph id=\"ph1\">` U`</ph>.","pos":[16657,16769],"source":" The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` U`."},{"pos":[16779,16791],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The result of <ph id=\"ph1\">`Left``^``Right`</ph>.","pos":[16795,16826],"source":"The result of `Left``^``Right`."},{"content":"The specialized template does perfect forwarding of the result, which has the type that's returned by <ph id=\"ph1\">`operator^`</ph>.","pos":[16827,16941],"source":" The specialized template does perfect forwarding of the result, which has the type that's returned by `operator^`."},{"pos":[16951,16958],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[16962,17101],"content":"The <ph id=\"ph1\">`bit_xor`</ph> functor is restricted to integral types for the basic data types, or to user-defined types that implement binary <ph id=\"ph2\">`operator^`</ph>.","source":"The `bit_xor` functor is restricted to integral types for the basic data types, or to user-defined types that implement binary `operator^`."},{"pos":[17111,17145],"content":"<bpt id=\"p1\">&lt;a name=\"cref_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  cref","linkify":"<a name=\"cref_function\"></a>  cref","source":"<a name=\"cref_function\"></a>  cref"},{"pos":[17149,17205],"content":"Constructs a const <ph id=\"ph1\">`reference_wrapper`</ph> from an argument.","source":"Constructs a const `reference_wrapper` from an argument."},{"pos":[17392,17402],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type of the argument to wrap.","pos":[17414,17447]},{"content":"The argument to wrap.","pos":[17463,17484]},{"pos":[17494,17501],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first function returns <ph id=\"ph1\">`reference_wrapper&lt;const Ty&gt;(arg.get())`</ph>.","pos":[17505,17573],"source":"The first function returns `reference_wrapper<const Ty>(arg.get())`."},{"content":"You use it to wrap a const reference.","pos":[17574,17611]},{"content":"The second function returns <ph id=\"ph1\">`reference_wrapper&lt;const Ty&gt;(arg)`</ph>.","pos":[17612,17675],"source":" The second function returns `reference_wrapper<const Ty>(arg)`."},{"content":"You use it to rewrap a wrapped reference as a const reference.","pos":[17676,17738]},{"pos":[17748,17755],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[18293,18331],"content":"<bpt id=\"p1\">&lt;a name=\"mem_fn_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  mem_fn","linkify":"<a name=\"mem_fn_function\"></a>  mem_fn","source":"<a name=\"mem_fn_function\"></a>  mem_fn"},{"content":"Generates a simple call wrapper.","pos":[18335,18367]},{"pos":[18458,18468],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The return type of the wrapped function.","pos":[18481,18521]},{"content":"The type of the member function pointer.","pos":[18536,18576]},{"pos":[18586,18593],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template function returns a simple call wrapper <ph id=\"ph1\">`cw`</ph>, with a weak result type, such that the expression <ph id=\"ph2\">`cw(t, a2, ..., aN)`</ph> is equivalent to <ph id=\"ph3\">`INVOKE(pm, t, a2, ..., aN)`</ph>.","pos":[18597,18772],"source":"The template function returns a simple call wrapper `cw`, with a weak result type, such that the expression `cw(t, a2, ..., aN)` is equivalent to `INVOKE(pm, t, a2, ..., aN)`."},{"content":"It does not throw any exceptions.","pos":[18773,18806]},{"pos":[18813,19123],"content":"The returned call wrapper is derived from <ph id=\"ph1\">`std::unary_function&lt;cv Ty*, Ret&gt;`</ph> (hence defining the nested type <ph id=\"ph2\">`result_type`</ph> as a synonym for <ph id=\"ph3\">`Ret`</ph> and the nested type <ph id=\"ph4\">`argument_type`</ph> as a synonym for <ph id=\"ph5\">`cv Ty*`</ph>) only if the type <ph id=\"ph6\">`Ty`</ph> is a pointer to member function with cv-qualifier <ph id=\"ph7\">`cv`</ph> that takes no arguments.","source":"The returned call wrapper is derived from `std::unary_function<cv Ty*, Ret>` (hence defining the nested type `result_type` as a synonym for `Ret` and the nested type `argument_type` as a synonym for `cv Ty*`) only if the type `Ty` is a pointer to member function with cv-qualifier `cv` that takes no arguments."},{"pos":[19130,19528],"content":"The returned call wrapper is derived from <ph id=\"ph1\">`std::binary_function&lt;cv Ty*, T2, Ret&gt;`</ph> (hence defining the nested type <ph id=\"ph2\">`result_type`</ph> as a synonym for <ph id=\"ph3\">`Ret`</ph>, the nested type <ph id=\"ph4\">`first argument_type`</ph> as a synonym for <ph id=\"ph5\">`cv Ty*`</ph>, and the nested type <ph id=\"ph6\">`second argument_type`</ph> as a synonym for <ph id=\"ph7\">`T2`</ph>) only if the type <ph id=\"ph8\">`Ty`</ph> is a pointer to member function with cv-qualifier <ph id=\"ph9\">`cv`</ph> that takes one argument, of type <ph id=\"ph10\">`T2`</ph>.","source":"The returned call wrapper is derived from `std::binary_function<cv Ty*, T2, Ret>` (hence defining the nested type `result_type` as a synonym for `Ret`, the nested type `first argument_type` as a synonym for `cv Ty*`, and the nested type `second argument_type` as a synonym for `T2`) only if the type `Ty` is a pointer to member function with cv-qualifier `cv` that takes one argument, of type `T2`."},{"pos":[19538,19545],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[20209,20249],"content":"<bpt id=\"p1\">&lt;a name=\"mem_fun_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  mem_fun","linkify":"<a name=\"mem_fun_function\"></a>  mem_fun","source":"<a name=\"mem_fun_function\"></a>  mem_fun"},{"content":"Helper template functions used to construct function object adaptors for member functions when initialized with pointer arguments.","pos":[20253,20383]},{"pos":[20859,20869],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A pointer to the member function of class <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> to be converted to a function object.","pos":[20883,20971],"source":" A pointer to the member function of class **Type** to be converted to a function object."},{"pos":[20981,20993],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[20997,21078],"content":"A <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>non_const<ept id=\"p2\">**</ept> function object of type <ph id=\"ph1\">`mem_fun_t`</ph> or <ph id=\"ph2\">`mem_fun1_t`</ph>.","source":"A **const** or **non_const** function object of type `mem_fun_t` or `mem_fun1_t`."},{"pos":[21088,21095],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[22828,22876],"content":"<bpt id=\"p1\">&lt;a name=\"mem_fun_ref_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  mem_fun_ref","linkify":"<a name=\"mem_fun_ref_function\"></a>  mem_fun_ref","source":"<a name=\"mem_fun_ref_function\"></a>  mem_fun_ref"},{"content":"Helper template functions used to construct function object adaptors for member functions when initialized by using reference arguments.","pos":[22880,23016]},{"pos":[23520,23530],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A pointer to the member function of class <ph id=\"ph1\">`Type`</ph> to be converted to a function object.","pos":[23544,23630],"source":" A pointer to the member function of class `Type` to be converted to a function object."},{"pos":[23640,23652],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[23656,23741],"content":"A <ph id=\"ph1\">`const`</ph> or <ph id=\"ph2\">`non_const`</ph> function object of type <ph id=\"ph3\">`mem_fun_ref_t`</ph> or <ph id=\"ph4\">`mem_fun1_ref_t`</ph>.","source":"A `const` or `non_const` function object of type `mem_fun_ref_t` or `mem_fun1_ref_t`."},{"pos":[23751,23758],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[26115,26149],"content":"<bpt id=\"p1\">&lt;a name=\"not1_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  not1","linkify":"<a name=\"not1_function\"></a>  not1","source":"<a name=\"not1_function\"></a>  not1"},{"content":"Returns the complement of a unary predicate.","pos":[26153,26197]},{"pos":[26319,26329],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The unary predicate to be negated.","pos":[26344,26378]},{"pos":[26388,26400],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"A unary predicate that is the negation of the unary predicate modified.","pos":[26404,26475]},{"pos":[26485,26492],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[26496,26602],"content":"If a <ph id=\"ph1\">`unary_negate`</ph> is constructed from a unary predicate <bpt id=\"p1\">**</bpt>Pred<ept id=\"p1\">**</ept>( <bpt id=\"p2\">*</bpt>x<ept id=\"p2\">*</ept>), then it returns <bpt id=\"p3\">**</bpt>!Pred<ept id=\"p3\">**</ept>( <bpt id=\"p4\">*</bpt>x<ept id=\"p4\">*</ept>).","source":"If a `unary_negate` is constructed from a unary predicate **Pred**( *x*), then it returns **!Pred**( *x*)."},{"pos":[26612,26619],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[27932,27966],"content":"<bpt id=\"p1\">&lt;a name=\"not2_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  not2","linkify":"<a name=\"not2_function\"></a>  not2","source":"<a name=\"not2_function\"></a>  not2"},{"content":"Returns the complement of a binary predicate.","pos":[27970,28015]},{"pos":[28141,28151],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The binary predicate to be negated.","pos":[28165,28200]},{"pos":[28210,28222],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"A binary predicate that is the negation of the binary predicate modified.","pos":[28226,28299]},{"pos":[28309,28316],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If a <ph id=\"ph1\">`binary_negate`</ph> is constructed from a binary predicate <bpt id=\"p1\">**</bpt>BinPred<ept id=\"p1\">**</ept>( <bpt id=\"p2\">*</bpt>x<ept id=\"p2\">*</ept>, <bpt id=\"p3\">*</bpt>y<ept id=\"p3\">*</ept>), then it returns !","pos":[28320,28421],"source":"If a `binary_negate` is constructed from a binary predicate **BinPred**( *x*, *y*), then it returns !"},{"content":"<bpt id=\"p1\">**</bpt>BinPred<ept id=\"p1\">**</ept>( <bpt id=\"p2\">*</bpt>x<ept id=\"p2\">*</ept>, <bpt id=\"p3\">*</bpt>y<ept id=\"p3\">*</ept>).","pos":[28422,28445],"source":"**BinPred**( *x*, *y*)."},{"pos":[28455,28462],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[29878,29918],"content":"<bpt id=\"p1\">&lt;a name=\"ptr_fun_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  ptr_fun","linkify":"<a name=\"ptr_fun_function\"></a>  ptr_fun","source":"<a name=\"ptr_fun_function\"></a>  ptr_fun"},{"content":"Helper template functions used to convert unary and binary function pointers, respectively, into unary and binary adaptable functions.","pos":[29922,30056]},{"pos":[30365,30375],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The unary or binary function pointer to be converted to an adaptable function.","pos":[30390,30468]},{"pos":[30478,30490],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[30494,30665],"content":"The first template function returns the unary function <bpt id=\"p1\">[</bpt>pointer_to_unary_function<ept id=\"p1\">](../standard-library/pointer-to-unary-function-class.md)</ept><ph id=\"ph1\"> &lt; </ph><ph id=\"ph2\">`Arg`</ph>, <bpt id=\"p2\">**</bpt>Result<ept id=\"p2\">**</ept>&gt;(* <ph id=\"ph3\">`pfunc`</ph>).","source":"The first template function returns the unary function [pointer_to_unary_function](../standard-library/pointer-to-unary-function-class.md) < `Arg`, **Result**>(* `pfunc`)."},{"pos":[30672,30857],"content":"The second template function returns binary function <bpt id=\"p1\">[</bpt>pointer_to_binary_function<ept id=\"p1\">](../standard-library/pointer-to-binary-function-class.md)</ept> <ph id=\"ph1\">\\&lt;</ph> <bpt id=\"p2\">**</bpt>Arg1<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>Arg2<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>Result<ept id=\"p4\">**</ept>&gt;(* <ph id=\"ph2\">`pfunc`</ph>).","source":"The second template function returns binary function [pointer_to_binary_function](../standard-library/pointer-to-binary-function-class.md) \\< **Arg1**, **Arg2**, **Result**>(* `pfunc`)."},{"pos":[30867,30874],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"A function pointer is a function object and may be passed to any Standard Template Library algorithm that is expecting a function as a parameter, but it is not adaptable.","pos":[30878,31048]},{"content":"To use it with an adaptor, such as binding a value to it or using it with a negator, it must be supplied with the nested types that make such an adaptation possible.","pos":[31049,31214]},{"content":"The conversion of unary and binary function pointers by the <ph id=\"ph1\">`ptr_fun`</ph> helper function allows the function adaptors to work with unary and binary function pointers.","pos":[31215,31378],"source":" The conversion of unary and binary function pointers by the `ptr_fun` helper function allows the function adaptors to work with unary and binary function pointers."},{"pos":[31388,31395],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[31399,31496],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>functional_ptr_fun#1<ept id=\"p2\">](../standard-library/codesnippet/CPP/functional-functions_1.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[functional_ptr_fun#1](../standard-library/codesnippet/CPP/functional-functions_1.cpp)]"},{"pos":[31506,31538],"content":"<bpt id=\"p1\">&lt;a name=\"ref_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  ref","linkify":"<a name=\"ref_function\"></a>  ref","source":"<a name=\"ref_function\"></a>  ref"},{"pos":[31542,31592],"content":"Constructs a <ph id=\"ph1\">`reference_wrapper`</ph> from an argument.","source":"Constructs a `reference_wrapper` from an argument."},{"pos":[31753,31765],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[31769,31834],"content":"A reference to <ph id=\"ph1\">`arg`</ph>; specifically, <ph id=\"ph2\">`reference_wrapper&lt;Ty&gt;(arg)`</ph>.","source":"A reference to `arg`; specifically, `reference_wrapper<Ty>(arg)`."},{"pos":[31844,31851],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example defines two functions: one bound to a string variable, the other bound to a reference of the string variable computed by a call to <ph id=\"ph1\">`ref`</ph>.","pos":[31856,32015],"source":"The following example defines two functions: one bound to a string variable, the other bound to a reference of the string variable computed by a call to `ref`."},{"content":"When the value of the variable changes, the first function continues to use the old value and the second function uses the new value.","pos":[32016,32149]},{"pos":[34059,34093],"content":"<bpt id=\"p1\">&lt;a name=\"swap_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  swap","linkify":"<a name=\"swap_function\"></a>  swap","source":"<a name=\"swap_function\"></a>  swap"},{"pos":[34097,34126],"content":"Swaps two <ph id=\"ph1\">`function`</ph> objects.","source":"Swaps two `function` objects."},{"pos":[34223,34233],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type controlled by the function objects.","pos":[34246,34290]},{"content":"The first function object.","pos":[34305,34331]},{"content":"The second function object.","pos":[34346,34373]},{"pos":[34383,34390],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[34394,34429],"content":"The function returns <ph id=\"ph1\">`f1.swap(f2)`</ph>.","source":"The function returns `f1.swap(f2)`."},{"pos":[34439,34446],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[35354,35362],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[35366,35416],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>functional&gt;<ept id=\"p1\">](../standard-library/functional.md)</ept>","source":"[\\<functional>](../standard-library/functional.md)"}],"content":"---\ntitle: \"&lt;functional&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: c34d0b45-50a7-447a-9368-2210d06339a4\ncaps.latest.revision: 12\nmanager: \"ghogen\"\n---\n# &lt;functional&gt; functions\n||||  \n|-|-|-|  \n|[bind](#bind_function)|[bind1st](#bind1st_function)|[bind2nd](#bind2nd_function)|  \n|[bit_and](#bit_and_function)|[bit_not](#bit_not_function)|[bit_or](#bit_or_function)|  \n|[bit_xor](#bit_xor_function)|[cref](#cref_function)|[mem_fn](#mem_fn_function)|  \n|[mem_fun](#mem_fun_function)|[mem_fun_ref](#mem_fun_ref_function)|[not1](#not1_function)|  \n|[not2](#not2_function)|[ptr_fun](#ptr_fun_function)|[ref](#ref_function)|  \n|[swap](#swap_function)|  \n  \n##  <a name=\"bind_function\"></a>  bind  \n Binds arguments to a callable object.  \n  \n```  \ntemplate <class Fty, class T1, class T2, ..., class TN>  \nunspecified bind(Fty fn, T1 t1, T2 t2, ..., TN tN);\n\ntemplate <class Ret, class Fty, class T1, class T2, ..., class TN>  \nunspecified bind(Fty fn, T1 t1, T2 t2, ..., TN tN);\n```  \n  \n### Parameters  \n `Fty`  \n The type of the object to call.  \n  \n `TN`  \n The type of the Nth call argument.  \n  \n `fn`  \n The object to call.  \n  \n `tN`  \n The Nth call argument.  \n  \n### Remarks  \n The types `Fty, T1, T2, ..., TN` must be copy constructible, and `INVOKE(fn, t1, ..., tN)` must be a valid expression for some values `w1, w2, ..., wN`.  \n  \n The first template function returns a forwarding call wrapper `g` with a weak result type. The effect of `g(u1, u2, ..., uM)` is `INVOKE(f, v1, v2, ..., vN,` [result_of Class](../standard-library/result-of-class2.md)`<Fty` `cv` `(V1, V2, ..., VN)>::type)`, where `cv` is the cv-qualifiers of `g` and the values and types of the bound arguments `v1, v2, ..., vN` are determined as specified below. You use it to bind arguments to a callable object to make a callable object with a tailored argument list.  \n  \n The second template function returns a forwarding call wrapper `g` with a nested type `result_type` that is a synonym for `Ret`. The effect of `g(u1, u2, ..., uM)` is `INVOKE(f, v1, v2, ..., vN, Ret)`, where `cv` is the cv-qualifiers of `g` and the values and types of the bound arguments `v1, v2, ..., vN` are determined as specified below. You use it to bind arguments to a callable object to make a callable object with a tailored argument list and with a specified return type.  \n  \n The values of the bound arguments `v1, v2, ..., vN` and their corresponding types `V1, V2, ..., VN` depend on the type of the corresponding argument `ti` of type `Ti` in the call to `bind` and the cv-qualifiers `cv` of the call wrapper `g` as follows:  \n  \n if `ti` is of type `reference_wrapper<T>` the argument `vi` is `ti.get()` and its type `Vi` is `T&`;  \n  \n if the value of `std::is_bind_expression<Ti>::value` is `true` the argument `vi` is `ti(u1, u2, ..., uM)` and its type `Vi` is `result_of<Ti` `cv` `(U1&, U2&, ..., UN&>::type`;  \n  \n if the value `j` of `std::is_placeholder<Ti>::value` is not zero the argument `vi` is `uj` and its type `Vi` is `Uj&`;  \n  \n otherwise the argument `vi` is `ti` and its type `Vi` is `Ti` `cv` `&`.  \n  \n For example, given a function `f(int, int)` the expression `bind(f, _1, 0)` returns a forwarding call wrapper `cw` such that `cw(x)` calls `f(x, 0)`. The expression `bind(f, 0, _1)` returns a forwarding call wrapper `cw` such that `cw(x)` calls `f(0, x)`.  \n  \n The number of arguments in a call to `bind` in addition to the argument `fn` must be equal to the number of arguments that can be passed to the callable object `fn`. Thus, `bind(cos, 1.0)` is correct, and both `bind(cos)` and `bind(cos, _1, 0.0)` are incorrect.  \n  \n The number of arguments in the function call to the call wrapper returned by `bind` must be at least as large as the highest numbered value of `is_placeholder<PH>::value` for all of the placeholder arguments in the call to `bind`. Thus, `bind(cos, _2)(0.0, 1.0)` is correct (and returns `cos(1.0)`), and `bind(cos, _2)(0.0)` is incorrect.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__bind.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <algorithm>   \n#include <iostream>   \n  \nusing namespace std::placeholders;   \n  \nvoid square(double x)\n{\n    std::cout << x << \"^2 == \" << x * x << std::endl;\n}\n\nvoid product(double x, double y)\n{\n    std::cout << x << \"*\" << y << \" == \" << x * y << std::endl;\n}\n\nint main()\n{\n    double arg[] = { 1, 2, 3 };\n\n    std::for_each(&arg[0], arg + 3, square);\n    std::cout << std::endl;\n\n    std::for_each(&arg[0], arg + 3, std::bind(product, _1, 2));\n    std::cout << std::endl;\n\n    std::for_each(&arg[0], arg + 3, std::bind(square, _1));\n\n    return (0);\n}\n\n```  \n  \n```Output  \n1^2 == 1  \n2^2 == 4  \n3^2 == 9  \n  \n1*2 == 2  \n2*2 == 4  \n3*2 == 6  \n  \n1^2 == 1  \n2^2 == 4  \n3^2 == 9  \n```  \n  \n##  <a name=\"bind1st_function\"></a>  bind1st  \n A helper template function that creates an adaptor to convert a binary function object into a unary function object by binding the first argument of the binary function to a specified value.  \n  \n```  \ntemplate <class Operation, class Type>  \nbinder1st <Operation> bind1st (const Operation& func, const Type& left);\n```  \n  \n### Parameters  \n `func`  \n The binary function object to be converted to a unary function object.  \n  \n ` left`  \n The value to which the first argument of the binary function object is to be bound.  \n  \n### Return Value  \n The unary function object that results from binding the first argument of the binary function object to the value ` left.`  \n  \n### Remarks  \n Function binders are a kind of function adaptor and, because they return function objects, can be used in certain types of function composition to construct more complicated and powerful expressions.  \n  \n If `func` is an object of type `Operation` and `c` is a constant, then `bind1st` ( `func`, `c`) is equivalent to the [binder1st](../standard-library/binder1st-class.md) class constructor `binder1st`< `Operation`> ( `func`, `c`) and is more convenient.  \n  \n### Example  \n  \n```cpp  \n// functional_bind1st.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <functional>  \n#include <algorithm>  \n#include <iostream>  \n  \nusing namespace std;  \n  \n// Creation of a user-defined function object  \n// that inherits from the unary_function base class  \nclass greaterthan5: unary_function<int, bool>  \n{  \npublic:  \n    result_type operator()(argument_type i)  \n    {  \n        return (result_type)(i > 5);  \n    }  \n};  \n  \nint main()  \n{  \n    vector<int> v1;  \n    vector<int>::iterator Iter;  \n  \n    int i;  \n    for (i = 0; i <= 5; i++)  \n    {  \n        v1.push_back(5 * i);  \n    }  \n  \n    cout << \"The vector v1 = ( \" ;  \n    for (Iter = v1.begin(); Iter != v1.end(); Iter++)  \n        cout << *Iter << \" \";  \n    cout << \")\" << endl;  \n  \n    // Count the number of integers > 10 in the vector  \n    vector<int>::iterator::difference_type result1a;  \n    result1a = count_if(v1.begin(), v1.end(), bind1st(less<int>(), 10));  \n    cout << \"The number of elements in v1 greater than 10 is: \"  \n         << result1a << \".\" << endl;  \n  \n    // Compare: counting the number of integers > 5 in the vector  \n    // with a user defined function object  \n    vector<int>::iterator::difference_type result1b;  \n    result1b = count_if(v1.begin(), v1.end(), greaterthan5());  \n    cout << \"The number of elements in v1 greater than 5 is: \"  \n         << result1b << \".\" << endl;  \n  \n    // Count the number of integers < 10 in the vector  \n    vector<int>::iterator::difference_type result2;  \n    result2 = count_if(v1.begin(), v1.end(), bind2nd(less<int>(), 10));  \n    cout << \"The number of elements in v1 less than 10 is: \"  \n         << result2 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe vector v1 = ( 0 5 10 15 20 25 )  \nThe number of elements in v1 greater than 10 is: 3.  \nThe number of elements in v1 greater than 5 is: 4.  \nThe number of elements in v1 less than 10 is: 2.  \n```  \n  \n##  <a name=\"bind2nd_function\"></a>  bind2nd  \n A helper template function that creates an adaptor to convert a binary function object into a unary function object by binding the second argument of the binary function to a specified value.  \n  \n```  \ntemplate <class Operation, class Type>  \nbinder2nd <Operation> bind2nd(const Operation& func, const Type& right);\n```  \n  \n### Parameters  \n `func`  \n The binary function object to be converted to a unary function object.  \n  \n ` right`  \n The value to which the second argument of the binary function object is to be bound.  \n  \n### Return Value  \n The unary function object that results from binding the second argument of the binary function object to the value ` right.`  \n  \n### Remarks  \n Function binders are a kind of function adaptor and, because they return function objects, can be used in certain types of function composition to construct more complicated and powerful expressions.  \n  \n If `func` is an object of type **Operation** and `c` is a constant, then `bind2nd` ( `func`, `c` ) is equivalent to the [binder2nd](../standard-library/binder2nd-class.md) class constructor **binder2nd\\<Operation>** ( `func`, `c` ) and more convenient.  \n  \n### Example  \n  \n```cpp  \n// functional_bind2nd.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <functional>  \n#include <algorithm>  \n#include <iostream>  \n  \nusing namespace std;  \n  \n// Creation of a user-defined function object  \n// that inherits from the unary_function base class  \nclass greaterthan15: unary_function<int, bool>  \n{  \npublic:  \n    result_type operator()(argument_type i)  \n    {  \n        return (result_type)(i > 15);  \n    }  \n};  \n  \nint main()  \n{  \n    vector<int> v1;  \n    vector<int>::iterator Iter;  \n  \n    int i;  \n    for (i = 0; i <= 5; i++)  \n    {  \n        v1.push_back(5 * i);  \n    }  \n  \n    cout << \"The vector v1 = ( \";  \n    for (Iter = v1.begin(); Iter != v1.end(); Iter++)  \n        cout << *Iter << \" \";  \n    cout << \")\" << endl;  \n  \n    // Count the number of integers > 10 in the vector  \n    vector<int>::iterator::difference_type result1a;  \n    result1a = count_if(v1.begin(), v1.end(), bind2nd(greater<int>(), 10));  \n    cout << \"The number of elements in v1 greater than 10 is: \"  \n         << result1a << \".\" << endl;  \n  \n    // Compare counting the number of integers > 15 in the vector  \n    // with a user-defined function object  \n    vector<int>::iterator::difference_type result1b;  \n    result1b = count_if(v1.begin(), v1.end(), greaterthan15());  \n    cout << \"The number of elements in v1 greater than 15 is: \"  \n         << result1b << \".\" << endl;  \n  \n    // Count the number of integers < 10 in the vector  \n    vector<int>::iterator::difference_type result2;  \n    result2 = count_if(v1.begin(), v1.end(), bind1st(greater<int>(), 10));  \n    cout << \"The number of elements in v1 less than 10 is: \"  \n         << result2 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe vector v1 = ( 0 5 10 15 20 25 )  \nThe number of elements in v1 greater than 10 is: 3.  \nThe number of elements in v1 greater than 15 is: 2.  \nThe number of elements in v1 less than 10 is: 2.  \n```  \n  \n##  <a name=\"bit_and_function\"></a>  bit_and  \n A predefined function object that performs the bitwise AND operation (binary `operator&`) on its arguments.  \n  \n```  \ntemplate <class Type = void>  \nstruct bit_and : public binary_function<Type, Type, Type> {  \n    Type operator()(\n    const Type& Left,   \n    const Type& Right) const; \n };  \n \n// specialized transparent functor for operator& \ntemplate <>\nstruct bit_and<void>\n{\n    template <class T, class U>\n    auto operator()(T&& Left, U&& Right) const  ->\n        decltype(std::forward<T>(Left) & std::forward<U>(Right));\n};\n```  \n  \n### Parameters  \n `Type`, ` T`, ` U`  \n Any type that supports an `operator&` that takes operands of the specified or inferred types.  \n  \n `Left`  \n The left operand of the bitwise AND operation. The unspecialized template takes an lvalue reference argument of type `Type`. The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` T`.  \n  \n `Right`  \n The right operand of the bitwise AND operation. The unspecialized template takes an lvalue reference argument of type `Type`. The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` U`.  \n  \n### Return Value  \n The result of `Left``&``Right`. The specialized template does perfect forwarding of the result, which has the type that's returned by `operator&`.  \n  \n### Remarks  \n The `bit_and` functor is restricted to integral types for the basic data types, or to user-defined types that implement binary `operator&`.  \n  \n##  <a name=\"bit_not_function\"></a>  bit_not  \n A predefined function object that performs the bitwise complement (NOT) operation (unary `operator~`) on its argument.  \n  \n```  \ntemplate <class Type = void>  \nstruct bit_not : public unary_function<Type, Type>   \n {  \n    Type operator()(const Type& Right) const; \n };  \n \n// specialized transparent functor for operator~  \ntemplate <>  \nstruct bit_not<void>   \n {  \n    template <class Type>  \n    auto operator()(Type&& Right) const  ->  decltype(~std::forward<Type>(Right));\n };  \n```  \n  \n### Parameters  \n `Type`  \n A type that supports a unary `operator~`.  \n  \n `Right`  \n The operand of the bitwise complement operation. The unspecialized template takes an lvalue reference argument of type `Type`. The specialized template does perfect forwarding of an lvalue or rvalue reference argument of inferred type `Type`.  \n  \n### Return Value  \n The result of `~``Right`. The specialized template does perfect forwarding of the result, which has the type that's returned by `operator~`.  \n  \n### Remarks  \n The `bit_not` functor is restricted to integral types for the basic data types, or to user-defined types that implement binary `operator~`.  \n  \n##  <a name=\"bit_or_function\"></a>  bit_or  \n A predefined function object that performs the bitwise OR operation ( `operator|`) on its arguments.  \n  \n```  \ntemplate <class Type = void>  \nstruct bit_or : public binary_function<Type, Type, Type> {  \n    Type operator()(\n    const Type& Left,   \n    const Type& Right) const; \n };  \n \n// specialized transparent functor for operator|  \ntemplate <>\nstruct bit_or<void>\n{\n    template <class T, class U>\n    auto operator()(T&& Left, U&& Right) const\n        ->  decltype(std::forward<T>(Left) | std::forward<U>(Right));\n};\n```  \n  \n### Parameters  \n `Type`, ` T`, ` U`  \n Any type that supports an `operator|` that takes operands of the specified or inferred types.  \n  \n `Left`  \n The left operand of the bitwise OR operation. The unspecialized template takes an lvalue reference argument of type `Type`. The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` T`.  \n  \n `Right`  \n The right operand of the bitwise OR operation. The unspecialized template takes an lvalue reference argument of type `Type`. The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` U`.  \n  \n### Return Value  \n The result of `Left``|``Right`. The specialized template does perfect forwarding of the result, which has the type that's returned by `operator|`.  \n  \n### Remarks  \n The `bit_or` functor is restricted to integral types for the basic data types, or to user-defined types that implement `operator|`.  \n  \n##  <a name=\"bit_xor_function\"></a>  bit_xor  \n A predefined function object that performs the bitwise XOR operation (binary `operator^`) on its arguments.  \n  \n```  \ntemplate <class Type = void>  \nstruct bit_xor : public binary_function<Type, Type, Type> {  \n    Type operator()(\n    const Type& Left,   \n    const Type& Right) const; \n };  \n \n// specialized transparent functor for operator^  \ntemplate <>\nstruct bit_xor<void>\n{\n    template <class T, class U>\n    auto operator()(T&& Left, U&& Right) const\n        -> decltype(std::forward<T>(Left) ^ std::forward<U>(Right));\n};\n```  \n  \n### Parameters  \n `Type`, ` T`, ` U`  \n Any type that supports an `operator^` that takes operands of the specified or inferred types.  \n  \n `Left`  \n The left operand of the bitwise XOR operation. The unspecialized template takes an lvalue reference argument of type `Type`. The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` T`.  \n  \n `Right`  \n The right operand of the bitwise XOR operation. The unspecialized template takes an lvalue reference argument of type `Type`. The specialized template does perfect forwarding of lvalue and rvalue reference arguments of inferred type ` U`.  \n  \n### Return Value  \n The result of `Left``^``Right`. The specialized template does perfect forwarding of the result, which has the type that's returned by `operator^`.  \n  \n### Remarks  \n The `bit_xor` functor is restricted to integral types for the basic data types, or to user-defined types that implement binary `operator^`.  \n  \n##  <a name=\"cref_function\"></a>  cref  \n Constructs a const `reference_wrapper` from an argument.  \n  \n```  \ntemplate <class Ty>  \nreference_wrapper<const Ty> cref(const Ty& arg);\n\ntemplate <class Ty>  \nreference_wrapper<const Ty> cref(const reference_wrapper<Ty>& arg);\n```  \n  \n### Parameters  \n `Ty`  \n The type of the argument to wrap.  \n  \n `arg`  \n The argument to wrap.  \n  \n### Remarks  \n The first function returns `reference_wrapper<const Ty>(arg.get())`. You use it to wrap a const reference. The second function returns `reference_wrapper<const Ty>(arg)`. You use it to rewrap a wrapped reference as a const reference.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__cref.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <iostream>   \n  \nint neg(int val)   \n    {   \n    return (-val);   \n    }   \n  \nint main()   \n    {   \n    int i = 1;   \n  \n    std::cout << \"i = \" << i << std::endl;   \n    std::cout << \"cref(i) = \" << std::cref(i) << std::endl;   \n    std::cout << \"cref(neg)(i) = \"   \n        << std::cref(&neg)(i) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \ni = 1  \ncref(i) = 1  \ncref(neg)(i) = -1  \n```  \n  \n##  <a name=\"mem_fn_function\"></a>  mem_fn  \n Generates a simple call wrapper.  \n  \n```  \ntemplate <class Ret, class Ty>  \nunspecified mem_fn(Ret Ty::*pm);\n```  \n  \n### Parameters  \n `Ret`  \n The return type of the wrapped function.  \n  \n `Ty`  \n The type of the member function pointer.  \n  \n### Remarks  \n The template function returns a simple call wrapper `cw`, with a weak result type, such that the expression `cw(t, a2, ..., aN)` is equivalent to `INVOKE(pm, t, a2, ..., aN)`. It does not throw any exceptions.  \n  \n The returned call wrapper is derived from `std::unary_function<cv Ty*, Ret>` (hence defining the nested type `result_type` as a synonym for `Ret` and the nested type `argument_type` as a synonym for `cv Ty*`) only if the type `Ty` is a pointer to member function with cv-qualifier `cv` that takes no arguments.  \n  \n The returned call wrapper is derived from `std::binary_function<cv Ty*, T2, Ret>` (hence defining the nested type `result_type` as a synonym for `Ret`, the nested type `first argument_type` as a synonym for `cv Ty*`, and the nested type `second argument_type` as a synonym for `T2`) only if the type `Ty` is a pointer to member function with cv-qualifier `cv` that takes one argument, of type `T2`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__mem_fn.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <iostream>   \n  \nclass Funs   \n    {   \npublic:   \n    void square(double x)   \n        {   \n        std::cout << x << \"^2 == \" << x * x << std::endl;   \n        }   \n  \n    void product(double x, double y)   \n        {   \n        std::cout << x << \"*\" << y << \" == \" << x * y << std::endl;   \n        }   \n    };   \n  \nint main()   \n    {   \n    Funs funs;   \n  \n    std::mem_fn(&Funs::square)(funs, 3.0);   \n    std::mem_fn(&Funs::product)(funs, 3.0, 2.0);   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \n3^2 == 9  \n3*2 == 6  \n```  \n  \n##  <a name=\"mem_fun_function\"></a>  mem_fun  \n Helper template functions used to construct function object adaptors for member functions when initialized with pointer arguments.  \n  \n```  \ntemplate <class Result, class Type>  \nmem_fun_t<Result, Type> mem_fun (Result(Type::* pmem)());\n\ntemplate <class Result, class Type, class Arg>  \nmem_fun1_t<Result, Type, Arg> mem_fun(Result (Type::* pmem)(Arg));\n\ntemplate <class Result, class Type>  \nconst_mem_fun_t<Result, Type> mem_fun(Result (Type::* pmem)() const);\n\ntemplate <class Result, class Type, class Arg>  \nconst_mem_fun1_t<Result, Type, Arg> mem_fun(Result (Type::* pmem)(Arg) const);\n```  \n  \n### Parameters  \n `pmem`  \n A pointer to the member function of class **Type** to be converted to a function object.  \n  \n### Return Value  \n A **const** or **non_const** function object of type `mem_fun_t` or `mem_fun1_t`.  \n  \n### Example  \n  \n```cpp  \n// functional_mem_fun.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <functional>  \n#include <algorithm>  \n#include <iostream>  \n  \nusing namespace std;  \n  \nclass StoreVals     \n{  \n    int val;  \npublic:  \n    StoreVals() { val = 0; }  \n    StoreVals(int j) { val = j; }  \n  \n    bool display() { cout << val << \" \"; return true; }  \n    int squareval() { val *= val; return val; }  \n    int lessconst(int k) {val -= k; return val; }  \n};  \n  \nint main( )  \n{  \n    vector<StoreVals *> v1;  \n  \n    StoreVals sv1(5);  \n    v1.push_back(&sv1);  \n    StoreVals sv2(10);  \n    v1.push_back(&sv2);  \n    StoreVals sv3(15);  \n    v1.push_back(&sv3);  \n    StoreVals sv4(20);  \n    v1.push_back(&sv4);  \n    StoreVals sv5(25);  \n    v1.push_back(&sv5);  \n  \n    cout << \"The original values stored are: \" ;  \n    for_each(v1.begin(), v1.end(), mem_fun<bool, StoreVals>(&StoreVals::display));  \n    cout << endl;  \n  \n    // Use of mem_fun calling member function through a pointer  \n    // square each value in the vector using squareval ()  \n    for_each(v1.begin(), v1.end(), mem_fun<int, StoreVals>(&StoreVals::squareval));     \n    cout << \"The squared values are: \" ;  \n    for_each(v1.begin(), v1.end(), mem_fun<bool, StoreVals>(&StoreVals::display));  \n    cout << endl;  \n  \n    // Use of mem_fun1 calling member function through a pointer  \n    // subtract 5 from each value in the vector using lessconst ()  \n    for_each(v1.begin(), v1.end(),   \n        bind2nd (mem_fun1<int, StoreVals,int>(&StoreVals::lessconst), 5));     \n    cout << \"The squared values less 5 are: \" ;  \n    for_each(v1.begin(), v1.end(), mem_fun<bool, StoreVals>(&StoreVals::display));  \n    cout << endl;  \n}  \n```  \n  \n##  <a name=\"mem_fun_ref_function\"></a>  mem_fun_ref  \n Helper template functions used to construct function object adaptors for member functions when initialized by using reference arguments.  \n  \n```  \ntemplate <class Result, class Type>  \nmem_fun_ref_t<Result, Type> mem_fun_ref(Result (Type::* pmem)());\n\ntemplate <class Result, class Type, class Arg>  \nmem_fun1_ref_t<Result, Type, Arg> mem_fun_ref(Result (Type::* pmem)(Arg));\n\ntemplate <class Result, class Type>  \nconst_mem_fun_ref_t<Result, Type> mem_fun_ref(Result Type::* pmem)() const);\n\ntemplate <class Result, class Type, class Arg>  \nconst_mem_fun1_ref_t<Result, Type, Arg> mem_fun_ref(Result (T::* pmem)(Arg) const);\n```  \n  \n### Parameters  \n `pmem`  \n A pointer to the member function of class `Type` to be converted to a function object.  \n  \n### Return Value  \n A `const` or `non_const` function object of type `mem_fun_ref_t` or `mem_fun1_ref_t`.  \n  \n### Example  \n  \n```cpp  \n// functional_mem_fun_ref.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <functional>  \n#include <algorithm>  \n#include <iostream>  \n  \nusing namespace std;  \n  \nclass NumVals  \n   {  \n   int val;  \n   public:  \n   NumVals ( ) { val = 0; }  \n   NumVals ( int j ) { val = j; }  \n  \n   bool display ( ) { cout << val << \" \"; return true; }  \n   bool isEven ( ) { return ( bool )  !( val %2 ); }  \n   bool isPrime( )  \n   {  \n      if (val < 2) { return true; }  \n      for (int i = 2; i <= val / i; ++i)  \n      {  \n         if (val % i == 0) { return false; }  \n      }  \n      return true;  \n   }  \n};  \n  \nint main( )  \n{  \n   vector <NumVals> v1 ( 13 ), v2 ( 13 );  \n   vector <NumVals>::iterator v1_Iter, v2_Iter;  \n   int i, k;  \n  \n   for ( i = 0; i < 13; i++ ) v1 [ i ] = NumVals ( i+1 );  \n   for ( k = 0; k < 13; k++ ) v2 [ k ] = NumVals ( k+1 );  \n  \n   cout << \"The original values stored in v1 are: \" ;  \n   for_each( v1.begin( ), v1.end( ),   \n   mem_fun_ref ( &NumVals::display ) );  \n   cout << endl;  \n  \n   // Use of mem_fun_ref calling member function through a reference  \n   // remove the primes in the vector using isPrime ( )  \n   v1_Iter = remove_if ( v1.begin( ),  v1.end( ),   \n      mem_fun_ref ( &NumVals::isPrime ) );     \n   cout << \"With the primes removed, the remaining values in v1 are: \" ;  \n   for_each( v1.begin( ), v1_Iter,   \n   mem_fun_ref ( &NumVals::display ) );  \n   cout << endl;  \n  \n   cout << \"The original values stored in v2 are: \" ;  \n   for_each( v2.begin( ), v2.end( ),   \n   mem_fun_ref ( &NumVals::display ) );  \n   cout << endl;  \n  \n   // Use of mem_fun_ref calling member function through a reference  \n   // remove the even numbers in the vector v2 using isEven ( )  \n   v2_Iter = remove_if ( v2.begin( ),  v2.end( ),   \n      mem_fun_ref ( &NumVals::isEven ) );     \n   cout << \"With the even numbers removed, the remaining values are: \" ;  \n   for_each( v2.begin( ),  v2_Iter,   \n   mem_fun_ref ( &NumVals::display ) );  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe original values stored in v1 are: 1 2 3 4 5 6 7 8 9 10 11 12 13   \nWith the primes removed, the remaining values in v1 are: 4 6 8 9 10 12   \nThe original values stored in v2 are: 1 2 3 4 5 6 7 8 9 10 11 12 13   \nWith the even numbers removed, the remaining values are: 1 3 5 7 9 11 13   \n```  \n  \n##  <a name=\"not1_function\"></a>  not1  \n Returns the complement of a unary predicate.  \n  \n```  \ntemplate <class UnaryPredicate>  \nunary_negate<UnaryPredicate> not1(const UnaryPredicate& pred);\n```  \n  \n### Parameters  \n ` pred`  \n The unary predicate to be negated.  \n  \n### Return Value  \n A unary predicate that is the negation of the unary predicate modified.  \n  \n### Remarks  \n If a `unary_negate` is constructed from a unary predicate **Pred**( *x*), then it returns **!Pred**( *x*).  \n  \n### Example  \n  \n```cpp  \n// functional_not1.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <functional>  \n#include <algorithm>  \n#include <iostream>  \n  \nusing namespace std;  \n  \nint main()  \n{  \n    vector<int> v1;  \n    vector<int>::iterator Iter;  \n  \n    int i;  \n    for (i = 0; i <= 7; i++)  \n    {  \n        v1.push_back(5 * i);  \n    }  \n  \n    cout << \"The vector v1 = ( \";  \n    for (Iter = v1.begin(); Iter != v1.end(); Iter++)  \n        cout << *Iter << \" \";  \n    cout << \")\" << endl;  \n  \n    vector<int>::iterator::difference_type result1;  \n    // Count the elements greater than 10  \n    result1 = count_if(v1.begin(), v1.end(), bind2nd(greater<int>(), 10));  \n    cout << \"The number of elements in v1 greater than 10 is: \"  \n         << result1 << \".\" << endl;  \n  \n    vector<int>::iterator::difference_type result2;  \n    // Use the negator to count the elements less than or equal to 10  \n    result2 = count_if(v1.begin(), v1.end(),  \n        not1(bind2nd(greater<int>(), 10)));  \n  \n    cout << \"The number of elements in v1 not greater than 10 is: \"  \n         << result2 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe vector v1 = ( 0 5 10 15 20 25 30 35 )  \nThe number of elements in v1 greater than 10 is: 5.  \nThe number of elements in v1 not greater than 10 is: 3.  \n```  \n  \n##  <a name=\"not2_function\"></a>  not2  \n Returns the complement of a binary predicate.  \n  \n```  \ntemplate <class BinaryPredicate>  \nbinary_negate<BinaryPredicate> not2(const BinaryPredicate& func);\n```  \n  \n### Parameters  \n `func`  \n The binary predicate to be negated.  \n  \n### Return Value  \n A binary predicate that is the negation of the binary predicate modified.  \n  \n### Remarks  \n If a `binary_negate` is constructed from a binary predicate **BinPred**( *x*, *y*), then it returns ! **BinPred**( *x*, *y*).  \n  \n### Example  \n  \n```cpp  \n// functional_not2.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <algorithm>  \n#include <functional>  \n#include <cstdlib>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   vector <int> v1;  \n   vector <int>::iterator Iter1;  \n  \n   int i;  \n   v1.push_back( 6262 );  \n   v1.push_back( 6262 );  \n   for ( i = 0 ; i < 5 ; i++ )  \n   {  \n      v1.push_back( rand( ) );  \n   }  \n  \n   cout << \"Original vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // To sort in ascending order,  \n   // use default binary predicate less<int>( )  \n   sort( v1.begin( ), v1.end( ) );  \n   cout << \"Sorted vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n  \n   // To sort in descending order,   \n   // use the binary_negate helper function not2  \n   sort( v1.begin( ), v1.end( ), not2(less<int>( ) ) );  \n   cout << \"Resorted vector v1 = ( \" ;  \n   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )  \n      cout << *Iter1 << \" \";  \n   cout << \")\" << endl;  \n}  \n```  \n  \n```Output  \nOriginal vector v1 = ( 6262 6262 41 18467 6334 26500 19169 )  \nSorted vector v1 = ( 41 6262 6262 6334 18467 19169 26500 )  \nResorted vector v1 = ( 26500 19169 18467 6334 6262 6262 41 )  \n```  \n  \n##  <a name=\"ptr_fun_function\"></a>  ptr_fun  \n Helper template functions used to convert unary and binary function pointers, respectively, into unary and binary adaptable functions.  \n  \n```  \ntemplate <class Arg, class Result>  \npointer_to_unary_function<Arg, Result, Result (*)(Arg)> ptr_fun(Result (*pfunc)(Arg));\n\ntemplate <class Arg1, class Arg2, class Result>  \npointer_to_binary_function<Arg1, Arg2, Result, Result (*)(Arg1, Arg2)> ptr_fun(Result (*pfunc)(Arg1, Arg2));\n```  \n  \n### Parameters  \n `pfunc`  \n The unary or binary function pointer to be converted to an adaptable function.  \n  \n### Return Value  \n The first template function returns the unary function [pointer_to_unary_function](../standard-library/pointer-to-unary-function-class.md) < `Arg`, **Result**>(* `pfunc`).  \n  \n The second template function returns binary function [pointer_to_binary_function](../standard-library/pointer-to-binary-function-class.md) \\< **Arg1**, **Arg2**, **Result**>(* `pfunc`).  \n  \n### Remarks  \n A function pointer is a function object and may be passed to any Standard Template Library algorithm that is expecting a function as a parameter, but it is not adaptable. To use it with an adaptor, such as binding a value to it or using it with a negator, it must be supplied with the nested types that make such an adaptation possible. The conversion of unary and binary function pointers by the `ptr_fun` helper function allows the function adaptors to work with unary and binary function pointers.  \n  \n### Example  \n [!code-cpp[functional_ptr_fun#1](../standard-library/codesnippet/CPP/functional-functions_1.cpp)]  \n  \n##  <a name=\"ref_function\"></a>  ref  \n Constructs a `reference_wrapper` from an argument.  \n  \n```  \ntemplate <class Ty>  \nreference_wrapper<Ty> ref(Ty& arg);\n\ntemplate <class Ty>  \nreference_wrapper<Ty> ref(reference_wrapper<Ty>& arg);\n```  \n  \n### Return Value  \n A reference to `arg`; specifically, `reference_wrapper<Ty>(arg)`.  \n  \n### Example  \n  The following example defines two functions: one bound to a string variable, the other bound to a reference of the string variable computed by a call to `ref`. When the value of the variable changes, the first function continues to use the old value and the second function uses the new value.  \n  \n```  \n#include <algorithm>  \n#include <functional>  \n#include <iostream>  \n#include <iterator>  \n#include <ostream>  \n#include <string>  \n#include <vector>  \nusing namespace std;  \nusing namespace std;  \nusing namespace std::placeholders;  \n  \nbool shorter_than(const string& l, const string& r) {  \n    return l.size() < r.size();  \n}  \n  \nint main() {  \n    vector<string> v_original;  \n    v_original.push_back(\"tiger\");  \n    v_original.push_back(\"cat\");  \n    v_original.push_back(\"lion\");  \n    v_original.push_back(\"cougar\");  \n  \n    copy(v_original.begin(), v_original.end(), ostream_iterator<string>(cout, \" \"));  \n    cout << endl;  \n  \n    string s(\"meow\");  \n  \n    function<bool (const string&)> f = bind(shorter_than, _1, s);  \n    function<bool (const string&)> f_ref = bind(shorter_than, _1, ref(s));  \n  \n    vector<string> v;  \n  \n    // Remove elements that are shorter than s (\"meow\")  \n  \n    v = v_original;  \n    v.erase(remove_if(v.begin(), v.end(), f), v.end());  \n  \n    copy(v.begin(), v.end(), ostream_iterator<string>(cout, \" \"));  \n    cout << endl;  \n  \n    // Now change the value of s.  \n    // f_ref, which is bound to ref(s), will use the  \n    // new value, while f is still bound to the old value.  \n  \n    s = \"kitty\";  \n  \n    // Remove elements that are shorter than \"meow\" (f is bound to old value of s)  \n  \n    v = v_original;  \n    v.erase(remove_if(v.begin(), v.end(), f), v.end());  \n  \n    copy(v.begin(), v.end(), ostream_iterator<string>(cout, \" \"));  \n    cout << endl;  \n  \n    // Remove elements that are shorter than \"kitty\" (f_ref is bound to ref(s))  \n  \n    v = v_original;  \n    v.erase(remove_if(v.begin(), v.end(), f_ref), v.end());  \n  \n    copy(v.begin(), v.end(), ostream_iterator<string>(cout, \" \"));  \n    cout << endl;  \n}  \n```  \n  \n```Output  \ntiger cat lion cougar  \ntiger lion cougar  \ntiger lion cougar  \ntiger cougar  \n```  \n  \n##  <a name=\"swap_function\"></a>  swap  \n Swaps two `function` objects.  \n  \n```  \ntemplate <class Fty>  \nvoid swap(function<Fty>& f1, function<Fty>& f2);\n```  \n  \n### Parameters  \n `Fty`  \n The type controlled by the function objects.  \n  \n `f1`  \n The first function object.  \n  \n `f2`  \n The second function object.  \n  \n### Remarks  \n The function returns `f1.swap(f2)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__swap.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <iostream>   \n  \nint neg(int val)   \n    {   \n    return (-val);   \n    }   \n  \nint main()   \n    {   \n    std::function<int (int)> fn0(neg);   \n    std::cout << std::boolalpha << \"empty == \" << !fn0 << std::endl;   \n    std::cout << \"val == \" << fn0(3) << std::endl;   \n  \n    std::function<int (int)> fn1;   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n    std::cout << std::endl;   \n  \n    swap(fn0, fn1);   \n    std::cout << std::boolalpha << \"empty == \" << !fn0 << std::endl;   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n    std::cout << \"val == \" << fn1(3) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nempty == false  \nval == -3  \nempty == true  \n  \nempty == true  \nempty == false  \nval == -3  \n```  \n  \n## See Also  \n [\\<functional>](../standard-library/functional.md)\n\n"}