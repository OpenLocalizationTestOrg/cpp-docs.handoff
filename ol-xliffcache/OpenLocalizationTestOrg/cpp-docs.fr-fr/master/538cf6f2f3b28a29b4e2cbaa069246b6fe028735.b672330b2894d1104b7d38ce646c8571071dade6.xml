{"nodes":[{"pos":[12,59],"content":"concurrent_unordered_set Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"concurrent_unordered_set Class | Microsoft Docs","pos":[0,47]}]},{"content":"concurrent_unordered_set Class","pos":[682,712]},{"pos":[713,987],"content":"The <ph id=\"ph1\">`concurrent_unordered_set`</ph> class is an concurrency-safe container that controls a varying-length sequence of elements of type K. The sequence is represented in a way that enables concurrency-safe append, element access, iterator access and iterator traversal operations.","source":"The `concurrent_unordered_set` class is an concurrency-safe container that controls a varying-length sequence of elements of type K. The sequence is represented in a way that enables concurrency-safe append, element access, iterator access and iterator traversal operations."},{"content":"Syntax","pos":[996,1002]},{"content":"Parameters","pos":[1486,1496]},{"content":"The key type.","pos":[1507,1520]},{"content":"The hash function object type.","pos":[1540,1570]},{"content":"This argument is optional and the default value is <ph id=\"ph1\">`std::tr1::hash&lt;``K``&gt;`</ph>.","pos":[1571,1646],"source":" This argument is optional and the default value is `std::tr1::hash<``K``>`."},{"content":"The equality comparison function object type.","pos":[1671,1716]},{"content":"This argument is optional and the default value is <ph id=\"ph1\">`std::equal_to&lt;``K``&gt;`</ph>.","pos":[1717,1791],"source":" This argument is optional and the default value is `std::equal_to<``K``>`."},{"content":"The type that represents the stored allocator object that encapsulates details about the allocation and deallocation of memory for the concurrent unordered set.","pos":[1819,1979]},{"content":"This argument is optional and the default value is <ph id=\"ph1\">`std::allocator&lt;``K``&gt;`</ph>.","pos":[1980,2055],"source":" This argument is optional and the default value is `std::allocator<``K``>`."},{"content":"Members","pos":[2064,2071]},{"content":"Public Typedefs","pos":[2081,2096]},{"content":"Name","pos":[2103,2107]},{"content":"Description","pos":[2108,2119]},{"content":"The type of an allocator for managing storage.","pos":[2174,2220]},{"content":"The type of a constant iterator for the controlled sequence.","pos":[2242,2302]},{"content":"The type of a constant bucket iterator for the controlled sequence.","pos":[2330,2397]},{"content":"The type of a constant pointer to an element.","pos":[2418,2463]},{"content":"The type of a constant reference to an element.","pos":[2486,2533]},{"content":"The type of a signed distance between two elements.","pos":[2556,2607]},{"content":"The type of the hash function.","pos":[2621,2651]},{"content":"The type of an iterator for the controlled sequence.","pos":[2667,2719]},{"content":"The type of the comparison function.","pos":[2736,2772]},{"content":"The type of an ordering key.","pos":[2788,2816]},{"content":"The type of a bucket iterator for the controlled sequence.","pos":[2838,2896]},{"content":"The type of a pointer to an element.","pos":[2911,2947]},{"content":"The type of a reference to an element.","pos":[2964,3002]},{"content":"The type of an unsigned distance between two elements.","pos":[3019,3073]},{"content":"The type of an element.","pos":[3091,3114]},{"content":"Public Constructors","pos":[3125,3144]},{"content":"Name","pos":[3151,3155]},{"content":"Description","pos":[3156,3167]},{"content":"concurrent_unordered_set::concurrent_unordered_set Constructor","pos":[3206,3268]},{"content":"Overloaded.","pos":[3277,3288]},{"content":"Constructs a concurrent unordered set.","pos":[3289,3327]},{"content":"Public Methods","pos":[3338,3352]},{"content":"Name","pos":[3359,3363]},{"content":"Description","pos":[3364,3375]},{"content":"concurrent_unordered_set::hash_function Method","pos":[3414,3460]},{"content":"Returns the stored hash function object.","pos":[3478,3518]},{"content":"concurrent_unordered_set::insert Method","pos":[3524,3563]},{"content":"Overloaded.","pos":[3574,3585]},{"content":"Adds elements to the <ph id=\"ph1\">`concurrent_unordered_set`</ph> object.","pos":[3586,3641],"source":" Adds elements to the `concurrent_unordered_set` object."},{"content":"concurrent_unordered_set::key_eq Method","pos":[3647,3686]},{"content":"Returns the stored equality comparison function object.","pos":[3697,3752]},{"content":"concurrent_unordered_set::swap Method","pos":[3758,3795]},{"content":"Swaps the contents of two <ph id=\"ph1\">`concurrent_unordered_set`</ph> objects.","pos":[3804,3865],"source":"Swaps the contents of two `concurrent_unordered_set` objects."},{"content":"This method is not concurrency-safe.","pos":[3866,3902]},{"content":"concurrent_unordered_set::unsafe_erase Method","pos":[3908,3953]},{"content":"Overloaded.","pos":[3970,3981]},{"content":"Removes elements from the <ph id=\"ph1\">`concurrent_unordered_set`</ph> at specified positions.","pos":[3982,4058],"source":" Removes elements from the `concurrent_unordered_set` at specified positions."},{"content":"This method is not concurrency-safe.","pos":[4059,4095]},{"content":"Public Operators","pos":[4106,4122]},{"content":"Name","pos":[4129,4133]},{"content":"Description","pos":[4134,4145]},{"content":"concurrent_unordered_set::operator= Operator","pos":[4184,4228]},{"content":"Overloaded.","pos":[4244,4255]},{"content":"Assigns the contents of another <ph id=\"ph1\">`concurrent_unordered_set`</ph> object to this one.","pos":[4256,4334],"source":" Assigns the contents of another `concurrent_unordered_set` object to this one."},{"content":"This method is not concurrency-safe.","pos":[4335,4371]},{"content":"Remarks","pos":[4381,4388]},{"pos":[4392,4557],"content":"For detailed information on the <ph id=\"ph1\">`concurrent_unordered_set`</ph> class, see <bpt id=\"p1\">[</bpt>Parallel Containers and Objects<ept id=\"p1\">](../../../parallel/concrt/parallel-containers-and-objects.md)</ept>.","source":"For detailed information on the `concurrent_unordered_set` class, see [Parallel Containers and Objects](../../../parallel/concrt/parallel-containers-and-objects.md)."},{"content":"Inheritance Hierarchy","pos":[4566,4587]},{"content":"Requirements","pos":[4667,4679]},{"pos":[4683,4721],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> concurrent_unordered_set.h","source":"**Header:** concurrent_unordered_set.h"},{"pos":[4728,4754],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> concurrency","source":"**Namespace:** concurrency"},{"pos":[4786,4824],"content":"concurrent_unordered_set::begin Method"},{"content":"Returns an iterator pointing to the first element in the concurrent container.","pos":[4828,4906]},{"content":"This method is concurrency safe.","pos":[4907,4939]},{"content":"Return Value","pos":[5011,5023]},{"content":"An iterator to the first element in the concurrent container.","pos":[5027,5088]},{"pos":[5121,5160],"content":"concurrent_unordered_set::cbegin Method"},{"content":"Returns a const iterator pointing to the first element in the concurrent container.","pos":[5164,5247]},{"content":"This method is concurrency safe.","pos":[5248,5280]},{"content":"Return Value","pos":[5334,5346]},{"content":"A const iterator to the first element in the concurrent container.","pos":[5350,5416]},{"pos":[5447,5484],"content":"concurrent_unordered_set::cend Method"},{"content":"Returns a const iterator pointing to the location succeeding the last element in the concurrent container.","pos":[5488,5594]},{"content":"This method is concurrency safe.","pos":[5595,5627]},{"content":"Return Value","pos":[5679,5691]},{"content":"A const iterator to the location succeeding the last element in the concurrent container.","pos":[5695,5784]},{"pos":[5816,5854],"content":"concurrent_unordered_set::clear Method"},{"content":"Erases all the elements in the concurrent container.","pos":[5858,5910]},{"content":"This function is not concurrency safe.","pos":[5911,5949]},{"pos":[6007,6069],"content":"concurrent_unordered_set::concurrent_unordered_set Constructor"},{"content":"Constructs a concurrent unordered set.","pos":[6073,6111]},{"content":"Parameters","pos":[6940,6950]},{"content":"The type of the input iterator.","pos":[6969,7000]},{"content":"The initial number of buckets for this unordered set.","pos":[7031,7084]},{"content":"The hash function for this unordered set.","pos":[7104,7145]},{"content":"The equality comparison function for this unordered set.","pos":[7170,7226]},{"content":"The allocator for this unordered set.","pos":[7249,7286]},{"content":"The source <ph id=\"ph1\">`concurrent_unordered_set`</ph> object to copy or move elements from.","pos":[7325,7400],"source":" The source `concurrent_unordered_set` object to copy or move elements from."},{"content":"Remarks","pos":[7410,7417]},{"pos":[7421,7510],"content":"All constructors store an allocator object <ph id=\"ph1\">`_Allocator`</ph> and initialize the unordered set.","source":"All constructors store an allocator object `_Allocator` and initialize the unordered set."},{"content":"The first constructor specifies an empty initial set and explicitly specifies the number of buckets, hash function, equality function and allocator type to be used.","pos":[7517,7681]},{"content":"The second constructor specifies an allocator for the unordered set.","pos":[7688,7756]},{"pos":[7763,7853],"content":"The third constructor specifies values supplied by the iterator range [ <ph id=\"ph1\">`_Begin`</ph>, <ph id=\"ph2\">`_End`</ph>).","source":"The third constructor specifies values supplied by the iterator range [ `_Begin`, `_End`)."},{"pos":[7860,7949],"content":"The fourth and fifth constructors specify a copy of the concurrent unordered set <ph id=\"ph1\">`_Uset`</ph>.","source":"The fourth and fifth constructors specify a copy of the concurrent unordered set `_Uset`."},{"pos":[7956,8034],"content":"The last constructor specifies a move of the concurrent unordered set <ph id=\"ph1\">`_Uset`</ph>.","source":"The last constructor specifies a move of the concurrent unordered set `_Uset`."},{"pos":[8066,8104],"content":"concurrent_unordered_set::count Method"},{"content":"Counts the number of elements matching a specified key.","pos":[8108,8163]},{"content":"This function is concurrency safe.","pos":[8164,8198]},{"content":"Parameters","pos":[8266,8276]},{"content":"The key to search for.","pos":[8290,8312]},{"content":"Return Value","pos":[8322,8334]},{"content":"The number of times number of times the key appears in the container.","pos":[8338,8407]},{"pos":[8439,8477],"content":"concurrent_unordered_set::empty Method"},{"content":"Tests whether no elements are present.","pos":[8481,8519]},{"content":"This method is concurrency safe.","pos":[8520,8552]},{"content":"Return Value","pos":[8595,8607]},{"pos":[8618,8674],"content":"if the concurrent container is empty, <ph id=\"ph1\">`false`</ph> otherwise.","source":" if the concurrent container is empty, `false` otherwise."},{"content":"Remarks","pos":[8684,8691]},{"content":"In the presence of concurrent inserts, whether or not the concurrent container is empty may change immediately after calling this function, before the return value is even read.","pos":[8695,8872]},{"pos":[8902,8938],"content":"concurrent_unordered_set::end Method"},{"content":"Returns an iterator pointing to the location succeeding the last element in the concurrent container.","pos":[8942,9043]},{"content":"This method is concurrency safe.","pos":[9044,9076]},{"content":"Return Value","pos":[9144,9156]},{"content":"An iterator to the location succeeding the last element in the concurrent container.","pos":[9160,9244]},{"pos":[9282,9326],"content":"concurrent_unordered_set::equal_range Method"},{"content":"Finds a range that matches a specified key.","pos":[9330,9373]},{"content":"This function is concurrency safe.","pos":[9374,9408]},{"content":"Parameters","pos":[9598,9608]},{"content":"The key value to search for.","pos":[9622,9650]},{"content":"Return Value","pos":[9660,9672]},{"pos":[9676,9873],"content":"A <bpt id=\"p1\">[</bpt>pair<ept id=\"p1\">](http://msdn.microsoft.com/en-us/32e72d66-3020-4cb9-92c3-f7a5fa7998ff)</ept> where the first element is an iterator to the beginning and the second element is an iterator to the end of the range.","source":"A [pair](http://msdn.microsoft.com/en-us/32e72d66-3020-4cb9-92c3-f7a5fa7998ff) where the first element is an iterator to the beginning and the second element is an iterator to the end of the range."},{"content":"Remarks","pos":[9883,9890]},{"content":"It is possible for concurrent inserts to cause additional keys to be inserted after the begin iterator and before the end iterator.","pos":[9894,10025]},{"pos":[10056,10093],"content":"concurrent_unordered_set::find Method"},{"content":"Finds an element that matches a specified key.","pos":[10097,10143]},{"content":"This function is concurrency safe.","pos":[10144,10178]},{"content":"Parameters","pos":[10288,10298]},{"content":"The key value to search for.","pos":[10312,10340]},{"content":"Return Value","pos":[10350,10362]},{"pos":[10366,10509],"content":"An iterator pointing to the location of the the first element that matched the key provided, or the iterator <ph id=\"ph1\">`end()`</ph> if no such element exists.","source":"An iterator pointing to the location of the the first element that matched the key provided, or the iterator `end()` if no such element exists."},{"pos":[10549,10595],"content":"concurrent_unordered_set::get_allocator Method"},{"content":"Returns the stored allocator object for this concurrent container.","pos":[10599,10665]},{"content":"This method is concurrency safe.","pos":[10666,10698]},{"content":"Return Value","pos":[10759,10771]},{"content":"The stored allocator object for this concurrent container.","pos":[10775,10833]},{"pos":[10873,10919],"content":"concurrent_unordered_set::hash_function Method"},{"content":"Returns the stored hash function object.","pos":[10923,10963]},{"content":"Return Value","pos":[11016,11028]},{"content":"The stored hash function object.","pos":[11032,11064]},{"pos":[11097,11136],"content":"concurrent_unordered_set::insert Method"},{"pos":[11140,11195],"content":"Adds elements to the <ph id=\"ph1\">`concurrent_unordered_set`</ph> object.","source":"Adds elements to the `concurrent_unordered_set` object."},{"content":"Parameters","pos":[11723,11733]},{"content":"The iterator type used for insertion.","pos":[11752,11789]},{"content":"The type of the value inserted into the set.","pos":[11803,11847]},{"content":"The value to be inserted.","pos":[11865,11890]},{"content":"The starting location to search for an insertion point.","pos":[11909,11964]},{"content":"The beginning of the range to insert.","pos":[11982,12019]},{"content":"The end of the range to insert.","pos":[12036,12067]},{"content":"Return Value","pos":[12077,12089]},{"content":"A pair that contains an iterator and a boolean value.","pos":[12093,12146]},{"content":"See the Remarks section for more details.","pos":[12147,12188]},{"content":"Remarks","pos":[12198,12205]},{"content":"The first member function determines whether an element X exists in the sequence whose key has equivalent ordering to that of <ph id=\"ph1\">`value`</ph>.","pos":[12209,12343],"source":"The first member function determines whether an element X exists in the sequence whose key has equivalent ordering to that of `value`."},{"content":"If not, it creates such an element X and initializes it with <ph id=\"ph1\">`value`</ph>.","pos":[12344,12413],"source":" If not, it creates such an element X and initializes it with `value`."},{"content":"The function then determines the iterator <ph id=\"ph1\">`where`</ph> that designates X. If an insertion occurred, the function returns <ph id=\"ph2\">`std::pair(where, true)`</ph>.","pos":[12414,12555],"source":" The function then determines the iterator `where` that designates X. If an insertion occurred, the function returns `std::pair(where, true)`."},{"content":"Otherwise, it returns <ph id=\"ph1\">`std::pair(where, false)`</ph>.","pos":[12556,12604],"source":" Otherwise, it returns `std::pair(where, false)`."},{"pos":[12611,12764],"content":"The second member function returns insert( <ph id=\"ph1\">`value`</ph>), using <ph id=\"ph2\">`_Where`</ph> as a starting place within the controlled sequence to search for the insertion point.","source":"The second member function returns insert( `value`), using `_Where` as a starting place within the controlled sequence to search for the insertion point."},{"pos":[12771,12870],"content":"The third member function inserts the sequence of element values from the range [ <ph id=\"ph1\">`first`</ph>, <ph id=\"ph2\">`last`</ph>).","source":"The third member function inserts the sequence of element values from the range [ `first`, `last`)."},{"pos":[12877,13001],"content":"The last two member functions behave the same as the first two, except that <ph id=\"ph1\">`value`</ph> is used to construct the inserted value.","source":"The last two member functions behave the same as the first two, except that `value` is used to construct the inserted value."},{"pos":[13034,13073],"content":"concurrent_unordered_set::key_eq Method"},{"content":"Returns the stored equality comparison function object.","pos":[13077,13132]},{"content":"Return Value","pos":[13181,13193]},{"content":"The stored equality comparison function object.","pos":[13197,13244]},{"pos":[13282,13326],"content":"concurrent_unordered_set::load_factor Method"},{"content":"Computes and returns the current load factor of the container.","pos":[13330,13392]},{"content":"The load factor is the number of elements in the container divided by the number of buckets.","pos":[13393,13485]},{"content":"Return Value","pos":[13535,13547]},{"content":"The load factor for the container.","pos":[13551,13585]},{"pos":[13627,13675],"content":"concurrent_unordered_set::max_load_factor Method"},{"content":"Gets or sets the maximum load factor of the container.","pos":[13679,13733]},{"content":"The maximum load factor is the largest number of elements than can be in any bucket before the container grows its internal table.","pos":[13734,13864]},{"content":"Parameters","pos":[13956,13966]},{"content":"Return Value","pos":[13989,14001]},{"content":"The first member function returns the stored maximum load factor.","pos":[14005,14070]},{"content":"The second member function does not return a value but throws an <bpt id=\"p1\">[</bpt>out_of_range<ept id=\"p1\">](../../../standard-library/out-of-range-class.md)</ept> exception if the supplied load factor is invalid..","pos":[14071,14250],"source":" The second member function does not return a value but throws an [out_of_range](../../../standard-library/out-of-range-class.md) exception if the supplied load factor is invalid.."},{"pos":[14285,14326],"content":"concurrent_unordered_set::max_size Method"},{"content":"Returns the maximum size of the concurrent container, determined by the allocator.","pos":[14330,14412]},{"content":"This method is concurrency safe.","pos":[14413,14445]},{"content":"Return Value","pos":[14496,14508]},{"content":"The maximum number of elements that can be inserted into this concurrent container.","pos":[14512,14595]},{"content":"Remarks","pos":[14605,14612]},{"content":"This upper bound value may actually be higher than what the container can actually hold.","pos":[14616,14704]},{"pos":[14742,14786],"content":"concurrent_unordered_set::operator= Operator"},{"content":"Assigns the contents of another <ph id=\"ph1\">`concurrent_unordered_set`</ph> object to this one.","pos":[14790,14868],"source":"Assigns the contents of another `concurrent_unordered_set` object to this one."},{"content":"This method is not concurrency-safe.","pos":[14869,14905]},{"content":"Parameters","pos":[15078,15088]},{"content":"The source <ph id=\"ph1\">`concurrent_unordered_set`</ph> object.","pos":[15103,15148],"source":" The source `concurrent_unordered_set` object."},{"content":"Return Value","pos":[15158,15170]},{"pos":[15174,15228],"content":"A reference to this <ph id=\"ph1\">`concurrent_unordered_set`</ph> object.","source":"A reference to this `concurrent_unordered_set` object."},{"content":"Remarks","pos":[15238,15245]},{"pos":[15249,15409],"content":"After erasing any existing elements in a concurrent unordered set, <ph id=\"ph1\">`operator=`</ph> either copies or moves the contents of <ph id=\"ph2\">`_Uset`</ph> into the concurrent unordered set.","source":"After erasing any existing elements in a concurrent unordered set, `operator=` either copies or moves the contents of `_Uset` into the concurrent unordered set."},{"pos":[15442,15481],"content":"concurrent_unordered_set::rehash Method"},{"content":"Rebuilds the hash table.","pos":[15485,15509]},{"content":"Parameters","pos":[15565,15575]},{"content":"The desired number of buckets.","pos":[15593,15623]},{"content":"Remarks","pos":[15633,15640]},{"content":"The member function alters the number of buckets to be at least <ph id=\"ph1\">`_Buckets`</ph> and rebuilds the hash table as needed.","pos":[15644,15757],"source":"The member function alters the number of buckets to be at least `_Buckets` and rebuilds the hash table as needed."},{"content":"The number of buckets must be a power of 2.","pos":[15758,15801]},{"content":"If not a power of 2, it will be rounded up to the next largest power of 2.","pos":[15802,15876]},{"pos":[15883,16063],"content":"It throws an <bpt id=\"p1\">[</bpt>out_of_range<ept id=\"p1\">](../../../standard-library/out-of-range-class.md)</ept> exception if the number of buckets is invalid (either 0 or greater than the maximum number of buckets).","source":"It throws an [out_of_range](../../../standard-library/out-of-range-class.md) exception if the number of buckets is invalid (either 0 or greater than the maximum number of buckets)."},{"pos":[16094,16131],"content":"concurrent_unordered_set::size Method"},{"content":"Returns the number of elements in this concurrent container.","pos":[16135,16195]},{"content":"This method is concurrency safe.","pos":[16196,16228]},{"content":"Return Value","pos":[16275,16287]},{"content":"The number of items in the container.","pos":[16291,16328]},{"content":"Remarks","pos":[16338,16345]},{"content":"In the presence of concurrent inserts, the number of elements in the concurrent container may change immediately after calling this function, before the return value is even read.","pos":[16349,16528]},{"pos":[16559,16596],"content":"concurrent_unordered_set::swap Method"},{"content":"Swaps the contents of two <ph id=\"ph1\">`concurrent_unordered_set`</ph> objects.","pos":[16600,16661],"source":"Swaps the contents of two `concurrent_unordered_set` objects."},{"content":"This method is not concurrency-safe.","pos":[16662,16698]},{"content":"Parameters","pos":[16765,16775]},{"content":"The <ph id=\"ph1\">`concurrent_unordered_set`</ph> object to swap with.","pos":[16790,16841],"source":" The `concurrent_unordered_set` object to swap with."},{"pos":[16880,16925],"content":"concurrent_unordered_set::unsafe_begin Method"},{"content":"Returns an iterator to the first element in this container for a specific bucket.","pos":[16929,17010]},{"content":"Parameters","pos":[17142,17152]},{"content":"The bucket index.","pos":[17169,17186]},{"content":"Return Value","pos":[17196,17208]},{"content":"An iterator pointing to the beginning of the bucket.","pos":[17212,17264]},{"pos":[17304,17350],"content":"concurrent_unordered_set::unsafe_bucket Method"},{"content":"Returns the bucket index that a specific key maps to in this container.","pos":[17354,17425]},{"content":"Parameters","pos":[17501,17511]},{"content":"The element key being searched for.","pos":[17525,17560]},{"content":"Return Value","pos":[17570,17582]},{"content":"The bucket index for the key in this container.","pos":[17586,17633]},{"pos":[17679,17731],"content":"concurrent_unordered_set::unsafe_bucket_count Method"},{"content":"Returns the current number of buckets in this container.","pos":[17735,17791]},{"content":"Return Value","pos":[17853,17865]},{"content":"The current number of buckets in this container.","pos":[17869,17917]},{"pos":[17962,18013],"content":"concurrent_unordered_set::unsafe_bucket_size Method"},{"content":"Returns the number of items in a specific bucket of this container.","pos":[18017,18084]},{"content":"Parameters","pos":[18156,18166]},{"content":"The bucket to search for.","pos":[18183,18208]},{"content":"Return Value","pos":[18218,18230]},{"content":"The current number of buckets in this container.","pos":[18234,18282]},{"pos":[18322,18368],"content":"concurrent_unordered_set::unsafe_cbegin Method"},{"content":"Returns an iterator to the first element in this container for a specific bucket.","pos":[18372,18453]},{"content":"Parameters","pos":[18537,18547]},{"content":"The bucket index.","pos":[18564,18581]},{"content":"Return Value","pos":[18591,18603]},{"content":"An iterator pointing to the beginning of the bucket.","pos":[18607,18659]},{"pos":[18697,18741],"content":"concurrent_unordered_set::unsafe_cend Method"},{"content":"Returns an iterator to the location succeeding the last element in a specific bucket.","pos":[18745,18830]},{"content":"Parameters","pos":[18912,18922]},{"content":"The bucket index.","pos":[18939,18956]},{"content":"Return Value","pos":[18966,18978]},{"content":"An iterator pointing to the beginning of the bucket.","pos":[18982,19034]},{"pos":[19071,19114],"content":"concurrent_unordered_set::unsafe_end Method"},{"content":"Returns an iterator to the last element in this container for a specific bucket.","pos":[19118,19198]},{"content":"Parameters","pos":[19326,19336]},{"content":"The bucket index.","pos":[19353,19370]},{"content":"Return Value","pos":[19380,19392]},{"content":"An iterator pointing to the end of the bucket.","pos":[19396,19442]},{"pos":[19481,19526],"content":"concurrent_unordered_set::unsafe_erase Method"},{"content":"Removes elements from the <ph id=\"ph1\">`concurrent_unordered_set`</ph> at specified positions.","pos":[19530,19606],"source":"Removes elements from the `concurrent_unordered_set` at specified positions."},{"content":"This method is not concurrency-safe.","pos":[19607,19643]},{"content":"Parameters","pos":[19845,19855]},{"content":"The iterator position to erase from.","pos":[19871,19907]},{"content":"The key value to erase.","pos":[19924,19947]},{"content":"Return Value","pos":[19981,19993]},{"content":"The first two member functions return an iterator that designates the first element remaining beyond any elements removed, or <bpt id=\"p1\">[</bpt>concurrent_unordered_set::end Method<ept id=\"p1\">](#end)</ept>() if no such element exists.","pos":[19997,20196],"source":"The first two member functions return an iterator that designates the first element remaining beyond any elements removed, or [concurrent_unordered_set::end Method](#end)() if no such element exists."},{"content":"The third member function returns the number of elements it removes.","pos":[20197,20265]},{"content":"Remarks","pos":[20275,20282]},{"content":"The first member function removes the element pointed to by <ph id=\"ph1\">`_Where`</ph>.","pos":[20286,20355],"source":"The first member function removes the element pointed to by `_Where`."},{"content":"The second member function removes the elements in the range [ <ph id=\"ph1\">`_Begin`</ph>, <ph id=\"ph2\">`_End`</ph>).","pos":[20356,20437],"source":" The second member function removes the elements in the range [ `_Begin`, `_End`)."},{"pos":[20444,20584],"content":"The third member function removes the elements in the range delimited by <bpt id=\"p1\">[</bpt>concurrent_unordered_set::equal_range Method<ept id=\"p1\">](#equal_range)</ept>(KVal).","source":"The third member function removes the elements in the range delimited by [concurrent_unordered_set::equal_range Method](#equal_range)(KVal)."},{"pos":[20634,20690],"content":"concurrent_unordered_set::unsafe_max_bucket_count Method"},{"content":"Returns the maximum number of buckets in this container.","pos":[20694,20750]},{"content":"Return Value","pos":[20816,20828]},{"content":"The maximum number of buckets in this container.","pos":[20832,20880]},{"content":"See Also","pos":[20889,20897]},{"content":"concurrency Namespace","pos":[20902,20923]},{"content":"Parallel Containers and Objects","pos":[20956,20987]}],"content":"---\ntitle: \"concurrent_unordered_set Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"concurrent_unordered_set/concurrency::concurrent_unordered_set\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"concurrent_unordered_set class\"\nms.assetid: c61f9a9a-4fd9-491a-9251-e300737ecf4b\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# concurrent_unordered_set Class\nThe `concurrent_unordered_set` class is an concurrency-safe container that controls a varying-length sequence of elements of type K. The sequence is represented in a way that enables concurrency-safe append, element access, iterator access and iterator traversal operations.  \n  \n## Syntax  \n  \n```\ntemplate <typename K,\n    typename _Hasher = std::tr1::hash<K>,\n    typename key_equality = std::equal_to<K>,\n    typename _Allocator_type = std::allocator<K>\n>,\n    typename key_equality = std::equal_to<K>,\n    typename _Allocator_type = std::allocator<K>> class concurrent_unordered_set : public details::_Concurrent_hash<details::_Concurrent_unordered_set_traits<K,\n    details::_Hash_compare<K,\n _Hasher,\n    key_equality>,\n _Allocator_type,\n    false>>;\n```   \n  \n#### Parameters  \n `K`  \n The key type.  \n  \n `_Hasher`  \n The hash function object type. This argument is optional and the default value is `std::tr1::hash<``K``>`.  \n  \n `key_equality`  \n The equality comparison function object type. This argument is optional and the default value is `std::equal_to<``K``>`.  \n  \n `_Allocator_type`  \n The type that represents the stored allocator object that encapsulates details about the allocation and deallocation of memory for the concurrent unordered set. This argument is optional and the default value is `std::allocator<``K``>`.  \n  \n## Members  \n  \n### Public Typedefs  \n  \n|Name|Description|  \n|----------|-----------------|  \n|`allocator_type`|The type of an allocator for managing storage.|  \n|`const_iterator`|The type of a constant iterator for the controlled sequence.|  \n|`const_local_iterator`|The type of a constant bucket iterator for the controlled sequence.|  \n|`const_pointer`|The type of a constant pointer to an element.|  \n|`const_reference`|The type of a constant reference to an element.|  \n|`difference_type`|The type of a signed distance between two elements.|  \n|`hasher`|The type of the hash function.|  \n|`iterator`|The type of an iterator for the controlled sequence.|  \n|`key_equal`|The type of the comparison function.|  \n|`key_type`|The type of an ordering key.|  \n|`local_iterator`|The type of a bucket iterator for the controlled sequence.|  \n|`pointer`|The type of a pointer to an element.|  \n|`reference`|The type of a reference to an element.|  \n|`size_type`|The type of an unsigned distance between two elements.|  \n|`value_type`|The type of an element.|  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[concurrent_unordered_set::concurrent_unordered_set Constructor](#ctor)|Overloaded. Constructs a concurrent unordered set.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[concurrent_unordered_set::hash_function Method](#hash_function)|Returns the stored hash function object.|  \n|[concurrent_unordered_set::insert Method](#insert)|Overloaded. Adds elements to the `concurrent_unordered_set` object.|  \n|[concurrent_unordered_set::key_eq Method](#key_eq)|Returns the stored equality comparison function object.|  \n|[concurrent_unordered_set::swap Method](#swap)|Swaps the contents of two `concurrent_unordered_set` objects. This method is not concurrency-safe.|  \n|[concurrent_unordered_set::unsafe_erase Method](#unsafe_erase)|Overloaded. Removes elements from the `concurrent_unordered_set` at specified positions. This method is not concurrency-safe.|  \n  \n### Public Operators  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[concurrent_unordered_set::operator= Operator](#operator_eq)|Overloaded. Assigns the contents of another `concurrent_unordered_set` object to this one. This method is not concurrency-safe.|  \n  \n## Remarks  \n For detailed information on the `concurrent_unordered_set` class, see [Parallel Containers and Objects](../../../parallel/concrt/parallel-containers-and-objects.md).  \n  \n## Inheritance Hierarchy  \n `_Traits`  \n  \n `_Concurrent_hash`  \n  \n `concurrent_unordered_set`  \n  \n## Requirements  \n **Header:** concurrent_unordered_set.h  \n  \n **Namespace:** concurrency  \n  \n##  <a name=\"begin\"></a>  concurrent_unordered_set::begin Method  \n Returns an iterator pointing to the first element in the concurrent container. This method is concurrency safe.  \n  \n```\niterator begin();\n\nconst_iterator begin() const;\n```  \n  \n### Return Value  \n An iterator to the first element in the concurrent container.  \n  \n##  <a name=\"cbegin\"></a>  concurrent_unordered_set::cbegin Method  \n Returns a const iterator pointing to the first element in the concurrent container. This method is concurrency safe.  \n  \n```\nconst_iterator cbegin() const;\n```  \n  \n### Return Value  \n A const iterator to the first element in the concurrent container.  \n  \n##  <a name=\"cend\"></a>  concurrent_unordered_set::cend Method  \n Returns a const iterator pointing to the location succeeding the last element in the concurrent container. This method is concurrency safe.  \n  \n```\nconst_iterator cend() const;\n```  \n  \n### Return Value  \n A const iterator to the location succeeding the last element in the concurrent container.  \n  \n##  <a name=\"clear\"></a>  concurrent_unordered_set::clear Method  \n Erases all the elements in the concurrent container. This function is not concurrency safe.  \n  \n```\nvoid clear();\n```  \n  \n##  <a name=\"ctor\"></a>  concurrent_unordered_set::concurrent_unordered_set Constructor  \n Constructs a concurrent unordered set.  \n  \n```\nexplicit concurrent_unordered_set(\n    size_type _Number_of_buckets = 8,\n    const hasher& _Hasher = hasher(),\n    const key_equal& key_equality = key_equal(),\n    const allocator_type& _Allocator = allocator_type());\n\nconcurrent_unordered_set(\n    const allocator_type& _Allocator);\n\ntemplate <typename _Iterator>\nconcurrent_unordered_set(_Iterator first,\n    _Iterator last,\n    size_type _Number_of_buckets = 8,\n    const hasher& _Hasher = hasher(),\n    const key_equal& key_equality = key_equal(),\n    const allocator_type& _Allocator = allocator_type());\n\nconcurrent_unordered_set(\n    const concurrent_unordered_set& _Uset);\n\nconcurrent_unordered_set(\n    const concurrent_unordered_set& _Uset,\n    const allocator_type& _Allocator);\n\nconcurrent_unordered_set(\n    concurrent_unordered_set&& _Uset);\n```  \n  \n### Parameters  \n `_Iterator`  \n The type of the input iterator.  \n  \n `_Number_of_buckets`  \n The initial number of buckets for this unordered set.  \n  \n `_Hasher`  \n The hash function for this unordered set.  \n  \n `key_equality`  \n The equality comparison function for this unordered set.  \n  \n `_Allocator`  \n The allocator for this unordered set.  \n  \n `first`  \n `last`  \n `_Uset`  \n The source `concurrent_unordered_set` object to copy or move elements from.  \n  \n### Remarks  \n All constructors store an allocator object `_Allocator` and initialize the unordered set.  \n  \n The first constructor specifies an empty initial set and explicitly specifies the number of buckets, hash function, equality function and allocator type to be used.  \n  \n The second constructor specifies an allocator for the unordered set.  \n  \n The third constructor specifies values supplied by the iterator range [ `_Begin`, `_End`).  \n  \n The fourth and fifth constructors specify a copy of the concurrent unordered set `_Uset`.  \n  \n The last constructor specifies a move of the concurrent unordered set `_Uset`.  \n  \n##  <a name=\"count\"></a>  concurrent_unordered_set::count Method  \n Counts the number of elements matching a specified key. This function is concurrency safe.  \n  \n```\nsize_type count(const key_type& KVal) const;\n```  \n  \n### Parameters  \n `KVal`  \n The key to search for.  \n  \n### Return Value  \n The number of times number of times the key appears in the container.  \n  \n##  <a name=\"empty\"></a>  concurrent_unordered_set::empty Method  \n Tests whether no elements are present. This method is concurrency safe.  \n  \n```\nbool empty() const;\n```  \n  \n### Return Value  \n `true` if the concurrent container is empty, `false` otherwise.  \n  \n### Remarks  \n In the presence of concurrent inserts, whether or not the concurrent container is empty may change immediately after calling this function, before the return value is even read.  \n  \n##  <a name=\"end\"></a>  concurrent_unordered_set::end Method  \n Returns an iterator pointing to the location succeeding the last element in the concurrent container. This method is concurrency safe.  \n  \n```\niterator end();\n\nconst_iterator end() const;\n```  \n  \n### Return Value  \n An iterator to the location succeeding the last element in the concurrent container.  \n  \n##  <a name=\"equal_range\"></a>  concurrent_unordered_set::equal_range Method  \n Finds a range that matches a specified key. This function is concurrency safe.  \n  \n```\nstd::pair<iterator,\n    iterator> equal_range(\n    const key_type& KVal);\n\nstd::pair<const_iterator,\n    const_iterator> equal_range(\n    const key_type& KVal) const;\n```  \n  \n### Parameters  \n `KVal`  \n The key value to search for.  \n  \n### Return Value  \n A [pair](http://msdn.microsoft.com/en-us/32e72d66-3020-4cb9-92c3-f7a5fa7998ff) where the first element is an iterator to the beginning and the second element is an iterator to the end of the range.  \n  \n### Remarks  \n It is possible for concurrent inserts to cause additional keys to be inserted after the begin iterator and before the end iterator.  \n  \n##  <a name=\"find\"></a>  concurrent_unordered_set::find Method  \n Finds an element that matches a specified key. This function is concurrency safe.  \n  \n```\niterator find(const key_type& KVal);\n\nconst_iterator find(const key_type& KVal) const;\n```  \n  \n### Parameters  \n `KVal`  \n The key value to search for.  \n  \n### Return Value  \n An iterator pointing to the location of the the first element that matched the key provided, or the iterator `end()` if no such element exists.  \n  \n##  <a name=\"get_allocator\"></a>  concurrent_unordered_set::get_allocator Method  \n Returns the stored allocator object for this concurrent container. This method is concurrency safe.  \n  \n```\nallocator_type get_allocator() const;\n```  \n  \n### Return Value  \n The stored allocator object for this concurrent container.  \n  \n##  <a name=\"hash_function\"></a>  concurrent_unordered_set::hash_function Method  \n Returns the stored hash function object.  \n  \n```\nhasher hash_function() const;\n```  \n  \n### Return Value  \n The stored hash function object.  \n  \n##  <a name=\"insert\"></a>  concurrent_unordered_set::insert Method  \n Adds elements to the `concurrent_unordered_set` object.  \n  \n```\nstd::pair<iterator,\n    bool> insert(\n    const value_type& value);\n\niterator insert(\n    const_iterator _Where,\n    const value_type& value);\n\ntemplate<class _Iterator>\nvoid insert(_Iterator first,\n    _Iterator last);\n\ntemplate<class V>\nstd::pair<iterator,\n    bool> insert(\n    V&& value);\n\ntemplate<class V>\ntypename std::tr1::enable_if<!std::tr1::is_same<const_iterator,\n    typename std::tr1::remove_reference<V>::type>::value,\n    iterator>::type insert(\n    const_iterator _Where,\n    V&& value);\n```  \n  \n### Parameters  \n `_Iterator`  \n The iterator type used for insertion.  \n  \n `V`  \n The type of the value inserted into the set.  \n  \n `value`  \n The value to be inserted.  \n  \n `_Where`  \n The starting location to search for an insertion point.  \n  \n `first`  \n The beginning of the range to insert.  \n  \n `last`  \n The end of the range to insert.  \n  \n### Return Value  \n A pair that contains an iterator and a boolean value. See the Remarks section for more details.  \n  \n### Remarks  \n The first member function determines whether an element X exists in the sequence whose key has equivalent ordering to that of `value`. If not, it creates such an element X and initializes it with `value`. The function then determines the iterator `where` that designates X. If an insertion occurred, the function returns `std::pair(where, true)`. Otherwise, it returns `std::pair(where, false)`.  \n  \n The second member function returns insert( `value`), using `_Where` as a starting place within the controlled sequence to search for the insertion point.  \n  \n The third member function inserts the sequence of element values from the range [ `first`, `last`).  \n  \n The last two member functions behave the same as the first two, except that `value` is used to construct the inserted value.  \n  \n##  <a name=\"key_eq\"></a>  concurrent_unordered_set::key_eq Method  \n Returns the stored equality comparison function object.  \n  \n```\nkey_equal key_eq() const;\n```  \n  \n### Return Value  \n The stored equality comparison function object.  \n  \n##  <a name=\"load_factor\"></a>  concurrent_unordered_set::load_factor Method  \n Computes and returns the current load factor of the container. The load factor is the number of elements in the container divided by the number of buckets.  \n  \n```\nfloat load_factor() const;\n```  \n  \n### Return Value  \n The load factor for the container.  \n  \n##  <a name=\"max_load_factor\"></a>  concurrent_unordered_set::max_load_factor Method  \n Gets or sets the maximum load factor of the container. The maximum load factor is the largest number of elements than can be in any bucket before the container grows its internal table.  \n  \n```\nfloat max_load_factor() const;\n\nvoid max_load_factor(float _Newmax);\n```  \n  \n### Parameters  \n `_Newmax`  \n  \n### Return Value  \n The first member function returns the stored maximum load factor. The second member function does not return a value but throws an [out_of_range](../../../standard-library/out-of-range-class.md) exception if the supplied load factor is invalid..  \n  \n##  <a name=\"max_size\"></a>  concurrent_unordered_set::max_size Method  \n Returns the maximum size of the concurrent container, determined by the allocator. This method is concurrency safe.  \n  \n```\nsize_type max_size() const;\n```  \n  \n### Return Value  \n The maximum number of elements that can be inserted into this concurrent container.  \n  \n### Remarks  \n This upper bound value may actually be higher than what the container can actually hold.  \n  \n##  <a name=\"operator_eq\"></a>  concurrent_unordered_set::operator= Operator  \n Assigns the contents of another `concurrent_unordered_set` object to this one. This method is not concurrency-safe.  \n  \n```\nconcurrent_unordered_set& operator= (const concurrent_unordered_set& _Uset);\n\nconcurrent_unordered_set& operator= (concurrent_unordered_set&& _Uset);\n```  \n  \n### Parameters  \n `_Uset`  \n The source `concurrent_unordered_set` object.  \n  \n### Return Value  \n A reference to this `concurrent_unordered_set` object.  \n  \n### Remarks  \n After erasing any existing elements in a concurrent unordered set, `operator=` either copies or moves the contents of `_Uset` into the concurrent unordered set.  \n  \n##  <a name=\"rehash\"></a>  concurrent_unordered_set::rehash Method  \n Rebuilds the hash table.  \n  \n```\nvoid rehash(size_type _Buckets);\n```  \n  \n### Parameters  \n `_Buckets`  \n The desired number of buckets.  \n  \n### Remarks  \n The member function alters the number of buckets to be at least `_Buckets` and rebuilds the hash table as needed. The number of buckets must be a power of 2. If not a power of 2, it will be rounded up to the next largest power of 2.  \n  \n It throws an [out_of_range](../../../standard-library/out-of-range-class.md) exception if the number of buckets is invalid (either 0 or greater than the maximum number of buckets).  \n  \n##  <a name=\"size\"></a>  concurrent_unordered_set::size Method  \n Returns the number of elements in this concurrent container. This method is concurrency safe.  \n  \n```\nsize_type size() const;\n```  \n  \n### Return Value  \n The number of items in the container.  \n  \n### Remarks  \n In the presence of concurrent inserts, the number of elements in the concurrent container may change immediately after calling this function, before the return value is even read.  \n  \n##  <a name=\"swap\"></a>  concurrent_unordered_set::swap Method  \n Swaps the contents of two `concurrent_unordered_set` objects. This method is not concurrency-safe.  \n  \n```\nvoid swap(concurrent_unordered_set& _Uset);\n```  \n  \n### Parameters  \n `_Uset`  \n The `concurrent_unordered_set` object to swap with.  \n  \n##  <a name=\"unsafe_begin\"></a>  concurrent_unordered_set::unsafe_begin Method  \n Returns an iterator to the first element in this container for a specific bucket.  \n  \n```\nlocal_iterator unsafe_begin(size_type _Bucket);\n\nconst_local_iterator unsafe_begin(size_type _Bucket) const;\n```  \n  \n### Parameters  \n `_Bucket`  \n The bucket index.  \n  \n### Return Value  \n An iterator pointing to the beginning of the bucket.  \n  \n##  <a name=\"unsafe_bucket\"></a>  concurrent_unordered_set::unsafe_bucket Method  \n Returns the bucket index that a specific key maps to in this container.  \n  \n```\nsize_type unsafe_bucket(const key_type& KVal) const;\n```  \n  \n### Parameters  \n `KVal`  \n The element key being searched for.  \n  \n### Return Value  \n The bucket index for the key in this container.  \n  \n##  <a name=\"unsafe_bucket_count\"></a>  concurrent_unordered_set::unsafe_bucket_count Method  \n Returns the current number of buckets in this container.  \n  \n```\nsize_type unsafe_bucket_count() const;\n```  \n  \n### Return Value  \n The current number of buckets in this container.  \n  \n##  <a name=\"unsafe_bucket_size\"></a>  concurrent_unordered_set::unsafe_bucket_size Method  \n Returns the number of items in a specific bucket of this container.  \n  \n```\nsize_type unsafe_bucket_size(size_type _Bucket);\n```  \n  \n### Parameters  \n `_Bucket`  \n The bucket to search for.  \n  \n### Return Value  \n The current number of buckets in this container.  \n  \n##  <a name=\"unsafe_cbegin\"></a>  concurrent_unordered_set::unsafe_cbegin Method  \n Returns an iterator to the first element in this container for a specific bucket.  \n  \n```\nconst_local_iterator unsafe_cbegin(size_type _Bucket) const;\n```  \n  \n### Parameters  \n `_Bucket`  \n The bucket index.  \n  \n### Return Value  \n An iterator pointing to the beginning of the bucket.  \n  \n##  <a name=\"unsafe_cend\"></a>  concurrent_unordered_set::unsafe_cend Method  \n Returns an iterator to the location succeeding the last element in a specific bucket.  \n  \n```\nconst_local_iterator unsafe_cend(size_type _Bucket) const;\n```  \n  \n### Parameters  \n `_Bucket`  \n The bucket index.  \n  \n### Return Value  \n An iterator pointing to the beginning of the bucket.  \n  \n##  <a name=\"unsafe_end\"></a>  concurrent_unordered_set::unsafe_end Method  \n Returns an iterator to the last element in this container for a specific bucket.  \n  \n```\nlocal_iterator unsafe_end(size_type _Bucket);\n\nconst_local_iterator unsafe_end(size_type _Bucket) const;\n```  \n  \n### Parameters  \n `_Bucket`  \n The bucket index.  \n  \n### Return Value  \n An iterator pointing to the end of the bucket.  \n  \n##  <a name=\"unsafe_erase\"></a>  concurrent_unordered_set::unsafe_erase Method  \n Removes elements from the `concurrent_unordered_set` at specified positions. This method is not concurrency-safe.  \n  \n```\niterator unsafe_erase(\n    const_iterator _Where);\n\nsize_type unsafe_erase(\n    const key_type& KVal);\n\niterator unsafe_erase(\n    const_iterator first,\n    const_iterator last);\n```  \n  \n### Parameters  \n `_Where`  \n The iterator position to erase from.  \n  \n `KVal`  \n The key value to erase.  \n  \n `first`  \n `last`  \n  \n### Return Value  \n The first two member functions return an iterator that designates the first element remaining beyond any elements removed, or [concurrent_unordered_set::end Method](#end)() if no such element exists. The third member function returns the number of elements it removes.  \n  \n### Remarks  \n The first member function removes the element pointed to by `_Where`. The second member function removes the elements in the range [ `_Begin`, `_End`).  \n  \n The third member function removes the elements in the range delimited by [concurrent_unordered_set::equal_range Method](#equal_range)(KVal).  \n  \n##  <a name=\"unsafe_max_bucket_count\"></a>  concurrent_unordered_set::unsafe_max_bucket_count Method  \n Returns the maximum number of buckets in this container.  \n  \n```\nsize_type unsafe_max_bucket_count() const;\n```  \n  \n### Return Value  \n The maximum number of buckets in this container.  \n  \n## See Also  \n [concurrency Namespace](concurrency-namespace.md)   \n [Parallel Containers and Objects](../../../parallel/concrt/parallel-containers-and-objects.md)\n\n\n\n"}