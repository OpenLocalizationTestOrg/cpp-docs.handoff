{"nodes":[{"pos":[12,63],"content":"recursive_directory_iterator Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"recursive_directory_iterator Class | Microsoft Docs","pos":[0,51]}]},{"content":"recursive_directory_iterator Class","pos":[619,653]},{"content":"describes an input iterator that sequences through the filenames in a directory, possibly descending into subdirectories recursively.","pos":[654,787]},{"content":"For an iterator X, the expression *X evaluates to an object of class directory_entry that wraps the filename and anything known about its status.","pos":[788,933]},{"pos":[940,1062],"content":"For more information and code examples, see <bpt id=\"p1\">[</bpt>File System Navigation (C++)<ept id=\"p1\">](../standard-library/file-system-navigation.md)</ept>.","source":"For more information and code examples, see [File System Navigation (C++)](../standard-library/file-system-navigation.md)."},{"content":"Syntax","pos":[1071,1077]},{"content":"Remarks","pos":[1139,1146]},{"content":"The template class stores:","pos":[1150,1176]},{"content":"an object of type stack&lt;pair<ph id=\"ph1\">\\&lt;</ph>directory_iterator, path&gt;&gt;, called mystack here for the purposes of exposition, which represents the nest of directories to be sequenced","pos":[1186,1352],"source":"an object of type stack<pair\\<directory_iterator, path>>, called mystack here for the purposes of exposition, which represents the nest of directories to be sequenced"},{"content":"an object of type directory_entry called myentry here, which represents the current filename in the directory sequence","pos":[1362,1480]},{"content":"an object of type bool, called no_push here, which records whether recursive descent into subdirectories is disabled","pos":[1490,1606]},{"content":"an object of type directory_options, called myoptions here, which records the options established at construction","pos":[1616,1729]},{"content":"A default constructed object of type recursive_directory_entry has an end-of-sequence iterator at mystack.top().first and represents the end-of-sequence iterator.For example, given the directory abc with entries def (a directory), def/ghi, and jkl, the code:","pos":[1736,1994]},{"pos":[2122,2266],"content":"will call visit with the arguments <ph id=\"ph1\">`path(\"abc/def/ghi\") and path(\"abc/jkl\").`</ph>You can qualify sequencing through a directory subtree in two ways:","source":"will call visit with the arguments `path(\"abc/def/ghi\") and path(\"abc/jkl\").`You can qualify sequencing through a directory subtree in two ways:"},{"content":"A directory symlink will be scanned only if you construct a recursive_directory_iterator with a directory_options argument whose value is directory_options::follow_directory_symlink.","pos":[2276,2458]},{"content":"If you call disable_recursion_pending then a subsequent directory encountered during an increment will not be recursively scanned.","pos":[2468,2598]},{"content":"recursive_directory_iterator::depth","pos":[2607,2642]},{"content":"Returns mystack.size() - 1, so pval is at depth zero.","pos":[2683,2736]},{"content":"recursive_directory_iterator::disable_recursion_pending","pos":[2745,2800]},{"content":"The member function stores true in no_push.","pos":[2856,2899]},{"content":"recursive_directory_iterator::operator!=","pos":[2908,2948]},{"content":"The member operator returns !(*this == right).","pos":[3036,3082]},{"content":"recursive_directory_iterator::operator=","pos":[3091,3130]},{"content":"The defaulted member assignment operators behave as expected.","pos":[3336,3397]},{"content":"recursive_directory_iterator::operator==","pos":[3406,3446]},{"content":"The member operator returns true only if both *this and right are end-of-sequence iterators or both are not end-of-sequence-iterators.","pos":[3534,3668]},{"content":"recursive_directory_iterator::operator*","pos":[3677,3716]},{"content":"The member operator returns myentry.","pos":[3780,3816]},{"content":"recursive_directory_iterator::operator-&gt;","pos":[3825,3865],"source":"recursive_directory_iterator::operator->"},{"content":"Returns &amp;**this.","pos":[3931,3947],"source":"Returns &**this."},{"content":"recursive_directory_iterator::operator++","pos":[3956,3996]},{"content":"The first member function calls increment(), then returns *this.","pos":[4110,4174]},{"content":"The second member function makes a copy of the object, calls increment(), then returns the copy.","pos":[4175,4271]},{"content":"recursive_directory_iterator::options","pos":[4280,4317]},{"content":"Returns myoptions.","pos":[4374,4392]},{"content":"recursive_directory_iterator::pop","pos":[4401,4434]},{"content":"If depth() == 0 the object becomes an end-of-sequence iterator.","pos":[4468,4531]},{"content":"Otherwise, the member function terminates scanning of the current (deepest) directory and resumes at the next lower depth.","pos":[4532,4654]},{"content":"recursive_directory_iterator::recursion_pending","pos":[4663,4710]},{"content":"Returns !no_push.","pos":[4764,4781]},{"content":"recursive_directory_iterator::recursive_directory_iterator","pos":[4790,4848]},{"content":"The first constructor produces an end-of-sequence iterator.","pos":[5404,5463]},{"content":"The second and third constructors store false in no_push and directory_options::none in myoptions, then attempt to open and read pval as a directory.","pos":[5464,5613]},{"content":"If successful, they initialize mystack and myentry to designate the first non-directory filename in the nested sequence; otherwise they produce an end-of-sequence iterator.","pos":[5614,5786]},{"content":"The fourth and fifth constructors behave the same as the second and third, except that they first store opts in myoptions.","pos":[5793,5915]},{"content":"The defaulted construtors behave as expected.","pos":[5916,5961]},{"content":"recursive_directory_iterator::increment","pos":[5970,6009]},{"content":"The function attempts to advance to the next filename in the nested sequence.","pos":[6099,6176]},{"content":"If successful, it stores that filename in myentry; otherwise it produces an end-of-sequence iterator.","pos":[6177,6278]},{"content":"Requirements","pos":[6287,6299]},{"pos":[6303,6325],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> filesystem","source":"**Header:** filesystem"},{"pos":[6332,6360],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std::tr2::sys","source":"**Namespace:** std::tr2::sys"},{"content":"See Also","pos":[6369,6377]},{"content":"Header Files Reference","pos":[6382,6404]},{"content":"filesystem&gt;","pos":[6471,6482],"source":"filesystem>"},{"content":"File System Navigation (C++)","pos":[6524,6552]}],"content":"---\ntitle: \"recursive_directory_iterator Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"filesystem/std::tr2::sys::recursive_directory_iterator\"\ndev_langs: \n  - \"C++\"\nms.assetid: 79a061bd-5b64-404c-97e8-749c888c2ced\ncaps.latest.revision: 15\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# recursive_directory_iterator Class\ndescribes an input iterator that sequences through the filenames in a directory, possibly descending into subdirectories recursively. For an iterator X, the expression *X evaluates to an object of class directory_entry that wraps the filename and anything known about its status.  \n  \n For more information and code examples, see [File System Navigation (C++)](../standard-library/file-system-navigation.md).  \n  \n## Syntax  \n  \n```  \nclass recursive_directory_iterator;  \n```  \n  \n## Remarks  \n The template class stores:  \n  \n1.  an object of type stack<pair\\<directory_iterator, path>>, called mystack here for the purposes of exposition, which represents the nest of directories to be sequenced  \n  \n2.  an object of type directory_entry called myentry here, which represents the current filename in the directory sequence  \n  \n3.  an object of type bool, called no_push here, which records whether recursive descent into subdirectories is disabled  \n  \n4.  an object of type directory_options, called myoptions here, which records the options established at construction  \n  \n A default constructed object of type recursive_directory_entry has an end-of-sequence iterator at mystack.top().first and represents the end-of-sequence iterator.For example, given the directory abc with entries def (a directory), def/ghi, and jkl, the code:  \n  \n```  \nfor (recursive_directory_iterator next(path(\"abc\")), end; next != end; ++next)  \n    visit(next->path());\n```  \n  \n will call visit with the arguments `path(\"abc/def/ghi\") and path(\"abc/jkl\").`You can qualify sequencing through a directory subtree in two ways:  \n  \n1.  A directory symlink will be scanned only if you construct a recursive_directory_iterator with a directory_options argument whose value is directory_options::follow_directory_symlink.  \n  \n2.  If you call disable_recursion_pending then a subsequent directory encountered during an increment will not be recursively scanned.  \n  \n## recursive_directory_iterator::depth  \n  \n```  \nint depth() const;\n```  \n  \n Returns mystack.size() - 1, so pval is at depth zero.  \n  \n## recursive_directory_iterator::disable_recursion_pending  \n  \n```  \nvoid disable_recursion_pending();\n```  \n  \n The member function stores true in no_push.  \n  \n## recursive_directory_iterator::operator!=  \n  \n```  \nbool operator!=(const recursive_directory_iterator& right) const;\n```  \n  \n The member operator returns !(*this == right).  \n  \n## recursive_directory_iterator::operator=  \n  \n```  \nrecursive_directory_iterator& operator=(const recursive_directory_iterator&) = default;  \nrecursive_directory_iterator& operator=(recursive_directory_iterator&&) noexcept = default;  \n```  \n  \n The defaulted member assignment operators behave as expected.  \n  \n## recursive_directory_iterator::operator==  \n  \n```  \nbool operator==(const recursive_directory_iterator& right) const;\n```  \n  \n The member operator returns true only if both *this and right are end-of-sequence iterators or both are not end-of-sequence-iterators.  \n  \n## recursive_directory_iterator::operator*  \n  \n```  \nconst directory_entry& operator*() const;\n```  \n  \n The member operator returns myentry.  \n  \n## recursive_directory_iterator::operator->  \n  \n```  \nconst directory_entry * operator->() const;\n```  \n  \n Returns &**this.  \n  \n## recursive_directory_iterator::operator++  \n  \n```  \nrecursive_directory_iterator& operator++();\n\nrecursive_directory_iterator& operator++(int);\n```  \n  \n The first member function calls increment(), then returns *this. The second member function makes a copy of the object, calls increment(), then returns the copy.  \n  \n## recursive_directory_iterator::options  \n  \n```  \ndirectory_options options() const;\n```  \n  \n Returns myoptions.  \n  \n## recursive_directory_iterator::pop  \n  \n```  \nvoid pop();\n```  \n  \n If depth() == 0 the object becomes an end-of-sequence iterator. Otherwise, the member function terminates scanning of the current (deepest) directory and resumes at the next lower depth.  \n  \n## recursive_directory_iterator::recursion_pending  \n  \n```  \nbool recursion_pending() const;\n```  \n  \n Returns !no_push.  \n  \n## recursive_directory_iterator::recursive_directory_iterator  \n  \n```  \nrecursive_directory_iterator() noexcept;  \nexplicit recursive_directory_iterator(const path& pval);\n\nrecursive_directory_iterator(const path& pval,  \n    error_code& ec) noexcept;  \nrecursive_directory_iterator(const path& pval,  \n    directory_options opts);\n\nrecursive_directory_iterator(const path& pval,  \n    directory_options opts,  \n    error_code& ec) noexcept;  \nrecursive_directory_iterator(const recursive_directory_iterator&) = default;  \nrecursive_directory_iterator(recursive_directory_iterator&&) noexcept = default;  \n```  \n  \n The first constructor produces an end-of-sequence iterator. The second and third constructors store false in no_push and directory_options::none in myoptions, then attempt to open and read pval as a directory. If successful, they initialize mystack and myentry to designate the first non-directory filename in the nested sequence; otherwise they produce an end-of-sequence iterator.  \n  \n The fourth and fifth constructors behave the same as the second and third, except that they first store opts in myoptions. The defaulted construtors behave as expected.  \n  \n## recursive_directory_iterator::increment  \n  \n```  \nrecursive_directory_iterator& increment(error_code& ec) noexcept;  \n```  \n  \n The function attempts to advance to the next filename in the nested sequence. If successful, it stores that filename in myentry; otherwise it produces an end-of-sequence iterator.  \n  \n## Requirements  \n **Header:** filesystem  \n  \n **Namespace:** std::tr2::sys  \n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)   \n [\\<filesystem>](../standard-library/filesystem.md)   \n [File System Navigation (C++)](../standard-library/file-system-navigation.md)\n\n"}