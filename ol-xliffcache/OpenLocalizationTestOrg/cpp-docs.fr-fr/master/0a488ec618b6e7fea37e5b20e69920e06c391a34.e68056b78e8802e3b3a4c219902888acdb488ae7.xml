{"nodes":[{"pos":[12,89],"content":"How to: Marshal Callbacks and Delegates By Using C++ Interop | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Marshal Callbacks and Delegates By Using C++ Interop | Microsoft Docs","pos":[0,77]}]},{"content":"How to: Marshal Callbacks and Delegates By Using C++ Interop","pos":[861,921]},{"content":"This topic demonstrates the marshalling of callbacks and delegates (the managed version of a callback) between managed and unmanaged code using Visual C++.","pos":[922,1077]},{"content":"The following code examples use the <bpt id=\"p1\">[</bpt>managed, unmanaged<ept id=\"p1\">](../preprocessor/managed-unmanaged.md)</ept> #pragma directives to implement managed and unmanaged functions in the same file, but the functions could also be defined in separate files.","pos":[1084,1319],"source":"The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but the functions could also be defined in separate files."},{"content":"Files containing only unmanaged functions do not need to be compiled with the <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>.","pos":[1320,1506],"source":" Files containing only unmanaged functions do not need to be compiled with the [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md)."},{"content":"Example","pos":[1515,1522]},{"content":"The following example demonstrates how to configure an unmanaged API to trigger a managed delegate.","pos":[1526,1625]},{"content":"A managed delegate is created and one of the interop methods, &lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A&gt;, is used to retrieve the underlying entry point for the delegate.","pos":[1626,1832],"source":" A managed delegate is created and one of the interop methods, <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A>, is used to retrieve the underlying entry point for the delegate."},{"content":"This address is then passed to the unmanaged function, which calls it with no knowledge of the fact that it is implemented as a managed function.","pos":[1833,1978]},{"content":"Notice that is it possible, but not necessary, to pin the delegate using <bpt id=\"p1\">[</bpt>pin_ptr (C++/CLI)<ept id=\"p1\">](../windows/pin-ptr-cpp-cli.md)</ept> to prevent it from being re-located or disposed of by the garbage collector.","pos":[1985,2185],"source":"Notice that is it possible, but not necessary, to pin the delegate using [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md) to prevent it from being re-located or disposed of by the garbage collector."},{"content":"Protection from premature garbage collection is needed, but pinning provides more protection than is necessary, as it prevents collection but also prevents relocation.","pos":[2186,2353]},{"content":"If a delegate is re-located by a garbage collection, it will not affect the underlaying managed callback, so &lt;xref:System.Runtime.InteropServices.GCHandle.Alloc%2A&gt; is used to add a reference to the delegate, allowing relocation of the delegate, but preventing disposal.","pos":[2360,2630],"source":"If a delegate is re-located by a garbage collection, it will not affect the underlaying managed callback, so <xref:System.Runtime.InteropServices.GCHandle.Alloc%2A> is used to add a reference to the delegate, allowing relocation of the delegate, but preventing disposal."},{"content":"Using GCHandle instead of pin_ptr reduces fragmentation potential of the managed heap.","pos":[2631,2717]},{"content":"Example","pos":[3973,3980]},{"content":"The following example is similar to the previous example, but in this case the provided function pointer is stored by the unmanaged API, so it can be invoked at any time, requiring that garbage collection be suppressed for an arbitrary length of time.","pos":[3984,4235]},{"content":"As a result, the following example uses a global instance of &lt;xref:System.Runtime.InteropServices.GCHandle&gt; to prevent the delegate from being relocated, independent of function scope.","pos":[4236,4420],"source":" As a result, the following example uses a global instance of <xref:System.Runtime.InteropServices.GCHandle> to prevent the delegate from being relocated, independent of function scope."},{"content":"As discussed in the first example, using pin_ptr is unnecessary for these examples, but in this case wouldn't work anyway, as the scope of a pin_ptr is limited to a single function.","pos":[4421,4602]},{"content":"See Also","pos":[6076,6084]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[6089,6125]}],"content":"---\ntitle: \"How to: Marshal Callbacks and Delegates By Using C++ Interop | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"data marshaling [C++], callbacks and delegates\"\n  - \"C++ Interop, callbacks and delegates\"\n  - \"interop [C++], callbacks and delegates\"\n  - \"delegates [C++], marshaling\"\n  - \"marshaling [C++], callbacks and delegates\"\n  - \"callbacks [C++], marshaling\"\nms.assetid: 2313e9eb-5df9-4367-be0f-14b4712d8d2d\ncaps.latest.revision: 23\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Marshal Callbacks and Delegates By Using C++ Interop\nThis topic demonstrates the marshalling of callbacks and delegates (the managed version of a callback) between managed and unmanaged code using Visual C++.  \n  \n The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but the functions could also be defined in separate files. Files containing only unmanaged functions do not need to be compiled with the [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md).  \n  \n## Example  \n The following example demonstrates how to configure an unmanaged API to trigger a managed delegate. A managed delegate is created and one of the interop methods, <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A>, is used to retrieve the underlying entry point for the delegate. This address is then passed to the unmanaged function, which calls it with no knowledge of the fact that it is implemented as a managed function.  \n  \n Notice that is it possible, but not necessary, to pin the delegate using [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md) to prevent it from being re-located or disposed of by the garbage collector. Protection from premature garbage collection is needed, but pinning provides more protection than is necessary, as it prevents collection but also prevents relocation.  \n  \n If a delegate is re-located by a garbage collection, it will not affect the underlaying managed callback, so <xref:System.Runtime.InteropServices.GCHandle.Alloc%2A> is used to add a reference to the delegate, allowing relocation of the delegate, but preventing disposal. Using GCHandle instead of pin_ptr reduces fragmentation potential of the managed heap.  \n  \n```  \n// MarshalDelegate1.cpp  \n// compile with: /clr  \n#include <iostream>  \n  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n#pragma unmanaged  \n  \n// Declare an unmanaged function type that takes two int arguments  \n// Note the use of __stdcall for compatibility with managed code  \ntypedef int (__stdcall *ANSWERCB)(int, int);  \n  \nint TakesCallback(ANSWERCB fp, int n, int m) {  \n   printf_s(\"[unmanaged] got callback address, calling it...\\n\");  \n   return fp(n, m);  \n}  \n  \n#pragma managed  \n  \npublic delegate int GetTheAnswerDelegate(int, int);  \n  \nint GetNumber(int n, int m) {  \n   Console::WriteLine(\"[managed] callback!\");  \n   return n + m;  \n}  \n  \nint main() {  \n   GetTheAnswerDelegate^ fp = gcnew GetTheAnswerDelegate(GetNumber);  \n   GCHandle gch = GCHandle::Alloc(fp);  \n   IntPtr ip = Marshal::GetFunctionPointerForDelegate(fp);  \n   ANSWERCB cb = static_cast<ANSWERCB>(ip.ToPointer());  \n   Console::WriteLine(\"[managed] sending delegate as callback...\");  \n  \n// force garbage collection cycle to prove  \n// that the delegate doesn't get disposed  \n   GC::Collect();  \n  \n   int answer = TakesCallback(cb, 243, 257);  \n  \n// release reference to delegate  \n   gch.Free();  \n}  \n```  \n  \n## Example  \n The following example is similar to the previous example, but in this case the provided function pointer is stored by the unmanaged API, so it can be invoked at any time, requiring that garbage collection be suppressed for an arbitrary length of time. As a result, the following example uses a global instance of <xref:System.Runtime.InteropServices.GCHandle> to prevent the delegate from being relocated, independent of function scope. As discussed in the first example, using pin_ptr is unnecessary for these examples, but in this case wouldn't work anyway, as the scope of a pin_ptr is limited to a single function.  \n  \n```  \n// MarshalDelegate2.cpp  \n// compile with: /clr   \n#include <iostream>  \n  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n#pragma unmanaged  \n  \n// Declare an unmanaged function type that takes two int arguments  \n// Note the use of __stdcall for compatibility with managed code  \ntypedef int (__stdcall *ANSWERCB)(int, int);  \nstatic ANSWERCB cb;  \n  \nint TakesCallback(ANSWERCB fp, int n, int m) {  \n   cb = fp;  \n   if (cb) {  \n      printf_s(\"[unmanaged] got callback address (%d), calling it...\\n\", cb);  \n      return cb(n, m);  \n   }  \n   printf_s(\"[unmanaged] unregistering callback\");  \n   return 0;  \n}  \n  \n#pragma managed  \n  \npublic delegate int GetTheAnswerDelegate(int, int);  \n  \nint GetNumber(int n, int m) {  \n   Console::WriteLine(\"[managed] callback!\");  \n   static int x = 0;  \n   ++x;  \n  \n   return n + m + x;  \n}  \n  \nstatic GCHandle gch;  \n  \nint main() {  \n   GetTheAnswerDelegate^ fp = gcnew GetTheAnswerDelegate(GetNumber);  \n  \n   gch = GCHandle::Alloc(fp);  \n  \n   IntPtr ip = Marshal::GetFunctionPointerForDelegate(fp);  \n   ANSWERCB cb = static_cast<ANSWERCB>(ip.ToPointer());  \n   Console::WriteLine(\"[managed] sending delegate as callback...\");  \n  \n   int answer = TakesCallback(cb, 243, 257);  \n  \n   // possibly much later (in another function)...  \n  \n   Console::WriteLine(\"[managed] releasing callback mechanisms...\");  \n   TakesCallback(0, 243, 257);  \n   gch.Free();  \n}  \n```  \n  \n## See Also  \n [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)"}