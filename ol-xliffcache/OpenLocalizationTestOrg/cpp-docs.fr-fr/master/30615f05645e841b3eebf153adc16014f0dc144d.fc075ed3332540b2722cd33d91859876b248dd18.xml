{"nodes":[{"pos":[12,43],"content":"function Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"function Class | Microsoft Docs","pos":[0,31]}]},{"pos":[686,700],"content":"function Class","linkify":"function Class","nodes":[{"content":"function Class","pos":[0,14]}]},{"content":"Wrapper for a callable object.","pos":[701,731]},{"pos":[740,746],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[2063,2073],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The function type to wrap.","pos":[2086,2112]},{"content":"The allocator function.","pos":[2127,2150]},{"pos":[2159,2166],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template class is a call wrapper whose call signature is <ph id=\"ph1\">`Ret(T1, T2, ..., TN)`</ph>.","pos":[2170,2254],"source":"The template class is a call wrapper whose call signature is `Ret(T1, T2, ..., TN)`."},{"content":"You use it to enclose a variety of callable objects in a uniform wrapper.","pos":[2255,2328]},{"content":"Some member functions take an operand that names the desired target object.","pos":[2335,2410]},{"content":"You can specify such an operand in several ways:","pos":[2411,2459]},{"pos":[2466,2557],"content":"<ph id=\"ph1\">`fn`</ph> -- the callable object <ph id=\"ph2\">`fn`</ph>; after the call the <ph id=\"ph3\">`function`</ph> object holds a copy of <ph id=\"ph4\">`fn`</ph>","source":"`fn` -- the callable object `fn`; after the call the `function` object holds a copy of `fn`"},{"pos":[2564,2690],"content":"<ph id=\"ph1\">`fnref`</ph> -- the callable object named by <ph id=\"ph2\">`fnref.get()`</ph>; after the call the <ph id=\"ph3\">`function`</ph> object holds a reference to <ph id=\"ph4\">`fnref.get()`</ph>","source":"`fnref` -- the callable object named by `fnref.get()`; after the call the `function` object holds a reference to `fnref.get()`"},{"pos":[2697,2774],"content":"<ph id=\"ph1\">`right`</ph> -- the callable object, if any, held by the <ph id=\"ph2\">`function`</ph> object <ph id=\"ph3\">`right`</ph>","source":"`right` -- the callable object, if any, held by the `function` object `right`"},{"pos":[2781,2851],"content":"<ph id=\"ph1\">`npc`</ph> -- a null pointer; after the call the <ph id=\"ph2\">`function`</ph> object is empty","source":"`npc` -- a null pointer; after the call the `function` object is empty"},{"pos":[2858,3078],"content":"In all cases, <ph id=\"ph1\">`INVOKE(f, t1, t2, ..., tN)`</ph>, where <ph id=\"ph2\">`f`</ph> is the callable object and <ph id=\"ph3\">`t1, t2, ..., tN`</ph> are lvalues of types <ph id=\"ph4\">`T1, T2, ..., TN`</ph> respectively, must be well-formed and, if <ph id=\"ph5\">`Ret`</ph> is not void, convertible to <ph id=\"ph6\">`Ret`</ph>.","source":"In all cases, `INVOKE(f, t1, t2, ..., tN)`, where `f` is the callable object and `t1, t2, ..., tN` are lvalues of types `T1, T2, ..., TN` respectively, must be well-formed and, if `Ret` is not void, convertible to `Ret`."},{"pos":[3085,3180],"content":"An empty <ph id=\"ph1\">`function`</ph> object does not hold a callable object or a reference to a callable object.","source":"An empty `function` object does not hold a callable object or a reference to a callable object."},{"pos":[3190,3202],"content":"Constructors","linkify":"Constructors","nodes":[{"content":"Constructors","pos":[0,12]}]},{"pos":[3223,3264],"content":"<bpt id=\"p1\">[</bpt>function::function<ept id=\"p1\">](#function__function)</ept>","source":"[function::function](#function__function)"},{"content":"Constructs a wrapper that either is empty or stores a callable object of arbitrary type with a fixed signature.","pos":[3265,3376]},{"pos":[3387,3395],"content":"Typedefs","linkify":"Typedefs","nodes":[{"content":"Typedefs","pos":[0,8]}]},{"pos":[3416,3463],"content":"<bpt id=\"p1\">[</bpt>function::result_type<ept id=\"p1\">](#function__result_type)</ept>","source":"[function::result_type](#function__result_type)"},{"content":"The return type of the stored callable object.","pos":[3464,3510]},{"pos":[3521,3537],"content":"Member Functions","linkify":"Member Functions","nodes":[{"content":"Member Functions","pos":[0,16]}]},{"pos":[3558,3595],"content":"<bpt id=\"p1\">[</bpt>function::assign<ept id=\"p1\">](#function__assign)</ept>","source":"[function::assign](#function__assign)"},{"content":"Assigns a callable object to this function object.","pos":[3596,3646]},{"pos":[3651,3684],"content":"<bpt id=\"p1\">[</bpt>function::swap<ept id=\"p1\">](#function__swap)</ept>","source":"[function::swap](#function__swap)"},{"content":"Swap two callable objects.","pos":[3685,3711]},{"pos":[3716,3753],"content":"<bpt id=\"p1\">[</bpt>function::target<ept id=\"p1\">](#function__target)</ept>","source":"[function::target](#function__target)"},{"content":"Tests if stored callable object is callable as specified.","pos":[3754,3811]},{"pos":[3816,3863],"content":"<bpt id=\"p1\">[</bpt>function::target_type<ept id=\"p1\">](#function__target_type)</ept>","source":"[function::target_type](#function__target_type)"},{"content":"Gets type information on the callable object.","pos":[3864,3909]},{"pos":[3920,3929],"content":"Operators","linkify":"Operators","nodes":[{"content":"Operators","pos":[0,9]}]},{"pos":[3950,4015],"content":"<bpt id=\"p1\">[</bpt>function::operator unspecified<ept id=\"p1\">](#function__operator_unspecified)</ept>","source":"[function::operator unspecified](#function__operator_unspecified)"},{"content":"Tests if stored callable object exists.","pos":[4016,4055]},{"pos":[4060,4105],"content":"<bpt id=\"p1\">[</bpt>function::operator()<ept id=\"p1\">](#function__operator__)</ept>","source":"[function::operator()](#function__operator__)"},{"content":"Calls a callable object.","pos":[4106,4130]},{"pos":[4135,4180],"content":"<bpt id=\"p1\">[</bpt>function::operator=<ept id=\"p1\">](#function__operator_eq)</ept>","source":"[function::operator=](#function__operator_eq)"},{"content":"Replaces the stored callable object.","pos":[4181,4217]},{"pos":[4227,4239],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[4243,4268],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>functional&gt;","source":"**Header:** \\<functional>"},{"pos":[4275,4293],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[4303,4352],"content":"<bpt id=\"p1\">&lt;a name=\"function__assign\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  function::assign","linkify":"<a name=\"function__assign\"></a>  function::assign","source":"<a name=\"function__assign\"></a>  function::assign"},{"content":"Assigns a callable object to this function object.","pos":[4356,4406]},{"pos":[4628,4638],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A callable object.","pos":[4653,4671]},{"content":"A reference wrapper that contains a callable object.","pos":[4690,4742]},{"content":"An allocator object.","pos":[4757,4777]},{"pos":[4787,4794],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member functions each replace the <ph id=\"ph1\">`callable object`</ph> held by <ph id=\"ph2\">`*this`</ph> with the callable object passed as the <ph id=\"ph3\">`operand`</ph>.","pos":[4798,4919],"source":"The member functions each replace the `callable object` held by `*this` with the callable object passed as the `operand`."},{"content":"Both allocate storage with the allocator object <ph id=\"ph1\">`Ax`</ph>.","pos":[4920,4973],"source":" Both allocate storage with the allocator object `Ax`."},{"pos":[4983,5036],"content":"<bpt id=\"p1\">&lt;a name=\"function__function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  function::function","linkify":"<a name=\"function__function\"></a>  function::function","source":"<a name=\"function__function\"></a>  function::function"},{"content":"Constructs a wrapper that either is empty or stores a callable object of arbitrary type with a fixed signature.","pos":[5040,5151]},{"pos":[5542,5552],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The function object to copy.","pos":[5568,5596]},{"content":"Fx","pos":[5603,5605]},{"content":"The type of the callable object.","pos":[5609,5641]},{"content":"The callable object to wrap.","pos":[5659,5687]},{"content":"Alloc","pos":[5694,5699]},{"content":"The allocator type.","pos":[5703,5722]},{"content":"The allocator.","pos":[5737,5751]},{"content":"The callable object reference to wrap.","pos":[5770,5808]},{"pos":[5818,5825],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first two constructors construct an empty <ph id=\"ph1\">`function`</ph> object.","pos":[5829,5893],"source":"The first two constructors construct an empty `function` object."},{"content":"The next three constructors construct a <ph id=\"ph1\">`function`</ph> object that holds the callable object passed as the operand.","pos":[5894,6005],"source":" The next three constructors construct a `function` object that holds the callable object passed as the operand."},{"content":"The last two constructors allocate storage with the allocator object Ax.","pos":[6006,6078]},{"pos":[6088,6095],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[7402,7479],"content":"<bpt id=\"p1\">&lt;a name=\"function__operator_unspecified\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  function::operator unspecified","linkify":"<a name=\"function__operator_unspecified\"></a>  function::operator unspecified","source":"<a name=\"function__operator_unspecified\"></a>  function::operator unspecified"},{"content":"Tests if stored callable object exists.","pos":[7483,7522]},{"content":"```  operator unspecified();","pos":[7528,7556]},{"pos":[8340,8397],"content":"<bpt id=\"p1\">&lt;a name=\"function__operator__\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  function::operator()","linkify":"<a name=\"function__operator__\"></a>  function::operator()","source":"<a name=\"function__operator__\"></a>  function::operator()"},{"content":"Calls a callable object.","pos":[8401,8425]},{"pos":[8508,8518],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type of the Nth call argument.","pos":[8530,8564]},{"content":"The Nth call argument.","pos":[8579,8601]},{"pos":[8611,8618],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function returns <ph id=\"ph1\">`INVOKE(fn, t1, t2, ..., tN, Ret)`</ph>, where <ph id=\"ph2\">`fn`</ph> is the target object stored in <ph id=\"ph3\">`*this`</ph>.","pos":[8622,8736],"source":"The member function returns `INVOKE(fn, t1, t2, ..., tN, Ret)`, where `fn` is the target object stored in `*this`."},{"content":"You use it to call the wrapped callable object.","pos":[8737,8784]},{"pos":[8794,8801],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9297,9354],"content":"<bpt id=\"p1\">&lt;a name=\"function__operator_eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  function::operator=","linkify":"<a name=\"function__operator_eq\"></a>  function::operator=","source":"<a name=\"function__operator_eq\"></a>  function::operator="},{"content":"Replaces the stored callable object.","pos":[9358,9394]},{"pos":[9634,9644],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A null pointer constant.","pos":[9657,9681]},{"content":"The function object to copy.","pos":[9699,9727]},{"content":"The callable object to wrap.","pos":[9742,9770]},{"content":"The callable object reference to wrap.","pos":[9788,9826]},{"pos":[9836,9843],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[9847,9957],"content":"The operators each replace the callable object held by <ph id=\"ph1\">`*this`</ph> with the callable object passed as the operand.","source":"The operators each replace the callable object held by `*this` with the callable object passed as the operand."},{"pos":[9967,9974],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[11151,11210],"content":"<bpt id=\"p1\">&lt;a name=\"function__result_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  function::result_type","linkify":"<a name=\"function__result_type\"></a>  function::result_type","source":"<a name=\"function__result_type\"></a>  function::result_type"},{"content":"The return type of the stored callable object.","pos":[11214,11260]},{"pos":[11312,11319],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The typedef is a synonym for the type <ph id=\"ph1\">`Ret`</ph> in the template's call signature.","pos":[11323,11400],"source":"The typedef is a synonym for the type `Ret` in the template's call signature."},{"content":"You use it to determine the return type of the wrapped callable object.","pos":[11401,11472]},{"pos":[11482,11489],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[12042,12087],"content":"<bpt id=\"p1\">&lt;a name=\"function__swap\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  function::swap","linkify":"<a name=\"function__swap\"></a>  function::swap","source":"<a name=\"function__swap\"></a>  function::swap"},{"content":"Swap two callable objects.","pos":[12091,12117]},{"pos":[12170,12180],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The function object to swap with.","pos":[12195,12228]},{"pos":[12238,12245],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function swaps the target objects between <ph id=\"ph1\">`*this`</ph> and <ph id=\"ph2\">`right`</ph>.","pos":[12249,12322],"source":"The member function swaps the target objects between `*this` and `right`."},{"content":"It does so in constant time and throws no exceptions.","pos":[12323,12376]},{"pos":[12386,12393],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[13310,13359],"content":"<bpt id=\"p1\">&lt;a name=\"function__target\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  function::target","linkify":"<a name=\"function__target\"></a>  function::target","source":"<a name=\"function__target\"></a>  function::target"},{"content":"Tests if stored callable object is callable as specified.","pos":[13363,13420]},{"pos":[13538,13548],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The target callable object type to test.","pos":[13562,13602]},{"pos":[13612,13619],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The type <ph id=\"ph1\">`Fty2`</ph> must be callable for the argument types <ph id=\"ph2\">`T1, T2, ..., TN`</ph> and the return type <ph id=\"ph3\">`Ret`</ph>.","pos":[13623,13723],"source":"The type `Fty2` must be callable for the argument types `T1, T2, ..., TN` and the return type `Ret`."},{"content":"If <ph id=\"ph1\">`target_type() == typeid(Fty2)`</ph>, the member template function returns the address of the target object; otherwise, it returns 0.","pos":[13724,13855],"source":" If `target_type() == typeid(Fty2)`, the member template function returns the address of the target object; otherwise, it returns 0."},{"pos":[13862,14136],"content":"A type <ph id=\"ph1\">`Fty2`</ph> is callable for the argument types <ph id=\"ph2\">`T1, T2, ..., TN`</ph> and the return type <ph id=\"ph3\">`Ret`</ph> if, for lvalues <ph id=\"ph4\">`fn, t1, t2, ..., tN`</ph> of types <ph id=\"ph5\">`Fty2, T1, T2, ..., TN`</ph>, respectively, <ph id=\"ph6\">`INVOKE(fn, t1, t2, ..., tN)`</ph> is well-formed and, if <ph id=\"ph7\">`Ret`</ph> is not <ph id=\"ph8\">`void`</ph>, convertible to <ph id=\"ph9\">`Ret`</ph>.","source":"A type `Fty2` is callable for the argument types `T1, T2, ..., TN` and the return type `Ret` if, for lvalues `fn, t1, t2, ..., tN` of types `Fty2, T1, T2, ..., TN`, respectively, `INVOKE(fn, t1, t2, ..., tN)` is well-formed and, if `Ret` is not `void`, convertible to `Ret`."},{"pos":[14146,14153],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[15054,15113],"content":"<bpt id=\"p1\">&lt;a name=\"function__target_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  function::target_type","linkify":"<a name=\"function__target_type\"></a>  function::target_type","source":"<a name=\"function__target_type\"></a>  function::target_type"},{"content":"Gets type information on the callable object.","pos":[15117,15162]},{"pos":[15230,15237],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[15241,15382],"content":"The member function returns <ph id=\"ph1\">`typeid(void)`</ph> if <ph id=\"ph2\">`*this`</ph> is empty, otherwise it returns <ph id=\"ph3\">`typeid(T)`</ph>, where <ph id=\"ph4\">`T`</ph> is the type of the target object.","source":"The member function returns `typeid(void)` if `*this` is empty, otherwise it returns `typeid(T)`, where `T` is the type of the target object."},{"pos":[15392,15399],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[16145,16153],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>mem_fn Function<ept id=\"p1\">](../standard-library/functional-functions.md#mem_fn_function)</ept><ph id=\"ph1\"> </ph>","pos":[16157,16236],"source":"[mem_fn Function](../standard-library/functional-functions.md#mem_fn_function) "},{"content":"<bpt id=\"p1\"> [</bpt>reference_wrapper Class<ept id=\"p1\">](../standard-library/reference-wrapper-class.md)</ept>","pos":[16239,16313],"source":" [reference_wrapper Class](../standard-library/reference-wrapper-class.md)"}],"content":"---\ntitle: \"function Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"functional/std::tr1::function\"\n  - \"std.tr1.function\"\n  - \"std::tr1::function\"\n  - \"function\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"function class [TR1]\"\nms.assetid: 7b5ca76b-9ca3-4d89-8fcf-cad70a4aeae6\ncaps.latest.revision: 26\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# function Class\nWrapper for a callable object.  \n  \n## Syntax  \n  \n```cpp  \ntemplate <class Fty>\nclass function  // Fty of type Ret(T1, T2, ..., TN)  \n    : public unary_function<T1, Ret>       // when Fty is Ret(T1)  \n    : public binary_function<T1, T2, Ret>  // when Fty is Ret(T1, T2)  \n{\npublic:\n    typedef Ret result_type;\n\n    function();\n    function(nullptr_t);\n\n    function(const function& right);\n\n    template <class Fty2>\n    function(Fty2 fn);\n\n    template <class Fty2, class Alloc>\n    function(reference_wrapper<Fty2>, const Alloc& Ax);\n\n    template <class Fty2, class Alloc>\n    void assign(Fty2, const Alloc& Ax);\n\n    template <class Fty2, class Alloc>\n    assign(reference_wrapper<Fty2>, const Alloc& Ax);\n    function& operator=(nullptr_t);\n    function& operator=(const function&);\n    template <class Fty2>\n    function& operator=(Fty2);\n    template <class Fty2>\n    function& operator=(reference_wrapper<Fty2>);\n\n    void swap(function&);\n    explicit operator bool() const;\n\n    result_type operator()(T1, T2, ....., TN) const;\n    const std::type_info& target_type() const;\n    template <class Fty2>\n    Fty2 *target();\n\n    template <class Fty2>\n    const Fty2 *target() const;\n\n    template <class Fty2>\n    void operator==(const Fty2&) const = delete;\n    template <class Fty2>\n    void operator!=(const Fty2&) const = delete;\n};\n```  \n  \n#### Parameters  \n `Fty`  \n The function type to wrap.  \n  \n `Ax`  \n The allocator function.  \n  \n## Remarks  \n The template class is a call wrapper whose call signature is `Ret(T1, T2, ..., TN)`. You use it to enclose a variety of callable objects in a uniform wrapper.  \n  \n Some member functions take an operand that names the desired target object. You can specify such an operand in several ways:  \n  \n `fn` -- the callable object `fn`; after the call the `function` object holds a copy of `fn`  \n  \n `fnref` -- the callable object named by `fnref.get()`; after the call the `function` object holds a reference to `fnref.get()`  \n  \n `right` -- the callable object, if any, held by the `function` object `right`  \n  \n `npc` -- a null pointer; after the call the `function` object is empty  \n  \n In all cases, `INVOKE(f, t1, t2, ..., tN)`, where `f` is the callable object and `t1, t2, ..., tN` are lvalues of types `T1, T2, ..., TN` respectively, must be well-formed and, if `Ret` is not void, convertible to `Ret`.  \n  \n An empty `function` object does not hold a callable object or a reference to a callable object.  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[function::function](#function__function)|Constructs a wrapper that either is empty or stores a callable object of arbitrary type with a fixed signature.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[function::result_type](#function__result_type)|The return type of the stored callable object.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[function::assign](#function__assign)|Assigns a callable object to this function object.|  \n|[function::swap](#function__swap)|Swap two callable objects.|  \n|[function::target](#function__target)|Tests if stored callable object is callable as specified.|  \n|[function::target_type](#function__target_type)|Gets type information on the callable object.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|[function::operator unspecified](#function__operator_unspecified)|Tests if stored callable object exists.|  \n|[function::operator()](#function__operator__)|Calls a callable object.|  \n|[function::operator=](#function__operator_eq)|Replaces the stored callable object.|  \n  \n## Requirements  \n **Header:** \\<functional>  \n  \n **Namespace:** std  \n  \n##  <a name=\"function__assign\"></a>  function::assign  \n Assigns a callable object to this function object.  \n  \n```  \ntemplate <class Fx, class Alloc>  \nvoid assign(\n    Fx _Func,   \n    const Alloc& Ax);\n\ntemplate <class Fx, class Alloc>  \nvoid assign(\n    reference_wrapper<Fx>  \n_Fnref,   \n    const Alloc& Ax);\n```  \n  \n### Parameters  \n `_Func`  \n A callable object.  \n  \n `_Fnref`  \n A reference wrapper that contains a callable object.  \n  \n `Ax`  \n An allocator object.  \n  \n### Remarks  \n The member functions each replace the `callable object` held by `*this` with the callable object passed as the `operand`. Both allocate storage with the allocator object `Ax`.  \n  \n##  <a name=\"function__function\"></a>  function::function  \n Constructs a wrapper that either is empty or stores a callable object of arbitrary type with a fixed signature.  \n  \n```  \nfunction();\n\nfunction(nullptr_t npc);\n\nfunction(const function& right);\n\ntemplate <class Fx>  \nfunction(Fx _Func);\n\ntemplate <class Fx>  \nfunction(reference_wrapper<Fx>  \n_Fnref);\n\ntemplate <class Fx, class Alloc>  \nfunction(\n Fx _Func,   \n    const Alloc& Ax);\n\ntemplate <class Fx, class Alloc>  \nfunction(\n reference_wrapper<Fx>  \n_Fnref,   \n    const Alloc& Ax);\n```  \n  \n### Parameters  \n ` right`  \n The function object to copy.  \n  \n Fx  \n The type of the callable object.  \n  \n `_Func`  \n The callable object to wrap.  \n  \n Alloc  \n The allocator type.  \n  \n `Ax`  \n The allocator.  \n  \n `_Fnref`  \n The callable object reference to wrap.  \n  \n### Remarks  \n The first two constructors construct an empty `function` object. The next three constructors construct a `function` object that holds the callable object passed as the operand. The last two constructors allocate storage with the allocator object Ax.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__function_function.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <iostream>   \n#include <vector>  \n  \nint square(int val)  \n{  \n    return val * val;  \n}  \n  \nclass multiply_by  \n{  \npublic:  \n    explicit multiply_by(const int n) : m_n(n) { }  \n  \n    int operator()(const int x) const  \n    {  \n        return m_n * x;  \n    }  \n  \nprivate:  \n    int m_n;  \n};  \n  \nint main()   \n{   \n  \n    typedef std::vector< std::function<int (int)> > vf_t;  \n  \n    vf_t v;  \n    v.push_back(square);  \n    v.push_back(std::negate<int>());  \n    v.push_back(multiply_by(3));  \n  \n    for (vf_t::const_iterator i = v.begin(); i != v.end(); ++i)  \n    {  \n        std::cout << (*i)(10) << std::endl;  \n    }  \n  \n    std::function<int (int)> f = v[0];  \n    std::function<int (int)> g;  \n  \n    if (f) {  \n        std::cout << \"f is non-empty (correct).\" << std::endl;  \n    } else {  \n        std::cout << \"f is empty (can't happen).\" << std::endl;  \n    }  \n  \n    if (g) {  \n        std::cout << \"g is non-empty (can't happen).\" << std::endl;  \n    } else {  \n        std::cout << \"g is empty (correct).\" << std::endl;  \n    }  \n  \n    return 0;   \n}  \n```  \n  \n```Output  \n100  \n-10  \n30  \nf is non-empty (correct).  \ng is empty (correct).  \n```  \n  \n##  <a name=\"function__operator_unspecified\"></a>  function::operator unspecified  \n Tests if stored callable object exists.  \n  \n```  operator unspecified();\n```   \n  \n### Remarks  \n The operator returns a value that is convertible to `bool` with a true value only if the object is not empty. You use it to test whether the object is empty.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__function_operator_bool.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <iostream>   \n  \nint neg(int val)   \n    {   \n    return (-val);   \n    }   \n  \nint main()   \n    {   \n    std::function<int (int)> fn0;   \n    std::cout << std::boolalpha << \"not empty == \" << (bool)fn0 << std::endl;   \n  \n    std::function<int (int)> fn1(neg);   \n    std::cout << std::boolalpha << \"not empty == \" << (bool)fn1 << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nnot empty == false  \nnot empty == true  \n```  \n  \n##  <a name=\"function__operator__\"></a>  function::operator()  \n Calls a callable object.  \n  \n```  \nresult_type operator()(T1 t1,\n    T2 t2, ...,\n    TN tN);\n```  \n  \n### Parameters  \n `TN`  \n The type of the Nth call argument.  \n  \n `tN`  \n The Nth call argument.  \n  \n### Remarks  \n The member function returns `INVOKE(fn, t1, t2, ..., tN, Ret)`, where `fn` is the target object stored in `*this`. You use it to call the wrapped callable object.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__function_operator_call.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <iostream>   \n  \nint neg(int val)   \n    {   \n    return (-val);   \n    }   \n  \nint main()   \n    {   \n    std::function<int (int)> fn1(neg);   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n    std::cout << \"val == \" << fn1(3) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nempty == false  \nval == -3  \n```  \n  \n##  <a name=\"function__operator_eq\"></a>  function::operator=  \n Replaces the stored callable object.  \n  \n```  \nfunction& operator=(null_ptr_type npc);\n\nfunction& operator=(const function& right);\n\ntemplate <class Fty>  \nfunction& operator=(Fty fn);\n\ntemplate <class Fty>  \nfunction& operator=(reference_wrapper<Fty>  \nfnref);\n```  \n  \n### Parameters  \n `npc`  \n A null pointer constant.  \n  \n `right`  \n The function object to copy.  \n  \n `fn`  \n The callable object to wrap.  \n  \n `fnref`  \n The callable object reference to wrap.  \n  \n### Remarks  \n The operators each replace the callable object held by `*this` with the callable object passed as the operand.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__function_operator_as.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <iostream>   \n  \nint neg(int val)   \n    {   \n    return (-val);   \n    }   \n  \nint main()   \n    {   \n    std::function<int (int)> fn0(neg);   \n    std::cout << std::boolalpha << \"empty == \" << !fn0 << std::endl;   \n    std::cout << \"val == \" << fn0(3) << std::endl;   \n  \n    std::function<int (int)> fn1;   \n    fn1 = 0;   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n  \n    fn1 = neg;   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n    std::cout << \"val == \" << fn1(3) << std::endl;   \n  \n    fn1 = fn0;   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n    std::cout << \"val == \" << fn1(3) << std::endl;   \n  \n    fn1 = std::cref(fn1);   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n    std::cout << \"val == \" << fn1(3) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nempty == false  \nval == -3  \nempty == true  \nempty == false  \nval == -3  \nempty == false  \nval == -3  \nempty == false  \nval == -3  \n```  \n  \n##  <a name=\"function__result_type\"></a>  function::result_type  \n The return type of the stored callable object.  \n  \n```  \ntypedef Ret result_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for the type `Ret` in the template's call signature. You use it to determine the return type of the wrapped callable object.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__function_result_type.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <iostream>   \n  \nint neg(int val)   \n    {   \n    return (-val);   \n    }   \n  \nint main()   \n    {   \n    std::function<int (int)> fn1(neg);   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n  \n    std::function<int (int)>::result_type val = fn1(3);   \n    std::cout << \"val == \" << val << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nempty == false  \nval == -3  \n```  \n  \n##  <a name=\"function__swap\"></a>  function::swap  \n Swap two callable objects.  \n  \n```  \nvoid swap(function& right);\n```  \n  \n### Parameters  \n `right`  \n The function object to swap with.  \n  \n### Remarks  \n The member function swaps the target objects between `*this` and `right`. It does so in constant time and throws no exceptions.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__function_swap.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <iostream>   \n  \nint neg(int val)   \n    {   \n    return (-val);   \n    }   \n  \nint main()   \n    {   \n    std::function<int (int)> fn0(neg);   \n    std::cout << std::boolalpha << \"empty == \" << !fn0 << std::endl;   \n    std::cout << \"val == \" << fn0(3) << std::endl;   \n  \n    std::function<int (int)> fn1;   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n    std::cout << std::endl;   \n  \n    fn0.swap(fn1);   \n    std::cout << std::boolalpha << \"empty == \" << !fn0 << std::endl;   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n    std::cout << \"val == \" << fn1(3) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nempty == false  \nval == -3  \nempty == true  \n  \nempty == true  \nempty == false  \nval == -3  \n```  \n  \n##  <a name=\"function__target\"></a>  function::target  \n Tests if stored callable object is callable as specified.  \n  \n```  \ntemplate <class Fty2>  \nFty2 *target();\n\ntemplate <class Fty2>  \nconst Fty2 *target() const;\n```  \n  \n### Parameters  \n `Fty2`  \n The target callable object type to test.  \n  \n### Remarks  \n The type `Fty2` must be callable for the argument types `T1, T2, ..., TN` and the return type `Ret`. If `target_type() == typeid(Fty2)`, the member template function returns the address of the target object; otherwise, it returns 0.  \n  \n A type `Fty2` is callable for the argument types `T1, T2, ..., TN` and the return type `Ret` if, for lvalues `fn, t1, t2, ..., tN` of types `Fty2, T1, T2, ..., TN`, respectively, `INVOKE(fn, t1, t2, ..., tN)` is well-formed and, if `Ret` is not `void`, convertible to `Ret`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__function_target.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <iostream>   \n  \nint neg(int val)   \n    {   \n    return (-val);   \n    }   \n  \nint main()   \n    {   \n    typedef int (*Myfun)(int);   \n    std::function<int (int)> fn0(neg);   \n    std::cout << std::boolalpha << \"empty == \" << !fn0 << std::endl;   \n    std::cout << \"no target == \" << (fn0.target<Myfun>() == 0) << std::endl;   \n  \n    Myfun *fptr = fn0.target<Myfun>();   \n    std::cout << \"val == \" << (*fptr)(3) << std::endl;   \n  \n    std::function<int (int)> fn1;   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n    std::cout << \"no target == \" << (fn1.target<Myfun>() == 0) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nempty == false  \nno target == false  \nval == -3  \nempty == true  \nno target == true  \n```  \n  \n##  <a name=\"function__target_type\"></a>  function::target_type  \n Gets type information on the callable object.  \n  \n```  \nconst std::type_info& target_type() const;\n```  \n  \n### Remarks  \n The member function returns `typeid(void)` if `*this` is empty, otherwise it returns `typeid(T)`, where `T` is the type of the target object.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__functional__function_target_type.cpp   \n// compile with: /EHsc   \n#include <functional>   \n#include <iostream>   \n  \nint neg(int val)   \n    {   \n    return (-val);   \n    }   \n  \nint main()   \n    {   \n    std::function<int (int)> fn0(neg);   \n    std::cout << std::boolalpha << \"empty == \" << !fn0 << std::endl;   \n    std::cout << \"type == \" << fn0.target_type().name() << std::endl;   \n  \n    std::function<int (int)> fn1;   \n    std::cout << std::boolalpha << \"empty == \" << !fn1 << std::endl;   \n    std::cout << \"type == \" << fn1.target_type().name() << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nempty == false  \ntype == int (__cdecl*)(int)  \nempty == true  \ntype == void  \n```  \n  \n## See Also  \n [mem_fn Function](../standard-library/functional-functions.md#mem_fn_function)   \n [reference_wrapper Class](../standard-library/reference-wrapper-class.md)\n"}