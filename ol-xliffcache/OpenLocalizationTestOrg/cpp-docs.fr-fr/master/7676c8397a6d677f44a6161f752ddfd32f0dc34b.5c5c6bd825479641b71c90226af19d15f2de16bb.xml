{"nodes":[{"pos":[12,85],"content":"strtok, _strtok_l, wcstok, _wcstok_l, _mbstok, _mbstok_l | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"strtok, _strtok_l, wcstok, _wcstok_l, _mbstok, _mbstok_l | Microsoft Docs","pos":[0,73]}]},{"pos":[1480,1536],"content":"strtok, _strtok_l, wcstok, _wcstok_l, _mbstok, _mbstok_l","linkify":"strtok, _strtok_l, wcstok, _wcstok_l, _mbstok, _mbstok_l","nodes":[{"content":"strtok, _strtok_l, wcstok, _wcstok_l, _mbstok, _mbstok_l","pos":[0,56]}]},{"content":"Finds the next token in a string, by using the current locale or a specified locale that's passed in.","pos":[1537,1638]},{"content":"More secure versions of these functions are available; see <bpt id=\"p1\">[</bpt>strtok_s, _strtok_s_l, wcstok_s, _wcstok_s_l, _mbstok_s, _mbstok_s_l<ept id=\"p1\">](../../c-runtime-library/reference/strtok-s-strtok-s-l-wcstok-s-wcstok-s-l-mbstok-s-mbstok-s-l.md)</ept>.","pos":[1639,1867],"source":" More secure versions of these functions are available; see [strtok_s, _strtok_s_l, wcstok_s, _wcstok_s_l, _mbstok_s, _mbstok_s_l](../../c-runtime-library/reference/strtok-s-strtok-s-l-wcstok-s-wcstok-s-l-mbstok-s-mbstok-s-l.md)."},{"pos":[1875,2112],"content":"[!IMPORTANT]\n `_mbstok` and `_mbstok_l` cannot be used in applications that execute in the Windows Runtime. For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx).","leadings":["","> "],"nodes":[{"content":" `_mbstok` and `_mbstok_l` cannot be used in applications that execute in the Windows Runtime. For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx).","pos":[13,235],"nodes":[{"content":"<ph id=\"ph1\"> `_mbstok`</ph> and <ph id=\"ph2\">`_mbstok_l`</ph> cannot be used in applications that execute in the Windows Runtime.","pos":[0,94],"source":" `_mbstok` and `_mbstok_l` cannot be used in applications that execute in the Windows Runtime."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>CRT functions not supported with /ZW<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx)</ept>.","pos":[95,222],"source":" For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx)."}]}]},{"pos":[2121,2127],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[2522,2532],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"String containing token or tokens.","pos":[2550,2584]},{"content":"Set of delimiter characters.","pos":[2607,2635]},{"content":"Locale to use.","pos":[2654,2668]},{"pos":[2677,2689],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Returns a pointer to the next token found in <ph id=\"ph1\">`strToken`</ph>.","pos":[2693,2749],"source":"Returns a pointer to the next token found in `strToken`."},{"content":"They return <ph id=\"ph1\">`NULL`</ph> when no more tokens are found.","pos":[2750,2799],"source":" They return `NULL` when no more tokens are found."},{"content":"Each call modifies <ph id=\"ph1\">`strToken`</ph> by substituting a <ph id=\"ph2\">`NULL`</ph> character for the first delimiter that occurs after the returned token.","pos":[2800,2926],"source":" Each call modifies `strToken` by substituting a `NULL` character for the first delimiter that occurs after the returned token."},{"pos":[2935,2942],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`strtok`</ph> function finds the next token in <ph id=\"ph2\">`strToken`</ph>.","pos":[2946,3003],"source":"The `strtok` function finds the next token in `strToken`."},{"content":"The set of characters in <ph id=\"ph1\">`strDelimit`</ph> specifies possible delimiters of the token to be found in <ph id=\"ph2\">`strToken`</ph> on the current call.","pos":[3004,3131],"source":" The set of characters in `strDelimit` specifies possible delimiters of the token to be found in `strToken` on the current call."},{"content":"<ph id=\"ph1\">`wcstok`</ph> and <ph id=\"ph2\">`_mbstok`</ph> are wide-character and multibyte-character versions of <ph id=\"ph3\">`strtok`</ph>.","pos":[3132,3219],"source":"`wcstok` and `_mbstok` are wide-character and multibyte-character versions of `strtok`."},{"content":"The arguments and return value of <ph id=\"ph1\">`wcstok`</ph> are wide-character strings; those of <ph id=\"ph2\">`_mbstok`</ph> are multibyte-character strings.","pos":[3220,3342],"source":" The arguments and return value of `wcstok` are wide-character strings; those of `_mbstok` are multibyte-character strings."},{"content":"These three functions behave identically otherwise.","pos":[3343,3394]},{"pos":[3402,3731],"content":"[!IMPORTANT]\n These functions incur a potential threat brought about by a buffer overrun problem. Buffer overrun problems are a frequent method of system attack, resulting in an unwarranted elevation of privilege. For more information, see [Avoiding Buffer Overruns](http://msdn.microsoft.com/library/windows/desktop/ms717795).","leadings":["","> "],"nodes":[{"content":" These functions incur a potential threat brought about by a buffer overrun problem. Buffer overrun problems are a frequent method of system attack, resulting in an unwarranted elevation of privilege. For more information, see [Avoiding Buffer Overruns](http://msdn.microsoft.com/library/windows/desktop/ms717795).","pos":[13,327],"nodes":[{"content":"These functions incur a potential threat brought about by a buffer overrun problem.","pos":[1,84]},{"content":"Buffer overrun problems are a frequent method of system attack, resulting in an unwarranted elevation of privilege.","pos":[85,200]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Avoiding Buffer Overruns<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms717795)</ept>.","pos":[201,314],"source":" For more information, see [Avoiding Buffer Overruns](http://msdn.microsoft.com/library/windows/desktop/ms717795)."}]}]},{"content":"On the first call to <ph id=\"ph1\">`strtok`</ph>, the function skips leading delimiters and returns a pointer to the first token in <ph id=\"ph2\">`strToken`</ph>, terminating the token with a null character.","pos":[3738,3907],"source":"On the first call to `strtok`, the function skips leading delimiters and returns a pointer to the first token in `strToken`, terminating the token with a null character."},{"content":"More tokens can be broken out of the remainder of <ph id=\"ph1\">`strToken`</ph> by a series of calls to <ph id=\"ph2\">`strtok`</ph>.","pos":[3908,4002],"source":" More tokens can be broken out of the remainder of `strToken` by a series of calls to `strtok`."},{"content":"Each call to <ph id=\"ph1\">`strtok`</ph>modifies <ph id=\"ph2\">`strToken`</ph> by inserting a null character after the <ph id=\"ph3\">`token`</ph> returned by that call.","pos":[4003,4114],"source":" Each call to `strtok`modifies `strToken` by inserting a null character after the `token` returned by that call."},{"content":"To read the next token from <ph id=\"ph1\">`strToken`</ph>, call <ph id=\"ph2\">`strtok`</ph> with a <ph id=\"ph3\">`NULL`</ph> value for the <ph id=\"ph4\">`strToken`</ph> argument.","pos":[4115,4217],"source":" To read the next token from `strToken`, call `strtok` with a `NULL` value for the `strToken` argument."},{"content":"The <ph id=\"ph1\">`NULL`</ph> <ph id=\"ph2\">`strToken`</ph> argument causes <ph id=\"ph3\">`strtok`</ph> to search for the next token in the modified <ph id=\"ph4\">`strToken`</ph>.","pos":[4218,4321],"source":" The `NULL` `strToken` argument causes `strtok` to search for the next token in the modified `strToken`."},{"content":"The <ph id=\"ph1\">`strDelimit`</ph> argument can take any value from one call to the next so that the set of delimiters may vary.","pos":[4322,4432],"source":" The `strDelimit` argument can take any value from one call to the next so that the set of delimiters may vary."},{"content":"The output value is affected by the setting of the <ph id=\"ph1\">`LC_CTYPE`</ph> category setting of the locale; see <bpt id=\"p1\">[</bpt>setlocale<ept id=\"p1\">](../../c-runtime-library/reference/setlocale-wsetlocale.md)</ept> for more information.","pos":[4439,4629],"source":"The output value is affected by the setting of the `LC_CTYPE` category setting of the locale; see [setlocale](../../c-runtime-library/reference/setlocale-wsetlocale.md) for more information."},{"content":"The versions of these functions without the <ph id=\"ph1\">`_l`</ph> suffix use the current locale for this locale-dependent behavior; the versions with the <ph id=\"ph2\">`_l`</ph> suffix are identical except that they use the locale parameter passed in instead.","pos":[4630,4853],"source":" The versions of these functions without the `_l` suffix use the current locale for this locale-dependent behavior; the versions with the `_l` suffix are identical except that they use the locale parameter passed in instead."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Locale<ept id=\"p1\">](../../c-runtime-library/locale.md)</ept>.","pos":[4854,4924],"source":" For more information, see [Locale](../../c-runtime-library/locale.md)."},{"pos":[4932,5630],"content":"[!NOTE]\n Each function uses a thread-local static variable for parsing the string into tokens. Therefore, multiple threads can simultaneously call these functions without undesirable effects. However, within a single thread, interleaving calls to one of these functions is highly likely to produce data corruption and inaccurate results. When parsing different strings, finish parsing one string before starting to parse the next. Also, be aware of the potential for danger when calling one of these functions from within a loop where another function is called. If the other function ends up using one of these functions, an interleaved sequence of calls will result, triggering data corruption.","leadings":["","> "],"nodes":[{"content":" Each function uses a thread-local static variable for parsing the string into tokens. Therefore, multiple threads can simultaneously call these functions without undesirable effects. However, within a single thread, interleaving calls to one of these functions is highly likely to produce data corruption and inaccurate results. When parsing different strings, finish parsing one string before starting to parse the next. Also, be aware of the potential for danger when calling one of these functions from within a loop where another function is called. If the other function ends up using one of these functions, an interleaved sequence of calls will result, triggering data corruption.","pos":[8,696],"nodes":[{"content":"Each function uses a thread-local static variable for parsing the string into tokens.","pos":[1,86]},{"content":"Therefore, multiple threads can simultaneously call these functions without undesirable effects.","pos":[87,183]},{"content":"However, within a single thread, interleaving calls to one of these functions is highly likely to produce data corruption and inaccurate results.","pos":[184,329]},{"content":"When parsing different strings, finish parsing one string before starting to parse the next.","pos":[330,422]},{"content":"Also, be aware of the potential for danger when calling one of these functions from within a loop where another function is called.","pos":[423,554]},{"content":"If the other function ends up using one of these functions, an interleaved sequence of calls will result, triggering data corruption.","pos":[555,688]}]}]},{"pos":[5640,5669],"content":"Generic-Text Routine Mappings","linkify":"Generic-Text Routine Mappings","nodes":[{"content":"Generic-Text Routine Mappings","pos":[0,29]}]},{"content":"TCHAR.H routine","pos":[5676,5691]},{"content":"_UNICODE &amp; _MBCS not defined","pos":[5692,5720],"source":"_UNICODE & _MBCS not defined"},{"content":"_MBCS defined","pos":[5721,5734]},{"content":"_UNICODE defined","pos":[5735,5751]},{"pos":[5961,5973],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[5980,5987]},{"content":"Required header","pos":[5988,6003]},{"content":"<ph id=\"ph1\">\\&lt;</ph>string.h&gt;","pos":[6057,6068],"source":"\\<string.h>"},{"content":"<ph id=\"ph1\">\\&lt;</ph>string.h&gt; or <ph id=\"ph2\">\\&lt;</ph>wchar.h&gt;","pos":[6082,6107],"source":"\\<string.h> or \\<wchar.h>"},{"pos":[6112,6134],"content":"<ph id=\"ph1\">`_mbstok`</ph>, <ph id=\"ph2\">`_mbstok_l`</ph>","source":"`_mbstok`, `_mbstok_l`"},{"content":"<ph id=\"ph1\">\\&lt;</ph>mbstring.h&gt;","pos":[6135,6148],"source":"\\<mbstring.h>"},{"pos":[6156,6260],"content":"For additional compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept>.","source":"For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md)."},{"pos":[6269,6276],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[7158,7183],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"Not applicable.","pos":[7187,7202]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[7203,7250],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[7251,7376],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[7385,7393],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>String Manipulation<ept id=\"p1\">](../../c-runtime-library/string-manipulation-crt.md)</ept><ph id=\"ph1\"> </ph>","pos":[7397,7471],"source":"[String Manipulation](../../c-runtime-library/string-manipulation-crt.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Locale<ept id=\"p1\">](../../c-runtime-library/locale.md)</ept><ph id=\"ph1\"> </ph>","pos":[7474,7519],"source":" [Locale](../../c-runtime-library/locale.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Interpretation of Multibyte-Character Sequences<ept id=\"p1\">](../../c-runtime-library/interpretation-of-multibyte-character-sequences.md)</ept><ph id=\"ph1\"> </ph>","pos":[7522,7649],"source":" [Interpretation of Multibyte-Character Sequences](../../c-runtime-library/interpretation-of-multibyte-character-sequences.md) "},{"content":"<bpt id=\"p1\"> [</bpt>strcspn, wcscspn, _mbscspn, _mbscspn_l<ept id=\"p1\">](../../c-runtime-library/reference/strcspn-wcscspn-mbscspn-mbscspn-l.md)</ept><ph id=\"ph1\"> </ph>","pos":[7652,7766],"source":" [strcspn, wcscspn, _mbscspn, _mbscspn_l](../../c-runtime-library/reference/strcspn-wcscspn-mbscspn-mbscspn-l.md) "},{"content":"<bpt id=\"p1\"> [</bpt>strspn, wcsspn, _mbsspn, _mbsspn_l<ept id=\"p1\">](../../c-runtime-library/reference/strspn-wcsspn-mbsspn-mbsspn-l.md)</ept>","pos":[7769,7874],"source":" [strspn, wcsspn, _mbsspn, _mbsspn_l](../../c-runtime-library/reference/strspn-wcsspn-mbsspn-mbsspn-l.md)"}],"content":"---\ntitle: \"strtok, _strtok_l, wcstok, _wcstok_l, _mbstok, _mbstok_l | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_mbstok_l\"\n  - \"_mbstok\"\n  - \"wcstok\"\n  - \"_mbstok\"\n  - \"strtok\"\n  - \"_wcstok_l\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\n  - \"api-ms-win-crt-multibyte-l1-1-0.dll\"\n  - \"api-ms-win-crt-string-l1-1-0.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"_mbstok\"\n  - \"strtok\"\n  - \"_tcstok\"\n  - \"wcstok\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"mbstok_l function\"\n  - \"strings [C++], searching\"\n  - \"tcstok function\"\n  - \"_tcstok function\"\n  - \"_strtok_l function\"\n  - \"strtok function\"\n  - \"mbstok function\"\n  - \"wcstok_l function\"\n  - \"_mbstok function\"\n  - \"tcstok_l function\"\n  - \"tokens, finding in strings\"\n  - \"_mbstok_l function\"\n  - \"wcstok function\"\n  - \"_wcstok_l function\"\n  - \"_tcstok_l function\"\n  - \"strtok_l function\"\nms.assetid: 904cb734-f0d7-4d77-ba81-4791ddf461ae\ncaps.latest.revision: 34\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# strtok, _strtok_l, wcstok, _wcstok_l, _mbstok, _mbstok_l\nFinds the next token in a string, by using the current locale or a specified locale that's passed in. More secure versions of these functions are available; see [strtok_s, _strtok_s_l, wcstok_s, _wcstok_s_l, _mbstok_s, _mbstok_s_l](../../c-runtime-library/reference/strtok-s-strtok-s-l-wcstok-s-wcstok-s-l-mbstok-s-mbstok-s-l.md).  \n  \n> [!IMPORTANT]\n>  `_mbstok` and `_mbstok_l` cannot be used in applications that execute in the Windows Runtime. For more information, see [CRT functions not supported with /ZW](http://msdn.microsoft.com/library/windows/apps/jj606124.aspx).  \n  \n## Syntax  \n  \n```  \nchar *strtok(  \n   char *strToken,  \n   const char *strDelimit   \n);  \nwchar_t *wcstok(  \n   wchar_t *strToken,  \n   const wchar_t *strDelimit   \n);  \nunsigned char *_mbstok(  \n   unsigned char*strToken,  \n   const unsigned char *strDelimit   \n);  \nunsigned char *_mbstok(  \n   unsigned char*strToken,  \n   const unsigned char *strDelimit,  \n   _locale_t locale  \n);  \n```  \n  \n#### Parameters  \n `strToken`  \n String containing token or tokens.  \n  \n `strDelimit`  \n Set of delimiter characters.  \n  \n `locale`  \n Locale to use.  \n  \n## Return Value  \n Returns a pointer to the next token found in `strToken`. They return `NULL` when no more tokens are found. Each call modifies `strToken` by substituting a `NULL` character for the first delimiter that occurs after the returned token.  \n  \n## Remarks  \n The `strtok` function finds the next token in `strToken`. The set of characters in `strDelimit` specifies possible delimiters of the token to be found in `strToken` on the current call. `wcstok` and `_mbstok` are wide-character and multibyte-character versions of `strtok`. The arguments and return value of `wcstok` are wide-character strings; those of `_mbstok` are multibyte-character strings. These three functions behave identically otherwise.  \n  \n> [!IMPORTANT]\n>  These functions incur a potential threat brought about by a buffer overrun problem. Buffer overrun problems are a frequent method of system attack, resulting in an unwarranted elevation of privilege. For more information, see [Avoiding Buffer Overruns](http://msdn.microsoft.com/library/windows/desktop/ms717795).  \n  \n On the first call to `strtok`, the function skips leading delimiters and returns a pointer to the first token in `strToken`, terminating the token with a null character. More tokens can be broken out of the remainder of `strToken` by a series of calls to `strtok`. Each call to `strtok`modifies `strToken` by inserting a null character after the `token` returned by that call. To read the next token from `strToken`, call `strtok` with a `NULL` value for the `strToken` argument. The `NULL` `strToken` argument causes `strtok` to search for the next token in the modified `strToken`. The `strDelimit` argument can take any value from one call to the next so that the set of delimiters may vary.  \n  \n The output value is affected by the setting of the `LC_CTYPE` category setting of the locale; see [setlocale](../../c-runtime-library/reference/setlocale-wsetlocale.md) for more information. The versions of these functions without the `_l` suffix use the current locale for this locale-dependent behavior; the versions with the `_l` suffix are identical except that they use the locale parameter passed in instead. For more information, see [Locale](../../c-runtime-library/locale.md).  \n  \n> [!NOTE]\n>  Each function uses a thread-local static variable for parsing the string into tokens. Therefore, multiple threads can simultaneously call these functions without undesirable effects. However, within a single thread, interleaving calls to one of these functions is highly likely to produce data corruption and inaccurate results. When parsing different strings, finish parsing one string before starting to parse the next. Also, be aware of the potential for danger when calling one of these functions from within a loop where another function is called. If the other function ends up using one of these functions, an interleaved sequence of calls will result, triggering data corruption.  \n  \n### Generic-Text Routine Mappings  \n  \n|TCHAR.H routine|_UNICODE & _MBCS not defined|_MBCS defined|_UNICODE defined|  \n|---------------------|------------------------------------|--------------------|-----------------------|  \n|`_tcstok`|`strtok`|`_mbstok`|`wcstok`|  \n|`_tcstok`|`_strtok_l`|`_mbstok_l`|`_wcstok_l`|  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`strtok`|\\<string.h>|  \n|`wcstok`|\\<string.h> or \\<wchar.h>|  \n|`_mbstok`, `_mbstok_l`|\\<mbstring.h>|  \n  \n For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md).  \n  \n## Example  \n  \n```  \n// crt_strtok.c  \n// compile with: /W3  \n// In this program, a loop uses strtok  \n// to print all the tokens (separated by commas  \n// or blanks) in the string named \"string\".  \n//  \n#include <string.h>  \n#include <stdio.h>  \n  \nchar string[] = \"A string\\tof ,,tokens\\nand some  more tokens\";  \nchar seps[]   = \" ,\\t\\n\";  \nchar *token;  \n  \nint main( void )  \n{  \n   printf( \"Tokens:\\n\" );  \n  \n   // Establish string and get the first token:  \n   token = strtok( string, seps ); // C4996  \n   // Note: strtok is deprecated; consider using strtok_s instead  \n   while( token != NULL )  \n   {  \n      // While there are tokens in \"string\"  \n      printf( \" %s\\n\", token );  \n  \n      // Get next token:   \n      token = strtok( NULL, seps ); // C4996  \n   }  \n}  \n```  \n  \n```Output  \nTokens:  \n A  \n string  \n of  \n tokens  \n and  \n some  \n more  \n tokens  \n```  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [String Manipulation](../../c-runtime-library/string-manipulation-crt.md)   \n [Locale](../../c-runtime-library/locale.md)   \n [Interpretation of Multibyte-Character Sequences](../../c-runtime-library/interpretation-of-multibyte-character-sequences.md)   \n [strcspn, wcscspn, _mbscspn, _mbscspn_l](../../c-runtime-library/reference/strcspn-wcscspn-mbscspn-mbscspn-l.md)   \n [strspn, wcsspn, _mbsspn, _mbsspn_l](../../c-runtime-library/reference/strspn-wcsspn-mbsspn-mbsspn-l.md)"}