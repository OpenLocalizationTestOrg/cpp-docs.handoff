{"nodes":[{"pos":[12,49],"content":"Assignment Operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Assignment Operators | Microsoft Docs","pos":[0,37]}]},{"content":"Assignment Operators","pos":[1100,1120]},{"content":"Syntax","pos":[1124,1130]},{"content":"Remarks","pos":[1298,1305]},{"content":"Assignment operators store a value in the object designated by the left operand.","pos":[1309,1389]},{"content":"There are two kinds of assignment operations: simple assignment, in which the value of the second operand is stored in the object specified by the first operand, and compound assignment, in which an arithmetic, shift, or bitwise operation is performed prior to storing the result.","pos":[1390,1670]},{"content":"All assignment operators in the following table except the = operator are compound assignment operators.","pos":[1671,1775]},{"content":"Assignment Operators","pos":[1785,1805]},{"content":"Operator","pos":[1812,1820]},{"content":"Meaning","pos":[1821,1828]},{"content":"Store the value of the second operand in the object specified by the first operand (simple assignment).","pos":[1872,1975]},{"content":"Multiply the value of the first operand by the value of the second operand; store the result in the object specified by the first operand.","pos":[1988,2126]},{"content":"Divide the value of the first operand by the value of the second operand; store the result in the object specified by the first operand.","pos":[2136,2272]},{"content":"Take modulus of the first operand specified by the value of the second operand; store the result in the object specified by the first operand.","pos":[2282,2424]},{"content":"Add the value of the second operand to the value of the first operand; store the result in the object specified by the first operand.","pos":[2434,2567]},{"content":"–=","pos":[2574,2576]},{"content":"Subtract the value of the second operand from the value of the first operand; store the result in the object specified by the first operand.","pos":[2579,2719]},{"content":"Shift the value of the first operand left the number of bits specified by the value of the second operand; store the result in the object specified by the first operand.","pos":[2733,2902]},{"content":"Shift the value of the first operand right the number of bits specified by the value of the second operand; store the result in the object specified by the first operand.","pos":[2915,3085]},{"content":"Obtain the bitwise AND of the first and second operands; store the result in the object specified by the first operand.","pos":[3097,3216]},{"content":"Obtain the bitwise exclusive OR of the first and second operands; store the result in the object specified by the first operand.","pos":[3226,3354]},{"content":"Obtain the bitwise inclusive OR of the first and second operands; store the result in the object specified by the first operand.","pos":[3369,3497]},{"content":"Operator Keywords","pos":[3507,3524]},{"content":"Three of the compound assignment operators have text equivalents.","pos":[3533,3598]},{"content":"They are:","pos":[3599,3608]},{"content":"Operator","pos":[3615,3623]},{"content":"Equivalent","pos":[3624,3634]},{"pos":[3738,3974],"content":"There are two ways to access these operator keywords in your programs: include the header file <ph id=\"ph1\">`iso646.h`</ph>, or compile with the <bpt id=\"p1\">[</bpt>/Za<ept id=\"p1\">](../build/reference/za-ze-disable-language-extensions.md)</ept> (Disable language extensions) compiler option.","source":"There are two ways to access these operator keywords in your programs: include the header file `iso646.h`, or compile with the [/Za](../build/reference/za-ze-disable-language-extensions.md) (Disable language extensions) compiler option."},{"content":"Example","pos":[3983,3990]},{"content":"Simple assignment","pos":[4620,4637]},{"content":"The simple assignment operator (=) causes the value of the second operand to be stored in the object specified by the first operand.","pos":[4641,4773]},{"content":"If both objects are of arithmetic types, the right operand is converted to the type of the left, prior to storing the value.","pos":[4774,4898]},{"content":"Objects of const and volatile types can be assigned to l-values of types that are just volatile or that are neither const nor volatile.","pos":[4905,5040]},{"content":"Assignment to objects of class type (struct, union, and class types) is performed by a function named operator=.","pos":[5047,5159]},{"content":"The default behavior of this operator function is to perform a bitwise copy; however, this behavior can be modified using overloaded operators.","pos":[5160,5303]},{"content":"(See <bpt id=\"p1\">[</bpt>Overloaded Operators<ept id=\"p1\">](../cpp/operator-overloading.md)</ept> for more information.)","pos":[5304,5386],"source":" (See [Overloaded Operators](../cpp/operator-overloading.md) for more information.)"},{"content":"An object of any unambiguously derived class from a given base class can be assigned to an object of the base class.","pos":[5393,5509]},{"content":"The reverse is not true because there is an implicit conversion from derived class to base class but not from base class to derived class.","pos":[5510,5648]},{"content":"For example:","pos":[5649,5661]},{"content":"Assignments to reference types behave as if the assignment were being made to the object to which the reference points.","pos":[6112,6231]},{"content":"For class-type objects, assignment is different from initialization.","pos":[6238,6306]},{"content":"To illustrate how different assignment and initialization can be, consider the code","pos":[6307,6390]},{"content":"The preceding code shows an initializer; it calls the constructor for <ph id=\"ph1\">`UserType2`</ph> that takes an argument of type <ph id=\"ph2\">`UserType1`</ph>.","pos":[6446,6571],"source":"The preceding code shows an initializer; it calls the constructor for `UserType2` that takes an argument of type `UserType1`."},{"content":"Given the code","pos":[6572,6586]},{"content":"the assignment statement","pos":[6650,6674]},{"content":"can have one of the following effects:","pos":[6706,6744]},{"pos":[6754,6858],"content":"Call the function operator= for <ph id=\"ph1\">`UserType2`</ph>, provided operator= is provided with a <ph id=\"ph2\">`UserType1`</ph> argument.","source":"Call the function operator= for `UserType2`, provided operator= is provided with a `UserType1` argument."},{"pos":[6868,6965],"content":"Call the explicit conversion function <ph id=\"ph1\">`UserType1::operator UserType2`</ph>, if such a function exists.","source":"Call the explicit conversion function `UserType1::operator UserType2`, if such a function exists."},{"pos":[6975,7110],"content":"Call a constructor <ph id=\"ph1\">`UserType2::UserType2`</ph>, provided such a constructor exists, that takes a <ph id=\"ph2\">`UserType1`</ph> argument and copies the result.","source":"Call a constructor `UserType2::UserType2`, provided such a constructor exists, that takes a `UserType1` argument and copies the result."},{"content":"Compound assignment","pos":[7119,7138]},{"pos":[7142,7384],"content":"The compound assignment operators, shown in the table in <bpt id=\"p1\">[</bpt>Assignment Operators<ept id=\"p1\">](../cpp/assignment-operators.md)</ept>, are specified in the form <bpt id=\"p2\">*</bpt>e1<ept id=\"p2\">*</ept> <ph id=\"ph1\">`op`= </ph><bpt id=\"p3\">*</bpt>e2<ept id=\"p3\">*</ept>, where <bpt id=\"p4\">*</bpt>e1<ept id=\"p4\">*</ept> is a modifiable l-value not of const type and <bpt id=\"p5\">*</bpt>e2<ept id=\"p5\">*</ept> is one of the following:","source":"The compound assignment operators, shown in the table in [Assignment Operators](../cpp/assignment-operators.md), are specified in the form *e1* `op`= *e2*, where *e1* is a modifiable l-value not of const type and *e2* is one of the following:"},{"content":"An arithmetic type","pos":[7394,7412]},{"pos":[7422,7450],"content":"A pointer, if <ph id=\"ph1\">`op`</ph> is + or –","source":"A pointer, if `op` is + or –"},{"pos":[7457,7548],"content":"The <bpt id=\"p1\">*</bpt>e1<ept id=\"p1\">*</ept> <ph id=\"ph1\">`op`= </ph><bpt id=\"p2\">*</bpt>e2<ept id=\"p2\">*</ept> form behaves as <bpt id=\"p3\">*</bpt>e1<ept id=\"p3\">*</ept> <bpt id=\"p4\">*</bpt>= e1<ept id=\"p4\">*</ept> <ph id=\"ph2\">`op`</ph> <bpt id=\"p5\">*</bpt>e2<ept id=\"p5\">*</ept>, but <bpt id=\"p6\">*</bpt>e1<ept id=\"p6\">*</ept> is evaluated only once.","source":"The *e1* `op`= *e2* form behaves as *e1* *= e1* `op` *e2*, but *e1* is evaluated only once."},{"content":"Compound assignment to an enumerated type generates an error message.","pos":[7555,7624]},{"content":"If the left operand is of a pointer type, the right operand must be of a pointer type or it must be a constant expression that evaluates to 0.","pos":[7625,7767]},{"content":"If the left operand is of an integral type, the right operand must not be of a pointer type.","pos":[7768,7860]},{"content":"Result of assignment operators","pos":[7869,7899]},{"content":"The assignment operators return the value of the object specified by the left operand after the assignment.","pos":[7903,8010]},{"content":"The resultant type is the type of the left operand.","pos":[8011,8062]},{"content":"The result of an assignment expression is always an l-value.","pos":[8063,8123]},{"content":"These operators have right-to-left associativity.","pos":[8124,8173]},{"content":"The left operand must be a modifiable l-value.","pos":[8174,8220]},{"content":"In ANSI C, the result of an assignment expression is not an l-value.","pos":[8227,8295]},{"content":"Therefore, the legal C++ expression <ph id=\"ph1\">`(a += b) += c`</ph> is illegal in C.","pos":[8296,8364],"source":" Therefore, the legal C++ expression `(a += b) += c` is illegal in C."},{"content":"See Also","pos":[8373,8381]},{"content":"Expressions with Binary Operators","pos":[8386,8419]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[8471,8523]},{"content":"C Assignment Operators","pos":[8593,8615]}],"content":"---\ntitle: \"Assignment Operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \">>=\"\n  - \"xor_eq\"\n  - \"&=\"\n  - \"<<=\"\n  - \"-=\"\n  - \"and_eq\"\n  - \"^=\"\n  - \"|=\"\n  - \"/=\"\n  - \"%=\"\n  - \"or_eq\"\n  - \"+=\"\n  - \"*=\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"or_eq operator\"\n  - \"&= operator\"\n  - \"operators [C++], assignment\"\n  - \"assignment operators, C++\"\n  - \"xor_eq operator\"\n  - \"+= operator\"\n  - \"and_eq operator\"\n  - \">>= operator\"\n  - \"|= operator\"\n  - \"operator>>=\"\n  - \"*= operator\"\n  - \"%= operator\"\n  - \"^= operator\"\n  - \"operator >>=\"\n  - \"= operator\"\n  - \"assignment operators\"\n  - \"-= operator\"\n  - \"/= operator\"\n  - \"<<= operator\"\nms.assetid: b028cf35-2ff1-4f14-9027-fd53ebec8aa0\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Assignment Operators\n## Syntax  \n  \n```  \n  \n      expression assignment-operator expression   \nassignment-operator : one of  \n   =   *=   /=   %=   +=   –=   <<=   >>=   &=   ^=   |=  \n```  \n  \n## Remarks  \n Assignment operators store a value in the object designated by the left operand. There are two kinds of assignment operations: simple assignment, in which the value of the second operand is stored in the object specified by the first operand, and compound assignment, in which an arithmetic, shift, or bitwise operation is performed prior to storing the result. All assignment operators in the following table except the = operator are compound assignment operators.  \n  \n### Assignment Operators  \n  \n|Operator|Meaning|  \n|--------------|-------------|  \n|**=**|Store the value of the second operand in the object specified by the first operand (simple assignment).|  \n|**\\*=**|Multiply the value of the first operand by the value of the second operand; store the result in the object specified by the first operand.|  \n|`/=`|Divide the value of the first operand by the value of the second operand; store the result in the object specified by the first operand.|  \n|`%=`|Take modulus of the first operand specified by the value of the second operand; store the result in the object specified by the first operand.|  \n|`+=`|Add the value of the second operand to the value of the first operand; store the result in the object specified by the first operand.|  \n|**–=**|Subtract the value of the second operand from the value of the first operand; store the result in the object specified by the first operand.|  \n|**<\\<=**|Shift the value of the first operand left the number of bits specified by the value of the second operand; store the result in the object specified by the first operand.|  \n|**>>=**|Shift the value of the first operand right the number of bits specified by the value of the second operand; store the result in the object specified by the first operand.|  \n|**&=**|Obtain the bitwise AND of the first and second operands; store the result in the object specified by the first operand.|  \n|`^=`|Obtain the bitwise exclusive OR of the first and second operands; store the result in the object specified by the first operand.|  \n|`&#124;=`|Obtain the bitwise inclusive OR of the first and second operands; store the result in the object specified by the first operand.|  \n  \n **Operator Keywords**  \n  \n Three of the compound assignment operators have text equivalents. They are:  \n  \n|Operator|Equivalent|  \n|--------------|----------------|  \n|**&=**|`and_eq`|  \n|`&#124;=`|`or_eq`|  \n|`^=`|`xor_eq`|  \n  \n There are two ways to access these operator keywords in your programs: include the header file `iso646.h`, or compile with the [/Za](../build/reference/za-ze-disable-language-extensions.md) (Disable language extensions) compiler option.  \n  \n## Example  \n  \n```  \n// expre_Assignment_Operators.cpp  \n// compile with: /EHsc  \n// Demonstrate assignment operators  \n#include <iostream>  \nusing namespace std;  \nint main() {  \n   int a = 3, b = 6, c = 10, d = 0xAAAA, e = 0x5555;  \n  \n   a += b;      // a is 9  \n   b %= a;      // b is 6  \n   c >>= 1;      // c is 5  \n   d |= e;      // Bitwise--d is 0xFFFF   \n  \n   cout  << \"a = 3, b = 6, c = 10, d = 0xAAAA, e = 0x5555\" << endl  \n         << \"a += b yields \" << a << endl  \n         << \"b %= a yields \" << b << endl  \n         << \"c >>= 1 yields \" << c << endl  \n         << \"d |= e yields \" << hex << d << endl;  \n}  \n```  \n  \n## Simple assignment  \n The simple assignment operator (=) causes the value of the second operand to be stored in the object specified by the first operand. If both objects are of arithmetic types, the right operand is converted to the type of the left, prior to storing the value.  \n  \n Objects of const and volatile types can be assigned to l-values of types that are just volatile or that are neither const nor volatile.  \n  \n Assignment to objects of class type (struct, union, and class types) is performed by a function named operator=. The default behavior of this operator function is to perform a bitwise copy; however, this behavior can be modified using overloaded operators. (See [Overloaded Operators](../cpp/operator-overloading.md) for more information.)  \n  \n An object of any unambiguously derived class from a given base class can be assigned to an object of the base class. The reverse is not true because there is an implicit conversion from derived class to base class but not from base class to derived class. For example:  \n  \n```  \n// expre_SimpleAssignment.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \nclass ABase  \n{  \npublic:  \n    ABase() { cout << \"constructing ABase\\n\"; }  \n};  \n  \nclass ADerived : public ABase  \n{  \npublic:  \n    ADerived() { cout << \"constructing ADerived\\n\"; }  \n};  \n  \nint main()  \n{  \n    ABase aBase;  \n    ADerived aDerived;  \n  \n    aBase = aDerived; // OK  \n    aDerived = aBase; // C2679  \n}  \n```  \n  \n Assignments to reference types behave as if the assignment were being made to the object to which the reference points.  \n  \n For class-type objects, assignment is different from initialization. To illustrate how different assignment and initialization can be, consider the code  \n  \n```  \nUserType1 A;  \nUserType2 B = A;  \n```  \n  \n The preceding code shows an initializer; it calls the constructor for `UserType2` that takes an argument of type `UserType1`. Given the code  \n  \n```  \nUserType1 A;  \nUserType2 B;  \n  \nB = A;  \n```  \n  \n the assignment statement  \n  \n```  \nB = A;   \n```  \n  \n can have one of the following effects:  \n  \n-   Call the function operator= for `UserType2`, provided operator= is provided with a `UserType1` argument.  \n  \n-   Call the explicit conversion function `UserType1::operator UserType2`, if such a function exists.  \n  \n-   Call a constructor `UserType2::UserType2`, provided such a constructor exists, that takes a `UserType1` argument and copies the result.  \n  \n## Compound assignment  \n The compound assignment operators, shown in the table in [Assignment Operators](../cpp/assignment-operators.md), are specified in the form *e1* `op`= *e2*, where *e1* is a modifiable l-value not of const type and *e2* is one of the following:  \n  \n-   An arithmetic type  \n  \n-   A pointer, if `op` is + or –  \n  \n The *e1* `op`= *e2* form behaves as *e1* *= e1* `op` *e2*, but *e1* is evaluated only once.  \n  \n Compound assignment to an enumerated type generates an error message. If the left operand is of a pointer type, the right operand must be of a pointer type or it must be a constant expression that evaluates to 0. If the left operand is of an integral type, the right operand must not be of a pointer type.  \n  \n## Result of assignment operators  \n The assignment operators return the value of the object specified by the left operand after the assignment. The resultant type is the type of the left operand. The result of an assignment expression is always an l-value. These operators have right-to-left associativity. The left operand must be a modifiable l-value.  \n  \n In ANSI C, the result of an assignment expression is not an l-value. Therefore, the legal C++ expression `(a += b) += c` is illegal in C.  \n  \n## See Also  \n [Expressions with Binary Operators](../cpp/expressions-with-binary-operators.md)   \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   \n [C Assignment Operators](../c-language/c-assignment-operators.md)"}