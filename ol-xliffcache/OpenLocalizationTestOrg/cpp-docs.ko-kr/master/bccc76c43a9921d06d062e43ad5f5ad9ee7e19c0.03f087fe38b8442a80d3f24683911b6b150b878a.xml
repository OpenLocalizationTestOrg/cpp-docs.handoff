{"nodes":[{"pos":[12,62],"content":"Type Casting of MFC Class Objects | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Type Casting of MFC Class Objects | Microsoft Docs","pos":[0,50]}]},{"content":"Type Casting of MFC Class Objects","pos":[731,764]},{"content":"Type casting macros provide a way to cast a given pointer to a pointer that points to an object of specific class, with or without checking that the cast is legal.","pos":[765,928]},{"content":"The following table lists the MFC type casting macros.","pos":[935,989]},{"content":"Macros That Cast Pointers to MFC Class Objects","pos":[999,1045]},{"content":"DYNAMIC_DOWNCAST","pos":[1067,1083]},{"content":"Casts a pointer to a pointer to a class object while checking to see if the cast is legal.","pos":[1104,1194]},{"content":"STATIC_DOWNCAST","pos":[1200,1215]},{"content":"Casts a pointer to an object from one class to a pointer of a related type.","pos":[1235,1310]},{"content":"In a debug build, causes an <bpt id=\"p1\">**</bpt>ASSERT<ept id=\"p1\">**</ept> if the object is not a \"kind of\" the target type.","pos":[1311,1399],"source":" In a debug build, causes an **ASSERT** if the object is not a \"kind of\" the target type."},{"pos":[1443,1459],"content":"DYNAMIC_DOWNCAST"},{"content":"Provides a handy way to cast a pointer to a pointer to a class object while checking to see if the cast is legal.","pos":[1463,1576]},{"content":"Parameters","pos":[1637,1647]},{"content":"The name of a class.","pos":[1662,1682]},{"content":"A pointer to be cast to a pointer to an object of type <ph id=\"ph1\">`class`</ph>.","pos":[1702,1765],"source":" A pointer to be cast to a pointer to an object of type `class`."},{"content":"Remarks","pos":[1775,1782]},{"pos":[1786,1888],"content":"The macro will cast the <ph id=\"ph1\">`pointer`</ph> parameter to a pointer to an object of the <ph id=\"ph2\">`class`</ph> parameter's type.","source":"The macro will cast the `pointer` parameter to a pointer to an object of the `class` parameter's type."},{"content":"If the object referenced by the pointer is a \"kind of\" the identified class, the macro returns the appropriate pointer.","pos":[1895,2014]},{"content":"If it is not a legal cast, the macro returns <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[2015,2069],"source":" If it is not a legal cast, the macro returns **NULL**."},{"pos":[2111,2126],"content":"STATIC_DOWNCAST"},{"pos":[2130,2184],"content":"Casts <bpt id=\"p1\">*</bpt>pobject<ept id=\"p1\">*</ept> to a pointer to a <bpt id=\"p2\">*</bpt>class_name<ept id=\"p2\">*</ept> object.","source":"Casts *pobject* to a pointer to a *class_name* object."},{"content":"Parameters","pos":[2250,2260]},{"content":"class_name","pos":[2265,2275]},{"content":"The name of the class being cast to.","pos":[2280,2316]},{"content":"pobject","pos":[2324,2331]},{"content":"The pointer to be cast to a pointer to a <bpt id=\"p1\">*</bpt>class_name<ept id=\"p1\">*</ept> object.","pos":[2336,2397],"source":" The pointer to be cast to a pointer to a *class_name* object."},{"content":"Remarks","pos":[2407,2414]},{"content":"<bpt id=\"p1\">*</bpt>pobject<ept id=\"p1\">*</ept> must either be <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept>, or point to an object of a class which is derived directly, or indirectly, from <bpt id=\"p3\">*</bpt>class_name<ept id=\"p3\">*</ept>.","pos":[2418,2546],"source":"*pobject* must either be **NULL**, or point to an object of a class which is derived directly, or indirectly, from *class_name*."},{"content":"In builds of your application with the <bpt id=\"p1\">**</bpt>_DEBUG<ept id=\"p1\">**</ept> preprocessor symbol defined, the macro will <bpt id=\"p2\">**</bpt>ASSERT<ept id=\"p2\">**</ept> if <bpt id=\"p3\">*</bpt>pobject<ept id=\"p3\">*</ept> is not <bpt id=\"p4\">**</bpt>NULL<ept id=\"p4\">**</ept>, or if it points to an object that is not a \"kind of\" the class specified in the <bpt id=\"p5\">*</bpt>class_name<ept id=\"p5\">*</ept> parameter (see <bpt id=\"p6\">[</bpt>CObject::IsKindOf<ept id=\"p6\">](../../mfc/reference/cobject-class.md#cobject__iskindof)</ept>).","pos":[2547,2867],"source":" In builds of your application with the **_DEBUG** preprocessor symbol defined, the macro will **ASSERT** if *pobject* is not **NULL**, or if it points to an object that is not a \"kind of\" the class specified in the *class_name* parameter (see [CObject::IsKindOf](../../mfc/reference/cobject-class.md#cobject__iskindof))."},{"content":"In non- <bpt id=\"p1\">**</bpt>_DEBUG<ept id=\"p1\">**</ept> builds, the macro performs the cast without any type checking.","pos":[2868,2949],"source":" In non- **_DEBUG** builds, the macro performs the cast without any type checking."},{"pos":[2956,3321],"content":"The class specified in the <bpt id=\"p1\">*</bpt>class_name<ept id=\"p1\">*</ept> parameter must be derived from <ph id=\"ph1\">`CObject`</ph> and must use the <ph id=\"ph2\">`DECLARE_DYNAMIC`</ph> and <ph id=\"ph3\">`IMPLEMENT_DYNAMIC`</ph>, the <ph id=\"ph4\">`DECLARE_DYNCREATE`</ph> and <ph id=\"ph5\">`IMPLEMENT_DYNCREATE`</ph>, or the <ph id=\"ph6\">`DECLARE_SERIAL`</ph> and <ph id=\"ph7\">`IMPLEMENT_SERIAL`</ph> macros as explained in the article <bpt id=\"p2\">[</bpt>CObject Class: Deriving a Class from CObject<ept id=\"p2\">](../../mfc/deriving-a-class-from-cobject.md)</ept>.","source":"The class specified in the *class_name* parameter must be derived from `CObject` and must use the `DECLARE_DYNAMIC` and `IMPLEMENT_DYNAMIC`, the `DECLARE_DYNCREATE` and `IMPLEMENT_DYNCREATE`, or the `DECLARE_SERIAL` and `IMPLEMENT_SERIAL` macros as explained in the article [CObject Class: Deriving a Class from CObject](../../mfc/deriving-a-class-from-cobject.md)."},{"pos":[3328,3448],"content":"For example, you might cast a pointer to <ph id=\"ph1\">`CMyDoc`</ph>, called <ph id=\"ph2\">`pMyDoc`</ph>, to a pointer to <bpt id=\"p1\">**</bpt>CDocument<ept id=\"p1\">**</ept> using this expression:","source":"For example, you might cast a pointer to `CMyDoc`, called `pMyDoc`, to a pointer to **CDocument** using this expression:"},{"pos":[3466,3484],"content":"NVC_MFCDocView#197"},{"pos":[3560,3677],"content":"If <ph id=\"ph1\">`pMyDoc`</ph> does not point to an object derived directly or indirectly from <bpt id=\"p1\">**</bpt>CDocument<ept id=\"p1\">**</ept>, the macro will <bpt id=\"p2\">**</bpt>ASSERT<ept id=\"p2\">**</ept>.","source":"If `pMyDoc` does not point to an object derived directly or indirectly from **CDocument**, the macro will **ASSERT**."},{"content":"See Also","pos":[3686,3694]},{"content":"Macros and Globals","pos":[3699,3717]}],"content":"---\ntitle: \"Type Casting of MFC Class Objects | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mfc.macros.classes\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"macros, type casting\"\n  - \"pointers, type casting\"\n  - \"type casts\"\n  - \"casting types\"\n  - \"macros, casting pointers\"\nms.assetid: e138465e-c35f-4e84-b788-bd200ccf2f0e\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Type Casting of MFC Class Objects\nType casting macros provide a way to cast a given pointer to a pointer that points to an object of specific class, with or without checking that the cast is legal.  \n  \n The following table lists the MFC type casting macros.  \n  \n### Macros That Cast Pointers to MFC Class Objects  \n  \n|||  \n|-|-|  \n|[DYNAMIC_DOWNCAST](#dynamic_downcast)|Casts a pointer to a pointer to a class object while checking to see if the cast is legal.|  \n|[STATIC_DOWNCAST](#static_downcast)|Casts a pointer to an object from one class to a pointer of a related type. In a debug build, causes an **ASSERT** if the object is not a \"kind of\" the target type.|  \n  \n##  <a name=\"dynamic_downcast\"></a>  DYNAMIC_DOWNCAST  \n Provides a handy way to cast a pointer to a pointer to a class object while checking to see if the cast is legal.  \n  \n```   \nDYNAMIC_DOWNCAST(class, pointer)  \n```  \n  \n### Parameters  \n `class`  \n The name of a class.  \n  \n `pointer`  \n A pointer to be cast to a pointer to an object of type `class`.  \n  \n### Remarks  \n The macro will cast the `pointer` parameter to a pointer to an object of the `class` parameter's type.  \n  \n If the object referenced by the pointer is a \"kind of\" the identified class, the macro returns the appropriate pointer. If it is not a legal cast, the macro returns **NULL**.  \n  \n##  <a name=\"static_downcast\"></a>  STATIC_DOWNCAST  \n Casts *pobject* to a pointer to a *class_name* object.  \n  \n```   \nSTATIC_DOWNCAST(class_name, pobject)   \n```  \n  \n### Parameters  \n *class_name*  \n The name of the class being cast to.  \n  \n *pobject*  \n The pointer to be cast to a pointer to a *class_name* object.  \n  \n### Remarks  \n *pobject* must either be **NULL**, or point to an object of a class which is derived directly, or indirectly, from *class_name*. In builds of your application with the **_DEBUG** preprocessor symbol defined, the macro will **ASSERT** if *pobject* is not **NULL**, or if it points to an object that is not a \"kind of\" the class specified in the *class_name* parameter (see [CObject::IsKindOf](../../mfc/reference/cobject-class.md#cobject__iskindof)). In non- **_DEBUG** builds, the macro performs the cast without any type checking.  \n  \n The class specified in the *class_name* parameter must be derived from `CObject` and must use the `DECLARE_DYNAMIC` and `IMPLEMENT_DYNAMIC`, the `DECLARE_DYNCREATE` and `IMPLEMENT_DYNCREATE`, or the `DECLARE_SERIAL` and `IMPLEMENT_SERIAL` macros as explained in the article [CObject Class: Deriving a Class from CObject](../../mfc/deriving-a-class-from-cobject.md).  \n  \n For example, you might cast a pointer to `CMyDoc`, called `pMyDoc`, to a pointer to **CDocument** using this expression:  \n  \n [!code-cpp[NVC_MFCDocView#197](../../mfc/codesnippet/cpp/type-casting-of-mfc-class-objects_1.cpp)]  \n  \n If `pMyDoc` does not point to an object derived directly or indirectly from **CDocument**, the macro will **ASSERT**.  \n  \n## See Also  \n [Macros and Globals](../../mfc/reference/mfc-macros-and-globals.md)\n"}