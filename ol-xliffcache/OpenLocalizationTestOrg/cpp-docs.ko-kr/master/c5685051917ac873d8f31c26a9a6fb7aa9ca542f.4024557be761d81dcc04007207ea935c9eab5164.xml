{"nodes":[{"pos":[12,47],"content":"STL-CLR Containers | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"STL-CLR Containers | Microsoft Docs","pos":[0,35]}]},{"content":"STL/CLR Containers","pos":[604,622]},{"content":"The STL/CLR Library has the same containers that are found in the Standard C++ Library, but it runs within the managed environment of the .NET Framework.","pos":[623,776]},{"content":"If you are already familiar with the Standard Template Library (STL), STL/CLR is the best way to continue to use the skills that you have already developed while upgrading your code to target the common language runtime (CLR).","pos":[777,1003]},{"content":"This document provides an overview of the containers in STL/CLR, such as the requirements for container elements, the types of elements that you can insert into the containers, and ownership issues with the elements in the containers.","pos":[1010,1244]},{"content":"Where appropriate, differences between the native Standard Template Library and STL/CLR are mentioned.","pos":[1245,1347]},{"content":"Requirements for Container Elements","pos":[1356,1391]},{"content":"All elements inserted into STL containers must obey certain guidelines.","pos":[1395,1466]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Requirements for STL/CLR Container Elements<ept id=\"p1\">](../dotnet/requirements-for-stl-clr-container-elements.md)</ept>.","pos":[1467,1597],"source":" For more information, see [Requirements for STL/CLR Container Elements](../dotnet/requirements-for-stl-clr-container-elements.md)."},{"content":"Valid Container Elements","pos":[1606,1630]},{"content":"STL/CLR containers can hold one of two types of elements:","pos":[1634,1691]},{"content":"Handles to reference types.","pos":[1701,1728]},{"content":"Reference types.","pos":[1738,1754]},{"content":"Unboxed value types.","pos":[1764,1784]},{"content":"You cannot insert boxed value types into any of the STL/CLR containers.","pos":[1791,1862]},{"content":"Handles to Reference Types","pos":[1872,1898]},{"content":"You can insert a handle to a reference type into an STL/CLR container.","pos":[1902,1972]},{"content":"A handle in C++ that targets the CLR is analogous to a pointer in native C++.","pos":[1973,2050]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Handle to Object Operator (^)<ept id=\"p1\">](../windows/handle-to-object-operator-hat-cpp-component-extensions.md)</ept>.","pos":[2051,2179],"source":" For more information, see [Handle to Object Operator (^)](../windows/handle-to-object-operator-hat-cpp-component-extensions.md)."},{"content":"Example","pos":[2190,2197]},{"pos":[2201,2321],"content":"The following example shows how to insert a handle to an Employee object into a <bpt id=\"p1\">[</bpt>cliext::set<ept id=\"p1\">](../dotnet/set-stl-clr.md)</ept>.","source":"The following example shows how to insert a handle to an Employee object into a [cliext::set](../dotnet/set-stl-clr.md)."},{"content":"Reference Types","pos":[4545,4560]},{"content":"It is also possible to insert a reference type (rather than a handle to a reference type) into a STL/CLR container.","pos":[4564,4679]},{"content":"The main difference here is that when a container of reference types is deleted, the destructor is called for all elements inside that container.","pos":[4680,4825]},{"content":"In a container of handles to reference types, the destructors for these elements would not be called.","pos":[4826,4927]},{"content":"Example","pos":[4938,4945]},{"pos":[4949,5031],"content":"The following example shows how to insert an Employee object into a <ph id=\"ph1\">`cliext::set`</ph>.","source":"The following example shows how to insert an Employee object into a `cliext::set`."},{"content":"Unboxed Value Types","pos":[7224,7243]},{"content":"You can also insert an unboxed value type into an STL/CLR container.","pos":[7247,7315]},{"content":"An unboxed value type is a value type that has not been <bpt id=\"p1\">*</bpt>boxed<ept id=\"p1\">*</ept> into a reference type.","pos":[7316,7402],"source":" An unboxed value type is a value type that has not been *boxed* into a reference type."},{"content":"A value type element can be one of the standard value types, such as an <ph id=\"ph1\">`int`</ph>, or it can be a user-defined value type, such as a <ph id=\"ph2\">`value class`</ph>.","pos":[7409,7552],"source":"A value type element can be one of the standard value types, such as an `int`, or it can be a user-defined value type, such as a `value class`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](../windows/classes-and-structs-cpp-component-extensions.md)</ept>","pos":[7553,7660],"source":" For more information, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)"},{"content":"Example","pos":[7671,7678]},{"content":"The following example modifies the first example by making the Employee class a value type.","pos":[7682,7773]},{"content":"This value type is then inserted into a <ph id=\"ph1\">`cliext::set`</ph> just as in the first example.","pos":[7774,7857],"source":" This value type is then inserted into a `cliext::set` just as in the first example."},{"pos":[9301,9466],"content":"If you attempt to insert a handle to a value type into a container, <bpt id=\"p1\">[</bpt>Compiler Error C3225<ept id=\"p1\">](../error-messages/compiler-errors-2/compiler-error-c3225.md)</ept> is generated.","source":"If you attempt to insert a handle to a value type into a container, [Compiler Error C3225](../error-messages/compiler-errors-2/compiler-error-c3225.md) is generated."},{"content":"Performance and Memory Implications","pos":[9476,9511]},{"content":"You must consider several factors when determining whether to use handles to reference types or value types as container elements.","pos":[9515,9645]},{"content":"If you decide to use value types, remember that a copy of the element is made every time an element is inserted into the container.","pos":[9646,9777]},{"content":"For small objects, this should not be a problem, but if the objects being inserted are large, performance might suffer.","pos":[9778,9897]},{"content":"Also, if you are using value types, it is impossible to store one element in multiple containers at the same time because each container would have its own copy of the element.","pos":[9898,10074]},{"content":"If you decide to use handles to reference types instead, performance might increase because it is not necessary to make a copy of the element when it is inserted in the container.","pos":[10081,10260]},{"content":"Also, unlike with value types, the same element can exist in multiple containers.","pos":[10261,10342]},{"content":"However, if you decide to use handles, you must take care to ensure that the handle is valid and that the object it refers to has not been deleted elsewhere in the program.","pos":[10343,10515]},{"content":"Ownership Issues with Containers","pos":[10524,10556]},{"content":"Containers in STL/CLR work on value semantics.","pos":[10560,10606]},{"content":"Every time you insert an element into a container, a copy of that element is inserted.","pos":[10607,10693]},{"content":"If you want to get reference-like semantics, you can insert a handle to an object rather than the object itself.","pos":[10694,10806]},{"content":"When you call the clear or erase method of a container of handle objects, the objects that the handles refer to are not freed from memory.","pos":[10813,10951]},{"content":"You must either explicitly delete the object, or, because these objects reside on the managed heap, allow the garbage collector to free the memory once it determines that the object is no longer being used.","pos":[10952,11158]},{"content":"See Also","pos":[11167,11175]},{"content":"C++ Standard Library Reference","pos":[11180,11210]}],"content":"---\ntitle: \"STL-CLR Containers | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"STL/CLR, containers\"\n  - \"containers, STL/CLR\"\nms.assetid: 34ca8031-2041-46b9-aed9-29082d1972ea\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# STL/CLR Containers\nThe STL/CLR Library has the same containers that are found in the Standard C++ Library, but it runs within the managed environment of the .NET Framework. If you are already familiar with the Standard Template Library (STL), STL/CLR is the best way to continue to use the skills that you have already developed while upgrading your code to target the common language runtime (CLR).  \n  \n This document provides an overview of the containers in STL/CLR, such as the requirements for container elements, the types of elements that you can insert into the containers, and ownership issues with the elements in the containers. Where appropriate, differences between the native Standard Template Library and STL/CLR are mentioned.  \n  \n## Requirements for Container Elements  \n All elements inserted into STL containers must obey certain guidelines. For more information, see [Requirements for STL/CLR Container Elements](../dotnet/requirements-for-stl-clr-container-elements.md).  \n  \n## Valid Container Elements  \n STL/CLR containers can hold one of two types of elements:  \n  \n-   Handles to reference types.  \n  \n-   Reference types.  \n  \n-   Unboxed value types.  \n  \n You cannot insert boxed value types into any of the STL/CLR containers.  \n  \n### Handles to Reference Types  \n You can insert a handle to a reference type into an STL/CLR container. A handle in C++ that targets the CLR is analogous to a pointer in native C++. For more information, see [Handle to Object Operator (^)](../windows/handle-to-object-operator-hat-cpp-component-extensions.md).  \n  \n#### Example  \n The following example shows how to insert a handle to an Employee object into a [cliext::set](../dotnet/set-stl-clr.md).  \n  \n```  \n// cliext_container_valid_reference_handle.cpp  \n// compile with: /clr  \n  \n#include <cliext/set>  \n  \nusing namespace cliext;  \nusing namespace System;  \n  \nref class Employee  \n{  \npublic:  \n    // STL containers might require a public constructor, so it  \n    // is a good idea to define one.  \n    Employee() :  \n        name(nullptr),  \n        employeeNumber(0) { }  \n  \n    // All STL containers require a public copy constructor.  \n    Employee(const Employee% orig) :  \n        name(orig.name),  \n        employeeNumber(orig.employeeNumber) { }  \n  \n    // All STL containers require a public assignment operator.  \n    Employee% operator=(const Employee% orig)  \n    {  \n        if (this != %orig)  \n        {  \n            name = orig.name;  \n            employeeNumber = orig.employeeNumber;  \n        }  \n  \n        return *this;  \n    }  \n  \n    // All STL containers require a public destructor.  \n    ~Employee() { }  \n  \n    // Associative containers such as maps and sets  \n    // require a comparison operator to be defined  \n    // to determine proper ordering.  \n    bool operator<(const Employee^ rhs)  \n    {  \n        return (employeeNumber < rhs->employeeNumber);  \n    }  \n  \n    // The employee's name.  \n    property String^ Name  \n    {  \n        String^ get() { return name; }  \n        void set(String^ value) { name = value; }  \n    }  \n  \n    // The employee's employee number.  \n    property int EmployeeNumber  \n    {  \n        int get() { return employeeNumber; }  \n        void set(int value) { employeeNumber = value; }  \n    }  \n  \nprivate:  \n    String^ name;  \n    int employeeNumber;  \n};  \n  \nint main()  \n{  \n    // Create a new employee object.  \n    Employee^ empl1419 = gcnew Employee();  \n    empl1419->Name = L\"Darin Lockert\";  \n    empl1419->EmployeeNumber = 1419;  \n  \n    // Add the employee to the set of all employees.  \n    set<Employee^>^ emplSet = gcnew set<Employee^>();  \n    emplSet->insert(empl1419);  \n  \n    // List all employees of the company.  \n    for each (Employee^ empl in emplSet)  \n    {  \n        Console::WriteLine(\"Employee Number {0}: {1}\",  \n            empl->EmployeeNumber, empl->Name);  \n    }  \n  \n    return 0;  \n}  \n```  \n  \n### Reference Types  \n It is also possible to insert a reference type (rather than a handle to a reference type) into a STL/CLR container. The main difference here is that when a container of reference types is deleted, the destructor is called for all elements inside that container. In a container of handles to reference types, the destructors for these elements would not be called.  \n  \n#### Example  \n The following example shows how to insert an Employee object into a `cliext::set`.  \n  \n```  \n// cliext_container_valid_reference.cpp  \n// compile with: /clr  \n  \n#include <cliext/set>  \n  \nusing namespace cliext;  \nusing namespace System;  \n  \nref class Employee  \n{  \npublic:  \n    // STL containers might require a public constructor, so it  \n    // is a good idea to define one.  \n    Employee() :  \n        name(nullptr),  \n        employeeNumber(0) { }  \n  \n    // All STL containers require a public copy constructor.  \n    Employee(const Employee% orig) :  \n        name(orig.name),  \n        employeeNumber(orig.employeeNumber) { }  \n  \n    // All STL containers require a public assignment operator.  \n    Employee% operator=(const Employee% orig)  \n    {  \n        if (this != %orig)  \n        {  \n            name = orig.name;  \n            employeeNumber = orig.employeeNumber;  \n        }  \n  \n        return *this;  \n    }  \n  \n    // All STL containers require a public destructor.  \n    ~Employee() { }  \n  \n    // Associative containers such as maps and sets  \n    // require a comparison operator to be defined  \n    // to determine proper ordering.  \n    bool operator<(const Employee^ rhs)  \n    {  \n        return (employeeNumber < rhs->employeeNumber);  \n    }  \n  \n    // The employee's name.  \n    property String^ Name  \n    {  \n        String^ get() { return name; }  \n        void set(String^ value) { name = value; }  \n    }  \n  \n    // The employee's employee number.  \n    property int EmployeeNumber  \n    {  \n        int get() { return employeeNumber; }  \n        void set(int value) { employeeNumber = value; }  \n    }  \n  \nprivate:  \n    String^ name;  \n    int employeeNumber;  \n};  \n  \nint main()  \n{  \n    // Create a new employee object.  \n    Employee empl1419;  \n    empl1419.Name = L\"Darin Lockert\";  \n    empl1419.EmployeeNumber = 1419;  \n  \n    // Add the employee to the set of all employees.  \n    set<Employee>^ emplSet = gcnew set<Employee>();  \n    emplSet->insert(empl1419);  \n  \n    // List all employees of the company.  \n    for each (Employee^ empl in emplSet)  \n    {  \n        Console::WriteLine(\"Employee Number {0}: {1}\",  \n            empl->EmployeeNumber, empl->Name);  \n    }  \n  \n    return 0;  \n}  \n```  \n  \n### Unboxed Value Types  \n You can also insert an unboxed value type into an STL/CLR container. An unboxed value type is a value type that has not been *boxed* into a reference type.  \n  \n A value type element can be one of the standard value types, such as an `int`, or it can be a user-defined value type, such as a `value class`. For more information, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)  \n  \n#### Example  \n The following example modifies the first example by making the Employee class a value type. This value type is then inserted into a `cliext::set` just as in the first example.  \n  \n```  \n// cliext_container_valid_valuetype.cpp  \n// compile with: /clr  \n  \n#include <cliext/set>  \n  \nusing namespace cliext;  \nusing namespace System;  \n  \nvalue class Employee  \n{  \npublic:  \n    // Associative containers such as maps and sets  \n    // require a comparison operator to be defined  \n    // to determine proper ordering.  \n    bool operator<(const Employee^ rhs)  \n    {  \n        return (employeeNumber < rhs->employeeNumber);  \n    }  \n  \n    // The employee's name.  \n    property String^ Name  \n    {  \n        String^ get() { return name; }  \n        void set(String^ value) { name = value; }  \n    }  \n  \n    // The employee's employee number.  \n    property int EmployeeNumber  \n    {  \n        int get() { return employeeNumber; }  \n        void set(int value) { employeeNumber = value; }  \n    }  \n  \nprivate:  \n    String^ name;  \n    int employeeNumber;  \n};  \n  \nint main()  \n{  \n    // Create a new employee object.  \n    Employee empl1419;  \n    empl1419.Name = L\"Darin Lockert\";  \n    empl1419.EmployeeNumber = 1419;  \n  \n    // Add the employee to the set of all employees.  \n    set<Employee>^ emplSet = gcnew set<Employee>();  \n    emplSet->insert(empl1419);  \n  \n    // List all employees of the company.  \n    for each (Employee empl in emplSet)  \n    {  \n        Console::WriteLine(\"Employee Number {0}: {1}\",  \n            empl.EmployeeNumber, empl.Name);  \n    }  \n  \n    return 0;  \n}  \n```  \n  \n If you attempt to insert a handle to a value type into a container, [Compiler Error C3225](../error-messages/compiler-errors-2/compiler-error-c3225.md) is generated.  \n  \n### Performance and Memory Implications  \n You must consider several factors when determining whether to use handles to reference types or value types as container elements. If you decide to use value types, remember that a copy of the element is made every time an element is inserted into the container. For small objects, this should not be a problem, but if the objects being inserted are large, performance might suffer. Also, if you are using value types, it is impossible to store one element in multiple containers at the same time because each container would have its own copy of the element.  \n  \n If you decide to use handles to reference types instead, performance might increase because it is not necessary to make a copy of the element when it is inserted in the container. Also, unlike with value types, the same element can exist in multiple containers. However, if you decide to use handles, you must take care to ensure that the handle is valid and that the object it refers to has not been deleted elsewhere in the program.  \n  \n## Ownership Issues with Containers  \n Containers in STL/CLR work on value semantics. Every time you insert an element into a container, a copy of that element is inserted. If you want to get reference-like semantics, you can insert a handle to an object rather than the object itself.  \n  \n When you call the clear or erase method of a container of handle objects, the objects that the handles refer to are not freed from memory. You must either explicitly delete the object, or, because these objects reside on the managed heap, allow the garbage collector to free the memory once it determines that the object is no longer being used.  \n  \n## See Also  \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)"}