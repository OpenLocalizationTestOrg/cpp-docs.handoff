{"nodes":[{"pos":[12,42],"content":"complex Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"complex Class | Microsoft Docs","pos":[0,30]}]},{"content":"complex Class","pos":[652,665]},{"pos":[666,844],"content":"The template class describes an object that stores two objects of type <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>, one that represents the real part of a complex number and one that represents the imaginary part.","source":"The template class describes an object that stores two objects of type **Type**, one that represents the real part of a complex number and one that represents the imaginary part."},{"content":"Syntax","pos":[853,859]},{"content":"Remarks","pos":[928,935]},{"pos":[939,967],"content":"An object of class <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>:","source":"An object of class **Type**:"},{"content":"Has a public default constructor, destructor, copy constructor, and assignment operator with conventional behavior.","pos":[977,1092]},{"content":"Can be assigned integer or floating-point values, or type cast to such values with conventional behavior.","pos":[1102,1207]},{"content":"Defines the arithmetic operators and math functions, as needed, that are defined for the floating-point types with conventional behavior.","pos":[1217,1354]},{"content":"In particular, no subtle differences may exist between copy construction and default construction followed by assignment.","pos":[1361,1482]},{"content":"None of the operations on objects of class <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> may throw exceptions.","pos":[1483,1556],"source":" None of the operations on objects of class **Type** may throw exceptions."},{"content":"Explicit specializations of template class complex exist for the three floating-point types.","pos":[1563,1655]},{"content":"In this implementation, a value of any other type <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> is typecast to <bpt id=\"p2\">**</bpt>double<ept id=\"p2\">**</ept> for actual calculations, with the <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept> result assigned back to the stored object of type <bpt id=\"p4\">**</bpt>Type<ept id=\"p4\">**</ept>","pos":[1656,1844],"source":" In this implementation, a value of any other type **Type** is typecast to **double** for actual calculations, with the **double** result assigned back to the stored object of type **Type**"},{"content":"Constructors","pos":[1857,1869]},{"content":"complex","pos":[1891,1898]},{"content":"Constructs a complex number with specified real and imaginary parts or as a copy of some other complex number.","pos":[1919,2029]},{"content":"Typedefs","pos":[2040,2048]},{"content":"value_type","pos":[2070,2080]},{"content":"A type that represents the data type used to represent the real and imaginary parts of a complex number.","pos":[2104,2208]},{"content":"Member Functions","pos":[2219,2235]},{"content":"imag","pos":[2257,2261]},{"content":"Extracts the imaginary component of a complex number.","pos":[2279,2332]},{"content":"real","pos":[2338,2342]},{"content":"Extracts the real component of a complex number.","pos":[2360,2408]},{"content":"Operators","pos":[2419,2428]},{"content":"operator*=","pos":[2450,2460]},{"content":"Multiplies a target complex number by a factor, which may be complex or be the same type as are the real and imaginary parts of the complex number.","pos":[2490,2637]},{"content":"operator+=","pos":[2643,2653]},{"content":"Adds a number to a target complex number, where the number added may be complex or of the same type as are the real and imaginary parts of the complex number to which it is added.","pos":[2682,2861]},{"content":"operator-=","pos":[2867,2877]},{"content":"Subtracts a number from a target complex number, where the number subtracted may be complex or of the same type as are the real and imaginary parts of the complex number to which it is added.","pos":[2903,3094]},{"content":"operator/=","pos":[3100,3110]},{"content":"Divides a target complex number by a divisor, which may be complex or be the same type as are the real and imaginary parts of the complex number.","pos":[3136,3281]},{"content":"operator=","pos":[3287,3296]},{"content":"Assigns a number to a target complex number, where the number assigned may be complex or of the same type as are the real and imaginary parts of the complex number to which it is being assigned.","pos":[3321,3515]},{"content":"Requirements","pos":[3525,3537]},{"pos":[3541,3563],"content":"<bpt id=\"p1\">**</bpt>Header<ept id=\"p1\">**</ept>: <ph id=\"ph1\">\\&lt;</ph>complex&gt;","source":"**Header**: \\<complex>"},{"pos":[3570,3588],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[3631,3647],"content":"complex::complex"},{"content":"Constructs a complex number with specified real and imaginary parts or as a copy of some other complex number.","pos":[3651,3761]},{"content":"Parameters","pos":[3968,3978]},{"content":"The value of the real part used to initialize the complex number being constructed.","pos":[3996,4079]},{"content":"The value of the imaginary part used to initialize the complex number being constructed.","pos":[4100,4188]},{"content":"The complex number whose real and imaginary parts are used to initialize the complex number being constructed.","pos":[4212,4322]},{"content":"Remarks","pos":[4332,4339]},{"content":"The first constructor initializes the stored real part to _ <bpt id=\"p1\">*</bpt>RealVal<ept id=\"p1\">*</ept> and the stored imaginary part to <ph id=\"ph1\">\\_</ph> <bpt id=\"p2\">*</bpt>Imagval<ept id=\"p2\">*</ept>.","pos":[4343,4459],"source":"The first constructor initializes the stored real part to _ *RealVal* and the stored imaginary part to \\_ *Imagval*."},{"content":"The second constructor initializes the stored real part to <ph id=\"ph1\">` complexNum`</ph><bpt id=\"p1\">**</bpt>.real<ept id=\"p1\">**</ept>() and the stored imaginary part to <ph id=\"ph2\">` complexNum`</ph><bpt id=\"p2\">**</bpt>.imag<ept id=\"p2\">**</ept>().","pos":[4460,4602],"source":" The second constructor initializes the stored real part to ` complexNum`**.real**() and the stored imaginary part to ` complexNum`**.imag**()."},{"content":"In this implementation, if a translator does not support member template functions, the template:","pos":[4609,4706]},{"content":"is replaced with:","pos":[4791,4808]},{"content":"which is the copy constructor.","pos":[4863,4893]},{"content":"Example","pos":[4903,4910]},{"pos":[6268,6281],"content":"complex::imag"},{"content":"Extracts the imaginary component of a complex number.","pos":[6285,6338]},{"content":"Parameters","pos":[6406,6416]},{"content":"A complex number whose imaginary value is to be extracted.","pos":[6432,6490]},{"content":"Return Value","pos":[6500,6512]},{"content":"The imaginary part of the complex number.","pos":[6516,6557]},{"content":"Remarks","pos":[6567,6574]},{"pos":[6578,6661],"content":"For a complex number <bpt id=\"p1\">*</bpt>a + bi<ept id=\"p1\">*</ept>, the imaginary part or component is <bpt id=\"p2\">*</bpt>Im(a + bi) = b.<ept id=\"p2\">*</ept>","source":"For a complex number *a + bi*, the imaginary part or component is *Im(a + bi) = b.*"},{"content":"Example","pos":[6671,6678]},{"pos":[7374,7393],"content":"complex::operator*="},{"content":"Multiplies a target complex number by a factor, which may be complex or be the same type as are the real and imaginary parts of the complex number.","pos":[7397,7544]},{"content":"Parameters","pos":[7747,7757]},{"content":"A complex number or a number that is of the same type as the parameter of the target complex number.","pos":[7773,7873]},{"content":"Return Value","pos":[7883,7895]},{"content":"A complex number that has been multiplied by the number specified as a parameter.","pos":[7899,7980]},{"content":"Remarks","pos":[7990,7997]},{"content":"The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.","pos":[8001,8140]},{"content":"Example","pos":[8150,8157]},{"pos":[10224,10243],"content":"complex::operator+="},{"content":"Adds a number to a target complex number, where the number added may be complex or of the same type as are the real and imaginary parts of the complex number to which it is added.","pos":[10247,10426]},{"content":"Parameters","pos":[10635,10645]},{"content":"A complex number or a number that is of the same type as the parameter of the target complex number.","pos":[10661,10761]},{"content":"Return Value","pos":[10771,10783]},{"content":"A complex number that has had the number specified as a parameter added.","pos":[10787,10859]},{"content":"Remarks","pos":[10869,10876]},{"content":"The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.","pos":[10880,11019]},{"content":"Example","pos":[11029,11036]},{"pos":[13820,13839],"content":"complex::operator-="},{"content":"Subtracts a number from a target complex number, where the number subtracted may be complex or of the same type as are the real and imaginary parts of the complex number to which it is added.","pos":[13843,14034]},{"content":"Parameters","pos":[14257,14267]},{"content":"A complex number to be subtracted from the target complex number.","pos":[14288,14353]},{"content":"A real number to be subtracted from the target complex number.","pos":[14375,14437]},{"content":"Return Value","pos":[14447,14459]},{"content":"A complex number that has had the number specified as a parameter subtracted from it.","pos":[14463,14548]},{"content":"Remarks","pos":[14558,14565]},{"content":"The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.","pos":[14569,14708]},{"content":"Example","pos":[14718,14725]},{"pos":[17590,17609],"content":"complex::operator/="},{"content":"Divides a target complex number by a divisor, which may be complex or be the same type as are the real and imaginary parts of the complex number.","pos":[17613,17758]},{"content":"Parameters","pos":[17981,17991]},{"content":"A complex number to be subtracted from the target complex number.","pos":[18012,18077]},{"content":"A real number to be subtracted from the target complex number.","pos":[18099,18161]},{"content":"Return Value","pos":[18171,18183]},{"content":"A complex number that has been divided by the number specified as a parameter.","pos":[18187,18265]},{"content":"Remarks","pos":[18275,18282]},{"content":"The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.","pos":[18286,18425]},{"content":"Example","pos":[18435,18442]},{"pos":[21236,21254],"content":"complex::operator="},{"content":"Assigns a number to a target complex number, where the number assigned may be complex or of the same type as are the real and imaginary parts of the complex number to which it is being assigned.","pos":[21258,21452]},{"content":"Parameters","pos":[21603,21613]},{"content":"A complex number or a number that is of the same type as the parameter of the target complex number.","pos":[21629,21729]},{"content":"Return Value","pos":[21739,21751]},{"content":"A complex number that has been assigned the number specified as a parameter.","pos":[21755,21831]},{"content":"Remarks","pos":[21841,21848]},{"content":"The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.","pos":[21852,21991]},{"content":"Example","pos":[22001,22008]},{"pos":[23784,23797],"content":"complex::real"},{"content":"Gets or sets the real component of a complex number.","pos":[23801,23853]},{"content":"Parameters","pos":[23931,23941]},{"content":"A complex number whose real value is to be extracted.","pos":[23957,24010]},{"content":"Return Value","pos":[24020,24032]},{"content":"The real part of the complex number.","pos":[24036,24072]},{"content":"Remarks","pos":[24082,24089]},{"pos":[24093,24171],"content":"For a complex number <bpt id=\"p1\">*</bpt>a + bi<ept id=\"p1\">*</ept>, the real part or component is <bpt id=\"p2\">*</bpt>Re(a + bi) = a.<ept id=\"p2\">*</ept>","source":"For a complex number *a + bi*, the real part or component is *Re(a + bi) = a.*"},{"content":"Example","pos":[24181,24188]},{"pos":[24884,24903],"content":"complex::value_type"},{"content":"A type that represents the data type used to represent the real and imaginary parts of a complex number.","pos":[24907,25011]},{"content":"Remarks","pos":[25065,25072]},{"pos":[25089,25152],"content":"is a synonym for the class complex <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> template parameter.","source":" is a synonym for the class complex **Type** template parameter."},{"content":"Example","pos":[25162,25169]},{"content":"See Also","pos":[25662,25670]},{"content":"complex Members","pos":[25675,25690]},{"content":"Thread Safety in the C++ Standard Library","pos":[25767,25808]}],"content":"---\ntitle: \"complex Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"complex\"\n  - \"std::complex\"\n  - \"std.complex\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"complex numbers\"\n  - \"complex class\"\nms.assetid: d6492e1c-5eba-4bc5-835b-2a88001a5868\ncaps.latest.revision: 18\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# complex Class\nThe template class describes an object that stores two objects of type **Type**, one that represents the real part of a complex number and one that represents the imaginary part.  \n  \n## Syntax  \n  \n```  \n \ntemplate <class   \nType>  \nclass complex  \n```  \n  \n## Remarks  \n An object of class **Type**:  \n  \n-   Has a public default constructor, destructor, copy constructor, and assignment operator with conventional behavior.  \n  \n-   Can be assigned integer or floating-point values, or type cast to such values with conventional behavior.  \n  \n-   Defines the arithmetic operators and math functions, as needed, that are defined for the floating-point types with conventional behavior.  \n  \n In particular, no subtle differences may exist between copy construction and default construction followed by assignment. None of the operations on objects of class **Type** may throw exceptions.  \n  \n Explicit specializations of template class complex exist for the three floating-point types. In this implementation, a value of any other type **Type** is typecast to **double** for actual calculations, with the **double** result assigned back to the stored object of type **Type**`.`  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[complex](#complex__complex)|Constructs a complex number with specified real and imaginary parts or as a copy of some other complex number.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[value_type](#complex__value_type)|A type that represents the data type used to represent the real and imaginary parts of a complex number.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[imag](#complex__imag)|Extracts the imaginary component of a complex number.|  \n|[real](#complex__real)|Extracts the real component of a complex number.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|[operator*=](#complex__operator_star_eq)|Multiplies a target complex number by a factor, which may be complex or be the same type as are the real and imaginary parts of the complex number.|  \n|[operator+=](#complex__operator_add_eq)|Adds a number to a target complex number, where the number added may be complex or of the same type as are the real and imaginary parts of the complex number to which it is added.|  \n|[operator-=](#complex__operator-_eq)|Subtracts a number from a target complex number, where the number subtracted may be complex or of the same type as are the real and imaginary parts of the complex number to which it is added.|  \n|[operator/=](#complex__operator__eq)|Divides a target complex number by a divisor, which may be complex or be the same type as are the real and imaginary parts of the complex number.|  \n|[operator=](#complex__operator_eq)|Assigns a number to a target complex number, where the number assigned may be complex or of the same type as are the real and imaginary parts of the complex number to which it is being assigned.|  \n  \n## Requirements  \n **Header**: \\<complex>  \n  \n **Namespace:** std  \n  \n##  <a name=\"complex__complex\"></a>  complex::complex  \n Constructs a complex number with specified real and imaginary parts or as a copy of some other complex number.  \n  \n```  \nconstexpr complex(\n    const T& \n    _RealVal = 0  ,   \n    const T& \n    _ImagVal = 0);\n\n    template <class Other>  \nconstexpr complex(\n    const complex<Other>& \n    complexNum);\n```  \n  \n### Parameters  \n `_RealVal`  \n The value of the real part used to initialize the complex number being constructed.  \n  \n `_ImagVal`  \n The value of the imaginary part used to initialize the complex number being constructed.  \n  \n ` complexNum`  \n The complex number whose real and imaginary parts are used to initialize the complex number being constructed.  \n  \n### Remarks  \n The first constructor initializes the stored real part to _ *RealVal* and the stored imaginary part to \\_ *Imagval*. The second constructor initializes the stored real part to ` complexNum`**.real**() and the stored imaginary part to ` complexNum`**.imag**().  \n  \n In this implementation, if a translator does not support member template functions, the template:  \n  \n```  \ntemplate <class Other>  \ncomplex(const complex<Other>& right);\n```  \n  \n is replaced with:  \n  \n```  \n \ncomplex(const complex& right);\n```  \n  \n which is the copy constructor.  \n  \n### Example  \n  \n```cpp  \n// complex_complex.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;   \n  \n   // The first constructor specifies real & imaginary parts  \n   complex <double> c1 ( 4.0 , 5.0 );  \n   cout << \"Specifying initial real & imaginary parts,\"  \n        << \"c1 = \" << c1 << endl;   \n  \n   // The second constructor initializes values of the real &  \n   // imaginary parts using those of another complex number  \n   complex <double> c2 ( c1 );  \n   cout << \"Initializing with the real and imaginary parts of c1,\"  \n        << \" c2 = \" << c2 << endl;   \n  \n   // Complex numbers can be initialized in polar form  \n   // but will be stored in Cartesian form  \n   complex <double> c3 ( polar ( sqrt( (double)8 ) , pi / 4 ) );  \n   cout << \"c3 = polar ( sqrt ( 8 ) , pi / 4 ) = \" << c3 << endl;   \n  \n   // The modulus and argument of a complex number can be recovered  \n   double absc3 = abs ( c3 );  \n   double argc3 = arg ( c3 );  \n   cout << \"The modulus of c3 is recovered from c3 using: abs ( c3 ) = \"  \n        << absc3 << endl;  \n   cout << \"Argument of c3 is recovered from c3 using:\\n arg ( c3 ) = \"  \n        << argc3 << \" radians, which is \" << argc3 * 180 / pi  \n        << \" degrees.\" << endl;  \n}  \n```  \n  \n##  <a name=\"complex__imag\"></a>  complex::imag  \n Extracts the imaginary component of a complex number.  \n  \n```  \nT imag() const;\n\n \nT imag(const T& right);\n```  \n  \n### Parameters  \n ` right`  \n A complex number whose imaginary value is to be extracted.  \n  \n### Return Value  \n The imaginary part of the complex number.  \n  \n### Remarks  \n For a complex number *a + bi*, the imaginary part or component is *Im(a + bi) = b.*  \n  \n### Example  \n  \n```cpp  \n// complex_imag.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   complex <double> c1 ( 4.0 , 3.0 );  \n   cout << \"The complex number c1 = \" << c1 << endl;  \n  \n   double dr1 = c1.real ( );  \n   cout << \"The real part of c1 is c1.real ( ) = \"  \n        << dr1 << \".\" << endl;  \n  \n   double di1 = c1.imag ( );  \n   cout << \"The imaginary part of c1 is c1.imag ( ) = \"  \n        << di1 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe complex number c1 = (4,3)  \nThe real part of c1 is c1.real ( ) = 4.  \nThe imaginary part of c1 is c1.imag ( ) = 3.  \n```  \n  \n##  <a name=\"complex__operator_star_eq\"></a>  complex::operator*=  \n Multiplies a target complex number by a factor, which may be complex or be the same type as are the real and imaginary parts of the complex number.  \n  \n```  \ntemplate <class Other>  \ncomplex& operator*=(const complex<Other>& right);\n\ncomplex<Type>& operator*=(const Type& right);\n\ncomplex<Type>& operator*=(const complex<Type>& right);\n```  \n  \n### Parameters  \n ` right`  \n A complex number or a number that is of the same type as the parameter of the target complex number.  \n  \n### Return Value  \n A complex number that has been multiplied by the number specified as a parameter.  \n  \n### Remarks  \n The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.  \n  \n### Example  \n  \n```cpp  \n// complex_op_me.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Example of the first member function  \n   // type complex<double> multiplied by type complex<double>  \n   complex <double> cl1 ( polar ( 3.0 , pi / 6 ) );  \n   complex <double> cr1 ( polar ( 2.0 , pi / 3 ) );  \n   cout << \"The left-side complex number is cl1 = \" << cl1 << endl;  \n   cout << \"The right-side complex number is cr1 = \" << cr1 << endl;  \n  \n   complex <double> cs1 = cl1 * cr1;  \n   cout << \"Quotient of two complex numbers is: cs1 = cl1 * cr1 = \"  \n        << cs1 << endl;  \n  \n   // This is equivalent to the following operation  \n   cl1 *= cr1;  \n   cout << \"Quotient of two complex numbers is also: cl1 *= cr1 = \"  \n        << cl1 << endl;  \n  \n   double abscl1 = abs ( cl1 );  \n   double argcl1 = arg ( cl1 );  \n   cout << \"The modulus of cl1 is: \" << abscl1 << endl;  \n   cout << \"The argument of cl1 is: \"<< argcl1 << \" radians, which is \"   \n        << argcl1 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Example of the second member function  \n   // type complex<double> multiplied by type double  \n   complex <double> cl2 ( polar ( 3.0 , pi / 6 ) );  \n   double cr2 = 5.0;  \n   cout << \"The left-side complex number is cl2 = \" << cl2 << endl;  \n   cout << \"The right-side complex number is cr2 = \" << cr2 << endl;  \n  \n   complex <double> cs2 = cl2 * cr2;  \n   cout << \"Quotient of two complex numbers is: cs2 = cl2 * cr2 = \"   \n        << cs2 << endl;  \n  \n   // This is equivalent to the following operation  \n   cl2 *= cr2;  \n   cout << \"Quotient of two complex numbers is also: cl2 *= cr2 = \"  \n        << cl2 << endl;  \n  \n   double abscl2 = abs ( cl2 );  \n   double argcl2 = arg ( cl2 );  \n   cout << \"The modulus of cl2 is: \" << abscl2 << endl;  \n   cout << \"The argument of cl2 is: \"<< argcl2 << \" radians, which is \"   \n        << argcl2 * 180 / pi << \" degrees.\" << endl;  \n}  \n```  \n  \n##  <a name=\"complex__operator_add_eq\"></a>  complex::operator+=  \n Adds a number to a target complex number, where the number added may be complex or of the same type as are the real and imaginary parts of the complex number to which it is added.  \n  \n```  \ntemplate <class Other>  \ncomplex<Type>& operator+=(const complex<Other>& right);\n\ncomplex<Type>& operator+=(const Type& right);\n\ncomplex<Type>& operator+=(const complex<Type>& right);\n```  \n  \n### Parameters  \n ` right`  \n A complex number or a number that is of the same type as the parameter of the target complex number.  \n  \n### Return Value  \n A complex number that has had the number specified as a parameter added.  \n  \n### Remarks  \n The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.  \n  \n### Example  \n  \n```cpp  \n// complex_op_pe.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Example of the first member function  \n   // type complex<double> added to type complex<double>  \n   complex <double> cl1 ( 3.0 , 4.0 );  \n   complex <double> cr1 ( 2.0 , -1.0 );  \n   cout << \"The left-side complex number is cl1 = \" << cl1 << endl;  \n   cout << \"The right-side complex number is cr1 = \" << cr1 << endl;  \n  \n   complex <double> cs1 = cl1 + cr1;  \n   cout << \"The sum of the two complex numbers is: cs1 = cl1 + cr1 = \"  \n        << cs1 << endl;  \n  \n   // This is equivalent to the following operation  \n   cl1 += cr1;  \n   cout << \"The complex number cr1 added to the complex number cl1 is:\"  \n        << \"\\n cl1 += cr1 = \" << cl1 << endl;  \n  \n   double abscl1 = abs ( cl1 );  \n   double argcl1 = arg ( cl1 );  \n   cout << \"The modulus of cl1 is: \" << abscl1 << endl;  \n   cout << \"The argument of cl1 is: \"<< argcl1 << \" radians, which is \"   \n        << argcl1 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Example of the second member function  \n   // type double added to type complex<double>  \n   complex <double> cl2 ( -2 , 4 );  \n   double cr2 =5.0;  \n   cout << \"The left-side complex number is cl2 = \" << cl2 << endl;  \n   cout << \"The right-side complex number is cr2 = \" << cr2 << endl;  \n  \n   complex <double> cs2 = cl2 + cr2;  \n   cout << \"The sum of the two complex numbers is: cs2 = cl2 + cr2 = \"   \n        << cs2 << endl;  \n  \n   // This is equivalent to the following operation  \n   cl2 += cr2;  \n   cout << \"The complex number cr2 added to the complex number cl2 is:\"  \n        << \"\\n cl2 += cr2 = \" << cl2 << endl;  \n  \n   double abscl2 = abs ( cl2 );  \n   double argcl2 = arg ( cl2 );  \n   cout << \"The modulus of cl2 is: \" << abscl2 << endl;  \n   cout << \"The argument of cl2 is: \"<< argcl2 << \" radians, which is \"   \n        << argcl2 * 180 / pi << \" degrees.\" << endl << endl;  \n}  \n```  \n  \n```Output  \nThe left-side complex number is cl1 = (3,4)  \nThe right-side complex number is cr1 = (2,-1)  \nThe sum of the two complex numbers is: cs1 = cl1 + cr1 = (5,3)  \nThe complex number cr1 added to the complex number cl1 is:  \n cl1 += cr1 = (5,3)  \nThe modulus of cl1 is: 5.83095  \nThe argument of cl1 is: 0.54042 radians, which is 30.9638 degrees.  \n  \nThe left-side complex number is cl2 = (-2,4)  \nThe right-side complex number is cr2 = 5  \nThe sum of the two complex numbers is: cs2 = cl2 + cr2 = (3,4)  \nThe complex number cr2 added to the complex number cl2 is:  \n cl2 += cr2 = (3,4)  \nThe modulus of cl2 is: 5  \nThe argument of cl2 is: 0.927295 radians, which is 53.1301 degrees.  \n```  \n  \n##  <a name=\"complex__operator-_eq\"></a>  complex::operator-=  \n Subtracts a number from a target complex number, where the number subtracted may be complex or of the same type as are the real and imaginary parts of the complex number to which it is added.  \n  \n```  \ntemplate <class Other>  \ncomplex<Type>& operator-=(const complex<Other>& complexNum);\n\ncomplex<Type>& operator-=(const Type& _RealPart);\n\ncomplex<Type>& operator-=(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n A complex number to be subtracted from the target complex number.  \n  \n `_RealPart`  \n A real number to be subtracted from the target complex number.  \n  \n### Return Value  \n A complex number that has had the number specified as a parameter subtracted from it.  \n  \n### Remarks  \n The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.  \n  \n### Example  \n  \n```cpp  \n// complex_op_se.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Example of the first member function  \n   // type complex<double> subtracted from type complex<double>  \n   complex <double> cl1 ( 3.0 , 4.0 );  \n   complex <double> cr1 ( 2.0 , -1.0 );  \n   cout << \"The left-side complex number is cl1 = \" << cl1 << endl;  \n   cout << \"The right-side complex number is cr1 = \" << cr1 << endl;  \n  \n   complex <double> cs1 = cl1 - cr1;  \n   cout << \"The difference between the two complex numbers is:\"  \n        << \"\\n cs1 = cl1 - cr1 = \" << cs1 << endl;  \n  \n   // This is equivalent to the following operation  \n   cl1 -= cr1;  \n   cout << \"Complex number cr1 subtracted from complex number cl1 is:\"  \n        << \"\\n cl1 -= cr1 = \" << cl1 << endl;  \n  \n   double abscl1 = abs ( cl1 );  \n   double argcl1 = arg ( cl1 );  \n   cout << \"The modulus of cl1 is: \" << abscl1 << endl;  \n   cout << \"The argument of cl1 is: \"<< argcl1 << \" radians, which is \"   \n        << argcl1 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Example of the second member function  \n   // type double subtracted from type complex<double>  \n   complex <double> cl2 ( 2.0 , 4.0 );  \n   double cr2 = 5.0;  \n   cout << \"The left-side complex number is cl2 = \" << cl2 << endl;  \n   cout << \"The right-side complex number is cr2 = \" << cr2 << endl;  \n  \n   complex <double> cs2 = cl2 - cr2;  \n   cout << \"The difference between the two complex numbers is:\"  \n        << \"\\n cs2 = cl2 - cr2 = \" << cs2 << endl;  \n  \n   // This is equivalent to the following operation  \n   cl2  -= cr2;  \n   cout << \"Complex number cr2 subtracted from complex number cl2 is:\"  \n        << \"\\n cl2 -= cr2 = \" << cl2 << endl;  \n  \n   double abscl2 = abs ( cl2 );  \n   double argcl2 = arg ( cl2 );  \n   cout << \"The modulus of cl2 is: \" << abscl2 << endl;  \n   cout << \"The argument of cl2 is: \"<< argcl2 << \" radians, which is \"   \n        << argcl2 * 180 / pi << \" degrees.\" << endl << endl;  \n}  \n```  \n  \n```Output  \nThe left-side complex number is cl1 = (3,4)  \nThe right-side complex number is cr1 = (2,-1)  \nThe difference between the two complex numbers is:  \n cs1 = cl1 - cr1 = (1,5)  \nComplex number cr1 subtracted from complex number cl1 is:  \n cl1 -= cr1 = (1,5)  \nThe modulus of cl1 is: 5.09902  \nThe argument of cl1 is: 1.3734 radians, which is 78.6901 degrees.  \n  \nThe left-side complex number is cl2 = (2,4)  \nThe right-side complex number is cr2 = 5  \nThe difference between the two complex numbers is:  \n cs2 = cl2 - cr2 = (-3,4)  \nComplex number cr2 subtracted from complex number cl2 is:  \n cl2 -= cr2 = (-3,4)  \nThe modulus of cl2 is: 5  \nThe argument of cl2 is: 2.2143 radians, which is 126.87 degrees.  \n```  \n  \n##  <a name=\"complex__operator__eq\"></a>  complex::operator/=  \n Divides a target complex number by a divisor, which may be complex or be the same type as are the real and imaginary parts of the complex number.  \n  \n```  \ntemplate <class Other>  \ncomplex<Type>& operator/=(const complex<Other>& complexNum);\n\ncomplex<Type>& operator/=(const Type& _RealPart);\n\ncomplex<Type>& operator/=(const complex<Type>& complexNum);\n```  \n  \n### Parameters  \n ` complexNum`  \n A complex number to be subtracted from the target complex number.  \n  \n `_RealPart`  \n A real number to be subtracted from the target complex number.  \n  \n### Return Value  \n A complex number that has been divided by the number specified as a parameter.  \n  \n### Remarks  \n The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.  \n  \n### Example  \n  \n```cpp  \n// complex_op_de.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Example of the first member function  \n   // type complex<double> divided by type complex<double>  \n   complex <double> cl1 ( polar (3.0 , pi / 6 ) );  \n   complex <double> cr1 ( polar (2.0 , pi / 3 ) );  \n   cout << \"The left-side complex number is cl1 = \" << cl1 << endl;  \n   cout << \"The right-side complex number is cr1 = \" << cr1 << endl;  \n  \n   complex <double> cs1 = cl1 / cr1;  \n   cout << \"The quotient of the two complex numbers is: cs1 = cl1 /cr1 = \"  \n        << cs1 << endl;  \n  \n   // This is equivalent to the following operation  \n   cl1 /= cr1;  \n   cout << \"Quotient of two complex numbers is also: cl1 /= cr1 = \"  \n        << cl1 << endl;  \n  \n   double abscl1 = abs ( cl1 );  \n   double argcl1 = arg ( cl1 );  \n   cout << \"The modulus of cl1 is: \" << abscl1 << endl;  \n   cout << \"The argument of cl1 is: \"<< argcl1 << \" radians, which is \"   \n        << argcl1 * 180 / pi << \" degrees.\" << endl << endl;   \n  \n   // Example of the second member function  \n   // type complex<double> divided by type double  \n   complex <double> cl2 ( polar (3.0 , pi / 6 ) );  \n   double cr2 =5;  \n   cout << \"The left-side complex number is cl2 = \" << cl2 << endl;  \n   cout << \"The right-side complex number is cr2 = \" << cr2 << endl;  \n  \n   complex <double> cs2 = cl2 / cr2;  \n   cout << \"The quotient of the two complex numbers is: cs2 /= cl2 cr2 = \"   \n        << cs2 << endl;  \n  \n   // This is equivalent to the following operation  \n   cl2 /= cr2;  \n   cout << \"Quotient of two complex numbers is also: cl2 = /cr2 = \"  \n        << cl2 << endl;  \n  \n   double abscl2 = abs ( cl2 );  \n   double argcl2 = arg ( cl2 );  \n   cout << \"The modulus of cl2 is: \" << abscl2 << endl;  \n   cout << \"The argument of cl2 is: \"<< argcl2 << \" radians, which is \"   \n        << argcl2 * 180 / pi << \" degrees.\" << endl << endl;  \n}  \n```  \n  \n```Output  \nThe left-side complex number is cl1 = (2.59808,1.5)  \nThe right-side complex number is cr1 = (1,1.73205)  \nThe quotient of the two complex numbers is: cs1 = cl1 /cr1 = (1.29904,-0.75)  \nQuotient of two complex numbers is also: cl1 /= cr1 = (1.29904,-0.75)  \nThe modulus of cl1 is: 1.5  \nThe argument of cl1 is: -0.523599 radians, which is -30 degrees.  \n  \nThe left-side complex number is cl2 = (2.59808,1.5)  \nThe right-side complex number is cr2 = 5  \nThe quotient of the two complex numbers is: cs2 /= cl2 cr2 = (0.519615,0.3)  \nQuotient of two complex numbers is also: cl2 = /cr2 = (0.519615,0.3)  \nThe modulus of cl2 is: 0.6  \nThe argument of cl2 is: 0.523599 radians, which is 30 degrees.  \n```  \n  \n##  <a name=\"complex__operator_eq\"></a>  complex::operator=  \n Assigns a number to a target complex number, where the number assigned may be complex or of the same type as are the real and imaginary parts of the complex number to which it is being assigned.  \n  \n```  \ntemplate <class Other>  \ncomplex<Type>& operator=(const complex<Other>& right);\n\ncomplex<Type>& operator=(const Type& right);\n```  \n  \n### Parameters  \n ` right`  \n A complex number or a number that is of the same type as the parameter of the target complex number.  \n  \n### Return Value  \n A complex number that has been assigned the number specified as a parameter.  \n  \n### Remarks  \n The operation is overloaded so that simple arithmetic operations can be executed without the conversion of the data to a particular format.  \n  \n### Example  \n  \n```cpp  \n// complex_op_as.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   double pi = 3.14159265359;  \n  \n   // Example of the first member function  \n   // type complex<double> assigned to type complex<double>  \n   complex <double> cl1 ( 3.0 , 4.0 );  \n   complex <double> cr1 ( 2.0 , -1.0 );  \n   cout << \"The left-side complex number is cl1 = \" << cl1 << endl;  \n   cout << \"The right-side complex number is cr1 = \" << cr1 << endl;  \n  \n   cl1  = cr1;  \n   cout << \"The complex number cr1 assigned to the complex number cl1 is:\"  \n        << \"\\n cl1 = cr1 = \" << cl1 << endl;  \n  \n   // Example of the second member function  \n   // type double assigned to type complex<double>  \n   complex <double> cl2 ( -2 , 4 );  \n   double cr2 =5.0;  \n   cout << \"The left-side complex number is cl2 = \" << cl2 << endl;  \n   cout << \"The right-side complex number is cr2 = \" << cr2 << endl;  \n  \n   cl2 = cr2;  \n   cout << \"The complex number cr2 assigned to the complex number cl2 is:\"  \n        << \"\\n cl2 = cr2 = \" << cl2 << endl;  \n  \n   cl2 = complex<double>(3.0, 4.0);  \n   cout << \"The complex number (3, 4) assigned to the complex number cl2 is:\"  \n        << \"\\n cl2 = \" << cl2 << endl;  \n}  \n```  \n  \n```Output  \nThe left-side complex number is cl1 = (3,4)  \nThe right-side complex number is cr1 = (2,-1)  \nThe complex number cr1 assigned to the complex number cl1 is:  \n cl1 = cr1 = (2,-1)  \nThe left-side complex number is cl2 = (-2,4)  \nThe right-side complex number is cr2 = 5  \nThe complex number cr2 assigned to the complex number cl2 is:  \n cl2 = cr2 = (5,0)  \nThe complex number (3, 4) assigned to the complex number cl2 is:  \n cl2 = (3,4)  \n```  \n  \n##  <a name=\"complex__real\"></a>  complex::real  \n Gets or sets the real component of a complex number.  \n  \n```  \nconstexpr T real() const;\n\n \nT real(const T& right);\n```  \n  \n### Parameters  \n ` right`  \n A complex number whose real value is to be extracted.  \n  \n### Return Value  \n The real part of the complex number.  \n  \n### Remarks  \n For a complex number *a + bi*, the real part or component is *Re(a + bi) = a.*  \n  \n### Example  \n  \n```cpp  \n// complex_class_real.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   complex <double> c1 ( 4.0 , 3.0 );  \n   cout << \"The complex number c1 = \" << c1 << endl;  \n  \n   double dr1 = c1.real ( );  \n   cout << \"The real part of c1 is c1.real ( ) = \"  \n        << dr1 << \".\" << endl;  \n  \n   double di1 = c1.imag ( );  \n   cout << \"The imaginary part of c1 is c1.imag ( ) = \"  \n        << di1 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe complex number c1 = (4,3)  \nThe real part of c1 is c1.real ( ) = 4.  \nThe imaginary part of c1 is c1.imag ( ) = 3.  \n```  \n  \n##  <a name=\"complex__value_type\"></a>  complex::value_type  \n A type that represents the data type used to represent the real and imaginary parts of a complex number.  \n  \n```  \n \ntypedef Type value_type;  \n```  \n  \n### Remarks  \n `value_type` is a synonym for the class complex **Type** template parameter.  \n  \n### Example  \n  \n```cpp  \n// complex_valuetype.cpp  \n// compile with: /EHsc  \n#include <complex>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   complex <double>::value_type a = 3, b = 4;  \n  \n   complex <double> c1 ( a , b );  \n   cout << \"Specifying initial real & imaginary parts\"  \n      << \"\\nof type value_type: \"  \n      << \"c1 = \" << c1 << \".\" << endl;  \n}  \n```  \n  \n```Output  \nSpecifying initial real & imaginary parts  \nof type value_type: c1 = (3,4).  \n```  \n  \n## See Also  \n [complex Members](http://msdn.microsoft.com/en-us/d5c4466c-43a0-4817-aca1-9a5d492dae28)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)\n\n"}