{"nodes":[{"pos":[12,86],"content":"Handle to Object Operator (^)  (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Handle to Object Operator (^)  (C++ Component Extensions) | Microsoft Docs","pos":[0,74]}]},{"content":"Handle to Object Operator (^)  (C++ Component Extensions)","pos":[657,714]},{"pos":[715,961],"content":"The <bpt id=\"p1\">*</bpt>handle declarator<ept id=\"p1\">*</ept> (<ph id=\"ph1\">`^`</ph>, pronounced \"hat\"), modifies the type <bpt id=\"p2\">[</bpt>specifier<ept id=\"p2\">](../cpp/overview-of-declarators.md)</ept> to mean that the declared object should be automatically deleted when the system determines that the object is no longer accessible.","source":"The *handle declarator* (`^`, pronounced \"hat\"), modifies the type [specifier](../cpp/overview-of-declarators.md) to mean that the declared object should be automatically deleted when the system determines that the object is no longer accessible."},{"content":"Accessing the Declared Object","pos":[970,999]},{"content":"A variable that is declared with the handle declarator behaves like a pointer to the object.","pos":[1003,1095]},{"content":"However, the variable points to the entire object, cannot point to a member of the object, and it does not support pointer arithmetic.","pos":[1096,1230]},{"content":"Use the indirection operator (<ph id=\"ph1\">`*`</ph>) to access the object, and the arrow member-access operator (<ph id=\"ph2\">`-&gt;`</ph>) to access a member of the object.","pos":[1231,1365],"source":" Use the indirection operator (`*`) to access the object, and the arrow member-access operator (`->`) to access a member of the object."},{"content":"The compiler uses the COM <bpt id=\"p1\">*</bpt>reference counting<ept id=\"p1\">*</ept> mechanism to determine if the object is no longer being used and can be deleted.","pos":[1430,1557],"source":"The compiler uses the COM *reference counting* mechanism to determine if the object is no longer being used and can be deleted."},{"content":"This is possible because an object that is derived from a Windows Runtime interface is actually a COM object.","pos":[1558,1667]},{"content":"The reference count is incremented when the object is created or copied, and decremented when the object is set to null or goes out of scope.","pos":[1668,1809]},{"content":"If the reference count goes to zero, the object is automatically and immediately deleted.","pos":[1810,1899]},{"content":"The advantage of the handle declarator is that in COM you must explicitly manage the reference count for an object, which is a tedious and error prone process.","pos":[1906,2065]},{"content":"That is, to increment and decrement the reference count you must call the object's AddRef() and Release() methods.","pos":[2066,2180]},{"content":"However, if you declare an object with the handle declarator, the Visual C++ compiler generates code that automatically adjusts the reference count.","pos":[2181,2329]},{"pos":[2336,2453],"content":"For information on how to instantiate an object, see <bpt id=\"p1\">[</bpt>ref new<ept id=\"p1\">](../windows/ref-new-gcnew-cpp-component-extensions.md)</ept>.","source":"For information on how to instantiate an object, see [ref new](../windows/ref-new-gcnew-cpp-component-extensions.md)."},{"content":"Requirements","pos":[2462,2474]},{"pos":[2478,2502],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"The system uses the CLR <bpt id=\"p1\">*</bpt>garbage collector<ept id=\"p1\">*</ept> mechanism to determine if the object is no longer being used and can be deleted.","pos":[2586,2710],"source":"The system uses the CLR *garbage collector* mechanism to determine if the object is no longer being used and can be deleted."},{"content":"The common language runtime maintains a heap on which it allocates objects, and uses managed references (variables) in your program indicate the location of objects on the heap.","pos":[2711,2888]},{"content":"When an object is no longer used, the memory that it occupied on the heap is freed.","pos":[2889,2972]},{"content":"Periodically, the garbage collector compacts the heap to better use the freed memory.","pos":[2973,3058]},{"content":"Compacting the heap can move objects on the heap, which invalidates the locations refered to by managed references.","pos":[3059,3174]},{"content":"However, the garbage collector is aware of the location of all managed references, and automatically updates them to indicate the current location of the objects on the heap.","pos":[3175,3349]},{"content":"Because native C++ pointers (<ph id=\"ph1\">`*`</ph>) and references (<ph id=\"ph2\">`&amp;`</ph>) are not managed references, the garbage collector cannot automatically update the addresses they point to.","pos":[3356,3517],"source":"Because native C++ pointers (`*`) and references (`&`) are not managed references, the garbage collector cannot automatically update the addresses they point to."},{"content":"To solve this problem, use the handle declarator to specify a variable that the garbage collector is aware of and can update automatically.","pos":[3518,3657]},{"content":"In Visual C++ 2002 and Visual C++ 2003, <ph id=\"ph1\">`__gc *`</ph> was used to declare an object on the managed heap.","pos":[3664,3763],"source":"In Visual C++ 2002 and Visual C++ 2003, `__gc *` was used to declare an object on the managed heap."},{"content":"The <ph id=\"ph1\">`^`</ph> replaces <ph id=\"ph2\">`__gc *`</ph> in the new syntax.","pos":[3765,3809],"source":"  The `^` replaces `__gc *` in the new syntax."},{"pos":[3816,3937],"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Declare Handles in Native Types<ept id=\"p1\">](../dotnet/how-to-declare-handles-in-native-types.md)</ept>.","source":"For more information, see [How to: Declare Handles in Native Types](../dotnet/how-to-declare-handles-in-native-types.md)."},{"content":"Examples","pos":[3947,3955]},{"content":"Example","pos":[3961,3968]},{"content":"This sample shows how to create an instance of a reference type on the managed heap.","pos":[3977,4061]},{"content":"This sample also shows that you can initialize one handle with another, resulting in two references to same object on managed, garbage-collected heap.","pos":[4063,4213]},{"content":"Notice that assigning <bpt id=\"p1\">[</bpt>nullptr<ept id=\"p1\">](../windows/nullptr-cpp-component-extensions.md)</ept> to one handle does not mark the object for garbage collection.","pos":[4214,4356],"source":" Notice that assigning [nullptr](../windows/nullptr-cpp-component-extensions.md) to one handle does not mark the object for garbage collection."},{"content":"Output","pos":[4781,4787]},{"content":"Example","pos":[4827,4834]},{"content":"The following sample shows how to declare a handle to an object on the managed heap, where the type of object is a boxed value type.","pos":[4843,4975]},{"content":"The sample also shows how to get the value type from the boxed object.","pos":[4976,5046]},{"content":"Output","pos":[5420,5426]},{"content":"Example","pos":[5482,5489]},{"content":"This sample shows that the common C++ idiom of using a void* pointer to point to an arbitrary object is replaced by Object^, which can hold a handle to any reference class.","pos":[5498,5670]},{"content":"It also shows that all types, such as arrays and delegates, can be converted to an object handle.","pos":[5671,5768]},{"content":"Output","pos":[6507,6513]},{"content":"Example","pos":[6629,6636]},{"content":"This sample shows that a handle can be dereferenced and that a member can be accessed via a dereferenced handle.","pos":[6645,6757]},{"content":"Output","pos":[7655,7661]},{"content":"Example","pos":[7758,7765]},{"content":"This sample shows that a native reference (<ph id=\"ph1\">`&amp;`</ph>) can’t bind to an <ph id=\"ph2\">`int`</ph> member of a managed type, as the <ph id=\"ph3\">`int`</ph> might be stored in the garbage collected heap, and native references don’t track object movement in the managed heap.","pos":[7774,8001],"source":"This sample shows that a native reference (`&`) can’t bind to an `int` member of a managed type, as the `int` might be stored in the garbage collected heap, and native references don’t track object movement in the managed heap."},{"content":"The fix is to use a local variable, or to change <ph id=\"ph1\">`&amp;`</ph> to <ph id=\"ph2\">`%`</ph>, making it a tracking reference.","pos":[8002,8094],"source":" The fix is to use a local variable, or to change `&` to `%`, making it a tracking reference."},{"content":"Requirements","pos":[8432,8444]},{"pos":[8448,8473],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"See Also","pos":[8482,8490]},{"content":"Component Extensions for Runtime Platforms","pos":[8495,8537]},{"content":"Tracking Reference Operator","pos":[8602,8629]}],"content":"---\ntitle: \"Handle to Object Operator (^)  (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"^ handle to object [C++]\"\nms.assetid: 70c411e6-be57-4468-a944-6ea7be89f392\ncaps.latest.revision: 26\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Handle to Object Operator (^)  (C++ Component Extensions)\nThe *handle declarator* (`^`, pronounced \"hat\"), modifies the type [specifier](../cpp/overview-of-declarators.md) to mean that the declared object should be automatically deleted when the system determines that the object is no longer accessible.  \n  \n## Accessing the Declared Object  \n A variable that is declared with the handle declarator behaves like a pointer to the object. However, the variable points to the entire object, cannot point to a member of the object, and it does not support pointer arithmetic. Use the indirection operator (`*`) to access the object, and the arrow member-access operator (`->`) to access a member of the object.  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n The compiler uses the COM *reference counting* mechanism to determine if the object is no longer being used and can be deleted. This is possible because an object that is derived from a Windows Runtime interface is actually a COM object. The reference count is incremented when the object is created or copied, and decremented when the object is set to null or goes out of scope. If the reference count goes to zero, the object is automatically and immediately deleted.  \n  \n The advantage of the handle declarator is that in COM you must explicitly manage the reference count for an object, which is a tedious and error prone process. That is, to increment and decrement the reference count you must call the object's AddRef() and Release() methods. However, if you declare an object with the handle declarator, the Visual C++ compiler generates code that automatically adjusts the reference count.  \n  \n For information on how to instantiate an object, see [ref new](../windows/ref-new-gcnew-cpp-component-extensions.md).  \n  \n## Requirements  \n Compiler option: **/ZW**  \n  \n## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  \n The system uses the CLR *garbage collector* mechanism to determine if the object is no longer being used and can be deleted. The common language runtime maintains a heap on which it allocates objects, and uses managed references (variables) in your program indicate the location of objects on the heap. When an object is no longer used, the memory that it occupied on the heap is freed. Periodically, the garbage collector compacts the heap to better use the freed memory. Compacting the heap can move objects on the heap, which invalidates the locations refered to by managed references. However, the garbage collector is aware of the location of all managed references, and automatically updates them to indicate the current location of the objects on the heap.  \n  \n Because native C++ pointers (`*`) and references (`&`) are not managed references, the garbage collector cannot automatically update the addresses they point to. To solve this problem, use the handle declarator to specify a variable that the garbage collector is aware of and can update automatically.  \n  \n In Visual C++ 2002 and Visual C++ 2003, `__gc *` was used to declare an object on the managed heap.  The `^` replaces `__gc *` in the new syntax.  \n  \n For more information, see [How to: Declare Handles in Native Types](../dotnet/how-to-declare-handles-in-native-types.md).  \n  \n### Examples  \n **Example**  \n  \n This sample shows how to create an instance of a reference type on the managed heap.  This sample also shows that you can initialize one handle with another, resulting in two references to same object on managed, garbage-collected heap. Notice that assigning [nullptr](../windows/nullptr-cpp-component-extensions.md) to one handle does not mark the object for garbage collection.  \n  \n```  \n// mcppv2_handle.cpp  \n// compile with: /clr  \nref class MyClass {  \npublic:  \n   MyClass() : i(){}  \n   int i;  \n   void Test() {  \n      i++;  \n      System::Console::WriteLine(i);  \n   }  \n};  \n  \nint main() {  \n   MyClass ^ p_MyClass = gcnew MyClass;  \n   p_MyClass->Test();  \n  \n   MyClass ^ p_MyClass2;  \n   p_MyClass2 = p_MyClass;  \n  \n   p_MyClass = nullptr;  \n   p_MyClass2->Test();     \n}  \n```  \n  \n **Output**  \n  \n```Output  \n1  \n2  \n```  \n  \n **Example**  \n  \n The following sample shows how to declare a handle to an object on the managed heap, where the type of object is a boxed value type. The sample also shows how to get the value type from the boxed object.  \n  \n```  \n// mcppv2_handle_2.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nvoid Test(Object^ o) {  \n   Int32^ i = dynamic_cast<Int32^>(o);  \n  \n   if(i)  \n      Console::WriteLine(i);  \n   else  \n      Console::WriteLine(\"Not a boxed int\");  \n}  \n  \nint main() {  \n   String^ str = \"test\";  \n   Test(str);  \n  \n   int n = 100;  \n   Test(n);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nNot a boxed int  \n100  \n```  \n  \n **Example**  \n  \n This sample shows that the common C++ idiom of using a void* pointer to point to an arbitrary object is replaced by Object^, which can hold a handle to any reference class. It also shows that all types, such as arrays and delegates, can be converted to an object handle.  \n  \n```  \n// mcppv2_handle_3.cpp  \n// compile with: /clr  \nusing namespace System;  \nusing namespace System::Collections;  \npublic delegate void MyDel();  \nref class MyClass {  \npublic:  \n   void Test() {}  \n};  \n  \nvoid Test(Object ^ x) {  \n   Console::WriteLine(\"Type is {0}\", x->GetType());  \n}  \n  \nint main() {  \n   // handle to Object can hold any ref type  \n   Object ^ h_MyClass = gcnew MyClass;  \n  \n   ArrayList ^ arr = gcnew ArrayList();  \n   arr->Add(gcnew MyClass);  \n  \n   h_MyClass = dynamic_cast<MyClass ^>(arr[0]);  \n   Test(arr);  \n  \n   Int32 ^ bi = 1;  \n   Test(bi);  \n  \n   MyClass ^ h_MyClass2 = gcnew MyClass;  \n  \n   MyDel^ DelInst = gcnew MyDel(h_MyClass2, &MyClass::Test);  \n   Test(DelInst);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nType is System.Collections.ArrayList  \n  \nType is System.Int32  \n  \nType is MyDel  \n```  \n  \n **Example**  \n  \n This sample shows that a handle can be dereferenced and that a member can be accessed via a dereferenced handle.  \n  \n```  \n// mcppv2_handle_4.cpp  \n// compile with: /clr  \nusing namespace System;  \nvalue struct DataCollection {  \nprivate:  \n   int Size;  \n   array<String^>^ x;  \n  \npublic:  \n   DataCollection(int i) : Size(i) {  \n      x = gcnew array<String^>(Size);  \n      for (int i = 0 ; i < Size ; i++)  \n         x[i] = i.ToString();  \n   }  \n  \n   void f(int Item) {  \n      if (Item >= Size)  \n      {  \n         System::Console::WriteLine(\"Cannot access array element {0}, size is {1}\", Item, Size);  \n         return;  \n      }  \n      else  \n         System::Console::WriteLine(\"Array value: {0}\", x[Item]);  \n   }  \n};  \n  \nvoid f(DataCollection y, int Item) {  \n   y.f(Item);  \n}  \n  \nint main() {  \n   DataCollection ^ a = gcnew DataCollection(10);  \n   f(*a, 7);   // dereference a handle, return handle's object  \n   (*a).f(11);   // access member via dereferenced handle  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nArray value: 7  \n  \nCannot access array element 11, size is 10  \n```  \n  \n **Example**  \n  \n This sample shows that a native reference (`&`) can’t bind to an `int` member of a managed type, as the `int` might be stored in the garbage collected heap, and native references don’t track object movement in the managed heap. The fix is to use a local variable, or to change `&` to `%`, making it a tracking reference.  \n  \n```  \n// mcppv2_handle_5.cpp  \n// compile with: /clr  \nref struct A {  \n   void Test(unsigned int &){}  \n   void Test2(unsigned int %){}  \n   unsigned int i;  \n};  \n  \nint main() {  \n   A a;  \n   a.i = 9;  \n   a.Test(a.i);   // C2664  \n   a.Test2(a.i);   // OK  \n  \n   unsigned int j = 0;  \n   a.Test(j);   // OK  \n}  \n```  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)   \n [Tracking Reference Operator](../windows/tracking-reference-operator-cpp-component-extensions.md)"}