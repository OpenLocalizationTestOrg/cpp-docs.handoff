{"nodes":[{"pos":[12,54],"content":"Nested Class Declarations | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Nested Class Declarations | Microsoft Docs","pos":[0,42]}]},{"content":"Nested Class Declarations","pos":[736,761]},{"content":"A class can be declared within the scope of another class.","pos":[762,820]},{"content":"Such a class is called a \"nested class.\"","pos":[821,861]},{"content":"Nested classes are considered to be within the scope of the enclosing class and are available for use within that scope.","pos":[862,982]},{"content":"To refer to a nested class from a scope other than its immediate enclosing scope, you must use a fully qualified name.","pos":[983,1101]},{"content":"The following example shows how to declare nested classes:","pos":[1108,1166]},{"content":"and <ph id=\"ph1\">`BufferedIO::BufferedOutput`</ph> are declared within <ph id=\"ph2\">`BufferedIO`</ph>.","pos":[1712,1778],"source":" and `BufferedIO::BufferedOutput` are declared within `BufferedIO`."},{"content":"These class names are not visible outside the scope of class <ph id=\"ph1\">`BufferedIO`</ph>.","pos":[1779,1853],"source":" These class names are not visible outside the scope of class `BufferedIO`."},{"content":"However, an object of type <ph id=\"ph1\">`BufferedIO`</ph> does not contain any objects of types <ph id=\"ph2\">`BufferedInput`</ph> or <ph id=\"ph3\">`BufferedOutput`</ph>.","pos":[1854,1968],"source":" However, an object of type `BufferedIO` does not contain any objects of types `BufferedInput` or `BufferedOutput`."},{"content":"Nested classes can directly use names, type names, names of static members, and enumerators only from the enclosing class.","pos":[1975,2097]},{"content":"To use names of other class members, you must use pointers, references, or object names.","pos":[2098,2186]},{"pos":[2193,2415],"content":"In the preceding <ph id=\"ph1\">`BufferedIO`</ph> example, the enumeration <ph id=\"ph2\">`IOError`</ph> can be accessed directly by member functions in the nested classes, <ph id=\"ph3\">`BufferedIO::BufferedInput`</ph> or <ph id=\"ph4\">`BufferedIO::BufferedOutput`</ph>, as shown in function <ph id=\"ph5\">`good`</ph>.","source":"In the preceding `BufferedIO` example, the enumeration `IOError` can be accessed directly by member functions in the nested classes, `BufferedIO::BufferedInput` or `BufferedIO::BufferedOutput`, as shown in function `good`."},{"pos":[2423,2663],"content":"[!NOTE]\n Nested classes declare only types within class scope. They do not cause contained objects of the nested class to be created. The preceding example declares two nested classes but does not declare any objects of these class types.","leadings":["","> "],"nodes":[{"content":" Nested classes declare only types within class scope. They do not cause contained objects of the nested class to be created. The preceding example declares two nested classes but does not declare any objects of these class types.","pos":[8,238],"nodes":[{"content":"Nested classes declare only types within class scope.","pos":[1,54]},{"content":"They do not cause contained objects of the nested class to be created.","pos":[55,125]},{"content":"The preceding example declares two nested classes but does not declare any objects of these class types.","pos":[126,230]}]}]},{"content":"An exception to the scope visibility of a nested class declaration is when a type name is declared together with a forward declaration.","pos":[2670,2805]},{"content":"In this case, the class name declared by the forward declaration is visible outside the enclosing class, with its scope defined to be the smallest enclosing non-class scope.","pos":[2807,2980]},{"content":"For example:","pos":[2982,2994]},{"content":"Access privilege in nested classes","pos":[3543,3577]},{"content":"Nesting a class within another class does not give special access privileges to member functions of the nested class.","pos":[3581,3698]},{"content":"Similarly, member functions of the enclosing class have no special access to members of the nested class.","pos":[3699,3804]},{"content":"Member functions in nested classes","pos":[3813,3847]},{"content":"Member functions declared in nested classes can be defined in file scope.","pos":[3851,3924]},{"content":"The preceding example could have been written:","pos":[3925,3971]},{"content":"In the preceding example, the <bpt id=\"p1\">*</bpt>qualified-type-name<ept id=\"p1\">*</ept> syntax is used to declare the function name.","pos":[4640,4736],"source":"In the preceding example, the *qualified-type-name* syntax is used to declare the function name."},{"content":"The declaration:","pos":[4737,4753]},{"content":"means \"the <ph id=\"ph1\">`read`</ph> function that is a member of the <ph id=\"ph2\">`BufferedInput`</ph> class that is in the scope of the <ph id=\"ph3\">`BufferedIO`</ph> class.\"","pos":[4811,4932],"source":"means \"the `read` function that is a member of the `BufferedInput` class that is in the scope of the `BufferedIO` class.\""},{"content":"Because this declaration uses the <bpt id=\"p1\">*</bpt>qualified-type-name<ept id=\"p1\">*</ept> syntax, constructs of the following form are possible:","pos":[4933,5043],"source":" Because this declaration uses the *qualified-type-name* syntax, constructs of the following form are possible:"},{"pos":[5139,5257],"content":"The preceding declaration is equivalent to the previous one, but it uses a <ph id=\"ph1\">`typedef`</ph> name in place of the class names.","source":"The preceding declaration is equivalent to the previous one, but it uses a `typedef` name in place of the class names."},{"content":"Friend functions in nested classes","pos":[5266,5300]},{"content":"Friend functions declared in a nested class are considered to be in the scope of the nested class, not the enclosing class.","pos":[5304,5427]},{"content":"Therefore, the friend functions gain no special access privileges to members or member functions of the enclosing class.","pos":[5428,5548]},{"content":"If you want to use a name that is declared in a nested class in a friend function and the friend function is defined in file scope, use qualified type names as follows:","pos":[5549,5717]},{"content":"The following code shows the function <ph id=\"ph1\">`GetExtendedErrorStatus`</ph> declared as a friend function.","pos":[6525,6618],"source":"The following code shows the function `GetExtendedErrorStatus` declared as a friend function."},{"content":"In the function, which is defined in file scope, a message is copied from a static array into a class member.","pos":[6619,6728]},{"content":"Note that a better implementation of <ph id=\"ph1\">`GetExtendedErrorStatus`</ph> is to declare it as:","pos":[6729,6811],"source":" Note that a better implementation of `GetExtendedErrorStatus` is to declare it as:"},{"content":"With the preceding interface, several classes can use the services of this function by passing a memory location where they want the error message copied.","pos":[6879,7033]},{"content":"See Also","pos":[7042,7050]},{"content":"Classes and Structs","pos":[7055,7074]}],"content":"---\ntitle: \"Nested Class Declarations | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"classes [C++], declaring\"\n  - \"declarations, class\"\n  - \"nested classes\"\n  - \"nested classes, declaring\"\n  - \"declaring classes\"\n  - \"declarations, nested classes\"\nms.assetid: c02e471d-b7f9-41b8-8ef6-2323f006dbd5\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Nested Class Declarations\nA class can be declared within the scope of another class. Such a class is called a \"nested class.\" Nested classes are considered to be within the scope of the enclosing class and are available for use within that scope. To refer to a nested class from a scope other than its immediate enclosing scope, you must use a fully qualified name.  \n  \n The following example shows how to declare nested classes:  \n  \n```  \n// nested_class_declarations.cpp  \nclass BufferedIO  \n{  \npublic:  \n   enum IOError { None, Access, General };  \n  \n   // Declare nested class BufferedInput.  \n   class BufferedInput  \n   {  \n   public:  \n      int read();  \n      int good()  \n      {  \n         return _inputerror == None;  \n      }  \n   private:  \n       IOError _inputerror;  \n   };  \n  \n   // Declare nested class BufferedOutput.  \n   class BufferedOutput  \n   {  \n      // Member list  \n   };  \n};  \n  \nint main()  \n{  \n}  \n```  \n  \n `BufferedIO::BufferedInput` and `BufferedIO::BufferedOutput` are declared within `BufferedIO`. These class names are not visible outside the scope of class `BufferedIO`. However, an object of type `BufferedIO` does not contain any objects of types `BufferedInput` or `BufferedOutput`.  \n  \n Nested classes can directly use names, type names, names of static members, and enumerators only from the enclosing class. To use names of other class members, you must use pointers, references, or object names.  \n  \n In the preceding `BufferedIO` example, the enumeration `IOError` can be accessed directly by member functions in the nested classes, `BufferedIO::BufferedInput` or `BufferedIO::BufferedOutput`, as shown in function `good`.  \n  \n> [!NOTE]\n>  Nested classes declare only types within class scope. They do not cause contained objects of the nested class to be created. The preceding example declares two nested classes but does not declare any objects of these class types.  \n  \n An exception to the scope visibility of a nested class declaration is when a type name is declared together with a forward declaration.  In this case, the class name declared by the forward declaration is visible outside the enclosing class, with its scope defined to be the smallest enclosing non-class scope.  For example:  \n  \n```  \n// nested_class_declarations_2.cpp  \nclass C  \n{  \npublic:  \n    typedef class U u_t; // class U visible outside class C scope  \n    typedef class V {} v_t; // class V not visible outside class C  \n};  \n  \nint main()  \n{  \n    // okay, forward declaration used above so file scope is used  \n    U* pu;  \n  \n    // error, type name only exists in class C scope  \n    u_t* pu2; // C2065  \n  \n    // error, class defined above so class C scope  \n    V* pv; // C2065  \n  \n    // okay, fully qualified name  \n    C::V* pv2;  \n}  \n```  \n  \n## Access privilege in nested classes  \n Nesting a class within another class does not give special access privileges to member functions of the nested class. Similarly, member functions of the enclosing class have no special access to members of the nested class.  \n  \n## Member functions in nested classes  \n Member functions declared in nested classes can be defined in file scope. The preceding example could have been written:  \n  \n```  \n// member_functions_in_nested_classes.cpp  \nclass BufferedIO  \n{  \npublic:  \n    enum IOError { None, Access, General };  \n    class BufferedInput  \n    {  \n    public:  \n        int read(); // Declare but do not define member  \n        int good(); //  functions read and good.  \n    private:  \n        IOError _inputerror;  \n    };  \n  \n    class BufferedOutput  \n    {  \n        // Member list.  \n    };  \n};  \n// Define member functions read and good in  \n//  file scope.  \nint BufferedIO::BufferedInput::read()  \n{  \n   return(1);  \n}  \n  \nint BufferedIO::BufferedInput::good()  \n{  \n    return _inputerror == None;  \n}  \nint main()  \n{  \n}  \n```  \n  \n In the preceding example, the *qualified-type-name* syntax is used to declare the function name. The declaration:  \n  \n```  \nBufferedIO::BufferedInput::read()  \n```  \n  \n means \"the `read` function that is a member of the `BufferedInput` class that is in the scope of the `BufferedIO` class.\" Because this declaration uses the *qualified-type-name* syntax, constructs of the following form are possible:  \n  \n```  \ntypedef BufferedIO::BufferedInput BIO_INPUT;  \n  \nint BIO_INPUT::read()  \n```  \n  \n The preceding declaration is equivalent to the previous one, but it uses a `typedef` name in place of the class names.  \n  \n## Friend functions in nested classes  \n Friend functions declared in a nested class are considered to be in the scope of the nested class, not the enclosing class. Therefore, the friend functions gain no special access privileges to members or member functions of the enclosing class. If you want to use a name that is declared in a nested class in a friend function and the friend function is defined in file scope, use qualified type names as follows:  \n  \n```  \n// friend_functions_and_nested_classes.cpp  \n  \n#include <string.h>  \n  \nenum  \n{  \n    sizeOfMessage = 255  \n};  \n  \nchar *rgszMessage[sizeOfMessage];  \n  \nclass BufferedIO  \n{  \npublic:  \n    class BufferedInput  \n    {  \n    public:  \n        friend int GetExtendedErrorStatus();  \n        static char *message;  \n        static int  messageSize;  \n        int iMsgNo;  \n   };  \n};  \n  \nchar *BufferedIO::BufferedInput::message;  \nint BufferedIO::BufferedInput::messageSize;  \n  \nint GetExtendedErrorStatus()  \n{  \n    int iMsgNo = 1; // assign arbitrary value as message number  \n  \n    strcpy_s( BufferedIO::BufferedInput::message,  \n              BufferedIO::BufferedInput::messageSize,  \n              rgszMessage[iMsgNo] );  \n  \n    return iMsgNo;  \n}  \n  \nint main()  \n{  \n}  \n```  \n  \n The following code shows the function `GetExtendedErrorStatus` declared as a friend function. In the function, which is defined in file scope, a message is copied from a static array into a class member. Note that a better implementation of `GetExtendedErrorStatus` is to declare it as:  \n  \n```  \nint GetExtendedErrorStatus( char *message )  \n```  \n  \n With the preceding interface, several classes can use the services of this function by passing a memory location where they want the error message copied.  \n  \n## See Also  \n [Classes and Structs](../cpp/classes-and-structs-cpp.md)"}