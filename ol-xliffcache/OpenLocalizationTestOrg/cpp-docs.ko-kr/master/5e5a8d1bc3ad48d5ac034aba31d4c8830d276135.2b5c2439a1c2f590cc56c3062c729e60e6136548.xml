{"nodes":[{"pos":[12,62],"content":"Arrays (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Arrays (C++ Component Extensions) | Microsoft Docs","pos":[0,50]}]},{"content":"Arrays (C++ Component Extensions)","pos":[805,838]},{"pos":[839,1090],"content":"The <ph id=\"ph1\">`Platform::Array&lt;T&gt;`</ph> type in <ph id=\"ph2\">[!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)]</ph>, or the <ph id=\"ph3\">`array`</ph> keyword in <ph id=\"ph4\">[!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]</ph>, declares an array of a specified type and initial value.","source":"The `Platform::Array<T>` type in [!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)], or the `array` keyword in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)], declares an array of a specified type and initial value."},{"content":"All Platforms","pos":[1099,1112]},{"content":"The array must be declared by using the handle-to-object (^) modifier after the closing angle bracket (&gt;) in the declaration.","pos":[1116,1241],"source":"The array must be declared by using the handle-to-object (^) modifier after the closing angle bracket (>) in the declaration."},{"content":"The number of elements of the array is not part of the type.","pos":[1248,1308]},{"content":"One array variable can refer to arrays of different sizes.","pos":[1309,1367]},{"content":"Unlike standard C++, subscripting is not a synonym for pointer arithmetic and is not commutative.","pos":[1374,1471]},{"content":"For more information about arrays, see:","pos":[1478,1517]},{"content":"How to: Use Arrays in C++/CLI","pos":[1531,1560]},{"content":"Variable Argument Lists (...) (C++/CLI)","pos":[1617,1656]},{"content":"Arrays are members of the <ph id=\"ph1\">`Platform`</ph> namespace.","pos":[1784,1831],"source":"Arrays are members of the `Platform` namespace."},{"content":"Arrays can be only one-dimensional.","pos":[1832,1867]},{"content":"Syntax","pos":[1876,1882]},{"content":"The first example of the syntax uses the <ph id=\"ph1\">`ref new`</ph> aggregate keyword to allocate an array.","pos":[1891,1981],"source":"The first example of the syntax uses the `ref new` aggregate keyword to allocate an array."},{"content":"The second example declares a local array.","pos":[1982,2024]},{"content":"<bpt id=\"p1\">*</bpt>qualifiers<ept id=\"p1\">*</ept> [optional]","pos":[2397,2420],"source":"*qualifiers* [optional]"},{"content":"One or more of these storage class specifiers: <bpt id=\"p1\">[</bpt>mutable<ept id=\"p1\">](../cpp/mutable-data-members-cpp.md)</ept>, <bpt id=\"p2\">[</bpt>volatile<ept id=\"p2\">](../cpp/volatile-cpp.md)</ept>, <bpt id=\"p3\">[</bpt>const<ept id=\"p3\">](../cpp/const-cpp.md)</ept>, <bpt id=\"p4\">[</bpt>extern<ept id=\"p4\">](../cpp/using-extern-to-specify-linkage.md)</ept>, <bpt id=\"p5\">[</bpt>static<ept id=\"p5\">](../cpp/static-members-cpp.md)</ept>.","pos":[2424,2676],"source":" One or more of these storage class specifiers: [mutable](../cpp/mutable-data-members-cpp.md), [volatile](../cpp/volatile-cpp.md), [const](../cpp/const-cpp.md), [extern](../cpp/using-extern-to-specify-linkage.md), [static](../cpp/static-members-cpp.md)."},{"content":"The type of the array variable.","pos":[2699,2730]},{"content":"Valid types are <ph id=\"ph1\">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> classes and fundamental types, ref classes and structs, value classes and structs, and native pointers (<ph id=\"ph2\">`type``*`</ph>).","pos":[2731,2915],"source":" Valid types are [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)] classes and fundamental types, ref classes and structs, value classes and structs, and native pointers (`type``*`)."},{"content":"[optional]","pos":[2929,2939]},{"content":"The number of dimensions of the array.","pos":[2943,2981]},{"content":"Must be 1.","pos":[2982,2992]},{"content":"The name of the array variable.","pos":[3015,3046]},{"content":"The type of the values that initialize the array.","pos":[3078,3127]},{"content":"Typically, <ph id=\"ph1\">`array-type`</ph> and <ph id=\"ph2\">`initialization-type`</ph> are the same type.","pos":[3128,3196],"source":" Typically, `array-type` and `initialization-type` are the same type."},{"content":"However, the types can be different if there is a conversion from <ph id=\"ph1\">`initialization-type`</ph> to <ph id=\"ph2\">`array-type`</ph>—for example, if <ph id=\"ph3\">`initialization-type`</ph> is derived from <ph id=\"ph4\">`array-type`</ph>.","pos":[3197,3368],"source":" However, the types can be different if there is a conversion from `initialization-type` to `array-type`—for example, if `initialization-type` is derived from `array-type`."},{"content":"[optional]","pos":[3397,3407]},{"content":"A comma-delimited list of values in curly brackets that initialize the elements of the array.","pos":[3411,3504]},{"content":"For example, if <ph id=\"ph1\">`rank-size-list`</ph> were <ph id=\"ph2\">`(3)`</ph>, which declares a one-dimensional array of 3 elements, <ph id=\"ph3\">`initialization list`</ph> could be <ph id=\"ph4\">`{1,2,3}`</ph>.","pos":[3505,3645],"source":" For example, if `rank-size-list` were `(3)`, which declares a one-dimensional array of 3 elements, `initialization list` could be `{1,2,3}`."},{"content":"Remarks","pos":[3654,3661]},{"content":"You can detect at compile time whether a type is a reference-counted array with <ph id=\"ph1\">`__is_ref_array(``type``)`</ph>.","pos":[3670,3777],"source":"You can detect at compile time whether a type is a reference-counted array with `__is_ref_array(``type``)`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Compiler Support for Type Traits<ept id=\"p1\">](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)</ept>.","pos":[3778,3912],"source":" For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)."},{"content":"Requirements","pos":[3922,3934]},{"pos":[3938,3962],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Examples","pos":[3972,3980]},{"content":"The following example creates a one-dimensional array that has 100 elements.","pos":[3984,4060]},{"content":"Syntax","pos":[4417,4423]},{"content":"The first example of the syntax uses the <ph id=\"ph1\">`gcnew`</ph> keyword to allocate an array.","pos":[4432,4510],"source":"The first example of the syntax uses the `gcnew` keyword to allocate an array."},{"content":"The second example declares a local array.","pos":[4511,4553]},{"content":"<bpt id=\"p1\">*</bpt>qualifiers<ept id=\"p1\">*</ept> [optional]","pos":[4915,4938],"source":"*qualifiers* [optional]"},{"content":"One or more of these storage class specifiers: <bpt id=\"p1\">[</bpt>mutable<ept id=\"p1\">](../cpp/mutable-data-members-cpp.md)</ept>, <bpt id=\"p2\">[</bpt>volatile<ept id=\"p2\">](../cpp/volatile-cpp.md)</ept>, <bpt id=\"p3\">[</bpt>const<ept id=\"p3\">](../cpp/const-cpp.md)</ept>, <bpt id=\"p4\">[</bpt>extern<ept id=\"p4\">](../cpp/using-extern-to-specify-linkage.md)</ept>, <bpt id=\"p5\">[</bpt>static<ept id=\"p5\">](../cpp/static-members-cpp.md)</ept>.","pos":[4942,5194],"source":" One or more of these storage class specifiers: [mutable](../cpp/mutable-data-members-cpp.md), [volatile](../cpp/volatile-cpp.md), [const](../cpp/const-cpp.md), [extern](../cpp/using-extern-to-specify-linkage.md), [static](../cpp/static-members-cpp.md)."},{"content":"The type of the array variable.","pos":[5217,5248]},{"content":"Valid types are <ph id=\"ph1\">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph> classes and fundamental types, ref classes and structs, value classes and structs, native pointers (<ph id=\"ph2\">`type``*`</ph>), and native POD (plain old data) types.","pos":[5249,5468],"source":" Valid types are [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)] classes and fundamental types, ref classes and structs, value classes and structs, native pointers (`type``*`), and native POD (plain old data) types."},{"content":"[optional]","pos":[5482,5492]},{"content":"The number of dimensions of the array.","pos":[5496,5534]},{"content":"The default is 1; the maximum is 32.","pos":[5535,5571]},{"content":"Each dimension of the array is itself an array.","pos":[5572,5619]},{"content":"The name of the array variable.","pos":[5642,5673]},{"content":"The type of the values that initialize the array.","pos":[5705,5754]},{"content":"Typically, <ph id=\"ph1\">`array-type`</ph> and <ph id=\"ph2\">`initialization-type`</ph> are the same type.","pos":[5755,5823],"source":" Typically, `array-type` and `initialization-type` are the same type."},{"content":"However, the types can be different if there is a conversion from <ph id=\"ph1\">`initialization-type`</ph> to <ph id=\"ph2\">`array-type`</ph>—for example, if <ph id=\"ph3\">`initialization-type`</ph> is derived from <ph id=\"ph4\">`array-type`</ph>.","pos":[5824,5995],"source":" However, the types can be different if there is a conversion from `initialization-type` to `array-type`—for example, if `initialization-type` is derived from `array-type`."},{"content":"A comma-delimited list of the size of each dimension in the array.","pos":[6022,6088]},{"content":"Alternatively, if the <ph id=\"ph1\">`initialization-list`</ph> parameter is specified, the compiler can deduce the size of each dimension and <ph id=\"ph2\">`rank-size-list`</ph> can be omitted.","pos":[6089,6244],"source":" Alternatively, if the `initialization-list` parameter is specified, the compiler can deduce the size of each dimension and `rank-size-list` can be omitted."},{"content":"[optional]","pos":[6272,6282]},{"content":"A comma-delimited list of values in curly brackets that initialize the elements of the array.","pos":[6286,6379]},{"content":"Or a comma-delimited list of nested <bpt id=\"p1\">*</bpt>initialization-list<ept id=\"p1\">*</ept> items that initialize the elements in a multi-dimensional array.","pos":[6380,6502],"source":" Or a comma-delimited list of nested *initialization-list* items that initialize the elements in a multi-dimensional array."},{"content":"For example, if <ph id=\"ph1\">`rank-size-list`</ph> were <ph id=\"ph2\">`(3)`</ph>, which declares a one-dimensional array of 3 elements, <ph id=\"ph3\">`initialization list`</ph> could be <ph id=\"ph4\">`{1,2,3}`</ph>.","pos":[6509,6649],"source":"For example, if `rank-size-list` were `(3)`, which declares a one-dimensional array of 3 elements, `initialization list` could be `{1,2,3}`."},{"content":"If <ph id=\"ph1\">`rank-size-list`</ph> were <ph id=\"ph2\">`(3,2,4)`</ph>, which declares a three-dimensional array of 3 elements in the first dimension, 2 elements in the second, and 4 elements in the third, <ph id=\"ph3\">`initialization-list`</ph> could be <ph id=\"ph4\">`{{1,2,3},{0,0},{-5,10,-21,99}}`</ph>.)","pos":[6650,6885],"source":" If `rank-size-list` were `(3,2,4)`, which declares a three-dimensional array of 3 elements in the first dimension, 2 elements in the second, and 4 elements in the third, `initialization-list` could be `{{1,2,3},{0,0},{-5,10,-21,99}}`.)"},{"content":"Remarks","pos":[6894,6901]},{"pos":[6918,7054],"content":"is in the <bpt id=\"p1\">[</bpt>Platform, default, and cli Namespaces<ept id=\"p1\">](../windows/platform-default-and-cli-namespaces-cpp-component-extensions.md)</ept> namespace.","source":" is in the [Platform, default, and cli Namespaces](../windows/platform-default-and-cli-namespaces-cpp-component-extensions.md) namespace."},{"content":"Like standard C++, the indices of an array are zero-based, and an array is subscripted by using square brackets ([]).","pos":[7061,7178]},{"content":"Unlike standard C++, the indices of a multi-dimensional array are specified in a list of indices for each dimension instead of a set of square-bracket ([]) operators for each dimension.","pos":[7179,7364]},{"content":"For example, <bpt id=\"p1\">*</bpt>identifier<ept id=\"p1\">*</ept>[<bpt id=\"p2\">*</bpt>index1<ept id=\"p2\">*</ept>, <bpt id=\"p3\">*</bpt>index2<ept id=\"p3\">*</ept>] instead of <bpt id=\"p4\">*</bpt>identifier<ept id=\"p4\">*</ept>[<bpt id=\"p5\">*</bpt>index1<ept id=\"p5\">*</ept>][ <bpt id=\"p6\">*</bpt>index2<ept id=\"p6\">*</ept>].","pos":[7365,7456],"source":" For example, *identifier*[*index1*, *index2*] instead of *identifier*[*index1*][ *index2*]."},{"content":"All managed arrays inherit from <ph id=\"ph1\">`System::Array`</ph>.","pos":[7463,7511],"source":"All managed arrays inherit from `System::Array`."},{"content":"Any method or property of <ph id=\"ph1\">`System::Array`</ph> can be applied directly to the array variable.","pos":[7512,7600],"source":" Any method or property of `System::Array` can be applied directly to the array variable."},{"content":"When you allocate an array whose element type is pointer-to a managed class, the elements are 0-initialized.","pos":[7607,7715]},{"content":"When you allocate an array whose element type is a value type <ph id=\"ph1\">`V`</ph>, the default constructor for <ph id=\"ph2\">`V`</ph> is applied to each array element.","pos":[7722,7854],"source":"When you allocate an array whose element type is a value type `V`, the default constructor for `V` is applied to each array element."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>.NET Framework Equivalents to C++ Native Types (C++/CLI)<ept id=\"p1\">](../dotnet/dotnet-framework-equivalents-to-cpp-native-types-cpp-cli.md)</ept>.","pos":[7855,8011],"source":" For more information, see [.NET Framework Equivalents to C++ Native Types (C++/CLI)](../dotnet/dotnet-framework-equivalents-to-cpp-native-types-cpp-cli.md)."},{"content":"At compile time, you can detect whether a type is a common language runtime (CLR) array with<ph id=\"ph1\">`__is_ref_array(``type``)`</ph>.","pos":[8018,8137],"source":"At compile time, you can detect whether a type is a common language runtime (CLR) array with`__is_ref_array(``type``)`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Compiler Support for Type Traits<ept id=\"p1\">](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)</ept>.","pos":[8138,8272],"source":" For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)."},{"content":"Requirements","pos":[8282,8294]},{"pos":[8298,8323],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[8333,8341]},{"content":"The following example creates a one-dimensional array that has 100 elements, and a three-dimensional array that has 3 elements in the first dimension, 5 elements in the second, and 6 elements in the third.","pos":[8345,8550]},{"content":"See Also","pos":[8944,8952]},{"content":"Component Extensions for Runtime Platforms","pos":[8957,8999]}],"content":"---\ntitle: \"Arrays (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"cli::array\"\n  - \"details::array\"\n  - \"lang::array\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"array keyword [C++]\"\n  - \"declaring arrays, about declaring arrays\"\n  - \"arrays [C++], multidimensional\"\n  - \"multidimensional arrays\"\n  - \"arrays [C++]\"\nms.assetid: 49445812-d775-4db1-a231-869598dbb955\ncaps.latest.revision: 34\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Arrays (C++ Component Extensions)\nThe `Platform::Array<T>` type in [!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)], or the `array` keyword in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)], declares an array of a specified type and initial value.  \n  \n## All Platforms  \n The array must be declared by using the handle-to-object (^) modifier after the closing angle bracket (>) in the declaration.  \n  \n The number of elements of the array is not part of the type. One array variable can refer to arrays of different sizes.  \n  \n Unlike standard C++, subscripting is not a synonym for pointer arithmetic and is not commutative.  \n  \n For more information about arrays, see:  \n  \n  \n-   [How to: Use Arrays in C++/CLI](../dotnet/how-to-use-arrays-in-cpp-cli.md)  \n    \n-   [Variable Argument Lists (...) (C++/CLI)](../windows/variable-argument-lists-dot-dot-dot-cpp-cli.md)  \n  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n Arrays are members of the `Platform` namespace. Arrays can be only one-dimensional.  \n  \n **Syntax**  \n  \n The first example of the syntax uses the `ref new` aggregate keyword to allocate an array. The second example declares a local array.  \n  \n```  \n  \n      [qualifiers]  \n      [  \n      Platform::  \n      ]  \n      Array<  \n      [qualifiers]  \n      array-type  \n      [,rank]  \n      >^  \n      identifier = ref new[Platform::]Array<initialization-type> [{initialization-list [,...]}]  \n  \n[qualifiers][Platform::]Array<[qualifiers]array-type[,rank]>^identifier = {initialization-list [,...]}  \n```  \n  \n *qualifiers* [optional]  \n One or more of these storage class specifiers: [mutable](../cpp/mutable-data-members-cpp.md), [volatile](../cpp/volatile-cpp.md), [const](../cpp/const-cpp.md), [extern](../cpp/using-extern-to-specify-linkage.md), [static](../cpp/static-members-cpp.md).  \n  \n `array-type`  \n The type of the array variable. Valid types are [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)] classes and fundamental types, ref classes and structs, value classes and structs, and native pointers (`type``*`).  \n  \n `rank` [optional]  \n The number of dimensions of the array. Must be 1.  \n  \n `identifier`  \n The name of the array variable.  \n  \n `initialization-type`  \n The type of the values that initialize the array. Typically, `array-type` and `initialization-type` are the same type. However, the types can be different if there is a conversion from `initialization-type` to `array-type`—for example, if `initialization-type` is derived from `array-type`.  \n  \n `initialization-list` [optional]  \n A comma-delimited list of values in curly brackets that initialize the elements of the array. For example, if `rank-size-list` were `(3)`, which declares a one-dimensional array of 3 elements, `initialization list` could be `{1,2,3}`.  \n  \n **Remarks**  \n  \n You can detect at compile time whether a type is a reference-counted array with `__is_ref_array(``type``)`. For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md).  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n### Examples  \n The following example creates a one-dimensional array that has 100 elements.  \n  \n```  \n  \n      // cwr_array.cpp  \n// compile with: /ZW  \nusing namespace Platform;  \nref class MyClass {};  \nint main() {  \n   // one-dimensional array  \n   Array<MyClass^>^ My1DArray = ref new Array<MyClass^>(100);  \n   My1DArray[99] = ref new MyClass();  \n}  \n```  \n  \n## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  \n **Syntax**  \n  \n The first example of the syntax uses the `gcnew` keyword to allocate an array. The second example declares a local array.  \n  \n```  \n  \n      [qualifiers]  \n      [  \n      cli::  \n      ]  \n      array<  \n      [qualifiers]  \n      array-type [,rank] >^identifier = gcnew[cli::]array<initialization-type[,rank]>(rank-size-list[,...]) [{initialization-list [,...]}]  \n  \n[qualifiers][cli::]array<[qualifiers]array-type [,rank] >^identifier = {initialization-list [,...]}  \n```  \n  \n *qualifiers* [optional]  \n One or more of these storage class specifiers: [mutable](../cpp/mutable-data-members-cpp.md), [volatile](../cpp/volatile-cpp.md), [const](../cpp/const-cpp.md), [extern](../cpp/using-extern-to-specify-linkage.md), [static](../cpp/static-members-cpp.md).  \n  \n `array-type`  \n The type of the array variable. Valid types are [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)] classes and fundamental types, ref classes and structs, value classes and structs, native pointers (`type``*`), and native POD (plain old data) types.  \n  \n `rank` [optional]  \n The number of dimensions of the array. The default is 1; the maximum is 32. Each dimension of the array is itself an array.  \n  \n `identifier`  \n The name of the array variable.  \n  \n `initialization-type`  \n The type of the values that initialize the array. Typically, `array-type` and `initialization-type` are the same type. However, the types can be different if there is a conversion from `initialization-type` to `array-type`—for example, if `initialization-type` is derived from `array-type`.  \n  \n `rank-size-list`  \n A comma-delimited list of the size of each dimension in the array. Alternatively, if the `initialization-list` parameter is specified, the compiler can deduce the size of each dimension and `rank-size-list` can be omitted. \n  \n `initialization-list` [optional]  \n A comma-delimited list of values in curly brackets that initialize the elements of the array. Or a comma-delimited list of nested *initialization-list* items that initialize the elements in a multi-dimensional array.  \n  \n For example, if `rank-size-list` were `(3)`, which declares a one-dimensional array of 3 elements, `initialization list` could be `{1,2,3}`. If `rank-size-list` were `(3,2,4)`, which declares a three-dimensional array of 3 elements in the first dimension, 2 elements in the second, and 4 elements in the third, `initialization-list` could be `{{1,2,3},{0,0},{-5,10,-21,99}}`.)  \n  \n **Remarks**  \n  \n `array` is in the [Platform, default, and cli Namespaces](../windows/platform-default-and-cli-namespaces-cpp-component-extensions.md) namespace.  \n  \n Like standard C++, the indices of an array are zero-based, and an array is subscripted by using square brackets ([]). Unlike standard C++, the indices of a multi-dimensional array are specified in a list of indices for each dimension instead of a set of square-bracket ([]) operators for each dimension. For example, *identifier*[*index1*, *index2*] instead of *identifier*[*index1*][ *index2*].  \n  \n All managed arrays inherit from `System::Array`. Any method or property of `System::Array` can be applied directly to the array variable.  \n  \n When you allocate an array whose element type is pointer-to a managed class, the elements are 0-initialized.  \n  \n When you allocate an array whose element type is a value type `V`, the default constructor for `V` is applied to each array element. For more information, see [.NET Framework Equivalents to C++ Native Types (C++/CLI)](../dotnet/dotnet-framework-equivalents-to-cpp-native-types-cpp-cli.md).  \n  \n At compile time, you can detect whether a type is a common language runtime (CLR) array with`__is_ref_array(``type``)`. For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md).  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n The following example creates a one-dimensional array that has 100 elements, and a three-dimensional array that has 3 elements in the first dimension, 5 elements in the second, and 6 elements in the third.  \n  \n```  \n// clr_array.cpp  \n// compile with: /clr  \nref class MyClass {};  \nint main() {  \n   // one-dimensional array  \n   array<MyClass ^> ^ My1DArray = gcnew array<MyClass ^>(100);  \n   My1DArray[99] = gcnew MyClass();  \n  \n   // three-dimensional array  \n   array<MyClass ^, 3> ^ My3DArray = gcnew array<MyClass ^, 3>(3, 5, 6);  \n   My3DArray[0,0,0] = gcnew MyClass();  \n}  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}