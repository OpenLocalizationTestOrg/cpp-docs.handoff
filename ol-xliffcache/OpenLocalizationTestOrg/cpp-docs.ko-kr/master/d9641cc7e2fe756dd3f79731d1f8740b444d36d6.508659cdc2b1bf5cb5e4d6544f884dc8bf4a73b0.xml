{"nodes":[{"pos":[12,71],"content":"Portability At ABI Boundaries (Modern C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Portability At ABI Boundaries (Modern C++) | Microsoft Docs","pos":[0,59]}]},{"content":"Portability At ABI Boundaries (Modern C++)","pos":[551,593]},{"content":"Use sufficiently portable types and conventions at binary interface boundaries.","pos":[594,673]},{"content":"A “portable type” is a C built-in type or a struct that contains only C built-in types.","pos":[674,761]},{"content":"Class types can only be used when caller and callee agree on layout, calling convention, etc. This is only possible when both are compiled with the same compiler and compiler settings.","pos":[762,946]},{"content":"How to flatten a class for C portability","pos":[955,995]},{"content":"When callers may be compiled with another compiler/language, then “flatten” to an “extern C” API with a specific calling convention:","pos":[999,1131]},{"content":"See Also","pos":[1599,1607]},{"content":"Welcome Back to C++","pos":[1612,1631]},{"content":"C++ Language Reference","pos":[1680,1702]},{"content":"C++ Standard Library","pos":[1743,1763]}],"content":"---\ntitle: \"Portability At ABI Boundaries (Modern C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: abbd405e-3038-427c-8c24-e00598f0936a\ncaps.latest.revision: 4\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Portability At ABI Boundaries (Modern C++)\nUse sufficiently portable types and conventions at binary interface boundaries. A “portable type” is a C built-in type or a struct that contains only C built-in types. Class types can only be used when caller and callee agree on layout, calling convention, etc. This is only possible when both are compiled with the same compiler and compiler settings.  \n  \n## How to flatten a class for C portability  \n When callers may be compiled with another compiler/language, then “flatten” to an “extern C” API with a specific calling convention:  \n  \n```cpp  \n// class widget {  \n//   widget();  \n//   ~widget();  \n//   double method( int, gadget& );  \n// };  \nextern “C” {    // functions using explicit “this”  \n  struct widget;   // + opaque type (fwd decl only)  \n  widget* STDCALL widget_create();    // ctor → create new  “this”  \n  void STDCALL widget_destroy( widget* );    // dtor → consume “this”  \n  double STDCALL widget_method( widget*, int, gadget* );    // method → use “this”  \n}  \n  \n```  \n  \n## See Also  \n [Welcome Back to C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   \n [C++ Language Reference](../cpp/cpp-language-reference.md)   \n [C++ Standard Library](../standard-library/cpp-standard-library-reference.md)"}