{"nodes":[{"pos":[12,43],"content":"&lt;atomic&gt; | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"atomic<ph id=\"ph1\">&amp;gt;</ph> | Microsoft Docs","pos":[4,31],"source":"atomic&gt; | Microsoft Docs"}]},{"content":"atomic","pos":[2087,2093]},{"content":"Defines classes and template classes to use to create types that support atomic operations.","pos":[2098,2189]},{"content":"Syntax","pos":[2198,2204]},{"content":"Remarks","pos":[2251,2258]},{"pos":[2266,2360],"content":"[!NOTE]\n In code that's compiled by using **/clr** or **/clr:pure**, this header is blocked.","leadings":["","> "],"nodes":[{"content":"In code that's compiled by using <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept>, this header is blocked.","pos":[9,92],"source":" In code that's compiled by using **/clr** or **/clr:pure**, this header is blocked."}]},{"content":"An atomic operation has two key properties that help you use multiple threads to correctly manipulate an object without using mutex locks.","pos":[2367,2505]},{"content":"Because an atomic operation is indivisible, a second atomic operation on the same object from a different thread can obtain the state of the object only before or after the first atomic operation.","pos":[2515,2711]},{"content":"Based on its <bpt id=\"p1\">[</bpt>memory_order<ept id=\"p1\">](../standard-library/atomic-enums.md#memory_order_enum)</ept> argument, an atomic operation establishes ordering requirements for the visibility of the effects of other atomic operations in the same thread.","pos":[2721,2948],"source":"Based on its [memory_order](../standard-library/atomic-enums.md#memory_order_enum) argument, an atomic operation establishes ordering requirements for the visibility of the effects of other atomic operations in the same thread."},{"content":"Consequently, it inhibits compiler optimizations that violate the ordering requirements.","pos":[2949,3037]},{"content":"On some platforms, it might not be possible to efficiently implement atomic operations for some types without using <ph id=\"ph1\">`mutex`</ph> locks.","pos":[3044,3174],"source":"On some platforms, it might not be possible to efficiently implement atomic operations for some types without using `mutex` locks."},{"content":"An atomic type is <bpt id=\"p1\">*</bpt>lock-free<ept id=\"p1\">*</ept> if no atomic operations on that type use locks.","pos":[3175,3252],"source":" An atomic type is *lock-free* if no atomic operations on that type use locks."},{"pos":[3259,3403],"content":"<bpt id=\"p1\">**</bpt>C++11<ept id=\"p1\">**</ept>: In signal-handlers you can perform atomic operations on an object <ph id=\"ph1\">`obj`</ph> if <ph id=\"ph2\">`obj.is_lock_free()`</ph> or <ph id=\"ph3\">`atomic_is_lock_free(x)`</ph> are true.","source":"**C++11**: In signal-handlers you can perform atomic operations on an object `obj` if `obj.is_lock_free()` or `atomic_is_lock_free(x)` are true."},{"content":"The class <bpt id=\"p1\">[</bpt>atomic_flag<ept id=\"p1\">](../standard-library/atomic-flag-structure.md)</ept> provides a minimal atomic type that holds a <ph id=\"ph1\">`bool`</ph> flag.","pos":[3410,3536],"source":"The class [atomic_flag](../standard-library/atomic-flag-structure.md) provides a minimal atomic type that holds a `bool` flag."},{"content":"Its operations are always lock-free.","pos":[3537,3573]},{"content":"The template class <ph id=\"ph1\">`atomic&lt;T&gt;`</ph> stores an object of its argument type <ph id=\"ph2\">`T`</ph> and provides atomic access to that stored value.","pos":[3580,3701],"source":"The template class `atomic<T>` stores an object of its argument type `T` and provides atomic access to that stored value."},{"content":"You can instantiate it by using any type that can be copied by using <bpt id=\"p1\">[</bpt>memcpy<ept id=\"p1\">](../c-runtime-library/reference/memcpy-wmemcpy.md)</ept> and tested for equality by using <bpt id=\"p2\">[</bpt>memcmp<ept id=\"p2\">](../c-runtime-library/reference/memcmp-wmemcmp.md)</ept>.","pos":[3702,3922],"source":" You can instantiate it by using any type that can be copied by using [memcpy](../c-runtime-library/reference/memcpy-wmemcpy.md) and tested for equality by using [memcmp](../c-runtime-library/reference/memcmp-wmemcmp.md)."},{"content":"In particular, you can use it with user-defined types that meet these requirements and, in many cases, with floating-point types.","pos":[3923,4052]},{"content":"The template also has a set of specializations for integral types and a partial specialization for pointers.","pos":[4059,4167]},{"content":"These specializations provide additional operations that are not available through the primary template.","pos":[4168,4272]},{"content":"Pointer Specializations","pos":[4281,4304]},{"content":"The <ph id=\"ph1\">`atomic&lt;T *&gt;`</ph> partial specializations apply to all pointer types.","pos":[4308,4377],"source":"The `atomic<T *>` partial specializations apply to all pointer types."},{"content":"They provide methods for pointer arithmetic.","pos":[4378,4422]},{"content":"Integral Specializations","pos":[4431,4455]},{"content":"The <ph id=\"ph1\">`atomic&lt;integral&gt;`</ph> specializations apply to all integral types.","pos":[4459,4526],"source":"The `atomic<integral>` specializations apply to all integral types."},{"content":"They provide additional operations that are not available through the primary template.","pos":[4527,4614]},{"content":"Each <ph id=\"ph1\">`atomic&lt;integral&gt;`</ph> type has a corresponding macro that you can use in an <ph id=\"ph2\">`if directive`</ph> to determine at compile time whether operations on that type are lock-free.","pos":[4621,4789],"source":"Each `atomic<integral>` type has a corresponding macro that you can use in an `if directive` to determine at compile time whether operations on that type are lock-free."},{"content":"If the value of the macro is zero, operations on the type are not lock-free.","pos":[4790,4866]},{"content":"If the value is 1, operations might be lock-free, and a runtime check is required.","pos":[4867,4949]},{"content":"If the value is 2, operations are lock-free.","pos":[4950,4994]},{"content":"You can use the function <ph id=\"ph1\">`atomic_is_lock_free`</ph> to determine at runtime whether operations on the type are lock-free.","pos":[4995,5111],"source":" You can use the function `atomic_is_lock_free` to determine at runtime whether operations on the type are lock-free."},{"content":"For each of the integral types, there is a corresponding named atomic type that manages an object of that integral type.","pos":[5118,5238]},{"content":"Each <ph id=\"ph1\">`atomic_integral`</ph> type has the same set of member functions as the corresponding instantiation of <ph id=\"ph2\">`atomic&lt;T&gt;`</ph> and can be passed to any of the non-member atomic functions.","pos":[5239,5414],"source":" Each `atomic_integral` type has the same set of member functions as the corresponding instantiation of `atomic<T>` and can be passed to any of the non-member atomic functions."},{"pos":[5439,5443],"content":"Type"},{"content":"Integral Type","pos":[5444,5457]},{"pos":[5480,5485],"content":"Macro"},{"content":"Typedef names exist for specializations of the atomic template for some of the types that are defined in the header <ph id=\"ph1\">\\&lt;</ph>inttypes.h&gt;.","pos":[6371,6501],"source":"Typedef names exist for specializations of the atomic template for some of the types that are defined in the header \\<inttypes.h>."},{"content":"Atomic Type","pos":[6508,6519]},{"content":"Typedef Name","pos":[6520,6532]},{"content":"Structs","pos":[7954,7961]},{"content":"Name","pos":[7968,7972]},{"content":"Description","pos":[7973,7984]},{"content":"atomic Structure","pos":[8023,8039]},{"content":"Describes an object that performs atomic operations on a stored value.","pos":[8082,8152]},{"content":"atomic_flag Structure","pos":[8158,8179]},{"pos":[8227,8293],"content":"Describes an object that atomically sets and clears a <ph id=\"ph1\">`bool`</ph> flag.","source":"Describes an object that atomically sets and clears a `bool` flag."},{"content":"Enums","pos":[8303,8308]},{"content":"Name","pos":[8315,8319]},{"content":"Description","pos":[8320,8331]},{"content":"memory_order Enum","pos":[8370,8387]},{"content":"Supplies symbolic names for synchronization operations on memory locations.","pos":[8444,8519]},{"content":"These operations affect how assignments in one thread become visible in another.","pos":[8520,8600]},{"content":"Functions","pos":[8610,8619]},{"pos":[8623,8885],"content":"In the following list, the functions that do not end in <ph id=\"ph1\">`_explicit`</ph> have the semantics of the corresponding <ph id=\"ph2\">`_explicit`</ph>, except that they have the implicit <bpt id=\"p1\">[</bpt>memory_order<ept id=\"p1\">](../standard-library/atomic-enums.md#memory_order_enum)</ept> arguments of <ph id=\"ph3\">`memory_order_seq_cst`</ph>.","source":"In the following list, the functions that do not end in `_explicit` have the semantics of the corresponding `_explicit`, except that they have the implicit [memory_order](../standard-library/atomic-enums.md#memory_order_enum) arguments of `memory_order_seq_cst`."},{"content":"Name","pos":[8892,8896]},{"content":"Description","pos":[8897,8908]},{"content":"atomic_compare_exchange_strong Function","pos":[8947,8986]},{"pos":[9069,9121],"content":"Performs an <bpt id=\"p1\">*</bpt>atomic compare and exchange<ept id=\"p1\">*</ept> operation.","source":"Performs an *atomic compare and exchange* operation."},{"content":"atomic_compare_exchange_strong_explicit Function","pos":[9127,9175]},{"pos":[9267,9319],"content":"Performs an <bpt id=\"p1\">*</bpt>atomic compare and exchange<ept id=\"p1\">*</ept> operation.","source":"Performs an *atomic compare and exchange* operation."},{"content":"atomic_compare_exchange_weak Function","pos":[9325,9362]},{"pos":[9443,9499],"content":"Performs a <bpt id=\"p1\">*</bpt>weak atomic compare and exchange<ept id=\"p1\">*</ept> operation.","source":"Performs a *weak atomic compare and exchange* operation."},{"content":"atomic_compare_exchange_weak_explicit Function","pos":[9505,9551]},{"pos":[9641,9697],"content":"Performs a <bpt id=\"p1\">*</bpt>weak atomic compare and exchange<ept id=\"p1\">*</ept> operation.","source":"Performs a *weak atomic compare and exchange* operation."},{"content":"atomic_exchange Function","pos":[9703,9727]},{"content":"Replaces a stored value.","pos":[9795,9819]},{"content":"atomic_exchange_explicit Function","pos":[9825,9858]},{"content":"Replaces a stored value.","pos":[9935,9959]},{"content":"atomic_fetch_add Function","pos":[9965,9990]},{"content":"Adds a specified value to an existing stored value.","pos":[10059,10110]},{"content":"atomic_fetch_add_explicit Function","pos":[10116,10150]},{"content":"Adds a specified value to an existing stored value.","pos":[10228,10279]},{"content":"atomic_fetch_and Function","pos":[10285,10310]},{"pos":[10379,10454],"content":"Performs a bitwise <ph id=\"ph1\">`and`</ph> on a specified value and an existing stored value.","source":"Performs a bitwise `and` on a specified value and an existing stored value."},{"content":"atomic_fetch_and_explicit Function","pos":[10460,10494]},{"pos":[10572,10647],"content":"Performs a bitwise <ph id=\"ph1\">`and`</ph> on a specified value and an existing stored value.","source":"Performs a bitwise `and` on a specified value and an existing stored value."},{"content":"atomic_fetch_or Function","pos":[10653,10677]},{"pos":[10745,10819],"content":"Performs a bitwise <ph id=\"ph1\">`or`</ph> on a specified value and an existing stored value.","source":"Performs a bitwise `or` on a specified value and an existing stored value."},{"content":"atomic_fetch_or_explicit Function","pos":[10825,10858]},{"pos":[10935,11009],"content":"Performs a bitwise <ph id=\"ph1\">`or`</ph> on a specified value and an existing stored value.","source":"Performs a bitwise `or` on a specified value and an existing stored value."},{"content":"atomic_fetch_sub Function","pos":[11015,11040]},{"content":"Subtracts a specified value from an existing stored value.","pos":[11109,11167]},{"content":"atomic_fetch_sub_explicit Function","pos":[11173,11207]},{"content":"Subtracts a specified value from an existing stored value.","pos":[11285,11343]},{"content":"atomic_fetch_xor Function","pos":[11349,11374]},{"pos":[11443,11527],"content":"Performs a bitwise <ph id=\"ph1\">`exclusive or`</ph> on a specified value and an existing stored value.","source":"Performs a bitwise `exclusive or` on a specified value and an existing stored value."},{"content":"atomic_fetch_xor_explicit Function","pos":[11533,11567]},{"pos":[11645,11729],"content":"Performs a bitwise <ph id=\"ph1\">`exclusive or`</ph> on a specified value and an existing stored value.","source":"Performs a bitwise `exclusive or` on a specified value and an existing stored value."},{"content":"atomic_flag_clear Function","pos":[11735,11761]},{"pos":[11831,11883],"content":"Sets the flag in an <ph id=\"ph1\">`atomic_flag`</ph> object to <ph id=\"ph2\">`false`</ph>.","source":"Sets the flag in an `atomic_flag` object to `false`."},{"content":"atomic_flag_clear_explicit Function","pos":[11889,11924]},{"pos":[12003,12055],"content":"Sets the flag in an <ph id=\"ph1\">`atomic_flag`</ph> object to <ph id=\"ph2\">`false`</ph>.","source":"Sets the flag in an `atomic_flag` object to `false`."},{"content":"atomic_flag_test_and_set Function","pos":[12061,12094]},{"pos":[12171,12222],"content":"Sets the flag in an <ph id=\"ph1\">`atomic_flag`</ph> object to <ph id=\"ph2\">`true`</ph>.","source":"Sets the flag in an `atomic_flag` object to `true`."},{"content":"atomic_flag_test_and_set_explicit Function","pos":[12228,12270]},{"pos":[12356,12407],"content":"Sets the flag in an <ph id=\"ph1\">`atomic_flag`</ph> object to <ph id=\"ph2\">`true`</ph>.","source":"Sets the flag in an `atomic_flag` object to `true`."},{"content":"atomic_init Function","pos":[12413,12433]},{"pos":[12497,12541],"content":"Sets the stored value in an <ph id=\"ph1\">`atomic`</ph> object.","source":"Sets the stored value in an `atomic` object."},{"content":"atomic_is_lock_free Function","pos":[12547,12575]},{"content":"Specifies whether atomic operations on a specified object are lock-free.","pos":[12647,12719]},{"content":"atomic_load Function","pos":[12725,12745]},{"content":"Atomically retrieves a value.","pos":[12809,12838]},{"content":"atomic_load_explicit Function","pos":[12844,12873]},{"content":"Atomically retrieves a value.","pos":[12946,12975]},{"content":"atomic_signal_fence Function","pos":[12981,13009]},{"pos":[13081,13233],"content":"Acts as a <bpt id=\"p1\">*</bpt>fence<ept id=\"p1\">*</ept> that establishes memory ordering requirements between fences in a calling thread that has signal handlers executed in the same thread.","source":"Acts as a *fence* that establishes memory ordering requirements between fences in a calling thread that has signal handlers executed in the same thread."},{"content":"atomic_store Function","pos":[13239,13260]},{"content":"Atomically stores a value.","pos":[13325,13351]},{"content":"atomic_store_explicit Function","pos":[13357,13387]},{"content":"Atomically stores a value.","pos":[13461,13487]},{"content":"atomic_thread_fence Function","pos":[13493,13521]},{"pos":[13593,13686],"content":"Acts as a <bpt id=\"p1\">*</bpt>fence<ept id=\"p1\">*</ept> that establishes memory ordering requirements with respect to other fences.","source":"Acts as a *fence* that establishes memory ordering requirements with respect to other fences."},{"content":"kill_dependency Function","pos":[13692,13716]},{"content":"Breaks a possible dependency chain.","pos":[13784,13819]},{"content":"See Also","pos":[13829,13837]},{"content":"Header Files Reference","pos":[13842,13864]},{"content":"C++ Standard Library Reference","pos":[13929,13959]}],"content":"---\ntitle: \"&lt;atomic&gt; | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"<atomic>\"\n  - \"atomic/std::atomic_int_least32_t\"\n  - \"atomic/std::atomic_ullong\"\n  - \"atomic/std::atomic_ptrdiff_t\"\n  - \"atomic/std::atomic_char16_t\"\n  - \"atomic/std::atomic_schar\"\n  - \"atomic/std::atomic_ulong\"\n  - \"atomic/std::atomic_uint_fast32_t\"\n  - \"atomic/std::atomic_uint8_t\"\n  - \"atomic/std::atomic_int32_t\"\n  - \"atomic/std::atomic_uint_fast64_t\"\n  - \"atomic/std::atomic_uint32_t\"\n  - \"atomic/std::atomic_int16_t\"\n  - \"atomic/std::atomic_uintmax_t\"\n  - \"atomic/std::atomic_intmax_t\"\n  - \"atomic/std::atomic_long\"\n  - \"atomic/std::atomic_int\"\n  - \"atomic/std::atomic_uint_least8_t\"\n  - \"atomic/std::atomic_size_t\"\n  - \"atomic/std::atomic_uint_fast16_t\"\n  - \"atomic/std::atomic_wchar_t\"\n  - \"atomic/std::atomic_int_fast64_t\"\n  - \"atomic/std::atomic_uint_fast8_t\"\n  - \"atomic/std::atomic_int_fast8_t\"\n  - \"atomic/std::atomic_intptr_t\"\n  - \"atomic/std::atomic_uint\"\n  - \"atomic/std::atomic_uint16_t\"\n  - \"atomic/std::atomic_char32_t\"\n  - \"atomic/std::atomic_uint64_t\"\n  - \"atomic/std::atomic_ushort\"\n  - \"atomic/std::atomic_int_least16_t\"\n  - \"atomic/std::atomic_char\"\n  - \"atomic/std::atomic_uint_least32_t\"\n  - \"atomic/std::atomic_uintptr_t\"\n  - \"atomic/std::atomic_short\"\n  - \"atomic/std::atomic_llong\"\n  - \"atomic/std::atomic_uint_least16_t\"\n  - \"atomic/std::atomic_int_fast16_t\"\n  - \"atomic/std::atomic_int_least8_t\"\n  - \"atomic/std::atomic_int_least64_t\"\n  - \"atomic/std::atomic_int_fast32_t\"\n  - \"atomic/std::atomic_uchar\"\n  - \"atomic/std::atomic_int8_t\"\n  - \"atomic/std::atomic_int64_t\"\n  - \"atomic/std::atomic_uint_least64_t\"\ndev_langs: \n  - \"C++\"\nms.assetid: e79a6b9f-52ff-48da-9554-654c4e1999f6\ncaps.latest.revision: 22\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# &lt;atomic&gt;\nDefines classes and template classes to use to create types that support atomic operations.  \n  \n## Syntax  \n  \n```cpp  \n#include <atomic>  \n```  \n  \n## Remarks  \n  \n> [!NOTE]\n>  In code that's compiled by using **/clr** or **/clr:pure**, this header is blocked.  \n  \n An atomic operation has two key properties that help you use multiple threads to correctly manipulate an object without using mutex locks.  \n  \n-   Because an atomic operation is indivisible, a second atomic operation on the same object from a different thread can obtain the state of the object only before or after the first atomic operation.  \n  \n-   Based on its [memory_order](../standard-library/atomic-enums.md#memory_order_enum) argument, an atomic operation establishes ordering requirements for the visibility of the effects of other atomic operations in the same thread. Consequently, it inhibits compiler optimizations that violate the ordering requirements.  \n  \n On some platforms, it might not be possible to efficiently implement atomic operations for some types without using `mutex` locks. An atomic type is *lock-free* if no atomic operations on that type use locks.  \n  \n **C++11**: In signal-handlers you can perform atomic operations on an object `obj` if `obj.is_lock_free()` or `atomic_is_lock_free(x)` are true.  \n  \n The class [atomic_flag](../standard-library/atomic-flag-structure.md) provides a minimal atomic type that holds a `bool` flag. Its operations are always lock-free.  \n  \n The template class `atomic<T>` stores an object of its argument type `T` and provides atomic access to that stored value. You can instantiate it by using any type that can be copied by using [memcpy](../c-runtime-library/reference/memcpy-wmemcpy.md) and tested for equality by using [memcmp](../c-runtime-library/reference/memcmp-wmemcmp.md). In particular, you can use it with user-defined types that meet these requirements and, in many cases, with floating-point types.  \n  \n The template also has a set of specializations for integral types and a partial specialization for pointers. These specializations provide additional operations that are not available through the primary template.  \n  \n## Pointer Specializations  \n The `atomic<T *>` partial specializations apply to all pointer types. They provide methods for pointer arithmetic.  \n  \n## Integral Specializations  \n The `atomic<integral>` specializations apply to all integral types. They provide additional operations that are not available through the primary template.  \n  \n Each `atomic<integral>` type has a corresponding macro that you can use in an `if directive` to determine at compile time whether operations on that type are lock-free. If the value of the macro is zero, operations on the type are not lock-free. If the value is 1, operations might be lock-free, and a runtime check is required. If the value is 2, operations are lock-free. You can use the function `atomic_is_lock_free` to determine at runtime whether operations on the type are lock-free.  \n  \n For each of the integral types, there is a corresponding named atomic type that manages an object of that integral type. Each `atomic_integral` type has the same set of member functions as the corresponding instantiation of `atomic<T>` and can be passed to any of the non-member atomic functions.  \n  \n|`atomic_integral` Type|Integral Type|`atomic_is_lock_free` Macro|  \n|----------------------------|-------------------|---------------------------------|  \n|`atomic_char`|`char`|`ATOMIC_CHAR_LOCK_FREE`|  \n|`atomic_schar`|`signed char`|`ATOMIC_CHAR_LOCK_FREE`|  \n|`atomic_uchar`|`unsigned char`|`ATOMIC_CHAR_LOCK_FREE`|  \n|`atomic_char16_t`|`char16_t`|`ATOMIC_CHAR16_T_LOCK_FREE`|  \n|`atomic_char32_t`|`char32_t`|`ATOMIC_CHAR32_T_LOCK_FREE`|  \n|`atomic_wchar_t`|`wchar_t`|`ATOMIC_WCHAR_T_LOCK_FREE`|  \n|`atomic_short`|`short`|`ATOMIC_SHORT_LOCK_FREE`|  \n|`atomic_ushort`|`unsigned short`|`ATOMIC_SHORT_LOCK_FREE`|  \n|`atomic_int`|`int`|`ATOMIC_INT_LOCK_FREE`|  \n|`atomic_uint`|`unsigned int`|`ATOMIC_INT_LOCK_FREE`|  \n|`atomic_long`|`long`|`ATOMIC_LONG_LOCK_FREE`|  \n|`atomic_ulong`|`unsigned long`|`ATOMIC_LONG_LOCK_FREE`|  \n|`atomic_llong`|`long long`|`ATOMIC_LLONG_LOCK_FREE`|  \n|`atomic_ullong`|`unsigned long long`|`ATOMIC_LLONG_LOCK_FREE`|  \n  \n Typedef names exist for specializations of the atomic template for some of the types that are defined in the header \\<inttypes.h>.  \n  \n|Atomic Type|Typedef Name|  \n|-----------------|------------------|  \n|`atomic_int8_t`|`atomic<int8_t>`|  \n|`atomic_uint8_t`|`atomic<uint8_t>`|  \n|`atomic_int16_t`|`atomic<int16_t>`|  \n|`atomic_uint16_t`|`atomic<uint16_t>`|  \n|`atomic_int32_t`|`atomic<int32_t>`|  \n|`atomic_uint32_t`|`atomic<uint32_t>`|  \n|`atomic_int64_t`|`atomic<int64_t>`|  \n|`atomic_uint64_t`|`atomic<uint64_t>`|  \n|`atomic_int_least8_t`|`atomic<int_least8_t>`|  \n|`atomic_uint_least8_t`|`atomic<uint_least8_t>`|  \n|`atomic_int_least16_t`|`atomic<int_least16_t>`|  \n|`atomic_uint_least16_t`|`atomic<uint_least16_t>`|  \n|`atomic_int_least32_t`|`atomic<int_least32_t>`|  \n|`atomic_uint_least32_t`|`atomic<uint_least32_t>`|  \n|`atomic_int_least64_t`|`atomic<int_least64_t>`|  \n|`atomic_uint_least64_t`|`atomic<uint_least64_t>`|  \n|`atomic_int_fast8_t`|`atomic<int_fast8_t>`|  \n|`atomic_uint_fast8_t`|`atomic<uint_fast8_t>`|  \n|`atomic_int_fast16_t`|`atomic<int_fast16_t>`|  \n|`atomic_uint_fast16_`|`atomic<uint_fast16_t>`|  \n|`atomic_int_fast32_t`|`atomic<int_fast32_t>`|  \n|`atomic_uint_fast32_t`|`atomic<uint_fast32_t>`|  \n|`atomic_int_fast64_t`|`atomic<int_fast64_t>`|  \n|`atomic_uint_fast64_t`|`atomic<uint_fast64_t>`|  \n|`atomic_intptr_t`|`atomic<intptr_t>`|  \n|`atomic_uintptr_t`|`atomic<uintptr_t>`|  \n|`atomic_size_t`|`atomic<size_t>`|  \n|`atomic_ptrdiff_t`|`atomic<ptrdiff_t>`|  \n|`atomic_intmax_t`|`atomic<intmax_t>`|  \n|`atomic_uintmax_t`|`atomic<uintmax_t>`|  \n  \n## Structs  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[atomic Structure](../standard-library/atomic-structure.md)|Describes an object that performs atomic operations on a stored value.|  \n|[atomic_flag Structure](../standard-library/atomic-flag-structure.md)|Describes an object that atomically sets and clears a `bool` flag.|  \n  \n## Enums  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[memory_order Enum](../standard-library/atomic-enums.md#memory_order_enum)|Supplies symbolic names for synchronization operations on memory locations. These operations affect how assignments in one thread become visible in another.|  \n  \n## Functions  \n In the following list, the functions that do not end in `_explicit` have the semantics of the corresponding `_explicit`, except that they have the implicit [memory_order](../standard-library/atomic-enums.md#memory_order_enum) arguments of `memory_order_seq_cst`.  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[atomic_compare_exchange_strong Function](../standard-library/atomic-functions.md#atomic_compare_exchange_strong_function)|Performs an *atomic compare and exchange* operation.|  \n|[atomic_compare_exchange_strong_explicit Function](../standard-library/atomic-functions.md#atomic_compare_exchange_strong_explicit_function)|Performs an *atomic compare and exchange* operation.|  \n|[atomic_compare_exchange_weak Function](../standard-library/atomic-functions.md#atomic_compare_exchange_weak_function)|Performs a *weak atomic compare and exchange* operation.|  \n|[atomic_compare_exchange_weak_explicit Function](../standard-library/atomic-functions.md#atomic_compare_exchange_weak_explicit_function)|Performs a *weak atomic compare and exchange* operation.|  \n|[atomic_exchange Function](../standard-library/atomic-functions.md#atomic_exchange_function)|Replaces a stored value.|  \n|[atomic_exchange_explicit Function](../standard-library/atomic-functions.md#atomic_exchange_explicit_function)|Replaces a stored value.|  \n|[atomic_fetch_add Function](../standard-library/atomic-functions.md#atomic_fetch_add_function)|Adds a specified value to an existing stored value.|  \n|[atomic_fetch_add_explicit Function](../standard-library/atomic-functions.md#atomic_fetch_add_explicit_function)|Adds a specified value to an existing stored value.|  \n|[atomic_fetch_and Function](../standard-library/atomic-functions.md#atomic_fetch_and_function)|Performs a bitwise `and` on a specified value and an existing stored value.|  \n|[atomic_fetch_and_explicit Function](../standard-library/atomic-functions.md#atomic_fetch_and_explicit_function)|Performs a bitwise `and` on a specified value and an existing stored value.|  \n|[atomic_fetch_or Function](../standard-library/atomic-functions.md#atomic_fetch_or_function)|Performs a bitwise `or` on a specified value and an existing stored value.|  \n|[atomic_fetch_or_explicit Function](../standard-library/atomic-functions.md#atomic_fetch_or_explicit_function)|Performs a bitwise `or` on a specified value and an existing stored value.|  \n|[atomic_fetch_sub Function](../standard-library/atomic-functions.md#atomic_fetch_sub_function)|Subtracts a specified value from an existing stored value.|  \n|[atomic_fetch_sub_explicit Function](../standard-library/atomic-functions.md#atomic_fetch_sub_explicit_function)|Subtracts a specified value from an existing stored value.|  \n|[atomic_fetch_xor Function](../standard-library/atomic-functions.md#atomic_fetch_xor_function)|Performs a bitwise `exclusive or` on a specified value and an existing stored value.|  \n|[atomic_fetch_xor_explicit Function](../standard-library/atomic-functions.md#atomic_fetch_xor_explicit_function)|Performs a bitwise `exclusive or` on a specified value and an existing stored value.|  \n|[atomic_flag_clear Function](../standard-library/atomic-functions.md#atomic_flag_clear_function)|Sets the flag in an `atomic_flag` object to `false`.|  \n|[atomic_flag_clear_explicit Function](../standard-library/atomic-functions.md#atomic_flag_clear_explicit_function)|Sets the flag in an `atomic_flag` object to `false`.|  \n|[atomic_flag_test_and_set Function](../standard-library/atomic-functions.md#atomic_flag_test_and_set_function)|Sets the flag in an `atomic_flag` object to `true`.|  \n|[atomic_flag_test_and_set_explicit Function](../standard-library/atomic-functions.md#atomic_flag_test_and_set_explicit_function)|Sets the flag in an `atomic_flag` object to `true`.|  \n|[atomic_init Function](../standard-library/atomic-functions.md#atomic_init_function)|Sets the stored value in an `atomic` object.|  \n|[atomic_is_lock_free Function](../standard-library/atomic-functions.md#atomic_is_lock_free_function)|Specifies whether atomic operations on a specified object are lock-free.|  \n|[atomic_load Function](../standard-library/atomic-functions.md#atomic_load_function)|Atomically retrieves a value.|  \n|[atomic_load_explicit Function](../standard-library/atomic-functions.md#atomic_load_explicit_function)|Atomically retrieves a value.|  \n|[atomic_signal_fence Function](../standard-library/atomic-functions.md#atomic_signal_fence_function)|Acts as a *fence* that establishes memory ordering requirements between fences in a calling thread that has signal handlers executed in the same thread.|  \n|[atomic_store Function](../standard-library/atomic-functions.md#atomic_store_function)|Atomically stores a value.|  \n|[atomic_store_explicit Function](../standard-library/atomic-functions.md#atomic_store_explicit_function)|Atomically stores a value.|  \n|[atomic_thread_fence Function](../standard-library/atomic-functions.md#atomic_thread_fence_function)|Acts as a *fence* that establishes memory ordering requirements with respect to other fences.|  \n|[kill_dependency Function](../standard-library/atomic-functions.md#kill_dependency_function)|Breaks a possible dependency chain.|  \n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)   \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)\n\n\n\n\n\n"}