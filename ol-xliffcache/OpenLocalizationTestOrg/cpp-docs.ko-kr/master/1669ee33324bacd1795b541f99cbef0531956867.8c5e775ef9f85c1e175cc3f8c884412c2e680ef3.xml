{"nodes":[{"pos":[12,42],"content":"num_get Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"num_get Class | Microsoft Docs","pos":[0,30]}]},{"pos":[657,670],"content":"num_get Class","linkify":"num_get Class","nodes":[{"content":"num_get Class","pos":[0,13]}]},{"pos":[671,819],"content":"A template class that describes an object that can serve as a locale facet to control conversions of sequences of type <ph id=\"ph1\">`CharType`</ph> to numeric values.","source":"A template class that describes an object that can serve as a locale facet to control conversions of sequences of type `CharType` to numeric values."},{"pos":[828,834],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[977,987],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type used within a program to encode characters in a locale.","pos":[1005,1069]},{"content":"The type of iterator from which the numeric get functions read their input.","pos":[1095,1170]},{"pos":[1179,1186],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"As with any locale facet, the static object ID has an initial stored value of zero.","pos":[1190,1273]},{"content":"The first attempt to access its stored value stores a unique positive value in <bpt id=\"p1\">**</bpt>id.<ept id=\"p1\">**</ept>","pos":[1274,1360],"source":" The first attempt to access its stored value stores a unique positive value in **id.**"},{"pos":[1370,1382],"content":"Constructors","linkify":"Constructors","nodes":[{"content":"Constructors","pos":[0,12]}]},{"pos":[1403,1431],"content":"<bpt id=\"p1\">[</bpt>num_get<ept id=\"p1\">](#num_get__num_get)</ept>","source":"[num_get](#num_get__num_get)"},{"pos":[1432,1535],"content":"The constructor for objects of type <ph id=\"ph1\">`num_get`</ph> that are used to extract numerical values from sequences.","source":"The constructor for objects of type `num_get` that are used to extract numerical values from sequences."},{"pos":[1546,1554],"content":"Typedefs","linkify":"Typedefs","nodes":[{"content":"Typedefs","pos":[0,8]}]},{"pos":[1575,1607],"content":"<bpt id=\"p1\">[</bpt>char_type<ept id=\"p1\">](#num_get__char_type)</ept>","source":"[char_type](#num_get__char_type)"},{"content":"A type that is used to describe a character used by a locale.","pos":[1608,1669]},{"pos":[1674,1706],"content":"<bpt id=\"p1\">[</bpt>iter_type<ept id=\"p1\">](#num_get__iter_type)</ept>","source":"[iter_type](#num_get__iter_type)"},{"content":"A type that describes an input iterator.","pos":[1707,1747]},{"pos":[1758,1774],"content":"Member Functions","linkify":"Member Functions","nodes":[{"content":"Member Functions","pos":[0,16]}]},{"pos":[1795,1821],"content":"<bpt id=\"p1\">[</bpt>do_get<ept id=\"p1\">](#num_get__do_get)</ept>","source":"[do_get](#num_get__do_get)"},{"content":"A virtual function that is called to extracts a numerical or Boolean value from a character sequence.","pos":[1822,1923]},{"pos":[1928,1948],"content":"<bpt id=\"p1\">[</bpt>get<ept id=\"p1\">](#num_get__get)</ept>","source":"[get](#num_get__get)"},{"content":"Extracts a numerical or Boolean value from a character sequence.","pos":[1949,2013]},{"pos":[2023,2035],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[2039,2060],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>locale&gt;","source":"**Header:** \\<locale>"},{"pos":[2067,2085],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[2095,2148],"content":"<bpt id=\"p1\">&lt;a name=\"num_get__char_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  num_get::char_type","linkify":"<a name=\"num_get__char_type\"></a>  num_get::char_type","source":"<a name=\"num_get__char_type\"></a>  num_get::char_type"},{"content":"A type that is used to describe a character used by a locale.","pos":[2152,2213]},{"pos":[2264,2271],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[2275,2337],"content":"The type is a synonym for the template parameter <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the template parameter **CharType**."},{"pos":[2347,2394],"content":"<bpt id=\"p1\">&lt;a name=\"num_get__do_get\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  num_get::do_get","linkify":"<a name=\"num_get__do_get\"></a>  num_get::do_get","source":"<a name=\"num_get__do_get\"></a>  num_get::do_get"},{"content":"A virtual function that is called to extracts a numerical or Boolean value from a character sequence.","pos":[2398,2499]},{"pos":[4172,4182],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The beginning of the range of characters from which to read the number.","pos":[4197,4268]},{"content":"The end of the range of characters from which to read the number.","pos":[4285,4350]},{"content":"The <bpt id=\"p1\">[</bpt>ios_base<ept id=\"p1\">](../standard-library/ios-base-class.md)</ept> whose flags are used by the conversion.","pos":[4371,4464],"source":" The [ios_base](../standard-library/ios-base-class.md) whose flags are used by the conversion."},{"content":"The state to which failbit (see <bpt id=\"p1\">[</bpt>ios_base::iostate<ept id=\"p1\">](../standard-library/ios-base-class.md#ios_base__iostate)</ept>) is added upon failure.","pos":[4483,4615],"source":" The state to which failbit (see [ios_base::iostate](../standard-library/ios-base-class.md#ios_base__iostate)) is added upon failure."},{"content":"The value that was read.","pos":[4631,4655]},{"pos":[4665,4677],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The iterator after the value has been read.","pos":[4681,4724]},{"pos":[4734,4741],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first virtual protected member function,","pos":[4745,4789]},{"content":"matches sequential elements beginning at <ph id=\"ph1\">`first`</ph> in the sequence <ph id=\"ph2\">`[``first``,`</ph> <ph id=\"ph3\">`last``)`</ph> until it has recognized a complete, nonempty integer input field.","pos":[4977,5131],"source":"matches sequential elements beginning at `first` in the sequence `[``first``,` `last``)` until it has recognized a complete, nonempty integer input field."},{"content":"If successful, it converts this field to its equivalent value as type <ph id=\"ph1\">`long``,`</ph> and stores the result in <ph id=\"ph2\">`val`</ph>.","pos":[5132,5243],"source":" If successful, it converts this field to its equivalent value as type `long``,` and stores the result in `val`."},{"content":"It returns an iterator designating the first element beyond the numeric input field.","pos":[5244,5328]},{"content":"Otherwise, the function stores nothing in <ph id=\"ph1\">`val`</ph> and sets <ph id=\"ph2\">`ios_base::failbit`</ph> in <ph id=\"ph3\">`state`</ph>.","pos":[5329,5417],"source":" Otherwise, the function stores nothing in `val` and sets `ios_base::failbit` in `state`."},{"content":"It returns an iterator designating the first element beyond any prefix of a valid integer input field.","pos":[5418,5520]},{"content":"In either case, if the return value equals <ph id=\"ph1\">`last`</ph>, the function sets <ph id=\"ph2\">`ios_base::eofbit`</ph> in <ph id=\"ph3\">`state`</ph>.","pos":[5521,5620],"source":" In either case, if the return value equals `last`, the function sets `ios_base::eofbit` in `state`."},{"content":"The integer input field is converted by the same rules used by the scan functions for matching and converting a series of <ph id=\"ph1\">`char`</ph> elements from a file.","pos":[5627,5777],"source":"The integer input field is converted by the same rules used by the scan functions for matching and converting a series of `char` elements from a file."},{"content":"(Each such <ph id=\"ph1\">`char`</ph> element is assumed to map to an equivalent element of type <ph id=\"ph2\">`Elem`</ph> by a simple, one-to-one, mapping.) The equivalent scan conversion specification is determined as follows:","pos":[5778,5967],"source":" (Each such `char` element is assumed to map to an equivalent element of type `Elem` by a simple, one-to-one, mapping.) The equivalent scan conversion specification is determined as follows:"},{"pos":[5974,6185],"content":"If <ph id=\"ph1\">`iosbase.`</ph><bpt id=\"p1\">[</bpt>ios_base::flags<ept id=\"p1\">](../standard-library/ios-base-class.md#ios_base__flags)</ept><ph id=\"ph2\">`() &amp; ios_base::basefield == ios_base::`</ph><bpt id=\"p2\">[</bpt>oct<ept id=\"p2\">](../standard-library/ios-functions.md#oct)</ept>, the conversion specification is <ph id=\"ph3\">`lo`</ph>.","source":"If `iosbase.`[ios_base::flags](../standard-library/ios-base-class.md#ios_base__flags)`() & ios_base::basefield == ios_base::`[oct](../standard-library/ios-functions.md#oct), the conversion specification is `lo`."},{"pos":[6192,6334],"content":"If <ph id=\"ph1\">`iosbase.flags() &amp; ios_base::basefield == ios_base::`</ph><bpt id=\"p1\">[</bpt>hex<ept id=\"p1\">](../standard-library/ios-functions.md#hex)</ept>, the conversion specification is <ph id=\"ph2\">`lx`</ph>.","source":"If `iosbase.flags() & ios_base::basefield == ios_base::`[hex](../standard-library/ios-functions.md#hex), the conversion specification is `lx`."},{"pos":[6341,6427],"content":"If <ph id=\"ph1\">`iosbase.flags() &amp; ios_base::basefield == 0`</ph>, the conversion specification is <ph id=\"ph2\">`li`</ph>.","source":"If `iosbase.flags() & ios_base::basefield == 0`, the conversion specification is `li`."},{"pos":[6434,6482],"content":"Otherwise, the conversion specification is <ph id=\"ph1\">`ld`</ph>.","source":"Otherwise, the conversion specification is `ld`."},{"content":"The format of an integer input field is further determined by the <bpt id=\"p1\">[</bpt>locale facet<ept id=\"p1\">](../standard-library/locale-class.md#facet_class)</ept><ph id=\"ph1\">`fac`</ph> returned by the call <bpt id=\"p2\">[</bpt>use_facet<ept id=\"p2\">](../standard-library/locale-functions.md#use_facet)</ept> <ph id=\"ph2\">`&lt;`</ph><bpt id=\"p3\">[</bpt>numpunct<ept id=\"p3\">](../standard-library/numpunct-class.md)</ept><ph id=\"ph3\">`&lt;Elem&gt;(iosbase.`</ph> <bpt id=\"p4\">[</bpt>ios_base::getloc<ept id=\"p4\">](../standard-library/ios-base-class.md#ios_base__getloc)</ept><ph id=\"ph4\">`())`</ph>.","pos":[6489,6858],"source":"The format of an integer input field is further determined by the [locale facet](../standard-library/locale-class.md#facet_class)`fac` returned by the call [use_facet](../standard-library/locale-functions.md#use_facet) `<`[numpunct](../standard-library/numpunct-class.md)`<Elem>(iosbase.` [ios_base::getloc](../standard-library/ios-base-class.md#ios_base__getloc)`())`."},{"content":"Specifically:","pos":[6859,6872]},{"pos":[6879,7036],"content":"<ph id=\"ph1\">`fac.`</ph> <bpt id=\"p1\">[</bpt>numpunct::grouping<ept id=\"p1\">](../standard-library/numpunct-class.md#numpunct__grouping)</ept> <ph id=\"ph2\">`()`</ph> determines how digits are grouped to the left of any decimal point","source":"`fac.` [numpunct::grouping](../standard-library/numpunct-class.md#numpunct__grouping) `()` determines how digits are grouped to the left of any decimal point"},{"pos":[7043,7233],"content":"<ph id=\"ph1\">`fac.`</ph> <bpt id=\"p1\">[</bpt>numpunct::thousands_sep<ept id=\"p1\">](../standard-library/numpunct-class.md#numpunct__thousands_sep)</ept> <ph id=\"ph2\">`()`</ph> determines the sequence that separates groups of digits to the left of any decimal point.","source":"`fac.` [numpunct::thousands_sep](../standard-library/numpunct-class.md#numpunct__thousands_sep) `()` determines the sequence that separates groups of digits to the left of any decimal point."},{"content":"If no instances of <ph id=\"ph1\">`fac.thousands_sep()`</ph> occur in the numeric input field, no grouping constraint is imposed.","pos":[7240,7349],"source":"If no instances of `fac.thousands_sep()` occur in the numeric input field, no grouping constraint is imposed."},{"content":"Otherwise, any grouping constraints imposed by <ph id=\"ph1\">`fac.grouping()`</ph> are enforced and separators are removed before the scan conversion occurs.","pos":[7350,7488],"source":" Otherwise, any grouping constraints imposed by `fac.grouping()` are enforced and separators are removed before the scan conversion occurs."},{"content":"The fourth virtual protected member function:","pos":[7495,7540]},{"content":"behaves the same as the first, except that it replaces a conversion specification of <ph id=\"ph1\">`ld`</ph> with <ph id=\"ph2\">`lu`</ph>.","pos":[7737,7837],"source":"behaves the same as the first, except that it replaces a conversion specification of `ld` with `lu`."},{"content":"If successful it converts the numeric input field to a value of type <ph id=\"ph1\">`unsigned long`</ph> and stores that value in <ph id=\"ph2\">`val`</ph>.","pos":[7838,7954],"source":" If successful it converts the numeric input field to a value of type `unsigned long` and stores that value in `val`."},{"content":"The fifth virtual protected member function:","pos":[7961,8005]},{"content":"behaves the same as the first, except that it replaces a conversion specification of <ph id=\"ph1\">`ld`</ph> with <ph id=\"ph2\">`lld`</ph>.","pos":[8198,8299],"source":"behaves the same as the first, except that it replaces a conversion specification of `ld` with `lld`."},{"content":"If successful it converts the numeric input field to a value of type <ph id=\"ph1\">`long long`</ph> and stores that value in <ph id=\"ph2\">`val`</ph>.","pos":[8300,8412],"source":" If successful it converts the numeric input field to a value of type `long long` and stores that value in `val`."},{"content":"The sixth virtual protected member function:","pos":[8419,8463]},{"content":"behaves the same as the first, except that it replaces a conversion specification of <ph id=\"ph1\">`ld`</ph> with <ph id=\"ph2\">`llu`</ph>.","pos":[8665,8766],"source":"behaves the same as the first, except that it replaces a conversion specification of `ld` with `llu`."},{"content":"If successful it converts the numeric input field to a value of type <ph id=\"ph1\">`unsigned long long`</ph> and stores that value in <ph id=\"ph2\">`val`</ph>.","pos":[8767,8888],"source":" If successful it converts the numeric input field to a value of type `unsigned long long` and stores that value in `val`."},{"content":"The seventh virtual protected member function:","pos":[8895,8941]},{"content":"behaves the same as the first, except that it endeavors to match a complete, nonempty floating-point input field.","pos":[9130,9243]},{"content":"<ph id=\"ph1\">`fac.`</ph><bpt id=\"p1\">[</bpt>numpunct::decimal_point<ept id=\"p1\">](../standard-library/numpunct-class.md#numpunct__decimal_point)</ept><ph id=\"ph2\">`()`</ph> determines the sequence that separates the integer digits from the fraction digits.","pos":[9244,9426],"source":"`fac.`[numpunct::decimal_point](../standard-library/numpunct-class.md#numpunct__decimal_point)`()` determines the sequence that separates the integer digits from the fraction digits."},{"content":"The equivalent scan conversion specifier is <ph id=\"ph1\">`lf`</ph>.","pos":[9427,9476],"source":" The equivalent scan conversion specifier is `lf`."},{"content":"The eighth virtual protected member function:","pos":[9483,9528]},{"content":"behaves the same as the first, except that it endeavors to match a complete, nonempty floating-point input field.","pos":[9718,9831]},{"content":"<ph id=\"ph1\">`fac.`</ph><bpt id=\"p1\">[</bpt>numpunct::decimal_point<ept id=\"p1\">](../standard-library/numpunct-class.md#numpunct__decimal_point)</ept><ph id=\"ph2\">`()`</ph> determines the sequence that separates the integer digits from the fraction digits.","pos":[9832,10014],"source":"`fac.`[numpunct::decimal_point](../standard-library/numpunct-class.md#numpunct__decimal_point)`()` determines the sequence that separates the integer digits from the fraction digits."},{"content":"The equivalent scan conversion specifier is <ph id=\"ph1\">`lf`</ph>.","pos":[10015,10064],"source":" The equivalent scan conversion specifier is `lf`."},{"content":"The ninth virtual protected member function:","pos":[10071,10115]},{"pos":[10310,10403],"content":"behaves the same as the eighth, except that the equivalent scan conversion specifier is <ph id=\"ph1\">`Lf`</ph>.","source":"behaves the same as the eighth, except that the equivalent scan conversion specifier is `Lf`."},{"content":"The ninth virtual protected member function:","pos":[10410,10454]},{"pos":[10644,10732],"content":"behaves the same the first, except that the equivalent scan conversion specifier is <ph id=\"ph1\">`p`</ph>.","source":"behaves the same the first, except that the equivalent scan conversion specifier is `p`."},{"content":"The last (eleventh) virtual protected member function:","pos":[10739,10793]},{"content":"behaves the same as the first, except that it endeavors to match a complete, nonempty Boolean input field.","pos":[10981,11087]},{"content":"If successful it converts the Boolean input field to a value of type <ph id=\"ph1\">`bool`</ph> and stores that value in <ph id=\"ph2\">`val`</ph>.","pos":[11088,11195],"source":" If successful it converts the Boolean input field to a value of type `bool` and stores that value in `val`."},{"content":"A Boolean input field takes one of two forms.","pos":[11202,11247]},{"content":"If <ph id=\"ph1\">`iosbase.flags() &amp; ios_base::`</ph><bpt id=\"p1\">[</bpt>boolalpha<ept id=\"p1\">](../standard-library/ios-functions.md#boolalpha)</ept> is false, it is the same as an integer input field, except that the converted value must be either 0 (for false) or 1 (for true).","pos":[11248,11470],"source":" If `iosbase.flags() & ios_base::`[boolalpha](../standard-library/ios-functions.md#boolalpha) is false, it is the same as an integer input field, except that the converted value must be either 0 (for false) or 1 (for true)."},{"content":"Otherwise, the sequence must match either <ph id=\"ph1\">`fac.`</ph><bpt id=\"p1\">[</bpt>numpunct::falsename<ept id=\"p1\">](../standard-library/numpunct-class.md#numpunct__falsename)</ept><ph id=\"ph2\">`()`</ph> (for false), or <ph id=\"ph3\">`fac.`</ph><bpt id=\"p2\">[</bpt>numpunct::truename<ept id=\"p2\">](../standard-library/numpunct-class.md#numpunct__truename)</ept><ph id=\"ph4\">`()`</ph> (for true).","pos":[11471,11720],"source":" Otherwise, the sequence must match either `fac.`[numpunct::falsename](../standard-library/numpunct-class.md#numpunct__falsename)`()` (for false), or `fac.`[numpunct::truename](../standard-library/numpunct-class.md#numpunct__truename)`()` (for true)."},{"pos":[11730,11737],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[11742,11840],"content":"See the example for <bpt id=\"p1\">[</bpt>get<ept id=\"p1\">](#num_get__get)</ept>, where the virtual member function is called by <ph id=\"ph1\">`do_get`</ph>.","source":"See the example for [get](#num_get__get), where the virtual member function is called by `do_get`."},{"pos":[11850,11891],"content":"<bpt id=\"p1\">&lt;a name=\"num_get__get\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  num_get::get","linkify":"<a name=\"num_get__get\"></a>  num_get::get","source":"<a name=\"num_get__get\"></a>  num_get::get"},{"content":"Extracts a numerical or Boolean value from a character sequence.","pos":[11895,11959]},{"pos":[13513,13523],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The beginning of the range of characters from which to read the number.","pos":[13538,13609]},{"content":"The end of the range of characters from which to read the number.","pos":[13626,13691]},{"content":"The <bpt id=\"p1\">[</bpt>ios_base<ept id=\"p1\">](../standard-library/ios-base-class.md)</ept> whose flags are used by the conversion.","pos":[13712,13805],"source":" The [ios_base](../standard-library/ios-base-class.md) whose flags are used by the conversion."},{"content":"The state to which failbit (see <bpt id=\"p1\">[</bpt>ios_base::iostate<ept id=\"p1\">](../standard-library/ios-base-class.md#ios_base__iostate)</ept>) is added upon failure.","pos":[13824,13956],"source":" The state to which failbit (see [ios_base::iostate](../standard-library/ios-base-class.md#ios_base__iostate)) is added upon failure."},{"content":"The value that was read.","pos":[13972,13996]},{"pos":[14006,14018],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The iterator after the value has been read.","pos":[14022,14065]},{"pos":[14075,14082],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[14086,14188],"content":"All member functions return <bpt id=\"p1\">[</bpt>do_get<ept id=\"p1\">](#num_get__do_get)</ept>( <ph id=\"ph1\">`first`</ph>, <ph id=\"ph2\">`last`</ph>, <ph id=\"ph3\">`_Iosbase`</ph>, <ph id=\"ph4\">`_State`</ph>, <ph id=\"ph5\">`val`</ph>).","source":"All member functions return [do_get](#num_get__do_get)( `first`, `last`, `_Iosbase`, `_State`, `val`)."},{"content":"The first virtual protected member function tries to match sequential elements beginning at first in the sequence [ <ph id=\"ph1\">`first`</ph>, <ph id=\"ph2\">`last`</ph>) until it has recognized a complete, nonempty integer input field.","pos":[14195,14393],"source":"The first virtual protected member function tries to match sequential elements beginning at first in the sequence [ `first`, `last`) until it has recognized a complete, nonempty integer input field."},{"content":"If successful, it converts this field to its equivalent value as type <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> and stores the result in <ph id=\"ph1\">`val`</ph>.","pos":[14394,14504],"source":" If successful, it converts this field to its equivalent value as type **long** and stores the result in `val`."},{"content":"It returns an iterator designating the first element beyond the numeric input field.","pos":[14505,14589]},{"content":"Otherwise, the function stores nothing in <ph id=\"ph1\">`val`</ph> and sets <ph id=\"ph2\">`ios_base::failbit`</ph> in _ <bpt id=\"p1\">*</bpt>State<ept id=\"p1\">*</ept>.","pos":[14590,14680],"source":" Otherwise, the function stores nothing in `val` and sets `ios_base::failbit` in _ *State*."},{"content":"It returns an iterator designating the first element beyond any prefix of a valid integer input field.","pos":[14681,14783]},{"content":"In either case, if the return value equals <bpt id=\"p1\">**</bpt>last<ept id=\"p1\">**</ept>, the function sets <ph id=\"ph1\">`ios_base::eofbit`</ph> in <ph id=\"ph2\">`_State`</ph>.","pos":[14784,14886],"source":" In either case, if the return value equals **last**, the function sets `ios_base::eofbit` in `_State`."},{"content":"The integer input field is converted by the same rules used by the scan functions for matching and converting a series of <ph id=\"ph1\">`char`</ph> elements from a file.","pos":[14893,15043],"source":"The integer input field is converted by the same rules used by the scan functions for matching and converting a series of `char` elements from a file."},{"content":"Each such <ph id=\"ph1\">`char`</ph> element is assumed to map to an equivalent element of type <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept> by a simple, one-to-one mapping.","pos":[15044,15165],"source":" Each such `char` element is assumed to map to an equivalent element of type **CharType** by a simple, one-to-one mapping."},{"content":"The equivalent scan conversion specification is determined as follows:","pos":[15166,15236]},{"content":"If <bpt id=\"p1\">**</bpt>iosbase<ept id=\"p1\">**</ept>.","pos":[15246,15261],"source":"If **iosbase**."},{"content":"<bpt id=\"p1\">[</bpt>flags<ept id=\"p1\">](../standard-library/ios-base-class.md#ios_base__flags)</ept><ph id=\"ph1\"> &amp; </ph><ph id=\"ph2\">`ios_base::basefield`</ph><ph id=\"ph3\"> == </ph><ph id=\"ph4\">`ios_base::`</ph><bpt id=\"p2\">[</bpt>oct<ept id=\"p2\">](../standard-library/ios-functions.md#oct)</ept>, the conversion specification is <bpt id=\"p3\">**</bpt>lo<ept id=\"p3\">**</ept>.","pos":[15262,15452],"source":"[flags](../standard-library/ios-base-class.md#ios_base__flags) & `ios_base::basefield` == `ios_base::`[oct](../standard-library/ios-functions.md#oct), the conversion specification is **lo**."},{"pos":[15462,15612],"content":"If <bpt id=\"p1\">**</bpt>iosbase.flags<ept id=\"p1\">**</ept><ph id=\"ph1\"> &amp; </ph><bpt id=\"p2\">**</bpt>ios_base::basefield<ept id=\"p2\">**</ept><ph id=\"ph2\"> == </ph><ph id=\"ph3\">`ios_base::`</ph><bpt id=\"p3\">[</bpt>hex<ept id=\"p3\">](../standard-library/ios-functions.md#hex)</ept>, the conversion specification is <bpt id=\"p4\">**</bpt>lx<ept id=\"p4\">**</ept>.","source":"If **iosbase.flags** & **ios_base::basefield** == `ios_base::`[hex](../standard-library/ios-functions.md#hex), the conversion specification is **lx**."},{"pos":[15622,15712],"content":"If <bpt id=\"p1\">**</bpt>iosbase.flags<ept id=\"p1\">**</ept><ph id=\"ph1\"> &amp; </ph><bpt id=\"p2\">**</bpt>ios_base::basefield<ept id=\"p2\">**</ept> == 0, the conversion specification is <ph id=\"ph2\">`li`</ph>.","source":"If **iosbase.flags** & **ios_base::basefield** == 0, the conversion specification is `li`."},{"pos":[15722,15772],"content":"Otherwise, the conversion specification is <bpt id=\"p1\">**</bpt>ld<ept id=\"p1\">**</ept>.","source":"Otherwise, the conversion specification is **ld**."},{"content":"The format of an integer input field is further determined by the <bpt id=\"p1\">[</bpt>locale facet<ept id=\"p1\">](../standard-library/locale-class.md#facet_class)</ept><bpt id=\"p2\">**</bpt>fac<ept id=\"p2\">**</ept> returned by the call <bpt id=\"p3\">[</bpt>use_facet<ept id=\"p3\">](../standard-library/locale-functions.md#use_facet)</ept><ph id=\"ph1\"> &lt; </ph><bpt id=\"p4\">[</bpt>numpunct<ept id=\"p4\">](../standard-library/numpunct-class.md)</ept><ph id=\"ph2\">\\&lt;</ph> <bpt id=\"p5\">**</bpt>Elem<ept id=\"p5\">**</ept>&gt;( <bpt id=\"p6\">**</bpt>iosbase<ept id=\"p6\">**</ept>.","pos":[15779,16077],"source":"The format of an integer input field is further determined by the [locale facet](../standard-library/locale-class.md#facet_class)**fac** returned by the call [use_facet](../standard-library/locale-functions.md#use_facet) < [numpunct](../standard-library/numpunct-class.md)\\< **Elem**>( **iosbase**."},{"content":"<bpt id=\"p1\">[</bpt>getloc<ept id=\"p1\">](../standard-library/ios-base-class.md#ios_base__getloc)</ept>).","pos":[16078,16144],"source":"[getloc](../standard-library/ios-base-class.md#ios_base__getloc))."},{"content":"Specifically:","pos":[16145,16158]},{"content":"<bpt id=\"p1\">**</bpt>fac<ept id=\"p1\">**</ept>.","pos":[16166,16174],"source":"**fac**."},{"content":"<bpt id=\"p1\">[</bpt>grouping<ept id=\"p1\">](../standard-library/numpunct-class.md#numpunct__grouping)</ept> determines how digits are grouped to the left of any decimal point.","pos":[16175,16311],"source":"[grouping](../standard-library/numpunct-class.md#numpunct__grouping) determines how digits are grouped to the left of any decimal point."},{"content":"<bpt id=\"p1\">**</bpt>fac<ept id=\"p1\">**</ept>.","pos":[16319,16327],"source":"**fac**."},{"content":"<bpt id=\"p1\">[</bpt>thousands_sep<ept id=\"p1\">](../standard-library/numpunct-class.md#numpunct__thousands_sep)</ept> determines the sequence that separates groups of digits to the left of any decimal point.","pos":[16328,16496],"source":"[thousands_sep](../standard-library/numpunct-class.md#numpunct__thousands_sep) determines the sequence that separates groups of digits to the left of any decimal point."},{"content":"If no instances of <bpt id=\"p1\">**</bpt>fac<ept id=\"p1\">**</ept>.","pos":[16503,16530],"source":"If no instances of **fac**."},{"content":"<ph id=\"ph1\">`thousands_sep`</ph> occur in the numeric input field, no grouping constraint is imposed.","pos":[16531,16615],"source":"`thousands_sep` occur in the numeric input field, no grouping constraint is imposed."},{"content":"Otherwise, any grouping constraints imposed by <bpt id=\"p1\">**</bpt>fac<ept id=\"p1\">**</ept>.","pos":[16616,16671],"source":" Otherwise, any grouping constraints imposed by **fac**."},{"content":"<bpt id=\"p1\">**</bpt>grouping<ept id=\"p1\">**</ept> is enforced and separators are removed before the scan conversion occurs.","pos":[16672,16758],"source":"**grouping** is enforced and separators are removed before the scan conversion occurs."},{"content":"The second virtual protected member function:","pos":[16765,16810]},{"content":"behaves the same as the first, except that it replaces a conversion specification of <bpt id=\"p1\">**</bpt>ld<ept id=\"p1\">**</ept> with <bpt id=\"p2\">**</bpt>lu<ept id=\"p2\">**</ept>.","pos":[16978,17082],"source":"behaves the same as the first, except that it replaces a conversion specification of **ld** with **lu**."},{"content":"If successful, it converts the numeric input field to a value of type <ph id=\"ph1\">`unsigned long`</ph> and stores that value in <ph id=\"ph2\">`val`</ph>.","pos":[17083,17200],"source":" If successful, it converts the numeric input field to a value of type `unsigned long` and stores that value in `val`."},{"content":"The third virtual protected member function:","pos":[17207,17251]},{"content":"behaves the same as the first, except that it tries to match a complete, nonempty floating-point input field.","pos":[17412,17521]},{"content":"<bpt id=\"p1\">**</bpt>fac<ept id=\"p1\">**</ept>.","pos":[17522,17530],"source":"**fac**."},{"content":"<bpt id=\"p1\">[</bpt>decimal_point<ept id=\"p1\">](../standard-library/numpunct-class.md#numpunct__decimal_point)</ept> determines the sequence that separates the integer digits from the fraction digits.","pos":[17531,17693],"source":"[decimal_point](../standard-library/numpunct-class.md#numpunct__decimal_point) determines the sequence that separates the integer digits from the fraction digits."},{"content":"The equivalent scan conversion specifier is <bpt id=\"p1\">**</bpt>lf<ept id=\"p1\">**</ept>.","pos":[17694,17745],"source":" The equivalent scan conversion specifier is **lf**."},{"content":"The fourth virtual protected member function:","pos":[17752,17797]},{"pos":[17963,18054],"content":"behaves the same the third, except that the equivalent scan conversion specifier is <bpt id=\"p1\">**</bpt>Lf<ept id=\"p1\">**</ept>.","source":"behaves the same the third, except that the equivalent scan conversion specifier is **Lf**."},{"content":"The fifth virtual protected member function:","pos":[18061,18105]},{"pos":[18266,18356],"content":"behaves the same the first, except that the equivalent scan conversion specifier is <bpt id=\"p1\">**</bpt>p<ept id=\"p1\">**</ept>.","source":"behaves the same the first, except that the equivalent scan conversion specifier is **p**."},{"content":"The sixth virtual protected member function:","pos":[18363,18407]},{"content":"behaves the same as the first, except that it tries to match a complete, nonempty boolean input field.","pos":[18566,18668]},{"content":"If successful it converts the Boolean input field to a value of type <ph id=\"ph1\">`bool`</ph> and stores that value in <ph id=\"ph2\">`val`</ph>.","pos":[18669,18776],"source":" If successful it converts the Boolean input field to a value of type `bool` and stores that value in `val`."},{"content":"A boolean input field takes one of two forms.","pos":[18783,18828]},{"content":"If <bpt id=\"p1\">**</bpt>iosbase<ept id=\"p1\">**</ept>.","pos":[18829,18844],"source":" If **iosbase**."},{"content":"<bpt id=\"p1\">**</bpt>flags<ept id=\"p1\">**</ept><ph id=\"ph1\"> &amp; </ph><ph id=\"ph2\">`ios_base::`</ph><bpt id=\"p2\">[</bpt>boolalpha<ept id=\"p2\">](../standard-library/ios-functions.md#boolalpha)</ept> is <bpt id=\"p3\">**</bpt>false<ept id=\"p3\">**</ept>, it is the same as an integer input field, except that the converted value must be either 0 (for <bpt id=\"p4\">**</bpt>false<ept id=\"p4\">**</ept>) or 1 (for <bpt id=\"p5\">**</bpt>true<ept id=\"p5\">**</ept>).","pos":[18845,19070],"source":"**flags** & `ios_base::`[boolalpha](../standard-library/ios-functions.md#boolalpha) is **false**, it is the same as an integer input field, except that the converted value must be either 0 (for **false**) or 1 (for **true**)."},{"content":"Otherwise, the sequence must match either <bpt id=\"p1\">**</bpt>fac<ept id=\"p1\">**</ept>.","pos":[19071,19121],"source":" Otherwise, the sequence must match either **fac**."},{"content":"<bpt id=\"p1\">[</bpt>falsename<ept id=\"p1\">](../standard-library/numpunct-class.md#numpunct__falsename)</ept> (for <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>), or <bpt id=\"p3\">**</bpt>fac<ept id=\"p3\">**</ept>.","pos":[19122,19221],"source":"[falsename](../standard-library/numpunct-class.md#numpunct__falsename) (for **false**), or **fac**."},{"content":"<bpt id=\"p1\">[</bpt>truename<ept id=\"p1\">](../standard-library/numpunct-class.md#numpunct__truename)</ept> (for <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>).","pos":[19222,19306],"source":"[truename](../standard-library/numpunct-class.md#numpunct__truename) (for **true**)."},{"pos":[19316,19323],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[20066,20119],"content":"<bpt id=\"p1\">&lt;a name=\"num_get__iter_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  num_get::iter_type","linkify":"<a name=\"num_get__iter_type\"></a>  num_get::iter_type","source":"<a name=\"num_get__iter_type\"></a>  num_get::iter_type"},{"content":"A type that describes an input iterator.","pos":[20123,20163]},{"pos":[20219,20226],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[20230,20297],"content":"The type is a synonym for the template parameter <bpt id=\"p1\">**</bpt>InputIterator<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the template parameter **InputIterator**."},{"pos":[20307,20356],"content":"<bpt id=\"p1\">&lt;a name=\"num_get__num_get\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  num_get::num_get","linkify":"<a name=\"num_get__num_get\"></a>  num_get::num_get","source":"<a name=\"num_get__num_get\"></a>  num_get::num_get"},{"pos":[20360,20463],"content":"The constructor for objects of type <ph id=\"ph1\">`num_get`</ph> that are used to extract numerical values from sequences.","source":"The constructor for objects of type `num_get` that are used to extract numerical values from sequences."},{"pos":[20522,20532],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Integer value used to specify the type of memory management for the object.","pos":[20547,20622]},{"pos":[20632,20639],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[20643,20716],"content":"The possible values for the <ph id=\"ph1\">`_Refs`</ph> parameter and their significance are:","source":"The possible values for the `_Refs` parameter and their significance are:"},{"content":"0: The lifetime of the object is managed by the locales that contain it.","pos":[20726,20798]},{"content":"1: The lifetime of the object must be manually managed.","pos":[20808,20863]},{"content":"<ph id=\"ph1\">\\&gt;</ph> 0: These values are not defined.","pos":[20873,20908],"source":"\\> 0: These values are not defined."},{"content":"No direct examples are possible, because the destructor is protected.","pos":[20915,20984]},{"pos":[20991,21119],"content":"The constructor initializes its base object with <bpt id=\"p1\">**</bpt>locale::<ept id=\"p1\">**</ept><bpt id=\"p2\">[</bpt>facet<ept id=\"p2\">](../standard-library/locale-class.md#facet_class)</ept>( <ph id=\"ph1\">`_Refs`</ph>).","source":"The constructor initializes its base object with **locale::**[facet](../standard-library/locale-class.md#facet_class)( `_Refs`)."},{"pos":[21128,21136],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>locale&gt;<ept id=\"p1\">](../standard-library/locale.md)</ept><ph id=\"ph2\"> </ph>","pos":[21140,21183],"source":"[\\<locale>](../standard-library/locale.md) "},{"content":"<bpt id=\"p1\"> [</bpt>facet Class<ept id=\"p1\">](../standard-library/locale-class.md#facet_class)</ept><ph id=\"ph1\"> </ph>","pos":[21186,21250],"source":" [facet Class](../standard-library/locale-class.md#facet_class) "},{"content":"<bpt id=\"p1\"> [</bpt>Thread Safety in the C++ Standard Library<ept id=\"p1\">](../standard-library/thread-safety-in-the-cpp-standard-library.md)</ept>","pos":[21253,21363],"source":" [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)"}],"content":"---\ntitle: \"num_get Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"num_get\"\n  - \"std::num_get\"\n  - \"std.num_get\"\n  - \"xlocnum/std::num_get\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"num_get class\"\nms.assetid: 9933735d-3918-4b17-abad-5fca2adc62d7\ncaps.latest.revision: 18\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# num_get Class\nA template class that describes an object that can serve as a locale facet to control conversions of sequences of type `CharType` to numeric values.  \n  \n## Syntax  \n  \n```\ntemplate <class CharType, class InputIterator = istreambuf_iterator<CharType>>  \nclass num_get : public locale::facet;\n```  \n  \n#### Parameters  \n `CharType`  \n The type used within a program to encode characters in a locale.  \n  \n `InputIterator`  \n The type of iterator from which the numeric get functions read their input.  \n  \n## Remarks  \n As with any locale facet, the static object ID has an initial stored value of zero. The first attempt to access its stored value stores a unique positive value in **id.**  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[num_get](#num_get__num_get)|The constructor for objects of type `num_get` that are used to extract numerical values from sequences.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[char_type](#num_get__char_type)|A type that is used to describe a character used by a locale.|  \n|[iter_type](#num_get__iter_type)|A type that describes an input iterator.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[do_get](#num_get__do_get)|A virtual function that is called to extracts a numerical or Boolean value from a character sequence.|  \n|[get](#num_get__get)|Extracts a numerical or Boolean value from a character sequence.|  \n  \n## Requirements  \n **Header:** \\<locale>  \n  \n **Namespace:** std  \n  \n##  <a name=\"num_get__char_type\"></a>  num_get::char_type  \n A type that is used to describe a character used by a locale.  \n  \n```\ntypedef CharType char_type;\n```  \n  \n### Remarks  \n The type is a synonym for the template parameter **CharType**.  \n  \n##  <a name=\"num_get__do_get\"></a>  num_get::do_get  \n A virtual function that is called to extracts a numerical or Boolean value from a character sequence.  \n  \n```\nvirtual iter_type do_get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    long& val) const;virtual iter_type do_get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    unsigned short& val) const;\n\nvirtual iter_type do_get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    unsigned int& val) const;\n\nvirtual iter_type do_get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    unsigned long& val) const;\n\nvirtual iter_type do_get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    long long& val) const;\n\nvirtual iter_type do_get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    unsigned long long& val) const;\n\nvirtual iter_type do_get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    float& val) const;\n\nvirtual iter_type do_get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    double& val) const;\n\nvirtual iter_type do_get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    long double& val) const;\n\nvirtual iter_type do_get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    void *& val) const;\n\nvirtual iter_type do_get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    bool& val) const;\n```  \n  \n### Parameters  \n `first`  \n The beginning of the range of characters from which to read the number.  \n  \n `last`  \n The end of the range of characters from which to read the number.  \n  \n `_Iosbase`  \n The [ios_base](../standard-library/ios-base-class.md) whose flags are used by the conversion.  \n  \n `_State`  \n The state to which failbit (see [ios_base::iostate](../standard-library/ios-base-class.md#ios_base__iostate)) is added upon failure.  \n  \n `val`  \n The value that was read.  \n  \n### Return Value  \n The iterator after the value has been read.  \n  \n### Remarks  \n The first virtual protected member function,  \n  \n `virtual iter_type do_get(`  \n  \n `iter_type first,`  \n  \n `iter_type last,`  \n  \n `ios_base& _Iosbase,`  \n  \n `ios_base::iostate& _State,`  \n  \n `long& val`  \n  \n `) const;`  \n  \n matches sequential elements beginning at `first` in the sequence `[``first``,` `last``)` until it has recognized a complete, nonempty integer input field. If successful, it converts this field to its equivalent value as type `long``,` and stores the result in `val`. It returns an iterator designating the first element beyond the numeric input field. Otherwise, the function stores nothing in `val` and sets `ios_base::failbit` in `state`. It returns an iterator designating the first element beyond any prefix of a valid integer input field. In either case, if the return value equals `last`, the function sets `ios_base::eofbit` in `state`.  \n  \n The integer input field is converted by the same rules used by the scan functions for matching and converting a series of `char` elements from a file. (Each such `char` element is assumed to map to an equivalent element of type `Elem` by a simple, one-to-one, mapping.) The equivalent scan conversion specification is determined as follows:  \n  \n If `iosbase.`[ios_base::flags](../standard-library/ios-base-class.md#ios_base__flags)`() & ios_base::basefield == ios_base::`[oct](../standard-library/ios-functions.md#oct), the conversion specification is `lo`.  \n  \n If `iosbase.flags() & ios_base::basefield == ios_base::`[hex](../standard-library/ios-functions.md#hex), the conversion specification is `lx`.  \n  \n If `iosbase.flags() & ios_base::basefield == 0`, the conversion specification is `li`.  \n  \n Otherwise, the conversion specification is `ld`.  \n  \n The format of an integer input field is further determined by the [locale facet](../standard-library/locale-class.md#facet_class)`fac` returned by the call [use_facet](../standard-library/locale-functions.md#use_facet) `<`[numpunct](../standard-library/numpunct-class.md)`<Elem>(iosbase.` [ios_base::getloc](../standard-library/ios-base-class.md#ios_base__getloc)`())`. Specifically:  \n  \n `fac.` [numpunct::grouping](../standard-library/numpunct-class.md#numpunct__grouping) `()` determines how digits are grouped to the left of any decimal point  \n  \n `fac.` [numpunct::thousands_sep](../standard-library/numpunct-class.md#numpunct__thousands_sep) `()` determines the sequence that separates groups of digits to the left of any decimal point.  \n  \n If no instances of `fac.thousands_sep()` occur in the numeric input field, no grouping constraint is imposed. Otherwise, any grouping constraints imposed by `fac.grouping()` are enforced and separators are removed before the scan conversion occurs.  \n  \n The fourth virtual protected member function:  \n  \n `virtual iter_type do_get(`  \n  \n `iter_type first,`  \n  \n `iter_type last,`  \n  \n `ios_base& _Iosbase,`  \n  \n `ios_base::iostate& _State,`  \n  \n `unsigned long& val`  \n  \n `) const;`  \n  \n behaves the same as the first, except that it replaces a conversion specification of `ld` with `lu`. If successful it converts the numeric input field to a value of type `unsigned long` and stores that value in `val`.  \n  \n The fifth virtual protected member function:  \n  \n `virtual iter_type do_get(`  \n  \n `iter_type first,`  \n  \n `iter_type last,`  \n  \n `ios_base& _Iosbase,`  \n  \n `ios_base::iostate& _State,`  \n  \n `long long& val`  \n  \n `) const;`  \n  \n behaves the same as the first, except that it replaces a conversion specification of `ld` with `lld`. If successful it converts the numeric input field to a value of type `long long` and stores that value in `val`.  \n  \n The sixth virtual protected member function:  \n  \n `virtual iter_type do_get(`  \n  \n `iter_type first,`  \n  \n `iter_type last,`  \n  \n `ios_base& _Iosbase,`  \n  \n `ios_base::iostate& _State,`  \n  \n `unsigned long long& val`  \n  \n `) const;`  \n  \n behaves the same as the first, except that it replaces a conversion specification of `ld` with `llu`. If successful it converts the numeric input field to a value of type `unsigned long long` and stores that value in `val`.  \n  \n The seventh virtual protected member function:  \n  \n `virtual iter_type do_get(`  \n  \n `iter_type first,`  \n  \n `iter_type last,`  \n  \n `ios_base& _Iosbase,`  \n  \n `ios_base::iostate& _State,`  \n  \n `float& val`  \n  \n `) const;`  \n  \n behaves the same as the first, except that it endeavors to match a complete, nonempty floating-point input field. `fac.`[numpunct::decimal_point](../standard-library/numpunct-class.md#numpunct__decimal_point)`()` determines the sequence that separates the integer digits from the fraction digits. The equivalent scan conversion specifier is `lf`.  \n  \n The eighth virtual protected member function:  \n  \n `virtual iter_type do_get(`  \n  \n `iter_type first,`  \n  \n `iter_type last,`  \n  \n `ios_base& _Iosbase,`  \n  \n `ios_base::iostate& _State,`  \n  \n `double& val`  \n  \n `) const;`  \n  \n behaves the same as the first, except that it endeavors to match a complete, nonempty floating-point input field. `fac.`[numpunct::decimal_point](../standard-library/numpunct-class.md#numpunct__decimal_point)`()` determines the sequence that separates the integer digits from the fraction digits. The equivalent scan conversion specifier is `lf`.  \n  \n The ninth virtual protected member function:  \n  \n `virtual iter_type do_get(`  \n  \n `iter_type first,`  \n  \n `iter_type last,`  \n  \n `ios_base& _Iosbase,`  \n  \n `ios_base::iostate& _State,`  \n  \n `long double& val`  \n  \n `) const;`  \n  \n behaves the same as the eighth, except that the equivalent scan conversion specifier is `Lf`.  \n  \n The ninth virtual protected member function:  \n  \n `virtual iter_type do_get(`  \n  \n `iter_type first,`  \n  \n `iter_type last,`  \n  \n `ios_base& _Iosbase,`  \n  \n `ios_base::iostate& _State,`  \n  \n `void *& val`  \n  \n `) const;`  \n  \n behaves the same the first, except that the equivalent scan conversion specifier is `p`.  \n  \n The last (eleventh) virtual protected member function:  \n  \n `virtual iter_type do_get(`  \n  \n `iter_type first,`  \n  \n `iter_type last,`  \n  \n `ios_base& _Iosbase,`  \n  \n `ios_base::iostate& _State,`  \n  \n `bool& val`  \n  \n `) const;`  \n  \n behaves the same as the first, except that it endeavors to match a complete, nonempty Boolean input field. If successful it converts the Boolean input field to a value of type `bool` and stores that value in `val`.  \n  \n A Boolean input field takes one of two forms. If `iosbase.flags() & ios_base::`[boolalpha](../standard-library/ios-functions.md#boolalpha) is false, it is the same as an integer input field, except that the converted value must be either 0 (for false) or 1 (for true). Otherwise, the sequence must match either `fac.`[numpunct::falsename](../standard-library/numpunct-class.md#numpunct__falsename)`()` (for false), or `fac.`[numpunct::truename](../standard-library/numpunct-class.md#numpunct__truename)`()` (for true).  \n  \n### Example  \n  See the example for [get](#num_get__get), where the virtual member function is called by `do_get`.  \n  \n##  <a name=\"num_get__get\"></a>  num_get::get  \n Extracts a numerical or Boolean value from a character sequence.  \n  \n```\niter_type get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    bool& val) const;\n\niter_type get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    unsigned short& val) const;\n\niter_type get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    unsigned int& val) const;\n\niter_type get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    long& val) const;\n\niter_type get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    unsigned long& val) const;\n\niter_type get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    long long& val) const;\n\niter_type get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    unsigned long long& val) const;\n\niter_type get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    float& val) const;\n\niter_type get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    double& val) const;\n\niter_type get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    long double& val) const;\n\niter_type get(\n    iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    void *& val) const;\n```  \n  \n### Parameters  \n `first`  \n The beginning of the range of characters from which to read the number.  \n  \n `last`  \n The end of the range of characters from which to read the number.  \n  \n `_Iosbase`  \n The [ios_base](../standard-library/ios-base-class.md) whose flags are used by the conversion.  \n  \n `_State`  \n The state to which failbit (see [ios_base::iostate](../standard-library/ios-base-class.md#ios_base__iostate)) is added upon failure.  \n  \n `val`  \n The value that was read.  \n  \n### Return Value  \n The iterator after the value has been read.  \n  \n### Remarks  \n All member functions return [do_get](#num_get__do_get)( `first`, `last`, `_Iosbase`, `_State`, `val`).  \n  \n The first virtual protected member function tries to match sequential elements beginning at first in the sequence [ `first`, `last`) until it has recognized a complete, nonempty integer input field. If successful, it converts this field to its equivalent value as type **long** and stores the result in `val`. It returns an iterator designating the first element beyond the numeric input field. Otherwise, the function stores nothing in `val` and sets `ios_base::failbit` in _ *State*. It returns an iterator designating the first element beyond any prefix of a valid integer input field. In either case, if the return value equals **last**, the function sets `ios_base::eofbit` in `_State`.  \n  \n The integer input field is converted by the same rules used by the scan functions for matching and converting a series of `char` elements from a file. Each such `char` element is assumed to map to an equivalent element of type **CharType** by a simple, one-to-one mapping. The equivalent scan conversion specification is determined as follows:  \n  \n-   If **iosbase**. [flags](../standard-library/ios-base-class.md#ios_base__flags) & `ios_base::basefield` == `ios_base::`[oct](../standard-library/ios-functions.md#oct), the conversion specification is **lo**.  \n  \n-   If **iosbase.flags** & **ios_base::basefield** == `ios_base::`[hex](../standard-library/ios-functions.md#hex), the conversion specification is **lx**.  \n  \n-   If **iosbase.flags** & **ios_base::basefield** == 0, the conversion specification is `li`.  \n  \n-   Otherwise, the conversion specification is **ld**.  \n  \n The format of an integer input field is further determined by the [locale facet](../standard-library/locale-class.md#facet_class)**fac** returned by the call [use_facet](../standard-library/locale-functions.md#use_facet) < [numpunct](../standard-library/numpunct-class.md)\\< **Elem**>( **iosbase**. [getloc](../standard-library/ios-base-class.md#ios_base__getloc)). Specifically:  \n  \n- **fac**. [grouping](../standard-library/numpunct-class.md#numpunct__grouping) determines how digits are grouped to the left of any decimal point.  \n  \n- **fac**. [thousands_sep](../standard-library/numpunct-class.md#numpunct__thousands_sep) determines the sequence that separates groups of digits to the left of any decimal point.  \n  \n If no instances of **fac**. `thousands_sep` occur in the numeric input field, no grouping constraint is imposed. Otherwise, any grouping constraints imposed by **fac**. **grouping** is enforced and separators are removed before the scan conversion occurs.  \n  \n The second virtual protected member function:  \n  \n```\nvirtual iter_type do_get(iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    unsigned long& val) const;\n```  \n  \n behaves the same as the first, except that it replaces a conversion specification of **ld** with **lu**. If successful, it converts the numeric input field to a value of type `unsigned long` and stores that value in `val`.  \n  \n The third virtual protected member function:  \n  \n```\nvirtual iter_type do_get(iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    double& val) const;\n```  \n  \n behaves the same as the first, except that it tries to match a complete, nonempty floating-point input field. **fac**. [decimal_point](../standard-library/numpunct-class.md#numpunct__decimal_point) determines the sequence that separates the integer digits from the fraction digits. The equivalent scan conversion specifier is **lf**.  \n  \n The fourth virtual protected member function:  \n  \n```\nvirtual iter_type do_get(iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    long double& val) const;\n```  \n  \n behaves the same the third, except that the equivalent scan conversion specifier is **Lf**.  \n  \n The fifth virtual protected member function:  \n  \n```\nvirtual iter_type do_get(iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    void *& val) const;\n```  \n  \n behaves the same the first, except that the equivalent scan conversion specifier is **p**.  \n  \n The sixth virtual protected member function:  \n  \n```\nvirtual iter_type do_get(iter_type first,\n    iter_type last,\n    ios_base& _Iosbase,\n    ios_base::iostate& _State,\n    bool& val) const;\n```  \n  \n behaves the same as the first, except that it tries to match a complete, nonempty boolean input field. If successful it converts the Boolean input field to a value of type `bool` and stores that value in `val`.  \n  \n A boolean input field takes one of two forms. If **iosbase**. **flags** & `ios_base::`[boolalpha](../standard-library/ios-functions.md#boolalpha) is **false**, it is the same as an integer input field, except that the converted value must be either 0 (for **false**) or 1 (for **true**). Otherwise, the sequence must match either **fac**. [falsename](../standard-library/numpunct-class.md#numpunct__falsename) (for **false**), or **fac**. [truename](../standard-library/numpunct-class.md#numpunct__truename) (for **true**).  \n  \n### Example  \n  \n```cpp  \n// num_get_get.cpp  \n// compile with: /EHsc  \n#include <locale>  \n#include <iostream>  \n#include <sstream>  \nusing namespace std;  \nint main( )  \n{  \n   locale loc( \"german_germany\" );  \n  \n   basic_stringstream<char> psz, psz2;  \n   psz << \"-1000,56\";  \n  \n   ios_base::iostate st = 0;  \n   long double fVal;  \n   cout << use_facet <numpunct <char> >(loc).thousands_sep( ) << endl;  \n  \n   psz.imbue( loc );  \n   use_facet <num_get <char> >  \n   (loc).get( basic_istream<char>::_Iter( psz.rdbuf( ) ),  \n           basic_istream<char>::_Iter(0), psz, st, fVal );  \n  \n   if ( st & ios_base::failbit )  \n      cout << \"money_get( ) FAILED\" << endl;  \n   else  \n      cout << \"money_get( ) = \" << fVal << endl;  \n}  \n```  \n  \n##  <a name=\"num_get__iter_type\"></a>  num_get::iter_type  \n A type that describes an input iterator.  \n  \n```\ntypedef InputIterator iter_type;\n```  \n  \n### Remarks  \n The type is a synonym for the template parameter **InputIterator**.  \n  \n##  <a name=\"num_get__num_get\"></a>  num_get::num_get  \n The constructor for objects of type `num_get` that are used to extract numerical values from sequences.  \n  \n```\nexplicit num_get(size_t _Refs = 0);\n```  \n  \n### Parameters  \n `_Refs`  \n Integer value used to specify the type of memory management for the object.  \n  \n### Remarks  \n The possible values for the `_Refs` parameter and their significance are:  \n  \n-   0: The lifetime of the object is managed by the locales that contain it.  \n  \n-   1: The lifetime of the object must be manually managed.  \n  \n-   \\> 0: These values are not defined.  \n  \n No direct examples are possible, because the destructor is protected.  \n  \n The constructor initializes its base object with **locale::**[facet](../standard-library/locale-class.md#facet_class)( `_Refs`).  \n  \n## See Also  \n [\\<locale>](../standard-library/locale.md)   \n [facet Class](../standard-library/locale-class.md#facet_class)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)\n\n\n\n"}