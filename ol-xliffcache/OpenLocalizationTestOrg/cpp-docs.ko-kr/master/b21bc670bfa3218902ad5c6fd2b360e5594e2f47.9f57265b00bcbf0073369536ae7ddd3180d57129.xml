{"nodes":[{"pos":[12,67],"content":"Managing the State Data of MFC Modules | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Managing the State Data of MFC Modules | Microsoft Docs","pos":[0,55]}]},{"content":"Managing the State Data of MFC Modules","pos":[884,922]},{"content":"This article discusses the state data of MFC modules and how this state is updated when the flow of execution (the path code takes through an application when executing) enters and leaves a module.","pos":[923,1120]},{"content":"Switching module states with the <ph id=\"ph1\">`AFX_MANAGE_STATE`</ph> and <ph id=\"ph2\">`METHOD_PROLOGUE`</ph> macros is also discussed.","pos":[1121,1220],"source":" Switching module states with the `AFX_MANAGE_STATE` and `METHOD_PROLOGUE` macros is also discussed."},{"pos":[1228,1474],"content":"[!NOTE]\n The term \"module\" here refers to an executable program, or to a DLL (or set of DLLs) that operate independently of the rest of the application, but uses a shared copy of the MFC DLL. An ActiveX control is a typical example of a module.","leadings":["","> "],"nodes":[{"content":" The term \"module\" here refers to an executable program, or to a DLL (or set of DLLs) that operate independently of the rest of the application, but uses a shared copy of the MFC DLL. An ActiveX control is a typical example of a module.","pos":[8,244],"nodes":[{"content":"The term \"module\" here refers to an executable program, or to a DLL (or set of DLLs) that operate independently of the rest of the application, but uses a shared copy of the MFC DLL.","pos":[1,183]},{"content":"An ActiveX control is a typical example of a module.","pos":[184,236]}]}]},{"content":"As shown in the following figure, MFC has state data for each module used in an application.","pos":[1481,1573]},{"content":"Examples of this data include Windows instance handles (used for loading resources), pointers to the current <ph id=\"ph1\">`CWinApp`</ph> and <ph id=\"ph2\">`CWinThread`</ph> objects of an application, OLE module reference counts, and a variety of maps that maintain the connections between Windows object handles and corresponding instances of MFC objects.","pos":[1574,1892],"source":" Examples of this data include Windows instance handles (used for loading resources), pointers to the current `CWinApp` and `CWinThread` objects of an application, OLE module reference counts, and a variety of maps that maintain the connections between Windows object handles and corresponding instances of MFC objects."},{"content":"However, when an application uses multiple modules, the state data of each module is not application wide.","pos":[1893,1999]},{"content":"Rather, each module has its own private copy of the MFC's state data.","pos":[2000,2069]},{"content":"State data of a single module &amp;#40;application&amp;#41;","pos":[2078,2129],"source":"State data of a single module &#40;application&#41;"},{"content":"State Data of a Single Module (Application)","pos":[2169,2212]},{"content":"A module's state data is contained in a structure and is always available via a pointer to that structure.","pos":[2219,2325]},{"content":"When the flow of execution enters a particular module, as shown in the following figure, that module's state must be the \"current\" or \"effective\" state.","pos":[2326,2478]},{"content":"Therefore, each thread object has a pointer to the effective state structure of that application.","pos":[2479,2576]},{"content":"Keeping this pointer updated at all times is vital to managing the application's global state and maintaining the integrity of each module's state.","pos":[2577,2724]},{"content":"Incorrect management of the global state can lead to unpredictable application behavior.","pos":[2725,2813]},{"content":"State data of multiple modules","pos":[2822,2852]},{"content":"State Data of Multiple Modules","pos":[2892,2922]},{"content":"In other words, each module is responsible for correctly switching between module states at all of its entry points.","pos":[2929,3045]},{"content":"An \"entry point\" is any place where the flow of execution can enter the module's code.","pos":[3046,3132]},{"content":"Entry points include:","pos":[3133,3154]},{"content":"Exported functions in a DLL","pos":[3165,3192]},{"content":"Member functions of COM interfaces","pos":[3250,3284]},{"content":"Window procedures","pos":[3334,3351]},{"content":"See Also","pos":[3402,3410]},{"content":"General MFC Topics","pos":[3415,3433]}],"content":"---\ntitle: \"Managing the State Data of MFC Modules | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"global state [C++]\"\n  - \"data management [C++], MFC modules\"\n  - \"window procedure entry points [C++]\"\n  - \"exported interfaces and global state [C++]\"\n  - \"module states, saving and restoring\"\n  - \"data management [C++]\"\n  - \"MFC [C++], managing state data\"\n  - \"multiple modules\"\n  - \"module state restored\"\nms.assetid: 81889c11-0101-4a66-ab3c-f81cf199e1bb\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Managing the State Data of MFC Modules\nThis article discusses the state data of MFC modules and how this state is updated when the flow of execution (the path code takes through an application when executing) enters and leaves a module. Switching module states with the `AFX_MANAGE_STATE` and `METHOD_PROLOGUE` macros is also discussed.  \n  \n> [!NOTE]\n>  The term \"module\" here refers to an executable program, or to a DLL (or set of DLLs) that operate independently of the rest of the application, but uses a shared copy of the MFC DLL. An ActiveX control is a typical example of a module.  \n  \n As shown in the following figure, MFC has state data for each module used in an application. Examples of this data include Windows instance handles (used for loading resources), pointers to the current `CWinApp` and `CWinThread` objects of an application, OLE module reference counts, and a variety of maps that maintain the connections between Windows object handles and corresponding instances of MFC objects. However, when an application uses multiple modules, the state data of each module is not application wide. Rather, each module has its own private copy of the MFC's state data.  \n  \n ![State data of a single module &#40;application&#41;](../mfc/media/vc387n1.gif \"vc387n1\")  \nState Data of a Single Module (Application)  \n  \n A module's state data is contained in a structure and is always available via a pointer to that structure. When the flow of execution enters a particular module, as shown in the following figure, that module's state must be the \"current\" or \"effective\" state. Therefore, each thread object has a pointer to the effective state structure of that application. Keeping this pointer updated at all times is vital to managing the application's global state and maintaining the integrity of each module's state. Incorrect management of the global state can lead to unpredictable application behavior.  \n  \n ![State data of multiple modules](../mfc/media/vc387n2.gif \"vc387n2\")  \nState Data of Multiple Modules  \n  \n In other words, each module is responsible for correctly switching between module states at all of its entry points. An \"entry point\" is any place where the flow of execution can enter the module's code. Entry points include:  \n  \n-   [Exported functions in a DLL](../mfc/exported-dll-function-entry-points.md)  \n  \n-   [Member functions of COM interfaces](../mfc/com-interface-entry-points.md)  \n  \n-   [Window procedures](../mfc/window-procedure-entry-points.md)  \n  \n## See Also  \n [General MFC Topics](../mfc/general-mfc-topics.md)\n\n"}