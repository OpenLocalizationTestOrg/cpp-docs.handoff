{"nodes":[{"pos":[12,48],"content":"basic_filebuf Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"basic_filebuf Class | Microsoft Docs","pos":[0,36]}]},{"pos":[693,712],"content":"basic_filebuf Class","linkify":"basic_filebuf Class","nodes":[{"content":"basic_filebuf Class","pos":[0,19]}]},{"pos":[713,917],"content":"Describes a stream buffer that controls the transmission of elements of type <ph id=\"ph1\">`Elem`</ph>, whose character traits are determined by the class <ph id=\"ph2\">`Tr`</ph>, to and from a sequence of elements stored in an external file.","source":"Describes a stream buffer that controls the transmission of elements of type `Elem`, whose character traits are determined by the class `Tr`, to and from a sequence of elements stored in an external file."},{"pos":[926,932],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1069,1079],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The basic element of the file buffer.","pos":[1093,1130]},{"content":"The traits of the basic element of the file buffer (usually <ph id=\"ph1\">`char_traits`</ph><ph id=\"ph2\">&lt; </ph><ph id=\"ph3\">`Elem`</ph>&gt;).","pos":[1145,1229],"source":" The traits of the basic element of the file buffer (usually `char_traits`< `Elem`>)."},{"pos":[1238,1245],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[1249,1472],"content":"The template class describes a stream buffer that controls the transmission of elements of type <ph id=\"ph1\">`Elem`</ph>, whose character traits are determined by the class <ph id=\"ph2\">`Tr`</ph>, to and from a sequence of elements stored in an external file.","source":"The template class describes a stream buffer that controls the transmission of elements of type `Elem`, whose character traits are determined by the class `Tr`, to and from a sequence of elements stored in an external file."},{"pos":[1480,2099],"content":"[!NOTE]\n Objects of type `basic_filebuf` are created with an internal buffer of type `char *` regardless of the `char_type` specified by the type parameter `Elem`. This means that a Unicode string (containing `wchar_t` characters) will be converted to an ANSI string (containing `char` characters) before it is written to the internal buffer. To store Unicode strings in the buffer, create a new buffer of type `wchar_t` and set it using the [basic_streambuf::pubsetbuf](../standard-library/basic-streambuf-class.md#basic_streambuf__pubsetbuf)`()` method. To see an example that demonstrates this behavior, see below.","leadings":["","> "],"nodes":[{"content":" Objects of type `basic_filebuf` are created with an internal buffer of type `char *` regardless of the `char_type` specified by the type parameter `Elem`. This means that a Unicode string (containing `wchar_t` characters) will be converted to an ANSI string (containing `char` characters) before it is written to the internal buffer. To store Unicode strings in the buffer, create a new buffer of type `wchar_t` and set it using the [basic_streambuf::pubsetbuf](../standard-library/basic-streambuf-class.md#basic_streambuf__pubsetbuf)`()` method. To see an example that demonstrates this behavior, see below.","pos":[8,617],"nodes":[{"content":"Objects of type <ph id=\"ph1\">`basic_filebuf`</ph> are created with an internal buffer of type <ph id=\"ph2\">`char *`</ph> regardless of the <ph id=\"ph3\">`char_type`</ph> specified by the type parameter <ph id=\"ph4\">`Elem`</ph>.","pos":[1,155],"source":" Objects of type `basic_filebuf` are created with an internal buffer of type `char *` regardless of the `char_type` specified by the type parameter `Elem`."},{"content":"This means that a Unicode string (containing <ph id=\"ph1\">`wchar_t`</ph> characters) will be converted to an ANSI string (containing <ph id=\"ph2\">`char`</ph> characters) before it is written to the internal buffer.","pos":[156,334],"source":" This means that a Unicode string (containing `wchar_t` characters) will be converted to an ANSI string (containing `char` characters) before it is written to the internal buffer."},{"content":"To store Unicode strings in the buffer, create a new buffer of type <ph id=\"ph1\">`wchar_t`</ph> and set it using the <bpt id=\"p1\">[</bpt>basic_streambuf::pubsetbuf<ept id=\"p1\">](../standard-library/basic-streambuf-class.md#basic_streambuf__pubsetbuf)</ept><ph id=\"ph2\">`()`</ph> method.","pos":[335,547],"source":" To store Unicode strings in the buffer, create a new buffer of type `wchar_t` and set it using the [basic_streambuf::pubsetbuf](../standard-library/basic-streambuf-class.md#basic_streambuf__pubsetbuf)`()` method."},{"content":"To see an example that demonstrates this behavior, see below.","pos":[548,609]}]}]},{"content":"An object of class <ph id=\"ph1\">`basic_filebuf`</ph><ph id=\"ph2\">&lt; </ph><ph id=\"ph3\">`Elem`</ph>, <ph id=\"ph4\">`Tr`</ph>&gt; stores a file pointer, which designates the <ph id=\"ph5\">`FILE`</ph> object that controls the stream associated with an open file.","pos":[2106,2268],"source":"An object of class `basic_filebuf`< `Elem`, `Tr`> stores a file pointer, which designates the `FILE` object that controls the stream associated with an open file."},{"content":"It also stores pointers to two file conversion facets for use by the protected member functions <bpt id=\"p1\">[</bpt>overflow<ept id=\"p1\">](#basic_filebuf__overflow)</ept> and <bpt id=\"p2\">[</bpt>underflow<ept id=\"p2\">](#basic_filebuf__underflow)</ept>.","pos":[2269,2445],"source":" It also stores pointers to two file conversion facets for use by the protected member functions [overflow](#basic_filebuf__overflow) and [underflow](#basic_filebuf__underflow)."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>basic_filebuf::open<ept id=\"p1\">](#basic_filebuf__open)</ept>.","pos":[2446,2516],"source":" For more information, see [basic_filebuf::open](#basic_filebuf__open)."},{"pos":[2525,2532],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[2536,2714],"content":"The following example demonstrates how to force an object of type <ph id=\"ph1\">`basic_filebuf&lt;wchar_t&gt;`</ph> to store Unicode characters in its internal buffer by calling the <ph id=\"ph2\">`pubsetbuf()`</ph> method.","source":"The following example demonstrates how to force an object of type `basic_filebuf<wchar_t>` to store Unicode characters in its internal buffer by calling the `pubsetbuf()` method."},{"pos":[5954,5966],"content":"Constructors","linkify":"Constructors","nodes":[{"content":"Constructors","pos":[0,12]}]},{"pos":[5987,6033],"content":"<bpt id=\"p1\">[</bpt>basic_filebuf<ept id=\"p1\">](#basic_filebuf__basic_filebuf)</ept>","source":"[basic_filebuf](#basic_filebuf__basic_filebuf)"},{"pos":[6034,6079],"content":"Constructs an object of type <ph id=\"ph1\">`basic_filebuf`</ph>.","source":"Constructs an object of type `basic_filebuf`."},{"pos":[6090,6098],"content":"Typedefs","linkify":"Typedefs","nodes":[{"content":"Typedefs","pos":[0,8]}]},{"pos":[6119,6157],"content":"<bpt id=\"p1\">[</bpt>char_type<ept id=\"p1\">](#basic_filebuf__char_type)</ept>","source":"[char_type](#basic_filebuf__char_type)"},{"pos":[6158,6216],"content":"Associates a type name with the <ph id=\"ph1\">`Elem`</ph> template parameter.","source":"Associates a type name with the `Elem` template parameter."},{"pos":[6221,6257],"content":"<bpt id=\"p1\">[</bpt>int_type<ept id=\"p1\">](#basic_filebuf__int_type)</ept>","source":"[int_type](#basic_filebuf__int_type)"},{"pos":[6258,6363],"content":"Makes this type within <ph id=\"ph1\">`basic_filebuf`</ph>'s scope equivalent to the type of the same name in the <ph id=\"ph2\">`Tr`</ph> scope.","source":"Makes this type within `basic_filebuf`'s scope equivalent to the type of the same name in the `Tr` scope."},{"pos":[6368,6404],"content":"<bpt id=\"p1\">[</bpt>off_type<ept id=\"p1\">](#basic_filebuf__off_type)</ept>","source":"[off_type](#basic_filebuf__off_type)"},{"pos":[6405,6510],"content":"Makes this type within <ph id=\"ph1\">`basic_filebuf`</ph>'s scope equivalent to the type of the same name in the <ph id=\"ph2\">`Tr`</ph> scope.","source":"Makes this type within `basic_filebuf`'s scope equivalent to the type of the same name in the `Tr` scope."},{"pos":[6515,6551],"content":"<bpt id=\"p1\">[</bpt>pos_type<ept id=\"p1\">](#basic_filebuf__pos_type)</ept>","source":"[pos_type](#basic_filebuf__pos_type)"},{"pos":[6552,6657],"content":"Makes this type within <ph id=\"ph1\">`basic_filebuf`</ph>'s scope equivalent to the type of the same name in the <ph id=\"ph2\">`Tr`</ph> scope.","source":"Makes this type within `basic_filebuf`'s scope equivalent to the type of the same name in the `Tr` scope."},{"pos":[6662,6704],"content":"<bpt id=\"p1\">[</bpt>traits_type<ept id=\"p1\">](#basic_filebuf__traits_type)</ept>","source":"[traits_type](#basic_filebuf__traits_type)"},{"pos":[6705,6761],"content":"Associates a type name with the <ph id=\"ph1\">`Tr`</ph> template parameter.","source":"Associates a type name with the `Tr` template parameter."},{"pos":[6772,6788],"content":"Member Functions","linkify":"Member Functions","nodes":[{"content":"Member Functions","pos":[0,16]}]},{"pos":[6809,6839],"content":"<bpt id=\"p1\">[</bpt>close<ept id=\"p1\">](#basic_filebuf__close)</ept>","source":"[close](#basic_filebuf__close)"},{"content":"Closes a file.","pos":[6840,6854]},{"pos":[6859,6893],"content":"<bpt id=\"p1\">[</bpt>is_open<ept id=\"p1\">](#basic_filebuf__is_open)</ept>","source":"[is_open](#basic_filebuf__is_open)"},{"content":"Indicates whether a file is open.","pos":[6894,6927]},{"pos":[6932,6960],"content":"<bpt id=\"p1\">[</bpt>open<ept id=\"p1\">](#basic_filebuf__open)</ept>","source":"[open](#basic_filebuf__open)"},{"content":"Opens a file.","pos":[6961,6974]},{"pos":[6979,7015],"content":"<bpt id=\"p1\">[</bpt>overflow<ept id=\"p1\">](#basic_filebuf__overflow)</ept>","source":"[overflow](#basic_filebuf__overflow)"},{"content":"A protected virtual function that can be called when a new character is inserted into a full buffer.","pos":[7016,7116]},{"pos":[7121,7159],"content":"<bpt id=\"p1\">[</bpt>pbackfail<ept id=\"p1\">](#basic_filebuf__pbackfail)</ept>","source":"[pbackfail](#basic_filebuf__pbackfail)"},{"content":"The protected virtual member function tries to put back an element into the input stream, then make it the current element (pointed to by the next pointer).","pos":[7160,7316]},{"pos":[7321,7355],"content":"<bpt id=\"p1\">[</bpt>seekoff<ept id=\"p1\">](#basic_filebuf__seekoff)</ept>","source":"[seekoff](#basic_filebuf__seekoff)"},{"content":"The protected virtual member function tries to alter the current positions for the controlled streams.","pos":[7356,7458]},{"pos":[7463,7497],"content":"<bpt id=\"p1\">[</bpt>seekpos<ept id=\"p1\">](#basic_filebuf__seekpos)</ept>","source":"[seekpos](#basic_filebuf__seekpos)"},{"content":"The protected virtual member function tries to alter the current positions for the controlled streams.","pos":[7498,7600]},{"pos":[7605,7637],"content":"<bpt id=\"p1\">[</bpt>setbuf<ept id=\"p1\">](#basic_filebuf__setbuf)</ept>","source":"[setbuf](#basic_filebuf__setbuf)"},{"content":"The protected virtual member function performs an operation particular to each derived stream buffer.","pos":[7638,7739]},{"pos":[7744,7772],"content":"<bpt id=\"p1\">[</bpt>Swap<ept id=\"p1\">](#basic_filebuf__swap)</ept>","source":"[Swap](#basic_filebuf__swap)"},{"pos":[7773,7877],"content":"Exchanges the content of this <ph id=\"ph1\">`basic_filebuf`</ph> for the content of the provided <ph id=\"ph2\">`basic_filebuf`</ph> parameter.","source":"Exchanges the content of this `basic_filebuf` for the content of the provided `basic_filebuf` parameter."},{"pos":[7882,7910],"content":"<bpt id=\"p1\">[</bpt>sync<ept id=\"p1\">](#basic_filebuf__sync)</ept>","source":"[sync](#basic_filebuf__sync)"},{"content":"Protected, virtual function tries to synchronize the controlled streams with any associated external streams.","pos":[7911,8020]},{"pos":[8025,8101],"content":"<bpt id=\"p1\">[</bpt>uflow<ept id=\"p1\">](../standard-library/basic-streambuf-class.md#basic_streambuf__uflow)</ept>","source":"[uflow](../standard-library/basic-streambuf-class.md#basic_streambuf__uflow)"},{"content":"Protected, virtual function to extract the current element from the input stream.","pos":[8102,8183]},{"pos":[8188,8226],"content":"<bpt id=\"p1\">[</bpt>underflow<ept id=\"p1\">](#basic_filebuf__underflow)</ept>","source":"[underflow](#basic_filebuf__underflow)"},{"content":"Protected, virtual function to extract the current element from the input stream.","pos":[8227,8308]},{"pos":[8318,8330],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[8334,8356],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>fstream&gt;","source":"**Header:** \\<fstream>"},{"pos":[8363,8381],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[8391,8464],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__basic_filebuf\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::basic_filebuf","linkify":"<a name=\"basic_filebuf__basic_filebuf\"></a>  basic_filebuf::basic_filebuf","source":"<a name=\"basic_filebuf__basic_filebuf\"></a>  basic_filebuf::basic_filebuf"},{"pos":[8468,8513],"content":"Constructs an object of type <ph id=\"ph1\">`basic_filebuf`</ph>.","source":"Constructs an object of type `basic_filebuf`."},{"pos":[8594,8601],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first constructor stores a null pointer in all the pointers controlling the input buffer and the output buffer.","pos":[8605,8720]},{"content":"It also stores a null pointer in the file pointer.","pos":[8721,8771]},{"pos":[8778,8885],"content":"The second constructor initializes the object with the contents of <ph id=\"ph1\">`right`</ph>, treated as an rvalue reference.","source":"The second constructor initializes the object with the contents of `right`, treated as an rvalue reference."},{"pos":[8895,8960],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__char_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::char_type","linkify":"<a name=\"basic_filebuf__char_type\"></a>  basic_filebuf::char_type","source":"<a name=\"basic_filebuf__char_type\"></a>  basic_filebuf::char_type"},{"pos":[8964,9024],"content":"Associates a type name with the <bpt id=\"p1\">**</bpt>Elem<ept id=\"p1\">**</ept> template parameter.","source":"Associates a type name with the **Elem** template parameter."},{"pos":[9075,9132],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__close\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::close","linkify":"<a name=\"basic_filebuf__close\"></a>  basic_filebuf::close","source":"<a name=\"basic_filebuf__close\"></a>  basic_filebuf::close"},{"content":"Closes a file.","pos":[9136,9150]},{"pos":[9209,9221],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The member function returns a null pointer if the file pointer is a null pointer.","pos":[9225,9306]},{"pos":[9316,9323],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<bpt id=\"p1\">**</bpt>close<ept id=\"p1\">**</ept> calls <ph id=\"ph1\">`fclose`</ph>( <bpt id=\"p2\">**</bpt>fp<ept id=\"p2\">**</ept>).","pos":[9327,9361],"source":"**close** calls `fclose`( **fp**)."},{"content":"If that function returns a nonzero value, the function returns a null pointer.","pos":[9362,9440]},{"content":"Otherwise, it returns <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> to indicate that the file was successfully closed.","pos":[9441,9522],"source":" Otherwise, it returns **this** to indicate that the file was successfully closed."},{"content":"For a wide stream, if any insertions have occurred since the stream was opened, or since the last call to <ph id=\"ph1\">`streampos`</ph>, the function calls <bpt id=\"p1\">[</bpt>overflow<ept id=\"p1\">](#basic_filebuf__overflow)</ept>.","pos":[9529,9704],"source":"For a wide stream, if any insertions have occurred since the stream was opened, or since the last call to `streampos`, the function calls [overflow](#basic_filebuf__overflow)."},{"content":"It also inserts any sequence needed to restore the initial conversion state, by using the file conversion facet <bpt id=\"p1\">**</bpt>fac<ept id=\"p1\">**</ept> to call <bpt id=\"p2\">**</bpt>fac.unshift<ept id=\"p2\">**</ept> as needed.","pos":[9705,9859],"source":" It also inserts any sequence needed to restore the initial conversion state, by using the file conversion facet **fac** to call **fac.unshift** as needed."},{"content":"Each element <bpt id=\"p1\">**</bpt>byte<ept id=\"p1\">**</ept> of type <ph id=\"ph1\">`char`</ph> thus produced is written to the associated stream designated by the file pointer <bpt id=\"p2\">**</bpt>fp<ept id=\"p2\">**</ept> as if by successive calls of the form <ph id=\"ph2\">`fputc`</ph>( <bpt id=\"p3\">**</bpt>byte<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>fp<ept id=\"p4\">**</ept>).","pos":[9860,10050],"source":" Each element **byte** of type `char` thus produced is written to the associated stream designated by the file pointer **fp** as if by successive calls of the form `fputc`( **byte**, **fp**)."},{"content":"If the call to <bpt id=\"p1\">**</bpt>fac.unshift<ept id=\"p1\">**</ept> or any write fails, the function does not succeed.","pos":[10051,10132],"source":" If the call to **fac.unshift** or any write fails, the function does not succeed."},{"pos":[10142,10149],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following sample assumes two files in the current directory: basic_filebuf_close.txt (contents is \"testing\") and iotest.txt (contents is \"ssss\").","pos":[10154,10303]},{"pos":[11258,11321],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__int_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::int_type","linkify":"<a name=\"basic_filebuf__int_type\"></a>  basic_filebuf::int_type","source":"<a name=\"basic_filebuf__int_type\"></a>  basic_filebuf::int_type"},{"pos":[11325,11430],"content":"Makes this type within basic_filebuf's scope equivalent to the type of the same name in the <bpt id=\"p1\">**</bpt>Tr<ept id=\"p1\">**</ept> scope.","source":"Makes this type within basic_filebuf's scope equivalent to the type of the same name in the **Tr** scope."},{"pos":[11506,11567],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__is_open\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::is_open","linkify":"<a name=\"basic_filebuf__is_open\"></a>  basic_filebuf::is_open","source":"<a name=\"basic_filebuf__is_open\"></a>  basic_filebuf::is_open"},{"content":"Indicates whether a file is open.","pos":[11571,11604]},{"pos":[11651,11663],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[11667,11718],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the file pointer is not a null pointer.","source":"**true** if the file pointer is not a null pointer."},{"pos":[11728,11735],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[12129,12192],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__off_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::off_type","linkify":"<a name=\"basic_filebuf__off_type\"></a>  basic_filebuf::off_type","source":"<a name=\"basic_filebuf__off_type\"></a>  basic_filebuf::off_type"},{"pos":[12196,12301],"content":"Makes this type within basic_filebuf's scope equivalent to the type of the same name in the <bpt id=\"p1\">**</bpt>Tr<ept id=\"p1\">**</ept> scope.","source":"Makes this type within basic_filebuf's scope equivalent to the type of the same name in the **Tr** scope."},{"pos":[12377,12432],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__open\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::open","linkify":"<a name=\"basic_filebuf__open\"></a>  basic_filebuf::open","source":"<a name=\"basic_filebuf__open\"></a>  basic_filebuf::open"},{"content":"Opens a file.","pos":[12436,12449]},{"pos":[12935,12945],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The name of the file to open.","pos":[12964,12993]},{"content":"One of the enumerations in <bpt id=\"p1\">[</bpt>ios_base::openmode<ept id=\"p1\">](../standard-library/ios-base-class.md#ios_base__openmode)</ept>.","pos":[13011,13117],"source":" One of the enumerations in [ios_base::openmode](../standard-library/ios-base-class.md#ios_base__openmode)."},{"content":"The default file opening protection, equivalent to the <ph id=\"ph1\">`shflag`</ph> parameter in <bpt id=\"p1\">[</bpt>_fsopen, _wfsopen<ept id=\"p1\">](../c-runtime-library/reference/fsopen-wfsopen.md)</ept>.","pos":[13135,13282],"source":" The default file opening protection, equivalent to the `shflag` parameter in [_fsopen, _wfsopen](../c-runtime-library/reference/fsopen-wfsopen.md)."},{"pos":[13292,13304],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"If the file pointer is a null pointer, the function returns a null pointer.","pos":[13308,13383]},{"content":"Otherwise, it returns <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept>.","pos":[13384,13415],"source":" Otherwise, it returns **this**."},{"pos":[13425,13432],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function opens the file with filename <bpt id=\"p1\">*</bpt>filename<ept id=\"p1\">*</ept>, by calling <bpt id=\"p2\">[</bpt>fopen<ept id=\"p2\">](../c-runtime-library/reference/fopen-wfopen.md)</ept>( <bpt id=\"p3\">*</bpt>filename<ept id=\"p3\">*</ept>, <bpt id=\"p4\">**</bpt>strmode<ept id=\"p4\">**</ept>).","pos":[13436,13590],"source":"The member function opens the file with filename *filename*, by calling [fopen](../c-runtime-library/reference/fopen-wfopen.md)( *filename*, **strmode**)."},{"content":"<bpt id=\"p1\">**</bpt>strmode<ept id=\"p1\">**</ept> is determined from <bpt id=\"p2\">**</bpt>mode &amp;<ept id=\"p2\">**</ept>~( <bpt id=\"p3\">[</bpt>ate<ept id=\"p3\">](../standard-library/ios-base-class.md#ios_base__openmode)</ept> &amp; &amp;#124; <bpt id=\"p4\">[</bpt>binary<ept id=\"p4\">](../standard-library/ios-base-class.md#ios_base__openmode)</ept>):","pos":[13591,13776],"source":"**strmode** is determined from **mode &**~( [ate](../standard-library/ios-base-class.md#ios_base__openmode) & &#124; [binary](../standard-library/ios-base-class.md#ios_base__openmode)):"},{"pos":[13784,13850],"content":"<bpt id=\"p1\">**</bpt>ios_base::in<ept id=\"p1\">**</ept> becomes <bpt id=\"p2\">**</bpt>\"r\"<ept id=\"p2\">**</ept> (open existing file for reading).","source":"**ios_base::in** becomes **\"r\"** (open existing file for reading)."},{"pos":[13858,14039],"content":"<bpt id=\"p1\">[</bpt>ios_base::out<ept id=\"p1\">](../standard-library/ios-base-class.md#ios_base__fmtflags)</ept> or <bpt id=\"p2\">**</bpt>ios_base::out &amp;#124; ios_base::trunc<ept id=\"p2\">**</ept> becomes <bpt id=\"p3\">**</bpt>\"w\"<ept id=\"p3\">**</ept> (truncate existing file or create for writing).","source":"[ios_base::out](../standard-library/ios-base-class.md#ios_base__fmtflags) or **ios_base::out &#124; ios_base::trunc** becomes **\"w\"** (truncate existing file or create for writing)."},{"pos":[14047,14138],"content":"<bpt id=\"p1\">**</bpt>ios_base::out &amp;#124; app<ept id=\"p1\">**</ept> becomes <bpt id=\"p2\">**</bpt>\"a\"<ept id=\"p2\">**</ept> (open existing file for appending all writes).","source":"**ios_base::out &#124; app** becomes **\"a\"** (open existing file for appending all writes)."},{"pos":[14146,14246],"content":"<bpt id=\"p1\">**</bpt>ios_base::in &amp;#124; ios_base::out<ept id=\"p1\">**</ept> becomes <bpt id=\"p2\">**</bpt>\"r+\"<ept id=\"p2\">**</ept> (open existing file for reading and writing).","source":"**ios_base::in &#124; ios_base::out** becomes **\"r+\"** (open existing file for reading and writing)."},{"pos":[14254,14391],"content":"<bpt id=\"p1\">**</bpt>ios_base::in &amp;#124; ios_base::out &amp;#124; ios_base::trunc<ept id=\"p1\">**</ept> becomes <bpt id=\"p2\">**</bpt>\"w+\"<ept id=\"p2\">**</ept> (truncate existing file or create for reading and writing).","source":"**ios_base::in &#124; ios_base::out &#124; ios_base::trunc** becomes **\"w+\"** (truncate existing file or create for reading and writing)."},{"pos":[14399,14537],"content":"<bpt id=\"p1\">**</bpt>ios_base::in &amp;#124; ios_base::out &amp;#124; ios_base::app<ept id=\"p1\">**</ept> becomes <bpt id=\"p2\">**</bpt>\"a+\"<ept id=\"p2\">**</ept> (open existing file for reading and for appending all writes).","source":"**ios_base::in &#124; ios_base::out &#124; ios_base::app** becomes **\"a+\"** (open existing file for reading and for appending all writes)."},{"content":"If <bpt id=\"p1\">**</bpt>mode &amp; ios_base::binary<ept id=\"p1\">**</ept> is nonzero, the function appends <bpt id=\"p2\">**</bpt>b<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>strmode<ept id=\"p3\">**</ept> to open a binary stream instead of a text stream.","pos":[14544,14678],"source":"If **mode & ios_base::binary** is nonzero, the function appends **b** to **strmode** to open a binary stream instead of a text stream."},{"content":"It then stores the value returned by <ph id=\"ph1\">`fopen`</ph> in the file pointer <bpt id=\"p1\">**</bpt>fp<ept id=\"p1\">**</ept>.","pos":[14679,14751],"source":" It then stores the value returned by `fopen` in the file pointer **fp**."},{"content":"If <bpt id=\"p1\">**</bpt>mode &amp; ios_base::ate<ept id=\"p1\">**</ept> is nonzero and the file pointer is not a null pointer, the function calls <ph id=\"ph1\">`fseek`</ph>( <bpt id=\"p2\">**</bpt>fp<ept id=\"p2\">**</ept>, 0, <ph id=\"ph2\">`SEEK_END`</ph>) to position the stream at end of file.","pos":[14752,14924],"source":" If **mode & ios_base::ate** is nonzero and the file pointer is not a null pointer, the function calls `fseek`( **fp**, 0, `SEEK_END`) to position the stream at end of file."},{"content":"If that positioning operation fails, the function calls <bpt id=\"p1\">[</bpt>close<ept id=\"p1\">](#basic_filebuf__close)</ept>( <bpt id=\"p2\">**</bpt>fp<ept id=\"p2\">**</ept>) and stores a null pointer in the file pointer.","pos":[14925,15067],"source":" If that positioning operation fails, the function calls [close](#basic_filebuf__close)( **fp**) and stores a null pointer in the file pointer."},{"pos":[15074,15483],"content":"If the file pointer is not a null pointer, the function determines the file conversion facet: <ph id=\"ph1\">`use_facet`</ph><ph id=\"ph2\">&lt; </ph><ph id=\"ph3\">`codecvt`</ph><ph id=\"ph4\">&lt; </ph><bpt id=\"p1\">**</bpt>Elem<ept id=\"p1\">**</ept>, <ph id=\"ph5\">`char`</ph>, <bpt id=\"p2\">**</bpt>traits_type::<ept id=\"p2\">**</ept><bpt id=\"p3\">[</bpt>state_type<ept id=\"p3\">](../standard-library/char-traits-struct.md#char_traits__state_type)</ept>&gt; &gt;( <bpt id=\"p4\">[</bpt>getloc<ept id=\"p4\">](../standard-library/basic-streambuf-class.md#basic_streambuf__getloc)</ept>), for use by <bpt id=\"p5\">[</bpt>underflow<ept id=\"p5\">](#basic_filebuf__underflow)</ept> and <bpt id=\"p6\">[</bpt>overflow<ept id=\"p6\">](#basic_filebuf__overflow)</ept>.","source":"If the file pointer is not a null pointer, the function determines the file conversion facet: `use_facet`< `codecvt`< **Elem**, `char`, **traits_type::**[state_type](../standard-library/char-traits-struct.md#char_traits__state_type)> >( [getloc](../standard-library/basic-streambuf-class.md#basic_streambuf__getloc)), for use by [underflow](#basic_filebuf__underflow) and [overflow](#basic_filebuf__overflow)."},{"content":"If the file pointer is a null pointer, the function returns a null pointer.","pos":[15490,15565]},{"content":"Otherwise, it returns <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept>.","pos":[15566,15597],"source":" Otherwise, it returns **this**."},{"pos":[15607,15614],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[15619,15703],"content":"See <bpt id=\"p1\">[</bpt>basic_filebuf::close<ept id=\"p1\">](#basic_filebuf__close)</ept> for an example that uses <bpt id=\"p2\">**</bpt>open<ept id=\"p2\">**</ept>.","source":"See [basic_filebuf::close](#basic_filebuf__close) for an example that uses **open**."},{"pos":[15713,15780],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__operator_eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::operator=","linkify":"<a name=\"basic_filebuf__operator_eq\"></a>  basic_filebuf::operator=","source":"<a name=\"basic_filebuf__operator_eq\"></a>  basic_filebuf::operator="},{"content":"Assign the content of this stream buffer object.","pos":[15784,15832]},{"content":"This is a move assignment involving an rvalue that does not leave a copy behind.","pos":[15833,15913]},{"pos":[15987,15997],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An rvalue reference to a <bpt id=\"p1\">[</bpt>basic_filebuf<ept id=\"p1\">](../standard-library/basic-filebuf-class.md)</ept> object.","pos":[16013,16105],"source":" An rvalue reference to a [basic_filebuf](../standard-library/basic-filebuf-class.md) object."},{"pos":[16115,16127],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Returns *this.","pos":[16131,16145]},{"pos":[16155,16162],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member operator replaces the contents of the object by using the contents of <ph id=\"ph1\">` right`</ph>, treated as an rvalue reference.","pos":[16166,16288],"source":"The member operator replaces the contents of the object by using the contents of ` right`, treated as an rvalue reference."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Rvalue Reference Declarator: &amp;&amp;<ept id=\"p1\">](../cpp/rvalue-reference-declarator-amp-amp.md)</ept>.","pos":[16289,16396],"source":" For more information, see [Rvalue Reference Declarator: &&](../cpp/rvalue-reference-declarator-amp-amp.md)."},{"pos":[16406,16469],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__overflow\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::overflow","linkify":"<a name=\"basic_filebuf__overflow\"></a>  basic_filebuf::overflow","source":"<a name=\"basic_filebuf__overflow\"></a>  basic_filebuf::overflow"},{"content":"Called when a new character is inserted into a full buffer.","pos":[16473,16532]},{"pos":[16619,16629],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The character to insert into the buffer or <bpt id=\"p1\">**</bpt>traits_type::eof<ept id=\"p1\">**</ept>.","pos":[16644,16708],"source":" The character to insert into the buffer or **traits_type::eof**."},{"pos":[16718,16730],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"If the function cannot succeed, it returns <bpt id=\"p1\">**</bpt>traits_type::eof<ept id=\"p1\">**</ept>.","pos":[16734,16798],"source":"If the function cannot succeed, it returns **traits_type::eof**."},{"content":"Otherwise, it returns <bpt id=\"p1\">**</bpt>traits_type::<ept id=\"p1\">**</ept><bpt id=\"p2\">[</bpt>not_eof<ept id=\"p2\">](../standard-library/char-traits-struct.md#char_traits__not_eof)</ept>(_ <bpt id=\"p3\">*</bpt>Meta<ept id=\"p3\">*</ept>).","pos":[16799,16922],"source":" Otherwise, it returns **traits_type::**[not_eof](../standard-library/char-traits-struct.md#char_traits__not_eof)(_ *Meta*)."},{"pos":[16932,16939],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If _ <bpt id=\"p1\">*</bpt>Meta<ept id=\"p1\">*</ept><bpt id=\"p2\">**</bpt>!= traits_type::<ept id=\"p2\">**</ept><bpt id=\"p3\">[</bpt>eof<ept id=\"p3\">](../standard-library/char-traits-struct.md#char_traits__eof)</ept>, the protected virtual member function endeavors to insert the element <bpt id=\"p4\">**</bpt>ch = traits_type::<ept id=\"p4\">**</ept><bpt id=\"p5\">[</bpt>to_char_type<ept id=\"p5\">](../standard-library/char-traits-struct.md#char_traits__to_char_type)</ept>(<ph id=\"ph1\">\\_</ph> <bpt id=\"p6\">*</bpt>Meta<ept id=\"p6\">*</ept>) into the output buffer.","pos":[16943,17251],"source":"If _ *Meta***!= traits_type::**[eof](../standard-library/char-traits-struct.md#char_traits__eof), the protected virtual member function endeavors to insert the element **ch = traits_type::**[to_char_type](../standard-library/char-traits-struct.md#char_traits__to_char_type)(\\_ *Meta*) into the output buffer."},{"content":"It can do so in various ways:","pos":[17252,17281]},{"content":"If a write position is available, it can store the element into the write position and increment the next pointer for the output buffer.","pos":[17291,17427]},{"content":"It can make a write position available by allocating new or additional storage for the output buffer.","pos":[17437,17538]},{"content":"It can convert any pending output in the output buffer, followed by <bpt id=\"p1\">**</bpt>ch<ept id=\"p1\">**</ept>, by using the file conversion facet <bpt id=\"p2\">**</bpt>fac<ept id=\"p2\">**</ept> to call <bpt id=\"p3\">**</bpt>fac.out<ept id=\"p3\">**</ept> as needed.","pos":[17548,17697],"source":"It can convert any pending output in the output buffer, followed by **ch**, by using the file conversion facet **fac** to call **fac.out** as needed."},{"content":"Each element <ph id=\"ph1\">`ch`</ph> of type <bpt id=\"p1\">*</bpt>char<ept id=\"p1\">*</ept> thus produced is written to the associated stream designated by the file pointer <bpt id=\"p2\">**</bpt>fp<ept id=\"p2\">**</ept> as if by successive calls of the form <ph id=\"ph2\">`fputc`</ph>( <bpt id=\"p3\">**</bpt>ch<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>fp<ept id=\"p4\">**</ept>).","pos":[17698,17882],"source":" Each element `ch` of type *char* thus produced is written to the associated stream designated by the file pointer **fp** as if by successive calls of the form `fputc`( **ch**, **fp**)."},{"content":"If any conversion or write fails, the function does not succeed.","pos":[17883,17947]},{"pos":[17957,18022],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__pbackfail\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::pbackfail","linkify":"<a name=\"basic_filebuf__pbackfail\"></a>  basic_filebuf::pbackfail","source":"<a name=\"basic_filebuf__pbackfail\"></a>  basic_filebuf::pbackfail"},{"content":"Tries to put back an element into the input stream, then make it the current element (pointed to by the next pointer).","pos":[18026,18144]},{"pos":[18232,18242],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The character to insert into the buffer, or <bpt id=\"p1\">**</bpt>traits_type::eof<ept id=\"p1\">**</ept>.","pos":[18257,18322],"source":" The character to insert into the buffer, or **traits_type::eof**."},{"pos":[18332,18344],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"If the function cannot succeed, it returns <bpt id=\"p1\">**</bpt>traits_type::eof<ept id=\"p1\">**</ept>.","pos":[18348,18412],"source":"If the function cannot succeed, it returns **traits_type::eof**."},{"content":"Otherwise, it returns <bpt id=\"p1\">**</bpt>traits_type::<ept id=\"p1\">**</ept><bpt id=\"p2\">[</bpt>not_eof<ept id=\"p2\">](../standard-library/char-traits-struct.md#char_traits__not_eof)</ept>(_ <bpt id=\"p3\">*</bpt>Meta<ept id=\"p3\">*</ept>).","pos":[18413,18536],"source":" Otherwise, it returns **traits_type::**[not_eof](../standard-library/char-traits-struct.md#char_traits__not_eof)(_ *Meta*)."},{"pos":[18546,18553],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The protected virtual member function puts back an element into the input buffer and then makes it the current element (pointed to by the next pointer).","pos":[18557,18709]},{"content":"If _ <bpt id=\"p1\">*</bpt>Meta<ept id=\"p1\">*</ept> <bpt id=\"p2\">**</bpt>== traits_type::<ept id=\"p2\">**</ept><bpt id=\"p3\">[</bpt>eof<ept id=\"p3\">](../standard-library/char-traits-struct.md#char_traits__eof)</ept>, the element to push back is effectively the one already in the stream before the current element.","pos":[18710,18906],"source":" If _ *Meta* **== traits_type::**[eof](../standard-library/char-traits-struct.md#char_traits__eof), the element to push back is effectively the one already in the stream before the current element."},{"content":"Otherwise, that element is replaced by <bpt id=\"p1\">**</bpt>ch = traits_type::<ept id=\"p1\">**</ept><bpt id=\"p2\">[</bpt>to_char_type<ept id=\"p2\">](../standard-library/char-traits-struct.md#char_traits__to_char_type)</ept>(<ph id=\"ph1\">\\_</ph> <bpt id=\"p3\">*</bpt>Meta<ept id=\"p3\">*</ept>).","pos":[18907,19063],"source":" Otherwise, that element is replaced by **ch = traits_type::**[to_char_type](../standard-library/char-traits-struct.md#char_traits__to_char_type)(\\_ *Meta*)."},{"content":"The function can put back an element in various ways:","pos":[19064,19117]},{"pos":[19127,19273],"content":"If a putback position is available, and the element stored there compares equal to <bpt id=\"p1\">**</bpt>ch<ept id=\"p1\">**</ept>, it can decrement the next pointer for the input buffer.","source":"If a putback position is available, and the element stored there compares equal to **ch**, it can decrement the next pointer for the input buffer."},{"pos":[19283,19436],"content":"If the function can make a <ph id=\"ph1\">`putback`</ph> position available, it can do so, set the next pointer to point at that position, and store <bpt id=\"p1\">**</bpt>ch<ept id=\"p1\">**</ept> in that position.","source":"If the function can make a `putback` position available, it can do so, set the next pointer to point at that position, and store **ch** in that position."},{"pos":[19446,19584],"content":"If the function can push back an element onto the input stream, it can do so, such as by calling <ph id=\"ph1\">`ungetc`</ph> for an element of type <ph id=\"ph2\">`char`</ph><bpt id=\"p1\">*</bpt>.<ept id=\"p1\">*</ept>","source":"If the function can push back an element onto the input stream, it can do so, such as by calling `ungetc` for an element of type `char`*.*"},{"pos":[19594,19657],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__pos_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::pos_type","linkify":"<a name=\"basic_filebuf__pos_type\"></a>  basic_filebuf::pos_type","source":"<a name=\"basic_filebuf__pos_type\"></a>  basic_filebuf::pos_type"},{"pos":[19661,19766],"content":"Makes this type within basic_filebuf's scope equivalent to the type of the same name in the <bpt id=\"p1\">**</bpt>Tr<ept id=\"p1\">**</ept> scope.","source":"Makes this type within basic_filebuf's scope equivalent to the type of the same name in the **Tr** scope."},{"pos":[19842,19903],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__seekoff\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::seekoff","linkify":"<a name=\"basic_filebuf__seekoff\"></a>  basic_filebuf::seekoff","source":"<a name=\"basic_filebuf__seekoff\"></a>  basic_filebuf::seekoff"},{"content":"Tries to alter the current positions for the controlled streams.","pos":[19907,19971]},{"pos":[20127,20137],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The position to seek for relative to <ph id=\"ph1\">`_Way`</ph>.","pos":[20151,20195],"source":" The position to seek for relative to `_Way`."},{"content":"The starting point for offset operations.","pos":[20212,20253]},{"content":"See <bpt id=\"p1\">[</bpt>seekdir<ept id=\"p1\">](../standard-library/ios-base-class.md#ios_base__seekdir)</ept> for possible values.","pos":[20254,20345],"source":" See [seekdir](../standard-library/ios-base-class.md#ios_base__seekdir) for possible values."},{"content":"Specifies the mode for the pointer position.","pos":[20364,20408]},{"content":"The default is to allow you to modify the read and write positions.","pos":[20409,20476]},{"pos":[20486,20498],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Returns the new position or an invalid stream position.","pos":[20502,20557]},{"pos":[20567,20574],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The protected virtual member function endeavors to alter the current positions for the controlled streams.","pos":[20578,20684]},{"content":"For an object of class <bpt id=\"p1\">[</bpt>basic_filebuf<ept id=\"p1\">](../standard-library/basic-filebuf-class.md)</ept><ph id=\"ph1\">&lt; </ph><ph id=\"ph2\">`Elem`</ph>, <ph id=\"ph3\">`Tr`</ph>&gt;, a stream position can be represented by an object of type <ph id=\"ph4\">`fpos_t`</ph>, which stores an offset and any state information needed to parse a wide stream.","pos":[20685,20931],"source":" For an object of class [basic_filebuf](../standard-library/basic-filebuf-class.md)< `Elem`, `Tr`>, a stream position can be represented by an object of type `fpos_t`, which stores an offset and any state information needed to parse a wide stream."},{"content":"Offset zero designates the first element of the stream.","pos":[20932,20987]},{"content":"(An object of type <bpt id=\"p1\">[</bpt>pos_type<ept id=\"p1\">](../standard-library/basic-streambuf-class.md#basic_streambuf__pos_type)</ept> stores at least an <ph id=\"ph1\">`fpos_t`</ph> object.)","pos":[20988,21126],"source":" (An object of type [pos_type](../standard-library/basic-streambuf-class.md#basic_streambuf__pos_type) stores at least an `fpos_t` object.)"},{"content":"For a file opened for both reading and writing, both the input and output streams are positioned in tandem.","pos":[21133,21240]},{"content":"To switch between inserting and extracting, you must call either <bpt id=\"p1\">[</bpt>pubseekoff<ept id=\"p1\">](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekoff)</ept> or <bpt id=\"p2\">[</bpt>pubseekpos<ept id=\"p2\">](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekpos)</ept>.","pos":[21241,21483],"source":" To switch between inserting and extracting, you must call either [pubseekoff](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekoff) or [pubseekpos](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekpos)."},{"content":"Calls to <ph id=\"ph1\">`pubseekoff`</ph> (and hence to <ph id=\"ph2\">`seekoff`</ph>) have various limitations for <bpt id=\"p1\">[</bpt>text streams<ept id=\"p1\">](../c-runtime-library/text-and-binary-streams.md)</ept>, <bpt id=\"p2\">[</bpt>binary streams<ept id=\"p2\">](../c-runtime-library/text-and-binary-streams.md)</ept>, and <bpt id=\"p3\">[</bpt>wide streams<ept id=\"p3\">](../c-runtime-library/byte-and-wide-streams.md)</ept>.","pos":[21484,21758],"source":" Calls to `pubseekoff` (and hence to `seekoff`) have various limitations for [text streams](../c-runtime-library/text-and-binary-streams.md), [binary streams](../c-runtime-library/text-and-binary-streams.md), and [wide streams](../c-runtime-library/byte-and-wide-streams.md)."},{"content":"If the file pointer <bpt id=\"p1\">**</bpt>fp<ept id=\"p1\">**</ept> is a null pointer, the function fails.","pos":[21765,21830],"source":"If the file pointer **fp** is a null pointer, the function fails."},{"content":"Otherwise, it endeavors to alter the stream position by calling <ph id=\"ph1\">`fseek`</ph>( <bpt id=\"p1\">**</bpt>fp<ept id=\"p1\">**</ept>, <ph id=\"ph2\">`_Off`</ph>, <ph id=\"ph3\">`_Way`</ph>).","pos":[21831,21928],"source":" Otherwise, it endeavors to alter the stream position by calling `fseek`( **fp**, `_Off`, `_Way`)."},{"content":"If that function succeeds and the resulting position <bpt id=\"p1\">**</bpt>fposn<ept id=\"p1\">**</ept> can be determined by calling <ph id=\"ph1\">`fgetpos`</ph>( <bpt id=\"p2\">**</bpt>fp<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>&amp;fposn<ept id=\"p3\">**</ept>), the function succeeds.","pos":[21929,22075],"source":" If that function succeeds and the resulting position **fposn** can be determined by calling `fgetpos`( **fp**, **&fposn**), the function succeeds."},{"content":"If the function succeeds, it returns a value of type <bpt id=\"p1\">**</bpt>pos_type<ept id=\"p1\">**</ept> containing <bpt id=\"p2\">**</bpt>fposn<ept id=\"p2\">**</ept>.","pos":[22076,22163],"source":" If the function succeeds, it returns a value of type **pos_type** containing **fposn**."},{"content":"Otherwise, it returns an invalid stream position.","pos":[22164,22213]},{"pos":[22223,22284],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__seekpos\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::seekpos","linkify":"<a name=\"basic_filebuf__seekpos\"></a>  basic_filebuf::seekpos","source":"<a name=\"basic_filebuf__seekpos\"></a>  basic_filebuf::seekpos"},{"content":"Tries to alter the current positions for the controlled streams.","pos":[22288,22352]},{"pos":[22475,22485],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The position to seek for.","pos":[22498,22523]},{"content":"Specifies the mode for the pointer position.","pos":[22542,22586]},{"content":"The default is to allow you to modify the read and write positions.","pos":[22587,22654]},{"pos":[22664,22676],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"If the file pointer <bpt id=\"p1\">**</bpt>fp<ept id=\"p1\">**</ept> is a null pointer, the function fails.","pos":[22680,22745],"source":"If the file pointer **fp** is a null pointer, the function fails."},{"content":"Otherwise, it endeavors to alter the stream position by calling <ph id=\"ph1\">`fsetpos`</ph>( <bpt id=\"p1\">**</bpt>fp<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>&amp;fposn<ept id=\"p2\">**</ept>), where <bpt id=\"p3\">**</bpt>fposn<ept id=\"p3\">**</ept> is the <ph id=\"ph2\">`fpos_t`</ph> object stored in <ph id=\"ph3\">`pos`</ph>.","pos":[22746,22897],"source":" Otherwise, it endeavors to alter the stream position by calling `fsetpos`( **fp**, **&fposn**), where **fposn** is the `fpos_t` object stored in `pos`."},{"content":"If that function succeeds, the function returns <ph id=\"ph1\">`pos`</ph>.","pos":[22898,22952],"source":" If that function succeeds, the function returns `pos`."},{"content":"Otherwise, it returns an invalid stream position.","pos":[22953,23002]},{"content":"To determine if the stream position is invalid, compare the return value with <ph id=\"ph1\">`pos_type(off_type(-1))`</ph>.","pos":[23003,23106],"source":" To determine if the stream position is invalid, compare the return value with `pos_type(off_type(-1))`."},{"pos":[23116,23123],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The protected virtual member function endeavors to alter the current positions for the controlled streams.","pos":[23127,23233]},{"content":"For an object of class <bpt id=\"p1\">[</bpt>basic_filebuf<ept id=\"p1\">](../standard-library/basic-filebuf-class.md)</ept><ph id=\"ph1\">\\&lt;</ph> <bpt id=\"p2\">**</bpt>Elem<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>Tr<ept id=\"p3\">**</ept>&gt;, a stream position can be represented by an object of type <ph id=\"ph2\">`fpos_t`</ph>, which stores an offset and any state information needed to parse a wide stream.","pos":[23234,23485],"source":" For an object of class [basic_filebuf](../standard-library/basic-filebuf-class.md)\\< **Elem**, **Tr**>, a stream position can be represented by an object of type `fpos_t`, which stores an offset and any state information needed to parse a wide stream."},{"content":"Offset zero designates the first element of the stream.","pos":[23486,23541]},{"content":"(An object of type <ph id=\"ph1\">`pos_type`</ph> stores at least an <ph id=\"ph2\">`fpos_t`</ph> object.)","pos":[23542,23608],"source":" (An object of type `pos_type` stores at least an `fpos_t` object.)"},{"content":"For a file opened for both reading and writing, both the input and output streams are positioned in tandem.","pos":[23615,23722]},{"content":"To switch between inserting and extracting, you must call either <bpt id=\"p1\">[</bpt>pubseekoff<ept id=\"p1\">](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekoff)</ept> or <bpt id=\"p2\">[</bpt>pubseekpos<ept id=\"p2\">](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekpos)</ept>.","pos":[23723,23965],"source":" To switch between inserting and extracting, you must call either [pubseekoff](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekoff) or [pubseekpos](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekpos)."},{"content":"Calls to <ph id=\"ph1\">`pubseekoff`</ph> (and hence to <ph id=\"ph2\">`seekoff`</ph>) have various limitations for text streams, binary streams, and wide streams.","pos":[23966,24089],"source":" Calls to `pubseekoff` (and hence to `seekoff`) have various limitations for text streams, binary streams, and wide streams."},{"content":"For a wide stream, if any insertions have occurred since the stream was opened, or since the last call to <ph id=\"ph1\">`streampos`</ph>, the function calls <bpt id=\"p1\">[</bpt>overflow<ept id=\"p1\">](#basic_filebuf__overflow)</ept>.","pos":[24096,24271],"source":"For a wide stream, if any insertions have occurred since the stream was opened, or since the last call to `streampos`, the function calls [overflow](#basic_filebuf__overflow)."},{"content":"It also inserts any sequence needed to restore the initial conversion state, by using the file conversion facet <bpt id=\"p1\">**</bpt>fac<ept id=\"p1\">**</ept> to call <bpt id=\"p2\">**</bpt>fac<ept id=\"p2\">**</ept><ph id=\"ph1\">`.``unshift`</ph> as needed.","pos":[24272,24430],"source":" It also inserts any sequence needed to restore the initial conversion state, by using the file conversion facet **fac** to call **fac**`.``unshift` as needed."},{"content":"Each element <bpt id=\"p1\">**</bpt>byte<ept id=\"p1\">**</ept> of type <ph id=\"ph1\">`char`</ph> thus produced is written to the associated stream designated by the file pointer <bpt id=\"p2\">**</bpt>fp<ept id=\"p2\">**</ept> as if by successive calls of the form <ph id=\"ph2\">`fputc`</ph>( <bpt id=\"p3\">**</bpt>byte<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>fp<ept id=\"p4\">**</ept>).","pos":[24431,24621],"source":" Each element **byte** of type `char` thus produced is written to the associated stream designated by the file pointer **fp** as if by successive calls of the form `fputc`( **byte**, **fp**)."},{"content":"If the call to <bpt id=\"p1\">**</bpt>fac.unshift<ept id=\"p1\">**</ept> or any write fails, the function does not succeed.","pos":[24622,24703],"source":" If the call to **fac.unshift** or any write fails, the function does not succeed."},{"pos":[24713,24772],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__setbuf\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::setbuf","linkify":"<a name=\"basic_filebuf__setbuf\"></a>  basic_filebuf::setbuf","source":"<a name=\"basic_filebuf__setbuf\"></a>  basic_filebuf::setbuf"},{"content":"Performs an operation particular to each derived stream buffer.","pos":[24776,24839]},{"pos":[24956,24966],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Pointer to a buffer.","pos":[24983,25003]},{"content":"Size of the buffer.","pos":[25022,25041]},{"pos":[25051,25063],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[25067,25153],"content":"The protected member function returns zero if the file pointer <ph id=\"ph1\">`fp`</ph> is a null pointer.","source":"The protected member function returns zero if the file pointer `fp` is a null pointer."},{"pos":[25163,25170],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`setbuf`</ph> calls <ph id=\"ph2\">`setvbuf`</ph>( <bpt id=\"p1\">**</bpt>fp<ept id=\"p1\">**</ept>, ( <ph id=\"ph3\">`char`</ph> <ph id=\"ph4\">\\*</ph>) <ph id=\"ph5\">`_Buffer`</ph>, <ph id=\"ph6\">`_IOFBF`</ph>, <ph id=\"ph7\">` count`</ph> <ph id=\"ph8\">\\*</ph> <ph id=\"ph9\">`sizeof`</ph> ( <bpt id=\"p2\">**</bpt>Elem<ept id=\"p2\">**</ept>) ) to offer the array of <ph id=\"ph10\">` count`</ph> elements beginning at _ <bpt id=\"p3\">*</bpt>Buffer<ept id=\"p3\">*</ept> as a buffer for the stream.","pos":[25174,25368],"source":"`setbuf` calls `setvbuf`( **fp**, ( `char` \\*) `_Buffer`, `_IOFBF`, ` count` \\* `sizeof` ( **Elem**) ) to offer the array of ` count` elements beginning at _ *Buffer* as a buffer for the stream."},{"content":"If that function returns a nonzero value, the function returns a null pointer.","pos":[25369,25447]},{"content":"Otherwise, it returns <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> to signal success.","pos":[25448,25497],"source":" Otherwise, it returns **this** to signal success."},{"pos":[25507,25562],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__swap\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::swap","linkify":"<a name=\"basic_filebuf__swap\"></a>  basic_filebuf::swap","source":"<a name=\"basic_filebuf__swap\"></a>  basic_filebuf::swap"},{"pos":[25566,25662],"content":"Exchanges the contents of this <ph id=\"ph1\">`basic_filebuf`</ph> for the contents of the provided <ph id=\"ph2\">`basic_filebuf`</ph>.","source":"Exchanges the contents of this `basic_filebuf` for the contents of the provided `basic_filebuf`."},{"pos":[25720,25730],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An <ph id=\"ph1\">`lvalue`</ph> reference to another <ph id=\"ph2\">`basic_filebuf`</ph>.","pos":[25746,25795],"source":" An `lvalue` reference to another `basic_filebuf`."},{"pos":[25805,25860],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__sync\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::sync","linkify":"<a name=\"basic_filebuf__sync\"></a>  basic_filebuf::sync","source":"<a name=\"basic_filebuf__sync\"></a>  basic_filebuf::sync"},{"content":"Tries to synchronize the controlled streams with any associated external streams.","pos":[25864,25945]},{"pos":[25990,26002],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Returns zero if the file pointer <bpt id=\"p1\">**</bpt>fp<ept id=\"p1\">**</ept> is a null pointer.","pos":[26006,26064],"source":"Returns zero if the file pointer **fp** is a null pointer."},{"content":"Otherwise, it returns zero only if calls to both <bpt id=\"p1\">[</bpt>overflow<ept id=\"p1\">](#basic_filebuf__overflow)</ept> and <ph id=\"ph1\">`fflush`</ph>( <bpt id=\"p2\">**</bpt>fp<ept id=\"p2\">**</ept>) succeed in flushing any pending output to the stream.","pos":[26065,26226],"source":" Otherwise, it returns zero only if calls to both [overflow](#basic_filebuf__overflow) and `fflush`( **fp**) succeed in flushing any pending output to the stream."},{"pos":[26236,26305],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__traits_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::traits_type","linkify":"<a name=\"basic_filebuf__traits_type\"></a>  basic_filebuf::traits_type","source":"<a name=\"basic_filebuf__traits_type\"></a>  basic_filebuf::traits_type"},{"pos":[26309,26367],"content":"Associates a type name with the <bpt id=\"p1\">**</bpt>Tr<ept id=\"p1\">**</ept> template parameter.","source":"Associates a type name with the **Tr** template parameter."},{"pos":[26418,26483],"content":"<bpt id=\"p1\">&lt;a name=\"basic_filebuf__underflow\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  basic_filebuf::underflow","linkify":"<a name=\"basic_filebuf__underflow\"></a>  basic_filebuf::underflow","source":"<a name=\"basic_filebuf__underflow\"></a>  basic_filebuf::underflow"},{"content":"Extracts the current element from the input stream.","pos":[26487,26538]},{"pos":[26593,26605],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"If the function cannot succeed, it returns <bpt id=\"p1\">**</bpt>traits_type::<ept id=\"p1\">**</ept><bpt id=\"p2\">[</bpt>eof<ept id=\"p2\">](../standard-library/char-traits-struct.md#char_traits__eof)</ept>.","pos":[26609,26735],"source":"If the function cannot succeed, it returns **traits_type::**[eof](../standard-library/char-traits-struct.md#char_traits__eof)."},{"content":"Otherwise, it returns <bpt id=\"p1\">**</bpt>ch<ept id=\"p1\">**</ept>, converted as described in the Remarks section.","pos":[26736,26812],"source":" Otherwise, it returns **ch**, converted as described in the Remarks section."},{"pos":[26822,26829],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The protected virtual member function endeavors to extract the current element <bpt id=\"p1\">**</bpt>ch<ept id=\"p1\">**</ept> from the input stream, and return the element as <bpt id=\"p2\">**</bpt>traits_type::<ept id=\"p2\">**</ept><bpt id=\"p3\">[</bpt>to_int_type<ept id=\"p3\">](../standard-library/char-traits-struct.md#char_traits__to_int_type)</ept>( <bpt id=\"p4\">**</bpt>ch<ept id=\"p4\">**</ept>).","pos":[26833,27076],"source":"The protected virtual member function endeavors to extract the current element **ch** from the input stream, and return the element as **traits_type::**[to_int_type](../standard-library/char-traits-struct.md#char_traits__to_int_type)( **ch**)."},{"content":"It can do so in various ways:","pos":[27077,27106]},{"pos":[27116,27259],"content":"If a read position is available, it takes <bpt id=\"p1\">**</bpt>ch<ept id=\"p1\">**</ept> as the element stored in the read position and advances the next pointer for the input buffer.","source":"If a read position is available, it takes **ch** as the element stored in the read position and advances the next pointer for the input buffer."},{"content":"It can read one or more elements of type <ph id=\"ph1\">`char`</ph><bpt id=\"p1\">*</bpt>,<ept id=\"p1\">*</ept> as if by successive calls of the form <ph id=\"ph2\">`fgetc`</ph>( <bpt id=\"p2\">**</bpt>fp<ept id=\"p2\">**</ept>), and convert them to an element <bpt id=\"p3\">**</bpt>ch<ept id=\"p3\">**</ept> of type <bpt id=\"p4\">**</bpt>Elem<ept id=\"p4\">**</ept> by using the file conversion facet fac to call <bpt id=\"p5\">**</bpt>fac.in<ept id=\"p5\">**</ept> as needed.","pos":[27269,27499],"source":"It can read one or more elements of type `char`*,* as if by successive calls of the form `fgetc`( **fp**), and convert them to an element **ch** of type **Elem** by using the file conversion facet fac to call **fac.in** as needed."},{"content":"If any read or conversion fails, the function does not succeed.","pos":[27500,27563]},{"pos":[27572,27580],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>fstream&gt;<ept id=\"p1\">](../standard-library/fstream.md)</ept><ph id=\"ph2\"> </ph>","pos":[27584,27629],"source":"[\\<fstream>](../standard-library/fstream.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Thread Safety in the C++ Standard Library<ept id=\"p1\">](../standard-library/thread-safety-in-the-cpp-standard-library.md)</ept><ph id=\"ph1\"> </ph>","pos":[27632,27743],"source":" [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md) "},{"content":"<bpt id=\"p1\"> [</bpt>iostream Programming<ept id=\"p1\">](../standard-library/iostream-programming.md)</ept><ph id=\"ph1\"> </ph>","pos":[27746,27815],"source":" [iostream Programming](../standard-library/iostream-programming.md) "},{"content":"<bpt id=\"p1\"> [</bpt>iostreams Conventions<ept id=\"p1\">](../standard-library/iostreams-conventions.md)</ept>","pos":[27818,27888],"source":" [iostreams Conventions](../standard-library/iostreams-conventions.md)"}],"content":"---\ntitle: \"basic_filebuf Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std.basic_filebuf\"\n  - \"fstream/std::basic_filebuf\"\n  - \"std::basic_filebuf\"\n  - \"basic_filebuf\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"basic_filebuf class\"\nms.assetid: 3196ba5c-bf38-41bd-9a95-70323ddfca1a\ncaps.latest.revision: 24\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# basic_filebuf Class\nDescribes a stream buffer that controls the transmission of elements of type `Elem`, whose character traits are determined by the class `Tr`, to and from a sequence of elements stored in an external file.  \n  \n## Syntax  \n  \n```  \ntemplate <class Elem, class Tr = char_traits<Elem>>  \nclass basic_filebuf : public basic_streambuf<Elem, Tr>  \n```  \n  \n#### Parameters  \n `Elem`  \n The basic element of the file buffer.  \n  \n `Tr`  \n The traits of the basic element of the file buffer (usually `char_traits`< `Elem`>).  \n  \n## Remarks  \n The template class describes a stream buffer that controls the transmission of elements of type `Elem`, whose character traits are determined by the class `Tr`, to and from a sequence of elements stored in an external file.  \n  \n> [!NOTE]\n>  Objects of type `basic_filebuf` are created with an internal buffer of type `char *` regardless of the `char_type` specified by the type parameter `Elem`. This means that a Unicode string (containing `wchar_t` characters) will be converted to an ANSI string (containing `char` characters) before it is written to the internal buffer. To store Unicode strings in the buffer, create a new buffer of type `wchar_t` and set it using the [basic_streambuf::pubsetbuf](../standard-library/basic-streambuf-class.md#basic_streambuf__pubsetbuf)`()` method. To see an example that demonstrates this behavior, see below.  \n  \n An object of class `basic_filebuf`< `Elem`, `Tr`> stores a file pointer, which designates the `FILE` object that controls the stream associated with an open file. It also stores pointers to two file conversion facets for use by the protected member functions [overflow](#basic_filebuf__overflow) and [underflow](#basic_filebuf__underflow). For more information, see [basic_filebuf::open](#basic_filebuf__open).  \n  \n## Example  \n The following example demonstrates how to force an object of type `basic_filebuf<wchar_t>` to store Unicode characters in its internal buffer by calling the `pubsetbuf()` method.  \n  \n```  \n// unicode_basic_filebuf.cpp  \n// compile with: /EHsc  \n  \n#include <iostream>  \n#include <string>  \n#include <fstream>  \n#include <iomanip>  \n#include <memory.h>  \n#include <string.h>  \n  \n#define IBUFSIZE 16  \n  \nusing namespace std;  \n  \nvoid hexdump(const string& filename);  \n  \nint main()  \n{  \n    wchar_t* wszHello = L\"Hello World\";  \n    wchar_t wBuffer[128];  \n  \n    basic_filebuf<wchar_t> wOutFile;  \n  \n    // Open a file, wcHello.txt, then write to it, then dump the  \n    // file's contents in hex  \n    wOutFile.open(\"wcHello.txt\",  \n        ios_base::out | ios_base::trunc | ios_base::binary);  \n    if(!wOutFile.is_open())  \n    {  \n        cout << \"Error Opening wcHello.txt\\n\";  \n        return -1;  \n    }  \n    wOutFile.sputn(wszHello, (streamsize)wcslen(wszHello));  \n    wOutFile.close();  \n    cout << \"Hex Dump of wcHello.txt - note that output is ANSI chars:\\n\";  \n    hexdump(string(\"wcHello.txt\"));  \n  \n    // Open a file, wwHello.txt, then set the internal buffer of  \n    // the basic_filebuf object to be of type wchar_t, then write  \n    // to the file and dump the file's contents in hex  \n    wOutFile.open(\"wwHello.txt\",  \n        ios_base::out | ios_base::trunc | ios_base::binary);  \n    if(!wOutFile.is_open())  \n    {  \n        cout << \"Error Opening wwHello.txt\\n\";  \n        return -1;  \n    }  \n    wOutFile.pubsetbuf(wBuffer, (streamsize)128);  \n    wOutFile.sputn(wszHello, (streamsize)wcslen(wszHello));  \n    wOutFile.close();  \n    cout << \"\\nHex Dump of wwHello.txt - note that output is wchar_t chars:\\n\";  \n    hexdump(string(\"wwHello.txt\"));  \n  \n    return 0;  \n}  \n  \n// dump contents of filename to stdout in hex  \nvoid hexdump(const string& filename)  \n{  \n    fstream ifile(filename.c_str(),  \n        ios_base::in | ios_base::binary);  \n    char *ibuff = new char[IBUFSIZE];  \n    char *obuff = new char[(IBUFSIZE*2)+1];  \n    int i;  \n  \n    if(!ifile.is_open())  \n    {  \n        cout << \"Cannot Open \" << filename.c_str()  \n             << \" for reading\\n\";  \n        return;  \n    }  \n    if(!ibuff || !obuff)  \n    {  \n        cout << \"Cannot Allocate buffers\\n\";  \n        ifile.close();  \n        return;  \n    }  \n  \n    while(!ifile.eof())  \n    {  \n        memset(obuff,0,(IBUFSIZE*2)+1);  \n        memset(ibuff,0,IBUFSIZE);  \n        ifile.read(ibuff,IBUFSIZE);  \n  \n        // corner case where file is exactly a multiple of  \n        // 16 bytes in length  \n        if(ibuff[0] == 0 && ifile.eof())  \n            break;  \n  \n        for(i = 0; i < IBUFSIZE; i++)  \n        {  \n            if(ibuff[i] >= ' ')  \n                obuff[i] = ibuff[i];  \n            else  \n                obuff[i] = '.';  \n  \n            cout << setfill('0') << setw(2) << hex  \n                 << (int)ibuff[i] << ' ';  \n        }  \n        cout << \"  \" << obuff << endl;  \n    }  \n    ifile.close();  \n}  \n```  \n  \n```Output  \nHex Dump of wcHello.txt - note that output is ANSI chars:  \n48 65 6c 6c 6f 20 57 6f 72 6c 64 00 00 00 00 00   Hello World.....  \n  \nHex Dump of wwHello.txt - note that output is wchar_t chars:  \n48 00 65 00 6c 00 6c 00 6f 00 20 00 57 00 6f 00   H.e.l.l.o. .W.o.  \n72 00 6c 00 64 00 00 00 00 00 00 00 00 00 00 00   r.l.d...........  \n```  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[basic_filebuf](#basic_filebuf__basic_filebuf)|Constructs an object of type `basic_filebuf`.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[char_type](#basic_filebuf__char_type)|Associates a type name with the `Elem` template parameter.|  \n|[int_type](#basic_filebuf__int_type)|Makes this type within `basic_filebuf`'s scope equivalent to the type of the same name in the `Tr` scope.|  \n|[off_type](#basic_filebuf__off_type)|Makes this type within `basic_filebuf`'s scope equivalent to the type of the same name in the `Tr` scope.|  \n|[pos_type](#basic_filebuf__pos_type)|Makes this type within `basic_filebuf`'s scope equivalent to the type of the same name in the `Tr` scope.|  \n|[traits_type](#basic_filebuf__traits_type)|Associates a type name with the `Tr` template parameter.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[close](#basic_filebuf__close)|Closes a file.|  \n|[is_open](#basic_filebuf__is_open)|Indicates whether a file is open.|  \n|[open](#basic_filebuf__open)|Opens a file.|  \n|[overflow](#basic_filebuf__overflow)|A protected virtual function that can be called when a new character is inserted into a full buffer.|  \n|[pbackfail](#basic_filebuf__pbackfail)|The protected virtual member function tries to put back an element into the input stream, then make it the current element (pointed to by the next pointer).|  \n|[seekoff](#basic_filebuf__seekoff)|The protected virtual member function tries to alter the current positions for the controlled streams.|  \n|[seekpos](#basic_filebuf__seekpos)|The protected virtual member function tries to alter the current positions for the controlled streams.|  \n|[setbuf](#basic_filebuf__setbuf)|The protected virtual member function performs an operation particular to each derived stream buffer.|  \n|[Swap](#basic_filebuf__swap)|Exchanges the content of this `basic_filebuf` for the content of the provided `basic_filebuf` parameter.|  \n|[sync](#basic_filebuf__sync)|Protected, virtual function tries to synchronize the controlled streams with any associated external streams.|  \n|[uflow](../standard-library/basic-streambuf-class.md#basic_streambuf__uflow)|Protected, virtual function to extract the current element from the input stream.|  \n|[underflow](#basic_filebuf__underflow)|Protected, virtual function to extract the current element from the input stream.|  \n  \n## Requirements  \n **Header:** \\<fstream>  \n  \n **Namespace:** std  \n  \n##  <a name=\"basic_filebuf__basic_filebuf\"></a>  basic_filebuf::basic_filebuf  \n Constructs an object of type `basic_filebuf`.  \n  \n```  \nbasic_filebuf();\n\nbasic_filebuf(basic_filebuf&& right);\n```  \n  \n### Remarks  \n The first constructor stores a null pointer in all the pointers controlling the input buffer and the output buffer. It also stores a null pointer in the file pointer.  \n  \n The second constructor initializes the object with the contents of `right`, treated as an rvalue reference.  \n  \n##  <a name=\"basic_filebuf__char_type\"></a>  basic_filebuf::char_type  \n Associates a type name with the **Elem** template parameter.  \n  \n```  \ntypedef Elem char_type;  \n```  \n  \n##  <a name=\"basic_filebuf__close\"></a>  basic_filebuf::close  \n Closes a file.  \n  \n```  \nbasic_filebuf<Elem, Tr> *close();\n```  \n  \n### Return Value  \n The member function returns a null pointer if the file pointer is a null pointer.  \n  \n### Remarks  \n **close** calls `fclose`( **fp**). If that function returns a nonzero value, the function returns a null pointer. Otherwise, it returns **this** to indicate that the file was successfully closed.  \n  \n For a wide stream, if any insertions have occurred since the stream was opened, or since the last call to `streampos`, the function calls [overflow](#basic_filebuf__overflow). It also inserts any sequence needed to restore the initial conversion state, by using the file conversion facet **fac** to call **fac.unshift** as needed. Each element **byte** of type `char` thus produced is written to the associated stream designated by the file pointer **fp** as if by successive calls of the form `fputc`( **byte**, **fp**). If the call to **fac.unshift** or any write fails, the function does not succeed.  \n  \n### Example  \n  The following sample assumes two files in the current directory: basic_filebuf_close.txt (contents is \"testing\") and iotest.txt (contents is \"ssss\").  \n  \n```  \n// basic_filebuf_close.cpp  \n// compile with: /EHsc  \n#include <fstream>  \n#include <iostream>  \n  \nint main() {  \n   using namespace std;  \n   ifstream file;  \n   basic_ifstream <wchar_t> wfile;  \n   char c;  \n   // Open and close with a basic_filebuf  \n   file.rdbuf()->open( \"basic_filebuf_close.txt\", ios::in );  \n   file >> c;  \n   cout << c << endl;  \n   file.rdbuf( )->close( );  \n  \n   // Open/close directly  \n   file.open( \"iotest.txt\" );  \n   file >> c;  \n   cout << c << endl;  \n   file.close( );  \n  \n   // open a file with a wide character name  \n   wfile.open( L\"iotest.txt\" );  \n  \n   // Open and close a nonexistent with a basic_filebuf  \n   file.rdbuf()->open( \"ziotest.txt\", ios::in );  \n   cout << file.fail() << endl;  \n   file.rdbuf( )->close( );  \n  \n   // Open/close directly  \n   file.open( \"ziotest.txt\" );  \n   cout << file.fail() << endl;  \n   file.close( );  \n}  \n```  \n  \n```Output  \nt  \ns  \n0  \n1  \n```  \n  \n##  <a name=\"basic_filebuf__int_type\"></a>  basic_filebuf::int_type  \n Makes this type within basic_filebuf's scope equivalent to the type of the same name in the **Tr** scope.  \n  \n```  \ntypedef typename traits_type::int_type int_type;  \n```  \n  \n##  <a name=\"basic_filebuf__is_open\"></a>  basic_filebuf::is_open  \n Indicates whether a file is open.  \n  \n```  \nbool is_open() const;\n```  \n  \n### Return Value  \n **true** if the file pointer is not a null pointer.  \n  \n### Example  \n  \n```cpp  \n// basic_filebuf_is_open.cpp  \n// compile with: /EHsc  \n#include <fstream>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   ifstream file;  \n   cout << boolalpha << file.rdbuf( )->is_open( ) << endl;  \n  \n   file.open( \"basic_filebuf_is_open.cpp\" );  \n   cout << file.rdbuf( )->is_open( ) << endl;  \n}  \n```  \n  \n```Output  \nfalse  \ntrue  \n```  \n  \n##  <a name=\"basic_filebuf__off_type\"></a>  basic_filebuf::off_type  \n Makes this type within basic_filebuf's scope equivalent to the type of the same name in the **Tr** scope.  \n  \n```  \ntypedef typename traits_type::off_type off_type;  \n```  \n  \n##  <a name=\"basic_filebuf__open\"></a>  basic_filebuf::open  \n Opens a file.  \n  \n```  \nbasic_filebuf<Elem, Tr> *open(\n    const char* _Filename,  \n    ios_base::openmode _Mode,  \n    int _Prot = (int)ios_base::_Openprot);\n\nbasic_filebuf<Elem, Tr> *open(\n    const char* _Filename,  \n    ios_base::openmode _Mode);\n\nbasic_filebuf<Elem, Tr> *open(\n    const wchar_t* _Filename,  \n    ios_base::openmode _Mode,  \n    int _Prot = (int)ios_base::_Openprot);\n\nbasic_filebuf<Elem, Tr> *open(\n    const wchar_t* _Filename,  \n    ios_base::openmode _Mode);\n```  \n  \n### Parameters  \n `_Filename`  \n The name of the file to open.  \n  \n `_Mode`  \n One of the enumerations in [ios_base::openmode](../standard-library/ios-base-class.md#ios_base__openmode).  \n  \n `_Prot`  \n The default file opening protection, equivalent to the `shflag` parameter in [_fsopen, _wfsopen](../c-runtime-library/reference/fsopen-wfsopen.md).  \n  \n### Return Value  \n If the file pointer is a null pointer, the function returns a null pointer. Otherwise, it returns **this**.  \n  \n### Remarks  \n The member function opens the file with filename *filename*, by calling [fopen](../c-runtime-library/reference/fopen-wfopen.md)( *filename*, **strmode**). **strmode** is determined from **mode &**~( [ate](../standard-library/ios-base-class.md#ios_base__openmode) & &#124; [binary](../standard-library/ios-base-class.md#ios_base__openmode)):  \n  \n- **ios_base::in** becomes **\"r\"** (open existing file for reading).  \n  \n- [ios_base::out](../standard-library/ios-base-class.md#ios_base__fmtflags) or **ios_base::out &#124; ios_base::trunc** becomes **\"w\"** (truncate existing file or create for writing).  \n  \n- **ios_base::out &#124; app** becomes **\"a\"** (open existing file for appending all writes).  \n  \n- **ios_base::in &#124; ios_base::out** becomes **\"r+\"** (open existing file for reading and writing).  \n  \n- **ios_base::in &#124; ios_base::out &#124; ios_base::trunc** becomes **\"w+\"** (truncate existing file or create for reading and writing).  \n  \n- **ios_base::in &#124; ios_base::out &#124; ios_base::app** becomes **\"a+\"** (open existing file for reading and for appending all writes).  \n  \n If **mode & ios_base::binary** is nonzero, the function appends **b** to **strmode** to open a binary stream instead of a text stream. It then stores the value returned by `fopen` in the file pointer **fp**. If **mode & ios_base::ate** is nonzero and the file pointer is not a null pointer, the function calls `fseek`( **fp**, 0, `SEEK_END`) to position the stream at end of file. If that positioning operation fails, the function calls [close](#basic_filebuf__close)( **fp**) and stores a null pointer in the file pointer.  \n  \n If the file pointer is not a null pointer, the function determines the file conversion facet: `use_facet`< `codecvt`< **Elem**, `char`, **traits_type::**[state_type](../standard-library/char-traits-struct.md#char_traits__state_type)> >( [getloc](../standard-library/basic-streambuf-class.md#basic_streambuf__getloc)), for use by [underflow](#basic_filebuf__underflow) and [overflow](#basic_filebuf__overflow).  \n  \n If the file pointer is a null pointer, the function returns a null pointer. Otherwise, it returns **this**.  \n  \n### Example  \n  See [basic_filebuf::close](#basic_filebuf__close) for an example that uses **open**.  \n  \n##  <a name=\"basic_filebuf__operator_eq\"></a>  basic_filebuf::operator=  \n Assign the content of this stream buffer object. This is a move assignment involving an rvalue that does not leave a copy behind.  \n  \n```  \nbasic_filebuf& operator=(basic_filebuf&& right);\n```  \n  \n### Parameters  \n ` right`  \n An rvalue reference to a [basic_filebuf](../standard-library/basic-filebuf-class.md) object.  \n  \n### Return Value  \n Returns *this.  \n  \n### Remarks  \n The member operator replaces the contents of the object by using the contents of ` right`, treated as an rvalue reference. For more information, see [Rvalue Reference Declarator: &&](../cpp/rvalue-reference-declarator-amp-amp.md).  \n  \n##  <a name=\"basic_filebuf__overflow\"></a>  basic_filebuf::overflow  \n Called when a new character is inserted into a full buffer.  \n  \n```  \nvirtual int_type overflow(int_type _Meta = traits_type::eof);\n```  \n  \n### Parameters  \n `_Meta`  \n The character to insert into the buffer or **traits_type::eof**.  \n  \n### Return Value  \n If the function cannot succeed, it returns **traits_type::eof**. Otherwise, it returns **traits_type::**[not_eof](../standard-library/char-traits-struct.md#char_traits__not_eof)(_ *Meta*).  \n  \n### Remarks  \n If _ *Meta***!= traits_type::**[eof](../standard-library/char-traits-struct.md#char_traits__eof), the protected virtual member function endeavors to insert the element **ch = traits_type::**[to_char_type](../standard-library/char-traits-struct.md#char_traits__to_char_type)(\\_ *Meta*) into the output buffer. It can do so in various ways:  \n  \n-   If a write position is available, it can store the element into the write position and increment the next pointer for the output buffer.  \n  \n-   It can make a write position available by allocating new or additional storage for the output buffer.  \n  \n-   It can convert any pending output in the output buffer, followed by **ch**, by using the file conversion facet **fac** to call **fac.out** as needed. Each element `ch` of type *char* thus produced is written to the associated stream designated by the file pointer **fp** as if by successive calls of the form `fputc`( **ch**, **fp**). If any conversion or write fails, the function does not succeed.  \n  \n##  <a name=\"basic_filebuf__pbackfail\"></a>  basic_filebuf::pbackfail  \n Tries to put back an element into the input stream, then make it the current element (pointed to by the next pointer).  \n  \n```  \nvirtual int_type pbackfail(int_type _Meta = traits_type::eof);\n```  \n  \n### Parameters  \n `_Meta`  \n The character to insert into the buffer, or **traits_type::eof**.  \n  \n### Return Value  \n If the function cannot succeed, it returns **traits_type::eof**. Otherwise, it returns **traits_type::**[not_eof](../standard-library/char-traits-struct.md#char_traits__not_eof)(_ *Meta*).  \n  \n### Remarks  \n The protected virtual member function puts back an element into the input buffer and then makes it the current element (pointed to by the next pointer). If _ *Meta* **== traits_type::**[eof](../standard-library/char-traits-struct.md#char_traits__eof), the element to push back is effectively the one already in the stream before the current element. Otherwise, that element is replaced by **ch = traits_type::**[to_char_type](../standard-library/char-traits-struct.md#char_traits__to_char_type)(\\_ *Meta*). The function can put back an element in various ways:  \n  \n-   If a putback position is available, and the element stored there compares equal to **ch**, it can decrement the next pointer for the input buffer.  \n  \n-   If the function can make a `putback` position available, it can do so, set the next pointer to point at that position, and store **ch** in that position.  \n  \n-   If the function can push back an element onto the input stream, it can do so, such as by calling `ungetc` for an element of type `char`*.*  \n  \n##  <a name=\"basic_filebuf__pos_type\"></a>  basic_filebuf::pos_type  \n Makes this type within basic_filebuf's scope equivalent to the type of the same name in the **Tr** scope.  \n  \n```  \ntypedef typename traits_type::pos_type pos_type;  \n```  \n  \n##  <a name=\"basic_filebuf__seekoff\"></a>  basic_filebuf::seekoff  \n Tries to alter the current positions for the controlled streams.  \n  \n```  \nvirtual pos_type seekoff(off_type _Off,\n    ios_base::seekdir _Way,\n    ios_base::openmode _Which = ios_base::in | ios_base::out);\n```  \n  \n### Parameters  \n `_Off`  \n The position to seek for relative to `_Way`.  \n  \n `_Way`  \n The starting point for offset operations. See [seekdir](../standard-library/ios-base-class.md#ios_base__seekdir) for possible values.  \n  \n `_Which`  \n Specifies the mode for the pointer position. The default is to allow you to modify the read and write positions.  \n  \n### Return Value  \n Returns the new position or an invalid stream position.  \n  \n### Remarks  \n The protected virtual member function endeavors to alter the current positions for the controlled streams. For an object of class [basic_filebuf](../standard-library/basic-filebuf-class.md)< `Elem`, `Tr`>, a stream position can be represented by an object of type `fpos_t`, which stores an offset and any state information needed to parse a wide stream. Offset zero designates the first element of the stream. (An object of type [pos_type](../standard-library/basic-streambuf-class.md#basic_streambuf__pos_type) stores at least an `fpos_t` object.)  \n  \n For a file opened for both reading and writing, both the input and output streams are positioned in tandem. To switch between inserting and extracting, you must call either [pubseekoff](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekoff) or [pubseekpos](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekpos). Calls to `pubseekoff` (and hence to `seekoff`) have various limitations for [text streams](../c-runtime-library/text-and-binary-streams.md), [binary streams](../c-runtime-library/text-and-binary-streams.md), and [wide streams](../c-runtime-library/byte-and-wide-streams.md).  \n  \n If the file pointer **fp** is a null pointer, the function fails. Otherwise, it endeavors to alter the stream position by calling `fseek`( **fp**, `_Off`, `_Way`). If that function succeeds and the resulting position **fposn** can be determined by calling `fgetpos`( **fp**, **&fposn**), the function succeeds. If the function succeeds, it returns a value of type **pos_type** containing **fposn**. Otherwise, it returns an invalid stream position.  \n  \n##  <a name=\"basic_filebuf__seekpos\"></a>  basic_filebuf::seekpos  \n Tries to alter the current positions for the controlled streams.  \n  \n```  \nvirtual pos_type seekpos(pos_type _Sp, ios_base::openmode _Which = ios_base::in | ios_base::out);\n```  \n  \n### Parameters  \n `_Sp`  \n The position to seek for.  \n  \n `_Which`  \n Specifies the mode for the pointer position. The default is to allow you to modify the read and write positions.  \n  \n### Return Value  \n If the file pointer **fp** is a null pointer, the function fails. Otherwise, it endeavors to alter the stream position by calling `fsetpos`( **fp**, **&fposn**), where **fposn** is the `fpos_t` object stored in `pos`. If that function succeeds, the function returns `pos`. Otherwise, it returns an invalid stream position. To determine if the stream position is invalid, compare the return value with `pos_type(off_type(-1))`.  \n  \n### Remarks  \n The protected virtual member function endeavors to alter the current positions for the controlled streams. For an object of class [basic_filebuf](../standard-library/basic-filebuf-class.md)\\< **Elem**, **Tr**>, a stream position can be represented by an object of type `fpos_t`, which stores an offset and any state information needed to parse a wide stream. Offset zero designates the first element of the stream. (An object of type `pos_type` stores at least an `fpos_t` object.)  \n  \n For a file opened for both reading and writing, both the input and output streams are positioned in tandem. To switch between inserting and extracting, you must call either [pubseekoff](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekoff) or [pubseekpos](../standard-library/basic-streambuf-class.md#basic_streambuf__pubseekpos). Calls to `pubseekoff` (and hence to `seekoff`) have various limitations for text streams, binary streams, and wide streams.  \n  \n For a wide stream, if any insertions have occurred since the stream was opened, or since the last call to `streampos`, the function calls [overflow](#basic_filebuf__overflow). It also inserts any sequence needed to restore the initial conversion state, by using the file conversion facet **fac** to call **fac**`.``unshift` as needed. Each element **byte** of type `char` thus produced is written to the associated stream designated by the file pointer **fp** as if by successive calls of the form `fputc`( **byte**, **fp**). If the call to **fac.unshift** or any write fails, the function does not succeed.  \n  \n##  <a name=\"basic_filebuf__setbuf\"></a>  basic_filebuf::setbuf  \n Performs an operation particular to each derived stream buffer.  \n  \n```  \nvirtual basic_streambuf<Elem, Tr> *setbuf(\n    char_type* _Buffer,  \n    streamsize count);\n```  \n  \n### Parameters  \n `_Buffer`  \n Pointer to a buffer.  \n  \n ` count`  \n Size of the buffer.  \n  \n### Return Value  \n The protected member function returns zero if the file pointer `fp` is a null pointer.  \n  \n### Remarks  \n `setbuf` calls `setvbuf`( **fp**, ( `char` \\*) `_Buffer`, `_IOFBF`, ` count` \\* `sizeof` ( **Elem**) ) to offer the array of ` count` elements beginning at _ *Buffer* as a buffer for the stream. If that function returns a nonzero value, the function returns a null pointer. Otherwise, it returns **this** to signal success.  \n  \n##  <a name=\"basic_filebuf__swap\"></a>  basic_filebuf::swap  \n Exchanges the contents of this `basic_filebuf` for the contents of the provided `basic_filebuf`.  \n  \n```  \nvoid swap(basic_filebuf& right);\n```  \n  \n### Parameters  \n ` right`  \n An `lvalue` reference to another `basic_filebuf`.  \n  \n##  <a name=\"basic_filebuf__sync\"></a>  basic_filebuf::sync  \n Tries to synchronize the controlled streams with any associated external streams.  \n  \n```  \nvirtual int sync();\n```  \n  \n### Return Value  \n Returns zero if the file pointer **fp** is a null pointer. Otherwise, it returns zero only if calls to both [overflow](#basic_filebuf__overflow) and `fflush`( **fp**) succeed in flushing any pending output to the stream.  \n  \n##  <a name=\"basic_filebuf__traits_type\"></a>  basic_filebuf::traits_type  \n Associates a type name with the **Tr** template parameter.  \n  \n```  \ntypedef Tr traits_type;  \n```  \n  \n##  <a name=\"basic_filebuf__underflow\"></a>  basic_filebuf::underflow  \n Extracts the current element from the input stream.  \n  \n```  \nvirtual int_type underflow();\n```  \n  \n### Return Value  \n If the function cannot succeed, it returns **traits_type::**[eof](../standard-library/char-traits-struct.md#char_traits__eof). Otherwise, it returns **ch**, converted as described in the Remarks section.  \n  \n### Remarks  \n The protected virtual member function endeavors to extract the current element **ch** from the input stream, and return the element as **traits_type::**[to_int_type](../standard-library/char-traits-struct.md#char_traits__to_int_type)( **ch**). It can do so in various ways:  \n  \n-   If a read position is available, it takes **ch** as the element stored in the read position and advances the next pointer for the input buffer.  \n  \n-   It can read one or more elements of type `char`*,* as if by successive calls of the form `fgetc`( **fp**), and convert them to an element **ch** of type **Elem** by using the file conversion facet fac to call **fac.in** as needed. If any read or conversion fails, the function does not succeed.  \n  \n## See Also  \n [\\<fstream>](../standard-library/fstream.md)   \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [iostream Programming](../standard-library/iostream-programming.md)   \n [iostreams Conventions](../standard-library/iostreams-conventions.md)\n\n"}