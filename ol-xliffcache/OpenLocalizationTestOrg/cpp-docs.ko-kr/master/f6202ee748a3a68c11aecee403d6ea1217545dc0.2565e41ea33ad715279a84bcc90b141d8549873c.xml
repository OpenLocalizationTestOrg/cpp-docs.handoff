{"nodes":[{"pos":[12,50],"content":"Purpose of Attributes | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Purpose of Attributes | Microsoft Docs","pos":[0,38]}]},{"content":"Purpose of Attributes","pos":[593,614]},{"content":"Attributes extend C++ in directions not currently possible without breaking the classic structure of the language.","pos":[615,729]},{"content":"Attributes allow providers (separate DLLs) to extend language functionality dynamically.","pos":[730,818]},{"content":"The primary goal of attributes is to simplify the authoring of COM components, in addition to increasing the productivity level of the component developer.","pos":[819,974]},{"content":"Attributes can be applied to nearly any C++ construct, such as classes, data members, or member functions.","pos":[975,1081]},{"content":"The following is a highlight of benefits provided by this new technology:","pos":[1082,1155]},{"content":"Exposes a familiar and simple calling convention.","pos":[1165,1214]},{"content":"Uses inserted code, which, unlike macros, is recognized by the debugger.","pos":[1224,1296]},{"content":"Allows easy derivation from base classes without burdensome implementation details.","pos":[1306,1389]},{"content":"Replaces the large amount of IDL code required by a COM component with a few concise attributes.","pos":[1399,1495]},{"content":"For example, to implement a simple event sink for a generic ATL class, you could apply the <bpt id=\"p1\">[</bpt>event_receiver<ept id=\"p1\">](../windows/event-receiver.md)</ept> attribute to a specific class such as <ph id=\"ph1\">`CMyReceiver`</ph>.","pos":[1502,1692],"source":"For example, to implement a simple event sink for a generic ATL class, you could apply the [event_receiver](../windows/event-receiver.md) attribute to a specific class such as `CMyReceiver`."},{"content":"The <bpt id=\"p1\">**</bpt>event_receiver<ept id=\"p1\">**</ept> attribute is then compiled by the Visual C++ compiler, which inserts the proper code into the object file.","pos":[1693,1822],"source":" The **event_receiver** attribute is then compiled by the Visual C++ compiler, which inserts the proper code into the object file."},{"pos":[1974,2213],"content":"You can then set up the <bpt id=\"p1\">**</bpt>CMyReceiver<ept id=\"p1\">**</ept> methods <ph id=\"ph1\">`handler1`</ph> and <ph id=\"ph2\">`handler2`</ph> to handle events (using the intrinsic function <bpt id=\"p2\">[</bpt>__hook<ept id=\"p2\">](../cpp/hook.md)</ept>) from an event source, which you can create using <bpt id=\"p3\">[</bpt>event_source<ept id=\"p3\">](../windows/event-source.md)</ept>.","source":"You can then set up the **CMyReceiver** methods `handler1` and `handler2` to handle events (using the intrinsic function [__hook](../cpp/hook.md)) from an event source, which you can create using [event_source](../windows/event-source.md)."},{"content":"See Also","pos":[2222,2230]},{"content":"Concepts","pos":[2235,2243]}],"content":"---\ntitle: \"Purpose of Attributes | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"attributes [C++], about attributes\"\nms.assetid: 3aff8bfa-a2a3-4fcb-a2c6-1d96a2b4c68d\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Purpose of Attributes\nAttributes extend C++ in directions not currently possible without breaking the classic structure of the language. Attributes allow providers (separate DLLs) to extend language functionality dynamically. The primary goal of attributes is to simplify the authoring of COM components, in addition to increasing the productivity level of the component developer. Attributes can be applied to nearly any C++ construct, such as classes, data members, or member functions. The following is a highlight of benefits provided by this new technology:  \n  \n-   Exposes a familiar and simple calling convention.  \n  \n-   Uses inserted code, which, unlike macros, is recognized by the debugger.  \n  \n-   Allows easy derivation from base classes without burdensome implementation details.  \n  \n-   Replaces the large amount of IDL code required by a COM component with a few concise attributes.  \n  \n For example, to implement a simple event sink for a generic ATL class, you could apply the [event_receiver](../windows/event-receiver.md) attribute to a specific class such as `CMyReceiver`. The **event_receiver** attribute is then compiled by the Visual C++ compiler, which inserts the proper code into the object file.  \n  \n```  \n[event_receiver(com)]  \nclass CMyReceiver   \n{  \n   void handler1(int i) { ... }  \n   void handler2(int i, float j) { ... }  \n}  \n```  \n  \n You can then set up the **CMyReceiver** methods `handler1` and `handler2` to handle events (using the intrinsic function [__hook](../cpp/hook.md)) from an event source, which you can create using [event_source](../windows/event-source.md).  \n  \n## See Also  \n [Concepts](../windows/attributed-programming-concepts.md)"}