{"nodes":[{"pos":[12,55],"content":"Property Index Declaration | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Property Index Declaration | Microsoft Docs","pos":[0,43]}]},{"content":"Property Index Declaration","pos":[650,676]},{"pos":[677,841],"content":"The syntax for declaring an indexed property has changed from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","source":"The syntax for declaring an indexed property has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"The two primary shortcoming of the Managed Extensions language support of indexed properties is the inability to provide class-level subscripting; that is, all indexed properties are required to be given a name, and thus there is no way, for example, to provide a managed subscript operator that can be directly applied to a <ph id=\"ph1\">`Vector`</ph> or <ph id=\"ph2\">`Matrix`</ph> class object.","pos":[848,1207],"source":"The two primary shortcoming of the Managed Extensions language support of indexed properties is the inability to provide class-level subscripting; that is, all indexed properties are required to be given a name, and thus there is no way, for example, to provide a managed subscript operator that can be directly applied to a `Vector` or `Matrix` class object."},{"content":"A second less significant shortcoming is that it is visually difficult to distinguish a property from an indexed property – the number of parameters is the only indication.","pos":[1208,1380]},{"content":"Finally, indexed properties suffer from the same problems as those of non-indexed properties – the accessors are not treated as an atomic unit, but separated into individual methods.","pos":[1381,1563]},{"content":"For example:","pos":[1565,1577]},{"content":"As you can see here, the indexers are distinguished only by the additional parameters to specify a two or single dimension index.","pos":[1900,2029]},{"content":"In the new syntax, the indexers are distinguished by the bracket ([,]) following the name of the indexer and indicating the number and type of each index:","pos":[2030,2184]},{"content":"To indicate a class level indexer that can be applied directly to objects of the class in the new syntax, the <ph id=\"ph1\">`default`</ph> keyword is reused to substitute for an explicit name.","pos":[2562,2735],"source":"To indicate a class level indexer that can be applied directly to objects of the class in the new syntax, the `default` keyword is reused to substitute for an explicit name."},{"content":"For example:","pos":[2736,2748]},{"content":"In the new syntax, when the default indexed property is specified, the two following names are reserved: <ph id=\"ph1\">`get_Item`</ph> and <ph id=\"ph2\">`set_Item`</ph>.","pos":[3267,3398],"source":"In the new syntax, when the default indexed property is specified, the two following names are reserved: `get_Item` and `set_Item`."},{"content":"This is because these are the underlying names generated for the default indexed property.","pos":[3399,3489]},{"content":"Note that there is no simple index syntax analogous to the simple property syntax.","pos":[3496,3578]},{"content":"See Also","pos":[3587,3595]},{"content":"Member Declarations within a Class or Interface (C++/CLI)","pos":[3600,3657]}],"content":"---\ntitle: \"Property Index Declaration | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"indexers\"\n  - \"default indexers\"\n  - \"defaults, indexers\"\n  - \"indexed properties, C++\"\nms.assetid: d898fdbc-2106-4b6a-8c5c-9f511d80fc2f\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Property Index Declaration\nThe syntax for declaring an indexed property has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)].  \n  \n The two primary shortcoming of the Managed Extensions language support of indexed properties is the inability to provide class-level subscripting; that is, all indexed properties are required to be given a name, and thus there is no way, for example, to provide a managed subscript operator that can be directly applied to a `Vector` or `Matrix` class object. A second less significant shortcoming is that it is visually difficult to distinguish a property from an indexed property – the number of parameters is the only indication. Finally, indexed properties suffer from the same problems as those of non-indexed properties – the accessors are not treated as an atomic unit, but separated into individual methods.  For example:  \n  \n```  \npublic __gc class Vector;  \npublic __gc class Matrix {  \n   float mat[,];  \n  \npublic:   \n   __property void set_Item( int r, int c, float value);  \n   __property float get_Item( int r, int c );  \n  \n   __property void set_Row( int r, Vector* value );  \n   __property Vector* get_Row( int r );  \n};  \n```  \n  \n As you can see here, the indexers are distinguished only by the additional parameters to specify a two or single dimension index. In the new syntax, the indexers are distinguished by the bracket ([,]) following the name of the indexer and indicating the number and type of each index:  \n  \n```  \npublic ref class Vector {};  \npublic ref class Matrix {  \nprivate:  \n   array<float, 2>^ mat;  \n  \npublic:  \n   property float Item [int,int] {  \n      float get( int r, int c );  \n      void set( int r, int c, float value );  \n   }  \n  \n   property Vector^ Row [int] {  \n      Vector^ get( int r );  \n      void set( int r, Vector^ value );  \n   }  \n};  \n```  \n  \n To indicate a class level indexer that can be applied directly to objects of the class in the new syntax, the `default` keyword is reused to substitute for an explicit name. For example:  \n  \n```  \npublic ref class Matrix {  \nprivate:  \n   array<float, 2>^ mat;  \n  \npublic:  \n   // ok: class level indexer now  \n   //  \n   //     Matrix mat …  \n   //     mat[ 0, 0 ] = 1;   \n   //  \n   // invokes the set accessor of the default indexer …  \n  \n   property float default [int,int] {  \n      float get( int r, int c );  \n      void set( int r, int c, float value );  \n   }  \n  \n   property Vector^ Row [int] {  \n      Vector^ get( int r );  \n      void set( int r, Vector^ value );  \n   }  \n};  \n```  \n  \n In the new syntax, when the default indexed property is specified, the two following names are reserved: `get_Item` and `set_Item`. This is because these are the underlying names generated for the default indexed property.  \n  \n Note that there is no simple index syntax analogous to the simple property syntax.  \n  \n## See Also  \n [Member Declarations within a Class or Interface (C++/CLI)](../dotnet/member-declarations-within-a-class-or-interface-cpp-cli.md)   \n "}