{"nodes":[{"pos":[12,53],"content":"try-except Statement (C) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"try-except Statement (C) | Microsoft Docs","pos":[0,41]}]},{"content":"try-except Statement (C)","pos":[912,936]},{"content":"Microsoft Specific","pos":[939,957]},{"content":"The <bpt id=\"p1\">**</bpt>try-except<ept id=\"p1\">**</ept> statement is a Microsoft extension to the C language that enables applications to gain control of a program when events that normally terminate execution occur.","pos":[966,1145],"source":"The **try-except** statement is a Microsoft extension to the C language that enables applications to gain control of a program when events that normally terminate execution occur."},{"content":"Such events are called exceptions, and the mechanism that deals with exceptions is called structured exception handling.","pos":[1146,1266]},{"content":"Exceptions can be either hardware- or software-based.","pos":[1273,1326]},{"content":"Even when applications cannot completely recover from hardware or software exceptions, structured exception handling makes it possible to display error information and trap the internal state of the application to help diagnose the problem.","pos":[1327,1567]},{"content":"This is especially useful for intermittent problems that cannot be reproduced easily.","pos":[1568,1653]},{"content":"Syntax","pos":[1662,1668]},{"content":"<bpt id=\"p1\">*</bpt>try-except-statement<ept id=\"p1\">*</ept>:","pos":[1672,1695],"source":"*try-except-statement*:"},{"content":"<bpt id=\"p1\"> **</bpt>__try<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>compound-statement<ept id=\"p2\">*</ept>","pos":[1698,1730],"source":" **__try**  *compound-statement*"},{"pos":[1737,1794],"content":"<bpt id=\"p1\">**</bpt>__except (<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>expression<ept id=\"p2\">*</ept>  <bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>  <bpt id=\"p4\">*</bpt>compound-statement<ept id=\"p4\">*</ept>","source":"**__except (**  *expression*  **)**  *compound-statement*"},{"content":"The compound statement after the <ph id=\"ph1\">`__try`</ph> clause is the guarded section.","pos":[1801,1872],"source":"The compound statement after the `__try` clause is the guarded section."},{"content":"The compound statement after the <ph id=\"ph1\">`__except`</ph> clause is the exception handler.","pos":[1873,1949],"source":" The compound statement after the `__except` clause is the exception handler."},{"content":"The handler specifies a set of actions to be taken if an exception is raised during execution of the guarded section.","pos":[1950,2067]},{"content":"Execution proceeds as follows:","pos":[2068,2098]},{"content":"The guarded section is executed.","pos":[2108,2140]},{"pos":[2150,2279],"content":"If no exception occurs during execution of the guarded section, execution continues at the statement after the <ph id=\"ph1\">`__except`</ph> clause.","source":"If no exception occurs during execution of the guarded section, execution continues at the statement after the `__except` clause."},{"content":"If an exception occurs during execution of the guarded section or in any routine the guarded section calls, the<ph id=\"ph1\">`__except`</ph> expression is evaluated and the value returned determines how the exception is handled.","pos":[2289,2498],"source":"If an exception occurs during execution of the guarded section or in any routine the guarded section calls, the`__except` expression is evaluated and the value returned determines how the exception is handled."},{"content":"There are three values:","pos":[2499,2522]},{"content":"Exception is not recognized.","pos":[2561,2589]},{"content":"Continue to search up the stack for a handler, first for containing <bpt id=\"p1\">**</bpt>try-except<ept id=\"p1\">**</ept> statements, then for handlers with the next highest precedence.","pos":[2590,2736],"source":" Continue to search up the stack for a handler, first for containing **try-except** statements, then for handlers with the next highest precedence."},{"content":"Exception is recognized but dismissed.","pos":[2778,2816]},{"content":"Continue execution at the point where the exception occurred.","pos":[2817,2878]},{"content":"Exception is recognized.","pos":[2917,2941]},{"content":"Transfer control to the exception handler by executing the <ph id=\"ph1\">`__except`</ph> compound statement, then continue execution at the point the exception occurred.","pos":[2942,3092],"source":" Transfer control to the exception handler by executing the `__except` compound statement, then continue execution at the point the exception occurred."},{"content":"Because the <ph id=\"ph1\">`__except`</ph> expression is evaluated as a C expression, it is limited to a single value, the conditional-expression operator, or the comma operator.","pos":[3099,3257],"source":"Because the `__except` expression is evaluated as a C expression, it is limited to a single value, the conditional-expression operator, or the comma operator."},{"content":"If more extensive processing is required, the expression can call a routine that returns one of the three values listed above.","pos":[3258,3384]},{"pos":[3392,3709],"content":"[!NOTE]\n Structured exception handling works with C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, the C++ exception handling mechanism is much more flexible, in that it can handle exceptions of any type.","leadings":["","> "],"nodes":[{"content":" Structured exception handling works with C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, the C++ exception handling mechanism is much more flexible, in that it can handle exceptions of any type.","pos":[8,315],"nodes":[{"content":"Structured exception handling works with C and C++ source files.","pos":[1,65]},{"content":"However, it is not specifically designed for C++.","pos":[66,115]},{"content":"You can ensure that your code is more portable by using C++ exception handling.","pos":[116,195]},{"content":"Also, the C++ exception handling mechanism is much more flexible, in that it can handle exceptions of any type.","pos":[196,307]}]}]},{"pos":[3717,3949],"content":"[!NOTE]\n For C++ programs, C++ exception handling should be used instead of structured exception handling. For more information, see [Exception Handling](../cpp/exception-handling-in-visual-cpp.md) in the *C++ Language Reference*.","leadings":["","> "],"nodes":[{"content":" For C++ programs, C++ exception handling should be used instead of structured exception handling. For more information, see [Exception Handling](../cpp/exception-handling-in-visual-cpp.md) in the *C++ Language Reference*.","pos":[8,230],"nodes":[{"content":"For C++ programs, C++ exception handling should be used instead of structured exception handling.","pos":[1,98]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Exception Handling<ept id=\"p1\">](../cpp/exception-handling-in-visual-cpp.md)</ept> in the <bpt id=\"p2\">*</bpt>C++ Language Reference<ept id=\"p2\">*</ept>.","pos":[99,222],"source":" For more information, see [Exception Handling](../cpp/exception-handling-in-visual-cpp.md) in the *C++ Language Reference*."}]}]},{"content":"Each routine in an application can have its own exception handler.","pos":[3956,4022]},{"content":"The <ph id=\"ph1\">`__except`</ph> expression executes in the scope of the <ph id=\"ph2\">`__try`</ph> body.","pos":[4023,4091],"source":" The `__except` expression executes in the scope of the `__try` body."},{"content":"This means it has access to any local variables declared there.","pos":[4092,4155]},{"content":"The <ph id=\"ph1\">`__leave`</ph> keyword is valid within a <bpt id=\"p1\">**</bpt>try-except<ept id=\"p1\">**</ept> statement block.","pos":[4162,4233],"source":"The `__leave` keyword is valid within a **try-except** statement block."},{"content":"The effect of <ph id=\"ph1\">`__leave`</ph> is to jump to the end of the <bpt id=\"p1\">**</bpt>try-except<ept id=\"p1\">**</ept> block.","pos":[4234,4308],"source":" The effect of `__leave` is to jump to the end of the **try-except** block."},{"content":"Execution resumes after the end of the exception handler.","pos":[4309,4366]},{"content":"Although a <ph id=\"ph1\">`goto`</ph> statement can be used to accomplish the same result, a <ph id=\"ph2\">`goto`</ph> statement causes stack unwinding.","pos":[4367,4480],"source":" Although a `goto` statement can be used to accomplish the same result, a `goto` statement causes stack unwinding."},{"content":"The <ph id=\"ph1\">`__leave`</ph> statement is more efficient because it does not involve stack unwinding.","pos":[4481,4567],"source":" The `__leave` statement is more efficient because it does not involve stack unwinding."},{"content":"Exiting a <bpt id=\"p1\">**</bpt>try-except<ept id=\"p1\">**</ept> statement using the <ph id=\"ph1\">`longjmp`</ph> run-time function is considered abnormal termination.","pos":[4574,4682],"source":"Exiting a **try-except** statement using the `longjmp` run-time function is considered abnormal termination."},{"content":"It is illegal to jump into a <ph id=\"ph1\">`__try`</ph> statement, but legal to jump out of one.","pos":[4683,4760],"source":" It is illegal to jump into a `__try` statement, but legal to jump out of one."},{"content":"The exception handler is not called if a process is killed in the middle of executing a <bpt id=\"p1\">**</bpt>try-except<ept id=\"p1\">**</ept> statement.","pos":[4761,4874],"source":" The exception handler is not called if a process is killed in the middle of executing a **try-except** statement."},{"content":"Example","pos":[4883,4890]},{"content":"Following is an example of an exception handler and a termination handler.","pos":[4894,4968]},{"content":"See <bpt id=\"p1\">[</bpt>The try-finally Statement<ept id=\"p1\">](../c-language/try-finally-statement-c.md)</ept> for more information about termination handlers.","pos":[4969,5091],"source":" See [The try-finally Statement](../c-language/try-finally-statement-c.md) for more information about termination handlers."},{"content":"This is the output from the example, with commentary added on the right:","pos":[5396,5468]},{"content":"END Microsoft Specific","pos":[5886,5908]},{"content":"See Also","pos":[5919,5927]},{"content":"try-except Statement","pos":[5932,5952]}],"content":"---\ntitle: \"try-except Statement (C) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"__except\"\n  - \"try\"\n  - \"__try\"\n  - \"except\"\n  - \"__except_cpp\"\n  - \"__try_cpp\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"try-except keyword [C]\"\n  - \"structured exception handling, try-except\"\n  - \"try-catch keyword [C]\"\n  - \"__try keyword [C]\"\n  - \"__except keyword [C]\"\n  - \"__except keyword [C], in try-except\"\n  - \"try-catch keyword [C], try-except keyword [C]\"\nms.assetid: f76db9d1-fc78-417f-b71f-18e545fc01c3\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# try-except Statement (C)\n**Microsoft Specific**  \n  \n The **try-except** statement is a Microsoft extension to the C language that enables applications to gain control of a program when events that normally terminate execution occur. Such events are called exceptions, and the mechanism that deals with exceptions is called structured exception handling.  \n  \n Exceptions can be either hardware- or software-based. Even when applications cannot completely recover from hardware or software exceptions, structured exception handling makes it possible to display error information and trap the internal state of the application to help diagnose the problem. This is especially useful for intermittent problems that cannot be reproduced easily.  \n  \n## Syntax  \n *try-except-statement*:  \n **__try**  *compound-statement*  \n  \n **__except (**  *expression*  **)**  *compound-statement*  \n  \n The compound statement after the `__try` clause is the guarded section. The compound statement after the `__except` clause is the exception handler. The handler specifies a set of actions to be taken if an exception is raised during execution of the guarded section. Execution proceeds as follows:  \n  \n1.  The guarded section is executed.  \n  \n2.  If no exception occurs during execution of the guarded section, execution continues at the statement after the `__except` clause.  \n  \n3.  If an exception occurs during execution of the guarded section or in any routine the guarded section calls, the`__except` expression is evaluated and the value returned determines how the exception is handled. There are three values:  \n  \n     `EXCEPTION_CONTINUE_SEARCH` Exception is not recognized. Continue to search up the stack for a handler, first for containing **try-except** statements, then for handlers with the next highest precedence.  \n  \n     `EXCEPTION_CONTINUE_EXECUTION` Exception is recognized but dismissed. Continue execution at the point where the exception occurred.  \n  \n     `EXCEPTION_EXECUTE_HANDLER` Exception is recognized. Transfer control to the exception handler by executing the `__except` compound statement, then continue execution at the point the exception occurred.  \n  \n Because the `__except` expression is evaluated as a C expression, it is limited to a single value, the conditional-expression operator, or the comma operator. If more extensive processing is required, the expression can call a routine that returns one of the three values listed above.  \n  \n> [!NOTE]\n>  Structured exception handling works with C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, the C++ exception handling mechanism is much more flexible, in that it can handle exceptions of any type.  \n  \n> [!NOTE]\n>  For C++ programs, C++ exception handling should be used instead of structured exception handling. For more information, see [Exception Handling](../cpp/exception-handling-in-visual-cpp.md) in the *C++ Language Reference*.  \n  \n Each routine in an application can have its own exception handler. The `__except` expression executes in the scope of the `__try` body. This means it has access to any local variables declared there.  \n  \n The `__leave` keyword is valid within a **try-except** statement block. The effect of `__leave` is to jump to the end of the **try-except** block. Execution resumes after the end of the exception handler. Although a `goto` statement can be used to accomplish the same result, a `goto` statement causes stack unwinding. The `__leave` statement is more efficient because it does not involve stack unwinding.  \n  \n Exiting a **try-except** statement using the `longjmp` run-time function is considered abnormal termination. It is illegal to jump into a `__try` statement, but legal to jump out of one. The exception handler is not called if a process is killed in the middle of executing a **try-except** statement.  \n  \n## Example  \n Following is an example of an exception handler and a termination handler. See [The try-finally Statement](../c-language/try-finally-statement-c.md) for more information about termination handlers.  \n  \n```  \n.  \n.  \n.  \nputs(\"hello\");  \n__try{  \n   puts(\"in try\");  \n   __try{  \n      puts(\"in try\");  \n      RAISE_AN_EXCEPTION();  \n   }__finally{  \n      puts(\"in finally\");  \n   }  \n}__except( puts(\"in filter\"), EXCEPTION_EXECUTE_HANDLER ){  \n   puts(\"in except\");  \n}  \nputs(\"world\");  \n```  \n  \n This is the output from the example, with commentary added on the right:  \n  \n```  \nhello  \nin try              /* fall into try                     */  \nin try              /* fall into nested try                */  \nin filter           /* execute filter; returns 1 so accept  */  \nin finally          /* unwind nested finally                */  \nin except           /* transfer control to selected handler */  \nworld               /* flow out of handler                  */  \n```  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [try-except Statement](../cpp/try-except-statement.md)"}