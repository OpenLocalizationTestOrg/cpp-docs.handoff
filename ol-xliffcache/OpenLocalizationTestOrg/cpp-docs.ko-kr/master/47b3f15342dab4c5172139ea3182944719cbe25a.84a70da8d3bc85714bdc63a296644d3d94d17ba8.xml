{"nodes":[{"pos":[12,67],"content":"Task Parallelism (Concurrency Runtime) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Task Parallelism (Concurrency Runtime) | Microsoft Docs","pos":[0,55]}]},{"content":"Task Parallelism (Concurrency Runtime)","pos":[763,801]},{"content":"In the Concurrency Runtime, a <bpt id=\"p1\">*</bpt>task<ept id=\"p1\">*</ept> is a unit of work that performs a specific job and typically runs in parallel with other tasks.","pos":[802,934],"source":"In the Concurrency Runtime, a *task* is a unit of work that performs a specific job and typically runs in parallel with other tasks."},{"content":"A task can be decomposed into additional, more fine-grained tasks that are organized into a <bpt id=\"p1\">*</bpt>task group<ept id=\"p1\">*</ept>.","pos":[935,1040],"source":" A task can be decomposed into additional, more fine-grained tasks that are organized into a *task group*."},{"content":"You use tasks when you write asynchronous code and want some operation to occur after the asynchronous operation completes.","pos":[1047,1170]},{"content":"For example, you could use a task to asynchronously read from a file and then use another task—a <bpt id=\"p1\">*</bpt>continuation task<ept id=\"p1\">*</ept>, which is explained later in this document—to process the data after it becomes available.","pos":[1171,1378],"source":" For example, you could use a task to asynchronously read from a file and then use another task—a *continuation task*, which is explained later in this document—to process the data after it becomes available."},{"content":"Conversely, you can use tasks groups to decompose parallel work into smaller pieces.","pos":[1379,1463]},{"content":"For example, suppose you have a recursive algorithm that divides the remaining work into two partitions.","pos":[1464,1568]},{"content":"You can use task groups to run these partitions concurrently, and then wait for the divided work to complete.","pos":[1569,1678]},{"content":"When you want to apply the same routine to every element of a collection in parallel, use a parallel algorithm, such as <bpt id=\"p1\">[</bpt>concurrency::parallel_for<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_for)</ept>, instead of a task or task group.","pos":[1697,1937],"source":"When you want to apply the same routine to every element of a collection in parallel, use a parallel algorithm, such as [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for), instead of a task or task group."},{"content":"For more information about parallel algorithms, see <bpt id=\"p1\">[</bpt>Parallel Algorithms<ept id=\"p1\">](../../parallel/concrt/parallel-algorithms.md)</ept>.","pos":[1938,2058],"source":" For more information about parallel algorithms, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)."},{"content":"Key Points","pos":[2068,2078]},{"content":"When you pass variables to a lambda expression by reference, you must guarantee that the lifetime of that variable persists until the task finishes.","pos":[2088,2236]},{"content":"Use tasks (the <bpt id=\"p1\">[</bpt>concurrency::task<ept id=\"p1\">](../../parallel/concrt/reference/task-class.md)</ept> class) when you write asynchronous code.","pos":[2246,2368],"source":"Use tasks (the [concurrency::task](../../parallel/concrt/reference/task-class.md) class) when you write asynchronous code."},{"content":"The task class uses the Windows ThreadPool as its scheduler, not the Concurrency Runtime.","pos":[2369,2458]},{"pos":[2468,2775],"content":"Use task groups (the <bpt id=\"p1\">[</bpt>concurrency::task_group<ept id=\"p1\">](reference/task-group-class.md)</ept> class or the <bpt id=\"p2\">[</bpt>concurrency::parallel_invoke<ept id=\"p2\">](reference/concurrency-namespace-functions.md#parallel_invoke)</ept> algorithm) when you want to decompose parallel work into smaller pieces and then wait for those smaller pieces to complete.","source":"Use task groups (the [concurrency::task_group](reference/task-group-class.md) class or the [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) algorithm) when you want to decompose parallel work into smaller pieces and then wait for those smaller pieces to complete."},{"content":"Use the <bpt id=\"p1\">[</bpt>concurrency::task::then<ept id=\"p1\">](reference/task-class.md#then)</ept> method to create continuations.","pos":[2785,2880],"source":"Use the [concurrency::task::then](reference/task-class.md#then) method to create continuations."},{"content":"A <bpt id=\"p1\">*</bpt>continuation<ept id=\"p1\">*</ept> is a task that runs asynchronously after another task completes.","pos":[2881,2962],"source":" A *continuation* is a task that runs asynchronously after another task completes."},{"content":"You can connect any number of continuations to form a chain of asynchronous work.","pos":[2963,3044]},{"content":"A task-based continuation is always scheduled for execution when the antecedent task finishes, even when the antecedent task is canceled or throws an exception.","pos":[3054,3214]},{"content":"Use <bpt id=\"p1\">[</bpt>concurrency:: HYPERLINK \"http://msdn.microsoft.com/library/system.threading.tasks.task.whenall(v=VS.110).aspx\" when_all<ept id=\"p1\">](reference/concurrency-namespace-functions.md#when_all)</ept> to create a task that completes after every member of a set of tasks completes.","pos":[3224,3484],"source":"Use [concurrency:: HYPERLINK \"http://msdn.microsoft.com/library/system.threading.tasks.task.whenall(v=VS.110).aspx\" when_all](reference/concurrency-namespace-functions.md#when_all) to create a task that completes after every member of a set of tasks completes."},{"content":"Use <bpt id=\"p1\">[</bpt>concurrency::when_any<ept id=\"p1\">](reference/concurrency-namespace-functions.md#when_all)</ept> to create a task that completes after one member of a set of tasks completes.","pos":[3485,3645],"source":" Use [concurrency::when_any](reference/concurrency-namespace-functions.md#when_all) to create a task that completes after one member of a set of tasks completes."},{"content":"Tasks and task groups can participate in the Parallel Patterns Library (PPL) cancellation mechanism.","pos":[3656,3756]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Cancellation in the PPL<ept id=\"p1\">](cancellation-in-the-ppl.md)</ept>.","pos":[3757,3837],"source":" For more information, see [Cancellation in the PPL](cancellation-in-the-ppl.md)."},{"pos":[3847,4030],"content":"To learn how the runtime handles exceptions that are thrown by tasks and task groups, see <bpt id=\"p1\">[</bpt>Exception Handling<ept id=\"p1\">](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)</ept>.","source":"To learn how the runtime handles exceptions that are thrown by tasks and task groups, see [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)."},{"content":"In this Document","pos":[4039,4055]},{"content":"Using Lambda Expressions","pos":[4064,4088]},{"content":"The task Class","pos":[4108,4122]},{"content":"Continuation Tasks","pos":[4145,4163]},{"content":"Value-Based Versus Task-Based Continuations","pos":[4189,4232]},{"content":"Composing Tasks","pos":[4262,4277]},{"content":"The when_all Function","pos":[4309,4330]},{"content":"The when_any Function","pos":[4355,4376]},{"content":"Delayed Task Execution","pos":[4397,4419]},{"content":"Task Groups","pos":[4445,4456]},{"content":"Comparing task_group to structured_task_group","pos":[4480,4525]},{"content":"Example","pos":[4554,4561]},{"content":"Robust Programming","pos":[4581,4599]},{"pos":[4642,4666],"content":"Using Lambda Expressions"},{"content":"Because of their succinct syntax, lambda expressions are a common way to define the work that is performed by tasks and task groups.","pos":[4670,4802]},{"content":"Here are some usage tips:","pos":[4803,4828]},{"content":"Because tasks typically run on background threads, be aware of the object lifetime when you capture variables in lambda expressions.","pos":[4838,4970]},{"content":"When you capture a variable by value, a copy of that variable is made in the lambda body.","pos":[4971,5060]},{"content":"When you capture by reference, a copy is not made.","pos":[5061,5111]},{"content":"Therefore, ensure that the lifetime of any variable that you capture by reference outlives the task that uses it.","pos":[5112,5225]},{"content":"When you pass a lambda expression to a task, don’t capture variables that are allocated on the stack by reference.","pos":[5235,5349]},{"content":"Be explicit about the variables you capture in lambda expressions so   that you can identify what you’re capturing by value versus by reference.","pos":[5359,5503]},{"content":"For this reason we recommend that you do not use the <ph id=\"ph1\">`[=]`</ph> or <ph id=\"ph2\">`[&amp;]`</ph> options for lambda expressions.","pos":[5504,5603],"source":" For this reason we recommend that you do not use the `[=]` or `[&]` options for lambda expressions."},{"content":"A common pattern is when one task in a continuation chain assigns to a variable, and another task reads that variable.","pos":[5610,5728]},{"content":"You can’t capture by value because each continuation task would hold a different copy of the variable.","pos":[5729,5831]},{"content":"For stack-allocated variables, you also can’t capture by reference because the variable may no longer be valid.","pos":[5832,5943]},{"content":"To solve this problem, use a smart pointer, such as <bpt id=\"p1\">[</bpt>std::shared_ptr<ept id=\"p1\">](../../standard-library/shared-ptr-class.md)</ept>, to wrap the variable and pass the smart pointer by value.","pos":[5950,6122],"source":"To solve this problem, use a smart pointer, such as [std::shared_ptr](../../standard-library/shared-ptr-class.md), to wrap the variable and pass the smart pointer by value."},{"content":"In this way, the underlying object can be assigned to and read from, and will outlive the tasks that use it.","pos":[6123,6231]},{"content":"Use this technique even when the variable is a pointer or a reference-counted handle (<ph id=\"ph1\">`^`</ph>) to a Windows Runtime object.","pos":[6232,6351],"source":" Use this technique even when the variable is a pointer or a reference-counted handle (`^`) to a Windows Runtime object."},{"content":"Here’s a basic example:","pos":[6352,6375]},{"pos":[6393,6422],"content":"concrt-lambda-task-lifetime#1"},{"pos":[6513,6625],"content":"For more information about lambda expressions, see <bpt id=\"p1\">[</bpt>Lambda Expressions<ept id=\"p1\">](../../cpp/lambda-expressions-in-cpp.md)</ept>.","source":"For more information about lambda expressions, see [Lambda Expressions](../../cpp/lambda-expressions-in-cpp.md)."},{"pos":[6661,6675],"content":"The task Class"},{"content":"You can use the <bpt id=\"p1\">[</bpt>concurrency::task<ept id=\"p1\">](../../parallel/concrt/reference/task-class.md)</ept> class to compose tasks into a set of dependent operations.","pos":[6679,6820],"source":"You can use the [concurrency::task](../../parallel/concrt/reference/task-class.md) class to compose tasks into a set of dependent operations."},{"content":"This composition model is supported by the notion of <bpt id=\"p1\">*</bpt>continuations<ept id=\"p1\">*</ept>.","pos":[6821,6890],"source":" This composition model is supported by the notion of *continuations*."},{"content":"A continuation enables code to be executed when the previous, or <bpt id=\"p1\">*</bpt>antecedent<ept id=\"p1\">*</ept>, task completes.","pos":[6891,6985],"source":" A continuation enables code to be executed when the previous, or *antecedent*, task completes."},{"content":"The result of the antecedent task is passed as the input to the one or more continuation tasks.","pos":[6986,7081]},{"content":"When an antecedent task completes, any continuation tasks that are waiting on it are scheduled for execution.","pos":[7082,7191]},{"content":"Each continuation task receives a copy of the result of the antecedent task.","pos":[7192,7268]},{"content":"In turn, those continuation tasks may also be antecedent tasks for other continuations, thereby creating a chain of tasks.","pos":[7269,7391]},{"content":"Continuations help you create arbitrary-length chains of tasks that have specific dependencies among them.","pos":[7392,7498]},{"content":"In addition, a task can participate in cancellation either before a tasks starts or in a cooperative manner while it is running.","pos":[7499,7627]},{"content":"For more information about this cancellation model, see <bpt id=\"p1\">[</bpt>Cancellation in the PPL<ept id=\"p1\">](cancellation-in-the-ppl.md)</ept>.","pos":[7628,7738],"source":" For more information about this cancellation model, see [Cancellation in the PPL](cancellation-in-the-ppl.md)."},{"content":"is a template class.","pos":[7752,7772]},{"content":"The type parameter <ph id=\"ph1\">`T`</ph> is the type of the result that is produced by the task.","pos":[7773,7851],"source":" The type parameter `T` is the type of the result that is produced by the task."},{"content":"This type can be <ph id=\"ph1\">`void`</ph> if the task does not return a value.","pos":[7852,7912],"source":" This type can be `void` if the task does not return a value."},{"content":"cannot use the <ph id=\"ph1\">`const`</ph> modifier.","pos":[7917,7949],"source":" cannot use the `const` modifier."},{"content":"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD When you create a task, you provide a <bpt id=\"p1\">*</bpt>work function<ept id=\"p1\">*</ept> that performs the task body.","pos":[7956,8052],"source":"<<<<<<< HEAD\n When you create a task, you provide a *work function* that performs the task body."},{"content":"This work function comes in the form of a lambda function, function pointer, or function object.","pos":[8053,8149]},{"content":"To wait for a task to finish without obtaining the result, call the <bpt id=\"p1\">[</bpt>concurrency::task::wait<ept id=\"p1\">](reference/task-class.md#wait)</ept> method.","pos":[8150,8281],"source":" To wait for a task to finish without obtaining the result, call the [concurrency::task::wait](reference/task-class.md#wait) method."},{"content":"The <ph id=\"ph1\">`task::wait`</ph> method returns a <bpt id=\"p1\">[</bpt>concurrency::task_status<ept id=\"p1\">](reference/concurrency-namespace-enums.md#task_group_status)</ept> value that describes whether the task was completed or canceled.","pos":[8282,8467],"source":" The `task::wait` method returns a [concurrency::task_status](reference/concurrency-namespace-enums.md#task_group_status) value that describes whether the task was completed or canceled."},{"content":"To get the result of the task, call the <bpt id=\"p1\">[</bpt>concurrency::task::get<ept id=\"p1\">](reference/task-class.md#get)</ept> method.","pos":[8468,8569],"source":" To get the result of the task, call the [concurrency::task::get](reference/task-class.md#get) method."},{"content":"This method calls <ph id=\"ph1\">`task::wait`</ph> to wait for the task to finish, and therefore blocks execution of the current thread until the result is available.","pos":[8570,8716],"source":" This method calls `task::wait` to wait for the task to finish, and therefore blocks execution of the current thread until the result is available."},{"content":"The following example shows how to create a task, wait for its result, and display its value.","pos":[8725,8818]},{"content":"The examples in this documentation use lambda functions because they provide a more succinct syntax.","pos":[8819,8919]},{"content":"However, you can also use function pointers and function objects when you use tasks.","pos":[8920,9004]},{"pos":[9022,9041],"content":"concrt-basic-task#1"},{"content":"When you use the <bpt id=\"p1\">[</bpt>concurrency::create_task<ept id=\"p1\">](reference/concurrency-namespace-functions.md#create_task)</ept> function, you can use the <ph id=\"ph1\">`auto`</ph> keyword instead of declaring the type.","pos":[9133,9306],"source":"When you use the [concurrency::create_task](reference/concurrency-namespace-functions.md#create_task) function, you can use the `auto` keyword instead of declaring the type."},{"content":"For example, consider this code that creates and prints the identity matrix:","pos":[9307,9383]},{"pos":[9402,9422],"content":"concrt-create-task#1"},{"pos":[9513,9587],"content":"You can use the <ph id=\"ph1\">`create_task`</ph> function to create the equivalent operation.","source":"You can use the `create_task` function to create the equivalent operation."},{"pos":[9605,9625],"content":"concrt-create-task#2"},{"content":"If an exception is thrown during the execution of a task, the runtime marshals that exception in the subsequent call to <ph id=\"ph1\">`task::get`</ph> or <ph id=\"ph2\">`task::wait`</ph>, or to a task-based continuation.","pos":[9716,9897],"source":"If an exception is thrown during the execution of a task, the runtime marshals that exception in the subsequent call to `task::get` or `task::wait`, or to a task-based continuation."},{"content":"For more information about the task exception-handling mechanism, see <bpt id=\"p1\">[</bpt>Exception Handling<ept id=\"p1\">](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)</ept>.","pos":[9898,10061],"source":" For more information about the task exception-handling mechanism, see [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)."},{"content":"For an example that uses <ph id=\"ph1\">`task`</ph>, <bpt id=\"p1\">[</bpt>concurrency::task_completion_event<ept id=\"p1\">](../../parallel/concrt/reference/task-completion-event-class.md)</ept>, cancellation, see <bpt id=\"p2\">[</bpt>Walkthrough: Connecting Using Tasks and XML HTTP Requests<ept id=\"p2\">](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md)</ept>.","pos":[10068,10364],"source":"For an example that uses `task`, [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md), cancellation, see [Walkthrough: Connecting Using Tasks and XML HTTP Requests](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md)."},{"content":"(The <ph id=\"ph1\">`task_completion_event`</ph> class is described later in this document.)","pos":[10365,10437],"source":" (The `task_completion_event` class is described later in this document.)"},{"pos":[10445,10850],"content":"[!TIP]\n To learn details that are specific to tasks in [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] apps, see [Asynchronous programming in C++](http://msdn.microsoft.com/en-us/512700b7-7863-44cc-93a2-366938052f31) and [Creating Asynchronous Operations in C++ for Windows Store Apps](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md).","leadings":["","> "],"nodes":[{"content":"To learn details that are specific to tasks in <ph id=\"ph1\">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> apps, see <bpt id=\"p1\">[</bpt>Asynchronous programming in C++<ept id=\"p1\">](http://msdn.microsoft.com/en-us/512700b7-7863-44cc-93a2-366938052f31)</ept> and <bpt id=\"p2\">[</bpt>Creating Asynchronous Operations in C++ for Windows Store Apps<ept id=\"p2\">](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md)</ept>.","pos":[8,403],"source":" To learn details that are specific to tasks in [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] apps, see [Asynchronous programming in C++](http://msdn.microsoft.com/en-us/512700b7-7863-44cc-93a2-366938052f31) and [Creating Asynchronous Operations in C++ for Windows Store Apps](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md)."}]},{"pos":[10889,10907],"content":"Continuation Tasks"},{"content":"In asynchronous programming, it is very common for one asynchronous operation, on completion, to invoke a second operation and pass data to it.","pos":[10911,11054]},{"content":"Traditionally, this is done by using callback methods.","pos":[11055,11109]},{"content":"In the Concurrency Runtime, the same functionality is provided by <bpt id=\"p1\">*</bpt>continuation tasks<ept id=\"p1\">*</ept>.","pos":[11110,11197],"source":" In the Concurrency Runtime, the same functionality is provided by *continuation tasks*."},{"content":"A continuation task (also known just as a continuation) is an asynchronous task that is invoked by another task, which is known as the <bpt id=\"p1\">*</bpt>antecedent<ept id=\"p1\">*</ept>, when the antecedent completes.","pos":[11198,11377],"source":" A continuation task (also known just as a continuation) is an asynchronous task that is invoked by another task, which is known as the *antecedent*, when the antecedent completes."},{"content":"By using continuations, you can:","pos":[11378,11410]},{"content":"Pass data from the antecedent to the continuation.","pos":[11420,11470]},{"content":"Specify the precise conditions under which the continuation is invoked or not invoked.","pos":[11480,11566]},{"content":"Cancel a continuation either before it starts or cooperatively while it is running.","pos":[11576,11659]},{"content":"Provide hints about how the continuation should be scheduled.","pos":[11669,11730]},{"content":"(This applies to <ph id=\"ph1\">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> apps only.","pos":[11731,11834],"source":" (This applies to [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] apps only."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Creating Asynchronous Operations in C++ for Windows Store Apps<ept id=\"p1\">](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md)</ept>.)","pos":[11835,12016],"source":" For more information, see [Creating Asynchronous Operations in C++ for Windows Store Apps](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md).)"},{"content":"Invoke multiple continuations from the same antecedent.","pos":[12026,12081]},{"content":"Invoke one continuation when all or any of multiple antecedents complete.","pos":[12091,12164]},{"content":"Chain continuations one after another to any length.","pos":[12174,12226]},{"content":"Use a continuation to handle exceptions that are thrown by the antecedent.","pos":[12236,12310]},{"content":"These features enable you to execute one or more tasks when the first task completes.","pos":[12317,12402]},{"content":"For example, you can create a continuation that compresses a file after the first task reads it from disk.","pos":[12403,12509]},{"pos":[12518,12733],"content":"The following example modifies the previous one to use the <bpt id=\"p1\">[</bpt>concurrency::task::then<ept id=\"p1\">](reference/task-class.md#then)</ept> method to schedule a continuation that prints the value of the antecedent task when it is available.","source":"The following example modifies the previous one to use the [concurrency::task::then](reference/task-class.md#then) method to schedule a continuation that prints the value of the antecedent task when it is available."},{"pos":[12753,12780],"content":"concrt-basic-continuation#1"},{"content":"You can chain and nest tasks to any length.","pos":[12871,12914]},{"content":"A task can also have multiple continuations.","pos":[12915,12959]},{"content":"The following example illustrates a basic continuation chain that increments the value of the previous task three times.","pos":[12960,13080]},{"pos":[13098,13125],"content":"concrt-continuation-chain#1"},{"content":"A continuation can also return another task.","pos":[13216,13260]},{"content":"If there is no cancellation, then this task is executed before the subsequent continuation.","pos":[13261,13352]},{"content":"This technique is known as <bpt id=\"p1\">*</bpt>asynchronous unwrapping<ept id=\"p1\">*</ept>.","pos":[13353,13406],"source":" This technique is known as *asynchronous unwrapping*."},{"content":"Asynchronous unwrapping is useful when you want to perform additional work in the background, but do not want the current task to block the current thread.","pos":[13407,13562]},{"content":"(This is common in <ph id=\"ph1\">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> apps, where continuations can run on the UI thread).","pos":[13563,13710],"source":" (This is common in [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] apps, where continuations can run on the UI thread)."},{"content":"The following example shows three tasks.","pos":[13711,13751]},{"content":"The first task returns another task that is run before a continuation task.","pos":[13752,13827]},{"pos":[13845,13870],"content":"concrt-async-unwrapping#1"},{"pos":[13962,14217],"content":"[!IMPORTANT]\n When a continuation of a task returns a nested task of type `N`, the resulting task has the type `N`, not `task<N>`, and completes when the nested task completes. In other words, the continuation performs the unwrapping of the nested task.","leadings":["","> "],"nodes":[{"content":" When a continuation of a task returns a nested task of type `N`, the resulting task has the type `N`, not `task<N>`, and completes when the nested task completes. In other words, the continuation performs the unwrapping of the nested task.","pos":[13,253],"nodes":[{"content":"When a continuation of a task returns a nested task of type <ph id=\"ph1\">`N`</ph>, the resulting task has the type <ph id=\"ph2\">`N`</ph>, not <ph id=\"ph3\">`task&lt;N&gt;`</ph>, and completes when the nested task completes.","pos":[1,163],"source":" When a continuation of a task returns a nested task of type `N`, the resulting task has the type `N`, not `task<N>`, and completes when the nested task completes."},{"content":"In other words, the continuation performs the unwrapping of the nested task.","pos":[164,240]}]}]},{"pos":[14260,14303],"content":"Value-Based Versus Task-Based Continuations"},{"content":"Given a <ph id=\"ph1\">`task`</ph> object whose return type is <ph id=\"ph2\">`T`</ph>, you can provide a value of type <ph id=\"ph3\">`T`</ph> or <ph id=\"ph4\">`task&lt;T&gt;`</ph> to its continuation tasks.","pos":[14307,14430],"source":"Given a `task` object whose return type is `T`, you can provide a value of type `T` or `task<T>` to its continuation tasks."},{"content":"A continuation that takes type <ph id=\"ph1\">`T`</ph> is known as a <bpt id=\"p1\">*</bpt>value-based continuation<ept id=\"p1\">*</ept>.","pos":[14431,14507],"source":" A continuation that takes type `T` is known as a *value-based continuation*."},{"content":"A value-based continuation is scheduled for execution when the antecedent task completes without error and is not canceled.","pos":[14508,14631]},{"content":"A continuation that takes type <ph id=\"ph1\">`task&lt;T&gt;`</ph> as its parameter is known as a <bpt id=\"p1\">*</bpt>task-based continuation<ept id=\"p1\">*</ept>.","pos":[14632,14730],"source":" A continuation that takes type `task<T>` as its parameter is known as a *task-based continuation*."},{"content":"A task-based continuation is always scheduled for execution when the antecedent task finishes, even when the antecedent task is canceled or throws an exception.","pos":[14731,14891]},{"content":"You can then call <ph id=\"ph1\">`task::get`</ph> to get the result of the antecedent task.","pos":[14892,14963],"source":" You can then call `task::get` to get the result of the antecedent task."},{"content":"If the antecedent task was canceled, <ph id=\"ph1\">`task::get`</ph> throws <bpt id=\"p1\">[</bpt>concurrency::task_canceled<ept id=\"p1\">](../../parallel/concrt/reference/task-canceled-class.md)</ept>.","pos":[14964,15105],"source":" If the antecedent task was canceled, `task::get` throws [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md)."},{"content":"If the antecedent task threw an exception, <ph id=\"ph1\">`task::get`</ph> rethrows that exception.","pos":[15106,15185],"source":" If the antecedent task threw an exception, `task::get` rethrows that exception."},{"content":"A task-based continuation is not marked as canceled when its antecedent task is canceled.","pos":[15186,15275]},{"pos":[15316,15331],"content":"Composing Tasks"},{"pos":[15335,15606],"content":"This section describes the <bpt id=\"p1\">[</bpt>concurrency::when_all<ept id=\"p1\">](reference/concurrency-namespace-functions.md#when_all)</ept> and <bpt id=\"p2\">[</bpt>concurrency::when_any<ept id=\"p2\">](reference/concurrency-namespace-functions.md#when_all)</ept> functions, which can help you compose multiple tasks to implement common patterns.","source":"This section describes the [concurrency::when_all](reference/concurrency-namespace-functions.md#when_all) and [concurrency::when_any](reference/concurrency-namespace-functions.md#when_all) functions, which can help you compose multiple tasks to implement common patterns."},{"pos":[15642,15663],"content":"The when_all Function"},{"content":"The <ph id=\"ph1\">`when_all`</ph> function produces a task that completes after a set of tasks complete.","pos":[15667,15752],"source":"The `when_all` function produces a task that completes after a set of tasks complete."},{"content":"This function returns a std::<bpt id=\"p1\">[</bpt>vector<ept id=\"p1\">](../../standard-library/vector-class.md)</ept> object that contains the result of each task in the set.","pos":[15753,15887],"source":" This function returns a std::[vector](../../standard-library/vector-class.md) object that contains the result of each task in the set."},{"content":"The following basic example uses <ph id=\"ph1\">`when_all`</ph> to create a task that represents the completion of three other tasks.","pos":[15888,16001],"source":" The following basic example uses `when_all` to create a task that represents the completion of three other tasks."},{"pos":[16019,16038],"content":"concrt-join-tasks#1"},{"pos":[16130,16247],"content":"[!NOTE]\n The tasks that you pass to `when_all` must be uniform. In other words, they must all return the same type.","leadings":["","> "],"nodes":[{"content":" The tasks that you pass to `when_all` must be uniform. In other words, they must all return the same type.","pos":[8,115],"nodes":[{"content":"The tasks that you pass to <ph id=\"ph1\">`when_all`</ph> must be uniform.","pos":[1,55],"source":" The tasks that you pass to `when_all` must be uniform."},{"content":"In other words, they must all return the same type.","pos":[56,107]}]}]},{"pos":[16254,16385],"content":"You can also use the <ph id=\"ph1\">`&amp;&amp;`</ph> syntax to produce a task that completes after a set of tasks complete, as shown in the following example.","source":"You can also use the `&&` syntax to produce a task that completes after a set of tasks complete, as shown in the following example."},{"content":"It is common to use a continuation together with <ph id=\"ph1\">`when_all`</ph> to perform an action after a set of tasks finishes.","pos":[16439,16550],"source":"It is common to use a continuation together with `when_all` to perform an action after a set of tasks finishes."},{"content":"The following example modifies the previous one to print the sum of three tasks that each produce an <ph id=\"ph1\">`int`</ph> result.","pos":[16551,16665],"source":" The following example modifies the previous one to print the sum of three tasks that each produce an `int` result."},{"pos":[16683,16702],"content":"concrt-join-tasks#2"},{"pos":[16793,16887],"content":"In this example, you can also specify<ph id=\"ph1\">`task&lt;vector&lt;int&gt;&gt;`</ph> to produce a task-based continuation.","source":"In this example, you can also specify`task<vector<int>>` to produce a task-based continuation."},{"content":"If any task in a set of tasks is canceled or throws an exception, <ph id=\"ph1\">`when_all`</ph> immediately completes and does not wait for the remaining tasks to finish.","pos":[16894,17045],"source":"If any task in a set of tasks is canceled or throws an exception, `when_all` immediately completes and does not wait for the remaining tasks to finish."},{"content":"If an exception is thrown, the runtime rethrows the exception when you call <ph id=\"ph1\">`task::get`</ph> or <ph id=\"ph2\">`task::wait`</ph> on the task object that <ph id=\"ph3\">`when_all`</ph> returns.","pos":[17046,17193],"source":" If an exception is thrown, the runtime rethrows the exception when you call `task::get` or `task::wait` on the task object that `when_all` returns."},{"content":"If more than one task throws, the runtime chooses one of them.","pos":[17194,17256]},{"content":"Therefore, ensure that you observe all exceptions after all tasks complete; an unhandled task exception causes the app to terminate.","pos":[17257,17389]},{"content":"Here’s a utility function that you can use to ensure that your program observes all exceptions.","pos":[17396,17491]},{"content":"For each task in the provided range, <ph id=\"ph1\">`observe_all_exceptions`</ph> triggers any exception that occurred to be rethrown and then swallows that exception.","pos":[17492,17639],"source":" For each task in the provided range, `observe_all_exceptions` triggers any exception that occurred to be rethrown and then swallows that exception."},{"pos":[17657,17677],"content":"concrt-eh-when_all#1"},{"content":"Consider a <ph id=\"ph1\">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app that uses C++ and XAML and writes a set of files to disk.","pos":[17769,17917],"source":"Consider a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app that uses C++ and XAML and writes a set of files to disk."},{"content":"The following example shows how to use <ph id=\"ph1\">`when_all`</ph> and <ph id=\"ph2\">`observe_all_exceptions`</ph> to ensure that the program observes all exceptions.","pos":[17918,18048],"source":" The following example shows how to use `when_all` and `observe_all_exceptions` to ensure that the program observes all exceptions."},{"pos":[18066,18086],"content":"concrt-eh-when_all#2"},{"content":"To run this example","pos":[18183,18202]},{"pos":[18212,18253],"content":"In MainPage.xaml, add a <ph id=\"ph1\">`Button`</ph> control.","source":"In MainPage.xaml, add a `Button` control."},{"pos":[18271,18291],"content":"concrt-eh-when_all#3"},{"pos":[18388,18500],"content":"In MainPage.xaml.h, add these forward declarations to the <ph id=\"ph1\">`private`</ph> section of the <ph id=\"ph2\">`MainPage`</ph> class declaration.","source":"In MainPage.xaml.h, add these forward declarations to the `private` section of the `MainPage` class declaration."},{"pos":[18518,18538],"content":"concrt-eh-when_all#4"},{"pos":[18631,18696],"content":"In MainPage.xaml.cpp, implement the <ph id=\"ph1\">`Button_Click`</ph> event handler.","source":"In MainPage.xaml.cpp, implement the `Button_Click` event handler."},{"pos":[18714,18734],"content":"concrt-eh-when_all#5"},{"pos":[18829,18903],"content":"In MainPage.xaml.cpp, implement <ph id=\"ph1\">`WriteFilesAsync`</ph> as shown in the example.","source":"In MainPage.xaml.cpp, implement `WriteFilesAsync` as shown in the example."},{"content":"is a non-blocking function that produces a <ph id=\"ph1\">`task`</ph> as its result.","pos":[18932,18996],"source":" is a non-blocking function that produces a `task` as its result."},{"content":"Unlike <bpt id=\"p1\">[</bpt>task::wait<ept id=\"p1\">](reference/task-class.md#wait)</ept>, it is safe to call this function in a <ph id=\"ph1\">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app on the ASTA (Application STA) thread.","pos":[18997,19203],"source":" Unlike [task::wait](reference/task-class.md#wait), it is safe to call this function in a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app on the ASTA (Application STA) thread."},{"pos":[19239,19260],"content":"The when_any Function"},{"content":"The <ph id=\"ph1\">`when_any`</ph> function produces a task that completes when the first task in a set of tasks completes.","pos":[19264,19367],"source":"The `when_any` function produces a task that completes when the first task in a set of tasks completes."},{"content":"This function returns a <bpt id=\"p1\">[</bpt>std::pair<ept id=\"p1\">](../../standard-library/pair-structure.md)</ept> object that contains the result of the completed task and the index of that task in the set.","pos":[19368,19538],"source":" This function returns a [std::pair](../../standard-library/pair-structure.md) object that contains the result of the completed task and the index of that task in the set."},{"pos":[19545,19617],"content":"The <ph id=\"ph1\">`when_any`</ph> function is especially useful in the following scenarios:","source":"The `when_any` function is especially useful in the following scenarios:"},{"content":"Redundant operations.","pos":[19627,19648]},{"content":"Consider an algorithm or operation that can be performed in many ways.","pos":[19649,19719]},{"content":"You can use the <ph id=\"ph1\">`when_any`</ph> function to select the operation that finishes first and then cancel the remaining operations.","pos":[19720,19841],"source":" You can use the `when_any` function to select the operation that finishes first and then cancel the remaining operations."},{"content":"Interleaved operations.","pos":[19851,19874]},{"content":"You can start multiple operations that all must finish and use the <ph id=\"ph1\">`when_any`</ph> function to process results as each operation finishes.","pos":[19875,20008],"source":" You can start multiple operations that all must finish and use the `when_any` function to process results as each operation finishes."},{"content":"After one operation finishes, you can start one or more additional tasks.","pos":[20009,20082]},{"content":"Throttled operations.","pos":[20092,20113]},{"content":"You can use the <ph id=\"ph1\">`when_any`</ph> function to extend the previous scenario by limiting the number of concurrent operations.","pos":[20114,20230],"source":" You can use the `when_any` function to extend the previous scenario by limiting the number of concurrent operations."},{"content":"Expired operations.","pos":[20240,20259]},{"content":"You can use the <ph id=\"ph1\">`when_any`</ph> function to select between one or more tasks and a task that finishes after a specific time.","pos":[20260,20379],"source":" You can use the `when_any` function to select between one or more tasks and a task that finishes after a specific time."},{"content":"As with <ph id=\"ph1\">`when_all`</ph>, it is common to use a continuation that has <ph id=\"ph2\">`when_any`</ph> to perform action when the first in a set of tasks finish.","pos":[20386,20519],"source":"As with `when_all`, it is common to use a continuation that has `when_any` to perform action when the first in a set of tasks finish."},{"content":"The following basic example uses <ph id=\"ph1\">`when_any`</ph> to create a task that completes when the first of three other tasks completes.","pos":[20520,20642],"source":" The following basic example uses `when_any` to create a task that completes when the first of three other tasks completes."},{"pos":[20660,20680],"content":"concrt-select-task#1"},{"pos":[20772,20873],"content":"In this example, you can also specify <ph id=\"ph1\">`task&lt;pair&lt;int, size_t&gt;&gt;`</ph> to produce a task-based continuation.","source":"In this example, you can also specify `task<pair<int, size_t>>` to produce a task-based continuation."},{"pos":[20881,20980],"content":"[!NOTE]\n As with `when_all`, the tasks that you pass to `when_any` must all return the same type.","leadings":["","> "],"nodes":[{"content":"As with <ph id=\"ph1\">`when_all`</ph>, the tasks that you pass to <ph id=\"ph2\">`when_any`</ph> must all return the same type.","pos":[9,97],"source":" As with `when_all`, the tasks that you pass to `when_any` must all return the same type."}]},{"pos":[20987,21137],"content":"You can also use the <ph id=\"ph1\">`||`</ph> syntax to produce a task that completes after the first task in a set of tasks completes, as shown in the following example.","source":"You can also use the `||` syntax to produce a task that completes after the first task in a set of tasks completes, as shown in the following example."},{"pos":[21192,21373],"content":"[!TIP]\n As with `when_all`, `when_any` is non-blocking and is safe to call in a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app on the ASTA thread.","leadings":["","> "],"nodes":[{"content":"As with <ph id=\"ph1\">`when_all`</ph>, <ph id=\"ph2\">`when_any`</ph> is non-blocking and is safe to call in a <ph id=\"ph3\">[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]</ph> app on the ASTA thread.","pos":[8,179],"source":" As with `when_all`, `when_any` is non-blocking and is safe to call in a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app on the ASTA thread."}]},{"pos":[21412,21434],"content":"Delayed Task Execution"},{"content":"It is sometimes necessary to delay the execution of a task until a condition is satisfied, or to start a task in response to an external event.","pos":[21438,21581]},{"content":"For example, in asynchronous programming, you might have to start a task in response to an I/O completion event.","pos":[21582,21694]},{"content":"Two ways to accomplish this are to use a continuation or to start a task and wait on an event inside the task’s work function.","pos":[21701,21827]},{"content":"However, there are cases where is it not possible to use one of these techniques.","pos":[21828,21909]},{"content":"For example, to create a continuation, you must have the antecedent task.","pos":[21910,21983]},{"content":"However, if you do not have the antecedent task, you can create a <bpt id=\"p1\">*</bpt>task completion event<ept id=\"p1\">*</ept> and later chain that completion event to the antecedent task when it becomes available.","pos":[21984,22161],"source":" However, if you do not have the antecedent task, you can create a *task completion event* and later chain that completion event to the antecedent task when it becomes available."},{"content":"In addition, because a waiting task also blocks a thread, you can use task completion events to perform work when an asynchronous operation completes, and thereby free a thread.","pos":[22162,22339]},{"content":"The <bpt id=\"p1\">[</bpt>concurrency::task_completion_event<ept id=\"p1\">](../../parallel/concrt/reference/task-completion-event-class.md)</ept> class helps simplify such composition of tasks.","pos":[22346,22498],"source":"The [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) class helps simplify such composition of tasks."},{"content":"Like the <ph id=\"ph1\">`task`</ph> class, the type parameter <ph id=\"ph2\">`T`</ph> is the type of the result that is produced by the task.","pos":[22499,22600],"source":" Like the `task` class, the type parameter `T` is the type of the result that is produced by the task."},{"content":"This type can be <ph id=\"ph1\">`void`</ph> if the task does not return a value.","pos":[22601,22661],"source":" This type can be `void` if the task does not return a value."},{"content":"cannot use the <ph id=\"ph1\">`const`</ph> modifier.","pos":[22666,22698],"source":" cannot use the `const` modifier."},{"content":"Typically, a <ph id=\"ph1\">`task_completion_event`</ph> object is provided to a thread or task that will signal it when the value for it becomes available.","pos":[22699,22835],"source":" Typically, a `task_completion_event` object is provided to a thread or task that will signal it when the value for it becomes available."},{"content":"At the same time, one or more tasks are set as listeners of that event.","pos":[22836,22907]},{"content":"When the event is set, the listener tasks complete and their continuations are scheduled to run.","pos":[22908,23004]},{"pos":[23011,23243],"content":"For an example that uses <ph id=\"ph1\">`task_completion_event`</ph> to implement a task that completes after a delay, see <bpt id=\"p1\">[</bpt>How to: Create a Task that Completes After a Delay<ept id=\"p1\">](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md)</ept>.","source":"For an example that uses `task_completion_event` to implement a task that completes after a delay, see [How to: Create a Task that Completes After a Delay](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md)."},{"pos":[23280,23291],"content":"Task Groups"},{"content":"A <bpt id=\"p1\">*</bpt>task group<ept id=\"p1\">*</ept> organizes a collection of tasks.","pos":[23295,23342],"source":"A *task group* organizes a collection of tasks."},{"content":"Task groups push tasks on to a work-stealing queue.","pos":[23343,23394]},{"content":"The scheduler removes tasks from this queue and executes them on available computing resources.","pos":[23395,23490]},{"content":"After you add tasks to a task group, you can wait for all tasks to finish or cancel tasks that have not yet started.","pos":[23491,23607]},{"content":"The PPL uses the <bpt id=\"p1\">[</bpt>concurrency::task_group<ept id=\"p1\">](reference/task-group-class.md)</ept> and <bpt id=\"p2\">[</bpt>concurrency::structured_task_group<ept id=\"p2\">](../../parallel/concrt/reference/structured-task-group-class.md)</ept> classes to represent task groups, and the <bpt id=\"p3\">[</bpt>concurrency::task_handle<ept id=\"p3\">](../../parallel/concrt/reference/task-handle-class.md)</ept> class to represent the tasks that run in these groups.","pos":[23614,23970],"source":"The PPL uses the [concurrency::task_group](reference/task-group-class.md) and [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) classes to represent task groups, and the [concurrency::task_handle](../../parallel/concrt/reference/task-handle-class.md) class to represent the tasks that run in these groups."},{"content":"The <ph id=\"ph1\">`task_handle`</ph> class encapsulates the code that performs work.","pos":[23971,24036],"source":" The `task_handle` class encapsulates the code that performs work."},{"content":"Like the <ph id=\"ph1\">`task`</ph> class, the work function comes in the form of a lambda function, function pointer, or function object.","pos":[24037,24155],"source":" Like the `task` class, the work function comes in the form of a lambda function, function pointer, or function object."},{"content":"You typically do not need to work with <ph id=\"ph1\">`task_handle`</ph> objects directly.","pos":[24156,24226],"source":" You typically do not need to work with `task_handle` objects directly."},{"content":"Instead, you pass work functions to a task group, and the task group creates and manages the <ph id=\"ph1\">`task_handle`</ph> objects.","pos":[24227,24342],"source":" Instead, you pass work functions to a task group, and the task group creates and manages the `task_handle` objects."},{"content":"The PPL divides task groups into these two categories: <bpt id=\"p1\">*</bpt>unstructured task groups<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>structured task groups<ept id=\"p2\">*</ept>.","pos":[24349,24460],"source":"The PPL divides task groups into these two categories: *unstructured task groups* and *structured task groups*."},{"content":"The PPL uses the <ph id=\"ph1\">`task_group`</ph> class to represent unstructured task groups and the <ph id=\"ph2\">`structured_task_group`</ph> class to represent structured task groups.","pos":[24461,24609],"source":" The PPL uses the `task_group` class to represent unstructured task groups and the `structured_task_group` class to represent structured task groups."},{"content":"The PPL also defines the <bpt id=\"p1\">[</bpt>concurrency::parallel_invoke<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_invoke)</ept> algorithm, which uses the <ph id=\"ph1\">`structured_task_group`</ph> class to execute a set of tasks in parallel.","pos":[24634,24846],"source":"The PPL also defines the [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) algorithm, which uses the `structured_task_group` class to execute a set of tasks in parallel."},{"content":"Because the <ph id=\"ph1\">`parallel_invoke`</ph> algorithm has a more succinct syntax, we recommend that you use it instead of the <ph id=\"ph2\">`structured_task_group`</ph> class when you can.","pos":[24847,25002],"source":" Because the `parallel_invoke` algorithm has a more succinct syntax, we recommend that you use it instead of the `structured_task_group` class when you can."},{"content":"The topic <bpt id=\"p1\">[</bpt>Parallel Algorithms<ept id=\"p1\">](../../parallel/concrt/parallel-algorithms.md)</ept> describes <ph id=\"ph1\">`parallel_invoke`</ph> in greater detail.","pos":[25003,25127],"source":" The topic [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md) describes `parallel_invoke` in greater detail."},{"content":"Use <ph id=\"ph1\">`parallel_invoke`</ph> when you have several independent tasks that you want to execute at the same time, and you must wait for all tasks to finish before you continue.","pos":[25134,25301],"source":"Use `parallel_invoke` when you have several independent tasks that you want to execute at the same time, and you must wait for all tasks to finish before you continue."},{"content":"This technique is often referred to as <bpt id=\"p1\">*</bpt>fork and join<ept id=\"p1\">*</ept> parallelism.","pos":[25302,25369],"source":" This technique is often referred to as *fork and join* parallelism."},{"content":"Use <ph id=\"ph1\">`task_group`</ph> when you have several independent tasks that you want to execute at the same time, but you want to wait for the tasks to finish at a later time.","pos":[25370,25531],"source":" Use `task_group` when you have several independent tasks that you want to execute at the same time, but you want to wait for the tasks to finish at a later time."},{"content":"For example, you can add tasks to a <ph id=\"ph1\">`task_group`</ph> object and wait for the tasks to finish in another function or from another thread.","pos":[25532,25664],"source":" For example, you can add tasks to a `task_group` object and wait for the tasks to finish in another function or from another thread."},{"content":"Task groups support the concept of cancellation.","pos":[25671,25719]},{"content":"Cancellation enables you to signal to all active tasks that you want to cancel the overall operation.","pos":[25720,25821]},{"content":"Cancellation also prevents tasks that have not yet started from starting.","pos":[25822,25895]},{"content":"For more information about cancellation, see <bpt id=\"p1\">[</bpt>Cancellation in the PPL<ept id=\"p1\">](cancellation-in-the-ppl.md)</ept>.","pos":[25896,25995],"source":" For more information about cancellation, see [Cancellation in the PPL](cancellation-in-the-ppl.md)."},{"content":"The runtime also provides an exception-handling model that enables you to throw an exception from a task and handle that exception when you wait for the associated task group to finish.","pos":[26002,26187]},{"content":"For more information about this exception-handling model, see <bpt id=\"p1\">[</bpt>Exception Handling<ept id=\"p1\">](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)</ept>.","pos":[26188,26343],"source":" For more information about this exception-handling model, see [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)."},{"pos":[26385,26430],"content":"Comparing task_group to structured_task_group"},{"content":"Although we recommend that you use <ph id=\"ph1\">`task_group`</ph> or <ph id=\"ph2\">`parallel_invoke`</ph> instead of the <ph id=\"ph3\">`structured_task_group`</ph> class, there are cases where you want to use <ph id=\"ph4\">`structured_task_group`</ph>, for example, when you write a parallel algorithm that performs a variable number of tasks or requires support for cancellation.","pos":[26434,26739],"source":"Although we recommend that you use `task_group` or `parallel_invoke` instead of the `structured_task_group` class, there are cases where you want to use `structured_task_group`, for example, when you write a parallel algorithm that performs a variable number of tasks or requires support for cancellation."},{"content":"This section explains the differences between the <ph id=\"ph1\">`task_group`</ph> and <ph id=\"ph2\">`structured_task_group`</ph> classes.","pos":[26740,26839],"source":" This section explains the differences between the `task_group` and `structured_task_group` classes."},{"content":"The <ph id=\"ph1\">`task_group`</ph> class is thread-safe.","pos":[26846,26884],"source":"The `task_group` class is thread-safe."},{"content":"Therefore you can add tasks to a <ph id=\"ph1\">`task_group`</ph> object from multiple threads and wait on or cancel a <ph id=\"ph2\">`task_group`</ph> object from multiple threads.","pos":[26885,27026],"source":" Therefore you can add tasks to a `task_group` object from multiple threads and wait on or cancel a `task_group` object from multiple threads."},{"content":"The construction and destruction of a <ph id=\"ph1\">`structured_task_group`</ph> object must occur in the same lexical scope.","pos":[27027,27133],"source":" The construction and destruction of a `structured_task_group` object must occur in the same lexical scope."},{"content":"In addition, all operations on a <ph id=\"ph1\">`structured_task_group`</ph> object must occur on the same thread.","pos":[27134,27228],"source":" In addition, all operations on a `structured_task_group` object must occur on the same thread."},{"content":"The exception to this rule is the <bpt id=\"p1\">[</bpt>concurrency::structured_task_group::cancel<ept id=\"p1\">](reference/structured-task-group-class.md#cancel)</ept> and <bpt id=\"p2\">[</bpt>concurrency::structured_task_group::is_canceling<ept id=\"p2\">](reference/structured-task-group-class.md#is_canceling)</ept> methods.","pos":[27229,27475],"source":" The exception to this rule is the [concurrency::structured_task_group::cancel](reference/structured-task-group-class.md#cancel) and [concurrency::structured_task_group::is_canceling](reference/structured-task-group-class.md#is_canceling) methods."},{"content":"A child task can call these methods to cancel the parent task group or check for cancelation at any time.","pos":[27476,27581]},{"content":"You can run additional tasks on a <ph id=\"ph1\">`task_group`</ph> object after you call the <bpt id=\"p1\">[</bpt>concurrency::task_group::wait<ept id=\"p1\">](reference/task-group-class.md#wait)</ept> or <bpt id=\"p2\">[</bpt>concurrency::task_group::run_and_wait<ept id=\"p2\">](reference/task-group-class.md#run_and_wait)</ept> method.","pos":[27588,27823],"source":"You can run additional tasks on a `task_group` object after you call the [concurrency::task_group::wait](reference/task-group-class.md#wait) or [concurrency::task_group::run_and_wait](reference/task-group-class.md#run_and_wait) method."},{"content":"Conversely, if you run additional tasks on a <ph id=\"ph1\">`structured_task_group`</ph> object after you call the <bpt id=\"p1\">[</bpt>concurrency::structured_task_group::wait<ept id=\"p1\">](reference/structured-task-group-class.md#wait)</ept> or <bpt id=\"p2\">[</bpt>concurrency::structured_task_group::run_and_wait<ept id=\"p2\">](reference/structured-task-group-class.md#run_and_wait)</ept> methods, then the behavior is undefined.","pos":[27824,28158],"source":" Conversely, if you run additional tasks on a `structured_task_group` object after you call the [concurrency::structured_task_group::wait](reference/structured-task-group-class.md#wait) or [concurrency::structured_task_group::run_and_wait](reference/structured-task-group-class.md#run_and_wait) methods, then the behavior is undefined."},{"content":"Because the <ph id=\"ph1\">`structured_task_group`</ph> class does not synchronize across threads, it has less execution overhead than the <ph id=\"ph2\">`task_group`</ph> class.","pos":[28165,28303],"source":"Because the `structured_task_group` class does not synchronize across threads, it has less execution overhead than the `task_group` class."},{"content":"Therefore, if your problem does not require that you schedule work from multiple threads and you cannot use the <ph id=\"ph1\">`parallel_invoke`</ph> algorithm, the <ph id=\"ph2\">`structured_task_group`</ph> class can help you write better performing code.","pos":[28304,28521],"source":" Therefore, if your problem does not require that you schedule work from multiple threads and you cannot use the `parallel_invoke` algorithm, the `structured_task_group` class can help you write better performing code."},{"content":"If you use one <ph id=\"ph1\">`structured_task_group`</ph> object inside another <ph id=\"ph2\">`structured_task_group`</ph> object, the inner object must finish and be destroyed before the outer object finishes.","pos":[28528,28700],"source":"If you use one `structured_task_group` object inside another `structured_task_group` object, the inner object must finish and be destroyed before the outer object finishes."},{"content":"The <ph id=\"ph1\">`task_group`</ph> class does not require for nested task groups to finish before the outer group finishes.","pos":[28701,28806],"source":" The `task_group` class does not require for nested task groups to finish before the outer group finishes."},{"content":"Unstructured task groups and structured task groups work with task handles in different ways.","pos":[28813,28906]},{"content":"You can pass work functions directly to a <ph id=\"ph1\">`task_group`</ph> object; the <ph id=\"ph2\">`task_group`</ph> object will create and manage the task handle for you.","pos":[28907,29041],"source":" You can pass work functions directly to a `task_group` object; the `task_group` object will create and manage the task handle for you."},{"content":"The <ph id=\"ph1\">`structured_task_group`</ph> class requires you to manage a <ph id=\"ph2\">`task_handle`</ph> object for each task.","pos":[29042,29136],"source":" The `structured_task_group` class requires you to manage a `task_handle` object for each task."},{"content":"Every <ph id=\"ph1\">`task_handle`</ph> object must remain valid throughout the lifetime of its associated <ph id=\"ph2\">`structured_task_group`</ph> object.","pos":[29137,29255],"source":" Every `task_handle` object must remain valid throughout the lifetime of its associated `structured_task_group` object."},{"content":"Use the <bpt id=\"p1\">[</bpt>concurrency::make_task<ept id=\"p1\">](reference/concurrency-namespace-functions.md#make_task)</ept> function to create a <ph id=\"ph1\">`task_handle`</ph> object, as shown in the following basic example:","pos":[29256,29428],"source":" Use the [concurrency::make_task](reference/concurrency-namespace-functions.md#make_task) function to create a `task_handle` object, as shown in the following basic example:"},{"pos":[29446,29474],"content":"concrt-make-task-structure#1"},{"pos":[29566,29822],"content":"To manage task handles for cases where you have a variable number of tasks, use a stack-allocation routine such as <bpt id=\"p1\">[</bpt>_malloca<ept id=\"p1\">](../../c-runtime-library/reference/malloca.md)</ept> or a container class, such as std::<bpt id=\"p2\">[</bpt>vector<ept id=\"p2\">](../../standard-library/vector-class.md)</ept>.","source":"To manage task handles for cases where you have a variable number of tasks, use a stack-allocation routine such as [_malloca](../../c-runtime-library/reference/malloca.md) or a container class, such as std::[vector](../../standard-library/vector-class.md)."},{"content":"Both <ph id=\"ph1\">`task_group`</ph> and <ph id=\"ph2\">`structured_task_group`</ph> support cancellation.","pos":[29829,29896],"source":"Both `task_group` and `structured_task_group` support cancellation."},{"content":"For more information about cancellation, see <bpt id=\"p1\">[</bpt>Cancellation in the PPL<ept id=\"p1\">](cancellation-in-the-ppl.md)</ept>.","pos":[29897,29996],"source":" For more information about cancellation, see [Cancellation in the PPL](cancellation-in-the-ppl.md)."},{"pos":[30029,30036],"content":"Example"},{"content":"The following basic example shows how to work with task groups.","pos":[30040,30103]},{"content":"This example uses the <ph id=\"ph1\">`parallel_invoke`</ph> algorithm to perform two tasks concurrently.","pos":[30104,30188],"source":" This example uses the `parallel_invoke` algorithm to perform two tasks concurrently."},{"content":"Each task adds sub-tasks to a <ph id=\"ph1\">`task_group`</ph> object.","pos":[30189,30239],"source":" Each task adds sub-tasks to a `task_group` object."},{"content":"Note that the <ph id=\"ph1\">`task_group`</ph> class allows for multiple tasks to add tasks to it concurrently.","pos":[30240,30331],"source":" Note that the `task_group` class allows for multiple tasks to add tasks to it concurrently."},{"pos":[30349,30375],"content":"concrt-using-task-groups#1"},{"content":"The following is sample output for this example:","pos":[30467,30515]},{"pos":[30620,30729],"content":"Because the <ph id=\"ph1\">`parallel_invoke`</ph> algorithm runs tasks concurrently, the order of the output messages could vary.","source":"Because the `parallel_invoke` algorithm runs tasks concurrently, the order of the output messages could vary."},{"content":"For complete examples that show how to use the <ph id=\"ph1\">`parallel_invoke`</ph> algorithm, see <bpt id=\"p1\">[</bpt>How to: Use parallel_invoke to Write a Parallel Sort Routine<ept id=\"p1\">](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)</ept> and <bpt id=\"p2\">[</bpt>How to: Use parallel_invoke to Execute Parallel Operations<ept id=\"p2\">](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)</ept>.","pos":[30736,31114],"source":"For complete examples that show how to use the `parallel_invoke` algorithm, see [How to: Use parallel_invoke to Write a Parallel Sort Routine](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md) and [How to: Use parallel_invoke to Execute Parallel Operations](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)."},{"content":"For a complete example that uses the <ph id=\"ph1\">`task_group`</ph> class to implement asynchronous futures, see <bpt id=\"p1\">[</bpt>Walkthrough: Implementing Futures<ept id=\"p1\">](../../parallel/concrt/walkthrough-implementing-futures.md)</ept>.","pos":[31115,31305],"source":" For a complete example that uses the `task_group` class to implement asynchronous futures, see [Walkthrough: Implementing Futures](../../parallel/concrt/walkthrough-implementing-futures.md)."},{"pos":[31337,31355],"content":"Robust Programming"},{"content":"Make sure that you understand the role of cancellation and exception handling when you use tasks, task groups, and parallel algorithms.","pos":[31359,31494]},{"content":"For example, in a tree of parallel work, a task that is canceled prevents child tasks from running.","pos":[31495,31594]},{"content":"This can cause problems if one of the child tasks performs an operation that is important to your application, such as freeing a resource.","pos":[31595,31733]},{"content":"In addition, if a child task throws an exception, that exception could propagate through an object destructor and cause undefined behavior in your application.","pos":[31734,31893]},{"content":"For an example that illustrates these points, see the <bpt id=\"p1\">[</bpt>Understand how Cancellation and Exception Handling Affect Object Destruction<ept id=\"p1\">](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction)</ept> section in the Best Practices in the Parallel Patterns Library document.","pos":[31894,32192],"source":" For an example that illustrates these points, see the [Understand how Cancellation and Exception Handling Affect Object Destruction](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) section in the Best Practices in the Parallel Patterns Library document."},{"content":"For more information about the cancellation and exception-handling models in the PPL, see <bpt id=\"p1\">[</bpt>Cancellation<ept id=\"p1\">](../../parallel/concrt/cancellation-in-the-ppl.md)</ept> and <bpt id=\"p2\">[</bpt>Exception Handling<ept id=\"p2\">](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)</ept>.","pos":[32193,32445],"source":" For more information about the cancellation and exception-handling models in the PPL, see [Cancellation](../../parallel/concrt/cancellation-in-the-ppl.md) and [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)."},{"content":"Related Topics","pos":[32454,32468]},{"content":"Title","pos":[32475,32480]},{"content":"Description","pos":[32481,32492]},{"content":"How to: Use parallel_invoke to Write a Parallel Sort Routine","pos":[32532,32592]},{"pos":[32680,32786],"content":"Shows how to use the <ph id=\"ph1\">`parallel_invoke`</ph> algorithm to improve the performance of the bitonic sort algorithm.","source":"Shows how to use the `parallel_invoke` algorithm to improve the performance of the bitonic sort algorithm."},{"content":"How to: Use parallel_invoke to Execute Parallel Operations","pos":[32792,32850]},{"pos":[32936,33083],"content":"Shows how to use the <ph id=\"ph1\">`parallel_invoke`</ph> algorithm to improve the performance of a program that performs multiple operations on a shared data source.","source":"Shows how to use the `parallel_invoke` algorithm to improve the performance of a program that performs multiple operations on a shared data source."},{"content":"How to: Create a Task that Completes After a Delay","pos":[33089,33139]},{"pos":[33217,33379],"content":"Shows how to use the <ph id=\"ph1\">`task`</ph>, <ph id=\"ph2\">`cancellation_token_source`</ph>, <ph id=\"ph3\">`cancellation_token`</ph>, and <ph id=\"ph4\">`task_completion_event`</ph> classes to create a task that completes after a delay.","source":"Shows how to use the `task`, `cancellation_token_source`, `cancellation_token`, and `task_completion_event` classes to create a task that completes after a delay."},{"content":"Walkthrough: Implementing Futures","pos":[33385,33418]},{"content":"Shows how to combine existing functionality in the Concurrency Runtime into something that does more.","pos":[33479,33580]},{"content":"Parallel Patterns Library (PPL)","pos":[33586,33617]},{"content":"Describes the PPL, which provides an imperative programming model for developing concurrent applications.","pos":[33675,33780]},{"content":"Reference","pos":[33790,33799]},{"content":"task Class (Concurrency Runtime)","pos":[33804,33836]},{"content":"task_completion_event Class","pos":[33892,33919]},{"content":"when_all Function","pos":[33990,34007]},{"content":"when_any Function","pos":[34071,34088]},{"content":"task_group Class","pos":[34152,34168]},{"content":"parallel_invoke Function","pos":[34208,34232]},{"content":"structured_task_group Class","pos":[34303,34330]}],"content":"---\ntitle: \"Task Parallelism (Concurrency Runtime) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"structured task groups [Concurrency Runtime]\"\n  - \"structured tasks [Concurrency Runtime]\"\n  - \"task groups [Concurrency Runtime]\"\n  - \"task parallelism\"\n  - \"tasks [Concurrency Runtime]\"\nms.assetid: 42f05ac3-2098-494a-ba84-737fcdcad077\ncaps.latest.revision: 56\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Task Parallelism (Concurrency Runtime)\nIn the Concurrency Runtime, a *task* is a unit of work that performs a specific job and typically runs in parallel with other tasks. A task can be decomposed into additional, more fine-grained tasks that are organized into a *task group*.  \n  \n You use tasks when you write asynchronous code and want some operation to occur after the asynchronous operation completes. For example, you could use a task to asynchronously read from a file and then use another task—a *continuation task*, which is explained later in this document—to process the data after it becomes available. Conversely, you can use tasks groups to decompose parallel work into smaller pieces. For example, suppose you have a recursive algorithm that divides the remaining work into two partitions. You can use task groups to run these partitions concurrently, and then wait for the divided work to complete.  \n  \n> [!TIP]\n\n>  When you want to apply the same routine to every element of a collection in parallel, use a parallel algorithm, such as [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for), instead of a task or task group. For more information about parallel algorithms, see [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md).  \n\n  \n## Key Points  \n  \n-   When you pass variables to a lambda expression by reference, you must guarantee that the lifetime of that variable persists until the task finishes.  \n  \n-   Use tasks (the [concurrency::task](../../parallel/concrt/reference/task-class.md) class) when you write asynchronous code. The task class uses the Windows ThreadPool as its scheduler, not the Concurrency Runtime.  \n  \n-   Use task groups (the [concurrency::task_group](reference/task-group-class.md) class or the [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) algorithm) when you want to decompose parallel work into smaller pieces and then wait for those smaller pieces to complete.  \n  \n-   Use the [concurrency::task::then](reference/task-class.md#then) method to create continuations. A *continuation* is a task that runs asynchronously after another task completes. You can connect any number of continuations to form a chain of asynchronous work.  \n  \n-   A task-based continuation is always scheduled for execution when the antecedent task finishes, even when the antecedent task is canceled or throws an exception.  \n  \n-   Use [concurrency:: HYPERLINK \"http://msdn.microsoft.com/library/system.threading.tasks.task.whenall(v=VS.110).aspx\" when_all](reference/concurrency-namespace-functions.md#when_all) to create a task that completes after every member of a set of tasks completes. Use [concurrency::when_any](reference/concurrency-namespace-functions.md#when_all) to create a task that completes after one member of a set of tasks completes.  \n\n  \n-   Tasks and task groups can participate in the Parallel Patterns Library (PPL) cancellation mechanism. For more information, see [Cancellation in the PPL](cancellation-in-the-ppl.md).  \n  \n-   To learn how the runtime handles exceptions that are thrown by tasks and task groups, see [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).  \n  \n## In this Document  \n  \n- [Using Lambda Expressions](#lambdas)  \n  \n- [The task Class](#task-class)  \n  \n- [Continuation Tasks](#continuations)  \n  \n- [Value-Based Versus Task-Based Continuations](#value-versus-task)  \n  \n- [Composing Tasks](#composing-tasks)  \n  \n    - [The when_all Function](#when-all)  \n  \n    - [The when_any Function](#when-any)  \n  \n- [Delayed Task Execution](#delayed-tasks)  \n  \n- [Task Groups](#task-groups)  \n  \n- [Comparing task_group to structured_task_group](#comparing-groups)  \n  \n- [Example](#example)  \n  \n- [Robust Programming](#robust)  \n  \n##  <a name=\"lambdas\"></a> Using Lambda Expressions  \n Because of their succinct syntax, lambda expressions are a common way to define the work that is performed by tasks and task groups. Here are some usage tips:  \n  \n-   Because tasks typically run on background threads, be aware of the object lifetime when you capture variables in lambda expressions. When you capture a variable by value, a copy of that variable is made in the lambda body. When you capture by reference, a copy is not made. Therefore, ensure that the lifetime of any variable that you capture by reference outlives the task that uses it.  \n  \n-   When you pass a lambda expression to a task, don’t capture variables that are allocated on the stack by reference.  \n  \n-   Be explicit about the variables you capture in lambda expressions so   that you can identify what you’re capturing by value versus by reference. For this reason we recommend that you do not use the `[=]` or `[&]` options for lambda expressions.  \n  \n A common pattern is when one task in a continuation chain assigns to a variable, and another task reads that variable. You can’t capture by value because each continuation task would hold a different copy of the variable. For stack-allocated variables, you also can’t capture by reference because the variable may no longer be valid.  \n  \n To solve this problem, use a smart pointer, such as [std::shared_ptr](../../standard-library/shared-ptr-class.md), to wrap the variable and pass the smart pointer by value. In this way, the underlying object can be assigned to and read from, and will outlive the tasks that use it. Use this technique even when the variable is a pointer or a reference-counted handle (`^`) to a Windows Runtime object. Here’s a basic example:  \n  \n [!code-cpp[concrt-lambda-task-lifetime#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_1.cpp)]  \n  \n For more information about lambda expressions, see [Lambda Expressions](../../cpp/lambda-expressions-in-cpp.md).  \n  \n##  <a name=\"task-class\"></a> The task Class  \n You can use the [concurrency::task](../../parallel/concrt/reference/task-class.md) class to compose tasks into a set of dependent operations. This composition model is supported by the notion of *continuations*. A continuation enables code to be executed when the previous, or *antecedent*, task completes. The result of the antecedent task is passed as the input to the one or more continuation tasks. When an antecedent task completes, any continuation tasks that are waiting on it are scheduled for execution. Each continuation task receives a copy of the result of the antecedent task. In turn, those continuation tasks may also be antecedent tasks for other continuations, thereby creating a chain of tasks. Continuations help you create arbitrary-length chains of tasks that have specific dependencies among them. In addition, a task can participate in cancellation either before a tasks starts or in a cooperative manner while it is running. For more information about this cancellation model, see [Cancellation in the PPL](cancellation-in-the-ppl.md).  \n  \n `task` is a template class. The type parameter `T` is the type of the result that is produced by the task. This type can be `void` if the task does not return a value. `T` cannot use the `const` modifier.  \n  \n\n<<<<<<< HEAD\n When you create a task, you provide a *work function* that performs the task body. This work function comes in the form of a lambda function, function pointer, or function object. To wait for a task to finish without obtaining the result, call the [concurrency::task::wait](reference/task-class.md#wait) method. The `task::wait` method returns a [concurrency::task_status](reference/concurrency-namespace-enums.md#task_group_status) value that describes whether the task was completed or canceled. To get the result of the task, call the [concurrency::task::get](reference/task-class.md#get) method. This method calls `task::wait` to wait for the task to finish, and therefore blocks execution of the current thread until the result is available.  \n\n\n  \n The following example shows how to create a task, wait for its result, and display its value. The examples in this documentation use lambda functions because they provide a more succinct syntax. However, you can also use function pointers and function objects when you use tasks.  \n  \n [!code-cpp[concrt-basic-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_2.cpp)]  \n  \n\n When you use the [concurrency::create_task](reference/concurrency-namespace-functions.md#create_task) function, you can use the `auto` keyword instead of declaring the type. For example, consider this code that creates and prints the identity matrix:  \n\n  \n [!code-cpp[concrt-create-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_3.cpp)]  \n  \n You can use the `create_task` function to create the equivalent operation.  \n  \n [!code-cpp[concrt-create-task#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_4.cpp)]  \n  \n If an exception is thrown during the execution of a task, the runtime marshals that exception in the subsequent call to `task::get` or `task::wait`, or to a task-based continuation. For more information about the task exception-handling mechanism, see [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).  \n  \n For an example that uses `task`, [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md), cancellation, see [Walkthrough: Connecting Using Tasks and XML HTTP Requests](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md). (The `task_completion_event` class is described later in this document.)  \n  \n> [!TIP]\n>  To learn details that are specific to tasks in [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] apps, see [Asynchronous programming in C++](http://msdn.microsoft.com/en-us/512700b7-7863-44cc-93a2-366938052f31) and [Creating Asynchronous Operations in C++ for Windows Store Apps](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md).  \n  \n##  <a name=\"continuations\"></a> Continuation Tasks  \n In asynchronous programming, it is very common for one asynchronous operation, on completion, to invoke a second operation and pass data to it. Traditionally, this is done by using callback methods. In the Concurrency Runtime, the same functionality is provided by *continuation tasks*. A continuation task (also known just as a continuation) is an asynchronous task that is invoked by another task, which is known as the *antecedent*, when the antecedent completes. By using continuations, you can:  \n  \n-   Pass data from the antecedent to the continuation.  \n  \n-   Specify the precise conditions under which the continuation is invoked or not invoked.  \n  \n-   Cancel a continuation either before it starts or cooperatively while it is running.  \n  \n-   Provide hints about how the continuation should be scheduled. (This applies to [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] apps only. For more information, see [Creating Asynchronous Operations in C++ for Windows Store Apps](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md).)  \n  \n-   Invoke multiple continuations from the same antecedent.  \n  \n-   Invoke one continuation when all or any of multiple antecedents complete.  \n  \n-   Chain continuations one after another to any length.  \n  \n-   Use a continuation to handle exceptions that are thrown by the antecedent.  \n  \n These features enable you to execute one or more tasks when the first task completes. For example, you can create a continuation that compresses a file after the first task reads it from disk.  \n  \n\n\n The following example modifies the previous one to use the [concurrency::task::then](reference/task-class.md#then) method to schedule a continuation that prints the value of the antecedent task when it is available.  \n\n\n  \n [!code-cpp[concrt-basic-continuation#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_5.cpp)]  \n  \n You can chain and nest tasks to any length. A task can also have multiple continuations. The following example illustrates a basic continuation chain that increments the value of the previous task three times.  \n  \n [!code-cpp[concrt-continuation-chain#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_6.cpp)]  \n  \n A continuation can also return another task. If there is no cancellation, then this task is executed before the subsequent continuation. This technique is known as *asynchronous unwrapping*. Asynchronous unwrapping is useful when you want to perform additional work in the background, but do not want the current task to block the current thread. (This is common in [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] apps, where continuations can run on the UI thread). The following example shows three tasks. The first task returns another task that is run before a continuation task.  \n  \n [!code-cpp[concrt-async-unwrapping#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_7.cpp)]  \n  \n> [!IMPORTANT]\n>  When a continuation of a task returns a nested task of type `N`, the resulting task has the type `N`, not `task<N>`, and completes when the nested task completes. In other words, the continuation performs the unwrapping of the nested task.  \n  \n##  <a name=\"value-versus-task\"></a> Value-Based Versus Task-Based Continuations  \n Given a `task` object whose return type is `T`, you can provide a value of type `T` or `task<T>` to its continuation tasks. A continuation that takes type `T` is known as a *value-based continuation*. A value-based continuation is scheduled for execution when the antecedent task completes without error and is not canceled. A continuation that takes type `task<T>` as its parameter is known as a *task-based continuation*. A task-based continuation is always scheduled for execution when the antecedent task finishes, even when the antecedent task is canceled or throws an exception. You can then call `task::get` to get the result of the antecedent task. If the antecedent task was canceled, `task::get` throws [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md). If the antecedent task threw an exception, `task::get` rethrows that exception. A task-based continuation is not marked as canceled when its antecedent task is canceled.  \n  \n##  <a name=\"composing-tasks\"></a> Composing Tasks  \n This section describes the [concurrency::when_all](reference/concurrency-namespace-functions.md#when_all) and [concurrency::when_any](reference/concurrency-namespace-functions.md#when_all) functions, which can help you compose multiple tasks to implement common patterns.  \n\n  \n###  <a name=\"when-all\"></a> The when_all Function  \n The `when_all` function produces a task that completes after a set of tasks complete. This function returns a std::[vector](../../standard-library/vector-class.md) object that contains the result of each task in the set. The following basic example uses `when_all` to create a task that represents the completion of three other tasks.  \n  \n [!code-cpp[concrt-join-tasks#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_8.cpp)]  \n  \n> [!NOTE]\n>  The tasks that you pass to `when_all` must be uniform. In other words, they must all return the same type.  \n  \n You can also use the `&&` syntax to produce a task that completes after a set of tasks complete, as shown in the following example.  \n  \n `auto t = t1 && t2; // same as when_all`  \n  \n It is common to use a continuation together with `when_all` to perform an action after a set of tasks finishes. The following example modifies the previous one to print the sum of three tasks that each produce an `int` result.  \n  \n [!code-cpp[concrt-join-tasks#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_9.cpp)]  \n  \n In this example, you can also specify`task<vector<int>>` to produce a task-based continuation.  \n  \n If any task in a set of tasks is canceled or throws an exception, `when_all` immediately completes and does not wait for the remaining tasks to finish. If an exception is thrown, the runtime rethrows the exception when you call `task::get` or `task::wait` on the task object that `when_all` returns. If more than one task throws, the runtime chooses one of them. Therefore, ensure that you observe all exceptions after all tasks complete; an unhandled task exception causes the app to terminate.  \n  \n Here’s a utility function that you can use to ensure that your program observes all exceptions. For each task in the provided range, `observe_all_exceptions` triggers any exception that occurred to be rethrown and then swallows that exception.  \n  \n [!code-cpp[concrt-eh-when_all#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_10.cpp)]  \n  \n Consider a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app that uses C++ and XAML and writes a set of files to disk. The following example shows how to use `when_all` and `observe_all_exceptions` to ensure that the program observes all exceptions.  \n  \n [!code-cpp[concrt-eh-when_all#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_11.cpp)]  \n  \n##### To run this example  \n  \n1.  In MainPage.xaml, add a `Button` control.  \n  \n [!code-xml[concrt-eh-when_all#3](../../parallel/concrt/codesnippet/xaml/task-parallelism-concurrency-runtime_12.xaml)]  \n  \n2.  In MainPage.xaml.h, add these forward declarations to the `private` section of the `MainPage` class declaration.  \n  \n [!code-cpp[concrt-eh-when_all#4](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_13.h)]  \n  \n3.  In MainPage.xaml.cpp, implement the `Button_Click` event handler.  \n  \n [!code-cpp[concrt-eh-when_all#5](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_14.cpp)]  \n  \n4.  In MainPage.xaml.cpp, implement `WriteFilesAsync` as shown in the example.  \n  \n> [!TIP]\n\n> `when_all` is a non-blocking function that produces a `task` as its result. Unlike [task::wait](reference/task-class.md#wait), it is safe to call this function in a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app on the ASTA (Application STA) thread.  \n\n  \n###  <a name=\"when-any\"></a> The when_any Function  \n The `when_any` function produces a task that completes when the first task in a set of tasks completes. This function returns a [std::pair](../../standard-library/pair-structure.md) object that contains the result of the completed task and the index of that task in the set.  \n  \n The `when_any` function is especially useful in the following scenarios:  \n  \n-   Redundant operations. Consider an algorithm or operation that can be performed in many ways. You can use the `when_any` function to select the operation that finishes first and then cancel the remaining operations.  \n  \n-   Interleaved operations. You can start multiple operations that all must finish and use the `when_any` function to process results as each operation finishes. After one operation finishes, you can start one or more additional tasks.  \n  \n-   Throttled operations. You can use the `when_any` function to extend the previous scenario by limiting the number of concurrent operations.  \n  \n-   Expired operations. You can use the `when_any` function to select between one or more tasks and a task that finishes after a specific time.  \n  \n As with `when_all`, it is common to use a continuation that has `when_any` to perform action when the first in a set of tasks finish. The following basic example uses `when_any` to create a task that completes when the first of three other tasks completes.  \n  \n [!code-cpp[concrt-select-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_15.cpp)]  \n  \n In this example, you can also specify `task<pair<int, size_t>>` to produce a task-based continuation.  \n  \n> [!NOTE]\n>  As with `when_all`, the tasks that you pass to `when_any` must all return the same type.  \n  \n You can also use the `||` syntax to produce a task that completes after the first task in a set of tasks completes, as shown in the following example.  \n  \n `auto t = t1 || t2; // same as when_any`  \n  \n> [!TIP]\n>  As with `when_all`, `when_any` is non-blocking and is safe to call in a [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] app on the ASTA thread.  \n  \n##  <a name=\"delayed-tasks\"></a> Delayed Task Execution  \n It is sometimes necessary to delay the execution of a task until a condition is satisfied, or to start a task in response to an external event. For example, in asynchronous programming, you might have to start a task in response to an I/O completion event.  \n  \n Two ways to accomplish this are to use a continuation or to start a task and wait on an event inside the task’s work function. However, there are cases where is it not possible to use one of these techniques. For example, to create a continuation, you must have the antecedent task. However, if you do not have the antecedent task, you can create a *task completion event* and later chain that completion event to the antecedent task when it becomes available. In addition, because a waiting task also blocks a thread, you can use task completion events to perform work when an asynchronous operation completes, and thereby free a thread.  \n  \n The [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) class helps simplify such composition of tasks. Like the `task` class, the type parameter `T` is the type of the result that is produced by the task. This type can be `void` if the task does not return a value. `T` cannot use the `const` modifier. Typically, a `task_completion_event` object is provided to a thread or task that will signal it when the value for it becomes available. At the same time, one or more tasks are set as listeners of that event. When the event is set, the listener tasks complete and their continuations are scheduled to run.  \n  \n For an example that uses `task_completion_event` to implement a task that completes after a delay, see [How to: Create a Task that Completes After a Delay](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md).  \n  \n##  <a name=\"task-groups\"></a> Task Groups  \n A *task group* organizes a collection of tasks. Task groups push tasks on to a work-stealing queue. The scheduler removes tasks from this queue and executes them on available computing resources. After you add tasks to a task group, you can wait for all tasks to finish or cancel tasks that have not yet started.  \n  \n The PPL uses the [concurrency::task_group](reference/task-group-class.md) and [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) classes to represent task groups, and the [concurrency::task_handle](../../parallel/concrt/reference/task-handle-class.md) class to represent the tasks that run in these groups. The `task_handle` class encapsulates the code that performs work. Like the `task` class, the work function comes in the form of a lambda function, function pointer, or function object. You typically do not need to work with `task_handle` objects directly. Instead, you pass work functions to a task group, and the task group creates and manages the `task_handle` objects.  \n  \n The PPL divides task groups into these two categories: *unstructured task groups* and *structured task groups*. The PPL uses the `task_group` class to represent unstructured task groups and the `structured_task_group` class to represent structured task groups.  \n  \n> [!IMPORTANT]\n\n>  The PPL also defines the [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) algorithm, which uses the `structured_task_group` class to execute a set of tasks in parallel. Because the `parallel_invoke` algorithm has a more succinct syntax, we recommend that you use it instead of the `structured_task_group` class when you can. The topic [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md) describes `parallel_invoke` in greater detail.  \n  \n Use `parallel_invoke` when you have several independent tasks that you want to execute at the same time, and you must wait for all tasks to finish before you continue. This technique is often referred to as *fork and join* parallelism. Use `task_group` when you have several independent tasks that you want to execute at the same time, but you want to wait for the tasks to finish at a later time. For example, you can add tasks to a `task_group` object and wait for the tasks to finish in another function or from another thread.  \n  \n Task groups support the concept of cancellation. Cancellation enables you to signal to all active tasks that you want to cancel the overall operation. Cancellation also prevents tasks that have not yet started from starting. For more information about cancellation, see [Cancellation in the PPL](cancellation-in-the-ppl.md).  \n  \n The runtime also provides an exception-handling model that enables you to throw an exception from a task and handle that exception when you wait for the associated task group to finish. For more information about this exception-handling model, see [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).  \n  \n##  <a name=\"comparing-groups\"></a> Comparing task_group to structured_task_group  \n Although we recommend that you use `task_group` or `parallel_invoke` instead of the `structured_task_group` class, there are cases where you want to use `structured_task_group`, for example, when you write a parallel algorithm that performs a variable number of tasks or requires support for cancellation. This section explains the differences between the `task_group` and `structured_task_group` classes.  \n  \n The `task_group` class is thread-safe. Therefore you can add tasks to a `task_group` object from multiple threads and wait on or cancel a `task_group` object from multiple threads. The construction and destruction of a `structured_task_group` object must occur in the same lexical scope. In addition, all operations on a `structured_task_group` object must occur on the same thread. The exception to this rule is the [concurrency::structured_task_group::cancel](reference/structured-task-group-class.md#cancel) and [concurrency::structured_task_group::is_canceling](reference/structured-task-group-class.md#is_canceling) methods. A child task can call these methods to cancel the parent task group or check for cancelation at any time.  \n  \n You can run additional tasks on a `task_group` object after you call the [concurrency::task_group::wait](reference/task-group-class.md#wait) or [concurrency::task_group::run_and_wait](reference/task-group-class.md#run_and_wait) method. Conversely, if you run additional tasks on a `structured_task_group` object after you call the [concurrency::structured_task_group::wait](reference/structured-task-group-class.md#wait) or [concurrency::structured_task_group::run_and_wait](reference/structured-task-group-class.md#run_and_wait) methods, then the behavior is undefined.  \n  \n Because the `structured_task_group` class does not synchronize across threads, it has less execution overhead than the `task_group` class. Therefore, if your problem does not require that you schedule work from multiple threads and you cannot use the `parallel_invoke` algorithm, the `structured_task_group` class can help you write better performing code.  \n  \n If you use one `structured_task_group` object inside another `structured_task_group` object, the inner object must finish and be destroyed before the outer object finishes. The `task_group` class does not require for nested task groups to finish before the outer group finishes.  \n  \n Unstructured task groups and structured task groups work with task handles in different ways. You can pass work functions directly to a `task_group` object; the `task_group` object will create and manage the task handle for you. The `structured_task_group` class requires you to manage a `task_handle` object for each task. Every `task_handle` object must remain valid throughout the lifetime of its associated `structured_task_group` object. Use the [concurrency::make_task](reference/concurrency-namespace-functions.md#make_task) function to create a `task_handle` object, as shown in the following basic example:  \n  \n [!code-cpp[concrt-make-task-structure#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_16.cpp)]  \n  \n To manage task handles for cases where you have a variable number of tasks, use a stack-allocation routine such as [_malloca](../../c-runtime-library/reference/malloca.md) or a container class, such as std::[vector](../../standard-library/vector-class.md).  \n  \n Both `task_group` and `structured_task_group` support cancellation. For more information about cancellation, see [Cancellation in the PPL](cancellation-in-the-ppl.md).  \n  \n##  <a name=\"example\"></a> Example  \n The following basic example shows how to work with task groups. This example uses the `parallel_invoke` algorithm to perform two tasks concurrently. Each task adds sub-tasks to a `task_group` object. Note that the `task_group` class allows for multiple tasks to add tasks to it concurrently.  \n  \n [!code-cpp[concrt-using-task-groups#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_17.cpp)]  \n  \n The following is sample output for this example:  \n  \n```Output  \nMessage from task: Hello  \nMessage from task: 3.14  \nMessage from task: 42  \n```  \n  \n Because the `parallel_invoke` algorithm runs tasks concurrently, the order of the output messages could vary.  \n  \n For complete examples that show how to use the `parallel_invoke` algorithm, see [How to: Use parallel_invoke to Write a Parallel Sort Routine](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md) and [How to: Use parallel_invoke to Execute Parallel Operations](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md). For a complete example that uses the `task_group` class to implement asynchronous futures, see [Walkthrough: Implementing Futures](../../parallel/concrt/walkthrough-implementing-futures.md).  \n  \n##  <a name=\"robust\"></a> Robust Programming  \n Make sure that you understand the role of cancellation and exception handling when you use tasks, task groups, and parallel algorithms. For example, in a tree of parallel work, a task that is canceled prevents child tasks from running. This can cause problems if one of the child tasks performs an operation that is important to your application, such as freeing a resource. In addition, if a child task throws an exception, that exception could propagate through an object destructor and cause undefined behavior in your application. For an example that illustrates these points, see the [Understand how Cancellation and Exception Handling Affect Object Destruction](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) section in the Best Practices in the Parallel Patterns Library document. For more information about the cancellation and exception-handling models in the PPL, see [Cancellation](../../parallel/concrt/cancellation-in-the-ppl.md) and [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).  \n  \n## Related Topics  \n  \n|Title|Description|  \n|-----------|-----------------|  \n|[How to: Use parallel_invoke to Write a Parallel Sort Routine](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)|Shows how to use the `parallel_invoke` algorithm to improve the performance of the bitonic sort algorithm.|  \n|[How to: Use parallel_invoke to Execute Parallel Operations](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)|Shows how to use the `parallel_invoke` algorithm to improve the performance of a program that performs multiple operations on a shared data source.|  \n|[How to: Create a Task that Completes After a Delay](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md)|Shows how to use the `task`, `cancellation_token_source`, `cancellation_token`, and `task_completion_event` classes to create a task that completes after a delay.|  \n|[Walkthrough: Implementing Futures](../../parallel/concrt/walkthrough-implementing-futures.md)|Shows how to combine existing functionality in the Concurrency Runtime into something that does more.|  \n|[Parallel Patterns Library (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)|Describes the PPL, which provides an imperative programming model for developing concurrent applications.|  \n  \n## Reference  \n [task Class (Concurrency Runtime)](../../parallel/concrt/reference/task-class.md)  \n  \n [task_completion_event Class](../../parallel/concrt/reference/task-completion-event-class.md)  \n\n [when_all Function](reference/concurrency-namespace-functions.md#when_all)  \n  \n [when_any Function](reference/concurrency-namespace-functions.md#when_any)  \n  \n [task_group Class](reference/task-group-class.md)  \n  \n [parallel_invoke Function](reference/concurrency-namespace-functions.md#parallel_invoke)  \n  \n [structured_task_group Class](../../parallel/concrt/reference/structured-task-group-class.md)\n"}