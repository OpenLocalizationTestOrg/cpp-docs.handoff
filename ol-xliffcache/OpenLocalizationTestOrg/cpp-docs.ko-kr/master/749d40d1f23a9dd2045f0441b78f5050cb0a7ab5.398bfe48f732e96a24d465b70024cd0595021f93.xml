{"nodes":[{"pos":[12,48],"content":"Function Prototypes | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Function Prototypes | Microsoft Docs","pos":[0,36]}]},{"content":"Function Prototypes","pos":[744,763]},{"content":"A function declaration precedes the function definition and specifies the name, return type, storage class, and other attributes of a function.","pos":[764,907]},{"content":"To be a prototype, the function declaration must also establish types and identifiers for the function's arguments.","pos":[908,1023]},{"content":"Syntax","pos":[1032,1038]},{"content":":","pos":[1055,1056]},{"content":"<bpt id=\"p1\"> *</bpt>declaration-specifiers attribute-seq<ept id=\"p1\">*</ept> opt<bpt id=\"p2\">*</bpt>init-declarator-list<ept id=\"p2\">*</ept> opt<bpt id=\"p3\">**</bpt>;<ept id=\"p3\">**</ept>","pos":[1059,1133],"source":" *declaration-specifiers attribute-seq* opt*init-declarator-list* opt**;**"},{"pos":[1144,1188],"content":"<bpt id=\"p1\">*</bpt>attribute-seq<ept id=\"p1\">*</ept> opt is Microsoft Specific */","source":"*attribute-seq* opt is Microsoft Specific */"},{"content":"<bpt id=\"p1\">*</bpt>declaration-specifiers<ept id=\"p1\">*</ept>:","pos":[1195,1220],"source":"*declaration-specifiers*:"},{"content":"<bpt id=\"p1\"> *</bpt>storage-class-specifier declaration-specifiers<ept id=\"p1\">*</ept> opt","pos":[1223,1276],"source":" *storage-class-specifier declaration-specifiers* opt"},{"pos":[1283,1326],"content":"<bpt id=\"p1\">*</bpt>type-specifier declaration-specifiers<ept id=\"p1\">*</ept> opt","source":"*type-specifier declaration-specifiers* opt"},{"pos":[1333,1376],"content":"<bpt id=\"p1\">*</bpt>type-qualifier declaration-specifiers<ept id=\"p1\">*</ept> opt","source":"*type-qualifier declaration-specifiers* opt"},{"content":"<bpt id=\"p1\">*</bpt>init-declarator-list<ept id=\"p1\">*</ept>:","pos":[1383,1406],"source":"*init-declarator-list*:"},{"content":"init-declarator","pos":[1411,1426]},{"pos":[1434,1482],"content":"<bpt id=\"p1\">*</bpt>init-declarator-list<ept id=\"p1\">*</ept>  <bpt id=\"p2\">**</bpt>,<ept id=\"p2\">**</ept>  <bpt id=\"p3\">*</bpt>init-declarator<ept id=\"p3\">*</ept>","source":"*init-declarator-list*  **,**  *init-declarator*"},{"content":"<bpt id=\"p1\">*</bpt>init-declarator<ept id=\"p1\">*</ept>:","pos":[1489,1507],"source":"*init-declarator*:"},{"content":"declarator","pos":[1512,1522]},{"content":"declarator = initializer","pos":[1531,1555]},{"content":":","pos":[1575,1576]},{"content":"<bpt id=\"p1\"> *</bpt>pointer<ept id=\"p1\">*</ept> opt<bpt id=\"p2\">*</bpt>direct-declarator<ept id=\"p2\">*</ept>","pos":[1579,1612],"source":" *pointer* opt*direct-declarator*"},{"content":"<bpt id=\"p1\">*</bpt>direct-declarator<ept id=\"p1\">*</ept>: /<ph id=\"ph1\">\\*</ph> A function declarator","pos":[1619,1665],"source":"*direct-declarator*: /\\* A function declarator "},{"content":"<bpt id=\"p1\"> *</bpt>direct-declarator<ept id=\"p1\">*</ept>  <bpt id=\"p2\">**</bpt>(<ept id=\"p2\">**</ept>  <bpt id=\"p3\">*</bpt>parameter-type-list<ept id=\"p3\">*</ept>  <bpt id=\"p4\">**</bpt>)<ept id=\"p4\">**</ept>  /* New-style declarator","pos":[1672,1754],"source":" *direct-declarator*  **(**  *parameter-type-list*  **)**  /* New-style declarator "},{"pos":[1765,1848],"content":"<bpt id=\"p1\">*</bpt>direct-declarator<ept id=\"p1\">*</ept>  <bpt id=\"p2\">**</bpt>(<ept id=\"p2\">**</ept>  <bpt id=\"p3\">*</bpt>identifier-list<ept id=\"p3\">*</ept> opt<bpt id=\"p4\">**</bpt>)<ept id=\"p4\">**</ept> /* Obsolete-style declarator","source":"*direct-declarator*  **(**  *identifier-list* opt**)** /* Obsolete-style declarator "},{"content":"The prototype has the same form as the function definition, except that it is terminated by a semicolon immediately following the closing parenthesis and therefore has no body.","pos":[1859,2035]},{"content":"In either case, the return type must agree with the return type specified in the function definition.","pos":[2036,2137]},{"content":"Function prototypes have the following important uses:","pos":[2144,2198]},{"content":"They establish the return type for functions that return types other than <ph id=\"ph1\">`int`</ph>.","pos":[2208,2288],"source":"They establish the return type for functions that return types other than `int`."},{"content":"Although functions that return <ph id=\"ph1\">`int`</ph> values do not require prototypes, prototypes are recommended.","pos":[2289,2387],"source":" Although functions that return `int` values do not require prototypes, prototypes are recommended."},{"content":"Without complete prototypes, standard conversions are made, but no attempt is made to check the type or number of arguments with the number of parameters.","pos":[2397,2551]},{"content":"Prototypes are used to initialize pointers to functions before those functions are defined.","pos":[2561,2652]},{"content":"The parameter list is used for checking the correspondence of arguments in the function call with the parameters in the function definition.","pos":[2662,2802]},{"content":"The converted type of each parameter determines the interpretation of the arguments that the function call places on the stack.","pos":[2809,2936]},{"content":"A type mismatch between an argument and a parameter may cause the arguments on the stack to be misinterpreted.","pos":[2937,3047]},{"content":"For example, on a 16-bit computer, if a 16-bit pointer is passed as an argument, then declared as a <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> parameter, the first 32 bits on the stack are interpreted as a <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept> parameter.","pos":[3048,3239],"source":" For example, on a 16-bit computer, if a 16-bit pointer is passed as an argument, then declared as a **long** parameter, the first 32 bits on the stack are interpreted as a **long** parameter."},{"content":"This error creates problems not only with the <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> parameter, but with any parameters that follow it.","pos":[3240,3345],"source":" This error creates problems not only with the **long** parameter, but with any parameters that follow it."},{"content":"You can detect errors of this kind by declaring complete function prototypes for all functions.","pos":[3346,3441]},{"content":"A prototype establishes the attributes of a function so that calls to the function that precede its definition (or occur in other source files) can be checked for argument-type and return-type mismatches.","pos":[3448,3652]},{"content":"For example, if you specify the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> storage-class specifier in a prototype, you must also specify the <bpt id=\"p2\">**</bpt>static<ept id=\"p2\">**</ept> storage class in the function definition.","pos":[3653,3814],"source":" For example, if you specify the **static** storage-class specifier in a prototype, you must also specify the **static** storage class in the function definition."},{"content":"Complete parameter declarations (<ph id=\"ph1\">`int a`</ph>) can be mixed with abstract declarators (<ph id=\"ph2\">`int`</ph>) in the same declaration.","pos":[3821,3934],"source":"Complete parameter declarations (`int a`) can be mixed with abstract declarators (`int`) in the same declaration."},{"content":"For example, the following declaration is legal:","pos":[3935,3983]},{"content":"The prototype can include both the type of, and an identifier for, each expression that is passed as an argument.","pos":[4030,4143]},{"content":"However, such identifiers have scope only until the end of the declaration.","pos":[4144,4219]},{"content":"The prototype can also reflect the fact that the number of arguments is variable, or that no arguments are passed.","pos":[4220,4334]},{"content":"Without such a list, mismatches may not be revealed, so the compiler cannot generate diagnostic messages concerning them.","pos":[4335,4456]},{"content":"See <bpt id=\"p1\">[</bpt>Arguments<ept id=\"p1\">](../c-language/arguments.md)</ept> for more information on type checking.","pos":[4457,4539],"source":" See [Arguments](../c-language/arguments.md) for more information on type checking."},{"content":"Prototype scope in the Microsoft C compiler is now ANSI-compliant when compiling with the /Za compiler option.","pos":[4546,4656]},{"content":"This means that if you declare a <ph id=\"ph1\">`struct`</ph> or <bpt id=\"p1\">**</bpt>union<ept id=\"p1\">**</ept> tag within a prototype, the tag is entered at that scope rather than at global scope.","pos":[4657,4797],"source":" This means that if you declare a `struct` or **union** tag within a prototype, the tag is entered at that scope rather than at global scope."},{"content":"For example, when compiling with /Za for ANSI compliance, you can never call this function without getting a type mismatch error:","pos":[4798,4927]},{"pos":[4977,5089],"content":"To correct your code, define or declare the <ph id=\"ph1\">`struct`</ph> or <bpt id=\"p1\">**</bpt>union<ept id=\"p1\">**</ept> at global scope before the function prototype:","source":"To correct your code, define or declare the `struct` or **union** at global scope before the function prototype:"},{"content":"Under /Ze, the tag is still entered at global scope.","pos":[5151,5203]},{"content":"See Also","pos":[5212,5220]},{"content":"Functions","pos":[5225,5234]}],"content":"---\ntitle: \"Function Prototypes | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"function prototypes\"\n  - \"function return types, function prototypes\"\n  - \"data types [C], function return types\"\n  - \"functions [C], return types\"\n  - \"prototypes [C++], function\"\nms.assetid: d152f8e6-971e-432c-93ca-5a91400653c2\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Function Prototypes\nA function declaration precedes the function definition and specifies the name, return type, storage class, and other attributes of a function. To be a prototype, the function declaration must also establish types and identifiers for the function's arguments.  \n  \n## Syntax  \n `declaration`:  \n *declaration-specifiers attribute-seq* opt*init-declarator-list* opt**;**  \n  \n /\\* *attribute-seq* opt is Microsoft Specific */  \n  \n *declaration-specifiers*:  \n *storage-class-specifier declaration-specifiers* opt  \n  \n *type-specifier declaration-specifiers* opt  \n  \n *type-qualifier declaration-specifiers* opt  \n  \n *init-declarator-list*:  \n *init-declarator*  \n  \n *init-declarator-list*  **,**  *init-declarator*  \n  \n *init-declarator*:  \n *declarator*  \n  \n *declarator = initializer*  \n  \n `declarator`:  \n *pointer* opt*direct-declarator*  \n  \n *direct-declarator*: /\\* A function declarator \\*/  \n *direct-declarator*  **(**  *parameter-type-list*  **)**  /* New-style declarator \\*/  \n  \n *direct-declarator*  **(**  *identifier-list* opt**)** /* Obsolete-style declarator \\*/  \n  \n The prototype has the same form as the function definition, except that it is terminated by a semicolon immediately following the closing parenthesis and therefore has no body. In either case, the return type must agree with the return type specified in the function definition.  \n  \n Function prototypes have the following important uses:  \n  \n-   They establish the return type for functions that return types other than `int`. Although functions that return `int` values do not require prototypes, prototypes are recommended.  \n  \n-   Without complete prototypes, standard conversions are made, but no attempt is made to check the type or number of arguments with the number of parameters.  \n  \n-   Prototypes are used to initialize pointers to functions before those functions are defined.  \n  \n-   The parameter list is used for checking the correspondence of arguments in the function call with the parameters in the function definition.  \n  \n The converted type of each parameter determines the interpretation of the arguments that the function call places on the stack. A type mismatch between an argument and a parameter may cause the arguments on the stack to be misinterpreted. For example, on a 16-bit computer, if a 16-bit pointer is passed as an argument, then declared as a **long** parameter, the first 32 bits on the stack are interpreted as a **long** parameter. This error creates problems not only with the **long** parameter, but with any parameters that follow it. You can detect errors of this kind by declaring complete function prototypes for all functions.  \n  \n A prototype establishes the attributes of a function so that calls to the function that precede its definition (or occur in other source files) can be checked for argument-type and return-type mismatches. For example, if you specify the **static** storage-class specifier in a prototype, you must also specify the **static** storage class in the function definition.  \n  \n Complete parameter declarations (`int a`) can be mixed with abstract declarators (`int`) in the same declaration. For example, the following declaration is legal:  \n  \n```  \nint add( int a, int );  \n```  \n  \n The prototype can include both the type of, and an identifier for, each expression that is passed as an argument. However, such identifiers have scope only until the end of the declaration. The prototype can also reflect the fact that the number of arguments is variable, or that no arguments are passed. Without such a list, mismatches may not be revealed, so the compiler cannot generate diagnostic messages concerning them. See [Arguments](../c-language/arguments.md) for more information on type checking.  \n  \n Prototype scope in the Microsoft C compiler is now ANSI-compliant when compiling with the /Za compiler option. This means that if you declare a `struct` or **union** tag within a prototype, the tag is entered at that scope rather than at global scope. For example, when compiling with /Za for ANSI compliance, you can never call this function without getting a type mismatch error:  \n  \n```  \nvoid func1( struct S * );  \n```  \n  \n To correct your code, define or declare the `struct` or **union** at global scope before the function prototype:  \n  \n```  \nstruct S;  \nvoid func1( struct S * );  \n```  \n  \n Under /Ze, the tag is still entered at global scope.  \n  \n## See Also  \n [Functions](../c-language/functions-c.md)"}