{"nodes":[{"pos":[12,48],"content":"Recursive Functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Recursive Functions | Microsoft Docs","pos":[0,36]}]},{"content":"Recursive Functions","pos":[693,712]},{"content":"Any function in a C program can be called recursively; that is, it can call itself.","pos":[713,796]},{"content":"The number of recursive calls is limited to the size of the stack.","pos":[797,863]},{"content":"See the <bpt id=\"p1\">[</bpt>/STACK (Stack Allocations)<ept id=\"p1\">](../build/reference/stack-stack-allocations.md)</ept> (/STACK) linker option for information about linker options that set stack size.","pos":[864,1028],"source":" See the [/STACK (Stack Allocations)](../build/reference/stack-stack-allocations.md) (/STACK) linker option for information about linker options that set stack size."},{"content":"Each time the function is called, new storage is allocated for the parameters and for the <bpt id=\"p1\">**</bpt>auto<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>register<ept id=\"p2\">**</ept> variables so that their values in previous, unfinished calls are not overwritten.","pos":[1029,1226],"source":" Each time the function is called, new storage is allocated for the parameters and for the **auto** and **register** variables so that their values in previous, unfinished calls are not overwritten."},{"content":"Parameters are only directly accessible to the instance of the function in which they are created.","pos":[1227,1325]},{"content":"Previous parameters are not directly accessible to ensuing instances of the function.","pos":[1326,1411]},{"content":"Note that variables declared with <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> storage do not require new storage with each recursive call.","pos":[1418,1523],"source":"Note that variables declared with **static** storage do not require new storage with each recursive call."},{"content":"Their storage exists for the lifetime of the program.","pos":[1524,1577]},{"content":"Each reference to such a variable accesses the same storage area.","pos":[1578,1643]},{"content":"Example","pos":[1652,1659]},{"content":"This example illustrates recursive calls:","pos":[1663,1704]},{"content":"See Also","pos":[2082,2090]},{"content":"Function Calls","pos":[2095,2109]}],"content":"---\ntitle: \"Recursive Functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"functions [C], recursive\"\n  - \"function calls, recursive\"\n  - \"functions [C], calling recursively\"\n  - \"recursive function calls\"\nms.assetid: 59739040-3081-4006-abbc-9d8423992bce\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Recursive Functions\nAny function in a C program can be called recursively; that is, it can call itself. The number of recursive calls is limited to the size of the stack. See the [/STACK (Stack Allocations)](../build/reference/stack-stack-allocations.md) (/STACK) linker option for information about linker options that set stack size. Each time the function is called, new storage is allocated for the parameters and for the **auto** and **register** variables so that their values in previous, unfinished calls are not overwritten. Parameters are only directly accessible to the instance of the function in which they are created. Previous parameters are not directly accessible to ensuing instances of the function.  \n  \n Note that variables declared with **static** storage do not require new storage with each recursive call. Their storage exists for the lifetime of the program. Each reference to such a variable accesses the same storage area.  \n  \n## Example  \n This example illustrates recursive calls:  \n  \n```  \nint factorial( int num );      /* Function prototype */  \n  \nint main()  \n{  \n    int result, number;  \n    .  \n    .  \n    .  \n    result = factorial( number );  \n}  \n  \nint factorial( int num )      /* Function definition */  \n{  \n    .  \n    .  \n    .  \n    if ( ( num > 0 ) || ( num <= 10 ) )  \n        return( num * factorial( num - 1 ) );  \n}  \n  \n```  \n  \n## See Also  \n [Function Calls](../c-language/function-calls.md)"}