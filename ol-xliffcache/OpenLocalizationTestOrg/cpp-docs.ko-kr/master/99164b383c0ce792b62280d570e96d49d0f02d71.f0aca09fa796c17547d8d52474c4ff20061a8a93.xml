{"nodes":[{"pos":[12,78],"content":"MFC ActiveX Controls: Painting an ActiveX Control | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"MFC ActiveX Controls: Painting an ActiveX Control | Microsoft Docs","pos":[0,66]}]},{"content":"MFC ActiveX Controls: Painting an ActiveX Control","pos":[657,706]},{"content":"This article describes the ActiveX control painting process and how you can alter paint code to optimize the process.","pos":[707,824]},{"content":"(See <bpt id=\"p1\">[</bpt>Optimizing Control Drawing<ept id=\"p1\">](../mfc/optimizing-control-drawing.md)</ept> for techniques on how to optimize drawing by not having controls individually restore previously selected GDI objects.","pos":[825,1015],"source":" (See [Optimizing Control Drawing](../mfc/optimizing-control-drawing.md) for techniques on how to optimize drawing by not having controls individually restore previously selected GDI objects."},{"content":"After all of the controls have been drawn, the container can automatically restore the original objects.)","pos":[1016,1121]},{"content":"Examples in this article are from a control created by the MFC ActiveX Control Wizard with default settings.","pos":[1128,1236]},{"content":"For more information on creating a skeleton control application using the MFC ActiveX Control Wizard, see the article <bpt id=\"p1\">[</bpt>MFC ActiveX Control Wizard<ept id=\"p1\">](../mfc/reference/mfc-activex-control-wizard.md)</ept>.","pos":[1237,1432],"source":" For more information on creating a skeleton control application using the MFC ActiveX Control Wizard, see the article [MFC ActiveX Control Wizard](../mfc/reference/mfc-activex-control-wizard.md)."},{"content":"The following topics are covered:","pos":[1439,1472]},{"content":"The overall process for painting a control and the code created by the ActiveX Control Wizard to support painting","pos":[1483,1596]},{"content":"How to optimize the painting process","pos":[1659,1695]},{"content":"How to paint your control using metafiles","pos":[1742,1783]},{"pos":[1904,1946],"content":"The Painting Process of an ActiveX Control"},{"content":"When ActiveX controls are initially displayed or are redrawn, they follow a painting process similar to other applications developed using MFC, with one important distinction: ActiveX controls can be in an active or an inactive state.","pos":[1950,2184]},{"content":"An active control is represented in an ActiveX control container by a child window.","pos":[2191,2274]},{"content":"Like other windows, it is responsible for painting itself when a <ph id=\"ph1\">`WM_PAINT`</ph> message is received.","pos":[2275,2371],"source":" Like other windows, it is responsible for painting itself when a `WM_PAINT` message is received."},{"content":"The control's base class, <bpt id=\"p1\">[</bpt>COleControl<ept id=\"p1\">](../mfc/reference/colecontrol-class.md)</ept>, handles this message in its <ph id=\"ph1\">`OnPaint`</ph> function.","pos":[2372,2499],"source":" The control's base class, [COleControl](../mfc/reference/colecontrol-class.md), handles this message in its `OnPaint` function."},{"content":"This default implementation calls the <ph id=\"ph1\">`OnDraw`</ph> function of your control.","pos":[2500,2572],"source":" This default implementation calls the `OnDraw` function of your control."},{"content":"An inactive control is painted differently.","pos":[2579,2622]},{"content":"When the control is inactive, its window is either invisible or nonexistent, so it can not receive a paint message.","pos":[2623,2738]},{"content":"Instead, the control container directly calls the <ph id=\"ph1\">`OnDraw`</ph> function of the control.","pos":[2739,2822],"source":" Instead, the control container directly calls the `OnDraw` function of the control."},{"content":"This differs from an active control's painting process in that the <ph id=\"ph1\">`OnPaint`</ph> member function is never called.","pos":[2823,2932],"source":" This differs from an active control's painting process in that the `OnPaint` member function is never called."},{"content":"As discussed in the preceding paragraphs, how an ActiveX control is updated depends on the state of the control.","pos":[2939,3051]},{"content":"However, because the framework calls the <ph id=\"ph1\">`OnDraw`</ph> member function in both cases, you add the majority of your painting code in this member function.","pos":[3052,3200],"source":" However, because the framework calls the `OnDraw` member function in both cases, you add the majority of your painting code in this member function."},{"content":"The <ph id=\"ph1\">`OnDraw`</ph> member function handles control painting.","pos":[3207,3261],"source":"The `OnDraw` member function handles control painting."},{"content":"When a control is inactive, the control container calls <ph id=\"ph1\">`OnDraw`</ph>, passing the device context of the control container and the coordinates of the rectangular area occupied by the control.","pos":[3262,3448],"source":" When a control is inactive, the control container calls `OnDraw`, passing the device context of the control container and the coordinates of the rectangular area occupied by the control."},{"content":"The rectangle passed by the framework to the <ph id=\"ph1\">`OnDraw`</ph> member function contains the area occupied by the control.","pos":[3455,3567],"source":"The rectangle passed by the framework to the `OnDraw` member function contains the area occupied by the control."},{"content":"If the control is active, the upper-left corner is (0, 0) and the device context passed is for the child window that contains the control.","pos":[3568,3706]},{"content":"If the control is inactive, the upper-left coordinate is not necessarily (0, 0) and the device context passed is for the control container containing the control.","pos":[3707,3869]},{"pos":[3877,4145],"content":"[!NOTE]\n It is important that your modifications to `OnDraw` do not depend on the rectangle's upper left point being equal to (0, 0) and that you draw only inside the rectangle passed to `OnDraw`. Unexpected results can occur if you draw beyond the rectangle's area.","leadings":["","> "],"nodes":[{"content":" It is important that your modifications to `OnDraw` do not depend on the rectangle's upper left point being equal to (0, 0) and that you draw only inside the rectangle passed to `OnDraw`. Unexpected results can occur if you draw beyond the rectangle's area.","pos":[8,266],"nodes":[{"content":"It is important that your modifications to <ph id=\"ph1\">`OnDraw`</ph> do not depend on the rectangle's upper left point being equal to (0, 0) and that you draw only inside the rectangle passed to <ph id=\"ph2\">`OnDraw`</ph>.","pos":[1,188],"source":" It is important that your modifications to `OnDraw` do not depend on the rectangle's upper left point being equal to (0, 0) and that you draw only inside the rectangle passed to `OnDraw`."},{"content":"Unexpected results can occur if you draw beyond the rectangle's area.","pos":[189,258]}]}]},{"content":"The default implementation provided by the MFC ActiveX Control Wizard in the control implementation file (.CPP), shown below, paints the rectangle with a white brush and fills the ellipse with the current background color.","pos":[4152,4374]},{"pos":[4392,4406],"content":"NVC_MFC_AxUI#1"},{"pos":[4495,4923],"content":"[!NOTE]\n When painting a control, you should not make assumptions about the state of the device context that is passed as the *pdc* parameter to the `OnDraw` function. Occasionally the device context is supplied by the container application and will not necessarily be initialized to the default state. In particular, explicitly select the pens, brushes, colors, fonts, and other resources that your drawing code depends upon.","leadings":["","> "],"nodes":[{"content":" When painting a control, you should not make assumptions about the state of the device context that is passed as the *pdc* parameter to the `OnDraw` function. Occasionally the device context is supplied by the container application and will not necessarily be initialized to the default state. In particular, explicitly select the pens, brushes, colors, fonts, and other resources that your drawing code depends upon.","pos":[8,426],"nodes":[{"content":"When painting a control, you should not make assumptions about the state of the device context that is passed as the <bpt id=\"p1\">*</bpt>pdc<ept id=\"p1\">*</ept> parameter to the <ph id=\"ph1\">`OnDraw`</ph> function.","pos":[1,159],"source":" When painting a control, you should not make assumptions about the state of the device context that is passed as the *pdc* parameter to the `OnDraw` function."},{"content":"Occasionally the device context is supplied by the container application and will not necessarily be initialized to the default state.","pos":[160,294]},{"content":"In particular, explicitly select the pens, brushes, colors, fonts, and other resources that your drawing code depends upon.","pos":[295,418]}]}]},{"pos":[4981,5007],"content":"Optimizing Your Paint Code"},{"pos":[5011,5113],"content":"After the control is successfully painting itself, the next step is to optimize the <ph id=\"ph1\">`OnDraw`</ph> function.","source":"After the control is successfully painting itself, the next step is to optimize the `OnDraw` function."},{"content":"The default implementation of ActiveX control painting paints the entire control area.","pos":[5120,5206]},{"content":"This is sufficient for simple controls, but in many cases repainting the control would be faster if only the portion that needed updating was repainted, instead of the entire control.","pos":[5207,5390]},{"content":"The <ph id=\"ph1\">`OnDraw`</ph> function provides an easy method of optimization by passing <ph id=\"ph2\">`rcInvalid`</ph>, the rectangular area of the control that needs redrawing.","pos":[5397,5540],"source":"The `OnDraw` function provides an easy method of optimization by passing `rcInvalid`, the rectangular area of the control that needs redrawing."},{"content":"Use this area, usually smaller than the entire control area, to speed up the painting process.","pos":[5541,5635]},{"pos":[5704,5741],"content":"Painting Your Control Using Metafiles"},{"content":"In most cases the <ph id=\"ph1\">`pdc`</ph> parameter to the <ph id=\"ph2\">`OnDraw`</ph> function points to a screen device context (DC).","pos":[5745,5843],"source":"In most cases the `pdc` parameter to the `OnDraw` function points to a screen device context (DC)."},{"content":"However, when printing images of the control or during a print preview session, the DC received for rendering is a special type called a \"metafile DC\".","pos":[5844,5995]},{"content":"Unlike a screen DC, which immediately handles requests sent to it, a metafile DC stores requests to be played back at a later time.","pos":[5996,6127]},{"content":"Some container applications may also choose to render the control image using a metafile DC when in design mode.","pos":[6128,6240]},{"content":"Metafile drawing requests can be made by the container through two interface functions: <bpt id=\"p1\">**</bpt>IViewObject::Draw<ept id=\"p1\">**</ept> (this function can also be called for non-metafile drawing) and <bpt id=\"p2\">**</bpt>IDataObject::GetData<ept id=\"p2\">**</ept>.","pos":[6247,6446],"source":"Metafile drawing requests can be made by the container through two interface functions: **IViewObject::Draw** (this function can also be called for non-metafile drawing) and **IDataObject::GetData**."},{"content":"When a metafile DC is passed as one of the parameters, the MFC framework makes a call to <bpt id=\"p1\">[</bpt>COleControl::OnDrawMetafile<ept id=\"p1\">](../mfc/reference/colecontrol-class.md#colecontrol__ondrawmetafile)</ept>.","pos":[6447,6633],"source":" When a metafile DC is passed as one of the parameters, the MFC framework makes a call to [COleControl::OnDrawMetafile](../mfc/reference/colecontrol-class.md#colecontrol__ondrawmetafile)."},{"content":"Because this is a virtual member function, override this function in the control class to do any special processing.","pos":[6634,6750]},{"content":"The default behavior calls <ph id=\"ph1\">`COleControl::OnDraw`</ph>.","pos":[6751,6800],"source":" The default behavior calls `COleControl::OnDraw`."},{"content":"To make sure the control can be drawn in both screen and metafile device contexts, you must use only member functions that are supported in both a screen and a metafile DC.","pos":[6807,6979]},{"content":"Be aware that the coordinate system may not be measured in pixels.","pos":[6980,7046]},{"content":"Because the default implementation of <ph id=\"ph1\">`OnDrawMetafile`</ph> calls the control's <ph id=\"ph2\">`OnDraw`</ph> function, use only member functions that are suitable for both a metafile and a screen device context, unless you override <ph id=\"ph3\">`OnDrawMetafile`</ph>.","pos":[7053,7277],"source":"Because the default implementation of `OnDrawMetafile` calls the control's `OnDraw` function, use only member functions that are suitable for both a metafile and a screen device context, unless you override `OnDrawMetafile`."},{"content":"The following lists the subset of <ph id=\"ph1\">`CDC`</ph> member functions that can be used in both a metafile and a screen device context.","pos":[7278,7399],"source":" The following lists the subset of `CDC` member functions that can be used in both a metafile and a screen device context."},{"content":"For more information on these functions, see class <bpt id=\"p1\">[</bpt>CDC<ept id=\"p1\">](../mfc/reference/cdc-class.md)</ept> in the <bpt id=\"p2\">*</bpt>MFC Reference<ept id=\"p2\">*</ept>.","pos":[7400,7511],"source":" For more information on these functions, see class [CDC](../mfc/reference/cdc-class.md) in the *MFC Reference*."},{"content":"Arc","pos":[7518,7521]},{"content":"BibBlt","pos":[7522,7528]},{"content":"Chord","pos":[7529,7534]},{"content":"Ellipse","pos":[7580,7587]},{"content":"Escape","pos":[7592,7598]},{"content":"Polygon","pos":[7769,7776]},{"content":"In addition to <ph id=\"ph1\">`CDC`</ph> member functions, there are several other functions that are compatible in a metafile DC.","pos":[8220,8330],"source":"In addition to `CDC` member functions, there are several other functions that are compatible in a metafile DC."},{"content":"These include <bpt id=\"p1\">[</bpt>CPalette::AnimatePalette<ept id=\"p1\">](../mfc/reference/cpalette-class.md#cpalette__animatepalette)</ept>, <bpt id=\"p2\">[</bpt>CFont::CreateFontIndirect<ept id=\"p2\">](../mfc/reference/cfont-class.md#cfont__createfontindirect)</ept>, and three member functions of <ph id=\"ph1\">`CBrush`</ph>: <bpt id=\"p3\">[</bpt>CreateBrushIndirect<ept id=\"p3\">](../mfc/reference/cbrush-class.md#cbrush__createbrushindirect)</ept>, <bpt id=\"p4\">[</bpt>CreateDIBPatternBrush<ept id=\"p4\">](../mfc/reference/cbrush-class.md#cbrush__createdibpatternbrush)</ept>, and <bpt id=\"p5\">[</bpt>CreatePatternBrush<ept id=\"p5\">](../mfc/reference/cbrush-class.md#cbrush__createpatternbrush)</ept>.","pos":[8331,8822],"source":" These include [CPalette::AnimatePalette](../mfc/reference/cpalette-class.md#cpalette__animatepalette), [CFont::CreateFontIndirect](../mfc/reference/cfont-class.md#cfont__createfontindirect), and three member functions of `CBrush`: [CreateBrushIndirect](../mfc/reference/cbrush-class.md#cbrush__createbrushindirect), [CreateDIBPatternBrush](../mfc/reference/cbrush-class.md#cbrush__createdibpatternbrush), and [CreatePatternBrush](../mfc/reference/cbrush-class.md#cbrush__createpatternbrush)."},{"content":"Functions that are not recorded in a metafile are: <bpt id=\"p1\">[</bpt>DrawFocusRect<ept id=\"p1\">](../mfc/reference/cdc-class.md#cdc__drawfocusrect)</ept>, <bpt id=\"p2\">[</bpt>DrawIcon<ept id=\"p2\">](../mfc/reference/cdc-class.md#cdc__drawicon)</ept>, <bpt id=\"p3\">[</bpt>DrawText<ept id=\"p3\">](../mfc/reference/cdc-class.md#cdc__drawtext)</ept>, <bpt id=\"p4\">[</bpt>ExcludeUpdateRgn<ept id=\"p4\">](../mfc/reference/cdc-class.md#cdc__excludeupdatergn)</ept>, <bpt id=\"p5\">[</bpt>FillRect<ept id=\"p5\">](../mfc/reference/cdc-class.md#cdc__fillrect)</ept>, <bpt id=\"p6\">[</bpt>FrameRect<ept id=\"p6\">](../mfc/reference/cdc-class.md#cdc__framerect)</ept>, <bpt id=\"p7\">[</bpt>GrayString<ept id=\"p7\">](../mfc/reference/cdc-class.md#cdc__graystring)</ept>, <bpt id=\"p8\">[</bpt>InvertRect<ept id=\"p8\">](../mfc/reference/cdc-class.md#cdc__invertrect)</ept>, <bpt id=\"p9\">[</bpt>ScrollDC<ept id=\"p9\">](../mfc/reference/cdc-class.md#cdc__scrolldc)</ept>, and <bpt id=\"p10\">[</bpt>TabbedTextOut<ept id=\"p10\">](../mfc/reference/cdc-class.md#cdc__tabbedtextout)</ept>.","pos":[8829,9499],"source":"Functions that are not recorded in a metafile are: [DrawFocusRect](../mfc/reference/cdc-class.md#cdc__drawfocusrect), [DrawIcon](../mfc/reference/cdc-class.md#cdc__drawicon), [DrawText](../mfc/reference/cdc-class.md#cdc__drawtext), [ExcludeUpdateRgn](../mfc/reference/cdc-class.md#cdc__excludeupdatergn), [FillRect](../mfc/reference/cdc-class.md#cdc__fillrect), [FrameRect](../mfc/reference/cdc-class.md#cdc__framerect), [GrayString](../mfc/reference/cdc-class.md#cdc__graystring), [InvertRect](../mfc/reference/cdc-class.md#cdc__invertrect), [ScrollDC](../mfc/reference/cdc-class.md#cdc__scrolldc), and [TabbedTextOut](../mfc/reference/cdc-class.md#cdc__tabbedtextout)."},{"content":"Because a metafile DC is not actually associated with a device, you cannot use SetDIBits, GetDIBits, and CreateDIBitmap with a metafile DC.","pos":[9500,9639]},{"content":"You can use SetDIBitsToDevice and StretchDIBits with a metafile DC as the destination.","pos":[9640,9726]},{"content":"<bpt id=\"p1\">[</bpt>CreateCompatibleDC<ept id=\"p1\">](../mfc/reference/cdc-class.md#cdc__createcompatibledc)</ept>, <bpt id=\"p2\">[</bpt>CreateCompatibleBitmap<ept id=\"p2\">](../mfc/reference/cbitmap-class.md#cbitmap__createcompatiblebitmap)</ept>, and <bpt id=\"p3\">[</bpt>CreateDiscardableBitmap<ept id=\"p3\">](../mfc/reference/cbitmap-class.md#cbitmap__creatediscardablebitmap)</ept> are not meaningful with a metafile DC.","pos":[9727,10033],"source":"[CreateCompatibleDC](../mfc/reference/cdc-class.md#cdc__createcompatibledc), [CreateCompatibleBitmap](../mfc/reference/cbitmap-class.md#cbitmap__createcompatiblebitmap), and [CreateDiscardableBitmap](../mfc/reference/cbitmap-class.md#cbitmap__creatediscardablebitmap) are not meaningful with a metafile DC."},{"content":"Another point to consider when using a metafile DC is that the coordinate system may not be measured in pixels.","pos":[10040,10151]},{"content":"For this reason, all your drawing code should be adjusted to fit in the rectangle passed to <ph id=\"ph1\">`OnDraw`</ph> in the <ph id=\"ph2\">`rcBounds`</ph> parameter.","pos":[10152,10281],"source":" For this reason, all your drawing code should be adjusted to fit in the rectangle passed to `OnDraw` in the `rcBounds` parameter."},{"content":"This prevents accidental painting outside the control because <ph id=\"ph1\">`rcBounds`</ph> represents the size of the control's window.","pos":[10282,10399],"source":" This prevents accidental painting outside the control because `rcBounds` represents the size of the control's window."},{"content":"After you have implemented metafile rendering for the control, use Test Container to test the metafile.","pos":[10406,10509]},{"content":"See <bpt id=\"p1\">[</bpt>Testing Properties and Events with Test Container<ept id=\"p1\">](../mfc/testing-properties-and-events-with-test-container.md)</ept> for information on how to access the test container.","pos":[10510,10679],"source":" See [Testing Properties and Events with Test Container](../mfc/testing-properties-and-events-with-test-container.md) for information on how to access the test container."},{"content":"To test the control's metafile using Test Container","pos":[10690,10741]},{"pos":[10751,10819],"content":"On the Test Container's <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> menu, click <bpt id=\"p2\">**</bpt>Insert New Control<ept id=\"p2\">**</ept>.","source":"On the Test Container's **Edit** menu, click **Insert New Control**."},{"pos":[10829,10900],"content":"In the <bpt id=\"p1\">**</bpt>Insert New Control<ept id=\"p1\">**</ept> box, select the control and click <bpt id=\"p2\">**</bpt>OK<ept id=\"p2\">**</ept>.","source":"In the **Insert New Control** box, select the control and click **OK**."},{"content":"The control will appear in Test container.","pos":[10911,10953]},{"pos":[10963,11012],"content":"On the <bpt id=\"p1\">**</bpt>Control<ept id=\"p1\">**</ept> menu, click <bpt id=\"p2\">**</bpt>Draw Metafile<ept id=\"p2\">**</ept>.","source":"On the **Control** menu, click **Draw Metafile**."},{"content":"A separate window appears in which the metafile is displayed.","pos":[11023,11084]},{"content":"You can change the size of this window to see how scaling affects the control's metafile.","pos":[11085,11174]},{"content":"You can close this window at any time.","pos":[11175,11213]},{"content":"See Also","pos":[11222,11230]},{"content":"MFC ActiveX Controls","pos":[11235,11255]}],"content":"---\ntitle: \"MFC ActiveX Controls: Painting an ActiveX Control | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"MFC ActiveX controls, painting\"\n  - \"MFC ActiveX controls, optimizing\"\nms.assetid: 25fff9c0-4dab-4704-aaae-8dfb1065dee3\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# MFC ActiveX Controls: Painting an ActiveX Control\nThis article describes the ActiveX control painting process and how you can alter paint code to optimize the process. (See [Optimizing Control Drawing](../mfc/optimizing-control-drawing.md) for techniques on how to optimize drawing by not having controls individually restore previously selected GDI objects. After all of the controls have been drawn, the container can automatically restore the original objects.)  \n  \n Examples in this article are from a control created by the MFC ActiveX Control Wizard with default settings. For more information on creating a skeleton control application using the MFC ActiveX Control Wizard, see the article [MFC ActiveX Control Wizard](../mfc/reference/mfc-activex-control-wizard.md).  \n  \n The following topics are covered:  \n  \n-   [The overall process for painting a control and the code created by the ActiveX Control Wizard to support painting](#_core_the_painting_process_of_an_activex_control)  \n  \n-   [How to optimize the painting process](#_core_optimizing_your_paint_code)  \n  \n-   [How to paint your control using metafiles](#_core_painting_your_control_using_metafiles)  \n  \n##  <a name=\"_core_the_painting_process_of_an_activex_control\"></a> The Painting Process of an ActiveX Control  \n When ActiveX controls are initially displayed or are redrawn, they follow a painting process similar to other applications developed using MFC, with one important distinction: ActiveX controls can be in an active or an inactive state.  \n  \n An active control is represented in an ActiveX control container by a child window. Like other windows, it is responsible for painting itself when a `WM_PAINT` message is received. The control's base class, [COleControl](../mfc/reference/colecontrol-class.md), handles this message in its `OnPaint` function. This default implementation calls the `OnDraw` function of your control.  \n  \n An inactive control is painted differently. When the control is inactive, its window is either invisible or nonexistent, so it can not receive a paint message. Instead, the control container directly calls the `OnDraw` function of the control. This differs from an active control's painting process in that the `OnPaint` member function is never called.  \n  \n As discussed in the preceding paragraphs, how an ActiveX control is updated depends on the state of the control. However, because the framework calls the `OnDraw` member function in both cases, you add the majority of your painting code in this member function.  \n  \n The `OnDraw` member function handles control painting. When a control is inactive, the control container calls `OnDraw`, passing the device context of the control container and the coordinates of the rectangular area occupied by the control.  \n  \n The rectangle passed by the framework to the `OnDraw` member function contains the area occupied by the control. If the control is active, the upper-left corner is (0, 0) and the device context passed is for the child window that contains the control. If the control is inactive, the upper-left coordinate is not necessarily (0, 0) and the device context passed is for the control container containing the control.  \n  \n> [!NOTE]\n>  It is important that your modifications to `OnDraw` do not depend on the rectangle's upper left point being equal to (0, 0) and that you draw only inside the rectangle passed to `OnDraw`. Unexpected results can occur if you draw beyond the rectangle's area.  \n  \n The default implementation provided by the MFC ActiveX Control Wizard in the control implementation file (.CPP), shown below, paints the rectangle with a white brush and fills the ellipse with the current background color.  \n  \n [!code-cpp[NVC_MFC_AxUI#1](../mfc/codesnippet/cpp/mfc-activex-controls-painting-an-activex-control_1.cpp)]  \n  \n> [!NOTE]\n>  When painting a control, you should not make assumptions about the state of the device context that is passed as the *pdc* parameter to the `OnDraw` function. Occasionally the device context is supplied by the container application and will not necessarily be initialized to the default state. In particular, explicitly select the pens, brushes, colors, fonts, and other resources that your drawing code depends upon.  \n  \n##  <a name=\"_core_optimizing_your_paint_code\"></a> Optimizing Your Paint Code  \n After the control is successfully painting itself, the next step is to optimize the `OnDraw` function.  \n  \n The default implementation of ActiveX control painting paints the entire control area. This is sufficient for simple controls, but in many cases repainting the control would be faster if only the portion that needed updating was repainted, instead of the entire control.  \n  \n The `OnDraw` function provides an easy method of optimization by passing `rcInvalid`, the rectangular area of the control that needs redrawing. Use this area, usually smaller than the entire control area, to speed up the painting process.  \n  \n##  <a name=\"_core_painting_your_control_using_metafiles\"></a> Painting Your Control Using Metafiles  \n In most cases the `pdc` parameter to the `OnDraw` function points to a screen device context (DC). However, when printing images of the control or during a print preview session, the DC received for rendering is a special type called a \"metafile DC\". Unlike a screen DC, which immediately handles requests sent to it, a metafile DC stores requests to be played back at a later time. Some container applications may also choose to render the control image using a metafile DC when in design mode.  \n  \n Metafile drawing requests can be made by the container through two interface functions: **IViewObject::Draw** (this function can also be called for non-metafile drawing) and **IDataObject::GetData**. When a metafile DC is passed as one of the parameters, the MFC framework makes a call to [COleControl::OnDrawMetafile](../mfc/reference/colecontrol-class.md#colecontrol__ondrawmetafile). Because this is a virtual member function, override this function in the control class to do any special processing. The default behavior calls `COleControl::OnDraw`.  \n  \n To make sure the control can be drawn in both screen and metafile device contexts, you must use only member functions that are supported in both a screen and a metafile DC. Be aware that the coordinate system may not be measured in pixels.  \n  \n Because the default implementation of `OnDrawMetafile` calls the control's `OnDraw` function, use only member functions that are suitable for both a metafile and a screen device context, unless you override `OnDrawMetafile`. The following lists the subset of `CDC` member functions that can be used in both a metafile and a screen device context. For more information on these functions, see class [CDC](../mfc/reference/cdc-class.md) in the *MFC Reference*.  \n  \n|Arc|BibBlt|Chord|  \n|---------|------------|-----------|  \n|**Ellipse**|**Escape**|`ExcludeClipRect`|  \n|`ExtTextOut`|`FloodFill`|`IntersectClipRect`|  \n|`LineTo`|`MoveTo`|`OffsetClipRgn`|  \n|`OffsetViewportOrg`|`OffsetWindowOrg`|`PatBlt`|  \n|`Pie`|**Polygon**|`Polyline`|  \n|`PolyPolygon`|`RealizePalette`|`RestoreDC`|  \n|`RoundRect`|`SaveDC`|`ScaleViewportExt`|  \n|`ScaleWindowExt`|`SelectClipRgn`|`SelectObject`|  \n|`SelectPalette`|`SetBkColor`|`SetBkMode`|  \n|`SetMapMode`|`SetMapperFlags`|`SetPixel`|  \n|`SetPolyFillMode`|`SetROP2`|`SetStretchBltMode`|  \n|`SetTextColor`|`SetTextJustification`|`SetViewportExt`|  \n|`SetViewportOrg`|`SetWindowExt`|`SetWindowORg`|  \n|`StretchBlt`|`TextOut`||  \n  \n In addition to `CDC` member functions, there are several other functions that are compatible in a metafile DC. These include [CPalette::AnimatePalette](../mfc/reference/cpalette-class.md#cpalette__animatepalette), [CFont::CreateFontIndirect](../mfc/reference/cfont-class.md#cfont__createfontindirect), and three member functions of `CBrush`: [CreateBrushIndirect](../mfc/reference/cbrush-class.md#cbrush__createbrushindirect), [CreateDIBPatternBrush](../mfc/reference/cbrush-class.md#cbrush__createdibpatternbrush), and [CreatePatternBrush](../mfc/reference/cbrush-class.md#cbrush__createpatternbrush).  \n  \n Functions that are not recorded in a metafile are: [DrawFocusRect](../mfc/reference/cdc-class.md#cdc__drawfocusrect), [DrawIcon](../mfc/reference/cdc-class.md#cdc__drawicon), [DrawText](../mfc/reference/cdc-class.md#cdc__drawtext), [ExcludeUpdateRgn](../mfc/reference/cdc-class.md#cdc__excludeupdatergn), [FillRect](../mfc/reference/cdc-class.md#cdc__fillrect), [FrameRect](../mfc/reference/cdc-class.md#cdc__framerect), [GrayString](../mfc/reference/cdc-class.md#cdc__graystring), [InvertRect](../mfc/reference/cdc-class.md#cdc__invertrect), [ScrollDC](../mfc/reference/cdc-class.md#cdc__scrolldc), and [TabbedTextOut](../mfc/reference/cdc-class.md#cdc__tabbedtextout). Because a metafile DC is not actually associated with a device, you cannot use SetDIBits, GetDIBits, and CreateDIBitmap with a metafile DC. You can use SetDIBitsToDevice and StretchDIBits with a metafile DC as the destination. [CreateCompatibleDC](../mfc/reference/cdc-class.md#cdc__createcompatibledc), [CreateCompatibleBitmap](../mfc/reference/cbitmap-class.md#cbitmap__createcompatiblebitmap), and [CreateDiscardableBitmap](../mfc/reference/cbitmap-class.md#cbitmap__creatediscardablebitmap) are not meaningful with a metafile DC.  \n  \n Another point to consider when using a metafile DC is that the coordinate system may not be measured in pixels. For this reason, all your drawing code should be adjusted to fit in the rectangle passed to `OnDraw` in the `rcBounds` parameter. This prevents accidental painting outside the control because `rcBounds` represents the size of the control's window.  \n  \n After you have implemented metafile rendering for the control, use Test Container to test the metafile. See [Testing Properties and Events with Test Container](../mfc/testing-properties-and-events-with-test-container.md) for information on how to access the test container.  \n  \n#### To test the control's metafile using Test Container  \n  \n1.  On the Test Container's **Edit** menu, click **Insert New Control**.  \n  \n2.  In the **Insert New Control** box, select the control and click **OK**.  \n  \n     The control will appear in Test container.  \n  \n3.  On the **Control** menu, click **Draw Metafile**.  \n  \n     A separate window appears in which the metafile is displayed. You can change the size of this window to see how scaling affects the control's metafile. You can close this window at any time.  \n  \n## See Also  \n [MFC ActiveX Controls](../mfc/mfc-activex-controls.md)\n\n"}