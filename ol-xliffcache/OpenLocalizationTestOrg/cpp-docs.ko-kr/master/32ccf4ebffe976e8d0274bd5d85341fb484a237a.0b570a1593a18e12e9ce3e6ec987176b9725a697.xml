{"nodes":[{"pos":[12,36],"content":"_expand | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_expand | Microsoft Docs","pos":[0,24]}]},{"pos":[1061,1068],"content":"_expand","linkify":"_expand","nodes":[{"content":"_expand","pos":[0,7]}]},{"content":"Changes the size of a memory block.","pos":[1069,1104]},{"pos":[1113,1119],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1207,1217],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Pointer to previously allocated memory block.","pos":[1235,1280]},{"content":"New size in bytes.","pos":[1297,1315]},{"pos":[1324,1336],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"<ph id=\"ph1\">`_expand`</ph> returns a void pointer to the reallocated memory block.","pos":[1340,1405],"source":"`_expand` returns a void pointer to the reallocated memory block."},{"content":"<ph id=\"ph1\">`_expand`</ph>, unlike <ph id=\"ph2\">`realloc`</ph>, cannot move a block to change its size.","pos":[1406,1474],"source":"`_expand`, unlike `realloc`, cannot move a block to change its size."},{"content":"Thus, if there is sufficient memory available to expand the block without moving it, the <ph id=\"ph1\">`memblock`</ph> parameter to <ph id=\"ph2\">`_expand`</ph> is the same as the return value.","pos":[1475,1630],"source":" Thus, if there is sufficient memory available to expand the block without moving it, the `memblock` parameter to `_expand` is the same as the return value."},{"content":"<ph id=\"ph1\">`_expand`</ph> returns <ph id=\"ph2\">`NULL`</ph> when an error is detected during its operation.","pos":[1637,1709],"source":"`_expand` returns `NULL` when an error is detected during its operation."},{"content":"For example, if <ph id=\"ph1\">`_expand`</ph> is used to shrink a memory block, it might detect corruption in the small block heap or an invalid block pointer and return <ph id=\"ph2\">`NULL`</ph>.","pos":[1710,1867],"source":" For example, if `_expand` is used to shrink a memory block, it might detect corruption in the small block heap or an invalid block pointer and return `NULL`."},{"content":"If there is insufficient memory available to expand the block to the given size without moving it, the function returns <ph id=\"ph1\">`NULL`</ph>.","pos":[1874,2001],"source":"If there is insufficient memory available to expand the block to the given size without moving it, the function returns `NULL`."},{"content":"<ph id=\"ph1\">`_expand`</ph> never returns a block expanded to a size less than requested.","pos":[2002,2073],"source":"`_expand` never returns a block expanded to a size less than requested."},{"content":"If a failure occurs, <ph id=\"ph1\">`errno`</ph> indicates the nature of the failure.","pos":[2074,2139],"source":" If a failure occurs, `errno` indicates the nature of the failure."},{"content":"For more information about <ph id=\"ph1\">`errno`</ph>, see <bpt id=\"p1\">[</bpt>errno, _doserrno, _sys_errlist, and _sys_nerr<ept id=\"p1\">](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)</ept>.","pos":[2140,2296],"source":" For more information about `errno`, see [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)."},{"content":"The return value points to a storage space that is guaranteed to be suitably aligned for storage of any type of object.","pos":[2303,2422]},{"content":"To check the new size of the item, use <ph id=\"ph1\">`_msize`</ph>.","pos":[2423,2471],"source":" To check the new size of the item, use `_msize`."},{"content":"To get a pointer to a type other than <ph id=\"ph1\">`void`</ph>, use a type cast on the return value.","pos":[2472,2554],"source":" To get a pointer to a type other than `void`, use a type cast on the return value."},{"pos":[2563,2570],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`_expand`</ph> function changes the size of a previously allocated memory block by trying to expand or contract the block without moving its location in the heap.","pos":[2574,2735],"source":"The `_expand` function changes the size of a previously allocated memory block by trying to expand or contract the block without moving its location in the heap."},{"content":"The <ph id=\"ph1\">`memblock`</ph> parameter points to the beginning of the block.","pos":[2736,2798],"source":" The `memblock` parameter points to the beginning of the block."},{"content":"The <ph id=\"ph1\">`size`</ph> parameter gives the new size of the block, in bytes.","pos":[2799,2862],"source":" The `size` parameter gives the new size of the block, in bytes."},{"content":"The contents of the block are unchanged up to the shorter of the new and old sizes.","pos":[2863,2946]},{"content":"<ph id=\"ph1\">`memblock`</ph> should not be a block that has been freed.","pos":[2947,3000],"source":"`memblock` should not be a block that has been freed."},{"pos":[3008,3295],"content":"[!NOTE]\n On 64-bit platforms, `_expand` might not contract the block if the new size is less than the current size; in particular, if the block was less than 16K in size and therefore allocated in the Low Fragmentation Heap, `_expand` leaves the block unchanged and returns `memblock`.","leadings":["","> "],"nodes":[{"content":"On 64-bit platforms, <ph id=\"ph1\">`_expand`</ph> might not contract the block if the new size is less than the current size; in particular, if the block was less than 16K in size and therefore allocated in the Low Fragmentation Heap, <ph id=\"ph2\">`_expand`</ph> leaves the block unchanged and returns <ph id=\"ph3\">`memblock`</ph>.","pos":[9,285],"source":" On 64-bit platforms, `_expand` might not contract the block if the new size is less than the current size; in particular, if the block was less than 16K in size and therefore allocated in the Low Fragmentation Heap, `_expand` leaves the block unchanged and returns `memblock`."}]},{"content":"When the application is linked with a debug version of the C run-time libraries, <ph id=\"ph1\">`_expand`</ph> resolves to <bpt id=\"p1\">[</bpt>_expand_dbg<ept id=\"p1\">](../../c-runtime-library/reference/expand-dbg.md)</ept>.","pos":[3302,3468],"source":"When the application is linked with a debug version of the C run-time libraries, `_expand` resolves to [_expand_dbg](../../c-runtime-library/reference/expand-dbg.md)."},{"content":"For more information about how the heap is managed during the debugging process, see <bpt id=\"p1\">[</bpt>The CRT Debug Heap<ept id=\"p1\">](/visualstudio/debugger/crt-debug-heap-details)</ept>.","pos":[3469,3622],"source":" For more information about how the heap is managed during the debugging process, see [The CRT Debug Heap](/visualstudio/debugger/crt-debug-heap-details)."},{"content":"This function validates its parameters.","pos":[3629,3668]},{"content":"If <ph id=\"ph1\">`memblock`</ph> is a null pointer, this function invokes an invalid parameter handler, as described in <bpt id=\"p1\">[</bpt>Parameter Validation<ept id=\"p1\">](../../c-runtime-library/parameter-validation.md)</ept>.","pos":[3669,3842],"source":" If `memblock` is a null pointer, this function invokes an invalid parameter handler, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md)."},{"content":"If execution is allowed to continue, <ph id=\"ph1\">`errno`</ph> is set to <ph id=\"ph2\">`EINVAL`</ph> and the function returns <ph id=\"ph3\">`NULL`</ph>.","pos":[3843,3939],"source":" If execution is allowed to continue, `errno` is set to `EINVAL` and the function returns `NULL`."},{"content":"If <ph id=\"ph1\">`size`</ph> is greater than <ph id=\"ph2\">`_HEAP_MAXREQ`</ph>, <ph id=\"ph3\">`errno`</ph> is set to <ph id=\"ph4\">`ENOMEM`</ph> and the function returns <ph id=\"ph5\">`NULL`</ph>.","pos":[3940,4041],"source":" If `size` is greater than `_HEAP_MAXREQ`, `errno` is set to `ENOMEM` and the function returns `NULL`."},{"pos":[4050,4062],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Function","pos":[4069,4077]},{"content":"Required header","pos":[4078,4093]},{"content":"<ph id=\"ph1\">\\&lt;</ph>malloc.h&gt;","pos":[4149,4160],"source":"\\<malloc.h>"},{"pos":[4168,4292],"content":"For additional compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept> in the Introduction.","source":"For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction."},{"pos":[4301,4308],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[5105,5130],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"Not applicable.","pos":[5134,5149]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[5150,5197],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[5198,5323],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[5332,5340],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Memory Allocation<ept id=\"p1\">](../../c-runtime-library/memory-allocation.md)</ept><ph id=\"ph1\"> </ph>","pos":[5344,5410],"source":"[Memory Allocation](../../c-runtime-library/memory-allocation.md) "},{"content":"<bpt id=\"p1\"> [</bpt>calloc<ept id=\"p1\">](../../c-runtime-library/reference/calloc.md)</ept><ph id=\"ph1\"> </ph>","pos":[5413,5468],"source":" [calloc](../../c-runtime-library/reference/calloc.md) "},{"content":"<bpt id=\"p1\"> [</bpt>free<ept id=\"p1\">](../../c-runtime-library/reference/free.md)</ept><ph id=\"ph1\"> </ph>","pos":[5471,5522],"source":" [free](../../c-runtime-library/reference/free.md) "},{"content":"<bpt id=\"p1\"> [</bpt>malloc<ept id=\"p1\">](../../c-runtime-library/reference/malloc.md)</ept><ph id=\"ph1\"> </ph>","pos":[5525,5580],"source":" [malloc](../../c-runtime-library/reference/malloc.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_msize<ept id=\"p1\">](../../c-runtime-library/reference/msize.md)</ept><ph id=\"ph1\"> </ph>","pos":[5583,5637],"source":" [_msize](../../c-runtime-library/reference/msize.md) "},{"content":"<bpt id=\"p1\"> [</bpt>realloc<ept id=\"p1\">](../../c-runtime-library/reference/realloc.md)</ept>","pos":[5640,5696],"source":" [realloc](../../c-runtime-library/reference/realloc.md)"}],"content":"---\ntitle: \"_expand | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_expand\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\n  - \"api-ms-win-crt-heap-l1-1-0.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"_bexpand\"\n  - \"fexpand\"\n  - \"expand\"\n  - \"nexpand\"\n  - \"_fexpand\"\n  - \"_nexpand\"\n  - \"bexpand\"\n  - \"_expand\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"memory blocks, changing size\"\n  - \"_expand function\"\n  - \"expand function\"\nms.assetid: 4ac55410-39c8-45c7-bccd-3f1042ae2ed3\ncaps.latest.revision: 22\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _expand\nChanges the size of a memory block.  \n  \n## Syntax  \n  \n```  \nvoid *_expand(   \n   void *memblock,  \n   size_t size   \n);  \n```  \n  \n#### Parameters  \n `memblock`  \n Pointer to previously allocated memory block.  \n  \n `size`  \n New size in bytes.  \n  \n## Return Value  \n `_expand` returns a void pointer to the reallocated memory block. `_expand`, unlike `realloc`, cannot move a block to change its size. Thus, if there is sufficient memory available to expand the block without moving it, the `memblock` parameter to `_expand` is the same as the return value.  \n  \n `_expand` returns `NULL` when an error is detected during its operation. For example, if `_expand` is used to shrink a memory block, it might detect corruption in the small block heap or an invalid block pointer and return `NULL`.  \n  \n If there is insufficient memory available to expand the block to the given size without moving it, the function returns `NULL`. `_expand` never returns a block expanded to a size less than requested. If a failure occurs, `errno` indicates the nature of the failure. For more information about `errno`, see [errno, _doserrno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).  \n  \n The return value points to a storage space that is guaranteed to be suitably aligned for storage of any type of object. To check the new size of the item, use `_msize`. To get a pointer to a type other than `void`, use a type cast on the return value.  \n  \n## Remarks  \n The `_expand` function changes the size of a previously allocated memory block by trying to expand or contract the block without moving its location in the heap. The `memblock` parameter points to the beginning of the block. The `size` parameter gives the new size of the block, in bytes. The contents of the block are unchanged up to the shorter of the new and old sizes. `memblock` should not be a block that has been freed.  \n  \n> [!NOTE]\n>  On 64-bit platforms, `_expand` might not contract the block if the new size is less than the current size; in particular, if the block was less than 16K in size and therefore allocated in the Low Fragmentation Heap, `_expand` leaves the block unchanged and returns `memblock`.  \n  \n When the application is linked with a debug version of the C run-time libraries, `_expand` resolves to [_expand_dbg](../../c-runtime-library/reference/expand-dbg.md). For more information about how the heap is managed during the debugging process, see [The CRT Debug Heap](/visualstudio/debugger/crt-debug-heap-details).  \n  \n This function validates its parameters. If `memblock` is a null pointer, this function invokes an invalid parameter handler, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md). If execution is allowed to continue, `errno` is set to `EINVAL` and the function returns `NULL`. If `size` is greater than `_HEAP_MAXREQ`, `errno` is set to `ENOMEM` and the function returns `NULL`.  \n  \n## Requirements  \n  \n|Function|Required header|  \n|--------------|---------------------|  \n|`_expand`|\\<malloc.h>|  \n  \n For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction.  \n  \n## Example  \n  \n```  \n// crt_expand.c  \n  \n#include <stdio.h>  \n#include <malloc.h>  \n#include <stdlib.h>  \n  \nint main( void )  \n{  \n   char *bufchar;  \n   printf( \"Allocate a 512 element buffer\\n\" );  \n   if( (bufchar = (char *)calloc( 512, sizeof( char ) )) == NULL )  \n      exit( 1 );  \n   printf( \"Allocated %d bytes at %Fp\\n\",   \n         _msize( bufchar ), (void *)bufchar );  \n   if( (bufchar = (char *)_expand( bufchar, 1024 )) == NULL )  \n      printf( \"Can't expand\" );  \n   else  \n      printf( \"Expanded block to %d bytes at %Fp\\n\",   \n            _msize( bufchar ), (void *)bufchar );  \n   // Free memory   \n   free( bufchar );  \n   exit( 0 );  \n}  \n```  \n  \n```Output  \nAllocate a 512 element buffer  \nAllocated 512 bytes at 002C12BC  \nExpanded block to 1024 bytes at 002C12BC  \n```  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [Memory Allocation](../../c-runtime-library/memory-allocation.md)   \n [calloc](../../c-runtime-library/reference/calloc.md)   \n [free](../../c-runtime-library/reference/free.md)   \n [malloc](../../c-runtime-library/reference/malloc.md)   \n [_msize](../../c-runtime-library/reference/msize.md)   \n [realloc](../../c-runtime-library/reference/realloc.md)"}