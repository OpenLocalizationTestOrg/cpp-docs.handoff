{"nodes":[{"pos":[12,49],"content":"Compiler Error C2678 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Error C2678 | Microsoft Docs","pos":[0,37]}]},{"pos":[598,618],"content":"Compiler Error C2678","linkify":"Compiler Error C2678","nodes":[{"content":"Compiler Error C2678","pos":[0,20]}]},{"content":"binary 'operator' : no operator defined which takes a left-hand operand of type 'type' (or there is no acceptable conversion)","pos":[619,744]},{"content":"To use the operator, you must overload it for the specified type or define a conversion to a type for which the operator is defined.","pos":[751,883]},{"pos":[892,899],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"C2678 can occur when the left-hand operand is const-qualified but the operator is defined to take a non-const argument.","pos":[903,1022]},{"content":"The following sample generates C2678 and shows how to fix it:","pos":[1029,1090]},{"pos":[1511,1518],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"C2678 can also occur if you do not pin a native member before calling a member function on it.","pos":[1522,1616]},{"content":"The following sample generates C2678 and shows how to fix it.","pos":[1623,1684]}],"content":"---\ntitle: \"Compiler Error C2678 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C2678\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C2678\"\nms.assetid: 1f0a4e26-b429-44f5-9f94-cb66441220c8\ncaps.latest.revision: 12\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Compiler Error C2678\nbinary 'operator' : no operator defined which takes a left-hand operand of type 'type' (or there is no acceptable conversion)  \n  \n To use the operator, you must overload it for the specified type or define a conversion to a type for which the operator is defined.  \n  \n## Example  \n C2678 can occur when the left-hand operand is const-qualified but the operator is defined to take a non-const argument.  \n  \n The following sample generates C2678 and shows how to fix it:  \n  \n```  \n// C2678a.cpp  \n// Compile by using: cl /EHsc /W4 C2678a.cpp  \nstruct Combo {  \n   int number;  \n   char letter;  \n};  \n  \ninline Combo& operator+=(Combo& lhs, int rhs) {  \n   lhs.number += rhs;  \n   return lhs;  \n}  \n  \nint main() {  \n   Combo const combo1{ 42, 'X' };  \n   Combo combo2{ 13, 'Z' };  \n  \n   combo1 += 6; // C2678  \n   combo2 += 9; // OK - operator+= matches non-const Combo  \n}  \n```  \n  \n## Example  \n C2678 can also occur if you do not pin a native member before calling a member function on it.  \n  \n The following sample generates C2678 and shows how to fix it.  \n  \n```  \n// C2678.cpp  \n// compile with: /clr /c  \nstruct S { int _a; };  \n  \nref class C {  \npublic:  \n   void M( S param ) {  \n      test = param;   // C2678  \n  \n      // OK  \n      pin_ptr<S> ptest = &test;  \n      *ptest = param;  \n   }  \n   S test;  \n};  \n```  \n"}