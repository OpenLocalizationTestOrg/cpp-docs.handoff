{"nodes":[{"pos":[12,48],"content":"TN043: RFX Routines | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN043: RFX Routines | Microsoft Docs","pos":[0,36]}]},{"content":"TN043: RFX Routines","pos":[669,688]},{"pos":[691,1006],"content":"[!NOTE]\n The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","leadings":["","> "],"nodes":[{"content":" The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[8,313],"nodes":[{"content":"The following technical note has not been updated since it was first included in the online documentation.","pos":[1,107]},{"content":"As a result, some procedures and topics might be out of date or incorrect.","pos":[108,182]},{"content":"For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[183,305]}]}]},{"content":"This note describes the record field exchange (RFX) architecture.","pos":[1013,1078]},{"content":"It also describes how you write an <bpt id=\"p1\">**</bpt>RFX_<ept id=\"p1\">**</ept> procedure.","pos":[1079,1133],"source":" It also describes how you write an **RFX_** procedure."},{"content":"Overview of Record Field Exchange","pos":[1142,1175]},{"content":"All recordset field functions are done with C++ code.","pos":[1179,1232]},{"content":"There are no special resources or magic macros.","pos":[1233,1280]},{"content":"The heart of the mechanism is a virtual function that must be overridden in every derived recordset class.","pos":[1281,1387]},{"content":"It is always found in this form:","pos":[1388,1420]},{"content":"The special format AFX comments allow ClassWizard to locate and edit the code within this function.","pos":[1626,1725]},{"content":"Code that is not compatible with ClassWizard should be placed outside of the special format comments.","pos":[1726,1827]},{"content":"In the above example, &lt;recordset_exchange_field_type_call&gt; is in the form:","pos":[1834,1908],"source":"In the above example, <recordset_exchange_field_type_call> is in the form:"},{"content":"and &lt;recordset_exchange_function_call&gt; is in the form:","pos":[1979,2033],"source":"and <recordset_exchange_function_call> is in the form:"},{"pos":[2092,2232],"content":"Most <bpt id=\"p1\">**</bpt>RFX_<ept id=\"p1\">**</ept> functions have three arguments as shown above, but some (e.g. <ph id=\"ph1\">`RFX_Text`</ph> and <ph id=\"ph2\">`RFX_Binary`</ph>) have additional optional arguments.","source":"Most **RFX_** functions have three arguments as shown above, but some (e.g. `RFX_Text` and `RFX_Binary`) have additional optional arguments."},{"pos":[2239,2312],"content":"More than one <bpt id=\"p1\">**</bpt>RFX_<ept id=\"p1\">**</ept> may be included in each <ph id=\"ph1\">`DoDataExchange`</ph> function.","source":"More than one **RFX_** may be included in each `DoDataExchange` function."},{"content":"See 'afxdb.h' for a list of all the recordset field exchange routines provided with MFC.","pos":[2319,2407]},{"pos":[2414,2544],"content":"Recordset field calls are a way of registering memory locations (usually data members) to store field data for a <bpt id=\"p1\">**</bpt>CMySet<ept id=\"p1\">**</ept> class.","source":"Recordset field calls are a way of registering memory locations (usually data members) to store field data for a **CMySet** class."},{"content":"Notes","pos":[2553,2558]},{"content":"Recordset field functions are designed to work only with the <ph id=\"ph1\">`CRecordset`</ph> classes.","pos":[2562,2644],"source":"Recordset field functions are designed to work only with the `CRecordset` classes."},{"content":"They are not generally usable by any other MFC classes.","pos":[2645,2700]},{"pos":[2707,2859],"content":"Initial values of data are set in the standard C++ constructor, usually in a block with <ph id=\"ph1\">`//{{AFX_FIELD_INIT(CMylSet)`</ph> and <ph id=\"ph2\">`//}}AFX_FIELD_INIT`</ph> comments.","source":"Initial values of data are set in the standard C++ constructor, usually in a block with `//{{AFX_FIELD_INIT(CMylSet)` and `//}}AFX_FIELD_INIT` comments."},{"pos":[2866,3035],"content":"Each <bpt id=\"p1\">**</bpt>RFX_<ept id=\"p1\">**</ept> function must support various operations, ranging from returning the dirty status of the field to archiving the field in preparation for editing the field.","source":"Each **RFX_** function must support various operations, ranging from returning the dirty status of the field to archiving the field in preparation for editing the field."},{"pos":[3042,3197],"content":"Each function that calls <ph id=\"ph1\">`DoFieldExchange`</ph> (for instance <ph id=\"ph2\">`SetFieldNull`</ph>, <ph id=\"ph3\">`IsFieldDirty`</ph>), does its own initialization around the call to <ph id=\"ph4\">`DoFieldExchange`</ph>.","source":"Each function that calls `DoFieldExchange` (for instance `SetFieldNull`, `IsFieldDirty`), does its own initialization around the call to `DoFieldExchange`."},{"content":"How Does It Work","pos":[3206,3222]},{"content":"You do not need to understand the following in order to use record field exchange.","pos":[3226,3308]},{"content":"However, understanding how this works behind the scenes will help you write your own exchange procedure.","pos":[3309,3413]},{"content":"The <ph id=\"ph1\">`DoFieldExchange`</ph> member function is much like the <ph id=\"ph2\">`Serialize`</ph> member function — it is responsible for getting or setting data to/from an external form (in this case columns from the result of an ODBC query) from/to member data in the class.","pos":[3420,3665],"source":"The `DoFieldExchange` member function is much like the `Serialize` member function — it is responsible for getting or setting data to/from an external form (in this case columns from the result of an ODBC query) from/to member data in the class."},{"content":"The <ph id=\"ph1\">`pFX`</ph> parameter is the context for doing data exchange and is similar to the <ph id=\"ph2\">`CArchive`</ph> parameter to <ph id=\"ph3\">`CObject::Serialize`</ph>.","pos":[3666,3792],"source":" The `pFX` parameter is the context for doing data exchange and is similar to the `CArchive` parameter to `CObject::Serialize`."},{"content":"The <ph id=\"ph1\">`pFX`</ph> (a <ph id=\"ph2\">`CFieldExchange`</ph> object) has an operation indicator, which is similar to, but a generalization of the <ph id=\"ph3\">`CArchive`</ph> direction flag.","pos":[3793,3934],"source":" The `pFX` (a `CFieldExchange` object) has an operation indicator, which is similar to, but a generalization of the `CArchive` direction flag."},{"content":"An RFX function may have to support the following operations:","pos":[3935,3996]},{"pos":[4004,4070],"content":"<bpt id=\"p1\">**</bpt>BindParam<ept id=\"p1\">**</ept> — Indicate where ODBC should retrieve parameter data","source":"**BindParam** — Indicate where ODBC should retrieve parameter data"},{"pos":[4078,4161],"content":"<bpt id=\"p1\">**</bpt>BindFieldToColumn<ept id=\"p1\">**</ept> — Indicate where ODBC must retrieve/deposit outputColumn data","source":"**BindFieldToColumn** — Indicate where ODBC must retrieve/deposit outputColumn data"},{"pos":[4169,4236],"content":"<bpt id=\"p1\">**</bpt>Fixup<ept id=\"p1\">**</ept> — Set <bpt id=\"p2\">**</bpt>CString/CByteArray<ept id=\"p2\">**</ept> lengths, set NULL status bit","source":"**Fixup** — Set **CString/CByteArray** lengths, set NULL status bit"},{"pos":[4244,4313],"content":"<bpt id=\"p1\">**</bpt>MarkForAddNew<ept id=\"p1\">**</ept> — Mark dirty if value has changed since AddNew call","source":"**MarkForAddNew** — Mark dirty if value has changed since AddNew call"},{"pos":[4321,4388],"content":"<bpt id=\"p1\">**</bpt>MarkForUpdate<ept id=\"p1\">**</ept> — Mark dirty if value has changed since Edit call","source":"**MarkForUpdate** — Mark dirty if value has changed since Edit call"},{"pos":[4396,4449],"content":"<bpt id=\"p1\">**</bpt>Name<ept id=\"p1\">**</ept> — Append field names for fields marked dirty","source":"**Name** — Append field names for fields marked dirty"},{"pos":[4457,4521],"content":"<bpt id=\"p1\">**</bpt>NameValue<ept id=\"p1\">**</ept> — Append \"<ph id=\"ph1\">\\&lt;</ph>column name&gt;=\" for fields marked dirty","source":"**NameValue** — Append \"\\<column name>=\" for fields marked dirty"},{"pos":[4529,4589],"content":"<bpt id=\"p1\">**</bpt>Value<ept id=\"p1\">**</ept> — Append \"\" followed by separator, like ',' or ' '","source":"**Value** — Append \"\" followed by separator, like ',' or ' '"},{"pos":[4613,4656],"content":"— Set status bit dirty (i.e. changed) field"},{"pos":[4679,4727],"content":"— Set status bit indicating null value for field"},{"pos":[4750,4784],"content":"— Return value of dirty status bit"},{"pos":[4806,4839],"content":"— Return value of null status bit"},{"pos":[4865,4908],"content":"— Return TRUE if field can hold NULL values"},{"pos":[4916,4952],"content":"<bpt id=\"p1\">**</bpt>StoreField<ept id=\"p1\">**</ept> — Archive field value","source":"**StoreField** — Archive field value"},{"pos":[4960,5003],"content":"<bpt id=\"p1\">**</bpt>LoadField<ept id=\"p1\">**</ept> — Reload archived field value","source":"**LoadField** — Reload archived field value"},{"pos":[5011,5072],"content":"<bpt id=\"p1\">**</bpt>GetFieldInfoValue<ept id=\"p1\">**</ept> — Return general information on a field","source":"**GetFieldInfoValue** — Return general information on a field"},{"pos":[5080,5143],"content":"<bpt id=\"p1\">**</bpt>GetFieldInfoOrdinal<ept id=\"p1\">**</ept> — Return general information on a field","source":"**GetFieldInfoOrdinal** — Return general information on a field"},{"content":"User Extensions","pos":[5152,5167]},{"content":"There are several ways to extend the default RFX mechanism.","pos":[5171,5230]},{"content":"You can","pos":[5231,5238]},{"content":"Add new data types.","pos":[5248,5267]},{"content":"For example:","pos":[5268,5280]},{"content":"Add new exchange procedures (RFX_).","pos":[5322,5357]},{"pos":[5479,5599],"content":"Have the <ph id=\"ph1\">`DoFieldExchange`</ph> member function conditionally include additional RFX calls or any other valid C++ statements.","source":"Have the `DoFieldExchange` member function conditionally include additional RFX calls or any other valid C++ statements."},{"pos":[5775,5891],"content":"[!NOTE]\n Such code cannot be edited by ClassWizard and should be used only outside of the special format comments.","leadings":["","> "],"nodes":[{"content":"Such code cannot be edited by ClassWizard and should be used only outside of the special format comments.","pos":[9,114]}]},{"content":"Writing a Custom RFX","pos":[5900,5920]},{"content":"To write your own Custom RFX function, it is suggested that you copy an existing RFX function and modify it to your own purposes.","pos":[5924,6053]},{"content":"Selecting the right RFX to copy can make your job much easier.","pos":[6054,6116]},{"content":"Some RFX functions have some unique properties that you should take into account when deciding which to copy.","pos":[6117,6226]},{"content":"<bpt id=\"p1\">**</bpt>RFX_Long and RFX_Int<ept id=\"p1\">**</ept>:","pos":[6233,6258],"source":"**RFX_Long and RFX_Int**:"},{"content":"These are the simplest RFX functions.","pos":[6262,6299]},{"content":"The data value does not need any special interpretation, and the data size is fixed.","pos":[6300,6384]},{"content":"<bpt id=\"p1\">**</bpt>RFX_Single and RFX_Double<ept id=\"p1\">**</ept>:","pos":[6391,6421],"source":"**RFX_Single and RFX_Double**:"},{"content":"Like RFX_Long and RFX_Int above, these functions are simple and can make use of the default implementation extensively.","pos":[6425,6544]},{"content":"They are stored in dbflt.cpp instead of dbrfx.cpp, however, to enable loading the runtime floating point library only when they are explicitly reference.","pos":[6545,6698]},{"content":"<bpt id=\"p1\">**</bpt>RFX_Text and RFX_Binary<ept id=\"p1\">**</ept>:","pos":[6705,6733],"source":"**RFX_Text and RFX_Binary**:"},{"content":"These two functions preallocate a static buffer to hold string/binary information, and must register these buffers with ODBC SQLBindCol instead of registering &amp;value.","pos":[6737,6903],"source":" These two functions preallocate a static buffer to hold string/binary information, and must register these buffers with ODBC SQLBindCol instead of registering &value."},{"content":"Because of this, these two functions have lots of special-case code.","pos":[6904,6972]},{"content":":","pos":[6989,6990]},{"content":"ODBC returns date and time information in their own TIMESTAMP_STRUCT data structure.","pos":[6994,7078]},{"content":"This function dynamically allocates a TIMESTAMP_STRUCT as a \"proxy\" for sending and receiving date time data.","pos":[7079,7188]},{"content":"Various operations must transfer the date and time information between the C++ <ph id=\"ph1\">`CTime`</ph> object and the TIMESTAMP_STRUCT proxy.","pos":[7189,7314],"source":" Various operations must transfer the date and time information between the C++ `CTime` object and the TIMESTAMP_STRUCT proxy."},{"content":"This complicates this function considerably, but it is a good example of how to use a proxy for data transfer.","pos":[7315,7425]},{"content":":","pos":[7448,7449]},{"content":"This is the only class library RFX function that does not use column binding to receive and send data.","pos":[7453,7555]},{"content":"This function ignores the BindFieldToColumn operation and instead, during the Fixup operation, allocates storage to hold the incoming SQL_LONGVARCHAR or SQL_LONGVARBINARY data, then performs an SQLGetData call to retrieve the value into the allocated storage.","pos":[7556,7815]},{"content":"When preparing to send data values back to the data source (such as NameValue and Value operations), this function uses ODBC's DATA_AT_EXEC functionality.","pos":[7816,7970]},{"content":"See <bpt id=\"p1\">[</bpt>Technical Note 45<ept id=\"p1\">](../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md)</ept> for more information on working with SQL_LONGVARBINARY and SQL_LONGVARCHARs.","pos":[7971,8136],"source":" See [Technical Note 45](../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md) for more information on working with SQL_LONGVARBINARY and SQL_LONGVARCHARs."},{"content":"When writing your own <bpt id=\"p1\">**</bpt>RFX_<ept id=\"p1\">**</ept> function, you will often be able to use <bpt id=\"p2\">**</bpt>CFieldExchange::Default<ept id=\"p2\">**</ept> to implement a given operation.","pos":[8143,8273],"source":"When writing your own **RFX_** function, you will often be able to use **CFieldExchange::Default** to implement a given operation."},{"content":"Look at the implementation of Default for the operation in question.","pos":[8274,8342]},{"content":"If it performs the operation you would be writing in your <bpt id=\"p1\">**</bpt>RFX_<ept id=\"p1\">**</ept> function you can delegate to the <bpt id=\"p2\">**</bpt>CFieldExchange::Default.<ept id=\"p2\">**</ept>","pos":[8343,8471],"source":" If it performs the operation you would be writing in your **RFX_** function you can delegate to the **CFieldExchange::Default.**"},{"content":"You can see examples of calling <bpt id=\"p1\">**</bpt>CFieldExchange::Default<ept id=\"p1\">**</ept> in dbrfx.cpp","pos":[8472,8544],"source":" You can see examples of calling **CFieldExchange::Default** in dbrfx.cpp"},{"content":"It is important to call <ph id=\"ph1\">`IsFieldType`</ph> at the start of your RFX function, and return immediately if it returns FALSE.","pos":[8551,8667],"source":"It is important to call `IsFieldType` at the start of your RFX function, and return immediately if it returns FALSE."},{"content":"This mechanism keeps parameter operations from being performed on <bpt id=\"p1\">**</bpt>outputColumns<ept id=\"p1\">**</ept>, and vice versa (like calling <bpt id=\"p2\">**</bpt>BindParam<ept id=\"p2\">**</ept> on an <bpt id=\"p3\">**</bpt>outputColumn<ept id=\"p3\">**</ept>).","pos":[8668,8820],"source":" This mechanism keeps parameter operations from being performed on **outputColumns**, and vice versa (like calling **BindParam** on an **outputColumn**)."},{"content":"In addition, <ph id=\"ph1\">`IsFieldType`</ph> automatically keeps track of the count of <bpt id=\"p1\">**</bpt>outputColumns<ept id=\"p1\">**</ept> (<ph id=\"ph2\">`m_nFields`</ph>) and params (<ph id=\"ph3\">`m_nParams`</ph>).","pos":[8821,8947],"source":" In addition, `IsFieldType` automatically keeps track of the count of **outputColumns** (`m_nFields`) and params (`m_nParams`)."},{"content":"See Also","pos":[8956,8964]},{"content":"Technical Notes by Number","pos":[8969,8994]},{"content":"Technical Notes by Category","pos":[9038,9065]}],"content":"---\ntitle: \"TN043: RFX Routines | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"RFX\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"RFX (record field exchange), architecture\"\n  - \"TN043\"\n  - \"RFX (record field exchange)\"\nms.assetid: f552d0c1-2c83-4389-b472-42c9940aa713\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN043: RFX Routines\n> [!NOTE]\n>  The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.  \n  \n This note describes the record field exchange (RFX) architecture. It also describes how you write an **RFX_** procedure.  \n  \n## Overview of Record Field Exchange  \n All recordset field functions are done with C++ code. There are no special resources or magic macros. The heart of the mechanism is a virtual function that must be overridden in every derived recordset class. It is always found in this form:  \n  \n```  \nvoid CMySet::DoFieldExchange(CFieldExchange* pFX)  \n{ *//{{AFX_FIELD_MAP(CMySet)  \n <recordset exchange field type call>  \n <recordset exchange function call> *//}}AFX_FIELD_MAP  \n}  \n```  \n  \n The special format AFX comments allow ClassWizard to locate and edit the code within this function. Code that is not compatible with ClassWizard should be placed outside of the special format comments.  \n  \n In the above example, <recordset_exchange_field_type_call> is in the form:  \n  \n```  \npFX->SetFieldType(CFieldExchange::outputColumn);\n```  \n  \n and <recordset_exchange_function_call> is in the form:  \n  \n```  \nRFX_Custom(pFX, \"Col2\",\n    m_Col2);\n```  \n  \n Most **RFX_** functions have three arguments as shown above, but some (e.g. `RFX_Text` and `RFX_Binary`) have additional optional arguments.  \n  \n More than one **RFX_** may be included in each `DoDataExchange` function.  \n  \n See 'afxdb.h' for a list of all the recordset field exchange routines provided with MFC.  \n  \n Recordset field calls are a way of registering memory locations (usually data members) to store field data for a **CMySet** class.  \n  \n## Notes  \n Recordset field functions are designed to work only with the `CRecordset` classes. They are not generally usable by any other MFC classes.  \n  \n Initial values of data are set in the standard C++ constructor, usually in a block with `//{{AFX_FIELD_INIT(CMylSet)` and `//}}AFX_FIELD_INIT` comments.  \n  \n Each **RFX_** function must support various operations, ranging from returning the dirty status of the field to archiving the field in preparation for editing the field.  \n  \n Each function that calls `DoFieldExchange` (for instance `SetFieldNull`, `IsFieldDirty`), does its own initialization around the call to `DoFieldExchange`.  \n  \n## How Does It Work  \n You do not need to understand the following in order to use record field exchange. However, understanding how this works behind the scenes will help you write your own exchange procedure.  \n  \n The `DoFieldExchange` member function is much like the `Serialize` member function — it is responsible for getting or setting data to/from an external form (in this case columns from the result of an ODBC query) from/to member data in the class. The `pFX` parameter is the context for doing data exchange and is similar to the `CArchive` parameter to `CObject::Serialize`. The `pFX` (a `CFieldExchange` object) has an operation indicator, which is similar to, but a generalization of the `CArchive` direction flag. An RFX function may have to support the following operations:  \n  \n- **BindParam** — Indicate where ODBC should retrieve parameter data  \n  \n- **BindFieldToColumn** — Indicate where ODBC must retrieve/deposit outputColumn data  \n  \n- **Fixup** — Set **CString/CByteArray** lengths, set NULL status bit  \n  \n- **MarkForAddNew** — Mark dirty if value has changed since AddNew call  \n  \n- **MarkForUpdate** — Mark dirty if value has changed since Edit call  \n  \n- **Name** — Append field names for fields marked dirty  \n  \n- **NameValue** — Append \"\\<column name>=\" for fields marked dirty  \n  \n- **Value** — Append \"\" followed by separator, like ',' or ' '  \n  \n- `SetFieldDirty` — Set status bit dirty (i.e. changed) field  \n  \n- `SetFieldNull` — Set status bit indicating null value for field  \n  \n- `IsFieldDirty` — Return value of dirty status bit  \n  \n- `IsFieldNull` — Return value of null status bit  \n  \n- `IsFieldNullable` — Return TRUE if field can hold NULL values  \n  \n- **StoreField** — Archive field value  \n  \n- **LoadField** — Reload archived field value  \n  \n- **GetFieldInfoValue** — Return general information on a field  \n  \n- **GetFieldInfoOrdinal** — Return general information on a field  \n  \n## User Extensions  \n There are several ways to extend the default RFX mechanism. You can  \n  \n-   Add new data types. For example:  \n  \n ```  \n    CBookmark \n ```  \n  \n-   Add new exchange procedures (RFX_).  \n  \n ```  \n    void AFXAPI RFX_Bigint(CFieldExchange* pFX,\n    const char *szName,  \n    BIGINT& value);\n\n ```  \n  \n-   Have the `DoFieldExchange` member function conditionally include additional RFX calls or any other valid C++ statements.  \n  \n ```  \n    while (posExtraFields != NULL)  \n {  \n    RFX_Text(pFX,\n    m_listName.GetNext(posExtraFields),   \n    m_listValue.GetNext(posExtraValues));\n\n }  \n ```  \n  \n> [!NOTE]\n>  Such code cannot be edited by ClassWizard and should be used only outside of the special format comments.  \n  \n## Writing a Custom RFX  \n To write your own Custom RFX function, it is suggested that you copy an existing RFX function and modify it to your own purposes. Selecting the right RFX to copy can make your job much easier. Some RFX functions have some unique properties that you should take into account when deciding which to copy.  \n  \n **RFX_Long and RFX_Int**:  \n These are the simplest RFX functions. The data value does not need any special interpretation, and the data size is fixed.  \n  \n **RFX_Single and RFX_Double**:  \n Like RFX_Long and RFX_Int above, these functions are simple and can make use of the default implementation extensively. They are stored in dbflt.cpp instead of dbrfx.cpp, however, to enable loading the runtime floating point library only when they are explicitly reference.  \n  \n **RFX_Text and RFX_Binary**:  \n These two functions preallocate a static buffer to hold string/binary information, and must register these buffers with ODBC SQLBindCol instead of registering &value. Because of this, these two functions have lots of special-case code.  \n  \n `RFX_Date`:  \n ODBC returns date and time information in their own TIMESTAMP_STRUCT data structure. This function dynamically allocates a TIMESTAMP_STRUCT as a \"proxy\" for sending and receiving date time data. Various operations must transfer the date and time information between the C++ `CTime` object and the TIMESTAMP_STRUCT proxy. This complicates this function considerably, but it is a good example of how to use a proxy for data transfer.  \n  \n `RFX_LongBinary`:  \n This is the only class library RFX function that does not use column binding to receive and send data. This function ignores the BindFieldToColumn operation and instead, during the Fixup operation, allocates storage to hold the incoming SQL_LONGVARCHAR or SQL_LONGVARBINARY data, then performs an SQLGetData call to retrieve the value into the allocated storage. When preparing to send data values back to the data source (such as NameValue and Value operations), this function uses ODBC's DATA_AT_EXEC functionality. See [Technical Note 45](../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md) for more information on working with SQL_LONGVARBINARY and SQL_LONGVARCHARs.  \n  \n When writing your own **RFX_** function, you will often be able to use **CFieldExchange::Default** to implement a given operation. Look at the implementation of Default for the operation in question. If it performs the operation you would be writing in your **RFX_** function you can delegate to the **CFieldExchange::Default.** You can see examples of calling **CFieldExchange::Default** in dbrfx.cpp  \n  \n It is important to call `IsFieldType` at the start of your RFX function, and return immediately if it returns FALSE. This mechanism keeps parameter operations from being performed on **outputColumns**, and vice versa (like calling **BindParam** on an **outputColumn**). In addition, `IsFieldType` automatically keeps track of the count of **outputColumns** (`m_nFields`) and params (`m_nParams`).  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}