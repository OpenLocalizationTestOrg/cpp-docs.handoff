{"nodes":[{"pos":[12,59],"content":"Chained Unwind Info Structures | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Chained Unwind Info Structures | Microsoft Docs","pos":[0,47]}]},{"content":"Chained Unwind Info Structures","pos":[566,596]},{"content":"If the UNW_FLAG_CHAININFO flag is set, then an unwind info structure is a secondary one, and the shared exception-handler/chained-info address field contains the primary unwind information.","pos":[597,786]},{"content":"The following code retrieves the primary unwind information, assuming that <ph id=\"ph1\">`unwindInfo`</ph> is the structure that has the UNW_FLAG_CHAININFO flag set.","pos":[787,933],"source":" The following code retrieves the primary unwind information, assuming that `unwindInfo` is the structure that has the UNW_FLAG_CHAININFO flag set."},{"content":"Chained info is useful in two situations.","pos":[1079,1120]},{"content":"First, it can be used for noncontiguous code segments.","pos":[1121,1175]},{"content":"By using chained info, you can reduce the size of the required unwind information, because you do not have to duplicate the unwind codes array from the primary unwind info.","pos":[1176,1348]},{"content":"You can also use chained info to group volatile register saves.","pos":[1355,1418]},{"content":"The compiler may delay saving some volatile registers until it is outside of the function entry prolog.","pos":[1419,1522]},{"content":"You can record this by having primary unwind info for the portion of the function before the grouped code, and then setting up chained info with a non-zero size of prolog, where the unwind codes in the chained info reflect saves of the nonvolatile registers.","pos":[1523,1781]},{"content":"In that case, the unwind codes are all instances of UWOP_SAVE_NONVOL.","pos":[1782,1851]},{"content":"A grouping that saves nonvolatile registers by using a PUSH or modifies the RSP register by using an additional fixed stack allocation is not supported.","pos":[1852,2004]},{"content":"An UNWIND_INFO item that has UNW_FLAG_CHAININFO set can contain a RUNTIME_FUNCTION entry whose UNWIND_INFO item also has UNW_FLAG_CHAININFO set (multiple shrink-wrapping).","pos":[2011,2182]},{"content":"Eventually, the chained unwind info pointers will arrive at an UNWIND_INFO item that has UNW_FLAG_CHAININFO cleared; this is the primary UNWIND_INFO item, which points to the actual procedure entry point.","pos":[2183,2387]},{"content":"See Also","pos":[2396,2404]},{"content":"Unwind Data for Exception Handling, Debugger Support","pos":[2409,2461]}],"content":"---\ntitle: \"Chained Unwind Info Structures | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 176835bf-f118-45d9-9128-9db4b7571864\ncaps.latest.revision: 14\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Chained Unwind Info Structures\nIf the UNW_FLAG_CHAININFO flag is set, then an unwind info structure is a secondary one, and the shared exception-handler/chained-info address field contains the primary unwind information. The following code retrieves the primary unwind information, assuming that `unwindInfo` is the structure that has the UNW_FLAG_CHAININFO flag set.  \n  \n```  \nPRUNTIME_FUNCTION primaryUwindInfo = (PRUNTIME_FUNCTION)&(unwindInfo->UnwindCode[( unwindInfo->CountOfCodes + 1 ) & ~1]);  \n```  \n  \n Chained info is useful in two situations. First, it can be used for noncontiguous code segments. By using chained info, you can reduce the size of the required unwind information, because you do not have to duplicate the unwind codes array from the primary unwind info.  \n  \n You can also use chained info to group volatile register saves. The compiler may delay saving some volatile registers until it is outside of the function entry prolog. You can record this by having primary unwind info for the portion of the function before the grouped code, and then setting up chained info with a non-zero size of prolog, where the unwind codes in the chained info reflect saves of the nonvolatile registers. In that case, the unwind codes are all instances of UWOP_SAVE_NONVOL. A grouping that saves nonvolatile registers by using a PUSH or modifies the RSP register by using an additional fixed stack allocation is not supported.  \n  \n An UNWIND_INFO item that has UNW_FLAG_CHAININFO set can contain a RUNTIME_FUNCTION entry whose UNWIND_INFO item also has UNW_FLAG_CHAININFO set (multiple shrink-wrapping). Eventually, the chained unwind info pointers will arrive at an UNWIND_INFO item that has UNW_FLAG_CHAININFO cleared; this is the primary UNWIND_INFO item, which points to the actual procedure entry point.  \n  \n## See Also  \n [Unwind Data for Exception Handling, Debugger Support](../build/unwind-data-for-exception-handling-debugger-support.md)"}