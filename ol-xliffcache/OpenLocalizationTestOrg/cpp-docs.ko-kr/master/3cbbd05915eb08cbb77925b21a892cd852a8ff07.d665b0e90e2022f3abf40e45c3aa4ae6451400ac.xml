{"nodes":[{"pos":[12,80],"content":"Specifying Compiler Optimization for an ATL Project | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Specifying Compiler Optimization for an ATL Project | Microsoft Docs","pos":[0,68]}]},{"content":"Specifying Compiler Optimization for an ATL Project","pos":[761,812]},{"pos":[813,956],"content":"By default, the <bpt id=\"p1\">[</bpt>ATL Control Wizard<ept id=\"p1\">](../../atl/reference/atl-control-wizard.md)</ept> generates new classes with the ATL_NO_VTABLE macro, as follows:","source":"By default, the [ATL Control Wizard](../../atl/reference/atl-control-wizard.md) generates new classes with the ATL_NO_VTABLE macro, as follows:"},{"content":"ATL then defines _ATL_NO_VTABLE as follows:","pos":[1026,1069]},{"content":"If you do not define _ATL_DISABLE_NO_VTABLE, the ATL_NO_VTABLE macro expands to <ph id=\"ph1\">`declspec(novtable)`</ph>.","pos":[1211,1312],"source":"If you do not define _ATL_DISABLE_NO_VTABLE, the ATL_NO_VTABLE macro expands to `declspec(novtable)`."},{"content":"Using <ph id=\"ph1\">`declspec(novtable)`</ph>in a class declaration prevents the vtable pointer from being initialized in the class constructor and destructor.","pos":[1313,1453],"source":" Using `declspec(novtable)`in a class declaration prevents the vtable pointer from being initialized in the class constructor and destructor."},{"content":"When you build your project, the linker eliminates the vtable and all functions to which the vtable points.","pos":[1454,1561]},{"content":"You must use ATL_NO_VTABLE, and consequently <ph id=\"ph1\">`declspec(novtable)`</ph>, with only base classes that are not directly creatable.","pos":[1568,1690],"source":"You must use ATL_NO_VTABLE, and consequently `declspec(novtable)`, with only base classes that are not directly creatable."},{"content":"You must not use <ph id=\"ph1\">`declspec(novtable)`</ph> with the most-derived class in your project, because this class (usually <bpt id=\"p1\">[</bpt>CComObject<ept id=\"p1\">](../../atl/reference/ccomobject-class.md)</ept>, <bpt id=\"p2\">[</bpt>CComAggObject<ept id=\"p2\">](../../atl/reference/ccomaggobject-class.md)</ept>, or <bpt id=\"p3\">[</bpt>CComPolyObject<ept id=\"p3\">](../../atl/reference/ccompolyobject-class.md)</ept>) initializes the vtable pointer for your project.","pos":[1691,2032],"source":" You must not use `declspec(novtable)` with the most-derived class in your project, because this class (usually [CComObject](../../atl/reference/ccomobject-class.md), [CComAggObject](../../atl/reference/ccomaggobject-class.md), or [CComPolyObject](../../atl/reference/ccompolyobject-class.md)) initializes the vtable pointer for your project."},{"content":"You must not call virtual functions from the constructor of any object that uses <ph id=\"ph1\">`declspec(novtable)`</ph>.","pos":[2039,2141],"source":"You must not call virtual functions from the constructor of any object that uses `declspec(novtable)`."},{"content":"You should move those calls to the <bpt id=\"p1\">[</bpt>FinalConstruct<ept id=\"p1\">](ccomobjectrootex-class.md#ccomobjectrootex__finalconstruct)</ept> method.","pos":[2142,2261],"source":" You should move those calls to the [FinalConstruct](ccomobjectrootex-class.md#ccomobjectrootex__finalconstruct) method."},{"pos":[2269,2455],"content":"If you are unsure whether you should use the <ph id=\"ph1\">`declspec(novtable)`</ph> modifier, you can remove the ATL_NO_VTABLE macro from any class definition, or you can globally disable it by specifying","source":"If you are unsure whether you should use the `declspec(novtable)` modifier, you can remove the ATL_NO_VTABLE macro from any class definition, or you can globally disable it by specifying"},{"content":"in stdafx.h, before all other ATL header files are included.","pos":[2510,2570]},{"content":"See Also","pos":[2579,2587]},{"content":"ATL Project Wizard","pos":[2592,2610]},{"content":"Visual C++ Project Types","pos":[2660,2684]},{"content":"Creating Desktop Projects By Using Application Wizards","pos":[2730,2784]},{"content":"Programming with ATL and C Run-Time Code","pos":[2860,2900]},{"content":"Fundamentals of ATL COM Objects","pos":[2962,2993]},{"content":"novtable","pos":[3046,3054]},{"content":"Default ATL Project Configurations","pos":[3084,3118]}],"content":"---\ntitle: \"Specifying Compiler Optimization for an ATL Project | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"vc.appwiz.ATL.optimization\"\n  - \"vc.appwiz.ATL.vtable\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"ATL_DISABLE_NO_VTABLE macro\"\n  - \"ATL projects, compiler optimization\"\n  - \"ATL_NO_VTABLE macro\"\nms.assetid: 7f379318-66d5-43dd-a53d-530758d3a228\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Specifying Compiler Optimization for an ATL Project\nBy default, the [ATL Control Wizard](../../atl/reference/atl-control-wizard.md) generates new classes with the ATL_NO_VTABLE macro, as follows:  \n  \n```  \nclass ATL_NO_VTABLE CProjName  \n{  \n ...  \n};  \n```  \n  \n ATL then defines _ATL_NO_VTABLE as follows:  \n  \n```  \n#ifdef _ATL_DISABLE_NO_VTABLE  \n #define ATL_NO_VTABLE  \n#else  \n #define ATL_NO_VTABLE __declspec(novtable)  \n#endif  \n```  \n  \n If you do not define _ATL_DISABLE_NO_VTABLE, the ATL_NO_VTABLE macro expands to `declspec(novtable)`. Using `declspec(novtable)`in a class declaration prevents the vtable pointer from being initialized in the class constructor and destructor. When you build your project, the linker eliminates the vtable and all functions to which the vtable points.  \n  \n You must use ATL_NO_VTABLE, and consequently `declspec(novtable)`, with only base classes that are not directly creatable. You must not use `declspec(novtable)` with the most-derived class in your project, because this class (usually [CComObject](../../atl/reference/ccomobject-class.md), [CComAggObject](../../atl/reference/ccomaggobject-class.md), or [CComPolyObject](../../atl/reference/ccompolyobject-class.md)) initializes the vtable pointer for your project.  \n  \n You must not call virtual functions from the constructor of any object that uses `declspec(novtable)`. You should move those calls to the [FinalConstruct](ccomobjectrootex-class.md#ccomobjectrootex__finalconstruct) method.  \n\n  \n If you are unsure whether you should use the `declspec(novtable)` modifier, you can remove the ATL_NO_VTABLE macro from any class definition, or you can globally disable it by specifying  \n  \n```  \n#define _ATL_DISABLE_NO_VTABLE  \n```  \n  \n in stdafx.h, before all other ATL header files are included.  \n  \n## See Also  \n [ATL Project Wizard](../../atl/reference/atl-project-wizard.md)   \n [Visual C++ Project Types](../../ide/visual-cpp-project-types.md)   \n [Creating Desktop Projects By Using Application Wizards](../../ide/creating-desktop-projects-by-using-application-wizards.md)   \n [Programming with ATL and C Run-Time Code](../../atl/programming-with-atl-and-c-run-time-code.md)   \n [Fundamentals of ATL COM Objects](../../atl/fundamentals-of-atl-com-objects.md)   \n [novtable](../../cpp/novtable.md)   \n [Default ATL Project Configurations](../../atl/reference/default-atl-project-configurations.md)\n\n"}