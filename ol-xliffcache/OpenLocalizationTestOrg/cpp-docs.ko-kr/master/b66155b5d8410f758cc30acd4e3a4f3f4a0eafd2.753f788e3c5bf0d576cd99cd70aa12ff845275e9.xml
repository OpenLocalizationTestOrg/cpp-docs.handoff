{"nodes":[{"pos":[12,49],"content":"Standard Conversions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Standard Conversions | Microsoft Docs","pos":[0,37]}]},{"content":"Standard Conversions","pos":[674,694]},{"content":"The C++ language defines conversions between its fundamental types.","pos":[695,762]},{"content":"It also defines conversions for pointer, reference, and pointer-to-member derived types.","pos":[763,851]},{"content":"These conversions are called \"standard conversions.\"","pos":[852,904]},{"content":"(For more information about types, standard types, and derived types, see <bpt id=\"p1\">[</bpt>Types<ept id=\"p1\">](http://msdn.microsoft.com/en-us/6882ee83-ea32-4373-8d57-c3efbbc15af0)</ept>.)","pos":[905,1058],"source":" (For more information about types, standard types, and derived types, see [Types](http://msdn.microsoft.com/en-us/6882ee83-ea32-4373-8d57-c3efbbc15af0).)"},{"content":"This section discusses the following standard conversions:","pos":[1065,1123]},{"content":"Integral promotions","pos":[1133,1152]},{"content":"Integral conversions","pos":[1162,1182]},{"content":"Floating conversions","pos":[1192,1212]},{"content":"Floating and integral conversions","pos":[1222,1255]},{"content":"Arithmetic conversions","pos":[1265,1287]},{"content":"Pointer conversions","pos":[1297,1316]},{"content":"Reference conversions","pos":[1326,1347]},{"content":"Pointer-to-member conversions","pos":[1357,1386]},{"pos":[1398,1620],"content":"[!NOTE]\n User-defined types can specify their own conversions. Conversion of user-defined types is covered in [Constructors](../cpp/constructors-cpp.md) and [Conversions](../cpp/user-defined-type-conversions-cpp.md).","leadings":["","    > "],"nodes":[{"content":" User-defined types can specify their own conversions. Conversion of user-defined types is covered in [Constructors](../cpp/constructors-cpp.md) and [Conversions](../cpp/user-defined-type-conversions-cpp.md).","pos":[8,216],"nodes":[{"content":"User-defined types can specify their own conversions.","pos":[1,54]},{"content":"Conversion of user-defined types is covered in <bpt id=\"p1\">[</bpt>Constructors<ept id=\"p1\">](../cpp/constructors-cpp.md)</ept> and <bpt id=\"p2\">[</bpt>Conversions<ept id=\"p2\">](../cpp/user-defined-type-conversions-cpp.md)</ept>.","pos":[55,208],"source":" Conversion of user-defined types is covered in [Constructors](../cpp/constructors-cpp.md) and [Conversions](../cpp/user-defined-type-conversions-cpp.md)."}]}]},{"content":"The following code causes conversions (in this example, integral promotions):","pos":[1627,1704]},{"content":"The result of a conversion is an l-value only if it produces a reference type.","pos":[1953,2031]},{"content":"For example, a user-defined conversion declared as <ph id=\"ph1\">`operator int&amp;()`</ph> returns a reference and is an l-value.","pos":[2032,2139],"source":" For example, a user-defined conversion declared as `operator int&()` returns a reference and is an l-value."},{"content":"However, a conversion declared as <ph id=\"ph1\">`operator int()`</ph>returns an object and is not an l-value.","pos":[2140,2230],"source":" However, a conversion declared as `operator int()`returns an object and is not an l-value."},{"content":"Integral promotions","pos":[2239,2258]},{"content":"Objects of an integral type can be converted to another wider integral type (that is, a type that can represent a larger set of values).","pos":[2262,2398]},{"content":"This widening type of conversion is called \"integral promotion.\"","pos":[2399,2463]},{"content":"With integral promotion, you can use the following in an expression wherever another integral type can be used:","pos":[2464,2575]},{"pos":[2585,2636],"content":"Objects, literals, and constants of type <ph id=\"ph1\">`char`</ph> and","source":"Objects, literals, and constants of type `char` and "},{"content":"Enumeration types","pos":[2658,2675]},{"pos":[2691,2701],"content":"bit fields"},{"content":"Enumerators","pos":[2711,2722]},{"content":"C++ promotions are \"value-preserving.\"","pos":[2729,2767]},{"content":"That is, the value after the promotion is guaranteed to be the same as the value before the promotion.","pos":[2768,2870]},{"content":"In value-preserving promotions, objects of shorter integral types (such as bit fields or objects of type <ph id=\"ph1\">`char`</ph>) are promoted to type <ph id=\"ph2\">`int`</ph> if <ph id=\"ph3\">`int`</ph> can represent the full range of the original type.","pos":[2871,3070],"source":" In value-preserving promotions, objects of shorter integral types (such as bit fields or objects of type `char`) are promoted to type `int` if `int` can represent the full range of the original type."},{"content":"If <ph id=\"ph1\">`int`</ph> cannot represent the full range of values, then the object is promoted to type <ph id=\"ph2\">`unsigned int`</ph>.","pos":[3071,3174],"source":" If `int` cannot represent the full range of values, then the object is promoted to type `unsigned int`."},{"content":"Although this strategy is the same as that used by ANSI C, value-preserving conversions do not preserve the \"signedness\" of the object.","pos":[3175,3310]},{"content":"Value-preserving promotions and promotions that preserve signedness normally produce the same results.","pos":[3317,3419]},{"content":"However, they can produce different results if the promoted object is one of the following:","pos":[3420,3511]},{"pos":[3521,3591],"content":"An operand of <bpt id=\"p1\">**</bpt><ph id=\"ph1\">/</ph><ept id=\"p1\">**</ept>, <ph id=\"ph2\">`%`</ph>, <ph id=\"ph3\">`/=`</ph>, <ph id=\"ph4\">`%=`</ph>, <bpt id=\"p2\">**</bpt><ph id=\"ph5\">&lt;</ph><ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt><ph id=\"ph6\">\\&lt;=</ph><ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt><ph id=\"ph7\">&gt;</ph><ept id=\"p4\">**</ept>, or <bpt id=\"p5\">**</bpt><ph id=\"ph8\">&gt;=</ph><ept id=\"p5\">**</ept>","source":"An operand of **/**, `%`, `/=`, `%=`, **<**, **\\<=**, **>**, or **>=**"},{"content":"These operators rely on sign for determining the result.","pos":[3602,3658]},{"content":"Therefore, value-preserving and sign-preserving promotions produce different results when applied to these operands.","pos":[3659,3775]},{"pos":[3785,3822],"content":"The left operand of <bpt id=\"p1\">**</bpt><ph id=\"ph1\">&gt;&gt;</ph><ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt><ph id=\"ph2\">&gt;&gt;=</ph><ept id=\"p2\">**</ept>","source":"The left operand of **>>** or **>>=**"},{"content":"These operators treat signed and unsigned quantities differently when performing a shift operation.","pos":[3833,3932]},{"content":"For signed quantities, shifting a quantity right causes the sign bit to be propagated into the vacated bit positions.","pos":[3933,4050]},{"content":"For unsigned quantities, the vacated bit positions are zero-filled.","pos":[4051,4118]},{"content":"An argument to an overloaded function or operand of an overloaded operator that depends on the signedness of the type of that operand for argument matching.","pos":[4128,4284]},{"content":"(See <bpt id=\"p1\">[</bpt>Overloaded Operators<ept id=\"p1\">](../cpp/operator-overloading.md)</ept> for more about defining overloaded operators.)","pos":[4285,4391],"source":" (See [Overloaded Operators](../cpp/operator-overloading.md) for more about defining overloaded operators.)"},{"content":"Integral conversions","pos":[4400,4420]},{"content":"Integral conversions are performed between integral types.","pos":[4424,4482]},{"content":"The integral types are <ph id=\"ph1\">`char`</ph>, <ph id=\"ph2\">`int`</ph>, and <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> (and the <bpt id=\"p2\">**</bpt>short<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>signed<ept id=\"p3\">**</ept>, and <ph id=\"ph3\">`unsigned`</ph> versions of these types).","pos":[4483,4606],"source":" The integral types are `char`, `int`, and **long** (and the **short**, **signed**, and `unsigned` versions of these types)."},{"content":"Signed to unsigned","pos":[4615,4633]},{"content":"Objects of signed integral types can be converted to corresponding unsigned types.","pos":[4642,4724]},{"content":"When these conversions occur, the actual bit pattern does not change; however, the interpretation of the data changes.","pos":[4725,4843]},{"content":"Consider this code:","pos":[4844,4863]},{"content":"In the preceding example, a <ph id=\"ph1\">`signed short`</ph>, <ph id=\"ph2\">`i`</ph>, is defined and initialized to a negative number.","pos":[5058,5155],"source":"In the preceding example, a `signed short`, `i`, is defined and initialized to a negative number."},{"content":"The expression <ph id=\"ph1\">`(u = i)`</ph> causes <ph id=\"ph2\">`i`</ph> to be converted to an <bpt id=\"p1\">**</bpt>unsigned short<ept id=\"p1\">**</ept> prior to the assignment to <ph id=\"ph3\">`u`</ph>.","pos":[5156,5264],"source":" The expression `(u = i)` causes `i` to be converted to an **unsigned short** prior to the assignment to `u`."},{"content":"Unsigned to signed","pos":[5273,5291]},{"content":"Objects of unsigned integral types can be converted to corresponding signed types.","pos":[5300,5382]},{"content":"However, such a conversion can cause misinterpretation of data if the value of the unsigned object is outside the range representable by the signed type, as demonstrated in the following example:","pos":[5383,5578]},{"content":"In the preceding example, <ph id=\"ph1\">`u`</ph> is an <ph id=\"ph2\">`unsigned`</ph> <bpt id=\"p1\">**</bpt>short<ept id=\"p1\">**</ept> integral object that must be converted to a signed quantity to evaluate the expression <ph id=\"ph3\">`(i = u)`</ph>.","pos":[5760,5914],"source":"In the preceding example, `u` is an `unsigned` **short** integral object that must be converted to a signed quantity to evaluate the expression `(i = u)`."},{"content":"Because its value cannot be properly represented in a <ph id=\"ph1\">`signed short`</ph>, the data is misinterpreted as shown.","pos":[5915,6021],"source":" Because its value cannot be properly represented in a `signed short`, the data is misinterpreted as shown."},{"content":"Floating point conversions","pos":[6030,6056]},{"content":"An object of a floating type can be safely converted to a more precise floating type — that is, the conversion causes no loss of significance.","pos":[6060,6202]},{"content":"For example, conversions from <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept> to <bpt id=\"p2\">**</bpt>double<ept id=\"p2\">**</ept> or from <bpt id=\"p3\">**</bpt>double<ept id=\"p3\">**</ept> to <ph id=\"ph1\">`long double`</ph> are safe, and the value is unchanged.","pos":[6203,6330],"source":" For example, conversions from **float** to **double** or from **double** to `long double` are safe, and the value is unchanged."},{"content":"An object of a floating type can also be converted to a less precise type, if it is in a range representable by that type.","pos":[6337,6459]},{"content":"(See <bpt id=\"p1\">[</bpt>Floating Limits<ept id=\"p1\">](../cpp/floating-limits.md)</ept> for the ranges of floating types.) If the original value cannot be represented precisely, it can be converted to either the next higher or the next lower representable value.","pos":[6460,6684],"source":" (See [Floating Limits](../cpp/floating-limits.md) for the ranges of floating types.) If the original value cannot be represented precisely, it can be converted to either the next higher or the next lower representable value."},{"content":"If no such value exists, the result is undefined.","pos":[6685,6734]},{"content":"Consider the following example:","pos":[6735,6766]},{"content":"The maximum value representable by type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept> is 3.402823466E38 — a much smaller number than 1E300.","pos":[6820,6923],"source":"The maximum value representable by type **float** is 3.402823466E38 — a much smaller number than 1E300."},{"content":"Therefore, the number is converted to infinity, and the result is 1.#INF.","pos":[6924,6997]},{"content":"Conversions between integral and floating point types","pos":[7006,7059]},{"content":"Certain expressions can cause objects of floating type to be converted to integral types, or vice versa.","pos":[7063,7167]},{"content":"When an object of integral type is converted to a floating type and the original value cannot be represented exactly, the result is either the next higher or the next lower representable value.","pos":[7168,7361]},{"content":"When an object of floating type is converted to an integral type, the fractional part is truncated.","pos":[7368,7467]},{"content":"No rounding takes place in the conversion process.","pos":[7468,7518]},{"content":"Truncation means that a number like 1.3 is converted to 1, and –1.3 is converted to –1.","pos":[7519,7606]},{"content":"Arithmetic conversions","pos":[7615,7637]},{"content":"Many binary operators (discussed in <bpt id=\"p1\">[</bpt>Expressions with Binary Operators<ept id=\"p1\">](../cpp/expressions-with-binary-operators.md)</ept>) cause conversions of operands and yield results the same way.","pos":[7641,7820],"source":"Many binary operators (discussed in [Expressions with Binary Operators](../cpp/expressions-with-binary-operators.md)) cause conversions of operands and yield results the same way."},{"content":"The way these operators cause conversions is called \"usual arithmetic conversions.\"","pos":[7821,7904]},{"content":"Arithmetic conversions of operands of different native types are performed as shown in the following table.","pos":[7905,8012]},{"content":"Typedef types behave according to their underlying native types.","pos":[8013,8077]},{"content":"Conditions for Type Conversion","pos":[8087,8117]},{"content":"Conditions Met","pos":[8124,8138]},{"content":"Conversion","pos":[8139,8149]},{"pos":[8196,8238],"content":"Either operand is of type <bpt id=\"p1\">**</bpt>long double<ept id=\"p1\">**</ept>.","source":"Either operand is of type **long double**."},{"pos":[8239,8290],"content":"Other operand is converted to type <bpt id=\"p1\">**</bpt>long double<ept id=\"p1\">**</ept>.","source":"Other operand is converted to type **long double**."},{"pos":[8295,8364],"content":"Preceding condition not met and either operand is of type <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>.","source":"Preceding condition not met and either operand is of type **double**."},{"pos":[8365,8411],"content":"Other operand is converted to type <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>.","source":"Other operand is converted to type **double**."},{"pos":[8416,8485],"content":"Preceding conditions not met and either operand is of type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","source":"Preceding conditions not met and either operand is of type **float**."},{"pos":[8486,8531],"content":"Other operand is converted to type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","source":"Other operand is converted to type **float**."},{"content":"Preceding conditions not met (none of the operands are of floating types).","pos":[8536,8610]},{"content":"Integral promotions are performed on the operands as follows:","pos":[8611,8672]},{"content":"-   If either operand is of type <ph id=\"ph1\">`unsigned`</ph> <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>, the other operand is converted to type <ph id=\"ph2\">`unsigned long`</ph>.","pos":[8685,8794],"source":" -   If either operand is of type `unsigned` **long**, the other operand is converted to type `unsigned long`."},{"content":"-   If preceding condition not met, and if either operand is of type <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> and the other of type <ph id=\"ph1\">`unsigned`</ph> <ph id=\"ph2\">`int`</ph>, both operands are converted to type <ph id=\"ph3\">`unsigned long`</ph>.","pos":[8800,8970],"source":"-   If preceding condition not met, and if either operand is of type **long** and the other of type `unsigned` `int`, both operands are converted to type `unsigned long`."},{"content":"-   If the preceding two conditions are not met, and if either operand is of type <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept>, the other operand is converted to type <bpt id=\"p2\">**</bpt>long<ept id=\"p2\">**</ept>.","pos":[8976,9116],"source":"-   If the preceding two conditions are not met, and if either operand is of type **long**, the other operand is converted to type **long**."},{"content":"-   If the preceding three conditions are not met, and if either operand is of type <ph id=\"ph1\">`unsigned int`</ph>, the other operand is converted to type <ph id=\"ph2\">`unsigned int`</ph>.","pos":[9122,9276],"source":"-   If the preceding three conditions are not met, and if either operand is of type `unsigned int`, the other operand is converted to type `unsigned int`."},{"content":"-   If none of the preceding conditions are met, both operands are converted to type <ph id=\"ph1\">`int`</ph>.","pos":[9282,9373],"source":"-   If none of the preceding conditions are met, both operands are converted to type `int`."},{"content":"The following code illustrates the conversion rules described in the table:","pos":[9381,9456]},{"content":"The first statement in the preceding example shows multiplication of two integral types, <ph id=\"ph1\">`iVal`</ph> and <ph id=\"ph2\">`ulVal`</ph>.","pos":[9795,9903],"source":"The first statement in the preceding example shows multiplication of two integral types, `iVal` and `ulVal`."},{"content":"The condition met is that neither operand is of floating type and one operand is of type <ph id=\"ph1\">`unsigned int`</ph>.","pos":[9904,10008],"source":" The condition met is that neither operand is of floating type and one operand is of type `unsigned int`."},{"content":"Therefore, the other operand, <ph id=\"ph1\">`iVal`</ph>, is converted to type <ph id=\"ph2\">`unsigned int`</ph>.","pos":[10009,10083],"source":" Therefore, the other operand, `iVal`, is converted to type `unsigned int`."},{"content":"The result is assigned to <ph id=\"ph1\">`dVal`</ph>.","pos":[10084,10117],"source":" The result is assigned to `dVal`."},{"content":"The condition met is that one operand is of type <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>; therefore, the <ph id=\"ph1\">`unsigned int`</ph> result of the multiplication is converted to type <bpt id=\"p2\">**</bpt>double<ept id=\"p2\">**</ept>.","pos":[10118,10270],"source":" The condition met is that one operand is of type **double**; therefore, the `unsigned int` result of the multiplication is converted to type **double**."},{"content":"The second statement in the preceding example shows addition of a <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept> and an integral type, <ph id=\"ph1\">`fVal`</ph> and <ph id=\"ph2\">`ulVal`</ph>.","pos":[10277,10394],"source":"The second statement in the preceding example shows addition of a **float** and an integral type, `fVal` and `ulVal`."},{"content":"The <ph id=\"ph1\">`ulVal`</ph> variable is converted to type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept> (third condition in the table).","pos":[10395,10478],"source":" The `ulVal` variable is converted to type **float** (third condition in the table)."},{"content":"The result of the addition is converted to type <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept> (second condition in the table) and assigned to <ph id=\"ph1\">`dVal`</ph>.","pos":[10479,10593],"source":" The result of the addition is converted to type **double** (second condition in the table) and assigned to `dVal`."},{"content":"Pointer conversions","pos":[10602,10621]},{"content":"Pointers can be converted during assignment, initialization, comparison, and other expressions.","pos":[10625,10720]},{"content":"Pointer to classes","pos":[10730,10748]},{"content":"There are two cases in which a pointer to a class can be converted to a pointer to a base class.","pos":[10752,10848]},{"content":"The first case is when the specified base class is accessible and the conversion is unambiguous.","pos":[10855,10951]},{"content":"(See <bpt id=\"p1\">[</bpt>Multiple Base Classes<ept id=\"p1\">](../cpp/multiple-base-classes.md)</ept> for more information about ambiguous base-class references.)","pos":[10952,11074],"source":" (See [Multiple Base Classes](../cpp/multiple-base-classes.md) for more information about ambiguous base-class references.)"},{"content":"Whether a base class is accessible depends on the kind of inheritance used in derivation.","pos":[11081,11170]},{"content":"Consider the inheritance illustrated in the following figure.","pos":[11171,11232]},{"content":"Inheritance graph showing base&amp;#45;class accessibility","pos":[11241,11295],"source":"Inheritance graph showing base&#45;class accessibility"},{"content":"Inheritance Graph for Illustration of Base-Class Accessibility","pos":[11335,11397]},{"content":"The following table shows the base-class accessibility for the situation illustrated in the figure.","pos":[11404,11503]},{"content":"Base-Class Accessibility","pos":[11513,11537]},{"content":"Type of Function","pos":[11544,11560]},{"content":"Derivation","pos":[11561,11571]},{"content":"Conversion from","pos":[11572,11587]},{"content":"B* to A<ph id=\"ph1\">\\*</ph> Legal?","pos":[11600,11616],"source":"B* to A\\* Legal?"},{"content":"External (not class-scoped) function","pos":[11709,11745]},{"content":"Private","pos":[11746,11753]},{"content":"No","pos":[11754,11756]},{"content":"Protected","pos":[11762,11771]},{"content":"No","pos":[11772,11774]},{"content":"Public","pos":[11780,11786]},{"content":"Yes","pos":[11787,11790]},{"content":"B member function (in B scope)","pos":[11795,11825]},{"content":"Private","pos":[11826,11833]},{"content":"Yes","pos":[11834,11837]},{"content":"Protected","pos":[11843,11852]},{"content":"Yes","pos":[11853,11856]},{"content":"Public","pos":[11862,11868]},{"content":"Yes","pos":[11869,11872]},{"content":"C member function (in C scope)","pos":[11877,11907]},{"content":"Private","pos":[11908,11915]},{"content":"No","pos":[11916,11918]},{"content":"Protected","pos":[11924,11933]},{"content":"Yes","pos":[11934,11937]},{"content":"Public","pos":[11943,11949]},{"content":"Yes","pos":[11950,11953]},{"content":"The second case in which a pointer to a class can be converted to a pointer to a base class is when you use an explicit type conversion.","pos":[11961,12097]},{"content":"(See <bpt id=\"p1\">[</bpt>Expressions with Explicit Type Conversions<ept id=\"p1\">](http://msdn.microsoft.com/en-us/060ad6b4-9592-4f3e-8509-a20ac84a85ae)</ept> for more information about explicit type conversions.)","pos":[12098,12272],"source":" (See [Expressions with Explicit Type Conversions](http://msdn.microsoft.com/en-us/060ad6b4-9592-4f3e-8509-a20ac84a85ae) for more information about explicit type conversions.)"},{"content":"The result of such a conversion is a pointer to the \"subobject,\" the portion of the object that is completely described by the base class.","pos":[12279,12417]},{"content":"The following code defines two classes, <ph id=\"ph1\">`A`</ph> and <ph id=\"ph2\">`B`</ph>, where <ph id=\"ph3\">`B`</ph> is derived from <ph id=\"ph4\">`A`</ph>.","pos":[12424,12507],"source":"The following code defines two classes, `A` and `B`, where `B` is derived from `A`."},{"content":"(For more information on inheritance, see <bpt id=\"p1\">[</bpt>Derived Classes<ept id=\"p1\">](../cpp/inheritance-cpp.md)</ept>.) It then defines <ph id=\"ph1\">`bObject`</ph>, an object of type <ph id=\"ph2\">`B`</ph>, and two pointers (<ph id=\"ph3\">`pA`</ph> and <ph id=\"ph4\">`pB`</ph>) that point to the object.","pos":[12508,12705],"source":" (For more information on inheritance, see [Derived Classes](../cpp/inheritance-cpp.md).) It then defines `bObject`, an object of type `B`, and two pointers (`pA` and `pB`) that point to the object."},{"content":"The pointer <ph id=\"ph1\">`pA`</ph> is of type <ph id=\"ph2\">`A *`</ph>, which can be interpreted as meaning \"pointer to an object of type <ph id=\"ph3\">`A`</ph>.\"","pos":[13149,13255],"source":"The pointer `pA` is of type `A *`, which can be interpreted as meaning \"pointer to an object of type `A`.\""},{"content":"Members of <ph id=\"ph1\">`bObject`</ph> <ph id=\"ph2\">`(`</ph>such as <ph id=\"ph3\">`BComponent`</ph> and <ph id=\"ph4\">`BMemberFunc`</ph>) are unique to type <ph id=\"ph5\">`B`</ph> and are therefore inaccessible through <ph id=\"ph6\">`pA`</ph>.","pos":[13256,13387],"source":" Members of `bObject` `(`such as `BComponent` and `BMemberFunc`) are unique to type `B` and are therefore inaccessible through `pA`."},{"content":"The <ph id=\"ph1\">`pA`</ph> pointer allows access only to those characteristics (member functions and data) of the object that are defined in class <ph id=\"ph2\">`A`</ph>.","pos":[13388,13521],"source":" The `pA` pointer allows access only to those characteristics (member functions and data) of the object that are defined in class `A`."},{"content":"Pointer to function","pos":[13531,13550]},{"pos":[13554,13673],"content":"A pointer to a function can be converted to type <bpt id=\"p1\">**</bpt>void <ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept>, if type <bpt id=\"p2\">**</bpt>void <ph id=\"ph2\">\\*</ph><ept id=\"p2\">**</ept> is large enough to hold that pointer.","source":"A pointer to a function can be converted to type **void \\***, if type **void \\*** is large enough to hold that pointer."},{"content":"Pointer to void","pos":[13683,13698]},{"content":"Pointers to type <ph id=\"ph1\">`void`</ph> can be converted to pointers to any other type, but only with an explicit type cast (unlike in C).","pos":[13702,13824],"source":"Pointers to type `void` can be converted to pointers to any other type, but only with an explicit type cast (unlike in C)."},{"content":"(See <bpt id=\"p1\">[</bpt>Expressions with Explicit Type Conversions<ept id=\"p1\">](http://msdn.microsoft.com/en-us/060ad6b4-9592-4f3e-8509-a20ac84a85ae)</ept> for more information about type casts.) A pointer to any type can be converted implicitly to a pointer to type <ph id=\"ph1\">`void`</ph>.A pointer to an incomplete object of a type can be converted to a pointer to <ph id=\"ph2\">`void`</ph> (implicitly) and back (explicitly).","pos":[13825,14182],"source":" (See [Expressions with Explicit Type Conversions](http://msdn.microsoft.com/en-us/060ad6b4-9592-4f3e-8509-a20ac84a85ae) for more information about type casts.) A pointer to any type can be converted implicitly to a pointer to type `void`.A pointer to an incomplete object of a type can be converted to a pointer to `void` (implicitly) and back (explicitly)."},{"content":"The result of such a conversion is equal to the value of the original pointer.","pos":[14183,14261]},{"content":"An object is considered incomplete if it is declared, but there is insufficient information available to determine its size or base class.","pos":[14262,14400]},{"pos":[14407,14528],"content":"A pointer to any object that is not <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph> can be implicitly converted to a pointer of type <bpt id=\"p2\">**</bpt>void <ph id=\"ph2\">\\*</ph><ept id=\"p2\">**</ept>.","source":"A pointer to any object that is not **const** or `volatile` can be implicitly converted to a pointer of type **void \\***."},{"content":"const and volatile pointers","pos":[14538,14565]},{"content":"C++ does not supply a standard conversion from a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`volatile`</ph> type to a type that is not <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> or <ph id=\"ph2\">`volatile`</ph>.","pos":[14569,14693],"source":"C++ does not supply a standard conversion from a **const** or `volatile` type to a type that is not **const** or `volatile`."},{"content":"However, any sort of conversion can be specified using explicit type casts (including conversions that are unsafe).","pos":[14694,14809]},{"pos":[14817,15066],"content":"[!NOTE]\n C++ pointers to members, except pointers to static members, are different from normal pointers and do not have the same standard conversions. Pointers to static members are normal pointers and have the same conversions as normal pointers.","leadings":["","> "],"nodes":[{"content":" C++ pointers to members, except pointers to static members, are different from normal pointers and do not have the same standard conversions. Pointers to static members are normal pointers and have the same conversions as normal pointers.","pos":[8,247],"nodes":[{"content":"C++ pointers to members, except pointers to static members, are different from normal pointers and do not have the same standard conversions.","pos":[1,142]},{"content":"Pointers to static members are normal pointers and have the same conversions as normal pointers.","pos":[143,239]}]}]},{"content":"null pointer conversions","pos":[15077,15101]},{"content":"An integral constant expression that evaluates to zero, or such an expression cast to a pointer type, is converted to a pointer called the \"null pointer.\"","pos":[15105,15259]},{"content":"This pointer is guaranteed to compare unequal to a pointer to any valid object or function (except for pointers to based objects, which can have the same offset and still point to different objects).","pos":[15260,15459]},{"pos":[15466,15561],"content":"In C++11 the <bpt id=\"p1\">[</bpt>nullptr<ept id=\"p1\">](../cpp/nullptr.md)</ept> type should be preferred to the C-style null pointer.","source":"In C++11 the [nullptr](../cpp/nullptr.md) type should be preferred to the C-style null pointer."},{"content":"Pointer expression conversions","pos":[15571,15601]},{"content":"Any expression with an array type can be converted to a pointer of the same type.","pos":[15605,15686]},{"content":"The result of the conversion is a pointer to the first array element.","pos":[15687,15756]},{"content":"The following example demonstrates such a conversion:","pos":[15757,15810]},{"content":"An expression that results in a function returning a particular type is converted to a pointer to a function returning that type, except when:","pos":[15929,16071]},{"pos":[16081,16153],"content":"The expression is used as an operand to the address-of operator (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p1\">**</ept>).","source":"The expression is used as an operand to the address-of operator (**&**)."},{"content":"The expression is used as an operand to the function-call operator.","pos":[16163,16230]},{"content":"Reference conversions","pos":[16239,16260]},{"content":"A reference to a class can be converted to a reference to a base class in the following cases:","pos":[16264,16358]},{"content":"The specified base class is accessible.","pos":[16368,16407]},{"content":"The conversion is unambiguous.","pos":[16417,16447]},{"content":"(See <bpt id=\"p1\">[</bpt>Multiple Base Classes<ept id=\"p1\">](../cpp/multiple-base-classes.md)</ept> for more information about ambiguous base-class references.)","pos":[16448,16570],"source":" (See [Multiple Base Classes](../cpp/multiple-base-classes.md) for more information about ambiguous base-class references.)"},{"content":"The result of the conversion is a pointer to the subobject that represents the base class.","pos":[16577,16667]},{"content":"Pointer to member","pos":[16676,16693]},{"content":"Pointers to class members can be converted during assignment, initialization, comparison, and other expressions.","pos":[16697,16809]},{"content":"This section describes the following pointer-to-member conversions:","pos":[16810,16877]},{"content":"Pointer to base class member","pos":[16886,16914]},{"content":"A pointer to a member of a base class can be converted to a pointer to a member of a class derived from it, when the following conditions are met:","pos":[16918,17064]},{"content":"The inverse conversion, from pointer to derived class to base-class pointer, is accessible.","pos":[17074,17165]},{"content":"The derived class does not inherit virtually from the base class.","pos":[17175,17240]},{"content":"When the left operand is a pointer to member, the right operand must be of pointer-to-member type or be a constant expression that evaluates to 0.","pos":[17247,17393]},{"content":"This assignment is valid only in the following cases:","pos":[17394,17447]},{"content":"The right operand is a pointer to a member of the same class as the left operand.","pos":[17457,17538]},{"content":"The left operand is a pointer to a member of a class derived publicly and unambiguously from the class of the right operand.","pos":[17548,17672]},{"content":"Integral constant conversions","pos":[17681,17710]},{"content":"An integral constant expression that evaluates to zero is converted to a pointer called the \"null pointer.\"","pos":[17714,17821]},{"content":"This pointer is guaranteed to compare unequal to a pointer to any valid object or function (except for pointers to based objects, which can have the same offset and still point to different objects).","pos":[17822,18021]},{"content":"The following code illustrates the definition of a pointer to member <ph id=\"ph1\">`i`</ph> in class <ph id=\"ph2\">`A`</ph>.","pos":[18028,18114],"source":"The following code illustrates the definition of a pointer to member `i` in class `A`."},{"content":"The pointer, <ph id=\"ph1\">`pai`</ph>, is initialized to 0, which is the null pointer.","pos":[18115,18182],"source":" The pointer, `pai`, is initialized to 0, which is the null pointer."},{"content":"See Also","pos":[18291,18299]},{"content":"C++ Language Reference","pos":[18304,18326]}],"content":"---\ntitle: \"Standard Conversions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"standard conversions, categories of\"\n  - \"L-values\"\n  - \"conversions, standard\"\nms.assetid: ce7ac8d3-5c99-4674-8229-0672de05528d\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Standard Conversions\nThe C++ language defines conversions between its fundamental types. It also defines conversions for pointer, reference, and pointer-to-member derived types. These conversions are called \"standard conversions.\" (For more information about types, standard types, and derived types, see [Types](http://msdn.microsoft.com/en-us/6882ee83-ea32-4373-8d57-c3efbbc15af0).)  \n  \n This section discusses the following standard conversions:  \n  \n-   Integral promotions  \n  \n-   Integral conversions  \n  \n-   Floating conversions  \n  \n-   Floating and integral conversions  \n  \n-   Arithmetic conversions  \n  \n-   Pointer conversions  \n  \n-   Reference conversions  \n  \n-   Pointer-to-member conversions  \n  \n    > [!NOTE]\n    >  User-defined types can specify their own conversions. Conversion of user-defined types is covered in [Constructors](../cpp/constructors-cpp.md) and [Conversions](../cpp/user-defined-type-conversions-cpp.md).  \n  \n The following code causes conversions (in this example, integral promotions):  \n  \n```  \nlong  long_num1, long_num2;  \nint   int_num;  \n  \n// int_num promoted to type long prior to assignment.  \nlong_num1 = int_num;  \n  \n// int_num promoted to type long prior to multiplication.  \nlong_num2 = int_num * long_num2;  \n```  \n  \n The result of a conversion is an l-value only if it produces a reference type. For example, a user-defined conversion declared as `operator int&()` returns a reference and is an l-value. However, a conversion declared as `operator int()`returns an object and is not an l-value.  \n  \n## Integral promotions  \n Objects of an integral type can be converted to another wider integral type (that is, a type that can represent a larger set of values). This widening type of conversion is called \"integral promotion.\" With integral promotion, you can use the following in an expression wherever another integral type can be used:  \n  \n-   Objects, literals, and constants of type `char` and `short int`  \n  \n-   Enumeration types  \n  \n-   `int` bit fields  \n  \n-   Enumerators  \n  \n C++ promotions are \"value-preserving.\" That is, the value after the promotion is guaranteed to be the same as the value before the promotion. In value-preserving promotions, objects of shorter integral types (such as bit fields or objects of type `char`) are promoted to type `int` if `int` can represent the full range of the original type. If `int` cannot represent the full range of values, then the object is promoted to type `unsigned int`. Although this strategy is the same as that used by ANSI C, value-preserving conversions do not preserve the \"signedness\" of the object.  \n  \n Value-preserving promotions and promotions that preserve signedness normally produce the same results. However, they can produce different results if the promoted object is one of the following:  \n  \n-   An operand of **/**, `%`, `/=`, `%=`, **<**, **\\<=**, **>**, or **>=**  \n  \n     These operators rely on sign for determining the result. Therefore, value-preserving and sign-preserving promotions produce different results when applied to these operands.  \n  \n-   The left operand of **>>** or **>>=**  \n  \n     These operators treat signed and unsigned quantities differently when performing a shift operation. For signed quantities, shifting a quantity right causes the sign bit to be propagated into the vacated bit positions. For unsigned quantities, the vacated bit positions are zero-filled.  \n  \n-   An argument to an overloaded function or operand of an overloaded operator that depends on the signedness of the type of that operand for argument matching. (See [Overloaded Operators](../cpp/operator-overloading.md) for more about defining overloaded operators.)  \n  \n## Integral conversions  \n Integral conversions are performed between integral types. The integral types are `char`, `int`, and **long** (and the **short**, **signed**, and `unsigned` versions of these types).  \n  \n **Signed to unsigned**  \n  \n Objects of signed integral types can be converted to corresponding unsigned types. When these conversions occur, the actual bit pattern does not change; however, the interpretation of the data changes. Consider this code:  \n  \n```  \n  \n#include <iostream>  \n  \nusing namespace std;  \nint main()  \n{  \n    short  i = -3;  \n    unsigned short u;  \n  \n    cout << (u = i) << \"\\n\";  \n}  \n// Output: 65533  \n  \n```  \n  \n In the preceding example, a `signed short`, `i`, is defined and initialized to a negative number. The expression `(u = i)` causes `i` to be converted to an **unsigned short** prior to the assignment to `u`.  \n  \n **Unsigned to signed**  \n  \n Objects of unsigned integral types can be converted to corresponding signed types. However, such a conversion can cause misinterpretation of data if the value of the unsigned object is outside the range representable by the signed type, as demonstrated in the following example:  \n  \n```  \n  \n#include <iostream>  \n  \nusing namespace std;  \nint main()  \n{  \n short  i;  \n unsigned short u = 65533;  \n  \n cout << (i = u) << \"\\n\";  \n}  \n//Output: -3  \n```  \n  \n In the preceding example, `u` is an `unsigned` **short** integral object that must be converted to a signed quantity to evaluate the expression `(i = u)`. Because its value cannot be properly represented in a `signed short`, the data is misinterpreted as shown.  \n  \n## Floating point conversions  \n An object of a floating type can be safely converted to a more precise floating type — that is, the conversion causes no loss of significance. For example, conversions from **float** to **double** or from **double** to `long double` are safe, and the value is unchanged.  \n  \n An object of a floating type can also be converted to a less precise type, if it is in a range representable by that type. (See [Floating Limits](../cpp/floating-limits.md) for the ranges of floating types.) If the original value cannot be represented precisely, it can be converted to either the next higher or the next lower representable value. If no such value exists, the result is undefined. Consider the following example:  \n  \n```  \ncout << (float)1E300 << endl;  \n```  \n  \n The maximum value representable by type **float** is 3.402823466E38 — a much smaller number than 1E300. Therefore, the number is converted to infinity, and the result is 1.#INF.  \n  \n## Conversions between integral and floating point types  \n Certain expressions can cause objects of floating type to be converted to integral types, or vice versa. When an object of integral type is converted to a floating type and the original value cannot be represented exactly, the result is either the next higher or the next lower representable value.  \n  \n When an object of floating type is converted to an integral type, the fractional part is truncated. No rounding takes place in the conversion process. Truncation means that a number like 1.3 is converted to 1, and –1.3 is converted to –1.  \n  \n## Arithmetic conversions  \n Many binary operators (discussed in [Expressions with Binary Operators](../cpp/expressions-with-binary-operators.md)) cause conversions of operands and yield results the same way. The way these operators cause conversions is called \"usual arithmetic conversions.\" Arithmetic conversions of operands of different native types are performed as shown in the following table. Typedef types behave according to their underlying native types.  \n  \n### Conditions for Type Conversion  \n  \n|Conditions Met|Conversion|  \n|--------------------|----------------|  \n|Either operand is of type **long double**.|Other operand is converted to type **long double**.|  \n|Preceding condition not met and either operand is of type **double**.|Other operand is converted to type **double**.|  \n|Preceding conditions not met and either operand is of type **float**.|Other operand is converted to type **float**.|  \n|Preceding conditions not met (none of the operands are of floating types).|Integral promotions are performed on the operands as follows:<br /><br /> -   If either operand is of type `unsigned` **long**, the other operand is converted to type `unsigned long`.<br />-   If preceding condition not met, and if either operand is of type **long** and the other of type `unsigned` `int`, both operands are converted to type `unsigned long`.<br />-   If the preceding two conditions are not met, and if either operand is of type **long**, the other operand is converted to type **long**.<br />-   If the preceding three conditions are not met, and if either operand is of type `unsigned int`, the other operand is converted to type `unsigned int`.<br />-   If none of the preceding conditions are met, both operands are converted to type `int`.|  \n  \n The following code illustrates the conversion rules described in the table:  \n  \n```  \n  \ndouble dVal;  \nfloat fVal;  \nint iVal;  \nunsigned long ulVal;  \n  \nint main() {  \n   // iVal converted to unsigned long  \n   // result of multiplication converted to double  \n   dVal = iVal * ulVal;  \n  \n   // ulVal converted to float  \n   // result of addition converted to double  \n   dVal = ulVal + fVal;  \n}  \n```  \n  \n The first statement in the preceding example shows multiplication of two integral types, `iVal` and `ulVal`. The condition met is that neither operand is of floating type and one operand is of type `unsigned int`. Therefore, the other operand, `iVal`, is converted to type `unsigned int`. The result is assigned to `dVal`. The condition met is that one operand is of type **double**; therefore, the `unsigned int` result of the multiplication is converted to type **double**.  \n  \n The second statement in the preceding example shows addition of a **float** and an integral type, `fVal` and `ulVal`. The `ulVal` variable is converted to type **float** (third condition in the table). The result of the addition is converted to type **double** (second condition in the table) and assigned to `dVal`.  \n  \n## Pointer conversions  \n Pointers can be converted during assignment, initialization, comparison, and other expressions.  \n  \n### Pointer to classes  \n There are two cases in which a pointer to a class can be converted to a pointer to a base class.  \n  \n The first case is when the specified base class is accessible and the conversion is unambiguous. (See [Multiple Base Classes](../cpp/multiple-base-classes.md) for more information about ambiguous base-class references.)  \n  \n Whether a base class is accessible depends on the kind of inheritance used in derivation. Consider the inheritance illustrated in the following figure.  \n  \n ![Inheritance graph showing base&#45;class accessibility](../cpp/media/vc38xa1.gif \"vc38XA1\")  \nInheritance Graph for Illustration of Base-Class Accessibility  \n  \n The following table shows the base-class accessibility for the situation illustrated in the figure.  \n  \n### Base-Class Accessibility  \n  \n|Type of Function|Derivation|Conversion from<br /><br /> B* to A\\* Legal?|  \n|----------------------|----------------|-------------------------------------------|  \n|External (not class-scoped) function|Private|No|  \n||Protected|No|  \n||Public|Yes|  \n|B member function (in B scope)|Private|Yes|  \n||Protected|Yes|  \n||Public|Yes|  \n|C member function (in C scope)|Private|No|  \n||Protected|Yes|  \n||Public|Yes|  \n  \n The second case in which a pointer to a class can be converted to a pointer to a base class is when you use an explicit type conversion. (See [Expressions with Explicit Type Conversions](http://msdn.microsoft.com/en-us/060ad6b4-9592-4f3e-8509-a20ac84a85ae) for more information about explicit type conversions.)  \n  \n The result of such a conversion is a pointer to the \"subobject,\" the portion of the object that is completely described by the base class.  \n  \n The following code defines two classes, `A` and `B`, where `B` is derived from `A`. (For more information on inheritance, see [Derived Classes](../cpp/inheritance-cpp.md).) It then defines `bObject`, an object of type `B`, and two pointers (`pA` and `pB`) that point to the object.  \n  \n```  \n// C2039 expected  \nclass A  \n{  \npublic:  \n    int AComponent;  \n    int AMemberFunc();  \n};  \n  \nclass B : public A  \n{  \npublic:  \n    int BComponent;  \n    int BMemberFunc();  \n};  \nint main()  \n{  \n   B bObject;  \n   A *pA = &bObject;  \n   B *pB = &bObject;  \n  \n   pA->AMemberFunc();   // OK in class A  \n   pB->AMemberFunc();   // OK: inherited from class A  \n   pA->BMemberFunc();   // Error: not in class A  \n}  \n```  \n  \n The pointer `pA` is of type `A *`, which can be interpreted as meaning \"pointer to an object of type `A`.\" Members of `bObject` `(`such as `BComponent` and `BMemberFunc`) are unique to type `B` and are therefore inaccessible through `pA`. The `pA` pointer allows access only to those characteristics (member functions and data) of the object that are defined in class `A`.  \n  \n### Pointer to function  \n A pointer to a function can be converted to type **void \\***, if type **void \\*** is large enough to hold that pointer.  \n  \n### Pointer to void  \n Pointers to type `void` can be converted to pointers to any other type, but only with an explicit type cast (unlike in C). (See [Expressions with Explicit Type Conversions](http://msdn.microsoft.com/en-us/060ad6b4-9592-4f3e-8509-a20ac84a85ae) for more information about type casts.) A pointer to any type can be converted implicitly to a pointer to type `void`.A pointer to an incomplete object of a type can be converted to a pointer to `void` (implicitly) and back (explicitly). The result of such a conversion is equal to the value of the original pointer. An object is considered incomplete if it is declared, but there is insufficient information available to determine its size or base class.  \n  \n A pointer to any object that is not **const** or `volatile` can be implicitly converted to a pointer of type **void \\***.  \n  \n### const and volatile pointers  \n C++ does not supply a standard conversion from a **const** or `volatile` type to a type that is not **const** or `volatile`. However, any sort of conversion can be specified using explicit type casts (including conversions that are unsafe).  \n  \n> [!NOTE]\n>  C++ pointers to members, except pointers to static members, are different from normal pointers and do not have the same standard conversions. Pointers to static members are normal pointers and have the same conversions as normal pointers.   \n  \n### null pointer conversions  \n An integral constant expression that evaluates to zero, or such an expression cast to a pointer type, is converted to a pointer called the \"null pointer.\" This pointer is guaranteed to compare unequal to a pointer to any valid object or function (except for pointers to based objects, which can have the same offset and still point to different objects).  \n  \n In C++11 the [nullptr](../cpp/nullptr.md) type should be preferred to the C-style null pointer.  \n  \n### Pointer expression conversions  \n Any expression with an array type can be converted to a pointer of the same type. The result of the conversion is a pointer to the first array element. The following example demonstrates such a conversion:  \n  \n```  \nchar szPath[_MAX_PATH]; // Array of type char.  \nchar *pszPath = szPath; // Equals &szPath[0].  \n```  \n  \n An expression that results in a function returning a particular type is converted to a pointer to a function returning that type, except when:  \n  \n-   The expression is used as an operand to the address-of operator (**&**).  \n  \n-   The expression is used as an operand to the function-call operator.  \n  \n## Reference conversions  \n A reference to a class can be converted to a reference to a base class in the following cases:  \n  \n-   The specified base class is accessible.  \n  \n-   The conversion is unambiguous. (See [Multiple Base Classes](../cpp/multiple-base-classes.md) for more information about ambiguous base-class references.)  \n  \n The result of the conversion is a pointer to the subobject that represents the base class.  \n  \n## Pointer to member  \n Pointers to class members can be converted during assignment, initialization, comparison, and other expressions. This section describes the following pointer-to-member conversions:  \n  \n## Pointer to base class member  \n A pointer to a member of a base class can be converted to a pointer to a member of a class derived from it, when the following conditions are met:  \n  \n-   The inverse conversion, from pointer to derived class to base-class pointer, is accessible.  \n  \n-   The derived class does not inherit virtually from the base class.  \n  \n When the left operand is a pointer to member, the right operand must be of pointer-to-member type or be a constant expression that evaluates to 0. This assignment is valid only in the following cases:  \n  \n-   The right operand is a pointer to a member of the same class as the left operand.  \n  \n-   The left operand is a pointer to a member of a class derived publicly and unambiguously from the class of the right operand.  \n  \n## Integral constant conversions  \n An integral constant expression that evaluates to zero is converted to a pointer called the \"null pointer.\" This pointer is guaranteed to compare unequal to a pointer to any valid object or function (except for pointers to based objects, which can have the same offset and still point to different objects).  \n  \n The following code illustrates the definition of a pointer to member `i` in class `A`. The pointer, `pai`, is initialized to 0, which is the null pointer.  \n  \n```  \nclass A  \n{  \npublic:  \n int i;  \n};  \n  \nint A::*pai = 0;  \n  \nint main()  \n{  \n}  \n```  \n  \n## See Also  \n [C++ Language Reference](../cpp/cpp-language-reference.md)"}