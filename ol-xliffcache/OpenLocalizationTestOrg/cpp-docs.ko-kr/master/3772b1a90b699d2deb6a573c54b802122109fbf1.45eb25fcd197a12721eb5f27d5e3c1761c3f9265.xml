{"nodes":[{"pos":[12,53],"content":"&lt;string&gt; operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"string<ph id=\"ph1\">&amp;gt;</ph> operators | Microsoft Docs","pos":[4,41],"source":"string&gt; operators | Microsoft Docs"}]},{"content":"string<ph id=\"ph1\">&amp;gt;</ph> operators","pos":[260,280],"source":"string&gt; operators"},{"content":"operator!=","pos":[300,310]},{"content":"operator","pos":[328,336]},{"content":"operator","pos":[358,366]},{"content":"operator","pos":[400,408]},{"content":"operator","pos":[434,442]},{"content":"operator","pos":[464,472]},{"content":"operator","pos":[506,514]},{"content":"operator+","pos":[540,549]},{"content":"operator==","pos":[567,577]},{"pos":[635,644],"content":"operator+"},{"content":"Concatenates two string objects.","pos":[648,680]},{"content":"Parameters","pos":[3266,3276]},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be concatenated.","pos":[3291,3363],"source":" A C-style string or an object of type `basic_string` to be concatenated."},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be concatenated.","pos":[3382,3454],"source":" A C-style string or an object of type `basic_string` to be concatenated."},{"content":"Return Value","pos":[3464,3476]},{"content":"The string that is the concatenation of the input strings.","pos":[3480,3538]},{"content":"Remarks","pos":[3548,3555]},{"content":"The functions each overload <ph id=\"ph1\">`operator+`</ph> to concatenate two objects of template class <bpt id=\"p1\">[</bpt>basic_string Class<ept id=\"p1\">](../standard-library/basic-string-class.md)</ept>.","pos":[3559,3708],"source":"The functions each overload `operator+` to concatenate two objects of template class [basic_string Class](../standard-library/basic-string-class.md)."},{"content":"All effectively return <ph id=\"ph1\">`basic_string`\\&lt;</ph> <bpt id=\"p1\">**</bpt>CharType<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Traits<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>Allocator<ept id=\"p3\">**</ept>&gt;(_ <bpt id=\"p4\">*</bpt>Left<ept id=\"p4\">*</ept>).","pos":[3709,3800],"source":" All effectively return `basic_string`\\< **CharType**, **Traits**, **Allocator**>(_ *Left*)."},{"content":"<bpt id=\"p1\">[</bpt>append<ept id=\"p1\">](../standard-library/basic-string-class.md#basic_string__append)</ept>(<ph id=\"ph1\">\\_</ph> <bpt id=\"p2\">*</bpt>Right<ept id=\"p2\">*</ept>).","pos":[3801,3886],"source":"[append](../standard-library/basic-string-class.md#basic_string__append)(\\_ *Right*)."},{"content":"Example","pos":[3896,3903]},{"pos":[5569,5579],"content":"operator!="},{"content":"Tests if the string object on the left side of the operator is not equal to the string object on the right side.","pos":[5583,5695]},{"content":"Parameters","pos":[6243,6253]},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[6268,6336],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[6355,6423],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"Return Value","pos":[6433,6445]},{"pos":[6449,6603],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the string object on the left side of the operator is not lexicographically equal to the string object on the right side; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if the string object on the left side of the operator is not lexicographically equal to the string object on the right side; otherwise **false**."},{"content":"Remarks","pos":[6613,6620]},{"content":"The comparison between string objects is based on a pairwise lexicographical comparison of their characters.","pos":[6624,6732]},{"content":"Two strings are equal if they have the same number of characters and their respective character values are the same.","pos":[6733,6849]},{"content":"Otherwise, they are unequal.","pos":[6850,6878]},{"content":"Example","pos":[6888,6895]},{"pos":[8554,8564],"content":"operator=="},{"content":"Tests if the string object on the left side of the operator is equal to the string object on the right side.","pos":[8568,8676]},{"content":"Parameters","pos":[9228,9238]},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[9253,9321],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[9340,9408],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"Return Value","pos":[9418,9430]},{"pos":[9434,9584],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the string object on the left side of the operator is lexicographically equal to the string object on the right side; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if the string object on the left side of the operator is lexicographically equal to the string object on the right side; otherwise **false**."},{"content":"Remarks","pos":[9594,9601]},{"content":"The comparison between string objects is based on a pairwise lexicographical comparison of their characters.","pos":[9605,9713]},{"content":"Two strings are equal if they have the same number of characters and their respective character values are the same.","pos":[9714,9830]},{"content":"Otherwise, they are unequal.","pos":[9831,9859]},{"content":"Example","pos":[9869,9876]},{"pos":[11533,11541],"content":"operator"},{"content":"Tests if the string object on the left side of the operator is less than to the string object on the right side.","pos":[11549,11661]},{"content":"Parameters","pos":[12210,12220]},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[12235,12303],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[12322,12390],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"Return Value","pos":[12400,12412]},{"pos":[12416,12567],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the string object on the left side of the operator is lexicographically less than the string object on the right side; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if the string object on the left side of the operator is lexicographically less than the string object on the right side; otherwise **false**."},{"content":"Remarks","pos":[12577,12584]},{"content":"A lexicographical comparison between strings compares them character by character until:","pos":[12588,12676]},{"content":"It finds two corresponding characters unequal, and the result of their comparison is taken as the result of the comparison between the strings.","pos":[12686,12829]},{"content":"It finds no inequalities, but one string has more characters than the other, and the shorter string is considered less than the longer string.","pos":[12839,12981]},{"content":"It finds no inequalities and finds that the strings have the same number of characters, and so the strings are equal.","pos":[12991,13108]},{"content":"Example","pos":[13118,13125]},{"pos":[14877,14885],"content":"operator"},{"content":"Tests if the string object on the left side of the operator is less than or equal to the string object on the right side.","pos":[14894,15015]},{"content":"Parameters","pos":[15567,15577]},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[15592,15660],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[15679,15747],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"Return Value","pos":[15757,15769]},{"pos":[15773,15936],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the string object on the left side of the operator is lexicographically less than or equal to the string object on the right side; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if the string object on the left side of the operator is lexicographically less than or equal to the string object on the right side; otherwise **false**."},{"content":"Remarks","pos":[15946,15953]},{"content":"A lexicographical comparison between strings compares them character by character until:","pos":[15957,16045]},{"content":"It finds two corresponding characters unequal, and the result of their comparison is taken as the result of the comparison between the strings.","pos":[16055,16198]},{"content":"It finds no inequalities, but one string has more characters than the other, and the shorter string is considered less than the longer string.","pos":[16208,16350]},{"content":"It finds no inequalities and finds that the strings have the same number of characters, so the strings are equal.","pos":[16360,16473]},{"content":"Example","pos":[16483,16490]},{"pos":[18421,18429],"content":"operator"},{"content":"A template function that writes a string into the output stream.","pos":[18441,18505]},{"content":"Parameters","pos":[18738,18748]},{"content":"_Ostr","pos":[18752,18757]},{"content":"The output stream being written to.","pos":[18761,18796]},{"content":"The string to be entered into the output stream.","pos":[18813,18861]},{"content":"Return Value","pos":[18871,18883]},{"pos":[18887,18957],"content":"Writes the value of the specified string to the output stream <ph id=\"ph1\">`_Ostr`</ph>.","source":"Writes the value of the specified string to the output stream `_Ostr`."},{"content":"Remarks","pos":[18967,18974]},{"content":"The template function overloads <bpt id=\"p1\">**</bpt>operator&lt;&lt;<ept id=\"p1\">**</ept> to insert an object _ <bpt id=\"p2\">*</bpt>Str<ept id=\"p2\">*</ept> of template class <bpt id=\"p3\">[</bpt>basic_string<ept id=\"p3\">](../standard-library/basic-string-class.md)</ept> into the stream <ph id=\"ph1\">\\_</ph> <bpt id=\"p4\">*</bpt>Ostr.<ept id=\"p4\">*</ept>","pos":[18978,19155],"source":"The template function overloads **operator<<** to insert an object _ *Str* of template class [basic_string](../standard-library/basic-string-class.md) into the stream \\_ *Ostr.*"},{"content":"The function effectively returns <ph id=\"ph1\">\\_</ph> <bpt id=\"p1\">*</bpt>Ostr<ept id=\"p1\">*</ept>.","pos":[19156,19199],"source":" The function effectively returns \\_ *Ostr*."},{"content":"<bpt id=\"p1\">**</bpt>write<ept id=\"p1\">**</ept>( <ph id=\"ph1\">\\_</ph> <bpt id=\"p2\">*</bpt>Str<ept id=\"p2\">*</ept>.","pos":[19200,19220],"source":"**write**( \\_ *Str*."},{"content":"<bpt id=\"p1\">[</bpt>c_str<ept id=\"p1\">](../standard-library/basic-string-class.md#basic_string__c_str)</ept>, <ph id=\"ph1\">\\_</ph> <bpt id=\"p2\">*</bpt>Str<ept id=\"p2\">*</ept>.","pos":[19221,19302],"source":"[c_str](../standard-library/basic-string-class.md#basic_string__c_str), \\_ *Str*."},{"content":"<bpt id=\"p1\">[</bpt>size<ept id=\"p1\">](../standard-library/basic-string-class.md#basic_string__size)</ept>).","pos":[19303,19373],"source":"[size](../standard-library/basic-string-class.md#basic_string__size))."},{"pos":[19412,19420],"content":"operator"},{"content":"Tests if the string object on the left side of the operator is greater than to the string object on the right side.","pos":[19428,19543]},{"content":"Parameters","pos":[20092,20102]},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[20117,20185],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[20204,20272],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"Return Value","pos":[20282,20294]},{"pos":[20298,20452],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the string object on the left side of the operator is lexicographically greater than the string object on the right side; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if the string object on the left side of the operator is lexicographically greater than the string object on the right side; otherwise **false**."},{"content":"Remarks","pos":[20462,20469]},{"content":"A lexicographical comparison between strings compares them character by character until:","pos":[20473,20561]},{"content":"It finds two corresponding characters unequal, and the result of their comparison is taken as the result of the comparison between the strings.","pos":[20571,20714]},{"content":"It finds no inequalities, but one string has more characters than the other, and the shorter string is considered less than the longer string.","pos":[20724,20866]},{"content":"It finds no inequalities and finds that the strings have the same number of characters, and so the strings are equal.","pos":[20876,20993]},{"content":"Example","pos":[21003,21010]},{"pos":[22913,22921],"content":"operator"},{"content":"Tests if the string object on the left side of the operator is greater than or equal to the string object on the right side.","pos":[22930,23054]},{"content":"Parameters","pos":[23606,23616]},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[23631,23699],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"A C-style string or an object of type <ph id=\"ph1\">`basic_string`</ph> to be compared.","pos":[23718,23786],"source":" A C-style string or an object of type `basic_string` to be compared."},{"content":"Return Value","pos":[23796,23808]},{"pos":[23812,23978],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the string object on the left side of the operator is lexicographically greater than or equal to the string object on the right side; otherwise <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>.","source":"**true** if the string object on the left side of the operator is lexicographically greater than or equal to the string object on the right side; otherwise **false**."},{"content":"Remarks","pos":[23988,23995]},{"content":"A lexicographical comparison between strings compares them character by character until:","pos":[23999,24087]},{"content":"It finds two corresponding characters unequal, and the result of their comparison is taken as the result of the comparison between the strings.","pos":[24097,24240]},{"content":"It finds no inequalities, but one string has more characters than the other, and the shorter string is considered less than the longer string.","pos":[24250,24392]},{"content":"It finds no inequalities and finds the strings have the same number of characters, and so the strings are equal.","pos":[24402,24514]},{"content":"Example","pos":[24524,24531]},{"pos":[26470,26478],"content":"operator"},{"content":"A template function that reads a string from an input stream.","pos":[26490,26551]},{"content":"Parameters","pos":[26781,26791]},{"content":"The input stream used to extract the sequence","pos":[26806,26851]},{"content":"The string that is being extracted from the input stream.","pos":[26870,26927]},{"content":"Return Value","pos":[26937,26949]},{"pos":[26953,27025],"content":"Reads the value of the specified string from <ph id=\"ph1\">`_Istr`</ph> and returns it into","source":"Reads the value of the specified string from `_Istr` and returns it into "},{"content":"Remarks","pos":[27045,27052]},{"content":"The operator skips the leading white spaces unless the <ph id=\"ph1\">`skipws`</ph> flag is set.","pos":[27056,27132],"source":"The operator skips the leading white spaces unless the `skipws` flag is set."},{"content":"It reads all the following characters until the next character is a white space or the end of the file is reached.","pos":[27133,27247]},{"content":"The template function overloads <bpt id=\"p1\">**</bpt>operator&gt;&gt;<ept id=\"p1\">**</ept> to replace the sequence controlled by <ph id=\"ph1\">` right`</ph> with a sequence of elements extracted from the stream <ph id=\"ph2\">`_Istr`</ph>.","pos":[27254,27410],"source":"The template function overloads **operator>>** to replace the sequence controlled by ` right` with a sequence of elements extracted from the stream `_Istr`."},{"content":"Extraction stops:","pos":[27411,27428]},{"content":"At end of file.","pos":[27438,27453]},{"content":"After the function extracts <ph id=\"ph1\">`_Istr`</ph>.","pos":[27463,27499],"source":"After the function extracts `_Istr`."},{"content":"<bpt id=\"p1\">**</bpt>width<ept id=\"p1\">**</ept> elements, if that value is nonzero.","pos":[27500,27545],"source":"**width** elements, if that value is nonzero."},{"content":"After the function extracts <ph id=\"ph1\">`_Istr`</ph>.","pos":[27552,27588],"source":"After the function extracts `_Istr`."},{"content":"<bpt id=\"p1\">[</bpt>max_size<ept id=\"p1\">](../standard-library/basic-string-class.md#basic_string__max_size)</ept> elements.","pos":[27589,27675],"source":"[max_size](../standard-library/basic-string-class.md#basic_string__max_size) elements."},{"content":"After the function extracts an element <bpt id=\"p1\">*</bpt>ch<ept id=\"p1\">*</ept> for which <bpt id=\"p2\">[</bpt>use_facet<ept id=\"p2\">](../standard-library/basic-filebuf-class.md#basic_filebuf__open)</ept><ph id=\"ph1\">&lt; </ph><bpt id=\"p3\">**</bpt>ctype<ept id=\"p3\">**</ept><ph id=\"ph2\">\\&lt;</ph> <bpt id=\"p4\">**</bpt>CharType<ept id=\"p4\">**</ept>&gt; &gt;( <ph id=\"ph3\">`getloc`</ph>).","pos":[27685,27855],"source":"After the function extracts an element *ch* for which [use_facet](../standard-library/basic-filebuf-class.md#basic_filebuf__open)< **ctype**\\< **CharType**> >( `getloc`)."},{"content":"<bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept>( <bpt id=\"p2\">**</bpt>ctype<ept id=\"p2\">**</ept><ph id=\"ph1\">\\&lt;</ph> <bpt id=\"p3\">**</bpt>CharType<ept id=\"p3\">**</ept>&gt;:: <bpt id=\"p4\">**</bpt>space<ept id=\"p4\">**</ept>, <bpt id=\"p5\">*</bpt>ch<ept id=\"p5\">*</ept>) is true, in which case the character is put back.","pos":[27856,27958],"source":"**is**( **ctype**\\< **CharType**>:: **space**, *ch*) is true, in which case the character is put back."},{"content":"If the function extracts no elements, it calls <bpt id=\"p1\">[</bpt>setstate<ept id=\"p1\">](../standard-library/basic-ios-class.md#basic_ios__setstate)</ept>( <ph id=\"ph1\">`ios_base::failbit`</ph>).","pos":[27965,28105],"source":"If the function extracts no elements, it calls [setstate](../standard-library/basic-ios-class.md#basic_ios__setstate)( `ios_base::failbit`)."},{"content":"In any case, it calls <bpt id=\"p1\">**</bpt>istr<ept id=\"p1\">**</ept>.","pos":[28106,28137],"source":" In any case, it calls **istr**."},{"content":"<bpt id=\"p1\">**</bpt>width<ept id=\"p1\">**</ept>(0) and returns <ph id=\"ph1\">\\*</ph> <bpt id=\"p2\">**</bpt>this<ept id=\"p2\">**</ept>.","pos":[28138,28175],"source":"**width**(0) and returns \\* **this**."},{"content":"Example","pos":[28185,28192]},{"content":"See Also","pos":[28518,28526]},{"content":"string&gt;","pos":[28533,28540],"source":"string>"}],"content":"---\ntitle: \"&lt;string&gt; operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 33ce8f05-06c7-45d3-a0cb-bcd27cf93910\ncaps.latest.revision: 11\nmanager: \"ghogen\"\n---\n# &lt;string&gt; operators\n||||  \n|-|-|-|  \n|[operator!=](#operator_neq)|[operator&gt;](#operator_gt_)|[operator&gt;&gt;](#operator_gt__gt_)|  \n|[operator&gt;=](#operator_gt__eq)|[operator&lt;](#operator_lt_)|[operator&lt;&lt;](#operator_lt__lt_)|  \n|[operator&lt;=](#operator_lt__eq)|[operator+](#operator_add)|[operator==](#operator_eq_eq)|  \n  \n##  <a name=\"operator_add\"></a>  operator+  \n Concatenates two string objects.  \n  \n```  \ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator> operator+(\n    const basic_string<CharType, Traits, Allocator>& left,  \n    const basic_string<CharType, Traits, Allocator>& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator> operator+(\n    const basic_string<CharType, Traits, Allocator>& left,  \n    const CharType* right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator> operator+(\n    const basic_string<CharType, Traits, Allocator>& left,  \n    const CharType right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator> operator+(\n    const CharType* left,  \n    const basic_string<CharType, Traits, Allocator>& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator> operator+(\n    const CharType left,  \n    const basic_string<CharType, Traits, Allocator>& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator>&& operator+(\n    const basic_string<CharType, Traits, Allocator>& left,  \n    const basic_string<CharType, Traits, Allocator>&& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator>&& operator+(\n    const basic_string<CharType, Traits, Allocator>&& left,  \n    const basic_string<CharType, Traits, Allocator>& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator>&& operator+(\n    const basic_string<CharType, Traits, Allocator>&& left,  \n    const basic_string<CharType, Traits, Allocator>&& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator>&& operator+(\n    const basic_string<CharType, Traits, Allocator>&& left,  \n    const CharType* right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator>&& operator+(\n    const basic_string<CharType, Traits, Allocator>&& left,  \n    CharType right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator>&& operator+(\n    const CharType* left,  \n    const basic_string<CharType, Traits, Allocator>&& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbasic_string<CharType, Traits, Allocator>&& operator+(\n    CharType left,  \n    const basic_string<CharType, Traits, Allocator>&& right);\n```  \n  \n### Parameters  \n ` left`  \n A C-style string or an object of type `basic_string` to be concatenated.  \n  \n ` right`  \n A C-style string or an object of type `basic_string` to be concatenated.  \n  \n### Return Value  \n The string that is the concatenation of the input strings.  \n  \n### Remarks  \n The functions each overload `operator+` to concatenate two objects of template class [basic_string Class](../standard-library/basic-string-class.md). All effectively return `basic_string`\\< **CharType**, **Traits**, **Allocator**>(_ *Left*). [append](../standard-library/basic-string-class.md#basic_string__append)(\\_ *Right*).  \n  \n### Example  \n  \n```cpp  \n// string_op_con.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   // Declaring an object of type basic_string<char>  \n   string s1 ( \"anti\" );  \n   string s2 ( \"gravity\" );  \n   cout << \"The basic_string s1 = \" << s1 << \".\" << endl;  \n   cout << \"The basic_string s2 = \" << s2 << \".\" << endl;  \n  \n   // Declaring a C-style string  \n   char *s3 = \"heroine\";  \n   cout << \"The C-style string s3 = \" << s3 << \".\" << endl;  \n  \n   // Declaring a character constant  \n   char c1 = '!';  \n   cout << \"The character constant c1 = \" << c1 << \".\" << endl;  \n  \n   // First member function: concatenates an  object  \n   // of type basic_string with an object of type basic_string  \n   string s12 = s1 + s2;  \n   cout << \"The string concatenating s1 & s2 is: \" << s12 << endl;  \n  \n   // Second & fourth member functions: concatenate an object  \n   // of type basic_string with an object of C-syle string type  \n   string s1s3 = s1 + s3;  \n   cout << \"The string concatenating s1 & s3 is: \" << s1s3 << endl;  \n  \n   // Third & fifth member functions: concatenate an object  \n   // of type basic_string with a character constant  \n   string s1s3c1 = s1s3 + c1;  \n   cout << \"The string concatenating s1 & s3 is: \" << s1s3c1 << endl;  \n}  \n```  \n  \n```Output  \nThe basic_string s1 = anti.  \nThe basic_string s2 = gravity.  \nThe C-style string s3 = heroine.  \nThe character constant c1 = !.  \nThe string concatenating s1 & s2 is: antigravity  \nThe string concatenating s1 & s3 is: antiheroine  \nThe string concatenating s1 & s3 is: antiheroine!  \n```  \n  \n##  <a name=\"operator_neq\"></a>  operator!=  \n Tests if the string object on the left side of the operator is not equal to the string object on the right side.  \n  \n```  \ntemplate <class CharType, class Traits, class Allocator>  \nbool operator!=(\n    const basic_string<CharType, Traits, Allocator>& left, \n    const basic_string<CharType, Traits, Allocator>& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator!=(\n    const basic_string<CharType, Traits, Allocator>& left, \nconst CharType* right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator!=(\n    const CharType* left, \n    const basic_string<CharType, Traits, Allocator>& right);\n```  \n  \n### Parameters  \n ` left`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n ` right`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n### Return Value  \n **true** if the string object on the left side of the operator is not lexicographically equal to the string object on the right side; otherwise **false**.  \n  \n### Remarks  \n The comparison between string objects is based on a pairwise lexicographical comparison of their characters. Two strings are equal if they have the same number of characters and their respective character values are the same. Otherwise, they are unequal.  \n  \n### Example  \n  \n```cpp  \n// string_op_ne.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // Declaring an objects of type basic_string<char>  \n   string s1 ( \"pluck\" );  \n   string s2 ( \"strum\" );  \n   cout << \"The basic_string s1 = \" << s1 << \".\" << endl;  \n   cout << \"The basic_string s2 = \" << s2 << \".\" << endl;  \n  \n   // Declaring a C-style string  \n   char *s3 = \"pluck\";  \n   cout << \"The C-style string s3 = \" << s3 << \".\" << endl;  \n  \n   // First member function: comparison between left-side object  \n   // of type basic_string & right-side object of type basic_string  \n   if ( s1 != s2 )  \n      cout << \"The strings s1 & s2 are not equal.\" << endl;  \n   else  \n      cout << \"The strings s1 & s2 are equal.\" << endl;  \n  \n   // Second member function: comparison between left-side object  \n   // of type basic_string & right-side object of C-syle string type  \n   if ( s1 != s3 )  \n      cout << \"The strings s1 & s3 are not equal.\" << endl;  \n   else  \n      cout << \"The strings s1 & s3 are equal.\" << endl;  \n  \n   // Third member function: comparison between left-side object  \n   // of C-syle string type & right-side object of type basic_string  \n   if ( s3 != s2 )  \n      cout << \"The strings s3 & s2 are not equal.\" << endl;  \n   else  \n      cout << \"The strings s3 & s2 are equal.\" << endl;  \n}  \n```  \n  \n```Output  \nThe basic_string s1 = pluck.  \nThe basic_string s2 = strum.  \nThe C-style string s3 = pluck.  \nThe strings s1 & s2 are not equal.  \nThe strings s1 & s3 are equal.  \nThe strings s3 & s2 are not equal.  \n```  \n  \n##  <a name=\"operator_eq_eq\"></a>  operator==  \n Tests if the string object on the left side of the operator is equal to the string object on the right side.  \n  \n```  \ntemplate <class CharType, class Traits, class Allocator>  \nbool operator==(\n    const basic_string<CharType, Traits, Allocator>& left, \n    const basic_string<CharType, Traits, Allocator>& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator==(\n    const basic_string<CharType, Traits, Allocator>& left, \n    const CharType* right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator==(\n    const CharType* left, \n    const basic_string<CharType, Traits, Allocator>& right);\n```  \n  \n### Parameters  \n ` left`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n ` right`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n### Return Value  \n **true** if the string object on the left side of the operator is lexicographically equal to the string object on the right side; otherwise **false**.  \n  \n### Remarks  \n The comparison between string objects is based on a pairwise lexicographical comparison of their characters. Two strings are equal if they have the same number of characters and their respective character values are the same. Otherwise, they are unequal.  \n  \n### Example  \n  \n```cpp  \n// string_op_eq.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // Declaring an objects of type basic_string<char>  \n   string s1 ( \"pluck\" );  \n   string s2 ( \"strum\" );  \n   cout << \"The basic_string s1 = \" << s1 << \".\" << endl;  \n   cout << \"The basic_string s2 = \" << s2 << \".\" << endl;  \n  \n   // Declaring a C-style string  \n   char *s3 = \"pluck\";  \n   cout << \"The C-style string s3 = \" << s3 << \".\" << endl;  \n  \n   // First member function: comparison between left-side object  \n   // of type basic_string & right-side object of type basic_string  \n   if ( s1 == s2 )  \n      cout << \"The strings s1 & s2 are equal.\" << endl;  \n   else  \n      cout << \"The strings s1 & s2 are not equal.\" << endl;  \n  \n   // Second member function: comparison between left-side object  \n   // of type basic_string & right-side object of C-syle string type  \n   if ( s1 == s3 )  \n      cout << \"The strings s1 & s3 are equal.\" << endl;  \n   else  \n      cout << \"The strings s1 & s3 are not equal.\" << endl;  \n  \n   // Third member function: comparison between left-side object  \n   // of C-syle string type & right-side object of type basic_string  \n   if ( s3 == s2 )  \n      cout << \"The strings s3 & s2 are equal.\" << endl;  \n   else  \n      cout << \"The strings s3 & s2 are not equal.\" << endl;  \n}  \n```  \n  \n```Output  \nThe basic_string s1 = pluck.  \nThe basic_string s2 = strum.  \nThe C-style string s3 = pluck.  \nThe strings s1 & s2 are not equal.  \nThe strings s1 & s3 are equal.  \nThe strings s3 & s2 are not equal.  \n```  \n  \n##  <a name=\"operator_lt_\"></a>  operator&lt;  \n Tests if the string object on the left side of the operator is less than to the string object on the right side.  \n  \n```  \ntemplate <class CharType, class Traits, class Allocator>  \nbool operator<(\n    const basic_string<CharType, Traits, Allocator>& left, \n    const basic_string<CharType, Traits, Allocator>& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator<(\n    const basic_string<CharType, Traits, Allocator>& left, \n    const CharType* right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator<(\n    const CharType* left, \n    const basic_string<CharType, Traits, Allocator>& right);\n```  \n  \n### Parameters  \n ` left`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n ` right`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n### Return Value  \n **true** if the string object on the left side of the operator is lexicographically less than the string object on the right side; otherwise **false**.  \n  \n### Remarks  \n A lexicographical comparison between strings compares them character by character until:  \n  \n-   It finds two corresponding characters unequal, and the result of their comparison is taken as the result of the comparison between the strings.  \n  \n-   It finds no inequalities, but one string has more characters than the other, and the shorter string is considered less than the longer string.  \n  \n-   It finds no inequalities and finds that the strings have the same number of characters, and so the strings are equal.  \n  \n### Example  \n  \n```cpp  \n// string_op_lt.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   // Declaring an objects of type basic_string<char>  \n   string s1 ( \"strict\" );  \n   string s2 ( \"strum\" );  \n   cout << \"The basic_string s1 = \" << s1 << \".\" << endl;  \n   cout << \"The basic_string s2 = \" << s2 << \".\" << endl;  \n  \n   // Declaring a C-style string  \n   char *s3 = \"strict\";  \n   cout << \"The C-style string s3 = \" << s3 << \".\" << endl;  \n  \n   // First member function: comparison between left-side object  \n   // of type basic_string & right-side object of type basic_string  \n   if ( s1 < s2 )  \n      cout << \"The string s1 is less than the string s2.\" << endl;  \n   else  \n      cout << \"The string s1 is not less than the string s2.\" << endl;  \n  \n   // Second member function: comparison between left-hand object  \n   // of type basic_string & right-hand object of C-syle string type  \n   if ( s1 < s3 )  \n      cout << \"The string s1 is less than the string s3.\" << endl;  \n   else  \n      cout << \"The string s1 is not less than the string s3.\" << endl;  \n  \n   // Third member function: comparison between left-hand object  \n   // of C-syle string type & right-hand object of type basic_string  \n   if ( s3 < s2 )  \n      cout << \"The string s3 is less than the string s2.\" << endl;  \n   else  \n      cout << \"The string s3 is not less than the string s2.\" << endl;  \n}  \n```  \n  \n```Output  \nThe basic_string s1 = strict.  \nThe basic_string s2 = strum.  \nThe C-style string s3 = strict.  \nThe string s1 is less than the string s2.  \nThe string s1 is not less than the string s3.  \nThe string s3 is less than the string s2.  \n```  \n  \n##  <a name=\"operator_lt__eq\"></a>  operator&lt;=  \n Tests if the string object on the left side of the operator is less than or equal to the string object on the right side.  \n  \n```  \ntemplate <class CharType, class Traits, class Allocator>  \nbool operator<=(\n    const basic_string<CharType, Traits, Allocator>& left, \n    const basic_string<CharType, Traits, Allocator>& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator<=(\n    const basic_string<CharType, Traits, Allocator>& left, \n    const CharType* right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator<=(\n    const CharType* left, \n    const basic_string<CharType, Traits, Allocator>& right);\n```  \n  \n### Parameters  \n ` left`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n ` right`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n### Return Value  \n **true** if the string object on the left side of the operator is lexicographically less than or equal to the string object on the right side; otherwise **false**.  \n  \n### Remarks  \n A lexicographical comparison between strings compares them character by character until:  \n  \n-   It finds two corresponding characters unequal, and the result of their comparison is taken as the result of the comparison between the strings.  \n  \n-   It finds no inequalities, but one string has more characters than the other, and the shorter string is considered less than the longer string.  \n  \n-   It finds no inequalities and finds that the strings have the same number of characters, so the strings are equal.  \n  \n### Example  \n  \n```cpp  \n// string_op_le.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // Declaring an objects of type basic_string<char>  \n   string s1 ( \"strict\" );  \n   string s2 ( \"strum\" );  \n   cout << \"The basic_string s1 = \" << s1 << \".\" << endl;  \n   cout << \"The basic_string s2 = \" << s2 << \".\" << endl;  \n  \n   // Declaring a C-style string  \n   char *s3 = \"strict\";  \n   cout << \"The C-style string s3 = \" << s3 << \".\" << endl;  \n  \n   // First member function: comparison between left-side object  \n   // of type basic_string & right-side object of type basic_string  \n   if ( s1 <= s2 )  \n      cout << \"The string s1 is less than or equal to \"  \n           << \"the string s2.\" << endl;  \n   else  \n      cout << \"The string s1 is greater than \"  \n           << \"the string s2.\" << endl;  \n  \n   // Second member function: comparison between left-side object  \n   // of type basic_string & right-side object of C-syle string type  \n   if ( s1 <= s3 )  \n      cout << \"The string s1 is less than or equal to \"  \n           << \"the string s3.\" << endl;  \n   else  \n      cout << \"The string s1 is greater than \"  \n           << \"the string s3.\" << endl;  \n  \n   // Third member function: comparison between left-side object  \n   // of C-syle string type  & right-side object of type basic_string  \n   if ( s2 <= s3 )  \n      cout << \"The string s2 is less than or equal to \"  \n           << \"the string s3.\" << endl;  \n   else  \n      cout << \"The string s2 is greater than \"  \n           << \"the string s3.\" << endl;  \n}  \n```  \n  \n```Output  \nThe basic_string s1 = strict.  \nThe basic_string s2 = strum.  \nThe C-style string s3 = strict.  \nThe string s1 is less than or equal to the string s2.  \nThe string s1 is less than or equal to the string s3.  \nThe string s2 is greater than the string s3.  \n```  \n  \n##  <a name=\"operator_lt__lt_\"></a>  operator&lt;&lt;  \n A template function that writes a string into the output stream.  \n  \n```  \ntemplate <class CharType, class Traits, class Allocator>  \nbasic_ostream<CharType, Traits>& operator<<(\n    basic_ostream<CharType, Traits>& _Ostr, \n    const basic_string<CharType, Traits, Allocator>& str);\n```  \n  \n### Parameters  \n _Ostr  \n The output stream being written to.  \n  \n ` str`  \n The string to be entered into the output stream.  \n  \n### Return Value  \n Writes the value of the specified string to the output stream `_Ostr`.  \n  \n### Remarks  \n The template function overloads **operator<<** to insert an object _ *Str* of template class [basic_string](../standard-library/basic-string-class.md) into the stream \\_ *Ostr.* The function effectively returns \\_ *Ostr*. **write**( \\_ *Str*. [c_str](../standard-library/basic-string-class.md#basic_string__c_str), \\_ *Str*. [size](../standard-library/basic-string-class.md#basic_string__size)).  \n  \n##  <a name=\"operator_gt_\"></a>  operator&gt;  \n Tests if the string object on the left side of the operator is greater than to the string object on the right side.  \n  \n```  \ntemplate <class CharType, class Traits, class Allocator>  \nbool operator>(\n    const basic_string<CharType, Traits, Allocator>& left, \n    const basic_string<CharType, Traits, Allocator>& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator>(\n    const basic_string<CharType, Traits, Allocator>& left, \n    const CharType* right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator>(\n    const CharType* left, \n    const basic_string<CharType, Traits, Allocator>& right);\n```  \n  \n### Parameters  \n ` left`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n ` right`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n### Return Value  \n **true** if the string object on the left side of the operator is lexicographically greater than the string object on the right side; otherwise **false**.  \n  \n### Remarks  \n A lexicographical comparison between strings compares them character by character until:  \n  \n-   It finds two corresponding characters unequal, and the result of their comparison is taken as the result of the comparison between the strings.  \n  \n-   It finds no inequalities, but one string has more characters than the other, and the shorter string is considered less than the longer string.  \n  \n-   It finds no inequalities and finds that the strings have the same number of characters, and so the strings are equal.  \n  \n### Example  \n  \n```cpp  \n// string_op_gt.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // Declaring an objects of type basic_string<char>  \n   string s1 ( \"strict\" );  \n   string s2 ( \"strum\" );  \n   cout << \"The basic_string s1 = \" << s1 << \".\" << endl;  \n   cout << \"The basic_string s2 = \" << s2 << \".\" << endl;  \n  \n   // Declaring a C-style string  \n   char *s3 = \"stricture\";  \n   cout << \"The C-style string s3 = \" << s3 << \".\" << endl;  \n  \n   // First member function: comparison between left-side object  \n   // of type basic_string & right-side object of type basic_string  \n   if ( s1 > s2 )  \n      cout << \"The string s1 is greater than \"  \n           << \"the string s2.\" << endl;  \n   else  \n      cout << \"The string s1 is not greater than \"  \n           << \"the string s2.\" << endl;  \n  \n   // Second member function: comparison between left-side object  \n   // of type basic_string & right-side object of C-syle string type  \n   if ( s3 > s1 )  \n      cout << \"The string s3 is greater than \"  \n           << \"the string s1.\" << endl;  \n   else  \n      cout << \"The string s3 is not greater than \"  \n           << \"the string s1.\" << endl;  \n  \n   // Third member function: comparison between left-side object  \n   // of C-syle string type & right-side object of type basic_string  \n   if ( s2 > s3 )  \n      cout << \"The string s2 is greater than \"  \n           << \"the string s3.\" << endl;  \n   else  \n      cout << \"The string s2 is not greater than \"  \n           << \"the string s3.\" << endl;  \n}  \n```  \n  \n```Output  \nThe basic_string s1 = strict.  \nThe basic_string s2 = strum.  \nThe C-style string s3 = stricture.  \nThe string s1 is not greater than the string s2.  \nThe string s3 is greater than the string s1.  \nThe string s2 is greater than the string s3.  \n```  \n  \n##  <a name=\"operator_gt__eq\"></a>  operator&gt;=  \n Tests if the string object on the left side of the operator is greater than or equal to the string object on the right side.  \n  \n```  \ntemplate <class CharType, class Traits, class Allocator>  \nbool operator>=(\n    const basic_string<CharType, Traits, Allocator>& left, \n    const basic_string<CharType, Traits, Allocator>& right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator>=(\n    const basic_string<CharType, Traits, Allocator>& left, \n    const CharType* right);\n\ntemplate <class CharType, class Traits, class Allocator>  \nbool operator>=(\n    const CharType* left, \n    const basic_string<CharType, Traits, Allocator>& right);\n```  \n  \n### Parameters  \n ` left`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n ` right`  \n A C-style string or an object of type `basic_string` to be compared.  \n  \n### Return Value  \n **true** if the string object on the left side of the operator is lexicographically greater than or equal to the string object on the right side; otherwise **false**.  \n  \n### Remarks  \n A lexicographical comparison between strings compares them character by character until:  \n  \n-   It finds two corresponding characters unequal, and the result of their comparison is taken as the result of the comparison between the strings.  \n  \n-   It finds no inequalities, but one string has more characters than the other, and the shorter string is considered less than the longer string.  \n  \n-   It finds no inequalities and finds the strings have the same number of characters, and so the strings are equal.  \n  \n### Example  \n  \n```cpp  \n// string_op_ge.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   // Declaring an objects of type basic_string<char>  \n   string s1 ( \"strict\" );  \n   string s2 ( \"strum\" );  \n   cout << \"The basic_string s1 = \" << s1 << \".\" << endl;  \n   cout << \"The basic_string s2 = \" << s2 << \".\" << endl;  \n  \n   // Declaring a C-style string  \n   char *s3 = \"stricture\";  \n   cout << \"The C-style string s3 = \" << s3 << \".\" << endl;  \n  \n   // First member function: comparison between left-side object  \n   // of type basic_string & right-side object of type basic_string  \n   if ( s1 >= s2 )  \n      cout << \"The string s1 is greater than or equal to \"  \n           << \"the string s2.\" << endl;  \n   else  \n      cout << \"The string s1 is less than \"  \n           << \"the string s2.\" << endl;  \n  \n   // Second member function: comparison between left-side object  \n   // of type basic_string & right-side object of C-syle string type  \n   if ( s3 >= s1 )  \n      cout << \"The string s3 is greater than or equal to \"  \n           << \"the string s1.\" << endl;  \n   else  \n      cout << \"The string s3 is less than \"  \n           << \"the string s1.\" << endl;  \n  \n   // Third member function: comparison between left-side object  \n   // of C-syle string type & right-side object of type basic_string  \n   if ( s2 >= s3 )  \n      cout << \"The string s2 is greater than or equal to \"  \n           << \"the string s3.\" << endl;  \n   else  \n      cout << \"The string s2 is less than \"  \n           << \"the string s3.\" << endl;  \n}  \n```  \n  \n```Output  \nThe basic_string s1 = strict.  \nThe basic_string s2 = strum.  \nThe C-style string s3 = stricture.  \nThe string s1 is less than the string s2.  \nThe string s3 is greater than or equal to the string s1.  \nThe string s2 is greater than or equal to the string s3.  \n```  \n  \n##  <a name=\"operator_gt__gt_\"></a>  operator&gt;&gt;  \n A template function that reads a string from an input stream.  \n  \n```  \ntemplate <class CharType, class Traits, class Allocator>  \nbasic_istream<CharType, Traits>& operator>>(\n    basic_istream<CharType, Traits>& _Istr,  \n    basic_string<CharType, Traits, Allocator>& right);\n```  \n  \n### Parameters  \n `_Istr`  \n The input stream used to extract the sequence  \n  \n ` right`  \n The string that is being extracted from the input stream.  \n  \n### Return Value  \n Reads the value of the specified string from `_Istr` and returns it into ` right.`  \n  \n### Remarks  \n The operator skips the leading white spaces unless the `skipws` flag is set. It reads all the following characters until the next character is a white space or the end of the file is reached.  \n  \n The template function overloads **operator>>** to replace the sequence controlled by ` right` with a sequence of elements extracted from the stream `_Istr`. Extraction stops:  \n  \n-   At end of file.  \n  \n-   After the function extracts `_Istr`. **width** elements, if that value is nonzero.  \n  \n After the function extracts `_Istr`. [max_size](../standard-library/basic-string-class.md#basic_string__max_size) elements.  \n  \n-   After the function extracts an element *ch* for which [use_facet](../standard-library/basic-filebuf-class.md#basic_filebuf__open)< **ctype**\\< **CharType**> >( `getloc`). **is**( **ctype**\\< **CharType**>:: **space**, *ch*) is true, in which case the character is put back.  \n  \n If the function extracts no elements, it calls [setstate](../standard-library/basic-ios-class.md#basic_ios__setstate)( `ios_base::failbit`). In any case, it calls **istr**. **width**(0) and returns \\* **this**.  \n  \n### Example  \n  \n```cpp  \n// string_op_read_.cpp  \n// compile with: /EHsc  \n#include <string>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   string c0;  \n   cout << \"Input a string c0 ( try: Fibonacci numbers ): \";  \n   cin >> c0;  \n   cout << \"The string entered is c0 = \" << c0 << endl;  \n}  \n```  \n  \n## See Also  \n [\\<string>](../standard-library/string.md)\n"}