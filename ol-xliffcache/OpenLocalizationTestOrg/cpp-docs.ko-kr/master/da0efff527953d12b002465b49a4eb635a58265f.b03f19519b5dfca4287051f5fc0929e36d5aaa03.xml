{"nodes":[{"pos":[12,44],"content":"Decorated Names | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Decorated Names | Microsoft Docs","pos":[0,32]}]},{"content":"Decorated Names","pos":[638,653]},{"content":"Functions, data, and objects in C and C++ programs are represented internally by their decorated names.","pos":[654,757]},{"content":"A <bpt id=\"p1\">*</bpt>decorated name<ept id=\"p1\">*</ept> is an encoded string created by the compiler during compilation of an object, data, or function definition.","pos":[758,884],"source":" A *decorated name* is an encoded string created by the compiler during compilation of an object, data, or function definition."},{"content":"It records calling conventions, types, function parameters and other information together with the name.","pos":[885,989]},{"content":"This name decoration, also known as <bpt id=\"p1\">*</bpt>name mangling<ept id=\"p1\">*</ept>, helps the linker find the correct functions and objects when linking an executable.","pos":[990,1126],"source":" This name decoration, also known as *name mangling*, helps the linker find the correct functions and objects when linking an executable."},{"content":"The decorated naming conventions have changed in various versions of Visual C++, and can also be different on different target architectures.","pos":[1133,1274]},{"content":"To link correctly with source files created by using Visual C++, C and C++ DLLs and libraries should be compiled by using the same compiler toolset, flags, and target architecture.","pos":[1275,1455]},{"content":"Contents","pos":[1464,1472]},{"content":"Using decorated names","pos":[1485,1506]},{"content":"Format of a C++ decorated name","pos":[1526,1556]},{"content":"Format of a C decorated name","pos":[1577,1605]},{"content":"Viewing decorated names","pos":[1627,1650]},{"content":"Viewing undecorated names","pos":[1672,1697]},{"pos":[1743,1764],"content":"Using decorated names"},{"content":"Normally, you don't have to know the decorated name to write code that compiles and links successfully.","pos":[1768,1871]},{"content":"Decorated names are an implementation detail internal to the compiler and linker.","pos":[1872,1953]},{"content":"The tools can usually handle the name in its undecorated form.","pos":[1954,2016]},{"content":"However, a decorated name is sometimes required when you specify a function name to the linker and other tools.","pos":[2017,2128]},{"content":"For example, to match overloaded C++ functions, members of namespaces, class constructors, destructors and special member functions, you must specify the decorated name.","pos":[2129,2298]},{"content":"For details about the option flags and other situations that require decorated names, see the documentation for the tools and options that you are using.","pos":[2299,2452]},{"content":"If you change the function name, class, calling convention, return type, or any parameter, the decorated name also changes.","pos":[2459,2582]},{"content":"In this case, you must get the new decorated name and use it everywhere the decorated name is specified.","pos":[2583,2687]},{"content":"Name decoration is also important when linking to code written in other programming languages or using other compilers.","pos":[2694,2813]},{"content":"Different compilers use different name decoration conventions.","pos":[2814,2876]},{"content":"When your executable links to code written in another language, special care must be taken to match the exported and imported names and calling conventions.","pos":[2877,3033]},{"content":"Assembly language code must use the Visual C++ decorated names and calling conventions to link to source code written using Visual C++.","pos":[3034,3169]},{"pos":[3201,3231],"content":"Format of a C++ decorated name"},{"content":"A decorated name for a C++ function contains the following information:","pos":[3235,3306]},{"content":"The function name.","pos":[3316,3334]},{"content":"The class that the function is a member of, if it is a member function.","pos":[3344,3415]},{"content":"This may include the class that encloses the class that contains the function, and so on.","pos":[3416,3505]},{"content":"The namespace the function belongs to, if it is part of a namespace.","pos":[3515,3583]},{"content":"The types of the function parameters.","pos":[3593,3630]},{"content":"The calling convention.","pos":[3640,3663]},{"content":"The return type of the function.","pos":[3673,3705]},{"content":"The function and class names are encoded in the decorated name.","pos":[3712,3775]},{"content":"The rest of the decorated name is a code that has internal meaning only for the compiler and the linker.","pos":[3776,3880]},{"content":"The following are examples of undecorated and decorated C++ names.","pos":[3881,3947]},{"content":"Undecorated name","pos":[3954,3970]},{"content":"Decorated name","pos":[3971,3985]},{"pos":[4170,4198],"content":"Format of a C decorated name"},{"content":"The form of decoration for a C function depends on the calling convention used in its declaration, as shown in the following table.","pos":[4202,4333]},{"content":"This is also the decoration format that is used when C++ code is declared to have <ph id=\"ph1\">`extern \"C\"`</ph> linkage.","pos":[4334,4437],"source":" This is also the decoration format that is used when C++ code is declared to have `extern \"C\"` linkage."},{"content":"The default calling convention is <ph id=\"ph1\">`__cdecl`</ph>.","pos":[4438,4482],"source":" The default calling convention is `__cdecl`."},{"content":"Note that in a 64-bit environment, functions are not decorated.","pos":[4483,4546]},{"content":"Calling convention","pos":[4553,4571]},{"content":"Decoration","pos":[4572,4582]},{"pos":[4643,4669],"content":"Leading underscore (<bpt id=\"p1\">**</bpt>_<ept id=\"p1\">**</ept>)","source":"Leading underscore (**_**)"},{"pos":[4686,4804],"content":"Leading underscore (<bpt id=\"p1\">**</bpt>_<ept id=\"p1\">**</ept>) and a trailing at sign (@) followed by the number of bytes in the parameter list in decimal","source":"Leading underscore (**_**) and a trailing at sign (@) followed by the number of bytes in the parameter list in decimal"},{"content":"Leading and trailing at signs (@) followed by a decimal number representing the number of bytes in the parameter list","pos":[4822,4939]},{"content":"Two trailing at signs (@@) followed by a decimal number of bytes in the parameter list","pos":[4959,5045]},{"pos":[5079,5102],"content":"Viewing decorated names"},{"content":"You can get the decorated form of a symbol name after you compile the source file that contains the data, object, or function definition or prototype.","pos":[5106,5256]},{"content":"To examine decorated names in your program, you can use one of the following methods:","pos":[5257,5342]},{"content":"To use a listing to view decorated names","pos":[5357,5397]},{"pos":[5411,5661],"content":"Generate a listing by compiling the source file that contains the data, object, or function definition or prototype with the <bpt id=\"p1\">[</bpt>Listing File Type<ept id=\"p1\">](../../build/reference/fa-fa-listing-file.md)</ept> compiler option set to Assembly with Source Code (<bpt id=\"p2\">**</bpt>/FAs<ept id=\"p2\">**</ept>).","source":"Generate a listing by compiling the source file that contains the data, object, or function definition or prototype with the [Listing File Type](../../build/reference/fa-fa-listing-file.md) compiler option set to Assembly with Source Code (**/FAs**)."},{"pos":[5676,5790],"content":"For example, enter <ph id=\"ph1\">`cl /c /FAs example.cpp`</ph> at a developer command prompt to generate a listing file, example.asm.","source":"For example, enter `cl /c /FAs example.cpp` at a developer command prompt to generate a listing file, example.asm."},{"content":"In the resulting listing file, find the line that starts with PUBLIC and ends a semicolon followed by the undecorated data or function name.","pos":[5804,5944]},{"content":"The symbol between PUBLIC and the semicolon is the decorated name.","pos":[5945,6011]},{"content":"To use DUMPBIN to view decorated names","pos":[6026,6064]},{"pos":[6078,6196],"content":"To see the exported symbols in an .obj or .lib file, enter <ph id=\"ph1\">`dumpbin /symbols`</ph> <ph id=\"ph2\">`objfile`</ph> at a developer command prompt.","source":"To see the exported symbols in an .obj or .lib file, enter `dumpbin /symbols` `objfile` at a developer command prompt."},{"content":"To find the decorated form of a symbol, look for the undecorated name in parentheses.","pos":[6210,6295]},{"content":"The decorated name is on the same line, after a pipe (&amp;#124;) character and before the undecorated name.","pos":[6296,6400],"source":" The decorated name is on the same line, after a pipe (&#124;) character and before the undecorated name."},{"pos":[6437,6462],"content":"Viewing undecorated names"},{"content":"You can use undname.exe to convert a decorated name to its undecorated form.","pos":[6466,6542]},{"content":"This example shows how it works:","pos":[6543,6575]},{"content":"See Also","pos":[6821,6829]},{"content":"C/C++ Build Tools","pos":[6834,6851]},{"content":"Using extern to Specify Linkage","pos":[6902,6933]}],"content":"---\ntitle: \"Decorated Names | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"decorated names, definition\"\n  - \"name decoration [C++]\"\n  - \"names [C++], decorated\"\nms.assetid: a4e9ae8e-b239-4454-b401-4102793cb344\ncaps.latest.revision: 10\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Decorated Names\nFunctions, data, and objects in C and C++ programs are represented internally by their decorated names. A *decorated name* is an encoded string created by the compiler during compilation of an object, data, or function definition. It records calling conventions, types, function parameters and other information together with the name. This name decoration, also known as *name mangling*, helps the linker find the correct functions and objects when linking an executable.  \n  \n The decorated naming conventions have changed in various versions of Visual C++, and can also be different on different target architectures. To link correctly with source files created by using Visual C++, C and C++ DLLs and libraries should be compiled by using the same compiler toolset, flags, and target architecture.  \n  \n **Contents**  \n  \n-   [Using decorated names](#Using)  \n  \n-   [Format of a C++ decorated name](#Format)  \n  \n-   [Format of a C decorated name](#FormatC)  \n  \n-   [Viewing decorated names](#Viewing)  \n  \n-   [Viewing undecorated names](#Undecorated)  \n  \n##  <a name=\"Using\"></a> Using decorated names  \n Normally, you don't have to know the decorated name to write code that compiles and links successfully. Decorated names are an implementation detail internal to the compiler and linker. The tools can usually handle the name in its undecorated form. However, a decorated name is sometimes required when you specify a function name to the linker and other tools. For example, to match overloaded C++ functions, members of namespaces, class constructors, destructors and special member functions, you must specify the decorated name. For details about the option flags and other situations that require decorated names, see the documentation for the tools and options that you are using.  \n  \n If you change the function name, class, calling convention, return type, or any parameter, the decorated name also changes. In this case, you must get the new decorated name and use it everywhere the decorated name is specified.  \n  \n Name decoration is also important when linking to code written in other programming languages or using other compilers. Different compilers use different name decoration conventions. When your executable links to code written in another language, special care must be taken to match the exported and imported names and calling conventions. Assembly language code must use the Visual C++ decorated names and calling conventions to link to source code written using Visual C++.  \n  \n##  <a name=\"Format\"></a> Format of a C++ decorated name  \n A decorated name for a C++ function contains the following information:  \n  \n-   The function name.  \n  \n-   The class that the function is a member of, if it is a member function. This may include the class that encloses the class that contains the function, and so on.  \n  \n-   The namespace the function belongs to, if it is part of a namespace.  \n  \n-   The types of the function parameters.  \n  \n-   The calling convention.  \n  \n-   The return type of the function.  \n  \n The function and class names are encoded in the decorated name. The rest of the decorated name is a code that has internal meaning only for the compiler and the linker. The following are examples of undecorated and decorated C++ names.  \n  \n|Undecorated name|Decorated name|  \n|----------------------|--------------------|  \n|`int a(char){int i=3;return i;};`|`?a@@YAHD@Z`|  \n|`void __stdcall b::c(float){};`|`?c@b@@AAGXM@Z`|  \n  \n##  <a name=\"FormatC\"></a> Format of a C decorated name  \n The form of decoration for a C function depends on the calling convention used in its declaration, as shown in the following table. This is also the decoration format that is used when C++ code is declared to have `extern \"C\"` linkage. The default calling convention is `__cdecl`. Note that in a 64-bit environment, functions are not decorated.  \n  \n|Calling convention|Decoration|  \n|------------------------|----------------|  \n|`__cdecl`|Leading underscore (**_**)|  \n|`__stdcall`|Leading underscore (**_**) and a trailing at sign (@) followed by the number of bytes in the parameter list in decimal|  \n|`__fastcall`|Leading and trailing at signs (@) followed by a decimal number representing the number of bytes in the parameter list|  \n|`__vectorcall`|Two trailing at signs (@@) followed by a decimal number of bytes in the parameter list|  \n  \n##  <a name=\"Viewing\"></a> Viewing decorated names  \n You can get the decorated form of a symbol name after you compile the source file that contains the data, object, or function definition or prototype. To examine decorated names in your program, you can use one of the following methods:  \n  \n-   #### To use a listing to view decorated names  \n  \n    1.  Generate a listing by compiling the source file that contains the data, object, or function definition or prototype with the [Listing File Type](../../build/reference/fa-fa-listing-file.md) compiler option set to Assembly with Source Code (**/FAs**).  \n  \n         For example, enter `cl /c /FAs example.cpp` at a developer command prompt to generate a listing file, example.asm.  \n  \n    2.  In the resulting listing file, find the line that starts with PUBLIC and ends a semicolon followed by the undecorated data or function name. The symbol between PUBLIC and the semicolon is the decorated name.  \n  \n-   #### To use DUMPBIN to view decorated names  \n  \n    1.  To see the exported symbols in an .obj or .lib file, enter `dumpbin /symbols` `objfile` at a developer command prompt.  \n  \n    2.  To find the decorated form of a symbol, look for the undecorated name in parentheses. The decorated name is on the same line, after a pipe (&#124;) character and before the undecorated name.  \n  \n##  <a name=\"Undecorated\"></a> Viewing undecorated names  \n You can use undname.exe to convert a decorated name to its undecorated form. This example shows how it works:  \n  \n```  \nC:\\>undname ?func1@a@@AAEXH@Z  \nMicrosoft (R) C++ Name Undecorator  \nCopyright (C) Microsoft Corporation. All rights reserved.  \n  \nUndecoration of :- \"?func1@a@@AAEXH@Z\"  \nis :- \"private: void __thiscall a::func1(int)\"  \n```  \n  \n## See Also  \n [C/C++ Build Tools](../../build/reference/c-cpp-build-tools.md)   \n [Using extern to Specify Linkage](../../cpp/using-extern-to-specify-linkage.md)"}