{"nodes":[{"pos":[12,82],"content":"Differences in Exception Handling Behavior Under -CLR | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Differences in Exception Handling Behavior Under -CLR | Microsoft Docs","pos":[0,70]}]},{"content":"Differences in Exception Handling Behavior Under /CLR","pos":[659,712]},{"content":"<bpt id=\"p1\">[</bpt>Basic Concepts in Using Managed Exceptions<ept id=\"p1\">](../dotnet/basic-concepts-in-using-managed-exceptions.md)</ept> discusses exception handling in managed applications.","pos":[713,868],"source":"[Basic Concepts in Using Managed Exceptions](../dotnet/basic-concepts-in-using-managed-exceptions.md) discusses exception handling in managed applications."},{"content":"In this topic, differences from the standard behavior of exception handling and some restrictions are discussed in detail.","pos":[869,991]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>The _set_se_translator Function<ept id=\"p1\">](../c-runtime-library/reference/set-se-translator.md)</ept>.","pos":[992,1105],"source":" For more information, see [The _set_se_translator Function](../c-runtime-library/reference/set-se-translator.md)."},{"pos":[1161,1191],"content":"Jumping Out of a Finally Block"},{"content":"In native C/C++ code, jumping out of a __<bpt id=\"p1\">**</bpt>finally<ept id=\"p1\">**</ept> block using structured exception handling (SEH) is allowed although it produces a warning.","pos":[1195,1338],"source":"In native C/C++ code, jumping out of a __**finally** block using structured exception handling (SEH) is allowed although it produces a warning."},{"content":"Under <bpt id=\"p1\">[</bpt>/clr<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>, jumping out of a <bpt id=\"p2\">**</bpt>finally<ept id=\"p2\">**</ept> block causes an error:","pos":[1340,1468],"source":"  Under [/clr](../build/reference/clr-common-language-runtime-compilation.md), jumping out of a **finally** block causes an error:"},{"pos":[1738,1783],"content":"Raising Exceptions Within an Exception Filter"},{"pos":[1787,1985],"content":"When an exception is raised during the processing of an <bpt id=\"p1\">[</bpt>exception filter<ept id=\"p1\">](../cpp/writing-an-exception-filter.md)</ept> within managed code, the exception is caught and treated as if the filter returns 0.","source":"When an exception is raised during the processing of an [exception filter](../cpp/writing-an-exception-filter.md) within managed code, the exception is caught and treated as if the filter returns 0."},{"content":"This is in contrast to the behavior in native code where a nested exception is raised, the <bpt id=\"p1\">**</bpt>ExceptionRecord<ept id=\"p1\">**</ept> field in the <bpt id=\"p2\">**</bpt>EXCEPTION_RECORD<ept id=\"p2\">**</ept> structure (as returned by <bpt id=\"p3\">[</bpt>GetExceptionInformation<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms679357)</ept>) is set, and the <bpt id=\"p4\">**</bpt>ExceptionFlags<ept id=\"p4\">**</ept> field sets the 0x10 bit.","pos":[1992,2309],"source":"This is in contrast to the behavior in native code where a nested exception is raised, the **ExceptionRecord** field in the **EXCEPTION_RECORD** structure (as returned by [GetExceptionInformation](http://msdn.microsoft.com/library/windows/desktop/ms679357)) is set, and the **ExceptionFlags** field sets the 0x10 bit."},{"content":"The following example illustrates this difference in behavior:","pos":[2310,2372]},{"content":"Output","pos":[3393,3399]},{"pos":[3549,3571],"content":"Disassociated Rethrows"},{"content":"<bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> does not support rethrowing an exception outside of a catch handler (known as a disassociated rethrow).","pos":[3575,3687],"source":"**/clr** does not support rethrowing an exception outside of a catch handler (known as a disassociated rethrow)."},{"content":"Exceptions of this type are treated as a standard C++ rethrow.","pos":[3688,3750]},{"content":"If a disassociated rethrow is encountered when there is an active managed exception, the exception is wrapped as a C++ exception and then rethrown.","pos":[3751,3898]},{"content":"Exceptions of this type can only be caught as an exception of type <bpt id=\"p1\">[</bpt>System::SEHException<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception.aspx)</ept>.","pos":[3899,4080],"source":" Exceptions of this type can only be caught as an exception of type [System::SEHException](https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception.aspx)."},{"content":"The following example demonstrates a managed exception rethrown as a C++ exception:","pos":[4087,4170]},{"content":"Output","pos":[5206,5212]},{"pos":[5331,5381],"content":"Exception Filters and EXCEPTION_CONTINUE_EXECUTION"},{"content":"If a filter returns <ph id=\"ph1\">`EXCEPTION_CONTINUE_EXECUTION`</ph> in a managed application, it is treated as if the filter returned <ph id=\"ph2\">`EXCEPTION_CONTINUE_SEARCH`</ph>.","pos":[5385,5530],"source":"If a filter returns `EXCEPTION_CONTINUE_EXECUTION` in a managed application, it is treated as if the filter returned `EXCEPTION_CONTINUE_SEARCH`."},{"content":"For more information on these constants, see <bpt id=\"p1\">[</bpt>try-except Statement<ept id=\"p1\">](../cpp/try-except-statement.md)</ept>.","pos":[5531,5631],"source":" For more information on these constants, see [try-except Statement](../cpp/try-except-statement.md)."},{"content":"The following example demonstrates this difference:","pos":[5638,5689]},{"content":"Output","pos":[6275,6281]},{"pos":[6369,6400],"content":"The _set_se_translator Function"},{"content":"The translator function, set by a call to <ph id=\"ph1\">`_set_se_translator`</ph>, affects only catches in unmanaged code.","pos":[6404,6507],"source":"The translator function, set by a call to `_set_se_translator`, affects only catches in unmanaged code."},{"content":"The following example demonstrates this limitation:","pos":[6508,6559]},{"content":"Output","pos":[8540,8546]},{"content":"See Also","pos":[8724,8732]},{"content":"Exception Handling","pos":[8737,8755]},{"content":"safe_cast","pos":[8821,8830]},{"content":"Exception Handling","pos":[8887,8905]}],"content":"---\ntitle: \"Differences in Exception Handling Behavior Under -CLR | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"EXCEPTION_CONTINUE_EXECUTION macro\"\n  - \"set_se_translator function\"\nms.assetid: 2e7e8daf-d019-44b0-a51c-62d7aaa89104\ncaps.latest.revision: 20\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Differences in Exception Handling Behavior Under /CLR\n[Basic Concepts in Using Managed Exceptions](../dotnet/basic-concepts-in-using-managed-exceptions.md) discusses exception handling in managed applications. In this topic, differences from the standard behavior of exception handling and some restrictions are discussed in detail. For more information, see [The _set_se_translator Function](../c-runtime-library/reference/set-se-translator.md).  \n  \n##  <a name=\"vcconjumpingoutofafinallyblock\"></a> Jumping Out of a Finally Block  \n In native C/C++ code, jumping out of a __**finally** block using structured exception handling (SEH) is allowed although it produces a warning.  Under [/clr](../build/reference/clr-common-language-runtime-compilation.md), jumping out of a **finally** block causes an error:  \n  \n```  \n// clr_exception_handling_4.cpp  \n// compile with: /clr  \nint main() {  \n   try {}  \n   finally {  \n      return 0;   // also fails with goto, break, continue  \n    }  \n}   // C3276  \n```  \n  \n##  <a name=\"vcconraisingexceptionswithinanexceptionfilter\"></a> Raising Exceptions Within an Exception Filter  \n When an exception is raised during the processing of an [exception filter](../cpp/writing-an-exception-filter.md) within managed code, the exception is caught and treated as if the filter returns 0.  \n  \n This is in contrast to the behavior in native code where a nested exception is raised, the **ExceptionRecord** field in the **EXCEPTION_RECORD** structure (as returned by [GetExceptionInformation](http://msdn.microsoft.com/library/windows/desktop/ms679357)) is set, and the **ExceptionFlags** field sets the 0x10 bit. The following example illustrates this difference in behavior:  \n  \n```  \n// clr_exception_handling_5.cpp  \n#include <windows.h>  \n#include <stdio.h>  \n#include <assert.h>  \n  \n#ifndef false  \n#define false 0  \n#endif  \n  \nint *p;  \n  \nint filter(PEXCEPTION_POINTERS ExceptionPointers) {  \n   PEXCEPTION_RECORD ExceptionRecord =   \n                     ExceptionPointers->ExceptionRecord;  \n  \n   if ((ExceptionRecord->ExceptionFlags & 0x10) == 0) {  \n      // not a nested exception, throw one  \n      *p = 0; // throw another AV  \n   }  \n   else {  \n      printf(\"Caught a nested exception\\n\");  \n      return 1;  \n    }  \n  \n   assert(false);  \n  \n   return 0;  \n}  \n  \nvoid f(void) {  \n   __try {  \n      *p = 0;   // throw an AV  \n   }  \n   __except(filter(GetExceptionInformation())) {  \n      printf_s(\"We should execute this handler if \"  \n                 \"compiled to native\\n\");  \n    }  \n}  \n  \nint main() {  \n   __try {  \n      f();  \n   }  \n   __except(1) {  \n      printf_s(\"The handler in main caught the \"  \n               \"exception\\n\");  \n    }  \n}  \n```  \n  \n### Output  \n  \n```  \nCaught a nested exception  \nWe should execute this handler if compiled to native  \n```  \n  \n##  <a name=\"vccondisassociatedrethrows\"></a> Disassociated Rethrows  \n **/clr** does not support rethrowing an exception outside of a catch handler (known as a disassociated rethrow). Exceptions of this type are treated as a standard C++ rethrow. If a disassociated rethrow is encountered when there is an active managed exception, the exception is wrapped as a C++ exception and then rethrown. Exceptions of this type can only be caught as an exception of type [System::SEHException](https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception.aspx).  \n  \n The following example demonstrates a managed exception rethrown as a C++ exception:  \n  \n```  \n// clr_exception_handling_6.cpp  \n// compile with: /clr  \nusing namespace System;  \n#include <assert.h>  \n#include <stdio.h>  \n  \nvoid rethrow( void ) {  \n   // This rethrow is a dissasociated rethrow.  \n   // The exception would be masked as SEHException.  \n   throw;  \n}  \n  \nint main() {  \n   try {  \n      try {  \n         throw gcnew ApplicationException;  \n      }  \n      catch ( ApplicationException^ ) {  \n         rethrow();  \n         // If the call to rethrow() is replaced with  \n         // a throw statement within the catch handler,  \n         // the rethrow would be a managed rethrow and  \n         // the exception type would remain   \n         // System::ApplicationException  \n      }  \n   }  \n  \n    catch ( ApplicationException^ ) {  \n      assert( false );  \n  \n      // This will not be executed since the exception  \n      // will be masked as SEHException.  \n    }  \n   catch ( Runtime::InteropServices::SEHException^ ) {  \n      printf_s(\"caught an SEH Exception\\n\" );  \n    }  \n}  \n```  \n  \n### Output  \n  \n```  \ncaught an SEH Exception  \n```  \n  \n##  <a name=\"vcconexceptionfiltersandexception_continue_execution\"></a> Exception Filters and EXCEPTION_CONTINUE_EXECUTION  \n If a filter returns `EXCEPTION_CONTINUE_EXECUTION` in a managed application, it is treated as if the filter returned `EXCEPTION_CONTINUE_SEARCH`. For more information on these constants, see [try-except Statement](../cpp/try-except-statement.md).  \n  \n The following example demonstrates this difference:  \n  \n```  \n// clr_exception_handling_7.cpp  \n#include <windows.h>  \n#include <stdio.h>  \n#include <assert.h>  \n  \nint main() {  \n   int Counter = 0;  \n   __try {  \n      __try  {  \n         Counter -= 1;  \n         RaiseException (0xe0000000|'seh',  \n                         0, 0, 0);  \n         Counter -= 2;  \n      }  \n      __except (Counter) {  \n         // Counter is negative,  \n         // indicating \"CONTINUE EXECUTE\"  \n         Counter -= 1;  \n      }  \n    }  \n    __except(1) {  \n      Counter -= 100;  \n   }  \n  \n   printf_s(\"Counter=%d\\n\", Counter);  \n}  \n```  \n  \n### Output  \n  \n```  \nCounter=-3  \n```  \n  \n##  <a name=\"vcconthe_set_se_translatorfunction\"></a> The _set_se_translator Function  \n The translator function, set by a call to `_set_se_translator`, affects only catches in unmanaged code. The following example demonstrates this limitation:  \n  \n```  \n// clr_exception_handling_8.cpp  \n// compile with: /clr /EHa  \n#include <iostream>  \n#include <windows.h>  \n#include <eh.h>  \n#pragma warning (disable: 4101)  \nusing namespace std;  \nusing namespace System;  \n  \n#define MYEXCEPTION_CODE 0xe0000101  \n  \nclass CMyException {  \npublic:  \n   unsigned int m_ErrorCode;  \n   EXCEPTION_POINTERS * m_pExp;  \n  \n   CMyException() : m_ErrorCode( 0 ), m_pExp( NULL ) {}  \n  \n   CMyException( unsigned int i, EXCEPTION_POINTERS * pExp )  \n         : m_ErrorCode( i ), m_pExp( pExp ) {}  \n  \n   CMyException( CMyException& c ) : m_ErrorCode( c.m_ErrorCode ),  \n                                      m_pExp( c.m_pExp ) {}  \n  \n   friend ostream& operator <<   \n                 ( ostream& out, const CMyException& inst ) {  \n      return out <<  \"CMyException[\\n\" <<    \n             \"Error Code: \" << inst.m_ErrorCode <<  \"]\";  \n    }  \n};  \n  \n#pragma unmanaged   \nvoid my_trans_func( unsigned int u, PEXCEPTION_POINTERS pExp ) {  \n   cout <<  \"In my_trans_func.\\n\";  \n   throw CMyException( u, pExp );  \n}  \n  \n#pragma managed   \nvoid managed_func() {  \n   try  {  \n      RaiseException( MYEXCEPTION_CODE, 0, 0, 0 );  \n   }  \n   catch ( CMyException x ) {}  \n   catch ( ... ) {  \n      printf_s(\"This is invoked since \"  \n               \"_set_se_translator is not \"  \n               \"supported when /clr is used\\n\" );  \n    }  \n}  \n  \n#pragma unmanaged   \nvoid unmanaged_func() {  \n   try  {  \n      RaiseException( MYEXCEPTION_CODE,   \n                      0, 0, 0 );  \n   }  \n   catch ( CMyException x ) {  \n      printf(\"Caught an SEH exception with \"  \n             \"exception code: %x\\n\", x.m_ErrorCode );  \n    }  \n    catch ( ... ) {}  \n}  \n  \n// #pragma managed   \nint main( int argc, char ** argv ) {  \n   _set_se_translator( my_trans_func );  \n  \n   // It does not matter whether the translator function  \n   // is registered in managed or unmanaged code  \n   managed_func();  \n   unmanaged_func();  \n}  \n```  \n  \n### Output  \n  \n```  \nThis is invoked since _set_se_translator is not supported when /clr is used  \nIn my_trans_func.  \nCaught an SEH exception with exception code: e0000101  \n```  \n  \n## See Also  \n [Exception Handling](../windows/exception-handling-cpp-component-extensions.md)   \n [safe_cast](../windows/safe-cast-cpp-component-extensions.md)   \n [Exception Handling](../cpp/exception-handling-in-visual-cpp.md)"}