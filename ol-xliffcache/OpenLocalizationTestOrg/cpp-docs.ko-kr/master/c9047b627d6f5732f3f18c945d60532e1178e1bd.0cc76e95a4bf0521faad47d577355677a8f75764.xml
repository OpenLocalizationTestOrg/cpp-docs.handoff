{"nodes":[{"pos":[12,36],"content":"mbrtowc | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"mbrtowc | Microsoft Docs","pos":[0,24]}]},{"pos":[907,914],"content":"mbrtowc","linkify":"mbrtowc","nodes":[{"content":"mbrtowc","pos":[0,7]}]},{"content":"Convert a multibyte character in the current locale into the equivalent wide character, with the capability of restarting in the middle of a multibyte character.","pos":[915,1076]},{"pos":[1085,1091],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1229,1239],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Address of a wide character to receive the converted wide character string (type <ph id=\"ph1\">`wchar_t`</ph>).","pos":[1254,1346],"source":" Address of a wide character to receive the converted wide character string (type `wchar_t`)."},{"content":"This value can be a null pointer if no return wide character is required.","pos":[1347,1420]},{"content":"Address of a sequence of bytes (a multibyte character).","pos":[1439,1494]},{"content":"Number of bytes to check.","pos":[1512,1537]},{"content":"Pointer to conversion state object.","pos":[1557,1592]},{"content":"If this value is a null pointer, the function uses a static internal conversion state object.","pos":[1593,1686]},{"content":"Because the internal <ph id=\"ph1\">`mbstate_t`</ph> object is not thread-safe, we recommend that you always pass your own <ph id=\"ph2\">`mbstate`</ph> argument.","pos":[1687,1809],"source":" Because the internal `mbstate_t` object is not thread-safe, we recommend that you always pass your own `mbstate` argument."},{"pos":[1818,1830],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"One of the following values:","pos":[1834,1862]},{"content":"0","pos":[1869,1870]},{"content":"The next <ph id=\"ph1\">`count`</ph> or fewer bytes complete the multibyte character that represents the null wide character, which is stored in <ph id=\"ph2\">`wchar`</ph>, if <ph id=\"ph3\">`wchar`</ph> is not a null pointer.","pos":[1874,2041],"source":" The next `count` or fewer bytes complete the multibyte character that represents the null wide character, which is stored in `wchar`, if `wchar` is not a null pointer."},{"content":"1 to <ph id=\"ph1\">`count`</ph>, inclusive","pos":[2048,2071],"source":"1 to `count`, inclusive"},{"content":"The next <ph id=\"ph1\">`count`</ph> or fewer bytes complete a valid multibyte character.","pos":[2075,2144],"source":" The next `count` or fewer bytes complete a valid multibyte character."},{"content":"The value returned is the number of bytes that complete the multibyte character.","pos":[2145,2225]},{"content":"The wide character equivalent is stored in <ph id=\"ph1\">`wchar`</ph>, if <ph id=\"ph2\">`wchar`</ph> is not a null pointer.","pos":[2226,2311],"source":" The wide character equivalent is stored in `wchar`, if `wchar` is not a null pointer."},{"content":"(size_t)(-1)","pos":[2318,2330]},{"content":"An encoding error occurred.","pos":[2334,2361]},{"content":"The next <ph id=\"ph1\">`count`</ph> or fewer bytes do not contribute to a complete and valid multibyte character.","pos":[2362,2456],"source":" The next `count` or fewer bytes do not contribute to a complete and valid multibyte character."},{"content":"In this case, <ph id=\"ph1\">`errno`</ph> is set to EILSEQ and the conversion shift state in <ph id=\"ph2\">`mbstate`</ph> is unspecified.","pos":[2457,2555],"source":" In this case, `errno` is set to EILSEQ and the conversion shift state in `mbstate` is unspecified."},{"content":"(size_t)(-2)","pos":[2562,2574]},{"content":"The next <ph id=\"ph1\">`count`</ph> bytes contribute to an incomplete but potentially valid multibyte character, and all <ph id=\"ph2\">`count`</ph> bytes have been processed.","pos":[2578,2714],"source":" The next `count` bytes contribute to an incomplete but potentially valid multibyte character, and all `count` bytes have been processed."},{"content":"No value is stored in <ph id=\"ph1\">`wchar`</ph>, but <ph id=\"ph2\">`mbstate`</ph> is updated to restart the function.","pos":[2715,2795],"source":" No value is stored in `wchar`, but `mbstate` is updated to restart the function."},{"pos":[2804,2811],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[2815,2885],"content":"If <ph id=\"ph1\">`mbchar`</ph> is a null pointer, the function is equivalent to the call:","source":"If `mbchar` is a null pointer, the function is equivalent to the call:"},{"pos":[2931,3004],"content":"In this case, the value of the arguments <ph id=\"ph1\">`wchar`</ph> and <ph id=\"ph2\">`count`</ph> are ignored.","source":"In this case, the value of the arguments `wchar` and `count` are ignored."},{"content":"If <ph id=\"ph1\">`mbchar`</ph> is not a null pointer, the function examines <ph id=\"ph2\">`count`</ph> bytes from <ph id=\"ph3\">`mbchar`</ph> to determine the required number of bytes that are required to complete the next multibyte character.","pos":[3011,3197],"source":"If `mbchar` is not a null pointer, the function examines `count` bytes from `mbchar` to determine the required number of bytes that are required to complete the next multibyte character."},{"content":"If the next character is valid, the corresponding multibyte character is stored in <ph id=\"ph1\">`wchar`</ph> if it is not a null pointer.","pos":[3198,3317],"source":" If the next character is valid, the corresponding multibyte character is stored in `wchar` if it is not a null pointer."},{"content":"If the character is the corresponding wide null character, the resulting state of <ph id=\"ph1\">`mbstate`</ph> is the initial conversion state.","pos":[3318,3442],"source":" If the character is the corresponding wide null character, the resulting state of `mbstate` is the initial conversion state."},{"content":"The <ph id=\"ph1\">`mbrtowc`</ph> function differs from <bpt id=\"p1\">[</bpt>mbtowc, _mbtowc_l<ept id=\"p1\">](../../c-runtime-library/reference/mbtowc-mbtowc-l.md)</ept> by its restartability.","pos":[3449,3581],"source":"The `mbrtowc` function differs from [mbtowc, _mbtowc_l](../../c-runtime-library/reference/mbtowc-mbtowc-l.md) by its restartability."},{"content":"The conversion state is stored in <ph id=\"ph1\">`mbstate`</ph> for subsequent calls to the same or other restartable functions.","pos":[3582,3690],"source":" The conversion state is stored in `mbstate` for subsequent calls to the same or other restartable functions."},{"content":"Results are undefined when mixing the use of restartable and nonrestartable functions.","pos":[3691,3777]},{"content":"For example, an application should use <ph id=\"ph1\">`wcsrlen`</ph> instead of <ph id=\"ph2\">`wcslen`</ph> if a subsequent call to <ph id=\"ph3\">`wcsrtombs`</ph> is used instead of <ph id=\"ph4\">`wcstombs`</ph>.","pos":[3779,3914],"source":"  For example, an application should use `wcsrlen` instead of `wcslen` if a subsequent call to `wcsrtombs` is used instead of `wcstombs`."},{"pos":[3923,3930],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"Converts a multibyte character to its wide character equivalent.","pos":[3934,3998]},{"pos":[6926,6939],"content":"Sample Output","linkify":"Sample Output","nodes":[{"content":"Sample Output","pos":[0,13]}]},{"pos":[7094,7106],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[7113,7120]},{"content":"Required header","pos":[7121,7136]},{"content":"<ph id=\"ph1\">\\&lt;</ph>wchar.h&gt;","pos":[7191,7201],"source":"\\<wchar.h>"},{"pos":[7211,7236],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"Not applicable.","pos":[7240,7255]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[7256,7303],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[7304,7429],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[7438,7446],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Data Conversion<ept id=\"p1\">](../../c-runtime-library/data-conversion.md)</ept><ph id=\"ph1\"> </ph>","pos":[7450,7512],"source":"[Data Conversion](../../c-runtime-library/data-conversion.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Locale<ept id=\"p1\">](../../c-runtime-library/locale.md)</ept><ph id=\"ph1\"> </ph>","pos":[7515,7560],"source":" [Locale](../../c-runtime-library/locale.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Interpretation of Multibyte-Character Sequences<ept id=\"p1\">](../../c-runtime-library/interpretation-of-multibyte-character-sequences.md)</ept>","pos":[7563,7689],"source":" [Interpretation of Multibyte-Character Sequences](../../c-runtime-library/interpretation-of-multibyte-character-sequences.md)"}],"content":"---\ntitle: \"mbrtowc | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"mbrtowc\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\n  - \"api-ms-win-crt-convert-l1-1-0.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"mbrtowc\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"mbrtowc function\"\nms.assetid: a1e87fcc-6de0-4ca1-bf26-508d28490286\ncaps.latest.revision: 15\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# mbrtowc\nConvert a multibyte character in the current locale into the equivalent wide character, with the capability of restarting in the middle of a multibyte character.  \n  \n## Syntax  \n  \n```  \nsize_t mbrtowc(  \n   wchar_t *wchar,  \n   const char *mbchar,  \n   size_t count,  \n   mbstate_t *mbstate  \n);  \n```  \n  \n#### Parameters  \n `wchar`  \n Address of a wide character to receive the converted wide character string (type `wchar_t`). This value can be a null pointer if no return wide character is required.  \n  \n `mbchar`  \n Address of a sequence of bytes (a multibyte character).  \n  \n `count`  \n Number of bytes to check.  \n  \n `mbstate`  \n Pointer to conversion state object. If this value is a null pointer, the function uses a static internal conversion state object. Because the internal `mbstate_t` object is not thread-safe, we recommend that you always pass your own `mbstate` argument.  \n  \n## Return Value  \n One of the following values:  \n  \n 0  \n The next `count` or fewer bytes complete the multibyte character that represents the null wide character, which is stored in `wchar`, if `wchar` is not a null pointer.  \n  \n 1 to `count`, inclusive  \n The next `count` or fewer bytes complete a valid multibyte character. The value returned is the number of bytes that complete the multibyte character. The wide character equivalent is stored in `wchar`, if `wchar` is not a null pointer.  \n  \n (size_t)(-1)  \n An encoding error occurred. The next `count` or fewer bytes do not contribute to a complete and valid multibyte character. In this case, `errno` is set to EILSEQ and the conversion shift state in `mbstate` is unspecified.  \n  \n (size_t)(-2)  \n The next `count` bytes contribute to an incomplete but potentially valid multibyte character, and all `count` bytes have been processed. No value is stored in `wchar`, but `mbstate` is updated to restart the function.  \n  \n## Remarks  \n If `mbchar` is a null pointer, the function is equivalent to the call:  \n  \n `mbrtowc(NULL, \"\", 1, &mbstate)`  \n  \n In this case, the value of the arguments `wchar` and `count` are ignored.  \n  \n If `mbchar` is not a null pointer, the function examines `count` bytes from `mbchar` to determine the required number of bytes that are required to complete the next multibyte character. If the next character is valid, the corresponding multibyte character is stored in `wchar` if it is not a null pointer. If the character is the corresponding wide null character, the resulting state of `mbstate` is the initial conversion state.  \n  \n The `mbrtowc` function differs from [mbtowc, _mbtowc_l](../../c-runtime-library/reference/mbtowc-mbtowc-l.md) by its restartability. The conversion state is stored in `mbstate` for subsequent calls to the same or other restartable functions. Results are undefined when mixing the use of restartable and nonrestartable functions.  For example, an application should use `wcsrlen` instead of `wcslen` if a subsequent call to `wcsrtombs` is used instead of `wcstombs`.  \n  \n## Example  \n Converts a multibyte character to its wide character equivalent.  \n  \n```  \n// crt_mbrtowc.cpp  \n  \n#include <stdio.h>  \n#include <mbctype.h>  \n#include <string.h>  \n#include <locale.h>  \n#include <wchar.h>  \n  \n#define BUF_SIZE 100  \n  \nint Sample(char* szIn, wchar_t* wcOut, int nMax)  \n{  \n    mbstate_t   state = {0}; // Initial state  \n    size_t      nConvResult,   \n                nmbLen = 0,  \n                nwcLen = 0;  \n    wchar_t*    wcCur = wcOut;  \n    wchar_t*    wcEnd = wcCur + nMax;  \n    const char* mbCur = szIn;  \n    const char* mbEnd = mbCur + strlen(mbCur) + 1;  \n    char*       szLocal;  \n  \n    // Sets all locale to French_Canada.1252  \n    szLocal = setlocale(LC_ALL, \"French_Canada.1252\");  \n    if (!szLocal)  \n    {  \n        printf(\"The fuction setlocale(LC_ALL, \\\"French_Canada.1252\\\") failed!\\n\");  \n        return 1;  \n    }  \n  \n    printf(\"Locale set to: \\\"%s\\\"\\n\", szLocal);  \n  \n    // Sets the code page associated current locale's code page  \n    // from a previous call to setlocale.  \n    if (_setmbcp(_MB_CP_SBCS) == -1)  \n    {  \n        printf(\"The fuction _setmbcp(_MB_CP_SBCS) failed!\");  \n        return 1;  \n    }  \n  \n    while ((mbCur < mbEnd) && (wcCur < wcEnd))  \n    {  \n        //  \n        nConvResult = mbrtowc(wcCur, mbCur, 1, &state);  \n        switch (nConvResult)  \n        {  \n            case 0:  \n            {  // done  \n                printf(\"Conversion succeeded!\\nMultibyte String: \");  \n                printf(szIn);  \n                printf(\"\\nWC String: \");  \n                wprintf(wcOut);  \n                printf(\"\\n\");  \n                mbCur = mbEnd;  \n                break;  \n            }  \n  \n            case -1:  \n            {  // encoding error  \n                printf(\"The call to mbrtowc has detected an encoding error.\\n\");  \n                mbCur = mbEnd;  \n                break;  \n            }  \n  \n            case -2:  \n            {  // incomplete character  \n                if   (!mbsinit(&state))  \n                {  \n                    printf(\"Currently in middle of mb conversion, state = %x\\n\", state);  \n                    // state will contain data regarding lead byte of mb character  \n                }  \n  \n                ++nmbLen;  \n                ++mbCur;  \n                break;  \n            }  \n  \n            default:  \n            {  \n                if   (nConvResult > 2) // The multibyte should never be larger than 2  \n                {  \n                    printf(\"Error: The size of the converted multibyte is %d.\\n\", nConvResult);  \n                }  \n  \n                ++nmbLen;  \n                ++nwcLen;  \n                ++wcCur;  \n                ++mbCur;  \n            break;  \n            }  \n        }  \n    }  \n  \n   return 0;  \n}  \n  \nint main(int argc, char* argv[])  \n{  \n    char    mbBuf[BUF_SIZE] = \"AaBbCc\\x9A\\x8B\\xE0\\xEF\\xF0xXyYzZ\";  \n    wchar_t wcBuf[BUF_SIZE] = {L''};  \n  \n    return Sample(mbBuf, wcBuf, BUF_SIZE);  \n}  \n```  \n  \n## Sample Output  \n  \n```  \nLocale set to: \"French_Canada.1252\"  \nConversion succeeded!  \nMultibyte String: AaBbCcÜïα∩≡xXyYzZ  \nWC String: AaBbCcÜïα∩≡xXyYzZ  \n```  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`mbrtowc`|\\<wchar.h>|  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [Data Conversion](../../c-runtime-library/data-conversion.md)   \n [Locale](../../c-runtime-library/locale.md)   \n [Interpretation of Multibyte-Character Sequences](../../c-runtime-library/interpretation-of-multibyte-character-sequences.md)"}