{"nodes":[{"pos":[12,91],"content":"How to: Interface Between Exceptional and Non-Exceptional Code | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Interface Between Exceptional and Non-Exceptional Code | Microsoft Docs","pos":[0,79]}]},{"content":"How to: Interface Between Exceptional and Non-Exceptional Code","pos":[572,634]},{"content":"This article describes how to implement consistent exception-handling in a C++ module, and also how to translate those exceptions to and from error codes at the exception boundaries.","pos":[635,817]},{"content":"Sometimes a C++ module has to interface with code that doesn't use exceptions (non-exceptional code).","pos":[824,925]},{"content":"Such an interface is known as an <bpt id=\"p1\">*</bpt>exception boundary<ept id=\"p1\">*</ept>.","pos":[926,980],"source":" Such an interface is known as an *exception boundary*."},{"content":"For example, you may want to call the Win32 function <ph id=\"ph1\">`CreateFile`</ph> in your C++ program.","pos":[981,1067],"source":" For example, you may want to call the Win32 function `CreateFile` in your C++ program."},{"content":"doesn't throw exceptions; instead it sets error codes that can be retrieved by the <ph id=\"ph1\">`GetLastError`</ph> function.","pos":[1081,1188],"source":" doesn't throw exceptions; instead it sets error codes that can be retrieved by the `GetLastError` function."},{"content":"If your C++ program is non-trivial, then in it you probably prefer to have a consistent exception-based error-handling policy.","pos":[1189,1315]},{"content":"And you probably don't want to abandon exceptions just because you interface with non-exceptional code, and neither do you want to mix exception-based and non-exception-based error policies in your C++ module.","pos":[1316,1525]},{"content":"Calling Non-Exceptional Functions from C++","pos":[1534,1576]},{"content":"When you call a non-exceptional function from C++, the idea is to wrap that function in a C++ function that detects any errors and then possibly throws an exception.","pos":[1580,1745]},{"content":"When you design such a wrapper function, first decide which type of exception guarantee to provide:  no-throw, strong, or basic.","pos":[1746,1874]},{"content":"Second, design the function so that all resources, for example, file handles, are correctly released if an exception is thrown.","pos":[1875,2002]},{"content":"Typically, this means that you use smart pointers or similar resource managers to own the resources.","pos":[2003,2103]},{"content":"For more information about design considerations, see <bpt id=\"p1\">[</bpt>How to: Design for Exception Safety<ept id=\"p1\">](../cpp/how-to-design-for-exception-safety.md)</ept>.","pos":[2104,2242],"source":" For more information about design considerations, see [How to: Design for Exception Safety](../cpp/how-to-design-for-exception-safety.md)."},{"content":"Example","pos":[2252,2259]},{"content":"The following example shows C++ functions that use the Win32 <ph id=\"ph1\">`CreateFile`</ph> and <ph id=\"ph2\">`ReadFile`</ph> functions internally to open and read two files.","pos":[2263,2400],"source":"The following example shows C++ functions that use the Win32 `CreateFile` and `ReadFile` functions internally to open and read two files."},{"content":"The <ph id=\"ph1\">`File`</ph> class is a resource acquisition is initialization (RAII) wrapper for the file handles.","pos":[2402,2499],"source":"  The `File` class is a resource acquisition is initialization (RAII) wrapper for the file handles."},{"content":"Its constructor detects a \"file not found\" condition and throws an exception to propagate the error up the call stack of the C++ module (in this example, the <ph id=\"ph1\">`main()`</ph> function).","pos":[2500,2677],"source":" Its constructor detects a \"file not found\" condition and throws an exception to propagate the error up the call stack of the C++ module (in this example, the `main()` function)."},{"content":"If an exception is thrown after a <ph id=\"ph1\">`File`</ph> object is fully constructed, the destructor automatically calls <ph id=\"ph2\">`CloseHandle`</ph> to release the file handle.","pos":[2678,2824],"source":" If an exception is thrown after a `File` object is fully constructed, the destructor automatically calls `CloseHandle` to release the file handle."},{"content":"(If you prefer, you can use the Active Template Library (ATL) <ph id=\"ph1\">`CHandle`</ph> class for this same purpose, or a <ph id=\"ph2\">`unique_ptr`</ph> together with a custom deleter.) The functions that call Win32 and CRT APIs detect errors and then throw C++ exceptions using the locally-defined <ph id=\"ph3\">`ThrowLastErrorIf`</ph> function, which in turn uses the <ph id=\"ph4\">`Win32Exception`</ph> class, derived from the <ph id=\"ph5\">`runtime_error`</ph> class.","pos":[2825,3205],"source":" (If you prefer, you can use the Active Template Library (ATL) `CHandle` class for this same purpose, or a `unique_ptr` together with a custom deleter.) The functions that call Win32 and CRT APIs detect errors and then throw C++ exceptions using the locally-defined `ThrowLastErrorIf` function, which in turn uses the `Win32Exception` class, derived from the `runtime_error` class."},{"content":"All functions in this example provide a strong exception guarantee; if an exception is thrown at any point in these functions, no resources are leaked and no program state is modified.","pos":[3206,3390]},{"content":"Calling Exceptional Code from Non-Exceptional Code","pos":[7032,7082]},{"content":"C++ functions that are declared as \"extern C\" can be called by C programs.","pos":[7086,7160]},{"content":"C++ COM servers can be consumed by code written in any of a number of different languages.","pos":[7161,7251]},{"content":"When you implement public exception-aware functions in C++ to be called by non-exceptional code, the C++ function must not allow any exceptions to propagate back to the caller.","pos":[7252,7428]},{"content":"Therefore, the C++ function must specifically catch every exception that it knows how to handle and, if appropriate, convert the exception to an error code that the caller understands.","pos":[7429,7613]},{"content":"If not all potential exceptions are known, the C++ function should have a <ph id=\"ph1\">`catch(…)`</ph> block as the last handler.","pos":[7614,7725],"source":" If not all potential exceptions are known, the C++ function should have a `catch(…)` block as the last handler."},{"content":"In such a case, it's best to report a fatal error to the caller, because your program might be in an unknown state.","pos":[7726,7841]},{"content":"The following example shows a function that assumes that any exception that might be thrown is either a Win32Exception or an exception type derived from <ph id=\"ph1\">`std::exception`</ph>.","pos":[7848,8018],"source":"The following example shows a function that assumes that any exception that might be thrown is either a Win32Exception or an exception type derived from `std::exception`."},{"content":"The function catches any exception of these types and propagates the error information as a Win32 error code to the caller.","pos":[8019,8142]},{"content":"When you convert from exceptions to error codes, one potential issue is that error codes often don't contain the richness of information that an exception can store.","pos":[8727,8892]},{"content":"To address this, you can provide a <ph id=\"ph1\">`catch`</ph> block for each specific exception type that might be thrown, and perform logging to record the details of the exception before it is converted to an error code.","pos":[8893,9096],"source":" To address this, you can provide a `catch` block for each specific exception type that might be thrown, and perform logging to record the details of the exception before it is converted to an error code."},{"content":"This approach can create a lot of code repetition if multiple functions all use the same set of <ph id=\"ph1\">`catch`</ph> blocks.","pos":[9097,9208],"source":" This approach can create a lot of code repetition if multiple functions all use the same set of `catch` blocks."},{"content":"A good way to avoid code repetition is by refactoring those blocks into one private utility function that implements the <ph id=\"ph1\">`try`</ph> and <ph id=\"ph2\">`catch`</ph> blocks and accepts a function object that is invoked in the <ph id=\"ph3\">`try`</ph> block.","pos":[9209,9420],"source":" A good way to avoid code repetition is by refactoring those blocks into one private utility function that implements the `try` and `catch` blocks and accepts a function object that is invoked in the `try` block."},{"content":"In each public function, pass the code to the utility function as a lambda expression.","pos":[9421,9507]},{"content":"The following example shows how to write the lambda expression that defines the functor.","pos":[9889,9977]},{"content":"When a functor is defined \"inline\" by using a lambda expression, it is often easier to read than it would be if it were written as a named function object.","pos":[9978,10133]},{"pos":[10538,10647],"content":"For more information about lambda expressions, see <bpt id=\"p1\">[</bpt>Lambda Expressions<ept id=\"p1\">](../cpp/lambda-expressions-in-cpp.md)</ept>.","source":"For more information about lambda expressions, see [Lambda Expressions](../cpp/lambda-expressions-in-cpp.md)."},{"content":"See Also","pos":[10656,10664]},{"content":"Errors and Exception Handling","pos":[10669,10698]},{"content":"How to: Design for Exception Safety","pos":[10757,10792]}],"content":"---\ntitle: \"How to: Interface Between Exceptional and Non-Exceptional Code | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: fd5bb4af-5665-46a1-a321-614b48d4061e\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Interface Between Exceptional and Non-Exceptional Code\nThis article describes how to implement consistent exception-handling in a C++ module, and also how to translate those exceptions to and from error codes at the exception boundaries.  \n  \n Sometimes a C++ module has to interface with code that doesn't use exceptions (non-exceptional code). Such an interface is known as an *exception boundary*. For example, you may want to call the Win32 function `CreateFile` in your C++ program. `CreateFile` doesn't throw exceptions; instead it sets error codes that can be retrieved by the `GetLastError` function. If your C++ program is non-trivial, then in it you probably prefer to have a consistent exception-based error-handling policy. And you probably don't want to abandon exceptions just because you interface with non-exceptional code, and neither do you want to mix exception-based and non-exception-based error policies in your C++ module.  \n  \n## Calling Non-Exceptional Functions from C++  \n When you call a non-exceptional function from C++, the idea is to wrap that function in a C++ function that detects any errors and then possibly throws an exception. When you design such a wrapper function, first decide which type of exception guarantee to provide:  no-throw, strong, or basic. Second, design the function so that all resources, for example, file handles, are correctly released if an exception is thrown. Typically, this means that you use smart pointers or similar resource managers to own the resources. For more information about design considerations, see [How to: Design for Exception Safety](../cpp/how-to-design-for-exception-safety.md).  \n  \n### Example  \n The following example shows C++ functions that use the Win32 `CreateFile` and `ReadFile` functions internally to open and read two files.  The `File` class is a resource acquisition is initialization (RAII) wrapper for the file handles. Its constructor detects a \"file not found\" condition and throws an exception to propagate the error up the call stack of the C++ module (in this example, the `main()` function). If an exception is thrown after a `File` object is fully constructed, the destructor automatically calls `CloseHandle` to release the file handle. (If you prefer, you can use the Active Template Library (ATL) `CHandle` class for this same purpose, or a `unique_ptr` together with a custom deleter.) The functions that call Win32 and CRT APIs detect errors and then throw C++ exceptions using the locally-defined `ThrowLastErrorIf` function, which in turn uses the `Win32Exception` class, derived from the `runtime_error` class. All functions in this example provide a strong exception guarantee; if an exception is thrown at any point in these functions, no resources are leaked and no program state is modified.  \n  \n```cpp  \n// compile with: /EHsc  \n#include <Windows.h>  \n#include <stdlib.h>  \n#include <vector>  \n#include <iostream>  \n#include <string>  \n#include <limits>  \n#include <stdexcept>  \n  \nusing namespace std;  \n  \nstring FormatErrorMessage(DWORD error, const string& msg)  \n{  \n    static const int BUFFERLENGTH = 1024;  \n    vector<char> buf(BUFFERLENGTH);  \n    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, error, 0, buf.data(),   \n        BUFFERLENGTH - 1, 0);   \n    return string(buf.data()) + \"   (\"  + msg  + \")\";  \n}  \n  \nclass Win32Exception : public runtime_error  \n{      \nprivate:  \n    DWORD m_error;  \npublic:  \n    Win32Exception(DWORD error, const string& msg)  \n        : runtime_error(FormatErrorMessage(error, msg)), m_error(error) { }  \n  \n    DWORD GetErrorCode() const { return m_error; }  \n};  \n  \nvoid ThrowLastErrorIf(bool expression, const string& msg)   \n{   \n    if (expression) {   \n        throw Win32Exception(GetLastError(), msg);   \n    }   \n}   \n  \nclass File  \n{  \nprivate:  \n    HANDLE m_handle;  \n  \n    // Declared but not defined, to avoid double closing.  \n    File& operator=(const File&);  \n    File(const File&);  \npublic:  \n    explicit File(const string& filename)   \n    {  \n        m_handle = CreateFileA(filename.c_str(), GENERIC_READ, FILE_SHARE_READ,   \n            nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, nullptr);  \n        ThrowLastErrorIf(m_handle == INVALID_HANDLE_VALUE,   \n            \"CreateFile call failed on file named \" + filename);  \n    }  \n  \n    ~File() { CloseHandle(m_handle); }  \n  \n    HANDLE GetHandle() { return m_handle; }  \n};  \n  \nsize_t GetFileSizeSafe(const string& filename)  \n{  \n    File fobj(filename);  \n    LARGE_INTEGER filesize;  \n  \n    BOOL result = GetFileSizeEx(fobj.GetHandle(), &filesize);  \n    ThrowLastErrorIf(result == FALSE, \"GetFileSizeEx failed: \" + filename);  \n  \n    if (filesize.QuadPart < (numeric_limits<size_t>::max)()) {  \n        return filesize.QuadPart;  \n    } else {  \n        throw;   \n    }  \n}  \n  \nvector<char> ReadFileVector(const string& filename)  \n{  \n    File fobj(filename);  \n    size_t filesize = GetFileSizeSafe(filename);  \n    DWORD bytesRead = 0;  \n  \n    vector<char> readbuffer(filesize);  \n  \n    BOOL result = ReadFile(fobj.GetHandle(), readbuffer.data(), readbuffer.size(),   \n        &bytesRead, nullptr);  \n    ThrowLastErrorIf(result == FALSE, \"ReadFile failed: \" + filename);  \n  \n    cout << filename << \" file size: \" << filesize << \", bytesRead: \"   \n        << bytesRead << endl;  \n  \n    return readbuffer;  \n}  \n  \nbool IsFileDiff(const string& filename1, const string& filename2)   \n{  \n    return ReadFileVector(filename1) != ReadFileVector(filename2);  \n}   \n  \n#include <iomanip>  \n  \nint main ( int argc, char* argv[] )  \n{  \n    string filename1(\"file1.txt\");  \n    string filename2(\"file2.txt\");  \n  \n    try  \n    {  \n        if(argc > 2) {  \n            filename1 = argv[1];  \n            filename2 = argv[2];  \n        }   \n  \n        cout << \"Using file names \" << filename1 << \" and \" << filename2 << endl;  \n  \n        if (IsFileDiff(filename1, filename2)) {  \n            cout << \"*** Files are different.\" << endl;  \n        } else {  \n            cout<< \"*** Files match.\" << endl;  \n        }  \n    }  \n    catch(const Win32Exception& e)  \n    {          \n        ios state(nullptr);  \n        state.copyfmt(cout);  \n        cout << e.what() << endl;  \n        cout << \"Error code: 0x\" << hex << uppercase << setw(8) << setfill('0')   \n            << e.GetErrorCode() << endl;  \n        cout.copyfmt(state); // restore previous formatting  \n    }  \n}  \n  \n```  \n  \n## Calling Exceptional Code from Non-Exceptional Code  \n C++ functions that are declared as \"extern C\" can be called by C programs. C++ COM servers can be consumed by code written in any of a number of different languages. When you implement public exception-aware functions in C++ to be called by non-exceptional code, the C++ function must not allow any exceptions to propagate back to the caller. Therefore, the C++ function must specifically catch every exception that it knows how to handle and, if appropriate, convert the exception to an error code that the caller understands. If not all potential exceptions are known, the C++ function should have a `catch(…)` block as the last handler. In such a case, it's best to report a fatal error to the caller, because your program might be in an unknown state.  \n  \n The following example shows a function that assumes that any exception that might be thrown is either a Win32Exception or an exception type derived from `std::exception`. The function catches any exception of these types and propagates the error information as a Win32 error code to the caller.  \n  \n```cpp  \nBOOL DiffFiles2(const string& file1, const string& file2)   \n{   \n    try   \n    {   \n        File f1(file1);   \n        File f2(file2);   \n        if (IsTextFileDiff(f1, f2))   \n        {   \n            SetLastError(MY_APPLICATION_ERROR_FILE_MISMATCH);   \n            return FALSE;   \n        }   \n        return TRUE;   \n    }   \n    catch(Win32Exception& e)   \n    {   \n        SetLastError(e.GetErrorCode());   \n    }  \n  \n    catch(std::exception& e)   \n    {   \n        SetLastError(MY_APPLICATION_GENERAL_ERROR);   \n    }   \n    return FALSE;   \n}  \n  \n```  \n  \n When you convert from exceptions to error codes, one potential issue is that error codes often don't contain the richness of information that an exception can store. To address this, you can provide a `catch` block for each specific exception type that might be thrown, and perform logging to record the details of the exception before it is converted to an error code. This approach can create a lot of code repetition if multiple functions all use the same set of `catch` blocks. A good way to avoid code repetition is by refactoring those blocks into one private utility function that implements the `try` and `catch` blocks and accepts a function object that is invoked in the `try` block. In each public function, pass the code to the utility function as a lambda expression.  \n  \n```cpp  \ntemplate<typename Func>   \nbool Win32ExceptionBoundary(Func&& f)   \n{   \n    try   \n    {   \n        return f();   \n    }   \n    catch(Win32Exception& e)   \n    {   \n        SetLastError(e.GetErrorCode());   \n    }   \n    catch(const std::exception& e)   \n    {   \n        SetLastError(MY_APPLICATION_GENERAL_ERROR);   \n    }   \n    return false;   \n}  \n  \n```  \n  \n The following example shows how to write the lambda expression that defines the functor. When a functor is defined \"inline\" by using a lambda expression, it is often easier to read than it would be if it were written as a named function object.  \n  \n```cpp  \nbool DiffFiles3(const string& file1, const string& file2)   \n{   \n    return Win32ExceptionBoundary([&]() -> bool  \n    {   \n        File f1(file1);   \n        File f2(file2);   \n        if (IsTextFileDiff(f1, f2))   \n        {   \n            SetLastError(MY_APPLICATION_ERROR_FILE_MISMATCH);   \n            return false;   \n        }   \n        return true;   \n    });   \n}  \n  \n```  \n  \n For more information about lambda expressions, see [Lambda Expressions](../cpp/lambda-expressions-in-cpp.md).  \n  \n## See Also  \n [Errors and Exception Handling](../cpp/errors-and-exception-handling-modern-cpp.md)   \n [How to: Design for Exception Safety](../cpp/how-to-design-for-exception-safety.md)"}