{"nodes":[{"pos":[12,65],"content":"Implementing an STL-Based Collection | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Implementing an STL-Based Collection | Microsoft Docs","pos":[0,53]}]},{"content":"Implementing an STL-Based Collection","pos":[605,641]},{"content":"ATL provides the <ph id=\"ph1\">`ICollectionOnSTLImpl`</ph> interface to enable you to quickly implement Standard Template Library (STL)-based collection interfaces on your objects.","pos":[642,803],"source":"ATL provides the `ICollectionOnSTLImpl` interface to enable you to quickly implement Standard Template Library (STL)-based collection interfaces on your objects."},{"content":"To understand how this class works, you will work through a simple example (below) that uses this class to implement a read-only collection aimed at Automation clients.","pos":[804,972]},{"pos":[979,1057],"content":"The sample code is from the <bpt id=\"p1\">[</bpt>ATLCollections sample<ept id=\"p1\">](../visual-cpp-samples.md)</ept>.","source":"The sample code is from the [ATLCollections sample](../visual-cpp-samples.md)."},{"content":"To complete this procedure, you will:","pos":[1064,1101]},{"pos":[1111,1170],"content":"<bpt id=\"p1\">[</bpt>Generate a new Simple Object<ept id=\"p1\">](#vccongenerating_an_object)</ept>.","source":"[Generate a new Simple Object](#vccongenerating_an_object)."},{"pos":[1180,1248],"content":"<bpt id=\"p1\">[</bpt>Edit the IDL file<ept id=\"p1\">](#vcconedit_the_idl)</ept> for the generated interface.","source":"[Edit the IDL file](#vcconedit_the_idl) for the generated interface."},{"pos":[1258,1424],"content":"<bpt id=\"p1\">[</bpt>Create five typedefs<ept id=\"p1\">](#vcconstorage_and_exposure_typedefs)</ept> describing how the collection items are stored and how they will be exposed to clients via COM interfaces.","source":"[Create five typedefs](#vcconstorage_and_exposure_typedefs) describing how the collection items are stored and how they will be exposed to clients via COM interfaces."},{"pos":[1434,1500],"content":"<bpt id=\"p1\">[</bpt>Create two typedefs for copy policy classes<ept id=\"p1\">](#vcconcopy_classes)</ept>.","source":"[Create two typedefs for copy policy classes](#vcconcopy_classes)."},{"pos":[1510,1612],"content":"<bpt id=\"p1\">[</bpt>Create typedefs for the enumerator and collection implementations<ept id=\"p1\">](#vcconenumeration_and_collection)</ept>.","source":"[Create typedefs for the enumerator and collection implementations](#vcconenumeration_and_collection)."},{"pos":[1622,1720],"content":"<bpt id=\"p1\">[</bpt>Edit the wizard-generated C++ code to use the collection typedef<ept id=\"p1\">](#vcconedit_the_generated_code)</ept>.","source":"[Edit the wizard-generated C++ code to use the collection typedef](#vcconedit_the_generated_code)."},{"pos":[1730,1799],"content":"<bpt id=\"p1\">[</bpt>Add code to populate the collection<ept id=\"p1\">](#vcconpopulate_the_collection)</ept>.","source":"[Add code to populate the collection](#vcconpopulate_the_collection)."},{"pos":[1850,1880],"content":"Generating a New Simple Object"},{"content":"Create a new project, ensuring that the Attributes box under Application Settings is cleared.","pos":[1884,1977]},{"content":"Use the ATL Add Class dialog box and Add Simple Object Wizard to generate a Simple Object called <ph id=\"ph1\">`Words`</ph>.","pos":[1978,2083],"source":" Use the ATL Add Class dialog box and Add Simple Object Wizard to generate a Simple Object called `Words`."},{"content":"Make sure that a dual interface called <ph id=\"ph1\">`IWords`</ph> is generated.","pos":[2084,2145],"source":" Make sure that a dual interface called `IWords` is generated."},{"content":"Objects of the generated class will be used to represent a collection of words (that is, strings).","pos":[2146,2244]},{"pos":[2287,2307],"content":"Editing the IDL File"},{"pos":[2311,2444],"content":"Now, open the IDL file and add the three properties necessary to turn <ph id=\"ph1\">`IWords`</ph> into a read-only collection interface, as shown below:","source":"Now, open the IDL file and add the three properties necessary to turn `IWords` into a read-only collection interface, as shown below:"},{"pos":[2462,2476],"content":"NVC_ATL_COM#24"},{"content":"This is the standard form for a read-only collection interface designed with Automation clients in mind.","pos":[2552,2656]},{"content":"The numbered comments in this interface definition correspond to the comments below:","pos":[2657,2741]},{"content":"Collection interfaces are usually dual because Automation clients accesses the <ph id=\"ph1\">`_NewEnum`</ph> property via <bpt id=\"p1\">**</bpt>IDispatch::Invoke<ept id=\"p1\">**</ept>.","pos":[2751,2876],"source":"Collection interfaces are usually dual because Automation clients accesses the `_NewEnum` property via **IDispatch::Invoke**."},{"content":"However, Automation clients can access the remaining methods via the vtable, so dual interfaces are preferable to dispinterfaces.","pos":[2877,3006]},{"content":"If a dual interface or dispinterface will not be extended at run time (that is, you won't provide extra methods or properties via <bpt id=\"p1\">**</bpt>IDispatch::Invoke<ept id=\"p1\">**</ept>), you should apply the <bpt id=\"p2\">**</bpt>nonextensible<ept id=\"p2\">**</ept> attribute to your definition.","pos":[3016,3238],"source":"If a dual interface or dispinterface will not be extended at run time (that is, you won't provide extra methods or properties via **IDispatch::Invoke**), you should apply the **nonextensible** attribute to your definition."},{"content":"This attribute enables Automation clients to perform full code verification at compile time.","pos":[3239,3331]},{"content":"In this case, the interface should not be extended.","pos":[3332,3383]},{"content":"The correct DISPID is important if you want Automation clients to be able to use this property.","pos":[3393,3488]},{"content":"(Note that there is only one underscore in <bpt id=\"p1\">**</bpt>DISPID_NEWENUM<ept id=\"p1\">**</ept>.)","pos":[3489,3552],"source":" (Note that there is only one underscore in **DISPID_NEWENUM**.)"},{"content":"You can supply any value as the DISPID of the <bpt id=\"p1\">**</bpt>Item<ept id=\"p1\">**</ept> property.","pos":[3562,3626],"source":"You can supply any value as the DISPID of the **Item** property."},{"content":"However, <bpt id=\"p1\">**</bpt>Item<ept id=\"p1\">**</ept> typically uses <bpt id=\"p2\">**</bpt>DISPID_VALUE<ept id=\"p2\">**</ept> to make it the default property of the collection.","pos":[3627,3727],"source":" However, **Item** typically uses **DISPID_VALUE** to make it the default property of the collection."},{"content":"This allows Automation clients to refer to the property without naming it explicitly.","pos":[3728,3813]},{"content":"The data type used for the return value of the <bpt id=\"p1\">**</bpt>Item<ept id=\"p1\">**</ept> property is the type of the item stored in the collection as far as COM clients are concerned.","pos":[3823,3973],"source":"The data type used for the return value of the **Item** property is the type of the item stored in the collection as far as COM clients are concerned."},{"content":"The interface returns strings, so you should use the standard COM string type, <ph id=\"ph1\">`BSTR`</ph>.","pos":[3974,4060],"source":" The interface returns strings, so you should use the standard COM string type, `BSTR`."},{"content":"You can store the data in a different format internally as you'll see shortly.","pos":[4061,4139]},{"content":"The value used for the DISPID of the <bpt id=\"p1\">**</bpt>Count<ept id=\"p1\">**</ept> property is completely arbitrary.","pos":[4149,4229],"source":"The value used for the DISPID of the **Count** property is completely arbitrary."},{"content":"There's no standard DISPID for this property.","pos":[4230,4275]},{"pos":[4335,4377],"content":"Creating Typedefs for Storage and Exposure"},{"content":"Once the collection interface is defined, you need to decide how the data will be stored, and how the data will be exposed via the enumerator.","pos":[4381,4523]},{"content":"The answers to these questions can be provided in the form of a number of typedefs, which you can add near the top of the header file for your newly created class:","pos":[4530,4693]},{"pos":[4711,4725],"content":"NVC_ATL_COM#25"},{"content":"In this case, you will store the data as a <bpt id=\"p1\">**</bpt>std::vector<ept id=\"p1\">**</ept> of <bpt id=\"p2\">**</bpt>std::string<ept id=\"p2\">**</ept>s.","pos":[4799,4878],"source":"In this case, you will store the data as a **std::vector** of **std::string**s."},{"content":"<bpt id=\"p1\">**</bpt>std::vector<ept id=\"p1\">**</ept> is an STL container class that behaves like a managed array.","pos":[4879,4955],"source":"**std::vector** is an STL container class that behaves like a managed array."},{"content":"<bpt id=\"p1\">**</bpt>std::string<ept id=\"p1\">**</ept> is the Standard C++ Library's string class.","pos":[4956,5015],"source":"**std::string** is the Standard C++ Library's string class."},{"content":"These classes make it easy to work with a collection of strings.","pos":[5016,5080]},{"content":"Since Visual Basic support is vital to the success of this interface, the enumerator returned by the <ph id=\"ph1\">`_NewEnum`</ph> property must support the <bpt id=\"p1\">**</bpt>IEnumVARIANT<ept id=\"p1\">**</ept> interface.","pos":[5087,5252],"source":"Since Visual Basic support is vital to the success of this interface, the enumerator returned by the `_NewEnum` property must support the **IEnumVARIANT** interface."},{"content":"This is the only enumerator interface understood by Visual Basic.","pos":[5253,5318]},{"pos":[5361,5402],"content":"Creating Typedefs for Copy Policy Classes"},{"content":"The typedefs you have created so far provide all the information you need to create further typedefs for the copy classes that will be used by the enumerator and collection:","pos":[5406,5579]},{"pos":[5597,5611],"content":"NVC_ATL_COM#26"},{"content":"In this example, you can use the custom <ph id=\"ph1\">`GenericCopy`</ph> class defined in VCUE_Copy.h and VCUE_CopyString.h from the <bpt id=\"p1\">[</bpt>ATLCollections<ept id=\"p1\">](../visual-cpp-samples.md)</ept> sample.","pos":[5685,5849],"source":"In this example, you can use the custom `GenericCopy` class defined in VCUE_Copy.h and VCUE_CopyString.h from the [ATLCollections](../visual-cpp-samples.md) sample."},{"content":"You can use this class in other code, but you may need to define further specializations of <ph id=\"ph1\">`GenericCopy`</ph> to support data types used in your own collections.","pos":[5850,6007],"source":" You can use this class in other code, but you may need to define further specializations of `GenericCopy` to support data types used in your own collections."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>ATL Copy Policy Classes<ept id=\"p1\">](../atl/atl-copy-policy-classes.md)</ept>.","pos":[6008,6095],"source":" For more information, see [ATL Copy Policy Classes](../atl/atl-copy-policy-classes.md)."},{"pos":[6152,6200],"content":"Creating Typedefs for Enumeration and Collection"},{"content":"Now all the template parameters necessary to specialize the <ph id=\"ph1\">`CComEnumOnSTL`</ph> and <ph id=\"ph2\">`ICollectionOnSTLImpl`</ph> classes for this situation have been provided in the form of typedefs.","pos":[6204,6377],"source":"Now all the template parameters necessary to specialize the `CComEnumOnSTL` and `ICollectionOnSTLImpl` classes for this situation have been provided in the form of typedefs."},{"content":"To simplify the use of the specializations, create two more typedefs as shown below:","pos":[6378,6462]},{"pos":[6480,6494],"content":"NVC_ATL_COM#27"},{"pos":[6568,6762],"content":"Now <ph id=\"ph1\">`CollectionType`</ph> is a synonym for a specialization of <ph id=\"ph2\">`ICollectionOnSTLImpl`</ph> that implements the <ph id=\"ph3\">`IWords`</ph> interface defined earlier and provides an enumerator that supports <bpt id=\"p1\">**</bpt>IEnumVARIANT<ept id=\"p1\">**</ept>.","source":"Now `CollectionType` is a synonym for a specialization of `ICollectionOnSTLImpl` that implements the `IWords` interface defined earlier and provides an enumerator that supports **IEnumVARIANT**."},{"pos":[6816,6849],"content":"Editing the Wizard-Generated Code"},{"pos":[6853,6997],"content":"Now you must derive <ph id=\"ph1\">`CWords`</ph> from the interface implementation represented by the <ph id=\"ph2\">`CollectionType`</ph> typedef rather than <ph id=\"ph3\">`IWords`</ph>, as shown below:","source":"Now you must derive `CWords` from the interface implementation represented by the `CollectionType` typedef rather than `IWords`, as shown below:"},{"pos":[7015,7029],"content":"NVC_ATL_COM#28"},{"pos":[7150,7188],"content":"Adding Code to Populate the Collection"},{"content":"The only thing that remains is to populate the vector with data.","pos":[7192,7256]},{"content":"In this simple example, you can add a few words to the collection in the constructor for the class:","pos":[7257,7356]},{"pos":[7374,7388],"content":"NVC_ATL_COM#29"},{"content":"Now, you can test the code with the client of your choice.","pos":[7462,7520]},{"content":"See Also","pos":[7529,7537]},{"content":"Collections and Enumerators","pos":[7542,7569]},{"content":"ATLCollections Sample","pos":[7619,7640]},{"content":"ATL Copy Policy Classes","pos":[7673,7696]}],"content":"---\ntitle: \"Implementing an STL-Based Collection | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"ICollectionOnSTLImpl interface\"\nms.assetid: 6d49f819-1957-4813-b074-3f12c494d8ca\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Implementing an STL-Based Collection\nATL provides the `ICollectionOnSTLImpl` interface to enable you to quickly implement Standard Template Library (STL)-based collection interfaces on your objects. To understand how this class works, you will work through a simple example (below) that uses this class to implement a read-only collection aimed at Automation clients.  \n  \n The sample code is from the [ATLCollections sample](../visual-cpp-samples.md).  \n  \n To complete this procedure, you will:  \n  \n-   [Generate a new Simple Object](#vccongenerating_an_object).  \n  \n-   [Edit the IDL file](#vcconedit_the_idl) for the generated interface.  \n  \n-   [Create five typedefs](#vcconstorage_and_exposure_typedefs) describing how the collection items are stored and how they will be exposed to clients via COM interfaces.  \n  \n-   [Create two typedefs for copy policy classes](#vcconcopy_classes).  \n  \n-   [Create typedefs for the enumerator and collection implementations](#vcconenumeration_and_collection).  \n  \n-   [Edit the wizard-generated C++ code to use the collection typedef](#vcconedit_the_generated_code).  \n  \n-   [Add code to populate the collection](#vcconpopulate_the_collection).  \n  \n##  <a name=\"vccongenerating_an_object\"></a> Generating a New Simple Object  \n Create a new project, ensuring that the Attributes box under Application Settings is cleared. Use the ATL Add Class dialog box and Add Simple Object Wizard to generate a Simple Object called `Words`. Make sure that a dual interface called `IWords` is generated. Objects of the generated class will be used to represent a collection of words (that is, strings).  \n  \n##  <a name=\"vcconedit_the_idl\"></a> Editing the IDL File  \n Now, open the IDL file and add the three properties necessary to turn `IWords` into a read-only collection interface, as shown below:  \n  \n [!code-cpp[NVC_ATL_COM#24](../atl/codesnippet/cpp/implementing-an-stl-based-collection_1.idl)]  \n  \n This is the standard form for a read-only collection interface designed with Automation clients in mind. The numbered comments in this interface definition correspond to the comments below:  \n  \n1.  Collection interfaces are usually dual because Automation clients accesses the `_NewEnum` property via **IDispatch::Invoke**. However, Automation clients can access the remaining methods via the vtable, so dual interfaces are preferable to dispinterfaces.  \n  \n2.  If a dual interface or dispinterface will not be extended at run time (that is, you won't provide extra methods or properties via **IDispatch::Invoke**), you should apply the **nonextensible** attribute to your definition. This attribute enables Automation clients to perform full code verification at compile time. In this case, the interface should not be extended.  \n  \n3.  The correct DISPID is important if you want Automation clients to be able to use this property. (Note that there is only one underscore in **DISPID_NEWENUM**.)  \n  \n4.  You can supply any value as the DISPID of the **Item** property. However, **Item** typically uses **DISPID_VALUE** to make it the default property of the collection. This allows Automation clients to refer to the property without naming it explicitly.  \n  \n5.  The data type used for the return value of the **Item** property is the type of the item stored in the collection as far as COM clients are concerned. The interface returns strings, so you should use the standard COM string type, `BSTR`. You can store the data in a different format internally as you'll see shortly.  \n  \n6.  The value used for the DISPID of the **Count** property is completely arbitrary. There's no standard DISPID for this property.  \n  \n##  <a name=\"vcconstorage_and_exposure_typedefs\"></a> Creating Typedefs for Storage and Exposure  \n Once the collection interface is defined, you need to decide how the data will be stored, and how the data will be exposed via the enumerator.  \n  \n The answers to these questions can be provided in the form of a number of typedefs, which you can add near the top of the header file for your newly created class:  \n  \n [!code-cpp[NVC_ATL_COM#25](../atl/codesnippet/cpp/implementing-an-stl-based-collection_2.h)]  \n  \n In this case, you will store the data as a **std::vector** of **std::string**s. **std::vector** is an STL container class that behaves like a managed array. **std::string** is the Standard C++ Library's string class. These classes make it easy to work with a collection of strings.  \n  \n Since Visual Basic support is vital to the success of this interface, the enumerator returned by the `_NewEnum` property must support the **IEnumVARIANT** interface. This is the only enumerator interface understood by Visual Basic.  \n  \n##  <a name=\"vcconcopy_classes\"></a> Creating Typedefs for Copy Policy Classes  \n The typedefs you have created so far provide all the information you need to create further typedefs for the copy classes that will be used by the enumerator and collection:  \n  \n [!code-cpp[NVC_ATL_COM#26](../atl/codesnippet/cpp/implementing-an-stl-based-collection_3.h)]  \n  \n In this example, you can use the custom `GenericCopy` class defined in VCUE_Copy.h and VCUE_CopyString.h from the [ATLCollections](../visual-cpp-samples.md) sample. You can use this class in other code, but you may need to define further specializations of `GenericCopy` to support data types used in your own collections. For more information, see [ATL Copy Policy Classes](../atl/atl-copy-policy-classes.md).  \n  \n##  <a name=\"vcconenumeration_and_collection\"></a> Creating Typedefs for Enumeration and Collection  \n Now all the template parameters necessary to specialize the `CComEnumOnSTL` and `ICollectionOnSTLImpl` classes for this situation have been provided in the form of typedefs. To simplify the use of the specializations, create two more typedefs as shown below:  \n  \n [!code-cpp[NVC_ATL_COM#27](../atl/codesnippet/cpp/implementing-an-stl-based-collection_4.h)]  \n  \n Now `CollectionType` is a synonym for a specialization of `ICollectionOnSTLImpl` that implements the `IWords` interface defined earlier and provides an enumerator that supports **IEnumVARIANT**.  \n  \n##  <a name=\"vcconedit_the_generated_code\"></a> Editing the Wizard-Generated Code  \n Now you must derive `CWords` from the interface implementation represented by the `CollectionType` typedef rather than `IWords`, as shown below:  \n  \n [!code-cpp[NVC_ATL_COM#28](../atl/codesnippet/cpp/implementing-an-stl-based-collection_5.h)]  \n  \n##  <a name=\"vcconpopulate_the_collection\"></a> Adding Code to Populate the Collection  \n The only thing that remains is to populate the vector with data. In this simple example, you can add a few words to the collection in the constructor for the class:  \n  \n [!code-cpp[NVC_ATL_COM#29](../atl/codesnippet/cpp/implementing-an-stl-based-collection_6.h)]  \n  \n Now, you can test the code with the client of your choice.  \n  \n## See Also  \n [Collections and Enumerators](../atl/atl-collections-and-enumerators.md)   \n [ATLCollections Sample](../visual-cpp-samples.md)   \n [ATL Copy Policy Classes](../atl/atl-copy-policy-classes.md)\n\n"}