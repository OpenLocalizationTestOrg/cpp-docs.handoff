{"nodes":[{"pos":[12,49],"content":"umeric_limits Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"umeric_limits Class | Microsoft Docs","pos":[0,36]}]},{"content":"numeric_limits Class","pos":[698,718]},{"content":"The template class describes arithmetic properties of built-in numerical types.","pos":[719,798]},{"content":"Syntax","pos":[807,813]},{"content":"Parameters","pos":[886,896]},{"content":"The fundamental element data type whose properties are being tested or queried or set.","pos":[910,996]},{"content":"Remarks","pos":[1005,1012]},{"content":"The header defines explicit specializations for the types <ph id=\"ph1\">`wchar_t`</ph>, <ph id=\"ph2\">`bool`</ph>, <ph id=\"ph3\">`char`</ph>, <ph id=\"ph4\">`signed char`</ph>, <ph id=\"ph5\">`unsigned char`</ph>, <ph id=\"ph6\">`short`</ph>, <ph id=\"ph7\">`unsigned short`</ph>, <ph id=\"ph8\">`int`</ph>, <ph id=\"ph9\">`unsigned int`</ph>, <ph id=\"ph10\">`long`</ph>, <ph id=\"ph11\">`unsigned long`</ph>, <ph id=\"ph12\">`float`</ph>, <ph id=\"ph13\">`double`</ph>, <ph id=\"ph14\">`long double`</ph><bpt id=\"p1\">**</bpt>,<ept id=\"p1\">**</ept> <ph id=\"ph15\">`long long`</ph>, <ph id=\"ph16\">`unsigned long long`</ph>, <ph id=\"ph17\">`char16_t`</ph>, and <ph id=\"ph18\">`char32_t`</ph>.","pos":[1016,1308],"source":"The header defines explicit specializations for the types `wchar_t`, `bool`, `char`, `signed char`, `unsigned char`, `short`, `unsigned short`, `int`, `unsigned int`, `long`, `unsigned long`, `float`, `double`, `long double`**,** `long long`, `unsigned long long`, `char16_t`, and `char32_t`."},{"content":"For these explicit specializations, the member <bpt id=\"p1\">[</bpt>numeric_limits::is_specialized<ept id=\"p1\">](#numeric_limits__is_specialized)</ept> is <ph id=\"ph1\">`true`</ph>, and all relevant members have meaningful values.","pos":[1309,1481],"source":" For these explicit specializations, the member [numeric_limits::is_specialized](#numeric_limits__is_specialized) is `true`, and all relevant members have meaningful values."},{"content":"The program can supply additional explicit specializations.","pos":[1482,1541]},{"content":"Most member functions of the class describe or test possible implementations of <ph id=\"ph1\">`float`</ph>.","pos":[1542,1630],"source":" Most member functions of the class describe or test possible implementations of `float`."},{"content":"For an arbitrary specialization, no members have meaningful values.","pos":[1637,1704]},{"content":"A member object that does not have a meaningful value stores zero (or <ph id=\"ph1\">`false`</ph>) and a member function that does not return a meaningful value returns <ph id=\"ph2\">`Type(0)`</ph>.","pos":[1705,1864],"source":" A member object that does not have a meaningful value stores zero (or `false`) and a member function that does not return a meaningful value returns `Type(0)`."},{"content":"Static Functions and Constants","pos":[1874,1904]},{"content":"denorm_min","pos":[1926,1936]},{"content":"Returns the smallest nonzero denormalized value.","pos":[1967,2015]},{"content":"digits","pos":[2021,2027]},{"content":"Returns the number of radix digits that the type can represent without loss of precision.","pos":[2054,2143]},{"content":"digits10","pos":[2149,2157]},{"content":"Returns the number of decimal digits that the type can represent without loss of precision.","pos":[2186,2277]},{"content":"epsilon","pos":[2283,2290]},{"content":"Returns the difference between 1 and the smallest value greater than 1 that the data type can represent.","pos":[2318,2422]},{"content":"has_denorm","pos":[2428,2438]},{"content":"Tests whether a type allows denormalized values.","pos":[2469,2517]},{"content":"has_denorm_loss","pos":[2523,2538]},{"content":"Tests whether loss of accuracy is detected as a denormalization loss rather than as an inexact result.","pos":[2574,2676]},{"content":"has_infinity","pos":[2682,2694]},{"content":"Tests whether a type has a representation for positive infinity.","pos":[2727,2791]},{"content":"has_quiet_NaN","pos":[2797,2810]},{"content":"Tests whether a type has a representation for a quiet not a number (NAN), which is nonsignaling.","pos":[2844,2940]},{"content":"has_signaling_NaN","pos":[2946,2963]},{"content":"Tests whether a type has a representation for signaling not a number (NAN).","pos":[3001,3076]},{"content":"infinity","pos":[3082,3090]},{"content":"The representation for positive infinity for a type, if available.","pos":[3119,3185]},{"content":"is_bounded","pos":[3191,3201]},{"content":"Tests if the set of values that a type may represent is finite.","pos":[3232,3295]},{"content":"is_exact","pos":[3301,3309]},{"content":"Tests if the calculations done on a type are free of rounding errors.","pos":[3338,3407]},{"content":"is_iec559","pos":[3413,3422]},{"content":"Tests if a type conforms to IEC 559 standards.","pos":[3452,3498]},{"content":"is_integer","pos":[3504,3514]},{"content":"Tests if a type has an integer representation.","pos":[3545,3591]},{"content":"is_modulo","pos":[3597,3606]},{"content":"Tests if a type has a modulo representation.","pos":[3636,3680]},{"content":"is_signed","pos":[3686,3695]},{"content":"Tests if a type has a signed representation.","pos":[3725,3769]},{"content":"is_specialized","pos":[3775,3789]},{"pos":[3824,3918],"content":"Tests if a type has an explicit specialization defined in the template class <ph id=\"ph1\">`numeric_limits`</ph>.","source":"Tests if a type has an explicit specialization defined in the template class `numeric_limits`."},{"content":"lowest","pos":[3924,3930]},{"content":"Returns the most negative finite value.","pos":[3957,3996]},{"content":"max","pos":[4002,4005]},{"content":"Returns the maximum finite value for a type.","pos":[4029,4073]},{"content":"max_digits10","pos":[4079,4091]},{"content":"Returns the number of decimal digits required to ensure that two distinct values of the type have distinct decimal representations.","pos":[4124,4255]},{"content":"max_exponent","pos":[4261,4273]},{"content":"Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.","pos":[4306,4459]},{"content":"max_exponent10","pos":[4465,4479]},{"content":"Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.","pos":[4514,4665]},{"content":"min","pos":[4671,4674]},{"content":"Returns the minimum normalized value for a type.","pos":[4698,4746]},{"content":"min_exponent","pos":[4752,4764]},{"content":"Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.","pos":[4797,4950]},{"content":"min_exponent10","pos":[4956,4970]},{"content":"Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.","pos":[5005,5156]},{"content":"quiet_NaN","pos":[5162,5171]},{"content":"Returns the representation of a quiet not a number (NAN) for the type.","pos":[5201,5271]},{"content":"radix","pos":[5277,5282]},{"content":"Returns the integral base, referred to as radix, used for the representation of a type.","pos":[5308,5395]},{"content":"round_error","pos":[5401,5412]},{"content":"Returns the maximum rounding error for the type.","pos":[5444,5492]},{"content":"round_style","pos":[5498,5509]},{"content":"Returns a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.","pos":[5541,5682]},{"content":"signaling_NaN","pos":[5688,5701]},{"content":"Returns the representation of a signaling not a number (NAN) for the type.","pos":[5735,5809]},{"content":"tinyness_before","pos":[5815,5830]},{"content":"Tests whether a type can determine that a value is too small to represent as a normalized value before rounding it.","pos":[5866,5981]},{"content":"traps","pos":[5987,5992]},{"content":"Tests whether trapping that reports on arithmetic exceptions is implemented for a type.","pos":[6018,6105]},{"content":"Requirements","pos":[6115,6127]},{"pos":[6131,6152],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>limits&gt;","source":"**Header:** \\<limits>"},{"pos":[6159,6177],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[6230,6256],"content":"numeric_limits::denorm_min"},{"content":"Returns the smallest nonzero denormalized value.","pos":[6260,6308]},{"content":"Return Value","pos":[6367,6379]},{"content":"The smallest nonzero denormalized value.","pos":[6383,6423]},{"content":"Remarks","pos":[6433,6440]},{"pos":[6458,6505],"content":"is the same as <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept> for the C++ compiler.","source":" is the same as **double** for the C++ compiler."},{"pos":[6512,6694],"content":"The function returns the minimum value for the type, which is the same as <bpt id=\"p1\">[</bpt>min<ept id=\"p1\">](#numeric_limits__min)</ept> if <bpt id=\"p2\">[</bpt>has_denorm<ept id=\"p2\">](#numeric_limits__has_denorm)</ept> is not equal to <bpt id=\"p3\">**</bpt>denorm_present<ept id=\"p3\">**</ept>.","source":"The function returns the minimum value for the type, which is the same as [min](#numeric_limits__min) if [has_denorm](#numeric_limits__has_denorm) is not equal to **denorm_present**."},{"content":"Example","pos":[6704,6711]},{"pos":[7925,7947],"content":"numeric_limits::digits"},{"content":"Returns the number of radix digits that the type can represent without loss of precision.","pos":[7951,8040]},{"content":"Return Value","pos":[8096,8108]},{"content":"The number of radix digits that the type can represent without loss of precision.","pos":[8112,8193]},{"content":"Remarks","pos":[8203,8210]},{"content":"The member stores the number of radix digits that the type can represent without change, which is the number of bits other than any sign bit for a predefined integer type, or the number of mantissa digits for a predefined floating-point type.","pos":[8214,8456]},{"content":"Example","pos":[8466,8473]},{"pos":[9003,9027],"content":"numeric_limits::digits10"},{"content":"Returns the number of decimal digits that the type can represent without loss of precision.","pos":[9031,9122]},{"content":"Return Value","pos":[9180,9192]},{"content":"The number of decimal digits that the type can represent without loss of precision.","pos":[9196,9279]},{"content":"Example","pos":[9289,9296]},{"pos":[9961,9984],"content":"numeric_limits::epsilon"},{"content":"The function returns the difference between 1 and the smallest value greater than 1 that is representable for the data type.","pos":[9988,10112]},{"content":"Return Value","pos":[10168,10180]},{"content":"The difference between 1 and the smallest value greater than 1 that is representable for the data type.","pos":[10184,10287]},{"content":"Remarks","pos":[10297,10304]},{"content":"The value is FLT_EPSILON for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[10308,10352],"source":"The value is FLT_EPSILON for type **float**."},{"content":"for a type is the smallest positive floating-point number <bpt id=\"p1\">*</bpt>N<ept id=\"p1\">*</ept> such that <bpt id=\"p2\">*</bpt>N<ept id=\"p2\">*</ept><ph id=\"ph1\"> + `epsilon` + </ph><bpt id=\"p3\">*</bpt>N<ept id=\"p3\">*</ept> is representable.","pos":[10363,10474],"source":" for a type is the smallest positive floating-point number *N* such that *N* + `epsilon` + *N* is representable."},{"content":"Example","pos":[10484,10491]},{"pos":[11624,11650],"content":"numeric_limits::has_denorm"},{"content":"Tests whether a type allows denormalized values.","pos":[11654,11702]},{"content":"Return Value","pos":[11789,11801]},{"pos":[11805,11920],"content":"An enumeration value of type <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept><ph id=\"ph1\">`float_denorm_style`</ph>, indicating whether the type allows denormalized values.","source":"An enumeration value of type **const**`float_denorm_style`, indicating whether the type allows denormalized values."},{"content":"Remarks","pos":[11930,11937]},{"pos":[11941,12081],"content":"The member stores <bpt id=\"p1\">**</bpt>denorm_present<ept id=\"p1\">**</ept> for a floating-point type that has denormalized values, effectively a variable number of exponent bits.","source":"The member stores **denorm_present** for a floating-point type that has denormalized values, effectively a variable number of exponent bits."},{"content":"Example","pos":[12091,12098]},{"pos":[12916,12947],"content":"numeric_limits::has_denorm_loss"},{"content":"Tests whether loss of accuracy is detected as a denormalization loss rather than as an inexact result.","pos":[12951,13053]},{"content":"Return Value","pos":[13123,13135]},{"pos":[13139,13228],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the loss of accuracy is detected as a denormalization loss; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the loss of accuracy is detected as a denormalization loss; **false** if not."},{"content":"Remarks","pos":[13238,13245]},{"content":"The member stores true for a type that determines whether a value has lost accuracy because it is delivered as a denormalized result (too small to represent as a normalized value) or because it is inexact (not the same as a result not subject to limitations of exponent range and precision), an option with IEC 559 floating-point representations that can affect some results.","pos":[13249,13624]},{"content":"Example","pos":[13634,13641]},{"pos":[14491,14519],"content":"numeric_limits::has_infinity"},{"content":"Tests whether a type has a representation for positive infinity.","pos":[14523,14587]},{"content":"Return Value","pos":[14654,14666]},{"pos":[14670,14752],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has a representation for positive infinity; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has a representation for positive infinity; **false** if not."},{"content":"Remarks","pos":[14762,14769]},{"pos":[14773,14856],"content":"The member returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if <bpt id=\"p2\">[</bpt>is_iec559<ept id=\"p2\">](#numeric_limits__is_iec559)</ept> is <bpt id=\"p3\">**</bpt>true<ept id=\"p3\">**</ept>.","source":"The member returns **true** if [is_iec559](#numeric_limits__is_iec559) is **true**."},{"content":"Example","pos":[14866,14873]},{"pos":[15622,15651],"content":"numeric_limits::has_quiet_NaN"},{"content":"Tests whether a type has a representation for a quiet not a number (NAN), which is nonsignaling.","pos":[15655,15751]},{"content":"Return Value","pos":[15819,15831]},{"pos":[15835,15915],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the <bpt id=\"p2\">**</bpt>type<ept id=\"p2\">**</ept> has a representation for a quiet NAN; <bpt id=\"p3\">**</bpt>false<ept id=\"p3\">**</ept> if not.","source":"**true** if the **type** has a representation for a quiet NAN; **false** if not."},{"content":"Remarks","pos":[15925,15932]},{"content":"A quiet NAN is an encoding for not a number, which does not signal its presence in an expression.","pos":[15936,16033]},{"content":"The return value is <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if <bpt id=\"p2\">[</bpt>is_iec559<ept id=\"p2\">](#numeric_limits__is_iec559)</ept> is true.","pos":[16034,16114],"source":" The return value is **true** if [is_iec559](#numeric_limits__is_iec559) is true."},{"content":"Example","pos":[16124,16131]},{"pos":[16897,16930],"content":"numeric_limits::has_signaling_NaN"},{"content":"Tests whether a type has a representation for signaling not a number (NAN).","pos":[16934,17009]},{"content":"Return Value","pos":[17081,17093]},{"pos":[17097,17177],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has a representation for a signaling NAN; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has a representation for a signaling NAN; **false** if not."},{"content":"Remarks","pos":[17187,17194]},{"content":"A signaling NAN is an encoding for not a number, which signals its presence in an expression.","pos":[17198,17291]},{"content":"The return value is <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept><bpt id=\"p2\">[</bpt>is_iec559<ept id=\"p2\">](#numeric_limits__is_iec559)</ept> is true.","pos":[17292,17368],"source":" The return value is **true**[is_iec559](#numeric_limits__is_iec559) is true."},{"content":"Example","pos":[17378,17385]},{"pos":[18194,18218],"content":"numeric_limits::infinity"},{"content":"The representation of positive infinity for a type, if available.","pos":[18222,18287]},{"content":"Return Value","pos":[18344,18356]},{"content":"The representation of positive infinity for a type, if available.","pos":[18360,18425]},{"content":"Remarks","pos":[18435,18442]},{"pos":[18446,18543],"content":"The return value is meaningful only if <bpt id=\"p1\">[</bpt>has_infinity<ept id=\"p1\">](#numeric_limits__has_infinity)</ept> is <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>.","source":"The return value is meaningful only if [has_infinity](#numeric_limits__has_infinity) is **true**."},{"content":"Example","pos":[18553,18560]},{"pos":[19681,19707],"content":"numeric_limits::is_bounded"},{"content":"Tests if the set of values that a type may represent is finite.","pos":[19711,19774]},{"content":"Return Value","pos":[19839,19851]},{"pos":[19855,19936],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has a bounded set of representable values; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has a bounded set of representable values; **false** if not."},{"content":"Remarks","pos":[19946,19953]},{"pos":[19957,20041],"content":"All predefined types have a bounded set of representable values and return <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept>.","source":"All predefined types have a bounded set of representable values and return **true**."},{"content":"Example","pos":[20051,20058]},{"pos":[21257,21281],"content":"numeric_limits::is_exact"},{"content":"Tests if the calculations done on a type are free of rounding errors.","pos":[21285,21354]},{"content":"Return Value","pos":[21417,21429]},{"pos":[21433,21508],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the calculations are free of rounding errors; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the calculations are free of rounding errors; **false** if not."},{"content":"Remarks","pos":[21518,21525]},{"content":"All predefined integer types have exact representations for their values and return <bpt id=\"p1\">**</bpt>false<ept id=\"p1\">**</ept>.","pos":[21529,21623],"source":"All predefined integer types have exact representations for their values and return **false**."},{"content":"A fixed-point or rational representation is also considered exact, but a floating-point representation is not.","pos":[21624,21734]},{"content":"Example","pos":[21744,21751]},{"pos":[22949,22974],"content":"numeric_limits::is_iec559"},{"content":"Tests if a type conforms to IEC 559 standards.","pos":[22978,23024]},{"content":"Return Value","pos":[23088,23100]},{"pos":[23104,23177],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type conforms to the IEC 559 standards; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type conforms to the IEC 559 standards; **false** if not."},{"content":"Remarks","pos":[23187,23194]},{"content":"The IEC 559 is an international standard for representing floating-point values and is also known as IEEE 754 in the USA.","pos":[23198,23319]},{"content":"Example","pos":[23329,23336]},{"pos":[24349,24375],"content":"numeric_limits::is_integer"},{"content":"Tests if a type has an integer representation.","pos":[24379,24425]},{"content":"Return Value","pos":[24490,24502]},{"pos":[24506,24575],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has an integer representation; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has an integer representation; **false** if not."},{"content":"Remarks","pos":[24585,24592]},{"content":"All predefined integer types have an integer representation.","pos":[24596,24656]},{"content":"Example","pos":[24666,24673]},{"pos":[25722,25747],"content":"numeric_limits::is_modulo"},{"pos":[25751,25799],"content":"Tests if a <bpt id=\"p1\">**</bpt>type<ept id=\"p1\">**</ept> has a modulo representation.","source":"Tests if a **type** has a modulo representation."},{"content":"Return Value","pos":[25863,25875]},{"pos":[25879,25946],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has a modulo representation; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has a modulo representation; **false** if not."},{"content":"Remarks","pos":[25956,25963]},{"content":"A modulo representation is a representation where all results are reduced modulo some value.","pos":[25967,26059]},{"content":"All predefined unsigned integer types have a modulo representation.","pos":[26060,26127]},{"content":"Example","pos":[26137,26144]},{"pos":[27188,27213],"content":"numeric_limits::is_signed"},{"content":"Tests if a type has a signed representation.","pos":[27217,27261]},{"content":"Return Value","pos":[27325,27337]},{"pos":[27341,27408],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has a signed representation; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has a signed representation; **false** if not."},{"content":"Remarks","pos":[27418,27425]},{"content":"The member stores true for a type that has a signed representation, which is the case for all predefined floating-point and signed integer types.","pos":[27429,27574]},{"content":"Example","pos":[27584,27591]},{"pos":[28642,28672],"content":"numeric_limits::is_specialized"},{"pos":[28676,28770],"content":"Tests if a type has an explicit specialization defined in the template class <ph id=\"ph1\">`numeric_limits`</ph>.","source":"Tests if a type has an explicit specialization defined in the template class `numeric_limits`."},{"content":"Return Value","pos":[28839,28851]},{"pos":[28855,28955],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has an explicit specialization defined in the template class; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has an explicit specialization defined in the template class; **false** if not."},{"content":"Remarks","pos":[28965,28972]},{"pos":[28976,29089],"content":"All scalar types other than pointers have an explicit specialization defined for template class <ph id=\"ph1\">`numeric_limits`</ph>.","source":"All scalar types other than pointers have an explicit specialization defined for template class `numeric_limits`."},{"content":"Example","pos":[29099,29106]},{"pos":[30313,30335],"content":"numeric_limits::lowest"},{"content":"Returns the most negative finite value.","pos":[30339,30378]},{"content":"Return Value","pos":[30433,30445]},{"content":"Returns the most negative finite value.","pos":[30449,30488]},{"content":"Remarks","pos":[30498,30505]},{"content":"Returns the most negative finite value for the type (which is typically <ph id=\"ph1\">`min`</ph> <ph id=\"ph2\">`()`</ph> for integer types and <ph id=\"ph3\">`-``max`</ph> <ph id=\"ph4\">`()`</ph> for floating-point types).","pos":[30509,30654],"source":"Returns the most negative finite value for the type (which is typically `min` `()` for integer types and `-``max` `()` for floating-point types)."},{"content":"The return value is meaningful if <ph id=\"ph1\">`is_bounded`</ph> is <ph id=\"ph2\">`true`</ph>.","pos":[30655,30712],"source":" The return value is meaningful if `is_bounded` is `true`."},{"pos":[30758,30777],"content":"numeric_limits::max"},{"content":"Returns the maximum finite value for a type.","pos":[30781,30825]},{"content":"Return Value","pos":[30877,30889]},{"content":"The maximum finite value for a type.","pos":[30893,30929]},{"content":"Remarks","pos":[30939,30946]},{"content":"The maximum finite value is INT_MAX for type <ph id=\"ph1\">`int`</ph> and FLT_MAX for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[30950,31032],"source":"The maximum finite value is INT_MAX for type `int` and FLT_MAX for type **float**."},{"content":"The return value is meaningful if <bpt id=\"p1\">[</bpt>is_bounded<ept id=\"p1\">](#numeric_limits__is_bounded)</ept> is <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>.","pos":[31033,31121],"source":" The return value is meaningful if [is_bounded](#numeric_limits__is_bounded) is **true**."},{"content":"Example","pos":[31131,31138]},{"pos":[31824,31852],"content":"numeric_limits::max_digits10"},{"content":"Returns the number of decimal digits required to make sure that two distinct values of the type have distinct decimal representations.","pos":[31856,31990]},{"content":"Return Value","pos":[32046,32058]},{"content":"Returns the number of decimal digits that are required to make sure that two distinct values of the type have distinct decimal representations.","pos":[32062,32205]},{"content":"Remarks","pos":[32215,32222]},{"content":"The member stores the number of decimal digits required to make sure that two distinct values of the type have distinct decimal representations.","pos":[32226,32370]},{"pos":[32425,32453],"content":"numeric_limits::max_exponent"},{"content":"Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.","pos":[32457,32610]},{"content":"Return Value","pos":[32672,32684]},{"content":"The maximum integral radix-based exponent representable by the type.","pos":[32688,32756]},{"content":"Remarks","pos":[32766,32773]},{"content":"The member function return is meaningful only for floating-point types.","pos":[32777,32848]},{"content":"The <ph id=\"ph1\">`max_exponent`</ph> is the value FLT_MAX_EXP for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[32849,32912],"source":" The `max_exponent` is the value FLT_MAX_EXP for type **float**."},{"content":"Example","pos":[32922,32929]},{"pos":[33791,33821],"content":"numeric_limits::max_exponent10"},{"content":"Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.","pos":[33825,33976]},{"content":"Return Value","pos":[34040,34052]},{"content":"The maximum integral base 10 exponent representable by the type.","pos":[34056,34120]},{"content":"Remarks","pos":[34130,34137]},{"content":"The member function return is meaningful only for floating-point types.","pos":[34141,34212]},{"content":"The <ph id=\"ph1\">`max_exponent`</ph> is the value FLT_MAX_10 for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[34213,34275],"source":" The `max_exponent` is the value FLT_MAX_10 for type **float**."},{"content":"Example","pos":[34285,34292]},{"pos":[35142,35161],"content":"numeric_limits::min"},{"content":"Returns the minimum normalized value for a type.","pos":[35165,35213]},{"content":"Return Value","pos":[35265,35277]},{"content":"The minimum normalized value for the type.","pos":[35281,35323]},{"content":"Remarks","pos":[35333,35340]},{"content":"The minimum normalized value is INT_MIN for type <ph id=\"ph1\">`int`</ph> and FLT_MIN for type <ph id=\"ph2\">`float`</ph>.","pos":[35344,35428],"source":"The minimum normalized value is INT_MIN for type `int` and FLT_MIN for type `float`."},{"content":"The return value is meaningful if <bpt id=\"p1\">[</bpt>is_bounded<ept id=\"p1\">](#numeric_limits__is_bounded)</ept> is <ph id=\"ph1\">`true`</ph> or if <bpt id=\"p2\">[</bpt>is_signed<ept id=\"p2\">](#numeric_limits__is_signed)</ept> is <ph id=\"ph2\">`false`</ph>.","pos":[35429,35572],"source":" The return value is meaningful if [is_bounded](#numeric_limits__is_bounded) is `true` or if [is_signed](#numeric_limits__is_signed) is `false`."},{"content":"Example","pos":[35582,35589]},{"pos":[36507,36535],"content":"numeric_limits::min_exponent"},{"content":"Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.","pos":[36539,36692]},{"content":"Return Value","pos":[36754,36766]},{"content":"The minimum integral radix-based exponent representable by the type.","pos":[36770,36838]},{"content":"Remarks","pos":[36848,36855]},{"content":"The member function is meaningful only for floating-point types.","pos":[36859,36923]},{"content":"The <ph id=\"ph1\">`min_exponent`</ph> is the value FLT_MIN_EXP for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[36924,36987],"source":" The `min_exponent` is the value FLT_MIN_EXP for type **float**."},{"content":"Example","pos":[36997,37004]},{"pos":[37870,37900],"content":"numeric_limits::min_exponent10"},{"content":"Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.","pos":[37904,38055]},{"content":"Return Value","pos":[38119,38131]},{"content":"The minimum integral base 10 exponent representable by the type.","pos":[38135,38199]},{"content":"Remarks","pos":[38209,38216]},{"content":"The member function is meaningful only for floating-point types.","pos":[38220,38284]},{"content":"The <ph id=\"ph1\">`min_exponent10`</ph> is the value FLT_MIN_10_EXP for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[38285,38353],"source":" The `min_exponent10` is the value FLT_MIN_10_EXP for type **float**."},{"content":"Example","pos":[38363,38370]},{"pos":[39211,39236],"content":"numeric_limits::quiet_NaN"},{"content":"Returns the representation of a quiet not a number (NAN) for the type.","pos":[39240,39310]},{"content":"Return Value","pos":[39368,39380]},{"content":"The representation of a quiet NAN for the type.","pos":[39384,39431]},{"content":"Remarks","pos":[39441,39448]},{"pos":[39452,39551],"content":"The return value is meaningful only if <bpt id=\"p1\">[</bpt>has_quiet_NaN<ept id=\"p1\">](#numeric_limits__has_quiet_nan)</ept> is <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>.","source":"The return value is meaningful only if [has_quiet_NaN](#numeric_limits__has_quiet_nan) is **true**."},{"content":"Example","pos":[39561,39568]},{"pos":[40299,40320],"content":"numeric_limits::radix"},{"content":"Returns the integral base, referred to as radix, used for the representation of a type.","pos":[40324,40411]},{"content":"Return Value","pos":[40466,40478]},{"content":"The integral base for the representation of the type.","pos":[40482,40535]},{"content":"Remarks","pos":[40545,40552]},{"content":"The base is 2 for the predefined integer types, and the base to which the exponent is raised, or FLT_RADIX, for the predefined floating-point types.","pos":[40556,40704]},{"content":"Example","pos":[40714,40721]},{"pos":[41391,41418],"content":"numeric_limits::round_error"},{"content":"Returns the maximum rounding error for the type.","pos":[41422,41470]},{"content":"Return Value","pos":[41530,41542]},{"content":"The maximum rounding error for the type.","pos":[41546,41586]},{"content":"Example","pos":[41596,41603]},{"pos":[42418,42445],"content":"numeric_limits::round_style"},{"content":"Returns a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.","pos":[42449,42590]},{"content":"Return Value","pos":[42681,42693]},{"pos":[42697,42780],"content":"A value from the <ph id=\"ph1\">`float_round_style`</ph> enumeration that describes the rounding style.","source":"A value from the `float_round_style` enumeration that describes the rounding style."},{"content":"Remarks","pos":[42790,42797]},{"content":"The member stores a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.","pos":[42801,42952]},{"content":"The round style is hard coded in this implementation, so even if the program starts up with a different rounding mode, that value will not change.","pos":[42959,43105]},{"content":"Example","pos":[43115,43122]},{"pos":[43919,43948],"content":"numeric_limits::signaling_NaN"},{"content":"Returns the representation of a signaling not a number (NAN) for the type.","pos":[43952,44026]},{"content":"Return Value","pos":[44088,44100]},{"content":"The representation of a signaling NAN for the type.","pos":[44104,44155]},{"content":"Remarks","pos":[44165,44172]},{"pos":[44176,44283],"content":"The return value is meaningful only if <bpt id=\"p1\">[</bpt>has_signaling_NaN<ept id=\"p1\">](#numeric_limits__has_signaling_nan)</ept> is <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>.","source":"The return value is meaningful only if [has_signaling_NaN](#numeric_limits__has_signaling_nan) is **true**."},{"content":"Example","pos":[44293,44300]},{"pos":[44918,44949],"content":"numeric_limits::tinyness_before"},{"content":"Tests whether a type can determine that a value is too small to represent as a normalized value before rounding it.","pos":[44953,45068]},{"content":"Return Value","pos":[45138,45150]},{"pos":[45161,45234],"content":"if the type can detect tiny values before rounding; <ph id=\"ph1\">`false`</ph> if it cannot.","source":" if the type can detect tiny values before rounding; `false` if it cannot."},{"content":"Remarks","pos":[45244,45251]},{"content":"Types that can detect tinyness were included as an option with IEC 559 floating-point representations and its implementation can affect some results.","pos":[45255,45404]},{"content":"Example","pos":[45414,45421]},{"pos":[46522,46543],"content":"numeric_limits::traps"},{"content":"Tests whether trapping that reports on arithmetic exceptions is implemented for a type.","pos":[46547,46634]},{"content":"Return Value","pos":[46694,46706]},{"pos":[46710,46783],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if trapping is implemented for the type; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if it is not.","source":"**true** if trapping is implemented for the type; **false** if it is not."},{"content":"Example","pos":[46793,46800]},{"content":"See Also","pos":[47732,47740]},{"content":"Thread Safety in the C++ Standard Library","pos":[47745,47786]}],"content":"---\ntitle: \"numeric_limits Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std::numeric_limits\"\n  - \"std.numeric_limits\"\n  - \"numeric_limits\"\n  - \"limits/std::numeric_limits\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"numeric_limits class\"\nms.assetid: 9e817177-0e91-48e6-b680-0531c4b26625\ncaps.latest.revision: 26\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# numeric_limits Class\nThe template class describes arithmetic properties of built-in numerical types.  \n  \n## Syntax  \n  \n```  \ntemplate <class Type>  \nclass numeric_limits  \n```  \n  \n#### Parameters  \n `Type`  \n The fundamental element data type whose properties are being tested or queried or set.  \n  \n## Remarks  \n The header defines explicit specializations for the types `wchar_t`, `bool`, `char`, `signed char`, `unsigned char`, `short`, `unsigned short`, `int`, `unsigned int`, `long`, `unsigned long`, `float`, `double`, `long double`**,** `long long`, `unsigned long long`, `char16_t`, and `char32_t`. For these explicit specializations, the member [numeric_limits::is_specialized](#numeric_limits__is_specialized) is `true`, and all relevant members have meaningful values. The program can supply additional explicit specializations. Most member functions of the class describe or test possible implementations of `float`.  \n  \n For an arbitrary specialization, no members have meaningful values. A member object that does not have a meaningful value stores zero (or `false`) and a member function that does not return a meaningful value returns `Type(0)`.  \n  \n### Static Functions and Constants  \n  \n|||  \n|-|-|  \n|[denorm_min](#numeric_limits__denorm_min)|Returns the smallest nonzero denormalized value.|  \n|[digits](#numeric_limits__digits)|Returns the number of radix digits that the type can represent without loss of precision.|  \n|[digits10](#numeric_limits__digits10)|Returns the number of decimal digits that the type can represent without loss of precision.|  \n|[epsilon](#numeric_limits__epsilon)|Returns the difference between 1 and the smallest value greater than 1 that the data type can represent.|  \n|[has_denorm](#numeric_limits__has_denorm)|Tests whether a type allows denormalized values.|  \n|[has_denorm_loss](#numeric_limits__has_denorm_loss)|Tests whether loss of accuracy is detected as a denormalization loss rather than as an inexact result.|  \n|[has_infinity](#numeric_limits__has_infinity)|Tests whether a type has a representation for positive infinity.|  \n|[has_quiet_NaN](#numeric_limits__has_quiet_nan)|Tests whether a type has a representation for a quiet not a number (NAN), which is nonsignaling.|  \n|[has_signaling_NaN](#numeric_limits__has_signaling_nan)|Tests whether a type has a representation for signaling not a number (NAN).|  \n|[infinity](#numeric_limits__infinity)|The representation for positive infinity for a type, if available.|  \n|[is_bounded](#numeric_limits__is_bounded)|Tests if the set of values that a type may represent is finite.|  \n|[is_exact](#numeric_limits__is_exact)|Tests if the calculations done on a type are free of rounding errors.|  \n|[is_iec559](#numeric_limits__is_iec559)|Tests if a type conforms to IEC 559 standards.|  \n|[is_integer](#numeric_limits__is_integer)|Tests if a type has an integer representation.|  \n|[is_modulo](#numeric_limits__is_modulo)|Tests if a type has a modulo representation.|  \n|[is_signed](#numeric_limits__is_signed)|Tests if a type has a signed representation.|  \n|[is_specialized](#numeric_limits__is_specialized)|Tests if a type has an explicit specialization defined in the template class `numeric_limits`.|  \n|[lowest](#numeric_limits__lowest)|Returns the most negative finite value.|  \n|[max](#numeric_limits__max)|Returns the maximum finite value for a type.|  \n|[max_digits10](#numeric_limits__max_digits10)|Returns the number of decimal digits required to ensure that two distinct values of the type have distinct decimal representations.|  \n|[max_exponent](#numeric_limits__max_exponent)|Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.|  \n|[max_exponent10](#numeric_limits__max_exponent10)|Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.|  \n|[min](#numeric_limits__min)|Returns the minimum normalized value for a type.|  \n|[min_exponent](#numeric_limits__min_exponent)|Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.|  \n|[min_exponent10](#numeric_limits__min_exponent10)|Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.|  \n|[quiet_NaN](#numeric_limits__quiet_nan)|Returns the representation of a quiet not a number (NAN) for the type.|  \n|[radix](#numeric_limits__radix)|Returns the integral base, referred to as radix, used for the representation of a type.|  \n|[round_error](#numeric_limits__round_error)|Returns the maximum rounding error for the type.|  \n|[round_style](#numeric_limits__round_style)|Returns a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.|  \n|[signaling_NaN](#numeric_limits__signaling_nan)|Returns the representation of a signaling not a number (NAN) for the type.|  \n|[tinyness_before](#numeric_limits__tinyness_before)|Tests whether a type can determine that a value is too small to represent as a normalized value before rounding it.|  \n|[traps](#numeric_limits__traps)|Tests whether trapping that reports on arithmetic exceptions is implemented for a type.|  \n  \n## Requirements  \n **Header:** \\<limits>  \n  \n **Namespace:** std  \n  \n##  <a name=\"numeric_limits__denorm_min\"></a>  numeric_limits::denorm_min  \n Returns the smallest nonzero denormalized value.  \n  \n```  \nstatic Type denorm_min() throw();\n```  \n  \n### Return Value  \n The smallest nonzero denormalized value.  \n  \n### Remarks  \n `long double` is the same as **double** for the C++ compiler.  \n  \n The function returns the minimum value for the type, which is the same as [min](#numeric_limits__min) if [has_denorm](#numeric_limits__has_denorm) is not equal to **denorm_present**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_denorm_min.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The smallest nonzero denormalized value\\n for float \"  \n        << \"objects is: \" << numeric_limits<float>::denorm_min( )   \n        << endl;  \n   cout << \"The smallest nonzero denormalized value\\n for double \"  \n        << \"objects is: \" << numeric_limits<double>::denorm_min( )   \n        << endl;  \n   cout << \"The smallest nonzero denormalized value\\n for long double \"  \n        << \"objects is: \" << numeric_limits<long double>::denorm_min( )   \n        << endl;  \n  \n   // A smaller value will round to zero  \n   cout << numeric_limits<float>::denorm_min( )/2 <<endl;  \n   cout << numeric_limits<double>::denorm_min( )/2 <<endl;  \n   cout << numeric_limits<long double>::denorm_min( )/2 <<endl;  \n}  \n```  \n  \n```Output  \nThe smallest nonzero denormalized value  \n for float objects is: 1.4013e-045  \nThe smallest nonzero denormalized value  \n for double objects is: 4.94066e-324  \nThe smallest nonzero denormalized value  \n for long double objects is: 4.94066e-324  \n0  \n0  \n0  \n```  \n  \n##  <a name=\"numeric_limits__digits\"></a>  numeric_limits::digits  \n Returns the number of radix digits that the type can represent without loss of precision.  \n  \n```  \nstatic const int digits = 0;  \n```  \n  \n### Return Value  \n The number of radix digits that the type can represent without loss of precision.  \n  \n### Remarks  \n The member stores the number of radix digits that the type can represent without change, which is the number of bits other than any sign bit for a predefined integer type, or the number of mantissa digits for a predefined floating-point type.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_digits_min.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << numeric_limits<float>::digits <<endl;  \n   cout << numeric_limits<double>::digits <<endl;  \n   cout << numeric_limits<long double>::digits <<endl;  \n   cout << numeric_limits<int>::digits <<endl;  \n   cout << numeric_limits<__int64>::digits <<endl;  \n}  \n```  \n  \n```Output  \n24  \n53  \n53  \n31  \n63  \n```  \n  \n##  <a name=\"numeric_limits__digits10\"></a>  numeric_limits::digits10  \n Returns the number of decimal digits that the type can represent without loss of precision.  \n  \n```  \nstatic const int digits10 = 0;  \n```  \n  \n### Return Value  \n The number of decimal digits that the type can represent without loss of precision.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_digits10.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << numeric_limits<float>::digits10 <<endl;  \n   cout << numeric_limits<double>::digits10 <<endl;  \n   cout << numeric_limits<long double>::digits10 <<endl;  \n   cout << numeric_limits<int>::digits10 <<endl;  \n   cout << numeric_limits<__int64>::digits10 <<endl;  \n   float f = (float)99999999;  \n   cout.precision ( 10 );  \n   cout << \"The float is; \" << f << endl;  \n}  \n```  \n  \n```Output  \n6  \n15  \n15  \n9  \n18  \nThe float is; 100000000  \n```  \n  \n##  <a name=\"numeric_limits__epsilon\"></a>  numeric_limits::epsilon  \n The function returns the difference between 1 and the smallest value greater than 1 that is representable for the data type.  \n  \n```  \nstatic Type epsilon() throw();\n```  \n  \n### Return Value  \n The difference between 1 and the smallest value greater than 1 that is representable for the data type.  \n  \n### Remarks  \n The value is FLT_EPSILON for type **float**. `epsilon` for a type is the smallest positive floating-point number *N* such that *N* + `epsilon` + *N* is representable.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_epsilon.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The difference between 1 and the smallest \"  \n        << \"value greater than 1\\n for float objects is: \"   \n        << numeric_limits<float>::epsilon( )   \n        << endl;  \n   cout << \"The difference between 1 and the smallest \"  \n        << \"value greater than 1\\n for double objects is: \"   \n        << numeric_limits<double>::epsilon( )   \n        << endl;  \n   cout << \"The difference between 1 and the smallest \"  \n        << \"value greater than 1\\n for long double objects is: \"   \n        << numeric_limits<long double>::epsilon( )   \n        << endl;  \n}  \n```  \n  \n```Output  \nThe difference between 1 and the smallest value greater than 1  \n for float objects is: 1.19209e-007  \nThe difference between 1 and the smallest value greater than 1  \n for double objects is: 2.22045e-016  \nThe difference between 1 and the smallest value greater than 1  \n for long double objects is: 2.22045e-016  \n```  \n  \n##  <a name=\"numeric_limits__has_denorm\"></a>  numeric_limits::has_denorm  \n Tests whether a type allows denormalized values.  \n  \n```  \nstatic const float_denorm_style has_denorm = denorm_absent;  \n```  \n  \n### Return Value  \n An enumeration value of type **const**`float_denorm_style`, indicating whether the type allows denormalized values.  \n  \n### Remarks  \n The member stores **denorm_present** for a floating-point type that has denormalized values, effectively a variable number of exponent bits.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_has_denorm.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects allow denormalized values: \"  \n        << numeric_limits<float>::has_denorm   \n        << endl;  \n   cout << \"Whether double objects allow denormalized values: \"  \n        << numeric_limits<double>::has_denorm   \n        << endl;  \n   cout << \"Whether long int objects allow denormalized values: \"   \n        << numeric_limits<long int>::has_denorm   \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects allow denormalized values: 1  \nWhether double objects allow denormalized values: 1  \nWhether long int objects allow denormalized values: 0  \n```  \n  \n##  <a name=\"numeric_limits__has_denorm_loss\"></a>  numeric_limits::has_denorm_loss  \n Tests whether loss of accuracy is detected as a denormalization loss rather than as an inexact result.  \n  \n```  \nstatic const bool has_denorm_loss = false;  \n```  \n  \n### Return Value  \n **true** if the loss of accuracy is detected as a denormalization loss; **false** if not.  \n  \n### Remarks  \n The member stores true for a type that determines whether a value has lost accuracy because it is delivered as a denormalized result (too small to represent as a normalized value) or because it is inexact (not the same as a result not subject to limitations of exponent range and precision), an option with IEC 559 floating-point representations that can affect some results.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_has_denorm_loss.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects can detect denormalized loss: \"  \n        << numeric_limits<float>::has_denorm_loss  \n        << endl;  \n   cout << \"Whether double objects can detect denormalized loss: \"  \n        << numeric_limits<double>::has_denorm_loss  \n        << endl;  \n   cout << \"Whether long int objects can detect denormalized loss: \"   \n        << numeric_limits<long int>::has_denorm_loss  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects can detect denormalized loss: 1  \nWhether double objects can detect denormalized loss: 1  \nWhether long int objects can detect denormalized loss: 0  \n```  \n  \n##  <a name=\"numeric_limits__has_infinity\"></a>  numeric_limits::has_infinity  \n Tests whether a type has a representation for positive infinity.  \n  \n```  \nstatic const bool has_infinity = false;  \n```  \n  \n### Return Value  \n **true** if the type has a representation for positive infinity; **false** if not.  \n  \n### Remarks  \n The member returns **true** if [is_iec559](#numeric_limits__is_iec559) is **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_has_infinity.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have infinity: \"  \n        << numeric_limits<float>::has_infinity  \n        << endl;  \n   cout << \"Whether double objects have infinity: \"  \n        << numeric_limits<double>::has_infinity  \n        << endl;  \n   cout << \"Whether long int objects have infinity: \"   \n        << numeric_limits<long int>::has_infinity  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have infinity: 1  \nWhether double objects have infinity: 1  \nWhether long int objects have infinity: 0  \n```  \n  \n##  <a name=\"numeric_limits__has_quiet_nan\"></a>  numeric_limits::has_quiet_NaN  \n Tests whether a type has a representation for a quiet not a number (NAN), which is nonsignaling.  \n  \n```  \nstatic const bool has_quiet_NaN = false;  \n```  \n  \n### Return Value  \n **true** if the **type** has a representation for a quiet NAN; **false** if not.  \n  \n### Remarks  \n A quiet NAN is an encoding for not a number, which does not signal its presence in an expression. The return value is **true** if [is_iec559](#numeric_limits__is_iec559) is true.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_has_quiet_nan.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have quiet_NaN: \"  \n        << numeric_limits<float>::has_quiet_NaN   \n        << endl;  \n   cout << \"Whether double objects have quiet_NaN: \"  \n        << numeric_limits<double>::has_quiet_NaN   \n        << endl;  \n   cout << \"Whether long int objects have quiet_NaN: \"   \n        << numeric_limits<long int>::has_quiet_NaN   \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have quiet_NaN: 1  \nWhether double objects have quiet_NaN: 1  \nWhether long int objects have quiet_NaN: 0  \n```  \n  \n##  <a name=\"numeric_limits__has_signaling_nan\"></a>  numeric_limits::has_signaling_NaN  \n Tests whether a type has a representation for signaling not a number (NAN).  \n  \n```  \nstatic const bool has_signaling_NaN = false;  \n```  \n  \n### Return Value  \n **true** if the type has a representation for a signaling NAN; **false** if not.  \n  \n### Remarks  \n A signaling NAN is an encoding for not a number, which signals its presence in an expression. The return value is **true**[is_iec559](#numeric_limits__is_iec559) is true.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_has_signaling_nan.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have a signaling_NaN: \"  \n        << numeric_limits<float>::has_signaling_NaN   \n        << endl;  \n   cout << \"Whether double objects have a signaling_NaN: \"  \n        << numeric_limits<double>::has_signaling_NaN   \n        << endl;  \n   cout << \"Whether long int objects have a signaling_NaN: \"   \n        << numeric_limits<long int>::has_signaling_NaN   \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have a signaling_NaN: 1  \nWhether double objects have a signaling_NaN: 1  \nWhether long int objects have a signaling_NaN: 0  \n```  \n  \n##  <a name=\"numeric_limits__infinity\"></a>  numeric_limits::infinity  \n The representation of positive infinity for a type, if available.  \n  \n```  \nstatic Type infinity() throw();\n```  \n  \n### Return Value  \n The representation of positive infinity for a type, if available.  \n  \n### Remarks  \n The return value is meaningful only if [has_infinity](#numeric_limits__has_infinity) is **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_infinity.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << numeric_limits<float>::has_infinity <<endl;  \n   cout << numeric_limits<double>::has_infinity<<endl;  \n   cout << numeric_limits<long double>::has_infinity <<endl;  \n   cout << numeric_limits<int>::has_infinity <<endl;  \n   cout << numeric_limits<__int64>::has_infinity <<endl;  \n  \n   cout << \"The representation of infinity for type float is: \"  \n        << numeric_limits<float>::infinity( ) <<endl;  \n   cout << \"The representation of infinity for type double is: \"  \n        << numeric_limits<double>::infinity( ) <<endl;  \n   cout << \"The representation of infinity for type long double is: \"  \n        << numeric_limits<long double>::infinity( ) <<endl;  \n}  \n```  \n  \n```Output  \n1  \n1  \n1  \n0  \n0  \nThe representation of infinity for type float is: 1.#INF  \nThe representation of infinity for type double is: 1.#INF  \nThe representation of infinity for type long double is: 1.#INF  \n```  \n  \n##  <a name=\"numeric_limits__is_bounded\"></a>  numeric_limits::is_bounded  \n Tests if the set of values that a type may represent is finite.  \n  \n```  \nstatic const bool is_bounded = false;  \n```  \n  \n### Return Value  \n **true** if the type has a bounded set of representable values; **false** if not.  \n  \n### Remarks  \n All predefined types have a bounded set of representable values and return **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_bounded.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have bounded set \"  \n        << \"of representable values: \"  \n        << numeric_limits<float>::is_bounded  \n        << endl;  \n   cout << \"Whether double objects have bounded set \"  \n        << \"of representable values: \"  \n        << numeric_limits<double>::is_bounded  \n        << endl;  \n   cout << \"Whether long int objects have bounded set \"  \n        << \"of representable values: \"  \n        << numeric_limits<long int>::is_bounded  \n        << endl;  \n   cout << \"Whether unsigned char objects have bounded set \"  \n        << \"of representable values: \"  \n        << numeric_limits<unsigned char>::is_bounded  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have bounded set of representable values: 1  \nWhether double objects have bounded set of representable values: 1  \nWhether long int objects have bounded set of representable values: 1  \nWhether unsigned char objects have bounded set of representable values: 1  \n```  \n  \n##  <a name=\"numeric_limits__is_exact\"></a>  numeric_limits::is_exact  \n Tests if the calculations done on a type are free of rounding errors.  \n  \n```  \nstatic const bool is_exact = false;  \n```  \n  \n### Return Value  \n **true** if the calculations are free of rounding errors; **false** if not.  \n  \n### Remarks  \n All predefined integer types have exact representations for their values and return **false**. A fixed-point or rational representation is also considered exact, but a floating-point representation is not.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_exact.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have calculations \"  \n        << \"free of rounding errors: \"  \n        << numeric_limits<float>::is_exact  \n        << endl;  \n   cout << \"Whether double objects have calculations \"  \n        << \"free of rounding errors: \"  \n        << numeric_limits<double>::is_exact  \n        << endl;  \n   cout << \"Whether long int objects have calculations \"  \n        << \"free of rounding errors: \"  \n        << numeric_limits<long int>::is_exact  \n        << endl;  \n   cout << \"Whether unsigned char objects have calculations \"  \n        << \"free of rounding errors: \"  \n        << numeric_limits<unsigned char>::is_exact  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have calculations free of rounding errors: 0  \nWhether double objects have calculations free of rounding errors: 0  \nWhether long int objects have calculations free of rounding errors: 1  \nWhether unsigned char objects have calculations free of rounding errors: 1  \n```  \n  \n##  <a name=\"numeric_limits__is_iec559\"></a>  numeric_limits::is_iec559  \n Tests if a type conforms to IEC 559 standards.  \n  \n```  \nstatic const bool is_iec559 = false;  \n```  \n  \n### Return Value  \n **true** if the type conforms to the IEC 559 standards; **false** if not.  \n  \n### Remarks  \n The IEC 559 is an international standard for representing floating-point values and is also known as IEEE 754 in the USA.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_iec559.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects conform to iec559 standards: \"  \n        << numeric_limits<float>::is_iec559  \n        << endl;  \n   cout << \"Whether double objects conform to iec559 standards: \"  \n        << numeric_limits<double>::is_iec559  \n        << endl;  \n   cout << \"Whether int objects conform to iec559 standards: \"  \n        << numeric_limits<int>::is_iec559  \n        << endl;  \n   cout << \"Whether unsigned char objects conform to iec559 standards: \"  \n        << numeric_limits<unsigned char>::is_iec559  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects conform to iec559 standards: 1  \nWhether double objects conform to iec559 standards: 1  \nWhether int objects conform to iec559 standards: 0  \nWhether unsigned char objects conform to iec559 standards: 0  \n```  \n  \n##  <a name=\"numeric_limits__is_integer\"></a>  numeric_limits::is_integer  \n Tests if a type has an integer representation.  \n  \n```  \nstatic const bool is_integer = false;  \n```  \n  \n### Return Value  \n **true** if the type has an integer representation; **false** if not.  \n  \n### Remarks  \n All predefined integer types have an integer representation.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_integer.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have an integral representation: \"  \n        << numeric_limits<float>::is_integer  \n        << endl;  \n   cout << \"Whether double objects have an integral representation: \"  \n        << numeric_limits<double>::is_integer  \n        << endl;  \n   cout << \"Whether int objects have an integral representation: \"  \n        << numeric_limits<int>::is_integer  \n        << endl;  \n   cout << \"Whether unsigned char objects have an integral representation: \"  \n        << numeric_limits<unsigned char>::is_integer  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have an integral representation: 0  \nWhether double objects have an integral representation: 0  \nWhether int objects have an integral representation: 1  \nWhether unsigned char objects have an integral representation: 1  \n```  \n  \n##  <a name=\"numeric_limits__is_modulo\"></a>  numeric_limits::is_modulo  \n Tests if a **type** has a modulo representation.  \n  \n```  \nstatic const bool is_modulo = false;  \n```  \n  \n### Return Value  \n **true** if the type has a modulo representation; **false** if not.  \n  \n### Remarks  \n A modulo representation is a representation where all results are reduced modulo some value. All predefined unsigned integer types have a modulo representation.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_modulo.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have a modulo representation: \"  \n        << numeric_limits<float>::is_modulo  \n        << endl;  \n   cout << \"Whether double objects have a modulo representation: \"  \n        << numeric_limits<double>::is_modulo  \n        << endl;  \n   cout << \"Whether signed char objects have a modulo representation: \"  \n        << numeric_limits<signed char>::is_modulo  \n        << endl;  \n   cout << \"Whether unsigned char objects have a modulo representation: \"  \n        << numeric_limits<unsigned char>::is_modulo  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have a modulo representation: 0  \nWhether double objects have a modulo representation: 0  \nWhether signed char objects have a modulo representation: 1  \nWhether unsigned char objects have a modulo representation: 1  \n```  \n  \n##  <a name=\"numeric_limits__is_signed\"></a>  numeric_limits::is_signed  \n Tests if a type has a signed representation.  \n  \n```  \nstatic const bool is_signed = false;  \n```  \n  \n### Return Value  \n **true** if the type has a signed representation; **false** if not.  \n  \n### Remarks  \n The member stores true for a type that has a signed representation, which is the case for all predefined floating-point and signed integer types.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_signaled.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have a signed representation: \"  \n        << numeric_limits<float>::is_signed  \n        << endl;  \n   cout << \"Whether double objects have a signed representation: \"  \n        << numeric_limits<double>::is_signed  \n        << endl;  \n   cout << \"Whether signed char objects have a signed representation: \"  \n        << numeric_limits<signed char>::is_signed  \n        << endl;  \n   cout << \"Whether unsigned char objects have a signed representation: \"  \n        << numeric_limits<unsigned char>::is_signed  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have a signed representation: 1  \nWhether double objects have a signed representation: 1  \nWhether signed char objects have a signed representation: 1  \nWhether unsigned char objects have a signed representation: 0  \n```  \n  \n##  <a name=\"numeric_limits__is_specialized\"></a>  numeric_limits::is_specialized  \n Tests if a type has an explicit specialization defined in the template class `numeric_limits`.  \n  \n```  \nstatic const bool is_specialized = false;  \n```  \n  \n### Return Value  \n **true** if the type has an explicit specialization defined in the template class; **false** if not.  \n  \n### Remarks  \n All scalar types other than pointers have an explicit specialization defined for template class `numeric_limits`.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_specialized.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have an explicit \"  \n        << \"specialization in the class: \"  \n        << numeric_limits<float>::is_specialized  \n        << endl;  \n   cout << \"Whether float* objects have an explicit \"  \n        << \"specialization in the class: \"  \n        << numeric_limits<float*>::is_specialized  \n        << endl;  \n   cout << \"Whether int objects have an explicit \"  \n        << \"specialization in the class: \"  \n        << numeric_limits<int>::is_specialized  \n        << endl;  \n   cout << \"Whether int* objects have an explicit \"  \n        << \"specialization in the class: \"  \n        << numeric_limits<int*>::is_specialized  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have an explicit specialization in the class: 1  \nWhether float* objects have an explicit specialization in the class: 0  \nWhether int objects have an explicit specialization in the class: 1  \nWhether int* objects have an explicit specialization in the class: 0  \n```  \n  \n##  <a name=\"numeric_limits__lowest\"></a>  numeric_limits::lowest  \n Returns the most negative finite value.  \n  \n```  \nstatic Type lowest() throw();\n```  \n  \n### Return Value  \n Returns the most negative finite value.  \n  \n### Remarks  \n Returns the most negative finite value for the type (which is typically `min` `()` for integer types and `-``max` `()` for floating-point types). The return value is meaningful if `is_bounded` is `true`.  \n  \n##  <a name=\"numeric_limits__max\"></a>  numeric_limits::max  \n Returns the maximum finite value for a type.  \n  \n```  \nstatic Type max() throw();\n```  \n  \n### Return Value  \n The maximum finite value for a type.  \n  \n### Remarks  \n The maximum finite value is INT_MAX for type `int` and FLT_MAX for type **float**. The return value is meaningful if [is_bounded](#numeric_limits__is_bounded) is **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_max.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main() {  \n   cout << \"The maximum value for type float is:  \"  \n        << numeric_limits<float>::max( )  \n        << endl;  \n   cout << \"The maximum value for type double is:  \"  \n        << numeric_limits<double>::max( )  \n        << endl;  \n   cout << \"The maximum value for type int is:  \"  \n        << numeric_limits<int>::max( )  \n        << endl;  \n   cout << \"The maximum value for type short int is:  \"  \n        << numeric_limits<short int>::max( )  \n        << endl;  \n}  \n```  \n  \n##  <a name=\"numeric_limits__max_digits10\"></a>  numeric_limits::max_digits10  \n Returns the number of decimal digits required to make sure that two distinct values of the type have distinct decimal representations.  \n  \n```  \nstatic int max_digits10 = 0;  \n```  \n  \n### Return Value  \n Returns the number of decimal digits that are required to make sure that two distinct values of the type have distinct decimal representations.  \n  \n### Remarks  \n The member stores the number of decimal digits required to make sure that two distinct values of the type have distinct decimal representations.  \n  \n##  <a name=\"numeric_limits__max_exponent\"></a>  numeric_limits::max_exponent  \n Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.  \n  \n```  \nstatic const int max_exponent = 0;  \n```  \n  \n### Return Value  \n The maximum integral radix-based exponent representable by the type.  \n  \n### Remarks  \n The member function return is meaningful only for floating-point types. The `max_exponent` is the value FLT_MAX_EXP for type **float**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_max_exponent.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The maximum radix-based exponent for type float is:  \"  \n        << numeric_limits<float>::max_exponent  \n        << endl;  \n   cout << \"The maximum radix-based exponent for type double is:  \"  \n        << numeric_limits<double>::max_exponent  \n        << endl;  \n   cout << \"The maximum radix-based exponent for type long double is:  \"  \n        << numeric_limits<long double>::max_exponent  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe maximum radix-based exponent for type float is:  128  \nThe maximum radix-based exponent for type double is:  1024  \nThe maximum radix-based exponent for type long double is:  1024  \n```  \n  \n##  <a name=\"numeric_limits__max_exponent10\"></a>  numeric_limits::max_exponent10  \n Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.  \n  \n```  \nstatic const int max_exponent10 = 0;  \n```  \n  \n### Return Value  \n The maximum integral base 10 exponent representable by the type.  \n  \n### Remarks  \n The member function return is meaningful only for floating-point types. The `max_exponent` is the value FLT_MAX_10 for type **float**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_max_exponent10.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The maximum base 10 exponent for type float is:  \"  \n           << numeric_limits<float>::max_exponent10  \n           << endl;  \n   cout << \"The maximum base 10 exponent for type double is:  \"  \n           << numeric_limits<double>::max_exponent10  \n           << endl;  \n   cout << \"The maximum base 10 exponent for type long double is:  \"  \n           << numeric_limits<long double>::max_exponent10  \n           << endl;  \n}  \n```  \n  \n```Output  \nThe maximum base 10 exponent for type float is:  38  \nThe maximum base 10 exponent for type double is:  308  \nThe maximum base 10 exponent for type long double is:  308  \n```  \n  \n##  <a name=\"numeric_limits__min\"></a>  numeric_limits::min  \n Returns the minimum normalized value for a type.  \n  \n```  \nstatic Type min() throw();\n```  \n  \n### Return Value  \n The minimum normalized value for the type.  \n  \n### Remarks  \n The minimum normalized value is INT_MIN for type `int` and FLT_MIN for type `float`. The return value is meaningful if [is_bounded](#numeric_limits__is_bounded) is `true` or if [is_signed](#numeric_limits__is_signed) is `false`.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_min.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The minimum value for type float is:  \"  \n        << numeric_limits<float>::min( )  \n        << endl;  \n   cout << \"The minimum value for type double is:  \"  \n        << numeric_limits<double>::min( )  \n        << endl;  \n   cout << \"The minimum value for type int is:  \"  \n        << numeric_limits<int>::min( )  \n        << endl;  \n   cout << \"The minimum value for type short int is:  \"  \n        << numeric_limits<short int>::min( )  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe minimum value for type float is:  1.17549e-038  \nThe minimum value for type double is:  2.22507e-308  \nThe minimum value for type int is:  -2147483648  \nThe minimum value for type short int is:  -32768  \n```  \n  \n##  <a name=\"numeric_limits__min_exponent\"></a>  numeric_limits::min_exponent  \n Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.  \n  \n```  \nstatic const int min_exponent = 0;  \n```  \n  \n### Return Value  \n The minimum integral radix-based exponent representable by the type.  \n  \n### Remarks  \n The member function is meaningful only for floating-point types. The `min_exponent` is the value FLT_MIN_EXP for type **float**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_min_exponent.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The minimum radix-based exponent for type float is:  \"  \n        << numeric_limits<float>::min_exponent  \n        << endl;  \n   cout << \"The minimum radix-based exponent for type double is:  \"  \n        << numeric_limits<double>::min_exponent  \n        << endl;  \n   cout << \"The minimum radix-based exponent for type long double is:  \"  \n         << numeric_limits<long double>::min_exponent  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe minimum radix-based exponent for type float is:  -125  \nThe minimum radix-based exponent for type double is:  -1021  \nThe minimum radix-based exponent for type long double is:  -1021  \n```  \n  \n##  <a name=\"numeric_limits__min_exponent10\"></a>  numeric_limits::min_exponent10  \n Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.  \n  \n```  \nstatic const int min_exponent10 = 0;  \n```  \n  \n### Return Value  \n The minimum integral base 10 exponent representable by the type.  \n  \n### Remarks  \n The member function is meaningful only for floating-point types. The `min_exponent10` is the value FLT_MIN_10_EXP for type **float**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_min_exponent10.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The minimum base 10 exponent for type float is:  \"  \n        << numeric_limits<float>::min_exponent10  \n        << endl;  \n   cout << \"The minimum base 10 exponent for type double is:  \"  \n        << numeric_limits<double>::min_exponent10  \n        << endl;  \n   cout << \"The minimum base 10 exponent for type long double is:  \"  \n        << numeric_limits<long double>::min_exponent10  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe minimum base 10 exponent for type float is:  -37  \nThe minimum base 10 exponent for type double is:  -307  \nThe minimum base 10 exponent for type long double is:  -307  \n```  \n  \n##  <a name=\"numeric_limits__quiet_nan\"></a>  numeric_limits::quiet_NaN  \n Returns the representation of a quiet not a number (NAN) for the type.  \n  \n```  \nstatic Type quiet_NaN() throw();\n```  \n  \n### Return Value  \n The representation of a quiet NAN for the type.  \n  \n### Remarks  \n The return value is meaningful only if [has_quiet_NaN](#numeric_limits__has_quiet_nan) is **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_quiet_nan.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The quiet NaN for type float is:  \"  \n        << numeric_limits<float>::quiet_NaN( )  \n        << endl;  \n   cout << \"The quiet NaN for type int is:  \"  \n        << numeric_limits<int>::quiet_NaN( )  \n        << endl;  \n   cout << \"The quiet NaN for type long double is:  \"  \n        << numeric_limits<long double>::quiet_NaN( )  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe quiet NaN for type float is:  1.#QNAN  \nThe quiet NaN for type int is:  0  \nThe quiet NaN for type long double is:  1.#QNAN  \n```  \n  \n##  <a name=\"numeric_limits__radix\"></a>  numeric_limits::radix  \n Returns the integral base, referred to as radix, used for the representation of a type.  \n  \n```  \nstatic const int radix = 0;  \n```  \n  \n### Return Value  \n The integral base for the representation of the type.  \n  \n### Remarks  \n The base is 2 for the predefined integer types, and the base to which the exponent is raised, or FLT_RADIX, for the predefined floating-point types.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_radix.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The base for type float is:  \"  \n        << numeric_limits<float>::radix  \n        << endl;  \n   cout << \"The base for type int is:  \"  \n        << numeric_limits<int>::radix  \n        << endl;  \n   cout << \"The base for type long double is:  \"  \n        << numeric_limits<long double>::radix  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe base for type float is:  2  \nThe base for type int is:  2  \nThe base for type long double is:  2  \n```  \n  \n##  <a name=\"numeric_limits__round_error\"></a>  numeric_limits::round_error  \n Returns the maximum rounding error for the type.  \n  \n```  \nstatic Type round_error() throw();\n```  \n  \n### Return Value  \n The maximum rounding error for the type.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_round_error.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The maximum rounding error for type float is:  \"  \n        << numeric_limits<float>::round_error( )  \n        << endl;  \n   cout << \"The maximum rounding error for type int is:  \"  \n        << numeric_limits<int>::round_error( )  \n        << endl;  \n   cout << \"The maximum rounding error for type long double is:  \"  \n        << numeric_limits<long double>::round_error( )  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe maximum rounding error for type float is:  0.5  \nThe maximum rounding error for type int is:  0  \nThe maximum rounding error for type long double is:  0.5  \n```  \n  \n##  <a name=\"numeric_limits__round_style\"></a>  numeric_limits::round_style  \n Returns a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.  \n  \n```  \nstatic const float_round_style round_style = round_toward_zero;  \n```  \n  \n### Return Value  \n A value from the `float_round_style` enumeration that describes the rounding style.  \n  \n### Remarks  \n The member stores a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.  \n  \n The round style is hard coded in this implementation, so even if the program starts up with a different rounding mode, that value will not change.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_round_style.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <float.h>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The rounding style for a double type is: \"   \n        << numeric_limits<double>::round_style << endl;  \n   _controlfp_s(NULL,_RC_DOWN,_MCW_RC );  \n   cout << \"The rounding style for a double type is now: \"   \n        << numeric_limits<double>::round_style << endl;  \n   cout << \"The rounding style for an int type is: \"   \n        << numeric_limits<int>::round_style << endl;  \n}  \n```  \n  \n```Output  \nThe rounding style for a double type is: 1  \nThe rounding style for a double type is now: 1  \nThe rounding style for an int type is: 0  \n```  \n  \n##  <a name=\"numeric_limits__signaling_nan\"></a>  numeric_limits::signaling_NaN  \n Returns the representation of a signaling not a number (NAN) for the type.  \n  \n```  \nstatic Type signaling_NaN() throw();\n```  \n  \n### Return Value  \n The representation of a signaling NAN for the type.  \n  \n### Remarks  \n The return value is meaningful only if [has_signaling_NaN](#numeric_limits__has_signaling_nan) is **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_signaling_nan.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The signaling NaN for type float is:  \"  \n        << numeric_limits<float>::signaling_NaN( )  \n        << endl;  \n   cout << \"The signaling NaN for type int is:  \"  \n        << numeric_limits<int>::signaling_NaN( )  \n        << endl;  \n   cout << \"The signaling NaN for type long double is:  \"  \n        << numeric_limits<long double>::signaling_NaN( )  \n        << endl;  \n}  \n```  \n  \n##  <a name=\"numeric_limits__tinyness_before\"></a>  numeric_limits::tinyness_before  \n Tests whether a type can determine that a value is too small to represent as a normalized value before rounding it.  \n  \n```  \nstatic const bool tinyness_before = false;  \n```  \n  \n### Return Value  \n `true` if the type can detect tiny values before rounding; `false` if it cannot.  \n  \n### Remarks  \n Types that can detect tinyness were included as an option with IEC 559 floating-point representations and its implementation can affect some results.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_tinyness_before.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float types can detect tinyness before rounding: \"  \n        << numeric_limits<float>::tinyness_before  \n        << endl;  \n   cout << \"Whether double types can detect tinyness before rounding: \"  \n        << numeric_limits<double>::tinyness_before  \n        << endl;  \n   cout << \"Whether long int types can detect tinyness before rounding: \"  \n        << numeric_limits<long int>::tinyness_before  \n        << endl;  \n   cout << \"Whether unsigned char types can detect tinyness before rounding: \"  \n        << numeric_limits<unsigned char>::tinyness_before  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float types can detect tinyness before rounding: 1  \nWhether double types can detect tinyness before rounding: 1  \nWhether long int types can detect tinyness before rounding: 0  \nWhether unsigned char types can detect tinyness before rounding: 0  \n```  \n  \n##  <a name=\"numeric_limits__traps\"></a>  numeric_limits::traps  \n Tests whether trapping that reports on arithmetic exceptions is implemented for a type.  \n  \n```  \nstatic const bool traps = false;  \n```  \n  \n### Return Value  \n **true** if trapping is implemented for the type; **false** if it is not.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_traps.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float types have implemented trapping: \"  \n        << numeric_limits<float>::traps  \n        << endl;  \n   cout << \"Whether double types have implemented trapping: \"  \n        << numeric_limits<double>::traps  \n        << endl;  \n   cout << \"Whether long int types have implemented trapping: \"  \n        << numeric_limits<long int>::traps  \n        << endl;  \n   cout << \"Whether unsigned char types have implemented trapping: \"  \n        << numeric_limits<unsigned char>::traps  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float types have implemented trapping: 1  \nWhether double types have implemented trapping: 1  \nWhether long int types have implemented trapping: 0  \nWhether unsigned char types have implemented trapping: 0  \n```  \n  \n## See Also  \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)\n\n"}