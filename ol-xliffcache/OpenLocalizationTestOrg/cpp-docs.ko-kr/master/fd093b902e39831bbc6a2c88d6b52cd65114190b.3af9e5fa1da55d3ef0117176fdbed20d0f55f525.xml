{"nodes":[{"pos":[12,45],"content":"Unwind Procedure | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Unwind Procedure | Microsoft Docs","pos":[0,33]}]},{"content":"Unwind Procedure","pos":[526,542]},{"content":"The unwind code array is sorted into descending order.","pos":[543,597]},{"content":"When an exception occurs, the complete context is stored by the operating system in a context record.","pos":[598,699]},{"content":"The exception dispatch logic is then invoked, which repeatedly executes the following steps to find an exception handler.","pos":[700,821]},{"content":"Use the current RIP stored in the context record to search for a RUNTIME_FUNCTION table entry that describes the current function (or function portion, in the case of chained UNWIND_INFO entries).","pos":[831,1027]},{"content":"If no function table entry is found, then it is in a leaf function, and RSP will directly address the return pointer.","pos":[1037,1154]},{"content":"The return pointer at [RSP] is stored in the updated context, the simulated RSP is incremented by 8, and step 1 is repeated.","pos":[1155,1279]},{"content":"If a function table entry is found, RIP can lie within three regions a) in an epilog, b) in the prolog, or c) in code that may be covered by an exception handler.","pos":[1289,1451]},{"content":"Case a) If the RIP is within an epilog, then control is leaving the function, there can be no exception handler associated with this exception for this function, and the effects of the epilog must be continued to compute the context of the caller function.","pos":[1465,1721]},{"content":"To determine if the RIP is within an epilog, the code stream from RIP on is examined.","pos":[1722,1807]},{"content":"If that code stream can be matched to the trailing portion of a legitimate epilog, then it is in an epilog, and the remaining portion of the epilog is simulated, with the context record updated as each instruction is processed.","pos":[1808,2035]},{"content":"After this, step 1 is repeated.","pos":[2036,2067]},{"content":"Case b) If the RIP lies within the prologue, then control has not entered the function, there can be no exception handler associated with this exception for this function, and the effects of the prolog must be undone to compute the context of the caller function.","pos":[2081,2344]},{"content":"The RIP is within the prolog if the distance from the function start to the RIP is less than or equal to the prolog size encoded in the unwind info.","pos":[2345,2493]},{"content":"The effects of the prolog are unwound by scanning forward through the unwind codes array for the first entry with an offset less than or equal to the offset of the RIP from the function start, then undoing the effect of all remaining items in the unwind code array.","pos":[2494,2759]},{"content":"Step 1 is then repeated.","pos":[2760,2784]},{"content":"Case c) If the RIP is not within a prolog or epilog and the function has an exception handler (UNW_FLAG_EHANDLER is set), then the language specific handler is called.","pos":[2798,2965]},{"content":"The handler scans its data and calls filter functions as appropriate.","pos":[2966,3035]},{"content":"The language specific handler can return that the exception was handled or that the search is to be continued.","pos":[3036,3146]},{"content":"It can also initiate an unwind directly.","pos":[3147,3187]},{"content":"If the language specific handler returns a handled status, then execution is continued using the original context record.","pos":[3197,3318]},{"content":"If there is no language specific handler or the handler returns a \"continue search\" status, then the context record must be unwound to the state of the caller.","pos":[3328,3487]},{"content":"This is accomplished by processing all of the unwind code array elements, undoing the effect of each.","pos":[3488,3589]},{"content":"Step 1 is then repeated.","pos":[3590,3614]},{"content":"When chained unwind info is involved, these basic steps are still followed.","pos":[3621,3696]},{"content":"The only difference is that, while walking the unwind code array to unwind a prolog’s effects, once the end of the array is reached, it is then linked to the parent unwind info and the entire unwind code array found there is walked.","pos":[3697,3929]},{"content":"This linking continues until arriving at an unwind info without the UNW_CHAINED_INFO flag and finish walking its unwind code array.","pos":[3930,4061]},{"content":"The smallest set of unwind data is 8 bytes.","pos":[4068,4111]},{"content":"This would represent a function that only allocated 128 bytes of stack or less, and possibly saved one nonvolatile register.","pos":[4112,4236]},{"content":"This is also the size of a chained unwind info structure for a zero-length prolog with no unwind codes.","pos":[4237,4340]},{"content":"See Also","pos":[4349,4357]},{"content":"Exception Handling (x64)","pos":[4362,4386]}],"content":"---\ntitle: \"Unwind Procedure | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 82c5d0ca-70be-4d1a-a306-bfe01c29159f\ncaps.latest.revision: 11\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Unwind Procedure\nThe unwind code array is sorted into descending order. When an exception occurs, the complete context is stored by the operating system in a context record. The exception dispatch logic is then invoked, which repeatedly executes the following steps to find an exception handler.  \n  \n1.  Use the current RIP stored in the context record to search for a RUNTIME_FUNCTION table entry that describes the current function (or function portion, in the case of chained UNWIND_INFO entries).  \n  \n2.  If no function table entry is found, then it is in a leaf function, and RSP will directly address the return pointer. The return pointer at [RSP] is stored in the updated context, the simulated RSP is incremented by 8, and step 1 is repeated.  \n  \n3.  If a function table entry is found, RIP can lie within three regions a) in an epilog, b) in the prolog, or c) in code that may be covered by an exception handler.  \n  \n    -   Case a) If the RIP is within an epilog, then control is leaving the function, there can be no exception handler associated with this exception for this function, and the effects of the epilog must be continued to compute the context of the caller function. To determine if the RIP is within an epilog, the code stream from RIP on is examined. If that code stream can be matched to the trailing portion of a legitimate epilog, then it is in an epilog, and the remaining portion of the epilog is simulated, with the context record updated as each instruction is processed. After this, step 1 is repeated.  \n  \n    -   Case b) If the RIP lies within the prologue, then control has not entered the function, there can be no exception handler associated with this exception for this function, and the effects of the prolog must be undone to compute the context of the caller function. The RIP is within the prolog if the distance from the function start to the RIP is less than or equal to the prolog size encoded in the unwind info. The effects of the prolog are unwound by scanning forward through the unwind codes array for the first entry with an offset less than or equal to the offset of the RIP from the function start, then undoing the effect of all remaining items in the unwind code array. Step 1 is then repeated.  \n  \n    -   Case c) If the RIP is not within a prolog or epilog and the function has an exception handler (UNW_FLAG_EHANDLER is set), then the language specific handler is called. The handler scans its data and calls filter functions as appropriate. The language specific handler can return that the exception was handled or that the search is to be continued. It can also initiate an unwind directly.  \n  \n4.  If the language specific handler returns a handled status, then execution is continued using the original context record.  \n  \n5.  If there is no language specific handler or the handler returns a \"continue search\" status, then the context record must be unwound to the state of the caller. This is accomplished by processing all of the unwind code array elements, undoing the effect of each. Step 1 is then repeated.  \n  \n When chained unwind info is involved, these basic steps are still followed. The only difference is that, while walking the unwind code array to unwind a prolog’s effects, once the end of the array is reached, it is then linked to the parent unwind info and the entire unwind code array found there is walked. This linking continues until arriving at an unwind info without the UNW_CHAINED_INFO flag and finish walking its unwind code array.  \n  \n The smallest set of unwind data is 8 bytes. This would represent a function that only allocated 128 bytes of stack or less, and possibly saved one nonvolatile register. This is also the size of a chained unwind info structure for a zero-length prolog with no unwind codes.  \n  \n## See Also  \n [Exception Handling (x64)](../build/exception-handling-x64.md)"}