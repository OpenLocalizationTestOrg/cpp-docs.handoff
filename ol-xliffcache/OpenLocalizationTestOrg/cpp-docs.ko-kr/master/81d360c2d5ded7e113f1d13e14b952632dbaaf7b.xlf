<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">81d360c2d5ded7e113f1d13e14b952632dbaaf7b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\mfc\reference\cevent-class.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6abc40b2c4df5b2bd0b5a7937fea1c2d804a1ef2</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5b5c2296b70fcd5ae4e3d6ef9ee38f029865d28f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>CEvent Class | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>CEvent Class</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Represents an event, which is a synchronization object that enables one thread to notify another that an event has occurred.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Members</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Public Constructors</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>CEvent::CEvent</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Constructs a <ph id="ph1">`CEvent`</ph> object.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Public Methods</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>CEvent::PulseEvent</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Sets the event to available (signaled), releases waiting threads, and sets the event to unavailable (nonsignaled).</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>CEvent::ResetEvent</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Sets the event to unavailable (nonsignaled).</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>CEvent::SetEvent</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Sets the event to available (signaled) and releases any waiting threads.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>CEvent::Unlock</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Releases the event object.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Events are useful when a thread must know when to perform its task.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For example, a thread that copies data to a data archive must be notified when new data is available.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>By using a <ph id="ph1">`CEvent`</ph> object to notify the copy thread when new data is available, the thread can perform its task as soon as possible.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>objects have two types: manual and automatic.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>An automatic <ph id="ph1">`CEvent`</ph> object automatically returns to a non-signaled (unavailable) state after at least one thread is released.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>By default, a <ph id="ph1">`CEvent`</ph> object is automatic unless you pass <ph id="ph2">`TRUE`</ph> for the <ph id="ph3">`bManualReset`</ph> parameter during construction.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A manual <ph id="ph1">`CEvent`</ph> object stays in the state set by <bpt id="p1">[</bpt>SetEvent<ept id="p1">](#cevent__setevent)</ept> or <bpt id="p2">[</bpt>ResetEvent<ept id="p2">](#cevent__resetevent)</ept> until the other function is called.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To create a manual <ph id="ph1">`CEvent`</ph> object, pass <ph id="ph2">`TRUE`</ph> for the <ph id="ph3">`bManualReset`</ph> parameter during construction.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>To use a <ph id="ph1">`CEvent`</ph> object, construct the <ph id="ph2">`CEvent`</ph> object when it is required.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Specify the name of the event you want to wait on, and also specify that your application should initially own it.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You can then access the event when the constructor returns.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Call <bpt id="p1">[</bpt>SetEvent<ept id="p1">](#cevent__setevent)</ept> to signal (make available) the event object and then call <bpt id="p2">[</bpt>Unlock<ept id="p2">](#cevent__unlock)</ept> when you are done accessing the controlled resource.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>An alternative method for using <ph id="ph1">`CEvent`</ph> objects is to add a variable of type <ph id="ph2">`CEvent`</ph> as a data member to the class you want to control.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>During construction of the controlled object, call the constructor of the <ph id="ph1">`CEvent`</ph> data member and specify whether the event is initially signaled, and also specifythe type of event object you want, the name of the event (if it will be used across process boundaries), and any security attributes you want.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>To access a resource controlled by a <ph id="ph1">`CEvent`</ph> object in this manner, first create a variable of either type <bpt id="p1">[</bpt>CSingleLock<ept id="p1">](../../mfc/reference/csinglelock-class.md)</ept> or type <bpt id="p2">[</bpt>CMultiLock<ept id="p2">](../../mfc/reference/cmultilock-class.md)</ept> in the access method of your resource.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Then call the <ph id="ph1">`Lock`</ph> method of the lock object (for example, <bpt id="p1">[</bpt>CMultiLock::Lock<ept id="p1">](../../mfc/reference/cmultilock-class.md#cmultilock__lock)</ept>).</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>At this point, your thread will either gain access to the resource, wait for the resource to be released and gain access, or wait for the resource to be released, time out, and fail to gain access to the resource.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In any case, your resource has been accessed in a thread-safe manner.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>To release the resource, call <ph id="ph1">`SetEvent`</ph> to signal the event object, and then use the <ph id="ph2">`Unlock`</ph> method of the lock object (for example, <bpt id="p1">[</bpt>CMultiLock::Unlock<ept id="p1">](../../mfc/reference/cmultilock-class.md#cmultilock__unlock)</ept>), or let the lock object fall out of scope.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For more information about how to use <ph id="ph1">`CEvent`</ph> objects, see <bpt id="p1">[</bpt>Multithreading: How to Use the Synchronization Classes<ept id="p1">](../../parallel/multithreading-how-to-use-the-synchronization-classes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>NVC_MFC_Utilities#45</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>NVC_MFC_Utilities#46</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Inheritance Hierarchy</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>CObject</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>CSyncObject</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Requirements</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Header:<ept id="p1">**</ept> afxmt.h</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>CEvent::CEvent</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Constructs a named or unnamed <ph id="ph1">`CEvent`</ph> object.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">**</bpt>TRUE<ept id="p1">**</ept>, the thread for the <bpt id="p2">**</bpt>CMultilock<ept id="p2">**</ept> or <ph id="ph1">`CSingleLock`</ph> object is enabled.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Otherwise, all threads wanting to access the resource must wait.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>bManualReset</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">**</bpt>TRUE<ept id="p1">**</ept>, specifies that the event object is a manual event, otherwise the event object is an automatic event.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Name of the <ph id="ph1">`CEvent`</ph> object.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Must be supplied if the object will be used across process boundaries.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>If the name matches an existing event, the constructor builds a new <ph id="ph1">`CEvent`</ph> object which references the event of that name.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If the name matches an existing synchronization object that is not an event, the construction will fail.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>, the name will be null.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Security attributes for the event object.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For a full description of this structure, see <bpt id="p1">[</bpt>SECURITY_ATTRIBUTES<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/aa379560)</ept> in the <ph id="ph1">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To access or release a <ph id="ph1">`CEvent`</ph> object, create a <bpt id="p1">[</bpt>CMultiLock<ept id="p1">](../../mfc/reference/cmultilock-class.md)</ept> or <bpt id="p2">[</bpt>CSingleLock<ept id="p2">](../../mfc/reference/csinglelock-class.md)</ept> object and call its <bpt id="p3">[</bpt>Lock<ept id="p3">](../../mfc/reference/csinglelock-class.md#csinglelock__lock)</ept> and <bpt id="p4">[</bpt>Unlock<ept id="p4">](../../mfc/reference/csinglelock-class.md#csinglelock__unlock)</ept> member functions.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To change the state of a <ph id="ph1">`CEvent`</ph> object to signaled (threads do not have to wait), call <bpt id="p1">[</bpt>SetEvent<ept id="p1">](#cevent__setevent)</ept> or <bpt id="p2">[</bpt>PulseEvent<ept id="p2">](#cevent__pulseevent)</ept>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>To set the state of a <ph id="ph1">`CEvent`</ph> object to nonsignaled (threads must wait), call <bpt id="p1">[</bpt>ResetEvent<ept id="p1">](#cevent__resetevent)</ept>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>After creating the <ph id="ph1">`CEvent`</ph> object, use <bpt id="p1">[</bpt>GetLastError<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms679360)</ept> to ensure that the mutex didn't already exist.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If the mutex did exist unexpectedly, it may indicate a rogue process is squatting and may be intending to use the mutex maliciously.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In this case, the recommended security-conscious procedure is to close the handle and continue as if there was a failure in creating the object.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>CEvent::PulseEvent</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Sets the state of the event to signaled (available), releases any waiting threads, and resets it to nonsignaled (unavailable) automatically.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Nonzero if the function was successful; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If the event is manual, all waiting threads are released, the event is set to nonsignaled, and <ph id="ph1">`PulseEvent`</ph> returns.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If the event is automatic, a single thread is released, the event is set to nonsignaled, and <ph id="ph1">`PulseEvent`</ph> returns.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>If no threads are waiting, or no threads can be released immediately, <ph id="ph1">`PulseEvent`</ph> sets the state of the event to nonsignaled and returns.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>uses the underlying Win32 <ph id="ph1">`PulseEvent`</ph> function, which can be momentarily removed from the wait state by a kernel-mode asynchronous procedure call.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Therefore, <ph id="ph1">`PulseEvent`</ph> is unreliable and should not be used by new applications.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>PulseEvent function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms684914)</ept>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>CEvent::ResetEvent</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Sets the state of the event to nonsignaled until explicitly set to signaled by the <bpt id="p1">[</bpt>SetEvent<ept id="p1">](#cevent__setevent)</ept> member function.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Nonzero if the function was successful; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This causes all threads wishing to access this event to wait.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>This member function is not used by automatic events.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>CEvent::SetEvent</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Sets the state of the event to signaled, releasing any waiting threads.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Nonzero if the function was successful, otherwise 0.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If the event is manual, the event will remain signaled until <bpt id="p1">[</bpt>ResetEvent<ept id="p1">](#cevent__resetevent)</ept> is called.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>More than one thread can be released in this case.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If the event is automatic, the event will remain signaled until a single thread is released.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The system will then set the state of the event to nonsignaled.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If no threads are waiting, the state remains signaled until one thread is released.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>CEvent::Unlock</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Releases the event object.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Nonzero if the thread owned the event object and the event is an automatic event; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>This member function is called by threads that currently own an automatic event to release it after they are done, if their lock object is to be reused.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If the lock object is not to be reused, this function will be called by the lock object's destructor.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>CSyncObject Class</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Hierarchy Chart</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>