{"nodes":[{"pos":[12,70],"content":"Exceptions: Freeing Objects in Exceptions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Exceptions: Freeing Objects in Exceptions | Microsoft Docs","pos":[0,58]}]},{"content":"Exceptions: Freeing Objects in Exceptions","pos":[892,933]},{"content":"This article explains the need and the method of freeing objects when an exception occurs.","pos":[934,1024]},{"content":"Topics include:","pos":[1025,1040]},{"content":"Handling the exception locally","pos":[1051,1081]},{"content":"Throwing exceptions after destroying objects","pos":[1132,1176]},{"content":"Exceptions thrown by the framework or by your application interrupt normal program flow.","pos":[1237,1325]},{"content":"Thus, it is very important to keep close track of objects so that you can properly dispose of them in case an exception is thrown.","pos":[1326,1456]},{"content":"There are two primary methods to do this.","pos":[1463,1504]},{"pos":[1514,1626],"content":"Handle exceptions locally using the <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> keywords, then destroy all objects with one statement.","source":"Handle exceptions locally using the **try** and **catch** keywords, then destroy all objects with one statement."},{"pos":[1636,1747],"content":"Destroy any object in the <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> block before throwing the exception outside the block for further handling.","source":"Destroy any object in the **catch** block before throwing the exception outside the block for further handling."},{"content":"These two approaches are illustrated below as solutions to the following problematic example:","pos":[1754,1847]},{"pos":[1865,1885],"content":"NVC_MFCExceptions#14"},{"content":"As written above, <ph id=\"ph1\">`myPerson`</ph> will not be deleted if an exception is thrown by <ph id=\"ph2\">`SomeFunc`</ph>.","pos":[1965,2054],"source":"As written above, `myPerson` will not be deleted if an exception is thrown by `SomeFunc`."},{"content":"Execution jumps directly to the next outer exception handler, bypassing the normal function exit and the code that deletes the object.","pos":[2055,2189]},{"content":"The pointer to the object goes out of scope when the exception leaves the function, and the memory occupied by the object will never be recovered as long as the program is running.","pos":[2190,2370]},{"content":"This is a memory leak; it would be detected by using the memory diagnostics.","pos":[2371,2447]},{"pos":[2509,2539],"content":"Handling the Exception Locally"},{"content":"The <bpt id=\"p1\">**</bpt>try/catch<ept id=\"p1\">**</ept> paradigm provides a defensive programming method for avoiding memory leaks and ensuring that your objects are destroyed when exceptions occur.","pos":[2543,2703],"source":"The **try/catch** paradigm provides a defensive programming method for avoiding memory leaks and ensuring that your objects are destroyed when exceptions occur."},{"content":"For instance, the example shown earlier in this article could be rewritten as follows:","pos":[2704,2790]},{"pos":[2808,2828],"content":"NVC_MFCExceptions#15"},{"content":"This new example sets up an exception handler to catch the exception and handle it locally.","pos":[2908,2999]},{"content":"It then exits the function normally and destroys the object.","pos":[3000,3060]},{"content":"The important aspect of this example is that a context to catch the exception is established with the <bpt id=\"p1\">**</bpt>try/catch<ept id=\"p1\">**</ept> blocks.","pos":[3061,3184],"source":" The important aspect of this example is that a context to catch the exception is established with the **try/catch** blocks."},{"content":"Without a local exception frame, the function would never know that an exception had been thrown and would not have the chance to exit normally and destroy the object.","pos":[3185,3352]},{"pos":[3428,3472],"content":"Throwing Exceptions After Destroying Objects"},{"content":"Another way to handle exceptions is to pass them on to the next outer exception-handling context.","pos":[3476,3573]},{"content":"In your <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> block, you can do some cleanup of your locally allocated objects and then throw the exception on for further processing.","pos":[3574,3712],"source":" In your **catch** block, you can do some cleanup of your locally allocated objects and then throw the exception on for further processing."},{"content":"The throwing function may or may not need to deallocate heap objects.","pos":[3719,3788]},{"content":"If the function always deallocates the heap object before returning in the normal case, then the function should also deallocate the heap object before throwing the exception.","pos":[3789,3964]},{"content":"On the other hand, if the function does not normally deallocate the object before returning in the normal case, then you must decide on a case-by-case basis whether the heap object should be deallocated.","pos":[3965,4168]},{"content":"The following example shows how locally allocated objects can be cleaned up:","pos":[4175,4251]},{"pos":[4269,4289],"content":"NVC_MFCExceptions#16"},{"content":"The exception mechanism automatically deallocates frame objects; the destructor of the frame object is also called.","pos":[4369,4484]},{"content":"If you call functions that can throw exceptions, you can use <bpt id=\"p1\">**</bpt>try/catch<ept id=\"p1\">**</ept> blocks to make sure that you catch the exceptions and have a chance to destroy any objects you have created.","pos":[4491,4674],"source":"If you call functions that can throw exceptions, you can use **try/catch** blocks to make sure that you catch the exceptions and have a chance to destroy any objects you have created."},{"content":"In particular, be aware that many MFC functions can throw exceptions.","pos":[4675,4744]},{"pos":[4751,4879],"content":"For more information, see <bpt id=\"p1\">[</bpt>Exceptions: Catching and Deleting Exceptions<ept id=\"p1\">](../mfc/exceptions-catching-and-deleting-exceptions.md)</ept>.","source":"For more information, see [Exceptions: Catching and Deleting Exceptions](../mfc/exceptions-catching-and-deleting-exceptions.md)."},{"content":"See Also","pos":[4888,4896]},{"content":"Exception Handling","pos":[4901,4919]}],"content":"---\ntitle: \"Exceptions: Freeing Objects in Exceptions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"throwing exceptions, freeing objects in exceptions\"\n  - \"local exception handling\"\n  - \"memory leaks, caused by exception\"\n  - \"try-catch exception handling, destroying objects\"\n  - \"destroying objects\"\n  - \"freeing objects\"\n  - \"throwing exceptions, after destroying\"\n  - \"exception handling, destroying objects\"\nms.assetid: 3b14b4ee-e789-4ed2-b8e3-984950441d97\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Exceptions: Freeing Objects in Exceptions\nThis article explains the need and the method of freeing objects when an exception occurs. Topics include:  \n  \n-   [Handling the exception locally](#_core_handling_the_exception_locally)  \n  \n-   [Throwing exceptions after destroying objects](#_core_throwing_exceptions_after_destroying_objects)  \n  \n Exceptions thrown by the framework or by your application interrupt normal program flow. Thus, it is very important to keep close track of objects so that you can properly dispose of them in case an exception is thrown.  \n  \n There are two primary methods to do this.  \n  \n-   Handle exceptions locally using the **try** and **catch** keywords, then destroy all objects with one statement.  \n  \n-   Destroy any object in the **catch** block before throwing the exception outside the block for further handling.  \n  \n These two approaches are illustrated below as solutions to the following problematic example:  \n  \n [!code-cpp[NVC_MFCExceptions#14](../mfc/codesnippet/cpp/exceptions-freeing-objects-in-exceptions_1.cpp)]  \n  \n As written above, `myPerson` will not be deleted if an exception is thrown by `SomeFunc`. Execution jumps directly to the next outer exception handler, bypassing the normal function exit and the code that deletes the object. The pointer to the object goes out of scope when the exception leaves the function, and the memory occupied by the object will never be recovered as long as the program is running. This is a memory leak; it would be detected by using the memory diagnostics.  \n  \n##  <a name=\"_core_handling_the_exception_locally\"></a> Handling the Exception Locally  \n The **try/catch** paradigm provides a defensive programming method for avoiding memory leaks and ensuring that your objects are destroyed when exceptions occur. For instance, the example shown earlier in this article could be rewritten as follows:  \n  \n [!code-cpp[NVC_MFCExceptions#15](../mfc/codesnippet/cpp/exceptions-freeing-objects-in-exceptions_2.cpp)]  \n  \n This new example sets up an exception handler to catch the exception and handle it locally. It then exits the function normally and destroys the object. The important aspect of this example is that a context to catch the exception is established with the **try/catch** blocks. Without a local exception frame, the function would never know that an exception had been thrown and would not have the chance to exit normally and destroy the object.  \n  \n##  <a name=\"_core_throwing_exceptions_after_destroying_objects\"></a> Throwing Exceptions After Destroying Objects  \n Another way to handle exceptions is to pass them on to the next outer exception-handling context. In your **catch** block, you can do some cleanup of your locally allocated objects and then throw the exception on for further processing.  \n  \n The throwing function may or may not need to deallocate heap objects. If the function always deallocates the heap object before returning in the normal case, then the function should also deallocate the heap object before throwing the exception. On the other hand, if the function does not normally deallocate the object before returning in the normal case, then you must decide on a case-by-case basis whether the heap object should be deallocated.  \n  \n The following example shows how locally allocated objects can be cleaned up:  \n  \n [!code-cpp[NVC_MFCExceptions#16](../mfc/codesnippet/cpp/exceptions-freeing-objects-in-exceptions_3.cpp)]  \n  \n The exception mechanism automatically deallocates frame objects; the destructor of the frame object is also called.  \n  \n If you call functions that can throw exceptions, you can use **try/catch** blocks to make sure that you catch the exceptions and have a chance to destroy any objects you have created. In particular, be aware that many MFC functions can throw exceptions.  \n  \n For more information, see [Exceptions: Catching and Deleting Exceptions](../mfc/exceptions-catching-and-deleting-exceptions.md).  \n  \n## See Also  \n [Exception Handling](../mfc/exception-handling-in-mfc.md)\n\n"}