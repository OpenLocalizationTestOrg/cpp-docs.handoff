{"nodes":[{"pos":[12,62],"content":"How to: Use Properties in C++-CLI | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Use Properties in C++-CLI | Microsoft Docs","pos":[0,50]}]},{"content":"How to: Use Properties in C++/CLI","pos":[620,653]},{"content":"This article shows how to use properties in C++/CLI.","pos":[654,706]},{"content":"Basic properties","pos":[715,731]},{"content":"For basic properties—those that merely assign and retrieve a private data member—you don't have to explicitly define the get and set accessor functions because the compiler automatically provides them when given just the data type of the property.","pos":[735,982]},{"content":"This code demonstrates a basic property:","pos":[983,1023]},{"content":"Output","pos":[1304,1310]},{"content":"Static properties","pos":[1358,1375]},{"content":"This code sample shows how to declare and use a static property.","pos":[1379,1443]},{"content":"A static property can only access static members of its class.","pos":[1445,1507]},{"content":"Output","pos":[2221,2227]},{"content":"Indexed properties","pos":[2269,2287]},{"content":"An indexed property typically exposes a data structure that's accessed by using a subscript operator.","pos":[2291,2392]},{"content":"If you use a default indexed property, you can access the data structure just by referring to the class name, but if you use a user-defined indexed property, you must to specify the property name to access the data structure.","pos":[2399,2624]},{"pos":[2631,2800],"content":"For information about how to consume an indexer that's written in C#, see <bpt id=\"p1\">[</bpt>How to: Consume a C# Indexer (C++/CLI)<ept id=\"p1\">](../dotnet/how-to-consume-a-csharp-indexer-cpp-cli.md)</ept>.","source":"For information about how to consume an indexer that's written in C#, see [How to: Consume a C# Indexer (C++/CLI)](../dotnet/how-to-consume-a-csharp-indexer-cpp-cli.md)."},{"content":"This code sample shows how to use default and user-defined indexed properties:","pos":[2807,2885]},{"content":"Output","pos":[4031,4037]},{"pos":[4099,4181],"content":"The next sample shows how to call the default indexer by using the <ph id=\"ph1\">`this`</ph> pointer.","source":"The next sample shows how to call the default indexer by using the `this` pointer."},{"content":"This sample shows how to use &lt;xref:System.Reflection.DefaultMemberAttribute&gt; to specify the default indexer:","pos":[4650,4758],"source":"This sample shows how to use <xref:System.Reflection.DefaultMemberAttribute> to specify the default indexer:"},{"content":"The next sample consumes the metadata that's created in the previous example.","pos":[5054,5131]},{"content":"Output","pos":[5362,5368]},{"content":"Virtual properties","pos":[5404,5422]},{"content":"This code sample shows how to declare and use virtual properties:","pos":[5426,5491]},{"content":"Output","pos":[6306,6312]},{"content":"Abstract and sealed properties","pos":[6354,6384]},{"pos":[6388,6722],"content":"Although the <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../windows/abstract-cpp-component-extensions.md)</ept> and <bpt id=\"p2\">[</bpt>sealed<ept id=\"p2\">](../windows/sealed-cpp-component-extensions.md)</ept> keywords are specified as valid in the ECMA C++/CLI specification, for the Visual C++ compiler, you cannot specify them on trivial properties, nor on the property declaration of a non-trivial property.","source":"Although the [abstract](../windows/abstract-cpp-component-extensions.md) and [sealed](../windows/sealed-cpp-component-extensions.md) keywords are specified as valid in the ECMA C++/CLI specification, for the Visual C++ compiler, you cannot specify them on trivial properties, nor on the property declaration of a non-trivial property."},{"pos":[6729,6900],"content":"To declare a sealed or abstract property, you must define a non-trivial property and then specify the <ph id=\"ph1\">`abstract`</ph> or <ph id=\"ph2\">`sealed`</ph> keyword on the get and set accessor functions.","source":"To declare a sealed or abstract property, you must define a non-trivial property and then specify the `abstract` or `sealed` keyword on the get and set accessor functions."},{"content":"Output","pos":[7954,7960]},{"content":"Multidimensional properties","pos":[8002,8029]},{"content":"You can use multidimensional properties to define property accessor methods that take a non-standard number of parameters.","pos":[8033,8155]},{"content":"Output","pos":[8906,8912]},{"content":"Overloading property accessors","pos":[8950,8980]},{"content":"The following example shows how to overload indexed properties.","pos":[8984,9047]},{"content":"Output","pos":[9643,9649]},{"content":"See Also","pos":[9693,9701]},{"content":"property","pos":[9706,9714]}],"content":"---\ntitle: \"How to: Use Properties in C++-CLI | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"simple properties\"\n  - \"properties [C++], simple\"\nms.assetid: f5d82547-e214-4f05-9e1b-ddb6d0dc5e4c\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Use Properties in C++/CLI\nThis article shows how to use properties in C++/CLI.  \n  \n## Basic properties  \n For basic properties—those that merely assign and retrieve a private data member—you don't have to explicitly define the get and set accessor functions because the compiler automatically provides them when given just the data type of the property. This code demonstrates a basic property:  \n  \n```  \n  \n      // SimpleProperties.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref class C {  \npublic:  \n   property int Size;  \n};  \n  \nint main() {  \n   C^ c = gcnew C;  \n   c->Size = 111;  \n   Console::WriteLine(\"c->Size = {0}\", c->Size);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nc->Size = 111  \n```  \n  \n## Static properties  \n This code sample shows how to declare and use a static property.  A static property can only access static members of its class.  \n  \n```  \n// mcppv2_property_3.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref class StaticProperties {  \n   static int MyInt;  \n   static int MyInt2;  \n  \npublic:  \n   static property int Static_Data_Member_Property;  \n  \n   static property int Static_Block_Property {  \n      int get() {  \n         return MyInt;  \n      }  \n  \n      void set(int value) {  \n         MyInt = value;  \n      }        \n   }  \n};  \n  \nint main() {  \n   StaticProperties::Static_Data_Member_Property = 96;  \n   Console::WriteLine(StaticProperties::Static_Data_Member_Property);  \n  \n   StaticProperties::Static_Block_Property = 47;  \n   Console::WriteLine(StaticProperties::Static_Block_Property);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n96  \n47  \n```  \n  \n## Indexed properties  \n An indexed property typically exposes a data structure that's accessed by using a subscript operator.  \n  \n If you use a default indexed property, you can access the data structure just by referring to the class name, but if you use a user-defined indexed property, you must to specify the property name to access the data structure.  \n  \n For information about how to consume an indexer that's written in C#, see [How to: Consume a C# Indexer (C++/CLI)](../dotnet/how-to-consume-a-csharp-indexer-cpp-cli.md).  \n  \n This code sample shows how to use default and user-defined indexed properties:  \n  \n```  \n// mcppv2_property_2.cpp  \n// compile with: /clr  \nusing namespace System;  \npublic ref class C {  \n   array<int>^ MyArr;  \n  \npublic:  \n   C() {  \n      MyArr = gcnew array<int>(5);  \n   }  \n  \n   // default indexer  \n   property int default[int] {  \n      int get(int index) {  \n         return MyArr[index];  \n      }  \n      void set(int index, int value) {  \n         MyArr[index] = value;  \n      }  \n   }  \n  \n   // user-defined indexer  \n   property int indexer1[int] {  \n      int get(int index) {  \n         return MyArr[index];  \n      }  \n      void set(int index, int value) {  \n         MyArr[index] = value;  \n      }  \n   }  \n};  \n  \nint main() {  \n   C ^ MyC = gcnew C();  \n  \n   // use the default indexer  \n   Console::Write(\"[ \");  \n   for (int i = 0 ; i < 5 ; i++) {  \n      MyC[i] = i;  \n      Console::Write(\"{0} \", MyC[i]);  \n   }  \n  \n   Console::WriteLine(\"]\");  \n  \n   // use the user-defined indexer  \n   Console::Write(\"[ \");  \n   for (int i = 0 ; i < 5 ; i++) {  \n      MyC->indexer1[i] = i * 2;  \n      Console::Write(\"{0} \", MyC->indexer1[i]);  \n   }  \n  \n   Console::WriteLine(\"]\");  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n[ 0 1 2 3 4 ]  \n[ 0 2 4 6 8 ]  \n```  \n  \n The next sample shows how to call the default indexer by using the `this` pointer.  \n  \n```  \n// call_default_indexer_through_this_pointer.cpp  \n// compile with: /clr /c  \nvalue class Position {  \npublic:  \n   Position(int x, int y) : position(gcnew array<int, 2>(100, 100)) {  \n      this->default[x, y] = 1;  \n   }  \n  \n   property int default[int, int] {  \n      int get(int x, int y) {  \n         return position[x, y];  \n      }  \n  \n      void set(int x, int y, int value) {}  \n   }  \n  \nprivate:  \n   array<int, 2> ^ position;  \n};  \n```  \n  \n This sample shows how to use <xref:System.Reflection.DefaultMemberAttribute> to specify the default indexer:  \n  \n```  \n// specify_default_indexer.cpp  \n// compile with: /LD /clr  \nusing namespace System;  \n[Reflection::DefaultMember(\"XXX\")]  \npublic ref struct Squares {  \n   property Double XXX[Double] {  \n      Double get(Double data) {  \n         return data*data;  \n      }  \n   }  \n};  \n```  \n  \n The next sample consumes the metadata that's created in the previous example.  \n  \n```  \n// consume_default_indexer.cpp  \n// compile with: /clr  \n#using \"specify_default_indexer.dll\"  \nint main() {  \n   Squares ^ square = gcnew Squares();  \n   System::Console::WriteLine(\"{0}\", square[3]);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n9  \n```  \n  \n## Virtual properties  \n This code sample shows how to declare and use virtual properties:  \n  \n```  \n// mcppv2_property_4.cpp  \n// compile with: /clr  \nusing namespace System;  \ninterface struct IEFace {  \npublic:  \n   property int VirtualProperty1;  \n   property int VirtualProperty2 {  \n      int get();  \n      void set(int i);  \n   }  \n};  \n  \n// implement virtual events  \nref class PropImpl : public IEFace {  \n   int MyInt;  \npublic:  \n   virtual property int VirtualProperty1;  \n  \n   virtual property int VirtualProperty2 {  \n      int get() {  \n         return MyInt;  \n      }  \n      void set(int i) {  \n         MyInt = i;  \n      }  \n   }  \n};  \n  \nint main() {  \n   PropImpl ^ MyPI = gcnew PropImpl();  \n   MyPI->VirtualProperty1 = 93;  \n   Console::WriteLine(MyPI->VirtualProperty1);  \n  \n   MyPI->VirtualProperty2 = 43;  \n   Console::WriteLine(MyPI->VirtualProperty2);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n93  \n43  \n```  \n  \n## Abstract and sealed properties  \n Although the [abstract](../windows/abstract-cpp-component-extensions.md) and [sealed](../windows/sealed-cpp-component-extensions.md) keywords are specified as valid in the ECMA C++/CLI specification, for the Visual C++ compiler, you cannot specify them on trivial properties, nor on the property declaration of a non-trivial property.  \n  \n To declare a sealed or abstract property, you must define a non-trivial property and then specify the `abstract` or `sealed` keyword on the get and set accessor functions.  \n  \n```  \n// properties_abstract_sealed.cpp  \n// compile with: /clr  \nref struct A {  \nprotected:  \n   int m_i;  \n  \npublic:  \n   A() { m_i = 87; }  \n  \n   // define abstract property  \n   property int Prop_1 {  \n      virtual int get() abstract;  \n      virtual void set(int i) abstract;  \n   }  \n};  \n  \nref struct B : A {  \nprivate:  \n   int m_i;  \n  \npublic:  \n   B() { m_i = 86; }  \n  \n   // implement abstract property  \n   property int Prop_1 {  \n      virtual int get() override { return m_i; }  \n      virtual void set(int i) override { m_i = i; }  \n   }  \n};  \n  \nref struct C {  \nprivate:  \n   int m_i;  \n  \npublic:  \n   C() { m_i = 87; }  \n  \n   // define sealed property  \n   property int Prop_2 {  \n      virtual int get() sealed { return m_i; }  \n      virtual void set(int i) sealed { m_i = i; };  \n   }  \n};  \n  \nint main() {  \n   B b1;  \n   // call implementation of abstract property  \n   System::Console::WriteLine(b1.Prop_1);  \n  \n   C c1;  \n   // call sealed property  \n   System::Console::WriteLine(c1.Prop_2);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n86  \n87  \n```  \n  \n## Multidimensional properties  \n You can use multidimensional properties to define property accessor methods that take a non-standard number of parameters.  \n  \n```  \n// mcppv2_property_5.cpp  \n// compile with: /clr  \nref class X {  \n   double d;  \npublic:  \n   X() : d(0) {}  \n   property double MultiDimProp[int, int, int] {  \n      double get(int, int, int) {  \n         return d;  \n      }  \n      void set(int i, int j, int k, double l) {  \n         // do something with those ints  \n         d = l;  \n      }  \n   }  \n  \n   property double MultiDimProp2[int] {  \n      double get(int) {  \n         return d;  \n      }  \n      void set(int i, double l) {  \n         // do something with those ints  \n         d = l;  \n      }  \n   }  \n  \n};  \n  \nint main() {  \n   X ^ MyX = gcnew X();  \n   MyX->MultiDimProp[0,0,0] = 1.1;  \n   System::Console::WriteLine(MyX->MultiDimProp[0, 0, 0]);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n1.1  \n```  \n  \n## Overloading property accessors  \n The following example shows how to overload indexed properties.  \n  \n```  \n// mcppv2_property_6.cpp  \n// compile with: /clr  \nref class X {  \n   double d;  \npublic:  \n   X() : d(0.0) {}  \n   property double MyProp[int] {  \n      double get(int i) {  \n         return d;  \n      }  \n  \n      double get(System::String ^ i) {  \n         return 2*d;  \n      }  \n  \n      void set(int i, double l) {  \n         d = i * l;  \n      }  \n   }   // end MyProp definition  \n};  \n  \nint main() {  \n   X ^ MyX = gcnew X();  \n   MyX->MyProp[2] = 1.7;  \n   System::Console::WriteLine(MyX->MyProp[1]);  \n   System::Console::WriteLine(MyX->MyProp[\"test\"]);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n3.4  \n6.8  \n```  \n  \n## See Also  \n [property](../windows/property-cpp-component-extensions.md)"}