{"nodes":[{"pos":[12,47],"content":"Single Inheritance | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Single Inheritance | Microsoft Docs","pos":[0,35]}]},{"content":"Single Inheritance","pos":[861,879]},{"content":"In \"single inheritance,\" a common form of inheritance, classes have only one base class.","pos":[880,968]},{"content":"Consider the relationship illustrated in the following figure.","pos":[969,1031]},{"content":"Basic single&amp;#45;inheritance graph","pos":[1040,1074],"source":"Basic single&#45;inheritance graph"},{"content":"Simple Single-Inheritance Graph","pos":[1114,1145]},{"content":"Note the progression from general to specific in the figure.","pos":[1152,1212]},{"content":"Another common attribute found in the design of most class hierarchies is that the derived class has a \"kind of\" relationship with the base class.","pos":[1213,1359]},{"content":"In the figure, a <ph id=\"ph1\">`Book`</ph> is a kind of a <ph id=\"ph2\">`PrintedDocument`</ph>, and a <ph id=\"ph3\">`PaperbackBook`</ph> is a kind of a <ph id=\"ph4\">`book`</ph>.","pos":[1360,1462],"source":" In the figure, a `Book` is a kind of a `PrintedDocument`, and a `PaperbackBook` is a kind of a `book`."},{"content":"One other item of note in the figure: <ph id=\"ph1\">`Book`</ph> is both a derived class (from <ph id=\"ph2\">`PrintedDocument`</ph>) and a base class (<ph id=\"ph3\">`PaperbackBook`</ph> is derived from <ph id=\"ph4\">`Book`</ph>).","pos":[1469,1621],"source":"One other item of note in the figure: `Book` is both a derived class (from `PrintedDocument`) and a base class (`PaperbackBook` is derived from `Book`)."},{"content":"A skeletal declaration of such a class hierarchy is shown in the following example:","pos":[1622,1705]},{"content":"is considered a \"direct base\" class to <ph id=\"ph1\">`Book`</ph>; it is an \"indirect base\" class to <ph id=\"ph2\">`PaperbackBook`</ph>.","pos":[2001,2098],"source":" is considered a \"direct base\" class to `Book`; it is an \"indirect base\" class to `PaperbackBook`."},{"content":"The difference is that a direct base class appears in the base list of a class declaration and an indirect base does not.","pos":[2099,2220]},{"content":"The base class from which each class is derived is declared before the declaration of the derived class.","pos":[2227,2331]},{"content":"It is not sufficient to provide a forward-referencing declaration for a base class; it must be a complete declaration.","pos":[2332,2450]},{"content":"In the preceding example, the access specifier <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> is used.","pos":[2457,2523],"source":"In the preceding example, the access specifier **public** is used."},{"content":"The meaning of public, protected, and private inheritance is described in <bpt id=\"p1\">[</bpt>Member-Access Control.<ept id=\"p1\">](../cpp/member-access-control-cpp.md)</ept>","pos":[2524,2659],"source":" The meaning of public, protected, and private inheritance is described in [Member-Access Control.](../cpp/member-access-control-cpp.md)"},{"content":"A class can serve as the base class for many specific classes, as illustrated in the following figure.","pos":[2666,2768]},{"content":"Directed acyclic graph","pos":[2777,2799]},{"content":"Sample of Directed Acyclic Graph","pos":[2839,2871]},{"content":"In the diagram shown above, called a \"directed acyclic graph\" (or \"DAG\"), some of the classes are base classes for more than one derived class.","pos":[2878,3021]},{"content":"However, the reverse is not true: there is only one direct base class for any given derived class.","pos":[3022,3120]},{"content":"The graph in the figure depicts a \"single inheritance\" structure.","pos":[3121,3186]},{"pos":[3194,3443],"content":"[!NOTE]\n Directed acyclic graphs are not unique to single inheritance. They are also used to depict multiple-inheritance graphs. This topic is covered in [Multiple Inheritance](http://msdn.microsoft.com/en-us/3b74185e-2beb-4e29-8684-441e51d2a2ca).","leadings":["","> "],"nodes":[{"content":" Directed acyclic graphs are not unique to single inheritance. They are also used to depict multiple-inheritance graphs. This topic is covered in [Multiple Inheritance](http://msdn.microsoft.com/en-us/3b74185e-2beb-4e29-8684-441e51d2a2ca).","pos":[8,247],"nodes":[{"content":"Directed acyclic graphs are not unique to single inheritance.","pos":[1,62]},{"content":"They are also used to depict multiple-inheritance graphs.","pos":[63,120]},{"content":"This topic is covered in <bpt id=\"p1\">[</bpt>Multiple Inheritance<ept id=\"p1\">](http://msdn.microsoft.com/en-us/3b74185e-2beb-4e29-8684-441e51d2a2ca)</ept>.","pos":[121,239],"source":" This topic is covered in [Multiple Inheritance](http://msdn.microsoft.com/en-us/3b74185e-2beb-4e29-8684-441e51d2a2ca)."}]}]},{"content":"In inheritance, the derived class contains the members of the base class plus any new members you add.","pos":[3450,3552]},{"content":"As a result, a derived class can refer to members of the base class (unless those members are redefined in the derived class).","pos":[3553,3679]},{"content":"The scope-resolution operator (<ph id=\"ph1\">`::`</ph>) can be used to refer to members of direct or indirect base classes when those members have been redefined in the derived class.","pos":[3680,3844],"source":" The scope-resolution operator (`::`) can be used to refer to members of direct or indirect base classes when those members have been redefined in the derived class."},{"content":"Consider this example:","pos":[3845,3867]},{"content":"Note that the constructor for <ph id=\"ph1\">`Book`</ph>, (<ph id=\"ph2\">`Book::Book`</ph>), has access to the data member, <ph id=\"ph3\">`Name`</ph>.","pos":[4568,4660],"source":"Note that the constructor for `Book`, (`Book::Book`), has access to the data member, `Name`."},{"content":"In a program, an object of type <ph id=\"ph1\">`Book`</ph> can be created and used as follows:","pos":[4661,4735],"source":" In a program, an object of type `Book` can be created and used as follows:"},{"content":"As the preceding example demonstrates, class-member and inherited data and functions are used identically.","pos":[5006,5112]},{"content":"If the implementation for class <ph id=\"ph1\">`Book`</ph> calls for a reimplementation of the <ph id=\"ph2\">`PrintNameOf`</ph> function, the function that belongs to the <ph id=\"ph3\">`Document`</ph> class can be called only by using the scope-resolution (<ph id=\"ph4\">`::`</ph>) operator:","pos":[5113,5327],"source":" If the implementation for class `Book` calls for a reimplementation of the `PrintNameOf` function, the function that belongs to the `Document` class can be called only by using the scope-resolution (`::`) operator:"},{"content":"Pointers and references to derived classes can be implicitly converted to pointers and references to their base classes if there is an accessible, unambiguous base class.","pos":[5808,5978]},{"content":"The following code demonstrates this concept using pointers (the same principle applies to references):","pos":[5979,6082]},{"content":"In the preceding example, different types are created.","pos":[6428,6482]},{"content":"However, because these types are all derived from the <ph id=\"ph1\">`Document`</ph> class, there is an implicit conversion to <ph id=\"ph2\">`Document *`</ph>.","pos":[6483,6603],"source":" However, because these types are all derived from the `Document` class, there is an implicit conversion to `Document *`."},{"content":"As a result, <ph id=\"ph1\">`DocLib`</ph> is a \"heterogeneous list\" (a list in which not all objects are of the same type) containing different kinds of objects.","pos":[6604,6745],"source":" As a result, `DocLib` is a \"heterogeneous list\" (a list in which not all objects are of the same type) containing different kinds of objects."},{"pos":[6752,7007],"content":"Because the <ph id=\"ph1\">`Document`</ph> class has a <ph id=\"ph2\">`PrintNameOf`</ph> function, it can print the name of each book in the library, although it may omit some of the information specific to the type of document (page count for <ph id=\"ph3\">`Book`</ph>, number of bytes for <ph id=\"ph4\">`HelpFile`</ph>, and so on).","source":"Because the `Document` class has a `PrintNameOf` function, it can print the name of each book in the library, although it may omit some of the information specific to the type of document (page count for `Book`, number of bytes for `HelpFile`, and so on)."},{"pos":[7015,7207],"content":"[!NOTE]\n Forcing the base class to implement a function such as `PrintNameOf` is often not the best design. [Virtual Functions](../cpp/virtual-functions.md) offers other design alternatives.","leadings":["","> "],"nodes":[{"content":" Forcing the base class to implement a function such as `PrintNameOf` is often not the best design. [Virtual Functions](../cpp/virtual-functions.md) offers other design alternatives.","pos":[8,190],"nodes":[{"content":"Forcing the base class to implement a function such as <ph id=\"ph1\">`PrintNameOf`</ph> is often not the best design.","pos":[1,99],"source":" Forcing the base class to implement a function such as `PrintNameOf` is often not the best design."},{"content":"<bpt id=\"p1\">[</bpt>Virtual Functions<ept id=\"p1\">](../cpp/virtual-functions.md)</ept> offers other design alternatives.","pos":[100,182],"source":"[Virtual Functions](../cpp/virtual-functions.md) offers other design alternatives."}]}]}],"content":"---\ntitle: \"Single Inheritance | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"single inheritance_cpp\"\n  - \"single inheritance\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"single inheritance\"\n  - \"base classes, indirect\"\n  - \"scope, scope resolution operator\"\n  - \"operators [C++], scope resolution\"\n  - \"scope resolution operator\"\n  - \"derived classes, single base class\"\n  - \"inheritance, single\"\nms.assetid: 1cb946ed-8b1b-4cf1-bde0-d9cecbfdc622\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Single Inheritance\nIn \"single inheritance,\" a common form of inheritance, classes have only one base class. Consider the relationship illustrated in the following figure.  \n  \n ![Basic single&#45;inheritance graph](../cpp/media/vc38xj1.gif \"vc38XJ1\")  \nSimple Single-Inheritance Graph  \n  \n Note the progression from general to specific in the figure. Another common attribute found in the design of most class hierarchies is that the derived class has a \"kind of\" relationship with the base class. In the figure, a `Book` is a kind of a `PrintedDocument`, and a `PaperbackBook` is a kind of a `book`.  \n  \n One other item of note in the figure: `Book` is both a derived class (from `PrintedDocument`) and a base class (`PaperbackBook` is derived from `Book`). A skeletal declaration of such a class hierarchy is shown in the following example:  \n  \n```  \n// deriv_SingleInheritance.cpp  \n// compile with: /LD  \nclass PrintedDocument {};  \n  \n// Book is derived from PrintedDocument.  \nclass Book : public PrintedDocument {};  \n  \n// PaperbackBook is derived from Book.  \nclass PaperbackBook : public Book {};  \n```  \n  \n `PrintedDocument` is considered a \"direct base\" class to `Book`; it is an \"indirect base\" class to `PaperbackBook`. The difference is that a direct base class appears in the base list of a class declaration and an indirect base does not.  \n  \n The base class from which each class is derived is declared before the declaration of the derived class. It is not sufficient to provide a forward-referencing declaration for a base class; it must be a complete declaration.  \n  \n In the preceding example, the access specifier **public** is used. The meaning of public, protected, and private inheritance is described in [Member-Access Control.](../cpp/member-access-control-cpp.md)  \n  \n A class can serve as the base class for many specific classes, as illustrated in the following figure.  \n  \n ![Directed acyclic graph](../cpp/media/vc38xj2.gif \"vc38XJ2\")  \nSample of Directed Acyclic Graph  \n  \n In the diagram shown above, called a \"directed acyclic graph\" (or \"DAG\"), some of the classes are base classes for more than one derived class. However, the reverse is not true: there is only one direct base class for any given derived class. The graph in the figure depicts a \"single inheritance\" structure.  \n  \n> [!NOTE]\n>  Directed acyclic graphs are not unique to single inheritance. They are also used to depict multiple-inheritance graphs. This topic is covered in [Multiple Inheritance](http://msdn.microsoft.com/en-us/3b74185e-2beb-4e29-8684-441e51d2a2ca).  \n  \n In inheritance, the derived class contains the members of the base class plus any new members you add. As a result, a derived class can refer to members of the base class (unless those members are redefined in the derived class). The scope-resolution operator (`::`) can be used to refer to members of direct or indirect base classes when those members have been redefined in the derived class. Consider this example:  \n  \n```  \n// deriv_SingleInheritance2.cpp  \n// compile with: /EHsc /c  \n#include <iostream>  \nusing namespace std;  \nclass Document {  \npublic:  \n   char *Name;   // Document name.  \n   void PrintNameOf();   // Print name.  \n};  \n  \n// Implementation of PrintNameOf function from class Document.  \nvoid Document::PrintNameOf() {  \n   cout << Name << endl;  \n}  \n  \nclass Book : public Document {  \npublic:  \n   Book( char *name, long pagecount );  \nprivate:  \n   long  PageCount;  \n};  \n  \n// Constructor from class Book.  \nBook::Book( char *name, long pagecount ) {  \n   Name = new char[ strlen( name ) + 1 ];  \n   strcpy_s( Name, strlen(Name), name );  \n   PageCount = pagecount;  \n};  \n```  \n  \n Note that the constructor for `Book`, (`Book::Book`), has access to the data member, `Name`. In a program, an object of type `Book` can be created and used as follows:  \n  \n```  \n//  Create a new object of type Book. This invokes the  \n//   constructor Book::Book.  \nBook LibraryBook( \"Programming Windows, 2nd Ed\", 944 );  \n  \n...  \n  \n//  Use PrintNameOf function inherited from class Document.  \nLibraryBook.PrintNameOf();  \n```  \n  \n As the preceding example demonstrates, class-member and inherited data and functions are used identically. If the implementation for class `Book` calls for a reimplementation of the `PrintNameOf` function, the function that belongs to the `Document` class can be called only by using the scope-resolution (`::`) operator:  \n  \n```  \n// deriv_SingleInheritance3.cpp  \n// compile with: /EHsc /LD  \n#include <iostream>  \nusing namespace std;  \n  \nclass Document {  \npublic:  \n   char *Name;          // Document name.  \n   void  PrintNameOf() {}  // Print name.  \n};  \n  \nclass Book : public Document {  \n   Book( char *name, long pagecount );  \n   void PrintNameOf();  \n   long  PageCount;  \n};  \n  \nvoid Book::PrintNameOf() {  \n   cout << \"Name of book: \";  \n   Document::PrintNameOf();  \n}  \n```  \n  \n Pointers and references to derived classes can be implicitly converted to pointers and references to their base classes if there is an accessible, unambiguous base class. The following code demonstrates this concept using pointers (the same principle applies to references):  \n  \n```  \n// deriv_SingleInheritance4.cpp  \n// compile with: /W3  \nstruct Document {  \n   char *Name;  \n   void PrintNameOf() {}  \n};  \n  \nclass PaperbackBook : public Document {};  \n  \nint main() {  \n   Document * DocLib[10];   // Library of ten documents.  \n   for (int i = 0 ; i < 10 ; i++)  \n      DocLib[i] = new Document;  \n}  \n```  \n  \n In the preceding example, different types are created. However, because these types are all derived from the `Document` class, there is an implicit conversion to `Document *`. As a result, `DocLib` is a \"heterogeneous list\" (a list in which not all objects are of the same type) containing different kinds of objects.  \n  \n Because the `Document` class has a `PrintNameOf` function, it can print the name of each book in the library, although it may omit some of the information specific to the type of document (page count for `Book`, number of bytes for `HelpFile`, and so on).  \n  \n> [!NOTE]\n>  Forcing the base class to implement a function such as `PrintNameOf` is often not the best design. [Virtual Functions](../cpp/virtual-functions.md) offers other design alternatives.  \n  \n"}