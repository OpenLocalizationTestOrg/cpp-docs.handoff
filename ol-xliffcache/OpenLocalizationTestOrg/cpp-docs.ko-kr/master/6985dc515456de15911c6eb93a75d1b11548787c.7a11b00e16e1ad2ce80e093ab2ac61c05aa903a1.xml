{"nodes":[{"pos":[12,57],"content":"Alignment (C++ Declarations) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Alignment (C++ Declarations) | Microsoft Docs","pos":[0,45]}]},{"content":"Alignment (C++ Declarations)","pos":[548,576]},{"content":"One of the low-level features of C++ is the ability to specify the precise alignment of objects in memory to take maximum advantage of a specific hardware architecture.","pos":[577,745]},{"content":"By default, the compiler aligns class and struct members on their size value: bool and char are aligned one one byte boundaries, short on two byte, int on four bytes, long long, double and long double on eight bytes.","pos":[746,962]},{"content":"In most scenarios you never have to be concerned with alignment because the default alignment is already optimal.","pos":[963,1076]},{"content":"In some cases however, you can achieve significant performance improvements, or memory savings, by specifying a custom alignment for your data structures.","pos":[1077,1231]},{"content":"Prior to Visual Studio 2015 you could use the Microsoft-specific keywords __alignof and declspec(alignas) to specify an alignment greater than the default.","pos":[1232,1387]},{"content":"Starting in Visual Studio 2015 you should use the C++11 standard keywords <bpt id=\"p1\">[</bpt>alignof and alignas<ept id=\"p1\">](../cpp/alignof-and-alignas-cpp.md)</ept> for maximum code portability.","pos":[1388,1548],"source":" Starting in Visual Studio 2015 you should use the C++11 standard keywords [alignof and alignas](../cpp/alignof-and-alignas-cpp.md) for maximum code portability."},{"content":"The new keywords behave in the same way under the hood as the Microsoft-specific extensions, and the documentation for those extensions also applies to the new keywords.","pos":[1549,1718]},{"content":"See <bpt id=\"p1\">[</bpt>__alignof Operator<ept id=\"p1\">](../cpp/alignof-operator.md)</ept> and <bpt id=\"p2\">[</bpt>align<ept id=\"p2\">](../cpp/align-cpp.md)</ept> for more information.","pos":[1719,1826],"source":" See [__alignof Operator](../cpp/alignof-operator.md) and [align](../cpp/align-cpp.md) for more information."},{"content":"The C++ standard does not specify packing behavior for aligning on boundaries smaller than the compiler default for the target platform, so you still need to use the Microsoft #pragma <bpt id=\"p1\">[</bpt>pack<ept id=\"p1\">](../preprocessor/pack.md)</ept> in that case.","pos":[1827,2056],"source":" The C++ standard does not specify packing behavior for aligning on boundaries smaller than the compiler default for the target platform, so you still need to use the Microsoft #pragma [pack](../preprocessor/pack.md) in that case."},{"pos":[2063,2392],"content":"The C++ standard library provides the <bpt id=\"p1\">[</bpt>aligned_storage Class<ept id=\"p1\">](../standard-library/aligned-storage-class.md)</ept> for allocating memory for data structures with custom alignments, and the <bpt id=\"p2\">[</bpt>aligned_union Class<ept id=\"p2\">](../standard-library/aligned-union-class.md)</ept> for specifying alignment for unions with non-trivial constructors or destructors.","source":"The C++ standard library provides the [aligned_storage Class](../standard-library/aligned-storage-class.md) for allocating memory for data structures with custom alignments, and the [aligned_union Class](../standard-library/aligned-union-class.md) for specifying alignment for unions with non-trivial constructors or destructors."},{"content":"About Alignment","pos":[2401,2416]},{"content":"Alignment is a property of a memory address, expressed as the numeric address modulo a power of 2.","pos":[2420,2518]},{"content":"For example, the address 0x0001103F modulo 4 is 3; that address is said to be aligned to 4n+3, where 4 indicates the chosen power of 2.","pos":[2519,2654]},{"content":"The alignment of an address depends on the chosen power of two.","pos":[2655,2718]},{"content":"The same address modulo 8 is 7.","pos":[2719,2750]},{"content":"An address is said to be aligned to X if its alignment is Xn+0.","pos":[2751,2814]},{"content":"CPUs execute instructions that operate on data stored in memory, and the data are identified by their addresses in memory.","pos":[2821,2943]},{"content":"In addition to its address, a single datum also has a size.","pos":[2944,3003]},{"content":"A datum is called naturally aligned if its address is aligned to its size, and misaligned otherwise.","pos":[3004,3104]},{"content":"For example, an 8-byte floating-point datum is naturally aligned if the address used to identify it is aligned to 8.","pos":[3105,3221]},{"content":"Compiler handling of data alignmentDevice compilers attempt to allocate data in a way that prevents data misalignment.","pos":[3228,3346]},{"content":"For simple data types, the compiler assigns addresses that are multiples of the size in bytes of the data type.","pos":[3353,3464]},{"content":"Thus, the compiler assigns addresses to variables of type long that are multiples of four, setting the bottom two bits of the address to zero.","pos":[3465,3607]},{"content":"In addition, the compiler pads structures in a way that naturally aligns each element of the structure.","pos":[3614,3717]},{"content":"Consider the structure struct x_ in the following code example:","pos":[3718,3781]},{"content":"The compiler pads this structure to enforce alignment naturally.","pos":[3946,4010]},{"content":"The following code example shows how the compiler places the padded structure in memory:Copy","pos":[4017,4109]},{"content":"Both declarations return sizeof(struct x_) as 12 bytes.","pos":[4460,4515]},{"content":"The second declaration includes two padding elements:","pos":[4525,4578]},{"content":"char _pad0[3] to align the int b member on a four-byte boundary","pos":[4588,4651]},{"content":"char _pad1[1] to align the array elements of the structure struct _x bar[3];","pos":[4661,4737]},{"content":"The padding aligns the elements of bar[3] in a way that allows natural access.","pos":[4747,4825]},{"content":"The following code example shows the bar[3] array layout:","pos":[4832,4889]},{"content":"See Also","pos":[5401,5409]},{"content":"Data Structure Alignment","pos":[5414,5438]}],"content":"---\ntitle: \"Alignment (C++ Declarations) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nms.assetid: a986d510-ccb8-41f8-b905-433df9183485\ncaps.latest.revision: 4\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Alignment (C++ Declarations)\nOne of the low-level features of C++ is the ability to specify the precise alignment of objects in memory to take maximum advantage of a specific hardware architecture. By default, the compiler aligns class and struct members on their size value: bool and char are aligned one one byte boundaries, short on two byte, int on four bytes, long long, double and long double on eight bytes. In most scenarios you never have to be concerned with alignment because the default alignment is already optimal. In some cases however, you can achieve significant performance improvements, or memory savings, by specifying a custom alignment for your data structures. Prior to Visual Studio 2015 you could use the Microsoft-specific keywords __alignof and declspec(alignas) to specify an alignment greater than the default. Starting in Visual Studio 2015 you should use the C++11 standard keywords [alignof and alignas](../cpp/alignof-and-alignas-cpp.md) for maximum code portability. The new keywords behave in the same way under the hood as the Microsoft-specific extensions, and the documentation for those extensions also applies to the new keywords. See [__alignof Operator](../cpp/alignof-operator.md) and [align](../cpp/align-cpp.md) for more information. The C++ standard does not specify packing behavior for aligning on boundaries smaller than the compiler default for the target platform, so you still need to use the Microsoft #pragma [pack](../preprocessor/pack.md) in that case.  \n  \n The C++ standard library provides the [aligned_storage Class](../standard-library/aligned-storage-class.md) for allocating memory for data structures with custom alignments, and the [aligned_union Class](../standard-library/aligned-union-class.md) for specifying alignment for unions with non-trivial constructors or destructors.  \n  \n## About Alignment  \n Alignment is a property of a memory address, expressed as the numeric address modulo a power of 2. For example, the address 0x0001103F modulo 4 is 3; that address is said to be aligned to 4n+3, where 4 indicates the chosen power of 2. The alignment of an address depends on the chosen power of two. The same address modulo 8 is 7. An address is said to be aligned to X if its alignment is Xn+0.  \n  \n CPUs execute instructions that operate on data stored in memory, and the data are identified by their addresses in memory. In addition to its address, a single datum also has a size. A datum is called naturally aligned if its address is aligned to its size, and misaligned otherwise. For example, an 8-byte floating-point datum is naturally aligned if the address used to identify it is aligned to 8.  \n  \n Compiler handling of data alignmentDevice compilers attempt to allocate data in a way that prevents data misalignment.  \n  \n For simple data types, the compiler assigns addresses that are multiples of the size in bytes of the data type. Thus, the compiler assigns addresses to variables of type long that are multiples of four, setting the bottom two bits of the address to zero.  \n  \n In addition, the compiler pads structures in a way that naturally aligns each element of the structure. Consider the structure struct x_ in the following code example:  \n  \n```  \nstruct x_  \n{  \n   char a;     // 1 byte  \n   int b;      // 4 bytes  \n   short c;    // 2 bytes  \n   char d;     // 1 byte  \n} MyStruct;  \n  \n```  \n  \n The compiler pads this structure to enforce alignment naturally.  \n  \n The following code example shows how the compiler places the padded structure in memory:Copy  \n  \n```  \n// Shows the actual memory layout  \nstruct x_  \n{  \n   char a;            // 1 byte  \n   char _pad0[3];     // padding to put 'b' on 4-byte boundary  \n   int b;            // 4 bytes  \n   short c;          // 2 bytes  \n   char d;           // 1 byte  \n   char _pad1[1];    // padding to make sizeof(x_) multiple of 4  \n}  \n  \n```  \n  \n1.  Both declarations return sizeof(struct x_) as 12 bytes.  \n  \n2.  The second declaration includes two padding elements:  \n  \n3.  char _pad0[3] to align the int b member on a four-byte boundary  \n  \n4.  char _pad1[1] to align the array elements of the structure struct _x bar[3];  \n  \n5.  The padding aligns the elements of bar[3] in a way that allows natural access.  \n  \n The following code example shows the bar[3] array layout:  \n  \n```  \nadr offset   element  \n------   -------  \n0x0000   char a;         // bar[0]  \n0x0001   char pad0[3];  \n0x0004   int b;  \n0x0008   short c;  \n0x000a   char d;  \n0x000b   char _pad1[1];  \n  \n0x000c   char a;         // bar[1]  \n0x000d   char _pad0[3];  \n0x0010   int b;  \n0x0014   short c;  \n0x0016   char d;  \n0x0017   char _pad1[1];  \n  \n0x0018   char a;         // bar[2]  \n0x0019   char _pad0[3];  \n0x001c   int b;  \n0x0020   short c;  \n0x0022   char d;  \n0x0023   char _pad1[1];  \n  \n```  \n  \n## See Also  \n [Data Structure Alignment](http://en.wikipedia.org/wiki/Data_structure_alignment)"}