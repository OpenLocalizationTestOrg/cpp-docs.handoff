{"nodes":[{"pos":[12,53],"content":"Overview of Declarations | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Overview of Declarations | Microsoft Docs","pos":[0,41]}]},{"content":"Overview of Declarations","pos":[625,649]},{"content":"A \"declaration\" specifies the interpretation and attributes of a set of identifiers.","pos":[650,734]},{"content":"A declaration that also causes storage to be reserved for the object or function named by the identifier is called a \"definition.\"","pos":[735,865]},{"content":"C declarations for variables, functions, and types have this syntax:","pos":[866,934]},{"content":"Syntax","pos":[943,949]},{"content":":","pos":[966,967]},{"content":"<bpt id=\"p1\"> *</bpt>declaration-specifiers<ept id=\"p1\">*</ept> <bpt id=\"p2\">*</bpt>attribute-seq<ept id=\"p2\">*</ept>opt<bpt id=\"p3\">*</bpt>init-declarator-list<ept id=\"p3\">*</ept>opt<bpt id=\"p4\">**</bpt>;<ept id=\"p4\">**</ept>","pos":[970,1044],"source":" *declaration-specifiers* *attribute-seq*opt*init-declarator-list*opt**;**"},{"pos":[1055,1098],"content":"<bpt id=\"p1\">*</bpt>attribute-seq<ept id=\"p1\">*</ept>opt is Microsoft specific */","source":"*attribute-seq*opt is Microsoft specific */"},{"content":"<bpt id=\"p1\">*</bpt>declaration-specifiers<ept id=\"p1\">*</ept>:","pos":[1105,1130],"source":"*declaration-specifiers*:"},{"content":"<bpt id=\"p1\"> *</bpt>storage-class-specifier declaration-specifiers<ept id=\"p1\">*</ept>opt","pos":[1133,1185],"source":" *storage-class-specifier declaration-specifiers*opt"},{"pos":[1192,1234],"content":"<bpt id=\"p1\">*</bpt>type-specifier declaration-specifiers<ept id=\"p1\">*</ept>opt","source":"*type-specifier declaration-specifiers*opt"},{"pos":[1241,1283],"content":"<bpt id=\"p1\">*</bpt>type-qualifier declaration-specifiers<ept id=\"p1\">*</ept>opt","source":"*type-qualifier declaration-specifiers*opt"},{"content":"<bpt id=\"p1\">*</bpt>init-declarator-list<ept id=\"p1\">*</ept>:","pos":[1290,1313],"source":"*init-declarator-list*:"},{"content":"init-declarator","pos":[1318,1333]},{"pos":[1341,1383],"content":"<bpt id=\"p1\">*</bpt>init-declarator-list<ept id=\"p1\">*</ept> , <bpt id=\"p2\">*</bpt>init-declarator<ept id=\"p2\">*</ept>","source":"*init-declarator-list* , *init-declarator*"},{"content":"<bpt id=\"p1\">*</bpt>init-declarator<ept id=\"p1\">*</ept>:","pos":[1390,1408],"source":"*init-declarator*:"},{"content":"declarator","pos":[1413,1423]},{"pos":[1431,1465],"content":"<bpt id=\"p1\">*</bpt>declarator<ept id=\"p1\">*</ept>  <bpt id=\"p2\">**</bpt><ph id=\"ph1\">=</ph><ept id=\"p2\">**</ept>  <bpt id=\"p3\">*</bpt>initializer<ept id=\"p3\">*</ept>","source":"*declarator*  **=**  *initializer*"},{"pos":[1473,1639],"content":"[!NOTE]\n This syntax for `declaration` is not repeated in the following sections. Syntax in the following sections usually begins with the `declarator` nonterminal.","leadings":["","> "],"nodes":[{"content":" This syntax for `declaration` is not repeated in the following sections. Syntax in the following sections usually begins with the `declarator` nonterminal.","pos":[8,164],"nodes":[{"content":"This syntax for <ph id=\"ph1\">`declaration`</ph> is not repeated in the following sections.","pos":[1,73],"source":" This syntax for `declaration` is not repeated in the following sections."},{"content":"Syntax in the following sections usually begins with the <ph id=\"ph1\">`declarator`</ph> nonterminal.","pos":[74,156],"source":" Syntax in the following sections usually begins with the `declarator` nonterminal."}]}]},{"content":"The declarations in the <bpt id=\"p1\">*</bpt>init-declarator-list<ept id=\"p1\">*</ept> contain the identifiers being named; <bpt id=\"p2\">*</bpt>init<ept id=\"p2\">*</ept> is an abbreviation for initializer.","pos":[1646,1772],"source":"The declarations in the *init-declarator-list* contain the identifiers being named; *init* is an abbreviation for initializer."},{"content":"The <bpt id=\"p1\">*</bpt>init-declarator-list<ept id=\"p1\">*</ept> is a comma-separated sequence of declarators, each of which can have additional type information, or an initializer, or both.","pos":[1773,1925],"source":" The *init-declarator-list* is a comma-separated sequence of declarators, each of which can have additional type information, or an initializer, or both."},{"content":"The <ph id=\"ph1\">`declarator`</ph> contains the identifiers, if any, being declared.","pos":[1926,1992],"source":" The `declarator` contains the identifiers, if any, being declared."},{"content":"The <bpt id=\"p1\">*</bpt>declaration-specifiers<ept id=\"p1\">*</ept> nonterminal consists of a sequence of type and storage-class specifiers that indicate the linkage, storage duration, and at least part of the type of the entities that the declarators denote.","pos":[1993,2213],"source":" The *declaration-specifiers* nonterminal consists of a sequence of type and storage-class specifiers that indicate the linkage, storage duration, and at least part of the type of the entities that the declarators denote."},{"content":"Therefore, declarations are made up of some combination of storage-class specifiers, type specifiers, type qualifiers, declarators, and initializers.","pos":[2214,2363]},{"content":"Declarations can contain one or more of the optional attributes listed in <bpt id=\"p1\">*</bpt>attribute-seq<ept id=\"p1\">*</ept>; <bpt id=\"p2\">*</bpt>seq<ept id=\"p2\">*</ept> is an abbreviation for sequence.","pos":[2370,2499],"source":"Declarations can contain one or more of the optional attributes listed in *attribute-seq*; *seq* is an abbreviation for sequence."},{"content":"These Microsoft-specific attributes perform a variety of functions, which are discussed in detail throughout this book.","pos":[2500,2619]},{"content":"In the general form of a variable declaration, <bpt id=\"p1\">*</bpt>type-specifier<ept id=\"p1\">*</ept> gives the data type of the variable.","pos":[2626,2726],"source":"In the general form of a variable declaration, *type-specifier* gives the data type of the variable."},{"content":"The <bpt id=\"p1\">*</bpt>type-specifier<ept id=\"p1\">*</ept> can be a compound, as when the type is modified by <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> or <ph id=\"ph1\">`volatile`</ph>.","pos":[2727,2823],"source":" The *type-specifier* can be a compound, as when the type is modified by **const** or `volatile`."},{"content":"The <ph id=\"ph1\">`declarator`</ph> gives the name of the variable, possibly modified to declare an array or a pointer type.","pos":[2824,2929],"source":" The `declarator` gives the name of the variable, possibly modified to declare an array or a pointer type."},{"content":"For example,","pos":[2930,2942]},{"content":"declares a variable named <ph id=\"ph1\">`fp`</ph> as a pointer to a nonmodifiable (<bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept>) <ph id=\"ph2\">`int`</ph> value.","pos":[2981,3068],"source":"declares a variable named `fp` as a pointer to a nonmodifiable (**const**) `int` value."},{"content":"You can define more than one variable in a declaration by using multiple declarators, separated by commas.","pos":[3069,3175]},{"content":"A declaration must have at least one declarator, or its type specifier must declare a structure tag, union tag, or members of an enumeration.","pos":[3182,3323]},{"content":"Declarators provide any remaining information about an identifier.","pos":[3324,3390]},{"content":"A declarator is an identifier that can be modified with brackets (<bpt id=\"p1\">**</bpt>[ ]<ept id=\"p1\">**</ept>), asterisks (<bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept>), or parentheses ( <bpt id=\"p3\">**</bpt>( )<ept id=\"p3\">**</ept> ) to declare an array, pointer, or function type, respectively.","pos":[3391,3575],"source":" A declarator is an identifier that can be modified with brackets (**[ ]**), asterisks (**\\***), or parentheses ( **( )** ) to declare an array, pointer, or function type, respectively."},{"content":"When you declare simple variables (such as character, integer, and floating-point items), or structures and unions of simple variables, the <ph id=\"ph1\">`declarator`</ph> is just an identifier.","pos":[3576,3751],"source":" When you declare simple variables (such as character, integer, and floating-point items), or structures and unions of simple variables, the `declarator` is just an identifier."},{"content":"For more information on declarators, see <bpt id=\"p1\">[</bpt>Declarators and Variable Declarations<ept id=\"p1\">](../c-language/declarators-and-variable-declarations.md)</ept>.","pos":[3752,3889],"source":" For more information on declarators, see [Declarators and Variable Declarations](../c-language/declarators-and-variable-declarations.md)."},{"content":"All definitions are implicitly declarations, but not all declarations are definitions.","pos":[3896,3982]},{"content":"For example, variable declarations that begin with the <ph id=\"ph1\">`extern`</ph> storage-class specifier are \"referencing,\" rather than \"defining\" declarations.","pos":[3983,4126],"source":" For example, variable declarations that begin with the `extern` storage-class specifier are \"referencing,\" rather than \"defining\" declarations."},{"content":"If an external variable is to be referred to before it is defined, or if it is defined in another source file from the one where it is used, an <ph id=\"ph1\">`extern`</ph> declaration is necessary.","pos":[4127,4305],"source":" If an external variable is to be referred to before it is defined, or if it is defined in another source file from the one where it is used, an `extern` declaration is necessary."},{"content":"Storage is not allocated by \"referencing\" declarations, nor can variables be initialized in declarations.","pos":[4306,4411]},{"content":"A storage class or a type (or both) is required in variable declarations.","pos":[4418,4491]},{"content":"Except for <ph id=\"ph1\">`__declspec`</ph>, only one storage-class specifier is allowed in a declaration and not all storage-class specifiers are permitted in every context.","pos":[4492,4646],"source":" Except for `__declspec`, only one storage-class specifier is allowed in a declaration and not all storage-class specifiers are permitted in every context."},{"content":"The <ph id=\"ph1\">`__declspec`</ph> storage class is allowed with other storage-class specifiers, and it is allowed more than once.","pos":[4647,4759],"source":" The `__declspec` storage class is allowed with other storage-class specifiers, and it is allowed more than once."},{"content":"The storage-class specifier of a declaration affects how the declared item is stored and initialized, and which parts of a program can reference the item.","pos":[4760,4914]},{"content":"The <bpt id=\"p1\">*</bpt>storage-class-specifier<ept id=\"p1\">*</ept> terminals defined in C include <bpt id=\"p2\">**</bpt>auto<ept id=\"p2\">**</ept>, <ph id=\"ph1\">`extern`</ph>, <bpt id=\"p3\">**</bpt>register<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>static<ept id=\"p4\">**</ept>, and <ph id=\"ph2\">`typedef`</ph>.","pos":[4921,5042],"source":"The *storage-class-specifier* terminals defined in C include **auto**, `extern`, **register**, **static**, and `typedef`."},{"content":"In addition, Microsoft C includes the <bpt id=\"p1\">*</bpt>storage-class-specifier<ept id=\"p1\">*</ept> terminal <ph id=\"ph1\">`__declspec`</ph>.","pos":[5043,5129],"source":" In addition, Microsoft C includes the *storage-class-specifier* terminal `__declspec`."},{"content":"All <bpt id=\"p1\">*</bpt>storage-class-specifier<ept id=\"p1\">*</ept> terminals except <ph id=\"ph1\">`typedef`</ph> and <ph id=\"ph2\">`__declspec`</ph> are discussed in <bpt id=\"p2\">[</bpt>Storage Classes<ept id=\"p2\">](../c-language/c-storage-classes.md)</ept>.","pos":[5130,5275],"source":" All *storage-class-specifier* terminals except `typedef` and `__declspec` are discussed in [Storage Classes](../c-language/c-storage-classes.md)."},{"content":"See <bpt id=\"p1\">[</bpt>Typedef Declarations<ept id=\"p1\">](../c-language/typedef-declarations.md)</ept> for information about <ph id=\"ph1\">`typedef`</ph>.","pos":[5276,5374],"source":" See [Typedef Declarations](../c-language/typedef-declarations.md) for information about `typedef`."},{"content":"See <bpt id=\"p1\">[</bpt>Extended Storage-Class Attributes<ept id=\"p1\">](../c-language/c-extended-storage-class-attributes.md)</ept> for information about <ph id=\"ph1\">`__declspec`</ph>.","pos":[5375,5504],"source":" See [Extended Storage-Class Attributes](../c-language/c-extended-storage-class-attributes.md) for information about `__declspec`."},{"content":"The location of the declaration within the source program and the presence or absence of other declarations of the variable are important factors in determining the lifetime of variables.","pos":[5511,5698]},{"content":"There can be multiple redeclarations but only one definition.","pos":[5699,5760]},{"content":"However, a definition can appear in more than one translation unit.","pos":[5761,5828]},{"content":"For objects with internal linkage, this rule applies separately to each translation unit, because internally linked objects are unique to a translation unit.","pos":[5829,5986]},{"content":"For objects with external linkage, this rule applies to the entire program.","pos":[5987,6062]},{"content":"See <bpt id=\"p1\">[</bpt>Lifetime, Scope, Visibility, and Linkage<ept id=\"p1\">](../c-language/lifetime-scope-visibility-and-linkage.md)</ept> for more information about visibility.","pos":[6063,6204],"source":" See [Lifetime, Scope, Visibility, and Linkage](../c-language/lifetime-scope-visibility-and-linkage.md) for more information about visibility."},{"content":"Type specifiers provide some information about the data types of identifiers.","pos":[6211,6288]},{"content":"The default type specifier is <ph id=\"ph1\">`int`</ph>.","pos":[6289,6325],"source":" The default type specifier is `int`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Type Specifiers<ept id=\"p1\">](../c-language/c-type-specifiers.md)</ept>.","pos":[6326,6406],"source":" For more information, see [Type Specifiers](../c-language/c-type-specifiers.md)."},{"content":"Type specifiers can also define type tags, structure and union component names, and enumeration constants.","pos":[6407,6513]},{"content":"For more information see <bpt id=\"p1\">[</bpt>Enumeration Declarations<ept id=\"p1\">](../c-language/c-enumeration-declarations.md)</ept>, <bpt id=\"p2\">[</bpt>Structure Declarations<ept id=\"p2\">](../c-language/structure-declarations.md)</ept>, and <bpt id=\"p3\">[</bpt>Union Declarations<ept id=\"p3\">](../c-language/union-declarations.md)</ept>.","pos":[6514,6741],"source":" For more information see [Enumeration Declarations](../c-language/c-enumeration-declarations.md), [Structure Declarations](../c-language/structure-declarations.md), and [Union Declarations](../c-language/union-declarations.md)."},{"content":"There are two <bpt id=\"p1\">*</bpt>type-qualifier<ept id=\"p1\">*</ept> terminals: <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> and <ph id=\"ph1\">`volatile`</ph>.","pos":[6748,6815],"source":"There are two *type-qualifier* terminals: **const** and `volatile`."},{"content":"These qualifiers specify additional properties of types that are relevant only when accessing objects of that type through l-values.","pos":[6816,6948]},{"content":"For more information on <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`volatile`</ph>, see <bpt id=\"p2\">[</bpt>Type Qualifiers<ept id=\"p2\">](../c-language/type-qualifiers.md)</ept>.","pos":[6949,7055],"source":" For more information on **const** and `volatile`, see [Type Qualifiers](../c-language/type-qualifiers.md)."},{"content":"For a definition of l-values, see <bpt id=\"p1\">[</bpt>L-Value and R-Value Expressions<ept id=\"p1\">](../c-language/l-value-and-r-value-expressions.md)</ept>.","pos":[7056,7174],"source":" For a definition of l-values, see [L-Value and R-Value Expressions](../c-language/l-value-and-r-value-expressions.md)."},{"content":"See Also","pos":[7183,7191]},{"content":"C Language Syntax Summary","pos":[7196,7221]},{"content":"Declarations and Types","pos":[7272,7294]},{"content":"Summary of Declarations","pos":[7342,7365]}],"content":"---\ntitle: \"Overview of Declarations | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"declarations, about declarations\"\n  - \"type qualifiers\"\nms.assetid: fcd2364c-c2a5-4fbf-9027-19dac4144cb5\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Overview of Declarations\nA \"declaration\" specifies the interpretation and attributes of a set of identifiers. A declaration that also causes storage to be reserved for the object or function named by the identifier is called a \"definition.\" C declarations for variables, functions, and types have this syntax:  \n  \n## Syntax  \n `declaration`:  \n *declaration-specifiers* *attribute-seq*opt*init-declarator-list*opt**;**  \n  \n /\\* *attribute-seq*opt is Microsoft specific */  \n  \n *declaration-specifiers*:  \n *storage-class-specifier declaration-specifiers*opt  \n  \n *type-specifier declaration-specifiers*opt  \n  \n *type-qualifier declaration-specifiers*opt  \n  \n *init-declarator-list*:  \n *init-declarator*  \n  \n *init-declarator-list* , *init-declarator*  \n  \n *init-declarator*:  \n *declarator*  \n  \n *declarator*  **=**  *initializer*  \n  \n> [!NOTE]\n>  This syntax for `declaration` is not repeated in the following sections. Syntax in the following sections usually begins with the `declarator` nonterminal.  \n  \n The declarations in the *init-declarator-list* contain the identifiers being named; *init* is an abbreviation for initializer. The *init-declarator-list* is a comma-separated sequence of declarators, each of which can have additional type information, or an initializer, or both. The `declarator` contains the identifiers, if any, being declared. The *declaration-specifiers* nonterminal consists of a sequence of type and storage-class specifiers that indicate the linkage, storage duration, and at least part of the type of the entities that the declarators denote. Therefore, declarations are made up of some combination of storage-class specifiers, type specifiers, type qualifiers, declarators, and initializers.  \n  \n Declarations can contain one or more of the optional attributes listed in *attribute-seq*; *seq* is an abbreviation for sequence. These Microsoft-specific attributes perform a variety of functions, which are discussed in detail throughout this book.  \n  \n In the general form of a variable declaration, *type-specifier* gives the data type of the variable. The *type-specifier* can be a compound, as when the type is modified by **const** or `volatile`. The `declarator` gives the name of the variable, possibly modified to declare an array or a pointer type. For example,  \n  \n```  \nint const *fp;  \n```  \n  \n declares a variable named `fp` as a pointer to a nonmodifiable (**const**) `int` value. You can define more than one variable in a declaration by using multiple declarators, separated by commas.  \n  \n A declaration must have at least one declarator, or its type specifier must declare a structure tag, union tag, or members of an enumeration. Declarators provide any remaining information about an identifier. A declarator is an identifier that can be modified with brackets (**[ ]**), asterisks (**\\***), or parentheses ( **( )** ) to declare an array, pointer, or function type, respectively. When you declare simple variables (such as character, integer, and floating-point items), or structures and unions of simple variables, the `declarator` is just an identifier. For more information on declarators, see [Declarators and Variable Declarations](../c-language/declarators-and-variable-declarations.md).  \n  \n All definitions are implicitly declarations, but not all declarations are definitions. For example, variable declarations that begin with the `extern` storage-class specifier are \"referencing,\" rather than \"defining\" declarations. If an external variable is to be referred to before it is defined, or if it is defined in another source file from the one where it is used, an `extern` declaration is necessary. Storage is not allocated by \"referencing\" declarations, nor can variables be initialized in declarations.  \n  \n A storage class or a type (or both) is required in variable declarations. Except for `__declspec`, only one storage-class specifier is allowed in a declaration and not all storage-class specifiers are permitted in every context. The `__declspec` storage class is allowed with other storage-class specifiers, and it is allowed more than once. The storage-class specifier of a declaration affects how the declared item is stored and initialized, and which parts of a program can reference the item.  \n  \n The *storage-class-specifier* terminals defined in C include **auto**, `extern`, **register**, **static**, and `typedef`. In addition, Microsoft C includes the *storage-class-specifier* terminal `__declspec`. All *storage-class-specifier* terminals except `typedef` and `__declspec` are discussed in [Storage Classes](../c-language/c-storage-classes.md). See [Typedef Declarations](../c-language/typedef-declarations.md) for information about `typedef`. See [Extended Storage-Class Attributes](../c-language/c-extended-storage-class-attributes.md) for information about `__declspec`.  \n  \n The location of the declaration within the source program and the presence or absence of other declarations of the variable are important factors in determining the lifetime of variables. There can be multiple redeclarations but only one definition. However, a definition can appear in more than one translation unit. For objects with internal linkage, this rule applies separately to each translation unit, because internally linked objects are unique to a translation unit. For objects with external linkage, this rule applies to the entire program. See [Lifetime, Scope, Visibility, and Linkage](../c-language/lifetime-scope-visibility-and-linkage.md) for more information about visibility.  \n  \n Type specifiers provide some information about the data types of identifiers. The default type specifier is `int`. For more information, see [Type Specifiers](../c-language/c-type-specifiers.md). Type specifiers can also define type tags, structure and union component names, and enumeration constants. For more information see [Enumeration Declarations](../c-language/c-enumeration-declarations.md), [Structure Declarations](../c-language/structure-declarations.md), and [Union Declarations](../c-language/union-declarations.md).  \n  \n There are two *type-qualifier* terminals: **const** and `volatile`. These qualifiers specify additional properties of types that are relevant only when accessing objects of that type through l-values. For more information on **const** and `volatile`, see [Type Qualifiers](../c-language/type-qualifiers.md). For a definition of l-values, see [L-Value and R-Value Expressions](../c-language/l-value-and-r-value-expressions.md).  \n  \n## See Also  \n [C Language Syntax Summary](../c-language/c-language-syntax-summary.md)   \n [Declarations and Types](../c-language/declarations-and-types.md)   \n [Summary of Declarations](../c-language/summary-of-declarations.md)"}