{"nodes":[{"pos":[12,56],"content":"Member Access Control (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Member Access Control (C++) | Microsoft Docs","pos":[0,44]}]},{"content":"Member Access Control (C++)","pos":[656,683]},{"content":"Access controls enable you to separate the <bpt id=\"p1\">[</bpt>public<ept id=\"p1\">](../cpp/public-cpp.md)</ept> interface of a class from the <bpt id=\"p2\">[</bpt>private<ept id=\"p2\">](../cpp/private-cpp.md)</ept> implementation details and the <bpt id=\"p3\">[</bpt>protected<ept id=\"p3\">](../cpp/protected-cpp.md)</ept> members that are only for use by derived classes.","pos":[684,938],"source":"Access controls enable you to separate the [public](../cpp/public-cpp.md) interface of a class from the [private](../cpp/private-cpp.md) implementation details and the [protected](../cpp/protected-cpp.md) members that are only for use by derived classes."},{"content":"The access specifier applies to all members declared after it until the next access specifier is encountered.","pos":[939,1048]},{"content":"The default access is <ph id=\"ph1\">`private`</ph> in a class, and <ph id=\"ph2\">`public`</ph> in a struct or union.","pos":[1531,1609],"source":"The default access is `private` in a class, and `public` in a struct or union."},{"content":"Access specifiers in a class can be used any number of times in any order.","pos":[1610,1684]},{"content":"The allocation of storage for objects of class types is implementation dependent, but members are guaranteed to be assigned successively higher memory addresses between access specifiers.","pos":[1685,1872]},{"content":"Member-Access Control","pos":[1882,1903]},{"content":"Type of Access","pos":[1910,1924]},{"content":"Meaning","pos":[1925,1932]},{"content":"private","pos":[1977,1984]},{"pos":[2009,2130],"content":"Class members declared as <ph id=\"ph1\">`private`</ph> can be used only by member functions and friends (classes or functions) of the class.","source":"Class members declared as `private` can be used only by member functions and friends (classes or functions) of the class."},{"content":"protected","pos":[2136,2145]},{"content":"Class members declared as <ph id=\"ph1\">`protected`</ph> can be used by member functions and friends (classes or functions) of the class.","pos":[2172,2290],"source":"Class members declared as `protected` can be used by member functions and friends (classes or functions) of the class."},{"content":"Additionally, they can be used by classes derived from the class.","pos":[2291,2356]},{"content":"public","pos":[2362,2368]},{"pos":[2392,2457],"content":"Class members declared as <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> can be used by any function.","source":"Class members declared as **public** can be used by any function."},{"content":"Access control helps prevent you from using objects in ways they were not intended to be used.","pos":[2465,2559]},{"content":"This protection is lost when explicit type conversions (casts) are performed.","pos":[2560,2637]},{"pos":[2645,2770],"content":"[!NOTE]\n Access control is equally applicable to all names: member functions, member data, nested classes, and enumerators.","leadings":["","> "],"nodes":[{"content":"Access control is equally applicable to all names: member functions, member data, nested classes, and enumerators.","pos":[9,123]}]},{"content":"Access Control in Derived Classes","pos":[2779,2812]},{"content":"Two factors control which members of a base class are accessible in a derived class; these same factors control access to the inherited members in the derived class:","pos":[2816,2981]},{"pos":[2991,3246],"content":"Whether the derived class declares the base class using the <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> access specifier in the <bpt id=\"p2\">*</bpt>class-head<ept id=\"p2\">*</ept> (<bpt id=\"p3\">*</bpt>class-head<ept id=\"p3\">*</ept> is described in the Grammar section in <bpt id=\"p4\">[</bpt>Defining Class Types<ept id=\"p4\">](http://msdn.microsoft.com/en-us/e8c65425-0f3a-4dca-afc2-418c3b1e57da)</ept>).","source":"Whether the derived class declares the base class using the **public** access specifier in the *class-head* (*class-head* is described in the Grammar section in [Defining Class Types](http://msdn.microsoft.com/en-us/e8c65425-0f3a-4dca-afc2-418c3b1e57da))."},{"content":"What the access to the member is in the base class.","pos":[3256,3307]},{"content":"The following table shows the interaction between these factors and how to determine base-class member access.","pos":[3314,3424]},{"content":"Member Access in Base Class","pos":[3434,3461]},{"content":"private","pos":[3468,3475]},{"content":"protected","pos":[3476,3485]},{"content":"Public","pos":[3486,3492]},{"content":"Always inaccessible regardless of derivation access","pos":[3544,3595]},{"content":"Private in derived class if you use private derivation","pos":[3596,3650]},{"content":"Private in derived class if you use private derivation","pos":[3651,3705]},{"content":"Protected in derived class if you use protected derivation","pos":[3711,3769]},{"content":"Protected in derived class if you use protected derivation","pos":[3770,3828]},{"content":"Protected in derived class if you use public derivation","pos":[3834,3889]},{"content":"Public in derived class if you use public derivation","pos":[3890,3942]},{"content":"The following example illustrates this:","pos":[3950,3989]},{"content":"In <ph id=\"ph1\">`DerivedClass1`</ph>, the member function <ph id=\"ph2\">`PublicFunc`</ph> is a public member and <ph id=\"ph3\">`ProtectedFunc`</ph> is a protected member because <ph id=\"ph4\">`BaseClass`</ph> is a public base class.","pos":[4465,4622],"source":"In `DerivedClass1`, the member function `PublicFunc` is a public member and `ProtectedFunc` is a protected member because `BaseClass` is a public base class."},{"content":"is private to <ph id=\"ph1\">`BaseClass`</ph>, and it is inaccessible to any derived classes.","pos":[4637,4710],"source":" is private to `BaseClass`, and it is inaccessible to any derived classes."},{"content":"In <ph id=\"ph1\">`DerivedClass2`</ph>, the functions <ph id=\"ph2\">`PublicFunc`</ph> and <ph id=\"ph3\">`ProtectedFunc`</ph> are considered private members because <ph id=\"ph4\">`BaseClass`</ph> is a private base class.","pos":[4717,4859],"source":"In `DerivedClass2`, the functions `PublicFunc` and `ProtectedFunc` are considered private members because `BaseClass` is a private base class."},{"content":"Again, <ph id=\"ph1\">`PrivateFunc`</ph> is private to <ph id=\"ph2\">`BaseClass`</ph>, and it is inaccessible to any derived classes.","pos":[4860,4954],"source":" Again, `PrivateFunc` is private to `BaseClass`, and it is inaccessible to any derived classes."},{"content":"You can declare a derived class without a base-class access specifier.","pos":[4961,5031]},{"content":"In such a case, the derivation is considered private if the derived class declaration uses the <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept> keyword.","pos":[5032,5145],"source":" In such a case, the derivation is considered private if the derived class declaration uses the **class** keyword."},{"content":"The derivation is considered public if the derived class declaration uses the <ph id=\"ph1\">`struct`</ph> keyword.","pos":[5146,5241],"source":" The derivation is considered public if the derived class declaration uses the `struct` keyword."},{"content":"For example, the following code:","pos":[5242,5274]},{"content":"is equivalent to:","pos":[5325,5342]},{"content":"Similarly, the following code:","pos":[5401,5431]},{"content":"is equivalent to:","pos":[5483,5500]},{"pos":[5559,5758],"content":"Note that members declared as having private access are not accessible to functions or derived classes unless those functions or classes are declared using the <ph id=\"ph1\">`friend`</ph> declaration in the base class.","source":"Note that members declared as having private access are not accessible to functions or derived classes unless those functions or classes are declared using the `friend` declaration in the base class."},{"pos":[5765,5807],"content":"A <bpt id=\"p1\">**</bpt>union<ept id=\"p1\">**</ept> type cannot have a base class.","source":"A **union** type cannot have a base class."},{"pos":[5815,5979],"content":"[!NOTE]\n When specifying a private base class, it is advisable to explicitly use the `private` keyword so users of the derived class understand the member access.","leadings":["","> "],"nodes":[{"content":"When specifying a private base class, it is advisable to explicitly use the <ph id=\"ph1\">`private`</ph> keyword so users of the derived class understand the member access.","pos":[9,162],"source":" When specifying a private base class, it is advisable to explicitly use the `private` keyword so users of the derived class understand the member access."}]},{"content":"Access control and static members","pos":[5988,6021]},{"content":"When you specify a base class as <ph id=\"ph1\">`private`</ph>, it affects only nonstatic members.","pos":[6025,6103],"source":"When you specify a base class as `private`, it affects only nonstatic members."},{"content":"Public static members are still accessible in the derived classes.","pos":[6104,6170]},{"content":"However, accessing members of the base class using pointers, references, or objects can require a conversion, at which time access control is again applied.","pos":[6171,6327]},{"content":"Consider the following example:","pos":[6328,6359]},{"content":"In the preceding code, access control prohibits conversion from a pointer to <ph id=\"ph1\">`Derived2`</ph> to a pointer to <ph id=\"ph2\">`Base`</ph>.","pos":[7216,7327],"source":"In the preceding code, access control prohibits conversion from a pointer to `Derived2` to a pointer to `Base`."},{"content":"The <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> pointer is implicitly of type <ph id=\"ph1\">`Derived2 *`</ph>.","pos":[7328,7384],"source":" The **this** pointer is implicitly of type `Derived2 *`."},{"content":"To select the <ph id=\"ph1\">`CountOf`</ph> function, <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> must be converted to type <ph id=\"ph2\">`Base *`</ph>.","pos":[7385,7463],"source":" To select the `CountOf` function, **this** must be converted to type `Base *`."},{"content":"Such a conversion is not permitted because <ph id=\"ph1\">`Base`</ph> is a private indirect base class to <ph id=\"ph2\">`Derived2`</ph>.","pos":[7464,7561],"source":" Such a conversion is not permitted because `Base` is a private indirect base class to `Derived2`."},{"content":"Conversion to a private base class type is acceptable only for pointers to immediate derived classes.","pos":[7562,7663]},{"content":"Therefore, pointers of type <ph id=\"ph1\">`Derived1 *`</ph> can be converted to type <ph id=\"ph2\">`Base *`</ph>.","pos":[7664,7739],"source":" Therefore, pointers of type `Derived1 *` can be converted to type `Base *`."},{"content":"Note that calling the <ph id=\"ph1\">`CountOf`</ph> function explicitly, without using a pointer, reference, or object to select it, implies no conversion.","pos":[7746,7881],"source":"Note that calling the `CountOf` function explicitly, without using a pointer, reference, or object to select it, implies no conversion."},{"content":"Therefore, the call is allowed.","pos":[7882,7913]},{"pos":[7920,8045],"content":"Members and friends of a derived class, <ph id=\"ph1\">`T`</ph>, can convert a pointer to <ph id=\"ph2\">`T`</ph> to a pointer to a private direct base class of <ph id=\"ph3\">`T`</ph>.","source":"Members and friends of a derived class, `T`, can convert a pointer to `T` to a pointer to a private direct base class of `T`."},{"content":"Access to virtual functions","pos":[8054,8081]},{"content":"The access control applied to <bpt id=\"p1\">[</bpt>virtual<ept id=\"p1\">](../cpp/virtual-cpp.md)</ept> functions is determined by the type used to make the function call.","pos":[8085,8215],"source":"The access control applied to [virtual](../cpp/virtual-cpp.md) functions is determined by the type used to make the function call."},{"content":"Overriding declarations of the function do not affect the access control for a given type.","pos":[8216,8306]},{"content":"For example:","pos":[8307,8319]},{"content":"In the preceding example, calling the virtual function <ph id=\"ph1\">`GetState`</ph> using a pointer to type <ph id=\"ph2\">`VFuncBase`</ph> calls <ph id=\"ph3\">`VFuncDerived::GetState`</ph>, and <ph id=\"ph4\">`GetState`</ph> is treated as public.","pos":[8964,9134],"source":"In the preceding example, calling the virtual function `GetState` using a pointer to type `VFuncBase` calls `VFuncDerived::GetState`, and `GetState` is treated as public."},{"content":"However, calling <ph id=\"ph1\">`GetState`</ph> using a pointer to type <ph id=\"ph2\">`VFuncDerived`</ph> is an access-control violation because <ph id=\"ph3\">`GetState`</ph> is declared private in class <ph id=\"ph4\">`VFuncDerived`</ph>.","pos":[9135,9296],"source":" However, calling `GetState` using a pointer to type `VFuncDerived` is an access-control violation because `GetState` is declared private in class `VFuncDerived`."},{"pos":[9304,9498],"content":"[!CAUTION]\n The virtual function `GetState` can be called using a pointer to the base class `VFuncBase`. This does not mean that the function called is the base-class version of that function.","leadings":["","> "],"nodes":[{"content":" The virtual function `GetState` can be called using a pointer to the base class `VFuncBase`. This does not mean that the function called is the base-class version of that function.","pos":[11,192],"nodes":[{"content":"The virtual function <ph id=\"ph1\">`GetState`</ph> can be called using a pointer to the base class <ph id=\"ph2\">`VFuncBase`</ph>.","pos":[1,93],"source":" The virtual function `GetState` can be called using a pointer to the base class `VFuncBase`."},{"content":"This does not mean that the function called is the base-class version of that function.","pos":[94,181]}]}]},{"content":"Access control with multiple inheritance","pos":[9507,9547]},{"content":"In multiple-inheritance lattices involving virtual base classes, a given name can be reached through more than one path.","pos":[9551,9671]},{"content":"Because different access control can be applied along these different paths, the compiler chooses the path that gives the most access.","pos":[9672,9806]},{"content":"See the following figure.","pos":[9807,9832]},{"content":"Access along paths of an inheritance graph","pos":[9841,9883]},{"content":"Access Along Paths of an Inheritance Graph","pos":[9923,9965]},{"content":"In the figure, a name declared in class <ph id=\"ph1\">`VBase`</ph> is always reached through class <ph id=\"ph2\">`RightPath`</ph>.","pos":[9972,10064],"source":"In the figure, a name declared in class `VBase` is always reached through class `RightPath`."},{"content":"The right path is more accessible because <ph id=\"ph1\">`RightPath`</ph> declares <ph id=\"ph2\">`VBase`</ph> as a public base class, whereas <ph id=\"ph3\">`LeftPath`</ph> declares <ph id=\"ph4\">`VBase`</ph> as private.","pos":[10065,10207],"source":" The right path is more accessible because `RightPath` declares `VBase` as a public base class, whereas `LeftPath` declares `VBase` as private."},{"content":"See Also","pos":[10216,10224]},{"content":"C++ Language Reference","pos":[10229,10251]}],"content":"---\ntitle: \"Member Access Control (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"access control [C++]\"\n  - \"member access [C++]\"\n  - \"member-access control [C++]\"\nms.assetid: 2d596bca-56ad-4277-94e1-ce3db45fa14a\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Member Access Control (C++)\nAccess controls enable you to separate the [public](../cpp/public-cpp.md) interface of a class from the [private](../cpp/private-cpp.md) implementation details and the [protected](../cpp/protected-cpp.md) members that are only for use by derived classes. The access specifier applies to all members declared after it until the next access specifier is encountered.  \n  \n```  \nclass Point  \n{  \npublic:                   \n    Point( int, int ) // Declare public constructor.;  \n    Point();// Declare public default constructor.  \n    int &x( int ); // Declare public accessor.  \n    int &y( int ); // Declare public accessor.  \n  \nprivate:                 // Declare private state variables.  \n    int _x;  \n    int _y;  \n  \nprotected:      // Declare protected function for derived classes only.  \n    Point ToWindowCoords();  \n};  \n  \n```  \n  \n The default access is `private` in a class, and `public` in a struct or union. Access specifiers in a class can be used any number of times in any order. The allocation of storage for objects of class types is implementation dependent, but members are guaranteed to be assigned successively higher memory addresses between access specifiers.  \n  \n### Member-Access Control  \n  \n|Type of Access|Meaning|  \n|--------------------|-------------|  \n|[private](../cpp/private-cpp.md)|Class members declared as `private` can be used only by member functions and friends (classes or functions) of the class.|  \n|[protected](../cpp/protected-cpp.md)|Class members declared as `protected` can be used by member functions and friends (classes or functions) of the class. Additionally, they can be used by classes derived from the class.|  \n|[public](../cpp/public-cpp.md)|Class members declared as **public** can be used by any function.|  \n  \n Access control helps prevent you from using objects in ways they were not intended to be used. This protection is lost when explicit type conversions (casts) are performed.  \n  \n> [!NOTE]\n>  Access control is equally applicable to all names: member functions, member data, nested classes, and enumerators.  \n  \n## Access Control in Derived Classes  \n Two factors control which members of a base class are accessible in a derived class; these same factors control access to the inherited members in the derived class:  \n  \n-   Whether the derived class declares the base class using the **public** access specifier in the *class-head* (*class-head* is described in the Grammar section in [Defining Class Types](http://msdn.microsoft.com/en-us/e8c65425-0f3a-4dca-afc2-418c3b1e57da)).  \n  \n-   What the access to the member is in the base class.  \n  \n The following table shows the interaction between these factors and how to determine base-class member access.  \n  \n### Member Access in Base Class  \n  \n|private|protected|Public|  \n|-------------|---------------|------------|  \n|Always inaccessible regardless of derivation access|Private in derived class if you use private derivation|Private in derived class if you use private derivation|  \n||Protected in derived class if you use protected derivation|Protected in derived class if you use protected derivation|  \n||Protected in derived class if you use public derivation|Public in derived class if you use public derivation|  \n  \n The following example illustrates this:  \n  \n```  \n// access_specifiers_for_base_classes.cpp  \nclass BaseClass  \n{  \npublic:  \n    int PublicFunc();    // Declare a public member.  \nprotected:  \n    int ProtectedFunc(); // Declare a protected member.  \nprivate:  \n    int PrivateFunc();   // Declare a private member.  \n};  \n  \n// Declare two classes derived from BaseClass.  \nclass DerivedClass1 : public BaseClass  \n{  \n};  \n  \nclass DerivedClass2 : private BaseClass  \n{  \n};  \n  \nint main()  \n{  \n}  \n```  \n  \n In `DerivedClass1`, the member function `PublicFunc` is a public member and `ProtectedFunc` is a protected member because `BaseClass` is a public base class. `PrivateFunc` is private to `BaseClass`, and it is inaccessible to any derived classes.  \n  \n In `DerivedClass2`, the functions `PublicFunc` and `ProtectedFunc` are considered private members because `BaseClass` is a private base class. Again, `PrivateFunc` is private to `BaseClass`, and it is inaccessible to any derived classes.  \n  \n You can declare a derived class without a base-class access specifier. In such a case, the derivation is considered private if the derived class declaration uses the **class** keyword. The derivation is considered public if the derived class declaration uses the `struct` keyword. For example, the following code:  \n  \n```  \nclass Derived : Base  \n...  \n```  \n  \n is equivalent to:  \n  \n```  \nclass Derived : private Base  \n...  \n```  \n  \n Similarly, the following code:  \n  \n```  \nstruct Derived : Base  \n...  \n```  \n  \n is equivalent to:  \n  \n```  \nstruct Derived : public Base  \n...  \n```  \n  \n Note that members declared as having private access are not accessible to functions or derived classes unless those functions or classes are declared using the `friend` declaration in the base class.  \n  \n A **union** type cannot have a base class.  \n  \n> [!NOTE]\n>  When specifying a private base class, it is advisable to explicitly use the `private` keyword so users of the derived class understand the member access.  \n  \n## Access control and static members  \n When you specify a base class as `private`, it affects only nonstatic members. Public static members are still accessible in the derived classes. However, accessing members of the base class using pointers, references, or objects can require a conversion, at which time access control is again applied. Consider the following example:  \n  \n```  \n// access_control.cpp  \nclass Base  \n{  \npublic:  \n    int Print();             // Nonstatic member.  \n    static int CountOf();    // Static member.  \n};  \n  \n// Derived1 declares Base as a private base class.  \nclass Derived1 : private Base  \n{  \n};  \n// Derived2 declares Derived1 as a public base class.  \nclass Derived2 : public Derived1  \n{  \n    int ShowCount();    // Nonstatic member.  \n};  \n// Define ShowCount function for Derived2.  \nint Derived2::ShowCount()  \n{  \n   // Call static member function CountOf explicitly.  \n    int cCount = Base::CountOf();     // OK.  \n  \n   // Call static member function CountOf using pointer.  \n    cCount = this->CountOf();  // C2247. Conversion of  \n                               //  Derived2 * to Base * not  \n                               //  permitted.  \n    return cCount;  \n}  \n```  \n  \n In the preceding code, access control prohibits conversion from a pointer to `Derived2` to a pointer to `Base`. The **this** pointer is implicitly of type `Derived2 *`. To select the `CountOf` function, **this** must be converted to type `Base *`. Such a conversion is not permitted because `Base` is a private indirect base class to `Derived2`. Conversion to a private base class type is acceptable only for pointers to immediate derived classes. Therefore, pointers of type `Derived1 *` can be converted to type `Base *`.  \n  \n Note that calling the `CountOf` function explicitly, without using a pointer, reference, or object to select it, implies no conversion. Therefore, the call is allowed.  \n  \n Members and friends of a derived class, `T`, can convert a pointer to `T` to a pointer to a private direct base class of `T`.  \n  \n## Access to virtual functions  \n The access control applied to [virtual](../cpp/virtual-cpp.md) functions is determined by the type used to make the function call. Overriding declarations of the function do not affect the access control for a given type. For example:  \n  \n```  \n// access_to_virtual_functions.cpp  \nclass VFuncBase  \n{  \npublic:  \n    virtual int GetState() { return _state; }  \nprotected:  \n    int _state;  \n};  \n  \nclass VFuncDerived : public VFuncBase  \n{  \nprivate:  \n    int GetState() { return _state; }  \n};  \n  \nint main()  \n{  \n   VFuncDerived vfd;             // Object of derived type.  \n   VFuncBase *pvfb = &vfd;       // Pointer to base type.  \n   VFuncDerived *pvfd = &vfd;    // Pointer to derived type.  \n   int State;  \n  \n   State = pvfb->GetState();     // GetState is public.  \n   State = pvfd->GetState();     // C2248 error expected; GetState is private;  \n}  \n```  \n  \n In the preceding example, calling the virtual function `GetState` using a pointer to type `VFuncBase` calls `VFuncDerived::GetState`, and `GetState` is treated as public. However, calling `GetState` using a pointer to type `VFuncDerived` is an access-control violation because `GetState` is declared private in class `VFuncDerived`.  \n  \n> [!CAUTION]\n>  The virtual function `GetState` can be called using a pointer to the base class `VFuncBase`. This does not mean that the function called is the base-class version of that function.  \n  \n## Access control with multiple inheritance  \n In multiple-inheritance lattices involving virtual base classes, a given name can be reached through more than one path. Because different access control can be applied along these different paths, the compiler chooses the path that gives the most access. See the following figure.  \n  \n ![Access along paths of an inheritance graph](../cpp/media/vc38v91.gif \"vc38V91\")  \nAccess Along Paths of an Inheritance Graph  \n  \n In the figure, a name declared in class `VBase` is always reached through class `RightPath`. The right path is more accessible because `RightPath` declares `VBase` as a public base class, whereas `LeftPath` declares `VBase` as private.  \n  \n## See Also  \n [C++ Language Reference](../cpp/cpp-language-reference.md)"}