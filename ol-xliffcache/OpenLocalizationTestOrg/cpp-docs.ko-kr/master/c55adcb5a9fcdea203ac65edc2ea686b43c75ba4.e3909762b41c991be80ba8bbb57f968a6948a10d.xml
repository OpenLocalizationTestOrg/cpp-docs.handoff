{"nodes":[{"pos":[12,36],"content":"_alloca | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_alloca | Microsoft Docs","pos":[0,24]}]},{"pos":[933,940],"content":"_alloca","linkify":"_alloca","nodes":[{"content":"_alloca","pos":[0,7]}]},{"content":"Allocates memory on the stack.","pos":[941,971]},{"content":"This function is deprecated because a more secure version is available; see <bpt id=\"p1\">[</bpt>_malloca<ept id=\"p1\">](../../c-runtime-library/reference/malloca.md)</ept>.","pos":[972,1105],"source":" This function is deprecated because a more secure version is available; see [_malloca](../../c-runtime-library/reference/malloca.md)."},{"pos":[1114,1120],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1187,1197],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"[in] <ph id=\"ph1\">`size`</ph>","pos":[1201,1212],"source":"[in] `size`"},{"content":"Bytes to be allocated from the stack.","pos":[1216,1253]},{"pos":[1262,1274],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The <ph id=\"ph1\">`_alloca`</ph> routine returns a <ph id=\"ph2\">`void`</ph> pointer to the allocated space, which is guaranteed to be suitably aligned for storage of any type of object.","pos":[1278,1426],"source":"The `_alloca` routine returns a `void` pointer to the allocated space, which is guaranteed to be suitably aligned for storage of any type of object."},{"content":"If <ph id=\"ph1\">`size`</ph> is 0, <ph id=\"ph2\">`_alloca`</ph> allocates a zero-length item and returns a valid pointer to that item.","pos":[1427,1523],"source":" If `size` is 0, `_alloca` allocates a zero-length item and returns a valid pointer to that item."},{"content":"A stack overflow exception is generated if the space cannot be allocated.","pos":[1530,1603]},{"content":"The stack overflow exception is not a C++ exception; it is a structured exception.","pos":[1604,1686]},{"content":"Instead of using C++ exception handling, you must use <bpt id=\"p1\">[</bpt>Structured Exception Handling<ept id=\"p1\">](../../cpp/structured-exception-handling-c-cpp.md)</ept> (SEH).","pos":[1687,1829],"source":" Instead of using C++ exception handling, you must use [Structured Exception Handling](../../cpp/structured-exception-handling-c-cpp.md) (SEH)."},{"pos":[1838,1845],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`_alloca`</ph> allocates <ph id=\"ph2\">`size`</ph> bytes from the program stack.","pos":[1849,1905],"source":"`_alloca` allocates `size` bytes from the program stack."},{"content":"The allocated space is automatically freed when the calling function exits (not when the allocation merely passes out of scope).","pos":[1906,2034]},{"content":"Therefore, do not pass the pointer value returned by <ph id=\"ph1\">`_alloca`</ph> as an argument to <bpt id=\"p1\">[</bpt>free<ept id=\"p1\">](../../c-runtime-library/reference/free.md)</ept>.","pos":[2035,2166],"source":" Therefore, do not pass the pointer value returned by `_alloca` as an argument to [free](../../c-runtime-library/reference/free.md)."},{"content":"There are restrictions to explicitly calling <ph id=\"ph1\">`_alloca`</ph> in an exception handler (EH).","pos":[2173,2257],"source":"There are restrictions to explicitly calling `_alloca` in an exception handler (EH)."},{"content":"EH routines that run on x86-class processors operate in their own memory frame: They perform their tasks in memory space that is not based on the current location of the stack pointer of the enclosing function.","pos":[2258,2468]},{"content":"The most common implementations include Windows NT structured exception handling (SEH) and C++ catch clause expressions.","pos":[2469,2589]},{"content":"Therefore, explicitly calling <ph id=\"ph1\">`_alloca`</ph> in any of the following scenarios results in program failure during the return to the calling EH routine:","pos":[2590,2735],"source":" Therefore, explicitly calling `_alloca` in any of the following scenarios results in program failure during the return to the calling EH routine:"},{"pos":[2745,2815],"content":"Windows NT SEH exception filter expression: <ph id=\"ph1\">`__except`</ph> (<ph id=\"ph2\">`_alloca ()`</ph> )","source":"Windows NT SEH exception filter expression: `__except` (`_alloca ()` )"},{"pos":[2825,2892],"content":"Windows NT SEH final exception handler: <ph id=\"ph1\">`__finally`</ph> {<ph id=\"ph2\">`_alloca ()`</ph> }","source":"Windows NT SEH final exception handler: `__finally` {`_alloca ()` }"},{"content":"C++ EH catch clause expression","pos":[2902,2932]},{"pos":[2939,3111],"content":"However, <ph id=\"ph1\">`_alloca`</ph> can be called directly from within an EH routine or from an application-supplied callback that gets invoked by one of the EH scenarios previously listed.","source":"However, `_alloca` can be called directly from within an EH routine or from an application-supplied callback that gets invoked by one of the EH scenarios previously listed."},{"pos":[3119,3299],"content":"[!IMPORTANT]\n In Windows XP, if `_alloca` is called inside a try/catch block, you must call [_resetstkoflw](../../c-runtime-library/reference/resetstkoflw.md) in the catch block.","leadings":["","> "],"nodes":[{"content":"In Windows XP, if <ph id=\"ph1\">`_alloca`</ph> is called inside a try/catch block, you must call <bpt id=\"p1\">[</bpt>_resetstkoflw<ept id=\"p1\">](../../c-runtime-library/reference/resetstkoflw.md)</ept> in the catch block.","pos":[14,178],"source":" In Windows XP, if `_alloca` is called inside a try/catch block, you must call [_resetstkoflw](../../c-runtime-library/reference/resetstkoflw.md) in the catch block."}]},{"content":"In addition to the above restrictions, when using the<bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../../build/reference/clr-common-language-runtime-compilation.md)</ept> option, <ph id=\"ph1\">`_alloca`</ph> cannot be used in <ph id=\"ph2\">`__except`</ph> blocks.","pos":[3306,3524],"source":"In addition to the above restrictions, when using the[/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md) option, `_alloca` cannot be used in `__except` blocks."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>/clr Restrictions<ept id=\"p1\">](../../build/reference/clr-restrictions.md)</ept>.","pos":[3525,3614],"source":" For more information, see [/clr Restrictions](../../build/reference/clr-restrictions.md)."},{"pos":[3623,3635],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[3642,3649]},{"content":"Required header","pos":[3650,3665]},{"content":"<ph id=\"ph1\">\\&lt;</ph>malloc.h&gt;","pos":[3720,3731],"source":"\\<malloc.h>"},{"pos":[3741,3748],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[5186,5211],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"Not applicable.","pos":[5215,5230]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[5231,5278],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[5279,5404],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[5413,5421],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Memory Allocation<ept id=\"p1\">](../../c-runtime-library/memory-allocation.md)</ept><ph id=\"ph1\"> </ph>","pos":[5425,5491],"source":"[Memory Allocation](../../c-runtime-library/memory-allocation.md) "},{"content":"<bpt id=\"p1\"> [</bpt>calloc<ept id=\"p1\">](../../c-runtime-library/reference/calloc.md)</ept><ph id=\"ph1\"> </ph>","pos":[5494,5549],"source":" [calloc](../../c-runtime-library/reference/calloc.md) "},{"content":"<bpt id=\"p1\"> [</bpt>malloc<ept id=\"p1\">](../../c-runtime-library/reference/malloc.md)</ept><ph id=\"ph1\"> </ph>","pos":[5552,5607],"source":" [malloc](../../c-runtime-library/reference/malloc.md) "},{"content":"<bpt id=\"p1\"> [</bpt>realloc<ept id=\"p1\">](../../c-runtime-library/reference/realloc.md)</ept><ph id=\"ph1\"> </ph>","pos":[5610,5667],"source":" [realloc](../../c-runtime-library/reference/realloc.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_resetstkoflw<ept id=\"p1\">](../../c-runtime-library/reference/resetstkoflw.md)</ept><ph id=\"ph1\"> </ph>","pos":[5670,5738],"source":" [_resetstkoflw](../../c-runtime-library/reference/resetstkoflw.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_malloca<ept id=\"p1\">](../../c-runtime-library/reference/malloca.md)</ept>","pos":[5741,5798],"source":" [_malloca](../../c-runtime-library/reference/malloca.md)"}],"content":"---\ntitle: \"_alloca | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_alloca\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"_alloca\"\n  - \"alloca\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"memory allocation, stack\"\n  - \"alloca function\"\n  - \"_alloca function\"\nms.assetid: 74488eb1-b71f-4515-88e1-cdd03b6f8225\ncaps.latest.revision: 23\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _alloca\nAllocates memory on the stack. This function is deprecated because a more secure version is available; see [_malloca](../../c-runtime-library/reference/malloca.md).  \n  \n## Syntax  \n  \n```  \nvoid *_alloca(   \n   size_t size   \n);  \n```  \n  \n#### Parameters  \n [in] `size`  \n Bytes to be allocated from the stack.  \n  \n## Return Value  \n The `_alloca` routine returns a `void` pointer to the allocated space, which is guaranteed to be suitably aligned for storage of any type of object. If `size` is 0, `_alloca` allocates a zero-length item and returns a valid pointer to that item.  \n  \n A stack overflow exception is generated if the space cannot be allocated. The stack overflow exception is not a C++ exception; it is a structured exception. Instead of using C++ exception handling, you must use [Structured Exception Handling](../../cpp/structured-exception-handling-c-cpp.md) (SEH).  \n  \n## Remarks  \n `_alloca` allocates `size` bytes from the program stack. The allocated space is automatically freed when the calling function exits (not when the allocation merely passes out of scope). Therefore, do not pass the pointer value returned by `_alloca` as an argument to [free](../../c-runtime-library/reference/free.md).  \n  \n There are restrictions to explicitly calling `_alloca` in an exception handler (EH). EH routines that run on x86-class processors operate in their own memory frame: They perform their tasks in memory space that is not based on the current location of the stack pointer of the enclosing function. The most common implementations include Windows NT structured exception handling (SEH) and C++ catch clause expressions. Therefore, explicitly calling `_alloca` in any of the following scenarios results in program failure during the return to the calling EH routine:  \n  \n-   Windows NT SEH exception filter expression: `__except` (`_alloca ()` )  \n  \n-   Windows NT SEH final exception handler: `__finally` {`_alloca ()` }  \n  \n-   C++ EH catch clause expression  \n  \n However, `_alloca` can be called directly from within an EH routine or from an application-supplied callback that gets invoked by one of the EH scenarios previously listed.  \n  \n> [!IMPORTANT]\n>  In Windows XP, if `_alloca` is called inside a try/catch block, you must call [_resetstkoflw](../../c-runtime-library/reference/resetstkoflw.md) in the catch block.  \n  \n In addition to the above restrictions, when using the[/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md) option, `_alloca` cannot be used in `__except` blocks. For more information, see [/clr Restrictions](../../build/reference/clr-restrictions.md).  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`_alloca`|\\<malloc.h>|  \n  \n## Example  \n  \n```  \n// crt_alloca.c  \n// This program demonstrates the use of  \n// _alloca and trapping any exceptions  \n// that may occur.  \n  \n#include <windows.h>  \n#include <stdio.h>  \n#include <malloc.h>  \n  \nint main()  \n{  \n    int     size = 1000;  \n    int     errcode = 0;  \n    void    *pData = NULL;  \n  \n    // Note: Do not use try/catch for _alloca,  \n    // use __try/__except, since _alloca throws  \n    // Structured Exceptions, not C++ exceptions.  \n  \n    __try {  \n        // An unbounded _alloca can easily result in a   \n        // stack overflow.  \n        // Checking for a size < 1024 bytes is recommended.  \n        if (size > 0 && size < 1024)  \n        {  \n            pData = _alloca( size );  \n            printf_s( \"Allocated %d bytes of stack at 0x%p\",  \n                      size, pData);  \n        }  \n        else  \n        {  \n            printf_s(\"Tried to allocate too many bytes.\\n\");  \n        }  \n    }  \n  \n    // If an exception occured with the _alloca function  \n    __except( GetExceptionCode() == STATUS_STACK_OVERFLOW )  \n    {  \n        printf_s(\"_alloca failed!\\n\");  \n  \n        // If the stack overflows, use this function to restore.  \n        errcode = _resetstkoflw();  \n        if (errcode)  \n        {  \n            printf_s(\"Could not reset the stack!\\n\");  \n            _exit(1);  \n        }  \n    };  \n}  \n```  \n  \n```Output  \nAllocated 1000 bytes of stack at 0x0012FB50  \n```  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [Memory Allocation](../../c-runtime-library/memory-allocation.md)   \n [calloc](../../c-runtime-library/reference/calloc.md)   \n [malloc](../../c-runtime-library/reference/malloc.md)   \n [realloc](../../c-runtime-library/reference/realloc.md)   \n [_resetstkoflw](../../c-runtime-library/reference/resetstkoflw.md)   \n [_malloca](../../c-runtime-library/reference/malloca.md)"}