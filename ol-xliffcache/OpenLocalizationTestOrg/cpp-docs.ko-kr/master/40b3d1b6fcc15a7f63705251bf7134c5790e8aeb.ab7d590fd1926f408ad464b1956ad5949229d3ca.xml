{"nodes":[{"pos":[12,83],"content":"TN045: MFC-Database Support for Long Varchar-Varbinary | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN045: MFC-Database Support for Long Varchar-Varbinary | Microsoft Docs","pos":[0,71]}]},{"content":"TN045: MFC/Database Support for Long Varchar/Varbinary","pos":[679,733]},{"pos":[736,1051],"content":"[!NOTE]\n The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","leadings":["","> "],"nodes":[{"content":" The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[8,313],"nodes":[{"content":"The following technical note has not been updated since it was first included in the online documentation.","pos":[1,107]},{"content":"As a result, some procedures and topics might be out of date or incorrect.","pos":[108,182]},{"content":"For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[183,305]}]}]},{"pos":[1058,1200],"content":"This note describes how to retrieve and send the ODBC <bpt id=\"p1\">**</bpt>SQL_LONGVARCHAR<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>SQL_LONGVARBINARY<ept id=\"p2\">**</ept> data types using the MFC database classes.","source":"This note describes how to retrieve and send the ODBC **SQL_LONGVARCHAR** and **SQL_LONGVARBINARY** data types using the MFC database classes."},{"content":"Overview of Long Varchar/Varbinary Support","pos":[1209,1251]},{"content":"The ODBC <bpt id=\"p1\">**</bpt>SQL_LONG_VARCHAR<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>SQL_LONGBINARY<ept id=\"p2\">**</ept> data types (referred to here as long data columns) can hold huge amounts of data.","pos":[1255,1389],"source":"The ODBC **SQL_LONG_VARCHAR** and **SQL_LONGBINARY** data types (referred to here as long data columns) can hold huge amounts of data."},{"content":"There are 3 ways you can handle this data:","pos":[1390,1432]},{"pos":[1442,1478],"content":"Bind it to a <ph id=\"ph1\">`CString`/`CByteArray`</ph>.","source":"Bind it to a `CString`/`CByteArray`."},{"pos":[1488,1515],"content":"Bind it to a <ph id=\"ph1\">`CLongBinary`</ph>.","source":"Bind it to a `CLongBinary`."},{"content":"Do not bind it at all and retrieve and send the long data value manually, independent of the database classes.","pos":[1525,1635]},{"content":"Each of the three methods has advantages and disadvantages.","pos":[1642,1701]},{"content":"Long data columns are not supported for parameters to a query.","pos":[1708,1770]},{"content":"They are only supported for outputColumns.","pos":[1771,1813]},{"content":"Binding a Long Data Column to a CString/CByteArray","pos":[1822,1872]},{"content":"Advantages:","pos":[1876,1887]},{"content":"This approach is simple to understand, and you work with familiar classes.","pos":[1894,1968]},{"content":"The framework provides <ph id=\"ph1\">`CFormView`</ph> support for <ph id=\"ph2\">`CString`</ph> with <ph id=\"ph3\">`DDX_Text`</ph>.","pos":[1969,2042],"source":" The framework provides `CFormView` support for `CString` with `DDX_Text`."},{"content":"You have lots of general string or collection functionality with the <ph id=\"ph1\">`CString`</ph> and <ph id=\"ph2\">`CByteArray`</ph> classes, and you can control the amount of memory allocated locally to hold the data value.","pos":[2043,2230],"source":" You have lots of general string or collection functionality with the `CString` and `CByteArray` classes, and you can control the amount of memory allocated locally to hold the data value."},{"content":"The framework maintains an old copy of field data during <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`AddNew`</ph> function calls, and the framework can automatically detect changes to the data for you.","pos":[2231,2396],"source":" The framework maintains an old copy of field data during **Edit** or `AddNew` function calls, and the framework can automatically detect changes to the data for you."},{"pos":[2404,2669],"content":"[!NOTE]\n Since `CString` is designed for working on character data, and `CByteArray` for working on binary data, it is recommended that you put the character data (**SQL_LONGVARCHAR**) into `CString`, and the binary data (**SQL_LONGVARBINARY**) into `CByteArray`.","leadings":["","> "],"nodes":[{"content":"Since <ph id=\"ph1\">`CString`</ph> is designed for working on character data, and <ph id=\"ph2\">`CByteArray`</ph> for working on binary data, it is recommended that you put the character data (<bpt id=\"p1\">**</bpt>SQL_LONGVARCHAR<ept id=\"p1\">**</ept>) into <ph id=\"ph3\">`CString`</ph>, and the binary data (<bpt id=\"p2\">**</bpt>SQL_LONGVARBINARY<ept id=\"p2\">**</ept>) into <ph id=\"ph4\">`CByteArray`</ph>.","pos":[9,263],"source":" Since `CString` is designed for working on character data, and `CByteArray` for working on binary data, it is recommended that you put the character data (**SQL_LONGVARCHAR**) into `CString`, and the binary data (**SQL_LONGVARBINARY**) into `CByteArray`."}]},{"content":"The RFX functions for <ph id=\"ph1\">`CString`</ph> and <ph id=\"ph2\">`CByteArray`</ph> have an additional argument which lets you override the default size of allocated memory to hold the retrieved value for the data column.","pos":[2676,2862],"source":"The RFX functions for `CString` and `CByteArray` have an additional argument which lets you override the default size of allocated memory to hold the retrieved value for the data column."},{"content":"Note the nMaxLength argument in the following function declarations:","pos":[2863,2931]},{"content":"If you retrieve a long data column into a <ph id=\"ph1\">`CString`</ph> or <ph id=\"ph2\">`CByteArray`</ph>, the maximum returned amount of data is, by default, 255 bytes.","pos":[3232,3363],"source":"If you retrieve a long data column into a `CString` or `CByteArray`, the maximum returned amount of data is, by default, 255 bytes."},{"content":"Anything beyond this is ignored.","pos":[3364,3396]},{"content":"In this case, the framework will throw the exception <bpt id=\"p1\">**</bpt>AFX_SQL_ERROR_DATA_TRUNCATED<ept id=\"p1\">**</ept>.","pos":[3397,3483],"source":" In this case, the framework will throw the exception **AFX_SQL_ERROR_DATA_TRUNCATED**."},{"content":"Fortunately, you can explicitly increase nMaxLength to greater values, up to <bpt id=\"p1\">**</bpt>MAXINT<ept id=\"p1\">**</ept>.","pos":[3484,3572],"source":" Fortunately, you can explicitly increase nMaxLength to greater values, up to **MAXINT**."},{"pos":[3580,4309],"content":"[!NOTE]\n The value of nMaxLength is used by MFC to set the local buffer of the **SQLBindColumn** function. This is the local buffer for storage of the data and does not actually affect the amount of data returned by the ODBC driver. `RFX_Text` and `RFX_Binary` only make one call using **SQLFetch** to retrieve the data from the back-end database. Each ODBC driver has a different limitation on the amount of data they can return in a single fetch. This limit may be much smaller than the value set in nMaxLength, in which case the exception **AFX_SQL_ERROR_DATA_TRUNCATED** will be thrown. Under these circumstances, switch to using `RFX_LongBinary` instead of `RFX_Text` or `RFX_Binary` so that all the data can be retrieved.","leadings":["","> "],"nodes":[{"content":" The value of nMaxLength is used by MFC to set the local buffer of the **SQLBindColumn** function. This is the local buffer for storage of the data and does not actually affect the amount of data returned by the ODBC driver. `RFX_Text` and `RFX_Binary` only make one call using **SQLFetch** to retrieve the data from the back-end database. Each ODBC driver has a different limitation on the amount of data they can return in a single fetch. This limit may be much smaller than the value set in nMaxLength, in which case the exception **AFX_SQL_ERROR_DATA_TRUNCATED** will be thrown. Under these circumstances, switch to using `RFX_LongBinary` instead of `RFX_Text` or `RFX_Binary` so that all the data can be retrieved.","pos":[8,727],"nodes":[{"content":"The value of nMaxLength is used by MFC to set the local buffer of the <bpt id=\"p1\">**</bpt>SQLBindColumn<ept id=\"p1\">**</ept> function.","pos":[1,98],"source":" The value of nMaxLength is used by MFC to set the local buffer of the **SQLBindColumn** function."},{"content":"This is the local buffer for storage of the data and does not actually affect the amount of data returned by the ODBC driver.","pos":[99,224]},{"content":"and <ph id=\"ph1\">`RFX_Binary`</ph> only make one call using <bpt id=\"p1\">**</bpt>SQLFetch<ept id=\"p1\">**</ept> to retrieve the data from the back-end database.","pos":[236,339],"source":" and `RFX_Binary` only make one call using **SQLFetch** to retrieve the data from the back-end database."},{"content":"Each ODBC driver has a different limitation on the amount of data they can return in a single fetch.","pos":[340,440]},{"content":"This limit may be much smaller than the value set in nMaxLength, in which case the exception <bpt id=\"p1\">**</bpt>AFX_SQL_ERROR_DATA_TRUNCATED<ept id=\"p1\">**</ept> will be thrown.","pos":[441,582],"source":" This limit may be much smaller than the value set in nMaxLength, in which case the exception **AFX_SQL_ERROR_DATA_TRUNCATED** will be thrown."},{"content":"Under these circumstances, switch to using <ph id=\"ph1\">`RFX_LongBinary`</ph> instead of <ph id=\"ph2\">`RFX_Text`</ph> or <ph id=\"ph3\">`RFX_Binary`</ph> so that all the data can be retrieved.","pos":[583,719],"source":" Under these circumstances, switch to using `RFX_LongBinary` instead of `RFX_Text` or `RFX_Binary` so that all the data can be retrieved."}]}]},{"content":"ClassWizard will bind a <bpt id=\"p1\">**</bpt>SQL_LONGVARCHAR<ept id=\"p1\">**</ept> to a <ph id=\"ph1\">`CString`</ph>, or a <bpt id=\"p2\">**</bpt>SQL_LONGVARBINARY<ept id=\"p2\">**</ept> to a <ph id=\"ph2\">`CByteArray`</ph> for you.","pos":[4316,4429],"source":"ClassWizard will bind a **SQL_LONGVARCHAR** to a `CString`, or a **SQL_LONGVARBINARY** to a `CByteArray` for you."},{"content":"If you want to allocate more than 255 bytes into which you retrieve your long data column, you can then supply an explicit value for nMaxLength.","pos":[4430,4574]},{"content":"When a long data column is bound to a <ph id=\"ph1\">`CString`</ph> or <ph id=\"ph2\">`CByteArray`</ph>, updating the field works just the same as when it is bound to a SQL_<bpt id=\"p1\">**</bpt>VARCHAR<ept id=\"p1\">**</ept> or SQL_<bpt id=\"p2\">**</bpt>VARBINARY<ept id=\"p2\">**</ept>.","pos":[4581,4747],"source":"When a long data column is bound to a `CString` or `CByteArray`, updating the field works just the same as when it is bound to a SQL_**VARCHAR** or SQL_**VARBINARY**."},{"content":"During <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, the data value is cached away and later compared when <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept> is called to detect changes to the data value and set the Dirty and Null values for the column appropriately.","pos":[4748,4939],"source":" During **Edit**, the data value is cached away and later compared when **Update** is called to detect changes to the data value and set the Dirty and Null values for the column appropriately."},{"content":"Binding a Long Data Column to a CLongBinary","pos":[4948,4991]},{"pos":[4995,5127],"content":"If your long data column may contain more <bpt id=\"p1\">**</bpt>MAXINT<ept id=\"p1\">**</ept> bytes of data, you should probably consider retrieving it into a <ph id=\"ph1\">`CLongBinary`</ph>.","source":"If your long data column may contain more **MAXINT** bytes of data, you should probably consider retrieving it into a `CLongBinary`."},{"content":"Advantages:","pos":[5134,5145]},{"content":"This retrieves an entire long data column, up to available memory.","pos":[5152,5218]},{"content":"Disadvantages:","pos":[5225,5239]},{"content":"The data is held in memory.","pos":[5246,5273]},{"content":"This approach is also prohibitively expensive for very large amounts of data.","pos":[5274,5351]},{"content":"You must call <ph id=\"ph1\">`SetFieldDirty`</ph> for the bound data member to ensure the field is included in an <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> operation.","pos":[5352,5467],"source":" You must call `SetFieldDirty` for the bound data member to ensure the field is included in an **Update** operation."},{"content":"If you retrieve long data columns into a <ph id=\"ph1\">`CLongBinary`</ph>, the database classes will check the total size of the long data column, then allocate an <ph id=\"ph2\">`HGLOBAL`</ph> memory segment large enough to hold it the entire data value.","pos":[5474,5690],"source":"If you retrieve long data columns into a `CLongBinary`, the database classes will check the total size of the long data column, then allocate an `HGLOBAL` memory segment large enough to hold it the entire data value."},{"content":"The database classes then retrieve the entire data value into the allocated <ph id=\"ph1\">`HGLOBAL`</ph>.","pos":[5691,5777],"source":" The database classes then retrieve the entire data value into the allocated `HGLOBAL`."},{"content":"If the data source cannot return the expected size of the long data column, the framework will throw the exception <bpt id=\"p1\">**</bpt>AFX_SQL_ERROR_SQL_NO_TOTAL<ept id=\"p1\">**</ept>.","pos":[5784,5930],"source":"If the data source cannot return the expected size of the long data column, the framework will throw the exception **AFX_SQL_ERROR_SQL_NO_TOTAL**."},{"content":"If the attempt to allocate the <ph id=\"ph1\">`HGLOBAL`</ph> fails, a standard memory exception is thrown.","pos":[5931,6017],"source":" If the attempt to allocate the `HGLOBAL` fails, a standard memory exception is thrown."},{"content":"ClassWizard will bind an <bpt id=\"p1\">**</bpt>SQL_LONGVARCHAR<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>SQL_LONGVARBINARY<ept id=\"p2\">**</ept> to a <ph id=\"ph1\">`CLongBinary`</ph> for you.","pos":[6024,6121],"source":"ClassWizard will bind an **SQL_LONGVARCHAR** or **SQL_LONGVARBINARY** to a `CLongBinary` for you."},{"content":"Select <ph id=\"ph1\">`CLongBinary`</ph> as the Variable Type in the Add Member Variable dialog.","pos":[6122,6198],"source":" Select `CLongBinary` as the Variable Type in the Add Member Variable dialog."},{"content":"ClassWizard will then add an <ph id=\"ph1\">`RFX_LongBinary`</ph> call to your <ph id=\"ph2\">`DoFieldExchange`</ph> call and increment the total number of bound fields.","pos":[6199,6328],"source":" ClassWizard will then add an `RFX_LongBinary` call to your `DoFieldExchange` call and increment the total number of bound fields."},{"content":"To update long data column values, first make sure the allocated <ph id=\"ph1\">`HGLOBAL`</ph> is large enough to hold your new data by calling <bpt id=\"p1\">**</bpt>::GlobalSize<ept id=\"p1\">**</ept> on the <ph id=\"ph2\">`m_hData`</ph> member of the <ph id=\"ph3\">`CLongBinary`</ph>.","pos":[6335,6521],"source":"To update long data column values, first make sure the allocated `HGLOBAL` is large enough to hold your new data by calling **::GlobalSize** on the `m_hData` member of the `CLongBinary`."},{"content":"If it is too small, release the <ph id=\"ph1\">`HGLOBAL`</ph> and allocate one the appropriate size.","pos":[6522,6602],"source":" If it is too small, release the `HGLOBAL` and allocate one the appropriate size."},{"content":"Then set <ph id=\"ph1\">`m_dwDataLength`</ph> to reflect the new size.","pos":[6603,6653],"source":" Then set `m_dwDataLength` to reflect the new size."},{"content":"Otherwise, if <ph id=\"ph1\">`m_dwDataLength`</ph> is larger than the size of the data you're replacing, you can either free and reallocate the <ph id=\"ph2\">`HGLOBAL`</ph>, or leave it allocated.","pos":[6660,6817],"source":"Otherwise, if `m_dwDataLength` is larger than the size of the data you're replacing, you can either free and reallocate the `HGLOBAL`, or leave it allocated."},{"content":"Make sure to indicate the number of bytes actually used in <ph id=\"ph1\">`m_dwDataLength`</ph>.","pos":[6818,6894],"source":" Make sure to indicate the number of bytes actually used in `m_dwDataLength`."},{"content":"How Updating a CLongBinary Works","pos":[6903,6935]},{"pos":[6939,7143],"content":"It is not necessary to understand how updating a <ph id=\"ph1\">`CLongBinary`</ph> works, but it may be useful as an example on how to send long data values to a data source, if you choose this third method, described below.","source":"It is not necessary to understand how updating a `CLongBinary` works, but it may be useful as an example on how to send long data values to a data source, if you choose this third method, described below."},{"pos":[7151,7489],"content":"[!NOTE]\n In order for a `CLongBinary` field to be included in an update, you must explicitly call `SetFieldDirty` for the field. If you make any change to a field, including setting it Null, you must call `SetFieldDirty`. You must also call `SetFieldNull`, with the second parameter being **FALSE**, to mark the field as having a value.","leadings":["","> "],"nodes":[{"content":" In order for a `CLongBinary` field to be included in an update, you must explicitly call `SetFieldDirty` for the field. If you make any change to a field, including setting it Null, you must call `SetFieldDirty`. You must also call `SetFieldNull`, with the second parameter being **FALSE**, to mark the field as having a value.","pos":[8,336],"nodes":[{"content":"In order for a <ph id=\"ph1\">`CLongBinary`</ph> field to be included in an update, you must explicitly call <ph id=\"ph2\">`SetFieldDirty`</ph> for the field.","pos":[1,120],"source":" In order for a `CLongBinary` field to be included in an update, you must explicitly call `SetFieldDirty` for the field."},{"content":"If you make any change to a field, including setting it Null, you must call <ph id=\"ph1\">`SetFieldDirty`</ph>.","pos":[121,213],"source":" If you make any change to a field, including setting it Null, you must call `SetFieldDirty`."},{"content":"You must also call <ph id=\"ph1\">`SetFieldNull`</ph>, with the second parameter being <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept>, to mark the field as having a value.","pos":[214,328],"source":" You must also call `SetFieldNull`, with the second parameter being **FALSE**, to mark the field as having a value."}]}]},{"content":"When updating a <ph id=\"ph1\">`CLongBinary`</ph> field, the database classes use ODBC's <bpt id=\"p1\">**</bpt>DATA_AT_EXEC<ept id=\"p1\">**</ept> mechanism (see ODBC documentation on <bpt id=\"p2\">**</bpt>SQLSetPos<ept id=\"p2\">**</ept>'s rgbValue argument).","pos":[7496,7654],"source":"When updating a `CLongBinary` field, the database classes use ODBC's **DATA_AT_EXEC** mechanism (see ODBC documentation on **SQLSetPos**'s rgbValue argument)."},{"content":"When the framework prepares the insert or update statement, instead of pointing to the <ph id=\"ph1\">`HGLOBAL`</ph> containing the data, the <bpt id=\"p1\">*</bpt>address<ept id=\"p1\">*</ept> of the <ph id=\"ph2\">`CLongBinary`</ph> is set as the <bpt id=\"p2\">*</bpt>value<ept id=\"p2\">*</ept> of the column instead, and the length indicator set to <bpt id=\"p3\">**</bpt>SQL_DATA_AT_EXEC<ept id=\"p3\">**</ept>.","pos":[7655,7906],"source":" When the framework prepares the insert or update statement, instead of pointing to the `HGLOBAL` containing the data, the *address* of the `CLongBinary` is set as the *value* of the column instead, and the length indicator set to **SQL_DATA_AT_EXEC**."},{"content":"Later, when the update statement is sent to the data source, <bpt id=\"p1\">**</bpt>SQLExecDirect<ept id=\"p1\">**</ept> will return <bpt id=\"p2\">**</bpt>SQL_NEED_DATA<ept id=\"p2\">**</ept>.","pos":[7907,8016],"source":" Later, when the update statement is sent to the data source, **SQLExecDirect** will return **SQL_NEED_DATA**."},{"content":"This alerts the framework that the value of the param for this column is actually the address of a <ph id=\"ph1\">`CLongBinary`</ph>.","pos":[8017,8130],"source":" This alerts the framework that the value of the param for this column is actually the address of a `CLongBinary`."},{"content":"The framework calls <bpt id=\"p1\">**</bpt>SQLGetData<ept id=\"p1\">**</ept> once with a small buffer, expecting the driver to return the actual length of the data.","pos":[8131,8253],"source":" The framework calls **SQLGetData** once with a small buffer, expecting the driver to return the actual length of the data."},{"content":"If the driver returns the actual length of the binary large object (the BLOB), MFC reallocates as much space as necessary to fetch the BLOB.","pos":[8254,8394]},{"content":"If the data source returns <bpt id=\"p1\">**</bpt>SQL_NO_TOTAL<ept id=\"p1\">**</ept>, indicating that it can't determine the size of the BLOB, MFC will create smaller blocks.","pos":[8395,8528],"source":" If the data source returns **SQL_NO_TOTAL**, indicating that it can't determine the size of the BLOB, MFC will create smaller blocks."},{"content":"The default initial size is 64K, and subsequent blocks will be double the size; for example, the second will be 128K, the third is 256K, and so on.","pos":[8529,8676]},{"content":"The initial size is configurable.","pos":[8677,8710]},{"content":"Not Binding: Retrieving/Sending Data Directly from ODBC with SQLGetData","pos":[8719,8790]},{"content":"With this method you completely bypass the database classes, and deal with the long data column yourself.","pos":[8794,8899]},{"content":"Advantages:","pos":[8906,8917]},{"content":"You can cache data to disk if necessary, or decide dynamically how much data to retrieve.","pos":[8924,9013]},{"content":"Disadvantages:","pos":[9020,9034]},{"pos":[9041,9237],"content":"You don't get the framework's <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`AddNew`</ph> support, and you must write code yourself to perform basic functionality (<bpt id=\"p2\">**</bpt>Delete<ept id=\"p2\">**</ept> does work though, since it is not a column level operation).","source":"You don't get the framework's **Edit** or `AddNew` support, and you must write code yourself to perform basic functionality (**Delete** does work though, since it is not a column level operation)."},{"content":"In this case, the long data column must be in the select list of the recordset, but should not be bound to by the framework.","pos":[9244,9368]},{"content":"One way to do this is to supply your own SQL statement via <ph id=\"ph1\">`GetDefaultSQL`</ph> or as the lpszSQL argument to <ph id=\"ph2\">`CRecordset`</ph>'s <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> function, and not bind the extra column with an RFX_ function call.","pos":[9369,9565],"source":" One way to do this is to supply your own SQL statement via `GetDefaultSQL` or as the lpszSQL argument to `CRecordset`'s **Open** function, and not bind the extra column with an RFX_ function call."},{"content":"ODBC requires that unbound fields appear to the right of bound fields, so add your unbound column or columns to the end of the select list.","pos":[9566,9705]},{"pos":[9713,9940],"content":"[!NOTE]\n Because your long data column is not bound by the framework, changes to it will not be handled with `CRecordset::Update` calls. You must create and send the required SQL **INSERT** and **UPDATE** statements yourself.","leadings":["","> "],"nodes":[{"content":" Because your long data column is not bound by the framework, changes to it will not be handled with `CRecordset::Update` calls. You must create and send the required SQL **INSERT** and **UPDATE** statements yourself.","pos":[8,225],"nodes":[{"content":"Because your long data column is not bound by the framework, changes to it will not be handled with <ph id=\"ph1\">`CRecordset::Update`</ph> calls.","pos":[1,128],"source":" Because your long data column is not bound by the framework, changes to it will not be handled with `CRecordset::Update` calls."},{"content":"You must create and send the required SQL <bpt id=\"p1\">**</bpt>INSERT<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>UPDATE<ept id=\"p2\">**</ept> statements yourself.","pos":[129,217],"source":" You must create and send the required SQL **INSERT** and **UPDATE** statements yourself."}]}]},{"content":"See Also","pos":[9949,9957]},{"content":"Technical Notes by Number","pos":[9962,9987]},{"content":"Technical Notes by Category","pos":[10031,10058]}],"content":"---\ntitle: \"TN045: MFC-Database Support for Long Varchar-Varbinary | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.mfc.data\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"TN045\"\n  - \"Varbinary data type\"\n  - \"Varchar data type\"\nms.assetid: cf572c35-5275-45b5-83df-5f0e36114f40\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN045: MFC/Database Support for Long Varchar/Varbinary\n> [!NOTE]\n>  The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.  \n  \n This note describes how to retrieve and send the ODBC **SQL_LONGVARCHAR** and **SQL_LONGVARBINARY** data types using the MFC database classes.  \n  \n## Overview of Long Varchar/Varbinary Support  \n The ODBC **SQL_LONG_VARCHAR** and **SQL_LONGBINARY** data types (referred to here as long data columns) can hold huge amounts of data. There are 3 ways you can handle this data:  \n  \n-   Bind it to a `CString`/`CByteArray`.  \n  \n-   Bind it to a `CLongBinary`.  \n  \n-   Do not bind it at all and retrieve and send the long data value manually, independent of the database classes.  \n  \n Each of the three methods has advantages and disadvantages.  \n  \n Long data columns are not supported for parameters to a query. They are only supported for outputColumns.  \n  \n## Binding a Long Data Column to a CString/CByteArray  \n Advantages:  \n  \n This approach is simple to understand, and you work with familiar classes. The framework provides `CFormView` support for `CString` with `DDX_Text`. You have lots of general string or collection functionality with the `CString` and `CByteArray` classes, and you can control the amount of memory allocated locally to hold the data value. The framework maintains an old copy of field data during **Edit** or `AddNew` function calls, and the framework can automatically detect changes to the data for you.  \n  \n> [!NOTE]\n>  Since `CString` is designed for working on character data, and `CByteArray` for working on binary data, it is recommended that you put the character data (**SQL_LONGVARCHAR**) into `CString`, and the binary data (**SQL_LONGVARBINARY**) into `CByteArray`.  \n  \n The RFX functions for `CString` and `CByteArray` have an additional argument which lets you override the default size of allocated memory to hold the retrieved value for the data column. Note the nMaxLength argument in the following function declarations:  \n  \n```  \nvoid AFXAPI RFX_Text(CFieldExchange* pFX,\n    const char *szName,  \n    CString& value,\n    int nMaxLength = 255,\n    int nColumnType = \n    SQL_VARCHAR);\n\n \nvoid AFXAPI RFX_Binary(CFieldExchange* pFX,\n    const char *szName,   \n    CByteArray& value,\n    int nMaxLength = 255);\n```  \n  \n If you retrieve a long data column into a `CString` or `CByteArray`, the maximum returned amount of data is, by default, 255 bytes. Anything beyond this is ignored. In this case, the framework will throw the exception **AFX_SQL_ERROR_DATA_TRUNCATED**. Fortunately, you can explicitly increase nMaxLength to greater values, up to **MAXINT**.  \n  \n> [!NOTE]\n>  The value of nMaxLength is used by MFC to set the local buffer of the **SQLBindColumn** function. This is the local buffer for storage of the data and does not actually affect the amount of data returned by the ODBC driver. `RFX_Text` and `RFX_Binary` only make one call using **SQLFetch** to retrieve the data from the back-end database. Each ODBC driver has a different limitation on the amount of data they can return in a single fetch. This limit may be much smaller than the value set in nMaxLength, in which case the exception **AFX_SQL_ERROR_DATA_TRUNCATED** will be thrown. Under these circumstances, switch to using `RFX_LongBinary` instead of `RFX_Text` or `RFX_Binary` so that all the data can be retrieved.  \n  \n ClassWizard will bind a **SQL_LONGVARCHAR** to a `CString`, or a **SQL_LONGVARBINARY** to a `CByteArray` for you. If you want to allocate more than 255 bytes into which you retrieve your long data column, you can then supply an explicit value for nMaxLength.  \n  \n When a long data column is bound to a `CString` or `CByteArray`, updating the field works just the same as when it is bound to a SQL_**VARCHAR** or SQL_**VARBINARY**. During **Edit**, the data value is cached away and later compared when **Update** is called to detect changes to the data value and set the Dirty and Null values for the column appropriately.  \n  \n## Binding a Long Data Column to a CLongBinary  \n If your long data column may contain more **MAXINT** bytes of data, you should probably consider retrieving it into a `CLongBinary`.  \n  \n Advantages:  \n  \n This retrieves an entire long data column, up to available memory.  \n  \n Disadvantages:  \n  \n The data is held in memory. This approach is also prohibitively expensive for very large amounts of data. You must call `SetFieldDirty` for the bound data member to ensure the field is included in an **Update** operation.  \n  \n If you retrieve long data columns into a `CLongBinary`, the database classes will check the total size of the long data column, then allocate an `HGLOBAL` memory segment large enough to hold it the entire data value. The database classes then retrieve the entire data value into the allocated `HGLOBAL`.  \n  \n If the data source cannot return the expected size of the long data column, the framework will throw the exception **AFX_SQL_ERROR_SQL_NO_TOTAL**. If the attempt to allocate the `HGLOBAL` fails, a standard memory exception is thrown.  \n  \n ClassWizard will bind an **SQL_LONGVARCHAR** or **SQL_LONGVARBINARY** to a `CLongBinary` for you. Select `CLongBinary` as the Variable Type in the Add Member Variable dialog. ClassWizard will then add an `RFX_LongBinary` call to your `DoFieldExchange` call and increment the total number of bound fields.  \n  \n To update long data column values, first make sure the allocated `HGLOBAL` is large enough to hold your new data by calling **::GlobalSize** on the `m_hData` member of the `CLongBinary`. If it is too small, release the `HGLOBAL` and allocate one the appropriate size. Then set `m_dwDataLength` to reflect the new size.  \n  \n Otherwise, if `m_dwDataLength` is larger than the size of the data you're replacing, you can either free and reallocate the `HGLOBAL`, or leave it allocated. Make sure to indicate the number of bytes actually used in `m_dwDataLength`.  \n  \n## How Updating a CLongBinary Works  \n It is not necessary to understand how updating a `CLongBinary` works, but it may be useful as an example on how to send long data values to a data source, if you choose this third method, described below.  \n  \n> [!NOTE]\n>  In order for a `CLongBinary` field to be included in an update, you must explicitly call `SetFieldDirty` for the field. If you make any change to a field, including setting it Null, you must call `SetFieldDirty`. You must also call `SetFieldNull`, with the second parameter being **FALSE**, to mark the field as having a value.  \n  \n When updating a `CLongBinary` field, the database classes use ODBC's **DATA_AT_EXEC** mechanism (see ODBC documentation on **SQLSetPos**'s rgbValue argument). When the framework prepares the insert or update statement, instead of pointing to the `HGLOBAL` containing the data, the *address* of the `CLongBinary` is set as the *value* of the column instead, and the length indicator set to **SQL_DATA_AT_EXEC**. Later, when the update statement is sent to the data source, **SQLExecDirect** will return **SQL_NEED_DATA**. This alerts the framework that the value of the param for this column is actually the address of a `CLongBinary`. The framework calls **SQLGetData** once with a small buffer, expecting the driver to return the actual length of the data. If the driver returns the actual length of the binary large object (the BLOB), MFC reallocates as much space as necessary to fetch the BLOB. If the data source returns **SQL_NO_TOTAL**, indicating that it can't determine the size of the BLOB, MFC will create smaller blocks. The default initial size is 64K, and subsequent blocks will be double the size; for example, the second will be 128K, the third is 256K, and so on. The initial size is configurable.  \n  \n## Not Binding: Retrieving/Sending Data Directly from ODBC with SQLGetData  \n With this method you completely bypass the database classes, and deal with the long data column yourself.  \n  \n Advantages:  \n  \n You can cache data to disk if necessary, or decide dynamically how much data to retrieve.  \n  \n Disadvantages:  \n  \n You don't get the framework's **Edit** or `AddNew` support, and you must write code yourself to perform basic functionality (**Delete** does work though, since it is not a column level operation).  \n  \n In this case, the long data column must be in the select list of the recordset, but should not be bound to by the framework. One way to do this is to supply your own SQL statement via `GetDefaultSQL` or as the lpszSQL argument to `CRecordset`'s **Open** function, and not bind the extra column with an RFX_ function call. ODBC requires that unbound fields appear to the right of bound fields, so add your unbound column or columns to the end of the select list.  \n  \n> [!NOTE]\n>  Because your long data column is not bound by the framework, changes to it will not be handled with `CRecordset::Update` calls. You must create and send the required SQL **INSERT** and **UPDATE** statements yourself.  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}