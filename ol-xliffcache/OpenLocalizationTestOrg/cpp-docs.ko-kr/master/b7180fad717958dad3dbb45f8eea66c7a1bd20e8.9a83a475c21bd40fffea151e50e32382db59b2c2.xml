{"nodes":[{"pos":[12,41],"content":"_controlfp_s | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_controlfp_s | Microsoft Docs","pos":[0,29]}]},{"pos":[1087,1099],"content":"_controlfp_s","linkify":"_controlfp_s","nodes":[{"content":"_controlfp_s","pos":[0,12]}]},{"content":"Gets and sets the floating-point control word.","pos":[1100,1146]},{"content":"This version of <bpt id=\"p1\">[</bpt>_control87, _controlfp, <ph id=\"ph1\">\\_</ph>_control87_2<ept id=\"p1\">](../../c-runtime-library/reference/control87-controlfp-control87-2.md)</ept> has security enhancements, as described in <bpt id=\"p2\">[</bpt>Security Features in the CRT<ept id=\"p2\">](../../c-runtime-library/security-features-in-the-crt.md)</ept>.","pos":[1147,1405],"source":" This version of [_control87, _controlfp, \\__control87_2](../../c-runtime-library/reference/control87-controlfp-control87-2.md) has security enhancements, as described in [Security Features in the CRT](../../c-runtime-library/security-features-in-the-crt.md)."},{"pos":[1414,1420],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1566,1576],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The current control-word bit value.","pos":[1600,1635]},{"content":"New control-word bit values.","pos":[1658,1686]},{"content":"Mask for new control-word bits to set.","pos":[1703,1741]},{"pos":[1750,1762],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[1766,1817],"content":"Zero if successful, or an <ph id=\"ph1\">`errno`</ph> value error code.","source":"Zero if successful, or an `errno` value error code."},{"pos":[1826,1833],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`_controlfp_s`</ph> function is a platform-independent and more secure version of <ph id=\"ph2\">`_control87`</ph>, which gets the floating-point control word into the address that's stored in <ph id=\"ph3\">`currentControl`</ph> and sets it by using <ph id=\"ph4\">`newControl`</ph>.","pos":[1837,2060],"source":"The `_controlfp_s` function is a platform-independent and more secure version of `_control87`, which gets the floating-point control word into the address that's stored in `currentControl` and sets it by using `newControl`."},{"content":"The bits in the values indicate the floating-point control state.","pos":[2061,2126]},{"content":"The floating-point control state enables the program to change the precision, rounding, and infinity modes in the floating-point math package, depending on the platform.","pos":[2127,2296]},{"content":"You can also use <ph id=\"ph1\">`_controlfp_s`</ph> to mask or unmask floating-point exceptions.","pos":[2297,2373],"source":" You can also use `_controlfp_s` to mask or unmask floating-point exceptions."},{"pos":[2380,2522],"content":"If the value for <ph id=\"ph1\">`mask`</ph> is equal to 0, <ph id=\"ph2\">`_controlfp_s`</ph> gets the floating-point control word and stores the retrieved value in <ph id=\"ph3\">`currentControl`</ph>.","source":"If the value for `mask` is equal to 0, `_controlfp_s` gets the floating-point control word and stores the retrieved value in `currentControl`."},{"content":"If <ph id=\"ph1\">`mask`</ph> is nonzero, a new value for the control word is set: For any bit that is set (that is, equal to 1) in <ph id=\"ph2\">`mask`</ph>, the corresponding bit in <ph id=\"ph3\">`new`</ph> is used to update the control word.","pos":[2529,2715],"source":"If `mask` is nonzero, a new value for the control word is set: For any bit that is set (that is, equal to 1) in `mask`, the corresponding bit in `new` is used to update the control word."},{"content":"In other words, <ph id=\"ph1\">`fpcntrl`</ph> <ph id=\"ph2\">`=`</ph> ((<ph id=\"ph3\">`fpcntrl`</ph> <ph id=\"ph4\">`&amp; ~mask`</ph>) &amp;#124; (<ph id=\"ph5\">`new &amp; mask`</ph>)) where <ph id=\"ph6\">`fpcntrl`</ph> is the floating-point control word.","pos":[2716,2843],"source":" In other words, `fpcntrl` `=` ((`fpcntrl` `& ~mask`) &#124; (`new & mask`)) where `fpcntrl` is the floating-point control word."},{"content":"In this scenario, <ph id=\"ph1\">`currentControl`</ph> is set to the value after the change completes; it is not the old control-word bit value.","pos":[2844,2968],"source":" In this scenario, `currentControl` is set to the value after the change completes; it is not the old control-word bit value."},{"pos":[2976,3057],"content":"[!NOTE]\n By default, the run-time libraries mask all floating-point exceptions.","leadings":["","> "],"nodes":[{"content":"By default, the run-time libraries mask all floating-point exceptions.","pos":[9,79]}]},{"content":"<ph id=\"ph1\">`_controlfp_s`</ph> is nearly identical to the <ph id=\"ph2\">`_control87`</ph> function on Intel (x86), <ph id=\"ph3\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph>, and ARM platforms.","pos":[3064,3230],"source":"`_controlfp_s` is nearly identical to the `_control87` function on Intel (x86), [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], and ARM platforms."},{"content":"If you are targeting x86, <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph>, or ARM platforms, you can use <ph id=\"ph2\">`_control87`</ph> or <ph id=\"ph3\">`_controlfp_s`</ph>.","pos":[3231,3386],"source":" If you are targeting x86, [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], or ARM platforms, you can use `_control87` or `_controlfp_s`."},{"content":"The difference between <ph id=\"ph1\">`_control87`</ph> and <ph id=\"ph2\">`_controlfp_s`</ph> is in how they treat <ph id=\"ph3\">`DENORMAL`</ph> values.","pos":[3393,3487],"source":"The difference between `_control87` and `_controlfp_s` is in how they treat `DENORMAL` values."},{"content":"For Intel (x86), <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph>, and ARM platforms, <ph id=\"ph2\">`_control87`</ph> can set and clear the DENORMAL OPERAND exception mask.","pos":[3488,3659],"source":" For Intel (x86), [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], and ARM platforms, `_control87` can set and clear the DENORMAL OPERAND exception mask."},{"content":"<ph id=\"ph1\">`_controlfp_s`</ph> does not modify the DENORMAL OPERAND exception mask.","pos":[3660,3727],"source":"`_controlfp_s` does not modify the DENORMAL OPERAND exception mask."},{"content":"This example demonstrates the difference:","pos":[3728,3769]},{"content":"The possible values for the mask constant (<ph id=\"ph1\">`mask`</ph>) and new control values (<ph id=\"ph2\">`newControl`</ph>) are shown in the following Hexadecimal Values table.","pos":[4007,4148],"source":"The possible values for the mask constant (`mask`) and new control values (`newControl`) are shown in the following Hexadecimal Values table."},{"content":"Use the portable constants listed below (<ph id=\"ph1\">`_MCW_EM`</ph>, <ph id=\"ph2\">`_EM_INVALID`</ph>, and so on) as arguments to these functions, rather than supplying the hexadecimal values explicitly.","pos":[4149,4316],"source":" Use the portable constants listed below (`_MCW_EM`, `_EM_INVALID`, and so on) as arguments to these functions, rather than supplying the hexadecimal values explicitly."},{"content":"Intel (x86)-derived platforms support the DENORMAL input and output values in hardware.","pos":[4323,4410]},{"content":"The x86 behavior is to preserve DENORMAL values.","pos":[4411,4459]},{"content":"The ARM platform and the <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> platforms that have SSE2 support enable DENORMAL operands and results to be flushed, or forced to zero.","pos":[4460,4655],"source":" The ARM platform and the [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms that have SSE2 support enable DENORMAL operands and results to be flushed, or forced to zero."},{"content":"The <ph id=\"ph1\">`_controlfp_s`</ph>, <ph id=\"ph2\">`_controlfp`</ph>, and <ph id=\"ph3\">`_control87`</ph> functions provide a mask to change this behavior.","pos":[4656,4756],"source":" The `_controlfp_s`, `_controlfp`, and `_control87` functions provide a mask to change this behavior."},{"content":"The following example demonstrates the use of this mask:","pos":[4757,4813]},{"content":"On ARM platforms, the <ph id=\"ph1\">`_controlfp_s`</ph> function applies to the FPSCR register.","pos":[5233,5309],"source":"On ARM platforms, the `_controlfp_s` function applies to the FPSCR register."},{"content":"On <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> architectures, only the SSE2 control word that's stored in the MXCSR register is affected.","pos":[5310,5470],"source":" On [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, only the SSE2 control word that's stored in the MXCSR register is affected."},{"content":"On Intel (x86) platforms, <ph id=\"ph1\">`_controlfp_s`</ph> affects the control words for both the x87 and the SSE2, if present.","pos":[5471,5580],"source":" On Intel (x86) platforms, `_controlfp_s` affects the control words for both the x87 and the SSE2, if present."},{"content":"It is possible for the two control words to be inconsistent with each other (because of a previous call to <bpt id=\"p1\">[</bpt>__control87_2<ept id=\"p1\">](../../c-runtime-library/reference/control87-controlfp-control87-2.md)</ept>, for example); if there is an inconsistency between the two control words, <ph id=\"ph1\">`_controlfp_s`</ph> sets the <ph id=\"ph2\">`EM_AMBIGUOUS`</ph> flag in <ph id=\"ph3\">`currentControl`</ph>.","pos":[5581,5913],"source":" It is possible for the two control words to be inconsistent with each other (because of a previous call to [__control87_2](../../c-runtime-library/reference/control87-controlfp-control87-2.md), for example); if there is an inconsistency between the two control words, `_controlfp_s` sets the `EM_AMBIGUOUS` flag in `currentControl`."},{"content":"This is a warning that the returned control word might not represent the state of both floating-point control words accurately.","pos":[5914,6041]},{"content":"On the ARM and <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> architectures, changing the infinity mode or the floating-point precision is not supported.","pos":[6048,6221],"source":"On the ARM and [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, changing the infinity mode or the floating-point precision is not supported."},{"content":"If the precision control mask is used on the <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> platform, the function raises an assertion and the invalid parameter handler is invoked, as described in <bpt id=\"p1\">[</bpt>Parameter Validation<ept id=\"p1\">](../../c-runtime-library/parameter-validation.md)</ept>.","pos":[6222,6511],"source":" If the precision control mask is used on the [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platform, the function raises an assertion and the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md)."},{"content":"If the mask is not set correctly, this function generates an invalid parameter exception, as described in <bpt id=\"p1\">[</bpt>Parameter Validation<ept id=\"p1\">](../../c-runtime-library/parameter-validation.md)</ept>.","pos":[6518,6696],"source":"If the mask is not set correctly, this function generates an invalid parameter exception, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md)."},{"content":"If execution is allowed to continue, this function returns <ph id=\"ph1\">`EINVAL`</ph> and sets <ph id=\"ph2\">`errno`</ph> to <ph id=\"ph3\">`EINVAL`</ph>.","pos":[6697,6794],"source":" If execution is allowed to continue, this function returns `EINVAL` and sets `errno` to `EINVAL`."},{"pos":[6801,7071],"content":"This function is ignored when you use <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../../build/reference/clr-common-language-runtime-compilation.md)</ept> or <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept> to compile because the common language runtime (CLR) only supports the default floating-point precision.","source":"This function is ignored when you use [/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md) or **/clr:pure** to compile because the common language runtime (CLR) only supports the default floating-point precision."},{"pos":[7078,7100],"content":"<bpt id=\"p1\">**</bpt>Hexadecimal Values<ept id=\"p1\">**</ept>","source":"**Hexadecimal Values**"},{"content":"For the <ph id=\"ph1\">`_MCW_EM`</ph> mask, clearing it sets the exception, which allows the hardware exception; setting it hides the exception.","pos":[7107,7231],"source":"For the `_MCW_EM` mask, clearing it sets the exception, which allows the hardware exception; setting it hides the exception."},{"content":"If a <ph id=\"ph1\">`_EM_UNDERFLOW`</ph> or <ph id=\"ph2\">`_EM_OVERFLOW`</ph> occurs, no hardware exception is thrown until the next floating-point instruction is executed.","pos":[7232,7365],"source":" If a `_EM_UNDERFLOW` or `_EM_OVERFLOW` occurs, no hardware exception is thrown until the next floating-point instruction is executed."},{"content":"To generate a hardware exception immediately after <ph id=\"ph1\">`_EM_UNDERFLOW`</ph> or <ph id=\"ph2\">`_EM_OVERFLOW`</ph>, call the FWAIT MASM instruction.","pos":[7366,7484],"source":" To generate a hardware exception immediately after `_EM_UNDERFLOW` or `_EM_OVERFLOW`, call the FWAIT MASM instruction."},{"content":"Mask","pos":[7491,7495]},{"content":"Hex value","pos":[7496,7505]},{"content":"Constant","pos":[7506,7514]},{"content":"Hex value","pos":[7515,7524]},{"pos":[7591,7619],"content":"<ph id=\"ph1\">`_MCW_DN`</ph> (Denormal control)","source":"`_MCW_DN` (Denormal control)"},{"content":"0x03000000","pos":[7620,7630]},{"content":"0x00000000","pos":[7666,7676]},{"content":"0x01000000","pos":[7689,7699]},{"pos":[7704,7740],"content":"<ph id=\"ph1\">`_MCW_EM`</ph> (Interrupt exception mask)","source":"`_MCW_EM` (Interrupt exception mask)"},{"content":"0x0008001F","pos":[7741,7751]},{"content":"0x00000010","pos":[7903,7913]},{"content":"0x00080000","pos":[7926,7936]},{"content":"0x00000008","pos":[7949,7959]},{"content":"0x00000004","pos":[7972,7982]},{"content":"0x00000002","pos":[7995,8005]},{"content":"0x00000001","pos":[8018,8028]},{"content":"<ph id=\"ph1\">`_MCW_IC`</ph> (Infinity control)","pos":[8033,8061],"source":"`_MCW_IC` (Infinity control)"},{"content":"(Not supported on ARM or <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> platforms.)","pos":[8074,8177],"source":" (Not supported on ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms.)"},{"content":"0x00040000","pos":[8178,8188]},{"content":"0x00040000","pos":[8231,8241]},{"content":"0x00000000","pos":[8254,8264]},{"pos":[8269,8297],"content":"<ph id=\"ph1\">`_MCW_RC`</ph> (Rounding control)","source":"`_MCW_RC` (Rounding control)"},{"content":"0x00000300","pos":[8298,8308]},{"content":"0x00000300","pos":[8387,8397]},{"content":"0x00000200","pos":[8410,8420]},{"content":"0x00000100","pos":[8433,8443]},{"content":"0x00000000","pos":[8456,8466]},{"content":"<ph id=\"ph1\">`_MCW_PC`</ph> (Precision control)","pos":[8471,8500],"source":"`_MCW_PC` (Precision control)"},{"content":"(Not supported on ARM or <ph id=\"ph1\">[!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]</ph> platforms.)","pos":[8513,8616],"source":" (Not supported on ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms.)"},{"content":"0x00030000","pos":[8617,8627]},{"content":"<ph id=\"ph1\">`_PC_24`</ph> (24 bits)","pos":[8628,8646],"source":"`_PC_24` (24 bits)"},{"content":"<ph id=\"ph1\">`_PC_53`</ph> (53 bits)","pos":[8659,8677],"source":"`_PC_53` (53 bits)"},{"content":"<ph id=\"ph1\">`_PC_64`</ph> (64 bits)","pos":[8690,8708],"source":"`_PC_64` (64 bits)"},{"content":"0x00020000","pos":[8709,8719]},{"content":"0x00010000","pos":[8732,8742]},{"content":"0x00000000","pos":[8755,8765]},{"pos":[8775,8787],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[8794,8801]},{"content":"Required header","pos":[8802,8817]},{"content":"<ph id=\"ph1\">\\&lt;</ph>float.h&gt;","pos":[8877,8887],"source":"\\<float.h>"},{"pos":[8895,9013],"content":"For more compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept> in the Introduction.","source":"For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction."},{"pos":[9022,9029],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[10236,10242],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"pos":[10437,10461],"content":"NET Framework Equivalent","linkify":"NET Framework Equivalent","nodes":[{"content":"NET Framework Equivalent","pos":[0,24]}]},{"content":"Not applicable.","pos":[10465,10480]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[10481,10528],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[10529,10654],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[10663,10671],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Floating-Point Support<ept id=\"p1\">](../../c-runtime-library/floating-point-support.md)</ept><ph id=\"ph1\"> </ph>","pos":[10675,10751],"source":"[Floating-Point Support](../../c-runtime-library/floating-point-support.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_clear87, _clearfp<ept id=\"p1\">](../../c-runtime-library/reference/clear87-clearfp.md)</ept><ph id=\"ph1\"> </ph>","pos":[10754,10830],"source":" [_clear87, _clearfp](../../c-runtime-library/reference/clear87-clearfp.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_status87, _statusfp, _statusfp2<ept id=\"p1\">](../../c-runtime-library/reference/status87-statusfp-statusfp2.md)</ept><ph id=\"ph1\"> </ph>","pos":[10833,10935],"source":" [_status87, _statusfp, _statusfp2](../../c-runtime-library/reference/status87-statusfp-statusfp2.md) "},{"content":"<bpt id=\"p1\"> [</bpt>_control87, _controlfp, <ph id=\"ph1\">\\_</ph>_control87_2<ept id=\"p1\">](../../c-runtime-library/reference/control87-controlfp-control87-2.md)</ept>","pos":[10938,11049],"source":" [_control87, _controlfp, \\__control87_2](../../c-runtime-library/reference/control87-controlfp-control87-2.md)"}],"content":"---\ntitle: \"_controlfp_s | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_controlfp_s\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\n  - \"api-ms-win-crt-runtime-l1-1-0.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"controlfp_s\"\n  - \"_controlfp_s\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"floating-point numbers, control word\"\n  - \"controlfp_s function\"\n  - \"floating-point functions, setting control word\"\n  - \"EM_AMBIGUOUS\"\n  - \"_controlfp_s function\"\nms.assetid: a51fc3f6-ab13-41f0-b227-6bf02d98e987\ncaps.latest.revision: 28\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _controlfp_s\nGets and sets the floating-point control word. This version of [_control87, _controlfp, \\__control87_2](../../c-runtime-library/reference/control87-controlfp-control87-2.md) has security enhancements, as described in [Security Features in the CRT](../../c-runtime-library/security-features-in-the-crt.md).  \n  \n## Syntax  \n  \n```  \nerrno_t _controlfp_s(  \n    unsigned int *currentControl,  \n    unsigned int newControl,  \n    unsigned int mask  \n);  \n```  \n  \n#### Parameters  \n `currentControl`  \n The current control-word bit value.  \n  \n `newControl`  \n New control-word bit values.  \n  \n `mask`  \n Mask for new control-word bits to set.  \n  \n## Return Value  \n Zero if successful, or an `errno` value error code.  \n  \n## Remarks  \n The `_controlfp_s` function is a platform-independent and more secure version of `_control87`, which gets the floating-point control word into the address that's stored in `currentControl` and sets it by using `newControl`. The bits in the values indicate the floating-point control state. The floating-point control state enables the program to change the precision, rounding, and infinity modes in the floating-point math package, depending on the platform. You can also use `_controlfp_s` to mask or unmask floating-point exceptions.  \n  \n If the value for `mask` is equal to 0, `_controlfp_s` gets the floating-point control word and stores the retrieved value in `currentControl`.  \n  \n If `mask` is nonzero, a new value for the control word is set: For any bit that is set (that is, equal to 1) in `mask`, the corresponding bit in `new` is used to update the control word. In other words, `fpcntrl` `=` ((`fpcntrl` `& ~mask`) &#124; (`new & mask`)) where `fpcntrl` is the floating-point control word. In this scenario, `currentControl` is set to the value after the change completes; it is not the old control-word bit value.  \n  \n> [!NOTE]\n>  By default, the run-time libraries mask all floating-point exceptions.  \n  \n `_controlfp_s` is nearly identical to the `_control87` function on Intel (x86), [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], and ARM platforms. If you are targeting x86, [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], or ARM platforms, you can use `_control87` or `_controlfp_s`.  \n  \n The difference between `_control87` and `_controlfp_s` is in how they treat `DENORMAL` values. For Intel (x86), [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)], and ARM platforms, `_control87` can set and clear the DENORMAL OPERAND exception mask. `_controlfp_s` does not modify the DENORMAL OPERAND exception mask. This example demonstrates the difference:  \n  \n```  \n_control87( _EM_INVALID, _MCW_EM );   \n// DENORMAL is unmasked by this call.  \nunsigned int current_word = 0;  \n_controlfp_s( &current_word, _EM_INVALID, _MCW_EM );   \n// DENORMAL exception mask remains unchanged.  \n```  \n  \n The possible values for the mask constant (`mask`) and new control values (`newControl`) are shown in the following Hexadecimal Values table. Use the portable constants listed below (`_MCW_EM`, `_EM_INVALID`, and so on) as arguments to these functions, rather than supplying the hexadecimal values explicitly.  \n  \n Intel (x86)-derived platforms support the DENORMAL input and output values in hardware. The x86 behavior is to preserve DENORMAL values. The ARM platform and the [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms that have SSE2 support enable DENORMAL operands and results to be flushed, or forced to zero. The `_controlfp_s`, `_controlfp`, and `_control87` functions provide a mask to change this behavior. The following example demonstrates the use of this mask:  \n  \n```  \nunsigned int current_word = 0;  \n_controlfp_s(&current_word, _DN_SAVE, _MCW_DN);     \n// Denormal values preserved on ARM platforms and on x64 processors with  \n// SSE2 support. NOP on x86 platforms.  \n_controlfp_s(&current_word, _DN_FLUSH, _MCW_DN);     \n// Denormal values flushed to zero by hardware on ARM platforms   \n// and x64 processors with SSE2 support. Ignored on other x86 platforms.  \n```  \n  \n On ARM platforms, the `_controlfp_s` function applies to the FPSCR register. On [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, only the SSE2 control word that's stored in the MXCSR register is affected. On Intel (x86) platforms, `_controlfp_s` affects the control words for both the x87 and the SSE2, if present. It is possible for the two control words to be inconsistent with each other (because of a previous call to [__control87_2](../../c-runtime-library/reference/control87-controlfp-control87-2.md), for example); if there is an inconsistency between the two control words, `_controlfp_s` sets the `EM_AMBIGUOUS` flag in `currentControl`. This is a warning that the returned control word might not represent the state of both floating-point control words accurately.  \n  \n On the ARM and [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] architectures, changing the infinity mode or the floating-point precision is not supported. If the precision control mask is used on the [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platform, the function raises an assertion and the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md).  \n  \n If the mask is not set correctly, this function generates an invalid parameter exception, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md). If execution is allowed to continue, this function returns `EINVAL` and sets `errno` to `EINVAL`.  \n  \n This function is ignored when you use [/clr (Common Language Runtime Compilation)](../../build/reference/clr-common-language-runtime-compilation.md) or **/clr:pure** to compile because the common language runtime (CLR) only supports the default floating-point precision.  \n  \n **Hexadecimal Values**  \n  \n For the `_MCW_EM` mask, clearing it sets the exception, which allows the hardware exception; setting it hides the exception. If a `_EM_UNDERFLOW` or `_EM_OVERFLOW` occurs, no hardware exception is thrown until the next floating-point instruction is executed. To generate a hardware exception immediately after `_EM_UNDERFLOW` or `_EM_OVERFLOW`, call the FWAIT MASM instruction.  \n  \n|Mask|Hex value|Constant|Hex value|  \n|----------|---------------|--------------|---------------|  \n|`_MCW_DN` (Denormal control)|0x03000000|`_DN_SAVE`<br /><br /> `_DN_FLUSH`|0x00000000<br /><br /> 0x01000000|  \n|`_MCW_EM` (Interrupt exception mask)|0x0008001F|`_EM_INVALID`<br /><br /> `_EM_DENORMAL`<br /><br /> `_EM_ZERODIVIDE`<br /><br /> `_EM_OVERFLOW`<br /><br /> `_EM_UNDERFLOW`<br /><br /> `_EM_INEXACT`|0x00000010<br /><br /> 0x00080000<br /><br /> 0x00000008<br /><br /> 0x00000004<br /><br /> 0x00000002<br /><br /> 0x00000001|  \n|`_MCW_IC` (Infinity control)<br /><br /> (Not supported on ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms.)|0x00040000|`_IC_AFFINE`<br /><br /> `_IC_PROJECTIVE`|0x00040000<br /><br /> 0x00000000|  \n|`_MCW_RC` (Rounding control)|0x00000300|`_RC_CHOP`<br /><br /> `_RC_UP`<br /><br /> `_RC_DOWN`<br /><br /> `_RC_NEAR`|0x00000300<br /><br /> 0x00000200<br /><br /> 0x00000100<br /><br /> 0x00000000|  \n|`_MCW_PC` (Precision control)<br /><br /> (Not supported on ARM or [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)] platforms.)|0x00030000|`_PC_24` (24 bits)<br /><br /> `_PC_53` (53 bits)<br /><br /> `_PC_64` (64 bits)|0x00020000<br /><br /> 0x00010000<br /><br /> 0x00000000|  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`_controlfp_s`|\\<float.h>|  \n  \n For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction.  \n  \n## Example  \n  \n```  \n  \n      // crt_contrlfp_s.c  \n// processor: x86  \n// This program uses _controlfp_s to output the FP control   \n// word, set the precision to 24 bits, and reset the status to   \n// the default.  \n//  \n  \n#include <stdio.h>  \n#include <float.h>  \n#pragma fenv_access (on)  \n  \nint main( void )  \n{  \n    double a = 0.1;  \n    unsigned int control_word;  \n    int err;  \n  \n    // Show original FP control word and do calculation.  \n    err = _controlfp_s(&control_word, 0, 0);  \n    if ( err ) /* handle error here */;  \n  \n    printf( \"Original: 0x%.4x\\n\", control_word );  \n    printf( \"%1.1f * %1.1f = %.15e\\n\", a, a, a * a );  \n  \n    // Set precision to 24 bits and recalculate.  \n    err = _controlfp_s(&control_word, _PC_24, MCW_PC);  \n    if ( err ) /* handle error here */;  \n  \n    printf( \"24-bit:   0x%.4x\\n\", control_word );  \n    printf( \"%1.1f * %1.1f = %.15e\\n\", a, a, a * a );  \n  \n    // Restore default precision-control bits and recalculate.  \n    err = _controlfp_s(&control_word, _CW_DEFAULT, MCW_PC);  \n    if ( err ) /* handle error here */;  \n  \n    printf( \"Default:  0x%.4x\\n\", control_word );  \n    printf( \"%1.1f * %1.1f = %.15e\\n\", a, a, a * a );  \n}  \n```  \n  \n## Output  \n  \n```  \nOriginal: 0x9001f  \n0.1 * 0.1 = 1.000000000000000e-002  \n24-bit:   0xa001f  \n0.1 * 0.1 = 9.999999776482582e-003  \nDefault:  0x9001f  \n0.1 * 0.1 = 1.000000000000000e-002  \n```  \n  \n## NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [Floating-Point Support](../../c-runtime-library/floating-point-support.md)   \n [_clear87, _clearfp](../../c-runtime-library/reference/clear87-clearfp.md)   \n [_status87, _statusfp, _statusfp2](../../c-runtime-library/reference/status87-statusfp-statusfp2.md)   \n [_control87, _controlfp, \\__control87_2](../../c-runtime-library/reference/control87-controlfp-control87-2.md)"}