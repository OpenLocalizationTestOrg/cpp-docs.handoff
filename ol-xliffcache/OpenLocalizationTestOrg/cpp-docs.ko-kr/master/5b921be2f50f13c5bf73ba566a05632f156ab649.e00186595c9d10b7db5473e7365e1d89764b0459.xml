{"nodes":[{"pos":[12,33],"content":"pack | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"pack | Microsoft Docs","pos":[0,21]}]},{"content":"pack","pos":[632,636]},{"content":"Specifies packing alignment for structure, union, and class members.","pos":[637,705]},{"content":"Syntax","pos":[714,720]},{"content":"Remarks","pos":[812,819]},{"content":"To pack a class is to place its members directly after each other in memory, which can mean that some or all members can be aligned on a boundary smaller than the default alignment the target architecture.","pos":[823,1028]},{"content":"gives control at the data-declaration level.","pos":[1036,1080]},{"content":"This differs from compiler option <bpt id=\"p1\">[</bpt>/Zp<ept id=\"p1\">](../build/reference/zp-struct-member-alignment.md)</ept>, which only provides module-level control.","pos":[1081,1213],"source":" This differs from compiler option [/Zp](../build/reference/zp-struct-member-alignment.md), which only provides module-level control."},{"content":"takes effect at the first <ph id=\"ph1\">`struct`</ph>, <ph id=\"ph2\">`union`</ph>, or <ph id=\"ph3\">`class`</ph> declaration after the pragma is seen.","pos":[1221,1314],"source":" takes effect at the first `struct`, `union`, or `class` declaration after the pragma is seen."},{"content":"has no effect on definitions.","pos":[1322,1351]},{"content":"Calling <ph id=\"ph1\">`pack`</ph> with no arguments sets <ph id=\"ph2\">`n`</ph> to the value set in the compiler option <bpt id=\"p1\">**</bpt>/Zp<ept id=\"p1\">**</ept>.","pos":[1352,1442],"source":" Calling `pack` with no arguments sets `n` to the value set in the compiler option **/Zp**."},{"content":"If the compiler option is not set, the default value is 8.","pos":[1443,1501]},{"content":"If you change the alignment of a structure, it may not use as much space in memory, but you may see a decrease in performance or even get a hardware-generated exception for unaligned access.","pos":[1508,1698]},{"content":"You can modify this exception behavior by using <bpt id=\"p1\">[</bpt>SetErrorMode<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms680621)</ept>.","pos":[1700,1823],"source":"  You can modify this exception behavior by using [SetErrorMode](http://msdn.microsoft.com/library/windows/desktop/ms680621)."},{"content":"<bpt id=\"p1\">**</bpt>show<ept id=\"p1\">**</ept> (optional)","pos":[1830,1849],"source":"**show** (optional)"},{"content":"Displays the current byte value for packing alignment.","pos":[1853,1907]},{"content":"The value is displayed by a warning message.","pos":[1908,1952]},{"content":"<bpt id=\"p1\">**</bpt>push<ept id=\"p1\">**</ept> (optional)","pos":[1959,1978],"source":"**push** (optional)"},{"content":"Pushes the current packing alignment value on the internal compiler stack, and sets the current packing alignment value to <ph id=\"ph1\">`n`</ph>.","pos":[1982,2109],"source":" Pushes the current packing alignment value on the internal compiler stack, and sets the current packing alignment value to `n`."},{"content":"If <ph id=\"ph1\">`n`</ph> is not specified, the current packing alignment value is pushed.","pos":[2110,2181],"source":" If `n` is not specified, the current packing alignment value is pushed."},{"content":"<bpt id=\"p1\">**</bpt>pop<ept id=\"p1\">**</ept> (optional)","pos":[2188,2206],"source":"**pop** (optional)"},{"content":"Removes the record from the top of the internal compiler stack.","pos":[2210,2273]},{"content":"If <ph id=\"ph1\">`n`</ph> is not specified with <bpt id=\"p1\">**</bpt>pop<ept id=\"p1\">**</ept>, then the packing value associated with the resulting record on the top of the stack is the new packing alignment value.","pos":[2274,2431],"source":" If `n` is not specified with **pop**, then the packing value associated with the resulting record on the top of the stack is the new packing alignment value."},{"content":"If <ph id=\"ph1\">`n`</ph> is specified, for example, <ph id=\"ph2\">`#pragma pack(pop, 16)`</ph>, <ph id=\"ph3\">`n`</ph> becomes the new packing alignment value.","pos":[2432,2535],"source":" If `n` is specified, for example, `#pragma pack(pop, 16)`, `n` becomes the new packing alignment value."},{"content":"If you pop with <ph id=\"ph1\">`identifier`</ph>, for example, <ph id=\"ph2\">`#pragma pack(pop, r1)`</ph>, then all records on the stack are popped until the record that has <ph id=\"ph3\">`identifier`</ph> is found.","pos":[2536,2693],"source":" If you pop with `identifier`, for example, `#pragma pack(pop, r1)`, then all records on the stack are popped until the record that has `identifier` is found."},{"content":"That record is popped and the packing value associated with the resulting record on the top of is the stack the new packing alignment value.","pos":[2694,2834]},{"content":"If you pop with an <ph id=\"ph1\">`identifier`</ph> that is not found in any record on the stack, then the <bpt id=\"p1\">**</bpt>pop<ept id=\"p1\">**</ept> is ignored.","pos":[2835,2941],"source":" If you pop with an `identifier` that is not found in any record on the stack, then the **pop** is ignored."},{"content":"(optional)","pos":[2961,2971]},{"content":"When used with <bpt id=\"p1\">**</bpt>push<ept id=\"p1\">**</ept>, assigns a name to the record on the internal compiler stack.","pos":[2975,3060],"source":" When used with **push**, assigns a name to the record on the internal compiler stack."},{"content":"When used with <bpt id=\"p1\">**</bpt>pop<ept id=\"p1\">**</ept>, pops records off the internal stack until <ph id=\"ph1\">`identifier`</ph> is removed; if <ph id=\"ph2\">`identifier`</ph> is not found on the internal stack, nothing is popped.","pos":[3061,3222],"source":" When used with **pop**, pops records off the internal stack until `identifier` is removed; if `identifier` is not found on the internal stack, nothing is popped."},{"content":"(optional)","pos":[3233,3243]},{"content":"Specifies the value, in bytes, to be used for packing.","pos":[3247,3301]},{"content":"If the compiler option <bpt id=\"p1\">[</bpt>/Zp<ept id=\"p1\">](../build/reference/zp-struct-member-alignment.md)</ept> is not set for the module, the default value for <ph id=\"ph1\">`n`</ph> is 8.","pos":[3302,3439],"source":" If the compiler option [/Zp](../build/reference/zp-struct-member-alignment.md) is not set for the module, the default value for `n` is 8."},{"content":"Valid values are 1, 2, 4, 8, and 16.","pos":[3440,3476]},{"content":"The alignment of a member will be on a boundary that is either a multiple of <ph id=\"ph1\">`n`</ph> or a multiple of the size of the member, whichever is smaller.","pos":[3477,3620],"source":" The alignment of a member will be on a boundary that is either a multiple of `n` or a multiple of the size of the member, whichever is smaller."},{"pos":[3673,3686],"content":"is undefined."},{"content":"For more information about how to modify alignment, see these topics:","pos":[3693,3762]},{"content":"__alignof","pos":[3773,3782]},{"content":"align","pos":[3822,3827]},{"content":"__unaligned","pos":[3860,3871]},{"pos":[3903,3996],"content":"<bpt id=\"p1\">[</bpt>Examples of Structure Alignment<ept id=\"p1\">](../build/examples-of-structure-alignment.md)</ept> (x64 specific)","source":"[Examples of Structure Alignment](../build/examples-of-structure-alignment.md) (x64 specific)"},{"pos":[4008,4399],"content":"[!WARNING]\n Note that in Visual Studio 2015 and later you can use the standard alignas and alignof operators which, unlike `__alignof` and `declspec( align )` are portable across compilers. The C++ standard does not address packing, so you must still use `pack` (or the corresponding extension on other compilers) to specify alignments smaller than the target architecture’s word size.","leadings":["","    > "],"nodes":[{"content":" Note that in Visual Studio 2015 and later you can use the standard alignas and alignof operators which, unlike `__alignof` and `declspec( align )` are portable across compilers. The C++ standard does not address packing, so you must still use `pack` (or the corresponding extension on other compilers) to specify alignments smaller than the target architecture’s word size.","pos":[11,385],"nodes":[{"content":"Note that in Visual Studio 2015 and later you can use the standard alignas and alignof operators which, unlike <ph id=\"ph1\">`__alignof`</ph> and <ph id=\"ph2\">`declspec( align )`</ph> are portable across compilers.","pos":[1,178],"source":" Note that in Visual Studio 2015 and later you can use the standard alignas and alignof operators which, unlike `__alignof` and `declspec( align )` are portable across compilers."},{"content":"The C++ standard does not address packing, so you must still use <ph id=\"ph1\">`pack`</ph> (or the corresponding extension on other compilers) to specify alignments smaller than the target architecture’s word size.","pos":[179,374],"source":" The C++ standard does not address packing, so you must still use `pack` (or the corresponding extension on other compilers) to specify alignments smaller than the target architecture’s word size."}]}]},{"content":"Example","pos":[4408,4415]},{"pos":[4419,4514],"content":"The following sample shows how to use the <ph id=\"ph1\">`pack`</ph> pragma to change the alignment of a structure.","source":"The following sample shows how to use the `pack` pragma to change the alignment of a structure."},{"content":"Example","pos":[5071,5078]},{"pos":[5082,5163],"content":"The following sample shows how to use the <bpt id=\"p1\">**</bpt>push<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>pop<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>show<ept id=\"p3\">**</ept> syntax.","source":"The following sample shows how to use the **push**, **pop**, and **show** syntax."},{"content":"See Also","pos":[5573,5581]},{"content":"Pragma Directives and the __Pragma Keyword","pos":[5586,5628]}],"content":"---\ntitle: \"pack | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"pack_CPP\"\n  - \"vc-pragma.pack\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"pragmas, pack\"\n  - \"pack pragma\"\nms.assetid: e4209cbb-5437-4b53-b3fe-ac264501d404\ncaps.latest.revision: 18\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# pack\nSpecifies packing alignment for structure, union, and class members.  \n  \n## Syntax  \n  \n```  \n  \n#pragma pack( [ show ] | [ push | pop ] [, identifier ] , n  )  \n```  \n  \n## Remarks  \n To pack a class is to place its members directly after each other in memory, which can mean that some or all members can be aligned on a boundary smaller than the default alignment the target architecture. `pack` gives control at the data-declaration level. This differs from compiler option [/Zp](../build/reference/zp-struct-member-alignment.md), which only provides module-level control. `pack` takes effect at the first `struct`, `union`, or `class` declaration after the pragma is seen. `pack` has no effect on definitions. Calling `pack` with no arguments sets `n` to the value set in the compiler option **/Zp**. If the compiler option is not set, the default value is 8.  \n  \n If you change the alignment of a structure, it may not use as much space in memory, but you may see a decrease in performance or even get a hardware-generated exception for unaligned access.  You can modify this exception behavior by using [SetErrorMode](http://msdn.microsoft.com/library/windows/desktop/ms680621).  \n  \n **show** (optional)  \n Displays the current byte value for packing alignment. The value is displayed by a warning message.  \n  \n **push** (optional)  \n Pushes the current packing alignment value on the internal compiler stack, and sets the current packing alignment value to `n`. If `n` is not specified, the current packing alignment value is pushed.  \n  \n **pop** (optional)  \n Removes the record from the top of the internal compiler stack. If `n` is not specified with **pop**, then the packing value associated with the resulting record on the top of the stack is the new packing alignment value. If `n` is specified, for example, `#pragma pack(pop, 16)`, `n` becomes the new packing alignment value. If you pop with `identifier`, for example, `#pragma pack(pop, r1)`, then all records on the stack are popped until the record that has `identifier` is found. That record is popped and the packing value associated with the resulting record on the top of is the stack the new packing alignment value. If you pop with an `identifier` that is not found in any record on the stack, then the **pop** is ignored.  \n  \n `identifier` (optional)  \n When used with **push**, assigns a name to the record on the internal compiler stack. When used with **pop**, pops records off the internal stack until `identifier` is removed; if `identifier` is not found on the internal stack, nothing is popped.  \n  \n `n` (optional)  \n Specifies the value, in bytes, to be used for packing. If the compiler option [/Zp](../build/reference/zp-struct-member-alignment.md) is not set for the module, the default value for `n` is 8. Valid values are 1, 2, 4, 8, and 16. The alignment of a member will be on a boundary that is either a multiple of `n` or a multiple of the size of the member, whichever is smaller.  \n  \n `#pragma pack(pop,` `identifier` `,`  `n` `)` is undefined.  \n  \n For more information about how to modify alignment, see these topics:  \n  \n-   [__alignof](../cpp/alignof-operator.md)  \n  \n-   [align](../cpp/align-cpp.md)  \n  \n-   [__unaligned](../cpp/unaligned.md)  \n  \n-   [Examples of Structure Alignment](../build/examples-of-structure-alignment.md) (x64 specific)  \n  \n    > [!WARNING]\n    >  Note that in Visual Studio 2015 and later you can use the standard alignas and alignof operators which, unlike `__alignof` and `declspec( align )` are portable across compilers. The C++ standard does not address packing, so you must still use `pack` (or the corresponding extension on other compilers) to specify alignments smaller than the target architecture’s word size.  \n  \n## Example  \n The following sample shows how to use the `pack` pragma to change the alignment of a structure.  \n  \n```  \n// pragma_directives_pack.cpp  \n#include <stddef.h>  \n#include <stdio.h>  \n  \nstruct S {  \n   int i;   // size 4  \n   short j;   // size 2  \n   double k;   // size 8  \n};  \n  \n#pragma pack(2)  \nstruct T {  \n   int i;  \n   short j;  \n   double k;  \n};  \n  \nint main() {  \n   printf(\"%zu \", offsetof(S, i));  \n   printf(\"%zu \", offsetof(S, j));  \n   printf(\"%zu\\n\", offsetof(S, k));  \n  \n   printf(\"%zu \", offsetof(T, i));  \n   printf(\"%zu \", offsetof(T, j));  \n   printf(\"%zu\\n\", offsetof(T, k));  \n}  \n```  \n  \n```  \n0 4 8  \n0 4 6  \n```  \n  \n## Example  \n The following sample shows how to use the **push**, **pop**, and **show** syntax.  \n  \n```  \n// pragma_directives_pack_2.cpp  \n// compile with: /W1 /c  \n#pragma pack()   // n defaults to 8; equivalent to /Zp8  \n#pragma pack(show)   // C4810  \n#pragma pack(4)   // n = 4  \n#pragma pack(show)   // C4810  \n#pragma pack(push, r1, 16)   // n = 16, pushed to stack  \n#pragma pack(show)   // C4810  \n#pragma pack(pop, r1, 2)   // n = 2 , stack popped  \n#pragma pack(show)   // C4810  \n```  \n  \n## See Also  \n [Pragma Directives and the __Pragma Keyword](../preprocessor/pragma-directives-and-the-pragma-keyword.md)"}