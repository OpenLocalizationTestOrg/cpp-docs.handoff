{"nodes":[{"pos":[12,49],"content":"numeric_limits Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"numeric_limits Class | Microsoft Docs","pos":[0,37]}]},{"pos":[698,718],"content":"numeric_limits Class","linkify":"numeric_limits Class","nodes":[{"content":"numeric_limits Class","pos":[0,20]}]},{"content":"The template class describes arithmetic properties of built-in numerical types.","pos":[719,798]},{"pos":[807,813],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[886,896],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The fundamental element data type whose properties are being tested or queried or set.","pos":[910,996]},{"pos":[1005,1012],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The header defines explicit specializations for the types <ph id=\"ph1\">`wchar_t`</ph>, <ph id=\"ph2\">`bool`</ph>, <ph id=\"ph3\">`char`</ph>, <ph id=\"ph4\">`signed char`</ph>, <ph id=\"ph5\">`unsigned char`</ph>, <ph id=\"ph6\">`short`</ph>, <ph id=\"ph7\">`unsigned short`</ph>, <ph id=\"ph8\">`int`</ph>, <ph id=\"ph9\">`unsigned int`</ph>, <ph id=\"ph10\">`long`</ph>, <ph id=\"ph11\">`unsigned long`</ph>, <ph id=\"ph12\">`float`</ph>, <ph id=\"ph13\">`double`</ph>, <ph id=\"ph14\">`long double`</ph><bpt id=\"p1\">**</bpt>,<ept id=\"p1\">**</ept> <ph id=\"ph15\">`long long`</ph>, <ph id=\"ph16\">`unsigned long long`</ph>, <ph id=\"ph17\">`char16_t`</ph>, and <ph id=\"ph18\">`char32_t`</ph>.","pos":[1016,1308],"source":"The header defines explicit specializations for the types `wchar_t`, `bool`, `char`, `signed char`, `unsigned char`, `short`, `unsigned short`, `int`, `unsigned int`, `long`, `unsigned long`, `float`, `double`, `long double`**,** `long long`, `unsigned long long`, `char16_t`, and `char32_t`."},{"content":"For these explicit specializations, the member <bpt id=\"p1\">[</bpt>numeric_limits::is_specialized<ept id=\"p1\">](#numeric_limits__is_specialized)</ept> is <ph id=\"ph1\">`true`</ph>, and all relevant members have meaningful values.","pos":[1309,1481],"source":" For these explicit specializations, the member [numeric_limits::is_specialized](#numeric_limits__is_specialized) is `true`, and all relevant members have meaningful values."},{"content":"The program can supply additional explicit specializations.","pos":[1482,1541]},{"content":"Most member functions of the class describe or test possible implementations of <ph id=\"ph1\">`float`</ph>.","pos":[1542,1630],"source":" Most member functions of the class describe or test possible implementations of `float`."},{"content":"For an arbitrary specialization, no members have meaningful values.","pos":[1637,1704]},{"content":"A member object that does not have a meaningful value stores zero (or <ph id=\"ph1\">`false`</ph>) and a member function that does not return a meaningful value returns <ph id=\"ph2\">`Type(0)`</ph>.","pos":[1705,1864],"source":" A member object that does not have a meaningful value stores zero (or `false`) and a member function that does not return a meaningful value returns `Type(0)`."},{"pos":[1874,1904],"content":"Static Functions and Constants","linkify":"Static Functions and Constants","nodes":[{"content":"Static Functions and Constants","pos":[0,30]}]},{"pos":[1925,1966],"content":"<bpt id=\"p1\">[</bpt>denorm_min<ept id=\"p1\">](#numeric_limits__denorm_min)</ept>","source":"[denorm_min](#numeric_limits__denorm_min)"},{"content":"Returns the smallest nonzero denormalized value.","pos":[1967,2015]},{"pos":[2020,2053],"content":"<bpt id=\"p1\">[</bpt>digits<ept id=\"p1\">](#numeric_limits__digits)</ept>","source":"[digits](#numeric_limits__digits)"},{"content":"Returns the number of radix digits that the type can represent without loss of precision.","pos":[2054,2143]},{"pos":[2148,2185],"content":"<bpt id=\"p1\">[</bpt>digits10<ept id=\"p1\">](#numeric_limits__digits10)</ept>","source":"[digits10](#numeric_limits__digits10)"},{"content":"Returns the number of decimal digits that the type can represent without loss of precision.","pos":[2186,2277]},{"pos":[2282,2317],"content":"<bpt id=\"p1\">[</bpt>epsilon<ept id=\"p1\">](#numeric_limits__epsilon)</ept>","source":"[epsilon](#numeric_limits__epsilon)"},{"content":"Returns the difference between 1 and the smallest value greater than 1 that the data type can represent.","pos":[2318,2422]},{"pos":[2427,2468],"content":"<bpt id=\"p1\">[</bpt>has_denorm<ept id=\"p1\">](#numeric_limits__has_denorm)</ept>","source":"[has_denorm](#numeric_limits__has_denorm)"},{"content":"Tests whether a type allows denormalized values.","pos":[2469,2517]},{"pos":[2522,2573],"content":"<bpt id=\"p1\">[</bpt>has_denorm_loss<ept id=\"p1\">](#numeric_limits__has_denorm_loss)</ept>","source":"[has_denorm_loss](#numeric_limits__has_denorm_loss)"},{"content":"Tests whether loss of accuracy is detected as a denormalization loss rather than as an inexact result.","pos":[2574,2676]},{"pos":[2681,2726],"content":"<bpt id=\"p1\">[</bpt>has_infinity<ept id=\"p1\">](#numeric_limits__has_infinity)</ept>","source":"[has_infinity](#numeric_limits__has_infinity)"},{"content":"Tests whether a type has a representation for positive infinity.","pos":[2727,2791]},{"pos":[2796,2843],"content":"<bpt id=\"p1\">[</bpt>has_quiet_NaN<ept id=\"p1\">](#numeric_limits__has_quiet_nan)</ept>","source":"[has_quiet_NaN](#numeric_limits__has_quiet_nan)"},{"content":"Tests whether a type has a representation for a quiet not a number (NAN), which is nonsignaling.","pos":[2844,2940]},{"pos":[2945,3000],"content":"<bpt id=\"p1\">[</bpt>has_signaling_NaN<ept id=\"p1\">](#numeric_limits__has_signaling_nan)</ept>","source":"[has_signaling_NaN](#numeric_limits__has_signaling_nan)"},{"content":"Tests whether a type has a representation for signaling not a number (NAN).","pos":[3001,3076]},{"pos":[3081,3118],"content":"<bpt id=\"p1\">[</bpt>infinity<ept id=\"p1\">](#numeric_limits__infinity)</ept>","source":"[infinity](#numeric_limits__infinity)"},{"content":"The representation for positive infinity for a type, if available.","pos":[3119,3185]},{"pos":[3190,3231],"content":"<bpt id=\"p1\">[</bpt>is_bounded<ept id=\"p1\">](#numeric_limits__is_bounded)</ept>","source":"[is_bounded](#numeric_limits__is_bounded)"},{"content":"Tests if the set of values that a type may represent is finite.","pos":[3232,3295]},{"pos":[3300,3337],"content":"<bpt id=\"p1\">[</bpt>is_exact<ept id=\"p1\">](#numeric_limits__is_exact)</ept>","source":"[is_exact](#numeric_limits__is_exact)"},{"content":"Tests if the calculations done on a type are free of rounding errors.","pos":[3338,3407]},{"pos":[3412,3451],"content":"<bpt id=\"p1\">[</bpt>is_iec559<ept id=\"p1\">](#numeric_limits__is_iec559)</ept>","source":"[is_iec559](#numeric_limits__is_iec559)"},{"content":"Tests if a type conforms to IEC 559 standards.","pos":[3452,3498]},{"pos":[3503,3544],"content":"<bpt id=\"p1\">[</bpt>is_integer<ept id=\"p1\">](#numeric_limits__is_integer)</ept>","source":"[is_integer](#numeric_limits__is_integer)"},{"content":"Tests if a type has an integer representation.","pos":[3545,3591]},{"pos":[3596,3635],"content":"<bpt id=\"p1\">[</bpt>is_modulo<ept id=\"p1\">](#numeric_limits__is_modulo)</ept>","source":"[is_modulo](#numeric_limits__is_modulo)"},{"content":"Tests if a type has a modulo representation.","pos":[3636,3680]},{"pos":[3685,3724],"content":"<bpt id=\"p1\">[</bpt>is_signed<ept id=\"p1\">](#numeric_limits__is_signed)</ept>","source":"[is_signed](#numeric_limits__is_signed)"},{"content":"Tests if a type has a signed representation.","pos":[3725,3769]},{"pos":[3774,3823],"content":"<bpt id=\"p1\">[</bpt>is_specialized<ept id=\"p1\">](#numeric_limits__is_specialized)</ept>","source":"[is_specialized](#numeric_limits__is_specialized)"},{"pos":[3824,3918],"content":"Tests if a type has an explicit specialization defined in the template class <ph id=\"ph1\">`numeric_limits`</ph>.","source":"Tests if a type has an explicit specialization defined in the template class `numeric_limits`."},{"pos":[3923,3956],"content":"<bpt id=\"p1\">[</bpt>lowest<ept id=\"p1\">](#numeric_limits__lowest)</ept>","source":"[lowest](#numeric_limits__lowest)"},{"content":"Returns the most negative finite value.","pos":[3957,3996]},{"pos":[4001,4028],"content":"<bpt id=\"p1\">[</bpt>max<ept id=\"p1\">](#numeric_limits__max)</ept>","source":"[max](#numeric_limits__max)"},{"content":"Returns the maximum finite value for a type.","pos":[4029,4073]},{"pos":[4078,4123],"content":"<bpt id=\"p1\">[</bpt>max_digits10<ept id=\"p1\">](#numeric_limits__max_digits10)</ept>","source":"[max_digits10](#numeric_limits__max_digits10)"},{"content":"Returns the number of decimal digits required to ensure that two distinct values of the type have distinct decimal representations.","pos":[4124,4255]},{"pos":[4260,4305],"content":"<bpt id=\"p1\">[</bpt>max_exponent<ept id=\"p1\">](#numeric_limits__max_exponent)</ept>","source":"[max_exponent](#numeric_limits__max_exponent)"},{"content":"Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.","pos":[4306,4459]},{"pos":[4464,4513],"content":"<bpt id=\"p1\">[</bpt>max_exponent10<ept id=\"p1\">](#numeric_limits__max_exponent10)</ept>","source":"[max_exponent10](#numeric_limits__max_exponent10)"},{"content":"Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.","pos":[4514,4665]},{"pos":[4670,4697],"content":"<bpt id=\"p1\">[</bpt>min<ept id=\"p1\">](#numeric_limits__min)</ept>","source":"[min](#numeric_limits__min)"},{"content":"Returns the minimum normalized value for a type.","pos":[4698,4746]},{"pos":[4751,4796],"content":"<bpt id=\"p1\">[</bpt>min_exponent<ept id=\"p1\">](#numeric_limits__min_exponent)</ept>","source":"[min_exponent](#numeric_limits__min_exponent)"},{"content":"Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.","pos":[4797,4950]},{"pos":[4955,5004],"content":"<bpt id=\"p1\">[</bpt>min_exponent10<ept id=\"p1\">](#numeric_limits__min_exponent10)</ept>","source":"[min_exponent10](#numeric_limits__min_exponent10)"},{"content":"Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.","pos":[5005,5156]},{"pos":[5161,5200],"content":"<bpt id=\"p1\">[</bpt>quiet_NaN<ept id=\"p1\">](#numeric_limits__quiet_nan)</ept>","source":"[quiet_NaN](#numeric_limits__quiet_nan)"},{"content":"Returns the representation of a quiet not a number (NAN) for the type.","pos":[5201,5271]},{"pos":[5276,5307],"content":"<bpt id=\"p1\">[</bpt>radix<ept id=\"p1\">](#numeric_limits__radix)</ept>","source":"[radix](#numeric_limits__radix)"},{"content":"Returns the integral base, referred to as radix, used for the representation of a type.","pos":[5308,5395]},{"pos":[5400,5443],"content":"<bpt id=\"p1\">[</bpt>round_error<ept id=\"p1\">](#numeric_limits__round_error)</ept>","source":"[round_error](#numeric_limits__round_error)"},{"content":"Returns the maximum rounding error for the type.","pos":[5444,5492]},{"pos":[5497,5540],"content":"<bpt id=\"p1\">[</bpt>round_style<ept id=\"p1\">](#numeric_limits__round_style)</ept>","source":"[round_style](#numeric_limits__round_style)"},{"content":"Returns a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.","pos":[5541,5682]},{"pos":[5687,5734],"content":"<bpt id=\"p1\">[</bpt>signaling_NaN<ept id=\"p1\">](#numeric_limits__signaling_nan)</ept>","source":"[signaling_NaN](#numeric_limits__signaling_nan)"},{"content":"Returns the representation of a signaling not a number (NAN) for the type.","pos":[5735,5809]},{"pos":[5814,5865],"content":"<bpt id=\"p1\">[</bpt>tinyness_before<ept id=\"p1\">](#numeric_limits__tinyness_before)</ept>","source":"[tinyness_before](#numeric_limits__tinyness_before)"},{"content":"Tests whether a type can determine that a value is too small to represent as a normalized value before rounding it.","pos":[5866,5981]},{"pos":[5986,6017],"content":"<bpt id=\"p1\">[</bpt>traps<ept id=\"p1\">](#numeric_limits__traps)</ept>","source":"[traps](#numeric_limits__traps)"},{"content":"Tests whether trapping that reports on arithmetic exceptions is implemented for a type.","pos":[6018,6105]},{"pos":[6115,6127],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[6131,6152],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>limits&gt;","source":"**Header:** \\<limits>"},{"pos":[6159,6177],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[6187,6256],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__denorm_min\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::denorm_min","linkify":"<a name=\"numeric_limits__denorm_min\"></a>  numeric_limits::denorm_min","source":"<a name=\"numeric_limits__denorm_min\"></a>  numeric_limits::denorm_min"},{"content":"Returns the smallest nonzero denormalized value.","pos":[6260,6308]},{"pos":[6367,6379],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The smallest nonzero denormalized value.","pos":[6383,6423]},{"pos":[6433,6440],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6444,6505],"content":"<ph id=\"ph1\">`long double`</ph> is the same as <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept> for the C++ compiler.","source":"`long double` is the same as **double** for the C++ compiler."},{"pos":[6512,6694],"content":"The function returns the minimum value for the type, which is the same as <bpt id=\"p1\">[</bpt>min<ept id=\"p1\">](#numeric_limits__min)</ept> if <bpt id=\"p2\">[</bpt>has_denorm<ept id=\"p2\">](#numeric_limits__has_denorm)</ept> is not equal to <bpt id=\"p3\">**</bpt>denorm_present<ept id=\"p3\">**</ept>.","source":"The function returns the minimum value for the type, which is the same as [min](#numeric_limits__min) if [has_denorm](#numeric_limits__has_denorm) is not equal to **denorm_present**."},{"pos":[6704,6711],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[7886,7947],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__digits\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::digits","linkify":"<a name=\"numeric_limits__digits\"></a>  numeric_limits::digits","source":"<a name=\"numeric_limits__digits\"></a>  numeric_limits::digits"},{"content":"Returns the number of radix digits that the type can represent without loss of precision.","pos":[7951,8040]},{"pos":[8096,8108],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The number of radix digits that the type can represent without loss of precision.","pos":[8112,8193]},{"pos":[8203,8210],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member stores the number of radix digits that the type can represent without change, which is the number of bits other than any sign bit for a predefined integer type, or the number of mantissa digits for a predefined floating-point type.","pos":[8214,8456]},{"pos":[8466,8473],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[8962,9027],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__digits10\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::digits10","linkify":"<a name=\"numeric_limits__digits10\"></a>  numeric_limits::digits10","source":"<a name=\"numeric_limits__digits10\"></a>  numeric_limits::digits10"},{"content":"Returns the number of decimal digits that the type can represent without loss of precision.","pos":[9031,9122]},{"pos":[9180,9192],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The number of decimal digits that the type can represent without loss of precision.","pos":[9196,9279]},{"pos":[9289,9296],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9921,9984],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__epsilon\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::epsilon","linkify":"<a name=\"numeric_limits__epsilon\"></a>  numeric_limits::epsilon","source":"<a name=\"numeric_limits__epsilon\"></a>  numeric_limits::epsilon"},{"content":"The function returns the difference between 1 and the smallest value greater than 1 that is representable for the data type.","pos":[9988,10112]},{"pos":[10168,10180],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The difference between 1 and the smallest value greater than 1 that is representable for the data type.","pos":[10184,10287]},{"pos":[10297,10304],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The value is FLT_EPSILON for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[10308,10352],"source":"The value is FLT_EPSILON for type **float**."},{"content":"<ph id=\"ph1\">`epsilon`</ph> for a type is the smallest positive floating-point number <bpt id=\"p1\">*</bpt>N<ept id=\"p1\">*</ept> such that <bpt id=\"p2\">*</bpt>N<ept id=\"p2\">*</ept><ph id=\"ph2\"> + </ph><ph id=\"ph3\">`epsilon`</ph><ph id=\"ph4\"> + </ph><bpt id=\"p3\">*</bpt>N<ept id=\"p3\">*</ept> is representable.","pos":[10353,10474],"source":"`epsilon` for a type is the smallest positive floating-point number *N* such that *N* + `epsilon` + *N* is representable."},{"pos":[10484,10491],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[11581,11650],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__has_denorm\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::has_denorm","linkify":"<a name=\"numeric_limits__has_denorm\"></a>  numeric_limits::has_denorm","source":"<a name=\"numeric_limits__has_denorm\"></a>  numeric_limits::has_denorm"},{"content":"Tests whether a type allows denormalized values.","pos":[11654,11702]},{"pos":[11789,11801],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[11805,11920],"content":"An enumeration value of type <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept><ph id=\"ph1\">`float_denorm_style`</ph>, indicating whether the type allows denormalized values.","source":"An enumeration value of type **const**`float_denorm_style`, indicating whether the type allows denormalized values."},{"pos":[11930,11937],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[11941,12081],"content":"The member stores <bpt id=\"p1\">**</bpt>denorm_present<ept id=\"p1\">**</ept> for a floating-point type that has denormalized values, effectively a variable number of exponent bits.","source":"The member stores **denorm_present** for a floating-point type that has denormalized values, effectively a variable number of exponent bits."},{"pos":[12091,12098],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[12868,12947],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__has_denorm_loss\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::has_denorm_loss","linkify":"<a name=\"numeric_limits__has_denorm_loss\"></a>  numeric_limits::has_denorm_loss","source":"<a name=\"numeric_limits__has_denorm_loss\"></a>  numeric_limits::has_denorm_loss"},{"content":"Tests whether loss of accuracy is detected as a denormalization loss rather than as an inexact result.","pos":[12951,13053]},{"pos":[13123,13135],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[13139,13228],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the loss of accuracy is detected as a denormalization loss; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the loss of accuracy is detected as a denormalization loss; **false** if not."},{"pos":[13238,13245],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member stores true for a type that determines whether a value has lost accuracy because it is delivered as a denormalized result (too small to represent as a normalized value) or because it is inexact (not the same as a result not subject to limitations of exponent range and precision), an option with IEC 559 floating-point representations that can affect some results.","pos":[13249,13624]},{"pos":[13634,13641],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[14446,14519],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__has_infinity\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::has_infinity","linkify":"<a name=\"numeric_limits__has_infinity\"></a>  numeric_limits::has_infinity","source":"<a name=\"numeric_limits__has_infinity\"></a>  numeric_limits::has_infinity"},{"content":"Tests whether a type has a representation for positive infinity.","pos":[14523,14587]},{"pos":[14654,14666],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[14670,14752],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has a representation for positive infinity; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has a representation for positive infinity; **false** if not."},{"pos":[14762,14769],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[14773,14856],"content":"The member returns <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if <bpt id=\"p2\">[</bpt>is_iec559<ept id=\"p2\">](#numeric_limits__is_iec559)</ept> is <bpt id=\"p3\">**</bpt>true<ept id=\"p3\">**</ept>.","source":"The member returns **true** if [is_iec559](#numeric_limits__is_iec559) is **true**."},{"pos":[14866,14873],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[15576,15651],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__has_quiet_nan\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::has_quiet_NaN","linkify":"<a name=\"numeric_limits__has_quiet_nan\"></a>  numeric_limits::has_quiet_NaN","source":"<a name=\"numeric_limits__has_quiet_nan\"></a>  numeric_limits::has_quiet_NaN"},{"content":"Tests whether a type has a representation for a quiet not a number (NAN), which is nonsignaling.","pos":[15655,15751]},{"pos":[15819,15831],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[15835,15915],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the <bpt id=\"p2\">**</bpt>type<ept id=\"p2\">**</ept> has a representation for a quiet NAN; <bpt id=\"p3\">**</bpt>false<ept id=\"p3\">**</ept> if not.","source":"**true** if the **type** has a representation for a quiet NAN; **false** if not."},{"pos":[15925,15932],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"A quiet NAN is an encoding for not a number, which does not signal its presence in an expression.","pos":[15936,16033]},{"content":"The return value is <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if <bpt id=\"p2\">[</bpt>is_iec559<ept id=\"p2\">](#numeric_limits__is_iec559)</ept> is true.","pos":[16034,16114],"source":" The return value is **true** if [is_iec559](#numeric_limits__is_iec559) is true."},{"pos":[16124,16131],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[16847,16930],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__has_signaling_nan\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::has_signaling_NaN","linkify":"<a name=\"numeric_limits__has_signaling_nan\"></a>  numeric_limits::has_signaling_NaN","source":"<a name=\"numeric_limits__has_signaling_nan\"></a>  numeric_limits::has_signaling_NaN"},{"content":"Tests whether a type has a representation for signaling not a number (NAN).","pos":[16934,17009]},{"pos":[17081,17093],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[17097,17177],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has a representation for a signaling NAN; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has a representation for a signaling NAN; **false** if not."},{"pos":[17187,17194],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"A signaling NAN is an encoding for not a number, which signals its presence in an expression.","pos":[17198,17291]},{"content":"The return value is <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept><bpt id=\"p2\">[</bpt>is_iec559<ept id=\"p2\">](#numeric_limits__is_iec559)</ept> is true.","pos":[17292,17368],"source":" The return value is **true**[is_iec559](#numeric_limits__is_iec559) is true."},{"pos":[17378,17385],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[18153,18218],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__infinity\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::infinity","linkify":"<a name=\"numeric_limits__infinity\"></a>  numeric_limits::infinity","source":"<a name=\"numeric_limits__infinity\"></a>  numeric_limits::infinity"},{"content":"The representation of positive infinity for a type, if available.","pos":[18222,18287]},{"pos":[18344,18356],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The representation of positive infinity for a type, if available.","pos":[18360,18425]},{"pos":[18435,18442],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[18446,18543],"content":"The return value is meaningful only if <bpt id=\"p1\">[</bpt>has_infinity<ept id=\"p1\">](#numeric_limits__has_infinity)</ept> is <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>.","source":"The return value is meaningful only if [has_infinity](#numeric_limits__has_infinity) is **true**."},{"pos":[18553,18560],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[19638,19707],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__is_bounded\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::is_bounded","linkify":"<a name=\"numeric_limits__is_bounded\"></a>  numeric_limits::is_bounded","source":"<a name=\"numeric_limits__is_bounded\"></a>  numeric_limits::is_bounded"},{"content":"Tests if the set of values that a type may represent is finite.","pos":[19711,19774]},{"pos":[19839,19851],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[19855,19936],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has a bounded set of representable values; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has a bounded set of representable values; **false** if not."},{"pos":[19946,19953],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[19957,20041],"content":"All predefined types have a bounded set of representable values and return <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept>.","source":"All predefined types have a bounded set of representable values and return **true**."},{"pos":[20051,20058],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[21216,21281],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__is_exact\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::is_exact","linkify":"<a name=\"numeric_limits__is_exact\"></a>  numeric_limits::is_exact","source":"<a name=\"numeric_limits__is_exact\"></a>  numeric_limits::is_exact"},{"content":"Tests if the calculations done on a type are free of rounding errors.","pos":[21285,21354]},{"pos":[21417,21429],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[21433,21508],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the calculations are free of rounding errors; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the calculations are free of rounding errors; **false** if not."},{"pos":[21518,21525],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"All predefined integer types have exact representations for their values and return <bpt id=\"p1\">**</bpt>false<ept id=\"p1\">**</ept>.","pos":[21529,21623],"source":"All predefined integer types have exact representations for their values and return **false**."},{"content":"A fixed-point or rational representation is also considered exact, but a floating-point representation is not.","pos":[21624,21734]},{"pos":[21744,21751],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[22907,22974],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__is_iec559\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::is_iec559","linkify":"<a name=\"numeric_limits__is_iec559\"></a>  numeric_limits::is_iec559","source":"<a name=\"numeric_limits__is_iec559\"></a>  numeric_limits::is_iec559"},{"content":"Tests if a type conforms to IEC 559 standards.","pos":[22978,23024]},{"pos":[23088,23100],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[23104,23177],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type conforms to the IEC 559 standards; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type conforms to the IEC 559 standards; **false** if not."},{"pos":[23187,23194],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The IEC 559 is an international standard for representing floating-point values and is also known as IEEE 754 in the USA.","pos":[23198,23319]},{"pos":[23329,23336],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[24306,24375],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__is_integer\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::is_integer","linkify":"<a name=\"numeric_limits__is_integer\"></a>  numeric_limits::is_integer","source":"<a name=\"numeric_limits__is_integer\"></a>  numeric_limits::is_integer"},{"content":"Tests if a type has an integer representation.","pos":[24379,24425]},{"pos":[24490,24502],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[24506,24575],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has an integer representation; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has an integer representation; **false** if not."},{"pos":[24585,24592],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"All predefined integer types have an integer representation.","pos":[24596,24656]},{"pos":[24666,24673],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[25680,25747],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__is_modulo\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::is_modulo","linkify":"<a name=\"numeric_limits__is_modulo\"></a>  numeric_limits::is_modulo","source":"<a name=\"numeric_limits__is_modulo\"></a>  numeric_limits::is_modulo"},{"pos":[25751,25799],"content":"Tests if a <bpt id=\"p1\">**</bpt>type<ept id=\"p1\">**</ept> has a modulo representation.","source":"Tests if a **type** has a modulo representation."},{"pos":[25863,25875],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[25879,25946],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has a modulo representation; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has a modulo representation; **false** if not."},{"pos":[25956,25963],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"A modulo representation is a representation where all results are reduced modulo some value.","pos":[25967,26059]},{"content":"All predefined unsigned integer types have a modulo representation.","pos":[26060,26127]},{"pos":[26137,26144],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[27146,27213],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__is_signed\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::is_signed","linkify":"<a name=\"numeric_limits__is_signed\"></a>  numeric_limits::is_signed","source":"<a name=\"numeric_limits__is_signed\"></a>  numeric_limits::is_signed"},{"content":"Tests if a type has a signed representation.","pos":[27217,27261]},{"pos":[27325,27337],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[27341,27408],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has a signed representation; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has a signed representation; **false** if not."},{"pos":[27418,27425],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member stores true for a type that has a signed representation, which is the case for all predefined floating-point and signed integer types.","pos":[27429,27574]},{"pos":[27584,27591],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[28595,28672],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__is_specialized\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::is_specialized","linkify":"<a name=\"numeric_limits__is_specialized\"></a>  numeric_limits::is_specialized","source":"<a name=\"numeric_limits__is_specialized\"></a>  numeric_limits::is_specialized"},{"pos":[28676,28770],"content":"Tests if a type has an explicit specialization defined in the template class <ph id=\"ph1\">`numeric_limits`</ph>.","source":"Tests if a type has an explicit specialization defined in the template class `numeric_limits`."},{"pos":[28839,28851],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[28855,28955],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the type has an explicit specialization defined in the template class; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if not.","source":"**true** if the type has an explicit specialization defined in the template class; **false** if not."},{"pos":[28965,28972],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[28976,29089],"content":"All scalar types other than pointers have an explicit specialization defined for template class <ph id=\"ph1\">`numeric_limits`</ph>.","source":"All scalar types other than pointers have an explicit specialization defined for template class `numeric_limits`."},{"pos":[29099,29106],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[30274,30335],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__lowest\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::lowest","linkify":"<a name=\"numeric_limits__lowest\"></a>  numeric_limits::lowest","source":"<a name=\"numeric_limits__lowest\"></a>  numeric_limits::lowest"},{"content":"Returns the most negative finite value.","pos":[30339,30378]},{"pos":[30433,30445],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Returns the most negative finite value.","pos":[30449,30488]},{"pos":[30498,30505],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Returns the most negative finite value for the type (which is typically <ph id=\"ph1\">`min`</ph> <ph id=\"ph2\">`()`</ph> for integer types and <ph id=\"ph3\">`-``max`</ph> <ph id=\"ph4\">`()`</ph> for floating-point types).","pos":[30509,30654],"source":"Returns the most negative finite value for the type (which is typically `min` `()` for integer types and `-``max` `()` for floating-point types)."},{"content":"The return value is meaningful if <ph id=\"ph1\">`is_bounded`</ph> is <ph id=\"ph2\">`true`</ph>.","pos":[30655,30712],"source":" The return value is meaningful if `is_bounded` is `true`."},{"pos":[30722,30777],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__max\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::max","linkify":"<a name=\"numeric_limits__max\"></a>  numeric_limits::max","source":"<a name=\"numeric_limits__max\"></a>  numeric_limits::max"},{"content":"Returns the maximum finite value for a type.","pos":[30781,30825]},{"pos":[30877,30889],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The maximum finite value for a type.","pos":[30893,30929]},{"pos":[30939,30946],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The maximum finite value is INT_MAX for type <ph id=\"ph1\">`int`</ph> and FLT_MAX for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[30950,31032],"source":"The maximum finite value is INT_MAX for type `int` and FLT_MAX for type **float**."},{"content":"The return value is meaningful if <bpt id=\"p1\">[</bpt>is_bounded<ept id=\"p1\">](#numeric_limits__is_bounded)</ept> is <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>.","pos":[31033,31121],"source":" The return value is meaningful if [is_bounded](#numeric_limits__is_bounded) is **true**."},{"pos":[31131,31138],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[31779,31852],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__max_digits10\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::max_digits10","linkify":"<a name=\"numeric_limits__max_digits10\"></a>  numeric_limits::max_digits10","source":"<a name=\"numeric_limits__max_digits10\"></a>  numeric_limits::max_digits10"},{"content":"Returns the number of decimal digits required to make sure that two distinct values of the type have distinct decimal representations.","pos":[31856,31990]},{"pos":[32046,32058],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Returns the number of decimal digits that are required to make sure that two distinct values of the type have distinct decimal representations.","pos":[32062,32205]},{"pos":[32215,32222],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member stores the number of decimal digits required to make sure that two distinct values of the type have distinct decimal representations.","pos":[32226,32370]},{"pos":[32380,32453],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__max_exponent\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::max_exponent","linkify":"<a name=\"numeric_limits__max_exponent\"></a>  numeric_limits::max_exponent","source":"<a name=\"numeric_limits__max_exponent\"></a>  numeric_limits::max_exponent"},{"content":"Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.","pos":[32457,32610]},{"pos":[32672,32684],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The maximum integral radix-based exponent representable by the type.","pos":[32688,32756]},{"pos":[32766,32773],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function return is meaningful only for floating-point types.","pos":[32777,32848]},{"content":"The <ph id=\"ph1\">`max_exponent`</ph> is the value FLT_MAX_EXP for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[32849,32912],"source":" The `max_exponent` is the value FLT_MAX_EXP for type **float**."},{"pos":[32922,32929],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[33744,33821],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__max_exponent10\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::max_exponent10","linkify":"<a name=\"numeric_limits__max_exponent10\"></a>  numeric_limits::max_exponent10","source":"<a name=\"numeric_limits__max_exponent10\"></a>  numeric_limits::max_exponent10"},{"content":"Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.","pos":[33825,33976]},{"pos":[34040,34052],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The maximum integral base 10 exponent representable by the type.","pos":[34056,34120]},{"pos":[34130,34137],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function return is meaningful only for floating-point types.","pos":[34141,34212]},{"content":"The <ph id=\"ph1\">`max_exponent`</ph> is the value FLT_MAX_10 for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[34213,34275],"source":" The `max_exponent` is the value FLT_MAX_10 for type **float**."},{"pos":[34285,34292],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[35106,35161],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__min\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::min","linkify":"<a name=\"numeric_limits__min\"></a>  numeric_limits::min","source":"<a name=\"numeric_limits__min\"></a>  numeric_limits::min"},{"content":"Returns the minimum normalized value for a type.","pos":[35165,35213]},{"pos":[35265,35277],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The minimum normalized value for the type.","pos":[35281,35323]},{"pos":[35333,35340],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The minimum normalized value is INT_MIN for type <ph id=\"ph1\">`int`</ph> and FLT_MIN for type <ph id=\"ph2\">`float`</ph>.","pos":[35344,35428],"source":"The minimum normalized value is INT_MIN for type `int` and FLT_MIN for type `float`."},{"content":"The return value is meaningful if <bpt id=\"p1\">[</bpt>is_bounded<ept id=\"p1\">](#numeric_limits__is_bounded)</ept> is <ph id=\"ph1\">`true`</ph> or if <bpt id=\"p2\">[</bpt>is_signed<ept id=\"p2\">](#numeric_limits__is_signed)</ept> is <ph id=\"ph2\">`false`</ph>.","pos":[35429,35572],"source":" The return value is meaningful if [is_bounded](#numeric_limits__is_bounded) is `true` or if [is_signed](#numeric_limits__is_signed) is `false`."},{"pos":[35582,35589],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[36462,36535],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__min_exponent\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::min_exponent","linkify":"<a name=\"numeric_limits__min_exponent\"></a>  numeric_limits::min_exponent","source":"<a name=\"numeric_limits__min_exponent\"></a>  numeric_limits::min_exponent"},{"content":"Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.","pos":[36539,36692]},{"pos":[36754,36766],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The minimum integral radix-based exponent representable by the type.","pos":[36770,36838]},{"pos":[36848,36855],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function is meaningful only for floating-point types.","pos":[36859,36923]},{"content":"The <ph id=\"ph1\">`min_exponent`</ph> is the value FLT_MIN_EXP for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[36924,36987],"source":" The `min_exponent` is the value FLT_MIN_EXP for type **float**."},{"pos":[36997,37004],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[37823,37900],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__min_exponent10\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::min_exponent10","linkify":"<a name=\"numeric_limits__min_exponent10\"></a>  numeric_limits::min_exponent10","source":"<a name=\"numeric_limits__min_exponent10\"></a>  numeric_limits::min_exponent10"},{"content":"Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.","pos":[37904,38055]},{"pos":[38119,38131],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The minimum integral base 10 exponent representable by the type.","pos":[38135,38199]},{"pos":[38209,38216],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member function is meaningful only for floating-point types.","pos":[38220,38284]},{"content":"The <ph id=\"ph1\">`min_exponent10`</ph> is the value FLT_MIN_10_EXP for type <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>.","pos":[38285,38353],"source":" The `min_exponent10` is the value FLT_MIN_10_EXP for type **float**."},{"pos":[38363,38370],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[39169,39236],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__quiet_nan\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::quiet_NaN","linkify":"<a name=\"numeric_limits__quiet_nan\"></a>  numeric_limits::quiet_NaN","source":"<a name=\"numeric_limits__quiet_nan\"></a>  numeric_limits::quiet_NaN"},{"content":"Returns the representation of a quiet not a number (NAN) for the type.","pos":[39240,39310]},{"pos":[39368,39380],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The representation of a quiet NAN for the type.","pos":[39384,39431]},{"pos":[39441,39448],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[39452,39551],"content":"The return value is meaningful only if <bpt id=\"p1\">[</bpt>has_quiet_NaN<ept id=\"p1\">](#numeric_limits__has_quiet_nan)</ept> is <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>.","source":"The return value is meaningful only if [has_quiet_NaN](#numeric_limits__has_quiet_nan) is **true**."},{"pos":[39561,39568],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[40261,40320],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__radix\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::radix","linkify":"<a name=\"numeric_limits__radix\"></a>  numeric_limits::radix","source":"<a name=\"numeric_limits__radix\"></a>  numeric_limits::radix"},{"content":"Returns the integral base, referred to as radix, used for the representation of a type.","pos":[40324,40411]},{"pos":[40466,40478],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The integral base for the representation of the type.","pos":[40482,40535]},{"pos":[40545,40552],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The base is 2 for the predefined integer types, and the base to which the exponent is raised, or FLT_RADIX, for the predefined floating-point types.","pos":[40556,40704]},{"pos":[40714,40721],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[41347,41418],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__round_error\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::round_error","linkify":"<a name=\"numeric_limits__round_error\"></a>  numeric_limits::round_error","source":"<a name=\"numeric_limits__round_error\"></a>  numeric_limits::round_error"},{"content":"Returns the maximum rounding error for the type.","pos":[41422,41470]},{"pos":[41530,41542],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The maximum rounding error for the type.","pos":[41546,41586]},{"pos":[41596,41603],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[42374,42445],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__round_style\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::round_style","linkify":"<a name=\"numeric_limits__round_style\"></a>  numeric_limits::round_style","source":"<a name=\"numeric_limits__round_style\"></a>  numeric_limits::round_style"},{"content":"Returns a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.","pos":[42449,42590]},{"pos":[42681,42693],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[42697,42780],"content":"A value from the <ph id=\"ph1\">`float_round_style`</ph> enumeration that describes the rounding style.","source":"A value from the `float_round_style` enumeration that describes the rounding style."},{"pos":[42790,42797],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The member stores a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.","pos":[42801,42952]},{"content":"The round style is hard coded in this implementation, so even if the program starts up with a different rounding mode, that value will not change.","pos":[42959,43105]},{"pos":[43115,43122],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[43873,43948],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__signaling_nan\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::signaling_NaN","linkify":"<a name=\"numeric_limits__signaling_nan\"></a>  numeric_limits::signaling_NaN","source":"<a name=\"numeric_limits__signaling_nan\"></a>  numeric_limits::signaling_NaN"},{"content":"Returns the representation of a signaling not a number (NAN) for the type.","pos":[43952,44026]},{"pos":[44088,44100],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The representation of a signaling NAN for the type.","pos":[44104,44155]},{"pos":[44165,44172],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[44176,44283],"content":"The return value is meaningful only if <bpt id=\"p1\">[</bpt>has_signaling_NaN<ept id=\"p1\">](#numeric_limits__has_signaling_nan)</ept> is <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>.","source":"The return value is meaningful only if [has_signaling_NaN](#numeric_limits__has_signaling_nan) is **true**."},{"pos":[44293,44300],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[44870,44949],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__tinyness_before\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::tinyness_before","linkify":"<a name=\"numeric_limits__tinyness_before\"></a>  numeric_limits::tinyness_before","source":"<a name=\"numeric_limits__tinyness_before\"></a>  numeric_limits::tinyness_before"},{"content":"Tests whether a type can determine that a value is too small to represent as a normalized value before rounding it.","pos":[44953,45068]},{"pos":[45138,45150],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[45154,45234],"content":"<ph id=\"ph1\">`true`</ph> if the type can detect tiny values before rounding; <ph id=\"ph2\">`false`</ph> if it cannot.","source":"`true` if the type can detect tiny values before rounding; `false` if it cannot."},{"pos":[45244,45251],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Types that can detect tinyness were included as an option with IEC 559 floating-point representations and its implementation can affect some results.","pos":[45255,45404]},{"pos":[45414,45421],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[46484,46543],"content":"<bpt id=\"p1\">&lt;a name=\"numeric_limits__traps\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  numeric_limits::traps","linkify":"<a name=\"numeric_limits__traps\"></a>  numeric_limits::traps","source":"<a name=\"numeric_limits__traps\"></a>  numeric_limits::traps"},{"content":"Tests whether trapping that reports on arithmetic exceptions is implemented for a type.","pos":[46547,46634]},{"pos":[46694,46706],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[46710,46783],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if trapping is implemented for the type; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if it is not.","source":"**true** if trapping is implemented for the type; **false** if it is not."},{"pos":[46793,46800],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[47732,47740],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[47744,47853],"content":"<bpt id=\"p1\">[</bpt>Thread Safety in the C++ Standard Library<ept id=\"p1\">](../standard-library/thread-safety-in-the-cpp-standard-library.md)</ept>","source":"[Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)"}],"content":"---\ntitle: \"numeric_limits Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std::numeric_limits\"\n  - \"std.numeric_limits\"\n  - \"numeric_limits\"\n  - \"limits/std::numeric_limits\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"numeric_limits class\"\nms.assetid: 9e817177-0e91-48e6-b680-0531c4b26625\ncaps.latest.revision: 26\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# numeric_limits Class\nThe template class describes arithmetic properties of built-in numerical types.  \n  \n## Syntax  \n  \n```  \ntemplate <class Type>  \nclass numeric_limits  \n```  \n  \n#### Parameters  \n `Type`  \n The fundamental element data type whose properties are being tested or queried or set.  \n  \n## Remarks  \n The header defines explicit specializations for the types `wchar_t`, `bool`, `char`, `signed char`, `unsigned char`, `short`, `unsigned short`, `int`, `unsigned int`, `long`, `unsigned long`, `float`, `double`, `long double`**,** `long long`, `unsigned long long`, `char16_t`, and `char32_t`. For these explicit specializations, the member [numeric_limits::is_specialized](#numeric_limits__is_specialized) is `true`, and all relevant members have meaningful values. The program can supply additional explicit specializations. Most member functions of the class describe or test possible implementations of `float`.  \n  \n For an arbitrary specialization, no members have meaningful values. A member object that does not have a meaningful value stores zero (or `false`) and a member function that does not return a meaningful value returns `Type(0)`.  \n  \n### Static Functions and Constants  \n  \n|||  \n|-|-|  \n|[denorm_min](#numeric_limits__denorm_min)|Returns the smallest nonzero denormalized value.|  \n|[digits](#numeric_limits__digits)|Returns the number of radix digits that the type can represent without loss of precision.|  \n|[digits10](#numeric_limits__digits10)|Returns the number of decimal digits that the type can represent without loss of precision.|  \n|[epsilon](#numeric_limits__epsilon)|Returns the difference between 1 and the smallest value greater than 1 that the data type can represent.|  \n|[has_denorm](#numeric_limits__has_denorm)|Tests whether a type allows denormalized values.|  \n|[has_denorm_loss](#numeric_limits__has_denorm_loss)|Tests whether loss of accuracy is detected as a denormalization loss rather than as an inexact result.|  \n|[has_infinity](#numeric_limits__has_infinity)|Tests whether a type has a representation for positive infinity.|  \n|[has_quiet_NaN](#numeric_limits__has_quiet_nan)|Tests whether a type has a representation for a quiet not a number (NAN), which is nonsignaling.|  \n|[has_signaling_NaN](#numeric_limits__has_signaling_nan)|Tests whether a type has a representation for signaling not a number (NAN).|  \n|[infinity](#numeric_limits__infinity)|The representation for positive infinity for a type, if available.|  \n|[is_bounded](#numeric_limits__is_bounded)|Tests if the set of values that a type may represent is finite.|  \n|[is_exact](#numeric_limits__is_exact)|Tests if the calculations done on a type are free of rounding errors.|  \n|[is_iec559](#numeric_limits__is_iec559)|Tests if a type conforms to IEC 559 standards.|  \n|[is_integer](#numeric_limits__is_integer)|Tests if a type has an integer representation.|  \n|[is_modulo](#numeric_limits__is_modulo)|Tests if a type has a modulo representation.|  \n|[is_signed](#numeric_limits__is_signed)|Tests if a type has a signed representation.|  \n|[is_specialized](#numeric_limits__is_specialized)|Tests if a type has an explicit specialization defined in the template class `numeric_limits`.|  \n|[lowest](#numeric_limits__lowest)|Returns the most negative finite value.|  \n|[max](#numeric_limits__max)|Returns the maximum finite value for a type.|  \n|[max_digits10](#numeric_limits__max_digits10)|Returns the number of decimal digits required to ensure that two distinct values of the type have distinct decimal representations.|  \n|[max_exponent](#numeric_limits__max_exponent)|Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.|  \n|[max_exponent10](#numeric_limits__max_exponent10)|Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.|  \n|[min](#numeric_limits__min)|Returns the minimum normalized value for a type.|  \n|[min_exponent](#numeric_limits__min_exponent)|Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.|  \n|[min_exponent10](#numeric_limits__min_exponent10)|Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.|  \n|[quiet_NaN](#numeric_limits__quiet_nan)|Returns the representation of a quiet not a number (NAN) for the type.|  \n|[radix](#numeric_limits__radix)|Returns the integral base, referred to as radix, used for the representation of a type.|  \n|[round_error](#numeric_limits__round_error)|Returns the maximum rounding error for the type.|  \n|[round_style](#numeric_limits__round_style)|Returns a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.|  \n|[signaling_NaN](#numeric_limits__signaling_nan)|Returns the representation of a signaling not a number (NAN) for the type.|  \n|[tinyness_before](#numeric_limits__tinyness_before)|Tests whether a type can determine that a value is too small to represent as a normalized value before rounding it.|  \n|[traps](#numeric_limits__traps)|Tests whether trapping that reports on arithmetic exceptions is implemented for a type.|  \n  \n## Requirements  \n **Header:** \\<limits>  \n  \n **Namespace:** std  \n  \n##  <a name=\"numeric_limits__denorm_min\"></a>  numeric_limits::denorm_min  \n Returns the smallest nonzero denormalized value.  \n  \n```  \nstatic Type denorm_min() throw();\n```  \n  \n### Return Value  \n The smallest nonzero denormalized value.  \n  \n### Remarks  \n `long double` is the same as **double** for the C++ compiler.  \n  \n The function returns the minimum value for the type, which is the same as [min](#numeric_limits__min) if [has_denorm](#numeric_limits__has_denorm) is not equal to **denorm_present**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_denorm_min.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The smallest nonzero denormalized value\\n for float \"  \n        << \"objects is: \" << numeric_limits<float>::denorm_min( )   \n        << endl;  \n   cout << \"The smallest nonzero denormalized value\\n for double \"  \n        << \"objects is: \" << numeric_limits<double>::denorm_min( )   \n        << endl;  \n   cout << \"The smallest nonzero denormalized value\\n for long double \"  \n        << \"objects is: \" << numeric_limits<long double>::denorm_min( )   \n        << endl;  \n  \n   // A smaller value will round to zero  \n   cout << numeric_limits<float>::denorm_min( )/2 <<endl;  \n   cout << numeric_limits<double>::denorm_min( )/2 <<endl;  \n   cout << numeric_limits<long double>::denorm_min( )/2 <<endl;  \n}  \n```  \n  \n```Output  \nThe smallest nonzero denormalized value  \n for float objects is: 1.4013e-045  \nThe smallest nonzero denormalized value  \n for double objects is: 4.94066e-324  \nThe smallest nonzero denormalized value  \n for long double objects is: 4.94066e-324  \n0  \n0  \n0  \n```  \n  \n##  <a name=\"numeric_limits__digits\"></a>  numeric_limits::digits  \n Returns the number of radix digits that the type can represent without loss of precision.  \n  \n```  \nstatic const int digits = 0;  \n```  \n  \n### Return Value  \n The number of radix digits that the type can represent without loss of precision.  \n  \n### Remarks  \n The member stores the number of radix digits that the type can represent without change, which is the number of bits other than any sign bit for a predefined integer type, or the number of mantissa digits for a predefined floating-point type.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_digits_min.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << numeric_limits<float>::digits <<endl;  \n   cout << numeric_limits<double>::digits <<endl;  \n   cout << numeric_limits<long double>::digits <<endl;  \n   cout << numeric_limits<int>::digits <<endl;  \n   cout << numeric_limits<__int64>::digits <<endl;  \n}  \n```  \n  \n```Output  \n24  \n53  \n53  \n31  \n63  \n```  \n  \n##  <a name=\"numeric_limits__digits10\"></a>  numeric_limits::digits10  \n Returns the number of decimal digits that the type can represent without loss of precision.  \n  \n```  \nstatic const int digits10 = 0;  \n```  \n  \n### Return Value  \n The number of decimal digits that the type can represent without loss of precision.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_digits10.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << numeric_limits<float>::digits10 <<endl;  \n   cout << numeric_limits<double>::digits10 <<endl;  \n   cout << numeric_limits<long double>::digits10 <<endl;  \n   cout << numeric_limits<int>::digits10 <<endl;  \n   cout << numeric_limits<__int64>::digits10 <<endl;  \n   float f = (float)99999999;  \n   cout.precision ( 10 );  \n   cout << \"The float is; \" << f << endl;  \n}  \n```  \n  \n```Output  \n6  \n15  \n15  \n9  \n18  \nThe float is; 100000000  \n```  \n  \n##  <a name=\"numeric_limits__epsilon\"></a>  numeric_limits::epsilon  \n The function returns the difference between 1 and the smallest value greater than 1 that is representable for the data type.  \n  \n```  \nstatic Type epsilon() throw();\n```  \n  \n### Return Value  \n The difference between 1 and the smallest value greater than 1 that is representable for the data type.  \n  \n### Remarks  \n The value is FLT_EPSILON for type **float**. `epsilon` for a type is the smallest positive floating-point number *N* such that *N* + `epsilon` + *N* is representable.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_epsilon.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The difference between 1 and the smallest \"  \n        << \"value greater than 1\\n for float objects is: \"   \n        << numeric_limits<float>::epsilon( )   \n        << endl;  \n   cout << \"The difference between 1 and the smallest \"  \n        << \"value greater than 1\\n for double objects is: \"   \n        << numeric_limits<double>::epsilon( )   \n        << endl;  \n   cout << \"The difference between 1 and the smallest \"  \n        << \"value greater than 1\\n for long double objects is: \"   \n        << numeric_limits<long double>::epsilon( )   \n        << endl;  \n}  \n```  \n  \n```Output  \nThe difference between 1 and the smallest value greater than 1  \n for float objects is: 1.19209e-007  \nThe difference between 1 and the smallest value greater than 1  \n for double objects is: 2.22045e-016  \nThe difference between 1 and the smallest value greater than 1  \n for long double objects is: 2.22045e-016  \n```  \n  \n##  <a name=\"numeric_limits__has_denorm\"></a>  numeric_limits::has_denorm  \n Tests whether a type allows denormalized values.  \n  \n```  \nstatic const float_denorm_style has_denorm = denorm_absent;  \n```  \n  \n### Return Value  \n An enumeration value of type **const**`float_denorm_style`, indicating whether the type allows denormalized values.  \n  \n### Remarks  \n The member stores **denorm_present** for a floating-point type that has denormalized values, effectively a variable number of exponent bits.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_has_denorm.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects allow denormalized values: \"  \n        << numeric_limits<float>::has_denorm   \n        << endl;  \n   cout << \"Whether double objects allow denormalized values: \"  \n        << numeric_limits<double>::has_denorm   \n        << endl;  \n   cout << \"Whether long int objects allow denormalized values: \"   \n        << numeric_limits<long int>::has_denorm   \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects allow denormalized values: 1  \nWhether double objects allow denormalized values: 1  \nWhether long int objects allow denormalized values: 0  \n```  \n  \n##  <a name=\"numeric_limits__has_denorm_loss\"></a>  numeric_limits::has_denorm_loss  \n Tests whether loss of accuracy is detected as a denormalization loss rather than as an inexact result.  \n  \n```  \nstatic const bool has_denorm_loss = false;  \n```  \n  \n### Return Value  \n **true** if the loss of accuracy is detected as a denormalization loss; **false** if not.  \n  \n### Remarks  \n The member stores true for a type that determines whether a value has lost accuracy because it is delivered as a denormalized result (too small to represent as a normalized value) or because it is inexact (not the same as a result not subject to limitations of exponent range and precision), an option with IEC 559 floating-point representations that can affect some results.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_has_denorm_loss.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects can detect denormalized loss: \"  \n        << numeric_limits<float>::has_denorm_loss  \n        << endl;  \n   cout << \"Whether double objects can detect denormalized loss: \"  \n        << numeric_limits<double>::has_denorm_loss  \n        << endl;  \n   cout << \"Whether long int objects can detect denormalized loss: \"   \n        << numeric_limits<long int>::has_denorm_loss  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects can detect denormalized loss: 1  \nWhether double objects can detect denormalized loss: 1  \nWhether long int objects can detect denormalized loss: 0  \n```  \n  \n##  <a name=\"numeric_limits__has_infinity\"></a>  numeric_limits::has_infinity  \n Tests whether a type has a representation for positive infinity.  \n  \n```  \nstatic const bool has_infinity = false;  \n```  \n  \n### Return Value  \n **true** if the type has a representation for positive infinity; **false** if not.  \n  \n### Remarks  \n The member returns **true** if [is_iec559](#numeric_limits__is_iec559) is **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_has_infinity.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have infinity: \"  \n        << numeric_limits<float>::has_infinity  \n        << endl;  \n   cout << \"Whether double objects have infinity: \"  \n        << numeric_limits<double>::has_infinity  \n        << endl;  \n   cout << \"Whether long int objects have infinity: \"   \n        << numeric_limits<long int>::has_infinity  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have infinity: 1  \nWhether double objects have infinity: 1  \nWhether long int objects have infinity: 0  \n```  \n  \n##  <a name=\"numeric_limits__has_quiet_nan\"></a>  numeric_limits::has_quiet_NaN  \n Tests whether a type has a representation for a quiet not a number (NAN), which is nonsignaling.  \n  \n```  \nstatic const bool has_quiet_NaN = false;  \n```  \n  \n### Return Value  \n **true** if the **type** has a representation for a quiet NAN; **false** if not.  \n  \n### Remarks  \n A quiet NAN is an encoding for not a number, which does not signal its presence in an expression. The return value is **true** if [is_iec559](#numeric_limits__is_iec559) is true.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_has_quiet_nan.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have quiet_NaN: \"  \n        << numeric_limits<float>::has_quiet_NaN   \n        << endl;  \n   cout << \"Whether double objects have quiet_NaN: \"  \n        << numeric_limits<double>::has_quiet_NaN   \n        << endl;  \n   cout << \"Whether long int objects have quiet_NaN: \"   \n        << numeric_limits<long int>::has_quiet_NaN   \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have quiet_NaN: 1  \nWhether double objects have quiet_NaN: 1  \nWhether long int objects have quiet_NaN: 0  \n```  \n  \n##  <a name=\"numeric_limits__has_signaling_nan\"></a>  numeric_limits::has_signaling_NaN  \n Tests whether a type has a representation for signaling not a number (NAN).  \n  \n```  \nstatic const bool has_signaling_NaN = false;  \n```  \n  \n### Return Value  \n **true** if the type has a representation for a signaling NAN; **false** if not.  \n  \n### Remarks  \n A signaling NAN is an encoding for not a number, which signals its presence in an expression. The return value is **true**[is_iec559](#numeric_limits__is_iec559) is true.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_has_signaling_nan.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have a signaling_NaN: \"  \n        << numeric_limits<float>::has_signaling_NaN   \n        << endl;  \n   cout << \"Whether double objects have a signaling_NaN: \"  \n        << numeric_limits<double>::has_signaling_NaN   \n        << endl;  \n   cout << \"Whether long int objects have a signaling_NaN: \"   \n        << numeric_limits<long int>::has_signaling_NaN   \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have a signaling_NaN: 1  \nWhether double objects have a signaling_NaN: 1  \nWhether long int objects have a signaling_NaN: 0  \n```  \n  \n##  <a name=\"numeric_limits__infinity\"></a>  numeric_limits::infinity  \n The representation of positive infinity for a type, if available.  \n  \n```  \nstatic Type infinity() throw();\n```  \n  \n### Return Value  \n The representation of positive infinity for a type, if available.  \n  \n### Remarks  \n The return value is meaningful only if [has_infinity](#numeric_limits__has_infinity) is **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_infinity.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << numeric_limits<float>::has_infinity <<endl;  \n   cout << numeric_limits<double>::has_infinity<<endl;  \n   cout << numeric_limits<long double>::has_infinity <<endl;  \n   cout << numeric_limits<int>::has_infinity <<endl;  \n   cout << numeric_limits<__int64>::has_infinity <<endl;  \n  \n   cout << \"The representation of infinity for type float is: \"  \n        << numeric_limits<float>::infinity( ) <<endl;  \n   cout << \"The representation of infinity for type double is: \"  \n        << numeric_limits<double>::infinity( ) <<endl;  \n   cout << \"The representation of infinity for type long double is: \"  \n        << numeric_limits<long double>::infinity( ) <<endl;  \n}  \n```  \n  \n```Output  \n1  \n1  \n1  \n0  \n0  \nThe representation of infinity for type float is: 1.#INF  \nThe representation of infinity for type double is: 1.#INF  \nThe representation of infinity for type long double is: 1.#INF  \n```  \n  \n##  <a name=\"numeric_limits__is_bounded\"></a>  numeric_limits::is_bounded  \n Tests if the set of values that a type may represent is finite.  \n  \n```  \nstatic const bool is_bounded = false;  \n```  \n  \n### Return Value  \n **true** if the type has a bounded set of representable values; **false** if not.  \n  \n### Remarks  \n All predefined types have a bounded set of representable values and return **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_bounded.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have bounded set \"  \n        << \"of representable values: \"  \n        << numeric_limits<float>::is_bounded  \n        << endl;  \n   cout << \"Whether double objects have bounded set \"  \n        << \"of representable values: \"  \n        << numeric_limits<double>::is_bounded  \n        << endl;  \n   cout << \"Whether long int objects have bounded set \"  \n        << \"of representable values: \"  \n        << numeric_limits<long int>::is_bounded  \n        << endl;  \n   cout << \"Whether unsigned char objects have bounded set \"  \n        << \"of representable values: \"  \n        << numeric_limits<unsigned char>::is_bounded  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have bounded set of representable values: 1  \nWhether double objects have bounded set of representable values: 1  \nWhether long int objects have bounded set of representable values: 1  \nWhether unsigned char objects have bounded set of representable values: 1  \n```  \n  \n##  <a name=\"numeric_limits__is_exact\"></a>  numeric_limits::is_exact  \n Tests if the calculations done on a type are free of rounding errors.  \n  \n```  \nstatic const bool is_exact = false;  \n```  \n  \n### Return Value  \n **true** if the calculations are free of rounding errors; **false** if not.  \n  \n### Remarks  \n All predefined integer types have exact representations for their values and return **false**. A fixed-point or rational representation is also considered exact, but a floating-point representation is not.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_exact.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have calculations \"  \n        << \"free of rounding errors: \"  \n        << numeric_limits<float>::is_exact  \n        << endl;  \n   cout << \"Whether double objects have calculations \"  \n        << \"free of rounding errors: \"  \n        << numeric_limits<double>::is_exact  \n        << endl;  \n   cout << \"Whether long int objects have calculations \"  \n        << \"free of rounding errors: \"  \n        << numeric_limits<long int>::is_exact  \n        << endl;  \n   cout << \"Whether unsigned char objects have calculations \"  \n        << \"free of rounding errors: \"  \n        << numeric_limits<unsigned char>::is_exact  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have calculations free of rounding errors: 0  \nWhether double objects have calculations free of rounding errors: 0  \nWhether long int objects have calculations free of rounding errors: 1  \nWhether unsigned char objects have calculations free of rounding errors: 1  \n```  \n  \n##  <a name=\"numeric_limits__is_iec559\"></a>  numeric_limits::is_iec559  \n Tests if a type conforms to IEC 559 standards.  \n  \n```  \nstatic const bool is_iec559 = false;  \n```  \n  \n### Return Value  \n **true** if the type conforms to the IEC 559 standards; **false** if not.  \n  \n### Remarks  \n The IEC 559 is an international standard for representing floating-point values and is also known as IEEE 754 in the USA.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_iec559.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects conform to iec559 standards: \"  \n        << numeric_limits<float>::is_iec559  \n        << endl;  \n   cout << \"Whether double objects conform to iec559 standards: \"  \n        << numeric_limits<double>::is_iec559  \n        << endl;  \n   cout << \"Whether int objects conform to iec559 standards: \"  \n        << numeric_limits<int>::is_iec559  \n        << endl;  \n   cout << \"Whether unsigned char objects conform to iec559 standards: \"  \n        << numeric_limits<unsigned char>::is_iec559  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects conform to iec559 standards: 1  \nWhether double objects conform to iec559 standards: 1  \nWhether int objects conform to iec559 standards: 0  \nWhether unsigned char objects conform to iec559 standards: 0  \n```  \n  \n##  <a name=\"numeric_limits__is_integer\"></a>  numeric_limits::is_integer  \n Tests if a type has an integer representation.  \n  \n```  \nstatic const bool is_integer = false;  \n```  \n  \n### Return Value  \n **true** if the type has an integer representation; **false** if not.  \n  \n### Remarks  \n All predefined integer types have an integer representation.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_integer.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have an integral representation: \"  \n        << numeric_limits<float>::is_integer  \n        << endl;  \n   cout << \"Whether double objects have an integral representation: \"  \n        << numeric_limits<double>::is_integer  \n        << endl;  \n   cout << \"Whether int objects have an integral representation: \"  \n        << numeric_limits<int>::is_integer  \n        << endl;  \n   cout << \"Whether unsigned char objects have an integral representation: \"  \n        << numeric_limits<unsigned char>::is_integer  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have an integral representation: 0  \nWhether double objects have an integral representation: 0  \nWhether int objects have an integral representation: 1  \nWhether unsigned char objects have an integral representation: 1  \n```  \n  \n##  <a name=\"numeric_limits__is_modulo\"></a>  numeric_limits::is_modulo  \n Tests if a **type** has a modulo representation.  \n  \n```  \nstatic const bool is_modulo = false;  \n```  \n  \n### Return Value  \n **true** if the type has a modulo representation; **false** if not.  \n  \n### Remarks  \n A modulo representation is a representation where all results are reduced modulo some value. All predefined unsigned integer types have a modulo representation.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_modulo.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have a modulo representation: \"  \n        << numeric_limits<float>::is_modulo  \n        << endl;  \n   cout << \"Whether double objects have a modulo representation: \"  \n        << numeric_limits<double>::is_modulo  \n        << endl;  \n   cout << \"Whether signed char objects have a modulo representation: \"  \n        << numeric_limits<signed char>::is_modulo  \n        << endl;  \n   cout << \"Whether unsigned char objects have a modulo representation: \"  \n        << numeric_limits<unsigned char>::is_modulo  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have a modulo representation: 0  \nWhether double objects have a modulo representation: 0  \nWhether signed char objects have a modulo representation: 1  \nWhether unsigned char objects have a modulo representation: 1  \n```  \n  \n##  <a name=\"numeric_limits__is_signed\"></a>  numeric_limits::is_signed  \n Tests if a type has a signed representation.  \n  \n```  \nstatic const bool is_signed = false;  \n```  \n  \n### Return Value  \n **true** if the type has a signed representation; **false** if not.  \n  \n### Remarks  \n The member stores true for a type that has a signed representation, which is the case for all predefined floating-point and signed integer types.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_signaled.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have a signed representation: \"  \n        << numeric_limits<float>::is_signed  \n        << endl;  \n   cout << \"Whether double objects have a signed representation: \"  \n        << numeric_limits<double>::is_signed  \n        << endl;  \n   cout << \"Whether signed char objects have a signed representation: \"  \n        << numeric_limits<signed char>::is_signed  \n        << endl;  \n   cout << \"Whether unsigned char objects have a signed representation: \"  \n        << numeric_limits<unsigned char>::is_signed  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have a signed representation: 1  \nWhether double objects have a signed representation: 1  \nWhether signed char objects have a signed representation: 1  \nWhether unsigned char objects have a signed representation: 0  \n```  \n  \n##  <a name=\"numeric_limits__is_specialized\"></a>  numeric_limits::is_specialized  \n Tests if a type has an explicit specialization defined in the template class `numeric_limits`.  \n  \n```  \nstatic const bool is_specialized = false;  \n```  \n  \n### Return Value  \n **true** if the type has an explicit specialization defined in the template class; **false** if not.  \n  \n### Remarks  \n All scalar types other than pointers have an explicit specialization defined for template class `numeric_limits`.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_is_specialized.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float objects have an explicit \"  \n        << \"specialization in the class: \"  \n        << numeric_limits<float>::is_specialized  \n        << endl;  \n   cout << \"Whether float* objects have an explicit \"  \n        << \"specialization in the class: \"  \n        << numeric_limits<float*>::is_specialized  \n        << endl;  \n   cout << \"Whether int objects have an explicit \"  \n        << \"specialization in the class: \"  \n        << numeric_limits<int>::is_specialized  \n        << endl;  \n   cout << \"Whether int* objects have an explicit \"  \n        << \"specialization in the class: \"  \n        << numeric_limits<int*>::is_specialized  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float objects have an explicit specialization in the class: 1  \nWhether float* objects have an explicit specialization in the class: 0  \nWhether int objects have an explicit specialization in the class: 1  \nWhether int* objects have an explicit specialization in the class: 0  \n```  \n  \n##  <a name=\"numeric_limits__lowest\"></a>  numeric_limits::lowest  \n Returns the most negative finite value.  \n  \n```  \nstatic Type lowest() throw();\n```  \n  \n### Return Value  \n Returns the most negative finite value.  \n  \n### Remarks  \n Returns the most negative finite value for the type (which is typically `min` `()` for integer types and `-``max` `()` for floating-point types). The return value is meaningful if `is_bounded` is `true`.  \n  \n##  <a name=\"numeric_limits__max\"></a>  numeric_limits::max  \n Returns the maximum finite value for a type.  \n  \n```  \nstatic Type max() throw();\n```  \n  \n### Return Value  \n The maximum finite value for a type.  \n  \n### Remarks  \n The maximum finite value is INT_MAX for type `int` and FLT_MAX for type **float**. The return value is meaningful if [is_bounded](#numeric_limits__is_bounded) is **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_max.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main() {  \n   cout << \"The maximum value for type float is:  \"  \n        << numeric_limits<float>::max( )  \n        << endl;  \n   cout << \"The maximum value for type double is:  \"  \n        << numeric_limits<double>::max( )  \n        << endl;  \n   cout << \"The maximum value for type int is:  \"  \n        << numeric_limits<int>::max( )  \n        << endl;  \n   cout << \"The maximum value for type short int is:  \"  \n        << numeric_limits<short int>::max( )  \n        << endl;  \n}  \n```  \n  \n##  <a name=\"numeric_limits__max_digits10\"></a>  numeric_limits::max_digits10  \n Returns the number of decimal digits required to make sure that two distinct values of the type have distinct decimal representations.  \n  \n```  \nstatic int max_digits10 = 0;  \n```  \n  \n### Return Value  \n Returns the number of decimal digits that are required to make sure that two distinct values of the type have distinct decimal representations.  \n  \n### Remarks  \n The member stores the number of decimal digits required to make sure that two distinct values of the type have distinct decimal representations.  \n  \n##  <a name=\"numeric_limits__max_exponent\"></a>  numeric_limits::max_exponent  \n Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.  \n  \n```  \nstatic const int max_exponent = 0;  \n```  \n  \n### Return Value  \n The maximum integral radix-based exponent representable by the type.  \n  \n### Remarks  \n The member function return is meaningful only for floating-point types. The `max_exponent` is the value FLT_MAX_EXP for type **float**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_max_exponent.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The maximum radix-based exponent for type float is:  \"  \n        << numeric_limits<float>::max_exponent  \n        << endl;  \n   cout << \"The maximum radix-based exponent for type double is:  \"  \n        << numeric_limits<double>::max_exponent  \n        << endl;  \n   cout << \"The maximum radix-based exponent for type long double is:  \"  \n        << numeric_limits<long double>::max_exponent  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe maximum radix-based exponent for type float is:  128  \nThe maximum radix-based exponent for type double is:  1024  \nThe maximum radix-based exponent for type long double is:  1024  \n```  \n  \n##  <a name=\"numeric_limits__max_exponent10\"></a>  numeric_limits::max_exponent10  \n Returns the maximum positive integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.  \n  \n```  \nstatic const int max_exponent10 = 0;  \n```  \n  \n### Return Value  \n The maximum integral base 10 exponent representable by the type.  \n  \n### Remarks  \n The member function return is meaningful only for floating-point types. The `max_exponent` is the value FLT_MAX_10 for type **float**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_max_exponent10.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The maximum base 10 exponent for type float is:  \"  \n           << numeric_limits<float>::max_exponent10  \n           << endl;  \n   cout << \"The maximum base 10 exponent for type double is:  \"  \n           << numeric_limits<double>::max_exponent10  \n           << endl;  \n   cout << \"The maximum base 10 exponent for type long double is:  \"  \n           << numeric_limits<long double>::max_exponent10  \n           << endl;  \n}  \n```  \n  \n```Output  \nThe maximum base 10 exponent for type float is:  38  \nThe maximum base 10 exponent for type double is:  308  \nThe maximum base 10 exponent for type long double is:  308  \n```  \n  \n##  <a name=\"numeric_limits__min\"></a>  numeric_limits::min  \n Returns the minimum normalized value for a type.  \n  \n```  \nstatic Type min() throw();\n```  \n  \n### Return Value  \n The minimum normalized value for the type.  \n  \n### Remarks  \n The minimum normalized value is INT_MIN for type `int` and FLT_MIN for type `float`. The return value is meaningful if [is_bounded](#numeric_limits__is_bounded) is `true` or if [is_signed](#numeric_limits__is_signed) is `false`.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_min.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The minimum value for type float is:  \"  \n        << numeric_limits<float>::min( )  \n        << endl;  \n   cout << \"The minimum value for type double is:  \"  \n        << numeric_limits<double>::min( )  \n        << endl;  \n   cout << \"The minimum value for type int is:  \"  \n        << numeric_limits<int>::min( )  \n        << endl;  \n   cout << \"The minimum value for type short int is:  \"  \n        << numeric_limits<short int>::min( )  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe minimum value for type float is:  1.17549e-038  \nThe minimum value for type double is:  2.22507e-308  \nThe minimum value for type int is:  -2147483648  \nThe minimum value for type short int is:  -32768  \n```  \n  \n##  <a name=\"numeric_limits__min_exponent\"></a>  numeric_limits::min_exponent  \n Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of radix is raised to that power.  \n  \n```  \nstatic const int min_exponent = 0;  \n```  \n  \n### Return Value  \n The minimum integral radix-based exponent representable by the type.  \n  \n### Remarks  \n The member function is meaningful only for floating-point types. The `min_exponent` is the value FLT_MIN_EXP for type **float**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_min_exponent.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The minimum radix-based exponent for type float is:  \"  \n        << numeric_limits<float>::min_exponent  \n        << endl;  \n   cout << \"The minimum radix-based exponent for type double is:  \"  \n        << numeric_limits<double>::min_exponent  \n        << endl;  \n   cout << \"The minimum radix-based exponent for type long double is:  \"  \n         << numeric_limits<long double>::min_exponent  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe minimum radix-based exponent for type float is:  -125  \nThe minimum radix-based exponent for type double is:  -1021  \nThe minimum radix-based exponent for type long double is:  -1021  \n```  \n  \n##  <a name=\"numeric_limits__min_exponent10\"></a>  numeric_limits::min_exponent10  \n Returns the maximum negative integral exponent that the floating-point type can represent as a finite value when a base of ten is raised to that power.  \n  \n```  \nstatic const int min_exponent10 = 0;  \n```  \n  \n### Return Value  \n The minimum integral base 10 exponent representable by the type.  \n  \n### Remarks  \n The member function is meaningful only for floating-point types. The `min_exponent10` is the value FLT_MIN_10_EXP for type **float**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_min_exponent10.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The minimum base 10 exponent for type float is:  \"  \n        << numeric_limits<float>::min_exponent10  \n        << endl;  \n   cout << \"The minimum base 10 exponent for type double is:  \"  \n        << numeric_limits<double>::min_exponent10  \n        << endl;  \n   cout << \"The minimum base 10 exponent for type long double is:  \"  \n        << numeric_limits<long double>::min_exponent10  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe minimum base 10 exponent for type float is:  -37  \nThe minimum base 10 exponent for type double is:  -307  \nThe minimum base 10 exponent for type long double is:  -307  \n```  \n  \n##  <a name=\"numeric_limits__quiet_nan\"></a>  numeric_limits::quiet_NaN  \n Returns the representation of a quiet not a number (NAN) for the type.  \n  \n```  \nstatic Type quiet_NaN() throw();\n```  \n  \n### Return Value  \n The representation of a quiet NAN for the type.  \n  \n### Remarks  \n The return value is meaningful only if [has_quiet_NaN](#numeric_limits__has_quiet_nan) is **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_quiet_nan.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The quiet NaN for type float is:  \"  \n        << numeric_limits<float>::quiet_NaN( )  \n        << endl;  \n   cout << \"The quiet NaN for type int is:  \"  \n        << numeric_limits<int>::quiet_NaN( )  \n        << endl;  \n   cout << \"The quiet NaN for type long double is:  \"  \n        << numeric_limits<long double>::quiet_NaN( )  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe quiet NaN for type float is:  1.#QNAN  \nThe quiet NaN for type int is:  0  \nThe quiet NaN for type long double is:  1.#QNAN  \n```  \n  \n##  <a name=\"numeric_limits__radix\"></a>  numeric_limits::radix  \n Returns the integral base, referred to as radix, used for the representation of a type.  \n  \n```  \nstatic const int radix = 0;  \n```  \n  \n### Return Value  \n The integral base for the representation of the type.  \n  \n### Remarks  \n The base is 2 for the predefined integer types, and the base to which the exponent is raised, or FLT_RADIX, for the predefined floating-point types.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_radix.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The base for type float is:  \"  \n        << numeric_limits<float>::radix  \n        << endl;  \n   cout << \"The base for type int is:  \"  \n        << numeric_limits<int>::radix  \n        << endl;  \n   cout << \"The base for type long double is:  \"  \n        << numeric_limits<long double>::radix  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe base for type float is:  2  \nThe base for type int is:  2  \nThe base for type long double is:  2  \n```  \n  \n##  <a name=\"numeric_limits__round_error\"></a>  numeric_limits::round_error  \n Returns the maximum rounding error for the type.  \n  \n```  \nstatic Type round_error() throw();\n```  \n  \n### Return Value  \n The maximum rounding error for the type.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_round_error.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The maximum rounding error for type float is:  \"  \n        << numeric_limits<float>::round_error( )  \n        << endl;  \n   cout << \"The maximum rounding error for type int is:  \"  \n        << numeric_limits<int>::round_error( )  \n        << endl;  \n   cout << \"The maximum rounding error for type long double is:  \"  \n        << numeric_limits<long double>::round_error( )  \n        << endl;  \n}  \n```  \n  \n```Output  \nThe maximum rounding error for type float is:  0.5  \nThe maximum rounding error for type int is:  0  \nThe maximum rounding error for type long double is:  0.5  \n```  \n  \n##  <a name=\"numeric_limits__round_style\"></a>  numeric_limits::round_style  \n Returns a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.  \n  \n```  \nstatic const float_round_style round_style = round_toward_zero;  \n```  \n  \n### Return Value  \n A value from the `float_round_style` enumeration that describes the rounding style.  \n  \n### Remarks  \n The member stores a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value.  \n  \n The round style is hard coded in this implementation, so even if the program starts up with a different rounding mode, that value will not change.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_round_style.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <float.h>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The rounding style for a double type is: \"   \n        << numeric_limits<double>::round_style << endl;  \n   _controlfp_s(NULL,_RC_DOWN,_MCW_RC );  \n   cout << \"The rounding style for a double type is now: \"   \n        << numeric_limits<double>::round_style << endl;  \n   cout << \"The rounding style for an int type is: \"   \n        << numeric_limits<int>::round_style << endl;  \n}  \n```  \n  \n```Output  \nThe rounding style for a double type is: 1  \nThe rounding style for a double type is now: 1  \nThe rounding style for an int type is: 0  \n```  \n  \n##  <a name=\"numeric_limits__signaling_nan\"></a>  numeric_limits::signaling_NaN  \n Returns the representation of a signaling not a number (NAN) for the type.  \n  \n```  \nstatic Type signaling_NaN() throw();\n```  \n  \n### Return Value  \n The representation of a signaling NAN for the type.  \n  \n### Remarks  \n The return value is meaningful only if [has_signaling_NaN](#numeric_limits__has_signaling_nan) is **true**.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_signaling_nan.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"The signaling NaN for type float is:  \"  \n        << numeric_limits<float>::signaling_NaN( )  \n        << endl;  \n   cout << \"The signaling NaN for type int is:  \"  \n        << numeric_limits<int>::signaling_NaN( )  \n        << endl;  \n   cout << \"The signaling NaN for type long double is:  \"  \n        << numeric_limits<long double>::signaling_NaN( )  \n        << endl;  \n}  \n```  \n  \n##  <a name=\"numeric_limits__tinyness_before\"></a>  numeric_limits::tinyness_before  \n Tests whether a type can determine that a value is too small to represent as a normalized value before rounding it.  \n  \n```  \nstatic const bool tinyness_before = false;  \n```  \n  \n### Return Value  \n `true` if the type can detect tiny values before rounding; `false` if it cannot.  \n  \n### Remarks  \n Types that can detect tinyness were included as an option with IEC 559 floating-point representations and its implementation can affect some results.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_tinyness_before.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float types can detect tinyness before rounding: \"  \n        << numeric_limits<float>::tinyness_before  \n        << endl;  \n   cout << \"Whether double types can detect tinyness before rounding: \"  \n        << numeric_limits<double>::tinyness_before  \n        << endl;  \n   cout << \"Whether long int types can detect tinyness before rounding: \"  \n        << numeric_limits<long int>::tinyness_before  \n        << endl;  \n   cout << \"Whether unsigned char types can detect tinyness before rounding: \"  \n        << numeric_limits<unsigned char>::tinyness_before  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float types can detect tinyness before rounding: 1  \nWhether double types can detect tinyness before rounding: 1  \nWhether long int types can detect tinyness before rounding: 0  \nWhether unsigned char types can detect tinyness before rounding: 0  \n```  \n  \n##  <a name=\"numeric_limits__traps\"></a>  numeric_limits::traps  \n Tests whether trapping that reports on arithmetic exceptions is implemented for a type.  \n  \n```  \nstatic const bool traps = false;  \n```  \n  \n### Return Value  \n **true** if trapping is implemented for the type; **false** if it is not.  \n  \n### Example  \n  \n```cpp  \n// numeric_limits_traps.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <limits>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   cout << \"Whether float types have implemented trapping: \"  \n        << numeric_limits<float>::traps  \n        << endl;  \n   cout << \"Whether double types have implemented trapping: \"  \n        << numeric_limits<double>::traps  \n        << endl;  \n   cout << \"Whether long int types have implemented trapping: \"  \n        << numeric_limits<long int>::traps  \n        << endl;  \n   cout << \"Whether unsigned char types have implemented trapping: \"  \n        << numeric_limits<unsigned char>::traps  \n        << endl;  \n}  \n```  \n  \n```Output  \nWhether float types have implemented trapping: 1  \nWhether double types have implemented trapping: 1  \nWhether long int types have implemented trapping: 0  \nWhether unsigned char types have implemented trapping: 0  \n```  \n  \n## See Also  \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)\n\n"}