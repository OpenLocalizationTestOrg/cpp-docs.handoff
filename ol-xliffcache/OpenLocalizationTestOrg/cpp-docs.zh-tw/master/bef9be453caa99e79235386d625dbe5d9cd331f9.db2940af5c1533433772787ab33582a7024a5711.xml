{"nodes":[{"pos":[12,46],"content":"basic_regex Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"basic_regex Class | Microsoft Docs","pos":[0,34]}]},{"content":"basic_regex Class","pos":[665,682]},{"content":"Wraps a regular expression.","pos":[683,710]},{"content":"Syntax","pos":[719,725]},{"content":"Parameters","pos":[2984,2994]},{"content":"The type of elements to match.","pos":[3008,3038]},{"content":"Traits class for elements.","pos":[3059,3085]},{"content":"Remarks","pos":[3094,3101]},{"content":"The template class describes an object that holds a regular expression.","pos":[3105,3176]},{"content":"Objects of this template class can be passed to the template functions <bpt id=\"p1\">[</bpt>regex_match Function<ept id=\"p1\">](../standard-library/regex-functions.md#regex_match_function)</ept>, <bpt id=\"p2\">[</bpt>regex_search Function<ept id=\"p2\">](../standard-library/regex-functions.md#regex_search_function)</ept>, and <bpt id=\"p3\">[</bpt>regex_replace Function<ept id=\"p3\">](../standard-library/regex-functions.md#regex_replace_function)</ept>, along with suitable text string arguments, to search for text that matches the regular expression.","pos":[3177,3611],"source":" Objects of this template class can be passed to the template functions [regex_match Function](../standard-library/regex-functions.md#regex_match_function), [regex_search Function](../standard-library/regex-functions.md#regex_search_function), and [regex_replace Function](../standard-library/regex-functions.md#regex_replace_function), along with suitable text string arguments, to search for text that matches the regular expression."},{"content":"There are two specializations of this template class, with the type definitions <bpt id=\"p1\">[</bpt>regex<ept id=\"p1\">](../standard-library/regex-typedefs.md#regex_typedef)</ept> for elements of type <ph id=\"ph1\">`char`</ph>, and <bpt id=\"p2\">[</bpt>wregex<ept id=\"p2\">](../standard-library/regex-typedefs.md#wregex_typedef)</ept> for elements of type <ph id=\"ph2\">`wchar_t`</ph>.","pos":[3612,3880],"source":" There are two specializations of this template class, with the type definitions [regex](../standard-library/regex-typedefs.md#regex_typedef) for elements of type `char`, and [wregex](../standard-library/regex-typedefs.md#wregex_typedef) for elements of type `wchar_t`."},{"content":"The template argument <ph id=\"ph1\">`RXtraits`</ph> describes various important properties of the syntax of the regular expressions that the template class supports.","pos":[3887,4033],"source":"The template argument `RXtraits` describes various important properties of the syntax of the regular expressions that the template class supports."},{"content":"A class that specifies these regular expression traits must have the same external interface as an object of template class <bpt id=\"p1\">[</bpt>regex_traits Class<ept id=\"p1\">](../standard-library/regex-traits-class.md)</ept>.","pos":[4034,4222],"source":" A class that specifies these regular expression traits must have the same external interface as an object of template class [regex_traits Class](../standard-library/regex-traits-class.md)."},{"content":"Some functions take an operand sequence that defines a regular expression.","pos":[4229,4303]},{"content":"You can specify such an operand sequence several ways:","pos":[4304,4358]},{"pos":[4371,4601],"content":"-- a null-terminated sequence (such as a C string, for <ph id=\"ph1\">`Elem`</ph> of type <ph id=\"ph2\">`char`</ph>) beginning at <ph id=\"ph3\">`ptr`</ph> (which must not be a null pointer), where the terminating element is the value <ph id=\"ph4\">`value_type()`</ph> and is not part of the operand sequence","source":" -- a null-terminated sequence (such as a C string, for `Elem` of type `char`) beginning at `ptr` (which must not be a null pointer), where the terminating element is the value `value_type()` and is not part of the operand sequence"},{"pos":[4613,4710],"content":", <ph id=\"ph1\">`count`</ph> -- a sequence of <ph id=\"ph2\">`count`</ph> elements beginning at <ph id=\"ph3\">`ptr`</ph> (which must not be a null pointer)","source":", `count` -- a sequence of `count` elements beginning at `ptr` (which must not be a null pointer)"},{"pos":[4723,4777],"content":"-- the sequence specified by the <ph id=\"ph1\">`basic_string`</ph> object","source":" -- the sequence specified by the `basic_string` object "},{"pos":[4797,4891],"content":", <ph id=\"ph1\">`last`</ph> -- a sequence of elements delimited by the iterators <ph id=\"ph2\">`first`</ph> and <ph id=\"ph3\">`last`</ph>, in the range","source":", `last` -- a sequence of elements delimited by the iterators `first` and `last`, in the range "},{"pos":[4922,4949],"content":"-- the <ph id=\"ph1\">`basic_regex`</ph> object","source":" -- the `basic_regex` object "},{"pos":[4964,5151],"content":"These member functions also take an argument <ph id=\"ph1\">`flags`</ph> that specifies various options for the interpretation of the regular expression in addition to those described by the <ph id=\"ph2\">`RXtraits`</ph> type.","source":"These member functions also take an argument `flags` that specifies various options for the interpretation of the regular expression in addition to those described by the `RXtraits` type."},{"content":"Requirements","pos":[5160,5172]},{"pos":[5176,5196],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>regex&gt;","source":"**Header:** \\<regex>"},{"pos":[5203,5221],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[5267,5286],"content":"basic_regex::assign"},{"content":"Assigns a value to the regular expressoin object.","pos":[5290,5339]},{"content":"Parameters","pos":[5975,5985]},{"content":"Traits class for a string source.","pos":[6003,6036]},{"content":"Allocator class for a string source.","pos":[6056,6092]},{"content":"Input iterator type for a range source.","pos":[6109,6148]},{"content":"Regex source to copy.","pos":[6166,6187]},{"content":"Pointer to beginning of sequence to copy.","pos":[6203,6244]},{"content":"Syntax option flags to add while copying.","pos":[6262,6303]},{"content":"Length of sequence to copy.","pos":[6323,6350]},{"content":"String to copy.","pos":[6366,6381]},{"content":"Beginning of sequence to copy.","pos":[6399,6429]},{"content":"End of sequence to copy.","pos":[6446,6470]},{"content":"The initializer_list to copy.","pos":[6488,6517]},{"content":"Remarks","pos":[6527,6534]},{"pos":[6538,6694],"content":"The member functions each replace the regular expression held by <ph id=\"ph1\">`*this`</ph> with the regular expression described by the operand sequence, then return <ph id=\"ph2\">`*this`</ph>.","source":"The member functions each replace the regular expression held by `*this` with the regular expression described by the operand sequence, then return `*this`."},{"content":"Example","pos":[6704,6711]},{"pos":[9120,9144],"content":"basic_regex::basic_regex"},{"content":"Construct the regular expression object.","pos":[9148,9188]},{"content":"Parameters","pos":[9752,9762]},{"content":"Traits class for a string source.","pos":[9780,9813]},{"content":"Allocator class for a string source.","pos":[9833,9869]},{"content":"Input iterator type for a range source.","pos":[9886,9925]},{"content":"Regex source to copy.","pos":[9943,9964]},{"content":"Pointer to beginning of sequence to copy.","pos":[9980,10021]},{"content":"Syntax option flags to add while copying.","pos":[10039,10080]},{"content":"Length of sequence to copy.","pos":[10100,10127]},{"content":"String to copy.","pos":[10143,10158]},{"content":"Beginning of sequence to copy.","pos":[10176,10206]},{"content":"End of sequence to copy.","pos":[10223,10247]},{"content":"The initializer_list to copy.","pos":[10265,10294]},{"content":"Remarks","pos":[10304,10311]},{"pos":[10315,10386],"content":"All constructors store a default-constructed object of type <ph id=\"ph1\">`RXtraits`</ph>.","source":"All constructors store a default-constructed object of type `RXtraits`."},{"content":"The first constructor constructs an empty <ph id=\"ph1\">`basic_regex`</ph> object.","pos":[10393,10456],"source":"The first constructor constructs an empty `basic_regex` object."},{"content":"The other constructors construct a <ph id=\"ph1\">`basic_regex`</ph> object that holds the regular expression described by the operand sequence.","pos":[10457,10581],"source":" The other constructors construct a `basic_regex` object that holds the regular expression described by the operand sequence."},{"pos":[10588,10934],"content":"An empty <ph id=\"ph1\">`basic_regex`</ph> object does not match any character sequence when passed to <bpt id=\"p1\">[</bpt>regex_match Function<ept id=\"p1\">](../standard-library/regex-functions.md#regex_match_function)</ept>, <bpt id=\"p2\">[</bpt>regex_search Function<ept id=\"p2\">](../standard-library/regex-functions.md#regex_search_function)</ept>, or <bpt id=\"p3\">[</bpt>regex_replace Function<ept id=\"p3\">](../standard-library/regex-functions.md#regex_replace_function)</ept>.","source":"An empty `basic_regex` object does not match any character sequence when passed to [regex_match Function](../standard-library/regex-functions.md#regex_match_function), [regex_search Function](../standard-library/regex-functions.md#regex_search_function), or [regex_replace Function](../standard-library/regex-functions.md#regex_replace_function)."},{"content":"Example","pos":[10944,10951]},{"pos":[13359,13381],"content":"basic_regex::flag_type"},{"content":"The type of syntax option flags.","pos":[13385,13417]},{"content":"Remarks","pos":[13499,13506]},{"pos":[13510,13656],"content":"The type is a synonym for <bpt id=\"p1\">[</bpt>regex_constants::syntax_option_type<ept id=\"p1\">](../standard-library/regex-constants-class.md#regex_constants__syntax_option_type)</ept>.","source":"The type is a synonym for [regex_constants::syntax_option_type](../standard-library/regex-constants-class.md#regex_constants__syntax_option_type)."},{"content":"Example","pos":[13666,13673]},{"pos":[16139,16157],"content":"basic_regex::flags"},{"content":"Returns syntax option flags.","pos":[16161,16189]},{"content":"Remarks","pos":[16239,16246]},{"pos":[16250,16493],"content":"The member function returns the value of the <ph id=\"ph1\">`flag_type`</ph> argument passed to the most recent call to one of the <bpt id=\"p1\">[</bpt>basic_regex::assign<ept id=\"p1\">](#basic_regex__assign)</ept> member functions or, if no such call has been made, the value passed to the constructor.","source":"The member function returns the value of the `flag_type` argument passed to the most recent call to one of the [basic_regex::assign](#basic_regex__assign) member functions or, if no such call has been made, the value passed to the constructor."},{"content":"Example","pos":[16503,16510]},{"pos":[18973,18992],"content":"basic_regex::getloc"},{"content":"Returns the stored locale object.","pos":[18996,19029]},{"content":"Remarks","pos":[19082,19089]},{"pos":[19093,19221],"content":"The member function returns <ph id=\"ph1\">`traits.`</ph><bpt id=\"p1\">[</bpt>regex_traits::getloc<ept id=\"p1\">](../standard-library/regex-traits-class.md#regex_traits__getloc)</ept><ph id=\"ph2\">`()`</ph>.","source":"The member function returns `traits.`[regex_traits::getloc](../standard-library/regex-traits-class.md#regex_traits__getloc)`()`."},{"content":"Example","pos":[19231,19238]},{"pos":[21701,21719],"content":"basic_regex::imbue"},{"content":"Alters the stored locale object.","pos":[21723,21755]},{"content":"Parameters","pos":[21816,21826]},{"content":"The locale object to store.","pos":[21839,21866]},{"content":"Remarks","pos":[21876,21883]},{"pos":[21887,22036],"content":"The member function empties <ph id=\"ph1\">`*this`</ph> and returns <ph id=\"ph2\">`traits.`</ph><bpt id=\"p1\">[</bpt>regex_traits::imbue<ept id=\"p1\">](../standard-library/regex-traits-class.md#regex_traits__imbue)</ept><ph id=\"ph3\">`(loc)`</ph>.","source":"The member function empties `*this` and returns `traits.`[regex_traits::imbue](../standard-library/regex-traits-class.md#regex_traits__imbue)`(loc)`."},{"content":"Example","pos":[22046,22053]},{"pos":[24521,24545],"content":"basic_regex::locale_type"},{"content":"The type of the stored locale object.","pos":[24549,24586]},{"content":"Remarks","pos":[24665,24672]},{"pos":[24676,24799],"content":"The type is a synonym for <bpt id=\"p1\">[</bpt>regex_traits::locale_type<ept id=\"p1\">](../standard-library/regex-traits-class.md#regex_traits__locale_type)</ept>.","source":"The type is a synonym for [regex_traits::locale_type](../standard-library/regex-traits-class.md#regex_traits__locale_type)."},{"content":"Example","pos":[24809,24816]},{"pos":[27289,27312],"content":"basic_regex::mark_count"},{"content":"Returns number of subexpressions matched.","pos":[27316,27357]},{"content":"Remarks","pos":[27411,27418]},{"content":"The member function returns the number of capture groups in the regular expression.","pos":[27422,27505]},{"content":"Example","pos":[27515,27522]},{"pos":[29995,30017],"content":"basic_regex::operator="},{"content":"Assigns a value to the regular expression object.","pos":[30021,30070]},{"content":"Parameters","pos":[30305,30315]},{"content":"Traits class for a string source.","pos":[30333,30366]},{"content":"Allocator class for a string source.","pos":[30386,30422]},{"content":"Regex source to copy.","pos":[30440,30461]},{"content":"String to copy.","pos":[30477,30492]},{"content":"Remarks","pos":[30502,30509]},{"pos":[30513,30662],"content":"The operators each replace the regular expression held by <ph id=\"ph1\">`*this`</ph> with the regular expression described by the operand sequence, then return <ph id=\"ph2\">`*this`</ph>.","source":"The operators each replace the regular expression held by `*this` with the regular expression described by the operand sequence, then return `*this`."},{"content":"Example","pos":[30672,30679]},{"pos":[33146,33163],"content":"basic_regex::swap"},{"content":"Swaps two regular expression objects.","pos":[33167,33204]},{"content":"Parameters","pos":[33268,33278]},{"content":"The regular expression object to swap with.","pos":[33293,33336]},{"content":"Remarks","pos":[33346,33353]},{"content":"The member function swaps the regular expressions between <ph id=\"ph1\">`*this`</ph> and <ph id=\"ph2\">`right`</ph>.","pos":[33357,33435],"source":"The member function swaps the regular expressions between `*this` and `right`."},{"content":"It does so in constant time and throws no exceptions.","pos":[33436,33489]},{"content":"Example","pos":[33499,33506]},{"pos":[35972,35995],"content":"basic_regex::value_type"},{"content":"The element type.","pos":[35999,36016]},{"content":"Remarks","pos":[36068,36075]},{"pos":[36079,36135],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Elem`</ph>.","source":"The type is a synonym for the template parameter `Elem`."},{"content":"Example","pos":[36145,36152]},{"content":"See Also","pos":[38583,38591]},{"content":"regex&gt;","pos":[38598,38604],"source":"regex>"},{"content":"regex_match Function","pos":[38641,38661]},{"content":"regex_search Function","pos":[38729,38750]},{"content":"regex_replace Function","pos":[38819,38841]},{"content":"regex","pos":[38911,38916]},{"content":"wregex","pos":[38976,38982]},{"content":"regex_traits Class","pos":[39043,39061]}],"content":"---\ntitle: \"basic_regex Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std::tr1::basic_regex\"\n  - \"basic_regex\"\n  - \"std.tr1.basic_regex\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"basic_regex class [TR1]\"\nms.assetid: 8a18c6b4-f22a-4cfd-bc16-b4267867ebc3\ncaps.latest.revision: 21\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# basic_regex Class\nWraps a regular expression.  \n  \n## Syntax  \n  \n```  \nclass basic_regex {  \n   public:  \n   basic_regex();\n   explicit basic_regex(const Elem *ptr,  \n   flag_type flags = ECMAScript);\n   basic_regex(const Elem *ptr, size_type len,  \n   flag_type flags = ECMAScript);\n   basic_regex(const basic_regex& right);\n   template <class STtraits, class STalloc>  \n   explicit basic_regex(const basic_string<Elem, STtraits, STalloc>& str,  \n   flag_type flags = ECMAScript);\n   template <class InIt>  \n   explicit basic_regex(InIt first, InIt last,  \n   flag_type flags = ECMAScript);\n   basic_regex& operator=(const basic_regex& right);\n   basic_regex& operator=(const Elem *ptr);\n   template <class STtraits, class STalloc>  \n   basic_regex& operator=(const basic_string<Elem, STtraits, STalloc>& str);\n   basic_regex& assign(const basic_regex& right);\n   basic_regex& assign(const Elem *ptr,  \n   flag_type flags = ECMAScript);\n   basic_regex& assign(const Elem *ptr, size_type len,  \n   flag_type flags = ECMAScript);\n   template <class STtraits, class STalloc>  \n   basic_regex& assign(const basic_string<Elem, STtraits, STalloc>& str,  \n   flag_type flags = ECMAScript);\n   template <class InIt>  \n   basic_regex& assign(InIt first, InIt last,  \n   flag_type flags = ECMAScript);\n   locale_type imbue(locale_type loc);\n   locale_type getloc() const;\n   void swap(basic_regex& other) throw();\n   unsigned mark_count() const;\n   flag_type flags() const;\n   typedef Elem value_type;  \n   typedef regex_constants::syntax_option_type flag_type;  \n   typedef typename RXtraits::locale_type locale_type;  \n   static const flag_type icase = regex_constants::icase;  \n   static const flag_type nosubs = regex_constants::nosubs;  \n   static const flag_type optimize = regex_constants::optimize;  \n   static const flag_type collate = regex_constants::collate;  \n   static const flag_type ECMAScript = regex_constants::ECMAScript;  \n   static const flag_type basic = regex_constants::basic;  \n   static const flag_type extended = regex_constants::extended;  \n   static const flag_type awk = regex_constants::awk;  \n   static const flag_type grep = regex_constants::grep;  \n   static const flag_type egrep = regex_constants::egrep;  \n   private:  \n   RXtraits traits;    // exposition only  \n   };  \n   ```   \n  \n#### Parameters  \n `Elem`  \n The type of elements to match.  \n  \n `RXtraits`  \n Traits class for elements.  \n  \n## Remarks  \n The template class describes an object that holds a regular expression. Objects of this template class can be passed to the template functions [regex_match Function](../standard-library/regex-functions.md#regex_match_function), [regex_search Function](../standard-library/regex-functions.md#regex_search_function), and [regex_replace Function](../standard-library/regex-functions.md#regex_replace_function), along with suitable text string arguments, to search for text that matches the regular expression. There are two specializations of this template class, with the type definitions [regex](../standard-library/regex-typedefs.md#regex_typedef) for elements of type `char`, and [wregex](../standard-library/regex-typedefs.md#wregex_typedef) for elements of type `wchar_t`.  \n  \n The template argument `RXtraits` describes various important properties of the syntax of the regular expressions that the template class supports. A class that specifies these regular expression traits must have the same external interface as an object of template class [regex_traits Class](../standard-library/regex-traits-class.md).  \n  \n Some functions take an operand sequence that defines a regular expression. You can specify such an operand sequence several ways:  \n  \n `ptr` -- a null-terminated sequence (such as a C string, for `Elem` of type `char`) beginning at `ptr` (which must not be a null pointer), where the terminating element is the value `value_type()` and is not part of the operand sequence  \n  \n `ptr`, `count` -- a sequence of `count` elements beginning at `ptr` (which must not be a null pointer)  \n  \n `str` -- the sequence specified by the `basic_string` object `str`  \n  \n `first`, `last` -- a sequence of elements delimited by the iterators `first` and `last`, in the range `[first, last)`  \n  \n `right` -- the `basic_regex` object `right`  \n  \n These member functions also take an argument `flags` that specifies various options for the interpretation of the regular expression in addition to those described by the `RXtraits` type.  \n  \n## Requirements  \n **Header:** \\<regex>  \n  \n **Namespace:** std  \n  \n##  <a name=\"basic_regex__assign\"></a>  basic_regex::assign  \n Assigns a value to the regular expressoin object.  \n  \n```  \nbasic_regex& assign(\n    const basic_regex& right);\n\nbasic_regex& assign(\n    const Elem* ptr,  \n    flag_type flags = ECMAScript);\n\nbasic_regex& assign(\n    const Elem* ptr,   \n    size_type len,  \n    flag_type flags = ECMAScript);\n\nbasic_regex& assign(\n    initializer_list<_Elem> IList,  \n    flag_type flags = regex_constants::ECMAScript);\n\ntemplate <class STtraits, class STalloc>  \nbasic_regex& assign(\n    const basic_string<Elem, STtraits, STalloc>& str,  \n    flag_type flags = ECMAScript);\n\ntemplate <class InIt>  \nbasic_regex& assign(\n    InIt first, InIt last,  \n    flag_type flags = ECMAScript);\n```  \n  \n### Parameters  \n `STtraits`  \n Traits class for a string source.  \n  \n `STalloc`  \n Allocator class for a string source.  \n  \n `InIt`  \n Input iterator type for a range source.  \n  \n `right`  \n Regex source to copy.  \n  \n `ptr`  \n Pointer to beginning of sequence to copy.  \n  \n `flags`  \n Syntax option flags to add while copying.  \n  \n `len/TD>`  \n Length of sequence to copy.  \n  \n `str`  \n String to copy.  \n  \n `first`  \n Beginning of sequence to copy.  \n  \n `last`  \n End of sequence to copy.  \n  \n `IList`  \n The initializer_list to copy.  \n  \n### Remarks  \n The member functions each replace the regular expression held by `*this` with the regular expression described by the operand sequence, then return `*this`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__basic_regex_assign.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nusing namespace std;  \n  \nint main()  \n{  \n    regex::value_type elem = 'x';  \n    regex::flag_type flag = regex::grep;  \n  \n    elem = elem;  // to quiet \"unused\" warnings   \n    flag = flag;  \n  \n    // constructors   \n    regex rx0;  \n    cout << \"match(\\\"abc\\\", \\\"\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx0) << endl;  \n  \n    regex rx1(\"abcd\", regex::ECMAScript);  \n    cout << \"match(\\\"abc\\\", \\\"abcd\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx1) << endl;  \n  \n    regex rx2(\"abcd\", 3);  \n    cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx2) << endl;  \n  \n    regex rx3(rx2);  \n    cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx3) << endl;  \n  \n    string str(\"abcd\");  \n    regex rx4(str);  \n    cout << \"match(string(\\\"abcd\\\"), \\\"abc\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx4) << endl;  \n  \n    regex rx5(str.begin(), str.end() - 1);  \n    cout << \"match(string(\\\"abc\\\"), \\\"abc\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx5) << endl;  \n    cout << endl;  \n  \n    // assignments   \n    rx0 = \"abc\";  \n    rx0 = rx1;  \n    rx0 = str;  \n  \n    rx0.assign(\"abcd\", regex::ECMAScript);  \n    rx0.assign(\"abcd\", 3);  \n    rx0.assign(rx1);  \n    rx0.assign(str);  \n    rx0.assign(str.begin(), str.end() - 1);  \n  \n    rx0.swap(rx1);  \n  \n    // mark_count   \n    cout << \"\\\"abc\\\" mark_count == \"  \n        << regex(\"abc\").mark_count() << endl;  \n    cout << \"\\\"(abc)\\\" mark_count == \"  \n        << regex(\"(abc)\").mark_count() << endl;  \n  \n    // locales   \n    regex::locale_type loc = rx0.imbue(locale());  \n    cout << \"getloc == imbued == \" << boolalpha  \n        << (loc == rx0.getloc()) << endl;  \n  \n    // initializer_list  \n    regex rx6({ 'a', 'b', 'c' }, regex::ECMAScript);  \n    cout << \"match(\\\"abc\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx6);  \n    cout << endl;   \n}  \n  \n```  \n  \n```Output  \nmatch(\"abc\", \"\") == falsematch(\"abc\", \"abcd\") == falsematch(\"abc\", \"abc\") == truematch(\"abc\", \"abc\") == truematch(string(\"abcd\"), \"abc\") == falsematch(string(\"abc\"), \"abc\") == true\"abc\" mark_count == 0\"(abc)\" mark_count == 1getloc == imbued == truematch(\"abc\") == true  \n```  \n  \n##  <a name=\"basic_regex__basic_regex\"></a>  basic_regex::basic_regex  \n Construct the regular expression object.  \n  \n```  \nbasic_regex();\n\nexplicit basic_regex(\n    const Elem* ptr,  \n    flag_type flags);\n\nexplicit basic_regex(\n    const Elem* ptr,   \n    size_type len,  \n    flag_type flags);\n\nbasic_regex(\n    const basic_regex& right);\n\nbasic_regex(\n    initializer_list<Type> IList,  \n    flag_type flags);\n\ntemplate <class STtraits, class STalloc>  \nexplicit basic_regex(\n    const basic_string<Elem, STtraits, STalloc>& str,  \n    flag_type flags);\n\ntemplate <class InIt>  \nexplicit basic_regex(\n    InIt first,   \n    InIt last,  \n    flag_type flags);\n```  \n  \n### Parameters  \n `STtraits`  \n Traits class for a string source.  \n  \n `STalloc`  \n Allocator class for a string source.  \n  \n `InIt`  \n Input iterator type for a range source.  \n  \n `right`  \n Regex source to copy.  \n  \n `ptr`  \n Pointer to beginning of sequence to copy.  \n  \n `flags`  \n Syntax option flags to add while copying.  \n  \n `len/TD>`  \n Length of sequence to copy.  \n  \n `str`  \n String to copy.  \n  \n `first`  \n Beginning of sequence to copy.  \n  \n `last`  \n End of sequence to copy.  \n  \n `IList`  \n The initializer_list to copy.  \n  \n### Remarks  \n All constructors store a default-constructed object of type `RXtraits`.  \n  \n The first constructor constructs an empty `basic_regex` object. The other constructors construct a `basic_regex` object that holds the regular expression described by the operand sequence.  \n  \n An empty `basic_regex` object does not match any character sequence when passed to [regex_match Function](../standard-library/regex-functions.md#regex_match_function), [regex_search Function](../standard-library/regex-functions.md#regex_search_function), or [regex_replace Function](../standard-library/regex-functions.md#regex_replace_function).  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__basic_regex_construct.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nusing namespace std;  \n  \nint main()  \n{  \n    regex::value_type elem = 'x';  \n    regex::flag_type flag = regex::grep;  \n  \n    elem = elem;  // to quiet \"unused\" warnings   \n    flag = flag;  \n  \n    // constructors   \n    regex rx0;  \n    cout << \"match(\\\"abc\\\", \\\"\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx0) << endl;  \n  \n    regex rx1(\"abcd\", regex::ECMAScript);  \n    cout << \"match(\\\"abc\\\", \\\"abcd\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx1) << endl;  \n  \n    regex rx2(\"abcd\", 3);  \n    cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx2) << endl;  \n  \n    regex rx3(rx2);  \n    cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx3) << endl;  \n  \n    string str(\"abcd\");  \n    regex rx4(str);  \n    cout << \"match(string(\\\"abcd\\\"), \\\"abc\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx4) << endl;  \n  \n    regex rx5(str.begin(), str.end() - 1);  \n    cout << \"match(string(\\\"abc\\\"), \\\"abc\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx5) << endl;  \n    cout << endl;  \n  \n    // assignments   \n    rx0 = \"abc\";  \n    rx0 = rx1;  \n    rx0 = str;  \n  \n    rx0.assign(\"abcd\", regex::ECMAScript);  \n    rx0.assign(\"abcd\", 3);  \n    rx0.assign(rx1);  \n    rx0.assign(str);  \n    rx0.assign(str.begin(), str.end() - 1);  \n  \n    rx0.swap(rx1);  \n  \n    // mark_count   \n    cout << \"\\\"abc\\\" mark_count == \"  \n        << regex(\"abc\").mark_count() << endl;  \n    cout << \"\\\"(abc)\\\" mark_count == \"  \n        << regex(\"(abc)\").mark_count() << endl;  \n  \n    // locales   \n    regex::locale_type loc = rx0.imbue(locale());  \n    cout << \"getloc == imbued == \" << boolalpha  \n        << (loc == rx0.getloc()) << endl;  \n  \n    // initializer_list  \n    regex rx6{ { 'a', 'b', 'c' } };  \n    cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << boolalpha  \n        << regex_match(\"abc\", rx6);  \n    cout << endl;  \n}  \n  \n```  \n  \n```Output  \nmatch(\"abc\", \"\") == falsematch(\"abc\", \"abcd\") == falsematch(\"abc\", \"abc\") == truematch(\"abc\", \"abc\") == truematch(string(\"abcd\"), \"abc\") == falsematch(string(\"abc\"), \"abc\") == true\"abc\" mark_count == 0\"(abc)\" mark_count == 1getloc == imbued == truematch(\"abc\", \"abc\") == true  \n```  \n  \n##  <a name=\"basic_regex__flag_type\"></a>  basic_regex::flag_type  \n The type of syntax option flags.  \n  \n```  \ntypedef regex_constants::syntax_option_type flag_type;  \n```  \n  \n### Remarks  \n The type is a synonym for [regex_constants::syntax_option_type](../standard-library/regex-constants-class.md#regex_constants__syntax_option_type).  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__basic_regex_flag_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex::value_type elem = 'x';   \n    std::regex::flag_type flag = std::regex::grep;   \n  \n    elem = elem;  // to quiet \"unused\" warnings   \n    flag = flag;   \n  \n// constructors   \n    std::regex rx0;   \n    std::cout << \"match(\\\"abc\\\", \\\"\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx0) << std::endl;   \n  \n    std::regex rx1(\"abcd\", std::regex::ECMAScript);   \n    std::cout << \"match(\\\"abc\\\", \\\"abcd\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx1) << std::endl;   \n  \n    std::regex rx2(\"abcd\", 3);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx2) << std::endl;   \n  \n    std::regex rx3(rx2);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx3) << std::endl;   \n  \n    std::string str(\"abcd\");   \n    std::regex rx4(str);   \n    std::cout << \"match(string(\\\"abcd\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx4) << std::endl;   \n  \n    std::regex rx5(str.begin(), str.end() - 1);   \n    std::cout << \"match(string(\\\"abc\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx5) << std::endl;   \n    std::cout << std::endl;   \n  \n// assignments   \n    rx0 = \"abc\";   \n    rx0 = rx1;   \n    rx0 = str;   \n  \n    rx0.assign(\"abcd\", std::regex::ECMAScript);   \n    rx0.assign(\"abcd\", 3);   \n    rx0.assign(rx1);   \n    rx0.assign(str);   \n    rx0.assign(str.begin(), str.end() - 1);   \n  \n    rx0.swap(rx1);   \n  \n// mark_count   \n    std::cout << \"\\\"abc\\\" mark_count == \"   \n        << std::regex(\"abc\").mark_count() << std::endl;   \n    std::cout << \"\\\"(abc)\\\" mark_count == \"   \n        << std::regex(\"(abc)\").mark_count() << std::endl;   \n  \n// locales   \n    std::regex::locale_type loc = rx0.imbue(std::locale());   \n    std::cout << \"getloc == imbued == \" << std::boolalpha   \n        << (loc == rx0.getloc()) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch(\"abc\", \"\") == false  \nmatch(\"abc\", \"abcd\") == false  \nmatch(\"abc\", \"abc\") == true  \nmatch(\"abc\", \"abc\") == true  \nmatch(string(\"abcd\"), \"abc\") == false  \nmatch(string(\"abc\"), \"abc\") == true  \n  \n\"abc\" mark_count == 0  \n\"(abc)\" mark_count == 1  \ngetloc == imbued == true  \n```  \n  \n##  <a name=\"basic_regex__flags\"></a>  basic_regex::flags  \n Returns syntax option flags.  \n  \n```  \nflag_type flags() const;\n```  \n  \n### Remarks  \n The member function returns the value of the `flag_type` argument passed to the most recent call to one of the [basic_regex::assign](#basic_regex__assign) member functions or, if no such call has been made, the value passed to the constructor.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__basic_regex_flags.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex::value_type elem = 'x';   \n    std::regex::flag_type flag = std::regex::grep;   \n  \n    elem = elem;  // to quiet \"unused\" warnings   \n    flag = flag;   \n  \n// constructors   \n    std::regex rx0;   \n    std::cout << \"match(\\\"abc\\\", \\\"\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx0) << std::endl;   \n  \n    std::regex rx1(\"abcd\", std::regex::ECMAScript);   \n    std::cout << \"match(\\\"abc\\\", \\\"abcd\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx1) << std::endl;   \n  \n    std::regex rx2(\"abcd\", 3);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx2) << std::endl;   \n  \n    std::regex rx3(rx2);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx3) << std::endl;   \n  \n    std::string str(\"abcd\");   \n    std::regex rx4(str);   \n    std::cout << \"match(string(\\\"abcd\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx4) << std::endl;   \n  \n    std::regex rx5(str.begin(), str.end() - 1);   \n    std::cout << \"match(string(\\\"abc\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx5) << std::endl;   \n    std::cout << std::endl;   \n  \n// assignments   \n    rx0 = \"abc\";   \n    rx0 = rx1;   \n    rx0 = str;   \n  \n    rx0.assign(\"abcd\", std::regex::ECMAScript);   \n    rx0.assign(\"abcd\", 3);   \n    rx0.assign(rx1);   \n    rx0.assign(str);   \n    rx0.assign(str.begin(), str.end() - 1);   \n  \n    rx0.swap(rx1);   \n  \n// mark_count   \n    std::cout << \"\\\"abc\\\" mark_count == \"   \n        << std::regex(\"abc\").mark_count() << std::endl;   \n    std::cout << \"\\\"(abc)\\\" mark_count == \"   \n        << std::regex(\"(abc)\").mark_count() << std::endl;   \n  \n// locales   \n    std::regex::locale_type loc = rx0.imbue(std::locale());   \n    std::cout << \"getloc == imbued == \" << std::boolalpha   \n        << (loc == rx0.getloc()) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch(\"abc\", \"\") == false  \nmatch(\"abc\", \"abcd\") == false  \nmatch(\"abc\", \"abc\") == true  \nmatch(\"abc\", \"abc\") == true  \nmatch(string(\"abcd\"), \"abc\") == false  \nmatch(string(\"abc\"), \"abc\") == true  \n  \n\"abc\" mark_count == 0  \n\"(abc)\" mark_count == 1  \ngetloc == imbued == true  \n```  \n  \n##  <a name=\"basic_regex__getloc\"></a>  basic_regex::getloc  \n Returns the stored locale object.  \n  \n```  \nlocale_type getloc() const;\n```  \n  \n### Remarks  \n The member function returns `traits.`[regex_traits::getloc](../standard-library/regex-traits-class.md#regex_traits__getloc)`()`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__basic_regex_getloc.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex::value_type elem = 'x';   \n    std::regex::flag_type flag = std::regex::grep;   \n  \n    elem = elem;  // to quiet \"unused\" warnings   \n    flag = flag;   \n  \n// constructors   \n    std::regex rx0;   \n    std::cout << \"match(\\\"abc\\\", \\\"\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx0) << std::endl;   \n  \n    std::regex rx1(\"abcd\", std::regex::ECMAScript);   \n    std::cout << \"match(\\\"abc\\\", \\\"abcd\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx1) << std::endl;   \n  \n    std::regex rx2(\"abcd\", 3);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx2) << std::endl;   \n  \n    std::regex rx3(rx2);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx3) << std::endl;   \n  \n    std::string str(\"abcd\");   \n    std::regex rx4(str);   \n    std::cout << \"match(string(\\\"abcd\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx4) << std::endl;   \n  \n    std::regex rx5(str.begin(), str.end() - 1);   \n    std::cout << \"match(string(\\\"abc\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx5) << std::endl;   \n    std::cout << std::endl;   \n  \n// assignments   \n    rx0 = \"abc\";   \n    rx0 = rx1;   \n    rx0 = str;   \n  \n    rx0.assign(\"abcd\", std::regex::ECMAScript);   \n    rx0.assign(\"abcd\", 3);   \n    rx0.assign(rx1);   \n    rx0.assign(str);   \n    rx0.assign(str.begin(), str.end() - 1);   \n  \n    rx0.swap(rx1);   \n  \n// mark_count   \n    std::cout << \"\\\"abc\\\" mark_count == \"   \n        << std::regex(\"abc\").mark_count() << std::endl;   \n    std::cout << \"\\\"(abc)\\\" mark_count == \"   \n        << std::regex(\"(abc)\").mark_count() << std::endl;   \n  \n// locales   \n    std::regex::locale_type loc = rx0.imbue(std::locale());   \n    std::cout << \"getloc == imbued == \" << std::boolalpha   \n        << (loc == rx0.getloc()) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch(\"abc\", \"\") == false  \nmatch(\"abc\", \"abcd\") == false  \nmatch(\"abc\", \"abc\") == true  \nmatch(\"abc\", \"abc\") == true  \nmatch(string(\"abcd\"), \"abc\") == false  \nmatch(string(\"abc\"), \"abc\") == true  \n  \n\"abc\" mark_count == 0  \n\"(abc)\" mark_count == 1  \ngetloc == imbued == true  \n```  \n  \n##  <a name=\"basic_regex__imbue\"></a>  basic_regex::imbue  \n Alters the stored locale object.  \n  \n```  \nlocale_type imbue(locale_type loc);\n```  \n  \n### Parameters  \n `loc`  \n The locale object to store.  \n  \n### Remarks  \n The member function empties `*this` and returns `traits.`[regex_traits::imbue](../standard-library/regex-traits-class.md#regex_traits__imbue)`(loc)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__basic_regex_imbue.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex::value_type elem = 'x';   \n    std::regex::flag_type flag = std::regex::grep;   \n  \n    elem = elem;  // to quiet \"unused\" warnings   \n    flag = flag;   \n  \n// constructors   \n    std::regex rx0;   \n    std::cout << \"match(\\\"abc\\\", \\\"\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx0) << std::endl;   \n  \n    std::regex rx1(\"abcd\", std::regex::ECMAScript);   \n    std::cout << \"match(\\\"abc\\\", \\\"abcd\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx1) << std::endl;   \n  \n    std::regex rx2(\"abcd\", 3);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx2) << std::endl;   \n  \n    std::regex rx3(rx2);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx3) << std::endl;   \n  \n    std::string str(\"abcd\");   \n    std::regex rx4(str);   \n    std::cout << \"match(string(\\\"abcd\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx4) << std::endl;   \n  \n    std::regex rx5(str.begin(), str.end() - 1);   \n    std::cout << \"match(string(\\\"abc\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx5) << std::endl;   \n    std::cout << std::endl;   \n  \n// assignments   \n    rx0 = \"abc\";   \n    rx0 = rx1;   \n    rx0 = str;   \n  \n    rx0.assign(\"abcd\", std::regex::ECMAScript);   \n    rx0.assign(\"abcd\", 3);   \n    rx0.assign(rx1);   \n    rx0.assign(str);   \n    rx0.assign(str.begin(), str.end() - 1);   \n  \n    rx0.swap(rx1);   \n  \n// mark_count   \n    std::cout << \"\\\"abc\\\" mark_count == \"   \n        << std::regex(\"abc\").mark_count() << std::endl;   \n    std::cout << \"\\\"(abc)\\\" mark_count == \"   \n        << std::regex(\"(abc)\").mark_count() << std::endl;   \n  \n// locales   \n    std::regex::locale_type loc = rx0.imbue(std::locale());   \n    std::cout << \"getloc == imbued == \" << std::boolalpha   \n        << (loc == rx0.getloc()) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch(\"abc\", \"\") == false  \nmatch(\"abc\", \"abcd\") == false  \nmatch(\"abc\", \"abc\") == true  \nmatch(\"abc\", \"abc\") == true  \nmatch(string(\"abcd\"), \"abc\") == false  \nmatch(string(\"abc\"), \"abc\") == true  \n  \n\"abc\" mark_count == 0  \n\"(abc)\" mark_count == 1  \ngetloc == imbued == true  \n```  \n  \n##  <a name=\"basic_regex__locale_type\"></a>  basic_regex::locale_type  \n The type of the stored locale object.  \n  \n```  \ntypedef typename RXtraits::locale_type locale_type;  \n```  \n  \n### Remarks  \n The type is a synonym for [regex_traits::locale_type](../standard-library/regex-traits-class.md#regex_traits__locale_type).  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__basic_regex_locale_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex::value_type elem = 'x';   \n    std::regex::flag_type flag = std::regex::grep;   \n  \n    elem = elem;  // to quiet \"unused\" warnings   \n    flag = flag;   \n  \n// constructors   \n    std::regex rx0;   \n    std::cout << \"match(\\\"abc\\\", \\\"\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx0) << std::endl;   \n  \n    std::regex rx1(\"abcd\", std::regex::ECMAScript);   \n    std::cout << \"match(\\\"abc\\\", \\\"abcd\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx1) << std::endl;   \n  \n    std::regex rx2(\"abcd\", 3);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx2) << std::endl;   \n  \n    std::regex rx3(rx2);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx3) << std::endl;   \n  \n    std::string str(\"abcd\");   \n    std::regex rx4(str);   \n    std::cout << \"match(string(\\\"abcd\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx4) << std::endl;   \n  \n    std::regex rx5(str.begin(), str.end() - 1);   \n    std::cout << \"match(string(\\\"abc\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx5) << std::endl;   \n    std::cout << std::endl;   \n  \n// assignments   \n    rx0 = \"abc\";   \n    rx0 = rx1;   \n    rx0 = str;   \n  \n    rx0.assign(\"abcd\", std::regex::ECMAScript);   \n    rx0.assign(\"abcd\", 3);   \n    rx0.assign(rx1);   \n    rx0.assign(str);   \n    rx0.assign(str.begin(), str.end() - 1);   \n  \n    rx0.swap(rx1);   \n  \n// mark_count   \n    std::cout << \"\\\"abc\\\" mark_count == \"   \n        << std::regex(\"abc\").mark_count() << std::endl;   \n    std::cout << \"\\\"(abc)\\\" mark_count == \"   \n        << std::regex(\"(abc)\").mark_count() << std::endl;   \n  \n// locales   \n    std::regex::locale_type loc = rx0.imbue(std::locale());   \n    std::cout << \"getloc == imbued == \" << std::boolalpha   \n        << (loc == rx0.getloc()) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch(\"abc\", \"\") == false  \nmatch(\"abc\", \"abcd\") == false  \nmatch(\"abc\", \"abc\") == true  \nmatch(\"abc\", \"abc\") == true  \nmatch(string(\"abcd\"), \"abc\") == false  \nmatch(string(\"abc\"), \"abc\") == true  \n  \n\"abc\" mark_count == 0  \n\"(abc)\" mark_count == 1  \ngetloc == imbued == true  \n```  \n  \n##  <a name=\"basic_regex__mark_count\"></a>  basic_regex::mark_count  \n Returns number of subexpressions matched.  \n  \n```  \nunsigned mark_count() const;\n```  \n  \n### Remarks  \n The member function returns the number of capture groups in the regular expression.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__basic_regex_mark_count.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex::value_type elem = 'x';   \n    std::regex::flag_type flag = std::regex::grep;   \n  \n    elem = elem;  // to quiet \"unused\" warnings   \n    flag = flag;   \n  \n// constructors   \n    std::regex rx0;   \n    std::cout << \"match(\\\"abc\\\", \\\"\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx0) << std::endl;   \n  \n    std::regex rx1(\"abcd\", std::regex::ECMAScript);   \n    std::cout << \"match(\\\"abc\\\", \\\"abcd\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx1) << std::endl;   \n  \n    std::regex rx2(\"abcd\", 3);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx2) << std::endl;   \n  \n    std::regex rx3(rx2);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx3) << std::endl;   \n  \n    std::string str(\"abcd\");   \n    std::regex rx4(str);   \n    std::cout << \"match(string(\\\"abcd\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx4) << std::endl;   \n  \n    std::regex rx5(str.begin(), str.end() - 1);   \n    std::cout << \"match(string(\\\"abc\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx5) << std::endl;   \n    std::cout << std::endl;   \n  \n// assignments   \n    rx0 = \"abc\";   \n    rx0 = rx1;   \n    rx0 = str;   \n  \n    rx0.assign(\"abcd\", std::regex::ECMAScript);   \n    rx0.assign(\"abcd\", 3);   \n    rx0.assign(rx1);   \n    rx0.assign(str);   \n    rx0.assign(str.begin(), str.end() - 1);   \n  \n    rx0.swap(rx1);   \n  \n// mark_count   \n    std::cout << \"\\\"abc\\\" mark_count == \"   \n        << std::regex(\"abc\").mark_count() << std::endl;   \n    std::cout << \"\\\"(abc)\\\" mark_count == \"   \n        << std::regex(\"(abc)\").mark_count() << std::endl;   \n  \n// locales   \n    std::regex::locale_type loc = rx0.imbue(std::locale());   \n    std::cout << \"getloc == imbued == \" << std::boolalpha   \n        << (loc == rx0.getloc()) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch(\"abc\", \"\") == false  \nmatch(\"abc\", \"abcd\") == false  \nmatch(\"abc\", \"abc\") == true  \nmatch(\"abc\", \"abc\") == true  \nmatch(string(\"abcd\"), \"abc\") == false  \nmatch(string(\"abc\"), \"abc\") == true  \n  \n\"abc\" mark_count == 0  \n\"(abc)\" mark_count == 1  \ngetloc == imbued == true  \n```  \n  \n##  <a name=\"basic_regex__operator_eq\"></a>  basic_regex::operator=  \n Assigns a value to the regular expression object.  \n  \n```  \nbasic_regex& operator=(const basic_regex& right);\n\nbasic_regex& operator=(const Elem *str);\n\ntemplate <class STtraits, class STalloc>  \nbasic_regex& operator=(const basic_string<Elem, STtraits, STalloc>& str);\n```  \n  \n### Parameters  \n `STtraits`  \n Traits class for a string source.  \n  \n `STalloc`  \n Allocator class for a string source.  \n  \n `right`  \n Regex source to copy.  \n  \n `str`  \n String to copy.  \n  \n### Remarks  \n The operators each replace the regular expression held by `*this` with the regular expression described by the operand sequence, then return `*this`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__basic_regex_operator_as.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex::value_type elem = 'x';   \n    std::regex::flag_type flag = std::regex::grep;   \n  \n    elem = elem;  // to quiet \"unused\" warnings   \n    flag = flag;   \n  \n// constructors   \n    std::regex rx0;   \n    std::cout << \"match(\\\"abc\\\", \\\"\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx0) << std::endl;   \n  \n    std::regex rx1(\"abcd\", std::regex::ECMAScript);   \n    std::cout << \"match(\\\"abc\\\", \\\"abcd\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx1) << std::endl;   \n  \n    std::regex rx2(\"abcd\", 3);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx2) << std::endl;   \n  \n    std::regex rx3(rx2);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx3) << std::endl;   \n  \n    std::string str(\"abcd\");   \n    std::regex rx4(str);   \n    std::cout << \"match(string(\\\"abcd\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx4) << std::endl;   \n  \n    std::regex rx5(str.begin(), str.end() - 1);   \n    std::cout << \"match(string(\\\"abc\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx5) << std::endl;   \n    std::cout << std::endl;   \n  \n// assignments   \n    rx0 = \"abc\";   \n    rx0 = rx1;   \n    rx0 = str;   \n  \n    rx0.assign(\"abcd\", std::regex::ECMAScript);   \n    rx0.assign(\"abcd\", 3);   \n    rx0.assign(rx1);   \n    rx0.assign(str);   \n    rx0.assign(str.begin(), str.end() - 1);   \n  \n    rx0.swap(rx1);   \n  \n// mark_count   \n    std::cout << \"\\\"abc\\\" mark_count == \"   \n        << std::regex(\"abc\").mark_count() << std::endl;   \n    std::cout << \"\\\"(abc)\\\" mark_count == \"   \n        << std::regex(\"(abc)\").mark_count() << std::endl;   \n  \n// locales   \n    std::regex::locale_type loc = rx0.imbue(std::locale());   \n    std::cout << \"getloc == imbued == \" << std::boolalpha   \n        << (loc == rx0.getloc()) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch(\"abc\", \"\") == false  \nmatch(\"abc\", \"abcd\") == false  \nmatch(\"abc\", \"abc\") == true  \nmatch(\"abc\", \"abc\") == true  \nmatch(string(\"abcd\"), \"abc\") == false  \nmatch(string(\"abc\"), \"abc\") == true  \n  \n\"abc\" mark_count == 0  \n\"(abc)\" mark_count == 1  \ngetloc == imbued == true  \n```  \n  \n##  <a name=\"basic_regex__swap\"></a>  basic_regex::swap  \n Swaps two regular expression objects.  \n  \n```  \nvoid swap(basic_regex& right) throw();\n```  \n  \n### Parameters  \n `right`  \n The regular expression object to swap with.  \n  \n### Remarks  \n The member function swaps the regular expressions between `*this` and `right`. It does so in constant time and throws no exceptions.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__basic_regex_swap.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex::value_type elem = 'x';   \n    std::regex::flag_type flag = std::regex::grep;   \n  \n    elem = elem;  // to quiet \"unused\" warnings   \n    flag = flag;   \n  \n// constructors   \n    std::regex rx0;   \n    std::cout << \"match(\\\"abc\\\", \\\"\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx0) << std::endl;   \n  \n    std::regex rx1(\"abcd\", std::regex::ECMAScript);   \n    std::cout << \"match(\\\"abc\\\", \\\"abcd\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx1) << std::endl;   \n  \n    std::regex rx2(\"abcd\", 3);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx2) << std::endl;   \n  \n    std::regex rx3(rx2);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx3) << std::endl;   \n  \n    std::string str(\"abcd\");   \n    std::regex rx4(str);   \n    std::cout << \"match(string(\\\"abcd\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx4) << std::endl;   \n  \n    std::regex rx5(str.begin(), str.end() - 1);   \n    std::cout << \"match(string(\\\"abc\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx5) << std::endl;   \n    std::cout << std::endl;   \n  \n// assignments   \n    rx0 = \"abc\";   \n    rx0 = rx1;   \n    rx0 = str;   \n  \n    rx0.assign(\"abcd\", std::regex::ECMAScript);   \n    rx0.assign(\"abcd\", 3);   \n    rx0.assign(rx1);   \n    rx0.assign(str);   \n    rx0.assign(str.begin(), str.end() - 1);   \n  \n    rx0.swap(rx1);   \n  \n// mark_count   \n    std::cout << \"\\\"abc\\\" mark_count == \"   \n        << std::regex(\"abc\").mark_count() << std::endl;   \n    std::cout << \"\\\"(abc)\\\" mark_count == \"   \n        << std::regex(\"(abc)\").mark_count() << std::endl;   \n  \n// locales   \n    std::regex::locale_type loc = rx0.imbue(std::locale());   \n    std::cout << \"getloc == imbued == \" << std::boolalpha   \n        << (loc == rx0.getloc()) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch(\"abc\", \"\") == false  \nmatch(\"abc\", \"abcd\") == false  \nmatch(\"abc\", \"abc\") == true  \nmatch(\"abc\", \"abc\") == true  \nmatch(string(\"abcd\"), \"abc\") == false  \nmatch(string(\"abc\"), \"abc\") == true  \n  \n\"abc\" mark_count == 0  \n\"(abc)\" mark_count == 1  \ngetloc == imbued == true  \n```  \n  \n##  <a name=\"basic_regex__value_type\"></a>  basic_regex::value_type  \n The element type.  \n  \n```  \ntypedef Elem value_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `Elem`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__basic_regex_value_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex::value_type elem = 'x';   \n    std::regex::flag_type flag = std::regex::grep;   \n  \n    elem = elem;  // to quiet \"unused\" warnings   \n    flag = flag;   \n  \n// constructors   \n    std::regex rx0;   \n    std::cout << \"match(\\\"abc\\\", \\\"\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx0) << std::endl;   \n  \n    std::regex rx1(\"abcd\", std::regex::ECMAScript);   \n    std::cout << \"match(\\\"abc\\\", \\\"abcd\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx1) << std::endl;   \n  \n    std::regex rx2(\"abcd\", 3);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx2) << std::endl;   \n  \n    std::regex rx3(rx2);   \n    std::cout << \"match(\\\"abc\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx3) << std::endl;   \n  \n    std::string str(\"abcd\");   \n    std::regex rx4(str);   \n    std::cout << \"match(string(\\\"abcd\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx4) << std::endl;   \n  \n    std::regex rx5(str.begin(), str.end() - 1);   \n    std::cout << \"match(string(\\\"abc\\\"), \\\"abc\\\") == \" << std::boolalpha   \n        << regex_match(\"abc\", rx5) << std::endl;   \n    std::cout << std::endl;   \n  \n// assignments   \n    rx0 = \"abc\";   \n    rx0 = rx1;   \n    rx0 = str;   \n  \n    rx0.assign(\"abcd\", std::regex::ECMAScript);   \n    rx0.assign(\"abcd\", 3);   \n    rx0.assign(rx1);   \n    rx0.assign(str);   \n    rx0.assign(str.begin(), str.end() - 1);   \n  \n    rx0.swap(rx1);   \n  \n// mark_count   \n    std::cout << \"\\\"abc\\\" mark_count == \"   \n        << std::regex(\"abc\").mark_count() << std::endl;   \n    std::cout << \"\\\"(abc)\\\" mark_count == \"   \n        << std::regex(\"(abc)\").mark_count() << std::endl;   \n  \n// locales   \n    std::regex::locale_type loc = rx0.imbue(std::locale());   \n    std::cout << \"getloc == imbued == \" << std::boolalpha   \n        << (loc == rx0.getloc()) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch(\"abc\", \"\") == false  \nmatch(\"abc\", \"abcd\") == false  \nmatch(\"abc\", \"abc\") == true  \nmatch(\"abc\", \"abc\") == true  \nmatch(string(\"abcd\"), \"abc\") == false  \nmatch(string(\"abc\"), \"abc\") == true  \n  \n\"abc\" mark_count == 0  \n\"(abc)\" mark_count == 1  \ngetloc == imbued == true  \n```  \n  \n## See Also  \n [\\<regex>](../standard-library/regex.md)   \n [regex_match Function](../standard-library/regex-functions.md#regex_match_function)   \n [regex_search Function](../standard-library/regex-functions.md#regex_search_function)   \n [regex_replace Function](../standard-library/regex-functions.md#regex_replace_function)   \n [regex](../standard-library/regex-typedefs.md#regex_typedef)   \n [wregex](../standard-library/regex-typedefs.md#wregex_typedef)   \n [regex_traits Class](../standard-library/regex-traits-class.md)\n\n"}