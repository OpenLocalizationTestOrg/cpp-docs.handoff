{"nodes":[{"pos":[12,57],"content":"&lt;filesystem&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"filesystem<ph id=\"ph1\">&amp;gt;</ph> functions | Microsoft Docs","pos":[4,45],"source":"filesystem&gt; functions | Microsoft Docs"}]},{"content":"filesystem<ph id=\"ph1\">&amp;gt;</ph> functions","pos":[4922,4946],"source":"filesystem&gt; functions"},{"content":"These free functions in the <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>filesystem&gt;<ept id=\"p1\">](../standard-library/filesystem.md)</ept> header perform modifying and query operations on paths, files, symlinks, directories and volumes.","pos":[4947,5123],"source":"These free functions in the [\\<filesystem>](../standard-library/filesystem.md) header perform modifying and query operations on paths, files, symlinks, directories and volumes."},{"content":"For more information and code examples, see <bpt id=\"p1\">[</bpt>File System Navigation (C++)<ept id=\"p1\">](../standard-library/file-system-navigation.md)</ept>.","pos":[5124,5246],"source":" For more information and code examples, see [File System Navigation (C++)](../standard-library/file-system-navigation.md)."},{"content":"absolute","pos":[5268,5276]},{"content":"begin","pos":[5290,5295]},{"content":"canonical","pos":[5306,5315]},{"content":"copy","pos":[5332,5336]},{"content":"copy_file","pos":[5346,5355]},{"content":"copy_symlink","pos":[5370,5382]},{"content":"create_directories","pos":[5402,5420]},{"content":"create_directory","pos":[5444,5460]},{"content":"create_directory_symlink","pos":[5482,5506]},{"content":"create_hard_link","pos":[5538,5554]},{"content":"create_symlink","pos":[5576,5590]},{"content":"current_path","pos":[5610,5622]},{"content":"end","pos":[5642,5645]},{"content":"equivalent","pos":[5654,5664]},{"content":"exists","pos":[5680,5686]},{"content":"file_size","pos":[5700,5709]},{"content":"hard_link_count","pos":[5724,5739]},{"content":"hash_value","pos":[5760,5770]},{"content":"is_block_file","pos":[5788,5801]},{"content":"is_character_file","pos":[5820,5837]},{"content":"is_directory","pos":[5860,5872]},{"content":"is_empty","pos":[5892,5900]},{"content":"is_fifo","pos":[5914,5921]},{"content":"is_other","pos":[5934,5942]},{"content":"is_regular_file","pos":[5958,5973]},{"content":"is_socket","pos":[5994,6003]},{"content":"is_symlink","pos":[6018,6028]},{"content":"last_write_time","pos":[6046,6061]},{"content":"permissions","pos":[6082,6093]},{"content":"read_symlink","pos":[6110,6122]},{"content":"remove","pos":[6142,6148]},{"content":"remove_all","pos":[6160,6170]},{"content":"rename","pos":[6186,6192]},{"content":"resize_file","pos":[6206,6217]},{"content":"space","pos":[6234,6239]},{"content":"status","pos":[6250,6256]},{"content":"status_known","pos":[6270,6282]},{"content":"swap","pos":[6300,6304]},{"content":"symlink_status","pos":[6314,6328]},{"content":"system_complete","pos":[6350,6365]},{"content":"temp_directory_path","pos":[6386,6405]},{"content":"u8path","pos":[6430,6436]},{"pos":[6496,6504],"content":"absolute"},{"pos":[6594,6693],"content":"The function returns the absolute pathname corresponding to <ph id=\"ph1\">`pval`</ph> relative to the pathname <ph id=\"ph2\">`base`</ph>:","source":"The function returns the absolute pathname corresponding to `pval` relative to the pathname `base`:"},{"content":"If pval.has_root_name() &amp;&amp; pval.has_root_directory() the function returns pval.","pos":[6703,6782],"source":"If pval.has_root_name() && pval.has_root_directory() the function returns pval."},{"content":"If pval.has_root_name() &amp;&amp; !pval.has_root_directory() the function returns pval.root_name() / absolute(base).root_directory() / absolute(base).relative_path() / pval.relative_path().","pos":[6792,6974],"source":"If pval.has_root_name() && !pval.has_root_directory() the function returns pval.root_name() / absolute(base).root_directory() / absolute(base).relative_path() / pval.relative_path()."},{"content":"If !pval.has_root_name() &amp;&amp; pval.has_root_directory() the function returns absolute(base).root_name() / pval.","pos":[6984,7093],"source":"If !pval.has_root_name() && pval.has_root_directory() the function returns absolute(base).root_name() / pval."},{"content":"If !pval.has_root_name() &amp;&amp; !pval.has_root_directory() the function returns absolute(base) / pval.","pos":[7103,7201],"source":"If !pval.has_root_name() && !pval.has_root_directory() the function returns absolute(base) / pval."},{"pos":[7232,7237],"content":"begin"},{"pos":[7436,7465],"content":"Both functions return <ph id=\"ph1\">`iter`</ph>.","source":"Both functions return `iter`."},{"pos":[7500,7509],"content":"canonical"},{"content":"The functions all form an absolute pathname pabs = absolute(pval, base) (or pabs = absolute(pval) for the overload with no base parameter), then reduce it to a canonical form in the following sequence of steps:","pos":[7718,7928]},{"content":"Every path component X for which is_symlink(X) is true is replaced by read_symlink(X).","pos":[7938,8024]},{"content":"Every path component .","pos":[8034,8056]},{"content":"(dot is the current directory established by previous path components) is removed.","pos":[8057,8139]},{"content":"Every pair of path components X/..","pos":[8149,8183]},{"content":"(dot-dot is the parent directory established by previous path components) is removed.","pos":[8184,8269]},{"content":"The function then returns pabs.","pos":[8276,8307]},{"pos":[8337,8341],"content":"copy"},{"content":"The functions all possibly copy or link one or more files at <ph id=\"ph1\">`from`</ph> to <ph id=\"ph2\">`to`</ph> under control of <ph id=\"ph3\">`opts`</ph>, which is taken as copy_options::none for the overloads with no <ph id=\"ph4\">`opts`</ph> parameter.","pos":[8635,8816],"source":"The functions all possibly copy or link one or more files at `from` to `to` under control of `opts`, which is taken as copy_options::none for the overloads with no `opts` parameter."},{"content":"shall contain at most one of:","pos":[8824,8853]},{"content":"skip_existing, overwrite_existing, or update_existing","pos":[8863,8916]},{"content":"copy_symlinks or skip_symlinks","pos":[8926,8956]},{"content":"directories_only, create_symlinks, or create_hard_links","pos":[8966,9021]},{"pos":[9028,9109],"content":"The functions first determine the file_status values f for <ph id=\"ph1\">`from`</ph> and t for <ph id=\"ph2\">`to`</ph>:","source":"The functions first determine the file_status values f for `from` and t for `to`:"},{"content":"if opts &amp; (copy_options::create_symlinks &amp;#124; copy_options::skip_symlinks), by calling symlink_status","pos":[9119,9222],"source":"if opts & (copy_options::create_symlinks &#124; copy_options::skip_symlinks), by calling symlink_status"},{"content":"otherwise, by calling status","pos":[9232,9260]},{"content":"Otherwise report an error.","pos":[9270,9296]},{"content":"If !exists(f) &amp;#124;&amp;#124; equivalent(f, t) &amp;#124;&amp;#124; is_other(f) &amp;#124;&amp;#124; is_other(t) &amp;#124;&amp;#124; is_directory(f)&amp;&amp; is_regular_file(t), they then report an error (and do nothing else).","pos":[9303,9496],"source":"If !exists(f) &#124;&#124; equivalent(f, t) &#124;&#124; is_other(f) &#124;&#124; is_other(t) &#124;&#124; is_directory(f)&& is_regular_file(t), they then report an error (and do nothing else)."},{"content":"Otherwise, if is_symlink(f) then:","pos":[9503,9536]},{"content":"If options &amp; copy_options::skip_symlinks then do nothing.","pos":[9546,9603],"source":"If options & copy_options::skip_symlinks then do nothing."},{"content":"Otherwise, if !exists(t)&amp;&amp; options &amp; copy_options::copy_symlinks then copy_symlink(from, to, opts).","pos":[9613,9712],"source":"Otherwise, if !exists(t)&& options & copy_options::copy_symlinks then copy_symlink(from, to, opts)."},{"content":"Otherwise report an error.","pos":[9722,9748]},{"content":"Otherwise, if is_regular_file(f) then:","pos":[9755,9793]},{"content":"If opts &amp; copy_options::directories_only then do nothing.","pos":[9803,9860],"source":"If opts & copy_options::directories_only then do nothing."},{"content":"Otherwise, if opts &amp; copy_options::create_symlinks then create_symlink(to, from).","pos":[9870,9951],"source":"Otherwise, if opts & copy_options::create_symlinks then create_symlink(to, from)."},{"content":"Otherwise, if opts &amp; copy_options::create_hard_links then create_hard_link(to, from).","pos":[9961,10046],"source":"Otherwise, if opts & copy_options::create_hard_links then create_hard_link(to, from)."},{"content":"Otherwise, if is_directory(f) then copy_file(from, to / from.filename(), opts).","pos":[10056,10135]},{"content":"Otherwise, copy_file(from, to, opts).","pos":[10145,10182]},{"content":"Otherwise, if is_directory(f) &amp;&amp; (opts &amp; copy_options::recursive &amp;#124;&amp;#124; !opts) then:","pos":[10189,10279],"source":"Otherwise, if is_directory(f) && (opts & copy_options::recursive &#124;&#124; !opts) then:"},{"content":"Otherwise, do nothing.","pos":[10572,10594]},{"pos":[10628,10637],"content":"copy_file"},{"content":"The functions all possibly copy the file at <ph id=\"ph1\">`from`</ph> to <ph id=\"ph2\">`to`</ph> under control of <ph id=\"ph3\">`opts`</ph>, which is taken as copy_options::none for the overloads with no <ph id=\"ph4\">`opts`</ph> parameter.","pos":[10951,11115],"source":"The functions all possibly copy the file at `from` to `to` under control of `opts`, which is taken as copy_options::none for the overloads with no `opts` parameter."},{"content":"shall contain at most one of skip_existing, overwrite_existing, or update_existing.","pos":[11123,11206]},{"content":"If exists<ph id=\"ph1\">\\(</ph>to<ph id=\"ph2\">\\) &amp;&amp; \\!\\(</ph>opts &amp; <ph id=\"ph3\">\\(</ph>copy_options::skip_existing &amp;#124; copy_options::overwrite_existing &amp;#124; copy_options::update_existing<ph id=\"ph4\">\\)\\)</ph> then report as an error that the file already exists.","pos":[11213,11407],"source":"If exists\\(to\\) && \\!\\(opts & \\(copy_options::skip_existing &#124; copy_options::overwrite_existing &#124; copy_options::update_existing\\)\\) then report as an error that the file already exists."},{"content":"Otherwise, if <ph id=\"ph1\">\\!</ph>exists<ph id=\"ph2\">\\(</ph>to<ph id=\"ph3\">\\)</ph> &amp;#124;&amp;#124; opts &amp; copy_options::overwrite_existing &amp;#124;&amp;#124; opts &amp; copy_options::update_existing&amp;&amp; last_write_time<ph id=\"ph4\">\\(</ph>to<ph id=\"ph5\">\\)</ph> <ph id=\"ph6\">\\&lt;</ph> last_write_time<ph id=\"ph7\">\\(</ph>from<ph id=\"ph8\">\\)</ph> &amp;#124;&amp;#124; <ph id=\"ph9\">\\!\\(</ph>opts &amp; <ph id=\"ph10\">\\(</ph>copy_options::skip_existing &amp;#124; copy_options::overwrite_existing &amp;#124; copy_options:update_existing<ph id=\"ph11\">\\)\\)</ph> then attempt to copy the contents and attributes of the file from to the file to.","pos":[11414,11812],"source":"Otherwise, if \\!exists\\(to\\) &#124;&#124; opts & copy_options::overwrite_existing &#124;&#124; opts & copy_options::update_existing&& last_write_time\\(to\\) \\< last_write_time\\(from\\) &#124;&#124; \\!\\(opts & \\(copy_options::skip_existing &#124; copy_options::overwrite_existing &#124; copy_options:update_existing\\)\\) then attempt to copy the contents and attributes of the file from to the file to."},{"content":"Report as an error if the copy attempt fails.","pos":[11813,11858]},{"content":"The functions return true if the copy is attempted and succeeds, otherwise false.","pos":[11865,11946]},{"pos":[11985,11997],"content":"copy_symlink"},{"content":"If is_directory<ph id=\"ph1\">\\(</ph>from<ph id=\"ph2\">\\)</ph> the function calls create_directory_symlink<ph id=\"ph3\">\\(</ph>from, to<ph id=\"ph4\">\\)</ph>.","pos":[12152,12232],"source":"If is_directory\\(from\\) the function calls create_directory_symlink\\(from, to\\)."},{"content":"Otherwise, it calls create_symlink<ph id=\"ph1\">\\(</ph>from, to<ph id=\"ph2\">\\)</ph>.","pos":[12233,12280],"source":" Otherwise, it calls create_symlink\\(from, to\\)."},{"pos":[12324,12342],"content":"create_directories"},{"content":"For a pathname such as a<ph id=\"ph1\">\\/</ph>b<ph id=\"ph2\">\\/</ph>c the function creates directories a and a<ph id=\"ph3\">\\/</ph>b as needed so that it can create the directory a<ph id=\"ph4\">\\/</ph>b<ph id=\"ph5\">\\/</ph>c as needed.","pos":[12477,12616],"source":"For a pathname such as a\\/b\\/c the function creates directories a and a\\/b as needed so that it can create the directory a\\/b\\/c as needed."},{"content":"It returns true only if it actually creates the directory <ph id=\"ph1\">`pval`</ph>.","pos":[12617,12682],"source":" It returns true only if it actually creates the directory `pval`."},{"pos":[12724,12740],"content":"create_directory"},{"content":"The function creates the directory <ph id=\"ph1\">`pval`</ph> as needed.","pos":[13017,13069],"source":"The function creates the directory `pval` as needed."},{"content":"It returns true only if it actually creates the directory <ph id=\"ph1\">`pval`</ph>, in which case it copies permissions from the existing file <ph id=\"ph2\">`attr`</ph>, or uses perms::all for the overloads with no <ph id=\"ph3\">`attr`</ph> parameter.","pos":[13070,13265],"source":" It returns true only if it actually creates the directory `pval`, in which case it copies permissions from the existing file `attr`, or uses perms::all for the overloads with no `attr` parameter."},{"pos":[13316,13340],"content":"create_directory_symlink"},{"pos":[13519,13580],"content":"The function creates link as a symlink to the directory <ph id=\"ph1\">`to`</ph>.","source":"The function creates link as a symlink to the directory `to`."},{"pos":[13622,13638],"content":"create_hard_link"},{"pos":[13802,13873],"content":"The function creates link as a hard link to the directory or file <ph id=\"ph1\">`to`</ph>.","source":"The function creates link as a hard link to the directory or file `to`."},{"pos":[13914,13928],"content":"create_symlink"},{"pos":[14089,14147],"content":"The function creates <ph id=\"ph1\">`link`</ph> as a symlink to the file <ph id=\"ph2\">`to`</ph>.","source":"The function creates `link` as a symlink to the file `to`."},{"pos":[14185,14197],"content":"current_path"},{"content":"The functions with no parameter <ph id=\"ph1\">`pval`</ph> return the pathname for the current directory.","pos":[14376,14461],"source":"The functions with no parameter `pval` return the pathname for the current directory."},{"content":"The remaining functions set the current directory to <ph id=\"ph1\">`pval`</ph>.","pos":[14462,14522],"source":" The remaining functions set the current directory to `pval`."},{"pos":[14551,14554],"content":"end"},{"content":"The first function returns directory_iterator<ph id=\"ph1\">\\(\\)</ph> and the second function returns recursive_directory_iterator","pos":[14732,14842],"source":"The first function returns directory_iterator\\(\\) and the second function returns recursive_directory_iterator"},{"pos":[14882,14892],"content":"equivalent"},{"pos":[15049,15139],"content":"The functions return true only if <ph id=\"ph1\">`left`</ph> and <ph id=\"ph2\">`right`</ph> designate the same filesystem entity.","source":"The functions return true only if `left` and `right` designate the same filesystem entity."},{"pos":[15171,15177],"content":"exists"},{"content":"The first function returns status_known &amp;&amp; stat.type<ph id=\"ph1\">\\(\\)</ph> <ph id=\"ph2\">\\!\\=</ph> file_not_found.","pos":[15330,15407],"source":"The first function returns status_known && stat.type\\(\\) \\!\\= file_not_found."},{"content":"The second and third functions return exists<ph id=\"ph1\">\\(</ph>status<ph id=\"ph2\">\\(</ph>pval<ph id=\"ph3\">\\)\\)</ph>.","pos":[15408,15471],"source":" The second and third functions return exists\\(status\\(pval\\)\\)."},{"pos":[15506,15515],"content":"file_size"},{"content":"The functions return the size in bytes of the file designated by <ph id=\"ph1\">`pval`</ph>, if exists<ph id=\"ph2\">\\(</ph>pval<ph id=\"ph3\">\\)</ph> &amp;&amp; is_regular_file<ph id=\"ph4\">\\(</ph>pval<ph id=\"ph5\">\\)</ph> and the file size can be determined.","pos":[15642,15796],"source":"The functions return the size in bytes of the file designated by `pval`, if exists\\(pval\\) && is_regular_file\\(pval\\) and the file size can be determined."},{"content":"Otherwise they report an error and return uintmax_t<ph id=\"ph1\">\\(\\-</ph>1<ph id=\"ph2\">\\)</ph>.","pos":[15797,15856],"source":" Otherwise they report an error and return uintmax_t\\(\\-1\\)."},{"pos":[15897,15912],"content":"hard_link_count"},{"pos":[16051,16135],"content":"The function returns the number of hard links for <ph id=\"ph1\">`pval`</ph>, or <ph id=\"ph2\">\\-</ph>1 if an error occurs.","source":"The function returns the number of hard links for `pval`, or \\-1 if an error occurs."},{"pos":[16171,16181],"content":"hash_value"},{"content":"The function returns a hash value for pval.native<ph id=\"ph1\">\\(\\)</ph>.","pos":[16251,16305],"source":"The function returns a hash value for pval.native\\(\\)."},{"pos":[16344,16357],"content":"is_block_file"},{"content":"The first function returns stat.type<ph id=\"ph1\">\\(\\)</ph> <ph id=\"ph2\">\\=\\=</ph> file_type::block.","pos":[16531,16594],"source":"The first function returns stat.type\\(\\) \\=\\= file_type::block."},{"content":"The remaining functions return is_block_file<ph id=\"ph1\">\\(</ph>status<ph id=\"ph2\">\\(</ph>pval<ph id=\"ph3\">\\)\\)</ph>.","pos":[16595,16658],"source":" The remaining functions return is_block_file\\(status\\(pval\\)\\)."},{"pos":[16701,16718],"content":"is_character_file"},{"content":"The first function returns stat.type<ph id=\"ph1\">\\(\\)</ph> <ph id=\"ph2\">\\=\\=</ph> file_type::character.","pos":[16905,16972],"source":"The first function returns stat.type\\(\\) \\=\\= file_type::character."},{"content":"The remaining functions return is_character_file<ph id=\"ph1\">\\(</ph>status<ph id=\"ph2\">\\(</ph>pval<ph id=\"ph3\">\\)\\)</ph>.","pos":[16973,17040],"source":" The remaining functions return is_character_file\\(status\\(pval\\)\\)."},{"pos":[17079,17091],"content":"is_directory"},{"content":"The first function returns stat.type<ph id=\"ph1\">\\(\\)</ph> <ph id=\"ph2\">\\=\\=</ph> file_type::directory.","pos":[17263,17330],"source":"The first function returns stat.type\\(\\) \\=\\= file_type::directory."},{"content":"The remaining functions return is_directory_file<ph id=\"ph1\">\\(</ph>status<ph id=\"ph2\">\\(</ph>pval<ph id=\"ph3\">\\)\\)</ph>.","pos":[17331,17398],"source":" The remaining functions return is_directory_file\\(status\\(pval\\)\\)."},{"pos":[17432,17440],"content":"is_empty"},{"content":"If is_directory<ph id=\"ph1\">\\(</ph>pval<ph id=\"ph2\">\\)</ph> then the function returns directory_iterator<ph id=\"ph3\">\\(</ph>pval<ph id=\"ph4\">\\)</ph> <ph id=\"ph5\">\\=\\=</ph> directory_iterator<ph id=\"ph6\">\\(\\)</ph>; otherwise it returns file_size<ph id=\"ph7\">\\(</ph>pval<ph id=\"ph8\">\\)</ph> <ph id=\"ph9\">\\=\\=</ph> 0.","pos":[17600,17752],"source":"If is_directory\\(pval\\) then the function returns directory_iterator\\(pval\\) \\=\\= directory_iterator\\(\\); otherwise it returns file_size\\(pval\\) \\=\\= 0."},{"pos":[17785,17792],"content":"is_fifo"},{"content":"The first function returns stat.type<ph id=\"ph1\">\\(\\)</ph> <ph id=\"ph2\">\\=\\=</ph> file_type::fifo.","pos":[17948,18010],"source":"The first function returns stat.type\\(\\) \\=\\= file_type::fifo."},{"content":"The remaining functions return is_fifo<ph id=\"ph1\">\\(</ph>status<ph id=\"ph2\">\\(</ph>pval<ph id=\"ph3\">\\)\\)</ph>.","pos":[18011,18068],"source":" The remaining functions return is_fifo\\(status\\(pval\\)\\)."},{"pos":[18102,18110],"content":"is_other"},{"content":"The first function returns stat.type<ph id=\"ph1\">\\(\\)</ph> <ph id=\"ph2\">\\=\\=</ph> file_type::other.","pos":[18269,18332],"source":"The first function returns stat.type\\(\\) \\=\\= file_type::other."},{"content":"The remaining functions return is_other<ph id=\"ph1\">\\(</ph>status<ph id=\"ph2\">\\(</ph>pval<ph id=\"ph3\">\\)\\)</ph>.","pos":[18333,18391],"source":" The remaining functions return is_other\\(status\\(pval\\)\\)."},{"pos":[18431,18446],"content":"is_regular_file"},{"content":"The first function returns stat.type<ph id=\"ph1\">\\(\\)</ph> <ph id=\"ph2\">\\=\\=</ph> file_type::regular.","pos":[18627,18692],"source":"The first function returns stat.type\\(\\) \\=\\= file_type::regular."},{"content":"The remaining functions return is_regular_file<ph id=\"ph1\">\\(</ph>status<ph id=\"ph2\">\\(</ph>pval<ph id=\"ph3\">\\)\\)</ph>.","pos":[18693,18758],"source":" The remaining functions return is_regular_file\\(status\\(pval\\)\\)."},{"pos":[18793,18802],"content":"is_socket"},{"content":"The first function returns stat.type<ph id=\"ph1\">\\(\\)</ph> <ph id=\"ph2\">\\=\\=</ph> file_type::socket.","pos":[18965,19029],"source":"The first function returns stat.type\\(\\) \\=\\= file_type::socket."},{"content":"The remaining functions return is_socket<ph id=\"ph1\">\\(</ph>status<ph id=\"ph2\">\\(</ph>pval<ph id=\"ph3\">\\)\\)</ph>.","pos":[19030,19089],"source":" The remaining functions return is_socket\\(status\\(pval\\)\\)."},{"pos":[19125,19135],"content":"is_symlink"},{"content":"The first function returns stat.type<ph id=\"ph1\">\\(\\)</ph> <ph id=\"ph2\">\\=\\=</ph> file_type::symlink.","pos":[19301,19366],"source":"The first function returns stat.type\\(\\) \\=\\= file_type::symlink."},{"content":"The remaining functions return is_symlink<ph id=\"ph1\">\\(</ph>status<ph id=\"ph2\">\\(</ph>pval<ph id=\"ph3\">\\)\\)</ph>.","pos":[19367,19427],"source":" The remaining functions return is_symlink\\(status\\(pval\\)\\)."},{"pos":[19468,19483],"content":"last_write_time"},{"content":"The first two functions return the time of last data modification for <ph id=\"ph1\">`pval`</ph>, or file_time_type<ph id=\"ph2\">\\(\\-</ph>1<ph id=\"ph3\">\\)</ph> if an error occurs.","pos":[19790,19912],"source":"The first two functions return the time of last data modification for `pval`, or file_time_type\\(\\-1\\) if an error occurs."},{"content":"The last two functions set the time of last data modification for <ph id=\"ph1\">`pval`</ph> to new_time.","pos":[19913,19998],"source":" The last two functions set the time of last data modification for `pval` to new_time."},{"pos":[20035,20046],"content":"permissions"},{"content":"The functions set the permissions for the pathname designated by <ph id=\"ph1\">`pval`</ph> to mask &amp; perms::mask under control of perms &amp; <ph id=\"ph2\">\\(</ph>perms::add_perms &amp;#124; perms::remove_perms<ph id=\"ph3\">\\)</ph>.","pos":[20191,20358],"source":"The functions set the permissions for the pathname designated by `pval` to mask & perms::mask under control of perms & \\(perms::add_perms &#124; perms::remove_perms\\)."},{"content":"mask shall contain at most one of perms::add_perms and perms::remove_perms.","pos":[20359,20434]},{"content":"If mask &amp; perms::add_perms the functions set the permissions to status<ph id=\"ph1\">\\(</ph>pval<ph id=\"ph2\">\\)</ph>.permissions<ph id=\"ph3\">\\(\\)</ph> &amp;#124; mask &amp; perms::mask.","pos":[20441,20562],"source":"If mask & perms::add_perms the functions set the permissions to status\\(pval\\).permissions\\(\\) &#124; mask & perms::mask."},{"content":"Otherwise, if mask &amp; perms::remove_perms the functions set the permissions to status<ph id=\"ph1\">\\(</ph>pval<ph id=\"ph2\">\\)</ph>.permissions<ph id=\"ph3\">\\(\\)</ph> &amp; ~<ph id=\"ph4\">\\(</ph>mask &amp; perms::mask<ph id=\"ph5\">\\)</ph>.","pos":[20563,20698],"source":" Otherwise, if mask & perms::remove_perms the functions set the permissions to status\\(pval\\).permissions\\(\\) & ~\\(mask & perms::mask\\)."},{"content":"Otherwise, the functions set the permissions to mask &amp; perms::mask.","pos":[20699,20766],"source":" Otherwise, the functions set the permissions to mask & perms::mask."},{"pos":[20804,20816],"content":"read_symlink"},{"content":"The functions report an error and return path<ph id=\"ph1\">\\(\\)</ph> if <ph id=\"ph2\">\\!</ph>is_symlink<ph id=\"ph3\">\\(</ph>pval<ph id=\"ph4\">\\)</ph>.","pos":[20928,21002],"source":"The functions report an error and return path\\(\\) if \\!is_symlink\\(pval\\)."},{"content":"Otherwise, the functions return an object of type <ph id=\"ph1\">`path`</ph> containing the symbolic link.","pos":[21003,21089],"source":" Otherwise, the functions return an object of type `path` containing the symbolic link."},{"pos":[21121,21127],"content":"remove"},{"content":"The functions return true only if exists<ph id=\"ph1\">\\(</ph>symlink_status<ph id=\"ph2\">\\(</ph>pval<ph id=\"ph3\">\\)\\)</ph> and the file is successfully removed.","pos":[21238,21342],"source":"The functions return true only if exists\\(symlink_status\\(pval\\)\\) and the file is successfully removed."},{"content":"A symlink is itself removed, not the file it designates.","pos":[21343,21399]},{"pos":[21435,21445],"content":"remove_all"},{"content":"If <ph id=\"ph1\">`pval`</ph> is a directory, the functions recursively remove all directory entries, then the entry itself.","pos":[21574,21678],"source":"If `pval` is a directory, the functions recursively remove all directory entries, then the entry itself."},{"content":"Otherwise, the functions call remove.","pos":[21679,21716]},{"content":"They return a count of all elements successfully removed.","pos":[21717,21774]},{"pos":[21806,21812],"content":"rename"},{"content":"The functions rename <ph id=\"ph1\">`from`</ph> to <ph id=\"ph2\">`to`</ph>.","pos":[21957,21993],"source":"The functions rename `from` to `to`."},{"content":"A symlink is itself renamed, not the file it designates.","pos":[21994,22050]},{"pos":[22087,22098],"content":"resize_file"},{"content":"The functions alter the size of a file such that file_size<ph id=\"ph1\">\\(</ph>pval<ph id=\"ph2\">\\)</ph> <ph id=\"ph3\">\\=\\=</ph> size","pos":[22241,22317],"source":"The functions alter the size of a file such that file_size\\(pval\\) \\=\\= size"},{"pos":[22348,22353],"content":"space"},{"content":"The function returns information about the volume designated by <ph id=\"ph1\">`pval`</ph>, in a structure of type <ph id=\"ph2\">`space_info`</ph>.","pos":[22474,22582],"source":"The function returns information about the volume designated by `pval`, in a structure of type `space_info`."},{"content":"The structure contains uintmax_t<ph id=\"ph1\">\\(\\-</ph>1<ph id=\"ph2\">\\)</ph> for any value that cannot be determined.","pos":[22583,22663],"source":" The structure contains uintmax_t\\(\\-1\\) for any value that cannot be determined."},{"pos":[22695,22701],"content":"status"},{"content":"The functions return the pathname status, the file type and permissions, associated with <ph id=\"ph1\">`pval`</ph>.","pos":[22826,22922],"source":"The functions return the pathname status, the file type and permissions, associated with `pval`."},{"content":"A symlink is itself not tested, but the file it designates.","pos":[22923,22982]},{"pos":[23020,23032],"content":"status_known"},{"content":"The function returns stat.type<ph id=\"ph1\">\\(\\)</ph> <ph id=\"ph2\">\\!\\=</ph> file_type::none","pos":[23102,23157],"source":"The function returns stat.type\\(\\) \\!\\= file_type::none"},{"pos":[23187,23191],"content":"swap"},{"pos":[23260,23318],"content":"The function exchanges the contents of <ph id=\"ph1\">`left`</ph> and <ph id=\"ph2\">`right`</ph>.","source":"The function exchanges the contents of `left` and `right`."},{"pos":[23358,23372],"content":"symlink_status"},{"content":"The functions return the pathname symlink status, the file type and permissions, associated with <ph id=\"ph1\">`pval`</ph>.","pos":[23514,23618],"source":"The functions return the pathname symlink status, the file type and permissions, associated with `pval`."},{"content":"The functions behave the same as status<ph id=\"ph1\">\\(</ph>pval<ph id=\"ph2\">\\)</ph> except that a symlink is itself tested, not the file it designates.","pos":[23619,23734],"source":" The functions behave the same as status\\(pval\\) except that a symlink is itself tested, not the file it designates."},{"pos":[23775,23790],"content":"system_complete"},{"content":"The functions return an absolute pathname that takes into account, as necessary, the current directory associated with its root name.","pos":[23908,24041]},{"content":"For Posix, the functions return absolute<ph id=\"ph1\">\\(</ph>pval<ph id=\"ph2\">\\)</ph>.","pos":[24044,24093],"source":"For Posix, the functions return absolute\\(pval\\)."},{"pos":[24140,24159],"content":"temp_directory_path"},{"content":"The functions return a pathname for a directory suitable for containing temporary files.","pos":[24251,24339]},{"pos":[24371,24377],"content":"u8path"},{"content":"The first function behaves the same as path(source) and the second function behaves the same as path(first, last) except that the designated source in each case is taken as a sequence of char elements encoded as UTF-8, regardless of the filesystem.","pos":[24521,24769]}],"content":"---\ntitle: \"&lt;filesystem&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"FILESYSTEM/std::experimental::filesystem::absolute\"\n  - \"std::experimental::filesystem::absolute\"\n  - \"FILESYSTEM/std::experimental::filesystem::canonical\"\n  - \"std::experimental::filesystem::canonical\"\n  - \"FILESYSTEM/std::experimental::filesystem::copy\"\n  - \"std::experimental::filesystem::copy\"\n  - \"FILESYSTEM/std::experimental::filesystem::copy_file\"\n  - \"std::experimental::filesystem::copy_file\"\n  - \"FILESYSTEM/std::experimental::filesystem::copy_symlink\"\n  - \"std::experimental::filesystem::copy_symlink\"\n  - \"FILESYSTEM/std::experimental::filesystem::create_directories\"\n  - \"std::experimental::filesystem::create_directories\"\n  - \"FILESYSTEM/std::experimental::filesystem::create_directory\"\n  - \"std::experimental::filesystem::create_directory\"\n  - \"FILESYSTEM/std::experimental::filesystem::create_directory_symlink\"\n  - \"std::experimental::filesystem::create_directory_symlink\"\n  - \"FILESYSTEM/std::experimental::filesystem::create_hard_link\"\n  - \"std::experimental::filesystem::create_hard_link\"\n  - \"FILESYSTEM/std::experimental::filesystem::create_symlink\"\n  - \"std::experimental::filesystem::create_symlink\"\n  - \"FILESYSTEM/std::experimental::filesystem::current_path\"\n  - \"std::experimental::filesystem::current_path\"\n  - \"FILESYSTEM/std::experimental::filesystem::equivalent\"\n  - \"std::experimental::filesystem::equivalent\"\n  - \"FILESYSTEM/std::experimental::filesystem::exists\"\n  - \"std::experimental::filesystem::exists\"\n  - \"FILESYSTEM/std::experimental::filesystem::file_size\"\n  - \"std::experimental::filesystem::file_size\"\n  - \"FILESYSTEM/std::experimental::filesystem::hard_link_count\"\n  - \"std::experimental::filesystem::hard_link_count\"\n  - \"FILESYSTEM/std::experimental::filesystem::hash_value\"\n  - \"std::experimental::filesystem::hash_value\"\n  - \"FILESYSTEM/std::experimental::filesystem::is_block_file\"\n  - \"std::experimental::filesystem::is_block_file\"\n  - \"FILESYSTEM/std::experimental::filesystem::is_character_file\"\n  - \"std::experimental::filesystem::is_character_file\"\n  - \"FILESYSTEM/std::experimental::filesystem::is_directory\"\n  - \"std::experimental::filesystem::is_directory\"\n  - \"FILESYSTEM/std::experimental::filesystem::is_empty\"\n  - \"std::experimental::filesystem::is_empty\"\n  - \"FILESYSTEM/std::experimental::filesystem::is_fifo\"\n  - \"std::experimental::filesystem::is_fifo\"\n  - \"FILESYSTEM/std::experimental::filesystem::is_other\"\n  - \"std::experimental::filesystem::is_other\"\n  - \"FILESYSTEM/std::experimental::filesystem::is_regular_file\"\n  - \"std::experimental::filesystem::is_regular_file\"\n  - \"FILESYSTEM/std::experimental::filesystem::is_socket\"\n  - \"std::experimental::filesystem::is_socket\"\n  - \"FILESYSTEM/std::experimental::filesystem::is_symlink\"\n  - \"std::experimental::filesystem::is_symlink\"\n  - \"FILESYSTEM/std::experimental::filesystem::last_write_time\"\n  - \"std::experimental::filesystem::last_write_time\"\n  - \"FILESYSTEM/std::experimental::filesystem::permissions\"\n  - \"std::experimental::filesystem::permissions\"\n  - \"FILESYSTEM/std::experimental::filesystem::read_symlink\"\n  - \"std::experimental::filesystem::read_symlink\"\n  - \"FILESYSTEM/std::experimental::filesystem::remove\"\n  - \"std::experimental::filesystem::remove\"\n  - \"FILESYSTEM/std::experimental::filesystem::remove_all\"\n  - \"std::experimental::filesystem::remove_all\"\n  - \"FILESYSTEM/std::experimental::filesystem::rename\"\n  - \"std::experimental::filesystem::rename\"\n  - \"FILESYSTEM/std::experimental::filesystem::resize_file\"\n  - \"std::experimental::filesystem::resize_file\"\n  - \"FILESYSTEM/std::experimental::filesystem::space\"\n  - \"std::experimental::filesystem::space\"\n  - \"FILESYSTEM/std::experimental::filesystem::status\"\n  - \"std::experimental::filesystem::status\"\n  - \"FILESYSTEM/std::experimental::filesystem::status_known\"\n  - \"std::experimental::filesystem::status_known\"\n  - \"FILESYSTEM/std::experimental::filesystem::swap\"\n  - \"std::experimental::filesystem::swap\"\n  - \"FILESYSTEM/std::experimental::filesystem::symlink_status\"\n  - \"std::experimental::filesystem::symlink_status\"\n  - \"FILESYSTEM/std::experimental::filesystem::system_complete\"\n  - \"std::experimental::filesystem::system_complete\"\n  - \"FILESYSTEM/std::experimental::filesystem::temp_directory_path\"\n  - \"std::experimental::filesystem::temp_directory_path\"\n  - \"FILESYSTEM/std::experimental::filesystem::u8path\"\n  - \"std::experimental::filesystem::u8path\"\ndev_langs: \n  - \"C++\"\nms.assetid: be3cb821-4728-4d47-ab78-858fa8aa5045\ncaps.latest.revision: 13\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# &lt;filesystem&gt; functions\nThese free functions in the [\\<filesystem>](../standard-library/filesystem.md) header perform modifying and query operations on paths, files, symlinks, directories and volumes. For more information and code examples, see [File System Navigation (C++)](../standard-library/file-system-navigation.md).  \n||||  \n|-|-|-|  \n|[absolute](#absolute)|[begin](#begin)|[canonical](#canonical)|\n|[copy](#copy)|[copy_file](#copy_file)|[copy_symlink](#copy_symlink)|\n|[create_directories](#create_directories)|[create_directory](#create_directory)|[create_directory_symlink](#create_directory_symlink)|\n|[create_hard_link](#create_hard_link)|[create_symlink](#create_symlink)|[current_path](#current_path)|\n|[end](#end)|[equivalent](#equivalent)|[exists](#exists)|\n|[file_size](#file_size)|[hard_link_count](#hard_link_count)|[hash_value](#hash_value)|\n|[is_block_file](#is_block_file)|[is_character_file](#is_character_file)|[is_directory](#is_directory)|\n|[is_empty](#is_empty)|[is_fifo](#is_fifo)|[is_other](#is_other)|\n|[is_regular_file](#is_regular_file)|[is_socket](#is_socket)|[is_symlink](#is_symlink)|\n|[last_write_time](#last_write_time)|[permissions](#permissions)|[read_symlink](#read_symlink)|\n|[remove](#remove)|[remove_all](#remove_all)|[rename](#rename)|\n|[resize_file](#resize_file)|[space](#space)|[status](#status)|\n|[status_known](#status_known)|[swap](#swap)|[symlink_status](#symlink_status)|\n|[system_complete](#system_complete)|[temp_directory_path](#temp_directory_path)|[u8path](#u8path)|  \n\n\n## <a name=\"\"></a>  <a name=\"absolute\"></a> absolute  \n  \n```  \npath absolute(const path& pval, const path& base = current_path());\n```  \n  \n The function returns the absolute pathname corresponding to `pval` relative to the pathname `base`:  \n  \n1.  If pval.has_root_name() && pval.has_root_directory() the function returns pval.  \n  \n2.  If pval.has_root_name() && !pval.has_root_directory() the function returns pval.root_name() / absolute(base).root_directory() / absolute(base).relative_path() / pval.relative_path().  \n  \n3.  If !pval.has_root_name() && pval.has_root_directory() the function returns absolute(base).root_name() / pval.  \n  \n4.  If !pval.has_root_name() && !pval.has_root_directory() the function returns absolute(base) / pval.  \n  \n## <a name=\"begin\"></a>  begin  \n  \n```  \nconst directory_iterator& begin(const directory_iterator& iter) noexcept;  \nconst recursive_directory_iterator& \n    begin(const recursive_directory_iterator& iter) noexcept;  \n```  \n  \n Both functions return `iter`.  \n  \n## <a name=\"canonical\"></a>  canonical  \n  \n```  \npath canonical(const path& pval, const path& base = current_path());\npath canonical(const path& pval, error_code& ec);\npath canonical(const path& pval, const path& base, error_code& ec);\n```  \n  \n The functions all form an absolute pathname pabs = absolute(pval, base) (or pabs = absolute(pval) for the overload with no base parameter), then reduce it to a canonical form in the following sequence of steps:  \n  \n1.  Every path component X for which is_symlink(X) is true is replaced by read_symlink(X).  \n  \n2.  Every path component . (dot is the current directory established by previous path components) is removed.  \n  \n3.  Every pair of path components X/.. (dot-dot is the parent directory established by previous path components) is removed.  \n  \n The function then returns pabs.  \n  \n## <a name=\"copy\"></a>  copy  \n  \n```  \nvoid copy(const path& from, const path& to);\nvoid copy(const path& from, const path& to, error_code& ec) noexcept;  \nvoid copy(const path& from, const path& to, copy_options opts);\nvoid copy(const path& from, const path& to, copy_options opts, error_code& ec) noexcept;  \n```  \n  \n The functions all possibly copy or link one or more files at `from` to `to` under control of `opts`, which is taken as copy_options::none for the overloads with no `opts` parameter. `opts` shall contain at most one of:  \n  \n-   skip_existing, overwrite_existing, or update_existing  \n  \n-   copy_symlinks or skip_symlinks  \n  \n-   directories_only, create_symlinks, or create_hard_links  \n  \n The functions first determine the file_status values f for `from` and t for `to`:  \n  \n-   if opts & (copy_options::create_symlinks &#124; copy_options::skip_symlinks), by calling symlink_status  \n  \n-   otherwise, by calling status  \n  \n-   Otherwise report an error.  \n  \n If !exists(f) &#124;&#124; equivalent(f, t) &#124;&#124; is_other(f) &#124;&#124; is_other(t) &#124;&#124; is_directory(f)&& is_regular_file(t), they then report an error (and do nothing else).  \n  \n Otherwise, if is_symlink(f) then:  \n  \n-   If options & copy_options::skip_symlinks then do nothing.  \n  \n-   Otherwise, if !exists(t)&& options & copy_options::copy_symlinks then copy_symlink(from, to, opts).  \n  \n-   Otherwise report an error.  \n  \n Otherwise, if is_regular_file(f) then:  \n  \n-   If opts & copy_options::directories_only then do nothing.  \n  \n-   Otherwise, if opts & copy_options::create_symlinks then create_symlink(to, from).  \n  \n-   Otherwise, if opts & copy_options::create_hard_links then create_hard_link(to, from).  \n  \n-   Otherwise, if is_directory(f) then copy_file(from, to / from.filename(), opts).  \n  \n-   Otherwise, copy_file(from, to, opts).  \n  \n Otherwise, if is_directory(f) && (opts & copy_options::recursive &#124;&#124; !opts) then:  \n  \n```cpp  \nif (!exists(t))\n{  // copy directory contents recursively  \n    create_directory(to, from, ec);\n\n    for (directory_iterator next(from), end; ec == error_code() && next != end; ++next)\n    {\n        copy(next->path(), to / next->path().filename(), opts, ec);\n    }\n\n}\n```  \n  \n Otherwise, do nothing.  \n  \n## <a name=\"opy_file\"></a>  copy_file  \n  \n```  \nbool copy_file(const path& from, const path& to);\nbool copy_file(const path& from, const path& to, error_code& ec) noexcept;  \nbool copy_file(const path& from, const path& to, copy_options opts);\nbool copy_file(const path& from, const path& to, copy_options opts, error_code& ec) noexcept;  \n```  \n  \n The functions all possibly copy the file at `from` to `to` under control of `opts`, which is taken as copy_options::none for the overloads with no `opts` parameter. `opts` shall contain at most one of skip_existing, overwrite_existing, or update_existing.  \n  \n If exists\\(to\\) && \\!\\(opts & \\(copy_options::skip_existing &#124; copy_options::overwrite_existing &#124; copy_options::update_existing\\)\\) then report as an error that the file already exists.  \n  \n Otherwise, if \\!exists\\(to\\) &#124;&#124; opts & copy_options::overwrite_existing &#124;&#124; opts & copy_options::update_existing&& last_write_time\\(to\\) \\< last_write_time\\(from\\) &#124;&#124; \\!\\(opts & \\(copy_options::skip_existing &#124; copy_options::overwrite_existing &#124; copy_options:update_existing\\)\\) then attempt to copy the contents and attributes of the file from to the file to. Report as an error if the copy attempt fails.  \n  \n The functions return true if the copy is attempted and succeeds, otherwise false.  \n  \n## <a name=\"copy_symlink \"></a>  copy_symlink  \n  \n```  \nvoid copy_symlink(const path& from, const path& to);\nvoid copy_symlink(const path& from, const path& to, error_code& ec) noexcept;  \n```  \n  \n If is_directory\\(from\\) the function calls create_directory_symlink\\(from, to\\). Otherwise, it calls create_symlink\\(from, to\\).  \n  \n## <a name=\"create_directories\"></a>  create_directories  \n  \n```  \nbool create_directories(const path& pval);\nbool create_directories(const path& pval, error_code& ec) noexcept;  \n```  \n  \n For a pathname such as a\\/b\\/c the function creates directories a and a\\/b as needed so that it can create the directory a\\/b\\/c as needed. It returns true only if it actually creates the directory `pval`.  \n  \n## <a name=\"create_directory\"></a>  create_directory  \n  \n```  \nbool create_directory(const path& pval);\n\nbool create_directory(const path& pval, error_code& ec) noexcept;  \nbool create_directory(const path& pval, const path& attr);\nbool create_directory(const path& pval, const path& attr, error_code& ec) noexcept;  \n```  \n  \n The function creates the directory `pval` as needed. It returns true only if it actually creates the directory `pval`, in which case it copies permissions from the existing file `attr`, or uses perms::all for the overloads with no `attr` parameter.  \n  \n## <a name=\"create_directory_symlink \"></a>  create_directory_symlink  \n  \n```  \nvoid create_directory_symlink(const path& to, const path& link);\nvoid create_directory_symlink(const path& to, const path& link, error_code& ec) noexcept;  \n```  \n  \n The function creates link as a symlink to the directory `to`.  \n  \n## <a name=\"create_hard_link\"></a>  create_hard_link  \n  \n```  \nvoid create_hard_link(const path& to,  const path& link);\nvoid create_hard_link(const path& to, const path& link, error_code& ec) noexcept;  \n```  \n  \n The function creates link as a hard link to the directory or file `to`.  \n  \n## <a name=\"create_symlink \"></a>  create_symlink  \n  \n```  \nvoid create_symlink(const path& to,  const path& link);\n\nvoid create_symlink(const path& to, const path& link, error_code& ec) noexcept;  \n```  \n  \n The function creates `link` as a symlink to the file `to`.  \n  \n## <a name=\"current_path\"></a>  current_path  \n  \n```  \npath current_path();\npath current_path(error_code& ec);\nvoid current_path(const path& pval);\nvoid current_path(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The functions with no parameter `pval` return the pathname for the current directory. The remaining functions set the current directory to `pval`.  \n  \n## <a name=\"end\"></a>  end  \n  \n```  \ndirectory_iterator& end(const directory_iterator& iter) noexcept;  \nrecursive_directory_iterator& end(const recursive_directory_iterator& iter) noexcept;  \n```  \n  \n The first function returns directory_iterator\\(\\) and the second function returns recursive_directory_iterator\\(\\)  \n  \n## <a name=\"equivalent\"></a>  equivalent  \n  \n```  \nbool equivalent(const path& left, const path& right);\nbool equivalent(const path& left, const path& right, error_code& ec) noexcept;  \n```  \n  \n The functions return true only if `left` and `right` designate the same filesystem entity.  \n  \n## <a name=\"exists\"></a>  exists  \n  \n```  \nbool exists(file_status stat) noexcept;  \nbool exists(const path& pval);\nbool exists(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The first function returns status_known && stat.type\\(\\) \\!\\= file_not_found. The second and third functions return exists\\(status\\(pval\\)\\).  \n  \n## <a name=\"file_size\"></a>  file_size  \n  \n```  \nuintmax_t file_size(const path& pval);\nuintmax_t file_size(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The functions return the size in bytes of the file designated by `pval`, if exists\\(pval\\) && is_regular_file\\(pval\\) and the file size can be determined. Otherwise they report an error and return uintmax_t\\(\\-1\\).  \n  \n## <a name=\"hard_link_count\"></a>  hard_link_count  \n  \n```  \nuintmax_t hard_link_count(const path& pval);\nuintmax_t hard_link_count(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The function returns the number of hard links for `pval`, or \\-1 if an error occurs.  \n  \n## <a name=\"hash_value\"></a>  hash_value  \n  \n```  \nsize_t hash_value(const path& pval) noexcept;  \n```  \n  \n The function returns a hash value for pval.native\\(\\).  \n  \n## <a name=\"is_block_file\"></a>  is_block_file  \n  \n```  \nbool is_block_file(file_status stat) noexcept;  \nbool is_block_file(const path& pval);\nbool is_block_file(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The first function returns stat.type\\(\\) \\=\\= file_type::block. The remaining functions return is_block_file\\(status\\(pval\\)\\).  \n  \n## <a name=\"is_character_file\"></a>  is_character_file  \n  \n```   \nbool is_character_file(file_status stat) noexcept;  \nbool is_character_file(const path& pval);\nbool is_character_file(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The first function returns stat.type\\(\\) \\=\\= file_type::character. The remaining functions return is_character_file\\(status\\(pval\\)\\).  \n  \n## <a name=\"is_directory \"></a>  is_directory  \n  \n```   \nbool is_directory(file_status stat) noexcept;  \nbool is_directory(const path& pval);\nbool is_directory(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The first function returns stat.type\\(\\) \\=\\= file_type::directory. The remaining functions return is_directory_file\\(status\\(pval\\)\\).  \n  \n## <a name=\"is_empty\"></a>  is_empty  \n  \n```   \nbool is_empty(file_status stat) noexcept;  \nbool is_empty(const path& pval);\nbool is_empty(const path& pval, error_code& ec) noexcept;  \n```  \n  \n If is_directory\\(pval\\) then the function returns directory_iterator\\(pval\\) \\=\\= directory_iterator\\(\\); otherwise it returns file_size\\(pval\\) \\=\\= 0.  \n  \n## <a name=\"is_fifo\"></a>  is_fifo  \n  \n```  \nbool is_fifo(file_status stat) noexcept;  \nbool is_fifo(const path& pval);\nbool is_fifo(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The first function returns stat.type\\(\\) \\=\\= file_type::fifo. The remaining functions return is_fifo\\(status\\(pval\\)\\).  \n  \n## <a name=\"is_other\"></a>  is_other  \n  \n```  \nbool is_other(file_status stat) noexcept;  \nbool is_other(const path& pval);\nbool is_other(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The first function returns stat.type\\(\\) \\=\\= file_type::other. The remaining functions return is_other\\(status\\(pval\\)\\).  \n  \n## <a name=\"s_regular_file\"></a>  is_regular_file  \n  \n```   \nbool is_regular_file(file_status stat) noexcept;  \nbool is_regular_file(const path& pval);\nbool is_regular_file(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The first function returns stat.type\\(\\) \\=\\= file_type::regular. The remaining functions return is_regular_file\\(status\\(pval\\)\\).  \n  \n## <a name=\"is_socket\"></a>  is_socket  \n  \n```   \nbool is_socket(file_status stat) noexcept;  \nbool is_socket(const path& pval);\nbool is_socket(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The first function returns stat.type\\(\\) \\=\\= file_type::socket. The remaining functions return is_socket\\(status\\(pval\\)\\).  \n  \n## <a name=\"is_symlink\"></a>  is_symlink  \n  \n```   \nbool is_symlink(file_status stat) noexcept;  \nbool is_symlink(const path& pval);\nbool is_symlink(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The first function returns stat.type\\(\\) \\=\\= file_type::symlink. The remaining functions return is_symlink\\(status\\(pval\\)\\).  \n  \n## <a name=\"last_write_time\"></a>  last_write_time  \n  \n```   \nfile_time_type last_write_time(const path& pval);\nfile_time_type last_write_time(const path& pval, error_code& ec) noexcept;  \nvoid last_write_time(const path& pval, file_time_type new_time);\nvoid last_write_time(const path& pval, file_time_type new_time, error_code& ec) noexcept;  \n```  \n  \n The first two functions return the time of last data modification for `pval`, or file_time_type\\(\\-1\\) if an error occurs. The last two functions set the time of last data modification for `pval` to new_time.  \n  \n## <a name=\"permissions\"></a>  permissions  \n  \n```  \nvoid permissions(const path& pval, perms mask);\nvoid permissions(const path& pval, perms mask, error_code& ec) noexcept;  \n```  \n  \n The functions set the permissions for the pathname designated by `pval` to mask & perms::mask under control of perms & \\(perms::add_perms &#124; perms::remove_perms\\). mask shall contain at most one of perms::add_perms and perms::remove_perms.  \n  \n If mask & perms::add_perms the functions set the permissions to status\\(pval\\).permissions\\(\\) &#124; mask & perms::mask. Otherwise, if mask & perms::remove_perms the functions set the permissions to status\\(pval\\).permissions\\(\\) & ~\\(mask & perms::mask\\). Otherwise, the functions set the permissions to mask & perms::mask.  \n  \n## <a name=\"read_symlink\"></a>  read_symlink  \n  \n```  \npath read_symlink(const path& pval);\npath read_symlink(const path& pval, error_code& ec);\n```  \n  \n The functions report an error and return path\\(\\) if \\!is_symlink\\(pval\\). Otherwise, the functions return an object of type `path` containing the symbolic link.  \n  \n## <a name=\"remove\"></a>  remove  \n  \n```  \nbool remove(const path& pval);\nbool remove(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The functions return true only if exists\\(symlink_status\\(pval\\)\\) and the file is successfully removed. A symlink is itself removed, not the file it designates.  \n  \n## <a name=\"remove_all\"></a>  remove_all  \n  \n```  \nuintmax_t remove_all(const path& pval);\nuintmax_t remove_all(const path& pval, error_code& ec) noexcept;  \n```  \n  \n If `pval` is a directory, the functions recursively remove all directory entries, then the entry itself. Otherwise, the functions call remove. They return a count of all elements successfully removed.  \n  \n## <a name=\"rename\"></a>  rename  \n  \n```  \nvoid rename(const path& from,  const path& to);\nvoid rename(const path& from,  const path& to, error_code& ec) noexcept;  \n```  \n  \n The functions rename `from` to `to`. A symlink is itself renamed, not the file it designates.  \n  \n## <a name=\"resize_file\"></a>  resize_file  \n  \n```  \nvoid resize(const path& pval, uintmax_t size);\nvoid resize(const path& pval, uintmax_t size, error_code& ec) noexcept;  \n```  \n  \n The functions alter the size of a file such that file_size\\(pval\\) \\=\\= size  \n  \n## <a name=\"space\"></a>  space  \n  \n```  \nspace_info space(const path& pval);\nspace_info space(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The function returns information about the volume designated by `pval`, in a structure of type `space_info`. The structure contains uintmax_t\\(\\-1\\) for any value that cannot be determined.  \n  \n## <a name=\"status\"></a>  status  \n  \n```  \nfile_status status(const path& pval);\nfile_status status(const path& pval, error_code& ec) noexcept;  \n```  \n  \n The functions return the pathname status, the file type and permissions, associated with `pval`. A symlink is itself not tested, but the file it designates.  \n  \n## <a name=\"status_known\"></a>  status_known  \n  \n```  \nbool status_known(file_status stat) noexcept;  \n```  \n  \n The function returns stat.type\\(\\) \\!\\= file_type::none  \n  \n## <a name=\"swap\"></a>  swap  \n  \n```  \nvoid swap(path& left, path& right) noexcept;  \n```  \n  \n The function exchanges the contents of `left` and `right`.  \n  \n## <a name=\"symlink_status\"></a>  symlink_status  \n  \n```  \nfile_status symlink_status(const path& pval);\nfile_status symlink_status(const path& pval, erroxr_code& ec) noexcept;  \n```  \n  \n The functions return the pathname symlink status, the file type and permissions, associated with `pval`. The functions behave the same as status\\(pval\\) except that a symlink is itself tested, not the file it designates.  \n  \n## <a name=\"system_complete\"></a>  system_complete  \n  \n```  \npath system_complete(const path& pval);\npath system_complete(const path& pval, error_code& ec);\n```  \n  \n The functions return an absolute pathname that takes into account, as necessary, the current directory associated with its root name. \\(For Posix, the functions return absolute\\(pval\\).\\)  \n  \n## <a name=\"temp_directory_path\"></a>  temp_directory_path  \n  \n```  \npath temp_directory_path();\npath temp_directory_path(error_code& ec);\n```  \n  \n The functions return a pathname for a directory suitable for containing temporary files.  \n  \n## <a name=\"u8path\"></a>  u8path  \n  \n```  \ntemplate <class Source>  \npath u8path(const Source& source);\n\ntemplate <class InIt>  \npath u8path(InIt first, InIt last);\n```  \n  \n The first function behaves the same as path(source) and the second function behaves the same as path(first, last) except that the designated source in each case is taken as a sequence of char elements encoded as UTF-8, regardless of the filesystem.\n\n\n"}