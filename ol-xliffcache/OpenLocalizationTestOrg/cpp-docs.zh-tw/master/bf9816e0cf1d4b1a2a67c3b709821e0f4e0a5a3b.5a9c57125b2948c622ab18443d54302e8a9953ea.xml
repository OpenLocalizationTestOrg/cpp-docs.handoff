{"nodes":[{"pos":[12,51],"content":"_com_ptr_t::_com_ptr_t | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_com_ptr_t::_com_ptr_t | Microsoft Docs","pos":[0,39]}]},{"content":"_com_ptr_t::_com_ptr_t","pos":[685,707]},{"content":"Microsoft Specific","pos":[710,728]},{"pos":[737,770],"content":"Constructs a <ph id=\"ph1\">`_com_ptr_t`</ph> object.","source":"Constructs a `_com_ptr_t` object."},{"content":"Syntax","pos":[779,785]},{"content":"Parameters","pos":[4391,4401]},{"content":"A raw interface pointer.","pos":[4421,4445]},{"content":"If <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`AddRef`</ph> is called to increment the reference count of the encapsulated interface pointer.","pos":[4465,4568],"source":" If **true**, `AddRef` is called to increment the reference count of the encapsulated interface pointer."},{"content":"cp","pos":[4576,4578]},{"content":"A <ph id=\"ph1\">`_com_ptr_t`</ph> object.","pos":[4583,4605],"source":" A `_com_ptr_t` object."},{"content":"A raw interface pointer, its type being different from the smart pointer type of this <ph id=\"ph1\">`_com_ptr_t`</ph> object.","pos":[4619,4725],"source":" A raw interface pointer, its type being different from the smart pointer type of this `_com_ptr_t` object."},{"content":"varSrc","pos":[4733,4739]},{"content":"A <ph id=\"ph1\">`_variant_t`</ph> object.","pos":[4744,4766],"source":" A `_variant_t` object."},{"content":"The <bpt id=\"p1\">**</bpt>CLSID<ept id=\"p1\">**</ept> of a coclass.","pos":[4784,4811],"source":" The **CLSID** of a coclass."},{"content":"Context for running executable code.","pos":[4836,4872]},{"content":"lpcStr","pos":[4880,4886]},{"content":"A multibyte string that holds either a <bpt id=\"p1\">**</bpt>CLSID<ept id=\"p1\">**</ept> (starting with \"<bpt id=\"p2\">**</bpt>{<ept id=\"p2\">**</ept>\") or a <bpt id=\"p3\">**</bpt>ProgID<ept id=\"p3\">**</ept>.","pos":[4891,4980],"source":" A multibyte string that holds either a **CLSID** (starting with \"**{**\") or a **ProgID**."},{"content":"The outer unknown for <bpt id=\"p1\">[</bpt>aggregation<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms686558)</ept>.","pos":[4999,5095],"source":" The outer unknown for [aggregation](http://msdn.microsoft.com/library/windows/desktop/ms686558)."},{"content":"See Also","pos":[5104,5112]},{"content":"_com_ptr_t Class","pos":[5117,5133]}],"content":"---\ntitle: \"_com_ptr_t::_com_ptr_t | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"_com_ptr_t::_com_ptr_t\"\n  - \"_com_ptr_t._com_ptr_t\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"_com_ptr_t method\"\nms.assetid: 0c00620a-28d2-4f60-ae4a-1696be36137e\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# _com_ptr_t::_com_ptr_t\n**Microsoft Specific**  \n  \n Constructs a `_com_ptr_t` object.  \n  \n## Syntax  \n  \n```  \n// Default constructor.  \n// Constructs a NULL smart pointer.  \n_com_ptr_t() throw();  \n  \n// Constructs a NULL smart pointer. The NULL argument must be zero.  \n_com_ptr_t(   \n   int null   \n);  \n  \n// Constructs a smart pointer as a copy of another instance of the   \n// same smart pointer. AddRef is called to increment the reference   \n// count for the encapsulated interface pointer.  \n_com_ptr_t(   \n   const _com_ptr_t& cp   \n) throw();  \n  \n// Move constructor (Visual Studio 2015 Update 3 and later)  \n_com_ptr_t(_com_ptr_t&& cp) throw();  \n  \n// Constructs a smart pointer from a raw interface pointer of this   \n// smart pointer's type. If fAddRef is true, AddRef is called   \n// to increment the reference count for the encapsulated   \n// interface pointer. If fAddRef is false, this constructor   \n// takes ownership of the raw interface pointer without calling AddRef.  \n_com_ptr_t(   \n   Interface* pInterface,   \n   bool fAddRef   \n) throw();  \n  \n// Construct pointer for a _variant_t object.  \n// Constructs a smart pointer from a _variant_t object. The   \n// encapsulated VARIANT must be of type VT_DISPATCH or VT_UNKNOWN, or   \n// it can be converted into one of these two types. If QueryInterface   \n// fails with an E_NOINTERFACE error, a NULL smart pointer is   \n// constructed.  \n_com_ptr_t(   \n   const _variant_t& varSrc   \n);  \n  \n// Constructs a smart pointer given the CLSID of a coclass. This   \n// function calls CoCreateInstance, by the member function  \n//  CreateInstance, to create a new COM object and then queries for   \n// this smart pointer's interface type. If QueryInterface fails with   \n// an E_NOINTERFACE error, a NULL smart pointer is constructed.  \nexplicit _com_ptr_t(   \n   const CLSID& clsid,    \n   IUnknown* pOuter = NULL,    \n   DWORD dwClsContext = CLSCTX_ALL   \n);  \n  \n// Calls CoCreateClass with provided CLSID retrieved from string.  \nexplicit _com_ptr_t(   \n   LPCWSTR str,    \n   IUnknown* pOuter = NULL,    \n   DWORD dwClsContext = CLSCTX_ALL   \n);  \n  \n// Constructs a smart pointer given a multibyte character string that   \n// holds either a CLSID (starting with \"{\") or a ProgID. This function   \n// calls CoCreateInstance, by the member function CreateInstance, to   \n// create a new COM object and then queries for this smart pointer's   \n// interface type. If QueryInterface fails with an E_NOINTERFACE error,   \n// a NULL smart pointer is constructed.  \nexplicit _com_ptr_t(   \n   LPCSTR str,   \n   IUnknown* pOuter = NULL,   \n   DWORD dwClsContext = CLSCTX_ALL   \n);  \n  \n// Saves the interface.  \ntemplate<>    \n_com_ptr_t(   \n   Interface* pInterface   \n) throw();  \n  \n// Make sure correct ctor is called  \ntemplate<>    \n_com_ptr_t(   \n   LPSTR str   \n);  \n  \n// Make sure correct ctor is called  \ntemplate<>    \n_com_ptr_t(   \n   LPWSTR str   \n);  \n  \n// Constructs a smart pointer from a different smart pointer type or   \n// from a different raw interface pointer. QueryInterface is called to   \n// find an interface pointer of this smart pointer's type. If   \n// QueryInterface fails with an E_NOINTERFACE error, a NULL smart   \n// pointer is constructed.  \ntemplate<typename _OtherIID>    \n_com_ptr_t(   \n   const _com_ptr_t<_OtherIID>& p   \n);  \n  \n// Constructs a smart-pointer from any IUnknown-based interface pointer.  \ntemplate<typename _InterfaceType>   \n_com_ptr_t(   \n   _InterfaceType* p   \n);  \n  \n// Disable conversion using _com_ptr_t* specialization of  \n// template<typename _InterfaceType> _com_ptr_t(_InterfaceType* p)  \ntemplate<>    \nexplicit _com_ptr_t(   \n   _com_ptr_t* p   \n);  \n```  \n  \n#### Parameters  \n `pInterface`  \n A raw interface pointer.  \n  \n `fAddRef`  \n If **true**, `AddRef` is called to increment the reference count of the encapsulated interface pointer.  \n  \n *cp*  \n A `_com_ptr_t` object.  \n  \n `p`  \n A raw interface pointer, its type being different from the smart pointer type of this `_com_ptr_t` object.  \n  \n *varSrc*  \n A `_variant_t` object.  \n  \n `clsid`  \n The **CLSID** of a coclass.  \n  \n `dwClsContext`  \n Context for running executable code.  \n  \n *lpcStr*  \n A multibyte string that holds either a **CLSID** (starting with \"**{**\") or a **ProgID**.  \n  \n `pOuter`  \n The outer unknown for [aggregation](http://msdn.microsoft.com/library/windows/desktop/ms686558).  \n  \n## See Also  \n [_com_ptr_t Class](../cpp/com-ptr-t-class.md)"}