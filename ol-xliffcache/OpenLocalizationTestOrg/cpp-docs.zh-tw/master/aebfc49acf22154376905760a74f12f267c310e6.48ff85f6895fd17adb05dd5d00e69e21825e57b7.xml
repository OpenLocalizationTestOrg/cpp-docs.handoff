{"nodes":[{"pos":[12,79],"content":"Uniform Initialization and Delegating Constructors | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Uniform Initialization and Delegating Constructors | Microsoft Docs","pos":[0,67]}]},{"content":"Uniform Initialization and Delegating Constructors","pos":[585,635]},{"content":"In modern C++, you can use <bpt id=\"p1\">*</bpt>brace initialization<ept id=\"p1\">*</ept> for any type, without the equals sign.","pos":[636,724],"source":"In modern C++, you can use *brace initialization* for any type, without the equals sign."},{"content":"Also, you can use delegating constructors to simplify your code when you have multiple constructors that perform similar work.","pos":[725,851]},{"content":"Brace Initialization","pos":[860,880]},{"content":"You can use brace initialization for any class, struct, or union.","pos":[884,949]},{"content":"If a type has a default constructor, either implicitly or explicitly declared, you can use default brace initialization (with empty braces).","pos":[950,1090]},{"content":"For example, the following class may be initialized by using both default and non-default brace initialization:","pos":[1091,1202]},{"content":"If a class has non-default constructors, the order in which class members appear in the brace initializer is the order in which the corresponding parameters appear in the constructor, not the order in which the members are declared (as with <ph id=\"ph1\">`class_a`</ph> in the previous example).","pos":[1733,2009],"source":"If a class has non-default constructors, the order in which class members appear in the brace initializer is the order in which the corresponding parameters appear in the constructor, not the order in which the members are declared (as with `class_a` in the previous example)."},{"content":"Otherwise, if the type has no declared constructor, the order in which the members appear in the brace initializer is the same as the order in which they are declared; in this case, you can initialize as many of the public members as you wish, but you cannot skip any member.","pos":[2010,2285]},{"content":"The following example shows the order that's used in brace initialization when there is no declared constructor:","pos":[2286,2398]},{"content":"If the default constructor is explicitly declared but marked as deleted, default brace initialization cannot be used:","pos":[2780,2897]},{"pos":[3186,3348],"content":"You can use brace initialization anywhere you would typically do initialization—for example, as a function parameter or a return value, or with the <ph id=\"ph1\">`new`</ph> keyword:","source":"You can use brace initialization anywhere you would typically do initialization—for example, as a function parameter or a return value, or with the `new` keyword:"},{"content":"initializer_list Constructors","pos":[3452,3481]},{"content":"The <bpt id=\"p1\">[</bpt>initializer_list Class<ept id=\"p1\">](../standard-library/initializer-list-class.md)</ept> represents a list of objects of a specified type that can be used in a constructor, and in other contexts.","pos":[3485,3667],"source":"The [initializer_list Class](../standard-library/initializer-list-class.md) represents a list of objects of a specified type that can be used in a constructor, and in other contexts."},{"content":"You can construct an initializer_list by using brace initialization:","pos":[3668,3736]},{"pos":[3805,3930],"content":"[!IMPORTANT]\n To use this class, you must include the [<initializer_list>](../standard-library/initializer-list.md) header.","leadings":["","> "],"nodes":[{"content":"To use this class, you must include the <bpt id=\"p1\">[</bpt>&lt;initializer_list&gt;<ept id=\"p1\">](../standard-library/initializer-list.md)</ept> header.","pos":[14,123],"source":" To use this class, you must include the [<initializer_list>](../standard-library/initializer-list.md) header."}]},{"content":"An <ph id=\"ph1\">`initializer_list`</ph> can be copied.","pos":[3937,3973],"source":"An `initializer_list` can be copied."},{"content":"In this case, the members of the new list are references to the members of the original list:","pos":[3974,4067]},{"content":"The standard library container classes, and also <ph id=\"ph1\">`string`</ph>, <ph id=\"ph2\">`wstring`</ph>, and <ph id=\"ph3\">`regex`</ph>, have <ph id=\"ph4\">`initializer_list`</ph> constructors.","pos":[4265,4385],"source":"The standard library container classes, and also `string`, `wstring`, and `regex`, have `initializer_list` constructors."},{"content":"The following examples show how to do brace initialization with these constructors:","pos":[4386,4469]},{"content":"Delegating Constructors","pos":[4632,4655]},{"content":"Many classes have multiple constructors that do similar things—for example, validate parameters:","pos":[4659,4755]},{"content":"You could reduce the repetitive code by adding a function that does all of the validation, but the code for <ph id=\"ph1\">`class_c`</ph> would be easier to understand and maintain if one constructor could delegate some of the work to another one.","pos":[5344,5571],"source":"You could reduce the repetitive code by adding a function that does all of the validation, but the code for `class_c` would be easier to understand and maintain if one constructor could delegate some of the work to another one."},{"content":"To add delegating constructors, use the <ph id=\"ph1\">`constructor (. . .) : constructor (. . .)`</ph> syntax:","pos":[5572,5663],"source":" To add delegating constructors, use the `constructor (. . .) : constructor (. . .)` syntax:"},{"content":"As you step through the previous example, notice that the constructor <ph id=\"ph1\">`class_c(int, int, int)`</ph> first calls the constructor <ph id=\"ph2\">`class_c(int, int)`</ph>, which in turn calls <ph id=\"ph3\">`class_c(int)`</ph>.","pos":[6186,6365],"source":"As you step through the previous example, notice that the constructor `class_c(int, int, int)` first calls the constructor `class_c(int, int)`, which in turn calls `class_c(int)`."},{"content":"Each of the constructors performs only the work that is not performed by the other constructors.","pos":[6366,6462]},{"content":"The first constructor that's called initializes the object so that all of its members are initialized at that point.","pos":[6469,6585]},{"content":"You can’t do member initialization in a constructor that delegates to another constructor, as shown here:","pos":[6586,6691]},{"content":"The next example shows the use of non-static data-member initializers.","pos":[7243,7313]},{"content":"Notice that if a constructor also initializes a given data member, the member initializer is overridden:","pos":[7314,7418]},{"content":"The constructor delegation syntax doesn't prevent the accidental creation of constructor recursion—Constructor1 calls Constructor2 which calls Constructor1—and no errors are thrown until there is a stack overflow.","pos":[7829,8042]},{"content":"It's your responsibility to avoid cycles.","pos":[8043,8084]}],"content":"---\ntitle: \"Uniform Initialization and Delegating Constructors | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: aa4daa64-eaec-4a3c-ade4-d9325e31e9d4\ncaps.latest.revision: 3\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Uniform Initialization and Delegating Constructors\nIn modern C++, you can use *brace initialization* for any type, without the equals sign. Also, you can use delegating constructors to simplify your code when you have multiple constructors that perform similar work.  \n  \n## Brace Initialization  \n You can use brace initialization for any class, struct, or union. If a type has a default constructor, either implicitly or explicitly declared, you can use default brace initialization (with empty braces). For example, the following class may be initialized by using both default and non-default brace initialization:  \n  \n```cpp  \n#include <string>  \nusing namespace std;  \n  \nclass class_a {  \npublic:  \n    class_a() {}  \n    class_a(string str) : m_string{ str } {}  \n    class_a(string str, double dbl) : m_string{ str }, m_double{ dbl } {}  \ndouble m_double;  \nstring m_string;  \n};  \n  \nint main()  \n{  \n    class_a c1{};  \n    class_a c1_1;  \n  \n    class_a c2{ \"ww\" };  \n    class_a c2_1(\"xx\");  \n  \n    // order of parameters is the same as the constructor  \n    class_a c3{ \"yy\", 4.4 };  \n    class_a c3_1(\"zz\", 5.5);  \n}  \n  \n```  \n  \n If a class has non-default constructors, the order in which class members appear in the brace initializer is the order in which the corresponding parameters appear in the constructor, not the order in which the members are declared (as with `class_a` in the previous example). Otherwise, if the type has no declared constructor, the order in which the members appear in the brace initializer is the same as the order in which they are declared; in this case, you can initialize as many of the public members as you wish, but you cannot skip any member. The following example shows the order that's used in brace initialization when there is no declared constructor:  \n  \n```cpp  \nclass class_d {  \npublic:  \n    float m_float;  \n    string m_string;  \n    wchar_t m_char;  \n};  \n  \nint main()  \n{  \n    class_d d1{};  \n    class_d d1{ 4.5 };  \n    class_d d2{ 4.5, \"string\" };  \n    class_d d3{ 4.5, \"string\", 'c' };  \n  \n    class_d d4{ \"string\", 'c' }; // compiler error  \n    class_d d5(\"string\", 'c', 2.0 }; // compiler error  \n}   \n```  \n  \n If the default constructor is explicitly declared but marked as deleted, default brace initialization cannot be used:  \n  \n```cpp  \nclass class_f {  \npublic:  \n    class_f() = delete;  \n    class_f(string x): m_string { x } {}  \n    string m_string;  \n};  \nint main()  \n{  \n    class_f cf{ \"hello\" };  \n    class_f cf1{}; // compiler error C2280: attempting to reference a deleted function  \n}  \n```  \n  \n You can use brace initialization anywhere you would typically do initialization—for example, as a function parameter or a return value, or with the `new` keyword:  \n  \n```cpp  \nclass_d* cf = new class_d{4.5};  \nkr->add_d({ 4.5 });  \nreturn { 4.5 };  \n  \n```  \n  \n## initializer_list Constructors  \n The [initializer_list Class](../standard-library/initializer-list-class.md) represents a list of objects of a specified type that can be used in a constructor, and in other contexts. You can construct an initializer_list by using brace initialization:  \n  \n```cpp  \ninitializer_list<int> int_list{5, 6, 7};  \n```  \n  \n> [!IMPORTANT]\n>  To use this class, you must include the [<initializer_list>](../standard-library/initializer-list.md) header.  \n  \n An `initializer_list` can be copied. In this case, the members of the new list are references to the members of the original list:  \n  \n```cpp  \ninitializer_list<int> ilist1{ 5, 6, 7 };  \ninitializer_list<int> ilist2( ilist1 );  \nif (ilist1.begin() == ilist2.begin())  \n    cout << \"yes\" << endl; // expect \"yes\"  \n  \n```  \n  \n The standard library container classes, and also `string`, `wstring`, and `regex`, have `initializer_list` constructors. The following examples show how to do brace initialization with these constructors:  \n  \n```cpp  \nvector<int> v1{ 9, 10, 11 };   \nmap<int, string> m1{ {1, \"a\"}, {2, \"b\"} };  \nstring s{ 'a', 'b', 'c' };   \nregex rgx{'x', 'y', 'z'};   \n```  \n  \n## Delegating Constructors  \n Many classes have multiple constructors that do similar things—for example, validate parameters:  \n  \n```cpp  \nclass class_c {  \npublic:  \n    int max;  \n    int min;  \n    int middle;  \n  \n    class_c() {}  \n    class_c(int my_max) {   \n        max = my_max > 0 ? my_max : 10;   \n    }  \n    class_c(int my_max, int my_min) {   \n        max = my_max > 0 ? my_max : 10;  \n        min = my_min > 0 && my_min < max ? my_min : 1;  \n    }  \n    class_c(int my_max, int my_min, int my_middle) {  \n        max = my_max > 0 ? my_max : 10;  \n        min = my_min > 0 && my_min < max ? my_min : 1;  \n        middle = my_middle < max && my_middle > min ? my_middle : 5;  \n    }  \n};  \n```  \n  \n You could reduce the repetitive code by adding a function that does all of the validation, but the code for `class_c` would be easier to understand and maintain if one constructor could delegate some of the work to another one. To add delegating constructors, use the `constructor (. . .) : constructor (. . .)` syntax:  \n  \n```cpp  \nclass class_c {  \npublic:  \n    int max;  \n    int min;  \n    int middle;  \n  \n    class_c(int my_max) {   \n        max = my_max > 0 ? my_max : 10;   \n    }  \n    class_c(int my_max, int my_min) : class_c(my_max) {   \n        min = my_min > 0 && my_min < max ? my_min : 1;  \n    }  \n    class_c(int my_max, int my_min, int my_middle) : class_c (my_max, my_min){  \n        middle = my_middle < max && my_middle > min ? my_middle : 5;  \n}  \n};  \nint main() {  \n  \n    class_c c1{ 1, 3, 2 };  \n}  \n  \n```  \n  \n As you step through the previous example, notice that the constructor `class_c(int, int, int)` first calls the constructor `class_c(int, int)`, which in turn calls `class_c(int)`. Each of the constructors performs only the work that is not performed by the other constructors.  \n  \n The first constructor that's called initializes the object so that all of its members are initialized at that point. You can’t do member initialization in a constructor that delegates to another constructor, as shown here:  \n  \n```cpp  \nclass class_a {  \npublic:  \n    class_a() {}  \n    // member initialization here, no delegate  \n    class_a(string str) : m_string{ str } {}  \n  \n    //can’t do member initialization here  \n    // error C3511: a call to a delegating constructor shall be the only member-initializer  \n    class_a(string str, double dbl) : class_a(str) , m_double{ dbl } {}  \n  \n    // only member assignment  \n    class_a(string str, double dbl) : class_a(str) { m_double = dbl; }  \n    double m_double{ 1.0 };  \n    string m_string;  \n};  \n  \n```  \n  \n The next example shows the use of non-static data-member initializers. Notice that if a constructor also initializes a given data member, the member initializer is overridden:  \n  \n```cpp  \nclass class_a {  \npublic:  \n    class_a() {}  \n    class_a(string str) : m_string{ str } {}  \n    class_a(string str, double dbl) : class_a(str) { m_double = dbl; }  \n    double m_double{ 1.0 };  \n    string m_string{ m_double < 10.0 ? \"alpha\" : \"beta\" };  \n};  \n  \nint main() {  \n    class_a a{ \"hello\", 2.0 };  //expect a.m_double == 2.0, a.m_string == \"hello\"  \n    int y = 4;  \n}  \n```  \n  \n The constructor delegation syntax doesn't prevent the accidental creation of constructor recursion—Constructor1 calls Constructor2 which calls Constructor1—and no errors are thrown until there is a stack overflow. It's your responsibility to avoid cycles.  \n  \n```cpp  \nclass class_f{  \npublic:  \n    int max;  \n    int min;  \n  \n    // don't do this  \n    class_f() : class_f(6, 3){ }  \n    class_f(int my_max, int my_min) : class_f() { }  \n};  \n```"}