{"nodes":[{"pos":[12,44],"content":"strict_gs_check | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"strict_gs_check | Microsoft Docs","pos":[0,32]}]},{"content":"strict_gs_check","pos":[663,678]},{"content":"This pragma provides enhanced security checking.","pos":[679,727]},{"content":"Syntax","pos":[736,742]},{"content":"Remarks","pos":[878,885]},{"content":"Instructs the compiler to insert a random cookie in the function stack to help detect some categories of stack-based buffer overrun.","pos":[889,1021]},{"content":"By default, the /GS (Buffer Security Check) compiler option does not insert a cookie for all functions.","pos":[1022,1125]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>/GS (Buffer Security Check)<ept id=\"p1\">](../build/reference/gs-buffer-security-check.md)</ept>.","pos":[1126,1230],"source":" For more information, see [/GS (Buffer Security Check)](../build/reference/gs-buffer-security-check.md)."},{"content":"You must compile with /GS (Buffer Security Check) to enable strict_gs_check.","pos":[1237,1313]},{"content":"Use this pragma in code modules that are exposed to potentially harmful data.","pos":[1320,1397]},{"content":"This pragma is very aggressive, and is applied to functions that might not need this defense, but is optimized to minimize its effect on the performance of the resulting application.","pos":[1398,1580]},{"content":"Even if you use this pragma, you should strive to write secure code.","pos":[1587,1655]},{"content":"That is, make sure that your code has no buffer overruns.","pos":[1656,1713]},{"content":"strict_gs_check might protect your application from buffer overruns that do remain in your code.","pos":[1714,1810]},{"content":"Example","pos":[1819,1826]},{"content":"In the following code a buffer overrun occurs when we copy an array to a local array.","pos":[1830,1915]},{"content":"When you compile this code with /GS, no cookie is inserted in the stack, because the array data type is a pointer.","pos":[1916,2030]},{"content":"Adding the strict_gs_check pragma forces the stack cookie into the function stack.","pos":[2031,2113]},{"content":"See Also","pos":[2757,2765]},{"content":"Pragma Directives and the __Pragma Keyword","pos":[2770,2812]},{"content":"/GS (Buffer Security Check)","pos":[2880,2907]}],"content":"---\ntitle: \"strict_gs_check | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"strict_gs_check\"\n  - \"strict_gs_check_CPP\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"strict_gs_check pragma\"\nms.assetid: decfec81-c916-42e0-a07f-8cc26df6a7ce\ncaps.latest.revision: 9\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# strict_gs_check\nThis pragma provides enhanced security checking.  \n  \n## Syntax  \n  \n```  \n#pragma strict_gs_check([push,] on )   \n#pragma strict_gs_check([push,] off )   \n#pragma strict_gs_check(pop)  \n```  \n  \n## Remarks  \n Instructs the compiler to insert a random cookie in the function stack to help detect some categories of stack-based buffer overrun. By default, the /GS (Buffer Security Check) compiler option does not insert a cookie for all functions. For more information, see [/GS (Buffer Security Check)](../build/reference/gs-buffer-security-check.md).  \n  \n You must compile with /GS (Buffer Security Check) to enable strict_gs_check.  \n  \n Use this pragma in code modules that are exposed to potentially harmful data. This pragma is very aggressive, and is applied to functions that might not need this defense, but is optimized to minimize its effect on the performance of the resulting application.  \n  \n Even if you use this pragma, you should strive to write secure code. That is, make sure that your code has no buffer overruns. strict_gs_check might protect your application from buffer overruns that do remain in your code.  \n  \n## Example  \n In the following code a buffer overrun occurs when we copy an array to a local array. When you compile this code with /GS, no cookie is inserted in the stack, because the array data type is a pointer. Adding the strict_gs_check pragma forces the stack cookie into the function stack.  \n  \n```cpp  \n// pragma_strict_gs_check.cpp  \n// compile with: /c  \n  \n#pragma strict_gs_check(on)  \n  \nvoid ** ReverseArray(void **pData,  \n                     size_t cData)  \n{  \n    // *** This buffer is subject to being overrun!! ***  \n    void *pReversed[20];  \n  \n    // Reverse the array into a temporary buffer  \n    for (size_t j = 0, i = cData; i ; --i, ++j)  \n        // *** Possible buffer overrun!! ***  \n            pReversed[j] = pData[i];   \n  \n    // Copy temporary buffer back into input/output buffer  \n    for (size_t i = 0; i < cData ; ++i)   \n        pData[i] = pReversed[i];  \n  \n    return pData;  \n}  \n  \n```  \n  \n## See Also  \n [Pragma Directives and the __Pragma Keyword](../preprocessor/pragma-directives-and-the-pragma-keyword.md)   \n [/GS (Buffer Security Check)](../build/reference/gs-buffer-security-check.md)"}