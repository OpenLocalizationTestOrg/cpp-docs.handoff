{"nodes":[{"pos":[12,75],"content":"TN062: Message Reflection for Windows Controls | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN062: Message Reflection for Windows Controls | Microsoft Docs","pos":[0,63]}]},{"content":"TN062: Message Reflection for Windows Controls","pos":[1311,1357]},{"pos":[1360,1675],"content":"[!NOTE]\n The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","leadings":["","> "],"nodes":[{"content":" The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[8,313],"nodes":[{"content":"The following technical note has not been updated since it was first included in the online documentation.","pos":[1,107]},{"content":"As a result, some procedures and topics might be out of date or incorrect.","pos":[108,182]},{"content":"For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[183,305]}]}]},{"content":"This technical note describes message reflection, a new feature in MFC 4.0.","pos":[1682,1757]},{"content":"It also contains directions for creating a simple reusable control that uses message reflection.","pos":[1758,1854]},{"content":"This technical note does not discuss message reflection as it applies to ActiveX controls (formerly called OLE controls).","pos":[1861,1982]},{"content":"Please see the article <bpt id=\"p1\">[</bpt>ActiveX Controls: Subclassing a Windows Control<ept id=\"p1\">](../mfc/mfc-activex-controls-subclassing-a-windows-control.md)</ept>.","pos":[1983,2118],"source":" Please see the article [ActiveX Controls: Subclassing a Windows Control](../mfc/mfc-activex-controls-subclassing-a-windows-control.md)."},{"content":"What Is Message Reflection","pos":[2127,2153]},{"content":"Windows controls frequently send notification messages to their parent windows.","pos":[2162,2241]},{"content":"For instance, many controls send a control color notification message (<ph id=\"ph1\">`WM_CTLCOLOR`</ph> or one of its variants) to their parent to allow the parent to supply a brush for painting the background of the control.","pos":[2242,2448],"source":" For instance, many controls send a control color notification message (`WM_CTLCOLOR` or one of its variants) to their parent to allow the parent to supply a brush for painting the background of the control."},{"content":"In Windows and in MFC before version 4.0, the parent window, often a dialog box, is responsible for handling these messages.","pos":[2455,2579]},{"content":"This means that the code for handling the message needs to be in the parent window's class and that it has to be duplicated in every class that needs to handle that message.","pos":[2580,2753]},{"content":"In the case above, every dialog box that wanted controls with custom backgrounds would have to handle the control color notification message.","pos":[2754,2895]},{"content":"It would be much easier to reuse code if a control class could be written that would handle its own background color.","pos":[2896,3013]},{"content":"In MFC 4.0, the old mechanism still works — parent windows can handle notification messages.","pos":[3020,3112]},{"content":"In addition, however, MFC 4.0 facilitates reuse by providing a feature called \"message reflection\" that allows these notification messages to be handled in either the child control window or the parent window, or in both.","pos":[3113,3334]},{"content":"In the control background color example, you can now write a control class that sets its own background color by handling the reflected <ph id=\"ph1\">`WM_CTLCOLOR`</ph> message — all without relying on the parent.","pos":[3335,3529],"source":" In the control background color example, you can now write a control class that sets its own background color by handling the reflected `WM_CTLCOLOR` message — all without relying on the parent."},{"content":"(Note that since message reflection is implemented by MFC, not by Windows, the parent window class must be derived from <ph id=\"ph1\">`CWnd`</ph> for message reflection to work.)","pos":[3530,3689],"source":" (Note that since message reflection is implemented by MFC, not by Windows, the parent window class must be derived from `CWnd` for message reflection to work.)"},{"content":"Older versions of MFC did something similar to message reflection by providing virtual functions for a few messages, such as messages for owner-drawn list boxes (<ph id=\"ph1\">`WM_DRAWITEM`</ph>, and so on).","pos":[3696,3884],"source":"Older versions of MFC did something similar to message reflection by providing virtual functions for a few messages, such as messages for owner-drawn list boxes (`WM_DRAWITEM`, and so on)."},{"content":"The new message reflection mechanism is generalized and consistent.","pos":[3885,3952]},{"content":"Message reflection is backward compatible with code written for versions of MFC before 4.0.","pos":[3959,4050]},{"content":"If you have supplied a handler for a specific message, or for a range of messages, in your parent window's class, it will override reflected message handlers for the same message provided you don't call the base class handler function in your own handler.","pos":[4057,4312]},{"content":"For example, if you handle <ph id=\"ph1\">`WM_CTLCOLOR`</ph> in your dialog box class, your handling will override any reflected message handlers.","pos":[4313,4439],"source":" For example, if you handle `WM_CTLCOLOR` in your dialog box class, your handling will override any reflected message handlers."},{"content":"If, in your parent window class, you supply a handler for a specific <bpt id=\"p1\">**</bpt>WM_NOTIFY<ept id=\"p1\">**</ept> message or a range of <bpt id=\"p2\">**</bpt>WM_NOTIFY<ept id=\"p2\">**</ept> messages, your handler will be called only if the child control sending those messages does not have a reflected message handler through <bpt id=\"p3\">**</bpt>ON_NOTIFY_REFLECT()<ept id=\"p3\">**</ept>.","pos":[4446,4726],"source":"If, in your parent window class, you supply a handler for a specific **WM_NOTIFY** message or a range of **WM_NOTIFY** messages, your handler will be called only if the child control sending those messages does not have a reflected message handler through **ON_NOTIFY_REFLECT()**."},{"content":"If you use <bpt id=\"p1\">**</bpt>ON_NOTIFY_REFLECT_EX()<ept id=\"p1\">**</ept> in your message map, your message handler may or may not allow the parent window to handle the message.","pos":[4727,4868],"source":" If you use **ON_NOTIFY_REFLECT_EX()** in your message map, your message handler may or may not allow the parent window to handle the message."},{"content":"If the handler returns <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept>, the message will be handled by the parent as well, while a call that returns <bpt id=\"p2\">**</bpt>TRUE<ept id=\"p2\">**</ept> does not allow the parent to handle it.","pos":[4869,5028],"source":" If the handler returns **FALSE**, the message will be handled by the parent as well, while a call that returns **TRUE** does not allow the parent to handle it."},{"content":"Note that the reflected message is handled before the notification message.","pos":[5029,5104]},{"content":"When a <bpt id=\"p1\">**</bpt>WM_NOTIFY<ept id=\"p1\">**</ept> message is sent, the control is offered the first chance to handle it.","pos":[5111,5202],"source":"When a **WM_NOTIFY** message is sent, the control is offered the first chance to handle it."},{"content":"If any other reflected message is sent, the parent window has the first chance to handle it and the control will receive the reflected message.","pos":[5203,5346]},{"content":"To do so, it will need a handler function and an appropriate entry in the control's class message map.","pos":[5347,5449]},{"content":"The message-map macro for reflected messages is slightly different than for regular notifications: it has <bpt id=\"p1\">**</bpt>_REFLECT<ept id=\"p1\">**</ept> appended to its usual name.","pos":[5456,5602],"source":"The message-map macro for reflected messages is slightly different than for regular notifications: it has **_REFLECT** appended to its usual name."},{"content":"For instance, to handle a <bpt id=\"p1\">**</bpt>WM_NOTIFY<ept id=\"p1\">**</ept> message in the parent, you use the macro <ph id=\"ph1\">`ON_NOTIFY`</ph> in the parent's message map.","pos":[5603,5724],"source":" For instance, to handle a **WM_NOTIFY** message in the parent, you use the macro `ON_NOTIFY` in the parent's message map."},{"content":"To handle the reflected message in the child control, use the <bpt id=\"p1\">**</bpt>ON_NOTIFY_REFLECT<ept id=\"p1\">**</ept> macro in the child control's message map.","pos":[5725,5850],"source":" To handle the reflected message in the child control, use the **ON_NOTIFY_REFLECT** macro in the child control's message map."},{"content":"In some cases, the parameters are different, as well.","pos":[5851,5904]},{"content":"Note that ClassWizard can usually add the message-map entries for you and provide skeleton function implementations with correct parameters.","pos":[5905,6045]},{"pos":[6052,6197],"content":"See <bpt id=\"p1\">[</bpt>TN061: ON_NOTIFY and WM_NOTIFY Messages<ept id=\"p1\">](../mfc/tn061-on-notify-and-wm-notify-messages.md)</ept> for information on the new <bpt id=\"p2\">**</bpt>WM_NOTIFY<ept id=\"p2\">**</ept> message.","source":"See [TN061: ON_NOTIFY and WM_NOTIFY Messages](../mfc/tn061-on-notify-and-wm-notify-messages.md) for information on the new **WM_NOTIFY** message."},{"content":"Message-Map Entries and Handler Function Prototypes for Reflected Messages","pos":[6206,6280]},{"content":"To handle a reflected control notification message, use the message-map macros and function prototypes listed in the table below.","pos":[6289,6418]},{"content":"ClassWizard can usually add these message-map entries for you and provide skeleton function implementations.","pos":[6425,6533]},{"content":"See <bpt id=\"p1\">[</bpt>Defining a Message Handler for a Reflected Message<ept id=\"p1\">](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md)</ept> for information about how to define handlers for reflected messages.","pos":[6534,6731],"source":" See [Defining a Message Handler for a Reflected Message](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md) for information about how to define handlers for reflected messages."},{"content":"To convert from the message name to the reflected macro name, prepend <bpt id=\"p1\">**</bpt>ON_<ept id=\"p1\">**</ept> and append <bpt id=\"p2\">**</bpt>_REFLECT<ept id=\"p2\">**</ept>.","pos":[6738,6840],"source":"To convert from the message name to the reflected macro name, prepend **ON_** and append **_REFLECT**."},{"content":"For example, <ph id=\"ph1\">`WM_CTLCOLOR`</ph> becomes <bpt id=\"p1\">**</bpt>ON_WM_CTLCOLOR_REFLECT<ept id=\"p1\">**</ept>.","pos":[6841,6903],"source":" For example, `WM_CTLCOLOR` becomes **ON_WM_CTLCOLOR_REFLECT**."},{"content":"(To see which messages can be reflected, do the opposite conversion on the macro entries in the table below.)","pos":[6904,7013]},{"content":"The three exceptions to the rule above are as follows:","pos":[7020,7074]},{"pos":[7084,7153],"content":"The macro for <bpt id=\"p1\">**</bpt>WM_COMMAND<ept id=\"p1\">**</ept> notifications is <bpt id=\"p2\">**</bpt>ON_CONTROL_REFLECT<ept id=\"p2\">**</ept>.","source":"The macro for **WM_COMMAND** notifications is **ON_CONTROL_REFLECT**."},{"pos":[7163,7228],"content":"The macro for <bpt id=\"p1\">**</bpt>WM_NOTIFY<ept id=\"p1\">**</ept> reflections is <bpt id=\"p2\">**</bpt>ON_NOTIFY_REFLECT<ept id=\"p2\">**</ept>.","source":"The macro for **WM_NOTIFY** reflections is **ON_NOTIFY_REFLECT**."},{"pos":[7238,7323],"content":"The macro for <ph id=\"ph1\">`ON_UPDATE_COMMAND_UI`</ph> reflections is <bpt id=\"p1\">**</bpt>ON_UPDATE_COMMAND_UI_REFLECT<ept id=\"p1\">**</ept>.","source":"The macro for `ON_UPDATE_COMMAND_UI` reflections is **ON_UPDATE_COMMAND_UI_REFLECT**."},{"content":"In each of the above special cases, you must specify the name of the handler member function.","pos":[7330,7423]},{"content":"In the other cases, you must use the standard name for your handler function.","pos":[7424,7501]},{"content":"The meanings of the parameters and return values of the functions are documented under either the function name or the function name with <bpt id=\"p1\">**</bpt>On<ept id=\"p1\">**</ept> prepended.","pos":[7508,7663],"source":"The meanings of the parameters and return values of the functions are documented under either the function name or the function name with **On** prepended."},{"content":"For instance, <bpt id=\"p1\">**</bpt>CtlColor<ept id=\"p1\">**</ept> is documented in <ph id=\"ph1\">`OnCtlColor`</ph>.","pos":[7664,7721],"source":" For instance, **CtlColor** is documented in `OnCtlColor`."},{"content":"Several reflected message handlers need fewer parameters than the similar handlers in a parent window.","pos":[7722,7824]},{"content":"Just match the names in the table below with the names of the formal parameters in the documentation.","pos":[7825,7926]},{"content":"Map entry","pos":[7933,7942]},{"content":"Function prototype","pos":[7943,7961]},{"pos":[8011,8072],"content":"<bpt id=\"p1\">**</bpt>ON_CONTROL_REFLECT(<ept id=\"p1\">**</ept> <ph id=\"ph1\">`wNotifyCode`</ph> <bpt id=\"p2\">**</bpt>,<ept id=\"p2\">**</ept> <ph id=\"ph2\">`memberFxn`</ph> <bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>","source":"**ON_CONTROL_REFLECT(** `wNotifyCode` **,** `memberFxn` **)**"},{"pos":[8073,8110],"content":"<bpt id=\"p1\">**</bpt>afx_msg void<ept id=\"p1\">**</ept> <ph id=\"ph1\">`memberFxn`</ph> <bpt id=\"p2\">**</bpt>( );<ept id=\"p2\">**</ept>","source":"**afx_msg void** `memberFxn` **( );**"},{"pos":[8115,8175],"content":"<bpt id=\"p1\">**</bpt>ON_NOTIFY_REFLECT(<ept id=\"p1\">**</ept> <ph id=\"ph1\">`wNotifyCode`</ph> <bpt id=\"p2\">**</bpt>,<ept id=\"p2\">**</ept> <ph id=\"ph2\">`memberFxn`</ph> <bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>","source":"**ON_NOTIFY_REFLECT(** `wNotifyCode` **,** `memberFxn` **)**"},{"pos":[8176,8267],"content":"<bpt id=\"p1\">**</bpt>afx_msg void<ept id=\"p1\">**</ept> <ph id=\"ph1\">`memberFxn`</ph> <bpt id=\"p2\">**</bpt>( NMHDR <ph id=\"ph2\">\\*</ph><ept id=\"p2\">**</ept> <ph id=\"ph3\">`pNotifyStruct`</ph> <bpt id=\"p3\">**</bpt>, LRESULT<ph id=\"ph4\">\\*</ph><ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt>result<ept id=\"p4\">*</ept> <bpt id=\"p5\">**</bpt>);<ept id=\"p5\">**</ept>","source":"**afx_msg void** `memberFxn` **( NMHDR \\*** `pNotifyStruct` **, LRESULT\\*** *result* **);**"},{"pos":[8272,8323],"content":"<bpt id=\"p1\">**</bpt>ON_UPDATE_COMMAND_UI_REFLECT(<ept id=\"p1\">**</ept> <ph id=\"ph1\">`memberFxn`</ph> <bpt id=\"p2\">**</bpt>)<ept id=\"p2\">**</ept>","source":"**ON_UPDATE_COMMAND_UI_REFLECT(** `memberFxn` **)**"},{"pos":[8324,8383],"content":"<bpt id=\"p1\">**</bpt>afx_msg void<ept id=\"p1\">**</ept> <ph id=\"ph1\">`memberFxn`</ph> <bpt id=\"p2\">**</bpt>( CCmdUI<ph id=\"ph2\">\\*</ph><ept id=\"p2\">**</ept> <ph id=\"ph3\">`pCmdUI`</ph> <bpt id=\"p3\">**</bpt>);<ept id=\"p3\">**</ept>","source":"**afx_msg void** `memberFxn` **( CCmdUI\\*** `pCmdUI` **);**"},{"content":"ON_WM_CTLCOLOR_REFLECT( )","pos":[8390,8415]},{"pos":[8418,8489],"content":"<bpt id=\"p1\">**</bpt>afx_msg HBRUSH CtlColor ( CDC<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> <ph id=\"ph2\">`pDC`</ph> <bpt id=\"p2\">**</bpt>, UINT<ept id=\"p2\">**</ept> <ph id=\"ph3\">`nCtlColor`</ph> <bpt id=\"p3\">**</bpt>);<ept id=\"p3\">**</ept>","source":"**afx_msg HBRUSH CtlColor ( CDC\\*** `pDC` **, UINT** `nCtlColor` **);**"},{"content":"ON_WM_DRAWITEM_REFLECT( )","pos":[8496,8521]},{"pos":[8524,8594],"content":"<bpt id=\"p1\">**</bpt>afx_msg void DrawItem ( LPDRAWITEMSTRUCT<ept id=\"p1\">**</ept> <ph id=\"ph1\">`lpDrawItemStruct`</ph> <bpt id=\"p2\">**</bpt>);<ept id=\"p2\">**</ept>","source":"**afx_msg void DrawItem ( LPDRAWITEMSTRUCT** `lpDrawItemStruct` **);**"},{"content":"ON_WM_MEASUREITEM_REFLECT( )","pos":[8601,8629]},{"pos":[8632,8711],"content":"<bpt id=\"p1\">**</bpt>afx_msg void MeasureItem ( LPMEASUREITEMSTRUCT<ept id=\"p1\">**</ept> <ph id=\"ph1\">`lpMeasureItemStruct`</ph> <bpt id=\"p2\">**</bpt>);<ept id=\"p2\">**</ept>","source":"**afx_msg void MeasureItem ( LPMEASUREITEMSTRUCT** `lpMeasureItemStruct` **);**"},{"content":"ON_WM_DELETEITEM_REFLECT( )","pos":[8718,8745]},{"pos":[8748,8824],"content":"<bpt id=\"p1\">**</bpt>afx_msg void DeleteItem ( LPDELETEITEMSTRUCT<ept id=\"p1\">**</ept> <ph id=\"ph1\">`lpDeleteItemStruct`</ph> <bpt id=\"p2\">**</bpt>);<ept id=\"p2\">**</ept>","source":"**afx_msg void DeleteItem ( LPDELETEITEMSTRUCT** `lpDeleteItemStruct` **);**"},{"content":"ON_WM_COMPAREITEM_REFLECT( )","pos":[8831,8859]},{"pos":[8862,8940],"content":"<bpt id=\"p1\">**</bpt>afx_msg int CompareItem ( LPCOMPAREITEMSTRUCT<ept id=\"p1\">**</ept> <ph id=\"ph1\">`lpCompareItemStruct`</ph> <bpt id=\"p2\">**</bpt>);<ept id=\"p2\">**</ept>","source":"**afx_msg int CompareItem ( LPCOMPAREITEMSTRUCT** `lpCompareItemStruct` **);**"},{"content":"ON_WM_CHARTOITEM_REFLECT( )","pos":[8947,8974]},{"pos":[8977,9044],"content":"<bpt id=\"p1\">**</bpt>afx_msg int CharToItem ( UINT<ept id=\"p1\">**</ept> <ph id=\"ph1\">`nKey`</ph> <bpt id=\"p2\">**</bpt>, UINT<ept id=\"p2\">**</ept> <ph id=\"ph2\">`nIndex`</ph> <bpt id=\"p3\">**</bpt>);<ept id=\"p3\">**</ept>","source":"**afx_msg int CharToItem ( UINT** `nKey` **, UINT** `nIndex` **);**"},{"content":"ON_WM_VKEYTOITEM_REFLECT( )","pos":[9051,9078]},{"pos":[9081,9148],"content":"<bpt id=\"p1\">**</bpt>afx_msg int VKeyToItem ( UINT<ept id=\"p1\">**</ept> <ph id=\"ph1\">`nKey`</ph> <bpt id=\"p2\">**</bpt>, UINT<ept id=\"p2\">**</ept> <ph id=\"ph2\">`nIndex`</ph> <bpt id=\"p3\">**</bpt>);<ept id=\"p3\">**</ept>","source":"**afx_msg int VKeyToItem ( UINT** `nKey` **, UINT** `nIndex` **);**"},{"content":"ON_WM_HSCROLL_REFLECT( )","pos":[9155,9179]},{"pos":[9182,9248],"content":"<bpt id=\"p1\">**</bpt>afx_msg void HScroll ( UINT<ept id=\"p1\">**</ept> <ph id=\"ph1\">`nSBCode`</ph> <bpt id=\"p2\">**</bpt>, UINT<ept id=\"p2\">**</ept> <ph id=\"ph2\">`nPos`</ph> <bpt id=\"p3\">**</bpt>);<ept id=\"p3\">**</ept>","source":"**afx_msg void HScroll ( UINT** `nSBCode` **, UINT** `nPos` **);**"},{"content":"ON_WM_VSCROLL_REFLECT( )","pos":[9255,9279]},{"pos":[9282,9348],"content":"<bpt id=\"p1\">**</bpt>afx_msg void VScroll ( UINT<ept id=\"p1\">**</ept> <ph id=\"ph1\">`nSBCode`</ph> <bpt id=\"p2\">**</bpt>, UINT<ept id=\"p2\">**</ept> <ph id=\"ph2\">`nPos`</ph> <bpt id=\"p3\">**</bpt>);<ept id=\"p3\">**</ept>","source":"**afx_msg void VScroll ( UINT** `nSBCode` **, UINT** `nPos` **);**"},{"content":"ON_WM_PARENTNOTIFY_REFLECT( )","pos":[9355,9384]},{"pos":[9387,9462],"content":"<bpt id=\"p1\">**</bpt>afx_msg void ParentNotify ( UINT<ept id=\"p1\">**</ept> <ph id=\"ph1\">`message`</ph> <bpt id=\"p2\">**</bpt>, LPARAM<ept id=\"p2\">**</ept> <ph id=\"ph2\">`lParam`</ph> <bpt id=\"p3\">**</bpt>);<ept id=\"p3\">**</ept>","source":"**afx_msg void ParentNotify ( UINT** `message` **, LPARAM** `lParam` **);**"},{"pos":[9470,9641],"content":"The <bpt id=\"p1\">**</bpt>ON_NOTIFY_REFLECT<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>ON_CONTROL_REFLECT<ept id=\"p2\">**</ept> macros have variations that allow more than one object (such as the control and its parent) to handle a given message.","source":"The **ON_NOTIFY_REFLECT** and **ON_CONTROL_REFLECT** macros have variations that allow more than one object (such as the control and its parent) to handle a given message."},{"content":"Map entry","pos":[9648,9657]},{"content":"Function prototype","pos":[9658,9676]},{"pos":[9726,9789],"content":"<bpt id=\"p1\">**</bpt>ON_NOTIFY_REFLECT_EX(<ept id=\"p1\">**</ept> <ph id=\"ph1\">`wNotifyCode`</ph> <bpt id=\"p2\">**</bpt>,<ept id=\"p2\">**</ept> <ph id=\"ph2\">`memberFxn`</ph> <bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>","source":"**ON_NOTIFY_REFLECT_EX(** `wNotifyCode` **,** `memberFxn` **)**"},{"pos":[9790,9881],"content":"<bpt id=\"p1\">**</bpt>afx_msg BOOL<ept id=\"p1\">**</ept> <ph id=\"ph1\">`memberFxn`</ph> <bpt id=\"p2\">**</bpt>( NMHDR <ph id=\"ph2\">\\*</ph><ept id=\"p2\">**</ept> <ph id=\"ph3\">`pNotifyStruct`</ph> <bpt id=\"p3\">**</bpt>, LRESULT<ph id=\"ph4\">\\*</ph><ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt>result<ept id=\"p4\">*</ept> <bpt id=\"p5\">**</bpt>);<ept id=\"p5\">**</ept>","source":"**afx_msg BOOL** `memberFxn` **( NMHDR \\*** `pNotifyStruct` **, LRESULT\\*** *result* **);**"},{"pos":[9886,9950],"content":"<bpt id=\"p1\">**</bpt>ON_CONTROL_REFLECT_EX(<ept id=\"p1\">**</ept> <ph id=\"ph1\">`wNotifyCode`</ph> <bpt id=\"p2\">**</bpt>,<ept id=\"p2\">**</ept> <ph id=\"ph2\">`memberFxn`</ph> <bpt id=\"p3\">**</bpt>)<ept id=\"p3\">**</ept>","source":"**ON_CONTROL_REFLECT_EX(** `wNotifyCode` **,** `memberFxn` **)**"},{"pos":[9951,9988],"content":"<bpt id=\"p1\">**</bpt>afx_msg BOOL<ept id=\"p1\">**</ept> <ph id=\"ph1\">`memberFxn`</ph> <bpt id=\"p2\">**</bpt>( );<ept id=\"p2\">**</ept>","source":"**afx_msg BOOL** `memberFxn` **( );**"},{"content":"Handling Reflected Messages: An Example of a Reusable control","pos":[9998,10059]},{"content":"This simple example creates a reusable control called <ph id=\"ph1\">`CYellowEdit`</ph>.","pos":[10063,10131],"source":"This simple example creates a reusable control called `CYellowEdit`."},{"content":"The control works the same as a regular edit control except that it displays black text on a yellow background.","pos":[10132,10243]},{"content":"It would be easy to add member functions that would allow the <ph id=\"ph1\">`CYellowEdit`</ph> control to display different colors.","pos":[10244,10356],"source":" It would be easy to add member functions that would allow the `CYellowEdit` control to display different colors."},{"content":"To try the example that creates a reusable control","pos":[10367,10417]},{"content":"Create a new dialog box in an existing application.","pos":[10427,10478]},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>dialog editor<ept id=\"p1\">](../mfc/dialog-editor.md)</ept> topic.","pos":[10479,10556],"source":" For more information, see the [dialog editor](../mfc/dialog-editor.md) topic."},{"content":"You must have an application in which to develop the reusable control.","pos":[10567,10637]},{"content":"If you don't have an existing application to use, create a dialog-based application using AppWizard.","pos":[10638,10738]},{"pos":[10748,10866],"content":"With your project loaded into Visual C++, use ClassWizard to create a new class called <ph id=\"ph1\">`CYellowEdit`</ph> based on <ph id=\"ph2\">`CEdit`</ph>.","source":"With your project loaded into Visual C++, use ClassWizard to create a new class called `CYellowEdit` based on `CEdit`."},{"content":"Add three member variables to your <ph id=\"ph1\">`CYellowEdit`</ph> class.","pos":[10876,10931],"source":"Add three member variables to your `CYellowEdit` class."},{"content":"The first two will be <bpt id=\"p1\">**</bpt>COLORREF<ept id=\"p1\">**</ept> variables to hold the text color and the background color.","pos":[10932,11025],"source":" The first two will be **COLORREF** variables to hold the text color and the background color."},{"content":"The third will be a <ph id=\"ph1\">`CBrush`</ph> object that will hold the brush for painting the background.","pos":[11026,11115],"source":" The third will be a `CBrush` object that will hold the brush for painting the background."},{"content":"The <ph id=\"ph1\">`CBrush`</ph> object allows you to create the brush once, merely referencing it after that, and to destroy the brush automatically when the <ph id=\"ph2\">`CYellowEdit`</ph> control is destroyed.","pos":[11116,11290],"source":" The `CBrush` object allows you to create the brush once, merely referencing it after that, and to destroy the brush automatically when the `CYellowEdit` control is destroyed."},{"content":"Initialize the member variables by writing the constructor as follows:","pos":[11300,11370]},{"content":"Using ClassWizard, add a handler for the reflected <ph id=\"ph1\">`WM_CTLCOLOR`</ph> message to your <ph id=\"ph2\">`CYellowEdit`</ph> class.","pos":[11567,11668],"source":"Using ClassWizard, add a handler for the reflected `WM_CTLCOLOR` message to your `CYellowEdit` class."},{"content":"Note that the equal sign in front of the message name in the list of messages you can handle indicates that the message is reflected.","pos":[11669,11802]},{"content":"This is described in <bpt id=\"p1\">[</bpt>Defining a Message Handler for a Reflected Message<ept id=\"p1\">](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md)</ept>.","pos":[11803,11949],"source":" This is described in [Defining a Message Handler for a Reflected Message](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md)."},{"content":"ClassWizard adds the following message-map macro and skeleton function for you:","pos":[11960,12039]},{"content":"Replace the body of the function with the following code.","pos":[12371,12428]},{"content":"The code specifies the text color, the text background color, and the background color for rest of the control.","pos":[12429,12540]},{"content":"Create an edit control in your dialog box, then attach it to a member variable by double-clicking the edit control while holding a control key down.","pos":[12710,12858]},{"content":"In the Add Member Variable dialog box, finish the variable name and choose \"Control\" for the category, then \"CYellowEdit\" for the variable type.","pos":[12859,13003]},{"content":"Don't forget to set the tab order in the dialog box.","pos":[13004,13056]},{"content":"Also, be sure to include the header file for the <ph id=\"ph1\">`CYellowEdit`</ph> control in your dialog box's header file.","pos":[13057,13161],"source":" Also, be sure to include the header file for the `CYellowEdit` control in your dialog box's header file."},{"content":"Build and run your application.","pos":[13171,13202]},{"content":"The edit control will have a yellow background.","pos":[13203,13250]},{"content":"See Also","pos":[13259,13267]},{"content":"Technical Notes by Number","pos":[13272,13297]},{"content":"Technical Notes by Category","pos":[13341,13368]}],"content":"---\ntitle: \"TN062: Message Reflection for Windows Controls | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.controls.messages\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"ON_WM_VKEYTOITEM_REFLECT macro\"\n  - \"ON_WM_DRAWITEM_REFLECT macro\"\n  - \"ON_WM_VSCROLL_REFLECT macro\"\n  - \"ON_NOTIFY_REFLECT message\"\n  - \"ON_CONTROL_REFLECT_EX macro\"\n  - \"ON_UPDATE_COMMAND_UI_REFLECT macro\"\n  - \"ON_NOTIFY_REFLECT_EX message\"\n  - \"ON_WM_HSCROLL_REFLECT macro\"\n  - \"message reflection\"\n  - \"ON_WM_COMPAREITEM_REFLECT macro\"\n  - \"ON_WM_MEASUREITEM_REFLECT macro\"\n  - \"ON_NOTIFY message\"\n  - \"WM_COMMAND\"\n  - \"WM_CTLCOLOR message\"\n  - \"TN062\"\n  - \"ON_WM_CHARTOITEM_REFLECT macro\"\n  - \"ON_WM_CTLCOLOR_REFLECT macro\"\n  - \"ON_WM_DELETEITEM_REFLECT macro\"\n  - \"notification messages\"\n  - \"ON_WM_PARENTNOTIFY_REFLECT macro\"\n  - \"WM_NOTIFY message\"\n  - \"ON_CONTROL_REFLECT macro\"\nms.assetid: 53efb0ba-fcda-4fa0-a3c7-14e0b78fb494\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN062: Message Reflection for Windows Controls\n> [!NOTE]\n>  The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.  \n  \n This technical note describes message reflection, a new feature in MFC 4.0. It also contains directions for creating a simple reusable control that uses message reflection.  \n  \n This technical note does not discuss message reflection as it applies to ActiveX controls (formerly called OLE controls). Please see the article [ActiveX Controls: Subclassing a Windows Control](../mfc/mfc-activex-controls-subclassing-a-windows-control.md).  \n  \n **What Is Message Reflection**  \n  \n Windows controls frequently send notification messages to their parent windows. For instance, many controls send a control color notification message (`WM_CTLCOLOR` or one of its variants) to their parent to allow the parent to supply a brush for painting the background of the control.  \n  \n In Windows and in MFC before version 4.0, the parent window, often a dialog box, is responsible for handling these messages. This means that the code for handling the message needs to be in the parent window's class and that it has to be duplicated in every class that needs to handle that message. In the case above, every dialog box that wanted controls with custom backgrounds would have to handle the control color notification message. It would be much easier to reuse code if a control class could be written that would handle its own background color.  \n  \n In MFC 4.0, the old mechanism still works — parent windows can handle notification messages. In addition, however, MFC 4.0 facilitates reuse by providing a feature called \"message reflection\" that allows these notification messages to be handled in either the child control window or the parent window, or in both. In the control background color example, you can now write a control class that sets its own background color by handling the reflected `WM_CTLCOLOR` message — all without relying on the parent. (Note that since message reflection is implemented by MFC, not by Windows, the parent window class must be derived from `CWnd` for message reflection to work.)  \n  \n Older versions of MFC did something similar to message reflection by providing virtual functions for a few messages, such as messages for owner-drawn list boxes (`WM_DRAWITEM`, and so on). The new message reflection mechanism is generalized and consistent.  \n  \n Message reflection is backward compatible with code written for versions of MFC before 4.0.  \n  \n If you have supplied a handler for a specific message, or for a range of messages, in your parent window's class, it will override reflected message handlers for the same message provided you don't call the base class handler function in your own handler. For example, if you handle `WM_CTLCOLOR` in your dialog box class, your handling will override any reflected message handlers.  \n  \n If, in your parent window class, you supply a handler for a specific **WM_NOTIFY** message or a range of **WM_NOTIFY** messages, your handler will be called only if the child control sending those messages does not have a reflected message handler through **ON_NOTIFY_REFLECT()**. If you use **ON_NOTIFY_REFLECT_EX()** in your message map, your message handler may or may not allow the parent window to handle the message. If the handler returns **FALSE**, the message will be handled by the parent as well, while a call that returns **TRUE** does not allow the parent to handle it. Note that the reflected message is handled before the notification message.  \n  \n When a **WM_NOTIFY** message is sent, the control is offered the first chance to handle it. If any other reflected message is sent, the parent window has the first chance to handle it and the control will receive the reflected message. To do so, it will need a handler function and an appropriate entry in the control's class message map.  \n  \n The message-map macro for reflected messages is slightly different than for regular notifications: it has **_REFLECT** appended to its usual name. For instance, to handle a **WM_NOTIFY** message in the parent, you use the macro `ON_NOTIFY` in the parent's message map. To handle the reflected message in the child control, use the **ON_NOTIFY_REFLECT** macro in the child control's message map. In some cases, the parameters are different, as well. Note that ClassWizard can usually add the message-map entries for you and provide skeleton function implementations with correct parameters.  \n  \n See [TN061: ON_NOTIFY and WM_NOTIFY Messages](../mfc/tn061-on-notify-and-wm-notify-messages.md) for information on the new **WM_NOTIFY** message.  \n  \n **Message-Map Entries and Handler Function Prototypes for Reflected Messages**  \n  \n To handle a reflected control notification message, use the message-map macros and function prototypes listed in the table below.  \n  \n ClassWizard can usually add these message-map entries for you and provide skeleton function implementations. See [Defining a Message Handler for a Reflected Message](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md) for information about how to define handlers for reflected messages.  \n  \n To convert from the message name to the reflected macro name, prepend **ON_** and append **_REFLECT**. For example, `WM_CTLCOLOR` becomes **ON_WM_CTLCOLOR_REFLECT**. (To see which messages can be reflected, do the opposite conversion on the macro entries in the table below.)  \n  \n The three exceptions to the rule above are as follows:  \n  \n-   The macro for **WM_COMMAND** notifications is **ON_CONTROL_REFLECT**.  \n  \n-   The macro for **WM_NOTIFY** reflections is **ON_NOTIFY_REFLECT**.  \n  \n-   The macro for `ON_UPDATE_COMMAND_UI` reflections is **ON_UPDATE_COMMAND_UI_REFLECT**.  \n  \n In each of the above special cases, you must specify the name of the handler member function. In the other cases, you must use the standard name for your handler function.  \n  \n The meanings of the parameters and return values of the functions are documented under either the function name or the function name with **On** prepended. For instance, **CtlColor** is documented in `OnCtlColor`. Several reflected message handlers need fewer parameters than the similar handlers in a parent window. Just match the names in the table below with the names of the formal parameters in the documentation.  \n  \n|Map entry|Function prototype|  \n|---------------|------------------------|  \n|**ON_CONTROL_REFLECT(** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg void** `memberFxn` **( );**|  \n|**ON_NOTIFY_REFLECT(** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg void** `memberFxn` **( NMHDR \\*** `pNotifyStruct` **, LRESULT\\*** *result* **);**|  \n|**ON_UPDATE_COMMAND_UI_REFLECT(** `memberFxn` **)**|**afx_msg void** `memberFxn` **( CCmdUI\\*** `pCmdUI` **);**|  \n|**ON_WM_CTLCOLOR_REFLECT( )**|**afx_msg HBRUSH CtlColor ( CDC\\*** `pDC` **, UINT** `nCtlColor` **);**|  \n|**ON_WM_DRAWITEM_REFLECT( )**|**afx_msg void DrawItem ( LPDRAWITEMSTRUCT** `lpDrawItemStruct` **);**|  \n|**ON_WM_MEASUREITEM_REFLECT( )**|**afx_msg void MeasureItem ( LPMEASUREITEMSTRUCT** `lpMeasureItemStruct` **);**|  \n|**ON_WM_DELETEITEM_REFLECT( )**|**afx_msg void DeleteItem ( LPDELETEITEMSTRUCT** `lpDeleteItemStruct` **);**|  \n|**ON_WM_COMPAREITEM_REFLECT( )**|**afx_msg int CompareItem ( LPCOMPAREITEMSTRUCT** `lpCompareItemStruct` **);**|  \n|**ON_WM_CHARTOITEM_REFLECT( )**|**afx_msg int CharToItem ( UINT** `nKey` **, UINT** `nIndex` **);**|  \n|**ON_WM_VKEYTOITEM_REFLECT( )**|**afx_msg int VKeyToItem ( UINT** `nKey` **, UINT** `nIndex` **);**|  \n|**ON_WM_HSCROLL_REFLECT( )**|**afx_msg void HScroll ( UINT** `nSBCode` **, UINT** `nPos` **);**|  \n|**ON_WM_VSCROLL_REFLECT( )**|**afx_msg void VScroll ( UINT** `nSBCode` **, UINT** `nPos` **);**|  \n|**ON_WM_PARENTNOTIFY_REFLECT( )**|**afx_msg void ParentNotify ( UINT** `message` **, LPARAM** `lParam` **);**|  \n  \n The **ON_NOTIFY_REFLECT** and **ON_CONTROL_REFLECT** macros have variations that allow more than one object (such as the control and its parent) to handle a given message.  \n  \n|Map entry|Function prototype|  \n|---------------|------------------------|  \n|**ON_NOTIFY_REFLECT_EX(** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg BOOL** `memberFxn` **( NMHDR \\*** `pNotifyStruct` **, LRESULT\\*** *result* **);**|  \n|**ON_CONTROL_REFLECT_EX(** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg BOOL** `memberFxn` **( );**|  \n  \n## Handling Reflected Messages: An Example of a Reusable control  \n This simple example creates a reusable control called `CYellowEdit`. The control works the same as a regular edit control except that it displays black text on a yellow background. It would be easy to add member functions that would allow the `CYellowEdit` control to display different colors.  \n  \n#### To try the example that creates a reusable control  \n  \n1.  Create a new dialog box in an existing application. For more information, see the [dialog editor](../mfc/dialog-editor.md) topic.  \n  \n     You must have an application in which to develop the reusable control. If you don't have an existing application to use, create a dialog-based application using AppWizard.  \n  \n2.  With your project loaded into Visual C++, use ClassWizard to create a new class called `CYellowEdit` based on `CEdit`.  \n  \n3.  Add three member variables to your `CYellowEdit` class. The first two will be **COLORREF** variables to hold the text color and the background color. The third will be a `CBrush` object that will hold the brush for painting the background. The `CBrush` object allows you to create the brush once, merely referencing it after that, and to destroy the brush automatically when the `CYellowEdit` control is destroyed.  \n  \n4.  Initialize the member variables by writing the constructor as follows:  \n  \n ```  \n    CYellowEdit::CYellowEdit() \n {  \n    m_clrText = RGB(0,\n    0,\n    0);\n\n    m_clrBkgnd = RGB(255,\n    255,\n    0);\n\n    m_brBkgnd.CreateSolidBrush(m_clrBkgnd);\n\n }  \n ```  \n  \n5.  Using ClassWizard, add a handler for the reflected `WM_CTLCOLOR` message to your `CYellowEdit` class. Note that the equal sign in front of the message name in the list of messages you can handle indicates that the message is reflected. This is described in [Defining a Message Handler for a Reflected Message](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md).  \n  \n     ClassWizard adds the following message-map macro and skeleton function for you:  \n  \n ```  \n    ON_WM_CTLCOLOR_REFLECT() \n *// Note: other code will be in between....  \n \n    HBRUSH CYellowEdit::CtlColor(CDC* pDC, UINT nCtlColor)   \n { *// TODO: Change any attributes of the DC here  \n *// TODO: Return a non-NULL brush if the *//   parent's handler should not be called  \n    return NULL;  \n }  \n ```  \n  \n6.  Replace the body of the function with the following code. The code specifies the text color, the text background color, and the background color for rest of the control.  \n  \n ```  \n    pDC->SetTextColor(m_clrText);\n*// text  \n    pDC->SetBkColor(m_clrBkgnd);\n*// text bkgnd  \n    return m_brBkgnd;            // ctl bkgnd  \n ```  \n  \n7.  Create an edit control in your dialog box, then attach it to a member variable by double-clicking the edit control while holding a control key down. In the Add Member Variable dialog box, finish the variable name and choose \"Control\" for the category, then \"CYellowEdit\" for the variable type. Don't forget to set the tab order in the dialog box. Also, be sure to include the header file for the `CYellowEdit` control in your dialog box's header file.  \n  \n8.  Build and run your application. The edit control will have a yellow background.  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}