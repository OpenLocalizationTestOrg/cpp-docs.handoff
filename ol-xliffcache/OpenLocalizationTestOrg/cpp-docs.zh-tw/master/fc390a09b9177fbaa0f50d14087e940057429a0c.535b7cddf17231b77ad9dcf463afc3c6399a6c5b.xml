{"nodes":[{"pos":[12,67],"content":"Writing Functions with Inline Assembly | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Writing Functions with Inline Assembly | Microsoft Docs","pos":[0,55]}]},{"content":"Writing Functions with Inline Assembly","pos":[736,774]},{"content":"Microsoft Specific","pos":[778,796]},{"content":"If you write a function with inline assembly code, it's easy to pass arguments to the function and return a value from it.","pos":[800,922]},{"content":"The following examples compare a function first written for a separate assembler and then rewritten for the inline assembler.","pos":[923,1048]},{"content":"The function, called <ph id=\"ph1\">`power2`</ph>, receives two parameters, multiplying the first parameter by 2 to the power of the second parameter.","pos":[1049,1179],"source":" The function, called `power2`, receives two parameters, multiplying the first parameter by 2 to the power of the second parameter."},{"content":"Written for a separate assembler, the function might look like this:","pos":[1180,1248]},{"content":"Since it's written for a separate assembler, the function requires a separate source file and assembly and link steps.","pos":[1842,1960]},{"content":"C and C++ function arguments are usually passed on the stack, so this version of the <ph id=\"ph1\">`power2`</ph> function accesses its arguments by their positions on the stack.","pos":[1961,2119],"source":" C and C++ function arguments are usually passed on the stack, so this version of the `power2` function accesses its arguments by their positions on the stack."},{"content":"(Note that the <bpt id=\"p1\">**</bpt>MODEL<ept id=\"p1\">**</ept> directive, available in MASM and some other assemblers, also allows you to access stack arguments and local stack variables by name.)","pos":[2120,2278],"source":" (Note that the **MODEL** directive, available in MASM and some other assemblers, also allows you to access stack arguments and local stack variables by name.)"},{"content":"Example","pos":[2287,2294]},{"pos":[2298,2366],"content":"This program writes the <ph id=\"ph1\">`power2`</ph> function with inline assembly code:","source":"This program writes the `power2` function with inline assembly code:"},{"content":"The inline version of the <ph id=\"ph1\">`power2`</ph> function refers to its arguments by name and appears in the same source file as the rest of the program.","pos":[2897,3036],"source":"The inline version of the `power2` function refers to its arguments by name and appears in the same source file as the rest of the program."},{"content":"This version also requires fewer assembly instructions.","pos":[3037,3092]},{"content":"Because the inline version of <ph id=\"ph1\">`power2`</ph> doesn't execute a C <ph id=\"ph2\">`return`</ph> statement, it causes a harmless warning if you compile at warning level 2 or higher.","pos":[3099,3251],"source":"Because the inline version of `power2` doesn't execute a C `return` statement, it causes a harmless warning if you compile at warning level 2 or higher."},{"content":"The function does return a value, but the compiler cannot tell that in the absence of a <ph id=\"ph1\">`return`</ph> statement.","pos":[3252,3359],"source":" The function does return a value, but the compiler cannot tell that in the absence of a `return` statement."},{"content":"You can use <bpt id=\"p1\">[</bpt>#pragma warning<ept id=\"p1\">](../../preprocessor/warning.md)</ept> to disable the generation of this warning.","pos":[3360,3463],"source":" You can use [#pragma warning](../../preprocessor/warning.md) to disable the generation of this warning."},{"content":"END Microsoft Specific","pos":[3472,3494]},{"content":"See Also","pos":[3505,3513]},{"content":"Using C or C++ in __asm Blocks","pos":[3518,3548]}],"content":"---\ntitle: \"Writing Functions with Inline Assembly | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"functions [C++], inline assembly\"\n  - \"inline assembly [C++], writing functions\"\n  - \"assembler [C++], writing functions\"\n  - \"__asm keyword [C++], in functions\"\nms.assetid: b5df8a04-fdc7-4622-8c9e-e4b618927497\ncaps.latest.revision: 9\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Writing Functions with Inline Assembly\n## Microsoft Specific  \n If you write a function with inline assembly code, it's easy to pass arguments to the function and return a value from it. The following examples compare a function first written for a separate assembler and then rewritten for the inline assembler. The function, called `power2`, receives two parameters, multiplying the first parameter by 2 to the power of the second parameter. Written for a separate assembler, the function might look like this:  \n  \n```  \n; POWER.ASM  \n; Compute the power of an integer  \n;  \n       PUBLIC _power2  \n_TEXT SEGMENT WORD PUBLIC 'CODE'  \n_power2 PROC  \n  \n        push ebp        ; Save EBP  \n        mov ebp, esp    ; Move ESP into EBP so we can refer  \n                        ;   to arguments on the stack  \n        mov eax, [ebp+4] ; Get first argument  \n        mov ecx, [ebp+6] ; Get second argument  \n        shl eax, cl     ; EAX = EAX * ( 2 ^ CL )  \n        pop ebp         ; Restore EBP  \n        ret             ; Return with sum in EAX  \n  \n_power2 ENDP  \n_TEXT   ENDS  \n        END  \n```  \n  \n Since it's written for a separate assembler, the function requires a separate source file and assembly and link steps. C and C++ function arguments are usually passed on the stack, so this version of the `power2` function accesses its arguments by their positions on the stack. (Note that the **MODEL** directive, available in MASM and some other assemblers, also allows you to access stack arguments and local stack variables by name.)  \n  \n## Example  \n This program writes the `power2` function with inline assembly code:  \n  \n```  \n// Power2_inline_asm.c  \n// compile with: /EHsc  \n// processor: x86  \n  \n#include <stdio.h>  \n  \nint power2( int num, int power );  \n  \nint main( void )  \n{  \n    printf_s( \"3 times 2 to the power of 5 is %d\\n\", \\  \n              power2( 3, 5) );  \n}  \nint power2( int num, int power )  \n{  \n   __asm  \n   {  \n      mov eax, num    ; Get first argument  \n      mov ecx, power  ; Get second argument  \n      shl eax, cl     ; EAX = EAX * ( 2 to the power of CL )  \n   }  \n   // Return with result in EAX  \n}  \n```  \n  \n The inline version of the `power2` function refers to its arguments by name and appears in the same source file as the rest of the program. This version also requires fewer assembly instructions.  \n  \n Because the inline version of `power2` doesn't execute a C `return` statement, it causes a harmless warning if you compile at warning level 2 or higher. The function does return a value, but the compiler cannot tell that in the absence of a `return` statement. You can use [#pragma warning](../../preprocessor/warning.md) to disable the generation of this warning.  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [Using C or C++ in __asm Blocks](../../assembler/inline/using-c-or-cpp-in-asm-blocks.md)"}