{"nodes":[{"pos":[12,59],"content":"_InterlockedCompareExchange128 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_InterlockedCompareExchange128 | Microsoft Docs","pos":[0,47]}]},{"content":"_InterlockedCompareExchange128","pos":[756,786]},{"content":"Microsoft Specific","pos":[789,807]},{"content":"Performs a 128-bit interlocked compare and exchange.","pos":[816,868]},{"content":"Syntax","pos":[877,883]},{"content":"Parameters","pos":[1083,1093]},{"content":"[in, out]","pos":[1097,1106]},{"content":"Pointer to the destination, which is an array of two 64-bit integers considered as a 128-bit field.","pos":[1124,1223]},{"content":"The destination data must be 16-byte aligned to avoid a general protection fault.","pos":[1224,1305]},{"content":"[in]","pos":[1312,1316]},{"content":"A 64-bit integer that may be exchanged with the high part of the destination.","pos":[1335,1412]},{"content":"[in]","pos":[1419,1423]},{"content":"A 64-bit integer that may be exchanged with the low part of the destination.","pos":[1441,1517]},{"content":"[in, out]","pos":[1524,1533]},{"content":"Pointer to an array of two 64-bit integers (considered as a 128-bit field) to compare with the destination.","pos":[1555,1662]},{"content":"On output, this is overwritten with the original value of the destination.","pos":[1664,1738]},{"content":"Return Value","pos":[1747,1759]},{"content":"1 if the 128-bit comparand equals the original value of the destination.","pos":[1763,1835]},{"content":"and <ph id=\"ph1\">`ExchangeLow`</ph> overwrite the 128-bit destination.","pos":[1851,1903],"source":" and `ExchangeLow` overwrite the 128-bit destination."},{"content":"0 if the comparand does not equal the original value of the destination.","pos":[1910,1982]},{"content":"The value of the destination is unchanged and the value of the comparand is overwritten with the value of the destination.","pos":[1983,2105]},{"content":"Requirements","pos":[2114,2126]},{"content":"Intrinsic","pos":[2133,2142]},{"content":"Architecture","pos":[2143,2155]},{"pos":[2303,2330],"content":"<bpt id=\"p1\">**</bpt>Header file<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>intrin.h&gt;","source":"**Header file** \\<intrin.h>"},{"content":"Remarks","pos":[2339,2346]},{"content":"This intrinsic generates the <ph id=\"ph1\">`cmpxchg16b`</ph> instruction (with the <ph id=\"ph2\">`lock`</ph> prefix) to perform a 128-bit locked compare and exchange.","pos":[2350,2478],"source":"This intrinsic generates the `cmpxchg16b` instruction (with the `lock` prefix) to perform a 128-bit locked compare and exchange."},{"content":"Early versions of AMD 64-bit hardware do not support this instruction.","pos":[2479,2549]},{"content":"To check for hardware support for the <ph id=\"ph1\">`cmpxchg16b`</ph> instruction, call the <ph id=\"ph2\">`__cpuid`</ph> intrinsic with <ph id=\"ph3\">`InfoType=0x00000001 (standard function 1)`</ph>.","pos":[2550,2692],"source":" To check for hardware support for the `cmpxchg16b` instruction, call the `__cpuid` intrinsic with `InfoType=0x00000001 (standard function 1)`."},{"content":"Bit 13 of <ph id=\"ph1\">`CPUInfo[2]`</ph> (ECX) is 1 if the instruction is supported.","pos":[2693,2759],"source":" Bit 13 of `CPUInfo[2]` (ECX) is 1 if the instruction is supported."},{"pos":[2767,3077],"content":"[!NOTE]\n The value of `ComparandResult` is always overwritten. After the `lock` instruction, this intrinsic immediately copies the initial value of `Destination` to `ComparandResult`. For this reason, `ComparandResult` and `Destination` should point to separate memory locations to avoid unexpected behavior.","leadings":["","> "],"nodes":[{"content":" The value of `ComparandResult` is always overwritten. After the `lock` instruction, this intrinsic immediately copies the initial value of `Destination` to `ComparandResult`. For this reason, `ComparandResult` and `Destination` should point to separate memory locations to avoid unexpected behavior.","pos":[8,308],"nodes":[{"content":"The value of <ph id=\"ph1\">`ComparandResult`</ph> is always overwritten.","pos":[1,54],"source":" The value of `ComparandResult` is always overwritten."},{"content":"After the <ph id=\"ph1\">`lock`</ph> instruction, this intrinsic immediately copies the initial value of <ph id=\"ph2\">`Destination`</ph> to <ph id=\"ph3\">`ComparandResult`</ph>.","pos":[55,175],"source":" After the `lock` instruction, this intrinsic immediately copies the initial value of `Destination` to `ComparandResult`."},{"content":"For this reason, <ph id=\"ph1\">`ComparandResult`</ph> and <ph id=\"ph2\">`Destination`</ph> should point to separate memory locations to avoid unexpected behavior.","pos":[176,300],"source":" For this reason, `ComparandResult` and `Destination` should point to separate memory locations to avoid unexpected behavior."}]}]},{"content":"Although you can use <ph id=\"ph1\">`_InterlockedCompareExchange128`</ph> for low-level thread synchronization, you do not need to synchronize over 128 bits if you can use smaller synchronization functions (such as the other <ph id=\"ph2\">`_InterlockedCompareExchange`</ph> intrinsics) instead.","pos":[3084,3339],"source":"Although you can use `_InterlockedCompareExchange128` for low-level thread synchronization, you do not need to synchronize over 128 bits if you can use smaller synchronization functions (such as the other `_InterlockedCompareExchange` intrinsics) instead."},{"content":"Use <ph id=\"ph1\">`_InterlockedCompareExchange128`</ph> if you want atomic access to a 128-bit value in memory.","pos":[3340,3432],"source":" Use `_InterlockedCompareExchange128` if you want atomic access to a 128-bit value in memory."},{"pos":[3439,3574],"content":"If you run code that uses this intrinsic on hardware that does not support the <ph id=\"ph1\">`cmpxchg16b`</ph> instruction, the results are unpredictable.","source":"If you run code that uses this intrinsic on hardware that does not support the `cmpxchg16b` instruction, the results are unpredictable."},{"content":"This routine is available only as an intrinsic.","pos":[3581,3628]},{"content":"Example","pos":[3637,3644]},{"content":"This example uses <ph id=\"ph1\">`_InterlockedCompareExchange128`</ph> to replace the high word of an array of two 64-bit integers with the sum of its high and low words and to increment the low word.","pos":[3648,3828],"source":"This example uses `_InterlockedCompareExchange128` to replace the high word of an array of two 64-bit integers with the sum of its high and low words and to increment the low word."},{"content":"The access to the BigInt.Int array is atomic, but this example uses a single thread and ignores the locking for simplicity.","pos":[3829,3952]},{"content":"END Microsoft Specific","pos":[5200,5222]},{"content":"Copyright 2007 by Advanced Micro Devices, Inc. All rights reserved.","pos":[5226,5293]},{"content":"Reproduced with permission from Advanced Micro Devices, Inc.","pos":[5294,5354]},{"content":"See Also","pos":[5363,5371]},{"content":"Compiler Intrinsics","pos":[5376,5395]},{"content":"_InterlockedCompareExchange Intrinsic Functions","pos":[5440,5487]},{"content":"Conflicts with the x86 Compiler","pos":[5559,5590]}],"content":"---\ntitle: \"_InterlockedCompareExchange128 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_InterlockedCompareExchange128_cpp\"\n  - \"_InterlockedCompareExchange128\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"cmpxchg16b instruction\"\n  - \"_InterlockedCompareExchange128 intrinsic\"\nms.assetid: f05918fc-716a-4f6d-b746-1456d6b96c56\ncaps.latest.revision: 17\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# _InterlockedCompareExchange128\n**Microsoft Specific**  \n  \n Performs a 128-bit interlocked compare and exchange.  \n  \n## Syntax  \n  \n```  \nunsigned char _InterlockedCompareExchange128(  \n   __int64 volatile * Destination,  \n   __int64 ExchangeHigh,  \n   __int64 ExchangeLow,  \n   __int64 * ComparandResult  \n);  \n```  \n  \n#### Parameters  \n [in, out] `Destination`  \n Pointer to the destination, which is an array of two 64-bit integers considered as a 128-bit field. The destination data must be 16-byte aligned to avoid a general protection fault.  \n  \n [in] `ExchangeHigh`  \n A 64-bit integer that may be exchanged with the high part of the destination.  \n  \n [in] `ExchangeLow`  \n A 64-bit integer that may be exchanged with the low part of the destination.  \n  \n [in, out] `ComparandResult`  \n Pointer to an array of two 64-bit integers (considered as a 128-bit field) to compare with the destination.  On output, this is overwritten with the original value of the destination.  \n  \n## Return Value  \n 1 if the 128-bit comparand equals the original value of the destination. `ExchangeHigh` and `ExchangeLow` overwrite the 128-bit destination.  \n  \n 0 if the comparand does not equal the original value of the destination. The value of the destination is unchanged and the value of the comparand is overwritten with the value of the destination.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|  \n|---------------|------------------|  \n|`_InterlockedCompareExchange128`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|  \n  \n **Header file** \\<intrin.h>  \n  \n## Remarks  \n This intrinsic generates the `cmpxchg16b` instruction (with the `lock` prefix) to perform a 128-bit locked compare and exchange. Early versions of AMD 64-bit hardware do not support this instruction. To check for hardware support for the `cmpxchg16b` instruction, call the `__cpuid` intrinsic with `InfoType=0x00000001 (standard function 1)`. Bit 13 of `CPUInfo[2]` (ECX) is 1 if the instruction is supported.  \n  \n> [!NOTE]\n>  The value of `ComparandResult` is always overwritten. After the `lock` instruction, this intrinsic immediately copies the initial value of `Destination` to `ComparandResult`. For this reason, `ComparandResult` and `Destination` should point to separate memory locations to avoid unexpected behavior.  \n  \n Although you can use `_InterlockedCompareExchange128` for low-level thread synchronization, you do not need to synchronize over 128 bits if you can use smaller synchronization functions (such as the other `_InterlockedCompareExchange` intrinsics) instead. Use `_InterlockedCompareExchange128` if you want atomic access to a 128-bit value in memory.  \n  \n If you run code that uses this intrinsic on hardware that does not support the `cmpxchg16b` instruction, the results are unpredictable.  \n  \n This routine is available only as an intrinsic.  \n  \n## Example  \n This example uses `_InterlockedCompareExchange128` to replace the high word of an array of two 64-bit integers with the sum of its high and low words and to increment the low word. The access to the BigInt.Int array is atomic, but this example uses a single thread and ignores the locking for simplicity.  \n  \n```  \n// cmpxchg16b.c  \n// processor: x64  \n// compile with: /EHsc /O2  \n#include <stdio.h>  \n#include <intrin.h>  \n  \ntypedef struct _LARGE_INTEGER_128 {  \n    __int64 Int[2];  \n} LARGE_INTEGER_128, *PLARGE_INTEGER_128;  \n  \nvolatile LARGE_INTEGER_128 BigInt;  \n  \n// This AtomicOp() function atomically performs:  \n//   BigInt.Int[1] += BigInt.Int[0]  \n//   BigInt.Int[0] += 1  \nvoid AtomicOp ()  \n{  \n    LARGE_INTEGER_128 Comparand;  \n    Comparand.Int[0] = BigInt.Int[0];  \n    Comparand.Int[1] = BigInt.Int[1];  \n    do {  \n        ; // nothing  \n    } while (_InterlockedCompareExchange128(BigInt.Int,  \n                                            Comparand.Int[0] + Comparand.Int[1],  \n                                            Comparand.Int[0] + 1,  \n                                            Comparand.Int) == 0);  \n}  \n  \n// In a real application, several threads contend for the value  \n// of BigInt.  \n// Here we focus on the compare and exchange for simplicity.  \nint main(void)  \n{  \n   BigInt.Int[1] = 23;  \n   BigInt.Int[0] = 11;  \n   AtomicOp();  \n   printf(\"BigInt.Int[1] = %d, BigInt.Int[0] = %d\\n\",  \n      BigInt.Int[1],BigInt.Int[0]);  \n}  \n```  \n  \n```Output  \nBigInt.Int[1] = 34, BigInt.Int[0] = 12  \n```  \n  \n## END Microsoft Specific  \n Copyright 2007 by Advanced Micro Devices, Inc. All rights reserved. Reproduced with permission from Advanced Micro Devices, Inc.  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)   \n [_InterlockedCompareExchange Intrinsic Functions](../intrinsics/interlockedcompareexchange-intrinsic-functions.md)   \n [Conflicts with the x86 Compiler](../build/conflicts-with-the-x86-compiler.md)"}