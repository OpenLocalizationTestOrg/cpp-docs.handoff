{"nodes":[{"pos":[12,68],"content":"How to: Declare Handles in Native Types | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Declare Handles in Native Types | Microsoft Docs","pos":[0,56]}]},{"content":"How to: Declare Handles in Native Types","pos":[702,741]},{"content":"You cannot declare a handle type in a native type.","pos":[742,792]},{"content":"vcclr.h provides the type-safe wrapper template <ph id=\"ph1\">`gcroot`</ph> to refer to a CLR object from the C++ heap.","pos":[793,893],"source":" vcclr.h provides the type-safe wrapper template `gcroot` to refer to a CLR object from the C++ heap."},{"content":"This template lets you embed a virtual handle in a native type and treat it as if it were the underlying type.","pos":[894,1004]},{"content":"In most cases, you can use the <ph id=\"ph1\">`gcroot`</ph> object as the embedded type without any casting.","pos":[1005,1093],"source":" In most cases, you can use the `gcroot` object as the embedded type without any casting."},{"content":"However, with <bpt id=\"p1\">[</bpt>for each, in<ept id=\"p1\">](../dotnet/for-each-in.md)</ept>, you have to use <ph id=\"ph1\">`static_cast`</ph> to retrieve the underlying managed reference.","pos":[1094,1225],"source":" However, with [for each, in](../dotnet/for-each-in.md), you have to use `static_cast` to retrieve the underlying managed reference."},{"content":"The <ph id=\"ph1\">`gcroot`</ph> template is implemented using the facilities of the value class System::Runtime::InteropServices::GCHandle, which provides \"handles\" into the garbage-collected heap.","pos":[1232,1410],"source":"The `gcroot` template is implemented using the facilities of the value class System::Runtime::InteropServices::GCHandle, which provides \"handles\" into the garbage-collected heap."},{"content":"Note that the handles themselves are not garbage collected and are freed when no longer in use by the destructor in the <ph id=\"ph1\">`gcroot`</ph> class (this destructor cannot be called manually).","pos":[1411,1590],"source":" Note that the handles themselves are not garbage collected and are freed when no longer in use by the destructor in the `gcroot` class (this destructor cannot be called manually)."},{"content":"If you instantiate a <ph id=\"ph1\">`gcroot`</ph> object on the native heap, you must call delete on that resource.","pos":[1591,1686],"source":" If you instantiate a `gcroot` object on the native heap, you must call delete on that resource."},{"content":"The runtime will maintain an association between the handle and the CLR object, which it references.","pos":[1693,1793]},{"content":"When the CLR object moves with the garbage-collected heap, the handle will return the new address of the object.","pos":[1794,1906]},{"content":"A variable does not have to be pinned before it is assigned to a <ph id=\"ph1\">`gcroot`</ph> template.","pos":[1907,1990],"source":" A variable does not have to be pinned before it is assigned to a `gcroot` template."},{"content":"Example","pos":[1999,2006]},{"pos":[2010,2080],"content":"This sample shows how to create a <ph id=\"ph1\">`gcroot`</ph> object on the native stack.","source":"This sample shows how to create a `gcroot` object on the native stack."},{"content":"Example","pos":[2477,2484]},{"pos":[2488,2557],"content":"This sample shows how to create a <ph id=\"ph1\">`gcroot`</ph> object on the native heap.","source":"This sample shows how to create a `gcroot` object on the native heap."},{"content":"Example","pos":[2982,2989]},{"pos":[2993,3140],"content":"This sample shows how to use <ph id=\"ph1\">`gcroot`</ph> to hold references to value types (not reference types) in a native type by using <ph id=\"ph2\">`gcroot`</ph> on the boxed type.","source":"This sample shows how to use `gcroot` to hold references to value types (not reference types) in a native type by using `gcroot` on the boxed type."},{"content":"See Also","pos":[3599,3607]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[3612,3648]}],"content":"---\ntitle: \"How to: Declare Handles in Native Types | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\nf1_keywords: \n  - \"gcroot\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"handles, declaring\"\n  - \"gcroot keyword [C++]\"\n  - \"types [C++], declaring handles in\"\nms.assetid: b8c0eead-17e5-4003-b21f-b673f997d79f\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Declare Handles in Native Types\nYou cannot declare a handle type in a native type. vcclr.h provides the type-safe wrapper template `gcroot` to refer to a CLR object from the C++ heap. This template lets you embed a virtual handle in a native type and treat it as if it were the underlying type. In most cases, you can use the `gcroot` object as the embedded type without any casting. However, with [for each, in](../dotnet/for-each-in.md), you have to use `static_cast` to retrieve the underlying managed reference.  \n  \n The `gcroot` template is implemented using the facilities of the value class System::Runtime::InteropServices::GCHandle, which provides \"handles\" into the garbage-collected heap. Note that the handles themselves are not garbage collected and are freed when no longer in use by the destructor in the `gcroot` class (this destructor cannot be called manually). If you instantiate a `gcroot` object on the native heap, you must call delete on that resource.  \n  \n The runtime will maintain an association between the handle and the CLR object, which it references. When the CLR object moves with the garbage-collected heap, the handle will return the new address of the object. A variable does not have to be pinned before it is assigned to a `gcroot` template.  \n  \n## Example  \n This sample shows how to create a `gcroot` object on the native stack.  \n  \n```  \n// mcpp_gcroot.cpp  \n// compile with: /clr  \n#include <vcclr.h>  \nusing namespace System;  \n  \nclass CppClass {  \npublic:  \n   gcroot<String^> str;   // can use str as if it were String^  \n   CppClass() {}  \n};  \n  \nint main() {  \n   CppClass c;  \n   c.str = gcnew String(\"hello\");  \n   Console::WriteLine( c.str );   // no cast required  \n}  \n```  \n  \n```Output  \nhello  \n```  \n  \n## Example  \n This sample shows how to create a `gcroot` object on the native heap.  \n  \n```  \n// mcpp_gcroot_2.cpp  \n// compile with: /clr  \n// compile with: /clr  \n#include <vcclr.h>  \nusing namespace System;  \n  \nstruct CppClass {  \n   gcroot<String ^> * str;  \n   CppClass() : str(new gcroot<String ^>) {}  \n  \n   ~CppClass() { delete str; }  \n  \n};  \n  \nint main() {  \n   CppClass c;  \n   *c.str = gcnew String(\"hello\");  \n   Console::WriteLine( *c.str );  \n}  \n```  \n  \n```Output  \nhello  \n```  \n  \n## Example  \n This sample shows how to use `gcroot` to hold references to value types (not reference types) in a native type by using `gcroot` on the boxed type.  \n  \n```  \n// mcpp_gcroot_3.cpp  \n// compile with: /clr  \n#include < vcclr.h >  \nusing namespace System;  \n  \npublic value struct V {  \n   String^ str;  \n};  \n  \nclass Native {  \npublic:  \n   gcroot< V^ > v_handle;  \n};  \n  \nint main() {  \n   Native native;  \n   V v;  \n   native.v_handle = v;  \n   native.v_handle->str = \"Hello\";  \n   Console::WriteLine(\"String in V: {0}\", native.v_handle->str);  \n}  \n```  \n  \n```Output  \nString in V: Hello  \n```  \n  \n## See Also  \n [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)"}