{"nodes":[{"pos":[12,43],"content":"volatile (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"volatile (C++) | Microsoft Docs","pos":[0,31]}]},{"content":"volatile (C++)","pos":[733,747]},{"content":"A type qualifier that you can use to declare that an object can be modified in the program by the hardware.","pos":[748,855]},{"content":"Syntax","pos":[864,870]},{"content":"Remarks","pos":[921,928]},{"pos":[932,1091],"content":"You can use the <bpt id=\"p1\">[</bpt>/volatile<ept id=\"p1\">](../build/reference/volatile-volatile-keyword-interpretation.md)</ept> compiler switch to modify how the compiler interprets this keyword.","source":"You can use the [/volatile](../build/reference/volatile-volatile-keyword-interpretation.md) compiler switch to modify how the compiler interprets this keyword."},{"content":"Visual Studio interprets the <ph id=\"ph1\">`volatile`</ph> keyword differently depending on the target architecture.","pos":[1098,1195],"source":"Visual Studio interprets the `volatile` keyword differently depending on the target architecture."},{"content":"For ARM, if no <bpt id=\"p1\">**</bpt>/volatile<ept id=\"p1\">**</ept> compiler option is specified, the compiler performs as if <bpt id=\"p2\">**</bpt>/volatile:iso<ept id=\"p2\">**</ept> were specified.","pos":[1196,1316],"source":" For ARM, if no **/volatile** compiler option is specified, the compiler performs as if **/volatile:iso** were specified."},{"content":"For architectures other than ARM, if no <bpt id=\"p1\">**</bpt>/volatile<ept id=\"p1\">**</ept> compiler option is specified, the compiler performs as if <bpt id=\"p2\">**</bpt>/volatile:ms<ept id=\"p2\">**</ept> were specified; therefore, for architectures other than ARM we strongly recommend that you specify <bpt id=\"p3\">**</bpt>/volatile:iso<ept id=\"p3\">**</ept>, and use explicit synchronization primitives and compiler intrinsics when you are dealing with memory that is shared across threads.","pos":[1317,1695],"source":" For architectures other than ARM, if no **/volatile** compiler option is specified, the compiler performs as if **/volatile:ms** were specified; therefore, for architectures other than ARM we strongly recommend that you specify **/volatile:iso**, and use explicit synchronization primitives and compiler intrinsics when you are dealing with memory that is shared across threads."},{"pos":[1702,1844],"content":"You can use the <ph id=\"ph1\">`volatile`</ph> qualifier to provide access to memory locations that are used by asynchronous processes such as interrupt handlers.","source":"You can use the `volatile` qualifier to provide access to memory locations that are used by asynchronous processes such as interrupt handlers."},{"pos":[1851,1987],"content":"When <ph id=\"ph1\">`volatile`</ph> is used on a variable that also has the <bpt id=\"p1\">[</bpt>__restrict<ept id=\"p1\">](../cpp/extension-restrict.md)</ept> keyword, <ph id=\"ph2\">`volatile`</ph> takes precedence.","source":"When `volatile` is used on a variable that also has the [__restrict](../cpp/extension-restrict.md) keyword, `volatile` takes precedence."},{"content":"If a <ph id=\"ph1\">`struct`</ph> member is marked as <ph id=\"ph2\">`volatile`</ph>, then <ph id=\"ph3\">`volatile`</ph> is propagated to the whole structure.","pos":[1994,2093],"source":"If a `struct` member is marked as `volatile`, then `volatile` is propagated to the whole structure."},{"content":"If a structure does not have a length that can be copied on the current architecture by using one instruction, <ph id=\"ph1\">`volatile`</ph> may be completely lost on that structure.","pos":[2094,2257],"source":" If a structure does not have a length that can be copied on the current architecture by using one instruction, `volatile` may be completely lost on that structure."},{"pos":[2264,2360],"content":"The <ph id=\"ph1\">`volatile`</ph> keyword may have no effect on a field if one of the following conditions is true:","source":"The `volatile` keyword may have no effect on a field if one of the following conditions is true:"},{"content":"The length of the volatile field exceeds the maximum size that can be copied on the current architecture by using one instruction.","pos":[2370,2500]},{"pos":[2510,2705],"content":"The length of the outermost containing <ph id=\"ph1\">`struct`</ph>—or if it's a member of a possibly nested <ph id=\"ph2\">`struct`</ph>—exceeds the maximum size that can be copied on the current architecture by using one instruction.","source":"The length of the outermost containing `struct`—or if it's a member of a possibly nested `struct`—exceeds the maximum size that can be copied on the current architecture by using one instruction."},{"pos":[2712,2902],"content":"Although the processor does not reorder un-cacheable memory accesses, un-cacheable variables must be marked as <ph id=\"ph1\">`volatile`</ph> to guarantee that the compiler does not reorder the memory accesses.","source":"Although the processor does not reorder un-cacheable memory accesses, un-cacheable variables must be marked as `volatile` to guarantee that the compiler does not reorder the memory accesses."},{"content":"Objects that are declared as <ph id=\"ph1\">`volatile`</ph> are not used in certain optimizations because their values can change at any time.","pos":[2909,3031],"source":"Objects that are declared as `volatile` are not used in certain optimizations because their values can change at any time."},{"content":"The system always reads the current value of a volatile object when it is requested, even if a previous instruction asked for a value from the same object.","pos":[3033,3188]},{"content":"Also, the value of the object is written immediately on assignment.","pos":[3190,3257]},{"content":"ISO Compliant","pos":[3266,3279]},{"content":"If you are familiar with the C# volatile keyword, or familiar with the behavior of <ph id=\"ph1\">`volatile`</ph> in earlier versions of Visual C++, be aware that the C++11 ISO Standard <ph id=\"ph2\">`volatile`</ph> keyword is different and is supported in Visual Studio when the <bpt id=\"p1\">[</bpt>/volatile:iso<ept id=\"p1\">](../build/reference/volatile-volatile-keyword-interpretation.md)</ept> compiler option is specified.","pos":[3283,3633],"source":"If you are familiar with the C# volatile keyword, or familiar with the behavior of `volatile` in earlier versions of Visual C++, be aware that the C++11 ISO Standard `volatile` keyword is different and is supported in Visual Studio when the [/volatile:iso](../build/reference/volatile-volatile-keyword-interpretation.md) compiler option is specified."},{"content":"(For ARM, it's specified by default).","pos":[3634,3671]},{"content":"The <ph id=\"ph1\">`volatile`</ph> keyword in C++11 ISO Standard code is to be used only for hardware access; do not use it for inter-thread communication.","pos":[3672,3807],"source":" The `volatile` keyword in C++11 ISO Standard code is to be used only for hardware access; do not use it for inter-thread communication."},{"content":"For inter-thread communication, use mechanisms such as <bpt id=\"p1\">[</bpt>std::atomic<ph id=\"ph1\">\\&lt;</ph>T&gt;<ept id=\"p1\">](../standard-library/atomic.md)</ept> from the <bpt id=\"p2\">[</bpt>C++ Standard Template Library<ept id=\"p2\">](../standard-library/cpp-standard-library-reference.md)</ept>.","pos":[3808,4008],"source":" For inter-thread communication, use mechanisms such as [std::atomic\\<T>](../standard-library/atomic.md) from the [C++ Standard Template Library](../standard-library/cpp-standard-library-reference.md)."},{"content":"End of ISO Compliant","pos":[4017,4037]},{"content":"Microsoft Specific","pos":[4046,4064]},{"content":"When the <bpt id=\"p1\">**</bpt>/volatile:ms<ept id=\"p1\">**</ept> compiler option is used—by default when architectures other than ARM are targeted—the compiler generates extra code to maintain ordering among references to volatile objects in addition to maintaining ordering to references to other global objects.","pos":[4068,4342],"source":"When the **/volatile:ms** compiler option is used—by default when architectures other than ARM are targeted—the compiler generates extra code to maintain ordering among references to volatile objects in addition to maintaining ordering to references to other global objects."},{"content":"In particular:","pos":[4343,4357]},{"content":"A write to a volatile object (also known as volatile write) has Release semantics; that is, a reference to a global or static object that occurs before a write to a volatile object in the instruction sequence will occur before that volatile write in the compiled binary.","pos":[4367,4637]},{"content":"A read of a volatile object (also known as volatile read) has Acquire semantics; that is, a reference to a global or static object that occurs after a read of volatile memory in the instruction sequence will occur after that volatile read in the compiled binary.","pos":[4647,4909]},{"content":"This enables volatile objects to be used for memory locks and releases in multithreaded applications.","pos":[4916,5017]},{"pos":[5025,5169],"content":"[!NOTE]\n When it relies on the enhanced guarantee that's provided when the **/volatile:ms** compiler option is used, the code is non-portable.","leadings":["","> "],"nodes":[{"content":"When it relies on the enhanced guarantee that's provided when the <bpt id=\"p1\">**</bpt>/volatile:ms<ept id=\"p1\">**</ept> compiler option is used, the code is non-portable.","pos":[9,142],"source":" When it relies on the enhanced guarantee that's provided when the **/volatile:ms** compiler option is used, the code is non-portable."}]},{"content":"End Microsoft Specific","pos":[5178,5200]},{"content":"See Also","pos":[5209,5217]},{"content":"Keywords","pos":[5222,5230]},{"content":"const","pos":[5261,5266]},{"content":"const and volatile Pointers","pos":[5294,5321]}],"content":"---\ntitle: \"volatile (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"volatile_cpp\"\n  - \"volatile\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"interrupt handlers and volatile keyword\"\n  - \"volatile keyword [C++]\"\n  - \"volatile objects\"\n  - \"objects [C++], volatile\"\nms.assetid: 81db4a85-ed5a-4a2c-9a53-5d07a771d2de\ncaps.latest.revision: 43\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# volatile (C++)\nA type qualifier that you can use to declare that an object can be modified in the program by the hardware.  \n  \n## Syntax  \n  \n```  \n  \nvolatile declarator ;  \n```  \n  \n## Remarks  \n You can use the [/volatile](../build/reference/volatile-volatile-keyword-interpretation.md) compiler switch to modify how the compiler interprets this keyword.  \n  \n Visual Studio interprets the `volatile` keyword differently depending on the target architecture. For ARM, if no **/volatile** compiler option is specified, the compiler performs as if **/volatile:iso** were specified. For architectures other than ARM, if no **/volatile** compiler option is specified, the compiler performs as if **/volatile:ms** were specified; therefore, for architectures other than ARM we strongly recommend that you specify **/volatile:iso**, and use explicit synchronization primitives and compiler intrinsics when you are dealing with memory that is shared across threads.  \n  \n You can use the `volatile` qualifier to provide access to memory locations that are used by asynchronous processes such as interrupt handlers.  \n  \n When `volatile` is used on a variable that also has the [__restrict](../cpp/extension-restrict.md) keyword, `volatile` takes precedence.  \n  \n If a `struct` member is marked as `volatile`, then `volatile` is propagated to the whole structure. If a structure does not have a length that can be copied on the current architecture by using one instruction, `volatile` may be completely lost on that structure.  \n  \n The `volatile` keyword may have no effect on a field if one of the following conditions is true:  \n  \n-   The length of the volatile field exceeds the maximum size that can be copied on the current architecture by using one instruction.  \n  \n-   The length of the outermost containing `struct`—or if it's a member of a possibly nested `struct`—exceeds the maximum size that can be copied on the current architecture by using one instruction.  \n  \n Although the processor does not reorder un-cacheable memory accesses, un-cacheable variables must be marked as `volatile` to guarantee that the compiler does not reorder the memory accesses.  \n  \n Objects that are declared as `volatile` are not used in certain optimizations because their values can change at any time.  The system always reads the current value of a volatile object when it is requested, even if a previous instruction asked for a value from the same object.  Also, the value of the object is written immediately on assignment.  \n  \n## ISO Compliant  \n If you are familiar with the C# volatile keyword, or familiar with the behavior of `volatile` in earlier versions of Visual C++, be aware that the C++11 ISO Standard `volatile` keyword is different and is supported in Visual Studio when the [/volatile:iso](../build/reference/volatile-volatile-keyword-interpretation.md) compiler option is specified. (For ARM, it's specified by default). The `volatile` keyword in C++11 ISO Standard code is to be used only for hardware access; do not use it for inter-thread communication. For inter-thread communication, use mechanisms such as [std::atomic\\<T>](../standard-library/atomic.md) from the [C++ Standard Template Library](../standard-library/cpp-standard-library-reference.md).  \n  \n## End of ISO Compliant  \n  \n## Microsoft Specific  \n When the **/volatile:ms** compiler option is used—by default when architectures other than ARM are targeted—the compiler generates extra code to maintain ordering among references to volatile objects in addition to maintaining ordering to references to other global objects. In particular:  \n  \n-   A write to a volatile object (also known as volatile write) has Release semantics; that is, a reference to a global or static object that occurs before a write to a volatile object in the instruction sequence will occur before that volatile write in the compiled binary.  \n  \n-   A read of a volatile object (also known as volatile read) has Acquire semantics; that is, a reference to a global or static object that occurs after a read of volatile memory in the instruction sequence will occur after that volatile read in the compiled binary.  \n  \n This enables volatile objects to be used for memory locks and releases in multithreaded applications.  \n  \n> [!NOTE]\n>  When it relies on the enhanced guarantee that's provided when the **/volatile:ms** compiler option is used, the code is non-portable.  \n  \n## End Microsoft Specific  \n  \n## See Also  \n [Keywords](../cpp/keywords-cpp.md)   \n [const](../cpp/const-cpp.md)   \n [const and volatile Pointers](../cpp/const-and-volatile-pointers.md)"}