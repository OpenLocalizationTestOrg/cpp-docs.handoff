{"nodes":[{"pos":[12,76],"content":"_interlockedbittestandreset Intrinsic Functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_interlockedbittestandreset Intrinsic Functions | Microsoft Docs","pos":[0,64]}]},{"content":"_interlockedbittestandreset Intrinsic Functions","pos":[1155,1202]},{"content":"Microsoft Specific","pos":[1205,1223]},{"pos":[1232,1334],"content":"Generates an instruction which sets bit <ph id=\"ph1\">`b`</ph> of the address <ph id=\"ph2\">`a`</ph> to zero and returns its original value.","source":"Generates an instruction which sets bit `b` of the address `a` to zero and returns its original value."},{"content":"Syntax","pos":[1343,1349]},{"content":"Parameters","pos":[2140,2150]},{"content":"[in]","pos":[2154,2158]},{"content":"A pointer to the memory to examine.","pos":[2166,2201]},{"content":"[in]","pos":[2208,2212]},{"content":"The bit position to test.","pos":[2220,2245]},{"content":"Return Value","pos":[2254,2266]},{"pos":[2270,2333],"content":"The original value of the bit at the position specified by <ph id=\"ph1\">`b`</ph>.","source":"The original value of the bit at the position specified by `b`."},{"content":"Requirements","pos":[2342,2354]},{"content":"Intrinsic","pos":[2361,2370]},{"content":"Architecture","pos":[2371,2383]},{"content":"Header","pos":[2384,2390]},{"pos":[2477,2486],"content":"x86, ARM,"},{"content":"intrin.h&gt;","pos":[2553,2562],"source":"intrin.h>"},{"pos":[2600,2635],"content":", <ph id=\"ph1\">`_interlockedbittestandreset_nf`</ph>,","source":", `_interlockedbittestandreset_nf`, "},{"content":"ARM","pos":[2670,2673]},{"content":"intrin.h&gt;","pos":[2676,2685],"source":"intrin.h>"},{"pos":[2730,2731],"content":","},{"pos":[2773,2777],"content":"x86,"},{"content":"immintrin.h&gt;","pos":[2844,2856],"source":"immintrin.h>"},{"content":"intrin.h&gt;","pos":[2959,2968],"source":"intrin.h>"},{"pos":[3015,3016],"content":","},{"content":"immintrin.h&gt;","pos":[3126,3138],"source":"immintrin.h>"},{"content":"Remarks","pos":[3148,3155]},{"pos":[3159,3364],"content":"On x86 and <ph id=\"ph1\">[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]</ph> processors, these intrinsics use the <ph id=\"ph2\">`lock btr`</ph> instruction, that reads and sets the specified bit to zero in an atomic operation.","source":"On x86 and [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] processors, these intrinsics use the `lock btr` instruction, that reads and sets the specified bit to zero in an atomic operation."},{"content":"On ARM processors, use the intrinsics with <ph id=\"ph1\">`_acq`</ph> and <ph id=\"ph2\">`_rel`</ph> suffixes for acquire and release semantics, such as at the beginning and end of a critical section.","pos":[3371,3531],"source":"On ARM processors, use the intrinsics with `_acq` and `_rel` suffixes for acquire and release semantics, such as at the beginning and end of a critical section."},{"content":"The ARM intrinsics with an <ph id=\"ph1\">`_nf`</ph> (\"no fence\") suffix do not act as a memory barrier.","pos":[3532,3616],"source":" The ARM intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier."},{"content":"On Intel processors that support Hardware Lock Elision (HLE) instructions, the intrinsics with <ph id=\"ph1\">`_HLEAcquire`</ph> and <ph id=\"ph2\">`_HLERelease`</ph> suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware.","pos":[3623,3868],"source":"On Intel processors that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware."},{"content":"If these intrinsics are called on processors that do not support HLE, the hint is ignored.","pos":[3869,3959]},{"content":"These routines are only available as intrinsics.","pos":[3966,4014]},{"content":"END Microsoft Specific","pos":[4023,4045]},{"content":"See Also","pos":[4054,4062]},{"content":"Compiler Intrinsics","pos":[4067,4086]},{"content":"Conflicts with the x86 Compiler","pos":[4131,4162]}],"content":"---\ntitle: \"_interlockedbittestandreset Intrinsic Functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_interlockedbittestandreset_rel\"\n  - \"_interlockedbittestandreset64\"\n  - \"_interlockedbittestandreset64_HLERelease\"\n  - \"_interlockedbittestandreset_HLERelease\"\n  - \"_interlockedbittestandreset_HLEAcquire\"\n  - \"_interlockedbittestandreset_acq\"\n  - \"_interlockedbittestandreset_cpp\"\n  - \"_interlockedbittestandreset_nf\"\n  - \"_interlockedbittestandreset64_cpp\"\n  - \"_interlockedbittestandreset64_HLEAcquire\"\n  - \"_interlockedbittestandreset\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"lock_btr instruction\"\n  - \"_interlockedbittestandreset64 intrinsic\"\n  - \"_interlockedbittestandreset intrinsic\"\nms.assetid: 9bbb1442-f2e9-4dc2-b0da-97f3de3493b9\ncaps.latest.revision: 15\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _interlockedbittestandreset Intrinsic Functions\n**Microsoft Specific**  \n  \n Generates an instruction which sets bit `b` of the address `a` to zero and returns its original value.  \n  \n## Syntax  \n  \n```  \nunsigned char _interlockedbittestandreset(  \n   long *a,  \n   long b  \n);  \nunsigned char _interlockedbittestandreset_acq(  \n   long *a,  \n   long b  \n);  \nunsigned char _interlockedbittestandreset_HLEAcquire(  \n   long *a,  \n   long b  \n);  \nunsigned char _interlockedbittestandreset_HLERelease(  \n   long *a,  \n   long b  \n);  \nunsigned char _interlockedbittestandreset_nf(  \n   long *a,  \n   long b  \n);  \nunsigned char _interlockedbittestandreset_rel(  \n   long *a,  \n   long b  \n);   \nunsigned char _interlockedbittestandreset64(  \n   __int64 *a,  \n   __int64 b  \n);   \nunsigned char _interlockedbittestandreset64_HLEAcquire(  \n   __int64 *a,  \n   __int64 b  \n);  \nunsigned char _interlockedbittestandreset64_HLERelease(  \n   __int64 *a,  \n   __int64 b  \n);  \n```  \n  \n#### Parameters  \n [in] `a`  \n A pointer to the memory to examine.  \n  \n [in] `b`  \n The bit position to test.  \n  \n## Return Value  \n The original value of the bit at the position specified by `b`.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|Header|  \n|---------------|------------------|------------|  \n|`_interlockedbittestandreset`|x86, ARM, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_interlockedbittestandreset_acq`, `_interlockedbittestandreset_nf`, `_interlockedbittestandreset_rel`|ARM|\\<intrin.h>|  \n|`_interlockedbittestandreset_HLEAcquire`, `_interlockedbittestandreset_HLERelease`|x86, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<immintrin.h>|  \n|`_interlockedbittestandreset64`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_interlockedbittestandreset64_HLEAcquire`, `_interlockedbittestandreset64_HLERelease`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<immintrin.h>|  \n  \n## Remarks  \n On x86 and [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] processors, these intrinsics use the `lock btr` instruction, that reads and sets the specified bit to zero in an atomic operation.  \n  \n On ARM processors, use the intrinsics with `_acq` and `_rel` suffixes for acquire and release semantics, such as at the beginning and end of a critical section. The ARM intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier.  \n  \n On Intel processors that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware. If these intrinsics are called on processors that do not support HLE, the hint is ignored.  \n  \n These routines are only available as intrinsics.  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)   \n [Conflicts with the x86 Compiler](../build/conflicts-with-the-x86-compiler.md)"}