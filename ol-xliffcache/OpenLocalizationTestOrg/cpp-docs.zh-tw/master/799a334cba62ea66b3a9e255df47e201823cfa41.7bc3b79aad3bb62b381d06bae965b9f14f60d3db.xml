{"nodes":[{"pos":[12,49],"content":"Compiler Error C3398 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Error C3398 | Microsoft Docs","pos":[0,37]}]},{"content":"Compiler Error C3398","pos":[618,638]},{"content":"'operator' : cannot convert from 'function_signature' to 'function_pointer'.","pos":[639,715]},{"content":"Source expression must be a function symbol","pos":[716,759]},{"pos":[766,993],"content":"When the <bpt id=\"p1\">[</bpt>__clrcall<ept id=\"p1\">](../../cpp/clrcall.md)</ept> calling convention is not specified when compiling with <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept>, the compiler generates two entry points (addresses) for each function, a native entry point and a managed entry point.","source":"When the [__clrcall](../../cpp/clrcall.md) calling convention is not specified when compiling with **/clr**, the compiler generates two entry points (addresses) for each function, a native entry point and a managed entry point."},{"content":"By default the compiler returns the native entry point, but there are some cases where the managed entry point is desired (for instance when assigning the address to a <ph id=\"ph1\">`__clrcall`</ph> function pointer).","pos":[1000,1198],"source":"By default the compiler returns the native entry point, but there are some cases where the managed entry point is desired (for instance when assigning the address to a `__clrcall` function pointer)."},{"content":"In order for the compiler to reliably choose the managed entry point in an assignment, the right hand side must be a function symbol.","pos":[1199,1332]}],"content":"---\ntitle: \"Compiler Error C3398 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"C3398\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C3398\"\nms.assetid: 26f8c8a4-526f-415b-8047-155c5cd4f180\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Compiler Error C3398\n'operator' : cannot convert from 'function_signature' to 'function_pointer'. Source expression must be a function symbol  \n  \n When the [__clrcall](../../cpp/clrcall.md) calling convention is not specified when compiling with **/clr**, the compiler generates two entry points (addresses) for each function, a native entry point and a managed entry point.  \n  \n By default the compiler returns the native entry point, but there are some cases where the managed entry point is desired (for instance when assigning the address to a `__clrcall` function pointer). In order for the compiler to reliably choose the managed entry point in an assignment, the right hand side must be a function symbol."}