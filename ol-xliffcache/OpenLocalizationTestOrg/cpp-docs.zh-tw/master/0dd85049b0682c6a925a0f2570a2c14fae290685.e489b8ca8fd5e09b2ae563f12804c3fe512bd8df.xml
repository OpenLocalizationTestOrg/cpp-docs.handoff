{"nodes":[{"pos":[12,61],"content":"How to: Use safe_cast in C++-CLI | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Use safe_cast in C++-CLI | Microsoft Docs","pos":[0,49]}]},{"content":"How to: Use safe_cast in C++/CLI","pos":[605,637]},{"content":"This article shows how to use safe_cast in <ph id=\"ph1\">[!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]</ph> applications.","pos":[638,755],"source":"This article shows how to use safe_cast in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)] applications."},{"content":"For information about safe_cast in <ph id=\"ph1\">[!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)]</ph>, see <bpt id=\"p1\">[</bpt>safe_cast<ept id=\"p1\">](../windows/safe-cast-cpp-component-extensions.md)</ept>.","pos":[756,931],"source":" For information about safe_cast in [!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)], see [safe_cast](../windows/safe-cast-cpp-component-extensions.md)."},{"content":"Upcasting","pos":[940,949]},{"content":"An upcast is a cast from a derived type to one of its base classes.","pos":[953,1020]},{"content":"This cast is safe and does not require an explicit cast notation.","pos":[1021,1086]},{"content":"The following sample shows how to perform an upcast, with <ph id=\"ph1\">`safe_cast`</ph> and without it.","pos":[1087,1172],"source":" The following sample shows how to perform an upcast, with `safe_cast` and without it."},{"content":"Downcasting","pos":[1934,1945]},{"content":"A downcast is a cast from a base class to a class that's derived from the base class.","pos":[1949,2034]},{"content":"A downcast is safe only if the object that's addressed at runtime is actually addressing a derived class object.","pos":[2036,2148]},{"content":"Unlike <ph id=\"ph1\">`static_cast`</ph>, <ph id=\"ph2\">`safe_cast`</ph> performs a dynamic check and throws &lt;xref:System.InvalidCastException&gt; if the conversion fails.","pos":[2150,2279],"source":"  Unlike `static_cast`, `safe_cast` performs a dynamic check and throws <xref:System.InvalidCastException> if the conversion fails."},{"content":"safe_cast with user-defined conversions","pos":[3122,3161]},{"pos":[3165,3250],"content":"The next sample shows how you can use <ph id=\"ph1\">`safe_cast`</ph> to invoke user-defined conversions.","source":"The next sample shows how you can use `safe_cast` to invoke user-defined conversions."},{"content":"safe_cast and boxing operations","pos":[4120,4151]},{"content":"Boxing","pos":[4157,4163]},{"content":"Boxing is defined as a compiler-injected, user-defined conversion.","pos":[4172,4238]},{"content":"Therefore, you can use <ph id=\"ph1\">`safe_cast`</ph> to box a value on the CLR heap.","pos":[4240,4306],"source":"  Therefore, you can use `safe_cast` to box a value on the CLR heap."},{"content":"The following sample shows boxing with simple and user-defined value types.","pos":[4313,4388]},{"content":"A <ph id=\"ph1\">`safe_cast`</ph> boxes a value type variable that's on the native stack so that it can be assigned to a variable on the garbage-collected heap.","pos":[4390,4530],"source":"  A `safe_cast` boxes a value type variable that's on the native stack so that it can be assigned to a variable on the garbage-collected heap."},{"pos":[4921,5026],"content":"The next sample shows that boxing has priority over a user-defined conversion in a <ph id=\"ph1\">`safe_cast`</ph> operation.","source":"The next sample shows that boxing has priority over a user-defined conversion in a `safe_cast` operation."},{"content":"Unboxing","pos":[5525,5533]},{"content":"Unboxing is defined as a compiler-injected, user-defined conversion.","pos":[5542,5610]},{"content":"Therefore, you can use <ph id=\"ph1\">`safe_cast`</ph> to unbox a value on the CLR heap.","pos":[5612,5680],"source":"  Therefore, you can use `safe_cast` to unbox a value on the CLR heap."},{"pos":[5687,5891],"content":"Unboxing is a user-defined conversion, but unlike boxing, unboxing must be explicit—that is, it must be performed by a <ph id=\"ph1\">`static_cast`</ph>, C-style cast, or <ph id=\"ph2\">`safe_cast`</ph>; unboxing cannot be performed implicitly.","source":"Unboxing is a user-defined conversion, but unlike boxing, unboxing must be explicit—that is, it must be performed by a `static_cast`, C-style cast, or `safe_cast`; unboxing cannot be performed implicitly."},{"content":"The following sample shows unboxing with value types and primitive types.","pos":[6046,6119]},{"content":"safe_cast and generic types","pos":[6770,6797]},{"pos":[6801,6893],"content":"The next sample shows how you can use <ph id=\"ph1\">`safe_cast`</ph> to perform a downcast with a generic type.","source":"The next sample shows how you can use `safe_cast` to perform a downcast with a generic type."},{"content":"See Also","pos":[7367,7375]},{"content":"safe_cast","pos":[7380,7389]}],"content":"---\ntitle: \"How to: Use safe_cast in C++-CLI | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"safe_cast keyword [C++], upcasting\"\nms.assetid: 0fbc87d8-ecdf-4cd5-81f4-0d8cc18e2aff\ncaps.latest.revision: 18\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Use safe_cast in C++/CLI\nThis article shows how to use safe_cast in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)] applications. For information about safe_cast in [!INCLUDE[cppwrt_short](../build/reference/includes/cppwrt_short_md.md)], see [safe_cast](../windows/safe-cast-cpp-component-extensions.md).  \n  \n## Upcasting  \n An upcast is a cast from a derived type to one of its base classes. This cast is safe and does not require an explicit cast notation. The following sample shows how to perform an upcast, with `safe_cast` and without it.  \n  \n```  \n  \n      // safe_upcast.cpp  \n// compile with: /clr  \nusing namespace System;  \ninterface class A {  \n   void Test();  \n};  \n  \nref struct B : public A {  \n   virtual void Test() {  \n      Console::WriteLine(\"in B::Test\");  \n   }  \n  \n   void Test2() {  \n      Console::WriteLine(\"in B::Test2\");  \n   }  \n};  \n  \nref struct C : public B {  \n   virtual void Test() override {  \n      Console::WriteLine(\"in C::Test\");  \n   };  \n};  \n  \nint main() {  \n   C ^ c = gcnew C;  \n  \n   // implicit upcast  \n   B ^ b = c;  \n   b->Test();  \n   b->Test2();  \n  \n   // upcast with safe_cast  \n   b = nullptr;  \n   b = safe_cast<B^>(c);  \n   b->Test();  \n   b->Test2();  \n}  \n```  \n  \n```Output  \nin C::Test  \nin B::Test2  \nin C::Test  \nin B::Test2  \n```  \n  \n## Downcasting  \n A downcast is a cast from a base class to a class that's derived from the base class.  A downcast is safe only if the object that's addressed at runtime is actually addressing a derived class object.  Unlike `static_cast`, `safe_cast` performs a dynamic check and throws <xref:System.InvalidCastException> if the conversion fails.  \n  \n```  \n// safe_downcast.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \ninterface class A { void Test(); };  \n  \nref struct B : public A {  \n   virtual void Test() {   \n      Console::WriteLine(\"in B::Test()\");  \n   }  \n  \n   void Test2() {   \n      Console::WriteLine(\"in B::Test2()\");  \n   }  \n};  \n  \nref struct C : public B {  \n   virtual void Test() override {   \n      Console::WriteLine(\"in C::Test()\");  \n   }  \n};  \n  \ninterface class I {};  \n  \nvalue struct V : public I {};  \n  \nint main() {  \n   A^ a = gcnew C();  \n   a->Test();  \n   B^ b = safe_cast<B^>(a);  \n   b->Test();  \n   b->Test2();  \n  \n   V v;   \n   I^ i = v;   // i boxes V  \n   V^ refv = safe_cast<V^>(i);   \n  \n   Object^ o = gcnew B;  \n   A^ a2= safe_cast<A^>(o);  \n}  \n```  \n  \n```Output  \nin C::Test()  \nin C::Test()  \nin B::Test2()  \n```  \n  \n## safe_cast with user-defined conversions  \n The next sample shows how you can use `safe_cast` to invoke user-defined conversions.  \n  \n```  \n// safe_cast_udc.cpp  \n// compile with: /clr  \nusing namespace System;  \nvalue struct V;  \n  \nref struct R {  \n   int x;  \n   R() {  \n      x = 1;  \n   }  \n  \n   R(int argx) {  \n      x = argx;  \n   }  \n  \n   static operator R::V^(R^ r);  \n};  \n  \nvalue struct V {  \n   int x;  \n   static operator R^(V& v) {  \n      Console::WriteLine(\"in operator R^(V& v)\");  \n      R^ r = gcnew R();  \n      r->x = v.x;    \n      return r;  \n   }  \n  \n   V(int argx) {  \n      x = argx;  \n   }  \n};  \n  \n   R::operator V^(R^ r) {  \n      Console::WriteLine(\"in operator V^(R^ r)\");  \n      return gcnew V(r->x);  \n   }  \n  \nint main() {  \n   bool fReturnVal = false;  \n   V v(2);  \n   R^ r = safe_cast<R^>(v);   // should invoke UDC  \n   V^ v2 = safe_cast<V^>(r);   // should invoke UDC  \n}  \n```  \n  \n```Output  \nin operator R^(V& v  \nin operator V^(R^ r)  \n```  \n  \n## safe_cast and boxing operations  \n **Boxing**  \n  \n Boxing is defined as a compiler-injected, user-defined conversion.  Therefore, you can use `safe_cast` to box a value on the CLR heap.  \n  \n The following sample shows boxing with simple and user-defined value types.  A `safe_cast` boxes a value type variable that's on the native stack so that it can be assigned to a variable on the garbage-collected heap.  \n  \n```  \n// safe_cast_boxing.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \ninterface struct I {};  \n  \nvalue struct V : public I {   \n   int m_x;  \n  \n   V(int i) : m_x(i) {}  \n};  \n  \nint main() {  \n   // box a value type  \n   V v(100);  \n   I^ i = safe_cast<I^>(v);  \n  \n   int x = 100;  \n   V^ refv = safe_cast<V^>(v);  \n   int^ refi = safe_cast<int^>(x);  \n}  \n```  \n  \n The next sample shows that boxing has priority over a user-defined conversion in a `safe_cast` operation.  \n  \n```  \n// safe_cast_boxing_2.cpp  \n// compile with: /clr  \nstatic bool fRetval = true;  \n  \ninterface struct I {};  \nvalue struct V : public I {  \n   int x;  \n  \n   V(int argx) {  \n      x = argx;  \n   }  \n  \n   static operator I^(V v) {  \n      fRetval = false;  \n      I^ pi = v;  \n      return pi;  \n   }  \n};  \n  \nref struct R {  \n   R() {}  \n   R(V^ pv) {}  \n};  \n  \nint main() {  \n   V v(10);  \n   I^ pv = safe_cast<I^>(v);   // boxing will occur, not UDC \"operator I^\"  \n}  \n```  \n  \n **Unboxing**  \n  \n Unboxing is defined as a compiler-injected, user-defined conversion.  Therefore, you can use `safe_cast` to unbox a value on the CLR heap.  \n  \n Unboxing is a user-defined conversion, but unlike boxing, unboxing must be explicit—that is, it must be performed by a `static_cast`, C-style cast, or `safe_cast`; unboxing cannot be performed implicitly.  \n  \n```  \n// safe_cast_unboxing.cpp  \n// compile with: /clr  \nint main() {  \n   System::Object ^ o = 42;  \n   int x = safe_cast<int>(o);  \n}  \n```  \n  \n The following sample shows unboxing with value types and primitive types.  \n  \n```  \n// safe_cast_unboxing_2.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \ninterface struct I {};  \n  \nvalue struct VI : public I {};  \n  \nvoid test1() {  \n   Object^ o = 5;  \n   int x = safe_cast<Int32>(o);  \n}  \n  \nvalue struct V {  \n   int x;  \n   String^ s;  \n};  \n  \nvoid test2() {  \n   V localv;  \n   Object^ o = localv;  \n   V unboxv = safe_cast<V>(o);  \n}  \n  \nvoid test3() {  \n   V localv;  \n   V^ o2 = localv;  \n   V unboxv2 = safe_cast<V>(o2);  \n}  \n  \nvoid test4() {  \n   I^ refi = VI();  \n   VI vi  = safe_cast<VI>(refi);  \n}  \n  \nint main() {  \n   test1();  \n   test2();  \n   test3();  \n   test4();  \n}  \n```  \n  \n## safe_cast and generic types  \n The next sample shows how you can use `safe_cast` to perform a downcast with a generic type.  \n  \n```  \n// safe_cast_generic_types.cpp  \n// compile with: /clr  \ninterface struct I {};  \n  \ngeneric<class T> where T:I  \nref struct Base {  \n   T t;  \n   void test1() {}  \n};  \n  \ngeneric<class T> where T:I  \nref struct Derived:public Base <T> {};  \n  \nref struct R:public I {};  \n  \ntypedef Base<R^> GBase_R;  \ntypedef Derived<R^> GDerived_R;  \n  \nint main() {  \n   GBase_R^ br = gcnew GDerived_R();  \n   GDerived_R^ dr = safe_cast<GDerived_R^>(br);  \n}  \n```  \n  \n## See Also  \n [safe_cast](../windows/safe-cast-cpp-component-extensions.md)"}