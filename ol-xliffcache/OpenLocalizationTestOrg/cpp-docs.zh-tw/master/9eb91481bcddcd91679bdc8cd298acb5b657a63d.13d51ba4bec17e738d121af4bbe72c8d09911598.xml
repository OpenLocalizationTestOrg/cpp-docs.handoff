{"nodes":[{"pos":[12,50],"content":"Event Handling in COM | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Event Handling in COM | Microsoft Docs","pos":[0,38]}]},{"content":"Event Handling in COM","pos":[971,992]},{"content":"In COM event handling, you set up an event source and event receiver using the <bpt id=\"p1\">[</bpt>event_source<ept id=\"p1\">](../windows/event-source.md)</ept> and <bpt id=\"p2\">[</bpt>event_receiver<ept id=\"p2\">](../windows/event-receiver.md)</ept> attributes, respectively, specifying <ph id=\"ph1\">`type`=</ph><bpt id=\"p3\">**</bpt>com<ept id=\"p3\">**</ept>.","pos":[993,1218],"source":"In COM event handling, you set up an event source and event receiver using the [event_source](../windows/event-source.md) and [event_receiver](../windows/event-receiver.md) attributes, respectively, specifying `type`=**com**."},{"content":"These attributes inject the appropriate code for custom, dispatch, and dual interfaces to allow the classes to which they are applied to fire events and handle events through COM connection points.","pos":[1219,1416]},{"content":"Declaring Events","pos":[1425,1441]},{"content":"In an event source class, use the <bpt id=\"p1\">[</bpt>__event<ept id=\"p1\">](../cpp/event.md)</ept> keyword on an interface declaration to declare that interface's methods as events.","pos":[1445,1588],"source":"In an event source class, use the [__event](../cpp/event.md) keyword on an interface declaration to declare that interface's methods as events."},{"content":"The events of that interface are fired when you call them as interface methods.","pos":[1589,1668]},{"content":"Methods on event interfaces can have zero or more parameters (which should all be <bpt id=\"p1\">**</bpt>in<ept id=\"p1\">**</ept> parameters).","pos":[1669,1770],"source":" Methods on event interfaces can have zero or more parameters (which should all be **in** parameters)."},{"content":"The return type can be void or any integral type.","pos":[1771,1820]},{"content":"Defining Event Handlers","pos":[1829,1852]},{"content":"In an event receiver class, you define event handlers, which are methods with signatures (return types, calling conventions, and arguments) that match the event that they will handle.","pos":[1856,2039]},{"content":"For COM events, calling conventions do not have to match; see <bpt id=\"p1\">[</bpt>Layout Dependent COM Events<ept id=\"p1\">](#vcconeventhandlingincomanchorlayoutdependentcomevents)</ept> below for details.","pos":[2040,2206],"source":" For COM events, calling conventions do not have to match; see [Layout Dependent COM Events](#vcconeventhandlingincomanchorlayoutdependentcomevents) below for details."},{"content":"Hooking Event Handlers to Events","pos":[2215,2247]},{"content":"Also in an event receiver class, you use the intrinsic function <bpt id=\"p1\">[</bpt>__hook<ept id=\"p1\">](../cpp/hook.md)</ept> to associate events with event handlers and <bpt id=\"p2\">[</bpt>__unhook<ept id=\"p2\">](../cpp/unhook.md)</ept> to dissociate events from event handlers.","pos":[2251,2454],"source":"Also in an event receiver class, you use the intrinsic function [__hook](../cpp/hook.md) to associate events with event handlers and [__unhook](../cpp/unhook.md) to dissociate events from event handlers."},{"content":"You can hook several events to an event handler, or several event handlers to an event.","pos":[2455,2542]},{"pos":[2550,2963],"content":"[!NOTE]\n Typically, there are two techniques to allow a COM event receiver to access event source interface definitions. The first, as shown below, is to share a common header file. The second is to use [#import](../preprocessor/hash-import-directive-cpp.md) with the `embedded_idl` import qualifier, so that the event source type library is written to the .tlh file with the attribute-generated code preserved.","leadings":["","> "],"nodes":[{"content":" Typically, there are two techniques to allow a COM event receiver to access event source interface definitions. The first, as shown below, is to share a common header file. The second is to use [#import](../preprocessor/hash-import-directive-cpp.md) with the `embedded_idl` import qualifier, so that the event source type library is written to the .tlh file with the attribute-generated code preserved.","pos":[8,411],"nodes":[{"content":"Typically, there are two techniques to allow a COM event receiver to access event source interface definitions.","pos":[1,112]},{"content":"The first, as shown below, is to share a common header file.","pos":[113,173]},{"content":"The second is to use <bpt id=\"p1\">[</bpt>#import<ept id=\"p1\">](../preprocessor/hash-import-directive-cpp.md)</ept> with the <ph id=\"ph1\">`embedded_idl`</ph> import qualifier, so that the event source type library is written to the .tlh file with the attribute-generated code preserved.","pos":[174,403],"source":" The second is to use [#import](../preprocessor/hash-import-directive-cpp.md) with the `embedded_idl` import qualifier, so that the event source type library is written to the .tlh file with the attribute-generated code preserved."}]}]},{"content":"Firing Events","pos":[2972,2985]},{"content":"To fire an event, simply call a method in the interface declared with the <ph id=\"ph1\">`__event`</ph> keyword in the event source class.","pos":[2989,3107],"source":"To fire an event, simply call a method in the interface declared with the `__event` keyword in the event source class."},{"content":"If handlers have been hooked to the event, the handlers will be called.","pos":[3108,3179]},{"content":"COM Event Code","pos":[3189,3203]},{"content":"The following example shows how to fire an event in a COM class.","pos":[3207,3271]},{"content":"To compile and run the example, refer to the comments in the code.","pos":[3272,3338]},{"content":"And then the server:","pos":[3730,3750]},{"content":"And then the client:","pos":[4315,4335]},{"content":"Output","pos":[5823,5829]},{"pos":[6003,6030],"content":"Layout Dependent COM Events"},{"content":"Layout dependency is only an issue for COM programming.","pos":[6034,6089]},{"content":"In native and managed event handling, the signatures (return type, calling convention, and arguments) of the handlers must match their events, but the handler names do not have to match their events.","pos":[6090,6289]},{"content":"However, in COM event handling, when you set the <bpt id=\"p1\">*</bpt>layout_dependent<ept id=\"p1\">*</ept> parameter of <bpt id=\"p2\">**</bpt>event_receiver<ept id=\"p2\">**</ept> to <bpt id=\"p3\">**</bpt>true<ept id=\"p3\">**</ept>, the name and signature matching is enforced.","pos":[6296,6453],"source":"However, in COM event handling, when you set the *layout_dependent* parameter of **event_receiver** to **true**, the name and signature matching is enforced."},{"content":"This means that the names and signatures of the handlers in the event receiver must exactly match the names and signatures of the events to which they are hooked.","pos":[6454,6616]},{"content":"When <bpt id=\"p1\">*</bpt>layout_dependent<ept id=\"p1\">*</ept> is set to <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>, the calling convention and storage class (virtual, static, and so on) can be mixed and matched between the firing event method and the hooking methods (its delegates).","pos":[6623,6835],"source":"When *layout_dependent* is set to **false**, the calling convention and storage class (virtual, static, and so on) can be mixed and matched between the firing event method and the hooking methods (its delegates)."},{"content":"It is slightly more efficient to have <bpt id=\"p1\">*</bpt>layout_dependent<ept id=\"p1\">*</ept><ph id=\"ph1\">=</ph><bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>.","pos":[6836,6902],"source":" It is slightly more efficient to have *layout_dependent*=**true**."},{"pos":[6909,6986],"content":"For example, suppose <ph id=\"ph1\">`IEventSource`</ph> is defined to have the following methods:","source":"For example, suppose `IEventSource` is defined to have the following methods:"},{"content":"Assume the event source has the following form:","pos":[7096,7143]},{"pos":[7389,7513],"content":"Then, in the event receiver, any handler hooked to a method in <ph id=\"ph1\">`IEventSource`</ph> must match its name and signature, as follows:","source":"Then, in the event receiver, any handler hooked to a method in `IEventSource` must match its name and signature, as follows:"},{"content":"See Also","pos":[8313,8321]},{"content":"Event Handling","pos":[8326,8340]}],"content":"---\ntitle: \"Event Handling in COM | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"event handling, COM\"\n  - \"event handling, about event handling\"\n  - \"declaring events\"\n  - \"event handlers, COM\"\n  - \"event handlers\"\n  - \"COM, events\"\n  - \"event receivers, in event handling\"\n  - \"event handling\"\n  - \"hooking events\"\n  - \"event receivers, name and signature matching\"\n  - \"event sources, in event handling\"\n  - \"declaring events, in COM\"\n  - \"declaring events, event handling in COM\"\nms.assetid: 6b4617d4-a58e-440c-a8a6-1ad1c715b2bb\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Event Handling in COM\nIn COM event handling, you set up an event source and event receiver using the [event_source](../windows/event-source.md) and [event_receiver](../windows/event-receiver.md) attributes, respectively, specifying `type`=**com**. These attributes inject the appropriate code for custom, dispatch, and dual interfaces to allow the classes to which they are applied to fire events and handle events through COM connection points.  \n  \n## Declaring Events  \n In an event source class, use the [__event](../cpp/event.md) keyword on an interface declaration to declare that interface's methods as events. The events of that interface are fired when you call them as interface methods. Methods on event interfaces can have zero or more parameters (which should all be **in** parameters). The return type can be void or any integral type.  \n  \n## Defining Event Handlers  \n In an event receiver class, you define event handlers, which are methods with signatures (return types, calling conventions, and arguments) that match the event that they will handle. For COM events, calling conventions do not have to match; see [Layout Dependent COM Events](#vcconeventhandlingincomanchorlayoutdependentcomevents) below for details.  \n  \n## Hooking Event Handlers to Events  \n Also in an event receiver class, you use the intrinsic function [__hook](../cpp/hook.md) to associate events with event handlers and [__unhook](../cpp/unhook.md) to dissociate events from event handlers. You can hook several events to an event handler, or several event handlers to an event.  \n  \n> [!NOTE]\n>  Typically, there are two techniques to allow a COM event receiver to access event source interface definitions. The first, as shown below, is to share a common header file. The second is to use [#import](../preprocessor/hash-import-directive-cpp.md) with the `embedded_idl` import qualifier, so that the event source type library is written to the .tlh file with the attribute-generated code preserved.  \n  \n## Firing Events  \n To fire an event, simply call a method in the interface declared with the `__event` keyword in the event source class. If handlers have been hooked to the event, the handlers will be called.  \n  \n### COM Event Code  \n The following example shows how to fire an event in a COM class. To compile and run the example, refer to the comments in the code.  \n  \n```  \n// evh_server.h  \n#pragma once  \n  \n[ dual, uuid(\"00000000-0000-0000-0000-000000000001\") ]  \n__interface IEvents {  \n   [id(1)] HRESULT MyEvent([in] int value);  \n};  \n  \n[ dual, uuid(\"00000000-0000-0000-0000-000000000002\") ]  \n__interface IEventSource {  \n   [id(1)] HRESULT FireEvent();  \n};  \n  \nclass DECLSPEC_UUID(\"530DF3AD-6936-3214-A83B-27B63C7997C4\") CSource;  \n```  \n  \n And then the server:  \n  \n```  \n// evh_server.cpp  \n// compile with: /LD  \n// post-build command: Regsvr32.exe /s evh_server.dll  \n#define _ATL_ATTRIBUTES 1  \n#include <atlbase.h>  \n#include <atlcom.h>  \n#include \"evh_server.h\"  \n  \n[ module(dll, name=\"EventSource\", uuid=\"6E46B59E-89C3-4c15-A6D8-B8A1CEC98830\") ];  \n  \n[coclass, event_source(com), uuid(\"530DF3AD-6936-3214-A83B-27B63C7997C4\")]  \nclass CSource : public IEventSource {  \npublic:  \n   __event __interface IEvents;   \n  \n   HRESULT FireEvent() {  \n      __raise MyEvent(123);  \n      return S_OK;  \n   }  \n};  \n```  \n  \n And then the client:  \n  \n```  \n// evh_client.cpp  \n// compile with: /link /OPT:NOREF  \n#define _ATL_ATTRIBUTES 1  \n#include <atlbase.h>  \n#include <atlcom.h>  \n#include <stdio.h>  \n#include \"evh_server.h\"  \n  \n[ module(name=\"EventReceiver\") ];  \n  \n[ event_receiver(com) ]  \nclass CReceiver {  \npublic:  \n   HRESULT MyHandler1(int nValue) {  \n      printf_s(\"MyHandler1 was called with value %d.\\n\", nValue);  \n      return S_OK;  \n   }  \n  \n   HRESULT MyHandler2(int nValue) {  \n      printf_s(\"MyHandler2 was called with value %d.\\n\", nValue);  \n      return S_OK;  \n   }  \n  \n   void HookEvent(IEventSource* pSource) {  \n      __hook(&IEvents::MyEvent, pSource, &CReceiver::MyHandler1);  \n      __hook(&IEvents::MyEvent, pSource, &CReceiver::MyHandler2);  \n   }  \n  \n   void UnhookEvent(IEventSource* pSource) {  \n      __unhook(&IEvents::MyEvent, pSource, &CReceiver::MyHandler1);  \n      __unhook(&IEvents::MyEvent, pSource, &CReceiver::MyHandler2);  \n   }  \n};  \n  \nint main() {  \n   // Create COM object  \n   CoInitialize(NULL);  \n   {  \n      IEventSource* pSource = 0;  \n      HRESULT hr = CoCreateInstance(__uuidof(CSource), NULL,         CLSCTX_ALL, __uuidof(IEventSource), (void **) &pSource);  \n      if (FAILED(hr)) {  \n         return -1;  \n      }  \n  \n      // Create receiver and fire event  \n      CReceiver receiver;  \n      receiver.HookEvent(pSource);  \n      pSource->FireEvent();  \n      receiver.UnhookEvent(pSource);  \n   }  \n   CoUninitialize();  \n   return 0;  \n}  \n```  \n  \n### Output  \n  \n```  \nMyHandler1 was called with value 123.  \nMyHandler2 was called with value 123.  \n```  \n  \n##  <a name=\"vcconeventhandlingincomanchorlayoutdependentcomevents\"></a> Layout Dependent COM Events  \n Layout dependency is only an issue for COM programming. In native and managed event handling, the signatures (return type, calling convention, and arguments) of the handlers must match their events, but the handler names do not have to match their events.  \n  \n However, in COM event handling, when you set the *layout_dependent* parameter of **event_receiver** to **true**, the name and signature matching is enforced. This means that the names and signatures of the handlers in the event receiver must exactly match the names and signatures of the events to which they are hooked.  \n  \n When *layout_dependent* is set to **false**, the calling convention and storage class (virtual, static, and so on) can be mixed and matched between the firing event method and the hooking methods (its delegates). It is slightly more efficient to have *layout_dependent*=**true**.  \n  \n For example, suppose `IEventSource` is defined to have the following methods:  \n  \n```  \n[id(1)] HRESULT MyEvent1([in] int value);  \n[id(2)] HRESULT MyEvent2([in] int value);  \n```  \n  \n Assume the event source has the following form:  \n  \n```  \n[coclass, event_source(com)]  \nclass CSource : public IEventSource {  \npublic:  \n   __event __interface IEvents;  \n  \n   HRESULT FireEvent() {  \n      MyEvent1(123);  \n      MyEvent2(123);  \n      return S_OK;  \n   }  \n};  \n```  \n  \n Then, in the event receiver, any handler hooked to a method in `IEventSource` must match its name and signature, as follows:  \n  \n```  \n[coclass, event_receiver(com, true)]  \nclass CReceiver {  \npublic:  \n   HRESULT MyEvent1(int nValue) {  // name and signature matches MyEvent1  \n      ...  \n   }  \n   HRESULT MyEvent2(E c, char* pc) {  // signature doesn't match MyEvent2  \n      ...  \n   }  \n   HRESULT MyHandler1(int nValue) {  // name doesn't match MyEvent1 (or 2)  \n      ...  \n   }  \n   void HookEvent(IEventSource* pSource) {  \n      __hook(IFace, pSource);  // Hooks up all name-matched events   \n                               // under layout_dependent = true  \n      __hook(&IFace::MyEvent1, pSource, &CReceive::MyEvent1);   // valid  \n      __hook(&IFace::MyEvent2, pSource, &CSink::MyEvent2);   // not valid  \n      __hook(&IFace::MyEvent1, pSource, &CSink:: MyHandler1); // not valid  \n   }  \n};  \n```  \n  \n## See Also  \n [Event Handling](../cpp/event-handling.md)"}