{"nodes":[{"pos":[12,61],"content":"User-Defined Operators (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"User-Defined Operators (C++-CLI) | Microsoft Docs","pos":[0,49]}]},{"content":"User-Defined Operators (C++/CLI)","pos":[630,662]},{"content":"User-defined operators for managed types are allowed as static members or instance members, or at global scope.","pos":[663,774]},{"content":"However, only static operators are accessible through metadata to clients that are written in a language other than Visual C++.","pos":[775,902]},{"content":"In a reference type, one of the parameters of a static user-defined operator must be one of these:","pos":[909,1007]},{"pos":[1017,1074],"content":"A handle (<ph id=\"ph1\">`type`</ph> ^) to an instance of the enclosing type.","source":"A handle (`type` ^) to an instance of the enclosing type."},{"pos":[1084,1183],"content":"A reference type indirection (<ph id=\"ph1\">`type`</ph>^&amp; or type^%) to a handle to an instance of the enclosing type.","source":"A reference type indirection (`type`^& or type^%) to a handle to an instance of the enclosing type."},{"content":"In a value type, one of the parameters of a static user-defined operator must be one of these:","pos":[1190,1284]},{"content":"Of the same type as the enclosing value type.","pos":[1294,1339]},{"pos":[1349,1408],"content":"A pointer type indirection (<ph id=\"ph1\">`type`</ph>^) to the enclosing type.","source":"A pointer type indirection (`type`^) to the enclosing type."},{"pos":[1418,1490],"content":"A reference type indirection (<ph id=\"ph1\">`type`</ph>% or <ph id=\"ph2\">`type`</ph>&amp;) to the enclosing type.","source":"A reference type indirection (`type`% or `type`&) to the enclosing type."},{"pos":[1500,1566],"content":"A reference type indirection (<ph id=\"ph1\">`type`</ph>^% or <ph id=\"ph2\">`type`</ph>^&amp;) to the handle.","source":"A reference type indirection (`type`^% or `type`^&) to the handle."},{"content":"You can define the following operators:","pos":[1573,1612]},{"content":"Operator","pos":[1619,1627]},{"content":"Unary/Binary Forms?","pos":[1628,1647]},{"content":"!","pos":[1698,1699]},{"content":"Unary","pos":[1700,1705]},{"content":"!=","pos":[1710,1712]},{"content":"Binary","pos":[1713,1719]},{"content":"Binary","pos":[1726,1732]},{"content":"Unary and Binary","pos":[1739,1755]},{"content":"Binary","pos":[1763,1769]},{"content":"Unary and Binary","pos":[1776,1792]},{"content":"Unary and Binary","pos":[1799,1815]},{"content":"Unary","pos":[1823,1828]},{"content":",","pos":[1833,1834]},{"content":"Binary","pos":[1835,1841]},{"content":"Unary and Binary","pos":[1848,1864]},{"content":"Unary","pos":[1872,1877]},{"content":"Unary","pos":[1885,1890]},{"content":"Binary","pos":[1897,1903]},{"content":"Binary","pos":[1910,1916]},{"content":"Binary","pos":[1924,1930]},{"content":"Binary","pos":[1939,1945]},{"content":"Binary","pos":[1952,1958]},{"content":"Binary","pos":[1966,1972]},{"content":"Binary","pos":[1979,1985]},{"content":"Binary","pos":[1993,1999]},{"content":"Binary","pos":[2007,2013]},{"content":"Binary","pos":[2020,2026]},{"content":"false","pos":[2031,2036]},{"content":"Unary","pos":[2037,2042]},{"content":"true","pos":[2047,2051]},{"content":"Unary","pos":[2052,2057]},{"content":"&amp;#124;","pos":[2062,2068],"source":"&#124;"},{"content":"Binary","pos":[2069,2075]},{"content":"&amp;#124;&amp;#124;","pos":[2080,2092],"source":"&#124;&#124;"},{"content":"Binary","pos":[2093,2099]},{"content":"Unary","pos":[2106,2111]},{"content":"Example","pos":[2121,2128]},{"content":"Example","pos":[3540,3547]},{"content":"The following sample demonstrates operator synthesis, which is only available when you use <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> to compile.","pos":[3551,3662],"source":"The following sample demonstrates operator synthesis, which is only available when you use **/clr** to compile."},{"content":"Operator synthesis creates the assignment form of a binary operator, if one is not defined, where the left-hand side of the assignment operator has a CLR type.","pos":[3663,3822]},{"content":"See Also","pos":[4274,4282]},{"content":"Classes and Structs","pos":[4287,4306]}],"content":"---\ntitle: \"User-Defined Operators (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"user-defined operators under /clr\"\nms.assetid: 42f93b4a-6de4-4e34-b07b-5a62ac014f2c\ncaps.latest.revision: 16\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# User-Defined Operators (C++/CLI)\nUser-defined operators for managed types are allowed as static members or instance members, or at global scope. However, only static operators are accessible through metadata to clients that are written in a language other than Visual C++.  \n  \n In a reference type, one of the parameters of a static user-defined operator must be one of these:  \n  \n-   A handle (`type` ^) to an instance of the enclosing type.  \n  \n-   A reference type indirection (`type`^& or type^%) to a handle to an instance of the enclosing type.  \n  \n In a value type, one of the parameters of a static user-defined operator must be one of these:  \n  \n-   Of the same type as the enclosing value type.  \n  \n-   A pointer type indirection (`type`^) to the enclosing type.  \n  \n-   A reference type indirection (`type`% or `type`&) to the enclosing type.  \n  \n-   A reference type indirection (`type`^% or `type`^&) to the handle.  \n  \n You can define the following operators:  \n  \n|Operator|Unary/Binary Forms?|  \n|--------------|--------------------------|  \n|!|Unary|  \n|!=|Binary|  \n|%|Binary|  \n|&|Unary and Binary|  \n|&&|Binary|  \n|*|Unary and Binary|  \n|+|Unary and Binary|  \n|++|Unary|  \n|,|Binary|  \n|-|Unary and Binary|  \n|--|Unary|  \n|->|Unary|  \n|/|Binary|  \n|<|Binary|  \n|<<|Binary|  \n|\\<=|Binary|  \n|=|Binary|  \n|==|Binary|  \n|>|Binary|  \n|>=|Binary|  \n|>>|Binary|  \n|^|Binary|  \n|false|Unary|  \n|true|Unary|  \n|&#124;|Binary|  \n|&#124;&#124;|Binary|  \n|~|Unary|  \n  \n## Example  \n  \n```  \n  \n      // mcppv2_user-defined_operators.cpp  \n// compile with: /clr  \nusing namespace System;  \npublic ref struct X {  \n   X(int i) : m_i(i) {}  \n   X() {}  \n  \n   int m_i;  \n  \n   // static, binary, user-defined operator  \n   static X ^ operator + (X^ me, int i) {  \n      return (gcnew X(me -> m_i + i));  \n   }  \n  \n   // instance, binary, user-defined operator  \n   X^ operator -( int i ) {  \n      return gcnew X(this->m_i - i);  \n   }  \n  \n   // instance, unary, user-defined pre-increment operator  \n   X^ operator ++() {  \n      return gcnew X(this->m_i++);  \n   }  \n  \n   // instance, unary, user-defined post-increment operator  \n   X^ operator ++(int i) {  \n      return gcnew X(this->m_i++);  \n   }  \n  \n   // static, unary user-defined pre- and post-increment operator  \n   static X^ operator-- (X^ me) {  \n      return (gcnew X(me -> m_i - 1));  \n   }  \n};  \n  \nint main() {  \n   X ^hX = gcnew X(-5);  \n   System::Console::WriteLine(hX -> m_i);  \n  \n   hX = hX + 1;  \n   System::Console::WriteLine(hX -> m_i);  \n  \n   hX = hX - (-1);  \n   System::Console::WriteLine(hX -> m_i);  \n  \n   ++hX;  \n   System::Console::WriteLine(hX -> m_i);  \n  \n   hX++;  \n   System::Console::WriteLine(hX -> m_i);  \n  \n   hX--;  \n   System::Console::WriteLine(hX -> m_i);  \n  \n   --hX;  \n   System::Console::WriteLine(hX -> m_i);  \n}  \n```  \n  \n```Output  \n-5  \n-4  \n-3  \n-2  \n-1  \n-2  \n-3  \n```  \n  \n## Example  \n The following sample demonstrates operator synthesis, which is only available when you use **/clr** to compile. Operator synthesis creates the assignment form of a binary operator, if one is not defined, where the left-hand side of the assignment operator has a CLR type.  \n  \n```  \n// mcppv2_user-defined_operators_2.cpp  \n// compile with: /clr  \nref struct A {  \n   A(int n) : m_n(n) {};  \n   static A^ operator + (A^ r1, A^ r2) {  \n      return gcnew A( r1->m_n + r2->m_n);  \n   };  \n   int m_n;  \n};  \n  \nint main() {  \n   A^ a1 = gcnew A(10);  \n   A^ a2 = gcnew A(20);  \n  \n   a1 += a2;   // a1 = a1 + a2   += not defined in source  \n   System::Console::WriteLine(a1->m_n);  \n}  \n```  \n  \n```Output  \n30  \n```  \n  \n## See Also  \n [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)"}