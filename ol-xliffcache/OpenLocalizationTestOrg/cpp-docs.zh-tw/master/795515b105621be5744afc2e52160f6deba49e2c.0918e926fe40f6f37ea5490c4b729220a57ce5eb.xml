{"nodes":[{"pos":[12,68],"content":"C++ Stack Semantics for Reference Types | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"C++ Stack Semantics for Reference Types | Microsoft Docs","pos":[0,56]}]},{"content":"C++ Stack Semantics for Reference Types","pos":[618,657]},{"content":"Prior to Visual C++ 2005, an instance of a reference type could only be created using the <ph id=\"ph1\">`new`</ph> operator, which created the object on the garbage collected heap.","pos":[658,819],"source":"Prior to Visual C++ 2005, an instance of a reference type could only be created using the `new` operator, which created the object on the garbage collected heap."},{"content":"However, you can now create an instance of a reference type using the same syntax that you would use to create an instance of a native type on the stack.","pos":[820,973]},{"content":"So, you do not need to use <bpt id=\"p1\">[</bpt>ref new, gcnew<ept id=\"p1\">](../windows/ref-new-gcnew-cpp-component-extensions.md)</ept> to create an object of a reference type.","pos":[974,1112],"source":" So, you do not need to use [ref new, gcnew](../windows/ref-new-gcnew-cpp-component-extensions.md) to create an object of a reference type."},{"content":"And when the object goes out of scope, the compiler calls the object's destructor.","pos":[1113,1195]},{"content":"Remarks","pos":[1204,1211]},{"pos":[1215,1381],"content":"When you create an instance of a reference type using stack semantics, the compiler does internally create the instance on the garbage collected heap (using <ph id=\"ph1\">`gcnew`</ph>).","source":"When you create an instance of a reference type using stack semantics, the compiler does internally create the instance on the garbage collected heap (using `gcnew`)."},{"content":"When the signature or return type of a function includes an instance of a by-value reference type, the function will be marked in the metadata as requiring special handling (with modreq).","pos":[1388,1575]},{"content":"This special handling is currently only provided by Visual C++ clients; other languages do not currently support consuming functions or data that use reference types created with stack semantics.","pos":[1576,1771]},{"content":"One reason to use <ph id=\"ph1\">`gcnew`</ph> (dynamic allocation) instead of stack semantics would be if the type has no destructor.","pos":[1778,1891],"source":"One reason to use `gcnew` (dynamic allocation) instead of stack semantics would be if the type has no destructor."},{"content":"Also, using reference types created with stack semantics in function signatures would not be possible if you want your functions to be consumed by languages other than Visual C++.","pos":[1892,2071]},{"content":"The compiler will not generate a copy constructor for a reference type.","pos":[2078,2149]},{"content":"Therefore, if you define a function that uses a by-value reference type in the signature, you must define a copy constructor for the reference type.","pos":[2150,2298]},{"content":"A copy constructor for a reference type has a signature of the following form: <ph id=\"ph1\">`R(R%){}`</ph>.","pos":[2299,2388],"source":" A copy constructor for a reference type has a signature of the following form: `R(R%){}`."},{"content":"The compiler will not generate a default assignment operator for a reference type.","pos":[2395,2477]},{"content":"An assignment operator allows you to create an object using stack semantics and initialize it with an existing object created using stack semantics.","pos":[2478,2626]},{"content":"An assignment operator for a reference type has a signature of the following form: <ph id=\"ph1\">`void operator=( R% ){}`</ph>.","pos":[2627,2735],"source":" An assignment operator for a reference type has a signature of the following form: `void operator=( R% ){}`."},{"content":"If your type's destructor releases critical resources and you use stack semantics for reference types, you do not need to explicitly call the destructor (or call <ph id=\"ph1\">`delete`</ph>).","pos":[2742,2914],"source":"If your type's destructor releases critical resources and you use stack semantics for reference types, you do not need to explicitly call the destructor (or call `delete`)."},{"content":"For more information on destructors in reference types, see <bpt id=\"p1\">[</bpt>Destructors and finalizers in How to: Define and consume classes and structs (C++/CLI)<ept id=\"p1\">](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers)</ept>.","pos":[2915,3164],"source":" For more information on destructors in reference types, see [Destructors and finalizers in How to: Define and consume classes and structs (C++/CLI)](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers)."},{"content":"A compiler-generated assignment operator will follow the usual standard C++ rules with the following additions:","pos":[3171,3282]},{"content":"Any non-static data members whose type is a handle to a reference type will be shallow copied (treated like a non-static data member whose type is a pointer).","pos":[3292,3450]},{"content":"Any non-static data member whose type is a value type will be shallow copied.","pos":[3460,3537]},{"content":"Any non-static data member whose type is an instance of a reference type will invoke a call to the reference type’s copy constructor.","pos":[3547,3680]},{"pos":[3687,3838],"content":"The compiler also provides a <ph id=\"ph1\">`%`</ph> unary operator to convert an instance of a reference type created using stack semantics to its underlying handle type.","source":"The compiler also provides a `%` unary operator to convert an instance of a reference type created using stack semantics to its underlying handle type."},{"content":"The following reference types are not available for use with stack semantics:","pos":[3845,3922]},{"content":"delegate  (C++ Component Extensions)","pos":[3933,3969]},{"content":"Arrays","pos":[4030,4036]},{"content":"&lt;xref:System.String&gt;","pos":[4094,4114],"source":"<xref:System.String>"},{"content":"Example","pos":[4123,4130]},{"content":"Description","pos":[4140,4151]},{"content":"The following code sample shows how to declare instances of reference types with stack semantics, how the assignment operator and copy constructor works, and how to initialize a tracking reference with reference type created using stack semantics.","pos":[4155,4402]},{"content":"Code","pos":[4412,4416]},{"content":"Output","pos":[5355,5361]},{"content":"See Also","pos":[5410,5418]},{"content":"Classes and Structs","pos":[5423,5442]}],"content":"---\ntitle: \"C++ Stack Semantics for Reference Types | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"reference types, C++ stack semantics for\"\nms.assetid: 319a1304-f4a4-4079-8b84-01cec847d531\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# C++ Stack Semantics for Reference Types\nPrior to Visual C++ 2005, an instance of a reference type could only be created using the `new` operator, which created the object on the garbage collected heap. However, you can now create an instance of a reference type using the same syntax that you would use to create an instance of a native type on the stack. So, you do not need to use [ref new, gcnew](../windows/ref-new-gcnew-cpp-component-extensions.md) to create an object of a reference type. And when the object goes out of scope, the compiler calls the object's destructor.  \n  \n## Remarks  \n When you create an instance of a reference type using stack semantics, the compiler does internally create the instance on the garbage collected heap (using `gcnew`).  \n  \n When the signature or return type of a function includes an instance of a by-value reference type, the function will be marked in the metadata as requiring special handling (with modreq). This special handling is currently only provided by Visual C++ clients; other languages do not currently support consuming functions or data that use reference types created with stack semantics.  \n  \n One reason to use `gcnew` (dynamic allocation) instead of stack semantics would be if the type has no destructor. Also, using reference types created with stack semantics in function signatures would not be possible if you want your functions to be consumed by languages other than Visual C++.  \n  \n The compiler will not generate a copy constructor for a reference type. Therefore, if you define a function that uses a by-value reference type in the signature, you must define a copy constructor for the reference type. A copy constructor for a reference type has a signature of the following form: `R(R%){}`.  \n  \n The compiler will not generate a default assignment operator for a reference type. An assignment operator allows you to create an object using stack semantics and initialize it with an existing object created using stack semantics. An assignment operator for a reference type has a signature of the following form: `void operator=( R% ){}`.  \n  \n If your type's destructor releases critical resources and you use stack semantics for reference types, you do not need to explicitly call the destructor (or call `delete`). For more information on destructors in reference types, see [Destructors and finalizers in How to: Define and consume classes and structs (C++/CLI)](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers).  \n  \n A compiler-generated assignment operator will follow the usual standard C++ rules with the following additions:  \n  \n-   Any non-static data members whose type is a handle to a reference type will be shallow copied (treated like a non-static data member whose type is a pointer).  \n  \n-   Any non-static data member whose type is a value type will be shallow copied.  \n  \n-   Any non-static data member whose type is an instance of a reference type will invoke a call to the reference type’s copy constructor.  \n  \n The compiler also provides a `%` unary operator to convert an instance of a reference type created using stack semantics to its underlying handle type.  \n  \n The following reference types are not available for use with stack semantics:  \n  \n-   [delegate  (C++ Component Extensions)](../windows/delegate-cpp-component-extensions.md)  \n  \n-   [Arrays](../windows/arrays-cpp-component-extensions.md)  \n  \n-   <xref:System.String>  \n  \n## Example  \n  \n### Description  \n The following code sample shows how to declare instances of reference types with stack semantics, how the assignment operator and copy constructor works, and how to initialize a tracking reference with reference type created using stack semantics.  \n  \n### Code  \n  \n```  \n// stack_semantics_for_reference_types.cpp  \n// compile with: /clr  \nref class R {  \npublic:  \n   int i;  \n   R(){}  \n  \n   // assignment operator  \n   void operator=(R% r) {  \n      i = r.i;  \n   }  \n  \n   // copy constructor  \n   R(R% r) : i(r.i) {}  \n};  \n  \nvoid Test(R r) {}   // requires copy constructor  \n  \nint main() {  \n   R r1;  \n   r1.i = 98;  \n  \n   R r2(r1);   // requires copy constructor  \n   System::Console::WriteLine(r1.i);  \n   System::Console::WriteLine(r2.i);  \n  \n   // use % unary operator to convert instance using stack semantics  \n   // to its underlying handle  \n   R ^ r3 = %r1;  \n   System::Console::WriteLine(r3->i);  \n  \n   Test(r1);  \n  \n   R r4;  \n   R r5;  \n   r5.i = 13;  \n   r4 = r5;   // requires a user-defined assignment operator  \n   System::Console::WriteLine(r4.i);  \n  \n   // initialize tracking reference  \n   R % r6 = r4;  \n   System::Console::WriteLine(r6.i);  \n}  \n```  \n  \n### Output  \n  \n```  \n98  \n98  \n98  \n13  \n13  \n```  \n  \n## See Also  \n [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)"}