{"nodes":[{"pos":[12,46],"content":"ptr::GetInterface | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"ptr::GetInterface | Microsoft Docs","pos":[0,34]}]},{"content":"ptr::GetInterface","pos":[726,743]},{"content":"Returns a pointer to the owned COM object.","pos":[744,786]},{"content":"Syntax","pos":[795,801]},{"content":"Return Value","pos":[861,873]},{"content":"A pointer to the owned COM object.","pos":[877,911]},{"content":"Exceptions","pos":[920,930]},{"pos":[934,1122],"content":"Internally, <ph id=\"ph1\">`QueryInterface`</ph> is called on the owned COM object and any error <ph id=\"ph2\">`HRESULT`</ph> is converted to an exception by &lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;.","source":"Internally, `QueryInterface` is called on the owned COM object and any error `HRESULT` is converted to an exception by <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A>."},{"content":"Remarks","pos":[1131,1138]},{"content":"The <ph id=\"ph1\">`com::ptr`</ph> adds a reference to the COM object on the caller's behalf and also keeps its own reference on the COM object.","pos":[1142,1266],"source":"The `com::ptr` adds a reference to the COM object on the caller's behalf and also keeps its own reference on the COM object."},{"content":"The caller must ultimately release the reference on the returned object or it will never be destroyed.","pos":[1267,1369]},{"content":"Example","pos":[1378,1385]},{"content":"This example implements a CLR class that uses a <ph id=\"ph1\">`com::ptr`</ph> to wrap its private member <ph id=\"ph2\">`IXMLDOMDocument`</ph> object.","pos":[1389,1500],"source":"This example implements a CLR class that uses a `com::ptr` to wrap its private member `IXMLDOMDocument` object."},{"content":"The <ph id=\"ph1\">`GetDocument`</ph> member function uses <ph id=\"ph2\">`GetInterface`</ph> to return a pointer to the COM object.","pos":[1501,1593],"source":" The `GetDocument` member function uses `GetInterface` to return a pointer to the COM object."},{"content":"Requirements","pos":[4978,4990]},{"pos":[4994,5028],"content":"<bpt id=\"p1\">**</bpt>Header file<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>msclr\\com\\ptr.h&gt;","source":"**Header file** \\<msclr\\com\\ptr.h>"},{"pos":[5035,5059],"content":"<bpt id=\"p1\">**</bpt>Namespace<ept id=\"p1\">**</ept> msclr::com","source":"**Namespace** msclr::com"},{"content":"See Also","pos":[5068,5076]},{"content":"ptr Members","pos":[5081,5092]},{"content":"ptr::QueryInterface","pos":[5125,5144]}],"content":"---\ntitle: \"ptr::GetInterface | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"ptr::GetInterface\"\n  - \"msclr::com::ptr::GetInterface\"\n  - \"GetInterface\"\n  - \"msclr.com.ptr.GetInterface\"\n  - \"ptr.GetInterface\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"GetInterface method\"\nms.assetid: d85553ec-fb88-4fd6-9df2-ddcaa8b2dc70\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# ptr::GetInterface\nReturns a pointer to the owned COM object.  \n  \n## Syntax  \n  \n```  \n_interface_type * GetInterface();  \n```  \n  \n## Return Value  \n A pointer to the owned COM object.  \n  \n## Exceptions  \n Internally, `QueryInterface` is called on the owned COM object and any error `HRESULT` is converted to an exception by <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A>.  \n  \n## Remarks  \n The `com::ptr` adds a reference to the COM object on the caller's behalf and also keeps its own reference on the COM object. The caller must ultimately release the reference on the returned object or it will never be destroyed.  \n  \n## Example  \n This example implements a CLR class that uses a `com::ptr` to wrap its private member `IXMLDOMDocument` object. The `GetDocument` member function uses `GetInterface` to return a pointer to the COM object.  \n  \n```  \n// comptr_getinterface.cpp  \n// compile with: /clr /link msxml2.lib  \n#include <msxml2.h>  \n#include <msclr\\com\\ptr.h>  \n  \n#import <msxml3.dll> raw_interfaces_only  \n  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \nusing namespace msclr;  \n  \n// a ref class that uses a com::ptr to contain an   \n// IXMLDOMDocument object  \nref class XmlDocument {  \npublic:  \n   // construct the internal com::ptr with a null interface  \n   // and use CreateInstance to fill it  \n   XmlDocument(String^ progid) {  \n      m_ptrDoc.CreateInstance(progid);     \n   }  \n  \n   // add a reference to and return the COM object  \n   // but keep an internal reference to the object  \n   IXMLDOMDocument* GetDocument() {  \n      return m_ptrDoc.GetInterface();  \n   }  \n  \n   // simplified function that only writes the first node  \n   void WriteDocument() {  \n      IXMLDOMNode* pNode = NULL;  \n      BSTR bstr = NULL;  \n  \n      try {  \n         // use operator -> to call XML Doc member  \n         Marshal::ThrowExceptionForHR(m_ptrDoc->get_firstChild(&pNode));  \n         if (NULL != pNode) {  \n            // write out the xml  \n            Marshal::ThrowExceptionForHR(pNode->get_nodeName(&bstr));  \n            String^ strName = gcnew String(bstr);  \n            Console::Write(\"<{0}>\", strName);  \n            ::SysFreeString(bstr);  \n            bstr = NULL;  \n  \n            Marshal::ThrowExceptionForHR(pNode->get_text(&bstr));  \n            Console::Write(gcnew String(bstr));  \n            ::SysFreeString(bstr);  \n            bstr = NULL;  \n  \n            Console::WriteLine(\"</{0}>\", strName);  \n         }  \n      }  \n      finally {  \n         if (NULL != pNode) {  \n            pNode->Release();  \n         }  \n         ::SysFreeString(bstr);  \n      }  \n   }  \n  \n   // note that the destructor will call the com::ptr destructor  \n   // and automatically release the reference to the COM object  \n  \nprivate:  \n   com::ptr<IXMLDOMDocument> m_ptrDoc;  \n};  \n  \n// unmanaged function that loads XML into a raw XML DOM Document object  \nHRESULT LoadXml(IXMLDOMDocument* pDoc, BSTR bstrXml) {  \n   HRESULT hr = S_OK;  \n   VARIANT_BOOL bSuccess;  \n   hr = pDoc->loadXML(bstrXml, &bSuccess);  \n   if (S_OK == hr && !bSuccess) {  \n      hr = E_FAIL;  \n   }  \n   return hr;  \n}  \n  \n// use the ref class to handle an XML DOM Document object  \nint main() {  \n   IXMLDOMDocument* pDoc = NULL;  \n   BSTR bstrXml = NULL;  \n  \n   try {  \n      // create the class from a progid string  \n      XmlDocument doc(\"Msxml2.DOMDocument.3.0\");  \n  \n      bstrXml = ::SysAllocString(L\"<word>persnickety</word>\");  \n      if (NULL == bstrXml) {  \n         throw gcnew OutOfMemoryException(\"bstrXml\");  \n      }  \n      // detach the document object from the ref class  \n      pDoc = doc.GetDocument();  \n      // use unmanaged function and raw object to load xml  \n      Marshal::ThrowExceptionForHR(LoadXml(pDoc, bstrXml));  \n      // release reference to document object (but ref class still references it)  \n      pDoc->Release();  \n      pDoc = NULL;  \n  \n      // call another function on the ref class  \n      doc.WriteDocument();  \n   }  \n   catch (Exception^ e) {  \n      Console::WriteLine(e);     \n   }  \n   finally {  \n      if (NULL != pDoc) {  \n         pDoc->Release();  \n      }  \n  \n   }  \n}  \n```  \n  \n```Output  \n<word>persnickety</word>  \n```  \n  \n## Requirements  \n **Header file** \\<msclr\\com\\ptr.h>  \n  \n **Namespace** msclr::com  \n  \n## See Also  \n [ptr Members](../dotnet/ptr-members.md)   \n [ptr::QueryInterface](../dotnet/ptr-queryinterface.md)"}