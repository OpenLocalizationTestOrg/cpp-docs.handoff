<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">234b4ff6e5c1a8eb7f285bddf7b8653f02a6d466</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\try-throw-and-catch-statements-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a9052737cbac63c26082d202ae1572ba4e760e05</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e7962ed2e9acd8a349ba33ea2e1a0006c99b8a16</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>try, throw, and catch Statements (C++) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>try, throw, and catch Statements (C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>To implement exception handling in C++, you use <ph id="ph1">`try`</ph>, <ph id="ph2">`throw`</ph>, and <ph id="ph3">`catch`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>First, use a <ph id="ph1">`try`</ph> block to enclose one or more statements that might throw an exception.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`throw`</ph> expression signals that an exceptional condition—often, an error—has occurred in a <ph id="ph2">`try`</ph> block.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can use an object of any type as the operand of a <ph id="ph1">`throw`</ph> expression.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Typically, this object is used to communicate information about the error.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In most cases, we recommend that you use the <bpt id="p1">[</bpt>std::exception<ept id="p1">](../standard-library/exception-class.md)</ept> class or one of the derived classes that are defined in the standard library.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>If one of those is not appropriate, we recommend that you derive your own exception class from  <ph id="ph1">`std::exception`</ph>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To handle exceptions that may be thrown, implement one or more <ph id="ph1">`catch`</ph> blocks immediately following a <ph id="ph2">`try`</ph> block.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Each <ph id="ph1">`catch`</ph> block specifies the type of exception it can handle.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This example shows a <ph id="ph1">`try`</ph> block and its handlers.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Assume that <ph id="ph1">`GetNetworkResource()`</ph> acquires data over a network connection and that the two exception types are user-defined classes that derive from <ph id="ph2">`std::exception`</ph>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Notice that the exceptions are caught by <ph id="ph1">`const`</ph> reference in the <ph id="ph2">`catch`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>We recommend that you throw exceptions by value and catch them by const reference.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The code after the <ph id="ph1">`try`</ph> clause is the guarded section of code.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`throw`</ph> expression <bpt id="p1">*</bpt>throws<ept id="p1">*</ept>—that is, raises—an exception.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The code block after the <ph id="ph1">`catch`</ph> clause is the exception handler.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This is the handler that <bpt id="p1">*</bpt>catches<ept id="p1">*</ept> the exception that's thrown if the types in the <ph id="ph1">`throw`</ph> and <ph id="ph2">`catch`</ph> expressions are compatible.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For a list of rules that govern type-matching in <ph id="ph1">`catch`</ph> blocks, see <bpt id="p1">[</bpt>How Catch Blocks are Evaluated<ept id="p1">](../cpp/how-catch-blocks-are-evaluated-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`catch`</ph> statement specifies an ellipsis (...) instead of a type, the <ph id="ph2">`catch`</ph> block handles every type of exception.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When you compile with the <bpt id="p1">[</bpt>/EHa<ept id="p1">](../build/reference/eh-exception-handling-model.md)</ept> option, these can include C structured exceptions and system-generated or application-generated asynchronous exceptions such as memory protection, divide-by-zero, and floating-point violations.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`catch`</ph> blocks are processed in program order to find a matching type, an ellipsis handler must be the last handler for the associated <ph id="ph2">`try`</ph> block.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`catch(...)`</ph> with caution; do not allow a program to continue unless the catch block knows how to handle the specific exception that is caught.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Typically, a <ph id="ph1">`catch(...)`</ph> block is used to log errors and perform special cleanup before program execution is stopped.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`throw`</ph> expression that has no operand re-throws the exception currently being handled.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>We recommend this form when re-throwing the exception, because this preserves the original exception’s polymorphic type information.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Such an expression should only be used in a <ph id="ph1">`catch`</ph> handler or in a function that's called from a <ph id="ph2">`catch`</ph> handler.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The re-thrown exception object is the original exception object, not a copy.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>C++ Exception Handling</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Keywords</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Unhandled C++ Exceptions</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>__uncaught_exception</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>