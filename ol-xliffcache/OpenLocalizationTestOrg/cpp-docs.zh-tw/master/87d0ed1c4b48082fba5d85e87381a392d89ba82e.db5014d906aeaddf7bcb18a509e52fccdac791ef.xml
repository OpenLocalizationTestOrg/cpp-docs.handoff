{"nodes":[{"pos":[12,63],"content":"_InterlockedOr Intrinsic Functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_InterlockedOr Intrinsic Functions | Microsoft Docs","pos":[0,51]}]},{"content":"_InterlockedOr Intrinsic Functions","pos":[2200,2234]},{"content":"Microsoft Specific","pos":[2237,2255]},{"content":"Perform an atomic bitwise or operation on a variable shared by multiple threads.","pos":[2264,2344]},{"content":"Syntax","pos":[2353,2359]},{"content":"Parameters","pos":[4298,4308]},{"content":"[in, out]","pos":[4312,4321]},{"content":"A pointer to the first operand, to be replaced by the result.","pos":[4333,4394]},{"content":"[in]","pos":[4401,4405]},{"content":"The second operand.","pos":[4416,4435]},{"content":"Return Value","pos":[4444,4456]},{"content":"The original value pointed to by the first parameter.","pos":[4460,4513]},{"content":"Requirements","pos":[4522,4534]},{"content":"Intrinsic","pos":[4541,4550]},{"content":"Architecture","pos":[4551,4563]},{"content":"Header","pos":[4564,4570]},{"pos":[4643,4683],"content":", <ph id=\"ph1\">`_InterlockedOr8`</ph>, <ph id=\"ph2\">`_InterlockedOr16`</ph>,","source":", `_InterlockedOr8`, `_InterlockedOr16`, "},{"pos":[4703,4712],"content":"x86, ARM,"},{"content":"intrin.h&gt;","pos":[4779,4788],"source":"intrin.h>"},{"pos":[4813,5043],"content":", <ph id=\"ph1\">`_InterlockedOr_nf`</ph>, <ph id=\"ph2\">`_InterlockedOr_rel`</ph>, <ph id=\"ph3\">`_InterlockedOr8_acq`</ph>, <ph id=\"ph4\">`_InterlockedOr8_nf`</ph>, <ph id=\"ph5\">`_InterlockedOr8_rel`</ph>, <ph id=\"ph6\">`_InterlockedOr16_acq`</ph>, <ph id=\"ph7\">`_InterlockedOr16_nf`</ph>, <ph id=\"ph8\">`_InterlockedOr16_rel`</ph>, <ph id=\"ph9\">`_InterlockedOr64_acq`</ph>, <ph id=\"ph10\">`_InterlockedOr64_nf`</ph>,","source":", `_InterlockedOr_nf`, `_InterlockedOr_rel`, `_InterlockedOr8_acq`, `_InterlockedOr8_nf`, `_InterlockedOr8_rel`, `_InterlockedOr16_acq`, `_InterlockedOr16_nf`, `_InterlockedOr16_rel`, `_InterlockedOr64_acq`, `_InterlockedOr64_nf`, "},{"content":"ARM","pos":[5067,5070]},{"content":"intrin.h&gt;","pos":[5073,5082],"source":"intrin.h>"},{"pos":[5106,5152],"content":", <ph id=\"ph1\">`_InterlockedOr8_np`</ph>, <ph id=\"ph2\">`_InterlockedOr16_np`</ph>,","source":", `_InterlockedOr8_np`, `_InterlockedOr16_np`, "},{"content":"intrin.h&gt;","pos":[5241,5250],"source":"intrin.h>"},{"pos":[5282,5343],"content":", <ph id=\"ph1\">`_InterlockedOr_HLERelease`</ph>, <ph id=\"ph2\">`_InterlockedOr64_HLEAcquire`</ph>,","source":", `_InterlockedOr_HLERelease`, `_InterlockedOr64_HLEAcquire`, "},{"pos":[5374,5378],"content":"x86,"},{"content":"immintrin.h&gt;","pos":[5445,5457],"source":"immintrin.h>"},{"content":"Remarks","pos":[5467,5474]},{"content":"The number in the name of each function specifies the bit size of the arguments.","pos":[5478,5558]},{"content":"On ARM platforms, use the intrinsics with <ph id=\"ph1\">`_acq`</ph> and <ph id=\"ph2\">`_rel`</ph> suffixes if you need acquire and release semantics, such as at the beginning and end of a critical section.","pos":[5565,5732],"source":"On ARM platforms, use the intrinsics with `_acq` and `_rel` suffixes if you need acquire and release semantics, such as at the beginning and end of a critical section."},{"content":"The ARM intrinsics with an <ph id=\"ph1\">`_nf`</ph> (\"no fence\") suffix do not act as a memory barrier.","pos":[5733,5817],"source":" The ARM intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier."},{"pos":[5824,5950],"content":"The intrinsics with an <ph id=\"ph1\">`_np`</ph> (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler.","source":"The intrinsics with an `_np` (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler."},{"content":"On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with <ph id=\"ph1\">`_HLEAcquire`</ph> and <ph id=\"ph2\">`_HLERelease`</ph> suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware.","pos":[5957,6201],"source":"On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware."},{"content":"If these intrinsics are called on platforms that do not support HLE, the hint is ignored.","pos":[6202,6291]},{"content":"Example","pos":[6300,6307]},{"content":"END Microsoft Specific","pos":[6719,6741]},{"content":"See Also","pos":[6750,6758]},{"content":"Compiler Intrinsics","pos":[6763,6782]},{"content":"Conflicts with the x86 Compiler","pos":[6827,6858]}],"content":"---\ntitle: \"_InterlockedOr Intrinsic Functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_InterlockedOr8_nf\"\n  - \"_InterlockedOr_HLEAcquire\"\n  - \"_InterlockedOr16_nf\"\n  - \"_InterlockedOr64\"\n  - \"_InterlockedOr8_np\"\n  - \"_InterlockedOr64_cpp\"\n  - \"_InterlockedOr8_acq\"\n  - \"_InterlockedOr_nf\"\n  - \"_InterlockedOr64_acq\"\n  - \"_InterlockedOr_np\"\n  - \"_InterlockedOr8\"\n  - \"_InterlockedOr\"\n  - \"_InterlockedOr64_np\"\n  - \"_InterlockedOr_acq\"\n  - \"_InterlockedOr64_HLERelease\"\n  - \"_InterlockedOr16_np\"\n  - \"_InterlockedOr_cpp\"\n  - \"_InterlockedOr8_rel\"\n  - \"_InterlockedOr64_rel\"\n  - \"_InterlockedOr16_acq\"\n  - \"_InterlockedOr_rel\"\n  - \"_InterlockedOr16_rel\"\n  - \"_InterlockedOr_HLERelease\"\n  - \"_InterlockedOr64_HLEAcquire\"\n  - \"_InterlockedOr16\"\n  - \"_InterlockedOr64_nf\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"_InterlockedOr_acq intrinsic\"\n  - \"InterlockedOr64 intrinsic\"\n  - \"_InterlockedOr_nf intrinsic\"\n  - \"_InterlockedOr intrinsic\"\n  - \"_InterlockedOr64_HLERelease intrinsic\"\n  - \"_InterlockedOr8_rel intrinsic\"\n  - \"_InterlockedOr8_np intrinsic\"\n  - \"_InterlockedOr64_nf intrinsic\"\n  - \"_InterlockedOr_HLERelease intrinsic\"\n  - \"_InterlockedOr16_np intrinsic\"\n  - \"InterlockedOr intrinsic\"\n  - \"_InterlockedOr8_nf intrinsic\"\n  - \"_InterlockedOr16_nf intrinsic\"\n  - \"_InterlockedOr8_acq intrinsic\"\n  - \"_InterlockedOr64 intrinsic\"\n  - \"_InterlockedOr16 intrinsic\"\n  - \"_InterlockedOr64_acq intrinsic\"\n  - \"_InterlockedOr64_HLEAcquire intrinsic\"\n  - \"_InterlockedOr_np intrinsic\"\n  - \"_InterlockedOr64_rel intrinsic\"\n  - \"_InterlockedOr64_np intrinsic\"\n  - \"_InterlockedOr_rel intrinsic\"\n  - \"_InterlockedOr8 intrinsic\"\n  - \"_InterlockedOr16_acq intrinsic\"\n  - \"_InterlockedOr16_rel intrinsic\"\n  - \"_InterlockedOr_HLEAcquire intrinsic\"\nms.assetid: 5f265240-7af8-44b7-b952-19f3a9c56186\ncaps.latest.revision: 19\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _InterlockedOr Intrinsic Functions\n**Microsoft Specific**  \n  \n Perform an atomic bitwise or operation on a variable shared by multiple threads.  \n  \n## Syntax  \n  \n```  \nlong _InterlockedOr(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedOr_acq(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedOr_HLEAcquire(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedOr_HLERelease(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedOr_nf(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedOr_np(  \n   long volatile * Value,  \n   long Mask  \n);  \nlong _InterlockedOr_rel(  \n   long volatile * Value,  \n   long Mask  \n);  \nchar _InterlockedOr8(  \n   char volatile * Value,  \n   long Mask  \n);  \nchar _InterlockedOr8_acq(  \n   char volatile * Value,  \n   char Mask  \n);  \nchar _InterlockedOr8_nf(  \n   char volatile * Value,  \n   char Mask  \n);  \nchar _InterlockedOr8_np(  \n   char volatile * Value,  \n   char Mask  \n);  \nchar _InterlockedOr8_rel(  \n   char volatile * Value,  \n   char Mask  \n);  \nshort _InterlockedOr16(  \n   short volatile * Value,  \n   short Mask  \n);  \nshort _InterlockedOr16_acq(  \n   short volatile * Value,  \n   short Mask  \n);  \nshort _InterlockedOr16_nf(  \n   short volatile * Value,  \n   short Mask  \n);  \nshort _InterlockedOr16_np(  \n   short volatile * Value,  \n   short Mask  \n);  \nshort _InterlockedOr16_rel(  \n   short volatile * Value,  \n   short Mask  \n);  \n__int64 _InterlockedOr64(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);  \n__int64 _InterlockedOr64_acq(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);   \n__int64 _InterlockedOr64_HLEAcquire(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);  \n__int64 _InterlockedOr64_HLERelease(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);   \n__int64 _InterlockedOr64_nf(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);  \n__int64 _InterlockedOr64_np(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);  \n__int64 _InterlockedOr64_rel(  \n   __int64 volatile * Value,  \n   __int64 Mask  \n);  \n```  \n  \n#### Parameters  \n [in, out] `Value`  \n A pointer to the first operand, to be replaced by the result.  \n  \n [in] `Mask`  \n The second operand.  \n  \n## Return Value  \n The original value pointed to by the first parameter.  \n  \n## Requirements  \n  \n|Intrinsic|Architecture|Header|  \n|---------------|------------------|------------|  \n|`_InterlockedOr`, `_InterlockedOr8`, `_InterlockedOr16`, `_InterlockedOr64`|x86, ARM, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_InterlockedOr_acq`, `_InterlockedOr_nf`, `_InterlockedOr_rel`, `_InterlockedOr8_acq`, `_InterlockedOr8_nf`, `_InterlockedOr8_rel`, `_InterlockedOr16_acq`, `_InterlockedOr16_nf`, `_InterlockedOr16_rel`, `_InterlockedOr64_acq`, `_InterlockedOr64_nf`, `_InterlockedOr64_rel`|ARM|\\<intrin.h>|  \n|`_InterlockedOr_np`, `_InterlockedOr8_np`, `_InterlockedOr16_np`, `_InterlockedOr64_np`|[!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<intrin.h>|  \n|`_InterlockedOr_HLEAcquire`, `_InterlockedOr_HLERelease`, `_InterlockedOr64_HLEAcquire`, `_InterlockedOr64_HLERelease`|x86, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]|\\<immintrin.h>|  \n  \n## Remarks  \n The number in the name of each function specifies the bit size of the arguments.  \n  \n On ARM platforms, use the intrinsics with `_acq` and `_rel` suffixes if you need acquire and release semantics, such as at the beginning and end of a critical section. The ARM intrinsics with an `_nf` (\"no fence\") suffix do not act as a memory barrier.  \n  \n The intrinsics with an `_np` (\"no prefetch\") suffix prevent a possible prefetch operation from being inserted by the compiler.  \n  \n On Intel platforms that support Hardware Lock Elision (HLE) instructions, the intrinsics with `_HLEAcquire` and `_HLERelease` suffixes include a hint to the processor that can accelerate performance by eliminating a lock write step in hardware. If these intrinsics are called on platforms that do not support HLE, the hint is ignored.  \n  \n## Example  \n  \n```  \n// _InterlockedOr.cpp  \n#include <stdio.h>  \n#include <intrin.h>  \n  \n#pragma intrinsic(_InterlockedOr)  \n  \nint main()  \n{  \n        long data1 = 0xFF00FF00;  \n        long data2 = 0x00FFFF00;  \n        long retval;  \n        retval = _InterlockedOr(&data1, data2);  \n        printf_s(\"0x%x 0x%x 0x%x\", data1, data2, retval);   \n}  \n```  \n  \n```Output  \n0xffffff00 0xffff00 0xff00ff00  \n```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Compiler Intrinsics](../intrinsics/compiler-intrinsics.md)   \n [Conflicts with the x86 Compiler](../build/conflicts-with-the-x86-compiler.md)"}