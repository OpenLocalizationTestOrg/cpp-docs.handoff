{"nodes":[{"pos":[12,79],"content":"Recordset: Dynamically Binding Data Columns (ODBC) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Recordset: Dynamically Binding Data Columns (ODBC) | Microsoft Docs","pos":[0,67]}]},{"content":"Recordset: Dynamically Binding Data Columns (ODBC)","pos":[810,860]},{"content":"This topic applies to the MFC ODBC classes.","pos":[861,904]},{"content":"Recordsets manage binding table columns that you specify at design time, but there are cases when you might want to bind columns that were unknown to you at design time.","pos":[911,1080]},{"content":"This topic explains:","pos":[1081,1101]},{"pos":[1111,1224],"content":"<bpt id=\"p1\">[</bpt>When you might want to bind columns dynamically to a recordset<ept id=\"p1\">](#_core_when_you_might_bind_columns_dynamically)</ept>.","source":"[When you might want to bind columns dynamically to a recordset](#_core_when_you_might_bind_columns_dynamically)."},{"pos":[1234,1320],"content":"<bpt id=\"p1\">[</bpt>How to bind columns dynamically at run time<ept id=\"p1\">](#_core_how_to_bind_columns_dynamically)</ept>.","source":"[How to bind columns dynamically at run time](#_core_how_to_bind_columns_dynamically)."},{"pos":[1328,1694],"content":"[!NOTE]\n This topic applies to objects derived from `CRecordset` in which bulk row fetching has not been implemented. The techniques described generally are not recommended if you are using bulk row fetching. For more information about bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" This topic applies to objects derived from `CRecordset` in which bulk row fetching has not been implemented. The techniques described generally are not recommended if you are using bulk row fetching. For more information about bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,364],"nodes":[{"content":"This topic applies to objects derived from <ph id=\"ph1\">`CRecordset`</ph> in which bulk row fetching has not been implemented.","pos":[1,109],"source":" This topic applies to objects derived from `CRecordset` in which bulk row fetching has not been implemented."},{"content":"The techniques described generally are not recommended if you are using bulk row fetching.","pos":[110,200]},{"content":"For more information about bulk row fetching, see <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[201,356],"source":" For more information about bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"pos":[1765,1804],"content":"When You Might Bind Columns Dynamically"},{"content":"At design time, the MFC Application Wizard or <bpt id=\"p1\">[</bpt>MFC ODBC Consumer Wizard<ept id=\"p1\">](../../mfc/reference/adding-an-mfc-odbc-consumer.md)</ept> (from <bpt id=\"p2\">**</bpt>Add Class<ept id=\"p2\">**</ept>) creates recordset classes based on the known tables and columns on your data source.","pos":[1808,2038],"source":"At design time, the MFC Application Wizard or [MFC ODBC Consumer Wizard](../../mfc/reference/adding-an-mfc-odbc-consumer.md) (from **Add Class**) creates recordset classes based on the known tables and columns on your data source."},{"content":"Databases can change between when you design them and later when your application uses those tables and columns at run time.","pos":[2039,2163]},{"content":"You or another user might add or drop a table or add or drop columns from a table that your application's recordset relies on.","pos":[2164,2290]},{"content":"This probably is not a concern for all data-access applications, but if it is for yours, how can you cope with changes in the database schema, other than by redesigning and recompiling?","pos":[2291,2476]},{"content":"The purpose of this topic is to answer that question.","pos":[2477,2530]},{"content":"This topic describes the most common case in which you might bind columns dynamically — having begun with a recordset based on a known database schema, you want to handle additional columns at run time.","pos":[2537,2739]},{"content":"The topic further assumes that the additional columns map to <ph id=\"ph1\">`CString`</ph> field data members, the most common case, although suggestions are supplied to help you manage other data types.","pos":[2740,2923],"source":" The topic further assumes that the additional columns map to `CString` field data members, the most common case, although suggestions are supplied to help you manage other data types."},{"content":"With a small amount of extra code, you can:","pos":[2930,2973]},{"pos":[2983,3090],"content":"<bpt id=\"p1\">[</bpt>Determine what columns are available at run time<ept id=\"p1\">](#_core_to_determine_the_columns_in_a_table_at_run_time)</ept>.","source":"[Determine what columns are available at run time](#_core_to_determine_the_columns_in_a_table_at_run_time)."},{"pos":[3100,3196],"content":"<bpt id=\"p1\">[</bpt>Bind additional columns to your recordset dynamically, at run time<ept id=\"p1\">](#_core_adding_the_columns)</ept>.","source":"[Bind additional columns to your recordset dynamically, at run time](#_core_adding_the_columns)."},{"content":"Your recordset still contains data members for the columns you knew about at design time.","pos":[3203,3292]},{"content":"It also contains a small amount of extra code that dynamically determines whether any new columns have been added to your target table and, if so, binds these new columns to dynamically allocated storage (rather than to recordset data members).","pos":[3293,3537]},{"content":"This topic does not cover other dynamic binding cases, such as dropped tables or columns.","pos":[3544,3633]},{"content":"For those cases, you need to use ODBC API calls more directly.","pos":[3634,3696]},{"content":"For information, see the ODBC SDK <bpt id=\"p1\">*</bpt>Programmer's Reference<ept id=\"p1\">*</ept> on the MSDN Library CD.","pos":[3697,3779],"source":" For information, see the ODBC SDK *Programmer's Reference* on the MSDN Library CD."},{"pos":[3842,3873],"content":"How to Bind Columns Dynamically"},{"content":"To bind columns dynamically, you must know (or be able to determine) the names of the additional columns.","pos":[3877,3982]},{"content":"You must also allocate storage for the additional field data members, specify their names and their types, and specify the number of columns you are adding.","pos":[3983,4139]},{"content":"The following discussion mentions two different recordsets.","pos":[4146,4205]},{"content":"The first is the main recordset that selects records from the target table.","pos":[4206,4281]},{"content":"The second is a special column recordset used to get information about the columns in your target table.","pos":[4282,4386]},{"pos":[4438,4453],"content":"General Process"},{"content":"At the most general level, you follow these steps:","pos":[4457,4507]},{"content":"Construct your main recordset object.","pos":[4517,4554]},{"pos":[4565,4708],"content":"Optionally, pass a pointer to an open <ph id=\"ph1\">`CDatabase`</ph> object or be able to supply connection information to the column recordset in some other way.","source":"Optionally, pass a pointer to an open `CDatabase` object or be able to supply connection information to the column recordset in some other way."},{"content":"Take steps to add columns dynamically.","pos":[4718,4756]},{"content":"See the process described in Adding the Columns below.","pos":[4767,4821]},{"content":"Open your main recordset.","pos":[4831,4856]},{"content":"The recordset selects records and uses record field exchange (RFX) to bind both the static columns (those mapped to recordset field data members) and the dynamic columns (mapped to extra storage that you allocate).","pos":[4867,5081]},{"pos":[5132,5150],"content":"Adding the Columns"},{"content":"Dynamically binding added columns at run time requires the following steps:","pos":[5154,5229]},{"content":"Determine at run time what columns are in the target table.","pos":[5239,5298]},{"content":"Extract from that information a list of the columns that have been added to the table since your recordset class was designed.","pos":[5299,5425]},{"content":"A good approach is to use a column recordset class designed to query the data source for column information for the target table (such as column name and data type).","pos":[5436,5601]},{"content":"Provide storage for the new field data members.","pos":[5611,5658]},{"content":"Because your main recordset class does not have field data members for unknown columns, you must provide a place to store the names, result values, and possibly data type information (if the columns are different data types).","pos":[5659,5884]},{"content":"One approach is to build one or more dynamic lists, one for the new columns' names, another for their result values, and a third for their data types (if necessary).","pos":[5895,6060]},{"content":"These lists, particularly the value list, provide the information and the necessary storage for binding.","pos":[6061,6165]},{"content":"The following figure illustrates building the lists.","pos":[6166,6218]},{"content":"Building lists of columns to bind dynamically","pos":[6231,6276]},{"content":"Building Lists of Columns to Bind Dynamically","pos":[6325,6370]},{"content":"Add an RFX function call in your main recordset's <ph id=\"ph1\">`DoFieldExchange`</ph> function for each added column.","pos":[6380,6479],"source":"Add an RFX function call in your main recordset's `DoFieldExchange` function for each added column."},{"content":"These RFX calls do the work of fetching a record, including the additional columns, and binding the columns to recordset data members or to your dynamically supplied storage for them.","pos":[6480,6663]},{"content":"One approach is to add a loop to your main recordset's <ph id=\"ph1\">`DoFieldExchange`</ph> function that loops through your list of new columns, calling the appropriate RFX function for each column in the list.","pos":[6674,6866],"source":"One approach is to add a loop to your main recordset's `DoFieldExchange` function that loops through your list of new columns, calling the appropriate RFX function for each column in the list."},{"content":"On each RFX call, pass a column name from the column name list and a storage location in the corresponding member of the result value list.","pos":[6867,7006]},{"pos":[7055,7071],"content":"Lists of Columns"},{"content":"The four lists you need to work with are shown in the following table.","pos":[7075,7145]},{"content":"Current-Table-Columns (List 1 in the illustration)","pos":[7153,7203]},{"content":"A list of the columns currently in the table on the data source.","pos":[7237,7301]},{"content":"This list might match the list of columns currently bound in your recordset.","pos":[7302,7378]},{"content":"Bound-Recordset-Columns (List 2 in the illustration)","pos":[7386,7438]},{"content":"A list of the columns bound in your recordset.","pos":[7472,7518]},{"content":"These columns already have RFX statements in your <ph id=\"ph1\">`DoFieldExchange`</ph> function.","pos":[7519,7596],"source":" These columns already have RFX statements in your `DoFieldExchange` function."},{"content":"Columns-To-Bind-Dynamically (List 3 in the illustration)","pos":[7604,7660]},{"content":"A list of columns in the table but not in your recordset.","pos":[7694,7751]},{"content":"These are the columns you want to bind dynamically.","pos":[7752,7803]},{"content":"Dynamic-Column-Values (List 4 in the illustration)","pos":[7811,7861]},{"content":"A list containing storage for the values retrieved from the columns you bind dynamically.","pos":[7895,7984]},{"content":"Elements of this list correspond to those in Columns-to-Bind-Dynamically, one to one.","pos":[7985,8070]},{"pos":[8122,8141],"content":"Building Your Lists"},{"content":"With a general strategy in mind, you can turn to the details.","pos":[8145,8206]},{"content":"The procedures in the rest of this topic show you how to build the lists shown in <bpt id=\"p1\">[</bpt>Lists of Columns<ept id=\"p1\">](#_core_lists_of_columns)</ept>.","pos":[8207,8333],"source":" The procedures in the rest of this topic show you how to build the lists shown in [Lists of Columns](#_core_lists_of_columns)."},{"content":"The procedures guide you through:","pos":[8334,8367]},{"pos":[8377,8500],"content":"<bpt id=\"p1\">[</bpt>Determining the names of columns not in your recordset<ept id=\"p1\">](#_core_determining_which_table_columns_are_not_in_your_recordset)</ept>.","source":"[Determining the names of columns not in your recordset](#_core_determining_which_table_columns_are_not_in_your_recordset)."},{"pos":[8510,8621],"content":"<bpt id=\"p1\">[</bpt>Providing dynamic storage for columns newly added to the table<ept id=\"p1\">](#_core_providing_storage_for_the_new_columns)</ept>.","source":"[Providing dynamic storage for columns newly added to the table](#_core_providing_storage_for_the_new_columns)."},{"pos":[8631,8723],"content":"<bpt id=\"p1\">[</bpt>Dynamically adding RFX calls for new columns<ept id=\"p1\">](#_core_adding_rfx_calls_to_bind_the_columns)</ept>.","source":"[Dynamically adding RFX calls for new columns](#_core_adding_rfx_calls_to_bind_the_columns)."},{"pos":[8813,8870],"content":"Determining Which Table Columns Are Not in Your Recordset"},{"content":"Build a list (Bound-Recordset-Columns, as in List 2 in the <bpt id=\"p1\">[</bpt>illustration<ept id=\"p1\">](#_core_illustration_dynamic)</ept>) that contains a list of the columns already bound in your main recordset.","pos":[8874,9051],"source":"Build a list (Bound-Recordset-Columns, as in List 2 in the [illustration](#_core_illustration_dynamic)) that contains a list of the columns already bound in your main recordset."},{"content":"Then build a list (Columns-to-Bind-Dynamically, derived from Current-Table-Columns and Bound-Recordset-Columns) that contains column names that are in the table on the data source but not in your main recordset.","pos":[9052,9263]},{"content":"To determine the names of columns not in the recordset (Columns-to-Bind-Dynamically)","pos":[9275,9359]},{"content":"Build a list (Bound-Recordset-Columns) of the columns already bound in your main recordset.","pos":[9369,9460]},{"content":"One approach is to create Bound-Recordset-Columns at design time.","pos":[9471,9536]},{"content":"You can visually examine the RFX function calls in the recordset's <ph id=\"ph1\">`DoFieldExchange`</ph> function to get these names.","pos":[9537,9650],"source":" You can visually examine the RFX function calls in the recordset's `DoFieldExchange` function to get these names."},{"content":"Then, set up your list as an array initialized with the names.","pos":[9651,9713]},{"content":"For example, the <bpt id=\"p1\">[</bpt>illustration<ept id=\"p1\">](#_core_illustration_dynamic)</ept> shows Bound-Recordset-Columns (List 2) with three elements.","pos":[9724,9844],"source":"For example, the [illustration](#_core_illustration_dynamic) shows Bound-Recordset-Columns (List 2) with three elements."},{"content":"Bound-Recordset-Columns is missing the Phone column shown in Current-Table-Columns (List 1).","pos":[9845,9937]},{"content":"Compare Current-Table-Columns and Bound-Recordset-Columns to build a list (Columns-to-Bind-Dynamically) of the columns not already bound in your main recordset.","pos":[9947,10107]},{"content":"One approach is to loop through your list of columns in the table at run time (Current-Table-Columns) and your list of columns already bound in your recordset (Bound-Recordset-Columns) in parallel.","pos":[10118,10315]},{"content":"Into Columns-to-Bind-Dynamically put any names in Current-Table-Columns that do not appear in Bound-Recordset-Columns.","pos":[10316,10434]},{"pos":[10445,10668],"content":"For example, the <bpt id=\"p1\">[</bpt>illustration<ept id=\"p1\">](#_core_illustration_dynamic)</ept> shows Columns-to-Bind-Dynamically (List 3) with one element: the Phone column found in Current-Table-Columns (List 1) but not in Bound-Recordset-Columns (List 2).","source":"For example, the [illustration](#_core_illustration_dynamic) shows Columns-to-Bind-Dynamically (List 3) with one element: the Phone column found in Current-Table-Columns (List 1) but not in Bound-Recordset-Columns (List 2)."},{"pos":[10678,10931],"content":"Build a list of Dynamic-Column-Values (as in List 4 in the <bpt id=\"p1\">[</bpt>illustration<ept id=\"p1\">](#_core_illustration_dynamic)</ept>) in which to store the data values corresponding to each column name stored in your list of columns to bind dynamically (Columns-to-Bind-Dynamically).","source":"Build a list of Dynamic-Column-Values (as in List 4 in the [illustration](#_core_illustration_dynamic)) in which to store the data values corresponding to each column name stored in your list of columns to bind dynamically (Columns-to-Bind-Dynamically)."},{"content":"The elements of this list play the role of new recordset field data members.","pos":[10942,11018]},{"content":"They are the storage locations to which the dynamic columns are bound.","pos":[11019,11089]},{"content":"For descriptions of the lists, see <bpt id=\"p1\">[</bpt>Lists of Columns<ept id=\"p1\">](#_core_lists_of_columns)</ept>.","pos":[11090,11169],"source":" For descriptions of the lists, see [Lists of Columns](#_core_lists_of_columns)."},{"pos":[11239,11276],"content":"Providing Storage for the New Columns"},{"content":"Next, set up storage locations for the columns to be bound dynamically.","pos":[11280,11351]},{"content":"The idea is to provide a list element in which to store each column's value.","pos":[11352,11428]},{"content":"These storage locations parallel the recordset member variables, which store the normally bound columns.","pos":[11429,11533]},{"content":"To provide dynamic storage for new columns (Dynamic-Column-Values)","pos":[11545,11611]},{"content":"Build Dynamic-Column-Values, parallel to Columns-to-Bind-Dynamically, to contain the value of the data in each column.","pos":[11621,11739]},{"pos":[11750,11955],"content":"For example, the <bpt id=\"p1\">[</bpt>illustration<ept id=\"p1\">](#_core_illustration_dynamic)</ept> shows Dynamic-Column-Values (List 4) with one element: a <ph id=\"ph1\">`CString`</ph> object containing the actual phone number for the current record: \"555-1212\".","source":"For example, the [illustration](#_core_illustration_dynamic) shows Dynamic-Column-Values (List 4) with one element: a `CString` object containing the actual phone number for the current record: \"555-1212\"."},{"content":"In the most common case, Dynamic-Column-Values has elements of type <ph id=\"ph1\">`CString`</ph>.","pos":[11966,12044],"source":"In the most common case, Dynamic-Column-Values has elements of type `CString`."},{"content":"If you are dealing with columns of varying data types, you need a list that can contain elements of a variety of types.","pos":[12045,12164]},{"content":"The result of the preceding procedures is two main lists: Columns-to-Bind-Dynamically containing the names of columns and Dynamic-Column-Values containing the values in the columns for the current record.","pos":[12171,12375]},{"pos":[12383,12783],"content":"[!TIP]\n If the new columns are not all of the same data type, you might want an extra parallel list containing items that somehow define the type of each corresponding element in the column list. (You can use the values **AFX_RFX_BOOL**, **AFX_RFX_BYTE**, and so on, for this if you want. These constants are defined in AFXDB.H.) Choose a list type based on how you represent the column data types.","leadings":["","> "],"nodes":[{"content":" If the new columns are not all of the same data type, you might want an extra parallel list containing items that somehow define the type of each corresponding element in the column list. (You can use the values **AFX_RFX_BOOL**, **AFX_RFX_BYTE**, and so on, for this if you want. These constants are defined in AFXDB.H.) Choose a list type based on how you represent the column data types.","pos":[7,398],"nodes":[{"content":"If the new columns are not all of the same data type, you might want an extra parallel list containing items that somehow define the type of each corresponding element in the column list.","pos":[1,188]},{"content":"(You can use the values <bpt id=\"p1\">**</bpt>AFX_RFX_BOOL<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>AFX_RFX_BYTE<ept id=\"p2\">**</ept>, and so on, for this if you want.","pos":[189,281],"source":" (You can use the values **AFX_RFX_BOOL**, **AFX_RFX_BYTE**, and so on, for this if you want."},{"content":"These constants are defined in AFXDB.H.) Choose a list type based on how you represent the column data types.","pos":[282,391]}]}]},{"pos":[12852,12888],"content":"Adding RFX Calls to Bind the Columns"},{"pos":[12892,13018],"content":"Finally, arrange for the dynamic binding to occur by placing RFX calls for the new columns in your <ph id=\"ph1\">`DoFieldExchange`</ph> function.","source":"Finally, arrange for the dynamic binding to occur by placing RFX calls for the new columns in your `DoFieldExchange` function."},{"content":"To dynamically add RFX calls for new columns","pos":[13030,13074]},{"content":"In your main recordset's <ph id=\"ph1\">`DoFieldExchange`</ph> member function, add code that loops through your list of new columns (Columns-to-Bind-Dynamically).","pos":[13084,13227],"source":"In your main recordset's `DoFieldExchange` member function, add code that loops through your list of new columns (Columns-to-Bind-Dynamically)."},{"content":"In each loop, extract a column name from Columns-to-Bind-Dynamically and a result value for the column from Dynamic-Column-Values.","pos":[13228,13358]},{"content":"Pass these items to an RFX function call appropriate to the data type of the column.","pos":[13359,13443]},{"content":"For descriptions of the lists, see <bpt id=\"p1\">[</bpt>Lists of Columns<ept id=\"p1\">](#_core_lists_of_columns)</ept>.","pos":[13444,13523],"source":" For descriptions of the lists, see [Lists of Columns](#_core_lists_of_columns)."},{"pos":[13530,13804],"content":"In the common case, in your <ph id=\"ph1\">`RFX_Text`</ph> function calls you extract <ph id=\"ph2\">`CString`</ph> objects from the lists, as in the following lines of code, where Columns-to-Bind-Dynamically is a <ph id=\"ph3\">`CStringList`</ph> called <ph id=\"ph4\">`m_listName`</ph> and Dynamic-Column-Values is a <ph id=\"ph5\">`CStringList`</ph> called <ph id=\"ph6\">`m_listValue`</ph>:","source":"In the common case, in your `RFX_Text` function calls you extract `CString` objects from the lists, as in the following lines of code, where Columns-to-Bind-Dynamically is a `CStringList` called `m_listName` and Dynamic-Column-Values is a `CStringList` called `m_listValue`:"},{"pos":[13938,14085],"content":"For more information about RFX functions, see <bpt id=\"p1\">[</bpt>Macros and Globals<ept id=\"p1\">](../../mfc/reference/mfc-macros-and-globals.md)</ept> in the <bpt id=\"p2\">*</bpt>Class Library Reference<ept id=\"p2\">*</ept>.","source":"For more information about RFX functions, see [Macros and Globals](../../mfc/reference/mfc-macros-and-globals.md) in the *Class Library Reference*."},{"pos":[14093,14235],"content":"[!TIP]\n If the new columns are different data types, use a switch statement in your loop to call the appropriate RFX function for each type.","leadings":["","> "],"nodes":[{"content":"If the new columns are different data types, use a switch statement in your loop to call the appropriate RFX function for each type.","pos":[8,140]}]},{"content":"When the framework calls <ph id=\"ph1\">`DoFieldExchange`</ph> during the <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> process to bind columns to the recordset, the RFX calls for the static columns bind those columns.","pos":[14242,14403],"source":"When the framework calls `DoFieldExchange` during the **Open** process to bind columns to the recordset, the RFX calls for the static columns bind those columns."},{"content":"Then your loop repeatedly calls RFX functions for the dynamic columns.","pos":[14404,14474]},{"content":"See Also","pos":[14483,14491]},{"content":"Recordset (ODBC)","pos":[14496,14512]},{"content":"Recordset: Working with Large Data Items (ODBC)","pos":[14554,14601]}],"content":"---\ntitle: \"Recordset: Dynamically Binding Data Columns (ODBC) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"ODBC recordsets [C++], binding columns dynamically\"\n  - \"data binding [C++], recordset columns\"\n  - \"recordsets [C++], binding data\"\n  - \"data binding [C++], columns in recordsets\"\n  - \"columns [C++], binding to recordsets\"\nms.assetid: bff67254-d953-4ae4-9716-91c348cb840b\ncaps.latest.revision: 8\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Recordset: Dynamically Binding Data Columns (ODBC)\nThis topic applies to the MFC ODBC classes.  \n  \n Recordsets manage binding table columns that you specify at design time, but there are cases when you might want to bind columns that were unknown to you at design time. This topic explains:  \n  \n-   [When you might want to bind columns dynamically to a recordset](#_core_when_you_might_bind_columns_dynamically).  \n  \n-   [How to bind columns dynamically at run time](#_core_how_to_bind_columns_dynamically).  \n  \n> [!NOTE]\n>  This topic applies to objects derived from `CRecordset` in which bulk row fetching has not been implemented. The techniques described generally are not recommended if you are using bulk row fetching. For more information about bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n##  <a name=\"_core_when_you_might_bind_columns_dynamically\"></a> When You Might Bind Columns Dynamically  \n At design time, the MFC Application Wizard or [MFC ODBC Consumer Wizard](../../mfc/reference/adding-an-mfc-odbc-consumer.md) (from **Add Class**) creates recordset classes based on the known tables and columns on your data source. Databases can change between when you design them and later when your application uses those tables and columns at run time. You or another user might add or drop a table or add or drop columns from a table that your application's recordset relies on. This probably is not a concern for all data-access applications, but if it is for yours, how can you cope with changes in the database schema, other than by redesigning and recompiling? The purpose of this topic is to answer that question.  \n  \n This topic describes the most common case in which you might bind columns dynamically — having begun with a recordset based on a known database schema, you want to handle additional columns at run time. The topic further assumes that the additional columns map to `CString` field data members, the most common case, although suggestions are supplied to help you manage other data types.  \n  \n With a small amount of extra code, you can:  \n  \n-   [Determine what columns are available at run time](#_core_to_determine_the_columns_in_a_table_at_run_time).  \n  \n-   [Bind additional columns to your recordset dynamically, at run time](#_core_adding_the_columns).  \n  \n Your recordset still contains data members for the columns you knew about at design time. It also contains a small amount of extra code that dynamically determines whether any new columns have been added to your target table and, if so, binds these new columns to dynamically allocated storage (rather than to recordset data members).  \n  \n This topic does not cover other dynamic binding cases, such as dropped tables or columns. For those cases, you need to use ODBC API calls more directly. For information, see the ODBC SDK *Programmer's Reference* on the MSDN Library CD.  \n  \n##  <a name=\"_core_how_to_bind_columns_dynamically\"></a> How to Bind Columns Dynamically  \n To bind columns dynamically, you must know (or be able to determine) the names of the additional columns. You must also allocate storage for the additional field data members, specify their names and their types, and specify the number of columns you are adding.  \n  \n The following discussion mentions two different recordsets. The first is the main recordset that selects records from the target table. The second is a special column recordset used to get information about the columns in your target table.  \n  \n###  <a name=\"_core_the_general_process\"></a> General Process  \n At the most general level, you follow these steps:  \n  \n1.  Construct your main recordset object.  \n  \n     Optionally, pass a pointer to an open `CDatabase` object or be able to supply connection information to the column recordset in some other way.  \n  \n2.  Take steps to add columns dynamically.  \n  \n     See the process described in Adding the Columns below.  \n  \n3.  Open your main recordset.  \n  \n     The recordset selects records and uses record field exchange (RFX) to bind both the static columns (those mapped to recordset field data members) and the dynamic columns (mapped to extra storage that you allocate).  \n  \n###  <a name=\"_core_adding_the_columns\"></a> Adding the Columns  \n Dynamically binding added columns at run time requires the following steps:  \n  \n1.  Determine at run time what columns are in the target table. Extract from that information a list of the columns that have been added to the table since your recordset class was designed.  \n  \n     A good approach is to use a column recordset class designed to query the data source for column information for the target table (such as column name and data type).  \n  \n2.  Provide storage for the new field data members. Because your main recordset class does not have field data members for unknown columns, you must provide a place to store the names, result values, and possibly data type information (if the columns are different data types).  \n  \n     One approach is to build one or more dynamic lists, one for the new columns' names, another for their result values, and a third for their data types (if necessary). These lists, particularly the value list, provide the information and the necessary storage for binding. The following figure illustrates building the lists.  \n  \n     ![Building lists of columns to bind dynamically](../../data/odbc/media/vc37w61.gif \"vc37w61\")  \nBuilding Lists of Columns to Bind Dynamically  \n  \n3.  Add an RFX function call in your main recordset's `DoFieldExchange` function for each added column. These RFX calls do the work of fetching a record, including the additional columns, and binding the columns to recordset data members or to your dynamically supplied storage for them.  \n  \n     One approach is to add a loop to your main recordset's `DoFieldExchange` function that loops through your list of new columns, calling the appropriate RFX function for each column in the list. On each RFX call, pass a column name from the column name list and a storage location in the corresponding member of the result value list.  \n  \n###  <a name=\"_core_lists_of_columns\"></a> Lists of Columns  \n The four lists you need to work with are shown in the following table.  \n  \n [Current-Table-Columns (List 1 in the illustration)](#_core_illustration_dynamic)  \n A list of the columns currently in the table on the data source. This list might match the list of columns currently bound in your recordset.  \n  \n [Bound-Recordset-Columns (List 2 in the illustration)](#_core_illustration_dynamic)  \n A list of the columns bound in your recordset. These columns already have RFX statements in your `DoFieldExchange` function.  \n  \n [Columns-To-Bind-Dynamically (List 3 in the illustration)](#_core_illustration_dynamic)  \n A list of columns in the table but not in your recordset. These are the columns you want to bind dynamically.  \n  \n [Dynamic-Column-Values (List 4 in the illustration)](#_core_illustration_dynamic)  \n A list containing storage for the values retrieved from the columns you bind dynamically. Elements of this list correspond to those in Columns-to-Bind-Dynamically, one to one.  \n  \n###  <a name=\"_core_building_your_lists\"></a> Building Your Lists  \n With a general strategy in mind, you can turn to the details. The procedures in the rest of this topic show you how to build the lists shown in [Lists of Columns](#_core_lists_of_columns). The procedures guide you through:  \n  \n-   [Determining the names of columns not in your recordset](#_core_determining_which_table_columns_are_not_in_your_recordset).  \n  \n-   [Providing dynamic storage for columns newly added to the table](#_core_providing_storage_for_the_new_columns).  \n  \n-   [Dynamically adding RFX calls for new columns](#_core_adding_rfx_calls_to_bind_the_columns).  \n  \n###  <a name=\"_core_determining_which_table_columns_are_not_in_your_recordset\"></a> Determining Which Table Columns Are Not in Your Recordset  \n Build a list (Bound-Recordset-Columns, as in List 2 in the [illustration](#_core_illustration_dynamic)) that contains a list of the columns already bound in your main recordset. Then build a list (Columns-to-Bind-Dynamically, derived from Current-Table-Columns and Bound-Recordset-Columns) that contains column names that are in the table on the data source but not in your main recordset.  \n  \n##### To determine the names of columns not in the recordset (Columns-to-Bind-Dynamically)  \n  \n1.  Build a list (Bound-Recordset-Columns) of the columns already bound in your main recordset.  \n  \n     One approach is to create Bound-Recordset-Columns at design time. You can visually examine the RFX function calls in the recordset's `DoFieldExchange` function to get these names. Then, set up your list as an array initialized with the names.  \n  \n     For example, the [illustration](#_core_illustration_dynamic) shows Bound-Recordset-Columns (List 2) with three elements. Bound-Recordset-Columns is missing the Phone column shown in Current-Table-Columns (List 1).  \n  \n2.  Compare Current-Table-Columns and Bound-Recordset-Columns to build a list (Columns-to-Bind-Dynamically) of the columns not already bound in your main recordset.  \n  \n     One approach is to loop through your list of columns in the table at run time (Current-Table-Columns) and your list of columns already bound in your recordset (Bound-Recordset-Columns) in parallel. Into Columns-to-Bind-Dynamically put any names in Current-Table-Columns that do not appear in Bound-Recordset-Columns.  \n  \n     For example, the [illustration](#_core_illustration_dynamic) shows Columns-to-Bind-Dynamically (List 3) with one element: the Phone column found in Current-Table-Columns (List 1) but not in Bound-Recordset-Columns (List 2).  \n  \n3.  Build a list of Dynamic-Column-Values (as in List 4 in the [illustration](#_core_illustration_dynamic)) in which to store the data values corresponding to each column name stored in your list of columns to bind dynamically (Columns-to-Bind-Dynamically).  \n  \n     The elements of this list play the role of new recordset field data members. They are the storage locations to which the dynamic columns are bound. For descriptions of the lists, see [Lists of Columns](#_core_lists_of_columns).  \n  \n###  <a name=\"_core_providing_storage_for_the_new_columns\"></a> Providing Storage for the New Columns  \n Next, set up storage locations for the columns to be bound dynamically. The idea is to provide a list element in which to store each column's value. These storage locations parallel the recordset member variables, which store the normally bound columns.  \n  \n##### To provide dynamic storage for new columns (Dynamic-Column-Values)  \n  \n1.  Build Dynamic-Column-Values, parallel to Columns-to-Bind-Dynamically, to contain the value of the data in each column.  \n  \n     For example, the [illustration](#_core_illustration_dynamic) shows Dynamic-Column-Values (List 4) with one element: a `CString` object containing the actual phone number for the current record: \"555-1212\".  \n  \n     In the most common case, Dynamic-Column-Values has elements of type `CString`. If you are dealing with columns of varying data types, you need a list that can contain elements of a variety of types.  \n  \n The result of the preceding procedures is two main lists: Columns-to-Bind-Dynamically containing the names of columns and Dynamic-Column-Values containing the values in the columns for the current record.  \n  \n> [!TIP]\n>  If the new columns are not all of the same data type, you might want an extra parallel list containing items that somehow define the type of each corresponding element in the column list. (You can use the values **AFX_RFX_BOOL**, **AFX_RFX_BYTE**, and so on, for this if you want. These constants are defined in AFXDB.H.) Choose a list type based on how you represent the column data types.  \n  \n###  <a name=\"_core_adding_rfx_calls_to_bind_the_columns\"></a> Adding RFX Calls to Bind the Columns  \n Finally, arrange for the dynamic binding to occur by placing RFX calls for the new columns in your `DoFieldExchange` function.  \n  \n##### To dynamically add RFX calls for new columns  \n  \n1.  In your main recordset's `DoFieldExchange` member function, add code that loops through your list of new columns (Columns-to-Bind-Dynamically). In each loop, extract a column name from Columns-to-Bind-Dynamically and a result value for the column from Dynamic-Column-Values. Pass these items to an RFX function call appropriate to the data type of the column. For descriptions of the lists, see [Lists of Columns](#_core_lists_of_columns).  \n  \n In the common case, in your `RFX_Text` function calls you extract `CString` objects from the lists, as in the following lines of code, where Columns-to-Bind-Dynamically is a `CStringList` called `m_listName` and Dynamic-Column-Values is a `CStringList` called `m_listValue`:  \n  \n```  \nRFX_Text( pFX,   \n            m_listName.GetNext( posName ),   \n            m_listValue.GetNext( posValue ));  \n```  \n  \n For more information about RFX functions, see [Macros and Globals](../../mfc/reference/mfc-macros-and-globals.md) in the *Class Library Reference*.  \n  \n> [!TIP]\n>  If the new columns are different data types, use a switch statement in your loop to call the appropriate RFX function for each type.  \n  \n When the framework calls `DoFieldExchange` during the **Open** process to bind columns to the recordset, the RFX calls for the static columns bind those columns. Then your loop repeatedly calls RFX functions for the dynamic columns.  \n  \n## See Also  \n [Recordset (ODBC)](../../data/odbc/recordset-odbc.md)   \n [Recordset: Working with Large Data Items (ODBC)](../../data/odbc/recordset-working-with-large-data-items-odbc.md)"}