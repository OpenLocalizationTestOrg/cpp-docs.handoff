{"nodes":[{"pos":[12,66],"content":"Structured Exception Handling (C-C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Structured Exception Handling (C-C++) | Microsoft Docs","pos":[0,54]}]},{"content":"Structured Exception Handling (C/C++)","pos":[873,910]},{"content":"Although Windows and Visual C++ support structured exception handling (SEH), we recommend that you use ISO-standard C++ exception handling because it makes code more portable and flexible.","pos":[911,1099]},{"content":"Nevertheless, in existing code or for particular kinds of programs, you still might have to use SEH.","pos":[1100,1200]},{"content":"Microsoft Specific","pos":[1209,1227]},{"content":"Grammar","pos":[1236,1243]},{"pos":[1247,1271],"content":"<bpt id=\"p1\">*</bpt>try-except-statement<ept id=\"p1\">*</ept> :","source":"*try-except-statement* :"},{"pos":[1287,1305],"content":"compound-statement"},{"pos":[1324,1361],"content":"( <ph id=\"ph1\">`expression`</ph> ) <bpt id=\"p1\">*</bpt>compound-statement<ept id=\"p1\">*</ept>","source":" ( `expression` ) *compound-statement*"},{"content":"Remarks","pos":[1370,1377]},{"content":"With SEH, you can ensure that resources such as memory blocks and files are correctly if execution unexpectedly terminates.","pos":[1381,1504]},{"content":"You can also handle specific problems—for example, insufficient memory—by using concise structured code that does not rely on <ph id=\"ph1\">`goto`</ph> statements or elaborate testing of return codes.","pos":[1505,1686],"source":" You can also handle specific problems—for example, insufficient memory—by using concise structured code that does not rely on `goto` statements or elaborate testing of return codes."},{"content":"The try-except and try-finally statements referred to in this article are Microsoft extensions to the C language.","pos":[1693,1806]},{"content":"They support SEH by enabling applications to gain control of a program after events that would otherwise terminate execution.","pos":[1807,1932]},{"content":"Although SEH works with C++ source files, it's not specifically designed for C++.","pos":[1933,2014]},{"content":"If you use SEH in a C++ program that you compile by using the <bpt id=\"p1\">[</bpt>/EH<ept id=\"p1\">](../build/reference/eh-exception-handling-model.md)</ept> option—together with certain modifiers—destructors for local objects are called but other execution behavior might not be what you expect.","pos":[2015,2272],"source":" If you use SEH in a C++ program that you compile by using the [/EH](../build/reference/eh-exception-handling-model.md) option—together with certain modifiers—destructors for local objects are called but other execution behavior might not be what you expect."},{"content":"(For an illustration, see the example later in this article.) In most cases, instead of SEH we recommend that you use ISO-standard <bpt id=\"p1\">[</bpt>C++ exception handling<ept id=\"p1\">](../cpp/try-throw-and-catch-statements-cpp.md)</ept>, which Visual C++ also supports.","pos":[2273,2507],"source":" (For an illustration, see the example later in this article.) In most cases, instead of SEH we recommend that you use ISO-standard [C++ exception handling](../cpp/try-throw-and-catch-statements-cpp.md), which Visual C++ also supports."},{"content":"By using C++ exception handling, you can ensure that your code is more portable, and you can handle exceptions of any type.","pos":[2508,2631]},{"content":"If you have C modules that use SEH, you can mix them with C++ modules that use C++ exception handling.","pos":[2638,2740]},{"content":"For information, see <bpt id=\"p1\">[</bpt>Exception Handling Differences<ept id=\"p1\">](../cpp/exception-handling-differences.md)</ept>.","pos":[2741,2837],"source":" For information, see [Exception Handling Differences](../cpp/exception-handling-differences.md)."},{"content":"There are two SEH mechanisms:","pos":[2844,2873]},{"pos":[2883,2991],"content":"<bpt id=\"p1\">[</bpt>Exception handlers<ept id=\"p1\">](../cpp/writing-an-exception-handler.md)</ept>, which can respond to or dismiss the exception.","source":"[Exception handlers](../cpp/writing-an-exception-handler.md), which can respond to or dismiss the exception."},{"pos":[3001,3139],"content":"<bpt id=\"p1\">[</bpt>Termination handlers<ept id=\"p1\">](../cpp/writing-a-termination-handler.md)</ept>, which are called when an exception causes termination in a block of code.","source":"[Termination handlers](../cpp/writing-a-termination-handler.md), which are called when an exception causes termination in a block of code."},{"content":"These two kinds of handlers are distinct, but are closely related through a process known as \"unwinding the stack.\"","pos":[3146,3261]},{"content":"When an exception occurs, Windows looks for the most recently installed exception handler that is currently active.","pos":[3262,3377]},{"content":"The handler can do one of three things:","pos":[3378,3417]},{"content":"Fail to recognize the exception and pass control to other handlers.","pos":[3427,3494]},{"content":"Recognize the exception but dismiss it.","pos":[3504,3543]},{"content":"Recognize the exception and handle it.","pos":[3553,3591]},{"content":"The exception handler that recognizes the exception may not be in the function that was running when the exception occurred.","pos":[3598,3722]},{"content":"In some cases, it may be in a function much higher on the stack.","pos":[3723,3787]},{"content":"The currently running function and all other functions on the stack frame are terminated.","pos":[3788,3877]},{"content":"During this process, the stack is \"unwound;\" that is, local variables of terminated functions—unless they are <ph id=\"ph1\">`static`</ph>—are cleared from the stack.","pos":[3878,4024],"source":" During this process, the stack is \"unwound;\" that is, local variables of terminated functions—unless they are `static`—are cleared from the stack."},{"content":"As it unwinds the stack, the operating system calls any termination handlers that you've written for each function.","pos":[4031,4146]},{"content":"By using a termination handler, you can clean up resources that otherwise would remain open because of an abnormal termination.","pos":[4147,4274]},{"content":"If you've entered a critical section, you can exit in the termination handler.","pos":[4275,4353]},{"content":"If the program is going to shut down, you can perform other housekeeping tasks such as closing and removing temporary files.","pos":[4354,4478]},{"content":"For more information, see:","pos":[4485,4511]},{"content":"Writing an Exception Handler","pos":[4522,4550]},{"content":"Writing a Termination Handler","pos":[4602,4631]},{"content":"Using Structured Exception Handling with C++","pos":[4684,4728]},{"content":"Example","pos":[4794,4801]},{"content":"As stated earlier, destructors for local objects are called if you use SEH in a C++ program and compile it by using the <bpt id=\"p1\">**</bpt>/EH<ept id=\"p1\">**</ept> option with certain modifiers—for example, <bpt id=\"p2\">**</bpt>/EHsc<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>/EHa<ept id=\"p3\">**</ept>.","pos":[4805,4999],"source":"As stated earlier, destructors for local objects are called if you use SEH in a C++ program and compile it by using the **/EH** option with certain modifiers—for example, **/EHsc** and **/EHa**."},{"content":"However, the behavior during execution may not be what you expect if you are also using C++ exceptions.","pos":[5000,5103]},{"content":"The following example demonstrates these behavioral differences.","pos":[5104,5168]},{"pos":[5952,6126],"content":"If you use <bpt id=\"p1\">**</bpt>/EHsc<ept id=\"p1\">**</ept> to compile this code but the local test control <ph id=\"ph1\">`CPPEX`</ph> is undefined, there is no execution of the <ph id=\"ph2\">`TestClass`</ph> destructor and the output looks like this:","source":"If you use **/EHsc** to compile this code but the local test control `CPPEX` is undefined, there is no execution of the `TestClass` destructor and the output looks like this:"},{"pos":[6212,6399],"content":"If you use <bpt id=\"p1\">**</bpt>/EHsc<ept id=\"p1\">**</ept> to compile the code and <ph id=\"ph1\">`CPPEX`</ph> is defined by using <ph id=\"ph2\">`/DCPPEX`</ph> (so that a C++ exception is thrown), the <ph id=\"ph3\">`TestClass`</ph> destructor executes and the output looks like this:","source":"If you use **/EHsc** to compile the code and `CPPEX` is defined by using `/DCPPEX` (so that a C++ exception is thrown), the `TestClass` destructor executes and the output looks like this:"},{"content":"If you use <bpt id=\"p1\">**</bpt>/EHa<ept id=\"p1\">**</ept> to compile the code, the <ph id=\"ph1\">`TestClass`</ph> destructor executes regardless of whether the exception was thrown by using <ph id=\"ph2\">`std::throw`</ph> or by using SEH to trigger the exception (<ph id=\"ph3\">`CPPEX`</ph> defined or not).","pos":[6507,6719],"source":"If you use **/EHa** to compile the code, the `TestClass` destructor executes regardless of whether the exception was thrown by using `std::throw` or by using SEH to trigger the exception (`CPPEX` defined or not)."},{"content":"The output looks like this:","pos":[6720,6747]},{"pos":[6855,6965],"content":"For more information, see <bpt id=\"p1\">[</bpt>/EH (Exception Handling Model)<ept id=\"p1\">](../build/reference/eh-exception-handling-model.md)</ept>.","source":"For more information, see [/EH (Exception Handling Model)](../build/reference/eh-exception-handling-model.md)."},{"content":"END Microsoft Specific","pos":[6974,6996]},{"content":"See Also","pos":[7005,7013]},{"content":"Exception Handling","pos":[7018,7036]},{"content":"Keywords","pos":[7087,7095]},{"content":"exception&gt;","pos":[7128,7138],"source":"exception>"},{"content":"Errors and Exception Handling","pos":[7179,7208]},{"content":"Structured Exception Handling (Windows)","pos":[7267,7306]}],"content":"---\ntitle: \"Structured Exception Handling (C-C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"termination handlers, handling exceptions in C++\"\n  - \"structured exception handling\"\n  - \"try-catch keyword [C++], exception handlers\"\n  - \"C++ exception handling, termination handlers\"\n  - \"try-catch keyword [C++], termination handlers\"\n  - \"C++ exception handling, exception handlers\"\nms.assetid: dd3b647d-c269-43a8-aab9-ad1458712976\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Structured Exception Handling (C/C++)\nAlthough Windows and Visual C++ support structured exception handling (SEH), we recommend that you use ISO-standard C++ exception handling because it makes code more portable and flexible. Nevertheless, in existing code or for particular kinds of programs, you still might have to use SEH.  \n  \n## Microsoft Specific  \n  \n## Grammar  \n *try-except-statement* :  \n  \n `__try` *compound-statement*  \n  \n `__except` ( `expression` ) *compound-statement*  \n  \n## Remarks  \n With SEH, you can ensure that resources such as memory blocks and files are correctly if execution unexpectedly terminates. You can also handle specific problems—for example, insufficient memory—by using concise structured code that does not rely on `goto` statements or elaborate testing of return codes.  \n  \n The try-except and try-finally statements referred to in this article are Microsoft extensions to the C language. They support SEH by enabling applications to gain control of a program after events that would otherwise terminate execution. Although SEH works with C++ source files, it's not specifically designed for C++. If you use SEH in a C++ program that you compile by using the [/EH](../build/reference/eh-exception-handling-model.md) option—together with certain modifiers—destructors for local objects are called but other execution behavior might not be what you expect. (For an illustration, see the example later in this article.) In most cases, instead of SEH we recommend that you use ISO-standard [C++ exception handling](../cpp/try-throw-and-catch-statements-cpp.md), which Visual C++ also supports. By using C++ exception handling, you can ensure that your code is more portable, and you can handle exceptions of any type.  \n  \n If you have C modules that use SEH, you can mix them with C++ modules that use C++ exception handling. For information, see [Exception Handling Differences](../cpp/exception-handling-differences.md).  \n  \n There are two SEH mechanisms:  \n  \n-   [Exception handlers](../cpp/writing-an-exception-handler.md), which can respond to or dismiss the exception.  \n  \n-   [Termination handlers](../cpp/writing-a-termination-handler.md), which are called when an exception causes termination in a block of code.  \n  \n These two kinds of handlers are distinct, but are closely related through a process known as \"unwinding the stack.\" When an exception occurs, Windows looks for the most recently installed exception handler that is currently active. The handler can do one of three things:  \n  \n-   Fail to recognize the exception and pass control to other handlers.  \n  \n-   Recognize the exception but dismiss it.  \n  \n-   Recognize the exception and handle it.  \n  \n The exception handler that recognizes the exception may not be in the function that was running when the exception occurred. In some cases, it may be in a function much higher on the stack. The currently running function and all other functions on the stack frame are terminated. During this process, the stack is \"unwound;\" that is, local variables of terminated functions—unless they are `static`—are cleared from the stack.  \n  \n As it unwinds the stack, the operating system calls any termination handlers that you've written for each function. By using a termination handler, you can clean up resources that otherwise would remain open because of an abnormal termination. If you've entered a critical section, you can exit in the termination handler. If the program is going to shut down, you can perform other housekeeping tasks such as closing and removing temporary files.  \n  \n For more information, see:  \n  \n-   [Writing an Exception Handler](../cpp/writing-an-exception-handler.md)  \n  \n-   [Writing a Termination Handler](../cpp/writing-a-termination-handler.md)  \n  \n-   [Using Structured Exception Handling with C++](../cpp/using-structured-exception-handling-with-cpp.md)  \n  \n## Example  \n As stated earlier, destructors for local objects are called if you use SEH in a C++ program and compile it by using the **/EH** option with certain modifiers—for example, **/EHsc** and **/EHa**. However, the behavior during execution may not be what you expect if you are also using C++ exceptions. The following example demonstrates these behavioral differences.  \n  \n```cpp  \n#include <stdio.h>  \n#include <Windows.h>  \n#include <exception>  \n  \nclass TestClass  \n{  \npublic:  \n    ~TestClass()  \n    {  \n        printf(\"Destroying TestClass!\\r\\n\");  \n    }  \n};  \n  \n__declspec(noinline) void TestCPPEX()  \n{  \n#ifdef CPPEX  \n    printf(\"Throwing C++ exception\\r\\n\");  \n    throw std::exception(\"\");  \n#else  \n    printf(\"Triggering SEH exception\\r\\n\");  \n    volatile int *pInt = 0x00000000;  \n    *pInt = 20;  \n#endif  \n}  \n  \n__declspec(noinline) void TestExceptions()  \n{  \n    TestClass d;  \n    TestCPPEX();  \n}  \n  \nint main()  \n{  \n    __try  \n    {  \n        TestExceptions();  \n    }  \n    __except(EXCEPTION_EXECUTE_HANDLER)  \n    {  \n        printf(\"Executing SEH __except block\\r\\n\");  \n    }  \n  \n    return 0;  \n}  \n  \n```  \n  \n If you use **/EHsc** to compile this code but the local test control `CPPEX` is undefined, there is no execution of the `TestClass` destructor and the output looks like this:  \n  \n```Output  \nTriggering SEH exception  \nExecuting SEH __except block  \n```  \n  \n If you use **/EHsc** to compile the code and `CPPEX` is defined by using `/DCPPEX` (so that a C++ exception is thrown), the `TestClass` destructor executes and the output looks like this:  \n  \n```Output  \nThrowing C++ exception  \nDestroying TestClass!  \nExecuting SEH __except block  \n```  \n  \n If you use **/EHa** to compile the code, the `TestClass` destructor executes regardless of whether the exception was thrown by using `std::throw` or by using SEH to trigger the exception (`CPPEX` defined or not). The output looks like this:  \n  \n```Output  \nThrowing C++ exception  \nDestroying TestClass!  \nExecuting SEH __except block  \n```  \n  \n For more information, see [/EH (Exception Handling Model)](../build/reference/eh-exception-handling-model.md).  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [Exception Handling](../cpp/exception-handling-in-visual-cpp.md)   \n [Keywords](../cpp/keywords-cpp.md)   \n [\\<exception>](../standard-library/exception.md)   \n [Errors and Exception Handling](../cpp/errors-and-exception-handling-modern-cpp.md)   \n [Structured Exception Handling (Windows)](http://msdn.microsoft.com/library/windows/desktop/ms680657.aspx)"}