{"nodes":[{"pos":[12,80],"content":"Recordset: How AddNew, Edit, and Delete Work (ODBC) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Recordset: How AddNew, Edit, and Delete Work (ODBC) | Microsoft Docs","pos":[0,68]}]},{"content":"Recordset: How AddNew, Edit, and Delete Work (ODBC)","pos":[1094,1145]},{"content":"This topic applies to the MFC ODBC classes.","pos":[1146,1189]},{"content":"This topic explains how the <ph id=\"ph1\">`AddNew`</ph>, <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, and <bpt id=\"p2\">**</bpt>Delete<ept id=\"p2\">**</ept> member functions of class <ph id=\"ph2\">`CRecordset`</ph> work.","pos":[1196,1303],"source":"This topic explains how the `AddNew`, **Edit**, and **Delete** member functions of class `CRecordset` work."},{"content":"Topics covered include:","pos":[1304,1327]},{"content":"How Adding Records Works","pos":[1338,1362]},{"content":"Visibility of Added Records","pos":[1398,1425]},{"content":"How Editing Records Works","pos":[1473,1498]},{"content":"How Deleting Records Works","pos":[1545,1571]},{"pos":[1606,1871],"content":"[!NOTE]\n This topic applies to objects derived from `CRecordset` in which bulk row fetching has not been implemented. If you are using bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" This topic applies to objects derived from `CRecordset` in which bulk row fetching has not been implemented. If you are using bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,263],"nodes":[{"content":"This topic applies to objects derived from <ph id=\"ph1\">`CRecordset`</ph> in which bulk row fetching has not been implemented.","pos":[1,109],"source":" This topic applies to objects derived from `CRecordset` in which bulk row fetching has not been implemented."},{"content":"If you are using bulk row fetching, see <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[110,255],"source":" If you are using bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"pos":[1878,2081],"content":"As a supplement, you might want to read <bpt id=\"p1\">[</bpt>Record Field Exchange: How RFX Works<ept id=\"p1\">](../../data/odbc/record-field-exchange-how-rfx-works.md)</ept>, which describes the corresponding role of RFX in update operations.","source":"As a supplement, you might want to read [Record Field Exchange: How RFX Works](../../data/odbc/record-field-exchange-how-rfx-works.md), which describes the corresponding role of RFX in update operations."},{"pos":[2128,2143],"content":"Adding a Record"},{"pos":[2148,2501],"content":"Adding a new record to a recordset involves calling the recordset's <bpt id=\"p1\">[</bpt>AddNew<ept id=\"p1\">](../../mfc/reference/crecordset-class.md#crecordset__addnew)</ept> member function, setting the values of the new record's field data members, and calling the <bpt id=\"p2\">[</bpt>Update<ept id=\"p2\">](../../mfc/reference/crecordset-class.md#crecordset__update)</ept> member function to write the record to the data source.","source":"Adding a new record to a recordset involves calling the recordset's [AddNew](../../mfc/reference/crecordset-class.md#crecordset__addnew) member function, setting the values of the new record's field data members, and calling the [Update](../../mfc/reference/crecordset-class.md#crecordset__update) member function to write the record to the data source."},{"content":"As a precondition for calling <ph id=\"ph1\">`AddNew`</ph>, the recordset must not have been opened as read-only.","pos":[2508,2601],"source":"As a precondition for calling `AddNew`, the recordset must not have been opened as read-only."},{"content":"The <ph id=\"ph1\">`CanUpdate`</ph> and <ph id=\"ph2\">`CanAppend`</ph> member functions let you determine these conditions.","pos":[2602,2686],"source":" The `CanUpdate` and `CanAppend` member functions let you determine these conditions."},{"pos":[2693,2716],"content":"When you call <ph id=\"ph1\">`AddNew`</ph>:","source":"When you call `AddNew`:"},{"content":"The record in the edit buffer is stored, so its contents can be restored if the operation is canceled.","pos":[2726,2828]},{"content":"The field data members are flagged so it is possible to detect changes in them later.","pos":[2838,2923]},{"content":"The field data members are also marked clean (unchanged) and set to a Null.","pos":[2924,2999]},{"content":"After you call <ph id=\"ph1\">`AddNew`</ph>, the edit buffer represents a new, empty record, ready to be filled in with values.","pos":[3006,3113],"source":"After you call `AddNew`, the edit buffer represents a new, empty record, ready to be filled in with values."},{"content":"To do this, you manually set the values by assigning to them.","pos":[3114,3175]},{"content":"Instead of specifying an actual data value for a field, you can call <ph id=\"ph1\">`SetFieldNull`</ph> to specify the value Null.","pos":[3176,3286],"source":" Instead of specifying an actual data value for a field, you can call `SetFieldNull` to specify the value Null."},{"content":"To commit your changes, you call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>.","pos":[3293,3337],"source":"To commit your changes, you call **Update**."},{"content":"When you call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> for the new record:","pos":[3338,3382],"source":" When you call **Update** for the new record:"},{"content":"If your ODBC driver supports the <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept> ODBC API function, MFC uses the function to add the record on the data source.","pos":[3392,3519],"source":"If your ODBC driver supports the **::SQLSetPos** ODBC API function, MFC uses the function to add the record on the data source."},{"content":"With <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept>, MFC can add a record more efficiently because it does not have to construct and process a SQL statement.","pos":[3520,3646],"source":" With **::SQLSetPos**, MFC can add a record more efficiently because it does not have to construct and process a SQL statement."},{"pos":[3656,3714],"content":"If <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept> cannot be used, MFC does the following:","source":"If **::SQLSetPos** cannot be used, MFC does the following:"},{"pos":[3728,3794],"content":"If no changes are detected, <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> does nothing and returns 0.","source":"If no changes are detected, **Update** does nothing and returns 0."},{"content":"If there are changes, <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> constructs a SQL <bpt id=\"p2\">**</bpt>INSERT<ept id=\"p2\">**</ept> statement.","pos":[3808,3879],"source":"If there are changes, **Update** constructs a SQL **INSERT** statement."},{"content":"The columns represented by all dirty field data members are listed in the <bpt id=\"p1\">**</bpt>INSERT<ept id=\"p1\">**</ept> statement.","pos":[3880,3975],"source":" The columns represented by all dirty field data members are listed in the **INSERT** statement."},{"content":"To force a column to be included, call the <bpt id=\"p1\">[</bpt>SetFieldDirty<ept id=\"p1\">](../../mfc/reference/crecordset-class.md#crecordset__setfielddirty)</ept> member function:","pos":[3976,4118],"source":" To force a column to be included, call the [SetFieldDirty](../../mfc/reference/crecordset-class.md#crecordset__setfielddirty) member function:"},{"pos":[4211,4419],"content":"<bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> commits the new record — the <bpt id=\"p2\">**</bpt>INSERT<ept id=\"p2\">**</ept> statement is executed and the record is committed to the table on the data source (and the recordset, if not a snapshot) unless a transaction is in progress.","source":"**Update** commits the new record — the **INSERT** statement is executed and the record is committed to the table on the data source (and the recordset, if not a snapshot) unless a transaction is in progress."},{"content":"The stored record is restored to the edit buffer.","pos":[4433,4482]},{"content":"The record that was current before the <ph id=\"ph1\">`AddNew`</ph> call is current again regardless of whether the <bpt id=\"p1\">**</bpt>INSERT<ept id=\"p1\">**</ept> statement was successfully executed.","pos":[4483,4626],"source":" The record that was current before the `AddNew` call is current again regardless of whether the **INSERT** statement was successfully executed."},{"pos":[4638,5183],"content":"[!TIP]\n For complete control of a new record, take the following approach: set the values of any fields that will have values and then explicitly set any fields that will remain Null by calling `SetFieldNull` with a pointer to the field and the parameter **TRUE** (the default). If you want to ensure that a field is not written to the data source, call `SetFieldDirty` with a pointer to the field and the parameter **FALSE**, and do not modify the field's value. To determine whether a field is allowed to be Null, call `IsFieldNullable`.","leadings":["","    > "],"nodes":[{"content":" For complete control of a new record, take the following approach: set the values of any fields that will have values and then explicitly set any fields that will remain Null by calling `SetFieldNull` with a pointer to the field and the parameter **TRUE** (the default). If you want to ensure that a field is not written to the data source, call `SetFieldDirty` with a pointer to the field and the parameter **FALSE**, and do not modify the field's value. To determine whether a field is allowed to be Null, call `IsFieldNullable`.","pos":[7,539],"nodes":[{"content":"For complete control of a new record, take the following approach: set the values of any fields that will have values and then explicitly set any fields that will remain Null by calling <ph id=\"ph1\">`SetFieldNull`</ph> with a pointer to the field and the parameter <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept> (the default).","pos":[1,271],"source":" For complete control of a new record, take the following approach: set the values of any fields that will have values and then explicitly set any fields that will remain Null by calling `SetFieldNull` with a pointer to the field and the parameter **TRUE** (the default)."},{"content":"If you want to ensure that a field is not written to the data source, call <ph id=\"ph1\">`SetFieldDirty`</ph> with a pointer to the field and the parameter <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept>, and do not modify the field's value.","pos":[272,456],"source":" If you want to ensure that a field is not written to the data source, call `SetFieldDirty` with a pointer to the field and the parameter **FALSE**, and do not modify the field's value."},{"content":"To determine whether a field is allowed to be Null, call <ph id=\"ph1\">`IsFieldNullable`</ph>.","pos":[457,532],"source":" To determine whether a field is allowed to be Null, call `IsFieldNullable`."}]}]},{"pos":[5195,5601],"content":"[!TIP]\n To detect when recordset data members change value, MFC uses a **PSEUDO_NULL** value appropriate to each data type that you can store in a recordset. If you must explicitly set a field to the **PSEUDO_NULL** value and the field happens already to be marked Null, you must also call `SetFieldNull`, passing the address of the field in the first parameter and **FALSE** in the second parameter.","leadings":["","    > "],"nodes":[{"content":" To detect when recordset data members change value, MFC uses a **PSEUDO_NULL** value appropriate to each data type that you can store in a recordset. If you must explicitly set a field to the **PSEUDO_NULL** value and the field happens already to be marked Null, you must also call `SetFieldNull`, passing the address of the field in the first parameter and **FALSE** in the second parameter.","pos":[7,400],"nodes":[{"content":"To detect when recordset data members change value, MFC uses a <bpt id=\"p1\">**</bpt>PSEUDO_NULL<ept id=\"p1\">**</ept> value appropriate to each data type that you can store in a recordset.","pos":[1,150],"source":" To detect when recordset data members change value, MFC uses a **PSEUDO_NULL** value appropriate to each data type that you can store in a recordset."},{"content":"If you must explicitly set a field to the <bpt id=\"p1\">**</bpt>PSEUDO_NULL<ept id=\"p1\">**</ept> value and the field happens already to be marked Null, you must also call <ph id=\"ph1\">`SetFieldNull`</ph>, passing the address of the field in the first parameter and <bpt id=\"p2\">**</bpt>FALSE<ept id=\"p2\">**</ept> in the second parameter.","pos":[151,393],"source":" If you must explicitly set a field to the **PSEUDO_NULL** value and the field happens already to be marked Null, you must also call `SetFieldNull`, passing the address of the field in the first parameter and **FALSE** in the second parameter."}]}]},{"pos":[5660,5687],"content":"Visibility of Added Records"},{"content":"When is an added record visible to your recordset?","pos":[5691,5741]},{"content":"Added records sometimes show up and sometimes are not visible, depending on two things:","pos":[5742,5829]},{"content":"What your driver is capable of.","pos":[5839,5870]},{"content":"What the framework can take advantage of.","pos":[5880,5921]},{"content":"If your ODBC driver supports the <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept> ODBC API function, MFC uses the function to add records.","pos":[5928,6033],"source":"If your ODBC driver supports the **::SQLSetPos** ODBC API function, MFC uses the function to add records."},{"content":"With <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept>, added records are visible to any updatable MFC recordset.","pos":[6034,6113],"source":" With **::SQLSetPos**, added records are visible to any updatable MFC recordset."},{"content":"Without support for the function, added records are not visible and you must call <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept> to see them.","pos":[6114,6220],"source":" Without support for the function, added records are not visible and you must call **Requery** to see them."},{"content":"Using <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept> is also more efficient.","pos":[6221,6266],"source":" Using **::SQLSetPos** is also more efficient."},{"pos":[6324,6350],"content":"Editing an Existing Record"},{"pos":[6354,6743],"content":"Editing an existing record in a recordset involves scrolling to the record, calling the recordset's <bpt id=\"p1\">[</bpt>Edit<ept id=\"p1\">](../../mfc/reference/crecordset-class.md#crecordset__edit)</ept> member function, setting the values of the new record's field data members, and calling the <bpt id=\"p2\">[</bpt>Update<ept id=\"p2\">](../../mfc/reference/crecordset-class.md#crecordset__update)</ept> member function to write the changed record to the data source.","source":"Editing an existing record in a recordset involves scrolling to the record, calling the recordset's [Edit](../../mfc/reference/crecordset-class.md#crecordset__edit) member function, setting the values of the new record's field data members, and calling the [Update](../../mfc/reference/crecordset-class.md#crecordset__update) member function to write the changed record to the data source."},{"content":"As a precondition for calling <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, the recordset must be updatable and on a record.","pos":[6750,6838],"source":"As a precondition for calling **Edit**, the recordset must be updatable and on a record."},{"content":"The <ph id=\"ph1\">`CanUpdate`</ph> and <ph id=\"ph2\">`IsDeleted`</ph> member functions let you determine these conditions.","pos":[6839,6923],"source":" The `CanUpdate` and `IsDeleted` member functions let you determine these conditions."},{"content":"The current record also must not already have been deleted, and there must be records in the recordset (both <ph id=\"ph1\">`IsBOF`</ph> and <ph id=\"ph2\">`IsEOF`</ph> return 0).","pos":[6924,7063],"source":" The current record also must not already have been deleted, and there must be records in the recordset (both `IsBOF` and `IsEOF` return 0)."},{"content":"When you call <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, the record in the edit buffer (the current record) is stored.","pos":[7070,7155],"source":"When you call **Edit**, the record in the edit buffer (the current record) is stored."},{"content":"The stored record's values are later used to detect whether any fields have changed.","pos":[7156,7240]},{"content":"After you call <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, the edit buffer still represents the current record but is now ready to accept changes to the field data members.","pos":[7247,7385],"source":"After you call **Edit**, the edit buffer still represents the current record but is now ready to accept changes to the field data members."},{"content":"To change the record, you manually set the values of any field data members you want to edit.","pos":[7386,7479]},{"content":"Instead of specifying an actual data value for a field, you can call <ph id=\"ph1\">`SetFieldNull`</ph> to specify the value Null.","pos":[7480,7590],"source":" Instead of specifying an actual data value for a field, you can call `SetFieldNull` to specify the value Null."},{"content":"To commit your changes, call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>.","pos":[7591,7631],"source":" To commit your changes, call **Update**."},{"pos":[7639,7744],"content":"[!TIP]\n To get out of `AddNew` or **Edit** mode, call **Move** with the parameter **AFX_MOVE_REFRESH**.","leadings":["","> "],"nodes":[{"content":"To get out of <ph id=\"ph1\">`AddNew`</ph> or <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> mode, call <bpt id=\"p2\">**</bpt>Move<ept id=\"p2\">**</ept> with the parameter <bpt id=\"p3\">**</bpt>AFX_MOVE_REFRESH<ept id=\"p3\">**</ept>.","pos":[8,103],"source":" To get out of `AddNew` or **Edit** mode, call **Move** with the parameter **AFX_MOVE_REFRESH**."}]},{"content":"As a precondition for calling <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>, the recordset must not be empty and the current record must not have been deleted.","pos":[7751,7875],"source":"As a precondition for calling **Update**, the recordset must not be empty and the current record must not have been deleted."},{"content":", <ph id=\"ph1\">`IsEOF`</ph>, and <ph id=\"ph2\">`IsDeleted`</ph> should all return 0.","pos":[7883,7930],"source":", `IsEOF`, and `IsDeleted` should all return 0."},{"pos":[7937,7984],"content":"When you call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> for the edited record:","source":"When you call **Update** for the edited record:"},{"content":"If your ODBC driver supports the <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept> ODBC API function, MFC uses the function to update the record on the data source.","pos":[7994,8124],"source":"If your ODBC driver supports the **::SQLSetPos** ODBC API function, MFC uses the function to update the record on the data source."},{"content":"With <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept>, the driver compares your edit buffer with the corresponding record on the server, updating the record on the server if the two are different.","pos":[8125,8288],"source":" With **::SQLSetPos**, the driver compares your edit buffer with the corresponding record on the server, updating the record on the server if the two are different."},{"content":"With <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept>, MFC can update a record more efficiently because it does not have to construct and process a SQL statement.","pos":[8289,8418],"source":" With **::SQLSetPos**, MFC can update a record more efficiently because it does not have to construct and process a SQL statement."},{"content":"-or-","pos":[8429,8433]},{"pos":[8443,8501],"content":"If <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept> cannot be used, MFC does the following:","source":"If **::SQLSetPos** cannot be used, MFC does the following:"},{"pos":[8515,8584],"content":"If there have been no changes, <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> does nothing and returns 0.","source":"If there have been no changes, **Update** does nothing and returns 0."},{"content":"If there are changes, <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> constructs a SQL <bpt id=\"p2\">**</bpt>UPDATE<ept id=\"p2\">**</ept> statement.","pos":[8598,8669],"source":"If there are changes, **Update** constructs a SQL **UPDATE** statement."},{"content":"The columns listed in the <bpt id=\"p1\">**</bpt>UPDATE<ept id=\"p1\">**</ept> statement are based on the field data members that have changed.","pos":[8670,8771],"source":" The columns listed in the **UPDATE** statement are based on the field data members that have changed."},{"content":"<bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> commits the changes — executes the <bpt id=\"p2\">**</bpt>UPDATE<ept id=\"p2\">**</ept> statement — and the record is changed on the data source, but not committed if a transaction is in progress (see <bpt id=\"p3\">[</bpt>Transaction: Performing a Transaction in a Recordset (ODBC)<ept id=\"p3\">](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md)</ept> for information about how the transaction affects the update).","pos":[8785,9156],"source":"**Update** commits the changes — executes the **UPDATE** statement — and the record is changed on the data source, but not committed if a transaction is in progress (see [Transaction: Performing a Transaction in a Recordset (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md) for information about how the transaction affects the update)."},{"content":"ODBC keeps a copy of the record, which also changes.","pos":[9157,9209]},{"content":"Unlike the process for <ph id=\"ph1\">`AddNew`</ph>, the <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> process does not restore the stored record.","pos":[9223,9312],"source":"Unlike the process for `AddNew`, the **Edit** process does not restore the stored record."},{"content":"The edited record remains in place as the current record.","pos":[9313,9370]},{"pos":[9382,9943],"content":"[!CAUTION]\n When you prepare to update a recordset by calling **Update**, take care that your recordset includes all columns making up the primary key of the table (or all of the columns of any unique index on the table, or enough columns to uniquely identify the row). In some cases, the framework can use only the columns selected in your recordset to identify which record in your table to update. Without all the necessary columns, multiple records might be updated in the table. In this case, the framework throws exceptions when you call **Update**.","leadings":["","    > "],"nodes":[{"content":" When you prepare to update a recordset by calling **Update**, take care that your recordset includes all columns making up the primary key of the table (or all of the columns of any unique index on the table, or enough columns to uniquely identify the row). In some cases, the framework can use only the columns selected in your recordset to identify which record in your table to update. Without all the necessary columns, multiple records might be updated in the table. In this case, the framework throws exceptions when you call **Update**.","pos":[11,555],"nodes":[{"content":"When you prepare to update a recordset by calling <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>, take care that your recordset includes all columns making up the primary key of the table (or all of the columns of any unique index on the table, or enough columns to uniquely identify the row).","pos":[1,258],"source":" When you prepare to update a recordset by calling **Update**, take care that your recordset includes all columns making up the primary key of the table (or all of the columns of any unique index on the table, or enough columns to uniquely identify the row)."},{"content":"In some cases, the framework can use only the columns selected in your recordset to identify which record in your table to update.","pos":[259,389]},{"content":"Without all the necessary columns, multiple records might be updated in the table.","pos":[390,472]},{"content":"In this case, the framework throws exceptions when you call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>.","pos":[473,544],"source":" In this case, the framework throws exceptions when you call **Update**."}]}]},{"pos":[9955,10361],"content":"[!TIP]\n If you call `AddNew` or **Edit** after having called either function previously but before you call **Update**, the edit buffer is refreshed with the stored record, replacing the new or edited record in progress. This behavior gives you a way to abort an `AddNew` or **Edit** and begin a new one: if you determine that the record-in-progress is faulty, simply call **Edit** or `AddNew` again.","leadings":["","    > "],"nodes":[{"content":" If you call `AddNew` or **Edit** after having called either function previously but before you call **Update**, the edit buffer is refreshed with the stored record, replacing the new or edited record in progress. This behavior gives you a way to abort an `AddNew` or **Edit** and begin a new one: if you determine that the record-in-progress is faulty, simply call **Edit** or `AddNew` again.","pos":[7,400],"nodes":[{"content":"If you call <ph id=\"ph1\">`AddNew`</ph> or <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> after having called either function previously but before you call <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept>, the edit buffer is refreshed with the stored record, replacing the new or edited record in progress.","pos":[1,213],"source":" If you call `AddNew` or **Edit** after having called either function previously but before you call **Update**, the edit buffer is refreshed with the stored record, replacing the new or edited record in progress."},{"content":"This behavior gives you a way to abort an <ph id=\"ph1\">`AddNew`</ph> or <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> and begin a new one: if you determine that the record-in-progress is faulty, simply call <bpt id=\"p2\">**</bpt>Edit<ept id=\"p2\">**</ept> or <ph id=\"ph2\">`AddNew`</ph> again.","pos":[214,393],"source":" This behavior gives you a way to abort an `AddNew` or **Edit** and begin a new one: if you determine that the record-in-progress is faulty, simply call **Edit** or `AddNew` again."}]}]},{"pos":[10410,10427],"content":"Deleting a Record"},{"content":"Deleting a record from a recordset involves scrolling to the record and calling the recordset's <bpt id=\"p1\">[</bpt>Delete<ept id=\"p1\">](../../mfc/reference/crecordset-class.md#crecordset__delete)</ept> member function.","pos":[10431,10612],"source":"Deleting a record from a recordset involves scrolling to the record and calling the recordset's [Delete](../../mfc/reference/crecordset-class.md#crecordset__delete) member function."},{"content":"Unlike <ph id=\"ph1\">`AddNew`</ph> and <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Delete<ept id=\"p2\">**</ept> does not require a matching call to <bpt id=\"p3\">**</bpt>Update<ept id=\"p3\">**</ept>.","pos":[10613,10701],"source":" Unlike `AddNew` and **Edit**, **Delete** does not require a matching call to **Update**."},{"content":"As a precondition for calling <bpt id=\"p1\">**</bpt>Delete<ept id=\"p1\">**</ept>, the recordset must be updatable and it must be on a record.","pos":[10708,10809],"source":"As a precondition for calling **Delete**, the recordset must be updatable and it must be on a record."},{"content":"The <ph id=\"ph1\">`CanUpdate`</ph>, <ph id=\"ph2\">`IsBOF`</ph>, <ph id=\"ph3\">`IsEOF`</ph>, and <ph id=\"ph4\">`IsDeleted`</ph> member functions let you determine these conditions.","pos":[10810,10913],"source":" The `CanUpdate`, `IsBOF`, `IsEOF`, and `IsDeleted` member functions let you determine these conditions."},{"pos":[10920,10945],"content":"When you call <bpt id=\"p1\">**</bpt>Delete<ept id=\"p1\">**</ept>:","source":"When you call **Delete**:"},{"content":"If your ODBC driver supports the <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept> ODBC API function, MFC uses the function to delete the record on the data source.","pos":[10955,11085],"source":"If your ODBC driver supports the **::SQLSetPos** ODBC API function, MFC uses the function to delete the record on the data source."},{"content":"Using <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept> is usually more efficient than using SQL.","pos":[11086,11149],"source":" Using **::SQLSetPos** is usually more efficient than using SQL."},{"content":"-or-","pos":[11160,11164]},{"pos":[11174,11232],"content":"If <bpt id=\"p1\">**</bpt>::SQLSetPos<ept id=\"p1\">**</ept> cannot be used, MFC does the following:","source":"If **::SQLSetPos** cannot be used, MFC does the following:"},{"pos":[11246,11329],"content":"The current record in the edit buffer is not backed up as in <ph id=\"ph1\">`AddNew`</ph> and <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>.","source":"The current record in the edit buffer is not backed up as in `AddNew` and **Edit**."},{"pos":[11343,11416],"content":"<bpt id=\"p1\">**</bpt>Delete<ept id=\"p1\">**</ept> constructs a SQL <bpt id=\"p2\">**</bpt>DELETE<ept id=\"p2\">**</ept> statement that removes the record.","source":"**Delete** constructs a SQL **DELETE** statement that removes the record."},{"pos":[11431,11511],"content":"The current record in the edit buffer is not stored as in <ph id=\"ph1\">`AddNew`</ph> and <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>.","source":"The current record in the edit buffer is not stored as in `AddNew` and **Edit**."},{"content":"<bpt id=\"p1\">**</bpt>Delete<ept id=\"p1\">**</ept> commits the deletion — executes the <bpt id=\"p2\">**</bpt>DELETE<ept id=\"p2\">**</ept> statement.","pos":[11525,11593],"source":"**Delete** commits the deletion — executes the **DELETE** statement."},{"content":"The record is marked deleted on the data source and, if the record is a snapshot, in ODBC.","pos":[11594,11684]},{"pos":[11698,11895],"content":"The deleted record's values are still in the field data members of the recordset, but the field data members are marked Null and the recordset's <ph id=\"ph1\">`IsDeleted`</ph> member function returns a nonzero value.","source":"The deleted record's values are still in the field data members of the recordset, but the field data members are marked Null and the recordset's `IsDeleted` member function returns a nonzero value."},{"pos":[11907,12097],"content":"[!NOTE]\n After deleting a record, you should scroll to another record to refill the edit buffer with the new record's data. It is an error to call **Delete** again or to call **Edit**.","leadings":["","    > "],"nodes":[{"content":" After deleting a record, you should scroll to another record to refill the edit buffer with the new record's data. It is an error to call **Delete** again or to call **Edit**.","pos":[8,184],"nodes":[{"content":"After deleting a record, you should scroll to another record to refill the edit buffer with the new record's data.","pos":[1,115]},{"content":"It is an error to call <bpt id=\"p1\">**</bpt>Delete<ept id=\"p1\">**</ept> again or to call <bpt id=\"p2\">**</bpt>Edit<ept id=\"p2\">**</ept>.","pos":[116,176],"source":" It is an error to call **Delete** again or to call **Edit**."}]}]},{"pos":[12104,12206],"content":"For information about the SQL statements used in update operations, see <bpt id=\"p1\">[</bpt>SQL<ept id=\"p1\">](../../data/odbc/sql.md)</ept>.","source":"For information about the SQL statements used in update operations, see [SQL](../../data/odbc/sql.md)."},{"content":"See Also","pos":[12215,12223]},{"content":"Recordset (ODBC)","pos":[12228,12244]},{"content":"Recordset: More About Updates (ODBC)","pos":[12286,12322]},{"content":"Record Field Exchange (RFX)","pos":[12383,12410]}],"content":"---\ntitle: \"Recordset: How AddNew, Edit, and Delete Work (ODBC) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"records [C++], updating\"\n  - \"record editing [C++], in recordsets\"\n  - \"recordsets [C++], adding records\"\n  - \"records [C++], adding\"\n  - \"ODBC recordsets [C++], adding records\"\n  - \"recordsets [C++], editing records\"\n  - \"recordsets [C++], updating\"\n  - \"AddNew method\"\n  - \"ODBC recordsets [C++], deleting records\"\n  - \"records [C++], deleting in recordsets\"\n  - \"data in recordsets [C++]\"\n  - \"recordsets [C++], deleting records\"\n  - \"ODBC recordsets [C++], editing records\"\n  - \"records [C++], editing\"\nms.assetid: cab43d43-235a-4bed-ac05-67d10e94f34e\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Recordset: How AddNew, Edit, and Delete Work (ODBC)\nThis topic applies to the MFC ODBC classes.  \n  \n This topic explains how the `AddNew`, **Edit**, and **Delete** member functions of class `CRecordset` work. Topics covered include:  \n  \n-   [How Adding Records Works](#_core_adding_a_record)  \n  \n-   [Visibility of Added Records](#_core_visibility_of_added_records)  \n  \n-   [How Editing Records Works](#_core_editing_an_existing_record)  \n  \n-   [How Deleting Records Works](#_core_deleting_a_record)  \n  \n> [!NOTE]\n>  This topic applies to objects derived from `CRecordset` in which bulk row fetching has not been implemented. If you are using bulk row fetching, see [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n As a supplement, you might want to read [Record Field Exchange: How RFX Works](../../data/odbc/record-field-exchange-how-rfx-works.md), which describes the corresponding role of RFX in update operations.  \n  \n##  <a name=\"_core_adding_a_record\"></a> Adding a Record  \n\n Adding a new record to a recordset involves calling the recordset's [AddNew](../../mfc/reference/crecordset-class.md#crecordset__addnew) member function, setting the values of the new record's field data members, and calling the [Update](../../mfc/reference/crecordset-class.md#crecordset__update) member function to write the record to the data source.  \n  \n As a precondition for calling `AddNew`, the recordset must not have been opened as read-only. The `CanUpdate` and `CanAppend` member functions let you determine these conditions.  \n  \n When you call `AddNew`:  \n  \n-   The record in the edit buffer is stored, so its contents can be restored if the operation is canceled.  \n  \n-   The field data members are flagged so it is possible to detect changes in them later. The field data members are also marked clean (unchanged) and set to a Null.  \n  \n After you call `AddNew`, the edit buffer represents a new, empty record, ready to be filled in with values. To do this, you manually set the values by assigning to them. Instead of specifying an actual data value for a field, you can call `SetFieldNull` to specify the value Null.  \n  \n To commit your changes, you call **Update**. When you call **Update** for the new record:  \n  \n-   If your ODBC driver supports the **::SQLSetPos** ODBC API function, MFC uses the function to add the record on the data source. With **::SQLSetPos**, MFC can add a record more efficiently because it does not have to construct and process a SQL statement.  \n  \n-   If **::SQLSetPos** cannot be used, MFC does the following:  \n  \n    1.  If no changes are detected, **Update** does nothing and returns 0.  \n  \n    2.  If there are changes, **Update** constructs a SQL **INSERT** statement. The columns represented by all dirty field data members are listed in the **INSERT** statement. To force a column to be included, call the [SetFieldDirty](../../mfc/reference/crecordset-class.md#crecordset__setfielddirty) member function:  \n  \n        ```  \n        SetFieldDirty( &m_dataMember, TRUE );  \n        ```  \n  \n    3.  **Update** commits the new record — the **INSERT** statement is executed and the record is committed to the table on the data source (and the recordset, if not a snapshot) unless a transaction is in progress.  \n  \n    4.  The stored record is restored to the edit buffer. The record that was current before the `AddNew` call is current again regardless of whether the **INSERT** statement was successfully executed.  \n  \n    > [!TIP]\n    >  For complete control of a new record, take the following approach: set the values of any fields that will have values and then explicitly set any fields that will remain Null by calling `SetFieldNull` with a pointer to the field and the parameter **TRUE** (the default). If you want to ensure that a field is not written to the data source, call `SetFieldDirty` with a pointer to the field and the parameter **FALSE**, and do not modify the field's value. To determine whether a field is allowed to be Null, call `IsFieldNullable`.  \n  \n    > [!TIP]\n    >  To detect when recordset data members change value, MFC uses a **PSEUDO_NULL** value appropriate to each data type that you can store in a recordset. If you must explicitly set a field to the **PSEUDO_NULL** value and the field happens already to be marked Null, you must also call `SetFieldNull`, passing the address of the field in the first parameter and **FALSE** in the second parameter.  \n  \n##  <a name=\"_core_visibility_of_added_records\"></a> Visibility of Added Records  \n When is an added record visible to your recordset? Added records sometimes show up and sometimes are not visible, depending on two things:  \n  \n-   What your driver is capable of.  \n  \n-   What the framework can take advantage of.  \n  \n If your ODBC driver supports the **::SQLSetPos** ODBC API function, MFC uses the function to add records. With **::SQLSetPos**, added records are visible to any updatable MFC recordset. Without support for the function, added records are not visible and you must call **Requery** to see them. Using **::SQLSetPos** is also more efficient.  \n  \n##  <a name=\"_core_editing_an_existing_record\"></a> Editing an Existing Record  \n Editing an existing record in a recordset involves scrolling to the record, calling the recordset's [Edit](../../mfc/reference/crecordset-class.md#crecordset__edit) member function, setting the values of the new record's field data members, and calling the [Update](../../mfc/reference/crecordset-class.md#crecordset__update) member function to write the changed record to the data source.  \n  \n As a precondition for calling **Edit**, the recordset must be updatable and on a record. The `CanUpdate` and `IsDeleted` member functions let you determine these conditions. The current record also must not already have been deleted, and there must be records in the recordset (both `IsBOF` and `IsEOF` return 0).  \n  \n When you call **Edit**, the record in the edit buffer (the current record) is stored. The stored record's values are later used to detect whether any fields have changed.  \n  \n After you call **Edit**, the edit buffer still represents the current record but is now ready to accept changes to the field data members. To change the record, you manually set the values of any field data members you want to edit. Instead of specifying an actual data value for a field, you can call `SetFieldNull` to specify the value Null. To commit your changes, call **Update**.  \n  \n> [!TIP]\n>  To get out of `AddNew` or **Edit** mode, call **Move** with the parameter **AFX_MOVE_REFRESH**.  \n  \n As a precondition for calling **Update**, the recordset must not be empty and the current record must not have been deleted. `IsBOF`, `IsEOF`, and `IsDeleted` should all return 0.  \n  \n When you call **Update** for the edited record:  \n  \n-   If your ODBC driver supports the **::SQLSetPos** ODBC API function, MFC uses the function to update the record on the data source. With **::SQLSetPos**, the driver compares your edit buffer with the corresponding record on the server, updating the record on the server if the two are different. With **::SQLSetPos**, MFC can update a record more efficiently because it does not have to construct and process a SQL statement.  \n  \n     -or-  \n  \n-   If **::SQLSetPos** cannot be used, MFC does the following:  \n  \n    1.  If there have been no changes, **Update** does nothing and returns 0.  \n  \n    2.  If there are changes, **Update** constructs a SQL **UPDATE** statement. The columns listed in the **UPDATE** statement are based on the field data members that have changed.  \n  \n    3.  **Update** commits the changes — executes the **UPDATE** statement — and the record is changed on the data source, but not committed if a transaction is in progress (see [Transaction: Performing a Transaction in a Recordset (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md) for information about how the transaction affects the update). ODBC keeps a copy of the record, which also changes.  \n  \n    4.  Unlike the process for `AddNew`, the **Edit** process does not restore the stored record. The edited record remains in place as the current record.  \n  \n    > [!CAUTION]\n    >  When you prepare to update a recordset by calling **Update**, take care that your recordset includes all columns making up the primary key of the table (or all of the columns of any unique index on the table, or enough columns to uniquely identify the row). In some cases, the framework can use only the columns selected in your recordset to identify which record in your table to update. Without all the necessary columns, multiple records might be updated in the table. In this case, the framework throws exceptions when you call **Update**.  \n  \n    > [!TIP]\n    >  If you call `AddNew` or **Edit** after having called either function previously but before you call **Update**, the edit buffer is refreshed with the stored record, replacing the new or edited record in progress. This behavior gives you a way to abort an `AddNew` or **Edit** and begin a new one: if you determine that the record-in-progress is faulty, simply call **Edit** or `AddNew` again.  \n  \n##  <a name=\"_core_deleting_a_record\"></a> Deleting a Record  \n Deleting a record from a recordset involves scrolling to the record and calling the recordset's [Delete](../../mfc/reference/crecordset-class.md#crecordset__delete) member function. Unlike `AddNew` and **Edit**, **Delete** does not require a matching call to **Update**.  \n  \n As a precondition for calling **Delete**, the recordset must be updatable and it must be on a record. The `CanUpdate`, `IsBOF`, `IsEOF`, and `IsDeleted` member functions let you determine these conditions.  \n  \n When you call **Delete**:  \n  \n-   If your ODBC driver supports the **::SQLSetPos** ODBC API function, MFC uses the function to delete the record on the data source. Using **::SQLSetPos** is usually more efficient than using SQL.  \n  \n     -or-  \n  \n-   If **::SQLSetPos** cannot be used, MFC does the following:  \n  \n    1.  The current record in the edit buffer is not backed up as in `AddNew` and **Edit**.  \n  \n    2.  **Delete** constructs a SQL **DELETE** statement that removes the record.  \n  \n         The current record in the edit buffer is not stored as in `AddNew` and **Edit**.  \n  \n    3.  **Delete** commits the deletion — executes the **DELETE** statement. The record is marked deleted on the data source and, if the record is a snapshot, in ODBC.  \n  \n    4.  The deleted record's values are still in the field data members of the recordset, but the field data members are marked Null and the recordset's `IsDeleted` member function returns a nonzero value.  \n  \n    > [!NOTE]\n    >  After deleting a record, you should scroll to another record to refill the edit buffer with the new record's data. It is an error to call **Delete** again or to call **Edit**.  \n  \n For information about the SQL statements used in update operations, see [SQL](../../data/odbc/sql.md).  \n  \n## See Also  \n [Recordset (ODBC)](../../data/odbc/recordset-odbc.md)   \n [Recordset: More About Updates (ODBC)](../../data/odbc/recordset-more-about-updates-odbc.md)   \n [Record Field Exchange (RFX)](../../data/odbc/record-field-exchange-rfx.md)"}