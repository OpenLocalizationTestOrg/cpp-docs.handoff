{"nodes":[{"pos":[12,70],"content":"Concurrency::graphics namespace functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Concurrency::graphics namespace functions | Microsoft Docs","pos":[0,58]}]},{"content":"Concurrency::graphics namespace functions","pos":[312,353]},{"content":"copy Function (Concurrency::graphics Namespace)","pos":[370,417]},{"content":"copy_async Function (Concurrency::graphics Namespace)","pos":[436,489]},{"pos":[553,600],"content":"copy Function (Concurrency::graphics Namespace)"},{"content":"Copies a source texture into a destination buffer, or copies a source buffer into a destination buffer.","pos":[604,707]},{"content":"The general form of this function is <ph id=\"ph1\">`copy(src, dest)`</ph>.","pos":[708,763],"source":" The general form of this function is `copy(src, dest)`."},{"content":"Parameters","pos":[3917,3927]},{"content":"The extent of the texture section to be copied.","pos":[3949,3996]},{"content":"The object to copy to.","pos":[4013,4035]},{"content":"The number of bytes in the destination.","pos":[4062,4101]},{"content":"The type of the destination object.","pos":[4123,4158]},{"content":"The offset into the destination at which to begin copying.","pos":[4182,4240]},{"content":"The type of the input interator.","pos":[4266,4298]},{"content":"The type of the output iterator.","pos":[4325,4357]},{"content":"To object to copy.","pos":[4374,4392]},{"content":"The number of bytes in the source.","pos":[4419,4453]},{"content":"The type of the source object.","pos":[4475,4505]},{"content":"The offset into the source from which to begin copying.","pos":[4529,4584]},{"content":"A beginning iterator into the source container.","pos":[4602,4649]},{"content":"An ending iterator into the source container.","pos":[4666,4711]},{"pos":[4757,4810],"content":"copy_async Function (Concurrency::graphics Namespace)"},{"content":"Asynchronously copies a source texture into a destination buffer, or copies a source buffer into a destination buffer, and then returns a <bpt id=\"p1\">[</bpt>completion_future<ept id=\"p1\">](completion-future-class.md)</ept> object that can be waited on.","pos":[4814,5029],"source":"Asynchronously copies a source texture into a destination buffer, or copies a source buffer into a destination buffer, and then returns a [completion_future](completion-future-class.md) object that can be waited on."},{"content":"Data can't be copied when code is running on an accelerator.","pos":[5030,5090]},{"content":"The general form of this function is <ph id=\"ph1\">`copy(src, dest)`</ph>.","pos":[5091,5146],"source":" The general form of this function is `copy(src, dest)`."},{"content":"Parameters","pos":[8567,8577]},{"content":"The extent of the texture section to be copied.","pos":[8599,8646]},{"content":"The object to copy to.","pos":[8663,8685]},{"content":"The number of bytes in the destination.","pos":[8712,8751]},{"content":"The type of the destination object.","pos":[8773,8808]},{"content":"The offset into the destination at which to begin copying.","pos":[8832,8890]},{"content":"The type of the input interator.","pos":[8916,8948]},{"content":"The type of the output iterator.","pos":[8975,9007]},{"content":"To object to copy.","pos":[9024,9042]},{"content":"The number of bytes in the source.","pos":[9069,9103]},{"content":"The type of the source object.","pos":[9125,9155]},{"content":"The offset into the source from which to begin copying.","pos":[9179,9234]},{"content":"A beginning iterator into the source container.","pos":[9252,9299]},{"content":"An ending iterator into the source container.","pos":[9316,9361]},{"content":"See Also","pos":[9370,9378]},{"content":"Concurrency::graphics Namespace","pos":[9383,9414]}],"content":"---\ntitle: \"Concurrency::graphics namespace functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: ace01cd5-29d3-4356-930e-c81a61c5f934\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\n---\n# Concurrency::graphics namespace functions\n|||  \n|-|-|  \n|[copy Function (Concurrency::graphics Namespace)](#copy_function)|[copy_async Function (Concurrency::graphics Namespace)](#copy_async_function)|  \n  \n##  <a name=\"copy_function\"></a>  copy Function (Concurrency::graphics Namespace)  \n Copies a source texture into a destination buffer, or copies a source buffer into a destination buffer. The general form of this function is `copy(src, dest)`.  \n  \n```  \ntemplate <\n    typename _Src_type,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture, void>::type>  \n>  \nvoid copy (\n    const _Src_type& _Src,  \n    _Out_ void* _Dst,  \n    unsigned int _Dst_byte_size);\n\n \ntemplate <\n    typename _Src_type,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture, void>::type  \n>  \nvoid copy(\n    const _Src_type& _Src,  \n    const index<_Src_type::rank>& _Src_offset,  \n    const extent<_Src_type::rank>& _Copy_extent,  \n    _Out_ void* _Dst,  \n    unsigned int _Dst_byte_size);\n\n \ntemplate <\n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Dst_type>::is_texture, void>::type  \n>  \nvoid copy(\n    const void* _Src,  \n    unsigned int _Src_byte_size, _Dst_type& _Dst);\n\n \ntemplate <\n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Dst_type>::is_texture, void>::type  \n>  \nvoid copy(\n    const void* _Src,  \n    unsigned int _Src_byte_size,  \n    _Dst_type& _Dst,  \n    const index<_Dst_type::rank>& _Dst_offset,  \n    const extent<_Dst_type::rank>& _Copy_extent);\n\n \ntemplate <\n    typename InputIterator,  \n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Dst_type>::is_texture, void>::type  \n>  \nvoid copy(InputIterator first, InputIterator last, _Dst_type& _Dst);\n\n \ntemplate <\n    typename InputIterator,  \n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Dst_type>::is_texture, void>::type  \n>void copy(InputIterator first, InputIterator last, _Dst_type& _Dst,  \n    const index<_Dst_type::rank>& _Dst_offset,  \n    const extent<_Dst_type::rank>& _Copy_extent);\n\n \ntemplate <\n    typename _Src_type,  \n    typename OutputIterator,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture&& !details::texture_traits<OutputIterator>::is_texture, void>::type  \n>  \nvoid copy(\n    const _Src_type& _Src, OutputIterator _Dst);\n\n \ntemplate <\n    typename _Src_type,  \n    typename OutputIterator,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture&& !details::texture_traits<OutputIterator>::is_texture, void>::type  \n>  \nvoid copy (\n    const _Src_type& _Src,  \n    const index<_Src_type::rank>& _Src_offset,  \n    const extent<_Src_type::rank>& _Copy_extent, OutputIterator _Dst);\n\n \ntemplate <\n    typename _Src_type,  \n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture&& details::texture_traits<_Dst_type>::is_texture, void>::type  \n>  \nvoid copy (\n    const _Src_type& _Src, _Dst_type& _Dst);\n\n \ntemplate <\n    typename _Src_type,  \n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture&& details::texture_traits<_Dst_type>::is_texture,  \n    void>::type \n>  \nvoid copy (\n    const _Src_type& _Src,  \n    const index<_Src_type::rank>& _Src_offset, _Dst_type& _Dst,  \n    const index<_Dst_type::rank>& _Dst_offset,  \n    const extent<_Src_type::rank>& _Copy_extent);\n```  \n  \n### Parameters  \n `_Copy_extent`  \n The extent of the texture section to be copied.  \n  \n `_Dst`  \n The object to copy to.  \n  \n `_Dst_byte_size`  \n The number of bytes in the destination.  \n  \n `_Dst_type`  \n The type of the destination object.  \n  \n `_Dst_offset`  \n The offset into the destination at which to begin copying.  \n  \n `InputIterator`  \n The type of the input interator.  \n  \n `OutputIterator`  \n The type of the output iterator.  \n  \n `_Src`  \n To object to copy.  \n  \n `_Src_byte_size`  \n The number of bytes in the source.  \n  \n `_Src_type`  \n The type of the source object.  \n  \n `_Src_offset`  \n The offset into the source from which to begin copying.  \n  \n `first`  \n A beginning iterator into the source container.  \n  \n `last`  \n An ending iterator into the source container.  \n  \n##  <a name=\"copy_async_function\"></a>  copy_async Function (Concurrency::graphics Namespace)  \n Asynchronously copies a source texture into a destination buffer, or copies a source buffer into a destination buffer, and then returns a [completion_future](completion-future-class.md) object that can be waited on. Data can't be copied when code is running on an accelerator. The general form of this function is `copy(src, dest)`.  \n  \n```  \ntemplate<\n    typename _Src_type,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture, void>::type  \n>  \nconcurrency::completion_future copy_async(\n    const _Src_type& _Src,  \n    _Out_ void* _Dst,  \n    unsigned int _Dst_byte_size);\n\n \ntemplate<\n    typename _Src_type,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture, void>::type  \n>  \nconcurrency::completion_future copy_async(\n    const _Src_type& _Src,  \n    const index<_Src_type::rank>& _Src_offset,  \n    const extent<_Src_type::rank>& _Copy_extent,  \n    _Out_ void* _Dst,  \n    unsigned int _Dst_byte_size);\n\n \ntemplate <\n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Dst_type>::is_texture, void>::type  \n>  \nconcurrency::completion_future copy_async(\n    const void* _Src,  \n    unsigned int _Src_byte_size, _Dst_type& _Dst);\n\n \ntemplate <\n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Dst_type>::is_texture, void>::type  \n>  \nconcurrency::completion_future copy_async(\n    const void* _Src,  \n    unsigned int _Src_byte_size, _Dst_type& _Dst,  \n    const index<_Dst_type::rank>& _Dst_offset,  \n    const extent<_Dst_type::rank>& _Copy_extent);\n\n \ntemplate <\n    typename InputIterator,  \n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Dst_type>::is_texture, void>::type  \n>  \nconcurrency::completion_future copy_async(InputIterator first, InputIterator last, _Dst_type& _Dst);\n\n \ntemplate <\n    typename InputIterator,  \n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Dst_type>::is_texture, void>::type  \n>  \nconcurrency::completion_future copy_async(InputIterator first, InputIterator last, _Dst_type& _Dst,  \n    const index<_Dst_type::rank>& _Dst_offset,  \n    const extent<_Dst_type::rank>& _Copy_extent);\n\n \ntemplate <\n    typename _Src_type,  \n    typename OutputIterator,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture&& !details::texture_traits<OutputIterator>::is_texture, void>::type  \n>  \nconcurrency::completion_future copy_async(_Src_type& _Src, OutputIterator _Dst);\n\n \ntemplate <\n    typename _Src_type,  \n    typename OutputIterator,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture&& !details::texture_traits<OutputIterator>::is_texture, void>::type  \n>  \nconcurrency::completion_future copy_async(_Src_type& _Src,  \n    const index<_Src_type::rank>& _Src_offset,  \n    const extent<_Src_type::rank>& _Copy_extent,  \n    OutputIterator _Dst);\n\n \ntemplate <\n    typename _Src_type,  \n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture&& details::texture_traits<_Dst_type>::is_texture, void>::type  \n>  \nconcurrency::completion_future copy_async(_Src_type& _Src, _Dst_type& _Dst);\n\n \ntemplate <\n    typename _Src_type,  \n    typename _Dst_type,  \n    typename = typename std::enable_if<details::texture_traits<_Src_type>::is_texture&& details::texture_traits<_Dst_type>::is_texture, void>::type  \n>  \nconcurrency::completion_future copy_async(_Src_type& _Src,  \n    const index<_Src_type::rank>& _Src_offset, _Dst_type &_Dst,  \n    const index<_Dst_type::rank>& _Dst_offset,  \n    const extent<_Src_type::rank>& _Copy_extent);\n```  \n  \n### Parameters  \n `_Copy_extent`  \n The extent of the texture section to be copied.  \n  \n `_Dst`  \n The object to copy to.  \n  \n `_Dst_byte_size`  \n The number of bytes in the destination.  \n  \n `_Dst_type`  \n The type of the destination object.  \n  \n `_Dst_offset`  \n The offset into the destination at which to begin copying.  \n  \n `InputIterator`  \n The type of the input interator.  \n  \n `OutputIterator`  \n The type of the output iterator.  \n  \n `_Src`  \n To object to copy.  \n  \n `_Src_byte_size`  \n The number of bytes in the source.  \n  \n `_Src_type`  \n The type of the source object.  \n  \n `_Src_offset`  \n The offset into the source from which to begin copying.  \n  \n `first`  \n A beginning iterator into the source container.  \n  \n `last`  \n An ending iterator into the source container.  \n  \n## See Also  \n [Concurrency::graphics Namespace](concurrency-graphics-namespace.md)\n"}