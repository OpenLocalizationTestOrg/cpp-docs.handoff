{"nodes":[{"pos":[12,54],"content":"&lt;utility&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"utility<ph id=\"ph1\">&amp;gt;</ph> functions | Microsoft Docs","pos":[4,42],"source":"utility&gt; functions | Microsoft Docs"}]},{"content":"utility<ph id=\"ph1\">&amp;gt;</ph> functions","pos":[260,281],"source":"utility&gt; functions"},{"content":"exchange","pos":[301,309]},{"content":"forward","pos":[323,330]},{"content":"get Function <ph id=\"ph1\">&amp;lt;</ph>utility","pos":[343,367],"source":"get Function &lt;utility"},{"content":"make_pair","pos":[384,393]},{"content":"move","pos":[408,412]},{"content":"swap","pos":[422,426]},{"pos":[470,478],"content":"exchange"},{"pos":[482,553],"content":"<bpt id=\"p1\">**</bpt>(C++14)<ept id=\"p1\">**</ept> Assigns a new value to an object and returns its old value.","source":"**(C++14)** Assigns a new value to an object and returns its old value."},{"content":"Parameters","pos":[651,661]},{"content":"The object that will receive the value of new_val.","pos":[674,724]},{"content":"The object whose value is copied or moved into val.","pos":[744,795]},{"content":"Remarks","pos":[805,812]},{"content":"For complex types, <ph id=\"ph1\">`exchange`</ph> avoids copying the old value when a move constructor is available, avoids copying the new value if it’s a temporary object or is moved, and accepts any type as the new value, using any available converting assignment operator.","pos":[816,1072],"source":"For complex types, `exchange` avoids copying the old value when a move constructor is available, avoids copying the new value if it’s a temporary object or is moved, and accepts any type as the new value, using any available converting assignment operator."},{"content":"The exchange function is different from <bpt id=\"p1\">[</bpt>std::swap<ept id=\"p1\">](../standard-library/algorithm-functions.md#swap)</ept> in that the left argument is not moved or copied to the right argument.","pos":[1073,1245],"source":" The exchange function is different from [std::swap](../standard-library/algorithm-functions.md#swap) in that the left argument is not moved or copied to the right argument."},{"content":"Example","pos":[1255,1262]},{"content":"The following example shows how to use <ph id=\"ph1\">`exchange`</ph>.","pos":[1267,1317],"source":"The following example shows how to use `exchange`."},{"content":"In the real world, <ph id=\"ph1\">`exchange`</ph> is most useful with large objects that are expensive to copy:","pos":[1318,1409],"source":" In the real world, `exchange` is most useful with large objects that are expensive to copy:"},{"pos":[1910,1917],"content":"forward"},{"content":"Conditionally casts its argument to an rvalue reference if the argument is an rvalue or rvalue reference.","pos":[1921,2026]},{"content":"This restores the rvalue-ness of an argument to the forwarding function in support of perfect forwarding.","pos":[2027,2132]},{"content":"Parameters","pos":[2409,2419]},{"content":"Parameter","pos":[2426,2435]},{"content":"Description","pos":[2436,2447]},{"content":"The type of the value passed in <ph id=\"ph1\">`Arg`</ph>, which might be different than the type of <ph id=\"ph2\">`Arg`</ph>.","pos":[2497,2584],"source":"The type of the value passed in `Arg`, which might be different than the type of `Arg`."},{"content":"Typically determined by a template argument of the forwarding function.","pos":[2585,2656]},{"content":"The argument to cast.","pos":[2667,2688]},{"content":"Return Value","pos":[2699,2711]},{"pos":[2715,2887],"content":"Returns an rvalue reference to <ph id=\"ph1\">`Arg`</ph> if the value passed in <ph id=\"ph2\">`Arg`</ph> was originally an rvalue or a reference to an rvalue; otherwise, returns <ph id=\"ph3\">`Arg`</ph> without modifying its type.","source":"Returns an rvalue reference to `Arg` if the value passed in `Arg` was originally an rvalue or a reference to an rvalue; otherwise, returns `Arg` without modifying its type."},{"content":"Remarks","pos":[2897,2904]},{"pos":[2908,2973],"content":"You must specify an explicit template argument to call <ph id=\"ph1\">`forward`</ph>.","source":"You must specify an explicit template argument to call `forward`."},{"content":"does not forward its argument.","pos":[2990,3020]},{"content":"Instead, by conditionally casting its argument to an rvalue reference if it was originally an rvalue or rvalue reference, <ph id=\"ph1\">`forward`</ph> enables the compiler to perform overload resolution with knowledge of the forwarded argument's original type.","pos":[3021,3262],"source":" Instead, by conditionally casting its argument to an rvalue reference if it was originally an rvalue or rvalue reference, `forward` enables the compiler to perform overload resolution with knowledge of the forwarded argument's original type."},{"content":"The apparent type of an argument to a forwarding function might be different than its original type—for example, when an rvalue is used as an argument to a function and is bound to a parameter name; having a name makes it an lvalue, regardless of whether the value actually exists as an rvalue— <ph id=\"ph1\">`forward`</ph> restores the rvalue-ness of the argument.","pos":[3263,3609],"source":" The apparent type of an argument to a forwarding function might be different than its original type—for example, when an rvalue is used as an argument to a function and is bound to a parameter name; having a name makes it an lvalue, regardless of whether the value actually exists as an rvalue— `forward` restores the rvalue-ness of the argument."},{"content":"Restoring the rvalue-ness of an argument's original value in order to perform overload resolution is known as <bpt id=\"p1\">*</bpt>perfect forwarding<ept id=\"p1\">*</ept>.","pos":[3616,3747],"source":"Restoring the rvalue-ness of an argument's original value in order to perform overload resolution is known as *perfect forwarding*."},{"content":"Perfect forwarding enables a template function to accept an argument of either reference type and to restore its rvalue-ness when it's necessary for correct overload resolution.","pos":[3748,3925]},{"content":"By using perfect forwarding, you can preserve move semantics for rvalues and avoid having to provide overloads for functions that vary only by the reference type of their arguments.","pos":[3926,4107]},{"pos":[4137,4140],"content":"get"},{"pos":[4144,4211],"content":"Gets an element from a <ph id=\"ph1\">`pair`</ph> object by index position, or by type.","source":"Gets an element from a `pair` object by index position, or by type."},{"content":"Parameters","pos":[5547,5557]},{"content":"The 0-based index of the designated element.","pos":[5572,5616]},{"content":"The type of the first pair element.","pos":[5631,5666]},{"content":"The type of the second pair element.","pos":[5681,5717]},{"content":"The pair to select from.","pos":[5732,5756]},{"content":"Remarks","pos":[5766,5773]},{"pos":[5777,5861],"content":"The template functions each return a reference to an element of its <ph id=\"ph1\">`pair`</ph> argument.","source":"The template functions each return a reference to an element of its `pair` argument."},{"content":"For the indexed overloads, if the value of <ph id=\"ph1\">`Index`</ph> is 0 the functions return <ph id=\"ph2\">`pr.first`</ph> and if the value of <ph id=\"ph3\">`Index`</ph> is 1 the functions return <ph id=\"ph4\">`pr.second`</ph>.","pos":[5868,6022],"source":"For the indexed overloads, if the value of `Index` is 0 the functions return `pr.first` and if the value of `Index` is 1 the functions return `pr.second`."},{"content":"The type <ph id=\"ph1\">`RI`</ph> is the type of the returned element.","pos":[6023,6073],"source":" The type `RI` is the type of the returned element."},{"content":"For the overloads that do not have an Index parameter, the element to return is deduced by the type argument.","pos":[6080,6189]},{"content":"Calling <ph id=\"ph1\">`get&lt;T&gt;(Tuple)`</ph> will produce a compiler error if <ph id=\"ph2\">`pr`</ph> contains more or less than one element of type T.","pos":[6190,6301],"source":" Calling `get<T>(Tuple)` will produce a compiler error if `pr` contains more or less than one element of type T."},{"content":"Example","pos":[6311,6318]},{"pos":[6810,6819],"content":"make_pair"},{"pos":[6823,7002],"content":"A template function that you can use to construct objects of type <ph id=\"ph1\">`pair`</ph>, where the component types are automatically chosen based on the data types that are passed as parameters.","source":"A template function that you can use to construct objects of type `pair`, where the component types are automatically chosen based on the data types that are passed as parameters."},{"content":"Parameters","pos":[7304,7314]},{"content":"Value that initializes the first element of <ph id=\"ph1\">`pair`</ph>.","pos":[7328,7379],"source":" Value that initializes the first element of `pair`."},{"content":"Value that initializes the second element of <ph id=\"ph1\">`pair`</ph>.","pos":[7396,7448],"source":" Value that initializes the second element of `pair`."},{"content":"Return Value","pos":[7458,7470]},{"pos":[7474,7545],"content":"The pair object that's constructed: <ph id=\"ph1\">`pair`&lt; `T`</ph>, <ph id=\"ph2\">`U`</ph>&gt;( <ph id=\"ph3\">`Val1`</ph>, <ph id=\"ph4\">`Val2`</ph>).","source":"The pair object that's constructed: `pair`< `T`, `U`>( `Val1`, `Val2`)."},{"content":"Remarks","pos":[7555,7562]},{"pos":[7578,7750],"content":"converts object of type <bpt id=\"p1\">[</bpt>reference_wrapper Class<ept id=\"p1\">](../standard-library/reference-wrapper-class.md)</ept> to reference types and converts decaying arrays and functions to pointers.","source":" converts object of type [reference_wrapper Class](../standard-library/reference-wrapper-class.md) to reference types and converts decaying arrays and functions to pointers."},{"pos":[7757,7817],"content":"In the returned <ph id=\"ph1\">`pair`</ph> object, <ph id=\"ph2\">`T`</ph> is determined as follows:","source":"In the returned `pair` object, `T` is determined as follows:"},{"pos":[7827,7906],"content":"If the input type <ph id=\"ph1\">`T`</ph> is <ph id=\"ph2\">`reference_wrapper&lt;X&gt;`</ph>, the returned type <ph id=\"ph3\">`T`</ph> is <ph id=\"ph4\">`X&amp;`</ph>.","source":"If the input type `T` is `reference_wrapper<X>`, the returned type `T` is `X&`."},{"content":"Otherwise, the returned type <ph id=\"ph1\">`T`</ph> is <ph id=\"ph2\">`decay&lt;T&gt;::type`</ph>.","pos":[7916,7969],"source":"Otherwise, the returned type `T` is `decay<T>::type`."},{"content":"If <bpt id=\"p1\">[</bpt>decay Class<ept id=\"p1\">](../standard-library/decay-class.md)</ept> is not supported, the returned type <ph id=\"ph1\">`T`</ph> is the same as the input type <ph id=\"ph2\">`T`</ph>.","pos":[7970,8097],"source":" If [decay Class](../standard-library/decay-class.md) is not supported, the returned type `T` is the same as the input type `T`."},{"pos":[8104,8174],"content":"The returned type <ph id=\"ph1\">`U`</ph> is similarly determined from the input type <ph id=\"ph2\">`U`</ph>.","source":"The returned type `U` is similarly determined from the input type `U`."},{"content":"One advantage of <ph id=\"ph1\">`make_pair`</ph> is that the types of objects that are being stored are determined automatically by the compiler and do not have to be explicitly specified.","pos":[8181,8349],"source":"One advantage of `make_pair` is that the types of objects that are being stored are determined automatically by the compiler and do not have to be explicitly specified."},{"content":"Don't use explicit template arguments such as <ph id=\"ph1\">`make_pair&lt;int, int&gt;(1, 2)`</ph> when you use <ph id=\"ph2\">`make_pair`</ph> because it is unnecessarily verbose and adds complex rvalue reference problems that might cause compilation failure.","pos":[8350,8565],"source":" Don't use explicit template arguments such as `make_pair<int, int>(1, 2)` when you use `make_pair` because it is unnecessarily verbose and adds complex rvalue reference problems that might cause compilation failure."},{"content":"For this example, the correct syntax would be","pos":[8566,8611]},{"pos":[8636,8767],"content":"The <ph id=\"ph1\">`make_pair`</ph> helper function also makes it possible to pass two values to a function that requires a pair as an input parameter.","source":"The `make_pair` helper function also makes it possible to pass two values to a function that requires a pair as an input parameter."},{"content":"Example","pos":[8777,8784]},{"pos":[8789,8947],"content":"For an example about how to use the helper function <ph id=\"ph1\">`make_pair`</ph> to declare and initialize a pair, see <bpt id=\"p1\">[</bpt>pair Structure<ept id=\"p1\">](../standard-library/pair-structure.md)</ept>.","source":"For an example about how to use the helper function `make_pair` to declare and initialize a pair, see [pair Structure](../standard-library/pair-structure.md)."},{"pos":[8978,8982],"content":"move"},{"content":"Unconditionally casts its argument to an rvalue reference, and thereby signals that it can be moved if its type is move-enabled.","pos":[8986,9114]},{"content":"Parameters","pos":[9236,9246]},{"content":"Parameter","pos":[9253,9262]},{"content":"Description","pos":[9263,9274]},{"pos":[9324,9431],"content":"A type deduced from the type of the argument passed in <ph id=\"ph1\">`Arg`</ph>, together with the reference collapsing rules.","source":"A type deduced from the type of the argument passed in `Arg`, together with the reference collapsing rules."},{"content":"The argument to cast.","pos":[9442,9463]},{"content":"Although the type of <ph id=\"ph1\">`Arg`</ph> appears to be specified as an rvalue reference, <ph id=\"ph2\">`move`</ph> also accepts lvalue arguments because lvalue references can bind to rvalue references.","pos":[9464,9632],"source":" Although the type of `Arg` appears to be specified as an rvalue reference, `move` also accepts lvalue arguments because lvalue references can bind to rvalue references."},{"content":"Return Value","pos":[9643,9655]},{"pos":[9665,9733],"content":"as an rvalue reference, whether or not its type is a reference type."},{"content":"Remarks","pos":[9743,9750]},{"content":"The template argument <ph id=\"ph1\">`Type`</ph> is not intended to be specified explicitly, but to be deduced from the type of the value passed in <ph id=\"ph2\">`Arg`</ph>.","pos":[9754,9888],"source":"The template argument `Type` is not intended to be specified explicitly, but to be deduced from the type of the value passed in `Arg`."},{"content":"The type of <ph id=\"ph1\">`Type`</ph> is further adjusted according to the reference collapsing rules.","pos":[9889,9972],"source":" The type of `Type` is further adjusted according to the reference collapsing rules."},{"content":"does not move its argument.","pos":[9986,10013]},{"content":"Instead, by unconditionally casting its argument—which might be an lvalue—to an rvalue reference, it enables the compiler to subsequently move, rather than copy, the value passed in <ph id=\"ph1\">`Arg`</ph> if its type is move-enabled.","pos":[10014,10230],"source":" Instead, by unconditionally casting its argument—which might be an lvalue—to an rvalue reference, it enables the compiler to subsequently move, rather than copy, the value passed in `Arg` if its type is move-enabled."},{"content":"If its type is not move-enabled, it is copied instead.","pos":[10231,10285]},{"content":"If the value passed in <ph id=\"ph1\">`Arg`</ph> is an lvalue—that is, it has a name or its address can be taken—it's invalidated when the move occurs.","pos":[10292,10423],"source":"If the value passed in `Arg` is an lvalue—that is, it has a name or its address can be taken—it's invalidated when the move occurs."},{"content":"Do not refer to the value passed in <ph id=\"ph1\">`Arg`</ph> by its name or address after it's been moved.","pos":[10424,10511],"source":" Do not refer to the value passed in `Arg` by its name or address after it's been moved."},{"pos":[10542,10546],"content":"swap"},{"pos":[10550,10644],"content":"Exchanges the elements of two <bpt id=\"p1\">[</bpt>pair Structure<ept id=\"p1\">](../standard-library/pair-structure.md)</ept> objects.","source":"Exchanges the elements of two [pair Structure](../standard-library/pair-structure.md) objects."},{"content":"Parameters","pos":[10745,10755]},{"content":"Parameter","pos":[10762,10771]},{"content":"Description","pos":[10772,10783]},{"pos":[10833,10858],"content":"An object of type <ph id=\"ph1\">`pair`</ph>.","source":"An object of type `pair`."},{"pos":[10871,10896],"content":"An object of type <ph id=\"ph1\">`pair`</ph>.","source":"An object of type `pair`."},{"content":"Remarks","pos":[10907,10914]},{"content":"One advantage of <ph id=\"ph1\">`swap`</ph> is that the types of objects that are being stored are determined automatically by the compiler and do not have to be explicitly specified.","pos":[10918,11081],"source":"One advantage of `swap` is that the types of objects that are being stored are determined automatically by the compiler and do not have to be explicitly specified."},{"content":"Don't use explicit template arguments such as <ph id=\"ph1\">`swap&lt;int, int&gt;(1, 2)`</ph> when you use <ph id=\"ph2\">`swap`</ph> because it is unnecessarily verbose and adds complex rvalue reference problems that might cause compilation failure.","pos":[11082,11287],"source":" Don't use explicit template arguments such as `swap<int, int>(1, 2)` when you use `swap` because it is unnecessarily verbose and adds complex rvalue reference problems that might cause compilation failure."},{"content":"See Also","pos":[11296,11304]},{"content":"utility&gt;","pos":[11311,11319],"source":"utility>"}],"content":"---\ntitle: \"&lt;utility&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: b1df38cd-3a59-4098-9c81-83342eb719a4\ncaps.latest.revision: 7\nmanager: \"ghogen\"\n---\n# &lt;utility&gt; functions\n||||  \n|-|-|-|  \n|[exchange](#exchange)|[forward](#forward)|[get Function &lt;utility&gt;](#get)|  \n|[make_pair](#make_pair)|[move](#move)|[swap](#swap)|  \n  \n##  <a name=\"exchange\"></a>  exchange  \n **(C++14)** Assigns a new value to an object and returns its old value.  \n  \n```cpp\ntemplate <class T, class Other = T>\nT exchange(T& val, Other&& new_val)\n```  \n  \n### Parameters  \n `val`  \n The object that will receive the value of new_val.  \n  \n `new_val`  \n The object whose value is copied or moved into val.  \n  \n### Remarks  \n For complex types, `exchange` avoids copying the old value when a move constructor is available, avoids copying the new value if it’s a temporary object or is moved, and accepts any type as the new value, using any available converting assignment operator. The exchange function is different from [std::swap](../standard-library/algorithm-functions.md#swap) in that the left argument is not moved or copied to the right argument.  \n  \n### Example  \n  The following example shows how to use `exchange`. In the real world, `exchange` is most useful with large objects that are expensive to copy:  \n  \n```  \n#include <utility>  \n#include <iostream>  \n  \nusing namespace std;  \n  \nstruct C  \n{  \nint i;  \n//...  \n};  \nint main()  \n{     \n// Use brace initialization   \nC c1{ 1 };  \nC c2{ 2 };  \nC result = exchange(c1, c2);  \ncout << \"The old value of c1 is: \" << result.i << endl;  \ncout << \"The new value of c1 after exchange is: \" << c1.i << endl;  \n  \nreturn 0;  \n}  \n/* Output:  \nThe old value of c1 is: 1  \nThe new value of c1 after exchange is: 2  \n*/  \n```  \n  \n##  <a name=\"forward\"></a>  forward  \n Conditionally casts its argument to an rvalue reference if the argument is an rvalue or rvalue reference. This restores the rvalue-ness of an argument to the forwarding function in support of perfect forwarding.  \n  \n```\ntemplate <class Type>    // accepts lvalues\nconstexpr Type&& forward(typename remove_reference<Type>::type& Arg) noexcept\n\ntemplate <class Type>    // accepts everything else\nconstexpr Type&& forward(typename remove_reference<Type>::type&& Arg) noexcept\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|`Type`|The type of the value passed in `Arg`, which might be different than the type of `Arg`. Typically determined by a template argument of the forwarding function.|  \n|`Arg`|The argument to cast.|  \n  \n### Return Value  \n Returns an rvalue reference to `Arg` if the value passed in `Arg` was originally an rvalue or a reference to an rvalue; otherwise, returns `Arg` without modifying its type.  \n  \n### Remarks  \n You must specify an explicit template argument to call `forward`.  \n  \n `forward` does not forward its argument. Instead, by conditionally casting its argument to an rvalue reference if it was originally an rvalue or rvalue reference, `forward` enables the compiler to perform overload resolution with knowledge of the forwarded argument's original type. The apparent type of an argument to a forwarding function might be different than its original type—for example, when an rvalue is used as an argument to a function and is bound to a parameter name; having a name makes it an lvalue, regardless of whether the value actually exists as an rvalue— `forward` restores the rvalue-ness of the argument.  \n  \n Restoring the rvalue-ness of an argument's original value in order to perform overload resolution is known as *perfect forwarding*. Perfect forwarding enables a template function to accept an argument of either reference type and to restore its rvalue-ness when it's necessary for correct overload resolution. By using perfect forwarding, you can preserve move semantics for rvalues and avoid having to provide overloads for functions that vary only by the reference type of their arguments.  \n  \n##  <a name=\"get\"></a>  get  \n Gets an element from a `pair` object by index position, or by type.  \n  \n```\n// get reference to element at Index in pair Pr\ntemplate <size_t Index, class T1, class T2>\nconstexpr tuple_element_t<Index, pair<T1, T2>>&\nget(pair<T1, T2>& Pr) noexcept;\n\n// get reference to element T1 in pair Pr\ntemplate <class T1, class T2>\nconstexpr T1& get(pair<T1, T2>& Pr) noexcept;\n\n// get reference to element T2 in pair Pr\ntemplate <class T2, class T1>\nconstexpr T2& get(pair<T1, T2>& Pr) noexcept;\n\n// get const reference to element at Index in pair Pr\ntemplate <size_t Index, class T1, class T2>\nconstexpr const tuple_element_t<Index, pair<T1, T2>>&\nget(const pair<T1, T2>& Pr) noexcept;\n\n// get const reference to element T1 in pair Pr\ntemplate <class T1, class T2>\nconstexpr const T1& get(const pair<T1, T2>& Pr) noexcept;\n\n// get const reference to element T2 in pair Pr\ntemplate <class T2, class T1>\nconstexpr const T2& get(const pair<T1, T2>& Pr) noexcept;\n\n// get rvalue reference to element at Index in pair Pr\ntemplate <size_t Index, class T1, class T2>\nconstexpr tuple_element_t<Index, pair<T1, T2>>&&\nget(pair<T1, T2>&& Pr) noexcept;\n\n// get rvalue reference to element T1 in pair Pr\ntemplate <class T1, class T2>\nconstexpr T1&& get(pair<T1, T2>&& Pr) noexcept;\n\n// get rvalue reference to element T2 in pair Pr\ntemplate <class T2, class T1>\nconstexpr T2&& get(pair<T1, T2>&& Pr) noexcept;\n```  \n  \n### Parameters  \n `Index`  \n The 0-based index of the designated element.  \n  \n `T1`  \n The type of the first pair element.  \n  \n `T2`  \n The type of the second pair element.  \n  \n `pr`  \n The pair to select from.  \n  \n### Remarks  \n The template functions each return a reference to an element of its `pair` argument.  \n  \n For the indexed overloads, if the value of `Index` is 0 the functions return `pr.first` and if the value of `Index` is 1 the functions return `pr.second`. The type `RI` is the type of the returned element.  \n  \n For the overloads that do not have an Index parameter, the element to return is deduced by the type argument. Calling `get<T>(Tuple)` will produce a compiler error if `pr` contains more or less than one element of type T.  \n  \n### Example  \n  \n```cpp  \n#include <utility>  \n#include <iostream>   \nusing namespace std;  \nint main()\n{\n\n    typedef pair<int, double> MyPair;\n\n    MyPair c0(9, 3.14);\n\n    // get elements by index  \n    cout << \" \" << get<0>(c0);\n    cout << \" \" << get<1>(c0) << endl;\n\n    // get elements by type (C++14)  \n    MyPair c1(1, 0.27);\n    cout << \" \" << get<int>(c1);\n    cout << \" \" << get<double>(c1) << endl;\n\n    /*\n    Output:\n    9 3.14\n    1 0.27\n    */\n\n}\n```  \n  \n##  <a name=\"make_pair\"></a>  make_pair  \n A template function that you can use to construct objects of type `pair`, where the component types are automatically chosen based on the data types that are passed as parameters.  \n  \n```\ntemplate <class T, class U>\npair<T, U> make_pair(T& Val1, U& Val2);\n\ntemplate <class T, class U>\npair<T, U> make_pair(T& Val1, U&& Val2);\n\ntemplate <class T, class U>\npair<T, U> make_pair(T&& Val1, U& Val2);\n\ntemplate <class T, class U>\npair<T, U> make_pair(T&& Val1, U&& Val2);\n```  \n  \n### Parameters  \n `Val1`  \n Value that initializes the first element of `pair`.  \n  \n `Val2`  \n Value that initializes the second element of `pair`.  \n  \n### Return Value  \n The pair object that's constructed: `pair`< `T`, `U`>( `Val1`, `Val2`).  \n  \n### Remarks  \n `make_pair` converts object of type [reference_wrapper Class](../standard-library/reference-wrapper-class.md) to reference types and converts decaying arrays and functions to pointers.  \n  \n In the returned `pair` object, `T` is determined as follows:  \n  \n-   If the input type `T` is `reference_wrapper<X>`, the returned type `T` is `X&`.  \n  \n-   Otherwise, the returned type `T` is `decay<T>::type`. If [decay Class](../standard-library/decay-class.md) is not supported, the returned type `T` is the same as the input type `T`.  \n  \n The returned type `U` is similarly determined from the input type `U`.  \n  \n One advantage of `make_pair` is that the types of objects that are being stored are determined automatically by the compiler and do not have to be explicitly specified. Don't use explicit template arguments such as `make_pair<int, int>(1, 2)` when you use `make_pair` because it is unnecessarily verbose and adds complex rvalue reference problems that might cause compilation failure. For this example, the correct syntax would be `make_pair(1, 2)`  \n  \n The `make_pair` helper function also makes it possible to pass two values to a function that requires a pair as an input parameter.  \n  \n### Example  \n  For an example about how to use the helper function `make_pair` to declare and initialize a pair, see [pair Structure](../standard-library/pair-structure.md).  \n  \n##  <a name=\"move\"></a>  move  \n Unconditionally casts its argument to an rvalue reference, and thereby signals that it can be moved if its type is move-enabled.  \n  \n```\ntemplate <class Type>\nconstexpr typename remove_reference<Type>::type&& move(Type&& Arg) noexcept;\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|`Type`|A type deduced from the type of the argument passed in `Arg`, together with the reference collapsing rules.|  \n|`Arg`|The argument to cast. Although the type of `Arg` appears to be specified as an rvalue reference, `move` also accepts lvalue arguments because lvalue references can bind to rvalue references.|  \n  \n### Return Value  \n `Arg` as an rvalue reference, whether or not its type is a reference type.  \n  \n### Remarks  \n The template argument `Type` is not intended to be specified explicitly, but to be deduced from the type of the value passed in `Arg`. The type of `Type` is further adjusted according to the reference collapsing rules.  \n  \n `move` does not move its argument. Instead, by unconditionally casting its argument—which might be an lvalue—to an rvalue reference, it enables the compiler to subsequently move, rather than copy, the value passed in `Arg` if its type is move-enabled. If its type is not move-enabled, it is copied instead.  \n  \n If the value passed in `Arg` is an lvalue—that is, it has a name or its address can be taken—it's invalidated when the move occurs. Do not refer to the value passed in `Arg` by its name or address after it's been moved.  \n  \n##  <a name=\"swap\"></a>  swap  \n Exchanges the elements of two [pair Structure](../standard-library/pair-structure.md) objects.  \n  \n```\ntemplate <class T, class U>  \nvoid swap(pair<T, U>& left, pair<T, U>& right);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|`left`|An object of type `pair`.|  \n|`right`|An object of type `pair`.|  \n  \n### Remarks  \n One advantage of `swap` is that the types of objects that are being stored are determined automatically by the compiler and do not have to be explicitly specified. Don't use explicit template arguments such as `swap<int, int>(1, 2)` when you use `swap` because it is unnecessarily verbose and adds complex rvalue reference problems that might cause compilation failure.  \n  \n## See Also  \n [\\<utility>](../standard-library/utility.md)\n\n\n\n"}