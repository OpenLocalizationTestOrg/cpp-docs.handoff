{"nodes":[{"pos":[12,85],"content":"Dynamically Determining Columns Returned to the Consumer | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Dynamically Determining Columns Returned to the Consumer | Microsoft Docs","pos":[0,73]}]},{"content":"Dynamically Determining Columns Returned to the Consumer","pos":[686,742]},{"content":"The PROVIDER_COLUMN_ENTRY macros normally handle the <bpt id=\"p1\">**</bpt>IColumnsInfo::GetColumnsInfo<ept id=\"p1\">**</ept> call.","pos":[743,834],"source":"The PROVIDER_COLUMN_ENTRY macros normally handle the **IColumnsInfo::GetColumnsInfo** call."},{"content":"However, because a consumer might choose to use bookmarks, the provider must be able to change the columns returned depending on whether the consumer asks for a bookmark.","pos":[835,1005]},{"pos":[1012,1263],"content":"To handle the <bpt id=\"p1\">**</bpt>IColumnsInfo::GetColumnsInfo<ept id=\"p1\">**</ept> call, delete the PROVIDER_COLUMN_MAP, which defines a function <ph id=\"ph1\">`GetColumnInfo`</ph>, from the <ph id=\"ph2\">`CAgentMan`</ph> user record in MyProviderRS.h and replace it with the definition for your own <ph id=\"ph3\">`GetColumnInfo`</ph> function:","source":"To handle the **IColumnsInfo::GetColumnsInfo** call, delete the PROVIDER_COLUMN_MAP, which defines a function `GetColumnInfo`, from the `CAgentMan` user record in MyProviderRS.h and replace it with the definition for your own `GetColumnInfo` function:"},{"pos":[1733,1830],"content":"Next, implement the <ph id=\"ph1\">`GetColumnInfo`</ph> function in MyProviderRS.cpp, as shown in the following code.","source":"Next, implement the `GetColumnInfo` function in MyProviderRS.cpp, as shown in the following code."},{"content":"checks first to see if the OLE DB property <bpt id=\"p1\">**</bpt>DBPROP_BOOKMARKS<ept id=\"p1\">**</ept> is set.","pos":[1853,1924],"source":" checks first to see if the OLE DB property **DBPROP_BOOKMARKS** is set."},{"content":"To get the property, <ph id=\"ph1\">`GetColumnInfo`</ph> uses a pointer (<ph id=\"ph2\">`pRowset`</ph>) to the rowset object.","pos":[1925,2010],"source":" To get the property, `GetColumnInfo` uses a pointer (`pRowset`) to the rowset object."},{"content":"The <ph id=\"ph1\">`pThis`</ph> pointer represents the class that created the rowset, which is the class where the property map is stored.","pos":[2011,2129],"source":" The `pThis` pointer represents the class that created the rowset, which is the class where the property map is stored."},{"content":"typecasts the <ph id=\"ph1\">`pThis`</ph> pointer to an <ph id=\"ph2\">`RMyProviderRowset`</ph> pointer.","pos":[2146,2210],"source":" typecasts the `pThis` pointer to an `RMyProviderRowset` pointer."},{"content":"To check for the <bpt id=\"p1\">**</bpt>DBPROP_BOOKMARKS<ept id=\"p1\">**</ept> property, <ph id=\"ph1\">`GetColumnInfo`</ph> uses the <ph id=\"ph2\">`IRowsetInfo`</ph> interface, which you can obtain by calling <ph id=\"ph3\">`QueryInterface`</ph> on the <ph id=\"ph4\">`pRowset`</ph> interface.","pos":[2217,2391],"source":"To check for the **DBPROP_BOOKMARKS** property, `GetColumnInfo` uses the `IRowsetInfo` interface, which you can obtain by calling `QueryInterface` on the `pRowset` interface."},{"content":"As an alternative, you can use an ATL <bpt id=\"p1\">[</bpt>CComQIPtr<ept id=\"p1\">](../../atl/reference/ccomqiptr-class.md)</ept> method instead.","pos":[2392,2497],"source":" As an alternative, you can use an ATL [CComQIPtr](../../atl/reference/ccomqiptr-class.md) method instead."},{"content":"This example uses a static array to contain the column information.","pos":[4422,4489]},{"content":"If the consumer does not want the bookmark column, one entry in the array is unused.","pos":[4490,4574]},{"content":"To handle the information, you create two array macros: ADD_COLUMN_ENTRY and ADD_COLUMN_ENTRY_EX.","pos":[4575,4672]},{"content":"ADD_COLUMN_ENTRY_EX takes an extra parameter, <ph id=\"ph1\">`flags`</ph>, that is needed if you designate a bookmark column.","pos":[4673,4778],"source":" ADD_COLUMN_ENTRY_EX takes an extra parameter, `flags`, that is needed if you designate a bookmark column."},{"pos":[6221,6291],"content":"In the <ph id=\"ph1\">`GetColumnInfo`</ph> function, the bookmark macro is used like this:","source":"In the `GetColumnInfo` function, the bookmark macro is used like this:"},{"content":"You can now compile and run the enhanced provider.","pos":[6472,6522]},{"content":"To test the provider, modify the test consumer as described in <bpt id=\"p1\">[</bpt>Implementing a Simple Consumer<ept id=\"p1\">](../../data/oledb/implementing-a-simple-consumer.md)</ept>.","pos":[6523,6671],"source":" To test the provider, modify the test consumer as described in [Implementing a Simple Consumer](../../data/oledb/implementing-a-simple-consumer.md)."},{"content":"Run the test consumer with the provider.","pos":[6672,6712]},{"content":"Verify that the test consumer retrieves the proper strings from the provider when you click the <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> button in the <bpt id=\"p2\">**</bpt>Test Consumer<ept id=\"p2\">**</ept> dialog box.","pos":[6713,6860],"source":" Verify that the test consumer retrieves the proper strings from the provider when you click the **Run** button in the **Test Consumer** dialog box."},{"content":"See Also","pos":[6869,6877]},{"content":"Enhancing the Simple Read-Only Provider","pos":[6882,6921]}],"content":"---\ntitle: \"Dynamically Determining Columns Returned to the Consumer | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"bookmarks [C++], dynamically determining columns\"\n  - \"dynamically determining columns [C++]\"\nms.assetid: 58522b7a-894e-4b7d-a605-f80e900a7f5f\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Dynamically Determining Columns Returned to the Consumer\nThe PROVIDER_COLUMN_ENTRY macros normally handle the **IColumnsInfo::GetColumnsInfo** call. However, because a consumer might choose to use bookmarks, the provider must be able to change the columns returned depending on whether the consumer asks for a bookmark.  \n  \n To handle the **IColumnsInfo::GetColumnsInfo** call, delete the PROVIDER_COLUMN_MAP, which defines a function `GetColumnInfo`, from the `CAgentMan` user record in MyProviderRS.h and replace it with the definition for your own `GetColumnInfo` function:  \n  \n```  \n////////////////////////////////////////////////////////////////////////  \n// MyProviderRS.H  \nclass CAgentMan  \n{  \npublic:  \n   DWORD dwBookmark;  \n   TCHAR szCommand[256];  \n   TCHAR szText[256];  \n   TCHAR szCommand2[256];  \n   TCHAR szText2[256];  \n  \n   static ATLCOLUMNINFO* GetColumnInfo(void* pThis, ULONG* pcCols);  \n   bool operator==(const CAgentMan& am)  \n   {  \n      return (lstrcmpi(szCommand, am.szCommand) == 0);  \n   }  \n  \n};  \n```  \n  \n Next, implement the `GetColumnInfo` function in MyProviderRS.cpp, as shown in the following code.  \n  \n `GetColumnInfo` checks first to see if the OLE DB property **DBPROP_BOOKMARKS** is set. To get the property, `GetColumnInfo` uses a pointer (`pRowset`) to the rowset object. The `pThis` pointer represents the class that created the rowset, which is the class where the property map is stored. `GetColumnInfo` typecasts the `pThis` pointer to an `RMyProviderRowset` pointer.  \n  \n To check for the **DBPROP_BOOKMARKS** property, `GetColumnInfo` uses the `IRowsetInfo` interface, which you can obtain by calling `QueryInterface` on the `pRowset` interface. As an alternative, you can use an ATL [CComQIPtr](../../atl/reference/ccomqiptr-class.md) method instead.  \n  \n```  \n////////////////////////////////////////////////////////////////////  \n// MyProviderRS.cpp  \nATLCOLUMNINFO* CAgentMan::GetColumnInfo(void* pThis, ULONG* pcCols)  \n{  \n   static ATLCOLUMNINFO _rgColumns[5];  \n   ULONG ulCols = 0;  \n  \n   // Check the property flag for bookmarks; if it is set, set the zero   \n   // ordinal entry in the column map with the bookmark information.  \n   CAgentRowset* pRowset = (CAgentRowset*) pThis;  \n   CComQIPtr<IRowsetInfo, &IID_IRowsetInfo> spRowsetProps = pRowset;  \n  \n   CDBPropIDSet set(DBPROPSET_ROWSET);  \n   set.AddPropertyID(DBPROP_BOOKMARKS);  \n   DBPROPSET* pPropSet = NULL;  \n   ULONG ulPropSet = 0;  \n   HRESULT hr;  \n  \n   if (spRowsetProps)  \n      hr = spRowsetProps->GetProperties(1, &set, &ulPropSet, &pPropSet);  \n  \n   if (pPropSet)  \n   {  \n      CComVariant var = pPropSet->rgProperties[0].vValue;  \n      CoTaskMemFree(pPropSet->rgProperties);  \n      CoTaskMemFree(pPropSet);  \n  \n      if (SUCCEEDED(hr) && (var.boolVal == VARIANT_TRUE))  \n      {  \n         ADD_COLUMN_ENTRY_EX(ulCols, OLESTR(\"Bookmark\"), 0, sizeof(DWORD),   \n         DBTYPE_BYTES, 0, 0, GUID_NULL, CAgentMan, dwBookmark,   \n         DBCOLUMNFLAGS_ISBOOKMARK)  \n         ulCols++;  \n      }  \n   }  \n  \n   // Next, set the other columns up.  \n   ADD_COLUMN_ENTRY(ulCols, OLESTR(\"Command\"), 1, 256, DBTYPE_STR, 0xFF, 0xFF,   \n      GUID_NULL, CAgentMan, szCommand)  \n   ulCols++;  \n   ADD_COLUMN_ENTRY(ulCols, OLESTR(\"Text\"), 2, 256, DBTYPE_STR, 0xFF, 0xFF,   \n      GUID_NULL, CAgentMan, szText)  \n   ulCols++;  \n  \n   ADD_COLUMN_ENTRY(ulCols, OLESTR(\"Command2\"), 3, 256, DBTYPE_STR, 0xFF, 0xFF,   \n      GUID_NULL, CAgentMan, szCommand2)  \n   ulCols++;  \n   ADD_COLUMN_ENTRY(ulCols, OLESTR(\"Text2\"), 4, 256, DBTYPE_STR, 0xFF, 0xFF,   \n      GUID_NULL, CAgentMan, szText2)  \n   ulCols++;  \n  \n   if (pcCols != NULL)  \n      *pcCols = ulCols;  \n  \n   return _rgColumns;  \n}  \n```  \n  \n This example uses a static array to contain the column information. If the consumer does not want the bookmark column, one entry in the array is unused. To handle the information, you create two array macros: ADD_COLUMN_ENTRY and ADD_COLUMN_ENTRY_EX. ADD_COLUMN_ENTRY_EX takes an extra parameter, `flags`, that is needed if you designate a bookmark column.  \n  \n```  \n////////////////////////////////////////////////////////////////////////  \n// MyProviderRS.h  \n  \n#define ADD_COLUMN_ENTRY(ulCols, name, ordinal, colSize, type, precision,   \nscale, guid, dataClass, member) \\  \n   _rgColumns[ulCols].pwszName = (LPOLESTR)name; \\  \n   _rgColumns[ulCols].pTypeInfo = (ITypeInfo*)NULL; \\  \n   _rgColumns[ulCols].iOrdinal = (ULONG)ordinal; \\  \n   _rgColumns[ulCols].dwFlags = 0; \\  \n   _rgColumns[ulCols].ulColumnSize = (ULONG)colSize; \\  \n   _rgColumns[ulCols].wType = (DBTYPE)type; \\  \n   _rgColumns[ulCols].bPrecision = (BYTE)precision; \\  \n   _rgColumns[ulCols].bScale = (BYTE)scale; \\  \n   _rgColumns[ulCols].cbOffset = offsetof(dataClass, member);  \n  \n#define ADD_COLUMN_ENTRY_EX(ulCols, name, ordinal, colSize, type,   \nprecision, scale, guid, dataClass, member, flags) \\  \n   _rgColumns[ulCols].pwszName = (LPOLESTR)name; \\  \n   _rgColumns[ulCols].pTypeInfo = (ITypeInfo*)NULL; \\  \n   _rgColumns[ulCols].iOrdinal = (ULONG)ordinal; \\  \n   _rgColumns[ulCols].dwFlags = flags; \\  \n   _rgColumns[ulCols].ulColumnSize = (ULONG)colSize; \\  \n   _rgColumns[ulCols].wType = (DBTYPE)type; \\  \n   _rgColumns[ulCols].bPrecision = (BYTE)precision; \\  \n   _rgColumns[ulCols].bScale = (BYTE)scale; \\  \n   _rgColumns[ulCols].cbOffset = offsetof(dataClass, member); \\  \n   memset(&(_rgColumns[ulCols].columnid), 0, sizeof(DBID)); \\  \n   _rgColumns[ulCols].columnid.uName.pwszName = (LPOLESTR)name;  \n```  \n  \n In the `GetColumnInfo` function, the bookmark macro is used like this:  \n  \n```  \nADD_COLUMN_ENTRY_EX(ulCols, OLESTR(\"Bookmark\"), 0, sizeof(DWORD),  \n   DBTYPE_BYTES, 0, 0, GUID_NULL, CAgentMan, dwBookmark,   \n   DBCOLUMNFLAGS_ISBOOKMARK)  \n```  \n  \n You can now compile and run the enhanced provider. To test the provider, modify the test consumer as described in [Implementing a Simple Consumer](../../data/oledb/implementing-a-simple-consumer.md). Run the test consumer with the provider. Verify that the test consumer retrieves the proper strings from the provider when you click the **Run** button in the **Test Consumer** dialog box.  \n  \n## See Also  \n [Enhancing the Simple Read-Only Provider](../../data/oledb/enhancing-the-simple-read-only-provider.md)"}