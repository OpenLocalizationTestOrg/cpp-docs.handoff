{"nodes":[{"pos":[12,53],"content":"reader_writer_lock Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"reader_writer_lock Class | Microsoft Docs","pos":[0,41]}]},{"content":"reader_writer_lock Class","pos":[646,670]},{"content":"A writer-preference queue-based reader-writer lock with local only spinning.","pos":[671,747]},{"content":"The lock grants first in - first out (FIFO) access to writers and starves readers under a continuous load of writers.","pos":[748,865]},{"content":"Syntax","pos":[874,880]},{"content":"Members","pos":[928,935]},{"content":"Public Classes","pos":[945,959]},{"content":"Name","pos":[966,970]},{"content":"Description","pos":[971,982]},{"content":"reader_writer_lock::scoped_lock Class","pos":[1021,1058]},{"pos":[1080,1185],"content":"An exception safe RAII wrapper that can be used to acquire <ph id=\"ph1\">`reader_writer_lock`</ph> lock objects as a writer.","source":"An exception safe RAII wrapper that can be used to acquire `reader_writer_lock` lock objects as a writer."},{"content":"reader_writer_lock::scoped_lock_read Class","pos":[1191,1233]},{"pos":[1260,1365],"content":"An exception safe RAII wrapper that can be used to acquire <ph id=\"ph1\">`reader_writer_lock`</ph> lock objects as a reader.","source":"An exception safe RAII wrapper that can be used to acquire `reader_writer_lock` lock objects as a reader."},{"content":"Public Constructors","pos":[1376,1395]},{"content":"Name","pos":[1402,1406]},{"content":"Description","pos":[1407,1418]},{"content":"reader_writer_lock::reader_writer_lock Constructor","pos":[1457,1507]},{"pos":[1516,1561],"content":"Constructs a new <ph id=\"ph1\">`reader_writer_lock`</ph> object.","source":"Constructs a new `reader_writer_lock` object."},{"content":"reader_writer_lock::~reader_writer_lock Destructor","pos":[1567,1617]},{"pos":[1626,1667],"content":"Destroys the <ph id=\"ph1\">`reader_writer_lock`</ph> object.","source":"Destroys the `reader_writer_lock` object."},{"content":"Public Methods","pos":[1678,1692]},{"content":"Name","pos":[1699,1703]},{"content":"Description","pos":[1704,1715]},{"content":"reader_writer_lock::lock Method","pos":[1754,1785]},{"content":"Acquires the reader-writer lock as a writer.","pos":[1794,1838]},{"content":"reader_writer_lock::lock_read Method","pos":[1844,1880]},{"content":"Acquires the reader-writer lock as a reader.","pos":[1894,1938]},{"content":"If there are writers, active readers have to wait until they are done.","pos":[1939,2009]},{"content":"The reader simply registers an interest in the lock and waits for writers to release it.","pos":[2010,2098]},{"content":"reader_writer_lock::try_lock Method","pos":[2104,2139]},{"content":"Attempts to acquire the reader-writer lock as a writer without blocking.","pos":[2152,2224]},{"content":"reader_writer_lock::try_lock_read Method","pos":[2230,2270]},{"content":"Attempts to acquire the reader-writer lock as a reader without blocking.","pos":[2288,2360]},{"content":"reader_writer_lock::unlock Method","pos":[2366,2399]},{"content":"Unlocks the reader-writer lock based on who locked it, reader or writer.","pos":[2410,2482]},{"content":"Remarks","pos":[2492,2499]},{"pos":[2503,2624],"content":"For more information, see <bpt id=\"p1\">[</bpt>Synchronization Data Structures<ept id=\"p1\">](../../../parallel/concrt/synchronization-data-structures.md)</ept>.","source":"For more information, see [Synchronization Data Structures](../../../parallel/concrt/synchronization-data-structures.md)."},{"content":"Inheritance Hierarchy","pos":[2633,2654]},{"content":"Requirements","pos":[2687,2699]},{"pos":[2703,2723],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> concrt.h","source":"**Header:** concrt.h"},{"pos":[2730,2756],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> concurrency","source":"**Namespace:** concurrency"},{"pos":[2787,2818],"content":"reader_writer_lock::lock Method"},{"content":"Acquires the reader-writer lock as a writer.","pos":[2822,2866]},{"content":"Remarks","pos":[2902,2909]},{"pos":[2913,3080],"content":"It is often safer to utilize the <bpt id=\"p1\">[</bpt>scoped_lock<ept id=\"p1\">](#scoped_lock_class)</ept> construct to acquire and release a <ph id=\"ph1\">`reader_writer_lock`</ph> object as a writer in an exception safe way.","source":"It is often safer to utilize the [scoped_lock](#scoped_lock_class) construct to acquire and release a `reader_writer_lock` object as a writer in an exception safe way."},{"content":"After a writer attempts to acquire the lock, any future readers will block until the writers have successfully acquired and released the lock.","pos":[3087,3229]},{"content":"This lock is biased towards writers and can starve readers under a continuous load of writers.","pos":[3230,3324]},{"content":"Writers are chained so that a writer exiting the lock releases the next writer in line.","pos":[3331,3418]},{"pos":[3425,3545],"content":"If the lock is already held by the calling context, an <bpt id=\"p1\">[</bpt>improper_lock<ept id=\"p1\">](improper-lock-class.md)</ept> exception will be thrown.","source":"If the lock is already held by the calling context, an [improper_lock](improper-lock-class.md) exception will be thrown."},{"pos":[3581,3617],"content":"reader_writer_lock::lock_read Method"},{"content":"Acquires the reader-writer lock as a reader.","pos":[3621,3665]},{"content":"If there are writers, active readers have to wait until they are done.","pos":[3666,3736]},{"content":"The reader simply registers an interest in the lock and waits for writers to release it.","pos":[3737,3825]},{"content":"Remarks","pos":[3866,3873]},{"pos":[3877,4054],"content":"It is often safer to utilize the <bpt id=\"p1\">[</bpt>scoped_lock_read<ept id=\"p1\">](#scoped_lock_read_class)</ept> construct to acquire and release a <ph id=\"ph1\">`reader_writer_lock`</ph> object as a reader in an exception safe way.","source":"It is often safer to utilize the [scoped_lock_read](#scoped_lock_read_class) construct to acquire and release a `reader_writer_lock` object as a reader in an exception safe way."},{"content":"If there are writers waiting on the lock, the reader will wait until all writers in line have acquired and released the lock.","pos":[4061,4186]},{"content":"This lock is biased towards writers and can starve readers under a continuous load of writers.","pos":[4187,4281]},{"pos":[4312,4362],"content":"reader_writer_lock::reader_writer_lock Constructor"},{"pos":[4366,4411],"content":"Constructs a new <ph id=\"ph1\">`reader_writer_lock`</ph> object.","source":"Constructs a new `reader_writer_lock` object."},{"pos":[4477,4527],"content":"reader_writer_lock::~reader_writer_lock Destructor"},{"pos":[4531,4572],"content":"Destroys the <ph id=\"ph1\">`reader_writer_lock`</ph> object.","source":"Destroys the `reader_writer_lock` object."},{"content":"Remarks","pos":[4618,4625]},{"content":"It is expected that the lock is no longer held when the destructor runs.","pos":[4629,4701]},{"content":"Allowing the reader writer lock to destruct with the lock still held results in undefined behavior.","pos":[4702,4801]},{"pos":[4845,4882],"content":"reader_writer_lock::scoped_lock Class"},{"pos":[4886,4991],"content":"An exception safe RAII wrapper that can be used to acquire <ph id=\"ph1\">`reader_writer_lock`</ph> lock objects as a writer.","source":"An exception safe RAII wrapper that can be used to acquire `reader_writer_lock` lock objects as a writer."},{"pos":[5061,5117],"content":"reader_writer_lock::scoped_lock::scoped_lock Constructor"},{"content":"Constructs a <ph id=\"ph1\">`scoped_lock`</ph> object and acquires the <ph id=\"ph2\">`reader_writer_lock`</ph> object passed in the <ph id=\"ph3\">`_Reader_writer_lock`</ph> parameter as a writer.","pos":[5118,5255],"source":"Constructs a `scoped_lock` object and acquires the `reader_writer_lock` object passed in the `_Reader_writer_lock` parameter as a writer."},{"content":"If the lock is held by another thread, this call will block.","pos":[5256,5316]},{"content":"Parameters","pos":[5414,5424]},{"content":"The <ph id=\"ph1\">`reader_writer_lock`</ph> object to acquire as a writer.","pos":[5453,5508],"source":" The `reader_writer_lock` object to acquire as a writer."},{"pos":[5550,5606],"content":"reader_writer_lock::scoped_lock::~scoped_lock Destructor"},{"pos":[5608,5697],"content":"Destroys a <ph id=\"ph1\">`reader_writer_lock`</ph> object and releases the lock supplied in its constructor.","source":"Destroys a `reader_writer_lock` object and releases the lock supplied in its constructor."},{"pos":[5774,5816],"content":"reader_writer_lock::scoped_lock_read Class"},{"pos":[5820,5925],"content":"An exception safe RAII wrapper that can be used to acquire <ph id=\"ph1\">`reader_writer_lock`</ph> lock objects as a reader.","source":"An exception safe RAII wrapper that can be used to acquire `reader_writer_lock` lock objects as a reader."},{"pos":[5997,6032],"content":"reader_writer_lock::try_lock Method"},{"content":"Attempts to acquire the reader-writer lock as a writer without blocking.","pos":[6036,6108]},{"pos":[6153,6219],"content":"reader_writer_lock::scoped_lock_read::scoped_lock_read Constructor"},{"content":"Constructs a <ph id=\"ph1\">`scoped_lock_read`</ph> object and acquires the <ph id=\"ph2\">`reader_writer_lock`</ph> object passed in the <ph id=\"ph3\">`_Reader_writer_lock`</ph> parameter as a reader.","pos":[6220,6362],"source":"Constructs a `scoped_lock_read` object and acquires the `reader_writer_lock` object passed in the `_Reader_writer_lock` parameter as a reader."},{"content":"If the lock is held by another thread as a writer or there are pending writers, this call will block.","pos":[6363,6464]},{"content":"Parameters","pos":[6564,6574]},{"content":"The <ph id=\"ph1\">`reader_writer_lock`</ph> object to acquire as a reader.","pos":[6603,6658],"source":" The `reader_writer_lock` object to acquire as a reader."},{"pos":[6701,6767],"content":"reader_writer_lock::scoped_lock_read::~scoped_lock_read Destructor"},{"pos":[6768,6855],"content":"Destroys a <ph id=\"ph1\">`scoped_lock_read`</ph> object and releases the lock supplied in its constructor.","source":"Destroys a `scoped_lock_read` object and releases the lock supplied in its constructor."},{"pos":[6920,6955],"content":"reader_writer_lock::try_lock Method"},{"content":"Return Value","pos":[6990,7002]},{"pos":[7006,7079],"content":"If the lock was acquired, the value <ph id=\"ph1\">`true`</ph>; otherwise, the value <ph id=\"ph2\">`false`</ph>.","source":"If the lock was acquired, the value `true`; otherwise, the value `false`."},{"pos":[7119,7159],"content":"reader_writer_lock::try_lock_read Method"},{"content":"Attempts to acquire the reader-writer lock as a reader without blocking.","pos":[7163,7235]},{"content":"Return Value","pos":[7280,7292]},{"pos":[7296,7369],"content":"If the lock was acquired, the value <ph id=\"ph1\">`true`</ph>; otherwise, the value <ph id=\"ph2\">`false`</ph>.","source":"If the lock was acquired, the value `true`; otherwise, the value `false`."},{"pos":[7402,7435],"content":"reader_writer_lock::unlock Method"},{"content":"Unlocks the reader-writer lock based on who locked it, reader or writer.","pos":[7439,7511]},{"content":"Remarks","pos":[7549,7556]},{"content":"If there are writers waiting on the lock, the release of the lock will always go to the next writer in FIFO order.","pos":[7560,7674]},{"content":"This lock is biased towards writers and can starve readers under a continuous load of writers.","pos":[7675,7769]},{"content":"See Also","pos":[7778,7786]},{"content":"concurrency Namespace","pos":[7791,7812]},{"content":"critical_section Class","pos":[7845,7867]}],"content":"---\ntitle: \"reader_writer_lock Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"concrt/concurrency::reader_writer_lock\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"reader_writer_lock class\"\nms.assetid: 91a59cd2-ca05-4b74-8398-d826d9f86736\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# reader_writer_lock Class\nA writer-preference queue-based reader-writer lock with local only spinning. The lock grants first in - first out (FIFO) access to writers and starves readers under a continuous load of writers.  \n  \n## Syntax  \n  \n```\nclass reader_writer_lock;\n```  \n  \n## Members  \n  \n### Public Classes  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[reader_writer_lock::scoped_lock Class](#scoped_lock_class)|An exception safe RAII wrapper that can be used to acquire `reader_writer_lock` lock objects as a writer.|  \n|[reader_writer_lock::scoped_lock_read Class](#scoped_lock_read_class)|An exception safe RAII wrapper that can be used to acquire `reader_writer_lock` lock objects as a reader.|  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[reader_writer_lock::reader_writer_lock Constructor](#ctor)|Constructs a new `reader_writer_lock` object.|  \n|[reader_writer_lock::~reader_writer_lock Destructor](#dtor)|Destroys the `reader_writer_lock` object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[reader_writer_lock::lock Method](#lock)|Acquires the reader-writer lock as a writer.|  \n|[reader_writer_lock::lock_read Method](#lock_read)|Acquires the reader-writer lock as a reader. If there are writers, active readers have to wait until they are done. The reader simply registers an interest in the lock and waits for writers to release it.|  \n|[reader_writer_lock::try_lock Method](#try_lock)|Attempts to acquire the reader-writer lock as a writer without blocking.|  \n|[reader_writer_lock::try_lock_read Method](#try_lock_read)|Attempts to acquire the reader-writer lock as a reader without blocking.|  \n|[reader_writer_lock::unlock Method](#unlock)|Unlocks the reader-writer lock based on who locked it, reader or writer.|  \n  \n## Remarks  \n For more information, see [Synchronization Data Structures](../../../parallel/concrt/synchronization-data-structures.md).  \n  \n## Inheritance Hierarchy  \n `reader_writer_lock`  \n  \n## Requirements  \n **Header:** concrt.h  \n  \n **Namespace:** concurrency  \n  \n##  <a name=\"lock\"></a>  reader_writer_lock::lock Method  \n Acquires the reader-writer lock as a writer.  \n  \n```\nvoid lock();\n```  \n  \n### Remarks  \n It is often safer to utilize the [scoped_lock](#scoped_lock_class) construct to acquire and release a `reader_writer_lock` object as a writer in an exception safe way.  \n  \n After a writer attempts to acquire the lock, any future readers will block until the writers have successfully acquired and released the lock. This lock is biased towards writers and can starve readers under a continuous load of writers.  \n  \n Writers are chained so that a writer exiting the lock releases the next writer in line.  \n  \n If the lock is already held by the calling context, an [improper_lock](improper-lock-class.md) exception will be thrown.  \n  \n##  <a name=\"lock_read\"></a>  reader_writer_lock::lock_read Method  \n Acquires the reader-writer lock as a reader. If there are writers, active readers have to wait until they are done. The reader simply registers an interest in the lock and waits for writers to release it.  \n  \n```\nvoid lock_read();\n```  \n  \n### Remarks  \n It is often safer to utilize the [scoped_lock_read](#scoped_lock_read_class) construct to acquire and release a `reader_writer_lock` object as a reader in an exception safe way.  \n  \n If there are writers waiting on the lock, the reader will wait until all writers in line have acquired and released the lock. This lock is biased towards writers and can starve readers under a continuous load of writers.  \n  \n##  <a name=\"ctor\"></a>  reader_writer_lock::reader_writer_lock Constructor  \n Constructs a new `reader_writer_lock` object.  \n  \n```\nreader_writer_lock();\n```  \n  \n##  <a name=\"dtor\"></a>  reader_writer_lock::~reader_writer_lock Destructor  \n Destroys the `reader_writer_lock` object.  \n  \n```\n~reader_writer_lock();\n```  \n  \n### Remarks  \n It is expected that the lock is no longer held when the destructor runs. Allowing the reader writer lock to destruct with the lock still held results in undefined behavior.  \n  \n##  <a name=\"scoped_lock_class\"></a>  reader_writer_lock::scoped_lock Class  \n An exception safe RAII wrapper that can be used to acquire `reader_writer_lock` lock objects as a writer.  \n  \n```\nclass scoped_lock;\n``` \n## <a name=\"scoped_lock_ctor\"></a>  reader_writer_lock::scoped_lock::scoped_lock Constructor\nConstructs a `scoped_lock` object and acquires the `reader_writer_lock` object passed in the `_Reader_writer_lock` parameter as a writer. If the lock is held by another thread, this call will block.  \n  \n  \n```\nexplicit _CRTIMP scoped_lock(reader_writer_lock& _Reader_writer_lock);\n```  \n  \n#### Parameters  \n `_Reader_writer_lock`  \n The `reader_writer_lock` object to acquire as a writer.  \n  \n## <a name=\"scoped_lock_dtor\"></a>  reader_writer_lock::scoped_lock::~scoped_lock Destructor\n\nDestroys a `reader_writer_lock` object and releases the lock supplied in its constructor.   \n\n```\n~scoped_lock();\n```  \n  \n##  <a name=\"scoped_lock_read_class\"></a>  reader_writer_lock::scoped_lock_read Class  \n An exception safe RAII wrapper that can be used to acquire `reader_writer_lock` lock objects as a reader.  \n  \n```\nclass scoped_lock_read;\n```  \n  \n##  <a name=\"try_lock\"></a>  reader_writer_lock::try_lock Method  \n Attempts to acquire the reader-writer lock as a writer without blocking.  \n\n## <a name=\"scoped_lock_read_ctor\"></a>  reader_writer_lock::scoped_lock_read::scoped_lock_read Constructor\nConstructs a `scoped_lock_read` object and acquires the `reader_writer_lock` object passed in the `_Reader_writer_lock` parameter as a reader. If the lock is held by another thread as a writer or there are pending writers, this call will block.  \n  \n```\nexplicit _CRTIMP scoped_lock_read(reader_writer_lock& _Reader_writer_lock);\n```  \n  \n#### Parameters  \n `_Reader_writer_lock`  \n The `reader_writer_lock` object to acquire as a reader.  \n  \n## <a name=\"scoped_lock_read_dtor\">  reader_writer_lock::scoped_lock_read::~scoped_lock_read Destructor\nDestroys a `scoped_lock_read` object and releases the lock supplied in its constructor.  \n\n```\n~scoped_lock_read();\n```  \n  \n## <a name=\"try_lock\"></a> reader_writer_lock::try_lock Method\n```\nbool try_lock();\n```  \n  \n### Return Value  \n If the lock was acquired, the value `true`; otherwise, the value `false`.  \n  \n##  <a name=\"try_lock_read\"></a>  reader_writer_lock::try_lock_read Method  \n Attempts to acquire the reader-writer lock as a reader without blocking.  \n  \n```\nbool try_lock_read();\n```  \n  \n### Return Value  \n If the lock was acquired, the value `true`; otherwise, the value `false`.  \n  \n##  <a name=\"unlock\"></a>  reader_writer_lock::unlock Method  \n Unlocks the reader-writer lock based on who locked it, reader or writer.  \n  \n```\nvoid unlock();\n```  \n  \n### Remarks  \n If there are writers waiting on the lock, the release of the lock will always go to the next writer in FIFO order. This lock is biased towards writers and can starve readers under a continuous load of writers.  \n  \n## See Also  \n [concurrency Namespace](concurrency-namespace.md)   \n [critical_section Class](critical-section-class.md)\n"}