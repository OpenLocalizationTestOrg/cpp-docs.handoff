{"nodes":[{"pos":[12,46],"content":"CSocketFile Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CSocketFile Class | Microsoft Docs","pos":[0,34]}]},{"content":"CSocketFile Class","pos":[759,776]},{"pos":[777,867],"content":"A <ph id=\"ph1\">`CFile`</ph> object used for sending and receiving data across a network via Windows Sockets.","source":"A `CFile` object used for sending and receiving data across a network via Windows Sockets."},{"content":"Syntax","pos":[876,882]},{"content":"Members","pos":[941,948]},{"content":"Public Constructors","pos":[958,977]},{"content":"Name","pos":[984,988]},{"content":"Description","pos":[989,1000]},{"content":"CSocketFile::CSocketFile","pos":[1039,1063]},{"pos":[1092,1126],"content":"Constructs a <ph id=\"ph1\">`CSocketFile`</ph> object.","source":"Constructs a `CSocketFile` object."},{"content":"Remarks","pos":[1136,1143]},{"content":"You can attach the <ph id=\"ph1\">`CSocketFile`</ph> object to a <ph id=\"ph2\">`CSocket`</ph> object for this purpose.","pos":[1147,1226],"source":"You can attach the `CSocketFile` object to a `CSocket` object for this purpose."},{"content":"You also can, and usually do, attach the <ph id=\"ph1\">`CSocketFile`</ph> object to a <ph id=\"ph2\">`CArchive`</ph> object to simplify sending and receiving data using MFC serialization.","pos":[1227,1375],"source":" You also can, and usually do, attach the `CSocketFile` object to a `CArchive` object to simplify sending and receiving data using MFC serialization."},{"content":"To serialize (send) data, you insert it into the archive, which calls <ph id=\"ph1\">`CSocketFile`</ph> member functions to write data to the <ph id=\"ph2\">`CSocket`</ph> object.","pos":[1382,1521],"source":"To serialize (send) data, you insert it into the archive, which calls `CSocketFile` member functions to write data to the `CSocket` object."},{"content":"To deserialize (receive) data, you extract from the archive.","pos":[1522,1582]},{"content":"This causes the archive to call <ph id=\"ph1\">`CSocketFile`</ph> member functions to read data from the <ph id=\"ph2\">`CSocket`</ph> object.","pos":[1583,1685],"source":" This causes the archive to call `CSocketFile` member functions to read data from the `CSocket` object."},{"pos":[1693,2426],"content":"[!TIP]\n Besides using `CSocketFile` as described here, you can use it as a stand-alone file object, just as you can with `CFile`, its base class. You can also use `CSocketFile` with any archive-based MFC serialization functions. Because `CSocketFile` does not support all of `CFile`'s functionality, some default MFC serialize functions are not compatible with `CSocketFile`. This is particularly true of the `CEditView` class. You should not try to serialize `CEditView` data through a `CArchive` object attached to a `CSocketFile` object using `CEditView::SerializeRaw`; use **CEditView::Serialize** instead. The `SerializeRaw` function expects the file object to have functions, such as `Seek`, that `CSocketFile` does not have.","leadings":["","> "],"nodes":[{"content":" Besides using `CSocketFile` as described here, you can use it as a stand-alone file object, just as you can with `CFile`, its base class. You can also use `CSocketFile` with any archive-based MFC serialization functions. Because `CSocketFile` does not support all of `CFile`'s functionality, some default MFC serialize functions are not compatible with `CSocketFile`. This is particularly true of the `CEditView` class. You should not try to serialize `CEditView` data through a `CArchive` object attached to a `CSocketFile` object using `CEditView::SerializeRaw`; use **CEditView::Serialize** instead. The `SerializeRaw` function expects the file object to have functions, such as `Seek`, that `CSocketFile` does not have.","pos":[7,731],"nodes":[{"content":"Besides using <ph id=\"ph1\">`CSocketFile`</ph> as described here, you can use it as a stand-alone file object, just as you can with <ph id=\"ph2\">`CFile`</ph>, its base class.","pos":[1,138],"source":" Besides using `CSocketFile` as described here, you can use it as a stand-alone file object, just as you can with `CFile`, its base class."},{"content":"You can also use <ph id=\"ph1\">`CSocketFile`</ph> with any archive-based MFC serialization functions.","pos":[139,221],"source":" You can also use `CSocketFile` with any archive-based MFC serialization functions."},{"content":"Because <ph id=\"ph1\">`CSocketFile`</ph> does not support all of <ph id=\"ph2\">`CFile`</ph>'s functionality, some default MFC serialize functions are not compatible with <ph id=\"ph3\">`CSocketFile`</ph>.","pos":[222,368],"source":" Because `CSocketFile` does not support all of `CFile`'s functionality, some default MFC serialize functions are not compatible with `CSocketFile`."},{"content":"This is particularly true of the <ph id=\"ph1\">`CEditView`</ph> class.","pos":[369,420],"source":" This is particularly true of the `CEditView` class."},{"content":"You should not try to serialize <ph id=\"ph1\">`CEditView`</ph> data through a <ph id=\"ph2\">`CArchive`</ph> object attached to a <ph id=\"ph3\">`CSocketFile`</ph> object using <ph id=\"ph4\">`CEditView::SerializeRaw`</ph>; use <bpt id=\"p1\">**</bpt>CEditView::Serialize<ept id=\"p1\">**</ept> instead.","pos":[421,603],"source":" You should not try to serialize `CEditView` data through a `CArchive` object attached to a `CSocketFile` object using `CEditView::SerializeRaw`; use **CEditView::Serialize** instead."},{"content":"The <ph id=\"ph1\">`SerializeRaw`</ph> function expects the file object to have functions, such as <ph id=\"ph2\">`Seek`</ph>, that <ph id=\"ph3\">`CSocketFile`</ph> does not have.","pos":[604,724],"source":" The `SerializeRaw` function expects the file object to have functions, such as `Seek`, that `CSocketFile` does not have."}]}]},{"content":"When you use <ph id=\"ph1\">`CArchive`</ph> with <ph id=\"ph2\">`CSocketFile`</ph> and <ph id=\"ph3\">`CSocket`</ph>, you might encounter a situation where <bpt id=\"p1\">**</bpt>CSocket::Receive<ept id=\"p1\">**</ept> enters a loop (by <bpt id=\"p2\">**</bpt>PumpMessages(FD_READ)<ept id=\"p2\">**</ept>) waiting for the requested amount of bytes.","pos":[2433,2637],"source":"When you use `CArchive` with `CSocketFile` and `CSocket`, you might encounter a situation where **CSocket::Receive** enters a loop (by **PumpMessages(FD_READ)**) waiting for the requested amount of bytes."},{"content":"This is because Windows sockets allow only one recv call per FD_READ notification, but <ph id=\"ph1\">`CSocketFile`</ph> and <ph id=\"ph2\">`CSocket`</ph> allow multiple recv calls per FD_READ.","pos":[2638,2791],"source":" This is because Windows sockets allow only one recv call per FD_READ notification, but `CSocketFile` and `CSocket` allow multiple recv calls per FD_READ."},{"content":"If you get an FD_READ when there is no data to read, the application hangs.","pos":[2792,2867]},{"content":"If you never get another FD_READ, the application stops communicating over the socket.","pos":[2868,2954]},{"content":"You can resolve this problem as follows.","pos":[2961,3001]},{"content":"In the <ph id=\"ph1\">`OnReceive`</ph> method of your socket class, call <bpt id=\"p1\">**</bpt>CAsyncSocket::IOCtl(FIONREAD, ...)<ept id=\"p1\">**</ept> before you call the <ph id=\"ph2\">`Serialize`</ph> method of your message class when the expected data to be read from the socket exceeds the size of one TCP packet (maximum transmission unit of the network medium, usually at least 1096 bytes).","pos":[3002,3319],"source":" In the `OnReceive` method of your socket class, call **CAsyncSocket::IOCtl(FIONREAD, ...)** before you call the `Serialize` method of your message class when the expected data to be read from the socket exceeds the size of one TCP packet (maximum transmission unit of the network medium, usually at least 1096 bytes)."},{"content":"If the size of the available data is less than needed, wait for all the data to be received and only then start the read operation.","pos":[3320,3451]},{"content":"In the following example, <ph id=\"ph1\">`m_dwExpected`</ph> is the approximate number of bytes that the user expects to receive.","pos":[3458,3567],"source":"In the following example, `m_dwExpected` is the approximate number of bytes that the user expects to receive."},{"content":"It is assumed that you declare it elsewhere in your code.","pos":[3568,3625]},{"pos":[3643,3664],"content":"NVC_MFCSocketThread#4"},{"pos":[3734,4024],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets in MFC<ept id=\"p1\">](../../mfc/windows-sockets-in-mfc.md)</ept>, <bpt id=\"p2\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p2\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>, as well as <bpt id=\"p3\">[</bpt>Windows Sockets 2 API<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms740673)</ept>.","source":"For more information, see [Windows Sockets in MFC](../../mfc/windows-sockets-in-mfc.md), [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md), as well as [Windows Sockets 2 API](http://msdn.microsoft.com/library/windows/desktop/ms740673)."},{"content":"Inheritance Hierarchy","pos":[4033,4054]},{"content":"CObject","pos":[4059,4066]},{"content":"CFile","pos":[4113,4118]},{"content":"Requirements","pos":[4184,4196]},{"pos":[4200,4221],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afxsock.h","source":"**Header:** afxsock.h"},{"pos":[4272,4296],"content":"CSocketFile::CSocketFile"},{"pos":[4300,4334],"content":"Constructs a <ph id=\"ph1\">`CSocketFile`</ph> object.","source":"Constructs a `CSocketFile` object."},{"content":"Parameters","pos":[4442,4452]},{"content":"The socket to attach to the <ph id=\"ph1\">`CSocketFile`</ph> object.","pos":[4469,4518],"source":" The socket to attach to the `CSocketFile` object."},{"content":"Specifies whether the file object is for use with a <ph id=\"ph1\">`CArchive`</ph> object.","pos":[4549,4619],"source":" Specifies whether the file object is for use with a `CArchive` object."},{"content":"Pass <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept> only if you want to use the <ph id=\"ph1\">`CSocketFile`</ph> object in a stand-alone manner as you would a stand-alone <ph id=\"ph2\">`CFile`</ph> object, with certain limitations.","pos":[4620,4776],"source":" Pass **FALSE** only if you want to use the `CSocketFile` object in a stand-alone manner as you would a stand-alone `CFile` object, with certain limitations."},{"content":"This flag changes how the <ph id=\"ph1\">`CArchive`</ph> object attached to the <ph id=\"ph2\">`CSocketFile`</ph> object manages its buffer for reading.","pos":[4777,4889],"source":" This flag changes how the `CArchive` object attached to the `CSocketFile` object manages its buffer for reading."},{"content":"Remarks","pos":[4899,4906]},{"content":"The object's destructor disassociates itself from the socket object when the object goes out of scope or is deleted.","pos":[4910,5026]},{"pos":[5034,5375],"content":"[!NOTE]\n A `CSocketFile` can also be used as a (limited) file without a `CArchive` object. By default, the `CSocketFile` constructor's `bArchiveCompatible` parameter is **TRUE**. This specifies that the file object is for use with an archive. To use the file object without an archive, pass **FALSE** in the `bArchiveCompatible` parameter.","leadings":["","> "],"nodes":[{"content":" A `CSocketFile` can also be used as a (limited) file without a `CArchive` object. By default, the `CSocketFile` constructor's `bArchiveCompatible` parameter is **TRUE**. This specifies that the file object is for use with an archive. To use the file object without an archive, pass **FALSE** in the `bArchiveCompatible` parameter.","pos":[8,339],"nodes":[{"content":"A <ph id=\"ph1\">`CSocketFile`</ph> can also be used as a (limited) file without a <ph id=\"ph2\">`CArchive`</ph> object.","pos":[1,82],"source":" A `CSocketFile` can also be used as a (limited) file without a `CArchive` object."},{"content":"By default, the <ph id=\"ph1\">`CSocketFile`</ph> constructor's <ph id=\"ph2\">`bArchiveCompatible`</ph> parameter is <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept>.","pos":[83,170],"source":" By default, the `CSocketFile` constructor's `bArchiveCompatible` parameter is **TRUE**."},{"content":"This specifies that the file object is for use with an archive.","pos":[171,234]},{"content":"To use the file object without an archive, pass <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept> in the <ph id=\"ph1\">`bArchiveCompatible`</ph> parameter.","pos":[235,331],"source":" To use the file object without an archive, pass **FALSE** in the `bArchiveCompatible` parameter."}]}]},{"content":"In its \"archive compatible\" mode, a <ph id=\"ph1\">`CSocketFile`</ph> object provides better performance and reduces the danger of a \"deadlock.\"","pos":[5382,5506],"source":"In its \"archive compatible\" mode, a `CSocketFile` object provides better performance and reduces the danger of a \"deadlock.\""},{"content":"A deadlock occurs when both the sending and receiving sockets are waiting on each other, or for a common resource.","pos":[5507,5621]},{"content":"This situation might occur if the <ph id=\"ph1\">`CArchive`</ph> object worked with the <ph id=\"ph2\">`CSocketFile`</ph> the way it does with a <ph id=\"ph3\">`CFile`</ph> object.","pos":[5622,5742],"source":" This situation might occur if the `CArchive` object worked with the `CSocketFile` the way it does with a `CFile` object."},{"content":"With <ph id=\"ph1\">`CFile`</ph>, the archive can assume that if it receives fewer bytes than it requested, the end of file has been reached.","pos":[5743,5864],"source":" With `CFile`, the archive can assume that if it receives fewer bytes than it requested, the end of file has been reached."},{"content":"With <ph id=\"ph1\">`CSocketFile`</ph>, however, data is message based; the buffer can contain multiple messages, so receiving fewer than the number of bytes requested does not imply end of file.","pos":[5871,6046],"source":"With `CSocketFile`, however, data is message based; the buffer can contain multiple messages, so receiving fewer than the number of bytes requested does not imply end of file."},{"content":"The application does not block in this case as it might with <ph id=\"ph1\">`CFile`</ph>, and it can continue reading messages from the buffer until the buffer is empty.","pos":[6047,6196],"source":" The application does not block in this case as it might with `CFile`, and it can continue reading messages from the buffer until the buffer is empty."},{"content":"The <bpt id=\"p1\">[</bpt>CArchive::IsBufferEmpty<ept id=\"p1\">](../../mfc/reference/carchive-class.md#carchive__isbufferempty)</ept> function is useful for monitoring the state of the archive's buffer in such a case.","pos":[6197,6373],"source":" The [CArchive::IsBufferEmpty](../../mfc/reference/carchive-class.md#carchive__isbufferempty) function is useful for monitoring the state of the archive's buffer in such a case."},{"pos":[6380,6673],"content":"For more information on the use of <ph id=\"ph1\">`CSocketFile`</ph>, see the articles <bpt id=\"p1\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p1\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept> and <bpt id=\"p2\">[</bpt>Windows Sockets: Example of Sockets Using Archives<ept id=\"p2\">](../../mfc/windows-sockets-example-of-sockets-using-archives.md)</ept>.","source":"For more information on the use of `CSocketFile`, see the articles [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md) and [Windows Sockets: Example of Sockets Using Archives](../../mfc/windows-sockets-example-of-sockets-using-archives.md)."},{"content":"See Also","pos":[6682,6690]},{"content":"CFile Class","pos":[6695,6706]},{"content":"Hierarchy Chart","pos":[6749,6764]},{"content":"CAsyncSocket Class","pos":[6801,6819]},{"content":"CSocket Class","pos":[6869,6882]}],"content":"---\ntitle: \"CSocketFile Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CSocketFile\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"networks [C++], archive\"\n  - \"serialization [C++], network\"\n  - \"networks [C++], serializing to\"\n  - \"CSocketFile class\"\n  - \"archives [C++], network\"\n  - \"SOCKET handle\"\nms.assetid: 7924c098-5f72-40d6-989d-42800a47958f\ncaps.latest.revision: 24\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CSocketFile Class\nA `CFile` object used for sending and receiving data across a network via Windows Sockets.  \n  \n## Syntax  \n  \n```  \nclass CSocketFile : public CFile  \n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CSocketFile::CSocketFile](#csocketfile__csocketfile)|Constructs a `CSocketFile` object.|  \n  \n## Remarks  \n You can attach the `CSocketFile` object to a `CSocket` object for this purpose. You also can, and usually do, attach the `CSocketFile` object to a `CArchive` object to simplify sending and receiving data using MFC serialization.  \n  \n To serialize (send) data, you insert it into the archive, which calls `CSocketFile` member functions to write data to the `CSocket` object. To deserialize (receive) data, you extract from the archive. This causes the archive to call `CSocketFile` member functions to read data from the `CSocket` object.  \n  \n> [!TIP]\n>  Besides using `CSocketFile` as described here, you can use it as a stand-alone file object, just as you can with `CFile`, its base class. You can also use `CSocketFile` with any archive-based MFC serialization functions. Because `CSocketFile` does not support all of `CFile`'s functionality, some default MFC serialize functions are not compatible with `CSocketFile`. This is particularly true of the `CEditView` class. You should not try to serialize `CEditView` data through a `CArchive` object attached to a `CSocketFile` object using `CEditView::SerializeRaw`; use **CEditView::Serialize** instead. The `SerializeRaw` function expects the file object to have functions, such as `Seek`, that `CSocketFile` does not have.  \n  \n When you use `CArchive` with `CSocketFile` and `CSocket`, you might encounter a situation where **CSocket::Receive** enters a loop (by **PumpMessages(FD_READ)**) waiting for the requested amount of bytes. This is because Windows sockets allow only one recv call per FD_READ notification, but `CSocketFile` and `CSocket` allow multiple recv calls per FD_READ. If you get an FD_READ when there is no data to read, the application hangs. If you never get another FD_READ, the application stops communicating over the socket.  \n  \n You can resolve this problem as follows. In the `OnReceive` method of your socket class, call **CAsyncSocket::IOCtl(FIONREAD, ...)** before you call the `Serialize` method of your message class when the expected data to be read from the socket exceeds the size of one TCP packet (maximum transmission unit of the network medium, usually at least 1096 bytes). If the size of the available data is less than needed, wait for all the data to be received and only then start the read operation.  \n  \n In the following example, `m_dwExpected` is the approximate number of bytes that the user expects to receive. It is assumed that you declare it elsewhere in your code.  \n  \n [!code-cpp[NVC_MFCSocketThread#4](../../mfc/reference/codesnippet/cpp/csocketfile-class_1.cpp)]  \n  \n For more information, see [Windows Sockets in MFC](../../mfc/windows-sockets-in-mfc.md), [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md), as well as [Windows Sockets 2 API](http://msdn.microsoft.com/library/windows/desktop/ms740673).  \n  \n## Inheritance Hierarchy  \n [CObject](../../mfc/reference/cobject-class.md)  \n  \n [CFile](../../mfc/reference/cfile-class.md)  \n  \n `CSocketFile`  \n  \n## Requirements  \n **Header:** afxsock.h  \n  \n##  <a name=\"csocketfile__csocketfile\"></a>  CSocketFile::CSocketFile  \n Constructs a `CSocketFile` object.  \n  \n```  \nexplicit CSocketFile(\n    CSocket* pSocket,  \n    BOOL bArchiveCompatible = TRUE);\n```  \n  \n### Parameters  \n `pSocket`  \n The socket to attach to the `CSocketFile` object.  \n  \n `bArchiveCompatible`  \n Specifies whether the file object is for use with a `CArchive` object. Pass **FALSE** only if you want to use the `CSocketFile` object in a stand-alone manner as you would a stand-alone `CFile` object, with certain limitations. This flag changes how the `CArchive` object attached to the `CSocketFile` object manages its buffer for reading.  \n  \n### Remarks  \n The object's destructor disassociates itself from the socket object when the object goes out of scope or is deleted.  \n  \n> [!NOTE]\n>  A `CSocketFile` can also be used as a (limited) file without a `CArchive` object. By default, the `CSocketFile` constructor's `bArchiveCompatible` parameter is **TRUE**. This specifies that the file object is for use with an archive. To use the file object without an archive, pass **FALSE** in the `bArchiveCompatible` parameter.  \n  \n In its \"archive compatible\" mode, a `CSocketFile` object provides better performance and reduces the danger of a \"deadlock.\" A deadlock occurs when both the sending and receiving sockets are waiting on each other, or for a common resource. This situation might occur if the `CArchive` object worked with the `CSocketFile` the way it does with a `CFile` object. With `CFile`, the archive can assume that if it receives fewer bytes than it requested, the end of file has been reached.  \n  \n With `CSocketFile`, however, data is message based; the buffer can contain multiple messages, so receiving fewer than the number of bytes requested does not imply end of file. The application does not block in this case as it might with `CFile`, and it can continue reading messages from the buffer until the buffer is empty. The [CArchive::IsBufferEmpty](../../mfc/reference/carchive-class.md#carchive__isbufferempty) function is useful for monitoring the state of the archive's buffer in such a case.  \n  \n For more information on the use of `CSocketFile`, see the articles [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md) and [Windows Sockets: Example of Sockets Using Archives](../../mfc/windows-sockets-example-of-sockets-using-archives.md).  \n  \n## See Also  \n [CFile Class](../../mfc/reference/cfile-class.md)   \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)   \n [CAsyncSocket Class](../../mfc/reference/casyncsocket-class.md)   \n [CSocket Class](../../mfc/reference/csocket-class.md)\n"}