{"nodes":[{"pos":[12,65],"content":"Using C++ Interop (Implicit PInvoke) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Using C++ Interop (Implicit PInvoke) | Microsoft Docs","pos":[0,53]}]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[1138,1174]},{"content":"Unlike other .NET languages, Visual C++ has interoperability support that allows managed and unmanaged code to exist in the same application and even in the same file (with the <bpt id=\"p1\">[</bpt>managed, unmanaged<ept id=\"p1\">](../preprocessor/managed-unmanaged.md)</ept> pragmas).","pos":[1175,1420],"source":"Unlike other .NET languages, Visual C++ has interoperability support that allows managed and unmanaged code to exist in the same application and even in the same file (with the [managed, unmanaged](../preprocessor/managed-unmanaged.md) pragmas)."},{"content":"This allows Visual C++ developers to integrate .NET functionality into existing Visual C++ applications without disturbing the rest of the application.","pos":[1421,1572]},{"pos":[1579,1702],"content":"You can also call unmanaged functions from a managed compiland using <bpt id=\"p1\">[</bpt>dllexport, dllimport<ept id=\"p1\">](../cpp/dllexport-dllimport.md)</ept>.","source":"You can also call unmanaged functions from a managed compiland using [dllexport, dllimport](../cpp/dllexport-dllimport.md)."},{"content":"Implicit PInvoke is useful when you do not need to specify how function parameters will be marshaled, or any of the other details that can be specified when explicitly calling DllImportAttribute.","pos":[1709,1904]},{"content":"Visual C++ provides two ways for managed and unmanaged functions to interoperate:","pos":[1911,1992]},{"content":"Using Explicit PInvoke in C++ (DllImport Attribute)","pos":[2003,2054]},{"content":"Explicit PInvoke is supported by the .NET Framework and is available in most .NET languages.","pos":[2126,2218]},{"content":"But as its name implies, C++ Interop is specific to Visual C++.","pos":[2219,2282]},{"content":"C++ Interop","pos":[2291,2302]},{"content":"C++ Interop is recommended over explicit PInvoke because it provides better type safety, is typically less tedious to implement, is more forgiving if the unmanaged API is modified, and makes performance enhancements possible that are not possible with explicit PInvoke.","pos":[2306,2575]},{"content":"However, C++ Interop is not possible if the unmanaged source code is not available or when compiling with <bpt id=\"p1\">**</bpt>/clr:safe<ept id=\"p1\">**</ept> (see <bpt id=\"p2\">[</bpt>Pure and Verifiable Code (C++/CLI)<ept id=\"p2\">](../dotnet/pure-and-verifiable-code-cpp-cli.md)</ept> for more information).","pos":[2576,2807],"source":" However, C++ Interop is not possible if the unmanaged source code is not available or when compiling with **/clr:safe** (see [Pure and Verifiable Code (C++/CLI)](../dotnet/pure-and-verifiable-code-cpp-cli.md) for more information)."},{"content":"C++ COM Interop","pos":[2816,2831]},{"content":"The interoperability features supported by Visual C++ offer a particular advantage over other .NET languages when it comes to interoperating with COM components.","pos":[2835,2996]},{"content":"Instead of being limited to the restrictions of the .NET Framework <bpt id=\"p1\">[</bpt>Tlbimp.exe (Type Library Importer)<ept id=\"p1\">](http://msdn.microsoft.com/Library/ec0a8d63-11b3-4acd-b398-da1e37e97382)</ept>, such as limited support for data types and the mandatory exposure of every member of every COM interface, C++ Interop allows COM components to be accessed at will and does not require separate interop assemblies.","pos":[2997,3386],"source":" Instead of being limited to the restrictions of the .NET Framework [Tlbimp.exe (Type Library Importer)](http://msdn.microsoft.com/Library/ec0a8d63-11b3-4acd-b398-da1e37e97382), such as limited support for data types and the mandatory exposure of every member of every COM interface, C++ Interop allows COM components to be accessed at will and does not require separate interop assemblies."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using COM from .NET<ept id=\"p1\">](http://msdn.microsoft.com/en-us/03976661-6278-4227-a6c1-3b3315502c15)</ept>.","pos":[3387,3505],"source":" For more information, see [Using COM from .NET](http://msdn.microsoft.com/en-us/03976661-6278-4227-a6c1-3b3315502c15)."},{"content":"Blittable Types","pos":[3514,3529]},{"content":"For unmanaged APIs that use simple, intrinsic types (see <bpt id=\"p1\">[</bpt>Blittable and Non-Blittable Types<ept id=\"p1\">](http://msdn.microsoft.com/Library/d03b050e-2916-49a0-99ba-f19316e5c1b3)</ept>), no special coding is required because these data types have the same representation in memory, but more complex data types require explicit data marshaling.","pos":[3533,3856],"source":"For unmanaged APIs that use simple, intrinsic types (see [Blittable and Non-Blittable Types](http://msdn.microsoft.com/Library/d03b050e-2916-49a0-99ba-f19316e5c1b3)), no special coding is required because these data types have the same representation in memory, but more complex data types require explicit data marshaling."},{"content":"For an example, see <bpt id=\"p1\">[</bpt>How to: Call Native DLLs from Managed Code Using PInvoke<ept id=\"p1\">](../dotnet/how-to-call-native-dlls-from-managed-code-using-pinvoke.md)</ept>.","pos":[3857,4006],"source":" For an example, see [How to: Call Native DLLs from Managed Code Using PInvoke](../dotnet/how-to-call-native-dlls-from-managed-code-using-pinvoke.md)."},{"content":"Example","pos":[4015,4022]},{"content":"In This Section","pos":[4818,4833]},{"content":"How to: Marshal ANSI Strings Using C++ Interop","pos":[4844,4890]},{"content":"How to: Marshal Unicode Strings Using C++ Interop","pos":[4962,5011]},{"content":"How to: Marshal COM Strings Using C++ Interop","pos":[5086,5131]},{"content":"How to: Marshal Structures Using C++ Interop","pos":[5202,5246]},{"content":"How to: Marshal Arrays Using C++ Interop","pos":[5316,5356]},{"content":"How to: Marshal Callbacks and Delegates By Using C++ Interop","pos":[5422,5482]},{"content":"How to: Marshal Embedded Pointers Using C++ Interop","pos":[5568,5619]},{"content":"How to: Access Characters in a System::String","pos":[5696,5741]},{"content":"How to: Convert char * String to System::Byte Array","pos":[5811,5862]},{"content":"How to: Convert System::String to wchar_t* or char","pos":[5941,5991]},{"content":"How to: Convert System::String to Standard String","pos":[6077,6126]},{"content":"How to: Convert Standard String to System::String","pos":[6200,6249]},{"content":"How to: Obtain a Pointer to Byte Array","pos":[6323,6361]},{"content":"How to: Load Unmanaged Resources into a Byte Array","pos":[6425,6475]},{"content":"How to: Modify Reference Class in a Native Function","pos":[6551,6602]},{"content":"How to: Determine if an Image is Native or CLR","pos":[6679,6725]},{"content":"How to: Add Native DLL to Global Assembly Cache","pos":[6797,6844]},{"content":"How to: Hold Reference to Value Type in Native Type","pos":[6917,6968]},{"content":"How to: Hold Object Reference in Unmanaged Memory","pos":[7045,7094]},{"content":"How to: Detect /clr Compilation","pos":[7169,7200]},{"content":"How to: Convert Between System::Guid and _GUID","pos":[7256,7302]},{"content":"How to: Specify an out Parameter","pos":[7372,7404]},{"content":"How to: Use a Native Type in a /clr Compilation","pos":[7462,7509]},{"content":"How to: Declare Handles in Native Types","pos":[7581,7620]},{"content":"How to: Wrap Native Class for Use by C","pos":[7685,7723]},{"pos":[7789,7940],"content":"For information on using delegates in an interop scenario, see <bpt id=\"p1\">[</bpt>delegate  (C++ Component Extensions)<ept id=\"p1\">](../windows/delegate-cpp-component-extensions.md)</ept>.","source":"For information on using delegates in an interop scenario, see [delegate  (C++ Component Extensions)](../windows/delegate-cpp-component-extensions.md)."},{"content":"See Also","pos":[7949,7957]},{"content":"Calling Native Functions from Managed Code","pos":[7962,8004]}],"content":"---\ntitle: \"Using C++ Interop (Implicit PInvoke) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"blittable types [C++]\"\n  - \"platform invoke [C++], implicit\"\n  - \"interop [C++], features\"\n  - \"data marshaling [C++], C++ Interop features\"\n  - \"porting [C++], C++ native to .NET\"\n  - \"COM interfaces [C++]\"\n  - \"implicit platform invoke\"\n  - \"examples [C++], interoperability\"\n  - \"types [C++], blittable\"\n  - \"marshaling [C++], C++ Interop features\"\n  - \"platform invoke [C++], examples\"\n  - \"interoperability [C++]\"\n  - \"C++ Interop\"\n  - \"interoperability [C++], Implicit PInvoke\"\n  - \"C++, interop\"\n  - \"C++ COM Interop\"\n  - \".NET [C++], porting C++ native to\"\nms.assetid: 5f710bf1-88ae-4c4e-8326-b3f0b7c4c68a\ncaps.latest.revision: 27\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Using C++ Interop (Implicit PInvoke)\nUnlike other .NET languages, Visual C++ has interoperability support that allows managed and unmanaged code to exist in the same application and even in the same file (with the [managed, unmanaged](../preprocessor/managed-unmanaged.md) pragmas). This allows Visual C++ developers to integrate .NET functionality into existing Visual C++ applications without disturbing the rest of the application.  \n  \n You can also call unmanaged functions from a managed compiland using [dllexport, dllimport](../cpp/dllexport-dllimport.md).  \n  \n Implicit PInvoke is useful when you do not need to specify how function parameters will be marshaled, or any of the other details that can be specified when explicitly calling DllImportAttribute.  \n  \n Visual C++ provides two ways for managed and unmanaged functions to interoperate:  \n  \n-   [Using Explicit PInvoke in C++ (DllImport Attribute)](../dotnet/using-explicit-pinvoke-in-cpp-dllimport-attribute.md)  \n  \n Explicit PInvoke is supported by the .NET Framework and is available in most .NET languages. But as its name implies, C++ Interop is specific to Visual C++.  \n  \n## C++ Interop  \n C++ Interop is recommended over explicit PInvoke because it provides better type safety, is typically less tedious to implement, is more forgiving if the unmanaged API is modified, and makes performance enhancements possible that are not possible with explicit PInvoke. However, C++ Interop is not possible if the unmanaged source code is not available or when compiling with **/clr:safe** (see [Pure and Verifiable Code (C++/CLI)](../dotnet/pure-and-verifiable-code-cpp-cli.md) for more information).  \n  \n## C++ COM Interop  \n The interoperability features supported by Visual C++ offer a particular advantage over other .NET languages when it comes to interoperating with COM components. Instead of being limited to the restrictions of the .NET Framework [Tlbimp.exe (Type Library Importer)](http://msdn.microsoft.com/Library/ec0a8d63-11b3-4acd-b398-da1e37e97382), such as limited support for data types and the mandatory exposure of every member of every COM interface, C++ Interop allows COM components to be accessed at will and does not require separate interop assemblies. For more information, see [Using COM from .NET](http://msdn.microsoft.com/en-us/03976661-6278-4227-a6c1-3b3315502c15).  \n  \n## Blittable Types  \n For unmanaged APIs that use simple, intrinsic types (see [Blittable and Non-Blittable Types](http://msdn.microsoft.com/Library/d03b050e-2916-49a0-99ba-f19316e5c1b3)), no special coding is required because these data types have the same representation in memory, but more complex data types require explicit data marshaling. For an example, see [How to: Call Native DLLs from Managed Code Using PInvoke](../dotnet/how-to-call-native-dlls-from-managed-code-using-pinvoke.md).  \n  \n## Example  \n  \n```  \n// vcmcppv2_impl_dllimp.cpp  \n// compile with: /clr:pure user32.lib  \nusing namespace System::Runtime::InteropServices;  \n  \n// Implicit DLLImport specifying calling convention  \nextern \"C\" int __stdcall MessageBeep(int);  \n  \n// explicit DLLImport needed here to use P/Invoke marshalling because  \n// System::String ^ is not the type of the first parameter to printf  \n[DllImport(\"msvcrt.dll\", EntryPoint = \"printf\", CallingConvention = CallingConvention::Cdecl,  CharSet = CharSet::Ansi)]  \n// or just  \n// [DllImport(\"msvcrt.dll\")]  \nint printf(System::String ^, ...);   \n  \nint main() {  \n   // (string literals are System::String by default)  \n   printf(\"Begin beep\\n\");  \n   MessageBeep(100000);  \n   printf(\"Done\\n\");  \n}  \n```  \n  \n```Output  \nBegin beep  \nDone  \n```  \n  \n## In This Section  \n  \n-   [How to: Marshal ANSI Strings Using C++ Interop](../dotnet/how-to-marshal-ansi-strings-using-cpp-interop.md)  \n  \n-   [How to: Marshal Unicode Strings Using C++ Interop](../dotnet/how-to-marshal-unicode-strings-using-cpp-interop.md)  \n  \n-   [How to: Marshal COM Strings Using C++ Interop](../dotnet/how-to-marshal-com-strings-using-cpp-interop.md)  \n  \n-   [How to: Marshal Structures Using C++ Interop](../dotnet/how-to-marshal-structures-using-cpp-interop.md)  \n  \n-   [How to: Marshal Arrays Using C++ Interop](../dotnet/how-to-marshal-arrays-using-cpp-interop.md)  \n  \n-   [How to: Marshal Callbacks and Delegates By Using C++ Interop](../dotnet/how-to-marshal-callbacks-and-delegates-by-using-cpp-interop.md)  \n  \n-   [How to: Marshal Embedded Pointers Using C++ Interop](../dotnet/how-to-marshal-embedded-pointers-using-cpp-interop.md)  \n  \n-   [How to: Access Characters in a System::String](../dotnet/how-to-access-characters-in-a-system-string.md)  \n  \n-   [How to: Convert char * String to System::Byte Array](../dotnet/how-to-convert-char-star-string-to-system-byte-array.md)  \n  \n-   [How to: Convert System::String to wchar_t* or char\\*](../dotnet/how-to-convert-system-string-to-wchar-t-star-or-char-star.md)  \n  \n-   [How to: Convert System::String to Standard String](../dotnet/how-to-convert-system-string-to-standard-string.md)  \n  \n-   [How to: Convert Standard String to System::String](../dotnet/how-to-convert-standard-string-to-system-string.md)  \n  \n-   [How to: Obtain a Pointer to Byte Array](../dotnet/how-to-obtain-a-pointer-to-byte-array.md)  \n  \n-   [How to: Load Unmanaged Resources into a Byte Array](../dotnet/how-to-load-unmanaged-resources-into-a-byte-array.md)  \n  \n-   [How to: Modify Reference Class in a Native Function](../dotnet/how-to-modify-reference-class-in-a-native-function.md)  \n  \n-   [How to: Determine if an Image is Native or CLR](../dotnet/how-to-determine-if-an-image-is-native-or-clr.md)  \n  \n-   [How to: Add Native DLL to Global Assembly Cache](../dotnet/how-to-add-native-dll-to-global-assembly-cache.md)  \n  \n-   [How to: Hold Reference to Value Type in Native Type](../dotnet/how-to-hold-reference-to-value-type-in-native-type.md)  \n  \n-   [How to: Hold Object Reference in Unmanaged Memory](../dotnet/how-to-hold-object-reference-in-unmanaged-memory.md)  \n  \n-   [How to: Detect /clr Compilation](../dotnet/how-to-detect-clr-compilation.md)  \n  \n-   [How to: Convert Between System::Guid and _GUID](../dotnet/how-to-convert-between-system-guid-and-guid.md)  \n  \n-   [How to: Specify an out Parameter](../dotnet/how-to-specify-an-out-parameter.md)  \n  \n-   [How to: Use a Native Type in a /clr Compilation](../dotnet/how-to-use-a-native-type-in-a-clr-compilation.md)  \n  \n-   [How to: Declare Handles in Native Types](../dotnet/how-to-declare-handles-in-native-types.md)  \n  \n-   [How to: Wrap Native Class for Use by C#](../dotnet/how-to-wrap-native-class-for-use-by-csharp.md)  \n  \n For information on using delegates in an interop scenario, see [delegate  (C++ Component Extensions)](../windows/delegate-cpp-component-extensions.md).  \n  \n## See Also  \n [Calling Native Functions from Managed Code](../dotnet/calling-native-functions-from-managed-code.md)"}