{"nodes":[{"pos":[12,68],"content":"Trivial, standard-layout, and POD types | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Trivial, standard-layout, and POD types | Microsoft Docs","pos":[0,56]}]},{"content":"Trivial, standard-layout, and POD types","pos":[271,310]},{"content":"The term <bpt id=\"p1\">*</bpt>layout<ept id=\"p1\">*</ept> refers to how the members of an object of class, struct or union type are arranged in memory.","pos":[311,422],"source":"The term *layout* refers to how the members of an object of class, struct or union type are arranged in memory."},{"content":"In some cases, the layout is well-defined by the language specification.","pos":[423,495]},{"content":"But when a class or struct contains certain C++ language features such as virtual base classes, virtual functions, members with different access control, then the compiler is free to choose a layout.","pos":[496,695]},{"content":"That layout may vary depending on what optimizations are being performed and in many cases object might not even occupy a contiguous area of memory.","pos":[696,844]},{"content":"For example, if a class has virtual functions, all the instances of that class might share a single virtual function table.","pos":[845,968]},{"content":"Such types are of course very useful, but they also have limitations.","pos":[969,1038]},{"content":"Because the layout is undefined they cannot be passed to programs written in other languages, such as C, and because they might be non-contiguous they cannot be reliably copied with fast low-level functions such as <ph id=\"ph1\">`memcopy`</ph> or serialized over a network.","pos":[1039,1293],"source":" Because the layout is undefined they cannot be passed to programs written in other languages, such as C, and because they might be non-contiguous they cannot be reliably copied with fast low-level functions such as `memcopy` or serialized over a network."},{"content":"To enable compilers as well as C++ programs and metaprograms to reason about the suitability of any given type for operations that depend on a particular memory layout, C++14 introduced three categories of simple classes and structs: <bpt id=\"p1\">*</bpt>trivial<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>standard-layout<ept id=\"p2\">*</ept>, and <bpt id=\"p3\">*</bpt>POD<ept id=\"p3\">*</ept> or Plain Old Data.","pos":[1300,1592],"source":"To enable compilers as well as C++ programs and metaprograms to reason about the suitability of any given type for operations that depend on a particular memory layout, C++14 introduced three categories of simple classes and structs: *trivial*, *standard-layout*, and *POD* or Plain Old Data."},{"content":"The Standard Library has the function templates <ph id=\"ph1\">`is_trivial&lt;T&gt;`</ph>, <ph id=\"ph2\">`is_standard_layout&lt;T&gt;`</ph> and <ph id=\"ph3\">`is_pod&lt;T&gt;`</ph> that determine whether a given type belongs to a given category.","pos":[1593,1762],"source":" The Standard Library has the function templates `is_trivial<T>`, `is_standard_layout<T>` and `is_pod<T>` that determine whether a given type belongs to a given category."},{"content":"Trivial types","pos":[1771,1784]},{"content":"When a class or struct in C++ has compiler-provided or explicitly defaulted special member functions, then it is a trivial type.","pos":[1788,1916]},{"content":"It occupies a contiguous memory area.","pos":[1917,1954]},{"content":"It can have members with different access specifiers.","pos":[1955,2008]},{"content":"In C++, the compiler is free to choose how to order  members in this situation.","pos":[2009,2088]},{"content":"Therefore, you can memcopy such objects but you cannot reliably consume them from a C program.","pos":[2089,2183]},{"content":"A trivial type T can be copied into an array of char or unsigned char, and safely copied back into a T variable.","pos":[2184,2296]},{"content":"Note that because of alignment requirements, there might be padding bytes between type members.","pos":[2297,2392]},{"content":"Trivial types have a trivial default constructor, trivial copy constructor, trivial copy assignment operator and trivial destructor.","pos":[2399,2531]},{"content":"In each case, <bpt id=\"p1\">*</bpt>trivial<ept id=\"p1\">*</ept> means the constructor/operator/destructor is not user-provided and belongs to a class that has","pos":[2532,2650],"source":" In each case, *trivial* means the constructor/operator/destructor is not user-provided and belongs to a class that has"},{"content":"no virtual functions or virtual base classes,","pos":[2660,2705]},{"content":"no base classes with a corresponding non-trivial constructor/operator/destructor","pos":[2715,2795]},{"content":"no data members of class type with a corresponding non-trivial constructor/operator/destructor","pos":[2805,2899]},{"content":"The following examples show trivial types.","pos":[2906,2948]},{"content":"In Trivial2, the presence of the <ph id=\"ph1\">`Trivial2(int a, int b)`</ph> constructor requires that you provide a default constructor.","pos":[2949,3067],"source":" In Trivial2, the presence of the `Trivial2(int a, int b)` constructor requires that you provide a default constructor."},{"content":"For the type to qualify as trivial, you must explicitly default that constructor.","pos":[3068,3149]},{"content":"Standard layout types","pos":[3416,3437]},{"content":"When a class or struct does not contain certain C++ language features such as virtual functions which are not found in the C language, and all members have the same access control, it is a standard-layout type.","pos":[3441,3651]},{"content":"It is memcopy-able and the layout is sufficiently defined that it can be consumed by C programs.","pos":[3652,3748]},{"content":"Standard-layout types can have user-defined special member functions.","pos":[3749,3818]},{"content":"In addition, standard layout types have these characteristics:","pos":[3819,3881]},{"content":"no virtual functions or virtual base classes","pos":[3891,3935]},{"content":"all non-static data members have the same access control","pos":[3945,4001]},{"content":"all non-static members of class type are standard-layout","pos":[4011,4067]},{"content":"any base classes are standard-layout","pos":[4077,4113]},{"content":"has no base classes of the same type as the first non-static data member.","pos":[4123,4196]},{"content":"meets one of these conditions:","pos":[4206,4236]},{"content":"no non-static data member in the most-derived class and no more than one base class with non-static data members, or","pos":[4250,4366]},{"content":"has no base classes with non-static data members","pos":[4380,4428]},{"content":"The following code shows one example of a standard-layout type:","pos":[4435,4498]},{"content":"The last two requirements can perhaps be better illustrated with code.","pos":[4684,4754]},{"content":"In the next example, even though Base is standard-layout, <ph id=\"ph1\">`Derived`</ph> is not standard layout because both it (the most derived class) and <ph id=\"ph2\">`Base`</ph> have non-static data members:","pos":[4755,4927],"source":" In the next example, even though Base is standard-layout, `Derived` is not standard layout because both it (the most derived class) and `Base` have non-static data members:"},{"pos":[5122,5213],"content":"In this example <ph id=\"ph1\">`Derived`</ph> is standard-layout because <ph id=\"ph2\">`Base`</ph> has no non-static data members:","source":"In this example `Derived` is standard-layout because `Base` has no non-static data members:"},{"pos":[5397,5506],"content":"Derived would also be standard-layout if <ph id=\"ph1\">`Base`</ph> had the data members and <ph id=\"ph2\">`Derived`</ph> had only member functions.","source":"Derived would also be standard-layout if `Base` had the data members and `Derived` had only member functions."},{"content":"POD types","pos":[5515,5524]},{"content":"When a class or struct is both trivial and standard-layout, it is a POD (Plain Old Data) type.","pos":[5528,5622]},{"content":"The memory layout of POD types is therefore contiguous and each member has a higher address than the member that was declared before it, so that byte for byte copies and binary I/O can be performed on these types.","pos":[5623,5836]},{"content":"Scalar types such as int are also POD types.","pos":[5838,5882]},{"content":"POD types that are classes can have only POD types as non-static data members.","pos":[5883,5961]},{"content":"Example","pos":[5970,5977]},{"content":"The following example shows the distinctions between trivial, standard-layout, and POD types:","pos":[5981,6074]},{"content":"See Also","pos":[7397,7405]},{"content":"Basic Concepts","pos":[7410,7424]}],"content":"---\ntitle: \"Trivial, standard-layout, and POD types | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 2b23a7be-9bad-49fc-8298-31a9a7c556b0\ncaps.latest.revision: 13\nmanager: \"ghogen\"\n---\n# Trivial, standard-layout, and POD types\nThe term *layout* refers to how the members of an object of class, struct or union type are arranged in memory. In some cases, the layout is well-defined by the language specification. But when a class or struct contains certain C++ language features such as virtual base classes, virtual functions, members with different access control, then the compiler is free to choose a layout. That layout may vary depending on what optimizations are being performed and in many cases object might not even occupy a contiguous area of memory. For example, if a class has virtual functions, all the instances of that class might share a single virtual function table. Such types are of course very useful, but they also have limitations. Because the layout is undefined they cannot be passed to programs written in other languages, such as C, and because they might be non-contiguous they cannot be reliably copied with fast low-level functions such as `memcopy` or serialized over a network.  \n  \n To enable compilers as well as C++ programs and metaprograms to reason about the suitability of any given type for operations that depend on a particular memory layout, C++14 introduced three categories of simple classes and structs: *trivial*, *standard-layout*, and *POD* or Plain Old Data. The Standard Library has the function templates `is_trivial<T>`, `is_standard_layout<T>` and `is_pod<T>` that determine whether a given type belongs to a given category.  \n  \n## Trivial types  \n When a class or struct in C++ has compiler-provided or explicitly defaulted special member functions, then it is a trivial type. It occupies a contiguous memory area. It can have members with different access specifiers. In C++, the compiler is free to choose how to order  members in this situation. Therefore, you can memcopy such objects but you cannot reliably consume them from a C program. A trivial type T can be copied into an array of char or unsigned char, and safely copied back into a T variable. Note that because of alignment requirements, there might be padding bytes between type members.  \n  \n Trivial types have a trivial default constructor, trivial copy constructor, trivial copy assignment operator and trivial destructor. In each case, *trivial* means the constructor/operator/destructor is not user-provided and belongs to a class that has  \n  \n-   no virtual functions or virtual base classes,  \n  \n-   no base classes with a corresponding non-trivial constructor/operator/destructor  \n  \n-   no data members of class type with a corresponding non-trivial constructor/operator/destructor  \n  \n The following examples show trivial types. In Trivial2, the presence of the `Trivial2(int a, int b)` constructor requires that you provide a default constructor. For the type to qualify as trivial, you must explicitly default that constructor.  \n  \n```cpp  \nstruct Trivial  \n{   \n    int i;  \nprivate:  \n    int j;    \n};  \n  \nstruct Trivial2  \n{   \n    int i;  \n    Trivial2(int a, int b) : i(a), j(b) {}  \n    Trivial2() = default;   \nprivate:  \n    int j;  // Different access control  \n};  \n  \n```  \n  \n## Standard layout types  \n When a class or struct does not contain certain C++ language features such as virtual functions which are not found in the C language, and all members have the same access control, it is a standard-layout type. It is memcopy-able and the layout is sufficiently defined that it can be consumed by C programs. Standard-layout types can have user-defined special member functions. In addition, standard layout types have these characteristics:  \n  \n-   no virtual functions or virtual base classes  \n  \n-   all non-static data members have the same access control  \n  \n-   all non-static members of class type are standard-layout  \n  \n-   any base classes are standard-layout  \n  \n-   has no base classes of the same type as the first non-static data member.  \n  \n-   meets one of these conditions:  \n  \n    -   no non-static data member in the most-derived class and no more than one base class with non-static data members, or  \n  \n    -   has no base classes with non-static data members  \n  \n The following code shows one example of a standard-layout type:  \n  \n```cpp  \nstruct SL   \n{     \n   // All members have same access:  \n   int i;  \n    int j;  \n    SL(int a, int b) : i(a), j(b) {} // User-defined constructor OK  \n};  \n  \n```  \n  \n The last two requirements can perhaps be better illustrated with code. In the next example, even though Base is standard-layout, `Derived` is not standard layout because both it (the most derived class) and `Base` have non-static data members:  \n  \n```cpp  \nstruct Base  \n{  \n    int i;  \n    int j;  \n};  \n  \n// std::is_standard_layout<<Derived> == false!  \nstruct Derived : public Base  \n{  \n    int x;  \n    int y;  \n};  \n  \n```  \n  \n In this example `Derived` is standard-layout because `Base` has no non-static data members:  \n  \n```cpp  \nstruct Base  \n{  \n    void Foo() {}  \n};  \n  \n// std::is_standard_layout<<Derived> == true  \nstruct Derived : public Base  \n{  \n    int x;  \n    int y;  \n};  \n```  \n  \n Derived would also be standard-layout if `Base` had the data members and `Derived` had only member functions.  \n  \n## POD types  \n When a class or struct is both trivial and standard-layout, it is a POD (Plain Old Data) type. The memory layout of POD types is therefore contiguous and each member has a higher address than the member that was declared before it, so that byte for byte copies and binary I/O can be performed on these types.  Scalar types such as int are also POD types. POD types that are classes can have only POD types as non-static data members.  \n  \n## Example  \n The following example shows the distinctions between trivial, standard-layout, and POD types:  \n  \n```cpp  \n  \n#include <type_traits>  \n#include <iostream>  \n  \nusing namespace std;  \n  \nstruct B  \n{  \nprotected:  \n    virtual void Foo() {}  \n};  \n  \n// Neither trivial nor standard-layout  \nstruct A : B  \n{   \n    int a;  \n    int b;  \n    void Foo() override {} // Virtual function  \n};  \n  \n// Trivial but not standard-layout  \nstruct C   \n{   \n    int a;  \nprivate:  \n    int b;  // Different access control  \n};  \n  \n// Standard-layout but not trivial  \nstruct D   \n{   \n    int a;  \n    int b;  \n    D() {} //User-defined constructor  \n};  \n  \nstruct POD   \n{  \n    int a;  \n    int b;  \n};  \n  \nint main()  \n{  \n cout << boolalpha;  \n    cout << \"A is trivial is \" << is_trivial<A>() << endl; // false  \n    cout << \"A is standard-layout is \" << is_standard_layout<A>() << endl;  // false  \n  \n    cout << \"C is trivial is \" << is_trivial<C>() << endl; // true  \n    cout << \"C is standard-layout is \" << is_standard_layout<C>() << endl;  // false  \n  \n    cout << \"D is trivial is \" << is_trivial<D>() << endl;  // false  \n    cout << \"D is standard-layout is \" << is_standard_layout<D>() << endl; // true  \n  \n    cout << \"POD is trivial is \" << is_trivial<POD>() << endl; // true  \n    cout << \"POD is standard-layout is \" << is_standard_layout<POD>() << endl; // true  \n  \nreturn 0;  \n}  \n  \n```  \n  \n## See Also  \n [Basic Concepts](../cpp/basic-concepts-cpp.md)"}