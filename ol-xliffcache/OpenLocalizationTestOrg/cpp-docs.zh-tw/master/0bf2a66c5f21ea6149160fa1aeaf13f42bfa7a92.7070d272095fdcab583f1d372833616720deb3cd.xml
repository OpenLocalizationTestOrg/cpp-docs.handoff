{"nodes":[{"pos":[12,61],"content":"Compiler Warning (level 2) C4146 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Warning (level 2) C4146 | Microsoft Docs","pos":[0,49]}]},{"content":"Compiler Warning (level 2) C4146","pos":[609,641]},{"content":"unary minus operator applied to unsigned type, result still unsigned","pos":[642,710]},{"content":"Unsigned types can hold only non-negative values, so unary minus (negation) does not usually make sense when applied to an unsigned type.","pos":[717,854]},{"content":"Both the operand and the result are non-negative.","pos":[855,904]},{"content":"Practically, this occurs when the programmer is trying to express the minimum integer value, which is -2147483648.","pos":[911,1025]},{"content":"This value cannot be written as -2147483648 because the expression is processed in two stages:","pos":[1026,1120]},{"content":"The number 2147483648 is evaluated.","pos":[1130,1165]},{"content":"Because it is greater than the maximum integer value of 2147483647, the type of 2147483648 is not <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](../../c-language/integer-types.md)</ept>, but <ph id=\"ph1\">`unsigned int`</ph>.","pos":[1166,1325],"source":" Because it is greater than the maximum integer value of 2147483647, the type of 2147483648 is not [int](../../c-language/integer-types.md), but `unsigned int`."},{"content":"Unary minus is applied to the value, with an unsigned result, which also happens to be 2147483648.","pos":[1335,1433]},{"content":"The unsigned type of the result can cause unexpected behavior.","pos":[1440,1502]},{"content":"If the result is used in a comparison, then an unsigned comparison might be used, for example, when the other operand is an <ph id=\"ph1\">`int`</ph>.","pos":[1503,1633],"source":" If the result is used in a comparison, then an unsigned comparison might be used, for example, when the other operand is an `int`."},{"content":"This explains why the example program below prints just one line.","pos":[1634,1699]},{"pos":[1706,1840],"content":"The expected second line, <ph id=\"ph1\">`1 is greater than the most negative int`</ph>, is not printed because <ph id=\"ph2\">`((unsigned int)1) &gt; 2147483648`</ph> is false.","source":"The expected second line, `1 is greater than the most negative int`, is not printed because `((unsigned int)1) > 2147483648` is false."},{"pos":[1847,1933],"content":"You can avoid C4146 by using INT_MIN from limits.h, which has the type <bpt id=\"p1\">**</bpt>signed int<ept id=\"p1\">**</ept>.","source":"You can avoid C4146 by using INT_MIN from limits.h, which has the type **signed int**."},{"content":"Example","pos":[1942,1949]},{"content":"The following sample generates C4146:","pos":[1953,1990]}],"content":"---\ntitle: \"Compiler Warning (level 2) C4146 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C4146\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C4146\"\nms.assetid: d6c31ab1-3120-40d5-8d80-32b5f7046e32\ncaps.latest.revision: 9\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Compiler Warning (level 2) C4146\nunary minus operator applied to unsigned type, result still unsigned  \n  \n Unsigned types can hold only non-negative values, so unary minus (negation) does not usually make sense when applied to an unsigned type. Both the operand and the result are non-negative.  \n  \n Practically, this occurs when the programmer is trying to express the minimum integer value, which is -2147483648. This value cannot be written as -2147483648 because the expression is processed in two stages:  \n  \n1.  The number 2147483648 is evaluated. Because it is greater than the maximum integer value of 2147483647, the type of 2147483648 is not [int](../../c-language/integer-types.md), but `unsigned int`.  \n  \n2.  Unary minus is applied to the value, with an unsigned result, which also happens to be 2147483648.  \n  \n The unsigned type of the result can cause unexpected behavior. If the result is used in a comparison, then an unsigned comparison might be used, for example, when the other operand is an `int`. This explains why the example program below prints just one line.  \n  \n The expected second line, `1 is greater than the most negative int`, is not printed because `((unsigned int)1) > 2147483648` is false.  \n  \n You can avoid C4146 by using INT_MIN from limits.h, which has the type **signed int**.  \n  \n## Example  \n The following sample generates C4146:  \n  \n```  \n// C4146.cpp  \n// compile with: /W2  \n#include <stdio.h>  \n  \nvoid check(int i)   \n{  \n    if (i > -2147483648)   // C4146  \n        printf_s(\"%d is greater than the most negative int\\n\", i);  \n}  \n  \nint main()   \n{  \n    check(-100);  \n    check(1);  \n}  \n```"}