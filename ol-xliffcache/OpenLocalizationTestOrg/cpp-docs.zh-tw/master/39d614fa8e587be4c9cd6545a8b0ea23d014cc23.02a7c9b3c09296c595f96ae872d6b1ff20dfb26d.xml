{"nodes":[{"pos":[12,48],"content":"Compiler Intrinsics | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Intrinsics | Microsoft Docs","pos":[0,36]}]},{"content":"Compiler Intrinsics","pos":[673,692]},{"content":"Most functions are contained in libraries, but some functions are built in (that is, intrinsic) to the compiler.","pos":[693,805]},{"content":"These are referred to as intrinsic functions or intrinsics.","pos":[806,865]},{"content":"Remarks","pos":[874,881]},{"content":"If a function is an intrinsic, the code for that function is usually inserted inline, avoiding the overhead of a function call and allowing highly efficient machine instructions to be emitted for that function.","pos":[885,1095]},{"content":"An intrinsic is often faster than the equivalent inline assembly, because the optimizer has a built-in knowledge of how many intrinsics behave, so some optimizations can be available that are not available when inline assembly is used.","pos":[1096,1331]},{"content":"Also, the optimizer can expand the intrinsic differently, align buffers differently, or make other adjustments depending on the context and arguments of the call.","pos":[1332,1494]},{"content":"The use of intrinsics affects the portability of code, because intrinsics that are available in Visual C++ might not be available if the code is compiled with other compilers and some intrinsics that might be available for some target architectures are not available for all architectures.","pos":[1501,1790]},{"content":"However, intrinsics are usually more portable than inline assembly.","pos":[1791,1858]},{"content":"The intrinsics are required on 64-bit architectures where inline assembly is not supported.","pos":[1859,1950]},{"pos":[1957,2100],"content":"Some intrinsics, such as <ph id=\"ph1\">`__assume`</ph> and <ph id=\"ph2\">`__ReadWriteBarrier`</ph>, provide information to the compiler, which affects the behavior of the optimizer.","source":"Some intrinsics, such as `__assume` and `__ReadWriteBarrier`, provide information to the compiler, which affects the behavior of the optimizer."},{"content":"Some intrinsics are available only as intrinsics, and some are available both in function and intrinsic implementations.","pos":[2107,2227]},{"content":"You can instruct the compiler to use the intrinsic implementation in one of two ways, depending on whether you want to enable only specific functions or you want to enable all intrinsics.","pos":[2228,2415]},{"content":"The first way is to use <ph id=\"ph1\">`#pragma intrinsic(``intrinsic-function-name-list``)`</ph>.","pos":[2416,2494],"source":" The first way is to use `#pragma intrinsic(``intrinsic-function-name-list``)`."},{"content":"The pragma can be used to specify a single intrinsic or multiple intrinsics separated by commas.","pos":[2495,2591]},{"content":"The second is to use the <bpt id=\"p1\">[</bpt>/Oi (Generate Intrinsic Functions)<ept id=\"p1\">](../build/reference/oi-generate-intrinsic-functions.md)</ept> compiler option, which makes all intrinsics on a given platform available.","pos":[2592,2783],"source":" The second is to use the [/Oi (Generate Intrinsic Functions)](../build/reference/oi-generate-intrinsic-functions.md) compiler option, which makes all intrinsics on a given platform available."},{"content":"Under <bpt id=\"p1\">**</bpt>/Oi<ept id=\"p1\">**</ept>, use <ph id=\"ph1\">`#pragma function(``intrinsic-function-name-list``)`</ph> to force a function call to be used instead of an intrinsic.","pos":[2784,2916],"source":" Under **/Oi**, use `#pragma function(``intrinsic-function-name-list``)` to force a function call to be used instead of an intrinsic."},{"content":"If the documentation for a specific intrinsic notes that the routine is only available as an intrinsic, then the intrinsic implementation is used regardless of whether <bpt id=\"p1\">**</bpt>/Oi<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`#pragma intrinsic`</ph> is specified.","pos":[2917,3129],"source":" If the documentation for a specific intrinsic notes that the routine is only available as an intrinsic, then the intrinsic implementation is used regardless of whether **/Oi** or `#pragma intrinsic` is specified."},{"content":"In all cases, <bpt id=\"p1\">**</bpt>/Oi<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`#pragma intrinsic`</ph> allows, but does not force, the optimizer to use the intrinsic.","pos":[3130,3238],"source":" In all cases, **/Oi** or `#pragma intrinsic` allows, but does not force, the optimizer to use the intrinsic."},{"content":"The optimizer can still call the function.","pos":[3239,3281]},{"content":"Some standard C/C++ library functions are available in intrinsic implementations on some architectures.","pos":[3288,3391]},{"content":"When calling a CRT function, the intrinsic implementation is used if <bpt id=\"p1\">**</bpt>/Oi<ept id=\"p1\">**</ept> is specified on the command line.","pos":[3392,3502],"source":" When calling a CRT function, the intrinsic implementation is used if **/Oi** is specified on the command line."},{"content":"A header file, <ph id=\"ph1\">\\&lt;</ph>intrin.h&gt;, is available that declares prototypes for the common intrinsic functions.","pos":[3509,3610],"source":"A header file, \\<intrin.h>, is available that declares prototypes for the common intrinsic functions."},{"content":"Manufacturer-specific intrinsics are available in the <ph id=\"ph1\">\\&lt;</ph>immintrin.h&gt; and <ph id=\"ph2\">\\&lt;</ph>ammintrin.h&gt; header files.","pos":[3611,3712],"source":" Manufacturer-specific intrinsics are available in the \\<immintrin.h> and \\<ammintrin.h> header files."},{"content":"Additionally, certain Windows headers declare functions that map onto a compiler intrinsic.","pos":[3713,3804]},{"content":"The following sections list all intrinsics that are available on various architectures.","pos":[3811,3898]},{"content":"For more information on how the intrinsics work on your particular target processor, refer to the manufacturer's reference documentation.","pos":[3899,4036]},{"content":"ARM Intrinsics","pos":[4047,4061]},{"content":"x86 Intrinsics List","pos":[4106,4125]},{"content":"x64 (amd64) Intrinsics List","pos":[4175,4202]},{"content":"Intrinsics Available on All Architectures","pos":[4258,4299]},{"content":"Alphabetical Listing of Intrinsic Functions","pos":[4371,4414]},{"content":"See Also","pos":[4486,4494]},{"content":"ARM Assembler Reference","pos":[4499,4522]},{"content":"Microsoft Macro Assembler Reference","pos":[4574,4609]},{"content":"Keywords","pos":[4674,4682]},{"content":"C Run-Time Library Reference","pos":[4713,4741]}],"content":"---\ntitle: \"Compiler Intrinsics | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"intrinsics, compiler\"\n  - \"compiler intrinsics\"\n  - \"cl.exe compiler, performance\"\n  - \"cl.exe compiler, intrinsics\"\nms.assetid: 48bb9929-7d78-4fd8-a092-ae3c9f971858\ncaps.latest.revision: 17\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Compiler Intrinsics\nMost functions are contained in libraries, but some functions are built in (that is, intrinsic) to the compiler. These are referred to as intrinsic functions or intrinsics.  \n  \n## Remarks  \n If a function is an intrinsic, the code for that function is usually inserted inline, avoiding the overhead of a function call and allowing highly efficient machine instructions to be emitted for that function. An intrinsic is often faster than the equivalent inline assembly, because the optimizer has a built-in knowledge of how many intrinsics behave, so some optimizations can be available that are not available when inline assembly is used. Also, the optimizer can expand the intrinsic differently, align buffers differently, or make other adjustments depending on the context and arguments of the call.  \n  \n The use of intrinsics affects the portability of code, because intrinsics that are available in Visual C++ might not be available if the code is compiled with other compilers and some intrinsics that might be available for some target architectures are not available for all architectures. However, intrinsics are usually more portable than inline assembly. The intrinsics are required on 64-bit architectures where inline assembly is not supported.  \n  \n Some intrinsics, such as `__assume` and `__ReadWriteBarrier`, provide information to the compiler, which affects the behavior of the optimizer.  \n  \n Some intrinsics are available only as intrinsics, and some are available both in function and intrinsic implementations. You can instruct the compiler to use the intrinsic implementation in one of two ways, depending on whether you want to enable only specific functions or you want to enable all intrinsics. The first way is to use `#pragma intrinsic(``intrinsic-function-name-list``)`. The pragma can be used to specify a single intrinsic or multiple intrinsics separated by commas. The second is to use the [/Oi (Generate Intrinsic Functions)](../build/reference/oi-generate-intrinsic-functions.md) compiler option, which makes all intrinsics on a given platform available. Under **/Oi**, use `#pragma function(``intrinsic-function-name-list``)` to force a function call to be used instead of an intrinsic. If the documentation for a specific intrinsic notes that the routine is only available as an intrinsic, then the intrinsic implementation is used regardless of whether **/Oi** or `#pragma intrinsic` is specified. In all cases, **/Oi** or `#pragma intrinsic` allows, but does not force, the optimizer to use the intrinsic. The optimizer can still call the function.  \n  \n Some standard C/C++ library functions are available in intrinsic implementations on some architectures. When calling a CRT function, the intrinsic implementation is used if **/Oi** is specified on the command line.  \n  \n A header file, \\<intrin.h>, is available that declares prototypes for the common intrinsic functions. Manufacturer-specific intrinsics are available in the \\<immintrin.h> and \\<ammintrin.h> header files. Additionally, certain Windows headers declare functions that map onto a compiler intrinsic.  \n  \n The following sections list all intrinsics that are available on various architectures. For more information on how the intrinsics work on your particular target processor, refer to the manufacturer's reference documentation.  \n  \n-   [ARM Intrinsics](../intrinsics/arm-intrinsics.md)  \n  \n-   [x86 Intrinsics List](../intrinsics/x86-intrinsics-list.md)  \n  \n-   [x64 (amd64) Intrinsics List](../intrinsics/x64-amd64-intrinsics-list.md)  \n  \n-   [Intrinsics Available on All Architectures](../intrinsics/intrinsics-available-on-all-architectures.md)  \n  \n-   [Alphabetical Listing of Intrinsic Functions](../intrinsics/alphabetical-listing-of-intrinsic-functions.md)  \n  \n## See Also  \n [ARM Assembler Reference](../assembler/arm/arm-assembler-reference.md)   \n [Microsoft Macro Assembler Reference](../assembler/masm/microsoft-macro-assembler-reference.md)   \n [Keywords](../cpp/keywords-cpp.md)   \n [C Run-Time Library Reference](../c-runtime-library/c-run-time-library-reference.md)"}