{"nodes":[{"pos":[12,58],"content":"General Rules and Limitations | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"General Rules and Limitations | Microsoft Docs","pos":[0,46]}]},{"content":"General Rules and Limitations","pos":[549,578]},{"content":"Microsoft Specific","pos":[582,600]},{"content":"If you declare a function or object without the <bpt id=\"p1\">**</bpt>dllimport<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`dllexport`</ph> attribute, the function or object is not considered part of the DLL interface.","pos":[610,765],"source":"If you declare a function or object without the **dllimport** or `dllexport` attribute, the function or object is not considered part of the DLL interface."},{"content":"Therefore, the definition of the function or object must be present in that module or in another module of the same program.","pos":[766,890]},{"content":"To make the function or object part of the DLL interface, you must declare the definition of the function or object in the other module as <ph id=\"ph1\">`dllexport`</ph>.","pos":[891,1042],"source":" To make the function or object part of the DLL interface, you must declare the definition of the function or object in the other module as `dllexport`."},{"content":"Otherwise, a linker error is generated.","pos":[1043,1082]},{"content":"If you declare a function or object with the <ph id=\"ph1\">`dllexport`</ph> attribute, its definition must appear in some module of the same program.","pos":[1093,1223],"source":"If you declare a function or object with the `dllexport` attribute, its definition must appear in some module of the same program."},{"content":"Otherwise, a linker error is generated.","pos":[1224,1263]},{"content":"If a single module in your program contains both <bpt id=\"p1\">**</bpt>dllimport<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`dllexport`</ph> declarations for the same function or object, the <ph id=\"ph2\">`dllexport`</ph> attribute takes precedence over the <bpt id=\"p2\">**</bpt>dllimport<ept id=\"p2\">**</ept> attribute.","pos":[1273,1474],"source":"If a single module in your program contains both **dllimport** and `dllexport` declarations for the same function or object, the `dllexport` attribute takes precedence over the **dllimport** attribute."},{"content":"However, a compiler warning is generated.","pos":[1475,1516]},{"content":"For example:","pos":[1517,1529]},{"content":"In C++, you can initialize a globally declared or static local data pointer or with the address of a data object declared with the <bpt id=\"p1\">**</bpt>dllimport<ept id=\"p1\">**</ept> attribute, which generates an error in C. In addition, you can initialize a static local function pointer with the address of a function declared with the <bpt id=\"p2\">**</bpt>dllimport<ept id=\"p2\">**</ept> attribute.","pos":[1734,2058],"source":"In C++, you can initialize a globally declared or static local data pointer or with the address of a data object declared with the **dllimport** attribute, which generates an error in C. In addition, you can initialize a static local function pointer with the address of a function declared with the **dllimport** attribute."},{"content":"In C, such an assignment sets the pointer to the address of the DLL import thunk (a code stub that transfers control to the function) rather than the address of the function.","pos":[2059,2233]},{"content":"In C++, it sets the pointer to the address of the function.","pos":[2234,2293]},{"content":"For example:","pos":[2294,2306]},{"content":"However, because a program that includes the <ph id=\"ph1\">`dllexport`</ph> attribute in the declaration of an object must provide the definition for that object somewhere in the program, you can initialize a global or local static function pointer with the address of a <ph id=\"ph2\">`dllexport`</ph> function.","pos":[2871,3144],"source":"However, because a program that includes the `dllexport` attribute in the declaration of an object must provide the definition for that object somewhere in the program, you can initialize a global or local static function pointer with the address of a `dllexport` function."},{"content":"Similarly, you can initialize a global or local static data pointer with the address of a <ph id=\"ph1\">`dllexport`</ph> data object.","pos":[3145,3259],"source":" Similarly, you can initialize a global or local static data pointer with the address of a `dllexport` data object."},{"content":"For example, the following code does not generate errors in C or C++:","pos":[3260,3329]},{"pos":[3718,4032],"content":"Because of a change in behavior introduce in Visual C++ .NET to make the application of <ph id=\"ph1\">`dllexport`</ph> more consistent between regular classes and specializations of class templates, if you apply <ph id=\"ph2\">`dllexport`</ph> to a regular class that has a base class that is not marked as <ph id=\"ph3\">`dllexport`</ph>, the compiler will generate C4275.","source":"Because of a change in behavior introduce in Visual C++ .NET to make the application of `dllexport` more consistent between regular classes and specializations of class templates, if you apply `dllexport` to a regular class that has a base class that is not marked as `dllexport`, the compiler will generate C4275."},{"content":"The compiler generates the same warning if the base class is a specialization of a class template.","pos":[4043,4141]},{"content":"To work around this, mark the base-class with <ph id=\"ph1\">`dllexport`</ph>.","pos":[4142,4200],"source":" To work around this, mark the base-class with `dllexport`."},{"content":"The problem with a specialization of a class template is where to place the <bpt id=\"p1\">**</bpt>__declspec(dllexport)<ept id=\"p1\">**</ept>; you are not allowed to mark the class template.","pos":[4201,4351],"source":" The problem with a specialization of a class template is where to place the **__declspec(dllexport)**; you are not allowed to mark the class template."},{"content":"Instead, explicitly instantiate the class template and mark this explicit instantiation with <ph id=\"ph1\">`dllexport`</ph>.","pos":[4352,4457],"source":" Instead, explicitly instantiate the class template and mark this explicit instantiation with `dllexport`."},{"content":"For example:","pos":[4458,4470]},{"content":"This workaround fails if the template argument is the deriving class.","pos":[4622,4691]},{"content":"For example:","pos":[4692,4704]},{"content":"Because this is common pattern with templates, the compiler changed the semantics of <ph id=\"ph1\">`dllexport`</ph> when it is applied to a class that has one or more base-classes and when one or more of the base classes is a specialization of a class template.","pos":[4803,5045],"source":"Because this is common pattern with templates, the compiler changed the semantics of `dllexport` when it is applied to a class that has one or more base-classes and when one or more of the base classes is a specialization of a class template."},{"content":"In this case, the compiler implicitly applies <ph id=\"ph1\">`dllexport`</ph> to the specializations of class templates.","pos":[5046,5146],"source":" In this case, the compiler implicitly applies `dllexport` to the specializations of class templates."},{"content":"In Visual C++ .NET, a user can do the following and not get a warning:","pos":[5147,5217]},{"content":"END Microsoft Specific","pos":[5314,5336]},{"content":"See Also","pos":[5345,5353]},{"content":"dllexport, dllimport","pos":[5358,5378]}],"content":"---\ntitle: \"General Rules and Limitations | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nms.assetid: 6c48902d-4259-4761-95d4-e421d69aa050\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# General Rules and Limitations\n## Microsoft Specific  \n  \n-   If you declare a function or object without the **dllimport** or `dllexport` attribute, the function or object is not considered part of the DLL interface. Therefore, the definition of the function or object must be present in that module or in another module of the same program. To make the function or object part of the DLL interface, you must declare the definition of the function or object in the other module as `dllexport`. Otherwise, a linker error is generated.  \n  \n     If you declare a function or object with the `dllexport` attribute, its definition must appear in some module of the same program. Otherwise, a linker error is generated.  \n  \n-   If a single module in your program contains both **dllimport** and `dllexport` declarations for the same function or object, the `dllexport` attribute takes precedence over the **dllimport** attribute. However, a compiler warning is generated. For example:  \n  \n    ```  \n    __declspec( dllimport ) int i;  \n    __declspec( dllexport ) int i;   // Warning; inconsistent;  \n                                     // dllexport takes precedence.  \n    ```  \n  \n-   In C++, you can initialize a globally declared or static local data pointer or with the address of a data object declared with the **dllimport** attribute, which generates an error in C. In addition, you can initialize a static local function pointer with the address of a function declared with the **dllimport** attribute. In C, such an assignment sets the pointer to the address of the DLL import thunk (a code stub that transfers control to the function) rather than the address of the function. In C++, it sets the pointer to the address of the function. For example:  \n  \n    ```  \n    __declspec( dllimport ) void func1( void );  \n    __declspec( dllimport ) int i;  \n  \n    int *pi = &i;                             // Error in C  \n    static void ( *pf )( void ) = &func1;     // Address of thunk in C,  \n                                              // function in C++  \n  \n    void func2()  \n    {  \n       static int *pi = &i;                  // Error in C  \n       static void ( *pf )( void ) = &func1; // Address of thunk in C,  \n                                             // function in C++  \n    }  \n    ```  \n  \n     However, because a program that includes the `dllexport` attribute in the declaration of an object must provide the definition for that object somewhere in the program, you can initialize a global or local static function pointer with the address of a `dllexport` function. Similarly, you can initialize a global or local static data pointer with the address of a `dllexport` data object. For example, the following code does not generate errors in C or C++:  \n  \n    ```  \n    __declspec( dllexport ) void func1( void );  \n    __declspec( dllexport ) int i;  \n  \n    int *pi = &i;                              // Okay  \n    static void ( *pf )( void ) = &func1;      // Okay  \n  \n    void func2()  \n    {  \n        static int *pi = &i;                   // Okay  \n        static void ( *pf )( void ) = &func1;  // Okay  \n    }  \n    ```  \n  \n-   Because of a change in behavior introduce in Visual C++ .NET to make the application of `dllexport` more consistent between regular classes and specializations of class templates, if you apply `dllexport` to a regular class that has a base class that is not marked as `dllexport`, the compiler will generate C4275.  \n  \n     The compiler generates the same warning if the base class is a specialization of a class template. To work around this, mark the base-class with `dllexport`. The problem with a specialization of a class template is where to place the **__declspec(dllexport)**; you are not allowed to mark the class template. Instead, explicitly instantiate the class template and mark this explicit instantiation with `dllexport`. For example:  \n  \n    ```  \n    template class __declspec(dllexport) B<int>;  \n    class __declspec(dllexport) D : public B<int> {  \n    // ...  \n    ```  \n  \n     This workaround fails if the template argument is the deriving class. For example:  \n  \n    ```  \n    class __declspec(dllexport) D : public B<D> {  \n    // ...  \n    ```  \n  \n     Because this is common pattern with templates, the compiler changed the semantics of `dllexport` when it is applied to a class that has one or more base-classes and when one or more of the base classes is a specialization of a class template. In this case, the compiler implicitly applies `dllexport` to the specializations of class templates. In Visual C++ .NET, a user can do the following and not get a warning:  \n  \n    ```  \n    class __declspec(dllexport) D : public B<D> {  \n    // ...  \n    ```  \n  \n## END Microsoft Specific  \n  \n## See Also  \n [dllexport, dllimport](../cpp/dllexport-dllimport.md)"}