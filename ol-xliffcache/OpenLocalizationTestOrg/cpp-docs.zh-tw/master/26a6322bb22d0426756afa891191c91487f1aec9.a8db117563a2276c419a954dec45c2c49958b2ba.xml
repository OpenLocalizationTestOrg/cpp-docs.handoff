{"nodes":[{"pos":[12,54],"content":"Lambda Expressions in C++ | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Lambda Expressions in C++ | Microsoft Docs","pos":[0,42]}]},{"content":"Lambda Expressions in C++","pos":[693,718]},{"content":"In C++11, a lambda expression—often called a <bpt id=\"p1\">*</bpt>lambda<ept id=\"p1\">*</ept>—is a convenient way of defining an anonymous function object right at the location where it is invoked or passed as an argument to a function.","pos":[719,915],"source":"In C++11, a lambda expression—often called a *lambda*—is a convenient way of defining an anonymous function object right at the location where it is invoked or passed as an argument to a function."},{"content":"Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous methods.","pos":[916,1032]},{"content":"This article defines what lambdas are, compares them to other programming techniques, describes their advantages, and provides a basic example.","pos":[1033,1176]},{"content":"Parts of a Lambda Expression","pos":[1185,1213]},{"pos":[1217,1327],"content":"The ISO C++ Standard shows a simple lambda that is passed as the third argument to the <ph id=\"ph1\">`std::sort()`</ph> function:","source":"The ISO C++ Standard shows a simple lambda that is passed as the third argument to the `std::sort()` function:"},{"content":"This illustration shows the parts of a lambda:","pos":[1639,1685]},{"content":"Structural elements of a lambda expression","pos":[1694,1736]},{"pos":[1799,1881],"content":"<bpt id=\"p1\">*</bpt>capture clause<ept id=\"p1\">*</ept> (Also known as the <bpt id=\"p2\">*</bpt>lambda-introducer<ept id=\"p2\">*</ept> in the C++ specification.)","source":"*capture clause* (Also known as the *lambda-introducer* in the C++ specification.)"},{"content":"<bpt id=\"p1\">*</bpt>parameter list<ept id=\"p1\">*</ept> Optional.","pos":[1891,1917],"source":"*parameter list* Optional."},{"content":"(Also known as the <bpt id=\"p1\">*</bpt>lambda declarator<ept id=\"p1\">*</ept>)","pos":[1918,1957],"source":" (Also known as the *lambda declarator*)"},{"pos":[1967,2000],"content":"<bpt id=\"p1\">*</bpt>mutable specification<ept id=\"p1\">*</ept> Optional.","source":"*mutable specification* Optional."},{"pos":[2010,2045],"content":"<bpt id=\"p1\">*</bpt>exception-specification<ept id=\"p1\">*</ept> Optional.","source":"*exception-specification* Optional."},{"pos":[2055,2087],"content":"<bpt id=\"p1\">*</bpt>trailing-return-type<ept id=\"p1\">*</ept> Optional.","source":"*trailing-return-type* Optional."},{"pos":[2097,2111],"content":"<bpt id=\"p1\">*</bpt>lambda body<ept id=\"p1\">*</ept>)","source":"*lambda body*)"},{"content":"Capture Clause","pos":[2121,2135]},{"content":"A lambda can introduce new variables in its body (in <bpt id=\"p1\">**</bpt>C++14<ept id=\"p1\">**</ept>), and it can also access—or <bpt id=\"p2\">*</bpt>capture<ept id=\"p2\">*</ept>--variables from the surrounding scope.","pos":[2139,2278],"source":"A lambda can introduce new variables in its body (in **C++14**), and it can also access—or *capture*--variables from the surrounding scope."},{"content":"A lambda begins with the capture clause (<bpt id=\"p1\">*</bpt>lambda-introducer<ept id=\"p1\">*</ept> in the Standard syntax), which specifies which variables are captured, and whether the capture is by value or by reference.","pos":[2279,2463],"source":" A lambda begins with the capture clause (*lambda-introducer* in the Standard syntax), which specifies which variables are captured, and whether the capture is by value or by reference."},{"content":"Variables that have the ampersand (<ph id=\"ph1\">`&amp;`</ph>) prefix are accessed by reference and variables that do not have it are accessed by value.","pos":[2464,2593],"source":" Variables that have the ampersand (`&`) prefix are accessed by reference and variables that do not have it are accessed by value."},{"pos":[2600,2726],"content":"An empty capture clause, <ph id=\"ph1\">`[ ]`</ph>, indicates that the body of the lambda expression accesses no variables in the enclosing scope.","source":"An empty capture clause, `[ ]`, indicates that the body of the lambda expression accesses no variables in the enclosing scope."},{"content":"You can use the default capture mode (<ph id=\"ph1\">`capture-default`</ph> in the Standard syntax) to indicate how to capture any outside variables that are referenced in the lambda: [&amp;] means all variables that you refer to are captured by reference, and [=] means they are captured by value.","pos":[2733,3007],"source":"You can use the default capture mode (`capture-default` in the Standard syntax) to indicate how to capture any outside variables that are referenced in the lambda: [&] means all variables that you refer to are captured by reference, and [=] means they are captured by value."},{"content":"You can use a default capture mode, and then specify the opposite mode explicitly for specific variables.","pos":[3008,3113]},{"content":"For example, if a lambda body accesses the external variable <ph id=\"ph1\">`total`</ph> by reference and the external variable <ph id=\"ph2\">`factor`</ph> by value, then the following capture clauses are equivalent:","pos":[3114,3291],"source":" For example, if a lambda body accesses the external variable `total` by reference and the external variable `factor` by value, then the following capture clauses are equivalent:"},{"pos":[3413,3507],"content":"Only variables that are mentioned in the lambda are captured when a <ph id=\"ph1\">`capture-default`</ph> is used.","source":"Only variables that are mentioned in the lambda are captured when a `capture-default` is used."},{"content":"If a capture clause includes a <ph id=\"ph1\">`capture-default``&amp;`</ph>, then no <ph id=\"ph2\">`identifier`</ph> in a <ph id=\"ph3\">`capture`</ph> of that capture clause can have the form <ph id=\"ph4\">`&amp; identifier`</ph>.","pos":[3514,3659],"source":"If a capture clause includes a `capture-default``&`, then no `identifier` in a `capture` of that capture clause can have the form `& identifier`."},{"content":"Likewise, if the capture clause includes a <ph id=\"ph1\">`capture-default``=`</ph>, then no <ph id=\"ph2\">`capture`</ph> of that capture clause can have the form <ph id=\"ph3\">`= identifier`</ph>.","pos":[3660,3799],"source":" Likewise, if the capture clause includes a `capture-default``=`, then no `capture` of that capture clause can have the form `= identifier`."},{"content":"An identifier or <ph id=\"ph1\">`this`</ph> cannot appear more than once in a capture clause.","pos":[3800,3873],"source":" An identifier or `this` cannot appear more than once in a capture clause."},{"content":"The following code snippet illustrates some examples.","pos":[3874,3927]},{"pos":[4199,4344],"content":"A <ph id=\"ph1\">`capture`</ph> followed by an ellipsis is a pack expansion, as shown in this <bpt id=\"p1\">[</bpt>variadic template<ept id=\"p1\">](../cpp/ellipses-and-variadic-templates.md)</ept> example:","source":"A `capture` followed by an ellipsis is a pack expansion, as shown in this [variadic template](../cpp/ellipses-and-variadic-templates.md) example:"},{"content":"To use lambda expressions in the body of a class method, pass the <ph id=\"ph1\">`this`</ph> pointer to the capture clause to provide access to the methods and data members of the enclosing class.","pos":[4484,4660],"source":"To use lambda expressions in the body of a class method, pass the `this` pointer to the capture clause to provide access to the methods and data members of the enclosing class."},{"content":"For an example that shows how to use lambda expressions with class methods, see \"Example: Using a Lambda Expression in a Method\" in <bpt id=\"p1\">[</bpt>Examples of Lambda Expressions<ept id=\"p1\">](../cpp/examples-of-lambda-expressions.md)</ept>.","pos":[4661,4868],"source":" For an example that shows how to use lambda expressions with class methods, see \"Example: Using a Lambda Expression in a Method\" in [Examples of Lambda Expressions](../cpp/examples-of-lambda-expressions.md)."},{"content":"When you use the capture clause, we recommend that you keep these points in mind, particularly when you use lambdas with multithreading:","pos":[4875,5011]},{"content":"Reference captures can be used to modify variables outside, but value captures cannot.","pos":[5021,5107]},{"content":"(<ph id=\"ph1\">`mutable`</ph> allows copies to be modified, but not originals.)","pos":[5108,5168],"source":" (`mutable` allows copies to be modified, but not originals.)"},{"content":"Reference captures reflect updates to variables outside, but value captures do not.","pos":[5178,5261]},{"content":"Reference captures introduce a lifetime dependency, but value captures have no lifetime dependencies.","pos":[5271,5372]},{"content":"This is especially important when the lambda runs asynchronously.","pos":[5373,5438]},{"content":"If you capture a local by reference in an async lambda, that local will very possibly be gone by the time the lambda runs, resulting in an access violation at run time.","pos":[5439,5607]},{"content":"Generalized capture (C++ 14)","pos":[5616,5644]},{"content":"In C++14, you can introduce and initialize new variables in the capture clause, without the need to have those variables exist in the lambda function’s enclosing scope.","pos":[5653,5821]},{"content":"The initialization can be expressed as any arbitrary expression; the type of the new variable is deduced from the type produced by the expression.","pos":[5822,5968]},{"content":"One benefit of this feature is that in C++14 you can capture move-only variables (such as std::unique_ptr) from the surrounding scope and use them in a lambda.","pos":[5969,6128]},{"content":"Parameter List","pos":[6291,6305]},{"content":"In addition to capturing variables, a lambda can accept input parameters.","pos":[6309,6382]},{"content":"A parameter list (<bpt id=\"p1\">*</bpt>lambda declarator<ept id=\"p1\">*</ept> in the Standard syntax) is optional and in most aspects resembles the parameter list for a function.","pos":[6383,6521],"source":" A parameter list (*lambda declarator* in the Standard syntax) is optional and in most aspects resembles the parameter list for a function."},{"content":"In <bpt id=\"p1\">**</bpt>C++ 14<ept id=\"p1\">**</ept>, if the parameter type is generic, you can use the auto keyword as the type specifier.","pos":[6621,6721],"source":"In **C++ 14**, if the parameter type is generic, you can use the auto keyword as the type specifier."},{"content":"This tells the compiler to create the function call operator as a template.","pos":[6722,6797]},{"content":"Each instance of auto in a parameter list is equivalent to a distinct type parameter.","pos":[6798,6883]},{"content":"A lambda expression can take another lambda expression as its argument.","pos":[6983,7054]},{"content":"For more information, see \"Higher-Order Lambda Expressions\" in the topic <bpt id=\"p1\">[</bpt>Examples of Lambda Expressions<ept id=\"p1\">](../cpp/examples-of-lambda-expressions.md)</ept>.","pos":[7055,7203],"source":" For more information, see \"Higher-Order Lambda Expressions\" in the topic [Examples of Lambda Expressions](../cpp/examples-of-lambda-expressions.md)."},{"pos":[7210,7447],"content":"Because a parameter list is optional, you can omit the empty parentheses if you do not pass arguments to the lambda expression and its <ph id=\"ph1\">`lambda-declarator:`</ph> does not contain <bpt id=\"p1\">*</bpt>exception-specification<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>trailing-return-type<ept id=\"p2\">*</ept>, or <ph id=\"ph2\">`mutable`</ph>.","source":"Because a parameter list is optional, you can omit the empty parentheses if you do not pass arguments to the lambda expression and its `lambda-declarator:` does not contain *exception-specification*, *trailing-return-type*, or `mutable`."},{"content":"Mutable Specification","pos":[7457,7478]},{"content":"Typically, a lambda's function call operator is const-by-value, but use of the <ph id=\"ph1\">`mutable`</ph> keyword cancels this out.","pos":[7482,7596],"source":"Typically, a lambda's function call operator is const-by-value, but use of the `mutable` keyword cancels this out."},{"content":"It does not produce mutable data members.","pos":[7597,7638]},{"content":"The mutable specification enables the body of a lambda expression to modify variables that are captured by value.","pos":[7639,7752]},{"content":"Some of the examples later in this article show how to use <ph id=\"ph1\">`mutable`</ph>.","pos":[7753,7822],"source":" Some of the examples later in this article show how to use `mutable`."},{"content":"Exception Specification","pos":[7832,7855]},{"content":"You can use the <ph id=\"ph1\">`throw()`</ph> exception specification to indicate that the lambda expression does not throw any exceptions.","pos":[7859,7978],"source":"You can use the `throw()` exception specification to indicate that the lambda expression does not throw any exceptions."},{"content":"As with ordinary functions, the Visual C++ compiler generates warning <bpt id=\"p1\">[</bpt>C4297<ept id=\"p1\">](../error-messages/compiler-warnings/compiler-warning-level-1-c4297.md)</ept> if a lambda expression declares the <ph id=\"ph1\">`throw()`</ph> exception specification and the lambda body throws an exception, as shown here:","pos":[7979,8253],"source":" As with ordinary functions, the Visual C++ compiler generates warning [C4297](../error-messages/compiler-warnings/compiler-warning-level-1-c4297.md) if a lambda expression declares the `throw()` exception specification and the lambda body throws an exception, as shown here:"},{"pos":[8414,8521],"content":"For more information, see <bpt id=\"p1\">[</bpt>Exception Specifications (throw)<ept id=\"p1\">](../cpp/exception-specifications-throw-cpp.md)</ept>.","source":"For more information, see [Exception Specifications (throw)](../cpp/exception-specifications-throw-cpp.md)."},{"content":"Return Type","pos":[8531,8542]},{"content":"The return type of a lambda expression is automatically deduced.","pos":[8546,8610]},{"content":"You don't have to use the <bpt id=\"p1\">[</bpt>auto<ept id=\"p1\">](../cpp/auto-cpp.md)</ept> keyword unless you specify a <bpt id=\"p2\">*</bpt>trailing-return-type<ept id=\"p2\">*</ept>.","pos":[8611,8716],"source":" You don't have to use the [auto](../cpp/auto-cpp.md) keyword unless you specify a *trailing-return-type*."},{"content":"The <bpt id=\"p1\">*</bpt>trailing-return-type<ept id=\"p1\">*</ept> resembles the return-type part of an ordinary method or function.","pos":[8717,8809],"source":" The *trailing-return-type* resembles the return-type part of an ordinary method or function."},{"content":"However, the return type must follow the parameter list, and you must include the trailing-return-type keyword <ph id=\"ph1\">`-&gt;`</ph> before the return type.","pos":[8810,8949],"source":" However, the return type must follow the parameter list, and you must include the trailing-return-type keyword `->` before the return type."},{"content":"You can omit the return-type part of a lambda expression if the lambda body contains just one return statement or the expression does not return a value.","pos":[8956,9109]},{"content":"If the lambda body contains one return statement, the compiler deduces the return type from the type of the return expression.","pos":[9110,9236]},{"content":"Otherwise, the compiler deduces the return type to be <ph id=\"ph1\">`void`</ph>.","pos":[9237,9298],"source":" Otherwise, the compiler deduces the return type to be `void`."},{"content":"Consider the following example code snippets that illustrate this principle.","pos":[9299,9375]},{"content":"A lambda expression can produce another lambda expression as its return value.","pos":[9628,9706]},{"content":"For more information, see \"Higher-Order Lambda Expressions\" in <bpt id=\"p1\">[</bpt>Examples of Lambda Expressions<ept id=\"p1\">](../cpp/examples-of-lambda-expressions.md)</ept>.","pos":[9707,9845],"source":" For more information, see \"Higher-Order Lambda Expressions\" in [Examples of Lambda Expressions](../cpp/examples-of-lambda-expressions.md)."},{"content":"Lambda Body","pos":[9855,9866]},{"content":"The lambda body (<bpt id=\"p1\">*</bpt>compound-statement<ept id=\"p1\">*</ept> in the Standard syntax) of a lambda expression can contain anything that the body of an ordinary method or function can contain.","pos":[9870,10036],"source":"The lambda body (*compound-statement* in the Standard syntax) of a lambda expression can contain anything that the body of an ordinary method or function can contain."},{"content":"The body of both an ordinary function and a lambda expression can access these kinds of variables:","pos":[10037,10135]},{"content":"Captured variables from the enclosing scope, as described previously.","pos":[10145,10214]},{"content":"Parameters","pos":[10224,10234]},{"content":"Locally-declared variables","pos":[10244,10270]},{"pos":[10280,10351],"content":"Class data members, when declared inside a class and <ph id=\"ph1\">`this`</ph> is captured","source":"Class data members, when declared inside a class and `this` is captured"},{"content":"Any variable that has static storage duration—for example, global variables","pos":[10361,10436]},{"pos":[10443,10599],"content":"The following example contains a lambda expression that explicitly captures the variable <ph id=\"ph1\">`n`</ph> by value and implicitly captures the variable <ph id=\"ph2\">`m`</ph> by reference:","source":"The following example contains a lambda expression that explicitly captures the variable `n` by value and implicitly captures the variable `m` by reference:"},{"content":"Output:","pos":[10879,10886]},{"content":"Because the variable <ph id=\"ph1\">`n`</ph> is captured by value, its value remains <ph id=\"ph2\">`0`</ph> after the call to the lambda expression.","pos":[10927,11036],"source":"Because the variable `n` is captured by value, its value remains `0` after the call to the lambda expression."},{"content":"The <ph id=\"ph1\">`mutable`</ph> specification allows <ph id=\"ph2\">`n`</ph> to be modified within the lambda.","pos":[11037,11109],"source":" The `mutable` specification allows `n` to be modified within the lambda."},{"content":"Although a lambda expression can only capture variables that have automatic storage duration, you can use variables that have static storage duration in the body of a lambda expression.","pos":[11116,11301]},{"content":"The following example uses the <ph id=\"ph1\">`generate`</ph> function and a lambda expression to assign a value to each element in a <ph id=\"ph2\">`vector`</ph> object.","pos":[11302,11432],"source":" The following example uses the `generate` function and a lambda expression to assign a value to each element in a `vector` object."},{"content":"The lambda expression modifies the static variable to generate the value of the next element.","pos":[11433,11526]},{"pos":[11968,12077],"content":"For more information, see <bpt id=\"p1\">[</bpt>generate<ept id=\"p1\">](http://msdn.microsoft.com/Library/0353f358-9651-4e00-b0c9-5bca720539a3)</ept>.","source":"For more information, see [generate](http://msdn.microsoft.com/Library/0353f358-9651-4e00-b0c9-5bca720539a3)."},{"content":"The following code example uses the function from the previous example, and adds an example of a lambda expression that uses the STL algorithm <ph id=\"ph1\">`generate_n`</ph>.","pos":[12084,12240],"source":"The following code example uses the function from the previous example, and adds an example of a lambda expression that uses the STL algorithm `generate_n`."},{"content":"This lambda expression assigns an element of a <ph id=\"ph1\">`vector`</ph> object to the sum of the previous two elements.","pos":[12241,12344],"source":" This lambda expression assigns an element of a `vector` object to the sum of the previous two elements."},{"content":"The <ph id=\"ph1\">`mutable`</ph> keyword is used so that the body of the lambda expression can modify its copies of the external variables <ph id=\"ph2\">`x`</ph> and <ph id=\"ph3\">`y`</ph>, which the lambda expression captures by value.","pos":[12345,12524],"source":" The `mutable` keyword is used so that the body of the lambda expression can modify its copies of the external variables `x` and `y`, which the lambda expression captures by value."},{"content":"Because the lambda expression captures the original variables <ph id=\"ph1\">`x`</ph> and <ph id=\"ph2\">`y`</ph> by value, their values remain <ph id=\"ph3\">`1`</ph> after the lambda executes.","pos":[12525,12659],"source":" Because the lambda expression captures the original variables `x` and `y` by value, their values remain `1` after the lambda executes."},{"content":"Output:","pos":[14686,14693]},{"pos":[14941,15052],"content":"For more information, see <bpt id=\"p1\">[</bpt>generate_n<ept id=\"p1\">](http://msdn.microsoft.com/Library/377e5b0f-1bb8-4b77-9449-fbebf57f6e5e)</ept>.","source":"For more information, see [generate_n](http://msdn.microsoft.com/Library/377e5b0f-1bb8-4b77-9449-fbebf57f6e5e)."},{"content":"Microsoft-Specific","pos":[15061,15079]},{"pos":[15083,15234],"content":"Lambdas are not supported in the following common language runtime (CLR) managed entities: <ph id=\"ph1\">`ref class`</ph>, <ph id=\"ph2\">`ref struct`</ph>, <ph id=\"ph3\">`value class`</ph>, or <ph id=\"ph4\">`value struct`</ph>.","source":"Lambdas are not supported in the following common language runtime (CLR) managed entities: `ref class`, `ref struct`, `value class`, or `value struct`."},{"pos":[15241,15438],"content":"If you are using a Microsoft-specific modifier such as <bpt id=\"p1\">[</bpt>__declspec<ept id=\"p1\">](../cpp/declspec.md)</ept>, you can insert it into a lambda expression immediately after the <ph id=\"ph1\">`parameter-declaration-clause`</ph>—for example:","source":"If you are using a Microsoft-specific modifier such as [__declspec](../cpp/declspec.md), you can insert it into a lambda expression immediately after the `parameter-declaration-clause`—for example:"},{"pos":[15546,15735],"content":"To determine whether a modifier is supported by lambdas, see the article about it in the <bpt id=\"p1\">[</bpt>Microsoft-Specific Modifiers<ept id=\"p1\">](../cpp/microsoft-specific-modifiers.md)</ept> section of the documentation.","source":"To determine whether a modifier is supported by lambdas, see the article about it in the [Microsoft-Specific Modifiers](../cpp/microsoft-specific-modifiers.md) section of the documentation."},{"content":"Visual Studio supports C++11 Standard lambda expression syntax and functionality, with these exceptions:","pos":[15742,15846]},{"content":"Like all other classes, lambdas don't get automatically generated move constructors and move assignment operators.","pos":[15856,15970]},{"content":"For more information about support for rvalue reference behaviors, see the \"Rvalue References\" section in <bpt id=\"p1\">[</bpt>Support For C++11/14/17 Features (Modern C++)<ept id=\"p1\">](../cpp/support-for-cpp11-14-17-features-modern-cpp.md)</ept>.","pos":[15971,16180],"source":" For more information about support for rvalue reference behaviors, see the \"Rvalue References\" section in [Support For C++11/14/17 Features (Modern C++)](../cpp/support-for-cpp11-14-17-features-modern-cpp.md)."},{"pos":[16190,16262],"content":"The optional <bpt id=\"p1\">*</bpt>attribute-specifier-seq<ept id=\"p1\">*</ept> is not supported in this version.","source":"The optional *attribute-specifier-seq* is not supported in this version."},{"content":"Visual Studio includes these features in addition to C++11 Standard lambda functionality:","pos":[16269,16358]},{"content":"Stateless lambdas, which are omni-convertible to function pointers that use arbitrary calling conventions.","pos":[16368,16474]},{"content":"Automatically deduced return types for lambda bodies that are more complicated than <ph id=\"ph1\">`{ return expression; }`</ph>, as long as all return statements have the same type.","pos":[16484,16646],"source":"Automatically deduced return types for lambda bodies that are more complicated than `{ return expression; }`, as long as all return statements have the same type."},{"content":"(This functionality is part of the proposed C++14 Standard.)","pos":[16647,16707]},{"content":"See Also","pos":[16716,16724]},{"content":"C++ Language Reference","pos":[16729,16751]},{"content":"Function Objects in the STL","pos":[16792,16819]},{"content":"Function Call","pos":[16878,16891]},{"content":"for_each","pos":[16927,16935]}],"content":"---\ntitle: \"Lambda Expressions in C++ | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"lambda expressions [C++]\"\n  - \"lambda expressions [C++], overview\"\n  - \"lambda expressions [C++], vs. function objects\"\nms.assetid: 713c7638-92be-4ade-ab22-fa33417073bf\ncaps.latest.revision: 36\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Lambda Expressions in C++\nIn C++11, a lambda expression—often called a *lambda*—is a convenient way of defining an anonymous function object right at the location where it is invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous methods. This article defines what lambdas are, compares them to other programming techniques, describes their advantages, and provides a basic example.  \n  \n## Parts of a Lambda Expression  \n The ISO C++ Standard shows a simple lambda that is passed as the third argument to the `std::sort()` function:  \n  \n```cpp  \n#include <algorithm>  \n#include <cmath>  \n  \nvoid abssort(float* x, unsigned n) {  \n    std::sort(x, x + n,  \n        // Lambda expression begins  \n        [](float a, float b) {  \n            return (std::abs(a) < std::abs(b));  \n        } // end of lambda expression  \n    );  \n}  \n  \n```  \n  \n This illustration shows the parts of a lambda:  \n  \n ![Structural elements of a lambda expression](../cpp/media/lambdaexpsyntax.png \"LambdaExpSyntax\")  \n  \n1.  *capture clause* (Also known as the *lambda-introducer* in the C++ specification.)  \n  \n2.  *parameter list* Optional. (Also known as the *lambda declarator*)  \n  \n3.  *mutable specification* Optional.  \n  \n4.  *exception-specification* Optional.  \n  \n5.  *trailing-return-type* Optional.  \n  \n6.  *lambda body*)  \n  \n### Capture Clause  \n A lambda can introduce new variables in its body (in **C++14**), and it can also access—or *capture*--variables from the surrounding scope. A lambda begins with the capture clause (*lambda-introducer* in the Standard syntax), which specifies which variables are captured, and whether the capture is by value or by reference. Variables that have the ampersand (`&`) prefix are accessed by reference and variables that do not have it are accessed by value.  \n  \n An empty capture clause, `[ ]`, indicates that the body of the lambda expression accesses no variables in the enclosing scope.  \n  \n You can use the default capture mode (`capture-default` in the Standard syntax) to indicate how to capture any outside variables that are referenced in the lambda: [&] means all variables that you refer to are captured by reference, and [=] means they are captured by value. You can use a default capture mode, and then specify the opposite mode explicitly for specific variables. For example, if a lambda body accesses the external variable `total` by reference and the external variable `factor` by value, then the following capture clauses are equivalent:  \n  \n```cpp  \n  \n[&total, factor]  \n[factor, &total]  \n[&, factor]  \n[factor, &]  \n[=, &total]  \n[&total, =]  \n```  \n  \n Only variables that are mentioned in the lambda are captured when a `capture-default` is used.  \n  \n If a capture clause includes a `capture-default``&`, then no `identifier` in a `capture` of that capture clause can have the form `& identifier`. Likewise, if the capture clause includes a `capture-default``=`, then no `capture` of that capture clause can have the form `= identifier`. An identifier or `this` cannot appear more than once in a capture clause. The following code snippet illustrates some examples.  \n  \n```cpp  \nstruct S { void f(int i); };  \n  \nvoid S::f(int i) {  \n    [&, i]{};    // OK  \n    [&, &i]{};   // ERROR: i preceded by & when & is the default  \n    [=, this]{}; // ERROR: this when = is the default  \n    [i, i]{};    // ERROR: i repeated  \n}  \n```  \n  \n A `capture` followed by an ellipsis is a pack expansion, as shown in this [variadic template](../cpp/ellipses-and-variadic-templates.md) example:  \n  \n```cpp  \ntemplate<class... Args>  \nvoid f(Args... args) {  \n    auto x = [args...] { return g(args...); };  \n    x();  \n}  \n```  \n  \n To use lambda expressions in the body of a class method, pass the `this` pointer to the capture clause to provide access to the methods and data members of the enclosing class. For an example that shows how to use lambda expressions with class methods, see \"Example: Using a Lambda Expression in a Method\" in [Examples of Lambda Expressions](../cpp/examples-of-lambda-expressions.md).  \n  \n When you use the capture clause, we recommend that you keep these points in mind, particularly when you use lambdas with multithreading:  \n  \n-   Reference captures can be used to modify variables outside, but value captures cannot. (`mutable` allows copies to be modified, but not originals.)  \n  \n-   Reference captures reflect updates to variables outside, but value captures do not.  \n  \n-   Reference captures introduce a lifetime dependency, but value captures have no lifetime dependencies. This is especially important when the lambda runs asynchronously. If you capture a local by reference in an async lambda, that local will very possibly be gone by the time the lambda runs, resulting in an access violation at run time.  \n  \n **Generalized capture (C++ 14)**  \n  \n In C++14, you can introduce and initialize new variables in the capture clause, without the need to have those variables exist in the lambda function’s enclosing scope. The initialization can be expressed as any arbitrary expression; the type of the new variable is deduced from the type produced by the expression. One benefit of this feature is that in C++14 you can capture move-only variables (such as std::unique_ptr) from the surrounding scope and use them in a lambda.  \n  \n```  \npNums = make_unique<vector<int>>(nums);  \n//...  \n      auto a = [ptr = move(pNums)]()  \n        {  \n           // use ptr  \n        };  \n```  \n  \n### Parameter List  \n In addition to capturing variables, a lambda can accept input parameters. A parameter list (*lambda declarator* in the Standard syntax) is optional and in most aspects resembles the parameter list for a function.  \n  \n```  \nint y = [] (int first, int second)  \n{  \n    return first + second;  \n};  \n  \n```  \n  \n In **C++ 14**, if the parameter type is generic, you can use the auto keyword as the type specifier. This tells the compiler to create the function call operator as a template. Each instance of auto in a parameter list is equivalent to a distinct type parameter.  \n  \n```  \nauto y = [] (auto first, auto second)  \n{  \n    return first + second;  \n};  \n```  \n  \n A lambda expression can take another lambda expression as its argument. For more information, see \"Higher-Order Lambda Expressions\" in the topic [Examples of Lambda Expressions](../cpp/examples-of-lambda-expressions.md).  \n  \n Because a parameter list is optional, you can omit the empty parentheses if you do not pass arguments to the lambda expression and its `lambda-declarator:` does not contain *exception-specification*, *trailing-return-type*, or `mutable`.  \n  \n### Mutable Specification  \n Typically, a lambda's function call operator is const-by-value, but use of the `mutable` keyword cancels this out. It does not produce mutable data members. The mutable specification enables the body of a lambda expression to modify variables that are captured by value. Some of the examples later in this article show how to use `mutable`.  \n  \n### Exception Specification  \n You can use the `throw()` exception specification to indicate that the lambda expression does not throw any exceptions. As with ordinary functions, the Visual C++ compiler generates warning [C4297](../error-messages/compiler-warnings/compiler-warning-level-1-c4297.md) if a lambda expression declares the `throw()` exception specification and the lambda body throws an exception, as shown here:  \n  \n```cpp  \n// throw_lambda_expression.cpp  \n// compile with: /W4 /EHsc   \nint main() // C4297 expected  \n{  \n   []() throw() { throw 5; }();  \n}  \n```  \n  \n For more information, see [Exception Specifications (throw)](../cpp/exception-specifications-throw-cpp.md).  \n  \n### Return Type  \n The return type of a lambda expression is automatically deduced. You don't have to use the [auto](../cpp/auto-cpp.md) keyword unless you specify a *trailing-return-type*. The *trailing-return-type* resembles the return-type part of an ordinary method or function. However, the return type must follow the parameter list, and you must include the trailing-return-type keyword `->` before the return type.  \n  \n You can omit the return-type part of a lambda expression if the lambda body contains just one return statement or the expression does not return a value. If the lambda body contains one return statement, the compiler deduces the return type from the type of the return expression. Otherwise, the compiler deduces the return type to be `void`. Consider the following example code snippets that illustrate this principle.  \n  \n```cpp  \nauto x1 = [](int i){ return i; }; // OK: return type is int  \nauto x2 = []{ return{ 1, 2 }; };  // ERROR: return type is void, deducing   \n                                  // return type from braced-init-list is not valid  \n  \n```  \n  \n A lambda expression can produce another lambda expression as its return value. For more information, see \"Higher-Order Lambda Expressions\" in [Examples of Lambda Expressions](../cpp/examples-of-lambda-expressions.md).  \n  \n### Lambda Body  \n The lambda body (*compound-statement* in the Standard syntax) of a lambda expression can contain anything that the body of an ordinary method or function can contain. The body of both an ordinary function and a lambda expression can access these kinds of variables:  \n  \n-   Captured variables from the enclosing scope, as described previously.  \n  \n-   Parameters  \n  \n-   Locally-declared variables  \n  \n-   Class data members, when declared inside a class and `this` is captured  \n  \n-   Any variable that has static storage duration—for example, global variables  \n  \n The following example contains a lambda expression that explicitly captures the variable `n` by value and implicitly captures the variable `m` by reference:  \n  \n```cpp  \n// captures_lambda_expression.cpp  \n// compile with: /W4 /EHsc   \n#include <iostream>  \nusing namespace std;  \n  \nint main()  \n{  \n   int m = 0;  \n   int n = 0;  \n   [&, n] (int a) mutable { m = ++n + a; }(4);  \n   cout << m << endl << n << endl;  \n}  \n```  \n  \n **Output:**  \n  \n```Output  \n5  \n0  \n  \n```  \n  \n Because the variable `n` is captured by value, its value remains `0` after the call to the lambda expression. The `mutable` specification allows `n` to be modified within the lambda.  \n  \n Although a lambda expression can only capture variables that have automatic storage duration, you can use variables that have static storage duration in the body of a lambda expression. The following example uses the `generate` function and a lambda expression to assign a value to each element in a `vector` object. The lambda expression modifies the static variable to generate the value of the next element.  \n  \n```cpp  \nvoid fillVector(vector<int>& v)  \n{  \n    // A local static variable.  \n    static int nextValue = 1;  \n  \n    // The lambda expression that appears in the following call to  \n    // the generate function modifies and uses the local static   \n    // variable nextValue.  \n    generate(v.begin(), v.end(), [] { return nextValue++; });   \n    //WARNING: this is not thread-safe and is shown for illustration only  \n}  \n```  \n  \n For more information, see [generate](http://msdn.microsoft.com/Library/0353f358-9651-4e00-b0c9-5bca720539a3).  \n  \n The following code example uses the function from the previous example, and adds an example of a lambda expression that uses the STL algorithm `generate_n`. This lambda expression assigns an element of a `vector` object to the sum of the previous two elements. The `mutable` keyword is used so that the body of the lambda expression can modify its copies of the external variables `x` and `y`, which the lambda expression captures by value. Because the lambda expression captures the original variables `x` and `y` by value, their values remain `1` after the lambda executes.  \n  \n```cpp  \n// compile with: /W4 /EHsc  \n#include <algorithm>  \n#include <iostream>  \n#include <vector>  \n#include <string>  \n  \nusing namespace std;  \n  \ntemplate <typename C> void print(const string& s, const C& c) {  \n    cout << s;  \n  \n    for (const auto& e : c) {  \n        cout << e << \" \";  \n    }  \n  \n    cout << endl;  \n}  \n  \nvoid fillVector(vector<int>& v)  \n{  \n    // A local static variable.  \n    static int nextValue = 1;  \n  \n    // The lambda expression that appears in the following call to  \n    // the generate function modifies and uses the local static   \n    // variable nextValue.  \n    generate(v.begin(), v.end(), [] { return nextValue++; });  \n    //WARNING: this is not thread-safe and is shown for illustration only  \n}  \n  \nint main()  \n{  \n    // The number of elements in the vector.  \n    const int elementCount = 9;  \n  \n    // Create a vector object with each element set to 1.  \n    vector<int> v(elementCount, 1);  \n  \n    // These variables hold the previous two elements of the vector.  \n    int x = 1;  \n    int y = 1;  \n  \n    // Sets each element in the vector to the sum of the   \n    // previous two elements.  \n    generate_n(v.begin() + 2,  \n        elementCount - 2,  \n        [=]() mutable throw() -> int { // lambda is the 3rd parameter  \n        // Generate current value.  \n        int n = x + y;  \n        // Update previous two values.  \n        x = y;  \n        y = n;  \n        return n;  \n    });  \n    print(\"vector v after call to generate_n() with lambda: \", v);  \n  \n    // Print the local variables x and y.  \n    // The values of x and y hold their initial values because   \n    // they are captured by value.  \n    cout << \"x: \" << x << \" y: \" << y << endl;  \n  \n    // Fill the vector with a sequence of numbers  \n    fillVector(v);  \n    print(\"vector v after 1st call to fillVector(): \", v);  \n    // Fill the vector with the next sequence of numbers  \n    fillVector(v);  \n    print(\"vector v after 2nd call to fillVector(): \", v);  \n}  \n  \n```  \n  \n **Output:**  \n  \n```Output  \nvector v after call to generate_n() with lambda: 1 1 2 3 5 8 13 21 34  \nx: 1 y: 1  \nvector v after 1st call to fillVector(): 1 2 3 4 5 6 7 8 9  \nvector v after 2nd call to fillVector(): 10 11 12 13 14 15 16 17 18  \n  \n```  \n  \n For more information, see [generate_n](http://msdn.microsoft.com/Library/377e5b0f-1bb8-4b77-9449-fbebf57f6e5e).  \n  \n## Microsoft-Specific  \n Lambdas are not supported in the following common language runtime (CLR) managed entities: `ref class`, `ref struct`, `value class`, or `value struct`.  \n  \n If you are using a Microsoft-specific modifier such as [__declspec](../cpp/declspec.md), you can insert it into a lambda expression immediately after the `parameter-declaration-clause`—for example:  \n  \n```cpp  \nauto Sqr = [](int t) __declspec(code_seg(\"PagedMem\")) -> int { return t*t; };  \n  \n```  \n  \n To determine whether a modifier is supported by lambdas, see the article about it in the [Microsoft-Specific Modifiers](../cpp/microsoft-specific-modifiers.md) section of the documentation.  \n  \n Visual Studio supports C++11 Standard lambda expression syntax and functionality, with these exceptions:  \n  \n-   Like all other classes, lambdas don't get automatically generated move constructors and move assignment operators. For more information about support for rvalue reference behaviors, see the \"Rvalue References\" section in [Support For C++11/14/17 Features (Modern C++)](../cpp/support-for-cpp11-14-17-features-modern-cpp.md).  \n  \n-   The optional *attribute-specifier-seq* is not supported in this version.  \n  \n Visual Studio includes these features in addition to C++11 Standard lambda functionality:  \n  \n-   Stateless lambdas, which are omni-convertible to function pointers that use arbitrary calling conventions.  \n  \n-   Automatically deduced return types for lambda bodies that are more complicated than `{ return expression; }`, as long as all return statements have the same type. (This functionality is part of the proposed C++14 Standard.)  \n  \n## See Also  \n [C++ Language Reference](../cpp/cpp-language-reference.md)   \n [Function Objects in the STL](../standard-library/function-objects-in-the-stl.md)   \n [Function Call](../cpp/function-call-cpp.md)   \n [for_each](http://msdn.microsoft.com/Library/8cb2ae72-bef6-488b-b011-0475c0787e33)"}