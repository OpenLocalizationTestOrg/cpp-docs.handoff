{"nodes":[{"pos":[12,52],"content":"&lt;regex&gt; operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"regex<ph id=\"ph1\">&amp;gt;</ph> operators | Microsoft Docs","pos":[4,40],"source":"regex&gt; operators | Microsoft Docs"}]},{"content":"regex<ph id=\"ph1\">&amp;gt;</ph> operators","pos":[259,278],"source":"regex&gt; operators"},{"content":"operator!=","pos":[298,308]},{"content":"operator","pos":[326,334]},{"content":"operator","pos":[356,364]},{"content":"operator","pos":[394,402]},{"content":"operator","pos":[424,432]},{"content":"operator","pos":[462,470]},{"content":"operator==","pos":[500,510]},{"pos":[568,578],"content":"operator!="},{"content":"Not equal comparison for various objects.","pos":[582,623]},{"content":"Parameters","pos":[1849,1859]},{"content":"The iterator type.","pos":[1874,1892]},{"content":"The string traits class.","pos":[1913,1937]},{"content":"The allocator class.","pos":[1955,1975]},{"content":"The left object to compare.","pos":[1992,2019]},{"content":"The right object to compare.","pos":[2037,2065]},{"content":"Remarks","pos":[2075,2082]},{"pos":[2086,2136],"content":"Each template operator returns <ph id=\"ph1\">`!(left == right)`</ph>.","source":"Each template operator returns `!(left == right)`."},{"content":"Example","pos":[2146,2153]},{"pos":[3790,3798],"content":"operator"},{"content":"Less than comparison for various objects.","pos":[3806,3847]},{"content":"Parameters","pos":[4921,4931]},{"content":"The iterator type.","pos":[4946,4964]},{"content":"The string traits class.","pos":[4985,5009]},{"content":"The allocator class.","pos":[5027,5047]},{"content":"The left object to compare.","pos":[5064,5091]},{"content":"The right object to compare.","pos":[5109,5137]},{"content":"Remarks","pos":[5147,5154]},{"pos":[5158,5326],"content":"Each template operator converts its arguments to a string type and returns true only if the converted value of <ph id=\"ph1\">`left`</ph> compares less than the converted value of <ph id=\"ph2\">`right`</ph>.","source":"Each template operator converts its arguments to a string type and returns true only if the converted value of `left` compares less than the converted value of `right`."},{"content":"Example","pos":[5336,5343]},{"pos":[6768,6776],"content":"operator"},{"content":"Inserts a sub_match in a stream.","pos":[6788,6820]},{"content":"Parameters","pos":[7026,7036]},{"content":"The element type.","pos":[7050,7067]},{"content":"The string traits class.","pos":[7088,7112]},{"content":"The allocator class.","pos":[7130,7150]},{"content":"The iterator type.","pos":[7168,7186]},{"content":"The output stream.","pos":[7201,7219]},{"content":"The object to insert.","pos":[7237,7258]},{"content":"Remarks","pos":[7268,7275]},{"pos":[7279,7329],"content":"The template operator returns <ph id=\"ph1\">`os &lt;&lt; right.str()`</ph>.","source":"The template operator returns `os << right.str()`."},{"content":"Example","pos":[7339,7346]},{"pos":[7815,7823],"content":"operator"},{"content":"Less than or equal comparison for various objects.","pos":[7832,7882]},{"content":"Parameters","pos":[8963,8973]},{"content":"The iterator type.","pos":[8988,9006]},{"content":"The string traits class.","pos":[9027,9051]},{"content":"The allocator class.","pos":[9069,9089]},{"content":"The left object to compare.","pos":[9106,9133]},{"content":"The right object to compare.","pos":[9151,9179]},{"content":"Remarks","pos":[9189,9196]},{"pos":[9200,9249],"content":"Each template operator returns <ph id=\"ph1\">`!(right &lt; left)`</ph>.","source":"Each template operator returns `!(right < left)`."},{"content":"Example","pos":[9259,9266]},{"pos":[10709,10719],"content":"operator=="},{"content":"Equal comparison for various objects.","pos":[10723,10760]},{"content":"Parameters","pos":[11986,11996]},{"content":"The iterator type.","pos":[12011,12029]},{"content":"The string traits class.","pos":[12050,12074]},{"content":"The allocator class.","pos":[12092,12112]},{"content":"The left object to compare.","pos":[12129,12156]},{"content":"The right object to compare.","pos":[12174,12202]},{"content":"Remarks","pos":[12212,12219]},{"content":"Each template operator converts each of its arguments to a string type and returns the result of comparing the converted objects for equality.","pos":[12223,12365]},{"content":"When a template operator converts its arguments to a string type it uses the first of the following transformations that applies:","pos":[12372,12501]},{"pos":[12508,12651],"content":"arguments whose types are a specialization of template class <ph id=\"ph1\">`match_results`</ph> or <ph id=\"ph2\">`sub_match`</ph> are converted by calling the <ph id=\"ph3\">`str`</ph> member function;","source":"arguments whose types are a specialization of template class `match_results` or `sub_match` are converted by calling the `str` member function;"},{"pos":[12658,12752],"content":"arguments whose types are a specialization of the template class <ph id=\"ph1\">`basic_string`</ph> are unchanged;","source":"arguments whose types are a specialization of the template class `basic_string` are unchanged;"},{"pos":[12759,12918],"content":"all other argument types are converted by passing the argument value to the constructor for an appropriate specialization of the template class <ph id=\"ph1\">`basic_string`</ph>.","source":"all other argument types are converted by passing the argument value to the constructor for an appropriate specialization of the template class `basic_string`."},{"content":"Example","pos":[12928,12935]},{"pos":[14576,14584],"content":"operator"},{"content":"Greater than comparison for various objects.","pos":[14592,14636]},{"content":"Parameters","pos":[15710,15720]},{"content":"The iterator type.","pos":[15735,15753]},{"content":"The string traits class.","pos":[15774,15798]},{"content":"The allocator class.","pos":[15816,15836]},{"content":"The left object to compare.","pos":[15853,15880]},{"content":"The right object to compare.","pos":[15898,15926]},{"content":"Remarks","pos":[15936,15943]},{"pos":[15947,15993],"content":"Each template operator returns <ph id=\"ph1\">`right &lt; left`</ph>.","source":"Each template operator returns `right < left`."},{"content":"Example","pos":[16003,16010]},{"pos":[17434,17442],"content":"operator"},{"content":"Greater than or equal comparison for various objects.","pos":[17451,17504]},{"content":"Parameters","pos":[18585,18595]},{"content":"The iterator type.","pos":[18610,18628]},{"content":"The string traits class.","pos":[18649,18673]},{"content":"The allocator class.","pos":[18691,18711]},{"content":"The left object to compare.","pos":[18728,18755]},{"content":"The right object to compare.","pos":[18773,18801]},{"content":"Remarks","pos":[18811,18818]},{"pos":[18822,18871],"content":"Each template operator returns <ph id=\"ph1\">`!(left &lt; right)`</ph>.","source":"Each template operator returns `!(left < right)`."},{"content":"Example","pos":[18881,18888]},{"content":"See Also","pos":[20307,20315]},{"content":"regex&gt;","pos":[20322,20328],"source":"regex>"}],"content":"---\ntitle: \"&lt;regex&gt; operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: ec623e65-c186-491f-aa18-6b12b47e1127\ncaps.latest.revision: 12\nmanager: \"ghogen\"\n---\n# &lt;regex&gt; operators\n||||  \n|-|-|-|  \n|[operator!=](#operator_neq)|[operator&gt;](#operator_gt_)|[operator&gt;=](#operator_gt__eq)|  \n|[operator&lt;](#operator_lt_)|[operator&lt;&lt;](#operator_lt__lt_)|[operator&lt;=](#operator_lt__eq)|  \n|[operator==](#operator_eq_eq)|  \n  \n##  <a name=\"operator_neq\"></a>  operator!=  \n Not equal comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator!=(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator!=(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator!=(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator!=(const typename iterator_traits<BidIt>::value_type *left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator!=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type *right);\n\ntemplate <class BidIt>  \nbool operator!=(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator!=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n\ntemplate <class BidIt, class Alloc>  \nbool operator!=(const match_results<BidIt, Alloc>& left,  \n    const match_results<BidIt, Alloc>& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator returns `!(left == right)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_ne.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"match == \" << mr.str() << std::endl;   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"match != match == \" << std::boolalpha   \n        << (mr != mr) << std::endl;   \n    std::cout << \"sub != sub == \" << std::boolalpha   \n        << (sub != sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") != sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") != sub) << std::endl;   \n    std::cout << \"sub != string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub != Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" != sub == \" << std::boolalpha   \n        << (\"aab\" != sub) << std::endl;   \n    std::cout << \"sub != \\\"aab\\\" == \" << std::boolalpha   \n        << (sub != \"aab\") << std::endl;   \n  \n    std::cout << \"'a' != sub == \" << std::boolalpha   \n        << ('a' != sub) << std::endl;   \n    std::cout << \"sub != 'a' == \" << std::boolalpha   \n        << (sub != 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == caaa  \nsub == aaa  \n  \nmatch != match == false  \nsub != sub == false  \nstring(\"aab\") != sub == true  \nsub != string(\"aab\") == true  \n\"aab\" != sub == true  \nsub != \"aab\" == true  \n'a' != sub == true  \nsub != 'a' == true  \n```  \n  \n##  <a name=\"operator_lt_\"></a>  operator&lt;  \n Less than comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator<(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator<(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator<(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator<(const typename iterator_traits<BidIt>::value_type *left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator<(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type *right);\n\ntemplate <class BidIt>  \nbool operator<(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator<(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator converts its arguments to a string type and returns true only if the converted value of `left` compares less than the converted value of `right`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_lt.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"sub < sub == \" << std::boolalpha   \n        << (sub < sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") < sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") < sub) << std::endl;   \n    std::cout << \"sub < string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub < Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" < sub == \" << std::boolalpha   \n        << (\"aab\" < sub) << std::endl;   \n    std::cout << \"sub < \\\"aab\\\" == \" << std::boolalpha   \n        << (sub < \"aab\") << std::endl;   \n  \n    std::cout << \"'a' < sub == \" << std::boolalpha   \n        << ('a' < sub) << std::endl;   \n    std::cout << \"sub < 'a' == \" << std::boolalpha   \n        << (sub < 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsub == aaa  \n  \nsub < sub == false  \nstring(\"aab\") < sub == false  \nsub < string(\"aab\") == true  \n\"aab\" < sub == false  \nsub < \"aab\" == true  \n'a' < sub == true  \nsub < 'a' == false  \n```  \n  \n##  <a name=\"operator_lt__lt_\"></a>  operator&lt;&lt;  \n Inserts a sub_match in a stream.  \n  \n```  \ntemplate <class Elem, class IOtraits, class Alloc, class BidIt>  \nbasic_ostream<Elem, IOtraits>& operator<<(basic_ostream<Elem, IOtraits>& os,  \n    const sub_match<BidIt>& right);\n```  \n  \n### Parameters  \n `Elem`  \n The element type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `BidIt`  \n The iterator type.  \n  \n `os`  \n The output stream.  \n  \n `right`  \n The object to insert.  \n  \n### Remarks  \n The template operator returns `os << right.str()`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_ins.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[0];   \n    std::cout << \"whole match: \" << sub << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nwhole match: caaa  \n```  \n  \n##  <a name=\"operator_lt__eq\"></a>  operator&lt;=  \n Less than or equal comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator<=(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator<=(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator<=(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator<=(const typename iterator_traits<BidIt>::value_type *left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator<=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type *right);\n\ntemplate <class BidIt>  \nbool operator<=(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator<=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator returns `!(right < left)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_le.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"sub <= sub == \" << std::boolalpha   \n        << (sub <= sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") <= sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") <= sub) << std::endl;   \n    std::cout << \"sub <= string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub <= Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" <= sub == \" << std::boolalpha   \n        << (\"aab\" <= sub) << std::endl;   \n    std::cout << \"sub <= \\\"aab\\\" == \" << std::boolalpha   \n        << (sub <= \"aab\") << std::endl;   \n  \n    std::cout << \"'a' <= sub == \" << std::boolalpha   \n        << ('a' <= sub) << std::endl;   \n    std::cout << \"sub <= 'a' == \" << std::boolalpha   \n        << (sub <= 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsub == aaa  \n  \nsub <= sub == true  \nstring(\"aab\") <= sub == false  \nsub <= string(\"aab\") == true  \n\"aab\" <= sub == false  \nsub <= \"aab\" == true  \n'a' <= sub == true  \nsub <= 'a' == false  \n```  \n  \n##  <a name=\"operator_eq_eq\"></a>  operator==  \n Equal comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator==(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator==(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator==(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator==(const typename iterator_traits<BidIt>::value_type* left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator==(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type* right);\n\ntemplate <class BidIt>  \nbool operator==(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator==(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n\ntemplate <class BidIt, class Alloc>  \nbool operator==(const match_results<BidIt, Alloc>& left,  \n    const match_results<BidIt, Alloc>& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator converts each of its arguments to a string type and returns the result of comparing the converted objects for equality.  \n  \n When a template operator converts its arguments to a string type it uses the first of the following transformations that applies:  \n  \n arguments whose types are a specialization of template class `match_results` or `sub_match` are converted by calling the `str` member function;  \n  \n arguments whose types are a specialization of the template class `basic_string` are unchanged;  \n  \n all other argument types are converted by passing the argument value to the constructor for an appropriate specialization of the template class `basic_string`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_eq.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"match == \" << mr.str() << std::endl;   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"match == match == \" << std::boolalpha   \n        << (mr == mr) << std::endl;   \n    std::cout << \"sub == sub == \" << std::boolalpha   \n        << (sub == sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") == sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") == sub) << std::endl;   \n    std::cout << \"sub == string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub == Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" == sub == \" << std::boolalpha   \n        << (\"aab\" == sub) << std::endl;   \n    std::cout << \"sub == \\\"aab\\\" == \" << std::boolalpha   \n        << (sub == \"aab\") << std::endl;   \n  \n    std::cout << \"'a' == sub == \" << std::boolalpha   \n        << ('a' == sub) << std::endl;   \n    std::cout << \"sub == 'a' == \" << std::boolalpha   \n        << (sub == 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == caaa  \nsub == aaa  \n  \nmatch == match == true  \nsub == sub == true  \nstring(\"aab\") == sub == false  \nsub == string(\"aab\") == false  \n\"aab\" == sub == false  \nsub == \"aab\" == false  \n'a' == sub == false  \nsub == 'a' == false  \n```  \n  \n##  <a name=\"operator_gt_\"></a>  operator&gt;  \n Greater than comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator>(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator>(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator>(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator>(const typename iterator_traits<BidIt>::value_type *left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator>(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type *right);\n\ntemplate <class BidIt>  \nbool operator>(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator>(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator returns `right < left`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_gt.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"sub > sub == \" << std::boolalpha   \n        << (sub > sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") > sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") > sub) << std::endl;   \n    std::cout << \"sub > string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub > Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" > sub == \" << std::boolalpha   \n        << (\"aab\" > sub) << std::endl;   \n    std::cout << \"sub > \\\"aab\\\" == \" << std::boolalpha   \n        << (sub > \"aab\") << std::endl;   \n  \n    std::cout << \"'a' > sub == \" << std::boolalpha   \n        << ('a' > sub) << std::endl;   \n    std::cout << \"sub > 'a' == \" << std::boolalpha   \n        << (sub > 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsub == aaa  \n  \nsub > sub == false  \nstring(\"aab\") > sub == true  \nsub > string(\"aab\") == false  \n\"aab\" > sub == true  \nsub > \"aab\" == false  \n'a' > sub == false  \nsub > 'a' == true  \n```  \n  \n##  <a name=\"operator_gt__eq\"></a>  operator&gt;=  \n Greater than or equal comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator>=(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator>=(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator>=(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator>=(const typename iterator_traits<BidIt>::value_type *left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator>=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type *right);\n\ntemplate <class BidIt>  \nbool operator>=(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator>=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator returns `!(left < right)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_ge.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::tr1std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"sub >= sub == \" << std::boolalpha   \n        << (sub >= sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") >= sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") >= sub) << std::endl;   \n    std::cout << \"sub >= string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub >= Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" >= sub == \" << std::boolalpha   \n        << (\"aab\" >= sub) << std::endl;   \n    std::cout << \"sub >= \\\"aab\\\" == \" << std::boolalpha   \n        << (sub >= \"aab\") << std::endl;   \n  \n    std::cout << \"'a' >= sub == \" << std::boolalpha   \n        << ('a' >= sub) << std::endl;   \n    std::cout << \"sub >= 'a' == \" << std::boolalpha   \n        << (sub >= 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsub == aaa  \n  \nsub >= sub == true  \nstring(\"aab\") >= sub == true  \nsub >= string(\"aab\") == false  \n\"aab\" >= sub == true  \nsub >= \"aab\" == false  \n'a' >= sub == false  \nsub >= 'a' == true  \n```  \n  \n## See Also  \n [\\<regex>](../standard-library/regex.md)\n\n"}