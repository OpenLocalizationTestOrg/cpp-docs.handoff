{"nodes":[{"pos":[12,63],"content":"Pure and Verifiable Code (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Pure and Verifiable Code (C++-CLI) | Microsoft Docs","pos":[0,51]}]},{"content":"Pure and Verifiable Code (C++/CLI)","pos":[1163,1197]},{"content":"For .NET Programming, Visual C++ supports the creation of three distinct types of components and applications: mixed, pure, and verifiable.","pos":[1198,1337]},{"content":"All three are available through the <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept> compiler option.","pos":[1338,1498],"source":" All three are available through the [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md) compiler option."},{"content":"Remarks","pos":[1507,1514]},{"content":"For more information about verifiable assemblies, see:","pos":[1518,1572]},{"content":"Mixed, Pure, and Verifiable Feature Comparison (C++/CLI)","pos":[1583,1639]},{"content":"How to: Migrate to /clr:pure (C++/CLI)","pos":[1718,1756]},{"content":"How to: Create Verifiable C++ Projects (C++/CLI)","pos":[1817,1865]},{"content":"How to: Migrate to /clr:safe (C++/CLI)","pos":[1937,1975]},{"content":"Using Verifiable Assemblies with SQL Server (C++/CLI)","pos":[2036,2089]},{"content":"Security Best Practices","pos":[2167,2190]},{"content":"Converting Projects from Mixed Mode to Pure Intermediate Language","pos":[2250,2315]},{"content":"Mixed (/clr)","pos":[2405,2417]},{"content":"Mixed assemblies (compiled with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>), contain both unmanaged and managed parts, making it possible for them to use .NET features, but still contain unmanaged code.","pos":[2421,2589],"source":"Mixed assemblies (compiled with **/clr**), contain both unmanaged and managed parts, making it possible for them to use .NET features, but still contain unmanaged code."},{"content":"This allows applications and components to be updated to use .NET features without requiring that the entire project be rewritten.","pos":[2590,2720]},{"content":"Using Visual C++ to mix managed and unmanaged code in this fashion is called C++ Interop.","pos":[2721,2810]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Mixed (Native and Managed) Assemblies<ept id=\"p1\">](../dotnet/mixed-native-and-managed-assemblies.md)</ept> and <bpt id=\"p2\">[</bpt>Native and .NET Interoperability<ept id=\"p2\">](../dotnet/native-and-dotnet-interoperability.md)</ept>.","pos":[2811,3015],"source":" For more information, see [Mixed (Native and Managed) Assemblies](../dotnet/mixed-native-and-managed-assemblies.md) and [Native and .NET Interoperability](../dotnet/native-and-dotnet-interoperability.md)."},{"content":"Pure (/clr:pure)","pos":[3024,3040]},{"content":"Pure assemblies (compiled with <bpt id=\"p1\">**</bpt>/clr:pure<ept id=\"p1\">**</ept>) can contain both native and managed data types, but only managed functions.","pos":[3044,3165],"source":"Pure assemblies (compiled with **/clr:pure**) can contain both native and managed data types, but only managed functions."},{"content":"Like mixed assemblies, pure assemblies allow interop with native DLLs through P/Invoke (see <bpt id=\"p1\">[</bpt>Using Explicit PInvoke in C++ (DllImport Attribute)<ept id=\"p1\">](../dotnet/using-explicit-pinvoke-in-cpp-dllimport-attribute.md)</ept>), but C++ Interop features are not available.","pos":[3166,3421],"source":" Like mixed assemblies, pure assemblies allow interop with native DLLs through P/Invoke (see [Using Explicit PInvoke in C++ (DllImport Attribute)](../dotnet/using-explicit-pinvoke-in-cpp-dllimport-attribute.md)), but C++ Interop features are not available."},{"content":"Moreover, pure assemblies cannot export functions that are callable from native functions because entry points in a pure assembly use the <bpt id=\"p1\">[</bpt>__clrcall<ept id=\"p1\">](../cpp/clrcall.md)</ept> calling convention.","pos":[3422,3610],"source":" Moreover, pure assemblies cannot export functions that are callable from native functions because entry points in a pure assembly use the [__clrcall](../cpp/clrcall.md) calling convention."},{"content":"Advantages of /clr:pure","pos":[3620,3643]},{"content":"Better Performance: Because pure assemblies contain only MSIL, there are no native functions, and therefore no managed/unmanaged transitions are necessary.","pos":[3653,3808]},{"content":"(Function calls made through P/Invoke are an exception to this rule.)","pos":[3809,3878]},{"content":"AppDomain Awareness: Managed functions and CLR data types exist inside <ph id=\"ph1\">`Application Domains`</ph>, which affects their visibility and accessibility.","pos":[3888,4031],"source":"AppDomain Awareness: Managed functions and CLR data types exist inside `Application Domains`, which affects their visibility and accessibility."},{"content":"Pure assemblies are domain-aware (__declspec(<bpt id=\"p1\">[</bpt>appdomain<ept id=\"p1\">](../cpp/appdomain.md)</ept>) is implied for each type) so accessing their types and functionality from other .NET components is easier and safer.","pos":[4032,4227],"source":" Pure assemblies are domain-aware (__declspec([appdomain](../cpp/appdomain.md)) is implied for each type) so accessing their types and functionality from other .NET components is easier and safer."},{"content":"As a result, pure assemblies interoperate more easily with other .NET components than mixed assemblies.","pos":[4228,4331]},{"content":"Non-disk loading: Pure assemblies can be loaded in-memory and even streamed.","pos":[4341,4417]},{"content":"This is essential for using .NET assemblies as stored procedures.","pos":[4418,4483]},{"content":"This differs from mixed assemblies, which due to a dependency on the Windows loading mechanisms, must exist on disk in order to execute.","pos":[4484,4620]},{"content":"Reflection: It is not possible to reflect over mixed executables, whereas pure assemblies provide full reflection support.","pos":[4630,4752]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Reflection (C++/CLI)<ept id=\"p1\">](../dotnet/reflection-cpp-cli.md)</ept>.","pos":[4753,4835],"source":" For more information, see [Reflection (C++/CLI)](../dotnet/reflection-cpp-cli.md)."},{"content":"Host Controllability: Because pure assemblies contain only MSIL, they behave more predictably and flexibly than mixed assemblies when used in applications that host the CLR and modify its default behavior.","pos":[4845,5050]},{"content":"Limitations of /clr:pure","pos":[5060,5084]},{"pos":[5088,5158],"content":"This section covers features not currently supported by <bpt id=\"p1\">**</bpt>/clr:pure<ept id=\"p1\">**</ept>.","source":"This section covers features not currently supported by **/clr:pure**."},{"content":"Pure assemblies cannot be called by unmanaged functions.","pos":[5168,5224]},{"content":"Therefore pure assemblies cannot implement COM interfaces or expose native callbacks.","pos":[5225,5310]},{"content":"Pure assemblies cannot export functions via __declspec(dllexport) or .DEF files.","pos":[5311,5391]},{"content":"Also, functions declared with the <ph id=\"ph1\">\\_</ph>_clrcall convention cannot be imported via <ph id=\"ph2\">\\_</ph>_declspec(dllimport).","pos":[5392,5494],"source":" Also, functions declared with the \\__clrcall convention cannot be imported via \\__declspec(dllimport)."},{"content":"Functions in a native module can be called from a pure assembly, but pure assemblies cannot expose native-callable functions, so exposing functionality in a pure assembly must be done through managed functions in a mixed assembly.","pos":[5495,5725]},{"content":"See <bpt id=\"p1\">[</bpt>How to: Migrate to /clr:pure (C++/CLI)<ept id=\"p1\">](../dotnet/how-to-migrate-to-clr-pure-cpp-cli.md)</ept> for more information.","pos":[5726,5841],"source":" See [How to: Migrate to /clr:pure (C++/CLI)](../dotnet/how-to-migrate-to-clr-pure-cpp-cli.md) for more information."},{"content":"ATL and MFC libraries are not supported by pure mode compilation in Visual C++.","pos":[5851,5930]},{"content":"Pure .netmodules are not accepted as input to the Visual C++ linker.","pos":[5940,6008]},{"content":"However, pure .obj files are accepted by the linker, and .obj files contain a superset of information contained in netmodules.","pos":[6009,6135]},{"content":"See <bpt id=\"p1\">[</bpt>.netmodule Files as Linker Input<ept id=\"p1\">](../build/reference/netmodule-files-as-linker-input.md)</ept> for more information.","pos":[6136,6251],"source":" See [.netmodule Files as Linker Input](../build/reference/netmodule-files-as-linker-input.md) for more information."},{"content":"Compiler COM support (#import) is not supported, as this would introduce unmanaged instructions into the pure assembly.","pos":[6261,6380]},{"content":"Floating point options for alignment and exception-handling are not adjustable for pure assemblies.","pos":[6390,6489]},{"content":"As a result, __declspec(align) cannot be used.","pos":[6490,6536]},{"content":"This renders some header files, such as fpieee.h, incompatible with /clr:pure.","pos":[6537,6615]},{"pos":[6625,6725],"content":"The GetLastError function in the PSDK can give undefined behavior when compiling with <bpt id=\"p1\">**</bpt>/clr:pure<ept id=\"p1\">**</ept>.","source":"The GetLastError function in the PSDK can give undefined behavior when compiling with **/clr:pure**."},{"content":"Verifiable (/clr:safe)","pos":[6734,6756]},{"content":"The <bpt id=\"p1\">**</bpt>/clr:safe<ept id=\"p1\">**</ept> compiler option generates verifiable assemblies, like those written in Visual Basic and C#, conforming to requirements that allow the common language runtime (CLR) to guarantee that the code does not violate current security settings.","pos":[6760,7012],"source":"The **/clr:safe** compiler option generates verifiable assemblies, like those written in Visual Basic and C#, conforming to requirements that allow the common language runtime (CLR) to guarantee that the code does not violate current security settings."},{"content":"For example, if security settings prohibit a component from writing to disk, the CLR can determine if a verifiable component meets this criterion before executing any of the code.","pos":[7013,7192]},{"content":"There is no CRT support for verifiable assemblies.","pos":[7193,7243]},{"content":"(CRT support is available to pure assemblies through a Pure MSIL version of the C Runtime library.)","pos":[7244,7343]},{"content":"Verifiable assemblies offer these advantages over pure and mixed assemblies:","pos":[7350,7426]},{"content":"Increased security.","pos":[7436,7455]},{"content":"Some situations require it (SQL components, for example).","pos":[7465,7522]},{"content":"Future versions of Windows will increasingly require components and applications to be verifiable.","pos":[7532,7630]},{"content":"One disadvantage is that C++ interop features are not available.","pos":[7637,7701]},{"content":"Verifiable assemblies cannot contain any unmanaged functions or native data types, even if they are not referenced by the managed code.","pos":[7702,7837]},{"pos":[7844,8027],"content":"Despite the use of the word \"safe\", compiling applications with <bpt id=\"p1\">**</bpt>/clr:safe<ept id=\"p1\">**</ept> does not mean there are no bugs; it just means that the CLR can verify the security settings at run time.","source":"Despite the use of the word \"safe\", compiling applications with **/clr:safe** does not mean there are no bugs; it just means that the CLR can verify the security settings at run time."},{"content":"Regardless of assembly type, calls made from managed assemblies to native DLLs via P/Invoke will compile, but may fail at runtime depending on security settings.","pos":[8034,8195]},{"pos":[8203,8459],"content":"[!NOTE]\n There is one coding scenario that will pass the compiler but that will result in an unverifiable assembly: calling a virtual function through an object instance using the scope resolution operator.  For example: `MyObj -> A::VirtualFunction();`.","leadings":["","> "],"nodes":[{"content":" There is one coding scenario that will pass the compiler but that will result in an unverifiable assembly: calling a virtual function through an object instance using the scope resolution operator.  For example: `MyObj -> A::VirtualFunction();`.","pos":[8,254],"nodes":[{"content":"There is one coding scenario that will pass the compiler but that will result in an unverifiable assembly: calling a virtual function through an object instance using the scope resolution operator.","pos":[1,198]},{"content":"For example: <ph id=\"ph1\">`MyObj -&gt; A::VirtualFunction();`</ph>.","pos":[200,246],"source":"  For example: `MyObj -> A::VirtualFunction();`."}]}]},{"content":"See Also","pos":[8468,8476]},{"content":".NET Programming with C++/CLI (Visual C++)","pos":[8481,8523]}],"content":"---\ntitle: \"Pure and Verifiable Code (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"/clr compiler option [C++], verifiable assemblies\"\n  - \"/clr compiler option [C++], mixed assemblies\"\n  - \"pure MSIL [C++]\"\n  - \"verifiable assemblies [C++]\"\n  - \"verifiably type-safe code [C++]\"\n  - \"/clr compiler option [C++], pure assemblies\"\n  - \".NET Framework [C++], pure and verifiable code\"\n  - \"assemblies [C++], mixed code\"\n  - \"verifiable assemblies [C++], about verifiable assemblies\"\n  - \"mixed assemblies [C++], about mixed assemblies\"\n  - \"pure MSIL [C++], about pure code\"\n  - \"assemblies [C++], verifiable code\"\n  - \"mixed assemblies [C++]\"\n  - \"assemblies [C++], pure code\"\nms.assetid: 9050e110-fa11-4356-b56c-665187ff871c\ncaps.latest.revision: 31\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Pure and Verifiable Code (C++/CLI)\nFor .NET Programming, Visual C++ supports the creation of three distinct types of components and applications: mixed, pure, and verifiable. All three are available through the [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md) compiler option.  \n  \n## Remarks  \n For more information about verifiable assemblies, see:  \n  \n-   [Mixed, Pure, and Verifiable Feature Comparison (C++/CLI)](../dotnet/mixed-pure-and-verifiable-feature-comparison-cpp-cli.md)  \n  \n-   [How to: Migrate to /clr:pure (C++/CLI)](../dotnet/how-to-migrate-to-clr-pure-cpp-cli.md)  \n  \n-   [How to: Create Verifiable C++ Projects (C++/CLI)](../dotnet/how-to-create-verifiable-cpp-projects-cpp-cli.md)  \n  \n-   [How to: Migrate to /clr:safe (C++/CLI)](../dotnet/how-to-migrate-to-clr-safe-cpp-cli.md)  \n  \n-   [Using Verifiable Assemblies with SQL Server (C++/CLI)](../dotnet/using-verifiable-assemblies-with-sql-server-cpp-cli.md)  \n  \n-   [Security Best Practices](../security/security-best-practices-for-cpp.md)  \n  \n-   [Converting Projects from Mixed Mode to Pure Intermediate Language](../dotnet/converting-projects-from-mixed-mode-to-pure-intermediate-language.md)  \n  \n## Mixed (/clr)  \n Mixed assemblies (compiled with **/clr**), contain both unmanaged and managed parts, making it possible for them to use .NET features, but still contain unmanaged code. This allows applications and components to be updated to use .NET features without requiring that the entire project be rewritten. Using Visual C++ to mix managed and unmanaged code in this fashion is called C++ Interop. For more information, see [Mixed (Native and Managed) Assemblies](../dotnet/mixed-native-and-managed-assemblies.md) and [Native and .NET Interoperability](../dotnet/native-and-dotnet-interoperability.md).  \n  \n## Pure (/clr:pure)  \n Pure assemblies (compiled with **/clr:pure**) can contain both native and managed data types, but only managed functions. Like mixed assemblies, pure assemblies allow interop with native DLLs through P/Invoke (see [Using Explicit PInvoke in C++ (DllImport Attribute)](../dotnet/using-explicit-pinvoke-in-cpp-dllimport-attribute.md)), but C++ Interop features are not available. Moreover, pure assemblies cannot export functions that are callable from native functions because entry points in a pure assembly use the [__clrcall](../cpp/clrcall.md) calling convention.  \n  \n### Advantages of /clr:pure  \n  \n-   Better Performance: Because pure assemblies contain only MSIL, there are no native functions, and therefore no managed/unmanaged transitions are necessary. (Function calls made through P/Invoke are an exception to this rule.)  \n  \n-   AppDomain Awareness: Managed functions and CLR data types exist inside `Application Domains`, which affects their visibility and accessibility. Pure assemblies are domain-aware (__declspec([appdomain](../cpp/appdomain.md)) is implied for each type) so accessing their types and functionality from other .NET components is easier and safer. As a result, pure assemblies interoperate more easily with other .NET components than mixed assemblies.  \n  \n-   Non-disk loading: Pure assemblies can be loaded in-memory and even streamed. This is essential for using .NET assemblies as stored procedures. This differs from mixed assemblies, which due to a dependency on the Windows loading mechanisms, must exist on disk in order to execute.  \n  \n-   Reflection: It is not possible to reflect over mixed executables, whereas pure assemblies provide full reflection support. For more information, see [Reflection (C++/CLI)](../dotnet/reflection-cpp-cli.md).  \n  \n-   Host Controllability: Because pure assemblies contain only MSIL, they behave more predictably and flexibly than mixed assemblies when used in applications that host the CLR and modify its default behavior.  \n  \n### Limitations of /clr:pure  \n This section covers features not currently supported by **/clr:pure**.  \n  \n-   Pure assemblies cannot be called by unmanaged functions. Therefore pure assemblies cannot implement COM interfaces or expose native callbacks. Pure assemblies cannot export functions via __declspec(dllexport) or .DEF files. Also, functions declared with the \\__clrcall convention cannot be imported via \\__declspec(dllimport). Functions in a native module can be called from a pure assembly, but pure assemblies cannot expose native-callable functions, so exposing functionality in a pure assembly must be done through managed functions in a mixed assembly. See [How to: Migrate to /clr:pure (C++/CLI)](../dotnet/how-to-migrate-to-clr-pure-cpp-cli.md) for more information.  \n  \n-   ATL and MFC libraries are not supported by pure mode compilation in Visual C++.  \n  \n-   Pure .netmodules are not accepted as input to the Visual C++ linker. However, pure .obj files are accepted by the linker, and .obj files contain a superset of information contained in netmodules. See [.netmodule Files as Linker Input](../build/reference/netmodule-files-as-linker-input.md) for more information.  \n  \n-   Compiler COM support (#import) is not supported, as this would introduce unmanaged instructions into the pure assembly.  \n  \n-   Floating point options for alignment and exception-handling are not adjustable for pure assemblies. As a result, __declspec(align) cannot be used. This renders some header files, such as fpieee.h, incompatible with /clr:pure.  \n  \n-   The GetLastError function in the PSDK can give undefined behavior when compiling with **/clr:pure**.  \n  \n## Verifiable (/clr:safe)  \n The **/clr:safe** compiler option generates verifiable assemblies, like those written in Visual Basic and C#, conforming to requirements that allow the common language runtime (CLR) to guarantee that the code does not violate current security settings. For example, if security settings prohibit a component from writing to disk, the CLR can determine if a verifiable component meets this criterion before executing any of the code. There is no CRT support for verifiable assemblies. (CRT support is available to pure assemblies through a Pure MSIL version of the C Runtime library.)  \n  \n Verifiable assemblies offer these advantages over pure and mixed assemblies:  \n  \n-   Increased security.  \n  \n-   Some situations require it (SQL components, for example).  \n  \n-   Future versions of Windows will increasingly require components and applications to be verifiable.  \n  \n One disadvantage is that C++ interop features are not available. Verifiable assemblies cannot contain any unmanaged functions or native data types, even if they are not referenced by the managed code.  \n  \n Despite the use of the word \"safe\", compiling applications with **/clr:safe** does not mean there are no bugs; it just means that the CLR can verify the security settings at run time.  \n  \n Regardless of assembly type, calls made from managed assemblies to native DLLs via P/Invoke will compile, but may fail at runtime depending on security settings.  \n  \n> [!NOTE]\n>  There is one coding scenario that will pass the compiler but that will result in an unverifiable assembly: calling a virtual function through an object instance using the scope resolution operator.  For example: `MyObj -> A::VirtualFunction();`.  \n  \n## See Also  \n [.NET Programming with C++/CLI (Visual C++)](../dotnet/dotnet-programming-with-cpp-cli-visual-cpp.md)"}