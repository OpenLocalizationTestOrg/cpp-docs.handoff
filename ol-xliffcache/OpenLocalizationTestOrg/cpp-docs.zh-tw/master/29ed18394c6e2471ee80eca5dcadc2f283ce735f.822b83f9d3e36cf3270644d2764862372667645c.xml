{"nodes":[{"pos":[12,44],"content":"memcpy, wmemcpy | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"memcpy, wmemcpy | Microsoft Docs","pos":[0,32]}]},{"content":"memcpy, wmemcpy","pos":[923,938]},{"content":"Copies bytes between buffers.","pos":[939,968]},{"content":"More secure versions of these functions are available; see <bpt id=\"p1\">[</bpt>memcpy_s, wmemcpy_s<ept id=\"p1\">](../../c-runtime-library/reference/memcpy-s-wmemcpy-s.md)</ept>.","pos":[969,1107],"source":" More secure versions of these functions are available; see [memcpy_s, wmemcpy_s](../../c-runtime-library/reference/memcpy-s-wmemcpy-s.md)."},{"content":"Syntax","pos":[1116,1122]},{"content":"Parameters","pos":[1315,1325]},{"content":"New buffer.","pos":[1339,1350]},{"content":"Buffer to copy from.","pos":[1366,1386]},{"content":"Number of characters to copy.","pos":[1404,1433]},{"content":"Return Value","pos":[1442,1454]},{"pos":[1458,1478],"content":"The value of <ph id=\"ph1\">`dest`</ph>.","source":"The value of `dest`."},{"content":"Remarks","pos":[1487,1494]},{"content":"copies <ph id=\"ph1\">`count`</ph> bytes from <ph id=\"ph2\">`src`</ph> to <ph id=\"ph3\">`dest`</ph>; <ph id=\"ph4\">`wmemcpy`</ph> copies <ph id=\"ph5\">`count`</ph> wide characters (two bytes).","pos":[1507,1603],"source":" copies `count` bytes from `src` to `dest`; `wmemcpy` copies `count` wide characters (two bytes)."},{"content":"If the source and destination overlap, the behavior of <ph id=\"ph1\">`memcpy`</ph> is undefined.","pos":[1604,1681],"source":" If the source and destination overlap, the behavior of `memcpy` is undefined."},{"content":"Use <ph id=\"ph1\">`memmove`</ph> to handle overlapping regions.","pos":[1682,1726],"source":" Use `memmove` to handle overlapping regions."},{"pos":[1734,1952],"content":"[!IMPORTANT]\n Make sure that the destination buffer is the same size or larger than the source buffer. For more information, see [Avoiding Buffer Overruns](http://msdn.microsoft.com/library/windows/desktop/ms717795).","leadings":["","> "],"nodes":[{"content":" Make sure that the destination buffer is the same size or larger than the source buffer. For more information, see [Avoiding Buffer Overruns](http://msdn.microsoft.com/library/windows/desktop/ms717795).","pos":[13,216],"nodes":[{"content":"Make sure that the destination buffer is the same size or larger than the source buffer.","pos":[1,89]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Avoiding Buffer Overruns<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms717795)</ept>.","pos":[90,203],"source":" For more information, see [Avoiding Buffer Overruns](http://msdn.microsoft.com/library/windows/desktop/ms717795)."}]}]},{"pos":[1960,3227],"content":"[!IMPORTANT]\n Because so many buffer overruns, and thus potential security exploits, have been traced to improper usage of `memcpy`, this function is listed among the “banned” functions by the Security Development Lifecycle (SDL).  You may observe that some VC++ library classes continue to use `memcpy`.  Furthermore, you may observe that the VC++ compiler optimizer sometimes emits calls to `memcpy`.  The Visual C++ product is developed in accordance with the SDL process, and thus usage of this banned function has been closely evaluated.  In the case of library use of it, the calls have been carefully scrutinized to ensure that buffer overruns will not be allowed through these calls.  In the case of the compiler, sometimes certain code patterns are recognized as identical to the pattern of `memcpy`, and are thus replaced with a call to the function.  In such cases, the use of `memcpy` is no more unsafe than the original instructions would have been; they have simply been optimized to a call to the performance-tuned `memcpy` function.  Just as the use of “safe” CRT functions doesn’t guarantee safety (they just make it harder to be unsafe), the use of “banned” functions doesn’t guarantee danger (they just require greater scrutiny to ensure safety).","leadings":["","> "],"nodes":[{"content":" Because so many buffer overruns, and thus potential security exploits, have been traced to improper usage of `memcpy`, this function is listed among the “banned” functions by the Security Development Lifecycle (SDL).  You may observe that some VC++ library classes continue to use `memcpy`.  Furthermore, you may observe that the VC++ compiler optimizer sometimes emits calls to `memcpy`.  The Visual C++ product is developed in accordance with the SDL process, and thus usage of this banned function has been closely evaluated.  In the case of library use of it, the calls have been carefully scrutinized to ensure that buffer overruns will not be allowed through these calls.  In the case of the compiler, sometimes certain code patterns are recognized as identical to the pattern of `memcpy`, and are thus replaced with a call to the function.  In such cases, the use of `memcpy` is no more unsafe than the original instructions would have been; they have simply been optimized to a call to the performance-tuned `memcpy` function.  Just as the use of “safe” CRT functions doesn’t guarantee safety (they just make it harder to be unsafe), the use of “banned” functions doesn’t guarantee danger (they just require greater scrutiny to ensure safety).","pos":[13,1265],"nodes":[{"content":"Because so many buffer overruns, and thus potential security exploits, have been traced to improper usage of <ph id=\"ph1\">`memcpy`</ph>, this function is listed among the “banned” functions by the Security Development Lifecycle (SDL).","pos":[1,217],"source":" Because so many buffer overruns, and thus potential security exploits, have been traced to improper usage of `memcpy`, this function is listed among the “banned” functions by the Security Development Lifecycle (SDL)."},{"content":"You may observe that some VC++ library classes continue to use <ph id=\"ph1\">`memcpy`</ph>.","pos":[219,291],"source":"  You may observe that some VC++ library classes continue to use `memcpy`."},{"content":"Furthermore, you may observe that the VC++ compiler optimizer sometimes emits calls to <ph id=\"ph1\">`memcpy`</ph>.","pos":[293,389],"source":"  Furthermore, you may observe that the VC++ compiler optimizer sometimes emits calls to `memcpy`."},{"content":"The Visual C++ product is developed in accordance with the SDL process, and thus usage of this banned function has been closely evaluated.","pos":[391,529]},{"content":"In the case of library use of it, the calls have been carefully scrutinized to ensure that buffer overruns will not be allowed through these calls.","pos":[531,678]},{"content":"In the case of the compiler, sometimes certain code patterns are recognized as identical to the pattern of <ph id=\"ph1\">`memcpy`</ph>, and are thus replaced with a call to the function.","pos":[680,847],"source":"  In the case of the compiler, sometimes certain code patterns are recognized as identical to the pattern of `memcpy`, and are thus replaced with a call to the function."},{"content":"In such cases, the use of <ph id=\"ph1\">`memcpy`</ph> is no more unsafe than the original instructions would have been; they have simply been optimized to a call to the performance-tuned <ph id=\"ph2\">`memcpy`</ph> function.","pos":[849,1035],"source":"  In such cases, the use of `memcpy` is no more unsafe than the original instructions would have been; they have simply been optimized to a call to the performance-tuned `memcpy` function."},{"content":"Just as the use of “safe” CRT functions doesn’t guarantee safety (they just make it harder to be unsafe), the use of “banned” functions doesn’t guarantee danger (they just require greater scrutiny to ensure safety).","pos":[1037,1252]}]}]},{"content":"Because <ph id=\"ph1\">`memcpy`</ph> usage by the VC++ compiler and libraries has been so carefully scrutinized, these calls are permitted within code that is otherwise compliant with SDL.","pos":[3238,3406],"source":"Because `memcpy` usage by the VC++ compiler and libraries has been so carefully scrutinized, these calls are permitted within code that is otherwise compliant with SDL."},{"content":"calls introduced in application source code are only compliant with the SDL when that use has been reviewed by security experts.","pos":[3417,3545]},{"pos":[3552,3778],"content":"The <ph id=\"ph1\">`memcpy`</ph> and <ph id=\"ph2\">`wmemcpy`</ph> functions will only be deprecated if the constant <ph id=\"ph3\">`_CRT_SECURE_DEPRECATE_MEMORY`</ph> is defined prior to the inclusion statement in order for the functions to be deprecated, such as in the example below:","source":"The `memcpy` and `wmemcpy` functions will only be deprecated if the constant `_CRT_SECURE_DEPRECATE_MEMORY` is defined prior to the inclusion statement in order for the functions to be deprecated, such as in the example below:"},{"content":"or","pos":[3861,3863]},{"content":"Requirements","pos":[3947,3959]},{"content":"Routine","pos":[3966,3973]},{"content":"Required header","pos":[3974,3989]},{"content":"memory.h&gt; or <ph id=\"ph1\">\\&lt;</ph>string.h&gt;","pos":[4045,4069],"source":"memory.h> or \\<string.h>"},{"content":"wchar.h&gt;","pos":[4086,4094],"source":"wchar.h>"},{"pos":[4102,4226],"content":"For additional compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept> in the Introduction.","source":"For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction."},{"content":"Example","pos":[4235,4242]},{"pos":[4246,4351],"content":"See <bpt id=\"p1\">[</bpt>memmove<ept id=\"p1\">](../../c-runtime-library/reference/memmove-wmemmove.md)</ept> for a sample of how to use <ph id=\"ph1\">`memcpy`</ph>.","source":"See [memmove](../../c-runtime-library/reference/memmove-wmemmove.md) for a sample of how to use `memcpy`."},{"content":"See Also","pos":[4360,4368]},{"content":"Buffer Manipulation","pos":[4373,4392]},{"content":"_memccpy","pos":[4447,4455]},{"content":"memchr, wmemchr","pos":[4508,4523]},{"content":"memcmp, wmemcmp","pos":[4583,4598]},{"content":"memmove, wmemmove","pos":[4658,4675]},{"content":"memset, wmemset","pos":[4737,4752]},{"content":"strcpy_s, wcscpy_s, _mbscpy_s","pos":[4812,4841]},{"content":"strncpy_s, _strncpy_s_l, wcsncpy_s, _wcsncpy_s_l, _mbsncpy_s, _mbsncpy_s_l","pos":[4913,4987]}],"content":"---\ntitle: \"memcpy, wmemcpy | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"memcpy\"\n  - \"wmemcpy\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"wmemcpy\"\n  - \"memcpy\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"wmemcpy function\"\n  - \"memcpy function\"\nms.assetid: 34abb90b-bffb-46dc-a2f3-a5e9940839d6\ncaps.latest.revision: 21\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# memcpy, wmemcpy\nCopies bytes between buffers. More secure versions of these functions are available; see [memcpy_s, wmemcpy_s](../../c-runtime-library/reference/memcpy-s-wmemcpy-s.md).  \n  \n## Syntax  \n  \n```  \nvoid *memcpy(  \n   void *dest,  \n   const void *src,  \n   size_t count   \n);  \nwchar_t *wmemcpy(  \n   wchar_t *dest,  \n   const wchar_t *src,  \n   size_t count  \n);  \n```  \n  \n#### Parameters  \n `dest`  \n New buffer.  \n  \n `src`  \n Buffer to copy from.  \n  \n `count`  \n Number of characters to copy.  \n  \n## Return Value  \n The value of `dest`.  \n  \n## Remarks  \n `memcpy` copies `count` bytes from `src` to `dest`; `wmemcpy` copies `count` wide characters (two bytes). If the source and destination overlap, the behavior of `memcpy` is undefined. Use `memmove` to handle overlapping regions.  \n  \n> [!IMPORTANT]\n>  Make sure that the destination buffer is the same size or larger than the source buffer. For more information, see [Avoiding Buffer Overruns](http://msdn.microsoft.com/library/windows/desktop/ms717795).  \n  \n> [!IMPORTANT]\n>  Because so many buffer overruns, and thus potential security exploits, have been traced to improper usage of `memcpy`, this function is listed among the “banned” functions by the Security Development Lifecycle (SDL).  You may observe that some VC++ library classes continue to use `memcpy`.  Furthermore, you may observe that the VC++ compiler optimizer sometimes emits calls to `memcpy`.  The Visual C++ product is developed in accordance with the SDL process, and thus usage of this banned function has been closely evaluated.  In the case of library use of it, the calls have been carefully scrutinized to ensure that buffer overruns will not be allowed through these calls.  In the case of the compiler, sometimes certain code patterns are recognized as identical to the pattern of `memcpy`, and are thus replaced with a call to the function.  In such cases, the use of `memcpy` is no more unsafe than the original instructions would have been; they have simply been optimized to a call to the performance-tuned `memcpy` function.  Just as the use of “safe” CRT functions doesn’t guarantee safety (they just make it harder to be unsafe), the use of “banned” functions doesn’t guarantee danger (they just require greater scrutiny to ensure safety).  \n>   \n>  Because `memcpy` usage by the VC++ compiler and libraries has been so carefully scrutinized, these calls are permitted within code that is otherwise compliant with SDL.  `memcpy` calls introduced in application source code are only compliant with the SDL when that use has been reviewed by security experts.  \n  \n The `memcpy` and `wmemcpy` functions will only be deprecated if the constant `_CRT_SECURE_DEPRECATE_MEMORY` is defined prior to the inclusion statement in order for the functions to be deprecated, such as in the example below:  \n  \n```  \n#define _CRT_SECURE_DEPRECATE_MEMORY  \n#include <memory.h>  \n```  \n  \n or  \n  \n```  \n#define _CRT_SECURE_DEPRECATE_MEMORY  \n#include <wchar.h>  \n```  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`memcpy`|\\<memory.h> or \\<string.h>|  \n|`wmemcpy`|\\<wchar.h>|  \n  \n For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction.  \n  \n## Example  \n See [memmove](../../c-runtime-library/reference/memmove-wmemmove.md) for a sample of how to use `memcpy`.  \n  \n## See Also  \n [Buffer Manipulation](../../c-runtime-library/buffer-manipulation.md)   \n [_memccpy](../../c-runtime-library/reference/memccpy.md)   \n [memchr, wmemchr](../../c-runtime-library/reference/memchr-wmemchr.md)   \n [memcmp, wmemcmp](../../c-runtime-library/reference/memcmp-wmemcmp.md)   \n [memmove, wmemmove](../../c-runtime-library/reference/memmove-wmemmove.md)   \n [memset, wmemset](../../c-runtime-library/reference/memset-wmemset.md)   \n [strcpy_s, wcscpy_s, _mbscpy_s](../../c-runtime-library/reference/strcpy-s-wcscpy-s-mbscpy-s.md)   \n [strncpy_s, _strncpy_s_l, wcsncpy_s, _wcsncpy_s_l, _mbsncpy_s, _mbsncpy_s_l](../../c-runtime-library/reference/strncpy-s-strncpy-s-l-wcsncpy-s-wcsncpy-s-l-mbsncpy-s-mbsncpy-s-l.md)"}