{"nodes":[{"pos":[12,75],"content":"How to: Determine if an Image is Native or CLR | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Determine if an Image is Native or CLR | Microsoft Docs","pos":[0,63]}]},{"content":"How to: Determine if an Image is Native or CLR","pos":[787,833]},{"pos":[834,981],"content":"One way to determine whether an image was built for the common language runtime is to use <bpt id=\"p1\">**</bpt>dumpbin<ept id=\"p1\">**</ept><bpt id=\"p2\">[</bpt>/CLRHEADER<ept id=\"p2\">](../build/reference/clrheader.md)</ept>.","source":"One way to determine whether an image was built for the common language runtime is to use **dumpbin**[/CLRHEADER](../build/reference/clrheader.md)."},{"content":"You can also programmatically check whether an image was built for the common language runtime.","pos":[988,1083]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Detect /clr Compilation<ept id=\"p1\">](../dotnet/how-to-detect-clr-compilation.md)</ept>.","pos":[1084,1188],"source":" For more information, see [How to: Detect /clr Compilation](../dotnet/how-to-detect-clr-compilation.md)."},{"content":"Example","pos":[1197,1204]},{"content":"The following sample determines whether an image was built to run on the common language runtime.","pos":[1208,1305]},{"content":"See Also","pos":[2974,2982]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[2987,3023]}],"content":"---\ntitle: \"How to: Determine if an Image is Native or CLR | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"common language runtime, image testing\"\n  - \"images [C++], CLR verification\"\n  - \"/clr compiler option [C++], detecting use in compilation\"\n  - \"common language runtime, /clr compiler option\"\nms.assetid: 5a854822-6172-4b22-b236-320165412568\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Determine if an Image is Native or CLR\nOne way to determine whether an image was built for the common language runtime is to use **dumpbin**[/CLRHEADER](../build/reference/clrheader.md).  \n  \n You can also programmatically check whether an image was built for the common language runtime. For more information, see [How to: Detect /clr Compilation](../dotnet/how-to-detect-clr-compilation.md).  \n  \n## Example  \n The following sample determines whether an image was built to run on the common language runtime.  \n  \n```  \n// detect_image_type.cpp  \n// compile with: /clr  \nusing namespace System;  \nusing namespace System::IO;  \n  \nenum class CompilationMode {Invalid, Native, CLR };  \n  \nstatic CompilationMode IsManaged(String^ filename) {  \n   try {  \n      array<Byte>^ data = gcnew array<Byte>(4096);  \n      FileInfo^ file = gcnew FileInfo(filename);  \n      Stream^ fin = file->Open(FileMode::Open, FileAccess::Read);  \n      Int32 iRead = fin->Read(data, 0, 4096);  \n      fin->Close();  \n  \n      // Verify this is a executable/dll  \n      if ((data[1] << 8 | data[0]) != 0x5a4d)  \n         return CompilationMode::Invalid;  \n  \n      // This will get the address for the WinNT header  \n      Int32 iWinNTHdr = data[63]<<24 | data[62]<<16 | data[61] << 8 | data[60];  \n  \n      // Verify this is an NT address  \n      if ((data[iWinNTHdr+3] << 24 | data[iWinNTHdr+2] << 16 | data[iWinNTHdr+1] << 8 | data[iWinNTHdr]) != 0x00004550)  \n         return CompilationMode::Invalid;  \n  \n      Int32 iLightningAddr = iWinNTHdr + 24 + 208;  \n      Int32 iSum = 0;  \n      Int32 iTop = iLightningAddr + 8;  \n  \n      for (int i = iLightningAddr; i < iTop; ++i)  \n         iSum |= data[i];  \n  \n      if (iSum == 0)  \n         return CompilationMode::Native;  \n      else  \n         return CompilationMode::CLR;  \n   }  \n   catch(Exception ^e) {  \n      throw(e);  \n   }  \n}  \n  \nint main() {  \n   array<String^>^ args = Environment::GetCommandLineArgs();  \n  \n   if (args->Length < 2) {  \n      Console::WriteLine(\"USAGE : detect_clr <assembly_name>\\n\");  \n      return -1;  \n   }  \n  \n   Console::WriteLine(\"{0} is compiled {1}\", args[1], IsManaged(args[1]));  \n}  \n```  \n  \n## See Also  \n [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)"}