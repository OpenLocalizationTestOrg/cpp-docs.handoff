{"nodes":[{"pos":[12,53],"content":"&lt;memory&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>memory<ph id=\"ph2\">&amp;gt;</ph> functions | Microsoft Docs","pos":[0,41],"source":"&lt;memory&gt; functions | Microsoft Docs"}]},{"pos":[256,280],"content":"&lt;memory&gt; functions","linkify":"&lt;memory&gt; functions","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>memory<ph id=\"ph2\">&amp;gt;</ph> functions","pos":[0,24],"source":"&lt;memory&gt; functions"}]},{"pos":[299,322],"content":"<bpt id=\"p1\">[</bpt>addressof<ept id=\"p1\">](#addressof)</ept>","source":"[addressof](#addressof)"},{"pos":[323,338],"content":"<bpt id=\"p1\">[</bpt>align<ept id=\"p1\">](#align)</ept>","source":"[align](#align)"},{"pos":[339,374],"content":"<bpt id=\"p1\">[</bpt>allocate_shared<ept id=\"p1\">](#allocate_shared)</ept>","source":"[allocate_shared](#allocate_shared)"},{"pos":[379,420],"content":"<bpt id=\"p1\">[</bpt>const_pointer_cast<ept id=\"p1\">](#const_pointer_cast)</ept>","source":"[const_pointer_cast](#const_pointer_cast)"},{"pos":[421,464],"content":"<bpt id=\"p1\">[</bpt>declare_no_pointers<ept id=\"p1\">](#declare_no_pointers)</ept>","source":"[declare_no_pointers](#declare_no_pointers)"},{"pos":[465,504],"content":"<bpt id=\"p1\">[</bpt>declare_reachable<ept id=\"p1\">](#declare_reachable)</ept>","source":"[declare_reachable](#declare_reachable)"},{"pos":[509,542],"content":"<bpt id=\"p1\">[</bpt>default_delete<ept id=\"p1\">](#default_delete)</ept>","source":"[default_delete](#default_delete)"},{"pos":[543,588],"content":"<bpt id=\"p1\">[</bpt>dynamic_pointer_cast<ept id=\"p1\">](#dynamic_pointer_cast)</ept>","source":"[dynamic_pointer_cast](#dynamic_pointer_cast)"},{"pos":[589,634],"content":"<bpt id=\"p1\">[</bpt>get_deleter Function<ept id=\"p1\">](#get_deleter_function)</ept>","source":"[get_deleter Function](#get_deleter_function)"},{"pos":[639,680],"content":"<bpt id=\"p1\">[</bpt>get_pointer_safety<ept id=\"p1\">](#get_pointer_safety)</ept>","source":"[get_pointer_safety](#get_pointer_safety)"},{"pos":[681,726],"content":"<bpt id=\"p1\">[</bpt>get_temporary_buffer<ept id=\"p1\">](#get_temporary_buffer)</ept>","source":"[get_temporary_buffer](#get_temporary_buffer)"},{"pos":[727,754],"content":"<bpt id=\"p1\">[</bpt>make_shared<ept id=\"p1\">](#make_shared)</ept>","source":"[make_shared](#make_shared)"},{"pos":[759,786],"content":"<bpt id=\"p1\">[</bpt>make_unique<ept id=\"p1\">](#make_unique)</ept>","source":"[make_unique](#make_unique)"},{"pos":[787,812],"content":"<bpt id=\"p1\">[</bpt>owner_less<ept id=\"p1\">](#owner_less)</ept>","source":"[owner_less](#owner_less)"},{"pos":[813,864],"content":"<bpt id=\"p1\">[</bpt>return_temporary_buffer<ept id=\"p1\">](#return_temporary_buffer)</ept>","source":"[return_temporary_buffer](#return_temporary_buffer)"},{"pos":[869,912],"content":"<bpt id=\"p1\">[</bpt>static_pointer_cast<ept id=\"p1\">](#static_pointer_cast)</ept>","source":"[static_pointer_cast](#static_pointer_cast)"},{"pos":[913,949],"content":"<bpt id=\"p1\">[</bpt>swap (C++ Standard Library)<ept id=\"p1\">](#swap)</ept>","source":"[swap (C++ Standard Library)](#swap)"},{"pos":[950,997],"content":"<bpt id=\"p1\">[</bpt>undeclare_no_pointers<ept id=\"p1\">](#undeclare_no_pointers)</ept>","source":"[undeclare_no_pointers](#undeclare_no_pointers)"},{"pos":[1002,1045],"content":"<bpt id=\"p1\">[</bpt>undeclare_reachable<ept id=\"p1\">](#undeclare_reachable)</ept>","source":"[undeclare_reachable](#undeclare_reachable)"},{"pos":[1046,1087],"content":"<bpt id=\"p1\">[</bpt>uninitialized_copy<ept id=\"p1\">](#uninitialized_copy)</ept>","source":"[uninitialized_copy](#uninitialized_copy)"},{"pos":[1088,1133],"content":"<bpt id=\"p1\">[</bpt>uninitialized_copy_n<ept id=\"p1\">](#uninitialized_copy_n)</ept>","source":"[uninitialized_copy_n](#uninitialized_copy_n)"},{"pos":[1138,1179],"content":"<bpt id=\"p1\">[</bpt>uninitialized_fill<ept id=\"p1\">](#uninitialized_fill)</ept>","source":"[uninitialized_fill](#uninitialized_fill)"},{"pos":[1180,1225],"content":"<bpt id=\"p1\">[</bpt>uninitialized_fill_n<ept id=\"p1\">](#uninitialized_fill_n)</ept>","source":"[uninitialized_fill_n](#uninitialized_fill_n)"},{"pos":[1236,1271],"content":"<bpt id=\"p1\">&lt;a name=\"addressof\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  addressof","linkify":"<a name=\"addressof\"></a>  addressof","source":"<a name=\"addressof\"></a>  addressof"},{"content":"Gets the true address of an object.","pos":[1275,1310]},{"pos":[1378,1388],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The object or function for which to obtain the true address.","pos":[1401,1461]},{"pos":[1471,1483],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[1487,1596],"content":"The actual address of the object or function referenced by <ph id=\"ph1\">`Val`</ph>, even if an overloaded <ph id=\"ph2\">`operator&amp;()`</ph> exists.","source":"The actual address of the object or function referenced by `Val`, even if an overloaded `operator&()` exists."},{"pos":[1606,1613],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[1623,1650],"content":"<bpt id=\"p1\">&lt;a name=\"align\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  align","linkify":"<a name=\"align\"></a>  align","source":"<a name=\"align\"></a>  align"},{"content":"Fits storage of the given size—aligned by the given alignment specification—into the first possible address of the given storage.","pos":[1654,1783]},{"pos":[1964,1974],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The alignment bound to attempt.","pos":[1993,2024]},{"content":"The size in bytes for the aligned storage.","pos":[2041,2083]},{"content":"The starting address of the available contiguous storage pool to use.","pos":[2099,2168]},{"content":"This parameter is also an output parameter, and will contain the new starting address if the alignment is successful.","pos":[2169,2286]},{"pos":[2293,2354],"content":"If <ph id=\"ph1\">`align()`</ph> is unsuccessful, this parameter is not modified.","source":"If `align()` is unsuccessful, this parameter is not modified."},{"content":"The total space available to <ph id=\"ph1\">`align()`</ph> to use in creating the aligned storage.","pos":[2372,2450],"source":" The total space available to `align()` to use in creating the aligned storage."},{"content":"This parameter is also an output parameter, and contains the adjusted space left in the storage buffer after the aligned storage and any associated overhead is subtracted.","pos":[2451,2622]},{"pos":[2629,2690],"content":"If <ph id=\"ph1\">`align()`</ph> is unsuccessful, this parameter is not modified.","source":"If `align()` is unsuccessful, this parameter is not modified."},{"pos":[2700,2712],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[2716,2837],"content":"A null pointer if the requested aligned buffer would not fit into the available space; otherwise, the new value of <ph id=\"ph1\">`Ptr`</ph>.","source":"A null pointer if the requested aligned buffer would not fit into the available space; otherwise, the new value of `Ptr`."},{"pos":[2847,2854],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The modified <ph id=\"ph1\">`Ptr`</ph> and <ph id=\"ph2\">`Space`</ph> parameters enable you to call <ph id=\"ph3\">`align()`</ph> repeatedly on the same buffer, possibly with different values for <ph id=\"ph4\">`Alignment`</ph> and <ph id=\"ph5\">`Size`</ph>.","pos":[2858,3018],"source":"The modified `Ptr` and `Space` parameters enable you to call `align()` repeatedly on the same buffer, possibly with different values for `Alignment` and `Size`."},{"content":"The following code snippet shows one use of <ph id=\"ph1\">`align()`</ph>.","pos":[3019,3073],"source":" The following code snippet shows one use of `align()`."},{"pos":[3990,4037],"content":"<bpt id=\"p1\">&lt;a name=\"allocate_shared\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  allocate_shared","linkify":"<a name=\"allocate_shared\"></a>  allocate_shared","source":"<a name=\"allocate_shared\"></a>  allocate_shared"},{"content":"Creates a <ph id=\"ph1\">`shared_ptr`</ph> to objects that are allocated and constructed for a given type by using a specified allocator.","pos":[4041,4158],"source":"Creates a `shared_ptr` to objects that are allocated and constructed for a given type by using a specified allocator."},{"content":"Returns the <ph id=\"ph1\">`shared_ptr`</ph>.","pos":[4159,4184],"source":" Returns the `shared_ptr`."},{"pos":[4336,4346],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The allocator used to create objects.","pos":[4361,4398]},{"content":"The zero or more arguments that become the objects.","pos":[4415,4466]},{"pos":[4476,4483],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[4487,4614],"content":"The function creates the object <ph id=\"ph1\">`shared_ptr``&lt;Type&gt;`</ph>, a pointer to <ph id=\"ph2\">`Type(``Args``...)`</ph> as allocated and constructed by <ph id=\"ph3\">`Alloc`</ph>.","source":"The function creates the object `shared_ptr``<Type>`, a pointer to `Type(``Args``...)` as allocated and constructed by `Alloc`."},{"pos":[4624,4677],"content":"<bpt id=\"p1\">&lt;a name=\"const_pointer_cast\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  const_pointer_cast","linkify":"<a name=\"const_pointer_cast\"></a>  const_pointer_cast","source":"<a name=\"const_pointer_cast\"></a>  const_pointer_cast"},{"content":"Const cast to shared_ptr.","pos":[4681,4706]},{"pos":[4832,4842],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type controlled by the returned shared pointer.","pos":[4854,4905]},{"content":"The type controlled by the argument shared pointer.","pos":[4923,4974]},{"content":"The argument shared pointer.","pos":[4992,5020]},{"pos":[5030,5037],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template function returns an empty shared_ptr object if <ph id=\"ph1\">`const_cast&lt;Ty*&gt;(sp.get())`</ph> returns a null pointer; otherwise it returns a <bpt id=\"p1\">[</bpt>shared_ptr Class<ept id=\"p1\">](../standard-library/shared-ptr-class.md)</ept><ph id=\"ph2\">`&lt;Ty&gt;`</ph> object that owns the resource that is owned by <ph id=\"ph3\">`sp`</ph>.","pos":[5041,5294],"source":"The template function returns an empty shared_ptr object if `const_cast<Ty*>(sp.get())` returns a null pointer; otherwise it returns a [shared_ptr Class](../standard-library/shared-ptr-class.md)`<Ty>` object that owns the resource that is owned by `sp`."},{"content":"The expression <ph id=\"ph1\">`const_cast&lt;Ty*&gt;(sp.get())`</ph> must be valid.","pos":[5295,5352],"source":" The expression `const_cast<Ty*>(sp.get())` must be valid."},{"pos":[5362,5369],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[5807,5862],"content":"<bpt id=\"p1\">&lt;a name=\"declare_no_pointers\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  declare_no_pointers","linkify":"<a name=\"declare_no_pointers\"></a>  declare_no_pointers","source":"<a name=\"declare_no_pointers\"></a>  declare_no_pointers"},{"content":"Informs a garbage collector that the characters in the memory block defined by a base address pointer and block size contains no traceable pointers.","pos":[5866,6014]},{"pos":[6102,6112],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[6119,6128]},{"content":"Description","pos":[6129,6140]},{"content":"Address of first character that no longer contains traceable pointers.","pos":[6190,6260]},{"pos":[6273,6345],"content":"Size of block that starts at <ph id=\"ph1\">` ptr`</ph> that contains no traceable pointers.","source":"Size of block that starts at ` ptr` that contains no traceable pointers."},{"pos":[6356,6363],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The function informs any <ph id=\"ph1\">`garbage collector`</ph> that the range of addresses <ph id=\"ph2\">`[`` ptr``,`</ph> <ph id=\"ph3\">` ptr`</ph> <ph id=\"ph4\">`+`</ph> <ph id=\"ph5\">`_Size``)`</ph> no longer contain traceable pointers.","pos":[6367,6512],"source":"The function informs any `garbage collector` that the range of addresses `[`` ptr``,` ` ptr` `+` `_Size``)` no longer contain traceable pointers."},{"content":"(Any pointers to allocated storage must not be dereferenced unless made <ph id=\"ph1\">`reachable`</ph>.)","pos":[6513,6598],"source":" (Any pointers to allocated storage must not be dereferenced unless made `reachable`.)"},{"pos":[6608,6659],"content":"<bpt id=\"p1\">&lt;a name=\"declare_reachable\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  declare_reachable","linkify":"<a name=\"declare_reachable\"></a>  declare_reachable","source":"<a name=\"declare_reachable\"></a>  declare_reachable"},{"content":"Informs garbage collection that the indicated address is to allocated storage and is reachable.","pos":[6663,6758]},{"pos":[6818,6828],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A pointer to a reachable, allocated, valid storage area.","pos":[6842,6898]},{"pos":[6908,6915],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6919,7056],"content":"If <ph id=\"ph1\">` ptr`</ph> is not null, the function informs any garbage collector that <ph id=\"ph2\">` ptr`</ph> is hereafter reachable (points to valid allocated storage).","source":"If ` ptr` is not null, the function informs any garbage collector that ` ptr` is hereafter reachable (points to valid allocated storage)."},{"pos":[7066,7111],"content":"<bpt id=\"p1\">&lt;a name=\"default_delete\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  default_delete","linkify":"<a name=\"default_delete\"></a>  default_delete","source":"<a name=\"default_delete\"></a>  default_delete"},{"content":"Deletes objects allocated with <ph id=\"ph1\">`operator new`</ph>.","pos":[7115,7161],"source":"Deletes objects allocated with `operator new`."},{"content":"Suitable for use with <ph id=\"ph1\">`unique_ptr`</ph>.","pos":[7162,7197],"source":" Suitable for use with `unique_ptr`."},{"pos":[7502,7512],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Pointer to the object to delete.","pos":[7525,7557]},{"content":"Other","pos":[7564,7569]},{"content":"The type of elements in the array to be deleted.","pos":[7573,7621]},{"pos":[7631,7638],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template class describes a <ph id=\"ph1\">`deleter`</ph> that deletes scalar objects allocated with <ph id=\"ph2\">`operator new`</ph>, suitable for use with template class <ph id=\"ph3\">`unique_ptr`</ph>.","pos":[7642,7792],"source":"The template class describes a `deleter` that deletes scalar objects allocated with `operator new`, suitable for use with template class `unique_ptr`."},{"content":"It also has the explicit specialization <ph id=\"ph1\">`default_delete&lt;Type[]&gt;`</ph>.","pos":[7793,7858],"source":" It also has the explicit specialization `default_delete<Type[]>`."},{"pos":[7868,7925],"content":"<bpt id=\"p1\">&lt;a name=\"dynamic_pointer_cast\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  dynamic_pointer_cast","linkify":"<a name=\"dynamic_pointer_cast\"></a>  dynamic_pointer_cast","source":"<a name=\"dynamic_pointer_cast\"></a>  dynamic_pointer_cast"},{"content":"Dynamic cast to shared_ptr.","pos":[7929,7956]},{"pos":[8086,8096],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type controlled by the returned shared pointer.","pos":[8108,8159]},{"content":"The type controlled by the argument shared pointer.","pos":[8177,8228]},{"content":"The argument shared pointer.","pos":[8243,8271]},{"pos":[8281,8288],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template function returns an empty shared_ptr object if <ph id=\"ph1\">`dynamic_cast&lt;Ty*&gt;(sp.get())`</ph> returns a null pointer; otherwise it returns a <bpt id=\"p1\">[</bpt>shared_ptr Class<ept id=\"p1\">](../standard-library/shared-ptr-class.md)</ept><ph id=\"ph2\">`&lt;Ty&gt;`</ph> object that owns the resource that is owned by <ph id=\"ph3\">`sp`</ph>.","pos":[8292,8547],"source":"The template function returns an empty shared_ptr object if `dynamic_cast<Ty*>(sp.get())` returns a null pointer; otherwise it returns a [shared_ptr Class](../standard-library/shared-ptr-class.md)`<Ty>` object that owns the resource that is owned by `sp`."},{"content":"The expression <ph id=\"ph1\">`dynamic_cast&lt;Ty*&gt;(sp.get())`</ph> must be valid.","pos":[8548,8607],"source":" The expression `dynamic_cast<Ty*>(sp.get())` must be valid."},{"pos":[8617,8624],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9254,9311],"content":"<bpt id=\"p1\">&lt;a name=\"get_deleter_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  get_deleter Function","linkify":"<a name=\"get_deleter_function\"></a>  get_deleter Function","source":"<a name=\"get_deleter_function\"></a>  get_deleter Function"},{"content":"Get deleter from shared_ptr.","pos":[9315,9343]},{"pos":[9441,9451],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type of the deleter.","pos":[9462,9486]},{"content":"The type controlled by the shared pointer.","pos":[9501,9543]},{"content":"The shared pointer.","pos":[9561,9580]},{"pos":[9590,9597],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template function returns a pointer to the deleter of type <ph id=\"ph1\">`D`</ph> that belongs to the <bpt id=\"p1\">[</bpt>shared_ptr Class<ept id=\"p1\">](../standard-library/shared-ptr-class.md)</ept> object <ph id=\"ph2\">`sp`</ph>.","pos":[9601,9760],"source":"The template function returns a pointer to the deleter of type `D` that belongs to the [shared_ptr Class](../standard-library/shared-ptr-class.md) object `sp`."},{"content":"If <ph id=\"ph1\">`sp`</ph> has no deleter or if its deleter is not of type <ph id=\"ph2\">`D`</ph> the function returns 0.","pos":[9761,9844],"source":" If `sp` has no deleter or if its deleter is not of type `D` the function returns 0."},{"pos":[9854,9861],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[10729,10782],"content":"<bpt id=\"p1\">&lt;a name=\"get_pointer_safety\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  get_pointer_safety","linkify":"<a name=\"get_pointer_safety\"></a>  get_pointer_safety","source":"<a name=\"get_pointer_safety\"></a>  get_pointer_safety"},{"content":"Returns the type of pointer safety assumed by any garbage collector.","pos":[10786,10854]},{"pos":[10916,10923],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[10927,11020],"content":"The function returns the type of pointer safety assumed by any automatic <ph id=\"ph1\">`garbage collector`</ph>.","source":"The function returns the type of pointer safety assumed by any automatic `garbage collector`."},{"pos":[11030,11087],"content":"<bpt id=\"p1\">&lt;a name=\"get_temporary_buffer\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  get_temporary_buffer","linkify":"<a name=\"get_temporary_buffer\"></a>  get_temporary_buffer","source":"<a name=\"get_temporary_buffer\"></a>  get_temporary_buffer"},{"content":"Allocates temporary storage for a sequence of elements that does not exceed a specified number of elements.","pos":[11091,11198]},{"pos":[11310,11320],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The maximum number of elements requested for which memory is to be allocated.","pos":[11336,11413]},{"pos":[11423,11435],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[11439,11636],"content":"A <ph id=\"ph1\">`pair`</ph> whose first component is a pointer to the memory that was allocated, and whose second component gives the size of the buffer, indicating the largest number of elements that it could store.","source":"A `pair` whose first component is a pointer to the memory that was allocated, and whose second component gives the size of the buffer, indicating the largest number of elements that it could store."},{"pos":[11646,11653],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The function makes a request for memory and it may not succeed.","pos":[11657,11720]},{"content":"If no buffer is allocated, then the function returns a pair, with the second component equal to zero and the first component equal to the null pointer.","pos":[11721,11872]},{"content":"This function should only be used for memory that is temporary.","pos":[11879,11942]},{"pos":[11952,11959],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[12824,12863],"content":"<bpt id=\"p1\">&lt;a name=\"make_shared\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  make_shared","linkify":"<a name=\"make_shared\"></a>  make_shared","source":"<a name=\"make_shared\"></a>  make_shared"},{"content":"Creates and returns a <ph id=\"ph1\">`shared_ptr`</ph> that points to the allocated objects that are constructed from zero or more arguments by using the default allocator.","pos":[12867,13019],"source":"Creates and returns a `shared_ptr` that points to the allocated objects that are constructed from zero or more arguments by using the default allocator."},{"content":"Allocates and constructs both an object of the specified type and a <ph id=\"ph1\">`shared_ptr`</ph> to manage shared ownership of the object, and returns the <ph id=\"ph2\">`shared_ptr`</ph>.","pos":[13020,13172],"source":" Allocates and constructs both an object of the specified type and a `shared_ptr` to manage shared ownership of the object, and returns the `shared_ptr`."},{"pos":[13292,13302],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[13309,13318]},{"content":"Description","pos":[13319,13330]},{"content":"Zero or more constructor arguments.","pos":[13381,13416]},{"content":"The function infers which constructor overload to invoke based on the arguments that are provided.","pos":[13417,13515]},{"pos":[13526,13533],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Use <ph id=\"ph1\">`make_shared`</ph> as a simple and more efficient way to create an object and a <ph id=\"ph2\">`shared_ptr`</ph> to manage shared access to the object at the same time.","pos":[13537,13684],"source":"Use `make_shared` as a simple and more efficient way to create an object and a `shared_ptr` to manage shared access to the object at the same time."},{"content":"Semantically, these two statements are equivalent:","pos":[13685,13735]},{"content":"However, the first statement makes two allocations, and if the allocation of the <ph id=\"ph1\">`shared_ptr`</ph> fails after the allocation of the <ph id=\"ph2\">`Example`</ph> object has succeeded, then the unnamed <ph id=\"ph3\">`Example`</ph> object is leaked.","pos":[13867,14071],"source":"However, the first statement makes two allocations, and if the allocation of the `shared_ptr` fails after the allocation of the `Example` object has succeeded, then the unnamed `Example` object is leaked."},{"content":"The statement that uses <ph id=\"ph1\">`make_shared`</ph> is simpler because there's only one function call involved.","pos":[14072,14169],"source":" The statement that uses `make_shared` is simpler because there's only one function call involved."},{"content":"It's more efficient because the library can make a single allocation for both the object and the smart pointer.","pos":[14170,14281]},{"content":"This is both faster and leads to less memory fragmentation, and there is no chance of an exception on one allocation but not the other.","pos":[14282,14417]},{"content":"Performance is improved by better locality for code that references the object and updates the reference counts in the smart pointer.","pos":[14418,14551]},{"content":"Consider using <bpt id=\"p1\">[</bpt>make_unique<ept id=\"p1\">](../standard-library/memory-functions.md#make_unique)</ept> if you do not need shared access to the object.","pos":[14558,14687],"source":"Consider using [make_unique](../standard-library/memory-functions.md#make_unique) if you do not need shared access to the object."},{"content":"Use <bpt id=\"p1\">[</bpt>allocate_shared<ept id=\"p1\">](../standard-library/memory-functions.md#allocate_shared)</ept> if you need to specify a custom allocator for the object.","pos":[14688,14824],"source":" Use [allocate_shared](../standard-library/memory-functions.md#allocate_shared) if you need to specify a custom allocator for the object."},{"content":"You can't use <ph id=\"ph1\">`make_shared`</ph> if your object requires a custom deleter, because there is no way to pass the deleter as an argument.","pos":[14825,14954],"source":" You can't use `make_shared` if your object requires a custom deleter, because there is no way to pass the deleter as an argument."},{"content":"The following example shows how to create shared pointers to a type by invoking specific constructor overloads.","pos":[14961,15072]},{"pos":[15082,15089],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The example produces this output:","pos":[16729,16762]},{"pos":[17085,17124],"content":"<bpt id=\"p1\">&lt;a name=\"make_unique\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  make_unique","linkify":"<a name=\"make_unique\"></a>  make_unique","source":"<a name=\"make_unique\"></a>  make_unique"},{"pos":[17128,17294],"content":"Creates and returns a <bpt id=\"p1\">[</bpt>unique_ptr<ept id=\"p1\">](../standard-library/unique-ptr-class.md)</ept> to an object of the specified type, which is constructed by using the specified arguments.","source":"Creates and returns a [unique_ptr](../standard-library/unique-ptr-class.md) to an object of the specified type, which is constructed by using the specified arguments."},{"pos":[17805,17815],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type of the object that the <ph id=\"ph1\">`unique_ptr`</ph> will point to.","pos":[17826,17885],"source":" The type of the object that the `unique_ptr` will point to."},{"content":"The types of the constructor arguments specified by <ph id=\"ph1\">`Args`</ph>.","pos":[17903,17962],"source":" The types of the constructor arguments specified by `Args`."},{"content":"The arguments to be passed to the constructor of the object of type <ph id=\"ph1\">`T`</ph>.","pos":[17979,18051],"source":" The arguments to be passed to the constructor of the object of type `T`."},{"content":"An array of elements of type <ph id=\"ph1\">`T`</ph>.","pos":[18068,18101],"source":" An array of elements of type `T`."},{"content":"The number of elements to allocate space for in the new array.","pos":[18118,18180]},{"pos":[18190,18197],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first overload is used for single objects, the second overload is invoked for arrays, and the third overload prevents the prevents you from specifying an array size in the type argument (make_unique<ph id=\"ph1\">\\&lt;</ph>T[N]&gt;); this construction is not supported by the current standard.","pos":[18201,18472],"source":"The first overload is used for single objects, the second overload is invoked for arrays, and the third overload prevents the prevents you from specifying an array size in the type argument (make_unique\\<T[N]>); this construction is not supported by the current standard."},{"content":"When you use <ph id=\"ph1\">`make_unique`</ph> to create a <ph id=\"ph2\">`unique_ptr`</ph> to an array, you have to initialize the array elements separately.","pos":[18473,18591],"source":" When you use `make_unique` to create a `unique_ptr` to an array, you have to initialize the array elements separately."},{"content":"If you are considering this overload, perhaps a better choice is to use a <bpt id=\"p1\">[</bpt>std::vector<ept id=\"p1\">](../standard-library/vector-class.md)</ept>.","pos":[18592,18717],"source":" If you are considering this overload, perhaps a better choice is to use a [std::vector](../standard-library/vector-class.md)."},{"pos":[18724,18887],"content":"Because <ph id=\"ph1\">`make_unique`</ph> is carefully implemented for exception safety, we recommend that you use <ph id=\"ph2\">`make_unique`</ph> instead of directly calling <ph id=\"ph3\">`unique_ptr`</ph> constructors.","source":"Because `make_unique` is carefully implemented for exception safety, we recommend that you use `make_unique` instead of directly calling `unique_ptr` constructors."},{"pos":[18897,18904],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example shows how to use <ph id=\"ph1\">`make_unique`</ph>.","pos":[18909,18962],"source":"The following example shows how to use `make_unique`."},{"content":"For more examples, see <bpt id=\"p1\">[</bpt>How to: Create and Use unique_ptr Instances<ept id=\"p1\">](../cpp/how-to-create-and-use-unique-ptr-instances.md)</ept>.","pos":[18963,19086],"source":" For more examples, see [How to: Create and Use unique_ptr Instances](../cpp/how-to-create-and-use-unique-ptr-instances.md)."},{"pos":[19093,19175],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>stl_smart_pointers#214<ept id=\"p2\">](../cpp/codesnippet/CPP/memory-functions_1.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[stl_smart_pointers#214](../cpp/codesnippet/CPP/memory-functions_1.cpp)]"},{"pos":[19183,19353],"content":"When you see error C2280 in connection with a <ph id=\"ph1\">`unique_ptr`</ph>, it is almost certainly because you are attempting to invoke its copy constructor, which is a deleted function.","source":"When you see error C2280 in connection with a `unique_ptr`, it is almost certainly because you are attempting to invoke its copy constructor, which is a deleted function."},{"pos":[19363,19400],"content":"<bpt id=\"p1\">&lt;a name=\"owner_less\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  owner_less","linkify":"<a name=\"owner_less\"></a>  owner_less","source":"<a name=\"owner_less\"></a>  owner_less"},{"content":"Allows ownership-based mixed comparisons of shared and weak pointers.","pos":[19404,19473]},{"content":"Returns <ph id=\"ph1\">`true`</ph> if the left parameter is ordered before right parameter by the member function <ph id=\"ph2\">`owner_before`</ph>.","pos":[19474,19583],"source":" Returns `true` if the left parameter is ordered before right parameter by the member function `owner_before`."},{"pos":[20356,20366],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A shared or weak pointer.","pos":[20381,20406]},{"content":"A shared or weak pointer.","pos":[20425,20450]},{"pos":[20460,20467],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[20471,20574],"content":"The template classes define all their member operators as returning <ph id=\"ph1\">` left``.owner_before(`` right``)`</ph>.","source":"The template classes define all their member operators as returning ` left``.owner_before(`` right``)`."},{"pos":[20584,20647],"content":"<bpt id=\"p1\">&lt;a name=\"return_temporary_buffer\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  return_temporary_buffer","linkify":"<a name=\"return_temporary_buffer\"></a>  return_temporary_buffer","source":"<a name=\"return_temporary_buffer\"></a>  return_temporary_buffer"},{"pos":[20651,20754],"content":"Deallocates the temporary memory that was allocated using the <ph id=\"ph1\">`get_temporary_buffer`</ph> template function.","source":"Deallocates the temporary memory that was allocated using the `get_temporary_buffer` template function."},{"pos":[20846,20856],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">*</bpt>_Pbuf<ept id=\"p1\">*</ept>","pos":[20860,20867],"source":"*_Pbuf*"},{"content":"A pointer to the memory to be deallocated.","pos":[20871,20913]},{"pos":[20923,20930],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This function should only be used for memory that is temporary.","pos":[20934,20997]},{"pos":[21007,21014],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[22029,22084],"content":"<bpt id=\"p1\">&lt;a name=\"static_pointer_cast\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  static_pointer_cast","linkify":"<a name=\"static_pointer_cast\"></a>  static_pointer_cast","source":"<a name=\"static_pointer_cast\"></a>  static_pointer_cast"},{"content":"Static cast to shared_ptr.","pos":[22088,22114]},{"pos":[22241,22251],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type controlled by the returned shared pointer.","pos":[22263,22314]},{"content":"The type controlled by the argument shared pointer.","pos":[22332,22383]},{"content":"The argument shared pointer.","pos":[22401,22429]},{"pos":[22439,22446],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template function returns an empty shared_ptr object if <ph id=\"ph1\">`sp`</ph> is an empty <ph id=\"ph2\">`shared_ptr`</ph> object; otherwise it returns a <bpt id=\"p1\">[</bpt>shared_ptr Class<ept id=\"p1\">](../standard-library/shared-ptr-class.md)</ept><ph id=\"ph3\">`&lt;Ty&gt;`</ph> object that owns the resource that is owned by <ph id=\"ph4\">`sp`</ph>.","pos":[22450,22689],"source":"The template function returns an empty shared_ptr object if `sp` is an empty `shared_ptr` object; otherwise it returns a [shared_ptr Class](../standard-library/shared-ptr-class.md)`<Ty>` object that owns the resource that is owned by `sp`."},{"content":"The expression <ph id=\"ph1\">`static_cast&lt;Ty*&gt;(sp.get())`</ph> must be valid.","pos":[22690,22748],"source":" The expression `static_cast<Ty*>(sp.get())` must be valid."},{"pos":[22758,22765],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[23341,23389],"content":"<bpt id=\"p1\">&lt;a name=\"swap\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  swap (C++ Standard Library)","linkify":"<a name=\"swap\"></a>  swap (C++ Standard Library)","source":"<a name=\"swap\"></a>  swap (C++ Standard Library)"},{"content":"Swap two shared_ptr or weak_ptr objects.","pos":[23393,23433]},{"pos":[23643,23653],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type controlled by the left shared/weak pointer.","pos":[23665,23717]},{"content":"The type controlled by the right shared/weak pointer.","pos":[23735,23788]},{"content":"The left shared/weak pointer.","pos":[23805,23834]},{"content":"The right shared/weak pointer.","pos":[23852,23882]},{"pos":[23892,23899],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[23903,23950],"content":"The template functions call <ph id=\"ph1\">`left.swap(right)`</ph>.","source":"The template functions call `left.swap(right)`."},{"pos":[23960,23967],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[24893,24952],"content":"<bpt id=\"p1\">&lt;a name=\"undeclare_no_pointers\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  undeclare_no_pointers","linkify":"<a name=\"undeclare_no_pointers\"></a>  undeclare_no_pointers","source":"<a name=\"undeclare_no_pointers\"></a>  undeclare_no_pointers"},{"content":"Informs a garbage collector that the characters in the memory block defined by a base address pointer and block size may now contain traceable pointers.","pos":[24956,25108]},{"pos":[25198,25205],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[25209,25354],"content":"The function informs any <ph id=\"ph1\">`garbage collector`</ph> that the range of addresses <ph id=\"ph2\">`[`` ptr``,`</ph> <ph id=\"ph3\">` ptr`</ph> <ph id=\"ph4\">`+`</ph> <ph id=\"ph5\">`_Size``)`</ph> may now contain <ph id=\"ph6\">`traceable pointers`</ph>.","source":"The function informs any `garbage collector` that the range of addresses `[`` ptr``,` ` ptr` `+` `_Size``)` may now contain `traceable pointers`."},{"pos":[25364,25419],"content":"<bpt id=\"p1\">&lt;a name=\"undeclare_reachable\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  undeclare_reachable","linkify":"<a name=\"undeclare_reachable\"></a>  undeclare_reachable","source":"<a name=\"undeclare_reachable\"></a>  undeclare_reachable"},{"pos":[25423,25503],"content":"Informs a <ph id=\"ph1\">`garbage_collector`</ph> that a specified memory location is not reachable.","source":"Informs a `garbage_collector` that a specified memory location is not reachable."},{"pos":[25590,25600],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Parameter","pos":[25607,25616]},{"content":"Description","pos":[25617,25628]},{"content":"A pointer to the memory address to be declared not reachable.","pos":[25678,25739]},{"pos":[25750,25757],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If <ph id=\"ph1\">` ptr`</ph> is not <ph id=\"ph2\">`null`</ph>, the function informs any <ph id=\"ph3\">`garbage collector`</ph> that <ph id=\"ph4\">` ptr`</ph> is hereafter not <ph id=\"ph5\">`reachable`</ph>.","pos":[25761,25872],"source":"If ` ptr` is not `null`, the function informs any `garbage collector` that ` ptr` is hereafter not `reachable`."},{"content":"It returns a <ph id=\"ph1\">`safely derived`</ph> pointer that compares equal to <ph id=\"ph2\">` ptr`</ph>.","pos":[25873,25941],"source":" It returns a `safely derived` pointer that compares equal to ` ptr`."},{"pos":[25951,26004],"content":"<bpt id=\"p1\">&lt;a name=\"uninitialized_copy\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  uninitialized_copy","linkify":"<a name=\"uninitialized_copy\"></a>  uninitialized_copy","source":"<a name=\"uninitialized_copy\"></a>  uninitialized_copy"},{"content":"Copies objects from a specified source range into an uninitialized destination range.","pos":[26008,26093]},{"pos":[26273,26283],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An input iterator addressing the first element in the source range.","pos":[26299,26366]},{"content":"An input iterator addressing the last element in the source range.","pos":[26384,26450]},{"content":"A forward iterator addressing the first element in the destination range.","pos":[26468,26541]},{"pos":[26551,26563],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[26567,26712],"content":"A forward iterator addressing the first position beyond the destination range, unless the source range was empty and iterator addresses <bpt id=\"p1\">*</bpt> first.<ept id=\"p1\">*</ept>","source":"A forward iterator addressing the first position beyond the destination range, unless the source range was empty and iterator addresses * first.*"},{"pos":[26722,26729],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This algorithm allows the decoupling of memory allocation from object construction.","pos":[26733,26816]},{"content":"The template function effectively executes:","pos":[26823,26866]},{"content":"unless the code throws an exception.","pos":[27019,27055]},{"content":"In that case, all constructed objects are destroyed and the exception is rethrown.","pos":[27056,27138]},{"pos":[27148,27155],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[28920,28977],"content":"<bpt id=\"p1\">&lt;a name=\"uninitialized_copy_n\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  uninitialized_copy_n","linkify":"<a name=\"uninitialized_copy_n\"></a>  uninitialized_copy_n","source":"<a name=\"uninitialized_copy_n\"></a>  uninitialized_copy_n"},{"content":"Creates a copy of a specified number of elements from an input iterator.","pos":[28981,29053]},{"content":"The copies are put in a forward iterator.","pos":[29054,29095]},{"pos":[29299,29309],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An input iterator that refers to the object to copy.","pos":[29325,29377]},{"content":"A signed or unsigned integer type specifying the number of times to copy the object.","pos":[29396,29480]},{"content":"A forward iterator that refers to where the new copies go.","pos":[29498,29556]},{"pos":[29566,29578],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"A forward iterator that addresses the first position beyond the destination.","pos":[29582,29658]},{"content":"If the source range was empty, the iterator addresses <ph id=\"ph1\">` first`</ph><bpt id=\"p1\">*</bpt>.<ept id=\"p1\">*</ept>","pos":[29659,29724],"source":" If the source range was empty, the iterator addresses ` first`*.*"},{"pos":[29734,29741],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template function effectively executes the following:","pos":[29745,29802]},{"pos":[29845,29876],"content":"<ph id=\"ph1\">`new ((void *)&amp;*`</ph> <ph id=\"ph2\">` dest`</ph> <ph id=\"ph3\">`++)`</ph>","source":"`new ((void *)&*` ` dest` `++)`"},{"pos":[29883,29945],"content":"<ph id=\"ph1\">`iterator_traits&lt;InputIterator&gt;::value_type(*`</ph> <ph id=\"ph2\">` first`</ph> <ph id=\"ph3\">`++);`</ph>","source":"`iterator_traits<InputIterator>::value_type(*` ` first` `++);`"},{"content":"unless the code throws an exception.","pos":[29973,30009]},{"content":"In that case, all constructed objects are destroyed and the exception is rethrown.","pos":[30010,30092]},{"pos":[30102,30155],"content":"<bpt id=\"p1\">&lt;a name=\"uninitialized_fill\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  uninitialized_fill","linkify":"<a name=\"uninitialized_fill\"></a>  uninitialized_fill","source":"<a name=\"uninitialized_fill\"></a>  uninitialized_fill"},{"content":"Copies objects of a specified value into an uninitialized destination range.","pos":[30159,30235]},{"pos":[30394,30404],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A forward iterator addressing the first element in the destination range that is to be initiated.","pos":[30420,30517]},{"content":"A forward iterator addressing the last element in the destination range that is to be initiated.","pos":[30535,30631]},{"content":"The value to be used to initialize the destination range.","pos":[30648,30705]},{"pos":[30715,30722],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This algorithm allows the decoupling of memory allocation from object construction.","pos":[30726,30809]},{"content":"The template function effectively executes:","pos":[30816,30859]},{"content":"unless the code throws an exception.","pos":[30993,31029]},{"content":"In that case, all constructed objects are destroyed and the exception is rethrown.","pos":[31030,31112]},{"pos":[31122,31129],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[31916,31973],"content":"<bpt id=\"p1\">&lt;a name=\"uninitialized_fill_n\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  uninitialized_fill_n","linkify":"<a name=\"uninitialized_fill_n\"></a>  uninitialized_fill_n","source":"<a name=\"uninitialized_fill_n\"></a>  uninitialized_fill_n"},{"content":"Copies objects of a specified value into specified number of elements into an uninitialized destination range.","pos":[31977,32087]},{"pos":[32240,32250],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A forward iterator addressing the first element in the destination range to be initiated.","pos":[32266,32355]},{"content":"The number of elements to be initialized.","pos":[32374,32415]},{"content":"The value to be used to initialize the destination range.","pos":[32432,32489]},{"pos":[32499,32506],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This algorithm allows the decoupling of memory allocation from object construction.","pos":[32510,32593]},{"content":"The template function effectively executes:","pos":[32600,32643]},{"content":"unless the code throws an exception.","pos":[32775,32811]},{"content":"In that case, all constructed objects are destroyed and the exception is rethrown.","pos":[32812,32894]},{"pos":[32904,32911],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[33549,33557],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[33561,33603],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>memory&gt;<ept id=\"p1\">](../standard-library/memory.md)</ept>","source":"[\\<memory>](../standard-library/memory.md)"}],"content":"---\ntitle: \"&lt;memory&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 3e1898c2-44b7-4626-87ce-84962e4c6f1a\ncaps.latest.revision: 12\nmanager: \"ghogen\"\n---\n# &lt;memory&gt; functions\n||||  \n|-|-|-|  \n|[addressof](#addressof)|[align](#align)|[allocate_shared](#allocate_shared)|  \n|[const_pointer_cast](#const_pointer_cast)|[declare_no_pointers](#declare_no_pointers)|[declare_reachable](#declare_reachable)|  \n|[default_delete](#default_delete)|[dynamic_pointer_cast](#dynamic_pointer_cast)|[get_deleter Function](#get_deleter_function)|  \n|[get_pointer_safety](#get_pointer_safety)|[get_temporary_buffer](#get_temporary_buffer)|[make_shared](#make_shared)|  \n|[make_unique](#make_unique)|[owner_less](#owner_less)|[return_temporary_buffer](#return_temporary_buffer)|  \n|[static_pointer_cast](#static_pointer_cast)|[swap (C++ Standard Library)](#swap)|[undeclare_no_pointers](#undeclare_no_pointers)|  \n|[undeclare_reachable](#undeclare_reachable)|[uninitialized_copy](#uninitialized_copy)|[uninitialized_copy_n](#uninitialized_copy_n)|  \n|[uninitialized_fill](#uninitialized_fill)|[uninitialized_fill_n](#uninitialized_fill_n)|  \n  \n##  <a name=\"addressof\"></a>  addressof  \n Gets the true address of an object.  \n  \n```  \ntemplate <class T>  \nT* addressof(T& Val);\n```  \n  \n### Parameters  \n `Val`  \n The object or function for which to obtain the true address.  \n  \n### Return Value  \n The actual address of the object or function referenced by `Val`, even if an overloaded `operator&()` exists.  \n  \n### Remarks  \n  \n##  <a name=\"align\"></a>  align  \n Fits storage of the given size—aligned by the given alignment specification—into the first possible address of the given storage.  \n  \n```  \nvoid* align(\n    size_t Alignment, // input  \n    size_t Size,   // input  \n    void*& Ptr        // input/output  \n    size_t& Space     // input/output);\n```  \n  \n### Parameters  \n `Alignment`  \n The alignment bound to attempt.  \n  \n `Size`  \n The size in bytes for the aligned storage.  \n  \n `Ptr`  \n The starting address of the available contiguous storage pool to use. This parameter is also an output parameter, and will contain the new starting address if the alignment is successful.  \n  \n If `align()` is unsuccessful, this parameter is not modified.  \n  \n `Space`  \n The total space available to `align()` to use in creating the aligned storage. This parameter is also an output parameter, and contains the adjusted space left in the storage buffer after the aligned storage and any associated overhead is subtracted.  \n  \n If `align()` is unsuccessful, this parameter is not modified.  \n  \n### Return Value  \n A null pointer if the requested aligned buffer would not fit into the available space; otherwise, the new value of `Ptr`.  \n  \n### Remarks  \n The modified `Ptr` and `Space` parameters enable you to call `align()` repeatedly on the same buffer, possibly with different values for `Alignment` and `Size`. The following code snippet shows one use of `align()`.  \n  \n```cpp  \n  \n#include <type_traits> // std::alignment_of()  \n#include <memory>  \n//...  \nchar buffer[256]; // for simplicity  \nsize_t alignment = std::alignment_of<int>::value;  \nvoid * ptr = buffer;  \nstd::size_t space = sizeof(buffer); // Be sure this results in the true size of your buffer  \n  \nwhile (alignment, sizeof(MyObj), ptr, space)) {  \n    // You now have storage the size of MyObj, starting at ptr, aligned on   \n    // int boundary. Use it here if you like, or save off the starting address  \n    // contained in ptr for later use.  \n    // ...  \n    // Last, move starting pointer and decrease available space before  \n    // the while loop restarts.  \n    ptr = reinterpret_cast<char*>(ptr) + sizeof(MyObj);  \n    space -= sizeof(MyObj);  \n}  \n// At this point, align() has returned a null pointer, signaling it is not  \n// possible to allow more aligned storage in this buffer.   \n```  \n  \n##  <a name=\"allocate_shared\"></a>  allocate_shared  \n Creates a `shared_ptr` to objects that are allocated and constructed for a given type by using a specified allocator. Returns the `shared_ptr`.  \n  \n```  \ntemplate <class Type, class Allocator, class... Types>  \nshared_ptr<Type>  \nallocate_shared(Allocator Alloc, Types&&... Args);\n```  \n  \n### Parameters  \n `Alloc`  \n The allocator used to create objects.  \n  \n `Args`  \n The zero or more arguments that become the objects.  \n  \n### Remarks  \n The function creates the object `shared_ptr``<Type>`, a pointer to `Type(``Args``...)` as allocated and constructed by `Alloc`.  \n  \n##  <a name=\"const_pointer_cast\"></a>  const_pointer_cast  \n Const cast to shared_ptr.  \n  \n```  \ntemplate <class Ty, class Other>  \nshared_ptr<Ty>  \nconst_pointer_cast(const shared_ptr<Other>& sp);\n```  \n  \n### Parameters  \n `Ty`  \n The type controlled by the returned shared pointer.  \n  \n `Other`  \n The type controlled by the argument shared pointer.  \n  \n `Other`  \n The argument shared pointer.  \n  \n### Remarks  \n The template function returns an empty shared_ptr object if `const_cast<Ty*>(sp.get())` returns a null pointer; otherwise it returns a [shared_ptr Class](../standard-library/shared-ptr-class.md)`<Ty>` object that owns the resource that is owned by `sp`. The expression `const_cast<Ty*>(sp.get())` must be valid.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__const_pointer_cast.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::shared_ptr<int> sp0(new int);   \n    std::shared_ptr<const int> sp1 =   \n        std::const_pointer_cast<const int>(sp0);   \n  \n *sp0 = 3;   \n    std::cout << \"sp1 == \" << *sp1 << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsp1 == 3  \n```  \n  \n##  <a name=\"declare_no_pointers\"></a>  declare_no_pointers  \n Informs a garbage collector that the characters in the memory block defined by a base address pointer and block size contains no traceable pointers.  \n  \n```  \nvoid declare_no_pointers(\n    char* ptr,   \n    size_t _Size);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|` ptr`|Address of first character that no longer contains traceable pointers.|  \n|`_Size`|Size of block that starts at ` ptr` that contains no traceable pointers.|  \n  \n### Remarks  \n The function informs any `garbage collector` that the range of addresses `[`` ptr``,` ` ptr` `+` `_Size``)` no longer contain traceable pointers. (Any pointers to allocated storage must not be dereferenced unless made `reachable`.)  \n  \n##  <a name=\"declare_reachable\"></a>  declare_reachable  \n Informs garbage collection that the indicated address is to allocated storage and is reachable.  \n  \n```  \nvoid declare_reachable(void* ptr);\n```  \n  \n### Parameters  \n ` ptr`  \n A pointer to a reachable, allocated, valid storage area.  \n  \n### Remarks  \n If ` ptr` is not null, the function informs any garbage collector that ` ptr` is hereafter reachable (points to valid allocated storage).  \n  \n##  <a name=\"default_delete\"></a>  default_delete  \n Deletes objects allocated with `operator new`. Suitable for use with `unique_ptr`.  \n```  \nstruct default_delete {\n   constexpr default_delete() noexcept = default;\n   template <class Other, class = typename enable_if<is_convertible<Other*, T*>::value, void>::type>>  \n   default_delete(const default_delete<Other>&) noexcept;\n   void operator()(T* Ptr) const noexcept;     };  \n```\n### Parameters  \n `Ptr`  \n Pointer to the object to delete.  \n  \n Other  \n The type of elements in the array to be deleted.  \n  \n### Remarks  \n The template class describes a `deleter` that deletes scalar objects allocated with `operator new`, suitable for use with template class `unique_ptr`. It also has the explicit specialization `default_delete<Type[]>`.  \n  \n##  <a name=\"dynamic_pointer_cast\"></a>  dynamic_pointer_cast  \n Dynamic cast to shared_ptr.  \n  \n```  \ntemplate <class Ty, class Other>  \nshared_ptr<Ty>  \ndynamic_pointer_cast(const shared_ptr`<`Other>& sp);\n```  \n  \n### Parameters  \n `Ty`  \n The type controlled by the returned shared pointer.  \n  \n `Other`  \n The type controlled by the argument shared pointer.  \n  \n `sp`  \n The argument shared pointer.  \n  \n### Remarks  \n The template function returns an empty shared_ptr object if `dynamic_cast<Ty*>(sp.get())` returns a null pointer; otherwise it returns a [shared_ptr Class](../standard-library/shared-ptr-class.md)`<Ty>` object that owns the resource that is owned by `sp`. The expression `dynamic_cast<Ty*>(sp.get())` must be valid.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__dynamic_pointer_cast.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nstruct base   \n    {   \n    virtual ~base()   \n        {   \n        }   \n  \n    int val;   \n    };   \n  \nstruct derived   \n    : public base   \n    {   \n    };   \n  \nint main()   \n    {   \n    std::shared_ptr<base> sp0(new derived);   \n    std::shared_ptr<derived> sp1 =   \n        std::dynamic_pointer_cast<derived>(sp0);   \n  \n    sp0->val = 3;   \n    std::cout << \"sp1->val == \" << sp1->val << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsp1->val == 3  \n```  \n  \n##  <a name=\"get_deleter_function\"></a>  get_deleter Function  \n Get deleter from shared_ptr.  \n  \n```  \ntemplate <class D, class Ty>  \nD *get_deleter(const shared_ptr<Ty>& sp);\n```  \n  \n### Parameters  \n `D`  \n The type of the deleter.  \n  \n `Ty`  \n The type controlled by the shared pointer.  \n  \n `Other`  \n The shared pointer.  \n  \n### Remarks  \n The template function returns a pointer to the deleter of type `D` that belongs to the [shared_ptr Class](../standard-library/shared-ptr-class.md) object `sp`. If `sp` has no deleter or if its deleter is not of type `D` the function returns 0.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__get_deleter.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nstruct base   \n    {   \n    int val;   \n    };   \n  \nstruct deleter   \n    {   \n    void operator()(base *p)   \n        {   \n        delete p;   \n        }   \n    };   \n  \nint main()   \n    {   \n    std::shared_ptr<base> sp0(new base);   \n  \n    sp0->val = 3;   \n    std::cout << \"get_deleter(sp0) != 0 == \" << std::boolalpha   \n        << (std::get_deleter<deleter>(sp0) != 0) << std::endl;   \n  \n    std::shared_ptr<base> sp1(new base, deleter());   \n  \n    sp0->val = 3;   \n    std::cout << \"get_deleter(sp1) != 0 == \" << std::boolalpha   \n        << (std::get_deleter<deleter>(sp1) != 0) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nget_deleter(sp0) != 0 == false  \nget_deleter(sp1) != 0 == true  \n```  \n  \n##  <a name=\"get_pointer_safety\"></a>  get_pointer_safety  \n Returns the type of pointer safety assumed by any garbage collector.  \n  \n```  \npointer_safety get_pointer_safety();\n```  \n  \n### Remarks  \n The function returns the type of pointer safety assumed by any automatic `garbage collector`.  \n  \n##  <a name=\"get_temporary_buffer\"></a>  get_temporary_buffer  \n Allocates temporary storage for a sequence of elements that does not exceed a specified number of elements.  \n  \n```  \ntemplate <class Type>  \npair<Type *, ptrdiff_t> get_temporary_buffer(ptrdiff_t count);\n```  \n  \n### Parameters  \n ` count`  \n The maximum number of elements requested for which memory is to be allocated.  \n  \n### Return Value  \n A `pair` whose first component is a pointer to the memory that was allocated, and whose second component gives the size of the buffer, indicating the largest number of elements that it could store.  \n  \n### Remarks  \n The function makes a request for memory and it may not succeed. If no buffer is allocated, then the function returns a pair, with the second component equal to zero and the first component equal to the null pointer.  \n  \n This function should only be used for memory that is temporary.  \n  \n### Example  \n  \n```cpp  \n// memory_get_temp_buf.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   // Create an array of ints  \n   int intArray [ ] = { 10, 20, 30, 40, 100, 200, 300, 1000, 2000 };  \n   int count = sizeof ( intArray ) / sizeof ( int );  \n   cout << \"The number of integers in the array is: \"   \n      << count << \".\" << endl;  \n  \n   pair<int *, ptrdiff_t> resultPair;  \n   resultPair = get_temporary_buffer<int>( count );  \n  \n   cout << \"The number of elements that the allocated memory\\n\"  \n        << \"could store is given by: resultPair.second = \"   \n        << resultPair.second << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe number of integers in the array is: 9.  \nThe number of elements that the allocated memory  \ncould store is given by: resultPair.second = 9.  \n```  \n  \n##  <a name=\"make_shared\"></a>  make_shared  \n Creates and returns a `shared_ptr` that points to the allocated objects that are constructed from zero or more arguments by using the default allocator. Allocates and constructs both an object of the specified type and a `shared_ptr` to manage shared ownership of the object, and returns the `shared_ptr`.  \n  \n```  \ntemplate <class Type, class... Types>  \nshared_ptr<Type>  \nmake_shared(\n    Types&&... _Args);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|`_Args`|Zero or more constructor arguments. The function infers which constructor overload to invoke based on the arguments that are provided.|  \n  \n### Remarks  \n Use `make_shared` as a simple and more efficient way to create an object and a `shared_ptr` to manage shared access to the object at the same time. Semantically, these two statements are equivalent:  \n  \n```cpp  \nauto sp = std::shared_ptr<Example>(new Example(argument));\nauto msp = std::make_shared<Example>(argument);\n```  \n  \n However, the first statement makes two allocations, and if the allocation of the `shared_ptr` fails after the allocation of the `Example` object has succeeded, then the unnamed `Example` object is leaked. The statement that uses `make_shared` is simpler because there's only one function call involved. It's more efficient because the library can make a single allocation for both the object and the smart pointer. This is both faster and leads to less memory fragmentation, and there is no chance of an exception on one allocation but not the other. Performance is improved by better locality for code that references the object and updates the reference counts in the smart pointer.  \n  \n Consider using [make_unique](../standard-library/memory-functions.md#make_unique) if you do not need shared access to the object. Use [allocate_shared](../standard-library/memory-functions.md#allocate_shared) if you need to specify a custom allocator for the object. You can't use `make_shared` if your object requires a custom deleter, because there is no way to pass the deleter as an argument.  \n  \n The following example shows how to create shared pointers to a type by invoking specific constructor overloads.  \n  \n### Example  \n  \n```cpp  \n// stl_make_shared.cpp  \n// Compile by using: cl /W4 /EHsc stl_make_shared.cpp  \n#include <iostream>  \n#include <string>  \n#include <memory>  \n#include <vector>  \n  \nclass Song {  \npublic:  \n   std::wstring title_;  \n   std::wstring artist_;  \n  \n   Song(std::wstring title, std::wstring artist) : title_(title), artist_(artist) {}  \n   Song(std::wstring title) : title_(title), artist_(L\"Unknown\") {}  \n};  \n  \nvoid CreateSharedPointers() {  \n   // Okay, but less efficient to have separate allocations for  \n   // Song object and shared_ptr control block.    \n   auto song = new Song(L\"Ode to Joy\", L\"Beethoven\");  \n   std::shared_ptr<Song> sp0(song);  \n  \n   // Use make_shared function when possible. Memory for control block  \n   // and Song object are allocated in the same call:    \n   auto sp1 = std::make_shared<Song>(L\"Yesterday\", L\"The Beatles\");  \n   auto sp2 = std::make_shared<Song>(L\"Blackbird\", L\"The Beatles\");  \n  \n   // make_shared infers which constructor to use based on the arguments.  \n   auto sp3 = std::make_shared<Song>(L\"Greensleeves\");  \n  \n   // The playlist vector makes copies of the shared_ptr pointers.  \n   std::vector<std::shared_ptr<Song>> playlist;  \n   playlist.push_back(sp0);  \n   playlist.push_back(sp1);  \n   playlist.push_back(sp2);  \n   playlist.push_back(sp3);  \n   playlist.push_back(sp1);  \n   playlist.push_back(sp2);  \n   for (auto&& sp : playlist) {  \n      std::wcout << L\"Playing \" << sp->title_ <<   \n         L\" by \" << sp->artist_ << L\", use count: \" <<   \n         sp.use_count() << std::endl;  \n   }  \n}  \n  \nint main() {  \n   CreateSharedPointers();  \n}  \n```  \n  \n  The example produces this output:  \n  \n```Output  \nPlaying Ode to Joy by Beethoven, use count: 2  \nPlaying Yesterday by The Beatles, use count: 3  \nPlaying Blackbird by The Beatles, use count: 3  \nPlaying Greensleeves by Unknown, use count: 2  \nPlaying Yesterday by The Beatles, use count: 3  \nPlaying Blackbird by The Beatles, use count: 3  \n```  \n  \n##  <a name=\"make_unique\"></a>  make_unique  \n Creates and returns a [unique_ptr](../standard-library/unique-ptr-class.md) to an object of the specified type, which is constructed by using the specified arguments.  \n  \n```scr  \n// make_unique<T>template <class T,   \n    class... Types>  \nunique_ptr<T> make_unique(Types&&... Args)  \n {  \n    return (unique_ptr<T>(new T(forward<Types>(Args)...)));\n\n }  \n// make_unique<T[]>  \ntemplate <class T>  \nmake_unique(size_t Size)   \n {   \n    return (unique_ptr<T>(new Elem[Size]()));\n\n }  \n \n// make_unique<T[N]> disallowed  \ntemplate <class T,   \n    class... Types>  \ntypename enable_if<extent<T>::value != 0,   \n    void>::type make_unique(Types&&...) = delete;  \n```  \n  \n### Parameters  \n `T`  \n The type of the object that the `unique_ptr` will point to.  \n  \n `Types`  \n The types of the constructor arguments specified by `Args`.  \n  \n `Args`  \n The arguments to be passed to the constructor of the object of type `T`.  \n  \n `Elem`  \n An array of elements of type `T`.  \n  \n `Size`  \n The number of elements to allocate space for in the new array.  \n  \n### Remarks  \n The first overload is used for single objects, the second overload is invoked for arrays, and the third overload prevents the prevents you from specifying an array size in the type argument (make_unique\\<T[N]>); this construction is not supported by the current standard. When you use `make_unique` to create a `unique_ptr` to an array, you have to initialize the array elements separately. If you are considering this overload, perhaps a better choice is to use a [std::vector](../standard-library/vector-class.md).  \n  \n Because `make_unique` is carefully implemented for exception safety, we recommend that you use `make_unique` instead of directly calling `unique_ptr` constructors.  \n  \n### Example  \n  The following example shows how to use `make_unique`. For more examples, see [How to: Create and Use unique_ptr Instances](../cpp/how-to-create-and-use-unique-ptr-instances.md).  \n  \n [!code-cpp[stl_smart_pointers#214](../cpp/codesnippet/CPP/memory-functions_1.cpp)]  \n  \n  When you see error C2280 in connection with a `unique_ptr`, it is almost certainly because you are attempting to invoke its copy constructor, which is a deleted function.  \n  \n##  <a name=\"owner_less\"></a>  owner_less  \n Allows ownership-based mixed comparisons of shared and weak pointers. Returns `true` if the left parameter is ordered before right parameter by the member function `owner_before`.  \n  \n```  \ntemplate <class Type>  \nstruct owner_less; // not defined  \n \ntemplate <class Type>  \nstruct owner_less<shared_ptr<Type>> {  \n    bool operator()(\n    const shared_ptr<Type>& left,  \n    const shared_ptr<Type>& right);\n\n    bool operator()(\n    const shared_ptr<Type>& left,  \n    const weak_ptr<Type>& right);\n\n    bool operator()(\n    const weak_ptr<Type>& left,  \n    const shared_ptr<Type>& right);\n\n};  \n \ntemplate <class Type>  \nstruct owner_less<weak_ptr<Type>>  \n    bool operator()(\n    const weak_ptr<Type>& left,  \n    const weak_ptr<Type>& right);\n\n    bool operator()(\n    const weak_ptr<Type>& left,  \n    const shared_ptr<Ty>& right);\n\n    bool operator()(\n    const shared_ptr<Type>& left,  \n    const weak_ptr<Type>& right);\n\n};  \n```  \n  \n### Parameters  \n `_left`  \n A shared or weak pointer.  \n  \n ` right`  \n A shared or weak pointer.  \n  \n### Remarks  \n The template classes define all their member operators as returning ` left``.owner_before(`` right``)`.  \n  \n##  <a name=\"return_temporary_buffer\"></a>  return_temporary_buffer  \n Deallocates the temporary memory that was allocated using the `get_temporary_buffer` template function.  \n  \n```  \ntemplate <class Type>  \nvoid return_temporary_buffer(Type* _Pbuf);\n```  \n  \n### Parameters  \n *_Pbuf*  \n A pointer to the memory to be deallocated.  \n  \n### Remarks  \n This function should only be used for memory that is temporary.  \n  \n### Example  \n  \n```cpp  \n// memory_ret_temp_buf.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   // Create an array of ints  \n   int intArray [ ] = { 10, 20, 30, 40, 100, 200, 300 };  \n   int count = sizeof ( intArray ) / sizeof ( int );  \n   cout << \"The number of integers in the array is: \"   \n         << count << \".\" << endl;  \n  \n   pair<int *, ptrdiff_t> resultPair;  \n   resultPair = get_temporary_buffer<int>( count );  \n  \n   cout << \"The number of elements that the allocated memory\\n\"  \n         << \" could store is given by: resultPair.second = \"   \n         << resultPair.second << \".\" << endl;  \n  \n   int* tempBuffer = resultPair.first;  \n  \n   // Deallocates memory allocated with get_temporary_buffer  \n   return_temporary_buffer ( tempBuffer );  \n}  \n```  \n  \n```Output  \nThe number of integers in the array is: 7.  \nThe number of elements that the allocated memory  \n could store is given by: resultPair.second = 7.  \n```  \n  \n##  <a name=\"static_pointer_cast\"></a>  static_pointer_cast  \n Static cast to shared_ptr.  \n  \n```  \ntemplate <class Ty, class Other>  \nshared_ptr<Ty>  \nstatic_pointer_cast(const shared_ptr<Other>& sp);\n```  \n  \n### Parameters  \n `Ty`  \n The type controlled by the returned shared pointer.  \n  \n `Other`  \n The type controlled by the argument shared pointer.  \n  \n `Other`  \n The argument shared pointer.  \n  \n### Remarks  \n The template function returns an empty shared_ptr object if `sp` is an empty `shared_ptr` object; otherwise it returns a [shared_ptr Class](../standard-library/shared-ptr-class.md)`<Ty>` object that owns the resource that is owned by `sp`. The expression `static_cast<Ty*>(sp.get())` must be valid.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__static_pointer_cast.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nstruct base   \n    {   \n    int val;   \n    };   \n  \nstruct derived   \n    : public base   \n    {   \n    };   \n  \nint main()   \n    {   \n    std::shared_ptr<base> sp0(new derived);   \n    std::shared_ptr<derived> sp1 =   \n        std::static_pointer_cast<derived>(sp0);   \n  \n    sp0->val = 3;   \n    std::cout << \"sp1->val == \" << sp1->val << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsp1->val == 3  \n```  \n  \n##  <a name=\"swap\"></a>  swap (C++ Standard Library)  \n Swap two shared_ptr or weak_ptr objects.  \n  \n```  \ntemplate <class Ty, class Other>  \nvoid swap(shared_ptr<Ty>& left, shared_ptr<Other>& right);\n\ntemplate <class Ty, class Other>  \nvoid swap(weak_ptr<Ty>& left, weak_ptr<Other>& right);\n```  \n  \n### Parameters  \n `Ty`  \n The type controlled by the left shared/weak pointer.  \n  \n `Other`  \n The type controlled by the right shared/weak pointer.  \n  \n `left`  \n The left shared/weak pointer.  \n  \n `right`  \n The right shared/weak pointer.  \n  \n### Remarks  \n The template functions call `left.swap(right)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__memory__swap.cpp   \n// compile with: /EHsc   \n#include <memory>   \n#include <iostream>   \n  \nstruct deleter\n{\n    void operator()(int *p)\n    {\n        delete p;\n    }\n};\n\nint main()\n{\n    std::shared_ptr<int> sp1(new int(5));\n    std::shared_ptr<int> sp2(new int(10));\n    std::cout << \"*sp1 == \" << *sp1 << std::endl;\n\n    sp1.swap(sp2);\n    std::cout << \"*sp1 == \" << *sp1 << std::endl;\n\n    swap(sp1, sp2);\n    std::cout << \"*sp1 == \" << *sp1 << std::endl;\n    std::cout << std::endl;\n\n    std::weak_ptr<int> wp1(sp1);\n    std::weak_ptr<int> wp2(sp2);\n    std::cout << \"*wp1 == \" << *wp1.lock() << std::endl;\n\n    wp1.swap(wp2);\n    std::cout << \"*wp1 == \" << *wp1.lock() << std::endl;\n\n    swap(wp1, wp2);\n    std::cout << \"*wp1 == \" << *wp1.lock() << std::endl;\n\n    return (0);\n}\n\n```  \n  \n```Output  \n*sp1 == 5  \n*sp1 == 10  \n*sp1 == 5  \n  \n*wp1 == 5  \n*wp1 == 10  \n*wp1 == 5  \n```  \n  \n##  <a name=\"undeclare_no_pointers\"></a>  undeclare_no_pointers  \n Informs a garbage collector that the characters in the memory block defined by a base address pointer and block size may now contain traceable pointers.  \n  \n```  \nvoid undeclare_no_pointers(\n    char* ptr,   \n    size_t _Size);\n```  \n  \n### Remarks  \n The function informs any `garbage collector` that the range of addresses `[`` ptr``,` ` ptr` `+` `_Size``)` may now contain `traceable pointers`.  \n  \n##  <a name=\"undeclare_reachable\"></a>  undeclare_reachable  \n Informs a `garbage_collector` that a specified memory location is not reachable.  \n  \n```  \ntemplate <class Type>  \nType *undeclare_reachable(Type* ptr);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|` ptr`|A pointer to the memory address to be declared not reachable.|  \n  \n### Remarks  \n If ` ptr` is not `null`, the function informs any `garbage collector` that ` ptr` is hereafter not `reachable`. It returns a `safely derived` pointer that compares equal to ` ptr`.  \n  \n##  <a name=\"uninitialized_copy\"></a>  uninitialized_copy  \n Copies objects from a specified source range into an uninitialized destination range.  \n  \n```  \ntemplate <class InputIterator, class ForwardIterator>  \nForwardIterator uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator dest);\n```  \n  \n### Parameters  \n ` first`  \n An input iterator addressing the first element in the source range.  \n  \n ` last`  \n An input iterator addressing the last element in the source range.  \n  \n ` dest`  \n A forward iterator addressing the first element in the destination range.  \n  \n### Return Value  \n A forward iterator addressing the first position beyond the destination range, unless the source range was empty and iterator addresses * first.*  \n  \n### Remarks  \n This algorithm allows the decoupling of memory allocation from object construction.  \n  \n The template function effectively executes:  \n  \n```  \nwhile (first!= last)  \n    new ((void*)&* dest ++)  \n    iterator_traits<InputIterator>::value_type (* first ++);\n\nreturn first;  \n```  \n  \n unless the code throws an exception. In that case, all constructed objects are destroyed and the exception is rethrown.  \n  \n### Example  \n  \n```cpp  \n// memory_uninit_copy.cpp  \n// compile with: /EHsc /W3  \n#include <memory>  \n#include <iostream>  \n  \nusing namespace std;  \n  \n class Integer\n{\npublic:\n    Integer(int x) : val(x) {}\n    int get() { return val; }\nprivate:\n    int val;\n};\n\nint main()\n{\n    int Array[] = { 10, 20, 30, 40 };\n    const int N = sizeof(Array) / sizeof(int);\n\n    int i;\n    cout << \"The initialized Array contains \" << N << \" elements: \";\n    for (i = 0; i < N; i++)\n    {\n        cout << \" \" << Array[i];\n    }\n    cout << endl;\n\n    Integer* ArrayPtr = (Integer*)malloc(N * sizeof(int));\n    Integer* LArrayPtr = uninitialized_copy(\n        Array, Array + N, ArrayPtr);  // C4996  \n\n    cout << \"Address of position after the last element in the array is: \"\n        << &Array[0] + N << endl;\n    cout << \"The iterator returned by uninitialized_copy addresses: \"\n        << (void*)LArrayPtr << endl;\n    cout << \"The address just beyond the last copied element is: \"\n        << (void*)(ArrayPtr + N) << endl;\n\n    if ((&Array[0] + N) == (void*)LArrayPtr)\n        cout << \"The return value is an iterator \"\n        << \"pointing just beyond the original array.\" << endl;\n    else\n        cout << \"The return value is an iterator \"\n        << \"not pointing just beyond the original array.\" << endl;\n\n    if ((void*)LArrayPtr == (void*)(ArrayPtr + N))\n        cout << \"The return value is an iterator \"\n        << \"pointing just beyond the copied array.\" << endl;\n    else\n        cout << \"The return value is an iterator \"\n        << \"not pointing just beyond the copied array.\" << endl;\n\n    free(ArrayPtr);\n\n    cout << \"Note that the exact addresses returned will vary\\n\"\n        << \"with the memory allocation in individual computers.\"\n        << endl;\n}\n```  \n  \n##  <a name=\"uninitialized_copy_n\"></a>  uninitialized_copy_n  \n Creates a copy of a specified number of elements from an input iterator. The copies are put in a forward iterator.  \n  \n```  \ntemplate <class InputIterator, class Size, class ForwardIterator>  \nForwardIterator uninitialized_copy_n(\n    InputIterator first,   \n    Size count,  \n    ForwardIterator dest);\n```  \n  \n### Parameters  \n ` first`  \n An input iterator that refers to the object to copy.  \n  \n ` count`  \n A signed or unsigned integer type specifying the number of times to copy the object.  \n  \n ` dest`  \n A forward iterator that refers to where the new copies go.  \n  \n### Return Value  \n A forward iterator that addresses the first position beyond the destination. If the source range was empty, the iterator addresses ` first`*.*  \n  \n### Remarks  \n The template function effectively executes the following:  \n  \n `for (; 0 < count; -- count)`  \n  \n `new ((void *)&*` ` dest` `++)`  \n  \n `iterator_traits<InputIterator>::value_type(*` ` first` `++);`  \n  \n `return dest;`  \n  \n unless the code throws an exception. In that case, all constructed objects are destroyed and the exception is rethrown.  \n  \n##  <a name=\"uninitialized_fill\"></a>  uninitialized_fill  \n Copies objects of a specified value into an uninitialized destination range.  \n  \n```  \ntemplate <class ForwardIterator, class Type>  \nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const Type& val);\n```  \n  \n### Parameters  \n ` first`  \n A forward iterator addressing the first element in the destination range that is to be initiated.  \n  \n ` last`  \n A forward iterator addressing the last element in the destination range that is to be initiated.  \n  \n ` val`  \n The value to be used to initialize the destination range.  \n  \n### Remarks  \n This algorithm allows the decoupling of memory allocation from object construction.  \n  \n The template function effectively executes:  \n  \n```  \nwhile (first != last)  \n    new ((void*)&* first ++)  \n    iterator_traits<ForwardIterator>::value_type (_Val);\n```  \n  \n unless the code throws an exception. In that case, all constructed objects are destroyed and the exception is rethrown.  \n  \n### Example  \n  \n```cpp  \n// memory_uninit_fill.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n  \nusing namespace std;  \n  \n   class Integer {         // No default constructor  \n   public:  \n      Integer( int x ) : val( x ) {}  \n      int get( ) { return val; }  \n   private:  \n      int val;  \n   };  \n  \nint main( )  \n{  \n   const int N = 10;  \n   Integer val ( 25 );  \n   Integer* Array = ( Integer* ) malloc( N * sizeof( int ) );  \n   uninitialized_fill( Array, Array + N, val );  \n   int i;  \n   cout << \"The initialized Array contains: \";  \n      for ( i = 0 ; i < N; i++ )  \n      {  \n         cout << Array [ i ].get( ) << \" \";  \n      }  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe initialized Array contains: 25 25 25 25 25 25 25 25 25 25   \n```  \n  \n##  <a name=\"uninitialized_fill_n\"></a>  uninitialized_fill_n  \n Copies objects of a specified value into specified number of elements into an uninitialized destination range.  \n  \n```  \ntemplate <class FwdIt, class Size, class Type>  \nvoid uninitialized_fill_n(ForwardIterator first, Size count, const Type& val);\n```  \n  \n### Parameters  \n ` first`  \n A forward iterator addressing the first element in the destination range to be initiated.  \n  \n ` count`  \n The number of elements to be initialized.  \n  \n ` val`  \n The value to be used to initialize the destination range.  \n  \n### Remarks  \n This algorithm allows the decoupling of memory allocation from object construction.  \n  \n The template function effectively executes:  \n  \n```cpp  \nwhile (0 <count--)  \n    new ((void*)&* first ++)  \n    iterator_traits<ForwardIterator>::value_type(val);\n```  \n  \n unless the code throws an exception. In that case, all constructed objects are destroyed and the exception is rethrown.  \n  \n### Example  \n  \n```cpp  \n// memory_uninit_fill_n.cpp  \n// compile with: /EHsc /W3  \n#include <memory>  \n#include <iostream>  \n  \nusing namespace std;  \n  \nclass Integer {   // No default constructor  \npublic:  \n   Integer( int x ) : val( x ) {}  \n   int get( ) { return val; }  \nprivate:  \n   int val;  \n};  \n  \nint main() {  \n   const int N = 10;  \n   Integer val ( 60 );  \n   Integer* Array = ( Integer* ) malloc( N * sizeof( int ) );  \n   uninitialized_fill_n( Array, N, val );  // C4996  \n   int i;  \n   cout << \"The uninitialized Array contains: \";  \n   for ( i = 0 ; i < N; i++ )  \n      cout << Array [ i ].get( ) <<  \" \";  \n}  \n```  \n  \n## See Also  \n [\\<memory>](../standard-library/memory.md)\n"}