{"nodes":[{"pos":[12,41],"content":"friend (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"friend (C++) | Microsoft Docs","pos":[0,29]}]},{"content":"friend (C++)","pos":[690,702]},{"content":"In some circumstances, it is more convenient to grant member-level access to functions that are not members of a class or to all members in a separate class.","pos":[703,860]},{"content":"Only the class implementer can declare who its friends are.","pos":[861,920]},{"content":"A function or class cannot declare itself as a friend of any class.","pos":[921,988]},{"content":"In a class definition, use the <ph id=\"ph1\">`friend`</ph> keyword and the name of a non-member function or other class to grant it access to the private and protected members of your class.","pos":[989,1160],"source":" In a class definition, use the `friend` keyword and the name of a non-member function or other class to grant it access to the private and protected members of your class."},{"content":"In a template definition, a type parameter can be declared as a friend.","pos":[1169,1240]},{"content":"Syntax","pos":[1249,1255]},{"content":"Friend declarations","pos":[1308,1327]},{"content":"If you declare a friend function that was not previously declared, that function is exported to the enclosing nonclass scope.","pos":[1331,1456]},{"content":"Functions declared in a friend declaration are treated as if they had been declared using the <ph id=\"ph1\">`extern`</ph> keyword.","pos":[1463,1574],"source":"Functions declared in a friend declaration are treated as if they had been declared using the `extern` keyword."},{"content":"(For more information about <ph id=\"ph1\">`extern`</ph>, see <bpt id=\"p1\">[</bpt>Static Storage-Class Specifiers<ept id=\"p1\">](http://msdn.microsoft.com/en-us/3ba9289a-a412-4a17-b319-ceb2c087df48)</ept>.)","pos":[1575,1722],"source":" (For more information about `extern`, see [Static Storage-Class Specifiers](http://msdn.microsoft.com/en-us/3ba9289a-a412-4a17-b319-ceb2c087df48).)"},{"content":"Although functions with global scope can be declared as friends prior to their prototypes, member functions cannot be declared as friends before the appearance of their complete class declaration.","pos":[1729,1925]},{"content":"The following code shows why this fails:","pos":[1926,1966]},{"content":"The preceding example enters the class name <ph id=\"ph1\">`ForwardDeclared`</ph> into scope, but the complete declaration — specifically, the portion that declares the function <ph id=\"ph2\">`IsAFriend`</ph> — is not known.","pos":[2143,2328],"source":"The preceding example enters the class name `ForwardDeclared` into scope, but the complete declaration — specifically, the portion that declares the function `IsAFriend` — is not known."},{"content":"Therefore, the <ph id=\"ph1\">`friend`</ph> declaration in class <ph id=\"ph2\">`HasFriends`</ph> generates an error.","pos":[2329,2406],"source":" Therefore, the `friend` declaration in class `HasFriends` generates an error."},{"content":"Starting in C++11, there are two forms of friend declarations for a class:","pos":[2413,2487]},{"content":"The first form introduces a new class F if no existing class by that name was found in the innermost namespace.","pos":[2542,2653]},{"content":"<bpt id=\"p1\">**</bpt>C++11<ept id=\"p1\">**</ept>: The second form does not introduce a new class; it can be used when the class has already been declared, and it must be used when declaring a template type parameter or a typedef as a friend.","pos":[2655,2857],"source":"**C++11**: The second form does not introduce a new class; it can be used when the class has already been declared, and it must be used when declaring a template type parameter or a typedef as a friend."},{"pos":[2864,2936],"content":"Use <ph id=\"ph1\">`class friend F`</ph> when the referenced type has not yet been declared:","source":"Use `class friend F` when the referenced type has not yet been declared:"},{"pos":[3241,3343],"content":"In the following example, <ph id=\"ph1\">`friend F`</ph> refers to the <ph id=\"ph2\">`F`</ph> class that is declared outside the scope of NS.","source":"In the following example, `friend F` refers to the `F` class that is declared outside the scope of NS."},{"pos":[3464,3523],"content":"Use <ph id=\"ph1\">`friend F`</ph> to declare a template parameter as a friend:","source":"Use `friend F` to declare a template parameter as a friend:"},{"pos":[3626,3672],"content":"Use <ph id=\"ph1\">`friend F`</ph> to declare a typedef as friend:","source":"Use `friend F` to declare a typedef as friend:"},{"content":"To declare two classes that are friends of one another, the entire second class must be specified as a friend of the first class.","pos":[3826,3955]},{"content":"The reason for this restriction is that the compiler has enough information to declare individual friend functions only at the point where the second class is declared.","pos":[3956,4124]},{"pos":[4132,4299],"content":"[!NOTE]\n Although the entire second class must be a friend to the first class, you can select which functions in the first class will be friends of the second class.","leadings":["","> "],"nodes":[{"content":"Although the entire second class must be a friend to the first class, you can select which functions in the first class will be friends of the second class.","pos":[9,165]}]},{"content":"friend functions","pos":[4308,4324]},{"content":"A <ph id=\"ph1\">`friend`</ph> function is a function that is not a member of a class but has access to the class's private and protected members.","pos":[4328,4454],"source":"A `friend` function is a function that is not a member of a class but has access to the class's private and protected members."},{"content":"Friend functions are not considered class members; they are normal external functions that are given special access privileges.","pos":[4455,4582]},{"content":"Friends are not in the class's scope, and they are not called using the member-selection operators (<bpt id=\"p1\">**</bpt>.<ept id=\"p1\">**</ept>","pos":[4583,4688],"source":" Friends are not in the class's scope, and they are not called using the member-selection operators (**.**"},{"content":"and –<bpt id=\"p1\">**</bpt><ph id=\"ph1\">&gt;</ph><ept id=\"p1\">**</ept>) unless they are members of another class.","pos":[4689,4742],"source":" and –**>**) unless they are members of another class."},{"content":"A <ph id=\"ph1\">`friend`</ph> function is declared by the class that is granting access.","pos":[4743,4812],"source":" A `friend` function is declared by the class that is granting access."},{"content":"The <ph id=\"ph1\">`friend`</ph> declaration can be placed anywhere in the class declaration.","pos":[4813,4886],"source":" The `friend` declaration can be placed anywhere in the class declaration."},{"content":"It is not affected by the access control keywords.","pos":[4887,4937]},{"content":"The following example shows a <ph id=\"ph1\">`Point`</ph> class and a friend function, <ph id=\"ph2\">`ChangePrivate`</ph>.","pos":[4944,5027],"source":"The following example shows a `Point` class and a friend function, `ChangePrivate`."},{"content":"The <ph id=\"ph1\">`friend`</ph> function has access to the private data member of the <ph id=\"ph2\">`Point`</ph> object it receives as a parameter.","pos":[5028,5137],"source":" The `friend` function has access to the private data member of the `Point` object it receives as a parameter."},{"content":"Class members as friends","pos":[5663,5687]},{"content":"Class member functions can be declared as friends in other classes.","pos":[5691,5758]},{"content":"Consider the following example:","pos":[5759,5790]},{"content":"In the preceding example, only the function <ph id=\"ph1\">`A::Func1( B&amp; )`</ph> is granted friend access to class <ph id=\"ph2\">`B`</ph>.","pos":[6250,6349],"source":"In the preceding example, only the function `A::Func1( B& )` is granted friend access to class `B`."},{"content":"Therefore, access to the private member <ph id=\"ph1\">`_b`</ph> is correct in <ph id=\"ph2\">`Func1`</ph> of class <ph id=\"ph3\">`A`</ph> but not in <ph id=\"ph4\">`Func2`</ph>.","pos":[6350,6449],"source":" Therefore, access to the private member `_b` is correct in `Func1` of class `A` but not in `Func2`."},{"content":"A <ph id=\"ph1\">`friend`</ph> class is a class all of whose member functions are friend functions of a class, that is, whose member functions have access to the other class's private and protected members.","pos":[6456,6642],"source":"A `friend` class is a class all of whose member functions are friend functions of a class, that is, whose member functions have access to the other class's private and protected members."},{"content":"Suppose the <ph id=\"ph1\">`friend`</ph> declaration in class <ph id=\"ph2\">`B`</ph> had been:","pos":[6643,6698],"source":" Suppose the `friend` declaration in class `B` had been:"},{"content":"In that case, all member functions in class <ph id=\"ph1\">`A`</ph> would have been granted friend access to class <ph id=\"ph2\">`B`</ph>.","pos":[6741,6840],"source":"In that case, all member functions in class `A` would have been granted friend access to class `B`."},{"content":"The following code is an example of a friend class:","pos":[6841,6892]},{"content":"Friendship is not mutual unless explicitly specified as such.","pos":[7479,7540]},{"content":"In the above example, member functions of <ph id=\"ph1\">`YourClass`</ph> cannot access the private members of <ph id=\"ph2\">`YourOtherClass`</ph>.","pos":[7541,7649],"source":" In the above example, member functions of `YourClass` cannot access the private members of `YourOtherClass`."},{"content":"A managed type cannot have any friend functions, friend classes, or friend interfaces.","pos":[7656,7742]},{"content":"Friendship is not inherited, meaning that classes derived from <ph id=\"ph1\">`YourOtherClass`</ph> cannot access <ph id=\"ph2\">`YourClass`</ph>'s private members.","pos":[7749,7873],"source":"Friendship is not inherited, meaning that classes derived from `YourOtherClass` cannot access `YourClass`'s private members."},{"content":"Friendship is not transitive, so classes that are friends of <ph id=\"ph1\">`YourOtherClass`</ph> cannot access <ph id=\"ph2\">`YourClass`</ph>'s private members.","pos":[7874,7996],"source":" Friendship is not transitive, so classes that are friends of `YourOtherClass` cannot access `YourClass`'s private members."},{"content":"The following figure shows four class declarations: <ph id=\"ph1\">`Base`</ph>, <ph id=\"ph2\">`Derived`</ph>, <ph id=\"ph3\">`aFriend`</ph>, and <ph id=\"ph4\">`anotherFriend`</ph>.","pos":[8003,8105],"source":"The following figure shows four class declarations: `Base`, `Derived`, `aFriend`, and `anotherFriend`."},{"content":"Only class <ph id=\"ph1\">`aFriend`</ph> has direct access to the private members of <ph id=\"ph2\">`Base`</ph> (and to any members <ph id=\"ph3\">`Base`</ph> might have inherited).","pos":[8106,8227],"source":" Only class `aFriend` has direct access to the private members of `Base` (and to any members `Base` might have inherited)."},{"content":"Implications of friend relationship","pos":[8236,8271]},{"content":"Implications of friend Relationship","pos":[8311,8346]},{"content":"Inline friend definitions","pos":[8355,8380]},{"content":"Friend functions can be defined inside class declarations.","pos":[8384,8442]},{"content":"These functions are inline functions, and like member inline functions they behave as though they were defined immediately after all class members have been seen but before the class scope is closed (the end of the class declaration).","pos":[8443,8677]},{"content":"Friend functions defined inside class declarations are not considered in the scope of the enclosing class; they are in file scope.","pos":[8684,8814]},{"content":"See Also","pos":[8823,8831]},{"content":"Keywords","pos":[8836,8844]}],"content":"---\ntitle: \"friend (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"Friend\"\n  - \"friend_cpp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"member access, from friend functions\"\n  - \"friend classes\"\n  - \"friend keyword [C++]\"\nms.assetid: 8fe9ee55-d56f-40cd-9075-d9fb1375aff4\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# friend (C++)\nIn some circumstances, it is more convenient to grant member-level access to functions that are not members of a class or to all members in a separate class. Only the class implementer can declare who its friends are. A function or class cannot declare itself as a friend of any class. In a class definition, use the `friend` keyword and the name of a non-member function or other class to grant it access to the private and protected members of your class.         In a template definition, a type parameter can be declared as a friend.  \n  \n## Syntax  \n  \n```  \nclass friend F  \nfriend F;  \n```  \n  \n## Friend declarations  \n If you declare a friend function that was not previously declared, that function is exported to the enclosing nonclass scope.  \n  \n Functions declared in a friend declaration are treated as if they had been declared using the `extern` keyword. (For more information about `extern`, see [Static Storage-Class Specifiers](http://msdn.microsoft.com/en-us/3ba9289a-a412-4a17-b319-ceb2c087df48).)  \n  \n Although functions with global scope can be declared as friends prior to their prototypes, member functions cannot be declared as friends before the appearance of their complete class declaration. The following code shows why this fails:  \n  \n```cpp  \nclass ForwardDeclared;   // Class name is known.  \nclass HasFriends  \n{  \n    friend int ForwardDeclared::IsAFriend();   // C2039 error expected  \n};  \n```  \n  \n The preceding example enters the class name `ForwardDeclared` into scope, but the complete declaration — specifically, the portion that declares the function `IsAFriend` — is not known. Therefore, the `friend` declaration in class `HasFriends` generates an error.  \n  \n Starting in C++11, there are two forms of friend declarations for a class:  \n  \n```cpp  \nfriend class F;  \nfriend F;  \n```  \n  \n The first form introduces a new class F if no existing class by that name was found in the innermost namespace.  **C++11**: The second form does not introduce a new class; it can be used when the class has already been declared, and it must be used when declaring a template type parameter or a typedef as a friend.  \n  \n Use `class friend F` when the referenced type has not yet been declared:  \n  \n```cpp  \nnamespace NS  \n{  \n    class M  \n    {  \n        class friend F;  // Introduces F but doesn't define it  \n    };  \n}  \n```  \n  \n```cpp  \nnamespace NS  \n{  \n    class M  \n    {  \n        friend F; // error C2433: 'NS::F': 'friend' not permitted on data declarations  \n    };  \n}  \n```  \n  \n In the following example, `friend F` refers to the `F` class that is declared outside the scope of NS.  \n  \n```cpp  \nclass F {};  \nnamespace NS  \n{  \n    class M  \n    {  \n        friend F;  // OK   \n    };  \n}  \n```  \n  \n Use `friend F` to declare a template parameter as a friend:  \n  \n```cpp  \ntemplate <typename T>  \nclass my_class  \n{  \n    friend T;  \n    //...  \n};  \n```  \n  \n Use `friend F` to declare a typedef as friend:  \n  \n```cpp  \nclass Foo {};  \ntypedef Foo F;  \n  \nclass G  \n{  \n    friend F; // OK  \n    friend class F // Error C2371 -- redefinition  \n};  \n```  \n  \n To declare two classes that are friends of one another, the entire second class must be specified as a friend of the first class. The reason for this restriction is that the compiler has enough information to declare individual friend functions only at the point where the second class is declared.  \n  \n> [!NOTE]\n>  Although the entire second class must be a friend to the first class, you can select which functions in the first class will be friends of the second class.  \n  \n## friend functions  \n A `friend` function is a function that is not a member of a class but has access to the class's private and protected members. Friend functions are not considered class members; they are normal external functions that are given special access privileges. Friends are not in the class's scope, and they are not called using the member-selection operators (**.** and –**>**) unless they are members of another class. A `friend` function is declared by the class that is granting access. The `friend` declaration can be placed anywhere in the class declaration. It is not affected by the access control keywords.  \n  \n The following example shows a `Point` class and a friend function, `ChangePrivate`. The `friend` function has access to the private data member of the `Point` object it receives as a parameter.  \n  \n```cpp  \n// friend_functions.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nusing namespace std;  \nclass Point  \n{  \n    friend void ChangePrivate( Point & );  \npublic:  \n    Point( void ) : m_i(0) {}  \n    void PrintPrivate( void ){cout << m_i << endl; }  \n  \nprivate:  \n    int m_i;  \n};  \n  \nvoid ChangePrivate ( Point &i ) { i.m_i++; }  \n  \nint main()  \n{  \n   Point sPoint;  \n   sPoint.PrintPrivate();  \n   ChangePrivate(sPoint);  \n   sPoint.PrintPrivate();  \n// Output: 0  \n           1  \n}  \n```  \n  \n## Class members as friends  \n Class member functions can be declared as friends in other classes. Consider the following example:  \n  \n```cpp  \n// classes_as_friends1.cpp  \n// compile with: /c  \nclass B;  \n  \nclass A {  \npublic:  \n   int Func1( B& b );  \n  \nprivate:  \n   int Func2( B& b );  \n};  \n  \nclass B {  \nprivate:  \n   int _b;  \n  \n   // A::Func1 is a friend function to class B  \n   // so A::Func1 has access to all members of B  \n   friend int A::Func1( B& );  \n};  \n  \nint A::Func1( B& b ) { return b._b; }   // OK  \nint A::Func2( B& b ) { return b._b; }   // C2248  \n```  \n  \n In the preceding example, only the function `A::Func1( B& )` is granted friend access to class `B`. Therefore, access to the private member `_b` is correct in `Func1` of class `A` but not in `Func2`.  \n  \n A `friend` class is a class all of whose member functions are friend functions of a class, that is, whose member functions have access to the other class's private and protected members. Suppose the `friend` declaration in class `B` had been:  \n  \n```cpp  \nfriend class A;  \n```  \n  \n In that case, all member functions in class `A` would have been granted friend access to class `B`. The following code is an example of a friend class:  \n  \n```cpp  \n// classes_as_friends2.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nusing namespace std;  \nclass YourClass {  \nfriend class YourOtherClass;  // Declare a friend class  \npublic:  \n   YourClass() : topSecret(0){}  \n   void printMember() { cout << topSecret << endl; }  \nprivate:  \n   int topSecret;  \n};  \n  \nclass YourOtherClass {  \npublic:  \n   void change( YourClass& yc, int x ){yc.topSecret = x;}  \n};  \n  \nint main() {  \n   YourClass yc1;  \n   YourOtherClass yoc1;  \n   yc1.printMember();  \n   yoc1.change( yc1, 5 );  \n   yc1.printMember();  \n}  \n```  \n  \n Friendship is not mutual unless explicitly specified as such. In the above example, member functions of `YourClass` cannot access the private members of `YourOtherClass`.  \n  \n A managed type cannot have any friend functions, friend classes, or friend interfaces.  \n  \n Friendship is not inherited, meaning that classes derived from `YourOtherClass` cannot access `YourClass`'s private members. Friendship is not transitive, so classes that are friends of `YourOtherClass` cannot access `YourClass`'s private members.  \n  \n The following figure shows four class declarations: `Base`, `Derived`, `aFriend`, and `anotherFriend`. Only class `aFriend` has direct access to the private members of `Base` (and to any members `Base` might have inherited).  \n  \n ![Implications of friend relationship](../cpp/media/vc38v41.gif \"vc38V41\")  \nImplications of friend Relationship  \n  \n## Inline friend definitions  \n Friend functions can be defined inside class declarations. These functions are inline functions, and like member inline functions they behave as though they were defined immediately after all class members have been seen but before the class scope is closed (the end of the class declaration).  \n  \n Friend functions defined inside class declarations are not considered in the scope of the enclosing class; they are in file scope.  \n  \n## See Also  \n [Keywords](../cpp/keywords-cpp.md)"}