{"nodes":[{"pos":[12,64],"content":"Multithreading: Terminating Threads | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Multithreading: Terminating Threads | Microsoft Docs","pos":[0,52]}]},{"content":"Multithreading: Terminating Threads","pos":[867,902]},{"content":"Two normal situations cause a thread to terminate: the controlling function exits or the thread is not allowed to run to completion.","pos":[903,1035]},{"content":"If a word processor used a thread for background printing, the controlling function would terminate normally if printing completed successfully.","pos":[1036,1180]},{"content":"If the user wants to cancel the printing, however, the background printing thread has to be terminated prematurely.","pos":[1181,1296]},{"content":"This topic explains both how to implement each situation and how to get the exit code of a thread after it terminates.","pos":[1297,1415]},{"content":"Normal Thread Termination","pos":[1426,1451]},{"content":"Premature Thread Termination","pos":[1497,1525]},{"content":"Retrieving the Exit Code of a Thread","pos":[1574,1610]},{"pos":[1713,1738],"content":"Normal Thread Termination"},{"content":"For a worker thread, normal thread termination is simple: Exit the controlling function and return a value that signifies the reason for termination.","pos":[1742,1891]},{"content":"You can use either the <bpt id=\"p1\">[</bpt>AfxEndThread<ept id=\"p1\">](http://msdn.microsoft.com/library/b8215409-7724-4159-9156-16b543443b99)</ept> function or a <ph id=\"ph1\">`return`</ph> statement.","pos":[1892,2035],"source":" You can use either the [AfxEndThread](http://msdn.microsoft.com/library/b8215409-7724-4159-9156-16b543443b99) function or a `return` statement."},{"content":"Typically, 0 signifies successful completion, but that is up to you.","pos":[2036,2104]},{"content":"For a user-interface thread, the process is just as simple: from within the user-interface thread, call <bpt id=\"p1\">[</bpt>PostQuitMessage<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms644945)</ept> in the <ph id=\"ph1\">[!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]</ph>.","pos":[2111,2380],"source":"For a user-interface thread, the process is just as simple: from within the user-interface thread, call [PostQuitMessage](http://msdn.microsoft.com/library/windows/desktop/ms644945) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]."},{"content":"The only parameter that <bpt id=\"p1\">**</bpt>PostQuitMessage<ept id=\"p1\">**</ept> takes is the exit code of the thread.","pos":[2381,2462],"source":" The only parameter that **PostQuitMessage** takes is the exit code of the thread."},{"content":"As for worker threads, 0 typically signifies successful completion.","pos":[2463,2530]},{"pos":[2590,2618],"content":"Premature Thread Termination"},{"content":"Terminating a thread prematurely is almost as simple: Call <bpt id=\"p1\">[</bpt>AfxEndThread<ept id=\"p1\">](http://msdn.microsoft.com/library/b8215409-7724-4159-9156-16b543443b99)</ept> from within the thread.","pos":[2622,2791],"source":"Terminating a thread prematurely is almost as simple: Call [AfxEndThread](http://msdn.microsoft.com/library/b8215409-7724-4159-9156-16b543443b99) from within the thread."},{"content":"Pass the desired exit code as the only parameter.","pos":[2792,2841]},{"content":"This stops execution of the thread, deallocates the thread's stack, detaches all DLLs attached to the thread, and deletes the thread object from memory.","pos":[2842,2994]},{"content":"must be called from within the thread to be terminated.","pos":[3016,3071]},{"content":"If you want to terminate a thread from another thread, you must set up a communication method between the two threads.","pos":[3072,3190]},{"pos":[3258,3294],"content":"Retrieving the Exit Code of a Thread"},{"content":"To get the exit code of either the worker or the user-interface thread, call the <bpt id=\"p1\">[</bpt>GetExitCodeThread<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms683190)</ept> function.","pos":[3298,3468],"source":"To get the exit code of either the worker or the user-interface thread, call the [GetExitCodeThread](http://msdn.microsoft.com/library/windows/desktop/ms683190) function."},{"content":"For information about this function, see the <ph id=\"ph1\">[!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]</ph>.","pos":[3469,3594],"source":" For information about this function, see the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]."},{"content":"This function takes the handle to the thread (stored in the <ph id=\"ph1\">`m_hThread`</ph> data member of <ph id=\"ph2\">`CWinThread`</ph> objects) and the address of a <ph id=\"ph3\">`DWORD`</ph>.","pos":[3595,3733],"source":" This function takes the handle to the thread (stored in the `m_hThread` data member of `CWinThread` objects) and the address of a `DWORD`."},{"pos":[3740,3901],"content":"If the thread is still active, <bpt id=\"p1\">**</bpt>GetExitCodeThread<ept id=\"p1\">**</ept> places <bpt id=\"p2\">**</bpt>STILL_ACTIVE<ept id=\"p2\">**</ept> in the supplied <ph id=\"ph1\">`DWORD`</ph> address; otherwise, the exit code is placed in this address.","source":"If the thread is still active, **GetExitCodeThread** places **STILL_ACTIVE** in the supplied `DWORD` address; otherwise, the exit code is placed in this address."},{"content":"Retrieving the exit code of <bpt id=\"p1\">[</bpt>CWinThread<ept id=\"p1\">](../mfc/reference/cwinthread-class.md)</ept> objects takes an extra step.","pos":[3908,4015],"source":"Retrieving the exit code of [CWinThread](../mfc/reference/cwinthread-class.md) objects takes an extra step."},{"content":"By default, when a <ph id=\"ph1\">`CWinThread`</ph> thread terminates, the thread object is deleted.","pos":[4016,4096],"source":" By default, when a `CWinThread` thread terminates, the thread object is deleted."},{"content":"This means you cannot access the <ph id=\"ph1\">`m_hThread`</ph> data member because the <ph id=\"ph2\">`CWinThread`</ph> object no longer exists.","pos":[4097,4203],"source":" This means you cannot access the `m_hThread` data member because the `CWinThread` object no longer exists."},{"content":"To avoid this situation, do one of the following:","pos":[4204,4253]},{"content":"Set the <ph id=\"ph1\">`m_bAutoDelete`</ph> data member to <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept>.","pos":[4263,4312],"source":"Set the `m_bAutoDelete` data member to **FALSE**."},{"content":"This allows the <ph id=\"ph1\">`CWinThread`</ph> object to survive after the thread has been terminated.","pos":[4313,4397],"source":" This allows the `CWinThread` object to survive after the thread has been terminated."},{"content":"You can then access the <ph id=\"ph1\">`m_hThread`</ph> data member after the thread has been terminated.","pos":[4398,4483],"source":" You can then access the `m_hThread` data member after the thread has been terminated."},{"content":"If you use this technique, however, you are responsible for destroying the <ph id=\"ph1\">`CWinThread`</ph> object because the framework will not automatically delete it for you.","pos":[4484,4642],"source":" If you use this technique, however, you are responsible for destroying the `CWinThread` object because the framework will not automatically delete it for you."},{"content":"This is the preferred method.","pos":[4643,4672]},{"content":"Store the thread's handle separately.","pos":[4682,4719]},{"content":"After the thread is created, copy its <ph id=\"ph1\">`m_hThread`</ph> data member (using <bpt id=\"p1\">**</bpt>::DuplicateHandle<ept id=\"p1\">**</ept>) to another variable and access it through that variable.","pos":[4720,4868],"source":" After the thread is created, copy its `m_hThread` data member (using **::DuplicateHandle**) to another variable and access it through that variable."},{"content":"This way the object is deleted automatically when termination occurs and you can still find out why the thread terminated.","pos":[4869,4991]},{"content":"Be careful that the thread does not terminate before you can duplicate the handle.","pos":[4992,5074]},{"content":"The safest way to do this is to pass <bpt id=\"p1\">**</bpt>CREATE_SUSPENDED<ept id=\"p1\">**</ept> to <bpt id=\"p2\">[</bpt>AfxBeginThread<ept id=\"p2\">](http://msdn.microsoft.com/library/e9e8684d-24f7-4599-8fdf-1f4f560a753b)</ept>, store the handle, and then resume the thread by calling <bpt id=\"p3\">[</bpt>ResumeThread<ept id=\"p3\">](../topic/../mfc/reference/cwinthread-class.md#cwinthread__resumethread)</ept>.","pos":[5075,5369],"source":" The safest way to do this is to pass **CREATE_SUSPENDED** to [AfxBeginThread](http://msdn.microsoft.com/library/e9e8684d-24f7-4599-8fdf-1f4f560a753b), store the handle, and then resume the thread by calling [ResumeThread](../topic/../mfc/reference/cwinthread-class.md#cwinthread__resumethread)."},{"pos":[5376,5451],"content":"Either method allows you to determine why a <ph id=\"ph1\">`CWinThread`</ph> object terminated.","source":"Either method allows you to determine why a `CWinThread` object terminated."},{"content":"See Also","pos":[5460,5468]},{"content":"Multithreading with C++ and MFC","pos":[5473,5504]},{"content":"_endthread, _endthreadex","pos":[5559,5583]},{"content":"_beginthread, _beginthreadex","pos":[5647,5675]},{"content":"ExitThread","pos":[5743,5753]}],"content":"---\ntitle: \"Multithreading: Terminating Threads | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"CREATE_SUSPENDED\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"premature thread termination\"\n  - \"starting threads\"\n  - \"threading [MFC], terminating threads\"\n  - \"multithreading [C++], terminating threads\"\n  - \"threading [C++], stopping threads\"\n  - \"terminating threads\"\n  - \"stopping threads\"\n  - \"AfxEndThread method\"\nms.assetid: 4c0a8c6d-c02f-456d-bd02-0a8c8d006ecb\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Multithreading: Terminating Threads\nTwo normal situations cause a thread to terminate: the controlling function exits or the thread is not allowed to run to completion. If a word processor used a thread for background printing, the controlling function would terminate normally if printing completed successfully. If the user wants to cancel the printing, however, the background printing thread has to be terminated prematurely. This topic explains both how to implement each situation and how to get the exit code of a thread after it terminates.  \n  \n-   [Normal Thread Termination](#_core_normal_thread_termination)  \n  \n-   [Premature Thread Termination](#_core_premature_thread_termination)  \n  \n-   [Retrieving the Exit Code of a Thread](#_core_retrieving_the_exit_code_of_a_thread)  \n  \n##  <a name=\"_core_normal_thread_termination\"></a> Normal Thread Termination  \n For a worker thread, normal thread termination is simple: Exit the controlling function and return a value that signifies the reason for termination. You can use either the [AfxEndThread](http://msdn.microsoft.com/library/b8215409-7724-4159-9156-16b543443b99) function or a `return` statement. Typically, 0 signifies successful completion, but that is up to you.  \n  \n For a user-interface thread, the process is just as simple: from within the user-interface thread, call [PostQuitMessage](http://msdn.microsoft.com/library/windows/desktop/ms644945) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]. The only parameter that **PostQuitMessage** takes is the exit code of the thread. As for worker threads, 0 typically signifies successful completion.  \n  \n##  <a name=\"_core_premature_thread_termination\"></a> Premature Thread Termination  \n Terminating a thread prematurely is almost as simple: Call [AfxEndThread](http://msdn.microsoft.com/library/b8215409-7724-4159-9156-16b543443b99) from within the thread. Pass the desired exit code as the only parameter. This stops execution of the thread, deallocates the thread's stack, detaches all DLLs attached to the thread, and deletes the thread object from memory.  \n  \n `AfxEndThread` must be called from within the thread to be terminated. If you want to terminate a thread from another thread, you must set up a communication method between the two threads.  \n  \n##  <a name=\"_core_retrieving_the_exit_code_of_a_thread\"></a> Retrieving the Exit Code of a Thread  \n To get the exit code of either the worker or the user-interface thread, call the [GetExitCodeThread](http://msdn.microsoft.com/library/windows/desktop/ms683190) function. For information about this function, see the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]. This function takes the handle to the thread (stored in the `m_hThread` data member of `CWinThread` objects) and the address of a `DWORD`.  \n  \n If the thread is still active, **GetExitCodeThread** places **STILL_ACTIVE** in the supplied `DWORD` address; otherwise, the exit code is placed in this address.  \n  \n Retrieving the exit code of [CWinThread](../mfc/reference/cwinthread-class.md) objects takes an extra step. By default, when a `CWinThread` thread terminates, the thread object is deleted. This means you cannot access the `m_hThread` data member because the `CWinThread` object no longer exists. To avoid this situation, do one of the following:  \n  \n-   Set the `m_bAutoDelete` data member to **FALSE**. This allows the `CWinThread` object to survive after the thread has been terminated. You can then access the `m_hThread` data member after the thread has been terminated. If you use this technique, however, you are responsible for destroying the `CWinThread` object because the framework will not automatically delete it for you. This is the preferred method.  \n  \n-   Store the thread's handle separately. After the thread is created, copy its `m_hThread` data member (using **::DuplicateHandle**) to another variable and access it through that variable. This way the object is deleted automatically when termination occurs and you can still find out why the thread terminated. Be careful that the thread does not terminate before you can duplicate the handle. The safest way to do this is to pass **CREATE_SUSPENDED** to [AfxBeginThread](http://msdn.microsoft.com/library/e9e8684d-24f7-4599-8fdf-1f4f560a753b), store the handle, and then resume the thread by calling [ResumeThread](../topic/../mfc/reference/cwinthread-class.md#cwinthread__resumethread).  \n  \n Either method allows you to determine why a `CWinThread` object terminated.  \n  \n## See Also  \n [Multithreading with C++ and MFC](../parallel/multithreading-with-cpp-and-mfc.md)   \n [_endthread, _endthreadex](../c-runtime-library/reference/endthread-endthreadex.md)   \n [_beginthread, _beginthreadex](../c-runtime-library/reference/beginthread-beginthreadex.md)   \n [ExitThread](http://msdn.microsoft.com/library/windows/desktop/ms682659)"}