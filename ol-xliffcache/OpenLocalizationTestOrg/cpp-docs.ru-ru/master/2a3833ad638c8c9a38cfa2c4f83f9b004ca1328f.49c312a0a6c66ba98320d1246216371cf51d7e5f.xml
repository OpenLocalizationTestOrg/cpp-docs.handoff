{"nodes":[{"pos":[12,47],"content":"_set_se_translator | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_set_se_translator | Microsoft Docs","pos":[0,35]}]},{"pos":[1003,1021],"content":"_set_se_translator","linkify":"_set_se_translator","nodes":[{"content":"_set_se_translator","pos":[0,18]}]},{"content":"Handles Win32 exceptions (C structured exceptions) as C++ typed exceptions.","pos":[1022,1097]},{"pos":[1106,1112],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1234,1244],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Pointer to a C structured exception translator function that you write.","pos":[1269,1340]},{"pos":[1349,1361],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Returns a pointer to the previous translator function registered by <ph id=\"ph1\">`_set_se_translator`</ph>, so that the previous function can be restored later.","pos":[1365,1507],"source":"Returns a pointer to the previous translator function registered by `_set_se_translator`, so that the previous function can be restored later."},{"content":"If no previous function has been set, the return value can be used to restore the default behavior; this value can be NULL.","pos":[1508,1631]},{"pos":[1640,1647],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`_set_se_translator`</ph> function provides a way to handle Win32 exceptions (C structured exceptions) as C++ typed exceptions.","pos":[1651,1777],"source":"The `_set_se_translator` function provides a way to handle Win32 exceptions (C structured exceptions) as C++ typed exceptions."},{"content":"To allow each C exception to be handled by a C++ <ph id=\"ph1\">`catch`</ph> handler, first define a C exception wrapper class that can be used, or derived from, to attribute a specific class type to a C exception.","pos":[1778,1972],"source":" To allow each C exception to be handled by a C++ `catch` handler, first define a C exception wrapper class that can be used, or derived from, to attribute a specific class type to a C exception."},{"content":"To use this class, install a custom C exception translator function that is called by the internal exception-handling mechanism each time a C exception is raised.","pos":[1973,2135]},{"content":"Within your translator function, you can throw any typed exception that can be caught by a matching C++ <ph id=\"ph1\">`catch`</ph> handler.","pos":[2136,2256],"source":" Within your translator function, you can throw any typed exception that can be caught by a matching C++ `catch` handler."},{"pos":[2263,2369],"content":"You must use <bpt id=\"p1\">[</bpt>/EHa<ept id=\"p1\">](../../build/reference/eh-exception-handling-model.md)</ept> when using <ph id=\"ph1\">`_set_se_translator`</ph>.","source":"You must use [/EHa](../../build/reference/eh-exception-handling-model.md) when using `_set_se_translator`."},{"content":"To specify a custom translation function, call <ph id=\"ph1\">`_set_se_translator`</ph> with the name of your translation function as its argument.","pos":[2376,2503],"source":"To specify a custom translation function, call `_set_se_translator` with the name of your translation function as its argument."},{"content":"The translator function that you write is called once for each function invocation on the stack that has <ph id=\"ph1\">`try`</ph> blocks.","pos":[2504,2622],"source":" The translator function that you write is called once for each function invocation on the stack that has `try` blocks."},{"content":"There is no default translator function.","pos":[2623,2663]},{"content":"Your translator function should do no more than throw a C++ typed exception.","pos":[2670,2746]},{"content":"If it does anything in addition to throwing (such as writing to a log file, for example) your program might not behave as expected, because the number of times the translator function is invoked is platform-dependent.","pos":[2747,2964]},{"content":"In a multithreaded environment, translator functions are maintained separately for each thread.","pos":[2971,3066]},{"content":"Each new thread needs to install its own translator function.","pos":[3067,3128]},{"content":"Thus, each thread is in charge of its own translation handling.","pos":[3129,3192]},{"content":"<ph id=\"ph1\">`_set_se_translator`</ph> is specific to one thread; another DLL can install a different translation function.","pos":[3193,3298],"source":"`_set_se_translator` is specific to one thread; another DLL can install a different translation function."},{"content":"The <ph id=\"ph1\">`seTransFunction`</ph> function that you write must be a native-compiled function (not compiled with /clr).","pos":[3305,3411],"source":"The `seTransFunction` function that you write must be a native-compiled function (not compiled with /clr)."},{"content":"It must take an unsigned integer and a pointer to a Win32 <ph id=\"ph1\">`_EXCEPTION_POINTERS`</ph> structure as arguments.","pos":[3412,3515],"source":" It must take an unsigned integer and a pointer to a Win32 `_EXCEPTION_POINTERS` structure as arguments."},{"content":"The arguments are the return values of calls to the Win32 API <ph id=\"ph1\">`GetExceptionCode`</ph> and <ph id=\"ph2\">`GetExceptionInformation`</ph> functions, respectively.","pos":[3516,3651],"source":" The arguments are the return values of calls to the Win32 API `GetExceptionCode` and `GetExceptionInformation` functions, respectively."},{"pos":[3760,3943],"content":"For <ph id=\"ph1\">`_set_se_translator`</ph>, there are implications when dynamically linking to the CRT; another DLL in the process might call <ph id=\"ph2\">`_set_se_translator`</ph> and replace your handler with its own.","source":"For `_set_se_translator`, there are implications when dynamically linking to the CRT; another DLL in the process might call `_set_se_translator` and replace your handler with its own."},{"content":"When using <ph id=\"ph1\">`_set_se_translator`</ph> from managed code (code compiled with /clr) or mixed native and managed code, be aware that the translator affects exceptions generated in native code only.","pos":[3950,4138],"source":"When using `_set_se_translator` from managed code (code compiled with /clr) or mixed native and managed code, be aware that the translator affects exceptions generated in native code only."},{"content":"Any managed exceptions generated in managed code (such as when raising <ph id=\"ph1\">`System::Exception`</ph>) are not routed through the translator function.","pos":[4139,4278],"source":" Any managed exceptions generated in managed code (such as when raising `System::Exception`) are not routed through the translator function."},{"content":"Exceptions raised in managed code using the Win32 function <ph id=\"ph1\">`RaiseException`</ph> or caused by a system exception like a divide by zero exception are routed through the translator.","pos":[4279,4453],"source":" Exceptions raised in managed code using the Win32 function `RaiseException` or caused by a system exception like a divide by zero exception are routed through the translator."},{"pos":[4462,4474],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[4481,4488]},{"content":"Required header","pos":[4489,4504]},{"content":"<ph id=\"ph1\">\\&lt;</ph>eh.h&gt;","pos":[4570,4577],"source":"\\<eh.h>"},{"pos":[4585,4773],"content":"The functionality provided by <ph id=\"ph1\">`_set_se_translator`</ph> is not available in code compiled with the <bpt id=\"p1\">[</bpt>/clr:pure<ept id=\"p1\">](../../build/reference/clr-common-language-runtime-compilation.md)</ept> compiler option.","source":"The functionality provided by `_set_se_translator` is not available in code compiled with the [/clr:pure](../../build/reference/clr-common-language-runtime-compilation.md) compiler option."},{"pos":[4780,4898],"content":"For more compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept> in the Introduction.","source":"For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction."},{"pos":[4907,4914],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[5975,5982],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"Although the functionality provided by <ph id=\"ph1\">`_set_se_translator`</ph> is not available in managed code, it is possible to use this mapping in native code, even if that native code is in a compilation under the <ph id=\"ph2\">`/clr`</ph> switch, as long as the native code is indicated using <ph id=\"ph3\">`#pragma unmanaged`</ph>.","pos":[5986,6267],"source":"Although the functionality provided by `_set_se_translator` is not available in managed code, it is possible to use this mapping in native code, even if that native code is in a compilation under the `/clr` switch, as long as the native code is indicated using `#pragma unmanaged`."},{"content":"If a structured exception is being thrown in managed code that is to be mapped, the code that generates and handles the exception must be marked with the <ph id=\"ph1\">`pragma`</ph>.","pos":[6268,6431],"source":" If a structured exception is being thrown in managed code that is to be mapped, the code that generates and handles the exception must be marked with the `pragma`."},{"content":"The following code shows a possible use.","pos":[6432,6472]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Pragma Directives and the __Pragma Keyword<ept id=\"p1\">](../../preprocessor/pragma-directives-and-the-pragma-keyword.md)</ept>.","pos":[6473,6608],"source":" For more information, see [Pragma Directives and the __Pragma Keyword](../../preprocessor/pragma-directives-and-the-pragma-keyword.md)."},{"pos":[7568,7593],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"Not applicable.","pos":[7597,7612]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[7613,7660],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[7661,7786],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[7795,7803],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Exception Handling Routines<ept id=\"p1\">](../../c-runtime-library/exception-handling-routines.md)</ept><ph id=\"ph1\"> </ph>","pos":[7807,7893],"source":"[Exception Handling Routines](../../c-runtime-library/exception-handling-routines.md) "},{"content":"<bpt id=\"p1\"> [</bpt>set_terminate<ept id=\"p1\">](../../c-runtime-library/reference/set-terminate-crt.md)</ept><ph id=\"ph1\"> </ph>","pos":[7896,7969],"source":" [set_terminate](../../c-runtime-library/reference/set-terminate-crt.md) "},{"content":"<bpt id=\"p1\"> [</bpt>set_unexpected<ept id=\"p1\">](../../c-runtime-library/reference/set-unexpected-crt.md)</ept><ph id=\"ph1\"> </ph>","pos":[7972,8047],"source":" [set_unexpected](../../c-runtime-library/reference/set-unexpected-crt.md) "},{"content":"<bpt id=\"p1\"> [</bpt>terminate<ept id=\"p1\">](../../c-runtime-library/reference/terminate-crt.md)</ept><ph id=\"ph1\"> </ph>","pos":[8050,8115],"source":" [terminate](../../c-runtime-library/reference/terminate-crt.md) "},{"content":"<bpt id=\"p1\"> [</bpt>unexpected<ept id=\"p1\">](../../c-runtime-library/reference/unexpected-crt.md)</ept>","pos":[8118,8184],"source":" [unexpected](../../c-runtime-library/reference/unexpected-crt.md)"}],"content":"---\ntitle: \"_set_se_translator | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_set_se_translator\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"_set_se_translator\"\n  - \"set_se_translator\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"set_se_translator function\"\n  - \"exception handling, changing\"\n  - \"_set_se_translator function\"\nms.assetid: 280842bc-d72a-468b-a565-2d3db893ae0f\ncaps.latest.revision: 21\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _set_se_translator\nHandles Win32 exceptions (C structured exceptions) as C++ typed exceptions.  \n  \n## Syntax  \n  \n```  \n_se_translator_function _set_se_translator(  \n   _se_translator_function seTransFunction  \n);  \n```  \n  \n#### Parameters  \n `seTransFunction`  \n Pointer to a C structured exception translator function that you write.  \n  \n## Return Value  \n Returns a pointer to the previous translator function registered by `_set_se_translator`, so that the previous function can be restored later. If no previous function has been set, the return value can be used to restore the default behavior; this value can be NULL.  \n  \n## Remarks  \n The `_set_se_translator` function provides a way to handle Win32 exceptions (C structured exceptions) as C++ typed exceptions. To allow each C exception to be handled by a C++ `catch` handler, first define a C exception wrapper class that can be used, or derived from, to attribute a specific class type to a C exception. To use this class, install a custom C exception translator function that is called by the internal exception-handling mechanism each time a C exception is raised. Within your translator function, you can throw any typed exception that can be caught by a matching C++ `catch` handler.  \n  \n You must use [/EHa](../../build/reference/eh-exception-handling-model.md) when using `_set_se_translator`.  \n  \n To specify a custom translation function, call `_set_se_translator` with the name of your translation function as its argument. The translator function that you write is called once for each function invocation on the stack that has `try` blocks. There is no default translator function.  \n  \n Your translator function should do no more than throw a C++ typed exception. If it does anything in addition to throwing (such as writing to a log file, for example) your program might not behave as expected, because the number of times the translator function is invoked is platform-dependent.  \n  \n In a multithreaded environment, translator functions are maintained separately for each thread. Each new thread needs to install its own translator function. Thus, each thread is in charge of its own translation handling. `_set_se_translator` is specific to one thread; another DLL can install a different translation function.  \n  \n The `seTransFunction` function that you write must be a native-compiled function (not compiled with /clr). It must take an unsigned integer and a pointer to a Win32 `_EXCEPTION_POINTERS` structure as arguments. The arguments are the return values of calls to the Win32 API `GetExceptionCode` and `GetExceptionInformation` functions, respectively.  \n  \n```  \ntypedef void (*_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS* );  \n```  \n  \n For `_set_se_translator`, there are implications when dynamically linking to the CRT; another DLL in the process might call `_set_se_translator` and replace your handler with its own.  \n  \n When using `_set_se_translator` from managed code (code compiled with /clr) or mixed native and managed code, be aware that the translator affects exceptions generated in native code only. Any managed exceptions generated in managed code (such as when raising `System::Exception`) are not routed through the translator function. Exceptions raised in managed code using the Win32 function `RaiseException` or caused by a system exception like a divide by zero exception are routed through the translator.  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`_set_se_translator`|\\<eh.h>|  \n  \n The functionality provided by `_set_se_translator` is not available in code compiled with the [/clr:pure](../../build/reference/clr-common-language-runtime-compilation.md) compiler option.  \n  \n For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction.  \n  \n## Example  \n  \n```  \n// crt_settrans.cpp  \n// compile with: /EHa  \n#include <stdio.h>  \n#include <windows.h>  \n#include <eh.h>  \n  \nvoid SEFunc();  \nvoid trans_func( unsigned int, EXCEPTION_POINTERS* );  \n  \nclass SE_Exception  \n{  \nprivate:  \n    unsigned int nSE;  \npublic:  \n    SE_Exception() {}  \n    SE_Exception( unsigned int n ) : nSE( n ) {}  \n    ~SE_Exception() {}  \n    unsigned int getSeNumber() { return nSE; }  \n};  \nint main( void )  \n{  \n    try  \n    {  \n        _set_se_translator( trans_func );  \n        SEFunc();  \n    }  \n    catch( SE_Exception e )  \n    {  \n        printf( \"Caught a __try exception with SE_Exception.\\n\" );  \n    }  \n}  \nvoid SEFunc()  \n{  \n    __try  \n    {  \n        int x, y=0;  \n        x = 5 / y;  \n    }  \n    __finally  \n    {  \n        printf( \"In finally\\n\" );  \n    }  \n}  \nvoid trans_func( unsigned int u, EXCEPTION_POINTERS* pExp )  \n{  \n    printf( \"In trans_func.\\n\" );  \n    throw SE_Exception();  \n}  \n```  \n  \n```Output  \nIn trans_func.  \nIn finally  \nCaught a __try exception with SE_Exception.  \n```  \n  \n## Example  \n Although the functionality provided by `_set_se_translator` is not available in managed code, it is possible to use this mapping in native code, even if that native code is in a compilation under the `/clr` switch, as long as the native code is indicated using `#pragma unmanaged`. If a structured exception is being thrown in managed code that is to be mapped, the code that generates and handles the exception must be marked with the `pragma`. The following code shows a possible use. For more information, see [Pragma Directives and the __Pragma Keyword](../../preprocessor/pragma-directives-and-the-pragma-keyword.md).  \n  \n```  \n// crt_set_se_translator_clr.cpp  \n// compile with: /clr  \n#include <windows.h>  \n#include <eh.h>  \n#include <assert.h>  \n#include <stdio.h>  \n  \nint thrower_func(int i) {  \n   int j = i/0;  \n  return 0;  \n}  \n  \nclass CMyException{  \n};  \n  \n#pragma unmanaged  \nvoid my_trans_func(unsigned int u, PEXCEPTION_POINTERS pExp )  \n{  \nprintf(\"Translating the structured exception to a C++\"  \n             \" exception.\\n\");  \nthrow CMyException();  \n}  \n  \nvoid DoTest()  \n{  \n    try  \n    {  \n      thrower_func(10);  \n    }   \n  \n    catch(CMyException e)  \n    {  \nprintf(\"Caught CMyException.\\n\");  \n    }  \n    catch(...)  \n    {  \n      printf(\"Caught unexpected SEH exception.\\n\");  \n    }  \n}  \n#pragma managed  \n  \nint main(int argc, char** argv) {  \n    _set_se_translator(my_trans_func);  \n    DoTest();  \n    return 0;  \n}  \n```  \n  \n```Output  \nTranslating the structured exception to a C++ exception.  \nCaught CMyException.  \n```  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [Exception Handling Routines](../../c-runtime-library/exception-handling-routines.md)   \n [set_terminate](../../c-runtime-library/reference/set-terminate-crt.md)   \n [set_unexpected](../../c-runtime-library/reference/set-unexpected-crt.md)   \n [terminate](../../c-runtime-library/reference/terminate-crt.md)   \n [unexpected](../../c-runtime-library/reference/unexpected-crt.md)"}