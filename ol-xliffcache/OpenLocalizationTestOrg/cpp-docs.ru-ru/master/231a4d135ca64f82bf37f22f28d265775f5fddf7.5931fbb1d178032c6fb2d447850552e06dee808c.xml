{"nodes":[{"pos":[12,62],"content":"Constraints of Delay Loading DLLs | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Constraints of Delay Loading DLLs | Microsoft Docs","pos":[0,50]}]},{"content":"Constraints of Delay Loading DLLs","pos":[686,719]},{"content":"There are constraints regarding the delay loading of imports.","pos":[720,781]},{"content":"Imports of data cannot be supported.","pos":[791,827]},{"content":"A workaround is to explicitly handle the data import yourself using <ph id=\"ph1\">`LoadLibrary`</ph> (or <ph id=\"ph2\">`GetModuleHandle`</ph> after you know the delay-load helper has loaded the DLL) and <ph id=\"ph3\">`GetProcAddress`</ph>.","pos":[828,1010],"source":" A workaround is to explicitly handle the data import yourself using `LoadLibrary` (or `GetModuleHandle` after you know the delay-load helper has loaded the DLL) and `GetProcAddress`."},{"content":"Delay loading Kernel32.dll is not supported.","pos":[1020,1064]},{"content":"This DLL is necessary for the delay-load helper routines to perform the delay loading.","pos":[1065,1151]},{"pos":[1161,1265],"content":"<bpt id=\"p1\">[</bpt>Binding<ept id=\"p1\">](../../build/reference/binding-imports.md)</ept> of entry points that are forwarded is not supported.","source":"[Binding](../../build/reference/binding-imports.md) of entry points that are forwarded is not supported."},{"content":"Delay loading of a DLL may not result in the same behavior of the process if there are per-process initializations that occur in the entry point of the delay-loaded DLL.","pos":[1275,1444]},{"content":"Other cases include static TLS (thread local storage), declared using <bpt id=\"p1\">[</bpt>__declspec(thread)<ept id=\"p1\">](../../cpp/thread.md)</ept>, which is not handled when the DLL is loaded via <ph id=\"ph1\">`LoadLibrary`</ph>.","pos":[1445,1620],"source":" Other cases include static TLS (thread local storage), declared using [__declspec(thread)](../../cpp/thread.md), which is not handled when the DLL is loaded via `LoadLibrary`."},{"content":"Dynamic TLS, using <ph id=\"ph1\">`TlsAlloc`</ph>, <ph id=\"ph2\">`TlsFree`</ph>, <ph id=\"ph3\">`TlsGetValue`</ph>, and <ph id=\"ph4\">`TlsSetValue`</ph>, is still available for use in either static or delay-loaded DLLs.","pos":[1621,1762],"source":" Dynamic TLS, using `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue`, is still available for use in either static or delay-loaded DLLs."},{"content":"Static (global) function pointers should be reinitialized to imported functions after the first call to the function.","pos":[1772,1889]},{"content":"This is because the first use of the function pointer will point to the thunk.","pos":[1890,1968]},{"content":"There is no way currently to delay the loading of only specific procedures from a DLL while using the normal import mechanism.","pos":[1978,2104]},{"content":"Custom calling conventions (such as using condition codes on x86 architectures) are not supported.","pos":[2114,2212]},{"content":"Also, the floating-point registers are not saved on any platform.","pos":[2213,2278]},{"content":"If your custom helper routine or hook routines use floating-point types, they need to completely save and restore the floating-point state on machines with register calling conventions with floating-point parameters.","pos":[2279,2495]},{"content":"Be careful about delay loading the CRT DLL if you call CRT functions that take floating-point parameters on a numeric data processor (NDP) stack in the help function.","pos":[2496,2662]},{"content":"See Also","pos":[2671,2679]},{"content":"Linker Support for Delay-Loaded DLLs","pos":[2684,2720]},{"content":"LoadLibrary function","pos":[2790,2810]},{"content":"GetModuleHandle function","pos":[2882,2906]},{"content":"GetProcAddress function","pos":[2978,3001]},{"content":"TlsAlloc function","pos":[3073,3090]},{"content":"TlsFree function","pos":[3162,3178]},{"content":"TlsGetValue function","pos":[3250,3270]},{"content":"TlsSetValue function","pos":[3342,3362]}],"content":"---\ntitle: \"Constraints of Delay Loading DLLs | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"constraints [C++], delayed loading of DLLs\"\n  - \"delayed loading of DLLs, constraints\"\n  - \"DLLs [C++], constraints\"\nms.assetid: 0097ff65-550f-4a4e-8ac3-39bf6404f926\ncaps.latest.revision: 8\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Constraints of Delay Loading DLLs\nThere are constraints regarding the delay loading of imports.  \n  \n-   Imports of data cannot be supported. A workaround is to explicitly handle the data import yourself using `LoadLibrary` (or `GetModuleHandle` after you know the delay-load helper has loaded the DLL) and `GetProcAddress`.  \n  \n-   Delay loading Kernel32.dll is not supported. This DLL is necessary for the delay-load helper routines to perform the delay loading.  \n  \n-   [Binding](../../build/reference/binding-imports.md) of entry points that are forwarded is not supported.  \n  \n-   Delay loading of a DLL may not result in the same behavior of the process if there are per-process initializations that occur in the entry point of the delay-loaded DLL. Other cases include static TLS (thread local storage), declared using [__declspec(thread)](../../cpp/thread.md), which is not handled when the DLL is loaded via `LoadLibrary`. Dynamic TLS, using `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue`, is still available for use in either static or delay-loaded DLLs.  \n  \n-   Static (global) function pointers should be reinitialized to imported functions after the first call to the function. This is because the first use of the function pointer will point to the thunk.  \n  \n-   There is no way currently to delay the loading of only specific procedures from a DLL while using the normal import mechanism.  \n  \n-   Custom calling conventions (such as using condition codes on x86 architectures) are not supported. Also, the floating-point registers are not saved on any platform. If your custom helper routine or hook routines use floating-point types, they need to completely save and restore the floating-point state on machines with register calling conventions with floating-point parameters. Be careful about delay loading the CRT DLL if you call CRT functions that take floating-point parameters on a numeric data processor (NDP) stack in the help function.  \n  \n## See Also  \n [Linker Support for Delay-Loaded DLLs](../../build/reference/linker-support-for-delay-loaded-dlls.md)   \n [LoadLibrary function](http://msdn.microsoft.com/library/windows/desktop/ms684175.aspx)   \n [GetModuleHandle function](http://msdn.microsoft.com/library/windows/desktop/ms683199.aspx)   \n [GetProcAddress function](http://msdn.microsoft.com/library/windows/desktop/ms683212.aspx)   \n [TlsAlloc function](http://msdn.microsoft.com/library/windows/desktop/ms686801.aspx)   \n [TlsFree function](http://msdn.microsoft.com/library/windows/desktop/ms686804.aspx)   \n [TlsGetValue function](http://msdn.microsoft.com/library/windows/desktop/ms686812.aspx)   \n [TlsSetValue function](http://msdn.microsoft.com/library/windows/desktop/ms686818.aspx)"}