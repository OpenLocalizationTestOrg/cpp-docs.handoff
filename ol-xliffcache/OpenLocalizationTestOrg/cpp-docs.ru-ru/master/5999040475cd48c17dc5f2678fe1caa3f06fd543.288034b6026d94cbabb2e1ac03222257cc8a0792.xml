{"nodes":[{"pos":[12,52],"content":"&lt;regex&gt; operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>regex<ph id=\"ph2\">&amp;gt;</ph> operators | Microsoft Docs","pos":[0,40],"source":"&lt;regex&gt; operators | Microsoft Docs"}]},{"pos":[255,278],"content":"&lt;regex&gt; operators","linkify":"&lt;regex&gt; operators","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>regex<ph id=\"ph2\">&amp;gt;</ph> operators","pos":[0,23],"source":"&lt;regex&gt; operators"}]},{"pos":[297,324],"content":"<bpt id=\"p1\">[</bpt>operator!=<ept id=\"p1\">](#operator_neq)</ept>","source":"[operator!=](#operator_neq)"},{"pos":[325,354],"content":"<bpt id=\"p1\">[</bpt>operator<ph id=\"ph1\">&amp;gt;</ph><ept id=\"p1\">](#operator_gt_)</ept>","source":"[operator&gt;](#operator_gt_)"},{"pos":[355,388],"content":"<bpt id=\"p1\">[</bpt>operator<ph id=\"ph1\">&amp;gt;</ph><ph id=\"ph2\">=</ph><ept id=\"p1\">](#operator_gt__eq)</ept>","source":"[operator&gt;=](#operator_gt__eq)"},{"pos":[393,422],"content":"<bpt id=\"p1\">[</bpt>operator<ph id=\"ph1\">&amp;lt;</ph><ept id=\"p1\">](#operator_lt_)</ept>","source":"[operator&lt;](#operator_lt_)"},{"pos":[423,460],"content":"<bpt id=\"p1\">[</bpt>operator<ph id=\"ph1\">&amp;lt;</ph><ph id=\"ph2\">&amp;lt;</ph><ept id=\"p1\">](#operator_lt__lt_)</ept>","source":"[operator&lt;&lt;](#operator_lt__lt_)"},{"pos":[461,494],"content":"<bpt id=\"p1\">[</bpt>operator<ph id=\"ph1\">&amp;lt;</ph><ph id=\"ph2\">=</ph><ept id=\"p1\">](#operator_lt__eq)</ept>","source":"[operator&lt;=](#operator_lt__eq)"},{"pos":[499,528],"content":"<bpt id=\"p1\">[</bpt>operator==<ept id=\"p1\">](#operator_eq_eq)</ept>","source":"[operator==](#operator_eq_eq)"},{"pos":[539,578],"content":"<bpt id=\"p1\">&lt;a name=\"operator_neq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator!=","linkify":"<a name=\"operator_neq\"></a>  operator!=","source":"<a name=\"operator_neq\"></a>  operator!="},{"content":"Not equal comparison for various objects.","pos":[582,623]},{"pos":[1849,1859],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type.","pos":[1874,1892]},{"content":"The string traits class.","pos":[1913,1937]},{"content":"The allocator class.","pos":[1955,1975]},{"content":"The left object to compare.","pos":[1992,2019]},{"content":"The right object to compare.","pos":[2037,2065]},{"pos":[2075,2082],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[2086,2136],"content":"Each template operator returns <ph id=\"ph1\">`!(left == right)`</ph>.","source":"Each template operator returns `!(left == right)`."},{"pos":[2146,2153],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[3761,3802],"content":"<bpt id=\"p1\">&lt;a name=\"operator_lt_\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator<ph id=\"ph1\">&amp;lt;</ph>","linkify":"<a name=\"operator_lt_\"></a>  operator&lt;","source":"<a name=\"operator_lt_\"></a>  operator&lt;"},{"content":"Less than comparison for various objects.","pos":[3806,3847]},{"pos":[4921,4931],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type.","pos":[4946,4964]},{"content":"The string traits class.","pos":[4985,5009]},{"content":"The allocator class.","pos":[5027,5047]},{"content":"The left object to compare.","pos":[5064,5091]},{"content":"The right object to compare.","pos":[5109,5137]},{"pos":[5147,5154],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5158,5326],"content":"Each template operator converts its arguments to a string type and returns true only if the converted value of <ph id=\"ph1\">`left`</ph> compares less than the converted value of <ph id=\"ph2\">`right`</ph>.","source":"Each template operator converts its arguments to a string type and returns true only if the converted value of `left` compares less than the converted value of `right`."},{"pos":[5336,5343],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6735,6784],"content":"<bpt id=\"p1\">&lt;a name=\"operator_lt__lt_\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator<ph id=\"ph1\">&amp;lt;</ph><ph id=\"ph2\">&amp;lt;</ph>","linkify":"<a name=\"operator_lt__lt_\"></a>  operator&lt;&lt;","source":"<a name=\"operator_lt__lt_\"></a>  operator&lt;&lt;"},{"content":"Inserts a sub_match in a stream.","pos":[6788,6820]},{"pos":[7026,7036],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The element type.","pos":[7050,7067]},{"content":"The string traits class.","pos":[7088,7112]},{"content":"The allocator class.","pos":[7130,7150]},{"content":"The iterator type.","pos":[7168,7186]},{"content":"The output stream.","pos":[7201,7219]},{"content":"The object to insert.","pos":[7237,7258]},{"pos":[7268,7275],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[7279,7329],"content":"The template operator returns <ph id=\"ph1\">`os &lt;&lt; right.str()`</ph>.","source":"The template operator returns `os << right.str()`."},{"pos":[7339,7346],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[7783,7828],"content":"<bpt id=\"p1\">&lt;a name=\"operator_lt__eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator<ph id=\"ph1\">&amp;lt;</ph><ph id=\"ph2\">=</ph>","linkify":"<a name=\"operator_lt__eq\"></a>  operator&lt;=","source":"<a name=\"operator_lt__eq\"></a>  operator&lt;="},{"content":"Less than or equal comparison for various objects.","pos":[7832,7882]},{"pos":[8963,8973],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type.","pos":[8988,9006]},{"content":"The string traits class.","pos":[9027,9051]},{"content":"The allocator class.","pos":[9069,9089]},{"content":"The left object to compare.","pos":[9106,9133]},{"content":"The right object to compare.","pos":[9151,9179]},{"pos":[9189,9196],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[9200,9249],"content":"Each template operator returns <ph id=\"ph1\">`!(right &lt; left)`</ph>.","source":"Each template operator returns `!(right < left)`."},{"pos":[9259,9266],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[10678,10719],"content":"<bpt id=\"p1\">&lt;a name=\"operator_eq_eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator==","linkify":"<a name=\"operator_eq_eq\"></a>  operator==","source":"<a name=\"operator_eq_eq\"></a>  operator=="},{"content":"Equal comparison for various objects.","pos":[10723,10760]},{"pos":[11986,11996],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type.","pos":[12011,12029]},{"content":"The string traits class.","pos":[12050,12074]},{"content":"The allocator class.","pos":[12092,12112]},{"content":"The left object to compare.","pos":[12129,12156]},{"content":"The right object to compare.","pos":[12174,12202]},{"pos":[12212,12219],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Each template operator converts each of its arguments to a string type and returns the result of comparing the converted objects for equality.","pos":[12223,12365]},{"content":"When a template operator converts its arguments to a string type it uses the first of the following transformations that applies:","pos":[12372,12501]},{"pos":[12508,12651],"content":"arguments whose types are a specialization of template class <ph id=\"ph1\">`match_results`</ph> or <ph id=\"ph2\">`sub_match`</ph> are converted by calling the <ph id=\"ph3\">`str`</ph> member function;","source":"arguments whose types are a specialization of template class `match_results` or `sub_match` are converted by calling the `str` member function;"},{"pos":[12658,12752],"content":"arguments whose types are a specialization of the template class <ph id=\"ph1\">`basic_string`</ph> are unchanged;","source":"arguments whose types are a specialization of the template class `basic_string` are unchanged;"},{"pos":[12759,12918],"content":"all other argument types are converted by passing the argument value to the constructor for an appropriate specialization of the template class <ph id=\"ph1\">`basic_string`</ph>.","source":"all other argument types are converted by passing the argument value to the constructor for an appropriate specialization of the template class `basic_string`."},{"pos":[12928,12935],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[14547,14588],"content":"<bpt id=\"p1\">&lt;a name=\"operator_gt_\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator<ph id=\"ph1\">&amp;gt;</ph>","linkify":"<a name=\"operator_gt_\"></a>  operator&gt;","source":"<a name=\"operator_gt_\"></a>  operator&gt;"},{"content":"Greater than comparison for various objects.","pos":[14592,14636]},{"pos":[15710,15720],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type.","pos":[15735,15753]},{"content":"The string traits class.","pos":[15774,15798]},{"content":"The allocator class.","pos":[15816,15836]},{"content":"The left object to compare.","pos":[15853,15880]},{"content":"The right object to compare.","pos":[15898,15926]},{"pos":[15936,15943],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[15947,15993],"content":"Each template operator returns <ph id=\"ph1\">`right &lt; left`</ph>.","source":"Each template operator returns `right < left`."},{"pos":[16003,16010],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[17402,17447],"content":"<bpt id=\"p1\">&lt;a name=\"operator_gt__eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator<ph id=\"ph1\">&amp;gt;</ph><ph id=\"ph2\">=</ph>","linkify":"<a name=\"operator_gt__eq\"></a>  operator&gt;=","source":"<a name=\"operator_gt__eq\"></a>  operator&gt;="},{"content":"Greater than or equal comparison for various objects.","pos":[17451,17504]},{"pos":[18585,18595],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type.","pos":[18610,18628]},{"content":"The string traits class.","pos":[18649,18673]},{"content":"The allocator class.","pos":[18691,18711]},{"content":"The left object to compare.","pos":[18728,18755]},{"content":"The right object to compare.","pos":[18773,18801]},{"pos":[18811,18818],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[18822,18871],"content":"Each template operator returns <ph id=\"ph1\">`!(left &lt; right)`</ph>.","source":"Each template operator returns `!(left < right)`."},{"pos":[18881,18888],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[20307,20315],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[20319,20359],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>regex&gt;<ept id=\"p1\">](../standard-library/regex.md)</ept>","source":"[\\<regex>](../standard-library/regex.md)"}],"content":"---\ntitle: \"&lt;regex&gt; operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: ec623e65-c186-491f-aa18-6b12b47e1127\ncaps.latest.revision: 12\nmanager: \"ghogen\"\n---\n# &lt;regex&gt; operators\n||||  \n|-|-|-|  \n|[operator!=](#operator_neq)|[operator&gt;](#operator_gt_)|[operator&gt;=](#operator_gt__eq)|  \n|[operator&lt;](#operator_lt_)|[operator&lt;&lt;](#operator_lt__lt_)|[operator&lt;=](#operator_lt__eq)|  \n|[operator==](#operator_eq_eq)|  \n  \n##  <a name=\"operator_neq\"></a>  operator!=  \n Not equal comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator!=(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator!=(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator!=(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator!=(const typename iterator_traits<BidIt>::value_type *left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator!=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type *right);\n\ntemplate <class BidIt>  \nbool operator!=(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator!=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n\ntemplate <class BidIt, class Alloc>  \nbool operator!=(const match_results<BidIt, Alloc>& left,  \n    const match_results<BidIt, Alloc>& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator returns `!(left == right)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_ne.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"match == \" << mr.str() << std::endl;   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"match != match == \" << std::boolalpha   \n        << (mr != mr) << std::endl;   \n    std::cout << \"sub != sub == \" << std::boolalpha   \n        << (sub != sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") != sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") != sub) << std::endl;   \n    std::cout << \"sub != string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub != Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" != sub == \" << std::boolalpha   \n        << (\"aab\" != sub) << std::endl;   \n    std::cout << \"sub != \\\"aab\\\" == \" << std::boolalpha   \n        << (sub != \"aab\") << std::endl;   \n  \n    std::cout << \"'a' != sub == \" << std::boolalpha   \n        << ('a' != sub) << std::endl;   \n    std::cout << \"sub != 'a' == \" << std::boolalpha   \n        << (sub != 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == caaa  \nsub == aaa  \n  \nmatch != match == false  \nsub != sub == false  \nstring(\"aab\") != sub == true  \nsub != string(\"aab\") == true  \n\"aab\" != sub == true  \nsub != \"aab\" == true  \n'a' != sub == true  \nsub != 'a' == true  \n```  \n  \n##  <a name=\"operator_lt_\"></a>  operator&lt;  \n Less than comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator<(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator<(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator<(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator<(const typename iterator_traits<BidIt>::value_type *left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator<(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type *right);\n\ntemplate <class BidIt>  \nbool operator<(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator<(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator converts its arguments to a string type and returns true only if the converted value of `left` compares less than the converted value of `right`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_lt.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"sub < sub == \" << std::boolalpha   \n        << (sub < sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") < sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") < sub) << std::endl;   \n    std::cout << \"sub < string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub < Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" < sub == \" << std::boolalpha   \n        << (\"aab\" < sub) << std::endl;   \n    std::cout << \"sub < \\\"aab\\\" == \" << std::boolalpha   \n        << (sub < \"aab\") << std::endl;   \n  \n    std::cout << \"'a' < sub == \" << std::boolalpha   \n        << ('a' < sub) << std::endl;   \n    std::cout << \"sub < 'a' == \" << std::boolalpha   \n        << (sub < 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsub == aaa  \n  \nsub < sub == false  \nstring(\"aab\") < sub == false  \nsub < string(\"aab\") == true  \n\"aab\" < sub == false  \nsub < \"aab\" == true  \n'a' < sub == true  \nsub < 'a' == false  \n```  \n  \n##  <a name=\"operator_lt__lt_\"></a>  operator&lt;&lt;  \n Inserts a sub_match in a stream.  \n  \n```  \ntemplate <class Elem, class IOtraits, class Alloc, class BidIt>  \nbasic_ostream<Elem, IOtraits>& operator<<(basic_ostream<Elem, IOtraits>& os,  \n    const sub_match<BidIt>& right);\n```  \n  \n### Parameters  \n `Elem`  \n The element type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `BidIt`  \n The iterator type.  \n  \n `os`  \n The output stream.  \n  \n `right`  \n The object to insert.  \n  \n### Remarks  \n The template operator returns `os << right.str()`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_ins.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[0];   \n    std::cout << \"whole match: \" << sub << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nwhole match: caaa  \n```  \n  \n##  <a name=\"operator_lt__eq\"></a>  operator&lt;=  \n Less than or equal comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator<=(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator<=(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator<=(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator<=(const typename iterator_traits<BidIt>::value_type *left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator<=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type *right);\n\ntemplate <class BidIt>  \nbool operator<=(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator<=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator returns `!(right < left)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_le.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"sub <= sub == \" << std::boolalpha   \n        << (sub <= sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") <= sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") <= sub) << std::endl;   \n    std::cout << \"sub <= string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub <= Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" <= sub == \" << std::boolalpha   \n        << (\"aab\" <= sub) << std::endl;   \n    std::cout << \"sub <= \\\"aab\\\" == \" << std::boolalpha   \n        << (sub <= \"aab\") << std::endl;   \n  \n    std::cout << \"'a' <= sub == \" << std::boolalpha   \n        << ('a' <= sub) << std::endl;   \n    std::cout << \"sub <= 'a' == \" << std::boolalpha   \n        << (sub <= 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsub == aaa  \n  \nsub <= sub == true  \nstring(\"aab\") <= sub == false  \nsub <= string(\"aab\") == true  \n\"aab\" <= sub == false  \nsub <= \"aab\" == true  \n'a' <= sub == true  \nsub <= 'a' == false  \n```  \n  \n##  <a name=\"operator_eq_eq\"></a>  operator==  \n Equal comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator==(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator==(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator==(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator==(const typename iterator_traits<BidIt>::value_type* left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator==(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type* right);\n\ntemplate <class BidIt>  \nbool operator==(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator==(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n\ntemplate <class BidIt, class Alloc>  \nbool operator==(const match_results<BidIt, Alloc>& left,  \n    const match_results<BidIt, Alloc>& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator converts each of its arguments to a string type and returns the result of comparing the converted objects for equality.  \n  \n When a template operator converts its arguments to a string type it uses the first of the following transformations that applies:  \n  \n arguments whose types are a specialization of template class `match_results` or `sub_match` are converted by calling the `str` member function;  \n  \n arguments whose types are a specialization of the template class `basic_string` are unchanged;  \n  \n all other argument types are converted by passing the argument value to the constructor for an appropriate specialization of the template class `basic_string`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_eq.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"match == \" << mr.str() << std::endl;   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"match == match == \" << std::boolalpha   \n        << (mr == mr) << std::endl;   \n    std::cout << \"sub == sub == \" << std::boolalpha   \n        << (sub == sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") == sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") == sub) << std::endl;   \n    std::cout << \"sub == string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub == Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" == sub == \" << std::boolalpha   \n        << (\"aab\" == sub) << std::endl;   \n    std::cout << \"sub == \\\"aab\\\" == \" << std::boolalpha   \n        << (sub == \"aab\") << std::endl;   \n  \n    std::cout << \"'a' == sub == \" << std::boolalpha   \n        << ('a' == sub) << std::endl;   \n    std::cout << \"sub == 'a' == \" << std::boolalpha   \n        << (sub == 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == caaa  \nsub == aaa  \n  \nmatch == match == true  \nsub == sub == true  \nstring(\"aab\") == sub == false  \nsub == string(\"aab\") == false  \n\"aab\" == sub == false  \nsub == \"aab\" == false  \n'a' == sub == false  \nsub == 'a' == false  \n```  \n  \n##  <a name=\"operator_gt_\"></a>  operator&gt;  \n Greater than comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator>(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator>(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator>(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator>(const typename iterator_traits<BidIt>::value_type *left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator>(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type *right);\n\ntemplate <class BidIt>  \nbool operator>(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator>(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator returns `right < left`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_gt.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"sub > sub == \" << std::boolalpha   \n        << (sub > sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") > sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") > sub) << std::endl;   \n    std::cout << \"sub > string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub > Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" > sub == \" << std::boolalpha   \n        << (\"aab\" > sub) << std::endl;   \n    std::cout << \"sub > \\\"aab\\\" == \" << std::boolalpha   \n        << (sub > \"aab\") << std::endl;   \n  \n    std::cout << \"'a' > sub == \" << std::boolalpha   \n        << ('a' > sub) << std::endl;   \n    std::cout << \"sub > 'a' == \" << std::boolalpha   \n        << (sub > 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsub == aaa  \n  \nsub > sub == false  \nstring(\"aab\") > sub == true  \nsub > string(\"aab\") == false  \n\"aab\" > sub == true  \nsub > \"aab\" == false  \n'a' > sub == false  \nsub > 'a' == true  \n```  \n  \n##  <a name=\"operator_gt__eq\"></a>  operator&gt;=  \n Greater than or equal comparison for various objects.  \n  \n```  \ntemplate <class BidIt>  \nbool operator>=(const sub_match<BidIt>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator>=(\n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt, class IOtraits, class Alloc>  \nbool operator>=(const sub_match<BidIt>& left,  \n    const basic_string<typename iterator_traits<BidIt>::value_type, IOtraits, Alloc>& right);\n\ntemplate <class BidIt>  \nbool operator>=(const typename iterator_traits<BidIt>::value_type *left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator>=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type *right);\n\ntemplate <class BidIt>  \nbool operator>=(const typename iterator_traits<BidIt>::value_type& left,  \n    const sub_match<BidIt>& right);\n\ntemplate <class BidIt>  \nbool operator>=(const sub_match<BidIt>& left,  \n    const typename iterator_traits<BidIt>::value_type& right);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `Alloc`  \n The allocator class.  \n  \n `left`  \n The left object to compare.  \n  \n `right`  \n The right object to compare.  \n  \n### Remarks  \n Each template operator returns `!(left < right)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__operator_ge.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::tr1std::cmatch::string_type Mystr;   \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"sub == \" << sub << std::endl;   \n    std::cout << std::endl;   \n  \n    std::cout << \"sub >= sub == \" << std::boolalpha   \n        << (sub >= sub) << std::endl;   \n  \n    std::cout << \"string(\\\"aab\\\") >= sub == \" << std::boolalpha   \n        << (Mystr(\"aab\") >= sub) << std::endl;   \n    std::cout << \"sub >= string(\\\"aab\\\") == \" << std::boolalpha   \n        << (sub >= Mystr(\"aab\")) << std::endl;   \n  \n    std::cout << \"\\\"aab\\\" >= sub == \" << std::boolalpha   \n        << (\"aab\" >= sub) << std::endl;   \n    std::cout << \"sub >= \\\"aab\\\" == \" << std::boolalpha   \n        << (sub >= \"aab\") << std::endl;   \n  \n    std::cout << \"'a' >= sub == \" << std::boolalpha   \n        << ('a' >= sub) << std::endl;   \n    std::cout << \"sub >= 'a' == \" << std::boolalpha   \n        << (sub >= 'a') << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsub == aaa  \n  \nsub >= sub == true  \nstring(\"aab\") >= sub == true  \nsub >= string(\"aab\") == false  \n\"aab\" >= sub == true  \nsub >= \"aab\" == false  \n'a' >= sub == false  \nsub >= 'a' == true  \n```  \n  \n## See Also  \n [\\<regex>](../standard-library/regex.md)\n\n"}