{"nodes":[{"pos":[12,47],"content":"CAsyncSocket Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CAsyncSocket Class | Microsoft Docs","pos":[0,35]}]},{"content":"CAsyncSocket Class","pos":[781,799]},{"content":"Represents a Windows Socket â€” an endpoint of network communication.","pos":[800,867]},{"content":"Syntax","pos":[876,882]},{"content":"Members","pos":[944,951]},{"content":"Public Constructors","pos":[961,980]},{"content":"Name","pos":[987,991]},{"content":"Description","pos":[992,1003]},{"content":"CAsyncSocket::CAsyncSocket","pos":[1042,1068]},{"pos":[1099,1134],"content":"Constructs a <ph id=\"ph1\">`CAsyncSocket`</ph> object.","source":"Constructs a `CAsyncSocket` object."},{"content":"Public Methods","pos":[1145,1159]},{"content":"Name","pos":[1166,1170]},{"content":"Description","pos":[1171,1182]},{"content":"CAsyncSocket::Accept","pos":[1221,1241]},{"content":"Accepts a connection on the socket.","pos":[1266,1301]},{"content":"CAsyncSocket::AsyncSelect","pos":[1307,1332]},{"content":"Requests event notification for the socket.","pos":[1362,1405]},{"content":"CAsyncSocket::Attach","pos":[1411,1431]},{"pos":[1456,1508],"content":"Attaches a socket handle to a <ph id=\"ph1\">`CAsyncSocket`</ph> object.","source":"Attaches a socket handle to a `CAsyncSocket` object."},{"content":"CAsyncSocket::Bind","pos":[1514,1532]},{"content":"Associates a local address with the socket.","pos":[1555,1598]},{"content":"CAsyncSocket::Close","pos":[1604,1623]},{"content":"Closes the socket.","pos":[1647,1665]},{"content":"CAsyncSocket::Connect","pos":[1671,1692]},{"content":"Establishes a connection to a peer socket.","pos":[1718,1760]},{"content":"CAsyncSocket::Create","pos":[1766,1786]},{"content":"Creates a socket.","pos":[1811,1828]},{"content":"CAsyncSocket::Detach","pos":[1834,1854]},{"pos":[1879,1933],"content":"Detaches a socket handle from a <ph id=\"ph1\">`CAsyncSocket`</ph> object.","source":"Detaches a socket handle from a `CAsyncSocket` object."},{"content":"CAsyncSocket::FromHandle","pos":[1939,1963]},{"pos":[1992,2060],"content":"Returns a pointer to a <ph id=\"ph1\">`CAsyncSocket`</ph> object, given a socket handle.","source":"Returns a pointer to a `CAsyncSocket` object, given a socket handle."},{"content":"CAsyncSocket::GetLastError","pos":[2066,2092]},{"content":"Gets the error status for the last operation that failed.","pos":[2123,2180]},{"content":"CAsyncSocket::GetPeerName","pos":[2186,2211]},{"content":"Gets the address of the peer socket to which the socket is connected.","pos":[2241,2310]},{"content":"CAsyncSocket::GetPeerNameEx","pos":[2316,2343]},{"content":"Gets the address of the peer socket to which the socket is connected (handles IPv6 addresses).","pos":[2375,2469]},{"content":"CAsyncSocket::GetSockName","pos":[2475,2500]},{"content":"Gets the local name for a socket.","pos":[2530,2563]},{"content":"CAsyncSocket::GetSockNameEx","pos":[2569,2596]},{"content":"Gets the local name for a socket (handles IPv6 addresses).","pos":[2628,2686]},{"content":"CAsyncSocket::GetSockOpt","pos":[2692,2716]},{"content":"Retrieves a socket option.","pos":[2745,2771]},{"content":"CAsyncSocket::IOCtl","pos":[2777,2796]},{"content":"Controls the mode of the socket.","pos":[2820,2852]},{"content":"CAsyncSocket::Listen","pos":[2858,2878]},{"content":"Establishes a socket to listen for incoming connection requests.","pos":[2903,2967]},{"content":"CAsyncSocket::Receive","pos":[2973,2994]},{"content":"Receives data from the socket.","pos":[3020,3050]},{"content":"CAsyncSocket::ReceiveFrom","pos":[3056,3081]},{"content":"Receives a datagram and stores the source address.","pos":[3111,3161]},{"content":"CAsyncSocket::ReceiveFromEx","pos":[3167,3194]},{"content":"Receives a datagram and stores the source address (handles IPv6 addresses).","pos":[3226,3301]},{"content":"CAsyncSocket::Send","pos":[3307,3325]},{"content":"Sends data to a connected socket.","pos":[3348,3381]},{"content":"CAsyncSocket::SendTo","pos":[3387,3407]},{"content":"Sends data to a specific destination.","pos":[3432,3469]},{"content":"CAsyncSocket::SendToEx","pos":[3475,3497]},{"content":"Sends data to a specific destination (handles IPv6 addresses).","pos":[3524,3586]},{"content":"CAsyncSocket::SetSockOpt","pos":[3592,3616]},{"content":"Sets a socket option.","pos":[3645,3666]},{"content":"CAsyncSocket::ShutDown","pos":[3672,3694]},{"pos":[3721,3778],"content":"Disables <bpt id=\"p1\">**</bpt>Send<ept id=\"p1\">**</ept> and/or <bpt id=\"p2\">**</bpt>Receive<ept id=\"p2\">**</ept> calls on the socket.","source":"Disables **Send** and/or **Receive** calls on the socket."},{"content":"CASyncSocket::Socket","pos":[3784,3804]},{"content":"Allocates a socket handle.","pos":[3829,3855]},{"content":"Protected Methods","pos":[3866,3883]},{"content":"Name","pos":[3890,3894]},{"content":"Description","pos":[3895,3906]},{"content":"CAsyncSocket::OnAccept","pos":[3945,3967]},{"pos":[3994,4091],"content":"Notifies a listening socket that it can accept pending connection requests by calling <bpt id=\"p1\">**</bpt>Accept<ept id=\"p1\">**</ept>.","source":"Notifies a listening socket that it can accept pending connection requests by calling **Accept**."},{"content":"CAsyncSocket::OnClose","pos":[4097,4118]},{"content":"Notifies a socket that the socket connected to it has closed.","pos":[4144,4205]},{"content":"CAsyncSocket::OnConnect","pos":[4211,4234]},{"content":"Notifies a connecting socket that the connection attempt is complete, whether successfully or in error.","pos":[4262,4365]},{"content":"CAsyncSocket::OnOutOfBandData","pos":[4371,4400]},{"content":"Notifies a receiving socket that there is out-of-band data to be read on the socket, usually an urgent message.","pos":[4434,4545]},{"content":"CAsyncSocket::OnReceive","pos":[4551,4574]},{"pos":[4602,4688],"content":"Notifies a listening socket that there is data to be retrieved by calling <bpt id=\"p1\">**</bpt>Receive<ept id=\"p1\">**</ept>.","source":"Notifies a listening socket that there is data to be retrieved by calling **Receive**."},{"content":"CAsyncSocket::OnSend","pos":[4694,4714]},{"pos":[4739,4799],"content":"Notifies a socket that it can send data by calling <bpt id=\"p1\">**</bpt>Send<ept id=\"p1\">**</ept>.","source":"Notifies a socket that it can send data by calling **Send**."},{"content":"Public Operators","pos":[4810,4826]},{"content":"Name","pos":[4833,4837]},{"content":"Description","pos":[4838,4849]},{"content":"CAsyncSocket::operator =","pos":[4888,4912]},{"pos":[4943,4990],"content":"Assigns a new value to a <ph id=\"ph1\">`CAsyncSocket`</ph> object.","source":"Assigns a new value to a `CAsyncSocket` object."},{"content":"CAsyncSocket::operator SOCKET","pos":[4996,5025]},{"pos":[5059,5140],"content":"Use this operator to retrieve the <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> handle of the <ph id=\"ph1\">`CAsyncSocket`</ph> object.","source":"Use this operator to retrieve the **SOCKET** handle of the `CAsyncSocket` object."},{"content":"Public Data Members","pos":[5151,5170]},{"content":"Name","pos":[5177,5181]},{"content":"Description","pos":[5182,5193]},{"content":"CAsyncSocket::m_hSocket","pos":[5232,5255]},{"pos":[5283,5354],"content":"Indicates the <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> handle attached to this <ph id=\"ph1\">`CAsyncSocket`</ph> object.","source":"Indicates the **SOCKET** handle attached to this `CAsyncSocket` object."},{"content":"Remarks","pos":[5364,5371]},{"pos":[5375,5556],"content":"Class <ph id=\"ph1\">`CAsyncSocket`</ph> encapsulates the Windows Socket Functions API, providing an object-oriented abstraction for programmers who want to use Windows Sockets in conjunction with MFC.","source":"Class `CAsyncSocket` encapsulates the Windows Socket Functions API, providing an object-oriented abstraction for programmers who want to use Windows Sockets in conjunction with MFC."},{"content":"This class is based on the assumption that you understand network communications.","pos":[5563,5644]},{"content":"You are responsible for handling blocking, byte-order differences, and conversions between Unicode and multibyte character set (MBCS) strings.","pos":[5645,5787]},{"content":"If you want a more convenient interface that manages these issues for you, see class <bpt id=\"p1\">[</bpt>CSocket<ept id=\"p1\">](../../mfc/reference/csocket-class.md)</ept>.","pos":[5788,5921],"source":" If you want a more convenient interface that manages these issues for you, see class [CSocket](../../mfc/reference/csocket-class.md)."},{"content":"To use a <ph id=\"ph1\">`CAsyncSocket`</ph> object, call its constructor, then call the <bpt id=\"p1\">[</bpt>Create<ept id=\"p1\">](#casyncsocket__create)</ept> function to create the underlying socket handle (type <ph id=\"ph2\">`SOCKET`</ph>), except on accepted sockets.","pos":[5928,6120],"source":"To use a `CAsyncSocket` object, call its constructor, then call the [Create](#casyncsocket__create) function to create the underlying socket handle (type `SOCKET`), except on accepted sockets."},{"content":"For a server socket call the <bpt id=\"p1\">[</bpt>Listen<ept id=\"p1\">](#casyncsocket__listen)</ept> member function, and for a client socket call the <bpt id=\"p2\">[</bpt>Connect<ept id=\"p2\">](#casyncsocket__connect)</ept> member function.","pos":[6121,6282],"source":" For a server socket call the [Listen](#casyncsocket__listen) member function, and for a client socket call the [Connect](#casyncsocket__connect) member function."},{"content":"The server socket should call the <bpt id=\"p1\">[</bpt>Accept<ept id=\"p1\">](#casyncsocket__accept)</ept> function upon receiving a connection request.","pos":[6283,6394],"source":" The server socket should call the [Accept](#casyncsocket__accept) function upon receiving a connection request."},{"content":"Use the remaining <ph id=\"ph1\">`CAsyncSocket`</ph> functions to carry out communications between sockets.","pos":[6395,6482],"source":" Use the remaining `CAsyncSocket` functions to carry out communications between sockets."},{"content":"Upon completion, destroy the <ph id=\"ph1\">`CAsyncSocket`</ph> object if it was created on the heap; the destructor automatically calls the <bpt id=\"p1\">[</bpt>Close<ept id=\"p1\">](#casyncsocket__close)</ept> function.","pos":[6483,6643],"source":" Upon completion, destroy the `CAsyncSocket` object if it was created on the heap; the destructor automatically calls the [Close](#casyncsocket__close) function."},{"content":"The <ph id=\"ph1\">`SOCKET`</ph> data type is described in the article <bpt id=\"p1\">[</bpt>Windows Sockets: Background<ept id=\"p1\">](../../mfc/windows-sockets-background.md)</ept>.","pos":[6644,6766],"source":" The `SOCKET` data type is described in the article [Windows Sockets: Background](../../mfc/windows-sockets-background.md)."},{"pos":[6774,7033],"content":"[!NOTE]\n When using MFC sockets in secondary threads in a statically linked MFC application, you must call `AfxSocketInit` in each thread that uses sockets to initialize the socket libraries. By default, `AfxSocketInit` is called only in the primary thread.","leadings":["","> "],"nodes":[{"content":" When using MFC sockets in secondary threads in a statically linked MFC application, you must call `AfxSocketInit` in each thread that uses sockets to initialize the socket libraries. By default, `AfxSocketInit` is called only in the primary thread.","pos":[8,257],"nodes":[{"content":"When using MFC sockets in secondary threads in a statically linked MFC application, you must call <ph id=\"ph1\">`AfxSocketInit`</ph> in each thread that uses sockets to initialize the socket libraries.","pos":[1,183],"source":" When using MFC sockets in secondary threads in a statically linked MFC application, you must call `AfxSocketInit` in each thread that uses sockets to initialize the socket libraries."},{"content":"By default, <ph id=\"ph1\">`AfxSocketInit`</ph> is called only in the primary thread.","pos":[184,249],"source":" By default, `AfxSocketInit` is called only in the primary thread."}]}]},{"pos":[7040,7283],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Using Class CAsyncSocket<ept id=\"p1\">](../../mfc/windows-sockets-using-class-casyncsocket.md)</ept> and related articles., as well as <bpt id=\"p2\">[</bpt>Windows Sockets 2 API<ept id=\"p2\">](http://msdn.microsoft.com/library/windows/desktop/ms740673)</ept>.","source":"For more information, see [Windows Sockets: Using Class CAsyncSocket](../../mfc/windows-sockets-using-class-casyncsocket.md) and related articles., as well as [Windows Sockets 2 API](http://msdn.microsoft.com/library/windows/desktop/ms740673)."},{"content":"Inheritance Hierarchy","pos":[7292,7313]},{"content":"CObject","pos":[7318,7325]},{"content":"Requirements","pos":[7394,7406]},{"pos":[7410,7431],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afxsock.h","source":"**Header:** afxsock.h"},{"pos":[7478,7498],"content":"CAsyncSocket::Accept"},{"content":"Call this member function to accept a connection on a socket.","pos":[7502,7563]},{"content":"Parameters","pos":[7714,7724]},{"content":"A reference identifying a new socket that is available for connection.","pos":[7750,7820]},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>SOCKADDR<ept id=\"p1\">](../../mfc/reference/sockaddr-structure.md)</ept> structure that receives the address of the connecting socket, as known on the network.","pos":[7843,7998],"source":" A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that receives the address of the connecting socket, as known on the network."},{"content":"The exact format of the <ph id=\"ph1\">`lpSockAddr`</ph> argument is determined by the address family established when the socket was created.","pos":[7999,8121],"source":" The exact format of the `lpSockAddr` argument is determined by the address family established when the socket was created."},{"content":"If <ph id=\"ph1\">`lpSockAddr`</ph> and/or <ph id=\"ph2\">`lpSockAddrLen`</ph> are equal to <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, then no information about the remote address of the accepted socket is returned.","pos":[8122,8264],"source":" If `lpSockAddr` and/or `lpSockAddrLen` are equal to **NULL**, then no information about the remote address of the accepted socket is returned."},{"content":"A pointer to the length of the address in <ph id=\"ph1\">`lpSockAddr`</ph> in bytes.","pos":[8290,8354],"source":" A pointer to the length of the address in `lpSockAddr` in bytes."},{"content":"The <ph id=\"ph1\">`lpSockAddrLen`</ph> is a value-result parameter: it should initially contain the amount of space pointed to by <ph id=\"ph2\">`lpSockAddr`</ph>; on return it will contain the actual length (in bytes) of the address returned.","pos":[8355,8559],"source":" The `lpSockAddrLen` is a value-result parameter: it should initially contain the amount of space pointed to by `lpSockAddr`; on return it will contain the actual length (in bytes) of the address returned."},{"content":"Return Value","pos":[8569,8581]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[8585,8735],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[8736,8787]},{"pos":[8795,8956],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[8964,9058],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[9066,9212],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpSockAddrLen`</ph> argument is too small (less than the size of a <bpt id=\"p2\">[</bpt>SOCKADDR<ept id=\"p2\">](../../mfc/reference/sockaddr-structure.md)</ept> structure).","source":"**WSAEFAULT** The `lpSockAddrLen` argument is too small (less than the size of a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure)."},{"pos":[9220,9286],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets call is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets call is in progress."},{"pos":[9294,9349],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> <ph id=\"ph1\">`Listen`</ph> was not invoked prior to accept.","source":"**WSAEINVAL** `Listen` was not invoked prior to accept."},{"pos":[9357,9450],"content":"<bpt id=\"p1\">**</bpt>WSAEMFILE<ept id=\"p1\">**</ept> The queue is empty upon entry to accept and there are no descriptors available.","source":"**WSAEMFILE** The queue is empty upon entry to accept and there are no descriptors available."},{"pos":[9471,9500],"content":"No buffer space is available."},{"pos":[9508,9555],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"pos":[9563,9659],"content":"<bpt id=\"p1\">**</bpt>WSAEOPNOTSUPP<ept id=\"p1\">**</ept> The referenced socket is not a type that supports connection-oriented service.","source":"**WSAEOPNOTSUPP** The referenced socket is not a type that supports connection-oriented service."},{"pos":[9667,9768],"content":"<bpt id=\"p1\">**</bpt>WSAEWOULDBLOCK<ept id=\"p1\">**</ept> The socket is marked as nonblocking and no connections are present to be accepted.","source":"**WSAEWOULDBLOCK** The socket is marked as nonblocking and no connections are present to be accepted."},{"content":"Remarks","pos":[9778,9785]},{"content":"This routine extracts the first connection in the queue of pending connections, creates a new socket with the same properties as this socket, and attaches it to <ph id=\"ph1\">`rConnectedSocket`</ph>.","pos":[9789,9969],"source":"This routine extracts the first connection in the queue of pending connections, creates a new socket with the same properties as this socket, and attaches it to `rConnectedSocket`."},{"content":"If no pending connections are present on the queue, <bpt id=\"p1\">**</bpt>Accept<ept id=\"p1\">**</ept> returns zero and <ph id=\"ph1\">`GetLastError`</ph> returns an error.","pos":[9970,10082],"source":" If no pending connections are present on the queue, **Accept** returns zero and `GetLastError` returns an error."},{"content":"The accepted socket ( <bpt id=\"p1\">*</bpt>rConnectedSocket)<ept id=\"p1\">*</ept> cannot be used to accept more connections.","pos":[10083,10167],"source":" The accepted socket ( *rConnectedSocket)* cannot be used to accept more connections."},{"content":"The original socket remains open and listening.","pos":[10168,10215]},{"content":"The argument <ph id=\"ph1\">`lpSockAddr`</ph> is a result parameter that is filled in with the address of the connecting socket, as known to the communications layer.","pos":[10222,10368],"source":"The argument `lpSockAddr` is a result parameter that is filled in with the address of the connecting socket, as known to the communications layer."},{"content":"<bpt id=\"p1\">**</bpt>Accept<ept id=\"p1\">**</ept> is used with connection-based socket types such as <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept>.","pos":[10369,10447],"source":"**Accept** is used with connection-based socket types such as **SOCK_STREAM**."},{"pos":[10499,10524],"content":"CAsyncSocket::AsyncSelect"},{"content":"Call this member function to request event notification for a socket.","pos":[10528,10597]},{"content":"Parameters","pos":[10719,10729]},{"content":"A bitmask which specifies a combination of network events in which the application is interested.","pos":[10745,10842]},{"pos":[10850,10916],"content":"<bpt id=\"p1\">**</bpt>FD_READ<ept id=\"p1\">**</ept> Want to receive notification of readiness for reading.","source":"**FD_READ** Want to receive notification of readiness for reading."},{"pos":[10924,11000],"content":"<bpt id=\"p1\">**</bpt>FD_WRITE<ept id=\"p1\">**</ept> Want to receive notification when data is available to be read.","source":"**FD_WRITE** Want to receive notification when data is available to be read."},{"pos":[11008,11083],"content":"<bpt id=\"p1\">**</bpt>FD_OOB<ept id=\"p1\">**</ept> Want to receive notification of the arrival of out-of-band data.","source":"**FD_OOB** Want to receive notification of the arrival of out-of-band data."},{"pos":[11091,11158],"content":"<bpt id=\"p1\">**</bpt>FD_ACCEPT<ept id=\"p1\">**</ept> Want to receive notification of incoming connections.","source":"**FD_ACCEPT** Want to receive notification of incoming connections."},{"pos":[11166,11232],"content":"<bpt id=\"p1\">**</bpt>FD_CONNECT<ept id=\"p1\">**</ept> Want to receive notification of connection results.","source":"**FD_CONNECT** Want to receive notification of connection results."},{"pos":[11240,11322],"content":"<bpt id=\"p1\">**</bpt>FD_CLOSE<ept id=\"p1\">**</ept> Want to receive notification when a socket has been closed by a peer.","source":"**FD_CLOSE** Want to receive notification when a socket has been closed by a peer."},{"content":"Return Value","pos":[11332,11344]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[11348,11498],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[11499,11550]},{"pos":[11558,11719],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[11727,11821],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[11829,11902],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> Indicates that one of the specified parameters was invalid.","source":"**WSAEINVAL** Indicates that one of the specified parameters was invalid."},{"pos":[11910,11981],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"content":"Remarks","pos":[11991,11998]},{"content":"This function is used to specify which MFC callback notification functions will be called for the socket.","pos":[12002,12107]},{"content":"automatically sets this socket to nonblocking mode.","pos":[12122,12173]},{"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Windows Sockets: Socket Notifications<ept id=\"p1\">](../../mfc/windows-sockets-socket-notifications.md)</ept>.","pos":[12174,12303],"source":" For more information, see the article [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md)."},{"pos":[12350,12370],"content":"CAsyncSocket::Attach"},{"pos":[12374,12459],"content":"Call this member function to attach the <ph id=\"ph1\">`hSocket`</ph> handle to an <ph id=\"ph2\">`CAsyncSocket`</ph> object.","source":"Call this member function to attach the `hSocket` handle to an `CAsyncSocket` object."},{"content":"Parameters","pos":[12597,12607]},{"content":"Contains a handle to a socket.","pos":[12624,12654]},{"content":"A bitmask which specifies a combination of network events in which the application is interested.","pos":[12673,12770]},{"pos":[12778,12844],"content":"<bpt id=\"p1\">**</bpt>FD_READ<ept id=\"p1\">**</ept> Want to receive notification of readiness for reading.","source":"**FD_READ** Want to receive notification of readiness for reading."},{"pos":[12852,12928],"content":"<bpt id=\"p1\">**</bpt>FD_WRITE<ept id=\"p1\">**</ept> Want to receive notification when data is available to be read.","source":"**FD_WRITE** Want to receive notification when data is available to be read."},{"pos":[12936,13011],"content":"<bpt id=\"p1\">**</bpt>FD_OOB<ept id=\"p1\">**</ept> Want to receive notification of the arrival of out-of-band data.","source":"**FD_OOB** Want to receive notification of the arrival of out-of-band data."},{"pos":[13019,13086],"content":"<bpt id=\"p1\">**</bpt>FD_ACCEPT<ept id=\"p1\">**</ept> Want to receive notification of incoming connections.","source":"**FD_ACCEPT** Want to receive notification of incoming connections."},{"pos":[13094,13160],"content":"<bpt id=\"p1\">**</bpt>FD_CONNECT<ept id=\"p1\">**</ept> Want to receive notification of connection results.","source":"**FD_CONNECT** Want to receive notification of connection results."},{"pos":[13168,13250],"content":"<bpt id=\"p1\">**</bpt>FD_CLOSE<ept id=\"p1\">**</ept> Want to receive notification when a socket has been closed by a peer.","source":"**FD_CLOSE** Want to receive notification when a socket has been closed by a peer."},{"content":"Return Value","pos":[13260,13272]},{"content":"Nonzero if the function is successful.","pos":[13276,13314]},{"content":"Remarks","pos":[13324,13331]},{"pos":[13335,13433],"content":"The <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> handle is stored in the object's <bpt id=\"p2\">[</bpt>m_hSocket<ept id=\"p2\">](#casyncsocket__m_hsocket)</ept> data member.","source":"The **SOCKET** handle is stored in the object's [m_hSocket](#casyncsocket__m_hsocket) data member."},{"pos":[13478,13496],"content":"CAsyncSocket::Bind"},{"content":"Call this member function to associate a local address with the socket.","pos":[13500,13571]},{"content":"Parameters","pos":[13742,13752]},{"content":"The port identifying the socket application.","pos":[13773,13817]},{"content":"The network address, a dotted number such as \"128.56.22.8\".","pos":[13847,13906]},{"content":"Passing the <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> string for this parameter indicates the <bpt id=\"p2\">**</bpt>CAsyncSocket<ept id=\"p2\">**</ept> instance should listen for client activity on all network interfaces.","pos":[13907,14054],"source":" Passing the **NULL** string for this parameter indicates the **CAsyncSocket** instance should listen for client activity on all network interfaces."},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>SOCKADDR<ept id=\"p1\">](../../mfc/reference/sockaddr-structure.md)</ept> structure that contains the address to assign to this socket.","pos":[14077,14207],"source":" A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that contains the address to assign to this socket."},{"content":"The length of the address in <ph id=\"ph1\">`lpSockAddr`</ph> in bytes.","pos":[14232,14283],"source":" The length of the address in `lpSockAddr` in bytes."},{"content":"Return Value","pos":[14293,14305]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[14309,14459],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[14460,14511]},{"pos":[14519,14680],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[14688,14782],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"content":"<bpt id=\"p1\">**</bpt>WSAEADDRINUSE<ept id=\"p1\">**</ept> The specified address is already in use.","pos":[14790,14848],"source":"**WSAEADDRINUSE** The specified address is already in use."},{"content":"(See the <bpt id=\"p1\">**</bpt>SO_REUSEADDR<ept id=\"p1\">**</ept> socket option under <bpt id=\"p2\">[</bpt>SetSockOpt<ept id=\"p2\">](#casyncsocket__setsockopt)</ept>.)","pos":[14849,14936],"source":" (See the **SO_REUSEADDR** socket option under [SetSockOpt](#casyncsocket__setsockopt).)"},{"pos":[14944,15089],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`nSockAddrLen`</ph> argument is too small (less than the size of a <bpt id=\"p2\">[</bpt>SOCKADDR<ept id=\"p2\">](../../mfc/reference/sockaddr-structure.md)</ept> structure).","source":"**WSAEFAULT** The `nSockAddrLen` argument is too small (less than the size of a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure)."},{"pos":[15097,15163],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets call is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets call is in progress."},{"pos":[15171,15250],"content":"<bpt id=\"p1\">**</bpt>WSAEAFNOSUPPORT<ept id=\"p1\">**</ept> The specified address family is not supported by this port.","source":"**WSAEAFNOSUPPORT** The specified address family is not supported by this port."},{"pos":[15258,15314],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> The socket is already bound to an address.","source":"**WSAEINVAL** The socket is already bound to an address."},{"pos":[15335,15386],"content":"Not enough buffers available, too many connections."},{"pos":[15394,15441],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"content":"Remarks","pos":[15451,15458]},{"content":"This routine is used on an unconnected datagram or stream socket, before subsequent <bpt id=\"p1\">**</bpt>Connect<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`Listen`</ph> calls.","pos":[15462,15576],"source":"This routine is used on an unconnected datagram or stream socket, before subsequent **Connect** or `Listen` calls."},{"content":"Before it can accept connection requests, a listening server socket must select a port number and make it known to Windows Sockets by calling <bpt id=\"p1\">**</bpt>Bind<ept id=\"p1\">**</ept>.","pos":[15577,15728],"source":" Before it can accept connection requests, a listening server socket must select a port number and make it known to Windows Sockets by calling **Bind**."},{"content":"<bpt id=\"p1\">**</bpt>Bind<ept id=\"p1\">**</ept> establishes the local association (host address/port number) of the socket by assigning a local name to an unnamed socket.","pos":[15729,15860],"source":"**Bind** establishes the local association (host address/port number) of the socket by assigning a local name to an unnamed socket."},{"pos":[15913,15939],"content":"CAsyncSocket::CAsyncSocket"},{"content":"Constructs a blank socket object.","pos":[15943,15976]},{"content":"Remarks","pos":[16017,16024]},{"content":"After constructing the object, you must call its <bpt id=\"p1\">**</bpt>Create<ept id=\"p1\">**</ept> member function to create the <bpt id=\"p2\">**</bpt>SOCKET<ept id=\"p2\">**</ept> data structure and bind its address.","pos":[16028,16165],"source":"After constructing the object, you must call its **Create** member function to create the **SOCKET** data structure and bind its address."},{"content":"(On the server side of a Windows Sockets communication, when the listening socket creates a socket to use in the <bpt id=\"p1\">**</bpt>Accept<ept id=\"p1\">**</ept> call, you do not call <bpt id=\"p2\">**</bpt>Create<ept id=\"p2\">**</ept> for that socket.)","pos":[16166,16340],"source":" (On the server side of a Windows Sockets communication, when the listening socket creates a socket to use in the **Accept** call, you do not call **Create** for that socket.)"},{"pos":[16386,16405],"content":"CAsyncSocket::Close"},{"content":"Closes the socket.","pos":[16409,16427]},{"content":"Remarks","pos":[16474,16481]},{"content":"This function releases the socket descriptor so that further references to it will fail with the error <bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept>.","pos":[16485,16604],"source":"This function releases the socket descriptor so that further references to it will fail with the error **WSAENOTSOCK**."},{"content":"If this is the last reference to the underlying socket, the associated naming information and queued data are discarded.","pos":[16605,16725]},{"content":"The socket object's destructor calls <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept> for you.","pos":[16726,16781],"source":" The socket object's destructor calls **Close** for you."},{"content":"For <ph id=\"ph1\">`CAsyncSocket`</ph>, but not for <ph id=\"ph2\">`CSocket`</ph>, the semantics of <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept> are affected by the socket options <bpt id=\"p2\">**</bpt>SO_LINGER<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>SO_DONTLINGER<ept id=\"p3\">**</ept>.","pos":[16788,16929],"source":"For `CAsyncSocket`, but not for `CSocket`, the semantics of **Close** are affected by the socket options **SO_LINGER** and **SO_DONTLINGER**."},{"content":"For further information, see member function <ph id=\"ph1\">`GetSockOpt`</ph>.","pos":[16930,16988],"source":" For further information, see member function `GetSockOpt`."},{"pos":[17036,17057],"content":"CAsyncSocket::Connect"},{"content":"Call this member function to establish a connection to an unconnected stream or datagram socket.","pos":[17061,17157]},{"content":"Parameters","pos":[17322,17332]},{"content":"The network address of the socket to which this object is connected: a machine name such as \"ftp.microsoft.com\", or a dotted number such as \"128.56.22.8\".","pos":[17357,17511]},{"content":"The port identifying the socket application.","pos":[17533,17577]},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>SOCKADDR<ept id=\"p1\">](../../mfc/reference/sockaddr-structure.md)</ept> structure that contains the address of the connected socket.","pos":[17600,17729],"source":" A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that contains the address of the connected socket."},{"content":"The length of the address in <ph id=\"ph1\">`lpSockAddr`</ph> in bytes.","pos":[17754,17805],"source":" The length of the address in `lpSockAddr` in bytes."},{"content":"Return Value","pos":[17815,17827]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[17831,17981],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"If this indicates an error code of <bpt id=\"p1\">**</bpt>WSAEWOULDBLOCK<ept id=\"p1\">**</ept>, and your application is using the overridable callbacks, your application will receive an <ph id=\"ph1\">`OnConnect`</ph> message when the connect operation is complete.","pos":[17982,18186],"source":" If this indicates an error code of **WSAEWOULDBLOCK**, and your application is using the overridable callbacks, your application will receive an `OnConnect` message when the connect operation is complete."},{"content":"The following errors apply to this member function:","pos":[18187,18238]},{"pos":[18246,18407],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[18415,18509],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[18517,18575],"content":"<bpt id=\"p1\">**</bpt>WSAEADDRINUSE<ept id=\"p1\">**</ept> The specified address is already in use.","source":"**WSAEADDRINUSE** The specified address is already in use."},{"pos":[18583,18649],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets call is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets call is in progress."},{"pos":[18657,18740],"content":"<bpt id=\"p1\">**</bpt>WSAEADDRNOTAVAIL<ept id=\"p1\">**</ept> The specified address is not available from the local machine.","source":"**WSAEADDRNOTAVAIL** The specified address is not available from the local machine."},{"pos":[18748,18834],"content":"<bpt id=\"p1\">**</bpt>WSAEAFNOSUPPORT<ept id=\"p1\">**</ept> Addresses in the specified family cannot be used with this socket.","source":"**WSAEAFNOSUPPORT** Addresses in the specified family cannot be used with this socket."},{"pos":[18842,18898],"content":"<bpt id=\"p1\">**</bpt>WSAECONNREFUSED<ept id=\"p1\">**</ept> The attempt to connect was rejected.","source":"**WSAECONNREFUSED** The attempt to connect was rejected."},{"pos":[18906,18960],"content":"<bpt id=\"p1\">**</bpt>WSAEDESTADDRREQ<ept id=\"p1\">**</ept> A destination address is required.","source":"**WSAEDESTADDRREQ** A destination address is required."},{"pos":[18968,19023],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`nSockAddrLen`</ph> argument is incorrect.","source":"**WSAEFAULT** The `nSockAddrLen` argument is incorrect."},{"pos":[19031,19066],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> Invalid host address.","source":"**WSAEINVAL** Invalid host address."},{"pos":[19074,19121],"content":"<bpt id=\"p1\">**</bpt>WSAEISCONN<ept id=\"p1\">**</ept> The socket is already connected.","source":"**WSAEISCONN** The socket is already connected."},{"pos":[19129,19182],"content":"<bpt id=\"p1\">**</bpt>WSAEMFILE<ept id=\"p1\">**</ept> No more file descriptors are available.","source":"**WSAEMFILE** No more file descriptors are available."},{"pos":[19190,19267],"content":"<bpt id=\"p1\">**</bpt>WSAENETUNREACH<ept id=\"p1\">**</ept> The network cannot be reached from this host at this time.","source":"**WSAENETUNREACH** The network cannot be reached from this host at this time."},{"content":"No buffer space is available.","pos":[19288,19317]},{"content":"The socket cannot be connected.","pos":[19318,19349]},{"pos":[19357,19404],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"pos":[19412,19492],"content":"<bpt id=\"p1\">**</bpt>WSAETIMEDOUT<ept id=\"p1\">**</ept> Attempt to connect timed out without establishing a connection.","source":"**WSAETIMEDOUT** Attempt to connect timed out without establishing a connection."},{"pos":[19500,19606],"content":"<bpt id=\"p1\">**</bpt>WSAEWOULDBLOCK<ept id=\"p1\">**</ept> The socket is marked as nonblocking and the connection cannot be completed immediately.","source":"**WSAEWOULDBLOCK** The socket is marked as nonblocking and the connection cannot be completed immediately."},{"content":"Remarks","pos":[19616,19623]},{"content":"If the socket is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound.","pos":[19627,19754]},{"content":"Note that if the address field of the name structure is all zeroes, <bpt id=\"p1\">**</bpt>Connect<ept id=\"p1\">**</ept> will return zero.","pos":[19755,19852],"source":" Note that if the address field of the name structure is all zeroes, **Connect** will return zero."},{"content":"To get extended error information, call the <ph id=\"ph1\">`GetLastError`</ph> member function.","pos":[19853,19928],"source":" To get extended error information, call the `GetLastError` member function."},{"content":"For stream sockets (type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept>), an active connection is initiated to the foreign host.","pos":[19935,20032],"source":"For stream sockets (type **SOCK_STREAM**), an active connection is initiated to the foreign host."},{"content":"When the socket call completes successfully, the socket is ready to send/receive data.","pos":[20033,20119]},{"pos":[20126,20265],"content":"For a datagram socket (type <bpt id=\"p1\">**</bpt>SOCK_DGRAM<ept id=\"p1\">**</ept>), a default destination is set, which will be used on subsequent <bpt id=\"p2\">**</bpt>Send<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>Receive<ept id=\"p3\">**</ept> calls.","source":"For a datagram socket (type **SOCK_DGRAM**), a default destination is set, which will be used on subsequent **Send** and **Receive** calls."},{"pos":[20312,20332],"content":"CAsyncSocket::Create"},{"pos":[20336,20450],"content":"Call the <bpt id=\"p1\">**</bpt>Create<ept id=\"p1\">**</ept> member function after constructing a socket object to create the Windows socket and attach it.","source":"Call the **Create** member function after constructing a socket object to create the Windows socket and attach it."},{"content":"Parameters","pos":[20677,20687]},{"content":"A well-known port to be used with the socket, or 0 if you want Windows Sockets to select a port.","pos":[20708,20804]},{"content":"<bpt id=\"p1\"> **</bpt>SOCK_STREAM<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>SOCK_DGRAM<ept id=\"p2\">**</ept>.","pos":[20827,20862],"source":" **SOCK_STREAM** or **SOCK_DGRAM**."},{"content":"A bitmask which specifies a combination of network events in which the application is interested.","pos":[20881,20978]},{"pos":[20986,21052],"content":"<bpt id=\"p1\">**</bpt>FD_READ<ept id=\"p1\">**</ept> Want to receive notification of readiness for reading.","source":"**FD_READ** Want to receive notification of readiness for reading."},{"pos":[21060,21127],"content":"<bpt id=\"p1\">**</bpt>FD_WRITE<ept id=\"p1\">**</ept> Want to receive notification of readiness for writing.","source":"**FD_WRITE** Want to receive notification of readiness for writing."},{"pos":[21135,21210],"content":"<bpt id=\"p1\">**</bpt>FD_OOB<ept id=\"p1\">**</ept> Want to receive notification of the arrival of out-of-band data.","source":"**FD_OOB** Want to receive notification of the arrival of out-of-band data."},{"pos":[21218,21285],"content":"<bpt id=\"p1\">**</bpt>FD_ACCEPT<ept id=\"p1\">**</ept> Want to receive notification of incoming connections.","source":"**FD_ACCEPT** Want to receive notification of incoming connections."},{"pos":[21293,21361],"content":"<bpt id=\"p1\">**</bpt>FD_CONNECT<ept id=\"p1\">**</ept> Want to receive notification of completed connection.","source":"**FD_CONNECT** Want to receive notification of completed connection."},{"pos":[21369,21429],"content":"<bpt id=\"p1\">**</bpt>FD_CLOSE<ept id=\"p1\">**</ept> Want to receive notification of socket closure.","source":"**FD_CLOSE** Want to receive notification of socket closure."},{"pos":[21436,21720],"content":"*lpszSockAddress*  \nA pointer to a string containing the network address of the connected socket, a dotted number such as \"128.56.22.8\".Passing the **NULL** string for this parameter indicates the **CAsyncSocket** instance should listen for client activity on all network interfaces.","leadings":[""," "],"nodes":[{"content":"lpszSockAddress","pos":[1,16]},{"content":"A pointer to a string containing the network address of the connected socket, a dotted number such as \"128.56.22.8\".Passing the <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> string for this parameter indicates the <bpt id=\"p2\">**</bpt>CAsyncSocket<ept id=\"p2\">**</ept> instance should listen for client activity on all network interfaces.","pos":[20,283],"source":"A pointer to a string containing the network address of the connected socket, a dotted number such as \"128.56.22.8\".Passing the **NULL** string for this parameter indicates the **CAsyncSocket** instance should listen for client activity on all network interfaces."}]},{"content":"Return Value","pos":[21730,21742]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[21746,21896],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[21897,21948]},{"pos":[21956,22117],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[22125,22219],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[22227,22293],"content":"<bpt id=\"p1\">**</bpt>WSAEAFNOSUPPORT<ept id=\"p1\">**</ept> The specified address family is not supported.","source":"**WSAEAFNOSUPPORT** The specified address family is not supported."},{"pos":[22301,22372],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[22380,22433],"content":"<bpt id=\"p1\">**</bpt>WSAEMFILE<ept id=\"p1\">**</ept> No more file descriptors are available.","source":"**WSAEMFILE** No more file descriptors are available."},{"content":"No buffer space is available.","pos":[22454,22483]},{"content":"The socket cannot be created.","pos":[22484,22513]},{"pos":[22521,22580],"content":"<bpt id=\"p1\">**</bpt>WSAEPROTONOSUPPORT<ept id=\"p1\">**</ept> The specified port is not supported.","source":"**WSAEPROTONOSUPPORT** The specified port is not supported."},{"pos":[22588,22659],"content":"<bpt id=\"p1\">**</bpt>WSAEPROTOTYPE<ept id=\"p1\">**</ept> The specified port is the wrong type for this socket.","source":"**WSAEPROTOTYPE** The specified port is the wrong type for this socket."},{"pos":[22667,22756],"content":"<bpt id=\"p1\">**</bpt>WSAESOCKTNOSUPPORT<ept id=\"p1\">**</ept> The specified socket type is not supported in this address family.","source":"**WSAESOCKTNOSUPPORT** The specified socket type is not supported in this address family."},{"content":"Remarks","pos":[22766,22773]},{"content":"<bpt id=\"p1\">**</bpt>Create<ept id=\"p1\">**</ept> calls <bpt id=\"p2\">[</bpt>Socket<ept id=\"p2\">](#casyncsocket__socket)</ept> and if successful, it calls <bpt id=\"p3\">[</bpt>Bind<ept id=\"p3\">](#casyncsocket__bind)</ept> to bind the socket to the specified address.","pos":[22777,22926],"source":"**Create** calls [Socket](#casyncsocket__socket) and if successful, it calls [Bind](#casyncsocket__bind) to bind the socket to the specified address."},{"content":"The following socket types are supported:","pos":[22927,22968]},{"content":"<bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept> Provides sequenced, reliable, full-duplex, connection-based byte streams.","pos":[22976,23065],"source":"**SOCK_STREAM** Provides sequenced, reliable, full-duplex, connection-based byte streams."},{"content":"Uses the Transmission Control Protocol (TCP) for the Internet address family.","pos":[23066,23143]},{"content":"<bpt id=\"p1\">**</bpt>SOCK_DGRAM<ept id=\"p1\">**</ept> Supports datagrams, which are connectionless, unreliable packets of a fixed (typically small) maximum length.","pos":[23151,23275],"source":"**SOCK_DGRAM** Supports datagrams, which are connectionless, unreliable packets of a fixed (typically small) maximum length."},{"content":"Uses the User Datagram Protocol (UDP) for the Internet address family.","pos":[23276,23346]},{"pos":[23358,23664],"content":"[!NOTE]\n The **Accept** member function takes a reference to a new, empty `CSocket` object as its parameter. You must construct this object before you call **Accept**. Keep in mind that if this socket object goes out of scope, the connection closes. Do not call **Create** for this new socket object.","leadings":["","    > "],"nodes":[{"content":" The **Accept** member function takes a reference to a new, empty `CSocket` object as its parameter. You must construct this object before you call **Accept**. Keep in mind that if this socket object goes out of scope, the connection closes. Do not call **Create** for this new socket object.","pos":[8,300],"nodes":[{"content":"The <bpt id=\"p1\">**</bpt>Accept<ept id=\"p1\">**</ept> member function takes a reference to a new, empty <ph id=\"ph1\">`CSocket`</ph> object as its parameter.","pos":[1,100],"source":" The **Accept** member function takes a reference to a new, empty `CSocket` object as its parameter."},{"content":"You must construct this object before you call <bpt id=\"p1\">**</bpt>Accept<ept id=\"p1\">**</ept>.","pos":[101,159],"source":" You must construct this object before you call **Accept**."},{"content":"Keep in mind that if this socket object goes out of scope, the connection closes.","pos":[160,241]},{"content":"Do not call <bpt id=\"p1\">**</bpt>Create<ept id=\"p1\">**</ept> for this new socket object.","pos":[242,292],"source":" Do not call **Create** for this new socket object."}]}]},{"pos":[23672,23912],"content":"[!IMPORTANT]\n**Create** is **not** thread-safe.  If you are calling it in a multi-threaded environment where it could be invoked simultaneously by different threads, be sure to protect each call with a mutex or other synchronization lock.","leadings":["","> "],"nodes":[{"content":"**Create** is **not** thread-safe.  If you are calling it in a multi-threaded environment where it could be invoked simultaneously by different threads, be sure to protect each call with a mutex or other synchronization lock.","pos":[13,238],"nodes":[{"content":"<bpt id=\"p1\">**</bpt>Create<ept id=\"p1\">**</ept> is <bpt id=\"p2\">**</bpt>not<ept id=\"p2\">**</ept> thread-safe.","pos":[0,34],"source":"**Create** is **not** thread-safe."},{"content":"If you are calling it in a multi-threaded environment where it could be invoked simultaneously by different threads, be sure to protect each call with a mutex or other synchronization lock.","pos":[36,225]}]}]},{"pos":[23919,24258],"content":"For more information about stream and datagram sockets, see the articles <bpt id=\"p1\">[</bpt>Windows Sockets: Background<ept id=\"p1\">](../../mfc/windows-sockets-background.md)</ept> and <bpt id=\"p2\">[</bpt>Windows Sockets: Ports and Socket Addresses<ept id=\"p2\">](../../mfc/windows-sockets-ports-and-socket-addresses.md)</ept> and <bpt id=\"p3\">[</bpt>Windows Sockets 2 API<ept id=\"p3\">](http://msdn.microsoft.com/library/windows/desktop/ms740673)</ept>.","source":"For more information about stream and datagram sockets, see the articles [Windows Sockets: Background](../../mfc/windows-sockets-background.md) and [Windows Sockets: Ports and Socket Addresses](../../mfc/windows-sockets-ports-and-socket-addresses.md) and [Windows Sockets 2 API](http://msdn.microsoft.com/library/windows/desktop/ms740673)."},{"pos":[24305,24325],"content":"CAsyncSocket::Detach"},{"pos":[24329,24481],"content":"Call this member function to detach the <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> handle in the <ph id=\"ph1\">`m_hSocket`</ph> data member from the <ph id=\"ph2\">`CAsyncSocket`</ph> object and set <ph id=\"ph3\">`m_hSocket`</ph> to <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept>.","source":"Call this member function to detach the **SOCKET** handle in the `m_hSocket` data member from the `CAsyncSocket` object and set `m_hSocket` to **NULL**."},{"pos":[24564,24588],"content":"CAsyncSocket::FromHandle"},{"pos":[24592,24637],"content":"Returns a pointer to a <ph id=\"ph1\">`CAsyncSocket`</ph> object.","source":"Returns a pointer to a `CAsyncSocket` object."},{"content":"Parameters","pos":[24718,24728]},{"content":"Contains a handle to a socket.","pos":[24745,24775]},{"content":"Return Value","pos":[24785,24797]},{"pos":[24801,24911],"content":"A pointer to an <ph id=\"ph1\">`CAsyncSocket`</ph> object, or <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if there is no <ph id=\"ph2\">`CAsyncSocket`</ph> object attached to <ph id=\"ph3\">`hSocket`</ph>.","source":"A pointer to an `CAsyncSocket` object, or **NULL** if there is no `CAsyncSocket` object attached to `hSocket`."},{"content":"Remarks","pos":[24921,24928]},{"pos":[24932,25059],"content":"When given a <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> handle, if a <ph id=\"ph1\">`CAsyncSocket`</ph> object is not attached to the handle, the member function returns <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept>.","source":"When given a **SOCKET** handle, if a `CAsyncSocket` object is not attached to the handle, the member function returns **NULL**."},{"pos":[25112,25138],"content":"CAsyncSocket::GetLastError"},{"content":"Call this member function to get the error status for the last operation that failed.","pos":[25142,25227]},{"content":"Return Value","pos":[25286,25298]},{"content":"The return value indicates the error code for the last Windows Sockets API routine performed by this thread.","pos":[25302,25410]},{"content":"Remarks","pos":[25420,25427]},{"content":"When a particular member function indicates that an error has occurred, <ph id=\"ph1\">`GetLastError`</ph> should be called to retrieve the appropriate error code.","pos":[25431,25574],"source":"When a particular member function indicates that an error has occurred, `GetLastError` should be called to retrieve the appropriate error code."},{"content":"See the individual member function descriptions for a list of applicable error codes.","pos":[25575,25660]},{"pos":[25667,25799],"content":"For more information about the error codes, see <bpt id=\"p1\">[</bpt>Windows Sockets 2 API<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms740673)</ept>.","source":"For more information about the error codes, see [Windows Sockets 2 API](http://msdn.microsoft.com/library/windows/desktop/ms740673)."},{"pos":[25851,25876],"content":"CAsyncSocket::GetPeerName"},{"content":"Call this member function to get the address of the peer socket to which this socket is connected.","pos":[25880,25978]},{"content":"Parameters","pos":[26146,26156]},{"content":"Reference to a <ph id=\"ph1\">`CString`</ph> object that receives a dotted number IP address.","pos":[26178,26251],"source":" Reference to a `CString` object that receives a dotted number IP address."},{"content":"Reference to a <bpt id=\"p1\">**</bpt>UINT<ept id=\"p1\">**</ept> that stores a port.","pos":[26273,26316],"source":" Reference to a **UINT** that stores a port."},{"content":"A pointer to the <bpt id=\"p1\">[</bpt>SOCKADDR<ept id=\"p1\">](../../mfc/reference/sockaddr-structure.md)</ept> structure that receives the name of the peer socket.","pos":[26339,26462],"source":" A pointer to the [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that receives the name of the peer socket."},{"content":"A pointer to the length of the address in <ph id=\"ph1\">`lpSockAddr`</ph> in bytes.","pos":[26488,26552],"source":" A pointer to the length of the address in `lpSockAddr` in bytes."},{"content":"On return, the <ph id=\"ph1\">`lpSockAddrLen`</ph> argument contains the actual size of <ph id=\"ph2\">`lpSockAddr`</ph> returned in bytes.","pos":[26553,26652],"source":" On return, the `lpSockAddrLen` argument contains the actual size of `lpSockAddr` returned in bytes."},{"content":"Return Value","pos":[26662,26674]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[26678,26828],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[26829,26880]},{"pos":[26888,27049],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[27057,27151],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[27159,27222],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpSockAddrLen`</ph> argument is not large enough.","source":"**WSAEFAULT** The `lpSockAddrLen` argument is not large enough."},{"pos":[27230,27296],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets call is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets call is in progress."},{"pos":[27304,27348],"content":"<bpt id=\"p1\">**</bpt>WSAENOTCONN<ept id=\"p1\">**</ept> The socket is not connected.","source":"**WSAENOTCONN** The socket is not connected."},{"pos":[27356,27403],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"content":"Remarks","pos":[27413,27420]},{"pos":[27424,27514],"content":"To handle IPv6 addresses, use <bpt id=\"p1\">[</bpt>CAsyncSocket::GetPeerNameEx<ept id=\"p1\">](#casyncsocket__getpeernameex)</ept>.","source":"To handle IPv6 addresses, use [CAsyncSocket::GetPeerNameEx](#casyncsocket__getpeernameex)."},{"pos":[27568,27595],"content":"CAsyncSocket::GetPeerNameEx"},{"content":"Call this member function to get the address of the peer socket to which this socket is connected (handles IPv6 addresses).","pos":[27599,27722]},{"content":"Parameters","pos":[27818,27828]},{"content":"Reference to a <ph id=\"ph1\">`CString`</ph> object that receives a dotted number IP address.","pos":[27850,27923],"source":" Reference to a `CString` object that receives a dotted number IP address."},{"content":"Reference to a <bpt id=\"p1\">**</bpt>UINT<ept id=\"p1\">**</ept> that stores a port.","pos":[27945,27988],"source":" Reference to a **UINT** that stores a port."},{"content":"Return Value","pos":[27998,28010]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[28014,28164],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[28165,28216]},{"pos":[28224,28385],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[28393,28487],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[28495,28558],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpSockAddrLen`</ph> argument is not large enough.","source":"**WSAEFAULT** The `lpSockAddrLen` argument is not large enough."},{"pos":[28566,28632],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets call is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets call is in progress."},{"pos":[28640,28684],"content":"<bpt id=\"p1\">**</bpt>WSAENOTCONN<ept id=\"p1\">**</ept> The socket is not connected.","source":"**WSAENOTCONN** The socket is not connected."},{"pos":[28692,28739],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"content":"Remarks","pos":[28749,28756]},{"pos":[28760,28910],"content":"This function is the same as <bpt id=\"p1\">[</bpt>CAsyncSocket::GetPeerName<ept id=\"p1\">](#casyncsocket__getpeername)</ept> except that it handles IPv6 addresses as well as older protocols.","source":"This function is the same as [CAsyncSocket::GetPeerName](#casyncsocket__getpeername) except that it handles IPv6 addresses as well as older protocols."},{"pos":[28962,28987],"content":"CAsyncSocket::GetSockName"},{"content":"Call this member function to get the local name for a socket.","pos":[28991,29052]},{"content":"Parameters","pos":[29224,29234]},{"content":"Reference to a <ph id=\"ph1\">`CString`</ph> object that receives a dotted number IP address.","pos":[29258,29331],"source":" Reference to a `CString` object that receives a dotted number IP address."},{"content":"Reference to a <bpt id=\"p1\">**</bpt>UINT<ept id=\"p1\">**</ept> that stores a port.","pos":[29355,29398],"source":" Reference to a **UINT** that stores a port."},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>SOCKADDR<ept id=\"p1\">](../../mfc/reference/sockaddr-structure.md)</ept> structure that receives the address of the socket.","pos":[29421,29540],"source":" A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that receives the address of the socket."},{"content":"A pointer to the length of the address in <ph id=\"ph1\">`lpSockAddr`</ph> in bytes.","pos":[29566,29630],"source":" A pointer to the length of the address in `lpSockAddr` in bytes."},{"content":"Return Value","pos":[29640,29652]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[29656,29806],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[29807,29858]},{"pos":[29866,30027],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[30035,30129],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[30137,30200],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpSockAddrLen`</ph> argument is not large enough.","source":"**WSAEFAULT** The `lpSockAddrLen` argument is not large enough."},{"pos":[30208,30279],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[30287,30334],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"pos":[30342,30414],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> The socket has not been bound to an address with <bpt id=\"p2\">**</bpt>Bind<ept id=\"p2\">**</ept>.","source":"**WSAEINVAL** The socket has not been bound to an address with **Bind**."},{"content":"Remarks","pos":[30424,30431]},{"pos":[30435,30652],"content":"This call is especially useful when a <bpt id=\"p1\">**</bpt>Connect<ept id=\"p1\">**</ept> call has been made without doing a <bpt id=\"p2\">**</bpt>Bind<ept id=\"p2\">**</ept> first; this call provides the only means by which you can determine the local association which has been set by the system.","source":"This call is especially useful when a **Connect** call has been made without doing a **Bind** first; this call provides the only means by which you can determine the local association which has been set by the system."},{"pos":[30659,30748],"content":"To handle IPv6 addresses, use <bpt id=\"p1\">[</bpt>CAsyncSocket::GetSockNameEx<ept id=\"p1\">](#casyncsocket__getsocknameex)</ept>","source":"To handle IPv6 addresses, use [CAsyncSocket::GetSockNameEx](#casyncsocket__getsocknameex)"},{"pos":[30802,30829],"content":"CAsyncSocket::GetSockNameEx"},{"content":"Call this member function to get the local name for a socket (handles IPv6 addresses).","pos":[30833,30919]},{"content":"Parameters","pos":[31019,31029]},{"content":"Reference to a <ph id=\"ph1\">`CString`</ph> object that receives a dotted number IP address.","pos":[31053,31126],"source":" Reference to a `CString` object that receives a dotted number IP address."},{"content":"Reference to a <bpt id=\"p1\">**</bpt>UINT<ept id=\"p1\">**</ept> that stores a port.","pos":[31150,31193],"source":" Reference to a **UINT** that stores a port."},{"content":"Return Value","pos":[31203,31215]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[31219,31369],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[31370,31421]},{"pos":[31429,31590],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[31598,31692],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[31700,31763],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpSockAddrLen`</ph> argument is not large enough.","source":"**WSAEFAULT** The `lpSockAddrLen` argument is not large enough."},{"pos":[31771,31842],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[31850,31897],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"pos":[31905,31977],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> The socket has not been bound to an address with <bpt id=\"p2\">**</bpt>Bind<ept id=\"p2\">**</ept>.","source":"**WSAEINVAL** The socket has not been bound to an address with **Bind**."},{"content":"Remarks","pos":[31987,31994]},{"pos":[31998,32144],"content":"This call is the same as <bpt id=\"p1\">[</bpt>CAsyncSocket::GetSockName<ept id=\"p1\">](#casyncsocket__getsockname)</ept> except that it handles IPv6 addresses as well as older protocols.","source":"This call is the same as [CAsyncSocket::GetSockName](#casyncsocket__getsockname) except that it handles IPv6 addresses as well as older protocols."},{"pos":[32151,32368],"content":"This call is especially useful when a <bpt id=\"p1\">**</bpt>Connect<ept id=\"p1\">**</ept> call has been made without doing a <bpt id=\"p2\">**</bpt>Bind<ept id=\"p2\">**</ept> first; this call provides the only means by which you can determine the local association which has been set by the system.","source":"This call is especially useful when a **Connect** call has been made without doing a **Bind** first; this call provides the only means by which you can determine the local association which has been set by the system."},{"pos":[32419,32443],"content":"CAsyncSocket::GetSockOpt"},{"content":"Call this member function to retrieve a socket option.","pos":[32447,32501]},{"content":"Parameters","pos":[32647,32657]},{"content":"The socket option for which the value is to be retrieved.","pos":[32678,32735]},{"content":"A pointer to the buffer in which the value for the requested option is to be returned.","pos":[32761,32847]},{"content":"The value associated with the selected option is returned in the buffer <ph id=\"ph1\">`lpOptionValue`</ph>.","pos":[32848,32936],"source":" The value associated with the selected option is returned in the buffer `lpOptionValue`."},{"content":"The integer pointed to by <ph id=\"ph1\">`lpOptionLen`</ph> should originally contain the size of this buffer in bytes; and on return, it will be set to the size of the value returned.","pos":[32937,33101],"source":" The integer pointed to by `lpOptionLen` should originally contain the size of this buffer in bytes; and on return, it will be set to the size of the value returned."},{"content":"For <bpt id=\"p1\">**</bpt>SO_LINGER<ept id=\"p1\">**</ept>, this will be the size of a <ph id=\"ph1\">`LINGER`</ph> structure; for all other options it will be the size of a <bpt id=\"p2\">**</bpt>BOOL<ept id=\"p2\">**</ept> or an <ph id=\"ph2\">`int`</ph>, depending on the option.","pos":[33102,33261],"source":" For **SO_LINGER**, this will be the size of a `LINGER` structure; for all other options it will be the size of a **BOOL** or an `int`, depending on the option."},{"content":"See the list of options and their sizes in the Remarks section.","pos":[33262,33325]},{"content":"A pointer to the size of the <ph id=\"ph1\">`lpOptionValue`</ph> buffer in bytes.","pos":[33349,33410],"source":" A pointer to the size of the `lpOptionValue` buffer in bytes."},{"content":"The level at which the option is defined; the only supported levels are <bpt id=\"p1\">**</bpt>SOL_SOCKET<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>IPPROTO_TCP<ept id=\"p2\">**</ept>.","pos":[33429,33536],"source":" The level at which the option is defined; the only supported levels are **SOL_SOCKET** and **IPPROTO_TCP**."},{"content":"Return Value","pos":[33546,33558]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[33562,33712],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"If an option was never set with <ph id=\"ph1\">`SetSockOpt`</ph>, then <ph id=\"ph2\">`GetSockOpt`</ph> returns the default value for the option.","pos":[33713,33818],"source":" If an option was never set with `SetSockOpt`, then `GetSockOpt` returns the default value for the option."},{"content":"The following errors apply to this member function:","pos":[33819,33870]},{"pos":[33878,34039],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[34047,34141],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[34149,34202],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpOptionLen`</ph> argument was invalid.","source":"**WSAEFAULT** The `lpOptionLen` argument was invalid."},{"pos":[34210,34281],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"content":"<bpt id=\"p1\">**</bpt>WSAENOPROTOOPT<ept id=\"p1\">**</ept> The option is unknown or unsupported.","pos":[34289,34345],"source":"**WSAENOPROTOOPT** The option is unknown or unsupported."},{"content":"In particular, <bpt id=\"p1\">**</bpt>SO_BROADCAST<ept id=\"p1\">**</ept> is not supported on sockets of type <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept>, while <bpt id=\"p3\">**</bpt>SO_ACCEPTCONN<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>SO_DONTLINGER<ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>SO_KEEPALIVE<ept id=\"p5\">**</ept>, <bpt id=\"p6\">**</bpt>SO_LINGER<ept id=\"p6\">**</ept>, and <bpt id=\"p7\">**</bpt>SO_OOBINLINE<ept id=\"p7\">**</ept> are not supported on sockets of type <bpt id=\"p8\">**</bpt>SOCK_DGRAM<ept id=\"p8\">**</ept>.","pos":[34346,34581],"source":" In particular, **SO_BROADCAST** is not supported on sockets of type **SOCK_STREAM**, while **SO_ACCEPTCONN**, **SO_DONTLINGER**, **SO_KEEPALIVE**, **SO_LINGER**, and **SO_OOBINLINE** are not supported on sockets of type **SOCK_DGRAM**."},{"pos":[34589,34636],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"content":"Remarks","pos":[34646,34653]},{"content":"retrieves the current value for a socket option associated with a socket of any type, in any state, and stores the result in <ph id=\"ph1\">`lpOptionValue`</ph>.","pos":[34670,34811],"source":" retrieves the current value for a socket option associated with a socket of any type, in any state, and stores the result in `lpOptionValue`."},{"content":"Options affect socket operations, such as the routing of packets, out-of-band data transfer, and so on.","pos":[34812,34915]},{"content":"The following options are supported for <ph id=\"ph1\">`GetSockOpt`</ph>.","pos":[34922,34975],"source":"The following options are supported for `GetSockOpt`."},{"content":"The Type identifies the type of data addressed by <ph id=\"ph1\">`lpOptionValue`</ph>.","pos":[34976,35042],"source":" The Type identifies the type of data addressed by `lpOptionValue`."},{"content":"The <bpt id=\"p1\">**</bpt>TCP_NODELAY<ept id=\"p1\">**</ept> option uses level <bpt id=\"p2\">**</bpt>IPPROTO_TCP<ept id=\"p2\">**</ept>; all other options use level <bpt id=\"p3\">**</bpt>SOL_SOCKET<ept id=\"p3\">**</ept>.","pos":[35043,35141],"source":" The **TCP_NODELAY** option uses level **IPPROTO_TCP**; all other options use level **SOL_SOCKET**."},{"content":"Value","pos":[35148,35153]},{"content":"Type","pos":[35154,35158]},{"content":"Meaning","pos":[35159,35166]},{"content":"SO_ACCEPTCONN","pos":[35214,35227]},{"content":"BOOL","pos":[35232,35236]},{"content":"Socket is listening.","pos":[35239,35259]},{"content":"SO_BROADCAST","pos":[35266,35278]},{"content":"BOOL","pos":[35283,35287]},{"content":"Socket is configured for the transmission of broadcast messages.","pos":[35290,35354]},{"content":"SO_DEBUG","pos":[35361,35369]},{"content":"BOOL","pos":[35374,35378]},{"content":"Debugging is enabled.","pos":[35381,35402]},{"content":"SO_DONTLINGER","pos":[35409,35422]},{"content":"BOOL","pos":[35427,35431]},{"pos":[35434,35480],"content":"If true, the <bpt id=\"p1\">**</bpt>SO_LINGER<ept id=\"p1\">**</ept> option is disabled.","source":"If true, the **SO_LINGER** option is disabled."},{"content":"SO_DONTROUTE","pos":[35487,35499]},{"content":"BOOL","pos":[35504,35508]},{"content":"Routing is disabled.","pos":[35511,35531]},{"content":"SO_ERROR","pos":[35538,35546]},{"content":"Retrieve error status and clear.","pos":[35555,35587]},{"content":"SO_KEEPALIVE","pos":[35594,35606]},{"content":"BOOL","pos":[35611,35615]},{"content":"Keep-alives are being sent.","pos":[35618,35645]},{"content":"SO_LINGER","pos":[35652,35661]},{"content":"struct LINGER","pos":[35666,35679]},{"content":"Returns the current linger options.","pos":[35682,35717]},{"content":"SO_OOBINLINE","pos":[35724,35736]},{"content":"BOOL","pos":[35741,35745]},{"content":"Out-of-band data is being received in the normal data stream.","pos":[35748,35809]},{"content":"SO_RCVBUF","pos":[35816,35825]},{"content":"Buffer size for receives.","pos":[35834,35859]},{"content":"SO_REUSEADDR","pos":[35866,35878]},{"content":"BOOL","pos":[35883,35887]},{"content":"The socket can be bound to an address which is already in use.","pos":[35890,35952]},{"content":"SO_SNDBUF","pos":[35959,35968]},{"content":"Buffer size for sends.","pos":[35977,35999]},{"content":"SO_TYPE","pos":[36006,36013]},{"pos":[36022,36076],"content":"The type of the socket (for example, <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept>).","source":"The type of the socket (for example, **SOCK_STREAM**)."},{"content":"TCP_NODELAY","pos":[36083,36094]},{"content":"BOOL","pos":[36099,36103]},{"content":"Disables the Nagle algorithm for send coalescing.","pos":[36106,36155]},{"pos":[36163,36243],"content":"Berkeley Software Distribution (BSD) options not supported for <ph id=\"ph1\">`GetSockOpt`</ph> are:","source":"Berkeley Software Distribution (BSD) options not supported for `GetSockOpt` are:"},{"content":"Value","pos":[36250,36255]},{"content":"Type","pos":[36256,36260]},{"content":"Meaning","pos":[36261,36268]},{"content":"SO_RCVLOWAT","pos":[36316,36327]},{"content":"Receive low water mark.","pos":[36336,36359]},{"content":"SO_RCVTIMEO","pos":[36366,36377]},{"content":"Receive timeout.","pos":[36386,36402]},{"content":"SO_SNDLOWAT","pos":[36409,36420]},{"content":"Send low water mark.","pos":[36429,36449]},{"content":"SO_SNDTIMEO","pos":[36456,36467]},{"content":"Send timeout.","pos":[36476,36489]},{"content":"IP_OPTIONS","pos":[36496,36506]},{"content":"Get options in IP header.","pos":[36510,36535]},{"content":"TCP_MAXSEG","pos":[36542,36552]},{"content":"Get TCP maximum segment size.","pos":[36561,36590]},{"pos":[36598,36732],"content":"Calling <ph id=\"ph1\">`GetSockOpt`</ph> with an unsupported option will result in an error code of <bpt id=\"p1\">**</bpt>WSAENOPROTOOPT<ept id=\"p1\">**</ept> being returned from <ph id=\"ph2\">`GetLastError`</ph>.","source":"Calling `GetSockOpt` with an unsupported option will result in an error code of **WSAENOPROTOOPT** being returned from `GetLastError`."},{"pos":[36778,36797],"content":"CAsyncSocket::IOCtl"},{"content":"Call this member function to control the mode of a socket.","pos":[36801,36859]},{"content":"Parameters","pos":[36941,36951]},{"content":"The command to perform on the socket.","pos":[36969,37006]},{"content":"A pointer to a parameter for <ph id=\"ph1\">`lCommand`</ph>.","pos":[37029,37069],"source":" A pointer to a parameter for `lCommand`."},{"content":"Return Value","pos":[37079,37091]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[37095,37245],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[37246,37297]},{"pos":[37305,37466],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[37474,37568],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[37576,37752],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> <ph id=\"ph1\">`lCommand`</ph> is not a valid command, or <ph id=\"ph2\">`lpArgument`</ph> is not an acceptable parameter for <ph id=\"ph3\">`lCommand`</ph>, or the command is not applicable to the type of socket supplied.","source":"**WSAEINVAL** `lCommand` is not a valid command, or `lpArgument` is not an acceptable parameter for `lCommand`, or the command is not applicable to the type of socket supplied."},{"pos":[37760,37831],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[37839,37886],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"content":"Remarks","pos":[37896,37903]},{"content":"This routine can be used on any socket in any state.","pos":[37907,37959]},{"content":"It is used to get or retrieve operating parameters associated with the socket, independent of the protocol and communications subsystem.","pos":[37960,38096]},{"content":"The following commands are supported:","pos":[38097,38134]},{"content":"<bpt id=\"p1\">**</bpt>FIONBIO<ept id=\"p1\">**</ept> Enable or disable nonblocking mode on the socket.","pos":[38142,38203],"source":"**FIONBIO** Enable or disable nonblocking mode on the socket."},{"content":"The <ph id=\"ph1\">`lpArgument`</ph> parameter points at a <ph id=\"ph2\">`DWORD`</ph>, which is nonzero if nonblocking mode is to be enabled and zero if it is to be disabled.","pos":[38204,38339],"source":" The `lpArgument` parameter points at a `DWORD`, which is nonzero if nonblocking mode is to be enabled and zero if it is to be disabled."},{"content":"If <ph id=\"ph1\">`AsyncSelect`</ph> has been issued on a socket, then any attempt to use <bpt id=\"p1\">**</bpt>IOCtl<ept id=\"p1\">**</ept> to set the socket back to blocking mode will fail with <bpt id=\"p2\">**</bpt>WSAEINVAL<ept id=\"p2\">**</ept>.","pos":[38340,38489],"source":" If `AsyncSelect` has been issued on a socket, then any attempt to use **IOCtl** to set the socket back to blocking mode will fail with **WSAEINVAL**."},{"content":"To set the socket back to blocking mode and prevent the <bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> error, an application must first disable <ph id=\"ph1\">`AsyncSelect`</ph> by calling <ph id=\"ph2\">`AsyncSelect`</ph> with the <ph id=\"ph3\">`lEvent`</ph> parameter equal to 0, then call <bpt id=\"p2\">**</bpt>IOCtl<ept id=\"p2\">**</ept>.","pos":[38490,38700],"source":" To set the socket back to blocking mode and prevent the **WSAEINVAL** error, an application must first disable `AsyncSelect` by calling `AsyncSelect` with the `lEvent` parameter equal to 0, then call **IOCtl**."},{"content":"<bpt id=\"p1\">**</bpt>FIONREAD<ept id=\"p1\">**</ept> Determine the maximum number of bytes that can be read with one <bpt id=\"p2\">**</bpt>Receive<ept id=\"p2\">**</ept> call from this socket.","pos":[38708,38819],"source":"**FIONREAD** Determine the maximum number of bytes that can be read with one **Receive** call from this socket."},{"content":"The <ph id=\"ph1\">`lpArgument`</ph> parameter points at a <ph id=\"ph2\">`DWORD`</ph> in which <bpt id=\"p1\">**</bpt>IOCtl<ept id=\"p1\">**</ept> stores the result.","pos":[38820,38904],"source":" The `lpArgument` parameter points at a `DWORD` in which **IOCtl** stores the result."},{"content":"If this socket is of type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>FIONREAD<ept id=\"p2\">**</ept> returns the total amount of data which can be read in a single <bpt id=\"p3\">**</bpt>Receive<ept id=\"p3\">**</ept>; this is normally the same as the total amount of data queued on the socket.","pos":[38905,39112],"source":" If this socket is of type **SOCK_STREAM**, **FIONREAD** returns the total amount of data which can be read in a single **Receive**; this is normally the same as the total amount of data queued on the socket."},{"content":"If this socket is of type <bpt id=\"p1\">**</bpt>SOCK_DGRAM<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>FIONREAD<ept id=\"p2\">**</ept> returns the size of the first datagram queued on the socket.","pos":[39113,39228],"source":" If this socket is of type **SOCK_DGRAM**, **FIONREAD** returns the size of the first datagram queued on the socket."},{"content":"<bpt id=\"p1\">**</bpt>SIOCATMARK<ept id=\"p1\">**</ept> Determine whether all out-of-band data has been read.","pos":[39236,39304],"source":"**SIOCATMARK** Determine whether all out-of-band data has been read."},{"content":"This applies only to a socket of type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept> which has been configured for in-line reception of any out-of-band data ( <bpt id=\"p2\">**</bpt>SO_OOBINLINE<ept id=\"p2\">**</ept>).","pos":[39305,39451],"source":" This applies only to a socket of type **SOCK_STREAM** which has been configured for in-line reception of any out-of-band data ( **SO_OOBINLINE**)."},{"content":"If no out-of-band data is waiting to be read, the operation returns nonzero.","pos":[39452,39528]},{"content":"Otherwise it returns 0, and the next <bpt id=\"p1\">**</bpt>Receive<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`ReceiveFrom`</ph> performed on the socket will retrieve some or all of the data preceding the \"mark\"; the application should use the <bpt id=\"p2\">**</bpt>SIOCATMARK<ept id=\"p2\">**</ept> operation to determine whether any data remains.","pos":[39529,39773],"source":" Otherwise it returns 0, and the next **Receive** or `ReceiveFrom` performed on the socket will retrieve some or all of the data preceding the \"mark\"; the application should use the **SIOCATMARK** operation to determine whether any data remains."},{"content":"If there is any normal data preceding the \"urgent\" (out-of-band) data, it will be received in order.","pos":[39774,39874]},{"content":"(Note that a <bpt id=\"p1\">**</bpt>Receive<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`ReceiveFrom`</ph> will never mix out-of-band and normal data in the same call.) The <ph id=\"ph2\">`lpArgument`</ph> parameter points at a <ph id=\"ph3\">`DWORD`</ph> in which <bpt id=\"p2\">**</bpt>IOCtl<ept id=\"p2\">**</ept> stores the result.","pos":[39875,40063],"source":" (Note that a **Receive** or `ReceiveFrom` will never mix out-of-band and normal data in the same call.) The `lpArgument` parameter points at a `DWORD` in which **IOCtl** stores the result."},{"content":"This function is a subset of <bpt id=\"p1\">**</bpt>ioctl()<ept id=\"p1\">**</ept> as used in Berkeley sockets.","pos":[40070,40139],"source":"This function is a subset of **ioctl()** as used in Berkeley sockets."},{"content":"In particular, there is no command which is equivalent to <bpt id=\"p1\">**</bpt>FIOASYNC<ept id=\"p1\">**</ept>, while <bpt id=\"p2\">**</bpt>SIOCATMARK<ept id=\"p2\">**</ept> is the only socket-level command which is supported.","pos":[40140,40285],"source":" In particular, there is no command which is equivalent to **FIOASYNC**, while **SIOCATMARK** is the only socket-level command which is supported."},{"pos":[40332,40352],"content":"CAsyncSocket::Listen"},{"content":"Call this member function to listen for incoming connection requests.","pos":[40356,40425]},{"content":"Parameters","pos":[40491,40501]},{"content":"nConnectionBacklog","pos":[40506,40524]},{"content":"The maximum length to which the queue of pending connections can grow.","pos":[40529,40599]},{"content":"Valid range is from 1 to 5.","pos":[40600,40627]},{"content":"Return Value","pos":[40637,40649]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[40653,40803],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[40804,40855]},{"pos":[40863,41024],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[41032,41126],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[41134,41208],"content":"<bpt id=\"p1\">**</bpt>WSAEADDRINUSE<ept id=\"p1\">**</ept> An attempt has been made to listen on an address in use.","source":"**WSAEADDRINUSE** An attempt has been made to listen on an address in use."},{"pos":[41216,41287],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[41295,41377],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> The socket has not been bound with <bpt id=\"p2\">**</bpt>Bind<ept id=\"p2\">**</ept> or is already connected.","source":"**WSAEINVAL** The socket has not been bound with **Bind** or is already connected."},{"pos":[41385,41432],"content":"<bpt id=\"p1\">**</bpt>WSAEISCONN<ept id=\"p1\">**</ept> The socket is already connected.","source":"**WSAEISCONN** The socket is already connected."},{"pos":[41440,41493],"content":"<bpt id=\"p1\">**</bpt>WSAEMFILE<ept id=\"p1\">**</ept> No more file descriptors are available.","source":"**WSAEMFILE** No more file descriptors are available."},{"pos":[41514,41543],"content":"No buffer space is available."},{"pos":[41551,41598],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"pos":[41606,41700],"content":"<bpt id=\"p1\">**</bpt>WSAEOPNOTSUPP<ept id=\"p1\">**</ept> The referenced socket is not of a type that supports the <ph id=\"ph1\">`Listen`</ph> operation.","source":"**WSAEOPNOTSUPP** The referenced socket is not of a type that supports the `Listen` operation."},{"content":"Remarks","pos":[41710,41717]},{"content":"To accept connections, the socket is first created with <bpt id=\"p1\">**</bpt>Create<ept id=\"p1\">**</ept>, a backlog for incoming connections is specified with <ph id=\"ph1\">`Listen`</ph>, and then the connections are accepted with <bpt id=\"p2\">**</bpt>Accept<ept id=\"p2\">**</ept>.","pos":[41721,41906],"source":"To accept connections, the socket is first created with **Create**, a backlog for incoming connections is specified with `Listen`, and then the connections are accepted with **Accept**."},{"content":"applies only to sockets that support connections, that is, those of type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept>.","pos":[41916,42005],"source":" applies only to sockets that support connections, that is, those of type **SOCK_STREAM**."},{"content":"This socket is put into \"passive\" mode where incoming connections are acknowledged and queued pending acceptance by the process.","pos":[42006,42134]},{"pos":[42141,42426],"content":"This function is typically used by servers (or any application that wants to accept connections) that could have more than one connection request at a time: if a connection request arrives with the queue full, the client will receive an error with an indication of <bpt id=\"p1\">**</bpt>WSAECONNREFUSED<ept id=\"p1\">**</ept>.","source":"This function is typically used by servers (or any application that wants to accept connections) that could have more than one connection request at a time: if a connection request arrives with the queue full, the client will receive an error with an indication of **WSAECONNREFUSED**."},{"content":"attempts to continue to function rationally when there are no available ports (descriptors).","pos":[42442,42534]},{"content":"It will accept connections until the queue is emptied.","pos":[42535,42589]},{"content":"If ports become available, a later call to <ph id=\"ph1\">`Listen`</ph> or <bpt id=\"p1\">**</bpt>Accept<ept id=\"p1\">**</ept> will refill the queue to the current or most recent \"backlog,\" if possible, and resume listening for incoming connections.","pos":[42590,42778],"source":" If ports become available, a later call to `Listen` or **Accept** will refill the queue to the current or most recent \"backlog,\" if possible, and resume listening for incoming connections."},{"pos":[42828,42851],"content":"CAsyncSocket::m_hSocket"},{"pos":[42855,42944],"content":"Contains the <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> handle for the socket encapsulated by this <ph id=\"ph1\">`CAsyncSocket`</ph> object.","source":"Contains the **SOCKET** handle for the socket encapsulated by this `CAsyncSocket` object."},{"pos":[43028,43050],"content":"CAsyncSocket::OnAccept"},{"pos":[43054,43217],"content":"Called by the framework to notify a listening socket that it can accept pending connection requests by calling the <bpt id=\"p1\">[</bpt>Accept<ept id=\"p1\">](#casyncsocket__accept)</ept> member function.","source":"Called by the framework to notify a listening socket that it can accept pending connection requests by calling the [Accept](#casyncsocket__accept) member function."},{"content":"Parameters","pos":[43281,43291]},{"content":"The most recent error on a socket.","pos":[43311,43345]},{"content":"The following error codes applies to the <ph id=\"ph1\">`OnAccept`</ph> member function:","pos":[43346,43414],"source":" The following error codes applies to the `OnAccept` member function:"},{"pos":[43422,43463],"content":"<bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> The function executed successfully.","source":"**0** The function executed successfully."},{"pos":[43471,43565],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"content":"Remarks","pos":[43575,43582]},{"pos":[43586,43703],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Socket Notifications<ept id=\"p1\">](../../mfc/windows-sockets-socket-notifications.md)</ept>.","source":"For more information, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md)."},{"pos":[43751,43772],"content":"CAsyncSocket::OnClose"},{"content":"Called by the framework to notify this socket that the connected socket is closed by its process.","pos":[43776,43873]},{"content":"Parameters","pos":[43936,43946]},{"content":"The most recent error on a socket.","pos":[43966,44000]},{"content":"The following error codes apply to the <ph id=\"ph1\">`OnClose`</ph> member function:","pos":[44001,44066],"source":" The following error codes apply to the `OnClose` member function:"},{"pos":[44074,44115],"content":"<bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> The function executed successfully.","source":"**0** The function executed successfully."},{"pos":[44123,44217],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[44225,44287],"content":"<bpt id=\"p1\">**</bpt>WSAECONNRESET<ept id=\"p1\">**</ept> The connection was reset by the remote side.","source":"**WSAECONNRESET** The connection was reset by the remote side."},{"pos":[44295,44374],"content":"<bpt id=\"p1\">**</bpt>WSAECONNABORTED<ept id=\"p1\">**</ept> The connection was aborted due to timeout or other failure.","source":"**WSAECONNABORTED** The connection was aborted due to timeout or other failure."},{"content":"Remarks","pos":[44384,44391]},{"pos":[44395,44512],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Socket Notifications<ept id=\"p1\">](../../mfc/windows-sockets-socket-notifications.md)</ept>.","source":"For more information, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md)."},{"pos":[44562,44585],"content":"CAsyncSocket::OnConnect"},{"content":"Called by the framework to notify this connecting socket that its connection attempt is completed, whether successfully or in error.","pos":[44589,44721]},{"content":"Parameters","pos":[44786,44796]},{"content":"The most recent error on a socket.","pos":[44816,44850]},{"content":"The following error codes apply to the <ph id=\"ph1\">`OnConnect`</ph> member function:","pos":[44851,44918],"source":" The following error codes apply to the `OnConnect` member function:"},{"pos":[44926,44967],"content":"<bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> The function executed successfully.","source":"**0** The function executed successfully."},{"pos":[44975,45033],"content":"<bpt id=\"p1\">**</bpt>WSAEADDRINUSE<ept id=\"p1\">**</ept> The specified address is already in use.","source":"**WSAEADDRINUSE** The specified address is already in use."},{"pos":[45041,45124],"content":"<bpt id=\"p1\">**</bpt>WSAEADDRNOTAVAIL<ept id=\"p1\">**</ept> The specified address is not available from the local machine.","source":"**WSAEADDRNOTAVAIL** The specified address is not available from the local machine."},{"pos":[45132,45218],"content":"<bpt id=\"p1\">**</bpt>WSAEAFNOSUPPORT<ept id=\"p1\">**</ept> Addresses in the specified family cannot be used with this socket.","source":"**WSAEAFNOSUPPORT** Addresses in the specified family cannot be used with this socket."},{"pos":[45226,45293],"content":"<bpt id=\"p1\">**</bpt>WSAECONNREFUSED<ept id=\"p1\">**</ept> The attempt to connect was forcefully rejected.","source":"**WSAECONNREFUSED** The attempt to connect was forcefully rejected."},{"pos":[45301,45355],"content":"<bpt id=\"p1\">**</bpt>WSAEDESTADDRREQ<ept id=\"p1\">**</ept> A destination address is required.","source":"**WSAEDESTADDRREQ** A destination address is required."},{"pos":[45363,45419],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpSockAddrLen`</ph> argument is incorrect.","source":"**WSAEFAULT** The `lpSockAddrLen` argument is incorrect."},{"pos":[45427,45483],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> The socket is already bound to an address.","source":"**WSAEINVAL** The socket is already bound to an address."},{"pos":[45491,45538],"content":"<bpt id=\"p1\">**</bpt>WSAEISCONN<ept id=\"p1\">**</ept> The socket is already connected.","source":"**WSAEISCONN** The socket is already connected."},{"pos":[45546,45599],"content":"<bpt id=\"p1\">**</bpt>WSAEMFILE<ept id=\"p1\">**</ept> No more file descriptors are available.","source":"**WSAEMFILE** No more file descriptors are available."},{"pos":[45607,45684],"content":"<bpt id=\"p1\">**</bpt>WSAENETUNREACH<ept id=\"p1\">**</ept> The network cannot be reached from this host at this time.","source":"**WSAENETUNREACH** The network cannot be reached from this host at this time."},{"content":"No buffer space is available.","pos":[45705,45734]},{"content":"The socket cannot be connected.","pos":[45735,45766]},{"pos":[45774,45818],"content":"<bpt id=\"p1\">**</bpt>WSAENOTCONN<ept id=\"p1\">**</ept> The socket is not connected.","source":"**WSAENOTCONN** The socket is not connected."},{"pos":[45826,45881],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is a file, not a socket.","source":"**WSAENOTSOCK** The descriptor is a file, not a socket."},{"pos":[45889,45973],"content":"<bpt id=\"p1\">**</bpt>WSAETIMEDOUT<ept id=\"p1\">**</ept> The attempt to connect timed out without establishing a connection.","source":"**WSAETIMEDOUT** The attempt to connect timed out without establishing a connection."},{"content":"Remarks","pos":[45983,45990]},{"pos":[45998,46321],"content":"[!NOTE]\n In [CSocket](../../mfc/reference/csocket-class.md), the `OnConnect` notification function is never called. For connections, you simply call **Connect**, which will return when the connection is completed (either successfully or in error). How connection notifications are handled is an MFC implementation detail.","leadings":["","> "],"nodes":[{"content":" In [CSocket](../../mfc/reference/csocket-class.md), the `OnConnect` notification function is never called. For connections, you simply call **Connect**, which will return when the connection is completed (either successfully or in error). How connection notifications are handled is an MFC implementation detail.","pos":[8,321],"nodes":[{"content":"In <bpt id=\"p1\">[</bpt>CSocket<ept id=\"p1\">](../../mfc/reference/csocket-class.md)</ept>, the <ph id=\"ph1\">`OnConnect`</ph> notification function is never called.","pos":[1,107],"source":" In [CSocket](../../mfc/reference/csocket-class.md), the `OnConnect` notification function is never called."},{"content":"For connections, you simply call <bpt id=\"p1\">**</bpt>Connect<ept id=\"p1\">**</ept>, which will return when the connection is completed (either successfully or in error).","pos":[108,239],"source":" For connections, you simply call **Connect**, which will return when the connection is completed (either successfully or in error)."},{"content":"How connection notifications are handled is an MFC implementation detail.","pos":[240,313]}]}]},{"pos":[46328,46445],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Socket Notifications<ept id=\"p1\">](../../mfc/windows-sockets-socket-notifications.md)</ept>.","source":"For more information, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md)."},{"content":"Example","pos":[46455,46462]},{"pos":[46477,46497],"content":"NVC_MFCAsyncSocket#1"},{"pos":[46617,46646],"content":"CAsyncSocket::OnOutOfBandData"},{"content":"Called by the framework to notify the receiving socket that the sending socket has out-of-band data to send.","pos":[46650,46758]},{"content":"Parameters","pos":[46829,46839]},{"content":"The most recent error on a socket.","pos":[46859,46893]},{"content":"The following error codes apply to the <ph id=\"ph1\">`OnOutOfBandData`</ph> member function:","pos":[46894,46967],"source":" The following error codes apply to the `OnOutOfBandData` member function:"},{"pos":[46975,47016],"content":"<bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> The function executed successfully.","source":"**0** The function executed successfully."},{"pos":[47024,47118],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"content":"Remarks","pos":[47128,47135]},{"content":"Out-of-band data is a logically independent channel that is associated with each pair of connected sockets of type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept>.","pos":[47139,47270],"source":"Out-of-band data is a logically independent channel that is associated with each pair of connected sockets of type **SOCK_STREAM**."},{"content":"The channel is generally used to send urgent data.","pos":[47271,47321]},{"content":"MFC supports out-of-band data, but users of class <ph id=\"ph1\">`CAsyncSocket`</ph> are discouraged from using it.","pos":[47328,47423],"source":"MFC supports out-of-band data, but users of class `CAsyncSocket` are discouraged from using it."},{"content":"The easier way is to create a second socket for passing such data.","pos":[47424,47490]},{"content":"For more information about out-of-band data, see <bpt id=\"p1\">[</bpt>Windows Sockets: Socket Notifications<ept id=\"p1\">](../../mfc/windows-sockets-socket-notifications.md)</ept>.","pos":[47491,47631],"source":" For more information about out-of-band data, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md)."},{"pos":[47681,47704],"content":"CAsyncSocket::OnReceive"},{"pos":[47708,47852],"content":"Called by the framework to notify this socket that there is data in the buffer that can be retrieved by calling the <bpt id=\"p1\">**</bpt>Receive<ept id=\"p1\">**</ept> member function.","source":"Called by the framework to notify this socket that there is data in the buffer that can be retrieved by calling the **Receive** member function."},{"content":"Parameters","pos":[47917,47927]},{"content":"The most recent error on a socket.","pos":[47947,47981]},{"content":"The following error codes apply to the <ph id=\"ph1\">`OnReceive`</ph> member function:","pos":[47982,48049],"source":" The following error codes apply to the `OnReceive` member function:"},{"pos":[48057,48098],"content":"<bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> The function executed successfully.","source":"**0** The function executed successfully."},{"pos":[48106,48200],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"content":"Remarks","pos":[48210,48217]},{"pos":[48221,48338],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Socket Notifications<ept id=\"p1\">](../../mfc/windows-sockets-socket-notifications.md)</ept>.","source":"For more information, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md)."},{"content":"Example","pos":[48348,48355]},{"pos":[48370,48390],"content":"NVC_MFCAsyncSocket#2"},{"pos":[48501,48521],"content":"CAsyncSocket::OnSend"},{"pos":[48525,48636],"content":"Called by the framework to notify the socket that it can now send data by calling the <bpt id=\"p1\">**</bpt>Send<ept id=\"p1\">**</ept> member function.","source":"Called by the framework to notify the socket that it can now send data by calling the **Send** member function."},{"content":"Parameters","pos":[48698,48708]},{"content":"The most recent error on a socket.","pos":[48728,48762]},{"content":"The following error codes apply to the <ph id=\"ph1\">`OnSend`</ph> member function:","pos":[48763,48827],"source":" The following error codes apply to the `OnSend` member function:"},{"pos":[48835,48876],"content":"<bpt id=\"p1\">**</bpt>0<ept id=\"p1\">**</ept> The function executed successfully.","source":"**0** The function executed successfully."},{"pos":[48884,48978],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"content":"Remarks","pos":[48988,48995]},{"pos":[48999,49116],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Socket Notifications<ept id=\"p1\">](../../mfc/windows-sockets-socket-notifications.md)</ept>.","source":"For more information, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md)."},{"content":"Example","pos":[49126,49133]},{"pos":[49148,49168],"content":"NVC_MFCAsyncSocket#3"},{"pos":[49285,49309],"content":"CAsyncSocket::operator ="},{"pos":[49313,49360],"content":"Assigns a new value to a <ph id=\"ph1\">`CAsyncSocket`</ph> object.","source":"Assigns a new value to a `CAsyncSocket` object."},{"content":"Parameters","pos":[49427,49437]},{"content":"A reference to an existing <ph id=\"ph1\">`CAsyncSocket`</ph> object.","pos":[49451,49500],"source":" A reference to an existing `CAsyncSocket` object."},{"content":"Remarks","pos":[49510,49517]},{"pos":[49521,49615],"content":"Call this function to copy an existing <ph id=\"ph1\">`CAsyncSocket`</ph> object to another <ph id=\"ph2\">`CAsyncSocket`</ph> object.","source":"Call this function to copy an existing `CAsyncSocket` object to another `CAsyncSocket` object."},{"pos":[49671,49700],"content":"CAsyncSocket::operator SOCKET"},{"pos":[49704,49785],"content":"Use this operator to retrieve the <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> handle of the <ph id=\"ph1\">`CAsyncSocket`</ph> object.","source":"Use this operator to retrieve the **SOCKET** handle of the `CAsyncSocket` object."},{"content":"Return Value","pos":[49838,49850]},{"pos":[49854,49926],"content":"If successful, the handle of the <bpt id=\"p1\">**</bpt>SOCKET<ept id=\"p1\">**</ept> object; otherwise, <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept>.","source":"If successful, the handle of the **SOCKET** object; otherwise, **NULL**."},{"content":"Remarks","pos":[49936,49943]},{"content":"You can use the handle to call Windows APIs directly.","pos":[49947,50000]},{"pos":[50048,50069],"content":"CAsyncSocket::Receive"},{"content":"Call this member function to receive data from a socket.","pos":[50073,50129]},{"content":"Parameters","pos":[50234,50244]},{"content":"A buffer for the incoming data.","pos":[50259,50290]},{"content":"The length of <ph id=\"ph1\">`lpBuf`</ph> in bytes.","pos":[50310,50341],"source":" The length of `lpBuf` in bytes."},{"content":"Specifies the way in which the call is made.","pos":[50360,50404]},{"content":"The semantics of this function are determined by the socket options and the <ph id=\"ph1\">`nFlags`</ph> parameter.","pos":[50405,50500],"source":" The semantics of this function are determined by the socket options and the `nFlags` parameter."},{"content":"The latter is constructed by combining any of the following values with the C++ <ph id=\"ph1\">`OR`</ph> operator:","pos":[50501,50595],"source":" The latter is constructed by combining any of the following values with the C++ `OR` operator:"},{"content":"<bpt id=\"p1\">**</bpt>MSG_PEEK<ept id=\"p1\">**</ept> Peek at the incoming data.","pos":[50603,50642],"source":"**MSG_PEEK** Peek at the incoming data."},{"content":"The data is copied into the buffer but is not removed from the input queue.","pos":[50643,50718]},{"pos":[50726,50763],"content":"<bpt id=\"p1\">**</bpt>MSG_OOB<ept id=\"p1\">**</ept> Process out-of-band data.","source":"**MSG_OOB** Process out-of-band data."},{"content":"Return Value","pos":[50773,50785]},{"content":"If no error occurs, <bpt id=\"p1\">**</bpt>Receive<ept id=\"p1\">**</ept> returns the number of bytes received.","pos":[50789,50858],"source":"If no error occurs, **Receive** returns the number of bytes received."},{"content":"If the connection has been closed, it returns 0.","pos":[50859,50907]},{"content":"Otherwise, a value of <bpt id=\"p1\">**</bpt>SOCKET_ERROR<ept id=\"p1\">**</ept> is returned, and a specific error code can be retrieved by calling <bpt id=\"p2\">[</bpt>GetLastError<ept id=\"p2\">](#casyncsocket__getlasterror)</ept>.","pos":[50908,51058],"source":" Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[51059,51110]},{"pos":[51118,51279],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[51287,51381],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[51389,51433],"content":"<bpt id=\"p1\">**</bpt>WSAENOTCONN<ept id=\"p1\">**</ept> The socket is not connected.","source":"**WSAENOTCONN** The socket is not connected."},{"pos":[51441,51512],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[51520,51567],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"pos":[51575,51662],"content":"<bpt id=\"p1\">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id=\"p1\">**</ept> was specified, but the socket is not of type <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept>.","source":"**WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**."},{"pos":[51670,51829],"content":"<bpt id=\"p1\">**</bpt>WSAESHUTDOWN<ept id=\"p1\">**</ept> The socket has been shut down; it is not possible to call <bpt id=\"p2\">**</bpt>Receive<ept id=\"p2\">**</ept> on a socket after <ph id=\"ph1\">`ShutDown`</ph> has been invoked with <ph id=\"ph2\">`nHow`</ph> set to 0 or 2.","source":"**WSAESHUTDOWN** The socket has been shut down; it is not possible to call **Receive** on a socket after `ShutDown` has been invoked with `nHow` set to 0 or 2."},{"pos":[51837,51934],"content":"<bpt id=\"p1\">**</bpt>WSAEWOULDBLOCK<ept id=\"p1\">**</ept> The socket is marked as nonblocking and the <bpt id=\"p2\">**</bpt>Receive<ept id=\"p2\">**</ept> operation would block.","source":"**WSAEWOULDBLOCK** The socket is marked as nonblocking and the **Receive** operation would block."},{"pos":[51942,52036],"content":"<bpt id=\"p1\">**</bpt>WSAEMSGSIZE<ept id=\"p1\">**</ept> The datagram was too large to fit into the specified buffer and was truncated.","source":"**WSAEMSGSIZE** The datagram was too large to fit into the specified buffer and was truncated."},{"pos":[52044,52102],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> The socket has not been bound with <bpt id=\"p2\">**</bpt>Bind<ept id=\"p2\">**</ept>.","source":"**WSAEINVAL** The socket has not been bound with **Bind**."},{"pos":[52110,52194],"content":"<bpt id=\"p1\">**</bpt>WSAECONNABORTED<ept id=\"p1\">**</ept> The virtual circuit was aborted due to timeout or other failure.","source":"**WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure."},{"pos":[52202,52269],"content":"<bpt id=\"p1\">**</bpt>WSAECONNRESET<ept id=\"p1\">**</ept> The virtual circuit was reset by the remote side.","source":"**WSAECONNRESET** The virtual circuit was reset by the remote side."},{"content":"Remarks","pos":[52279,52286]},{"content":"This function is used for connected stream or datagram sockets and is used to read incoming data.","pos":[52290,52387]},{"content":"For sockets of type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept>, as much information as is currently available up to the size of the buffer supplied is returned.","pos":[52394,52527],"source":"For sockets of type **SOCK_STREAM**, as much information as is currently available up to the size of the buffer supplied is returned."},{"content":"If the socket has been configured for in-line reception of out-of-band data (socket option <bpt id=\"p1\">**</bpt>SO_OOBINLINE<ept id=\"p1\">**</ept>) and out-of-band data is unread, only out-of-band data will be returned.","pos":[52528,52708],"source":" If the socket has been configured for in-line reception of out-of-band data (socket option **SO_OOBINLINE**) and out-of-band data is unread, only out-of-band data will be returned."},{"content":"The application can use the <bpt id=\"p1\">**</bpt>IOCtlSIOCATMARK<ept id=\"p1\">**</ept> option or <bpt id=\"p2\">[</bpt>OnOutOfBandData<ept id=\"p2\">](#casyncsocket__onoutofbanddata)</ept> to determine whether any more out-of-band data remains to be read.","pos":[52709,52883],"source":" The application can use the **IOCtlSIOCATMARK** option or [OnOutOfBandData](#casyncsocket__onoutofbanddata) to determine whether any more out-of-band data remains to be read."},{"content":"For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied.","pos":[52890,53002]},{"content":"If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the datagram, the excess data is lost, and <bpt id=\"p1\">**</bpt>Receive<ept id=\"p1\">**</ept> returns a value of <bpt id=\"p2\">**</bpt>SOCKET_ERROR<ept id=\"p2\">**</ept> with the error code set to <bpt id=\"p3\">**</bpt>WSAEMSGSIZE<ept id=\"p3\">**</ept>.","pos":[53003,53233],"source":" If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the datagram, the excess data is lost, and **Receive** returns a value of **SOCKET_ERROR** with the error code set to **WSAEMSGSIZE**."},{"content":"If no incoming data is available at the socket, a value of <bpt id=\"p1\">**</bpt>SOCKET_ERROR<ept id=\"p1\">**</ept> is returned with the error code set to <bpt id=\"p2\">**</bpt>WSAEWOULDBLOCK<ept id=\"p2\">**</ept>.","pos":[53234,53368],"source":" If no incoming data is available at the socket, a value of **SOCKET_ERROR** is returned with the error code set to **WSAEWOULDBLOCK**."},{"content":"The <bpt id=\"p1\">[</bpt>OnReceive<ept id=\"p1\">](#casyncsocket__onreceive)</ept> callback function can be used to determine when more data arrives.","pos":[53369,53477],"source":" The [OnReceive](#casyncsocket__onreceive) callback function can be used to determine when more data arrives."},{"content":"If the socket is of type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept> and the remote side has shut down the connection gracefully, a <bpt id=\"p2\">**</bpt>Receive<ept id=\"p2\">**</ept> will complete immediately with 0 bytes received.","pos":[53484,53648],"source":"If the socket is of type **SOCK_STREAM** and the remote side has shut down the connection gracefully, a **Receive** will complete immediately with 0 bytes received."},{"content":"If the connection has been reset, a <bpt id=\"p1\">**</bpt>Receive<ept id=\"p1\">**</ept> will fail with the error <bpt id=\"p2\">**</bpt>WSAECONNRESET<ept id=\"p2\">**</ept>.","pos":[53649,53740],"source":" If the connection has been reset, a **Receive** will fail with the error **WSAECONNRESET**."},{"pos":[53747,53862],"content":"<bpt id=\"p1\">**</bpt>Receive<ept id=\"p1\">**</ept> should be called only once for each time <bpt id=\"p2\">[</bpt>CAsyncSocket::OnReceive<ept id=\"p2\">](#casyncsocket__onreceive)</ept> is called.","source":"**Receive** should be called only once for each time [CAsyncSocket::OnReceive](#casyncsocket__onreceive) is called."},{"content":"Example","pos":[53872,53879]},{"pos":[53884,53956],"content":"See the example for <bpt id=\"p1\">[</bpt>CAsyncSocket::OnReceive<ept id=\"p1\">](#casyncsocket__onreceive)</ept>.","source":"See the example for [CAsyncSocket::OnReceive](#casyncsocket__onreceive)."},{"pos":[54008,54033],"content":"CAsyncSocket::ReceiveFrom"},{"pos":[54037,54208],"content":"Call this member function to receive a datagram and store the source address in the <bpt id=\"p1\">[</bpt>SOCKADDR<ept id=\"p1\">](../../mfc/reference/sockaddr-structure.md)</ept> structure or in <ph id=\"ph1\">`rSocketAddress`</ph>.","source":"Call this member function to receive a datagram and store the source address in the [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure or in `rSocketAddress`."},{"content":"Parameters","pos":[54498,54508]},{"content":"A buffer for the incoming data.","pos":[54523,54554]},{"content":"The length of <ph id=\"ph1\">`lpBuf`</ph> in bytes.","pos":[54574,54605],"source":" The length of `lpBuf` in bytes."},{"content":"Reference to a <ph id=\"ph1\">`CString`</ph> object that receives a dotted number IP address.","pos":[54632,54705],"source":" Reference to a `CString` object that receives a dotted number IP address."},{"content":"Reference to a <bpt id=\"p1\">**</bpt>UINT<ept id=\"p1\">**</ept> that stores a port.","pos":[54729,54772],"source":" Reference to a **UINT** that stores a port."},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>SOCKADDR<ept id=\"p1\">](../../mfc/reference/sockaddr-structure.md)</ept> structure that holds the source address upon return.","pos":[54795,54916],"source":" A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that holds the source address upon return."},{"content":"A pointer to the length of the source address in <ph id=\"ph1\">`lpSockAddr`</ph> in bytes.","pos":[54942,55013],"source":" A pointer to the length of the source address in `lpSockAddr` in bytes."},{"content":"Specifies the way in which the call is made.","pos":[55032,55076]},{"content":"The semantics of this function are determined by the socket options and the <ph id=\"ph1\">`nFlags`</ph> parameter.","pos":[55077,55172],"source":" The semantics of this function are determined by the socket options and the `nFlags` parameter."},{"content":"The latter is constructed by combining any of the following values with the C++ <ph id=\"ph1\">`OR`</ph> operator:","pos":[55173,55267],"source":" The latter is constructed by combining any of the following values with the C++ `OR` operator:"},{"content":"<bpt id=\"p1\">**</bpt>MSG_PEEK<ept id=\"p1\">**</ept> Peek at the incoming data.","pos":[55275,55314],"source":"**MSG_PEEK** Peek at the incoming data."},{"content":"The data is copied into the buffer but is not removed from the input queue.","pos":[55315,55390]},{"pos":[55398,55435],"content":"<bpt id=\"p1\">**</bpt>MSG_OOB<ept id=\"p1\">**</ept> Process out-of-band data.","source":"**MSG_OOB** Process out-of-band data."},{"content":"Return Value","pos":[55445,55457]},{"content":"If no error occurs, <ph id=\"ph1\">`ReceiveFrom`</ph> returns the number of bytes received.","pos":[55461,55532],"source":"If no error occurs, `ReceiveFrom` returns the number of bytes received."},{"content":"If the connection has been closed, it returns 0.","pos":[55533,55581]},{"content":"Otherwise, a value of <bpt id=\"p1\">**</bpt>SOCKET_ERROR<ept id=\"p1\">**</ept> is returned, and a specific error code can be retrieved by calling <ph id=\"ph1\">`GetLastError`</ph>.","pos":[55582,55703],"source":" Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling `GetLastError`."},{"content":"The following errors apply to this member function:","pos":[55704,55755]},{"pos":[55763,55924],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[55932,56026],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[56034,56160],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpSockAddrLen`</ph> argument was invalid: the <ph id=\"ph2\">`lpSockAddr`</ph> buffer was too small to accommodate the peer address.","source":"**WSAEFAULT** The `lpSockAddrLen` argument was invalid: the `lpSockAddr` buffer was too small to accommodate the peer address."},{"pos":[56168,56239],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[56247,56305],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> The socket has not been bound with <bpt id=\"p2\">**</bpt>Bind<ept id=\"p2\">**</ept>.","source":"**WSAEINVAL** The socket has not been bound with **Bind**."},{"pos":[56313,56381],"content":"<bpt id=\"p1\">**</bpt>WSAENOTCONN<ept id=\"p1\">**</ept> The socket is not connected ( <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept> only).","source":"**WSAENOTCONN** The socket is not connected ( **SOCK_STREAM** only)."},{"pos":[56389,56436],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"pos":[56444,56531],"content":"<bpt id=\"p1\">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id=\"p1\">**</ept> was specified, but the socket is not of type <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept>.","source":"**WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**."},{"pos":[56539,56700],"content":"<bpt id=\"p1\">**</bpt>WSAESHUTDOWN<ept id=\"p1\">**</ept> The socket has been shut down; it is not possible to call <ph id=\"ph1\">`ReceiveFrom`</ph> on a socket after <ph id=\"ph2\">`ShutDown`</ph> has been invoked with <ph id=\"ph3\">`nHow`</ph> set to 0 or 2.","source":"**WSAESHUTDOWN** The socket has been shut down; it is not possible to call `ReceiveFrom` on a socket after `ShutDown` has been invoked with `nHow` set to 0 or 2."},{"pos":[56708,56807],"content":"<bpt id=\"p1\">**</bpt>WSAEWOULDBLOCK<ept id=\"p1\">**</ept> The socket is marked as nonblocking and the <ph id=\"ph1\">`ReceiveFrom`</ph> operation would block.","source":"**WSAEWOULDBLOCK** The socket is marked as nonblocking and the `ReceiveFrom` operation would block."},{"pos":[56815,56909],"content":"<bpt id=\"p1\">**</bpt>WSAEMSGSIZE<ept id=\"p1\">**</ept> The datagram was too large to fit into the specified buffer and was truncated.","source":"**WSAEMSGSIZE** The datagram was too large to fit into the specified buffer and was truncated."},{"pos":[56917,57001],"content":"<bpt id=\"p1\">**</bpt>WSAECONNABORTED<ept id=\"p1\">**</ept> The virtual circuit was aborted due to timeout or other failure.","source":"**WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure."},{"pos":[57009,57076],"content":"<bpt id=\"p1\">**</bpt>WSAECONNRESET<ept id=\"p1\">**</ept> The virtual circuit was reset by the remote side.","source":"**WSAECONNRESET** The virtual circuit was reset by the remote side."},{"content":"Remarks","pos":[57086,57093]},{"content":"This function is used to read incoming data on a (possibly connected) socket and capture the address from which the data was sent.","pos":[57097,57227]},{"pos":[57234,57324],"content":"To handle IPv6 addresses, use <bpt id=\"p1\">[</bpt>CAsyncSocket::ReceiveFromEx<ept id=\"p1\">](#casyncsocket__receivefromex)</ept>.","source":"To handle IPv6 addresses, use [CAsyncSocket::ReceiveFromEx](#casyncsocket__receivefromex)."},{"content":"For sockets of type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept>, as much information as is currently available up to the size of the buffer supplied is returned.","pos":[57331,57464],"source":"For sockets of type **SOCK_STREAM**, as much information as is currently available up to the size of the buffer supplied is returned."},{"content":"If the socket has been configured for in-line reception of out-of-band data (socket option <bpt id=\"p1\">**</bpt>SO_OOBINLINE<ept id=\"p1\">**</ept>) and out-of-band data is unread, only out-of-band data will be returned.","pos":[57465,57645],"source":" If the socket has been configured for in-line reception of out-of-band data (socket option **SO_OOBINLINE**) and out-of-band data is unread, only out-of-band data will be returned."},{"content":"The application can use the <bpt id=\"p1\">**</bpt>IOCtlSIOCATMARK<ept id=\"p1\">**</ept> option or <ph id=\"ph1\">`OnOutOfBandData`</ph> to determine whether any more out-of-band data remains to be read.","pos":[57646,57788],"source":" The application can use the **IOCtlSIOCATMARK** option or `OnOutOfBandData` to determine whether any more out-of-band data remains to be read."},{"content":"The <ph id=\"ph1\">`lpSockAddr`</ph> and <ph id=\"ph2\">`lpSockAddrLen`</ph> parameters are ignored for <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept> sockets.","pos":[57789,57877],"source":" The `lpSockAddr` and `lpSockAddrLen` parameters are ignored for **SOCK_STREAM** sockets."},{"content":"For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied.","pos":[57884,57996]},{"content":"If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the message, the excess data is lost, and <ph id=\"ph1\">`ReceiveFrom`</ph> returns a value of <bpt id=\"p1\">**</bpt>SOCKET_ERROR<ept id=\"p1\">**</ept> with the error code set to <bpt id=\"p2\">**</bpt>WSAEMSGSIZE<ept id=\"p2\">**</ept>.","pos":[57997,58228],"source":" If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the message, the excess data is lost, and `ReceiveFrom` returns a value of **SOCKET_ERROR** with the error code set to **WSAEMSGSIZE**."},{"content":"If <ph id=\"ph1\">`lpSockAddr`</ph> is nonzero, and the socket is of type <bpt id=\"p1\">**</bpt>SOCK_DGRAM<ept id=\"p1\">**</ept>, the network address of the socket which sent the data is copied to the corresponding <bpt id=\"p2\">[</bpt>SOCKADDR<ept id=\"p2\">](../../mfc/reference/sockaddr-structure.md)</ept> structure.","pos":[58235,58454],"source":"If `lpSockAddr` is nonzero, and the socket is of type **SOCK_DGRAM**, the network address of the socket which sent the data is copied to the corresponding [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure."},{"content":"The value pointed to by <ph id=\"ph1\">`lpSockAddrLen`</ph> is initialized to the size of this structure, and is modified on return to indicate the actual size of the address stored there.","pos":[58455,58623],"source":" The value pointed to by `lpSockAddrLen` is initialized to the size of this structure, and is modified on return to indicate the actual size of the address stored there."},{"content":"If no incoming data is available at the socket, the <ph id=\"ph1\">`ReceiveFrom`</ph> call waits for data to arrive unless the socket is nonblocking.","pos":[58624,58753],"source":" If no incoming data is available at the socket, the `ReceiveFrom` call waits for data to arrive unless the socket is nonblocking."},{"content":"In this case, a value of <bpt id=\"p1\">**</bpt>SOCKET_ERROR<ept id=\"p1\">**</ept> is returned with the error code set to <bpt id=\"p2\">**</bpt>WSAEWOULDBLOCK<ept id=\"p2\">**</ept>.","pos":[58754,58854],"source":" In this case, a value of **SOCKET_ERROR** is returned with the error code set to **WSAEWOULDBLOCK**."},{"content":"The <ph id=\"ph1\">`OnReceive`</ph> callback can be used to determine when more data arrives.","pos":[58855,58928],"source":" The `OnReceive` callback can be used to determine when more data arrives."},{"pos":[58935,59101],"content":"If the socket is of type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept> and the remote side has shut down the connection gracefully, a <ph id=\"ph1\">`ReceiveFrom`</ph> will complete immediately with 0 bytes received.","source":"If the socket is of type **SOCK_STREAM** and the remote side has shut down the connection gracefully, a `ReceiveFrom` will complete immediately with 0 bytes received."},{"pos":[59155,59182],"content":"CAsyncSocket::ReceiveFromEx"},{"pos":[59186,59382],"content":"Call this member function to receive a datagram and store the source address in the <bpt id=\"p1\">[</bpt>SOCKADDR<ept id=\"p1\">](../../mfc/reference/sockaddr-structure.md)</ept> structure or in <ph id=\"ph1\">`rSocketAddress`</ph> (handles IPv6 addresses).","source":"Call this member function to receive a datagram and store the source address in the [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure or in `rSocketAddress` (handles IPv6 addresses)."},{"content":"Parameters","pos":[59541,59551]},{"content":"A buffer for the incoming data.","pos":[59566,59597]},{"content":"The length of <ph id=\"ph1\">`lpBuf`</ph> in bytes.","pos":[59617,59648],"source":" The length of `lpBuf` in bytes."},{"content":"Reference to a <ph id=\"ph1\">`CString`</ph> object that receives a dotted number IP address.","pos":[59675,59748],"source":" Reference to a `CString` object that receives a dotted number IP address."},{"content":"Reference to a <bpt id=\"p1\">**</bpt>UINT<ept id=\"p1\">**</ept> that stores a port.","pos":[59772,59815],"source":" Reference to a **UINT** that stores a port."},{"content":"Specifies the way in which the call is made.","pos":[59834,59878]},{"content":"The semantics of this function are determined by the socket options and the <ph id=\"ph1\">`nFlags`</ph> parameter.","pos":[59879,59974],"source":" The semantics of this function are determined by the socket options and the `nFlags` parameter."},{"content":"The latter is constructed by combining any of the following values with the C++ <ph id=\"ph1\">`OR`</ph> operator:","pos":[59975,60069],"source":" The latter is constructed by combining any of the following values with the C++ `OR` operator:"},{"content":"<bpt id=\"p1\">**</bpt>MSG_PEEK<ept id=\"p1\">**</ept> Peek at the incoming data.","pos":[60077,60116],"source":"**MSG_PEEK** Peek at the incoming data."},{"content":"The data is copied into the buffer but is not removed from the input queue.","pos":[60117,60192]},{"pos":[60200,60237],"content":"<bpt id=\"p1\">**</bpt>MSG_OOB<ept id=\"p1\">**</ept> Process out-of-band data.","source":"**MSG_OOB** Process out-of-band data."},{"content":"Return Value","pos":[60247,60259]},{"content":"If no error occurs, <ph id=\"ph1\">`ReceiveFromEx`</ph> returns the number of bytes received.","pos":[60263,60336],"source":"If no error occurs, `ReceiveFromEx` returns the number of bytes received."},{"content":"If the connection has been closed, it returns 0.","pos":[60337,60385]},{"content":"Otherwise, a value of <bpt id=\"p1\">**</bpt>SOCKET_ERROR<ept id=\"p1\">**</ept> is returned, and a specific error code can be retrieved by calling <ph id=\"ph1\">`GetLastError`</ph>.","pos":[60386,60507],"source":" Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling `GetLastError`."},{"content":"The following errors apply to this member function:","pos":[60508,60559]},{"pos":[60567,60728],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[60736,60830],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[60838,60964],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpSockAddrLen`</ph> argument was invalid: the <ph id=\"ph2\">`lpSockAddr`</ph> buffer was too small to accommodate the peer address.","source":"**WSAEFAULT** The `lpSockAddrLen` argument was invalid: the `lpSockAddr` buffer was too small to accommodate the peer address."},{"pos":[60972,61043],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[61051,61109],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> The socket has not been bound with <bpt id=\"p2\">**</bpt>Bind<ept id=\"p2\">**</ept>.","source":"**WSAEINVAL** The socket has not been bound with **Bind**."},{"pos":[61117,61185],"content":"<bpt id=\"p1\">**</bpt>WSAENOTCONN<ept id=\"p1\">**</ept> The socket is not connected ( <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept> only).","source":"**WSAENOTCONN** The socket is not connected ( **SOCK_STREAM** only)."},{"pos":[61193,61240],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"pos":[61248,61335],"content":"<bpt id=\"p1\">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id=\"p1\">**</ept> was specified, but the socket is not of type <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept>.","source":"**WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**."},{"pos":[61343,61506],"content":"<bpt id=\"p1\">**</bpt>WSAESHUTDOWN<ept id=\"p1\">**</ept> The socket has been shut down; it is not possible to call <ph id=\"ph1\">`ReceiveFromEx`</ph> on a socket after <ph id=\"ph2\">`ShutDown`</ph> has been invoked with <ph id=\"ph3\">`nHow`</ph> set to 0 or 2.","source":"**WSAESHUTDOWN** The socket has been shut down; it is not possible to call `ReceiveFromEx` on a socket after `ShutDown` has been invoked with `nHow` set to 0 or 2."},{"pos":[61514,61615],"content":"<bpt id=\"p1\">**</bpt>WSAEWOULDBLOCK<ept id=\"p1\">**</ept> The socket is marked as nonblocking and the <ph id=\"ph1\">`ReceiveFromEx`</ph> operation would block.","source":"**WSAEWOULDBLOCK** The socket is marked as nonblocking and the `ReceiveFromEx` operation would block."},{"pos":[61623,61717],"content":"<bpt id=\"p1\">**</bpt>WSAEMSGSIZE<ept id=\"p1\">**</ept> The datagram was too large to fit into the specified buffer and was truncated.","source":"**WSAEMSGSIZE** The datagram was too large to fit into the specified buffer and was truncated."},{"pos":[61725,61809],"content":"<bpt id=\"p1\">**</bpt>WSAECONNABORTED<ept id=\"p1\">**</ept> The virtual circuit was aborted due to timeout or other failure.","source":"**WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure."},{"pos":[61817,61884],"content":"<bpt id=\"p1\">**</bpt>WSAECONNRESET<ept id=\"p1\">**</ept> The virtual circuit was reset by the remote side.","source":"**WSAECONNRESET** The virtual circuit was reset by the remote side."},{"content":"Remarks","pos":[61894,61901]},{"content":"This function is used to read incoming data on a (possibly connected) socket and capture the address from which the data was sent.","pos":[61905,62035]},{"pos":[62042,62192],"content":"This function is the same as <bpt id=\"p1\">[</bpt>CAsyncSocket::ReceiveFrom<ept id=\"p1\">](#casyncsocket__receivefrom)</ept> except that it handles IPv6 addresses as well as older protocols.","source":"This function is the same as [CAsyncSocket::ReceiveFrom](#casyncsocket__receivefrom) except that it handles IPv6 addresses as well as older protocols."},{"content":"For sockets of type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept>, as much information as is currently available up to the size of the buffer supplied is returned.","pos":[62199,62332],"source":"For sockets of type **SOCK_STREAM**, as much information as is currently available up to the size of the buffer supplied is returned."},{"content":"If the socket has been configured for in-line reception of out-of-band data (socket option <bpt id=\"p1\">**</bpt>SO_OOBINLINE<ept id=\"p1\">**</ept>) and out-of-band data is unread, only out-of-band data will be returned.","pos":[62333,62513],"source":" If the socket has been configured for in-line reception of out-of-band data (socket option **SO_OOBINLINE**) and out-of-band data is unread, only out-of-band data will be returned."},{"content":"The application can use the <bpt id=\"p1\">**</bpt>IOCtlSIOCATMARK<ept id=\"p1\">**</ept> option or <ph id=\"ph1\">`OnOutOfBandData`</ph> to determine whether any more out-of-band data remains to be read.","pos":[62514,62656],"source":" The application can use the **IOCtlSIOCATMARK** option or `OnOutOfBandData` to determine whether any more out-of-band data remains to be read."},{"content":"The <ph id=\"ph1\">`lpSockAddr`</ph> and <ph id=\"ph2\">`lpSockAddrLen`</ph> parameters are ignored for <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept> sockets.","pos":[62657,62745],"source":" The `lpSockAddr` and `lpSockAddrLen` parameters are ignored for **SOCK_STREAM** sockets."},{"content":"For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied.","pos":[62752,62864]},{"content":"If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the message, the excess data is lost, and <ph id=\"ph1\">`ReceiveFromEx`</ph> returns a value of <bpt id=\"p1\">**</bpt>SOCKET_ERROR<ept id=\"p1\">**</ept> with the error code set to <bpt id=\"p2\">**</bpt>WSAEMSGSIZE<ept id=\"p2\">**</ept>.","pos":[62865,63098],"source":" If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the message, the excess data is lost, and `ReceiveFromEx` returns a value of **SOCKET_ERROR** with the error code set to **WSAEMSGSIZE**."},{"content":"If <ph id=\"ph1\">`lpSockAddr`</ph> is nonzero, and the socket is of type <bpt id=\"p1\">**</bpt>SOCK_DGRAM<ept id=\"p1\">**</ept>, the network address of the socket which sent the data is copied to the corresponding <bpt id=\"p2\">[</bpt>SOCKADDR<ept id=\"p2\">](../../mfc/reference/sockaddr-structure.md)</ept> structure.","pos":[63105,63324],"source":"If `lpSockAddr` is nonzero, and the socket is of type **SOCK_DGRAM**, the network address of the socket which sent the data is copied to the corresponding [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure."},{"content":"The value pointed to by <ph id=\"ph1\">`lpSockAddrLen`</ph> is initialized to the size of this structure, and is modified on return to indicate the actual size of the address stored there.","pos":[63325,63493],"source":" The value pointed to by `lpSockAddrLen` is initialized to the size of this structure, and is modified on return to indicate the actual size of the address stored there."},{"content":"If no incoming data is available at the socket, the <ph id=\"ph1\">`ReceiveFromEx`</ph> call waits for data to arrive unless the socket is nonblocking.","pos":[63494,63625],"source":" If no incoming data is available at the socket, the `ReceiveFromEx` call waits for data to arrive unless the socket is nonblocking."},{"content":"In this case, a value of <bpt id=\"p1\">**</bpt>SOCKET_ERROR<ept id=\"p1\">**</ept> is returned with the error code set to <bpt id=\"p2\">**</bpt>WSAEWOULDBLOCK<ept id=\"p2\">**</ept>.","pos":[63626,63726],"source":" In this case, a value of **SOCKET_ERROR** is returned with the error code set to **WSAEWOULDBLOCK**."},{"content":"The <ph id=\"ph1\">`OnReceive`</ph> callback can be used to determine when more data arrives.","pos":[63727,63800],"source":" The `OnReceive` callback can be used to determine when more data arrives."},{"pos":[63807,63975],"content":"If the socket is of type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept> and the remote side has shut down the connection gracefully, a <ph id=\"ph1\">`ReceiveFromEx`</ph> will complete immediately with 0 bytes received.","source":"If the socket is of type **SOCK_STREAM** and the remote side has shut down the connection gracefully, a `ReceiveFromEx` will complete immediately with 0 bytes received."},{"pos":[64020,64038],"content":"CAsyncSocket::Send"},{"content":"Call this member function to send data on a connected socket.","pos":[64042,64103]},{"content":"Parameters","pos":[64211,64221]},{"content":"A buffer containing the data to be transmitted.","pos":[64236,64283]},{"content":"The length of the data in <ph id=\"ph1\">`lpBuf`</ph> in bytes.","pos":[64303,64346],"source":" The length of the data in `lpBuf` in bytes."},{"content":"Specifies the way in which the call is made.","pos":[64365,64409]},{"content":"The semantics of this function are determined by the socket options and the <ph id=\"ph1\">`nFlags`</ph> parameter.","pos":[64410,64505],"source":" The semantics of this function are determined by the socket options and the `nFlags` parameter."},{"content":"The latter is constructed by combining any of the following values with the C++ <ph id=\"ph1\">`OR`</ph> operator:","pos":[64506,64600],"source":" The latter is constructed by combining any of the following values with the C++ `OR` operator:"},{"content":"<bpt id=\"p1\">**</bpt>MSG_DONTROUTE<ept id=\"p1\">**</ept> Specifies that the data should not be subject to routing.","pos":[64608,64683],"source":"**MSG_DONTROUTE** Specifies that the data should not be subject to routing."},{"content":"A Windows Sockets supplier can choose to ignore this flag.","pos":[64684,64742]},{"pos":[64750,64808],"content":"<bpt id=\"p1\">**</bpt>MSG_OOB<ept id=\"p1\">**</ept> Send out-of-band data ( <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept> only).","source":"**MSG_OOB** Send out-of-band data ( **SOCK_STREAM** only)."},{"content":"Return Value","pos":[64818,64830]},{"content":"If no error occurs, <bpt id=\"p1\">**</bpt>Send<ept id=\"p1\">**</ept> returns the total number of characters sent.","pos":[64834,64907],"source":"If no error occurs, **Send** returns the total number of characters sent."},{"content":"(Note that this can be less than the number indicated by <ph id=\"ph1\">`nBufLen`</ph>.) Otherwise, a value of <bpt id=\"p1\">**</bpt>SOCKET_ERROR<ept id=\"p1\">**</ept> is returned, and a specific error code can be retrieved by calling <bpt id=\"p2\">[</bpt>GetLastError<ept id=\"p2\">](#casyncsocket__getlasterror)</ept>.","pos":[64908,65127],"source":" (Note that this can be less than the number indicated by `nBufLen`.) Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[65128,65179]},{"pos":[65187,65348],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[65356,65450],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[65458,65555],"content":"<bpt id=\"p1\">**</bpt>WSAEACCES<ept id=\"p1\">**</ept> The requested address is a broadcast address, but the appropriate flag was not set.","source":"**WSAEACCES** The requested address is a broadcast address, but the appropriate flag was not set."},{"pos":[65563,65634],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[65642,65726],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpBuf`</ph> argument is not in a valid part of the user address space.","source":"**WSAEFAULT** The `lpBuf` argument is not in a valid part of the user address space."},{"pos":[65734,65834],"content":"<bpt id=\"p1\">**</bpt>WSAENETRESET<ept id=\"p1\">**</ept> The connection must be reset because the Windows Sockets implementation dropped it.","source":"**WSAENETRESET** The connection must be reset because the Windows Sockets implementation dropped it."},{"pos":[65855,65916],"content":"The Windows Sockets implementation reports a buffer deadlock."},{"pos":[65924,65968],"content":"<bpt id=\"p1\">**</bpt>WSAENOTCONN<ept id=\"p1\">**</ept> The socket is not connected.","source":"**WSAENOTCONN** The socket is not connected."},{"pos":[65976,66023],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"pos":[66031,66118],"content":"<bpt id=\"p1\">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id=\"p1\">**</ept> was specified, but the socket is not of type <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept>.","source":"**WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**."},{"pos":[66126,66282],"content":"<bpt id=\"p1\">**</bpt>WSAESHUTDOWN<ept id=\"p1\">**</ept> The socket has been shut down; it is not possible to call <bpt id=\"p2\">**</bpt>Send<ept id=\"p2\">**</ept> on a socket after <ph id=\"ph1\">`ShutDown`</ph> has been invoked with <ph id=\"ph2\">`nHow`</ph> set to 1 or 2.","source":"**WSAESHUTDOWN** The socket has been shut down; it is not possible to call **Send** on a socket after `ShutDown` has been invoked with `nHow` set to 1 or 2."},{"pos":[66290,66385],"content":"<bpt id=\"p1\">**</bpt>WSAEWOULDBLOCK<ept id=\"p1\">**</ept> The socket is marked as nonblocking and the requested operation would block.","source":"**WSAEWOULDBLOCK** The socket is marked as nonblocking and the requested operation would block."},{"pos":[66393,66539],"content":"<bpt id=\"p1\">**</bpt>WSAEMSGSIZE<ept id=\"p1\">**</ept> The socket is of type <bpt id=\"p2\">**</bpt>SOCK_DGRAM<ept id=\"p2\">**</ept>, and the datagram is larger than the maximum supported by the Windows Sockets implementation.","source":"**WSAEMSGSIZE** The socket is of type **SOCK_DGRAM**, and the datagram is larger than the maximum supported by the Windows Sockets implementation."},{"pos":[66547,66605],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> The socket has not been bound with <bpt id=\"p2\">**</bpt>Bind<ept id=\"p2\">**</ept>.","source":"**WSAEINVAL** The socket has not been bound with **Bind**."},{"pos":[66613,66697],"content":"<bpt id=\"p1\">**</bpt>WSAECONNABORTED<ept id=\"p1\">**</ept> The virtual circuit was aborted due to timeout or other failure.","source":"**WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure."},{"pos":[66705,66772],"content":"<bpt id=\"p1\">**</bpt>WSAECONNRESET<ept id=\"p1\">**</ept> The virtual circuit was reset by the remote side.","source":"**WSAECONNRESET** The virtual circuit was reset by the remote side."},{"content":"Remarks","pos":[66782,66789]},{"content":"<bpt id=\"p1\">**</bpt>Send<ept id=\"p1\">**</ept> is used to write outgoing data on connected stream or datagram sockets.","pos":[66793,66873],"source":"**Send** is used to write outgoing data on connected stream or datagram sockets."},{"content":"For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the <bpt id=\"p1\">**</bpt>iMaxUdpDg<ept id=\"p1\">**</ept> element in the <bpt id=\"p2\">[</bpt>WSADATA<ept id=\"p2\">](../../mfc/reference/wsadata-structure.md)</ept> structure returned by <ph id=\"ph1\">`AfxSocketInit`</ph>.","pos":[66874,67124],"source":" For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the **iMaxUdpDg** element in the [WSADATA](../../mfc/reference/wsadata-structure.md) structure returned by `AfxSocketInit`."},{"content":"If the data is too long to pass atomically through the underlying protocol, the error <bpt id=\"p1\">**</bpt>WSAEMSGSIZE<ept id=\"p1\">**</ept> is returned via <ph id=\"ph1\">`GetLastError`</ph>, and no data is transmitted.","pos":[67125,67286],"source":" If the data is too long to pass atomically through the underlying protocol, the error **WSAEMSGSIZE** is returned via `GetLastError`, and no data is transmitted."},{"pos":[67293,67424],"content":"Note that for a datagram socket the successful completion of a <bpt id=\"p1\">**</bpt>Send<ept id=\"p1\">**</ept> does not indicate that the data was successfully delivered.","source":"Note that for a datagram socket the successful completion of a **Send** does not indicate that the data was successfully delivered."},{"pos":[67431,67622],"content":"On <ph id=\"ph1\">`CAsyncSocket`</ph> objects of type <bpt id=\"p1\">**</bpt>SOCK_STREAM<ept id=\"p1\">**</ept>, the number of bytes written can be between 1 and the requested length, depending on buffer availability on both the local and foreign hosts.","source":"On `CAsyncSocket` objects of type **SOCK_STREAM**, the number of bytes written can be between 1 and the requested length, depending on buffer availability on both the local and foreign hosts."},{"content":"Example","pos":[67632,67639]},{"pos":[67644,67710],"content":"See the example for <bpt id=\"p1\">[</bpt>CAsyncSocket::OnSend<ept id=\"p1\">](#casyncsocket__onsend)</ept>.","source":"See the example for [CAsyncSocket::OnSend](#casyncsocket__onsend)."},{"pos":[67757,67777],"content":"CAsyncSocket::SendTo"},{"content":"Call this member function to send data to a specific destination.","pos":[67781,67846]},{"content":"Parameters","pos":[68146,68156]},{"content":"A buffer containing the data to be transmitted.","pos":[68171,68218]},{"content":"The length of the data in <ph id=\"ph1\">`lpBuf`</ph> in bytes.","pos":[68238,68281],"source":" The length of the data in `lpBuf` in bytes."},{"content":"The port identifying the socket application.","pos":[68303,68347]},{"content":"The network address of the socket to which this object is connected: a machine name such as \"ftp.microsoft.com,\" or a dotted number such as \"128.56.22.8\".","pos":[68375,68529]},{"content":"Specifies the way in which the call is made.","pos":[68548,68592]},{"content":"The semantics of this function are determined by the socket options and the <ph id=\"ph1\">`nFlags`</ph> parameter.","pos":[68593,68688],"source":" The semantics of this function are determined by the socket options and the `nFlags` parameter."},{"content":"The latter is constructed by combining any of the following values with the C++ <ph id=\"ph1\">`OR`</ph> operator:","pos":[68689,68783],"source":" The latter is constructed by combining any of the following values with the C++ `OR` operator:"},{"content":"<bpt id=\"p1\">**</bpt>MSG_DONTROUTE<ept id=\"p1\">**</ept> Specifies that the data should not be subject to routing.","pos":[68791,68866],"source":"**MSG_DONTROUTE** Specifies that the data should not be subject to routing."},{"content":"A Windows Sockets supplier can choose to ignore this flag.","pos":[68867,68925]},{"pos":[68933,68991],"content":"<bpt id=\"p1\">**</bpt>MSG_OOB<ept id=\"p1\">**</ept> Send out-of-band data ( <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept> only).","source":"**MSG_OOB** Send out-of-band data ( **SOCK_STREAM** only)."},{"pos":[68998,69140],"content":"`lpSockAddr`  \nA pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that contains the address of the target socket.","leadings":[""," "],"nodes":[{"content":"A pointer to a <bpt id=\"p1\">[</bpt>SOCKADDR<ept id=\"p1\">](../../mfc/reference/sockaddr-structure.md)</ept> structure that contains the address of the target socket.","pos":[15,141],"source":"A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that contains the address of the target socket."}]},{"pos":[69147,69216],"content":"`nSockAddrLen`  \nThe length of the address in `lpSockAddr` in bytes.","leadings":[""," "],"nodes":[{"content":"The length of the address in <ph id=\"ph1\">`lpSockAddr`</ph> in bytes.","pos":[17,68],"source":"The length of the address in `lpSockAddr` in bytes."}]},{"content":"Return Value","pos":[69226,69238]},{"content":"If no error occurs, <ph id=\"ph1\">`SendTo`</ph> returns the total number of characters sent.","pos":[69242,69315],"source":"If no error occurs, `SendTo` returns the total number of characters sent."},{"content":"(Note that this can be less than the number indicated by <ph id=\"ph1\">`nBufLen`</ph>.) Otherwise, a value of <bpt id=\"p1\">**</bpt>SOCKET_ERROR<ept id=\"p1\">**</ept> is returned, and a specific error code can be retrieved by calling <bpt id=\"p2\">[</bpt>GetLastError<ept id=\"p2\">](#casyncsocket__getlasterror)</ept>.","pos":[69316,69535],"source":" (Note that this can be less than the number indicated by `nBufLen`.) Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[69536,69587]},{"pos":[69595,69756],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[69764,69858],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[69866,69963],"content":"<bpt id=\"p1\">**</bpt>WSAEACCES<ept id=\"p1\">**</ept> The requested address is a broadcast address, but the appropriate flag was not set.","source":"**WSAEACCES** The requested address is a broadcast address, but the appropriate flag was not set."},{"pos":[69971,70042],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[70050,70275],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpBuf`</ph> or <ph id=\"ph2\">`lpSockAddr`</ph> parameters are not part of the user address space, or the <ph id=\"ph3\">`lpSockAddr`</ph> argument is too small (less than the size of a <bpt id=\"p2\">[</bpt>SOCKADDR<ept id=\"p2\">](../../mfc/reference/sockaddr-structure.md)</ept> structure).","source":"**WSAEFAULT** The `lpBuf` or `lpSockAddr` parameters are not part of the user address space, or the `lpSockAddr` argument is too small (less than the size of a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure)."},{"pos":[70283,70322],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> The host name is invalid.","source":"**WSAEINVAL** The host name is invalid."},{"pos":[70330,70430],"content":"<bpt id=\"p1\">**</bpt>WSAENETRESET<ept id=\"p1\">**</ept> The connection must be reset because the Windows Sockets implementation dropped it.","source":"**WSAENETRESET** The connection must be reset because the Windows Sockets implementation dropped it."},{"pos":[70451,70512],"content":"The Windows Sockets implementation reports a buffer deadlock."},{"pos":[70520,70588],"content":"<bpt id=\"p1\">**</bpt>WSAENOTCONN<ept id=\"p1\">**</ept> The socket is not connected ( <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept> only).","source":"**WSAENOTCONN** The socket is not connected ( **SOCK_STREAM** only)."},{"pos":[70596,70643],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"pos":[70651,70738],"content":"<bpt id=\"p1\">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id=\"p1\">**</ept> was specified, but the socket is not of type <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept>.","source":"**WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**."},{"pos":[70746,70902],"content":"<bpt id=\"p1\">**</bpt>WSAESHUTDOWN<ept id=\"p1\">**</ept> The socket has been shut down; it is not possible to call <ph id=\"ph1\">`SendTo`</ph> on a socket after <ph id=\"ph2\">`ShutDown`</ph> has been invoked with <ph id=\"ph3\">`nHow`</ph> set to 1 or 2.","source":"**WSAESHUTDOWN** The socket has been shut down; it is not possible to call `SendTo` on a socket after `ShutDown` has been invoked with `nHow` set to 1 or 2."},{"pos":[70910,71005],"content":"<bpt id=\"p1\">**</bpt>WSAEWOULDBLOCK<ept id=\"p1\">**</ept> The socket is marked as nonblocking and the requested operation would block.","source":"**WSAEWOULDBLOCK** The socket is marked as nonblocking and the requested operation would block."},{"pos":[71013,71159],"content":"<bpt id=\"p1\">**</bpt>WSAEMSGSIZE<ept id=\"p1\">**</ept> The socket is of type <bpt id=\"p2\">**</bpt>SOCK_DGRAM<ept id=\"p2\">**</ept>, and the datagram is larger than the maximum supported by the Windows Sockets implementation.","source":"**WSAEMSGSIZE** The socket is of type **SOCK_DGRAM**, and the datagram is larger than the maximum supported by the Windows Sockets implementation."},{"pos":[71167,71251],"content":"<bpt id=\"p1\">**</bpt>WSAECONNABORTED<ept id=\"p1\">**</ept> The virtual circuit was aborted due to timeout or other failure.","source":"**WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure."},{"pos":[71259,71326],"content":"<bpt id=\"p1\">**</bpt>WSAECONNRESET<ept id=\"p1\">**</ept> The virtual circuit was reset by the remote side.","source":"**WSAECONNRESET** The virtual circuit was reset by the remote side."},{"pos":[71334,71417],"content":"<bpt id=\"p1\">**</bpt>WSAEADDRNOTAVAIL<ept id=\"p1\">**</ept> The specified address is not available from the local machine.","source":"**WSAEADDRNOTAVAIL** The specified address is not available from the local machine."},{"pos":[71425,71511],"content":"<bpt id=\"p1\">**</bpt>WSAEAFNOSUPPORT<ept id=\"p1\">**</ept> Addresses in the specified family cannot be used with this socket.","source":"**WSAEAFNOSUPPORT** Addresses in the specified family cannot be used with this socket."},{"pos":[71519,71573],"content":"<bpt id=\"p1\">**</bpt>WSAEDESTADDRREQ<ept id=\"p1\">**</ept> A destination address is required.","source":"**WSAEDESTADDRREQ** A destination address is required."},{"pos":[71581,71658],"content":"<bpt id=\"p1\">**</bpt>WSAENETUNREACH<ept id=\"p1\">**</ept> The network cannot be reached from this host at this time.","source":"**WSAENETUNREACH** The network cannot be reached from this host at this time."},{"content":"Remarks","pos":[71668,71675]},{"content":"is used on datagram or stream sockets and is used to write outgoing data on a socket.","pos":[71688,71773]},{"content":"For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the <bpt id=\"p1\">**</bpt>iMaxUdpDg<ept id=\"p1\">**</ept> element in the <bpt id=\"p2\">[</bpt>WSADATA<ept id=\"p2\">](../../mfc/reference/wsadata-structure.md)</ept> structure filled out by <bpt id=\"p3\">[</bpt>AfxSocketInit<ept id=\"p3\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept>.","pos":[71774,72103],"source":" For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the **iMaxUdpDg** element in the [WSADATA](../../mfc/reference/wsadata-structure.md) structure filled out by [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit)."},{"content":"If the data is too long to pass atomically through the underlying protocol, the error <bpt id=\"p1\">**</bpt>WSAEMSGSIZE<ept id=\"p1\">**</ept> is returned, and no data is transmitted.","pos":[72104,72246],"source":" If the data is too long to pass atomically through the underlying protocol, the error **WSAEMSGSIZE** is returned, and no data is transmitted."},{"pos":[72253,72362],"content":"Note that the successful completion of a <ph id=\"ph1\">`SendTo`</ph> does not indicate that the data was successfully delivered.","source":"Note that the successful completion of a `SendTo` does not indicate that the data was successfully delivered."},{"pos":[72378,72499],"content":"is only used on a <bpt id=\"p1\">**</bpt>SOCK_DGRAM<ept id=\"p1\">**</ept> socket to send a datagram to a specific socket identified by the <ph id=\"ph1\">`lpSockAddr`</ph> parameter.","source":" is only used on a **SOCK_DGRAM** socket to send a datagram to a specific socket identified by the `lpSockAddr` parameter."},{"content":"To send a broadcast (on a <bpt id=\"p1\">**</bpt>SOCK_DGRAM<ept id=\"p1\">**</ept> only), the address in the <ph id=\"ph1\">`lpSockAddr`</ph> parameter should be constructed using the special IP address <bpt id=\"p2\">**</bpt>INADDR_BROADCAST<ept id=\"p2\">**</ept> (defined in the Windows Sockets header file WINSOCK.H) together with the intended port number.","pos":[72506,72762],"source":"To send a broadcast (on a **SOCK_DGRAM** only), the address in the `lpSockAddr` parameter should be constructed using the special IP address **INADDR_BROADCAST** (defined in the Windows Sockets header file WINSOCK.H) together with the intended port number."},{"content":"Or, if the <ph id=\"ph1\">`lpszHostAddress`</ph> parameter is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the socket is configured for broadcast.","pos":[72763,72854],"source":" Or, if the `lpszHostAddress` parameter is **NULL**, the socket is configured for broadcast."},{"content":"It is generally inadvisable for a broadcast datagram to exceed the size at which fragmentation can occur, which implies that the data portion of the datagram (excluding headers) should not exceed 512 bytes.","pos":[72855,73061]},{"pos":[73068,73148],"content":"To handle IPv6 addresses, use <bpt id=\"p1\">[</bpt>CAsyncSocket::SendToEx<ept id=\"p1\">](#casyncsocket__sendtoex)</ept>.","source":"To handle IPv6 addresses, use [CAsyncSocket::SendToEx](#casyncsocket__sendtoex)."},{"pos":[73197,73219],"content":"CAsyncSocket::SendToEx"},{"content":"Call this member function to send data to a specific destination (handles IPv6 addresses).","pos":[73223,73313]},{"content":"Parameters","pos":[73477,73487]},{"content":"A buffer containing the data to be transmitted.","pos":[73502,73549]},{"content":"The length of the data in <ph id=\"ph1\">`lpBuf`</ph> in bytes.","pos":[73569,73612],"source":" The length of the data in `lpBuf` in bytes."},{"content":"The port identifying the socket application.","pos":[73634,73678]},{"content":"The network address of the socket to which this object is connected: a machine name such as \"ftp.microsoft.com,\" or a dotted number such as \"128.56.22.8\".","pos":[73706,73860]},{"content":"Specifies the way in which the call is made.","pos":[73879,73923]},{"content":"The semantics of this function are determined by the socket options and the <ph id=\"ph1\">`nFlags`</ph> parameter.","pos":[73924,74019],"source":" The semantics of this function are determined by the socket options and the `nFlags` parameter."},{"content":"The latter is constructed by combining any of the following values with the C++ <ph id=\"ph1\">`OR`</ph> operator:","pos":[74020,74114],"source":" The latter is constructed by combining any of the following values with the C++ `OR` operator:"},{"content":"<bpt id=\"p1\">**</bpt>MSG_DONTROUTE<ept id=\"p1\">**</ept> Specifies that the data should not be subject to routing.","pos":[74122,74197],"source":"**MSG_DONTROUTE** Specifies that the data should not be subject to routing."},{"content":"A Windows Sockets supplier can choose to ignore this flag.","pos":[74198,74256]},{"pos":[74264,74322],"content":"<bpt id=\"p1\">**</bpt>MSG_OOB<ept id=\"p1\">**</ept> Send out-of-band data ( <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept> only).","source":"**MSG_OOB** Send out-of-band data ( **SOCK_STREAM** only)."},{"content":"Return Value","pos":[74332,74344]},{"content":"If no error occurs, <ph id=\"ph1\">`SendToEx`</ph> returns the total number of characters sent.","pos":[74348,74423],"source":"If no error occurs, `SendToEx` returns the total number of characters sent."},{"content":"(Note that this can be less than the number indicated by <ph id=\"ph1\">`nBufLen`</ph>.) Otherwise, a value of <bpt id=\"p1\">**</bpt>SOCKET_ERROR<ept id=\"p1\">**</ept> is returned, and a specific error code can be retrieved by calling <bpt id=\"p2\">[</bpt>GetLastError<ept id=\"p2\">](#casyncsocket__getlasterror)</ept>.","pos":[74424,74643],"source":" (Note that this can be less than the number indicated by `nBufLen`.) Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[74644,74695]},{"pos":[74703,74864],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[74872,74966],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[74974,75071],"content":"<bpt id=\"p1\">**</bpt>WSAEACCES<ept id=\"p1\">**</ept> The requested address is a broadcast address, but the appropriate flag was not set.","source":"**WSAEACCES** The requested address is a broadcast address, but the appropriate flag was not set."},{"pos":[75079,75150],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[75158,75383],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> The <ph id=\"ph1\">`lpBuf`</ph> or <ph id=\"ph2\">`lpSockAddr`</ph> parameters are not part of the user address space, or the <ph id=\"ph3\">`lpSockAddr`</ph> argument is too small (less than the size of a <bpt id=\"p2\">[</bpt>SOCKADDR<ept id=\"p2\">](../../mfc/reference/sockaddr-structure.md)</ept> structure).","source":"**WSAEFAULT** The `lpBuf` or `lpSockAddr` parameters are not part of the user address space, or the `lpSockAddr` argument is too small (less than the size of a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure)."},{"pos":[75391,75430],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> The host name is invalid.","source":"**WSAEINVAL** The host name is invalid."},{"pos":[75438,75538],"content":"<bpt id=\"p1\">**</bpt>WSAENETRESET<ept id=\"p1\">**</ept> The connection must be reset because the Windows Sockets implementation dropped it.","source":"**WSAENETRESET** The connection must be reset because the Windows Sockets implementation dropped it."},{"pos":[75559,75620],"content":"The Windows Sockets implementation reports a buffer deadlock."},{"pos":[75628,75696],"content":"<bpt id=\"p1\">**</bpt>WSAENOTCONN<ept id=\"p1\">**</ept> The socket is not connected ( <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept> only).","source":"**WSAENOTCONN** The socket is not connected ( **SOCK_STREAM** only)."},{"pos":[75704,75751],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"pos":[75759,75846],"content":"<bpt id=\"p1\">**</bpt>WSAEOPNOTSUPP MSG_OOB<ept id=\"p1\">**</ept> was specified, but the socket is not of type <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept>.","source":"**WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**."},{"pos":[75854,76012],"content":"<bpt id=\"p1\">**</bpt>WSAESHUTDOWN<ept id=\"p1\">**</ept> The socket has been shut down; it is not possible to call <ph id=\"ph1\">`SendToEx`</ph> on a socket after <ph id=\"ph2\">`ShutDown`</ph> has been invoked with <ph id=\"ph3\">`nHow`</ph> set to 1 or 2.","source":"**WSAESHUTDOWN** The socket has been shut down; it is not possible to call `SendToEx` on a socket after `ShutDown` has been invoked with `nHow` set to 1 or 2."},{"pos":[76020,76115],"content":"<bpt id=\"p1\">**</bpt>WSAEWOULDBLOCK<ept id=\"p1\">**</ept> The socket is marked as nonblocking and the requested operation would block.","source":"**WSAEWOULDBLOCK** The socket is marked as nonblocking and the requested operation would block."},{"pos":[76123,76269],"content":"<bpt id=\"p1\">**</bpt>WSAEMSGSIZE<ept id=\"p1\">**</ept> The socket is of type <bpt id=\"p2\">**</bpt>SOCK_DGRAM<ept id=\"p2\">**</ept>, and the datagram is larger than the maximum supported by the Windows Sockets implementation.","source":"**WSAEMSGSIZE** The socket is of type **SOCK_DGRAM**, and the datagram is larger than the maximum supported by the Windows Sockets implementation."},{"pos":[76277,76361],"content":"<bpt id=\"p1\">**</bpt>WSAECONNABORTED<ept id=\"p1\">**</ept> The virtual circuit was aborted due to timeout or other failure.","source":"**WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure."},{"pos":[76369,76436],"content":"<bpt id=\"p1\">**</bpt>WSAECONNRESET<ept id=\"p1\">**</ept> The virtual circuit was reset by the remote side.","source":"**WSAECONNRESET** The virtual circuit was reset by the remote side."},{"pos":[76444,76527],"content":"<bpt id=\"p1\">**</bpt>WSAEADDRNOTAVAIL<ept id=\"p1\">**</ept> The specified address is not available from the local machine.","source":"**WSAEADDRNOTAVAIL** The specified address is not available from the local machine."},{"pos":[76535,76621],"content":"<bpt id=\"p1\">**</bpt>WSAEAFNOSUPPORT<ept id=\"p1\">**</ept> Addresses in the specified family cannot be used with this socket.","source":"**WSAEAFNOSUPPORT** Addresses in the specified family cannot be used with this socket."},{"pos":[76629,76683],"content":"<bpt id=\"p1\">**</bpt>WSAEDESTADDRREQ<ept id=\"p1\">**</ept> A destination address is required.","source":"**WSAEDESTADDRREQ** A destination address is required."},{"pos":[76691,76768],"content":"<bpt id=\"p1\">**</bpt>WSAENETUNREACH<ept id=\"p1\">**</ept> The network cannot be reached from this host at this time.","source":"**WSAENETUNREACH** The network cannot be reached from this host at this time."},{"content":"Remarks","pos":[76778,76785]},{"pos":[76789,76927],"content":"This method is the same as <bpt id=\"p1\">[</bpt>CAsyncSocket::SendTo<ept id=\"p1\">](#casyncsocket__sendto)</ept> except that it handles IPv6 addresses as well as older protocols.","source":"This method is the same as [CAsyncSocket::SendTo](#casyncsocket__sendto) except that it handles IPv6 addresses as well as older protocols."},{"content":"is used on datagram or stream sockets and is used to write outgoing data on a socket.","pos":[76945,77030]},{"content":"For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the <bpt id=\"p1\">**</bpt>iMaxUdpDg<ept id=\"p1\">**</ept> element in the <bpt id=\"p2\">[</bpt>WSADATA<ept id=\"p2\">](../../mfc/reference/wsadata-structure.md)</ept> structure filled out by <bpt id=\"p3\">[</bpt>AfxSocketInit<ept id=\"p3\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept>.","pos":[77031,77360],"source":" For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the **iMaxUdpDg** element in the [WSADATA](../../mfc/reference/wsadata-structure.md) structure filled out by [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit)."},{"content":"If the data is too long to pass atomically through the underlying protocol, the error <bpt id=\"p1\">**</bpt>WSAEMSGSIZE<ept id=\"p1\">**</ept> is returned, and no data is transmitted.","pos":[77361,77503],"source":" If the data is too long to pass atomically through the underlying protocol, the error **WSAEMSGSIZE** is returned, and no data is transmitted."},{"pos":[77510,77621],"content":"Note that the successful completion of a <ph id=\"ph1\">`SendToEx`</ph> does not indicate that the data was successfully delivered.","source":"Note that the successful completion of a `SendToEx` does not indicate that the data was successfully delivered."},{"pos":[77639,77760],"content":"is only used on a <bpt id=\"p1\">**</bpt>SOCK_DGRAM<ept id=\"p1\">**</ept> socket to send a datagram to a specific socket identified by the <ph id=\"ph1\">`lpSockAddr`</ph> parameter.","source":" is only used on a **SOCK_DGRAM** socket to send a datagram to a specific socket identified by the `lpSockAddr` parameter."},{"content":"To send a broadcast (on a <bpt id=\"p1\">**</bpt>SOCK_DGRAM<ept id=\"p1\">**</ept> only), the address in the <ph id=\"ph1\">`lpSockAddr`</ph> parameter should be constructed using the special IP address <bpt id=\"p2\">**</bpt>INADDR_BROADCAST<ept id=\"p2\">**</ept> (defined in the Windows Sockets header file WINSOCK.H) together with the intended port number.","pos":[77767,78023],"source":"To send a broadcast (on a **SOCK_DGRAM** only), the address in the `lpSockAddr` parameter should be constructed using the special IP address **INADDR_BROADCAST** (defined in the Windows Sockets header file WINSOCK.H) together with the intended port number."},{"content":"Or, if the <ph id=\"ph1\">`lpszHostAddress`</ph> parameter is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the socket is configured for broadcast.","pos":[78024,78115],"source":" Or, if the `lpszHostAddress` parameter is **NULL**, the socket is configured for broadcast."},{"content":"It is generally inadvisable for a broadcast datagram to exceed the size at which fragmentation can occur, which implies that the data portion of the datagram (excluding headers) should not exceed 512 bytes.","pos":[78116,78322]},{"pos":[78373,78397],"content":"CAsyncSocket::SetSockOpt"},{"content":"Call this member function to set a socket option.","pos":[78401,78450]},{"content":"Parameters","pos":[78600,78610]},{"content":"The socket option for which the value is to be set.","pos":[78631,78682]},{"content":"A pointer to the buffer in which the value for the requested option is supplied.","pos":[78708,78788]},{"content":"The size of the <ph id=\"ph1\">`lpOptionValue`</ph> buffer in bytes.","pos":[78811,78859],"source":" The size of the `lpOptionValue` buffer in bytes."},{"content":"The level at which the option is defined; the only supported levels are <bpt id=\"p1\">**</bpt>SOL_SOCKET<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>IPPROTO_TCP<ept id=\"p2\">**</ept>.","pos":[78878,78985],"source":" The level at which the option is defined; the only supported levels are **SOL_SOCKET** and **IPPROTO_TCP**."},{"content":"Return Value","pos":[78995,79007]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[79011,79161],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[79162,79213]},{"pos":[79221,79382],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[79390,79484],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[79492,79574],"content":"<bpt id=\"p1\">**</bpt>WSAEFAULT<ept id=\"p1\">**</ept> <ph id=\"ph1\">`lpOptionValue`</ph> is not in a valid part of the process address space.","source":"**WSAEFAULT** `lpOptionValue` is not in a valid part of the process address space."},{"pos":[79582,79653],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[79661,79749],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> <ph id=\"ph1\">`nLevel`</ph> is not valid, or the information in <ph id=\"ph2\">`lpOptionValue`</ph> is not valid.","source":"**WSAEINVAL** `nLevel` is not valid, or the information in `lpOptionValue` is not valid."},{"pos":[79757,79828],"content":"<bpt id=\"p1\">**</bpt>WSAENETRESET<ept id=\"p1\">**</ept> Connection has timed out when <bpt id=\"p2\">**</bpt>SO_KEEPALIVE<ept id=\"p2\">**</ept> is set.","source":"**WSAENETRESET** Connection has timed out when **SO_KEEPALIVE** is set."},{"content":"<bpt id=\"p1\">**</bpt>WSAENOPROTOOPT<ept id=\"p1\">**</ept> The option is unknown or unsupported.","pos":[79836,79892],"source":"**WSAENOPROTOOPT** The option is unknown or unsupported."},{"content":"In particular, <bpt id=\"p1\">**</bpt>SO_BROADCAST<ept id=\"p1\">**</ept> is not supported on sockets of type <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept>, while <bpt id=\"p3\">**</bpt>SO_DONTLINGER<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>SO_KEEPALIVE<ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>SO_LINGER<ept id=\"p5\">**</ept>, and <bpt id=\"p6\">**</bpt>SO_OOBINLINE<ept id=\"p6\">**</ept> are not supported on sockets of type <bpt id=\"p7\">**</bpt>SOCK_DGRAM<ept id=\"p7\">**</ept>.","pos":[79893,80109],"source":" In particular, **SO_BROADCAST** is not supported on sockets of type **SOCK_STREAM**, while **SO_DONTLINGER**, **SO_KEEPALIVE**, **SO_LINGER**, and **SO_OOBINLINE** are not supported on sockets of type **SOCK_DGRAM**."},{"pos":[80117,80188],"content":"<bpt id=\"p1\">**</bpt>WSAENOTCONN<ept id=\"p1\">**</ept> Connection has been reset when <bpt id=\"p2\">**</bpt>SO_KEEPALIVE<ept id=\"p2\">**</ept> is set.","source":"**WSAENOTCONN** Connection has been reset when **SO_KEEPALIVE** is set."},{"pos":[80196,80243],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"content":"Remarks","pos":[80253,80260]},{"content":"sets the current value for a socket option associated with a socket of any type, in any state.","pos":[80277,80371]},{"content":"Although options can exist at multiple protocol levels, this specification only defines options that exist at the uppermost \"socket\" level.","pos":[80372,80511]},{"content":"Options affect socket operations, such as whether expedited data is received in the normal data stream, whether broadcast messages can be sent on the socket, and so on.","pos":[80512,80680]},{"content":"There are two types of socket options: Boolean options that enable or disable a feature or behavior, and options which require an integer value or structure.","pos":[80687,80844]},{"content":"To enable a Boolean option, <ph id=\"ph1\">`lpOptionValue`</ph> points to a nonzero integer.","pos":[80845,80917],"source":" To enable a Boolean option, `lpOptionValue` points to a nonzero integer."},{"content":"To disable the option <ph id=\"ph1\">`lpOptionValue`</ph> points to an integer equal to zero.","pos":[80918,80991],"source":" To disable the option `lpOptionValue` points to an integer equal to zero."},{"content":"should be equal to <bpt id=\"p1\">**</bpt>sizeof(BOOL)<ept id=\"p1\">**</ept> for Boolean options.","pos":[81005,81061],"source":" should be equal to **sizeof(BOOL)** for Boolean options."},{"content":"For other options, <ph id=\"ph1\">`lpOptionValue`</ph> points to the integer or structure that contains the desired value for the option, and <ph id=\"ph2\">`nOptionLen`</ph> is the length of the integer or structure.","pos":[81062,81239],"source":" For other options, `lpOptionValue` points to the integer or structure that contains the desired value for the option, and `nOptionLen` is the length of the integer or structure."},{"pos":[81246,81382],"content":"<bpt id=\"p1\">**</bpt>SO_LINGER<ept id=\"p1\">**</ept> controls the action taken when unsent data is queued on a socket and the <bpt id=\"p2\">**</bpt>Close<ept id=\"p2\">**</ept> function is called to close the socket.","source":"**SO_LINGER** controls the action taken when unsent data is queued on a socket and the **Close** function is called to close the socket."},{"content":"By default, a socket cannot be bound (see <bpt id=\"p1\">[</bpt>Bind<ept id=\"p1\">](#casyncsocket__bind)</ept>) to a local address which is already in use.","pos":[81389,81503],"source":"By default, a socket cannot be bound (see [Bind](#casyncsocket__bind)) to a local address which is already in use."},{"content":"On occasion, however, it may be desirable to \"reuse\" an address in this way.","pos":[81504,81580]},{"content":"Since every connection is uniquely identified by the combination of local and remote addresses, there is no problem with having two sockets bound to the same local address as long as the remote addresses are different.","pos":[81581,81799]},{"content":"To inform the Windows Sockets implementation that a <bpt id=\"p1\">**</bpt>Bind<ept id=\"p1\">**</ept> call on a socket should not be disallowed because the desired address is already in use by another socket, the application should set the <bpt id=\"p2\">**</bpt>SO_REUSEADDR<ept id=\"p2\">**</ept> socket option for the socket before issuing the <bpt id=\"p3\">**</bpt>Bind<ept id=\"p3\">**</ept> call.","pos":[81806,82084],"source":"To inform the Windows Sockets implementation that a **Bind** call on a socket should not be disallowed because the desired address is already in use by another socket, the application should set the **SO_REUSEADDR** socket option for the socket before issuing the **Bind** call."},{"content":"Note that the option is interpreted only at the time of the <bpt id=\"p1\">**</bpt>Bind<ept id=\"p1\">**</ept> call: it is therefore unnecessary (but harmless) to set the option on a socket which is not to be bound to an existing address, and setting or resetting the option after the <bpt id=\"p2\">**</bpt>Bind<ept id=\"p2\">**</ept> call has no effect on this or any other socket.","pos":[82085,82384],"source":" Note that the option is interpreted only at the time of the **Bind** call: it is therefore unnecessary (but harmless) to set the option on a socket which is not to be bound to an existing address, and setting or resetting the option after the **Bind** call has no effect on this or any other socket."},{"content":"An application can request that the Windows Sockets implementation enable the use of \"keep-alive\" packets on Transmission Control Protocol (TCP) connections by turning on the <bpt id=\"p1\">**</bpt>SO_KEEPALIVE<ept id=\"p1\">**</ept> socket option.","pos":[82391,82597],"source":"An application can request that the Windows Sockets implementation enable the use of \"keep-alive\" packets on Transmission Control Protocol (TCP) connections by turning on the **SO_KEEPALIVE** socket option."},{"content":"A Windows Sockets implementation need not support the use of keep-alives: if it does, the precise semantics are implementation-specific but should conform to section 4.2.3.6 of RFC 1122: \"Requirements for Internet Hosts â€” Communication Layers.\"","pos":[82598,82842]},{"content":"If a connection is dropped as the result of \"keep-alives\" the error code <bpt id=\"p1\">**</bpt>WSAENETRESET<ept id=\"p1\">**</ept> is returned to any calls in progress on the socket, and any subsequent calls will fail with <bpt id=\"p2\">**</bpt>WSAENOTCONN<ept id=\"p2\">**</ept>.","pos":[82843,83041],"source":" If a connection is dropped as the result of \"keep-alives\" the error code **WSAENETRESET** is returned to any calls in progress on the socket, and any subsequent calls will fail with **WSAENOTCONN**."},{"content":"The <bpt id=\"p1\">**</bpt>TCP_NODELAY<ept id=\"p1\">**</ept> option disables the Nagle algorithm.","pos":[83048,83104],"source":"The **TCP_NODELAY** option disables the Nagle algorithm."},{"content":"The Nagle algorithm is used to reduce the number of small packets sent by a host by buffering unacknowledged send data until a full-size packet can be sent.","pos":[83105,83261]},{"content":"However, for some applications this algorithm can impede performance, and <bpt id=\"p1\">**</bpt>TCP_NODELAY<ept id=\"p1\">**</ept> can be used to turn it off.","pos":[83262,83379],"source":" However, for some applications this algorithm can impede performance, and **TCP_NODELAY** can be used to turn it off."},{"content":"Application writers should not set <bpt id=\"p1\">**</bpt>TCP_NODELAY<ept id=\"p1\">**</ept> unless the impact of doing so is well-understood and desired, since setting <bpt id=\"p2\">**</bpt>TCP_NODELAY<ept id=\"p2\">**</ept> can have a significant negative impact on network performance.","pos":[83380,83585],"source":" Application writers should not set **TCP_NODELAY** unless the impact of doing so is well-understood and desired, since setting **TCP_NODELAY** can have a significant negative impact on network performance."},{"content":"<bpt id=\"p1\">**</bpt>TCP_NODELAY<ept id=\"p1\">**</ept> is the only supported socket option which uses level <bpt id=\"p2\">**</bpt>IPPROTO_TCP<ept id=\"p2\">**</ept>; all other options use level <bpt id=\"p3\">**</bpt>SOL_SOCKET<ept id=\"p3\">**</ept>.","pos":[83586,83715],"source":"**TCP_NODELAY** is the only supported socket option which uses level **IPPROTO_TCP**; all other options use level **SOL_SOCKET**."},{"pos":[83722,83846],"content":"Some implementations of Windows Sockets supply output debug information if the <bpt id=\"p1\">**</bpt>SO_DEBUG<ept id=\"p1\">**</ept> option is set by an application.","source":"Some implementations of Windows Sockets supply output debug information if the **SO_DEBUG** option is set by an application."},{"content":"The following options are supported for <ph id=\"ph1\">`SetSockOpt`</ph>.","pos":[83853,83906],"source":"The following options are supported for `SetSockOpt`."},{"content":"The Type identifies the type of data addressed by <ph id=\"ph1\">`lpOptionValue`</ph>.","pos":[83907,83973],"source":" The Type identifies the type of data addressed by `lpOptionValue`."},{"content":"Value","pos":[83980,83985]},{"content":"Type","pos":[83986,83990]},{"content":"Meaning","pos":[83991,83998]},{"content":"SO_BROADCAST","pos":[84046,84058]},{"content":"BOOL","pos":[84063,84067]},{"content":"Allow transmission of broadcast messages on the socket.","pos":[84070,84125]},{"content":"SO_DEBUG","pos":[84132,84140]},{"content":"BOOL","pos":[84145,84149]},{"content":"Record debugging information.","pos":[84152,84181]},{"content":"SO_DONTLINGER","pos":[84188,84201]},{"content":"BOOL","pos":[84206,84210]},{"content":"Don't block <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept> waiting for unsent data to be sent.","pos":[84213,84270],"source":"Don't block **Close** waiting for unsent data to be sent."},{"content":"Setting this option is equivalent to setting <bpt id=\"p1\">**</bpt>SO_LINGER<ept id=\"p1\">**</ept> with <bpt id=\"p2\">**</bpt>l_onoff<ept id=\"p2\">**</ept> set to zero.","pos":[84271,84359],"source":" Setting this option is equivalent to setting **SO_LINGER** with **l_onoff** set to zero."},{"content":"SO_DONTROUTE","pos":[84366,84378]},{"content":"BOOL","pos":[84383,84387]},{"content":"Don't route: send directly to interface.","pos":[84390,84430]},{"content":"SO_KEEPALIVE","pos":[84437,84449]},{"content":"BOOL","pos":[84454,84458]},{"content":"Send keep-alives.","pos":[84461,84478]},{"content":"SO_LINGER","pos":[84485,84494]},{"content":"struct LINGER","pos":[84499,84512]},{"pos":[84515,84561],"content":"Linger on <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept> if unsent data is present.","source":"Linger on **Close** if unsent data is present."},{"content":"SO_OOBINLINE","pos":[84568,84580]},{"content":"BOOL","pos":[84585,84589]},{"content":"Receive out-of-band data in the normal data stream.","pos":[84592,84643]},{"content":"SO_RCVBUF","pos":[84650,84659]},{"content":"Specify buffer size for receives.","pos":[84668,84701]},{"content":"SO_REUSEADDR","pos":[84708,84720]},{"content":"BOOL","pos":[84725,84729]},{"content":"Allow the socket to be bound to an address which is already in use.","pos":[84732,84799]},{"content":"(See <bpt id=\"p1\">[</bpt>Bind<ept id=\"p1\">](#casyncsocket__bind)</ept>.)","pos":[84800,84834],"source":" (See [Bind](#casyncsocket__bind).)"},{"content":"SO_SNDBUF","pos":[84841,84850]},{"content":"Specify buffer size for sends.","pos":[84859,84889]},{"content":"TCP_NODELAY","pos":[84896,84907]},{"content":"BOOL","pos":[84912,84916]},{"content":"Disables the Nagle algorithm for send coalescing.","pos":[84919,84968]},{"pos":[84976,85056],"content":"Berkeley Software Distribution (BSD) options not supported for <ph id=\"ph1\">`SetSockOpt`</ph> are:","source":"Berkeley Software Distribution (BSD) options not supported for `SetSockOpt` are:"},{"content":"Value","pos":[85063,85068]},{"content":"Type","pos":[85069,85073]},{"content":"Meaning","pos":[85074,85081]},{"content":"SO_ACCEPTCONN","pos":[85129,85142]},{"content":"BOOL","pos":[85147,85151]},{"content":"Socket is listening","pos":[85154,85173]},{"content":"SO_ERROR","pos":[85180,85188]},{"content":"Get error status and clear.","pos":[85197,85224]},{"content":"SO_RCVLOWAT","pos":[85231,85242]},{"content":"Receive low water mark.","pos":[85251,85274]},{"content":"SO_RCVTIMEO","pos":[85281,85292]},{"content":"Receive timeout","pos":[85301,85316]},{"content":"SO_SNDLOWAT","pos":[85323,85334]},{"content":"Send low water mark.","pos":[85343,85363]},{"content":"SO_SNDTIMEO","pos":[85370,85381]},{"content":"Send timeout.","pos":[85390,85403]},{"content":"SO_TYPE","pos":[85410,85417]},{"content":"Type of the socket.","pos":[85426,85445]},{"content":"IP_OPTIONS","pos":[85452,85462]},{"content":"Set options field in IP header.","pos":[85466,85497]},{"pos":[85547,85569],"content":"CAsyncSocket::ShutDown"},{"content":"Call this member function to disable sends, receives, or both on the socket.","pos":[85573,85649]},{"content":"Parameters","pos":[85707,85717]},{"content":"A flag that describes what types of operation will no longer be allowed, using the following enumerated values:","pos":[85731,85842]},{"content":"receives = 0","pos":[85852,85864]},{"content":"sends = 1","pos":[85876,85885]},{"content":"both = 2","pos":[85897,85905]},{"content":"Return Value","pos":[85917,85929]},{"content":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](#casyncsocket__getlasterror)</ept>.","pos":[85933,86083],"source":"Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror)."},{"content":"The following errors apply to this member function:","pos":[86084,86135]},{"pos":[86143,86304],"content":"<bpt id=\"p1\">**</bpt>WSANOTINITIALISED<ept id=\"p1\">**</ept> A successful <bpt id=\"p2\">[</bpt>AfxSocketInit<ept id=\"p2\">](../../mfc/reference/application-information-and-management.md#afxsocketinit)</ept> must occur before using this API.","source":"**WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API."},{"pos":[86312,86406],"content":"<bpt id=\"p1\">**</bpt>WSAENETDOWN<ept id=\"p1\">**</ept> The Windows Sockets implementation detected that the network subsystem failed.","source":"**WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed."},{"pos":[86414,86448],"content":"<bpt id=\"p1\">**</bpt>WSAEINVAL<ept id=\"p1\">**</ept> <ph id=\"ph1\">`nHow`</ph> is not valid.","source":"**WSAEINVAL** `nHow` is not valid."},{"pos":[86456,86527],"content":"<bpt id=\"p1\">**</bpt>WSAEINPROGRESS<ept id=\"p1\">**</ept> A blocking Windows Sockets operation is in progress.","source":"**WSAEINPROGRESS** A blocking Windows Sockets operation is in progress."},{"pos":[86535,86603],"content":"<bpt id=\"p1\">**</bpt>WSAENOTCONN<ept id=\"p1\">**</ept> The socket is not connected ( <bpt id=\"p2\">**</bpt>SOCK_STREAM<ept id=\"p2\">**</ept> only).","source":"**WSAENOTCONN** The socket is not connected ( **SOCK_STREAM** only)."},{"pos":[86611,86658],"content":"<bpt id=\"p1\">**</bpt>WSAENOTSOCK<ept id=\"p1\">**</ept> The descriptor is not a socket.","source":"**WSAENOTSOCK** The descriptor is not a socket."},{"content":"Remarks","pos":[86668,86675]},{"content":"is used on all types of sockets to disable reception, transmission, or both.","pos":[86690,86766]},{"content":"If <ph id=\"ph1\">`nHow`</ph> is 0, subsequent receives on the socket will be disallowed.","pos":[86767,86836],"source":" If `nHow` is 0, subsequent receives on the socket will be disallowed."},{"content":"This has no effect on the lower protocol layers.","pos":[86837,86885]},{"content":"For Transmission Control Protocol (TCP), the TCP window is not changed and incoming data will be accepted (but not acknowledged) until the window is exhausted.","pos":[86892,87051]},{"content":"For User Datagram Protocol (UDP), incoming datagrams are accepted and queued.","pos":[87052,87129]},{"content":"In no case will an ICMP error packet be generated.","pos":[87130,87180]},{"content":"If <ph id=\"ph1\">`nHow`</ph> is 1, subsequent sends are disallowed.","pos":[87181,87229],"source":" If `nHow` is 1, subsequent sends are disallowed."},{"content":"For TCP sockets, a FIN will be sent.","pos":[87230,87266]},{"content":"Setting <ph id=\"ph1\">`nHow`</ph> to 2 disables both sends and receives as described above.","pos":[87267,87339],"source":" Setting `nHow` to 2 disables both sends and receives as described above."},{"content":"Note that <ph id=\"ph1\">`ShutDown`</ph> does not close the socket, and resources attached to the socket will not be freed until <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept> is called.","pos":[87346,87475],"source":"Note that `ShutDown` does not close the socket, and resources attached to the socket will not be freed until **Close** is called."},{"content":"An application should not rely on being able to reuse a socket after it has been shut down.","pos":[87476,87567]},{"content":"In particular, a Windows Sockets implementation is not required to support the use of <bpt id=\"p1\">**</bpt>Connect<ept id=\"p1\">**</ept> on such a socket.","pos":[87568,87683],"source":" In particular, a Windows Sockets implementation is not required to support the use of **Connect** on such a socket."},{"content":"Example","pos":[87693,87700]},{"pos":[87705,87777],"content":"See the example for <bpt id=\"p1\">[</bpt>CAsyncSocket::OnReceive<ept id=\"p1\">](#casyncsocket__onreceive)</ept>.","source":"See the example for [CAsyncSocket::OnReceive](#casyncsocket__onreceive)."},{"pos":[87824,87844],"content":"CASyncSocket::Socket"},{"content":"Allocates a socket handle.","pos":[87848,87874]},{"content":"Parameters","pos":[88098,88108]},{"content":"Specifies <ph id=\"ph1\">`SOCK_STREAM`</ph> or <ph id=\"ph2\">`SOCK_DGRAM`</ph>.","pos":[88129,88169],"source":" Specifies `SOCK_STREAM` or `SOCK_DGRAM`."},{"content":"A bitmask that specifies a combination of network events in which the application is interested.","pos":[88188,88284]},{"pos":[88301,88357],"content":": Want to receive notification of readiness for reading."},{"pos":[88375,88431],"content":": Want to receive notification of readiness for writing."},{"pos":[88447,88513],"content":": Want to receive notification of the arrival of out-of-band data."},{"pos":[88532,88587],"content":": Want to receive notification of incoming connections."},{"pos":[88607,88662],"content":": Want to receive notification of completed connection."},{"pos":[88680,88729],"content":": Want to receive notification of socket closure."},{"pos":[88736,88840],"content":"`nProtocolType`  \nProtocol to be used with the socket that is specific to the indicated address family.","leadings":[""," "],"nodes":[{"content":"Protocol to be used with the socket that is specific to the indicated address family.","pos":[18,103]}]},{"pos":[88847,88896],"content":"`nAddressFormat`  \nAddress family specification.","leadings":[""," "],"nodes":[{"content":"Address family specification.","pos":[19,48]}]},{"content":"Return Value","pos":[88906,88918]},{"pos":[88922,88968],"content":"Returns <ph id=\"ph1\">`TRUE`</ph> on success, <ph id=\"ph2\">`FALSE`</ph> on failure.","source":"Returns `TRUE` on success, `FALSE` on failure."},{"content":"Remarks","pos":[88978,88985]},{"content":"This method allocates a socket handle.","pos":[88989,89027]},{"content":"It does not call <bpt id=\"p1\">[</bpt>CAsyncSocket::Bind<ept id=\"p1\">](#casyncsocket__bind)</ept> to bind the socket to a specified address, so you need to call <ph id=\"ph1\">`Bind`</ph> later to bind the socket to a specified address.","pos":[89028,89205],"source":" It does not call [CAsyncSocket::Bind](#casyncsocket__bind) to bind the socket to a specified address, so you need to call `Bind` later to bind the socket to a specified address."},{"content":"You can use <bpt id=\"p1\">[</bpt>CAsyncSocket::SetSockOpt<ept id=\"p1\">](#casyncsocket__setsockopt)</ept> to set the socket option before it is bound.","pos":[89206,89316],"source":" You can use [CAsyncSocket::SetSockOpt](#casyncsocket__setsockopt) to set the socket option before it is bound."},{"content":"See Also","pos":[89325,89333]},{"content":"CObject Class","pos":[89338,89351]},{"content":"Hierarchy Chart","pos":[89396,89411]},{"content":"CSocket Class","pos":[89448,89461]},{"content":"CSocketFile Class","pos":[89506,89523]}],"content":"---\ntitle: \"CAsyncSocket Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CAsyncSocket\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"network communications\"\n  - \"asynchronous Windows Sockets\"\n  - \"CAsyncSocket class\"\n  - \"Windows Sockets [C++], asynchronous\"\n  - \"communications [C++], network\"\n  - \"sockets [C++], Windows\"\nms.assetid: cca4d5a1-aa0f-48bd-843e-ef0e2d7fc00b\ncaps.latest.revision: 23\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CAsyncSocket Class\nRepresents a Windows Socket â€” an endpoint of network communication.  \n  \n## Syntax  \n  \n```  \nclass CAsyncSocket : public CObject  \n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CAsyncSocket::CAsyncSocket](#casyncsocket__casyncsocket)|Constructs a `CAsyncSocket` object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CAsyncSocket::Accept](#casyncsocket__accept)|Accepts a connection on the socket.|  \n|[CAsyncSocket::AsyncSelect](#casyncsocket__asyncselect)|Requests event notification for the socket.|  \n|[CAsyncSocket::Attach](#casyncsocket__attach)|Attaches a socket handle to a `CAsyncSocket` object.|  \n|[CAsyncSocket::Bind](#casyncsocket__bind)|Associates a local address with the socket.|  \n|[CAsyncSocket::Close](#casyncsocket__close)|Closes the socket.|  \n|[CAsyncSocket::Connect](#casyncsocket__connect)|Establishes a connection to a peer socket.|  \n|[CAsyncSocket::Create](#casyncsocket__create)|Creates a socket.|  \n|[CAsyncSocket::Detach](#casyncsocket__detach)|Detaches a socket handle from a `CAsyncSocket` object.|  \n|[CAsyncSocket::FromHandle](#casyncsocket__fromhandle)|Returns a pointer to a `CAsyncSocket` object, given a socket handle.|  \n|[CAsyncSocket::GetLastError](#casyncsocket__getlasterror)|Gets the error status for the last operation that failed.|  \n|[CAsyncSocket::GetPeerName](#casyncsocket__getpeername)|Gets the address of the peer socket to which the socket is connected.|  \n|[CAsyncSocket::GetPeerNameEx](#casyncsocket__getpeernameex)|Gets the address of the peer socket to which the socket is connected (handles IPv6 addresses).|  \n|[CAsyncSocket::GetSockName](#casyncsocket__getsockname)|Gets the local name for a socket.|  \n|[CAsyncSocket::GetSockNameEx](#casyncsocket__getsocknameex)|Gets the local name for a socket (handles IPv6 addresses).|  \n|[CAsyncSocket::GetSockOpt](#casyncsocket__getsockopt)|Retrieves a socket option.|  \n|[CAsyncSocket::IOCtl](#casyncsocket__ioctl)|Controls the mode of the socket.|  \n|[CAsyncSocket::Listen](#casyncsocket__listen)|Establishes a socket to listen for incoming connection requests.|  \n|[CAsyncSocket::Receive](#casyncsocket__receive)|Receives data from the socket.|  \n|[CAsyncSocket::ReceiveFrom](#casyncsocket__receivefrom)|Receives a datagram and stores the source address.|  \n|[CAsyncSocket::ReceiveFromEx](#casyncsocket__receivefromex)|Receives a datagram and stores the source address (handles IPv6 addresses).|  \n|[CAsyncSocket::Send](#casyncsocket__send)|Sends data to a connected socket.|  \n|[CAsyncSocket::SendTo](#casyncsocket__sendto)|Sends data to a specific destination.|  \n|[CAsyncSocket::SendToEx](#casyncsocket__sendtoex)|Sends data to a specific destination (handles IPv6 addresses).|  \n|[CAsyncSocket::SetSockOpt](#casyncsocket__setsockopt)|Sets a socket option.|  \n|[CAsyncSocket::ShutDown](#casyncsocket__shutdown)|Disables **Send** and/or **Receive** calls on the socket.|  \n|[CASyncSocket::Socket](#casyncsocket__socket)|Allocates a socket handle.|  \n  \n### Protected Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CAsyncSocket::OnAccept](#casyncsocket__onaccept)|Notifies a listening socket that it can accept pending connection requests by calling **Accept**.|  \n|[CAsyncSocket::OnClose](#casyncsocket__onclose)|Notifies a socket that the socket connected to it has closed.|  \n|[CAsyncSocket::OnConnect](#casyncsocket__onconnect)|Notifies a connecting socket that the connection attempt is complete, whether successfully or in error.|  \n|[CAsyncSocket::OnOutOfBandData](#casyncsocket__onoutofbanddata)|Notifies a receiving socket that there is out-of-band data to be read on the socket, usually an urgent message.|  \n|[CAsyncSocket::OnReceive](#casyncsocket__onreceive)|Notifies a listening socket that there is data to be retrieved by calling **Receive**.|  \n|[CAsyncSocket::OnSend](#casyncsocket__onsend)|Notifies a socket that it can send data by calling **Send**.|  \n  \n### Public Operators  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CAsyncSocket::operator =](#casyncsocket__operator__eq)|Assigns a new value to a `CAsyncSocket` object.|  \n|[CAsyncSocket::operator SOCKET](#casyncsocket__operator_socket)|Use this operator to retrieve the **SOCKET** handle of the `CAsyncSocket` object.|  \n  \n### Public Data Members  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CAsyncSocket::m_hSocket](#casyncsocket__m_hsocket)|Indicates the **SOCKET** handle attached to this `CAsyncSocket` object.|  \n  \n## Remarks  \n Class `CAsyncSocket` encapsulates the Windows Socket Functions API, providing an object-oriented abstraction for programmers who want to use Windows Sockets in conjunction with MFC.  \n  \n This class is based on the assumption that you understand network communications. You are responsible for handling blocking, byte-order differences, and conversions between Unicode and multibyte character set (MBCS) strings. If you want a more convenient interface that manages these issues for you, see class [CSocket](../../mfc/reference/csocket-class.md).  \n  \n To use a `CAsyncSocket` object, call its constructor, then call the [Create](#casyncsocket__create) function to create the underlying socket handle (type `SOCKET`), except on accepted sockets. For a server socket call the [Listen](#casyncsocket__listen) member function, and for a client socket call the [Connect](#casyncsocket__connect) member function. The server socket should call the [Accept](#casyncsocket__accept) function upon receiving a connection request. Use the remaining `CAsyncSocket` functions to carry out communications between sockets. Upon completion, destroy the `CAsyncSocket` object if it was created on the heap; the destructor automatically calls the [Close](#casyncsocket__close) function. The `SOCKET` data type is described in the article [Windows Sockets: Background](../../mfc/windows-sockets-background.md).  \n  \n> [!NOTE]\n>  When using MFC sockets in secondary threads in a statically linked MFC application, you must call `AfxSocketInit` in each thread that uses sockets to initialize the socket libraries. By default, `AfxSocketInit` is called only in the primary thread.  \n  \n For more information, see [Windows Sockets: Using Class CAsyncSocket](../../mfc/windows-sockets-using-class-casyncsocket.md) and related articles., as well as [Windows Sockets 2 API](http://msdn.microsoft.com/library/windows/desktop/ms740673).  \n  \n## Inheritance Hierarchy  \n [CObject](../../mfc/reference/cobject-class.md)  \n  \n `CAsyncSocket`  \n  \n## Requirements  \n **Header:** afxsock.h  \n  \n##  <a name=\"casyncsocket__accept\"></a>  CAsyncSocket::Accept  \n Call this member function to accept a connection on a socket.  \n  \n```  \nvirtual BOOL Accept(\n    CAsyncSocket& rConnectedSocket,  \n    SOCKADDR* lpSockAddr = NULL,  \n    int* lpSockAddrLen = NULL);\n```  \n  \n### Parameters  \n `rConnectedSocket`  \n A reference identifying a new socket that is available for connection.  \n  \n `lpSockAddr`  \n A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that receives the address of the connecting socket, as known on the network. The exact format of the `lpSockAddr` argument is determined by the address family established when the socket was created. If `lpSockAddr` and/or `lpSockAddrLen` are equal to **NULL**, then no information about the remote address of the accepted socket is returned.  \n  \n `lpSockAddrLen`  \n A pointer to the length of the address in `lpSockAddr` in bytes. The `lpSockAddrLen` is a value-result parameter: it should initially contain the amount of space pointed to by `lpSockAddr`; on return it will contain the actual length (in bytes) of the address returned.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEFAULT** The `lpSockAddrLen` argument is too small (less than the size of a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure).  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets call is in progress.  \n  \n- **WSAEINVAL** `Listen` was not invoked prior to accept.  \n  \n- **WSAEMFILE** The queue is empty upon entry to accept and there are no descriptors available.  \n  \n- `WSAENOBUFS` No buffer space is available.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n- **WSAEOPNOTSUPP** The referenced socket is not a type that supports connection-oriented service.  \n  \n- **WSAEWOULDBLOCK** The socket is marked as nonblocking and no connections are present to be accepted.  \n  \n### Remarks  \n This routine extracts the first connection in the queue of pending connections, creates a new socket with the same properties as this socket, and attaches it to `rConnectedSocket`. If no pending connections are present on the queue, **Accept** returns zero and `GetLastError` returns an error. The accepted socket ( *rConnectedSocket)* cannot be used to accept more connections. The original socket remains open and listening.  \n  \n The argument `lpSockAddr` is a result parameter that is filled in with the address of the connecting socket, as known to the communications layer. **Accept** is used with connection-based socket types such as **SOCK_STREAM**.  \n  \n##  <a name=\"casyncsocket__asyncselect\"></a>  CAsyncSocket::AsyncSelect  \n Call this member function to request event notification for a socket.  \n  \n```  \nBOOL AsyncSelect(long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);\n```  \n  \n### Parameters  \n `lEvent`  \n A bitmask which specifies a combination of network events in which the application is interested.  \n  \n- **FD_READ** Want to receive notification of readiness for reading.  \n  \n- **FD_WRITE** Want to receive notification when data is available to be read.  \n  \n- **FD_OOB** Want to receive notification of the arrival of out-of-band data.  \n  \n- **FD_ACCEPT** Want to receive notification of incoming connections.  \n  \n- **FD_CONNECT** Want to receive notification of connection results.  \n  \n- **FD_CLOSE** Want to receive notification when a socket has been closed by a peer.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEINVAL** Indicates that one of the specified parameters was invalid.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n### Remarks  \n This function is used to specify which MFC callback notification functions will be called for the socket. `AsyncSelect` automatically sets this socket to nonblocking mode. For more information, see the article [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md).  \n  \n##  <a name=\"casyncsocket__attach\"></a>  CAsyncSocket::Attach  \n Call this member function to attach the `hSocket` handle to an `CAsyncSocket` object.  \n  \n```  \nBOOL Attach(\n    SOCKET hSocket, long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);\n```  \n  \n### Parameters  \n `hSocket`  \n Contains a handle to a socket.  \n  \n `lEvent`  \n A bitmask which specifies a combination of network events in which the application is interested.  \n  \n- **FD_READ** Want to receive notification of readiness for reading.  \n  \n- **FD_WRITE** Want to receive notification when data is available to be read.  \n  \n- **FD_OOB** Want to receive notification of the arrival of out-of-band data.  \n  \n- **FD_ACCEPT** Want to receive notification of incoming connections.  \n  \n- **FD_CONNECT** Want to receive notification of connection results.  \n  \n- **FD_CLOSE** Want to receive notification when a socket has been closed by a peer.  \n  \n### Return Value  \n Nonzero if the function is successful.  \n  \n### Remarks  \n The **SOCKET** handle is stored in the object's [m_hSocket](#casyncsocket__m_hsocket) data member.  \n  \n##  <a name=\"casyncsocket__bind\"></a>  CAsyncSocket::Bind  \n Call this member function to associate a local address with the socket.  \n  \n```  \nBOOL Bind(\n    UINT nSocketPort,  \n    LPCTSTR lpszSocketAddress = NULL);\n\n \nBOOL Bind (\n    const SOCKADDR* lpSockAddr,  \n    int nSockAddrLen);\n```  \n  \n### Parameters  \n `nSocketPort`  \n The port identifying the socket application.  \n  \n `lpszSocketAddress`  \n The network address, a dotted number such as \"128.56.22.8\". Passing the **NULL** string for this parameter indicates the **CAsyncSocket** instance should listen for client activity on all network interfaces.  \n  \n `lpSockAddr`  \n A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that contains the address to assign to this socket.  \n  \n `nSockAddrLen`  \n The length of the address in `lpSockAddr` in bytes.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEADDRINUSE** The specified address is already in use. (See the **SO_REUSEADDR** socket option under [SetSockOpt](#casyncsocket__setsockopt).)  \n  \n- **WSAEFAULT** The `nSockAddrLen` argument is too small (less than the size of a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure).  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets call is in progress.  \n  \n- **WSAEAFNOSUPPORT** The specified address family is not supported by this port.  \n  \n- **WSAEINVAL** The socket is already bound to an address.  \n  \n- `WSAENOBUFS` Not enough buffers available, too many connections.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n### Remarks  \n This routine is used on an unconnected datagram or stream socket, before subsequent **Connect** or `Listen` calls. Before it can accept connection requests, a listening server socket must select a port number and make it known to Windows Sockets by calling **Bind**. **Bind** establishes the local association (host address/port number) of the socket by assigning a local name to an unnamed socket.  \n  \n##  <a name=\"casyncsocket__casyncsocket\"></a>  CAsyncSocket::CAsyncSocket  \n Constructs a blank socket object.  \n  \n```  \nCAsyncSocket();\n```  \n  \n### Remarks  \n After constructing the object, you must call its **Create** member function to create the **SOCKET** data structure and bind its address. (On the server side of a Windows Sockets communication, when the listening socket creates a socket to use in the **Accept** call, you do not call **Create** for that socket.)  \n  \n##  <a name=\"casyncsocket__close\"></a>  CAsyncSocket::Close  \n Closes the socket.  \n  \n```  \nvirtual void Close();\n```  \n  \n### Remarks  \n This function releases the socket descriptor so that further references to it will fail with the error **WSAENOTSOCK**. If this is the last reference to the underlying socket, the associated naming information and queued data are discarded. The socket object's destructor calls **Close** for you.  \n  \n For `CAsyncSocket`, but not for `CSocket`, the semantics of **Close** are affected by the socket options **SO_LINGER** and **SO_DONTLINGER**. For further information, see member function `GetSockOpt`.  \n  \n##  <a name=\"casyncsocket__connect\"></a>  CAsyncSocket::Connect  \n Call this member function to establish a connection to an unconnected stream or datagram socket.  \n  \n```  \nBOOL Connect(\n    LPCTSTR lpszHostAddress,  \n    UINT nHostPort);\n\n \nBOOL Connect(\n    const SOCKADDR* lpSockAddr,  \n    int nSockAddrLen);\n```  \n  \n### Parameters  \n `lpszHostAddress`  \n The network address of the socket to which this object is connected: a machine name such as \"ftp.microsoft.com\", or a dotted number such as \"128.56.22.8\".  \n  \n `nHostPort`  \n The port identifying the socket application.  \n  \n `lpSockAddr`  \n A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that contains the address of the connected socket.  \n  \n `nSockAddrLen`  \n The length of the address in `lpSockAddr` in bytes.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). If this indicates an error code of **WSAEWOULDBLOCK**, and your application is using the overridable callbacks, your application will receive an `OnConnect` message when the connect operation is complete. The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEADDRINUSE** The specified address is already in use.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets call is in progress.  \n  \n- **WSAEADDRNOTAVAIL** The specified address is not available from the local machine.  \n  \n- **WSAEAFNOSUPPORT** Addresses in the specified family cannot be used with this socket.  \n  \n- **WSAECONNREFUSED** The attempt to connect was rejected.  \n  \n- **WSAEDESTADDRREQ** A destination address is required.  \n  \n- **WSAEFAULT** The `nSockAddrLen` argument is incorrect.  \n  \n- **WSAEINVAL** Invalid host address.  \n  \n- **WSAEISCONN** The socket is already connected.  \n  \n- **WSAEMFILE** No more file descriptors are available.  \n  \n- **WSAENETUNREACH** The network cannot be reached from this host at this time.  \n  \n- `WSAENOBUFS` No buffer space is available. The socket cannot be connected.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n- **WSAETIMEDOUT** Attempt to connect timed out without establishing a connection.  \n  \n- **WSAEWOULDBLOCK** The socket is marked as nonblocking and the connection cannot be completed immediately.  \n  \n### Remarks  \n If the socket is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound. Note that if the address field of the name structure is all zeroes, **Connect** will return zero. To get extended error information, call the `GetLastError` member function.  \n  \n For stream sockets (type **SOCK_STREAM**), an active connection is initiated to the foreign host. When the socket call completes successfully, the socket is ready to send/receive data.  \n  \n For a datagram socket (type **SOCK_DGRAM**), a default destination is set, which will be used on subsequent **Send** and **Receive** calls.  \n  \n##  <a name=\"casyncsocket__create\"></a>  CAsyncSocket::Create  \n Call the **Create** member function after constructing a socket object to create the Windows socket and attach it.  \n  \n```  \nBOOL Create(\n    UINT nSocketPort = 0,  \n    int nSocketType = SOCK_STREAM,  \n    long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,  \n    LPCTSTR lpszSocketAddress = NULL);\n```  \n  \n### Parameters  \n `nSocketPort`  \n A well-known port to be used with the socket, or 0 if you want Windows Sockets to select a port.  \n  \n `nSocketType`  \n **SOCK_STREAM** or **SOCK_DGRAM**.  \n  \n `lEvent`  \n A bitmask which specifies a combination of network events in which the application is interested.  \n  \n- **FD_READ** Want to receive notification of readiness for reading.  \n  \n- **FD_WRITE** Want to receive notification of readiness for writing.  \n  \n- **FD_OOB** Want to receive notification of the arrival of out-of-band data.  \n  \n- **FD_ACCEPT** Want to receive notification of incoming connections.  \n  \n- **FD_CONNECT** Want to receive notification of completed connection.  \n  \n- **FD_CLOSE** Want to receive notification of socket closure.  \n  \n *lpszSockAddress*  \n A pointer to a string containing the network address of the connected socket, a dotted number such as \"128.56.22.8\".Passing the **NULL** string for this parameter indicates the **CAsyncSocket** instance should listen for client activity on all network interfaces.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEAFNOSUPPORT** The specified address family is not supported.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAEMFILE** No more file descriptors are available.  \n  \n- `WSAENOBUFS` No buffer space is available. The socket cannot be created.  \n  \n- **WSAEPROTONOSUPPORT** The specified port is not supported.  \n  \n- **WSAEPROTOTYPE** The specified port is the wrong type for this socket.  \n  \n- **WSAESOCKTNOSUPPORT** The specified socket type is not supported in this address family.  \n  \n### Remarks  \n **Create** calls [Socket](#casyncsocket__socket) and if successful, it calls [Bind](#casyncsocket__bind) to bind the socket to the specified address. The following socket types are supported:  \n  \n- **SOCK_STREAM** Provides sequenced, reliable, full-duplex, connection-based byte streams. Uses the Transmission Control Protocol (TCP) for the Internet address family.  \n  \n- **SOCK_DGRAM** Supports datagrams, which are connectionless, unreliable packets of a fixed (typically small) maximum length. Uses the User Datagram Protocol (UDP) for the Internet address family.  \n  \n    > [!NOTE]\n    >  The **Accept** member function takes a reference to a new, empty `CSocket` object as its parameter. You must construct this object before you call **Accept**. Keep in mind that if this socket object goes out of scope, the connection closes. Do not call **Create** for this new socket object.  \n  \n> [!IMPORTANT]\n> **Create** is **not** thread-safe.  If you are calling it in a multi-threaded environment where it could be invoked simultaneously by different threads, be sure to protect each call with a mutex or other synchronization lock.  \n  \n For more information about stream and datagram sockets, see the articles [Windows Sockets: Background](../../mfc/windows-sockets-background.md) and [Windows Sockets: Ports and Socket Addresses](../../mfc/windows-sockets-ports-and-socket-addresses.md) and [Windows Sockets 2 API](http://msdn.microsoft.com/library/windows/desktop/ms740673).  \n  \n##  <a name=\"casyncsocket__detach\"></a>  CAsyncSocket::Detach  \n Call this member function to detach the **SOCKET** handle in the `m_hSocket` data member from the `CAsyncSocket` object and set `m_hSocket` to **NULL**.  \n  \n```  \nSOCKET Detach();\n```  \n  \n##  <a name=\"casyncsocket__fromhandle\"></a>  CAsyncSocket::FromHandle  \n Returns a pointer to a `CAsyncSocket` object.  \n  \n```  \nstatic CAsyncSocket* PASCAL FromHandle(SOCKET hSocket);\n```  \n  \n### Parameters  \n `hSocket`  \n Contains a handle to a socket.  \n  \n### Return Value  \n A pointer to an `CAsyncSocket` object, or **NULL** if there is no `CAsyncSocket` object attached to `hSocket`.  \n  \n### Remarks  \n When given a **SOCKET** handle, if a `CAsyncSocket` object is not attached to the handle, the member function returns **NULL**.  \n  \n##  <a name=\"casyncsocket__getlasterror\"></a>  CAsyncSocket::GetLastError  \n Call this member function to get the error status for the last operation that failed.  \n  \n```  \nstatic int PASCAL GetLastError();\n```  \n  \n### Return Value  \n The return value indicates the error code for the last Windows Sockets API routine performed by this thread.  \n  \n### Remarks  \n When a particular member function indicates that an error has occurred, `GetLastError` should be called to retrieve the appropriate error code. See the individual member function descriptions for a list of applicable error codes.  \n  \n For more information about the error codes, see [Windows Sockets 2 API](http://msdn.microsoft.com/library/windows/desktop/ms740673).  \n  \n##  <a name=\"casyncsocket__getpeername\"></a>  CAsyncSocket::GetPeerName  \n Call this member function to get the address of the peer socket to which this socket is connected.  \n  \n```  \nBOOL GetPeerName(\n    CString& rPeerAddress,  \n    UINT& rPeerPort);\n\n \nBOOL GetPeerName(\n    SOCKADDR* lpSockAddr,  \n    int* lpSockAddrLen);\n```  \n  \n### Parameters  \n `rPeerAddress`  \n Reference to a `CString` object that receives a dotted number IP address.  \n  \n `rPeerPort`  \n Reference to a **UINT** that stores a port.  \n  \n `lpSockAddr`  \n A pointer to the [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that receives the name of the peer socket.  \n  \n `lpSockAddrLen`  \n A pointer to the length of the address in `lpSockAddr` in bytes. On return, the `lpSockAddrLen` argument contains the actual size of `lpSockAddr` returned in bytes.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEFAULT** The `lpSockAddrLen` argument is not large enough.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets call is in progress.  \n  \n- **WSAENOTCONN** The socket is not connected.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n### Remarks  \n To handle IPv6 addresses, use [CAsyncSocket::GetPeerNameEx](#casyncsocket__getpeernameex).  \n  \n##  <a name=\"casyncsocket__getpeernameex\"></a>  CAsyncSocket::GetPeerNameEx  \n Call this member function to get the address of the peer socket to which this socket is connected (handles IPv6 addresses).  \n  \n```  \nBOOL GetPeerNameEx(\n    CString& rPeerAddress,  \n    UINT& rPeerPort);\n```  \n  \n### Parameters  \n `rPeerAddress`  \n Reference to a `CString` object that receives a dotted number IP address.  \n  \n `rPeerPort`  \n Reference to a **UINT** that stores a port.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEFAULT** The `lpSockAddrLen` argument is not large enough.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets call is in progress.  \n  \n- **WSAENOTCONN** The socket is not connected.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n### Remarks  \n This function is the same as [CAsyncSocket::GetPeerName](#casyncsocket__getpeername) except that it handles IPv6 addresses as well as older protocols.  \n  \n##  <a name=\"casyncsocket__getsockname\"></a>  CAsyncSocket::GetSockName  \n Call this member function to get the local name for a socket.  \n  \n```  \nBOOL GetSockName(\n    CString& rSocketAddress,  \n    UINT& rSocketPort);\n\n \nBOOL GetSockName(\n    SOCKADDR* lpSockAddr,  \n    int* lpSockAddrLen);\n```  \n  \n### Parameters  \n `rSocketAddress`  \n Reference to a `CString` object that receives a dotted number IP address.  \n  \n `rSocketPort`  \n Reference to a **UINT** that stores a port.  \n  \n `lpSockAddr`  \n A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that receives the address of the socket.  \n  \n `lpSockAddrLen`  \n A pointer to the length of the address in `lpSockAddr` in bytes.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEFAULT** The `lpSockAddrLen` argument is not large enough.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n- **WSAEINVAL** The socket has not been bound to an address with **Bind**.  \n  \n### Remarks  \n This call is especially useful when a **Connect** call has been made without doing a **Bind** first; this call provides the only means by which you can determine the local association which has been set by the system.  \n  \n To handle IPv6 addresses, use [CAsyncSocket::GetSockNameEx](#casyncsocket__getsocknameex)  \n  \n##  <a name=\"casyncsocket__getsocknameex\"></a>  CAsyncSocket::GetSockNameEx  \n Call this member function to get the local name for a socket (handles IPv6 addresses).  \n  \n```  \nBOOL GetSockNameEx(\n    CString& rSocketAddress,  \n    UINT& rSocketPort);\n```  \n  \n### Parameters  \n `rSocketAddress`  \n Reference to a `CString` object that receives a dotted number IP address.  \n  \n `rSocketPort`  \n Reference to a **UINT** that stores a port.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEFAULT** The `lpSockAddrLen` argument is not large enough.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n- **WSAEINVAL** The socket has not been bound to an address with **Bind**.  \n  \n### Remarks  \n This call is the same as [CAsyncSocket::GetSockName](#casyncsocket__getsockname) except that it handles IPv6 addresses as well as older protocols.  \n  \n This call is especially useful when a **Connect** call has been made without doing a **Bind** first; this call provides the only means by which you can determine the local association which has been set by the system.  \n  \n##  <a name=\"casyncsocket__getsockopt\"></a>  CAsyncSocket::GetSockOpt  \n Call this member function to retrieve a socket option.  \n  \n```  \nBOOL GetSockOpt(\n    int nOptionName,  \n    void* lpOptionValue,  \n    int* lpOptionLen,  \n    int nLevel = SOL_SOCKET);\n```  \n  \n### Parameters  \n `nOptionName`  \n The socket option for which the value is to be retrieved.  \n  \n `lpOptionValue`  \n A pointer to the buffer in which the value for the requested option is to be returned. The value associated with the selected option is returned in the buffer `lpOptionValue`. The integer pointed to by `lpOptionLen` should originally contain the size of this buffer in bytes; and on return, it will be set to the size of the value returned. For **SO_LINGER**, this will be the size of a `LINGER` structure; for all other options it will be the size of a **BOOL** or an `int`, depending on the option. See the list of options and their sizes in the Remarks section.  \n  \n `lpOptionLen`  \n A pointer to the size of the `lpOptionValue` buffer in bytes.  \n  \n `nLevel`  \n The level at which the option is defined; the only supported levels are **SOL_SOCKET** and **IPPROTO_TCP**.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). If an option was never set with `SetSockOpt`, then `GetSockOpt` returns the default value for the option. The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEFAULT** The `lpOptionLen` argument was invalid.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAENOPROTOOPT** The option is unknown or unsupported. In particular, **SO_BROADCAST** is not supported on sockets of type **SOCK_STREAM**, while **SO_ACCEPTCONN**, **SO_DONTLINGER**, **SO_KEEPALIVE**, **SO_LINGER**, and **SO_OOBINLINE** are not supported on sockets of type **SOCK_DGRAM**.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n### Remarks  \n `GetSockOpt` retrieves the current value for a socket option associated with a socket of any type, in any state, and stores the result in `lpOptionValue`. Options affect socket operations, such as the routing of packets, out-of-band data transfer, and so on.  \n  \n The following options are supported for `GetSockOpt`. The Type identifies the type of data addressed by `lpOptionValue`. The **TCP_NODELAY** option uses level **IPPROTO_TCP**; all other options use level **SOL_SOCKET**.  \n  \n|Value|Type|Meaning|  \n|-----------|----------|-------------|  \n|**SO_ACCEPTCONN**|**BOOL**|Socket is listening.|  \n|**SO_BROADCAST**|**BOOL**|Socket is configured for the transmission of broadcast messages.|  \n|**SO_DEBUG**|**BOOL**|Debugging is enabled.|  \n|**SO_DONTLINGER**|**BOOL**|If true, the **SO_LINGER** option is disabled.|  \n|**SO_DONTROUTE**|**BOOL**|Routing is disabled.|  \n|**SO_ERROR**|`int`|Retrieve error status and clear.|  \n|**SO_KEEPALIVE**|**BOOL**|Keep-alives are being sent.|  \n|**SO_LINGER**|**struct LINGER**|Returns the current linger options.|  \n|**SO_OOBINLINE**|**BOOL**|Out-of-band data is being received in the normal data stream.|  \n|**SO_RCVBUF**|`int`|Buffer size for receives.|  \n|**SO_REUSEADDR**|**BOOL**|The socket can be bound to an address which is already in use.|  \n|**SO_SNDBUF**|`int`|Buffer size for sends.|  \n|**SO_TYPE**|`int`|The type of the socket (for example, **SOCK_STREAM**).|  \n|**TCP_NODELAY**|**BOOL**|Disables the Nagle algorithm for send coalescing.|  \n  \n Berkeley Software Distribution (BSD) options not supported for `GetSockOpt` are:  \n  \n|Value|Type|Meaning|  \n|-----------|----------|-------------|  \n|**SO_RCVLOWAT**|`int`|Receive low water mark.|  \n|**SO_RCVTIMEO**|`int`|Receive timeout.|  \n|**SO_SNDLOWAT**|`int`|Send low water mark.|  \n|**SO_SNDTIMEO**|`int`|Send timeout.|  \n|**IP_OPTIONS**||Get options in IP header.|  \n|**TCP_MAXSEG**|`int`|Get TCP maximum segment size.|  \n  \n Calling `GetSockOpt` with an unsupported option will result in an error code of **WSAENOPROTOOPT** being returned from `GetLastError`.  \n  \n##  <a name=\"casyncsocket__ioctl\"></a>  CAsyncSocket::IOCtl  \n Call this member function to control the mode of a socket.  \n  \n```  \nBOOL IOCtl(\n    long lCommand,  \n    DWORD* lpArgument);\n```  \n  \n### Parameters  \n `lCommand`  \n The command to perform on the socket.  \n  \n `lpArgument`  \n A pointer to a parameter for `lCommand`.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEINVAL** `lCommand` is not a valid command, or `lpArgument` is not an acceptable parameter for `lCommand`, or the command is not applicable to the type of socket supplied.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n### Remarks  \n This routine can be used on any socket in any state. It is used to get or retrieve operating parameters associated with the socket, independent of the protocol and communications subsystem. The following commands are supported:  \n  \n- **FIONBIO** Enable or disable nonblocking mode on the socket. The `lpArgument` parameter points at a `DWORD`, which is nonzero if nonblocking mode is to be enabled and zero if it is to be disabled. If `AsyncSelect` has been issued on a socket, then any attempt to use **IOCtl** to set the socket back to blocking mode will fail with **WSAEINVAL**. To set the socket back to blocking mode and prevent the **WSAEINVAL** error, an application must first disable `AsyncSelect` by calling `AsyncSelect` with the `lEvent` parameter equal to 0, then call **IOCtl**.  \n  \n- **FIONREAD** Determine the maximum number of bytes that can be read with one **Receive** call from this socket. The `lpArgument` parameter points at a `DWORD` in which **IOCtl** stores the result. If this socket is of type **SOCK_STREAM**, **FIONREAD** returns the total amount of data which can be read in a single **Receive**; this is normally the same as the total amount of data queued on the socket. If this socket is of type **SOCK_DGRAM**, **FIONREAD** returns the size of the first datagram queued on the socket.  \n  \n- **SIOCATMARK** Determine whether all out-of-band data has been read. This applies only to a socket of type **SOCK_STREAM** which has been configured for in-line reception of any out-of-band data ( **SO_OOBINLINE**). If no out-of-band data is waiting to be read, the operation returns nonzero. Otherwise it returns 0, and the next **Receive** or `ReceiveFrom` performed on the socket will retrieve some or all of the data preceding the \"mark\"; the application should use the **SIOCATMARK** operation to determine whether any data remains. If there is any normal data preceding the \"urgent\" (out-of-band) data, it will be received in order. (Note that a **Receive** or `ReceiveFrom` will never mix out-of-band and normal data in the same call.) The `lpArgument` parameter points at a `DWORD` in which **IOCtl** stores the result.  \n  \n This function is a subset of **ioctl()** as used in Berkeley sockets. In particular, there is no command which is equivalent to **FIOASYNC**, while **SIOCATMARK** is the only socket-level command which is supported.  \n  \n##  <a name=\"casyncsocket__listen\"></a>  CAsyncSocket::Listen  \n Call this member function to listen for incoming connection requests.  \n  \n```  \nBOOL Listen(int nConnectionBacklog = 5);\n```  \n  \n### Parameters  \n *nConnectionBacklog*  \n The maximum length to which the queue of pending connections can grow. Valid range is from 1 to 5.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEADDRINUSE** An attempt has been made to listen on an address in use.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAEINVAL** The socket has not been bound with **Bind** or is already connected.  \n  \n- **WSAEISCONN** The socket is already connected.  \n  \n- **WSAEMFILE** No more file descriptors are available.  \n  \n- `WSAENOBUFS` No buffer space is available.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n- **WSAEOPNOTSUPP** The referenced socket is not of a type that supports the `Listen` operation.  \n  \n### Remarks  \n To accept connections, the socket is first created with **Create**, a backlog for incoming connections is specified with `Listen`, and then the connections are accepted with **Accept**. `Listen` applies only to sockets that support connections, that is, those of type **SOCK_STREAM**. This socket is put into \"passive\" mode where incoming connections are acknowledged and queued pending acceptance by the process.  \n  \n This function is typically used by servers (or any application that wants to accept connections) that could have more than one connection request at a time: if a connection request arrives with the queue full, the client will receive an error with an indication of **WSAECONNREFUSED**.  \n  \n `Listen` attempts to continue to function rationally when there are no available ports (descriptors). It will accept connections until the queue is emptied. If ports become available, a later call to `Listen` or **Accept** will refill the queue to the current or most recent \"backlog,\" if possible, and resume listening for incoming connections.  \n  \n##  <a name=\"casyncsocket__m_hsocket\"></a>  CAsyncSocket::m_hSocket  \n Contains the **SOCKET** handle for the socket encapsulated by this `CAsyncSocket` object.  \n  \n```  \nSOCKET m_hSocket;  \n```  \n  \n##  <a name=\"casyncsocket__onaccept\"></a>  CAsyncSocket::OnAccept  \n Called by the framework to notify a listening socket that it can accept pending connection requests by calling the [Accept](#casyncsocket__accept) member function.  \n  \n```  \nvirtual void OnAccept(int nErrorCode);\n```  \n  \n### Parameters  \n `nErrorCode`  \n The most recent error on a socket. The following error codes applies to the `OnAccept` member function:  \n  \n- **0** The function executed successfully.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n### Remarks  \n For more information, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md).  \n  \n##  <a name=\"casyncsocket__onclose\"></a>  CAsyncSocket::OnClose  \n Called by the framework to notify this socket that the connected socket is closed by its process.  \n  \n```  \nvirtual void OnClose(int nErrorCode);\n```  \n  \n### Parameters  \n `nErrorCode`  \n The most recent error on a socket. The following error codes apply to the `OnClose` member function:  \n  \n- **0** The function executed successfully.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAECONNRESET** The connection was reset by the remote side.  \n  \n- **WSAECONNABORTED** The connection was aborted due to timeout or other failure.  \n  \n### Remarks  \n For more information, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md).  \n  \n##  <a name=\"casyncsocket__onconnect\"></a>  CAsyncSocket::OnConnect  \n Called by the framework to notify this connecting socket that its connection attempt is completed, whether successfully or in error.  \n  \n```  \nvirtual void OnConnect(int nErrorCode);\n```  \n  \n### Parameters  \n `nErrorCode`  \n The most recent error on a socket. The following error codes apply to the `OnConnect` member function:  \n  \n- **0** The function executed successfully.  \n  \n- **WSAEADDRINUSE** The specified address is already in use.  \n  \n- **WSAEADDRNOTAVAIL** The specified address is not available from the local machine.  \n  \n- **WSAEAFNOSUPPORT** Addresses in the specified family cannot be used with this socket.  \n  \n- **WSAECONNREFUSED** The attempt to connect was forcefully rejected.  \n  \n- **WSAEDESTADDRREQ** A destination address is required.  \n  \n- **WSAEFAULT** The `lpSockAddrLen` argument is incorrect.  \n  \n- **WSAEINVAL** The socket is already bound to an address.  \n  \n- **WSAEISCONN** The socket is already connected.  \n  \n- **WSAEMFILE** No more file descriptors are available.  \n  \n- **WSAENETUNREACH** The network cannot be reached from this host at this time.  \n  \n- `WSAENOBUFS` No buffer space is available. The socket cannot be connected.  \n  \n- **WSAENOTCONN** The socket is not connected.  \n  \n- **WSAENOTSOCK** The descriptor is a file, not a socket.  \n  \n- **WSAETIMEDOUT** The attempt to connect timed out without establishing a connection.  \n  \n### Remarks  \n  \n> [!NOTE]\n>  In [CSocket](../../mfc/reference/csocket-class.md), the `OnConnect` notification function is never called. For connections, you simply call **Connect**, which will return when the connection is completed (either successfully or in error). How connection notifications are handled is an MFC implementation detail.  \n  \n For more information, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md).  \n  \n### Example  \n [!code-cpp[NVC_MFCAsyncSocket#1](../../mfc/reference/codesnippet/cpp/casyncsocket-class_1.cpp)]  \n  \n##  <a name=\"casyncsocket__onoutofbanddata\"></a>  CAsyncSocket::OnOutOfBandData  \n Called by the framework to notify the receiving socket that the sending socket has out-of-band data to send.  \n  \n```  \nvirtual void OnOutOfBandData(int nErrorCode);\n```  \n  \n### Parameters  \n `nErrorCode`  \n The most recent error on a socket. The following error codes apply to the `OnOutOfBandData` member function:  \n  \n- **0** The function executed successfully.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n### Remarks  \n Out-of-band data is a logically independent channel that is associated with each pair of connected sockets of type **SOCK_STREAM**. The channel is generally used to send urgent data.  \n  \n MFC supports out-of-band data, but users of class `CAsyncSocket` are discouraged from using it. The easier way is to create a second socket for passing such data. For more information about out-of-band data, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md).  \n  \n##  <a name=\"casyncsocket__onreceive\"></a>  CAsyncSocket::OnReceive  \n Called by the framework to notify this socket that there is data in the buffer that can be retrieved by calling the **Receive** member function.  \n  \n```  \nvirtual void OnReceive(int nErrorCode);\n```  \n  \n### Parameters  \n `nErrorCode`  \n The most recent error on a socket. The following error codes apply to the `OnReceive` member function:  \n  \n- **0** The function executed successfully.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n### Remarks  \n For more information, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md).  \n  \n### Example  \n [!code-cpp[NVC_MFCAsyncSocket#2](../../mfc/reference/codesnippet/cpp/casyncsocket-class_2.cpp)]  \n  \n##  <a name=\"casyncsocket__onsend\"></a>  CAsyncSocket::OnSend  \n Called by the framework to notify the socket that it can now send data by calling the **Send** member function.  \n  \n```  \nvirtual void OnSend(int nErrorCode);\n```  \n  \n### Parameters  \n `nErrorCode`  \n The most recent error on a socket. The following error codes apply to the `OnSend` member function:  \n  \n- **0** The function executed successfully.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n### Remarks  \n For more information, see [Windows Sockets: Socket Notifications](../../mfc/windows-sockets-socket-notifications.md).  \n  \n### Example  \n [!code-cpp[NVC_MFCAsyncSocket#3](../../mfc/reference/codesnippet/cpp/casyncsocket-class_3.cpp)]  \n  \n##  <a name=\"casyncsocket__operator__eq\"></a>  CAsyncSocket::operator =  \n Assigns a new value to a `CAsyncSocket` object.  \n  \n```  \nvoid operator=(const CAsyncSocket& rSrc);\n```  \n  \n### Parameters  \n `rSrc`  \n A reference to an existing `CAsyncSocket` object.  \n  \n### Remarks  \n Call this function to copy an existing `CAsyncSocket` object to another `CAsyncSocket` object.  \n  \n##  <a name=\"casyncsocket__operator_socket\"></a>  CAsyncSocket::operator SOCKET  \n Use this operator to retrieve the **SOCKET** handle of the `CAsyncSocket` object.  \n  \n```  \noperator SOCKET() const;\n\n \n```  \n  \n### Return Value  \n If successful, the handle of the **SOCKET** object; otherwise, **NULL**.  \n  \n### Remarks  \n You can use the handle to call Windows APIs directly.  \n  \n##  <a name=\"casyncsocket__receive\"></a>  CAsyncSocket::Receive  \n Call this member function to receive data from a socket.  \n  \n```  \nvirtual int Receive(\n    void* lpBuf,  \n    int nBufLen,  \n    int nFlags = 0);\n```  \n  \n### Parameters  \n `lpBuf`  \n A buffer for the incoming data.  \n  \n `nBufLen`  \n The length of `lpBuf` in bytes.  \n  \n `nFlags`  \n Specifies the way in which the call is made. The semantics of this function are determined by the socket options and the `nFlags` parameter. The latter is constructed by combining any of the following values with the C++ `OR` operator:  \n  \n- **MSG_PEEK** Peek at the incoming data. The data is copied into the buffer but is not removed from the input queue.  \n  \n- **MSG_OOB** Process out-of-band data.  \n  \n### Return Value  \n If no error occurs, **Receive** returns the number of bytes received. If the connection has been closed, it returns 0. Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAENOTCONN** The socket is not connected.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n- **WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**.  \n  \n- **WSAESHUTDOWN** The socket has been shut down; it is not possible to call **Receive** on a socket after `ShutDown` has been invoked with `nHow` set to 0 or 2.  \n  \n- **WSAEWOULDBLOCK** The socket is marked as nonblocking and the **Receive** operation would block.  \n  \n- **WSAEMSGSIZE** The datagram was too large to fit into the specified buffer and was truncated.  \n  \n- **WSAEINVAL** The socket has not been bound with **Bind**.  \n  \n- **WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure.  \n  \n- **WSAECONNRESET** The virtual circuit was reset by the remote side.  \n  \n### Remarks  \n This function is used for connected stream or datagram sockets and is used to read incoming data.  \n  \n For sockets of type **SOCK_STREAM**, as much information as is currently available up to the size of the buffer supplied is returned. If the socket has been configured for in-line reception of out-of-band data (socket option **SO_OOBINLINE**) and out-of-band data is unread, only out-of-band data will be returned. The application can use the **IOCtlSIOCATMARK** option or [OnOutOfBandData](#casyncsocket__onoutofbanddata) to determine whether any more out-of-band data remains to be read.  \n  \n For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied. If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the datagram, the excess data is lost, and **Receive** returns a value of **SOCKET_ERROR** with the error code set to **WSAEMSGSIZE**. If no incoming data is available at the socket, a value of **SOCKET_ERROR** is returned with the error code set to **WSAEWOULDBLOCK**. The [OnReceive](#casyncsocket__onreceive) callback function can be used to determine when more data arrives.  \n  \n If the socket is of type **SOCK_STREAM** and the remote side has shut down the connection gracefully, a **Receive** will complete immediately with 0 bytes received. If the connection has been reset, a **Receive** will fail with the error **WSAECONNRESET**.  \n  \n **Receive** should be called only once for each time [CAsyncSocket::OnReceive](#casyncsocket__onreceive) is called.  \n  \n### Example  \n  See the example for [CAsyncSocket::OnReceive](#casyncsocket__onreceive).  \n  \n##  <a name=\"casyncsocket__receivefrom\"></a>  CAsyncSocket::ReceiveFrom  \n Call this member function to receive a datagram and store the source address in the [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure or in `rSocketAddress`.  \n  \n```  \nint ReceiveFrom(\n    void* lpBuf,  \n    int nBufLen,  \n    CString& rSocketAddress,  \n    UINT& rSocketPort,  \n    int nFlags = 0);\n\n \nint ReceiveFrom(\n    void* lpBuf,  \n    int nBufLen,  \n    SOCKADDR* lpSockAddr,  \n    int* lpSockAddrLen,  \n    int nFlags = 0);\n```  \n  \n### Parameters  \n `lpBuf`  \n A buffer for the incoming data.  \n  \n `nBufLen`  \n The length of `lpBuf` in bytes.  \n  \n `rSocketAddress`  \n Reference to a `CString` object that receives a dotted number IP address.  \n  \n `rSocketPort`  \n Reference to a **UINT** that stores a port.  \n  \n `lpSockAddr`  \n A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that holds the source address upon return.  \n  \n `lpSockAddrLen`  \n A pointer to the length of the source address in `lpSockAddr` in bytes.  \n  \n `nFlags`  \n Specifies the way in which the call is made. The semantics of this function are determined by the socket options and the `nFlags` parameter. The latter is constructed by combining any of the following values with the C++ `OR` operator:  \n  \n- **MSG_PEEK** Peek at the incoming data. The data is copied into the buffer but is not removed from the input queue.  \n  \n- **MSG_OOB** Process out-of-band data.  \n  \n### Return Value  \n If no error occurs, `ReceiveFrom` returns the number of bytes received. If the connection has been closed, it returns 0. Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling `GetLastError`. The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEFAULT** The `lpSockAddrLen` argument was invalid: the `lpSockAddr` buffer was too small to accommodate the peer address.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAEINVAL** The socket has not been bound with **Bind**.  \n  \n- **WSAENOTCONN** The socket is not connected ( **SOCK_STREAM** only).  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n- **WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**.  \n  \n- **WSAESHUTDOWN** The socket has been shut down; it is not possible to call `ReceiveFrom` on a socket after `ShutDown` has been invoked with `nHow` set to 0 or 2.  \n  \n- **WSAEWOULDBLOCK** The socket is marked as nonblocking and the `ReceiveFrom` operation would block.  \n  \n- **WSAEMSGSIZE** The datagram was too large to fit into the specified buffer and was truncated.  \n  \n- **WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure.  \n  \n- **WSAECONNRESET** The virtual circuit was reset by the remote side.  \n  \n### Remarks  \n This function is used to read incoming data on a (possibly connected) socket and capture the address from which the data was sent.  \n  \n To handle IPv6 addresses, use [CAsyncSocket::ReceiveFromEx](#casyncsocket__receivefromex).  \n  \n For sockets of type **SOCK_STREAM**, as much information as is currently available up to the size of the buffer supplied is returned. If the socket has been configured for in-line reception of out-of-band data (socket option **SO_OOBINLINE**) and out-of-band data is unread, only out-of-band data will be returned. The application can use the **IOCtlSIOCATMARK** option or `OnOutOfBandData` to determine whether any more out-of-band data remains to be read. The `lpSockAddr` and `lpSockAddrLen` parameters are ignored for **SOCK_STREAM** sockets.  \n  \n For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied. If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the message, the excess data is lost, and `ReceiveFrom` returns a value of **SOCKET_ERROR** with the error code set to **WSAEMSGSIZE**.  \n  \n If `lpSockAddr` is nonzero, and the socket is of type **SOCK_DGRAM**, the network address of the socket which sent the data is copied to the corresponding [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure. The value pointed to by `lpSockAddrLen` is initialized to the size of this structure, and is modified on return to indicate the actual size of the address stored there. If no incoming data is available at the socket, the `ReceiveFrom` call waits for data to arrive unless the socket is nonblocking. In this case, a value of **SOCKET_ERROR** is returned with the error code set to **WSAEWOULDBLOCK**. The `OnReceive` callback can be used to determine when more data arrives.  \n  \n If the socket is of type **SOCK_STREAM** and the remote side has shut down the connection gracefully, a `ReceiveFrom` will complete immediately with 0 bytes received.  \n  \n##  <a name=\"casyncsocket__receivefromex\"></a>  CAsyncSocket::ReceiveFromEx  \n Call this member function to receive a datagram and store the source address in the [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure or in `rSocketAddress` (handles IPv6 addresses).  \n  \n```  \nint ReceiveFromEx(\n    void* lpBuf,  \n    int nBufLen,  \n    CString& rSocketAddress,  \n    UINT& rSocketPort,  \n    int nFlags = 0);\n```  \n  \n### Parameters  \n `lpBuf`  \n A buffer for the incoming data.  \n  \n `nBufLen`  \n The length of `lpBuf` in bytes.  \n  \n `rSocketAddress`  \n Reference to a `CString` object that receives a dotted number IP address.  \n  \n `rSocketPort`  \n Reference to a **UINT** that stores a port.  \n  \n `nFlags`  \n Specifies the way in which the call is made. The semantics of this function are determined by the socket options and the `nFlags` parameter. The latter is constructed by combining any of the following values with the C++ `OR` operator:  \n  \n- **MSG_PEEK** Peek at the incoming data. The data is copied into the buffer but is not removed from the input queue.  \n  \n- **MSG_OOB** Process out-of-band data.  \n  \n### Return Value  \n If no error occurs, `ReceiveFromEx` returns the number of bytes received. If the connection has been closed, it returns 0. Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling `GetLastError`. The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEFAULT** The `lpSockAddrLen` argument was invalid: the `lpSockAddr` buffer was too small to accommodate the peer address.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAEINVAL** The socket has not been bound with **Bind**.  \n  \n- **WSAENOTCONN** The socket is not connected ( **SOCK_STREAM** only).  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n- **WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**.  \n  \n- **WSAESHUTDOWN** The socket has been shut down; it is not possible to call `ReceiveFromEx` on a socket after `ShutDown` has been invoked with `nHow` set to 0 or 2.  \n  \n- **WSAEWOULDBLOCK** The socket is marked as nonblocking and the `ReceiveFromEx` operation would block.  \n  \n- **WSAEMSGSIZE** The datagram was too large to fit into the specified buffer and was truncated.  \n  \n- **WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure.  \n  \n- **WSAECONNRESET** The virtual circuit was reset by the remote side.  \n  \n### Remarks  \n This function is used to read incoming data on a (possibly connected) socket and capture the address from which the data was sent.  \n  \n This function is the same as [CAsyncSocket::ReceiveFrom](#casyncsocket__receivefrom) except that it handles IPv6 addresses as well as older protocols.  \n  \n For sockets of type **SOCK_STREAM**, as much information as is currently available up to the size of the buffer supplied is returned. If the socket has been configured for in-line reception of out-of-band data (socket option **SO_OOBINLINE**) and out-of-band data is unread, only out-of-band data will be returned. The application can use the **IOCtlSIOCATMARK** option or `OnOutOfBandData` to determine whether any more out-of-band data remains to be read. The `lpSockAddr` and `lpSockAddrLen` parameters are ignored for **SOCK_STREAM** sockets.  \n  \n For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied. If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the message, the excess data is lost, and `ReceiveFromEx` returns a value of **SOCKET_ERROR** with the error code set to **WSAEMSGSIZE**.  \n  \n If `lpSockAddr` is nonzero, and the socket is of type **SOCK_DGRAM**, the network address of the socket which sent the data is copied to the corresponding [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure. The value pointed to by `lpSockAddrLen` is initialized to the size of this structure, and is modified on return to indicate the actual size of the address stored there. If no incoming data is available at the socket, the `ReceiveFromEx` call waits for data to arrive unless the socket is nonblocking. In this case, a value of **SOCKET_ERROR** is returned with the error code set to **WSAEWOULDBLOCK**. The `OnReceive` callback can be used to determine when more data arrives.  \n  \n If the socket is of type **SOCK_STREAM** and the remote side has shut down the connection gracefully, a `ReceiveFromEx` will complete immediately with 0 bytes received.  \n  \n##  <a name=\"casyncsocket__send\"></a>  CAsyncSocket::Send  \n Call this member function to send data on a connected socket.  \n  \n```  \nvirtual int Send(\n    const void* lpBuf,  \n    int nBufLen,  \n    int nFlags = 0);\n```  \n  \n### Parameters  \n `lpBuf`  \n A buffer containing the data to be transmitted.  \n  \n `nBufLen`  \n The length of the data in `lpBuf` in bytes.  \n  \n `nFlags`  \n Specifies the way in which the call is made. The semantics of this function are determined by the socket options and the `nFlags` parameter. The latter is constructed by combining any of the following values with the C++ `OR` operator:  \n  \n- **MSG_DONTROUTE** Specifies that the data should not be subject to routing. A Windows Sockets supplier can choose to ignore this flag.  \n  \n- **MSG_OOB** Send out-of-band data ( **SOCK_STREAM** only).  \n  \n### Return Value  \n If no error occurs, **Send** returns the total number of characters sent. (Note that this can be less than the number indicated by `nBufLen`.) Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEACCES** The requested address is a broadcast address, but the appropriate flag was not set.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAEFAULT** The `lpBuf` argument is not in a valid part of the user address space.  \n  \n- **WSAENETRESET** The connection must be reset because the Windows Sockets implementation dropped it.  \n  \n- `WSAENOBUFS` The Windows Sockets implementation reports a buffer deadlock.  \n  \n- **WSAENOTCONN** The socket is not connected.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n- **WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**.  \n  \n- **WSAESHUTDOWN** The socket has been shut down; it is not possible to call **Send** on a socket after `ShutDown` has been invoked with `nHow` set to 1 or 2.  \n  \n- **WSAEWOULDBLOCK** The socket is marked as nonblocking and the requested operation would block.  \n  \n- **WSAEMSGSIZE** The socket is of type **SOCK_DGRAM**, and the datagram is larger than the maximum supported by the Windows Sockets implementation.  \n  \n- **WSAEINVAL** The socket has not been bound with **Bind**.  \n  \n- **WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure.  \n  \n- **WSAECONNRESET** The virtual circuit was reset by the remote side.  \n  \n### Remarks  \n **Send** is used to write outgoing data on connected stream or datagram sockets. For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the **iMaxUdpDg** element in the [WSADATA](../../mfc/reference/wsadata-structure.md) structure returned by `AfxSocketInit`. If the data is too long to pass atomically through the underlying protocol, the error **WSAEMSGSIZE** is returned via `GetLastError`, and no data is transmitted.  \n  \n Note that for a datagram socket the successful completion of a **Send** does not indicate that the data was successfully delivered.  \n  \n On `CAsyncSocket` objects of type **SOCK_STREAM**, the number of bytes written can be between 1 and the requested length, depending on buffer availability on both the local and foreign hosts.  \n  \n### Example  \n  See the example for [CAsyncSocket::OnSend](#casyncsocket__onsend).  \n  \n##  <a name=\"casyncsocket__sendto\"></a>  CAsyncSocket::SendTo  \n Call this member function to send data to a specific destination.  \n  \n```  \nint SendTo(\n    const void* lpBuf,  \n    int nBufLen,  \n    UINT nHostPort,  \n    LPCTSTR lpszHostAddress = NULL,  \n    int nFlags = 0);\n\n \nint SendTo(\n    const void* lpBuf,  \n    int nBufLen,  \n    const SOCKADDR* lpSockAddr,  \n    int nSockAddrLen,  \n    int nFlags = 0);\n```  \n  \n### Parameters  \n `lpBuf`  \n A buffer containing the data to be transmitted.  \n  \n `nBufLen`  \n The length of the data in `lpBuf` in bytes.  \n  \n `nHostPort`  \n The port identifying the socket application.  \n  \n `lpszHostAddress`  \n The network address of the socket to which this object is connected: a machine name such as \"ftp.microsoft.com,\" or a dotted number such as \"128.56.22.8\".  \n  \n `nFlags`  \n Specifies the way in which the call is made. The semantics of this function are determined by the socket options and the `nFlags` parameter. The latter is constructed by combining any of the following values with the C++ `OR` operator:  \n  \n- **MSG_DONTROUTE** Specifies that the data should not be subject to routing. A Windows Sockets supplier can choose to ignore this flag.  \n  \n- **MSG_OOB** Send out-of-band data ( **SOCK_STREAM** only).  \n  \n `lpSockAddr`  \n A pointer to a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure that contains the address of the target socket.  \n  \n `nSockAddrLen`  \n The length of the address in `lpSockAddr` in bytes.  \n  \n### Return Value  \n If no error occurs, `SendTo` returns the total number of characters sent. (Note that this can be less than the number indicated by `nBufLen`.) Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEACCES** The requested address is a broadcast address, but the appropriate flag was not set.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAEFAULT** The `lpBuf` or `lpSockAddr` parameters are not part of the user address space, or the `lpSockAddr` argument is too small (less than the size of a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure).  \n  \n- **WSAEINVAL** The host name is invalid.  \n  \n- **WSAENETRESET** The connection must be reset because the Windows Sockets implementation dropped it.  \n  \n- `WSAENOBUFS` The Windows Sockets implementation reports a buffer deadlock.  \n  \n- **WSAENOTCONN** The socket is not connected ( **SOCK_STREAM** only).  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n- **WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**.  \n  \n- **WSAESHUTDOWN** The socket has been shut down; it is not possible to call `SendTo` on a socket after `ShutDown` has been invoked with `nHow` set to 1 or 2.  \n  \n- **WSAEWOULDBLOCK** The socket is marked as nonblocking and the requested operation would block.  \n  \n- **WSAEMSGSIZE** The socket is of type **SOCK_DGRAM**, and the datagram is larger than the maximum supported by the Windows Sockets implementation.  \n  \n- **WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure.  \n  \n- **WSAECONNRESET** The virtual circuit was reset by the remote side.  \n  \n- **WSAEADDRNOTAVAIL** The specified address is not available from the local machine.  \n  \n- **WSAEAFNOSUPPORT** Addresses in the specified family cannot be used with this socket.  \n  \n- **WSAEDESTADDRREQ** A destination address is required.  \n  \n- **WSAENETUNREACH** The network cannot be reached from this host at this time.  \n  \n### Remarks  \n `SendTo` is used on datagram or stream sockets and is used to write outgoing data on a socket. For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the **iMaxUdpDg** element in the [WSADATA](../../mfc/reference/wsadata-structure.md) structure filled out by [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit). If the data is too long to pass atomically through the underlying protocol, the error **WSAEMSGSIZE** is returned, and no data is transmitted.  \n  \n Note that the successful completion of a `SendTo` does not indicate that the data was successfully delivered.  \n  \n `SendTo` is only used on a **SOCK_DGRAM** socket to send a datagram to a specific socket identified by the `lpSockAddr` parameter.  \n  \n To send a broadcast (on a **SOCK_DGRAM** only), the address in the `lpSockAddr` parameter should be constructed using the special IP address **INADDR_BROADCAST** (defined in the Windows Sockets header file WINSOCK.H) together with the intended port number. Or, if the `lpszHostAddress` parameter is **NULL**, the socket is configured for broadcast. It is generally inadvisable for a broadcast datagram to exceed the size at which fragmentation can occur, which implies that the data portion of the datagram (excluding headers) should not exceed 512 bytes.  \n  \n To handle IPv6 addresses, use [CAsyncSocket::SendToEx](#casyncsocket__sendtoex).  \n  \n##  <a name=\"casyncsocket__sendtoex\"></a>  CAsyncSocket::SendToEx  \n Call this member function to send data to a specific destination (handles IPv6 addresses).  \n  \n```  \nint SendToEx(\n    const void* lpBuf,  \n    int nBufLen,  \n    UINT nHostPort,  \n    LPCTSTR lpszHostAddress = NULL,  \n    int nFlags = 0);\n```  \n  \n### Parameters  \n `lpBuf`  \n A buffer containing the data to be transmitted.  \n  \n `nBufLen`  \n The length of the data in `lpBuf` in bytes.  \n  \n `nHostPort`  \n The port identifying the socket application.  \n  \n `lpszHostAddress`  \n The network address of the socket to which this object is connected: a machine name such as \"ftp.microsoft.com,\" or a dotted number such as \"128.56.22.8\".  \n  \n `nFlags`  \n Specifies the way in which the call is made. The semantics of this function are determined by the socket options and the `nFlags` parameter. The latter is constructed by combining any of the following values with the C++ `OR` operator:  \n  \n- **MSG_DONTROUTE** Specifies that the data should not be subject to routing. A Windows Sockets supplier can choose to ignore this flag.  \n  \n- **MSG_OOB** Send out-of-band data ( **SOCK_STREAM** only).  \n  \n### Return Value  \n If no error occurs, `SendToEx` returns the total number of characters sent. (Note that this can be less than the number indicated by `nBufLen`.) Otherwise, a value of **SOCKET_ERROR** is returned, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEACCES** The requested address is a broadcast address, but the appropriate flag was not set.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAEFAULT** The `lpBuf` or `lpSockAddr` parameters are not part of the user address space, or the `lpSockAddr` argument is too small (less than the size of a [SOCKADDR](../../mfc/reference/sockaddr-structure.md) structure).  \n  \n- **WSAEINVAL** The host name is invalid.  \n  \n- **WSAENETRESET** The connection must be reset because the Windows Sockets implementation dropped it.  \n  \n- `WSAENOBUFS` The Windows Sockets implementation reports a buffer deadlock.  \n  \n- **WSAENOTCONN** The socket is not connected ( **SOCK_STREAM** only).  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n- **WSAEOPNOTSUPP MSG_OOB** was specified, but the socket is not of type **SOCK_STREAM**.  \n  \n- **WSAESHUTDOWN** The socket has been shut down; it is not possible to call `SendToEx` on a socket after `ShutDown` has been invoked with `nHow` set to 1 or 2.  \n  \n- **WSAEWOULDBLOCK** The socket is marked as nonblocking and the requested operation would block.  \n  \n- **WSAEMSGSIZE** The socket is of type **SOCK_DGRAM**, and the datagram is larger than the maximum supported by the Windows Sockets implementation.  \n  \n- **WSAECONNABORTED** The virtual circuit was aborted due to timeout or other failure.  \n  \n- **WSAECONNRESET** The virtual circuit was reset by the remote side.  \n  \n- **WSAEADDRNOTAVAIL** The specified address is not available from the local machine.  \n  \n- **WSAEAFNOSUPPORT** Addresses in the specified family cannot be used with this socket.  \n  \n- **WSAEDESTADDRREQ** A destination address is required.  \n  \n- **WSAENETUNREACH** The network cannot be reached from this host at this time.  \n  \n### Remarks  \n This method is the same as [CAsyncSocket::SendTo](#casyncsocket__sendto) except that it handles IPv6 addresses as well as older protocols.  \n  \n `SendToEx` is used on datagram or stream sockets and is used to write outgoing data on a socket. For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the **iMaxUdpDg** element in the [WSADATA](../../mfc/reference/wsadata-structure.md) structure filled out by [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit). If the data is too long to pass atomically through the underlying protocol, the error **WSAEMSGSIZE** is returned, and no data is transmitted.  \n  \n Note that the successful completion of a `SendToEx` does not indicate that the data was successfully delivered.  \n  \n `SendToEx` is only used on a **SOCK_DGRAM** socket to send a datagram to a specific socket identified by the `lpSockAddr` parameter.  \n  \n To send a broadcast (on a **SOCK_DGRAM** only), the address in the `lpSockAddr` parameter should be constructed using the special IP address **INADDR_BROADCAST** (defined in the Windows Sockets header file WINSOCK.H) together with the intended port number. Or, if the `lpszHostAddress` parameter is **NULL**, the socket is configured for broadcast. It is generally inadvisable for a broadcast datagram to exceed the size at which fragmentation can occur, which implies that the data portion of the datagram (excluding headers) should not exceed 512 bytes.  \n  \n##  <a name=\"casyncsocket__setsockopt\"></a>  CAsyncSocket::SetSockOpt  \n Call this member function to set a socket option.  \n  \n```  \nBOOL SetSockOpt(\n    int nOptionName,  \n    const void* lpOptionValue,  \n    int nOptionLen,  \n    int nLevel = SOL_SOCKET);\n```  \n  \n### Parameters  \n `nOptionName`  \n The socket option for which the value is to be set.  \n  \n `lpOptionValue`  \n A pointer to the buffer in which the value for the requested option is supplied.  \n  \n `nOptionLen`  \n The size of the `lpOptionValue` buffer in bytes.  \n  \n `nLevel`  \n The level at which the option is defined; the only supported levels are **SOL_SOCKET** and **IPPROTO_TCP**.  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEFAULT** `lpOptionValue` is not in a valid part of the process address space.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAEINVAL** `nLevel` is not valid, or the information in `lpOptionValue` is not valid.  \n  \n- **WSAENETRESET** Connection has timed out when **SO_KEEPALIVE** is set.  \n  \n- **WSAENOPROTOOPT** The option is unknown or unsupported. In particular, **SO_BROADCAST** is not supported on sockets of type **SOCK_STREAM**, while **SO_DONTLINGER**, **SO_KEEPALIVE**, **SO_LINGER**, and **SO_OOBINLINE** are not supported on sockets of type **SOCK_DGRAM**.  \n  \n- **WSAENOTCONN** Connection has been reset when **SO_KEEPALIVE** is set.  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n### Remarks  \n `SetSockOpt` sets the current value for a socket option associated with a socket of any type, in any state. Although options can exist at multiple protocol levels, this specification only defines options that exist at the uppermost \"socket\" level. Options affect socket operations, such as whether expedited data is received in the normal data stream, whether broadcast messages can be sent on the socket, and so on.  \n  \n There are two types of socket options: Boolean options that enable or disable a feature or behavior, and options which require an integer value or structure. To enable a Boolean option, `lpOptionValue` points to a nonzero integer. To disable the option `lpOptionValue` points to an integer equal to zero. `nOptionLen` should be equal to **sizeof(BOOL)** for Boolean options. For other options, `lpOptionValue` points to the integer or structure that contains the desired value for the option, and `nOptionLen` is the length of the integer or structure.  \n  \n **SO_LINGER** controls the action taken when unsent data is queued on a socket and the **Close** function is called to close the socket.  \n  \n By default, a socket cannot be bound (see [Bind](#casyncsocket__bind)) to a local address which is already in use. On occasion, however, it may be desirable to \"reuse\" an address in this way. Since every connection is uniquely identified by the combination of local and remote addresses, there is no problem with having two sockets bound to the same local address as long as the remote addresses are different.  \n  \n To inform the Windows Sockets implementation that a **Bind** call on a socket should not be disallowed because the desired address is already in use by another socket, the application should set the **SO_REUSEADDR** socket option for the socket before issuing the **Bind** call. Note that the option is interpreted only at the time of the **Bind** call: it is therefore unnecessary (but harmless) to set the option on a socket which is not to be bound to an existing address, and setting or resetting the option after the **Bind** call has no effect on this or any other socket.  \n  \n An application can request that the Windows Sockets implementation enable the use of \"keep-alive\" packets on Transmission Control Protocol (TCP) connections by turning on the **SO_KEEPALIVE** socket option. A Windows Sockets implementation need not support the use of keep-alives: if it does, the precise semantics are implementation-specific but should conform to section 4.2.3.6 of RFC 1122: \"Requirements for Internet Hosts â€” Communication Layers.\" If a connection is dropped as the result of \"keep-alives\" the error code **WSAENETRESET** is returned to any calls in progress on the socket, and any subsequent calls will fail with **WSAENOTCONN**.  \n  \n The **TCP_NODELAY** option disables the Nagle algorithm. The Nagle algorithm is used to reduce the number of small packets sent by a host by buffering unacknowledged send data until a full-size packet can be sent. However, for some applications this algorithm can impede performance, and **TCP_NODELAY** can be used to turn it off. Application writers should not set **TCP_NODELAY** unless the impact of doing so is well-understood and desired, since setting **TCP_NODELAY** can have a significant negative impact on network performance. **TCP_NODELAY** is the only supported socket option which uses level **IPPROTO_TCP**; all other options use level **SOL_SOCKET**.  \n  \n Some implementations of Windows Sockets supply output debug information if the **SO_DEBUG** option is set by an application.  \n  \n The following options are supported for `SetSockOpt`. The Type identifies the type of data addressed by `lpOptionValue`.  \n  \n|Value|Type|Meaning|  \n|-----------|----------|-------------|  \n|**SO_BROADCAST**|**BOOL**|Allow transmission of broadcast messages on the socket.|  \n|**SO_DEBUG**|**BOOL**|Record debugging information.|  \n|**SO_DONTLINGER**|**BOOL**|Don't block **Close** waiting for unsent data to be sent. Setting this option is equivalent to setting **SO_LINGER** with **l_onoff** set to zero.|  \n|**SO_DONTROUTE**|**BOOL**|Don't route: send directly to interface.|  \n|**SO_KEEPALIVE**|**BOOL**|Send keep-alives.|  \n|**SO_LINGER**|**struct LINGER**|Linger on **Close** if unsent data is present.|  \n|**SO_OOBINLINE**|**BOOL**|Receive out-of-band data in the normal data stream.|  \n|**SO_RCVBUF**|`int`|Specify buffer size for receives.|  \n|**SO_REUSEADDR**|**BOOL**|Allow the socket to be bound to an address which is already in use. (See [Bind](#casyncsocket__bind).)|  \n|**SO_SNDBUF**|`int`|Specify buffer size for sends.|  \n|**TCP_NODELAY**|**BOOL**|Disables the Nagle algorithm for send coalescing.|  \n  \n Berkeley Software Distribution (BSD) options not supported for `SetSockOpt` are:  \n  \n|Value|Type|Meaning|  \n|-----------|----------|-------------|  \n|**SO_ACCEPTCONN**|**BOOL**|Socket is listening|  \n|**SO_ERROR**|`int`|Get error status and clear.|  \n|**SO_RCVLOWAT**|`int`|Receive low water mark.|  \n|**SO_RCVTIMEO**|`int`|Receive timeout|  \n|**SO_SNDLOWAT**|`int`|Send low water mark.|  \n|**SO_SNDTIMEO**|`int`|Send timeout.|  \n|**SO_TYPE**|`int`|Type of the socket.|  \n|**IP_OPTIONS**||Set options field in IP header.|  \n  \n##  <a name=\"casyncsocket__shutdown\"></a>  CAsyncSocket::ShutDown  \n Call this member function to disable sends, receives, or both on the socket.  \n  \n```  \nBOOL ShutDown(int nHow = sends);\n```  \n  \n### Parameters  \n `nHow`  \n A flag that describes what types of operation will no longer be allowed, using the following enumerated values:  \n  \n- **receives = 0**  \n  \n- **sends = 1**  \n  \n- **both = 2**  \n  \n### Return Value  \n Nonzero if the function is successful; otherwise 0, and a specific error code can be retrieved by calling [GetLastError](#casyncsocket__getlasterror). The following errors apply to this member function:  \n  \n- **WSANOTINITIALISED** A successful [AfxSocketInit](../../mfc/reference/application-information-and-management.md#afxsocketinit) must occur before using this API.  \n  \n- **WSAENETDOWN** The Windows Sockets implementation detected that the network subsystem failed.  \n  \n- **WSAEINVAL** `nHow` is not valid.  \n  \n- **WSAEINPROGRESS** A blocking Windows Sockets operation is in progress.  \n  \n- **WSAENOTCONN** The socket is not connected ( **SOCK_STREAM** only).  \n  \n- **WSAENOTSOCK** The descriptor is not a socket.  \n  \n### Remarks  \n `ShutDown` is used on all types of sockets to disable reception, transmission, or both. If `nHow` is 0, subsequent receives on the socket will be disallowed. This has no effect on the lower protocol layers.  \n  \n For Transmission Control Protocol (TCP), the TCP window is not changed and incoming data will be accepted (but not acknowledged) until the window is exhausted. For User Datagram Protocol (UDP), incoming datagrams are accepted and queued. In no case will an ICMP error packet be generated. If `nHow` is 1, subsequent sends are disallowed. For TCP sockets, a FIN will be sent. Setting `nHow` to 2 disables both sends and receives as described above.  \n  \n Note that `ShutDown` does not close the socket, and resources attached to the socket will not be freed until **Close** is called. An application should not rely on being able to reuse a socket after it has been shut down. In particular, a Windows Sockets implementation is not required to support the use of **Connect** on such a socket.  \n  \n### Example  \n  See the example for [CAsyncSocket::OnReceive](#casyncsocket__onreceive).  \n  \n##  <a name=\"casyncsocket__socket\"></a>  CASyncSocket::Socket  \n Allocates a socket handle.  \n  \n```  \nBOOL Socket(\n    int nSocketType = SOCK_STREAM,  \n    long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,  \n    int nProtocolType = 0,  \n    int nAddressFormat = PF_INET);\n```  \n  \n### Parameters  \n `nSocketType`  \n Specifies `SOCK_STREAM` or `SOCK_DGRAM`.  \n  \n `lEvent`  \n A bitmask that specifies a combination of network events in which the application is interested.  \n  \n- `FD_READ`: Want to receive notification of readiness for reading.  \n  \n- `FD_WRITE`: Want to receive notification of readiness for writing.  \n  \n- `FD_OOB`: Want to receive notification of the arrival of out-of-band data.  \n  \n- `FD_ACCEPT`: Want to receive notification of incoming connections.  \n  \n- `FD_CONNECT`: Want to receive notification of completed connection.  \n  \n- `FD_CLOSE`: Want to receive notification of socket closure.  \n  \n `nProtocolType`  \n Protocol to be used with the socket that is specific to the indicated address family.  \n  \n `nAddressFormat`  \n Address family specification.  \n  \n### Return Value  \n Returns `TRUE` on success, `FALSE` on failure.  \n  \n### Remarks  \n This method allocates a socket handle. It does not call [CAsyncSocket::Bind](#casyncsocket__bind) to bind the socket to a specified address, so you need to call `Bind` later to bind the socket to a specified address. You can use [CAsyncSocket::SetSockOpt](#casyncsocket__setsockopt) to set the socket option before it is bound.  \n  \n## See Also  \n [CObject Class](../../mfc/reference/cobject-class.md)   \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)   \n [CSocket Class](../../mfc/reference/csocket-class.md)   \n [CSocketFile Class](../../mfc/reference/csocketfile-class.md)\n"}