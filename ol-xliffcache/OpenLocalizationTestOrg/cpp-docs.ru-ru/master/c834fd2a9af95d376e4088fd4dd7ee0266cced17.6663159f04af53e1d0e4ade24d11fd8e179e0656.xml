{"nodes":[{"pos":[12,55],"content":"Aliases and typedefs (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Aliases and typedefs (C++) | Microsoft Docs","pos":[0,43]}]},{"content":"Aliases and typedefs (C++)","pos":[575,601]},{"content":"You can use an <bpt id=\"p1\">*</bpt>alias declaration<ept id=\"p1\">*</ept> to declare a name to use as a synonym for a previously declared type.","pos":[602,706],"source":"You can use an *alias declaration* to declare a name to use as a synonym for a previously declared type."},{"content":"(This mechanism is also referred to informally as a <bpt id=\"p1\">*</bpt>type alias<ept id=\"p1\">*</ept>).","pos":[707,773],"source":" (This mechanism is also referred to informally as a *type alias*)."},{"content":"You can also use this mechanism to create an <bpt id=\"p1\">*</bpt>alias template<ept id=\"p1\">*</ept>, which can be particularly useful for custom allocators.","pos":[774,892],"source":" You can also use this mechanism to create an *alias template*, which can be particularly useful for custom allocators."},{"content":"Syntax","pos":[901,907]},{"content":"Remarks","pos":[961,968]},{"content":"The name of the alias.","pos":[988,1010]},{"content":"The type identifier you are creating an alias for.","pos":[1027,1077]},{"content":"An alias does not introduce a new type and cannot change the meaning of an existing type name.","pos":[1084,1178]},{"pos":[1185,1267],"content":"The simplest form of an alias is equivalent to the <ph id=\"ph1\">`typedef`</ph> mechanism from C++03:","source":"The simplest form of an alias is equivalent to the `typedef` mechanism from C++03:"},{"content":"Both of these enable the creation of variables of type \"counter\".","pos":[1386,1451]},{"content":"Something more useful would be a type alias like this one for <ph id=\"ph1\">`std::ios_base::fmtflags`</ph>:","pos":[1452,1540],"source":" Something more useful would be a type alias like this one for `std::ios_base::fmtflags`:"},{"content":"Aliases also work with function pointers, but are much more readable than the equivalent typedef:","pos":[1854,1951]},{"content":"A limitation of the <ph id=\"ph1\">`typedef`</ph> mechanism is that it doesn't work with templates.","pos":[2221,2300],"source":"A limitation of the `typedef` mechanism is that it doesn't work with templates."},{"content":"However, the type alias syntax in C++11 enables the creation of alias templates:","pos":[2301,2381]},{"content":"Example","pos":[2530,2537]},{"content":"The following example demonstrates how to use an alias template with a custom allocator—in this case, an integer vector type.","pos":[2541,2666]},{"content":"You can substitute any type for <ph id=\"ph1\">`int`</ph> to create a convenient alias to hide the complex parameter lists in your main functional code.","pos":[2667,2799],"source":" You can substitute any type for `int` to create a convenient alias to hide the complex parameter lists in your main functional code."},{"content":"By using the custom allocator throughout your code you can improve readability and reduce the risk of introducing bugs caused by typos.","pos":[2800,2935]},{"content":"Output","pos":[4051,4057]},{"content":"Typedefs","pos":[4104,4112]},{"pos":[4116,4272],"content":"A <ph id=\"ph1\">`typedef`</ph> declaration introduces a name that, within its scope, becomes a synonym for the type given by the <bpt id=\"p1\">*</bpt>type-declaration<ept id=\"p1\">*</ept> portion of the declaration.","source":"A `typedef` declaration introduces a name that, within its scope, becomes a synonym for the type given by the *type-declaration* portion of the declaration."},{"content":"You can use typedef declarations to construct shorter or more meaningful names for types already defined by the language or for types that you have declared.","pos":[4279,4436]},{"content":"Typedef names allow you to encapsulate implementation details that may change.","pos":[4437,4515]},{"pos":[4522,4694],"content":"In contrast to the <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`struct`</ph>, <bpt id=\"p2\">**</bpt>union<ept id=\"p2\">**</ept>, and <ph id=\"ph2\">`enum`</ph> declarations, <ph id=\"ph3\">`typedef`</ph> declarations do not introduce new types — they introduce new names for existing types.","source":"In contrast to the **class**, `struct`, **union**, and `enum` declarations, `typedef` declarations do not introduce new types — they introduce new names for existing types."},{"content":"Names declared using <ph id=\"ph1\">`typedef`</ph> occupy the same namespace as other identifiers (except statement labels).","pos":[4701,4805],"source":"Names declared using `typedef` occupy the same namespace as other identifiers (except statement labels)."},{"content":"Therefore, they cannot use the same identifier as a previously declared name, except in a class-type declaration.","pos":[4806,4919]},{"content":"Consider the following example:","pos":[4920,4951]},{"content":"The name-hiding rules that pertain to other identifiers also govern the visibility of names declared using <ph id=\"ph1\">`typedef`</ph>.","pos":[5129,5246],"source":"The name-hiding rules that pertain to other identifiers also govern the visibility of names declared using `typedef`."},{"content":"Therefore, the following example is legal in C++:","pos":[5247,5296]},{"content":"When declaring a local-scope identifier by the same name as a typedef, or when declaring a member of a structure or union in the same scope or in an inner scope, the type specifier must be specified.","pos":[5662,5861]},{"content":"For example:","pos":[5862,5874]},{"pos":[5941,6054],"content":"To reuse the <ph id=\"ph1\">`FlagType`</ph> name for an identifier, a structure member, or a union member, the type must be provided:","source":"To reuse the `FlagType` name for an identifier, a structure member, or a union member, the type must be provided:"},{"content":"It is not sufficient to say","pos":[6126,6153]},{"content":"because the <ph id=\"ph1\">`FlagType`</ph> is taken to be part of the type, not an identifier that is being redeclared.","pos":[6226,6325],"source":"because the `FlagType` is taken to be part of the type, not an identifier that is being redeclared."},{"content":"This declaration is taken to be an illegal declaration like","pos":[6326,6385]},{"content":"You can declare any type with typedef, including pointer, function, and array types.","pos":[6439,6523]},{"content":"You can declare a typedef name for a pointer to a structure or union type before you define the structure or union type, as long as the definition has the same visibility as the declaration.","pos":[6524,6714]},{"content":"Examples","pos":[6724,6732]},{"content":"One use of <ph id=\"ph1\">`typedef`</ph> declarations is to make declarations more uniform and compact.","pos":[6736,6819],"source":"One use of `typedef` declarations is to make declarations more uniform and compact."},{"content":"For example:","pos":[6820,6832]},{"content":"To use <ph id=\"ph1\">`typedef`</ph> to specify fundamental and derived types in the same declaration, you can separate declarators with commas.","pos":[7093,7217],"source":"To use `typedef` to specify fundamental and derived types in the same declaration, you can separate declarators with commas."},{"content":"For example:","pos":[7218,7230]},{"pos":[7280,7391],"content":"The following example provides the type <ph id=\"ph1\">`DRAWF`</ph> for a function returning no value and taking two int arguments:","source":"The following example provides the type `DRAWF` for a function returning no value and taking two int arguments:"},{"pos":[7447,7499],"content":"After the above <ph id=\"ph1\">`typedef`</ph> statement, the declaration","source":"After the above `typedef` statement, the declaration"},{"content":"would be equivalent to the declaration","pos":[7535,7573]},{"pos":[7629,7700],"content":"is often combined with <ph id=\"ph1\">`struct`</ph> to declare and name user-defined types:","source":" is often combined with `struct` to declare and name user-defined types:"},{"content":"Re-declaration of typedefs","pos":[8012,8038]},{"content":"The <ph id=\"ph1\">`typedef`</ph> declaration can be used to redeclare the same name to refer to the same type.","pos":[8042,8133],"source":"The `typedef` declaration can be used to redeclare the same name to refer to the same type."},{"content":"For example:","pos":[8134,8146]},{"content":"The program PROG.CPP includes two header files, both of which contain <ph id=\"ph1\">`typedef`</ph> declarations for the name <ph id=\"ph2\">`CHAR`</ph>.","pos":[8306,8419],"source":"The program PROG.CPP includes two header files, both of which contain `typedef` declarations for the name `CHAR`."},{"content":"As long as both declarations refer to the same type, such redeclaration is acceptable.","pos":[8420,8506]},{"content":"A <ph id=\"ph1\">`typedef`</ph> cannot redefine a name that was previously declared as a different type.","pos":[8513,8597],"source":"A `typedef` cannot redefine a name that was previously declared as a different type."},{"content":"Therefore, if FILE2.H contains","pos":[8598,8628]},{"content":"the compiler issues an error because of the attempt to redeclare the name <ph id=\"ph1\">`CHAR`</ph> to refer to a different type.","pos":[8696,8806],"source":"the compiler issues an error because of the attempt to redeclare the name `CHAR` to refer to a different type."},{"content":"This extends to constructs such as:","pos":[8807,8842]},{"content":"typedefs in C++ vs. C","pos":[9136,9157]},{"content":"Use of the <ph id=\"ph1\">`typedef`</ph> specifier with class types is supported largely because of the ANSI C practice of declaring unnamed structures in <ph id=\"ph2\">`typedef`</ph> declarations.","pos":[9161,9319],"source":"Use of the `typedef` specifier with class types is supported largely because of the ANSI C practice of declaring unnamed structures in `typedef` declarations."},{"content":"For example, many C programmers use the following:","pos":[9320,9370]},{"content":"The advantage of such a declaration is that it enables declarations like:","pos":[9607,9680]},{"content":"instead of:","pos":[9720,9731]},{"content":"In C++, the difference between <ph id=\"ph1\">`typedef`</ph> names and real types (declared with the <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept>, <ph id=\"ph2\">`struct`</ph>, <bpt id=\"p2\">**</bpt>union<ept id=\"p2\">**</ept>, and <ph id=\"ph3\">`enum`</ph> keywords) is more distinct.","pos":[9780,9931],"source":"In C++, the difference between `typedef` names and real types (declared with the **class**, `struct`, **union**, and `enum` keywords) is more distinct."},{"content":"Although the C practice of declaring a nameless structure in a <ph id=\"ph1\">`typedef`</ph> statement still works, it provides no notational benefits as it does in C.","pos":[9932,10079],"source":" Although the C practice of declaring a nameless structure in a `typedef` statement still works, it provides no notational benefits as it does in C."},{"content":"The preceding example declares a class named <ph id=\"ph1\">`POINT`</ph> using the unnamed class <ph id=\"ph2\">`typedef`</ph> syntax.","pos":[10244,10338],"source":"The preceding example declares a class named `POINT` using the unnamed class `typedef` syntax."},{"content":"is treated as a class name; however, the following restrictions apply to names introduced this way:","pos":[10347,10446]},{"pos":[10456,10542],"content":"The name (the synonym) cannot appear after a <bpt id=\"p1\">**</bpt>class<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`struct`</ph>, or <bpt id=\"p2\">**</bpt>union<ept id=\"p2\">**</ept> prefix.","source":"The name (the synonym) cannot appear after a **class**, `struct`, or **union** prefix."},{"content":"The name cannot be used as constructor or destructor names within a class declaration.","pos":[10552,10638]},{"content":"In summary, this syntax does not provide any mechanism for inheritance, construction, or destruction.","pos":[10645,10746]}],"content":"---\ntitle: \"Aliases and typedefs (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"typedef\"\ndev_langs: \n  - \"C++\"\nms.assetid: af1c24d2-4bfd-408a-acfc-482e264232f5\ncaps.latest.revision: 18\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Aliases and typedefs (C++)\nYou can use an *alias declaration* to declare a name to use as a synonym for a previously declared type. (This mechanism is also referred to informally as a *type alias*). You can also use this mechanism to create an *alias template*, which can be particularly useful for custom allocators.  \n  \n## Syntax  \n  \n```  \n  \nusing identifier = type;  \n```  \n  \n## Remarks  \n `identifier`  \n The name of the alias.  \n  \n `type`  \n The type identifier you are creating an alias for.  \n  \n An alias does not introduce a new type and cannot change the meaning of an existing type name.  \n  \n The simplest form of an alias is equivalent to the `typedef` mechanism from C++03:  \n  \n```cpp  \n  \n// C++11  \nusing counter = long;  \n  \n// C++03 equivalent:  \n// typedef long counter;  \n  \n```  \n  \n Both of these enable the creation of variables of type \"counter\". Something more useful would be a type alias like this one for `std::ios_base::fmtflags`:  \n  \n```cpp  \n  \n// C++11  \nusing fmtfl = std::ios_base::fmtflags;  \n// C++03 equivalent:  \n// typedef std::ios_base::fmtflags fmtfl;  \n  \nfmtfl fl_orig = std::cout.flags();  \nfmtfl fl_hex = (fl_orig & ~std::cout.basefield) | std::cout.showbase | std::cout.hex;  \n// ...  \nstd::cout.flags(fl_hex);  \n  \n```  \n  \n Aliases also work with function pointers, but are much more readable than the equivalent typedef:  \n  \n```cpp  \n  \n// C++11  \nusing func = void(*)(int);  \n  \n// C++03 equivalent:  \n// typedef void (*func)(int);  \n  \n// func can be assigned to a function pointer value  \nvoid actual_function(int arg) { /* some code */ }  \nfunc fptr = &actual_function;  \n  \n```  \n  \n A limitation of the `typedef` mechanism is that it doesn't work with templates. However, the type alias syntax in C++11 enables the creation of alias templates:  \n  \n```cpp  \ntemplate<typename T> using ptr = T*;   \n  \n// the name 'ptr<T>' is now an alias for pointer to T  \nptr<int> ptr_int;  \n  \n```  \n  \n## Example  \n The following example demonstrates how to use an alias template with a custom allocator—in this case, an integer vector type. You can substitute any type for `int` to create a convenient alias to hide the complex parameter lists in your main functional code. By using the custom allocator throughout your code you can improve readability and reduce the risk of introducing bugs caused by typos.  \n  \n```cpp  \n  \n#include <stdlib.h>  \n#include <new>  \n  \ntemplate <typename T> struct MyAlloc {  \n    typedef T value_type;  \n  \n    MyAlloc() { }  \n    template <typename U> MyAlloc(const MyAlloc<U>&) { }  \n  \n    bool operator==(const MyAlloc&) const { return true; }  \n    bool operator!=(const MyAlloc&) const { return false; }  \n  \n    T * allocate(const size_t n) const {  \n        if (n == 0) {  \n            return nullptr;  \n        }  \n  \n        if (n > static_cast<size_t>(-1) / sizeof(T)) {  \n            throw std::bad_array_new_length();  \n        }  \n  \n        void * const pv = malloc(n * sizeof(T));  \n  \n        if (!pv) {  \n            throw std::bad_alloc();  \n        }  \n  \n        return static_cast<T *>(pv);  \n    }  \n  \n    void deallocate(T * const p, size_t) const {  \n        free(p);  \n    }  \n};  \n  \n#include <vector>  \nusing MyIntVector = std::vector<int, MyAlloc<int>>;  \n  \n#include <iostream>  \n  \nint main ()   \n{  \n    MyIntVector foov = { 1701, 1764, 1664 };  \n  \n    for (auto a: foov) std::cout << a << \" \";  \n    std::cout << \"\\n\";  \n  \n    return 0;  \n}  \n```  \n  \n## Output  \n  \n```Output  \n1701 1764 1664  \n```  \n  \n## Typedefs  \n A `typedef` declaration introduces a name that, within its scope, becomes a synonym for the type given by the *type-declaration* portion of the declaration.  \n  \n You can use typedef declarations to construct shorter or more meaningful names for types already defined by the language or for types that you have declared. Typedef names allow you to encapsulate implementation details that may change.  \n  \n In contrast to the **class**, `struct`, **union**, and `enum` declarations, `typedef` declarations do not introduce new types — they introduce new names for existing types.  \n  \n Names declared using `typedef` occupy the same namespace as other identifiers (except statement labels). Therefore, they cannot use the same identifier as a previously declared name, except in a class-type declaration. Consider the following example:  \n  \n```  \n// typedef_names1.cpp  \n// C2377 expected  \ntypedef unsigned long UL;   // Declare a typedef name, UL.  \nint UL;                     // C2377: redefined.  \n```  \n  \n The name-hiding rules that pertain to other identifiers also govern the visibility of names declared using `typedef`. Therefore, the following example is legal in C++:  \n  \n```  \n// typedef_names2.cpp  \ntypedef unsigned long UL;   // Declare a typedef name, UL  \nint main()  \n{  \n   unsigned int UL;   // Redeclaration hides typedef name  \n}  \n  \n// typedef UL back in scope  \n```  \n \n  \n```  \n// typedef_specifier1.cpp  \ntypedef char FlagType;  \n  \nint main()  \n{  \n}  \n  \nvoid myproc( int )  \n{  \n    int FlagType;  \n}  \n```  \n  \n When declaring a local-scope identifier by the same name as a typedef, or when declaring a member of a structure or union in the same scope or in an inner scope, the type specifier must be specified. For example:  \n  \n```  \ntypedef char FlagType;  \nconst FlagType x;  \n```  \n  \n To reuse the `FlagType` name for an identifier, a structure member, or a union member, the type must be provided:  \n  \n```  \nconst int FlagType;  // Type specifier required  \n```  \n  \n It is not sufficient to say  \n  \n```  \nconst FlagType;      // Incomplete specification  \n```  \n  \n because the `FlagType` is taken to be part of the type, not an identifier that is being redeclared. This declaration is taken to be an illegal declaration like  \n  \n```  \nint;  // Illegal declaration   \n```  \n  \n You can declare any type with typedef, including pointer, function, and array types. You can declare a typedef name for a pointer to a structure or union type before you define the structure or union type, as long as the definition has the same visibility as the declaration.  \n  \n### Examples  \n One use of `typedef` declarations is to make declarations more uniform and compact. For example:  \n  \n```  \ntypedef char CHAR;          // Character type.  \ntypedef CHAR * PSTR;        // Pointer to a string (char *).  \nPSTR strchr( PSTR source, CHAR target );  \ntypedef unsigned long ulong;  \nulong ul;     // Equivalent to \"unsigned long ul;\"  \n```  \n  \n To use `typedef` to specify fundamental and derived types in the same declaration, you can separate declarators with commas. For example:  \n  \n```  \ntypedef char CHAR, *PSTR;  \n```  \n  \n The following example provides the type `DRAWF` for a function returning no value and taking two int arguments:  \n  \n```  \ntypedef void DRAWF( int, int );  \n```  \n  \n After the above `typedef` statement, the declaration  \n  \n```  \nDRAWF box;   \n```  \n  \n would be equivalent to the declaration  \n  \n```  \nvoid box( int, int );  \n```  \n  \n `typedef` is often combined with `struct` to declare and name user-defined types:  \n  \n```  \n// typedef_specifier2.cpp  \n#include <stdio.h>  \n  \ntypedef struct mystructtag  \n{  \n    int   i;  \n    double f;  \n} mystruct;  \n  \nint main()  \n{  \n    mystruct ms;  \n    ms.i = 10;  \n    ms.f = 0.99;  \n    printf_s(\"%d   %f\\n\", ms.i, ms.f);  \n}  \n```  \n  \n```Output  \n10   0.990000  \n```  \n  \n### Re-declaration of typedefs  \n The `typedef` declaration can be used to redeclare the same name to refer to the same type. For example:  \n  \n```  \n// FILE1.H  \ntypedef char CHAR;  \n  \n// FILE2.H  \ntypedef char CHAR;  \n  \n// PROG.CPP  \n#include \"file1.h\"  \n#include \"file2.h\"   // OK  \n```  \n  \n The program PROG.CPP includes two header files, both of which contain `typedef` declarations for the name `CHAR`. As long as both declarations refer to the same type, such redeclaration is acceptable.  \n  \n A `typedef` cannot redefine a name that was previously declared as a different type. Therefore, if FILE2.H contains  \n  \n```  \n// FILE2.H  \ntypedef int CHAR;     // Error  \n```  \n  \n the compiler issues an error because of the attempt to redeclare the name `CHAR` to refer to a different type. This extends to constructs such as:  \n  \n```  \ntypedef char CHAR;  \ntypedef CHAR CHAR;      // OK: redeclared as same type  \n  \ntypedef union REGS      // OK: name REGS redeclared  \n{                       //  by typedef name with the  \n    struct wordregs x;  //  same meaning.  \n    struct byteregs h;  \n} REGS;  \n```  \n  \n### typedefs in C++ vs. C  \n Use of the `typedef` specifier with class types is supported largely because of the ANSI C practice of declaring unnamed structures in `typedef` declarations. For example, many C programmers use the following:  \n  \n```  \n// typedef_with_class_types1.cpp  \n// compile with: /c  \ntypedef struct {   // Declare an unnamed structure and give it the  \n                   // typedef name POINT.  \n   unsigned x;  \n   unsigned y;  \n} POINT;  \n```  \n  \n The advantage of such a declaration is that it enables declarations like:  \n  \n```  \nPOINT ptOrigin;  \n```  \n  \n instead of:  \n  \n```  \nstruct point_t ptOrigin;  \n```  \n  \n In C++, the difference between `typedef` names and real types (declared with the **class**, `struct`, **union**, and `enum` keywords) is more distinct. Although the C practice of declaring a nameless structure in a `typedef` statement still works, it provides no notational benefits as it does in C.  \n  \n```  \n// typedef_with_class_types2.cpp  \n// compile with: /c /W1  \ntypedef struct {  \n   int POINT();  \n   unsigned x;  \n   unsigned y;  \n} POINT;  \n```  \n  \n The preceding example declares a class named `POINT` using the unnamed class `typedef` syntax. `POINT` is treated as a class name; however, the following restrictions apply to names introduced this way:  \n  \n-   The name (the synonym) cannot appear after a **class**, `struct`, or **union** prefix.  \n  \n-   The name cannot be used as constructor or destructor names within a class declaration.  \n  \n In summary, this syntax does not provide any mechanism for inheritance, construction, or destruction.  \n"}