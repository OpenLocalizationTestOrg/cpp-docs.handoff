{"nodes":[{"pos":[12,51],"content":"integer_sequence Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"integer_sequence Class | Microsoft Docs","pos":[0,39]}]},{"pos":[876,898],"content":"integer_sequence Class","linkify":"integer_sequence Class","nodes":[{"content":"integer_sequence Class","pos":[0,22]}]},{"content":"Represents an integer sequence.","pos":[899,930]},{"content":"Can be used to deduce and expand parameter packs in variadic types such as std::tuple<ph id=\"ph1\">\\&lt;</ph>T...&gt; that are passed as arguments to a function.","pos":[931,1067],"source":" Can be used to deduce and expand parameter packs in variadic types such as std::tuple\\<T...> that are passed as arguments to a function."},{"pos":[1076,1082],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1169,1179],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"T","pos":[1183,1184]},{"content":"The type of the values; must be an integral type: bool, char, char16_t, char32_t, wchar_t, or signed or unsigned integer types.","pos":[1188,1315]},{"content":"Vals","pos":[1322,1326]},{"content":"A non-type parameter pack that represents a sequence of values of integral type T.","pos":[1330,1412]},{"pos":[1421,1428],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"content":"The number of elements in the sequence.","pos":[1481,1520]},{"content":"typedef T value_type","pos":[1525,1545]},{"content":"The type of each element in the sequence.","pos":[1546,1587]},{"content":"Must be an integral type.","pos":[1588,1613]},{"pos":[1623,1630],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"A parameter pack that is passed directly to a function can be unpacked without any special library helpers.","pos":[1634,1741]},{"content":"When a parameter pack is part of a type that is passed to a function, and you need indices to access the elements, then the easiest way to unpack it is to use <ph id=\"ph1\">`integer_sequence`</ph> and its related type aliases <ph id=\"ph2\">`make_integer_sequence`</ph>, <ph id=\"ph3\">`index_sequence`</ph>, <ph id=\"ph4\">`make_index_sequence`</ph>, and <ph id=\"ph5\">`index_sequence_for`</ph>.","pos":[1742,2040],"source":" When a parameter pack is part of a type that is passed to a function, and you need indices to access the elements, then the easiest way to unpack it is to use `integer_sequence` and its related type aliases `make_integer_sequence`, `index_sequence`, `make_index_sequence`, and `index_sequence_for`."},{"pos":[2049,2056],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example is based on the original proposal <bpt id=\"p1\">[</bpt>N3658<ept id=\"p1\">](http://open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3658.html)</ept>.","pos":[2060,2188],"source":"The following example is based on the original proposal [N3658](http://open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3658.html)."},{"content":"It shows how to use an <ph id=\"ph1\">`integer_sequence`</ph> to create a <ph id=\"ph2\">`std::tuple`</ph> from a <ph id=\"ph3\">`std::array&lt;T,N&gt;`</ph>, and how to use an <ph id=\"ph4\">`integer_sequence`</ph> to get at the tuple members.","pos":[2189,2347],"source":" It shows how to use an `integer_sequence` to create a `std::tuple` from a `std::array<T,N>`, and how to use an `integer_sequence` to get at the tuple members."},{"content":"In the <ph id=\"ph1\">`a2t`</ph> function, an <ph id=\"ph2\">`index_sequence`</ph> is an alias of <ph id=\"ph3\">`integer_sequence`</ph> based on the <ph id=\"ph4\">`size_t`</ph> integral type.","pos":[2354,2467],"source":"In the `a2t` function, an `index_sequence` is an alias of `integer_sequence` based on the `size_t` integral type."},{"content":"<ph id=\"ph1\">`make_index_sequence`</ph> is an alias that at compile time creates a zero-based <ph id=\"ph2\">`index_sequence`</ph> with the same number of elements as the array that is passed in by the caller.","pos":[2468,2639],"source":"`make_index_sequence` is an alias that at compile time creates a zero-based `index_sequence` with the same number of elements as the array that is passed in by the caller."},{"content":"<ph id=\"ph1\">`a2t`</ph> passes the <ph id=\"ph2\">`index_sequence`</ph> by value to <ph id=\"ph3\">`a2t_`</ph> , where the expression <ph id=\"ph4\">`a[I]...`</ph> unpacks <ph id=\"ph5\">`I`</ph>, and then the elements are being fed to <ph id=\"ph6\">`make_tuple`</ph> which consumes them as individual arguments.","pos":[2640,2835],"source":"`a2t` passes the `index_sequence` by value to `a2t_` , where the expression `a[I]...` unpacks `I`, and then the elements are being fed to `make_tuple` which consumes them as individual arguments."},{"content":"For example, if the sequence contains three elements, then <ph id=\"ph1\">`make_tuple`</ph> is called as make_tuple(a[0], a[1], a[2]).","pos":[2836,2950],"source":" For example, if the sequence contains three elements, then `make_tuple` is called as make_tuple(a[0], a[1], a[2])."},{"content":"The array elements themselves can of course be any type.","pos":[2951,3007]},{"content":"The apply function accepts a <bpt id=\"p1\">[</bpt>std::tuple<ept id=\"p1\">](../standard-library/tuple-class.md)</ept>, and produces an integer_sequence by using the <ph id=\"ph1\">`tuple_size`</ph> helper class.","pos":[3014,3165],"source":"The apply function accepts a [std::tuple](../standard-library/tuple-class.md), and produces an integer_sequence by using the `tuple_size` helper class."},{"content":"Note that <bpt id=\"p1\">[</bpt>std::decay_t<ept id=\"p1\">](../standard-library/decay-class.md)</ept>_is necessary because <bpt id=\"p2\">[</bpt>tuple_size<ept id=\"p2\">](../standard-library/tuple-size-class-tuple.md)</ept> does not work with reference types.","pos":[3166,3343],"source":" Note that [std::decay_t](../standard-library/decay-class.md)_is necessary because [tuple_size](../standard-library/tuple-size-class-tuple.md) does not work with reference types."},{"content":"The <ph id=\"ph1\">`apply_`</ph> function unpacks the tuple members and forwards them as separate arguments to a function call.","pos":[3344,3451],"source":" The `apply_` function unpacks the tuple members and forwards them as separate arguments to a function call."},{"content":"In this example the function is a simple lambda expression that prints out the values.","pos":[3452,3538]},{"pos":[5149,5289],"content":"To make an <ph id=\"ph1\">`index_sequence`</ph> for a parameter pack, use <ph id=\"ph2\">`index_sequence_for`</ph><ph id=\"ph3\">\\&lt;</ph>T...&gt; which is an alias for <ph id=\"ph4\">`make_index_sequence`</ph><ph id=\"ph5\">\\&lt;</ph>sizeof...(T)&gt;","source":"To make an `index_sequence` for a parameter pack, use `index_sequence_for`\\<T...> which is an alias for `make_index_sequence`\\<sizeof...(T)>"},{"pos":[5298,5310],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Header: &lt;type_traits&gt;","pos":[5314,5335],"source":"Header: <type_traits>"},{"content":"Namepace: std","pos":[5342,5355]},{"pos":[5364,5372],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[5376,5452],"content":"<bpt id=\"p1\">[</bpt>Ellipses and Variadic Templates<ept id=\"p1\">](../cpp/ellipses-and-variadic-templates.md)</ept>","source":"[Ellipses and Variadic Templates](../cpp/ellipses-and-variadic-templates.md)"}],"content":"---\ntitle: \"integer_sequence Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"type_traits/std::index_sequence\"\n  - \"type_traits/std::make_index_sequence\"\n  - \"type_traits/std::integer_sequence\"\n  - \"type_traits/std::make_integer_sequence\"\n  - \"type_traits/std::index_sequence_for\"\n  - \"integer_sequence\"\n  - \"std.integer_sequence\"\n  - \"std::integer_sequence\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"integer_sequence\"\nms.assetid: 2cfdddee-819d-478e-bb78-c8a9c2696803\ncaps.latest.revision: 9\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# integer_sequence Class\nRepresents an integer sequence. Can be used to deduce and expand parameter packs in variadic types such as std::tuple\\<T...> that are passed as arguments to a function.  \n  \n## Syntax  \n  \n```cpp  \ntemplate <class T, T... Vals>  \nstruct integer_sequence  \n```  \n  \n#### Parameters  \n T  \n The type of the values; must be an integral type: bool, char, char16_t, char32_t, wchar_t, or signed or unsigned integer types.  \n  \n Vals  \n A non-type parameter pack that represents a sequence of values of integral type T.  \n  \n## Members  \n  \n|||  \n|-|-|  \n|`static size_t size() noexcept`|The number of elements in the sequence.|  \n|typedef T value_type|The type of each element in the sequence. Must be an integral type.|  \n  \n## Remarks  \n A parameter pack that is passed directly to a function can be unpacked without any special library helpers. When a parameter pack is part of a type that is passed to a function, and you need indices to access the elements, then the easiest way to unpack it is to use `integer_sequence` and its related type aliases `make_integer_sequence`, `index_sequence`, `make_index_sequence`, and `index_sequence_for`.  \n  \n## Example  \n The following example is based on the original proposal [N3658](http://open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3658.html). It shows how to use an `integer_sequence` to create a `std::tuple` from a `std::array<T,N>`, and how to use an `integer_sequence` to get at the tuple members.  \n  \n In the `a2t` function, an `index_sequence` is an alias of `integer_sequence` based on the `size_t` integral type. `make_index_sequence` is an alias that at compile time creates a zero-based `index_sequence` with the same number of elements as the array that is passed in by the caller. `a2t` passes the `index_sequence` by value to `a2t_` , where the expression `a[I]...` unpacks `I`, and then the elements are being fed to `make_tuple` which consumes them as individual arguments. For example, if the sequence contains three elements, then `make_tuple` is called as make_tuple(a[0], a[1], a[2]). The array elements themselves can of course be any type.  \n  \n The apply function accepts a [std::tuple](../standard-library/tuple-class.md), and produces an integer_sequence by using the `tuple_size` helper class. Note that [std::decay_t](../standard-library/decay-class.md)_is necessary because [tuple_size](../standard-library/tuple-size-class-tuple.md) does not work with reference types. The `apply_` function unpacks the tuple members and forwards them as separate arguments to a function call. In this example the function is a simple lambda expression that prints out the values.  \n  \n```  \n  \n#include <stddef.h>  \n#include <iostream>  \n#include <tuple>  \n#include <utility>  \n#include <array>  \n#include <string>  \n  \nusing namespace std;  \n  \n// Create a tuple from the array and the index_sequence  \ntemplate<typename Array, size_t... I>  \nauto a2t_(const Array& a, index_sequence<I...>)  \n{  \n    return make_tuple(a[I]...);  \n}  \n  \n// Create an index sequence for the array, and pass it to the  \n// implementation function a2t_  \ntemplate<typename T, size_t N>  \nauto a2t(const array<T, N>& a)  \n{  \n    return a2t_(a, make_index_sequence<N>());  \n}  \n  \n// Call function F with the tuple members as separate arguments.   \ntemplate<typename F, typename Tuple = tuple<T...>, size_t... I>  \ndecltype(auto) apply_(F&& f, Tuple&& args, index_sequence<I...>)   \n{  \n    return forward<F>(f)(get<I>(forward<Tuple>(args))...);  \n}  \n  \n// Create an index_sequence for the tuple, and pass it with the   \n// function object and the tuple to the implementation function apply_  \ntemplate<typename F, typename Tuple = tuple<T...>>  \ndecltype(auto) apply(F&& f, Tuple&& args)  \n{  \n    using Indices = make_index_sequence<tuple_size<decay_t<Tuple>>::value >;  \n    return apply_(forward<F>(f), forward<Tuple>(args), Indices());  \n}  \n  \nint main()  \n{   \n    const array<string, 3> arr { \"Hello\", \"from\", \"C++14\" };  \n  \n    //Create a tuple given a array  \n    auto tup = a2t(arr);   \n  \n    // Extract the tuple elements  \n    apply([](const string& a, const string& b, const string& c) {cout << a << \" \" << b << \" \" << c << endl; }, tup);  \n  \n    char c;  \n    cin >> c;  \n}  \n  \n```  \n  \n  To make an `index_sequence` for a parameter pack, use `index_sequence_for`\\<T...> which is an alias for `make_index_sequence`\\<sizeof...(T)>  \n  \n## Requirements  \n Header: <type_traits>  \n  \n Namepace: std  \n  \n## See Also  \n [Ellipses and Variadic Templates](../cpp/ellipses-and-variadic-templates.md)\n\n"}