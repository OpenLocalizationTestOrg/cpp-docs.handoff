{"nodes":[{"pos":[12,73],"content":"How to: Marshal Structures Using C++ Interop | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Marshal Structures Using C++ Interop | Microsoft Docs","pos":[0,61]}]},{"content":"How to: Marshal Structures Using C++ Interop","pos":[760,804]},{"content":"This topic demonstrates one facet of Visual C++ interoperability.","pos":[805,870]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using C++ Interop (Implicit PInvoke)<ept id=\"p1\">](../dotnet/using-cpp-interop-implicit-pinvoke.md)</ept>.","pos":[871,985],"source":" For more information, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)."},{"content":"The following code examples use the <bpt id=\"p1\">[</bpt>managed, unmanaged<ept id=\"p1\">](../preprocessor/managed-unmanaged.md)</ept> #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files.","pos":[992,1250],"source":"The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files."},{"content":"Files containing only unmanaged functions do not need to be compiled with <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>.","pos":[1251,1433],"source":" Files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md)."},{"content":"Example","pos":[1442,1449]},{"content":"The following example demonstrates passing a structure from a managed to an unmanaged function, both by value and by reference.","pos":[1453,1580]},{"content":"Because the structure in this example contains only simple, intrinsic data types (see <bpt id=\"p1\">[</bpt>Blittable and Non-Blittable Types<ept id=\"p1\">](http://msdn.microsoft.com/Library/d03b050e-2916-49a0-99ba-f19316e5c1b3)</ept>), no special marshaling is required.","pos":[1581,1811],"source":" Because the structure in this example contains only simple, intrinsic data types (see [Blittable and Non-Blittable Types](http://msdn.microsoft.com/Library/d03b050e-2916-49a0-99ba-f19316e5c1b3)), no special marshaling is required."},{"content":"To marshal non-blittable structures, such as those that contain pointers, see <bpt id=\"p1\">[</bpt>How to: Marshal Embedded Pointers Using C++ Interop<ept id=\"p1\">](../dotnet/how-to-marshal-embedded-pointers-using-cpp-interop.md)</ept>.","pos":[1812,2009],"source":" To marshal non-blittable structures, such as those that contain pointers, see [How to: Marshal Embedded Pointers Using C++ Interop](../dotnet/how-to-marshal-embedded-pointers-using-cpp-interop.md)."},{"content":"Example","pos":[3096,3103]},{"content":"The following example demonstrates passing a structure from an unmanaged to a managed function, both by value and by reference.","pos":[3107,3234]},{"content":"Because the structure in this example contains only simple, intrinsic data types (see <bpt id=\"p1\">[</bpt>Blittable and Non-Blittable Types<ept id=\"p1\">](http://msdn.microsoft.com/Library/d03b050e-2916-49a0-99ba-f19316e5c1b3)</ept>), no special marshalling is required.","pos":[3235,3466],"source":" Because the structure in this example contains only simple, intrinsic data types (see [Blittable and Non-Blittable Types](http://msdn.microsoft.com/Library/d03b050e-2916-49a0-99ba-f19316e5c1b3)), no special marshalling is required."},{"content":"To marshal non-blittable structures, such as those that contain pointers, see <bpt id=\"p1\">[</bpt>How to: Marshal Embedded Pointers Using C++ Interop<ept id=\"p1\">](../dotnet/how-to-marshal-embedded-pointers-using-cpp-interop.md)</ept>.","pos":[3467,3664],"source":" To marshal non-blittable structures, such as those that contain pointers, see [How to: Marshal Embedded Pointers Using C++ Interop](../dotnet/how-to-marshal-embedded-pointers-using-cpp-interop.md)."},{"content":"See Also","pos":[4946,4954]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[4959,4995]}],"content":"---\ntitle: \"How to: Marshal Structures Using C++ Interop | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C++ Interop, structures\"\n  - \"structures [C++], marshaling\"\n  - \"data marshaling [C++], structures\"\n  - \"interop [C++], structures\"\n  - \"marshaling [C++], structures\"\nms.assetid: c2080200-f983-4d6e-a557-cd870f060a54\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Marshal Structures Using C++ Interop\nThis topic demonstrates one facet of Visual C++ interoperability. For more information, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md).  \n  \n The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files. Files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md).  \n  \n## Example  \n The following example demonstrates passing a structure from a managed to an unmanaged function, both by value and by reference. Because the structure in this example contains only simple, intrinsic data types (see [Blittable and Non-Blittable Types](http://msdn.microsoft.com/Library/d03b050e-2916-49a0-99ba-f19316e5c1b3)), no special marshaling is required. To marshal non-blittable structures, such as those that contain pointers, see [How to: Marshal Embedded Pointers Using C++ Interop](../dotnet/how-to-marshal-embedded-pointers-using-cpp-interop.md).  \n  \n```  \n// PassStruct1.cpp  \n// compile with: /clr  \n  \n#include <stdio.h>  \n#include <math.h>  \n  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n#pragma unmanaged  \n  \nstruct Location {  \n   int x;  \n   int y;  \n};  \n  \ndouble GetDistance(Location loc1, Location loc2) {  \n   printf_s(\"[unmanaged] loc1(%d,%d)\", loc1.x, loc1.y);  \n   printf_s(\" loc2(%d,%d)\\n\", loc2.x, loc2.y);  \n  \n   double h = loc1.x - loc2.x;  \n   double v = loc1.y = loc2.y;  \n   double dist = sqrt( pow(h,2) + pow(v,2) );  \n  \n   return dist;  \n}  \n  \nvoid InitLocation(Location* lp) {  \n   printf_s(\"[unmanaged] Initializing location...\\n\");  \n   lp->x = 50;  \n   lp->y = 50;  \n}  \n  \n#pragma managed  \n  \nint main() {  \n   Location loc1;  \n   loc1.x = 0;  \n   loc1.y = 0;  \n  \n   Location loc2;  \n   loc2.x = 100;  \n   loc2.y = 100;  \n  \n   double dist = GetDistance(loc1, loc2);  \n   Console::WriteLine(\"[managed] distance = {0}\", dist);  \n  \n   Location loc3;  \n   InitLocation(&loc3);  \n   Console::WriteLine(\"[managed] x={0} y={1}\", loc3.x, loc3.y);  \n}  \n```  \n  \n## Example  \n The following example demonstrates passing a structure from an unmanaged to a managed function, both by value and by reference. Because the structure in this example contains only simple, intrinsic data types (see [Blittable and Non-Blittable Types](http://msdn.microsoft.com/Library/d03b050e-2916-49a0-99ba-f19316e5c1b3)), no special marshalling is required. To marshal non-blittable structures, such as those that contain pointers, see [How to: Marshal Embedded Pointers Using C++ Interop](../dotnet/how-to-marshal-embedded-pointers-using-cpp-interop.md).  \n  \n```  \n// PassStruct2.cpp  \n// compile with: /clr  \n#include <stdio.h>  \n#include <math.h>  \nusing namespace System;  \n  \n// native structure definition  \nstruct Location {  \n   int x;  \n   int y;  \n};  \n  \n#pragma managed  \n  \ndouble GetDistance(Location loc1, Location loc2) {  \n   Console::Write(\"[managed] got loc1({0},{1})\", loc1.x, loc1.y);  \n   Console::WriteLine(\" loc2({0},{1})\", loc2.x, loc2.y);  \n  \n   double h = loc1.x - loc2.x;  \n   double v = loc1.y = loc2.y;  \n   double dist = sqrt( pow(h,2) + pow(v,2) );  \n  \n   return dist;  \n}  \n  \nvoid InitLocation(Location* lp) {  \n   Console::WriteLine(\"[managed] Initializing location...\");  \n   lp->x = 50;  \n   lp->y = 50;  \n}  \n  \n#pragma unmanaged  \n  \nint UnmanagedFunc() {  \n   Location loc1;  \n   loc1.x = 0;  \n   loc1.y = 0;  \n  \n   Location loc2;  \n   loc2.x = 100;  \n   loc2.y = 100;  \n  \n   printf_s(\"(unmanaged) loc1=(%d,%d)\", loc1.x, loc1.y);  \n   printf_s(\" loc2=(%d,%d)\\n\", loc2.x, loc2.y);  \n  \n   double dist = GetDistance(loc1, loc2);  \n   printf_s(\"[unmanaged] distance = %f\\n\", dist);  \n  \n   Location loc3;  \n   InitLocation(&loc3);  \n   printf_s(\"[unmanaged] got x=%d y=%d\\n\", loc3.x, loc3.y);  \n  \n    return 0;  \n}  \n  \n#pragma managed  \n  \nint main() {  \n   UnmanagedFunc();  \n}  \n```  \n  \n## See Also  \n [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)"}