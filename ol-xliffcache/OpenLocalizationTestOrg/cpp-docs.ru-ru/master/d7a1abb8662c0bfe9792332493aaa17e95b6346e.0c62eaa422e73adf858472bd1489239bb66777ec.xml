{"nodes":[{"pos":[12,62],"content":"Walkthrough: Implementing Futures | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Walkthrough: Implementing Futures | Microsoft Docs","pos":[0,50]}]},{"content":"Walkthrough: Implementing Futures","pos":[690,723]},{"content":"This topic shows how to implement futures in your application.","pos":[724,786]},{"content":"The topic demonstrates how to combine existing functionality in the Concurrency Runtime into something that does more.","pos":[787,905]},{"pos":[913,1227],"content":"[!IMPORTANT]\n This topic illustrates the concept of futures for demonstration purposes. We recommend that you use [std::future](../../standard-library/future-class.md) or [concurrency::task](../../parallel/concrt/reference/task-class.md) when you require an asynchronous task that computes a value for later use.","leadings":["","> "],"nodes":[{"content":" This topic illustrates the concept of futures for demonstration purposes. We recommend that you use [std::future](../../standard-library/future-class.md) or [concurrency::task](../../parallel/concrt/reference/task-class.md) when you require an asynchronous task that computes a value for later use.","pos":[13,312],"nodes":[{"content":"This topic illustrates the concept of futures for demonstration purposes.","pos":[1,74]},{"content":"We recommend that you use <bpt id=\"p1\">[</bpt>std::future<ept id=\"p1\">](../../standard-library/future-class.md)</ept> or <bpt id=\"p2\">[</bpt>concurrency::task<ept id=\"p2\">](../../parallel/concrt/reference/task-class.md)</ept> when you require an asynchronous task that computes a value for later use.","pos":[75,299],"source":" We recommend that you use [std::future](../../standard-library/future-class.md) or [concurrency::task](../../parallel/concrt/reference/task-class.md) when you require an asynchronous task that computes a value for later use."}]}]},{"content":"A <bpt id=\"p1\">*</bpt>task<ept id=\"p1\">*</ept> is a computation that can be decomposed into additional, more fine-grained, computations.","pos":[1234,1332],"source":"A *task* is a computation that can be decomposed into additional, more fine-grained, computations."},{"content":"A <bpt id=\"p1\">*</bpt>future<ept id=\"p1\">*</ept> is an asynchronous task that computes a value for later use.","pos":[1333,1404],"source":" A *future* is an asynchronous task that computes a value for later use."},{"content":"To implement futures, this topic defines the <ph id=\"ph1\">`async_future`</ph> class.","pos":[1411,1477],"source":"To implement futures, this topic defines the `async_future` class."},{"content":"The <ph id=\"ph1\">`async_future`</ph> class uses these components of the Concurrency Runtime: the <bpt id=\"p1\">[</bpt>concurrency::task_group<ept id=\"p1\">](reference/task-group-class.md)</ept> class and the <bpt id=\"p2\">[</bpt>concurrency::single_assignment<ept id=\"p2\">](../../parallel/concrt/reference/single-assignment-class.md)</ept> class.","pos":[1478,1727],"source":" The `async_future` class uses these components of the Concurrency Runtime: the [concurrency::task_group](reference/task-group-class.md) class and the [concurrency::single_assignment](../../parallel/concrt/reference/single-assignment-class.md) class."},{"content":"The <ph id=\"ph1\">`async_future`</ph> class uses the <ph id=\"ph2\">`task_group`</ph> class to compute a value asynchronously and the <ph id=\"ph3\">`single_assignment`</ph> class to store the result of the computation.","pos":[1728,1888],"source":" The `async_future` class uses the `task_group` class to compute a value asynchronously and the `single_assignment` class to store the result of the computation."},{"content":"The constructor of the <ph id=\"ph1\">`async_future`</ph> class takes a work function that computes the result, and the <ph id=\"ph2\">`get`</ph> method retrieves the result.","pos":[1889,2023],"source":" The constructor of the `async_future` class takes a work function that computes the result, and the `get` method retrieves the result."},{"content":"To implement the async_future class","pos":[2033,2068]},{"content":"Declare a template class named <ph id=\"ph1\">`async_future`</ph> that is parameterized on the type of the resulting computation.","pos":[2078,2187],"source":"Declare a template class named `async_future` that is parameterized on the type of the resulting computation."},{"content":"Add <ph id=\"ph1\">`public`</ph> and <ph id=\"ph2\">`private`</ph> sections to this class.","pos":[2188,2238],"source":" Add `public` and `private` sections to this class."},{"pos":[2256,2272],"content":"concrt-futures#2"},{"pos":[2362,2477],"content":"In the <ph id=\"ph1\">`private`</ph> section of the <ph id=\"ph2\">`async_future`</ph> class, declare a <ph id=\"ph3\">`task_group`</ph> and a <ph id=\"ph4\">`single_assignment`</ph> data member.","source":"In the `private` section of the `async_future` class, declare a `task_group` and a `single_assignment` data member."},{"pos":[2495,2511],"content":"concrt-futures#3"},{"content":"In the <ph id=\"ph1\">`public`</ph> section of the <ph id=\"ph2\">`async_future`</ph> class, implement the constructor.","pos":[2602,2681],"source":"In the `public` section of the `async_future` class, implement the constructor."},{"content":"The constructor is a template that is parameterized on the work function that computes the result.","pos":[2682,2780]},{"content":"The constructor asynchronously executes the work function in the <ph id=\"ph1\">`task_group`</ph> data member and uses the <bpt id=\"p1\">[</bpt>concurrency::send<ept id=\"p1\">](reference/concurrency-namespace-functions.md#send)</ept> function to write the result to the <ph id=\"ph2\">`single_assignment`</ph> data member.","pos":[2781,3023],"source":" The constructor asynchronously executes the work function in the `task_group` data member and uses the [concurrency::send](reference/concurrency-namespace-functions.md#send) function to write the result to the `single_assignment` data member."},{"pos":[3041,3057],"content":"concrt-futures#4"},{"content":"In the <ph id=\"ph1\">`public`</ph> section of the <ph id=\"ph2\">`async_future`</ph> class, implement the destructor.","pos":[3147,3225],"source":"In the `public` section of the `async_future` class, implement the destructor."},{"content":"The destructor waits for the task to finish.","pos":[3226,3270]},{"pos":[3288,3304],"content":"concrt-futures#5"},{"content":"In the <ph id=\"ph1\">`public`</ph> section of the <ph id=\"ph2\">`async_future`</ph> class, implement the <ph id=\"ph3\">`get`</ph> method.","pos":[3395,3475],"source":"In the `public` section of the `async_future` class, implement the `get` method."},{"content":"This method uses the <bpt id=\"p1\">[</bpt>concurrency::receive<ept id=\"p1\">](reference/concurrency-namespace-functions.md#receive)</ept> function to retrieve the result of the work function.","pos":[3476,3627],"source":" This method uses the [concurrency::receive](reference/concurrency-namespace-functions.md#receive) function to retrieve the result of the work function."},{"pos":[3646,3662],"content":"concrt-futures#6"},{"content":"Example","pos":[3751,3758]},{"content":"Description","pos":[3768,3779]},{"content":"The following example shows the complete <ph id=\"ph1\">`async_future`</ph> class and an example of its usage.","pos":[3783,3873],"source":"The following example shows the complete `async_future` class and an example of its usage."},{"content":"The <ph id=\"ph1\">`wmain`</ph> function creates a std::<bpt id=\"p1\">[</bpt>vector<ept id=\"p1\">](../../standard-library/vector-class.md)</ept> object that contains 10,000 random integer values.","pos":[3874,4009],"source":" The `wmain` function creates a std::[vector](../../standard-library/vector-class.md) object that contains 10,000 random integer values."},{"content":"It then uses <ph id=\"ph1\">`async_future`</ph> objects to find the smallest and largest values that are contained in the <ph id=\"ph2\">`vector`</ph> object.","pos":[4010,4128],"source":" It then uses `async_future` objects to find the smallest and largest values that are contained in the `vector` object."},{"content":"Code","pos":[4138,4142]},{"pos":[4157,4173],"content":"concrt-futures#1"},{"content":"Comments","pos":[4263,4271]},{"content":"This example produces the following output:","pos":[4275,4318]},{"content":"The example uses the <ph id=\"ph1\">`async_future::get`</ph> method to retrieve the results of the computation.","pos":[4394,4485],"source":"The example uses the `async_future::get` method to retrieve the results of the computation."},{"content":"The <ph id=\"ph1\">`async_future::get`</ph> method waits for the computation to finish if the computation is still active.","pos":[4486,4588],"source":" The `async_future::get` method waits for the computation to finish if the computation is still active."},{"content":"Robust Programming","pos":[4597,4615]},{"content":"To extend the <ph id=\"ph1\">`async_future`</ph> class to handle exceptions that are thrown by the work function, modify the <ph id=\"ph2\">`async_future::get`</ph> method to call the <bpt id=\"p1\">[</bpt>concurrency::task_group::wait<ept id=\"p1\">](reference/task-group-class.md#wait)</ept> method.","pos":[4621,4840],"source":"To extend the `async_future` class to handle exceptions that are thrown by the work function, modify the `async_future::get` method to call the [concurrency::task_group::wait](reference/task-group-class.md#wait) method."},{"content":"The <ph id=\"ph1\">`task_group::wait`</ph> method throws any exceptions that were generated by the work function.","pos":[4841,4934],"source":" The `task_group::wait` method throws any exceptions that were generated by the work function."},{"content":"The following example shows the modified version of the <ph id=\"ph1\">`async_future`</ph> class.","pos":[4943,5020],"source":"The following example shows the modified version of the `async_future` class."},{"content":"The <ph id=\"ph1\">`wmain`</ph> function uses a <ph id=\"ph2\">`try`-`catch`</ph> block to print the result of the <ph id=\"ph3\">`async_future`</ph> object or to print the value of the exception that is generated by the work function.","pos":[5021,5196],"source":" The `wmain` function uses a `try`-`catch` block to print the result of the `async_future` object or to print the value of the exception that is generated by the work function."},{"pos":[5214,5238],"content":"concrt-futures-with-eh#1"},{"content":"This example produces the following output:","pos":[5325,5368]},{"pos":[5422,5603],"content":"For more information about the exception handling model in the Concurrency Runtime, see <bpt id=\"p1\">[</bpt>Exception Handling<ept id=\"p1\">](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)</ept>.","source":"For more information about the exception handling model in the Concurrency Runtime, see [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)."},{"content":"Compiling the Code","pos":[5612,5630]},{"pos":[5634,5823],"content":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named <ph id=\"ph1\">`futures.cpp`</ph> and then run the following command in a Visual Studio Command Prompt window.","source":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `futures.cpp` and then run the following command in a Visual Studio Command Prompt window."},{"content":"cl.exe /EHsc futures.cpp","pos":[5832,5856]},{"content":"See Also","pos":[5867,5875]},{"content":"Concurrency Runtime Walkthroughs","pos":[5880,5912]},{"content":"Exception Handling","pos":[5978,5996]},{"content":"task_group Class","pos":[6075,6091]},{"content":"single_assignment Class","pos":[6129,6152]}],"content":"---\ntitle: \"Walkthrough: Implementing Futures | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"implementing futures [Concurrency Runtime]\"\n  - \"futures, implementing [Concurrency Runtime]\"\nms.assetid: 82ea75cc-aaec-4452-b10d-8abce0a87e5b\ncaps.latest.revision: 25\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Walkthrough: Implementing Futures\nThis topic shows how to implement futures in your application. The topic demonstrates how to combine existing functionality in the Concurrency Runtime into something that does more.  \n  \n> [!IMPORTANT]\n>  This topic illustrates the concept of futures for demonstration purposes. We recommend that you use [std::future](../../standard-library/future-class.md) or [concurrency::task](../../parallel/concrt/reference/task-class.md) when you require an asynchronous task that computes a value for later use.  \n  \n A *task* is a computation that can be decomposed into additional, more fine-grained, computations. A *future* is an asynchronous task that computes a value for later use.  \n  \n To implement futures, this topic defines the `async_future` class. The `async_future` class uses these components of the Concurrency Runtime: the [concurrency::task_group](reference/task-group-class.md) class and the [concurrency::single_assignment](../../parallel/concrt/reference/single-assignment-class.md) class. The `async_future` class uses the `task_group` class to compute a value asynchronously and the `single_assignment` class to store the result of the computation. The constructor of the `async_future` class takes a work function that computes the result, and the `get` method retrieves the result.  \n  \n### To implement the async_future class  \n  \n1.  Declare a template class named `async_future` that is parameterized on the type of the resulting computation. Add `public` and `private` sections to this class.  \n  \n [!code-cpp[concrt-futures#2](../../parallel/concrt/codesnippet/cpp/walkthrough-implementing-futures_1.cpp)]  \n  \n2.  In the `private` section of the `async_future` class, declare a `task_group` and a `single_assignment` data member.  \n  \n [!code-cpp[concrt-futures#3](../../parallel/concrt/codesnippet/cpp/walkthrough-implementing-futures_2.cpp)]  \n  \n\n3.  In the `public` section of the `async_future` class, implement the constructor. The constructor is a template that is parameterized on the work function that computes the result. The constructor asynchronously executes the work function in the `task_group` data member and uses the [concurrency::send](reference/concurrency-namespace-functions.md#send) function to write the result to the `single_assignment` data member.  \n  \n [!code-cpp[concrt-futures#4](../../parallel/concrt/codesnippet/cpp/walkthrough-implementing-futures_3.cpp)]  \n  \n4.  In the `public` section of the `async_future` class, implement the destructor. The destructor waits for the task to finish.  \n  \n [!code-cpp[concrt-futures#5](../../parallel/concrt/codesnippet/cpp/walkthrough-implementing-futures_4.cpp)]  \n  \n\n5.  In the `public` section of the `async_future` class, implement the `get` method. This method uses the [concurrency::receive](reference/concurrency-namespace-functions.md#receive) function to retrieve the result of the work function.  \n\n  \n [!code-cpp[concrt-futures#6](../../parallel/concrt/codesnippet/cpp/walkthrough-implementing-futures_5.cpp)]  \n  \n## Example  \n  \n### Description  \n The following example shows the complete `async_future` class and an example of its usage. The `wmain` function creates a std::[vector](../../standard-library/vector-class.md) object that contains 10,000 random integer values. It then uses `async_future` objects to find the smallest and largest values that are contained in the `vector` object.  \n  \n### Code  \n [!code-cpp[concrt-futures#1](../../parallel/concrt/codesnippet/cpp/walkthrough-implementing-futures_6.cpp)]  \n  \n### Comments  \n This example produces the following output:  \n  \n```Output  \nsmallest: 0  \nlargest:  9999  \naverage:  4981  \n```  \n  \n The example uses the `async_future::get` method to retrieve the results of the computation. The `async_future::get` method waits for the computation to finish if the computation is still active.  \n  \n## Robust Programming  \n\n\n To extend the `async_future` class to handle exceptions that are thrown by the work function, modify the `async_future::get` method to call the [concurrency::task_group::wait](reference/task-group-class.md#wait) method. The `task_group::wait` method throws any exceptions that were generated by the work function.  \n\n\n  \n The following example shows the modified version of the `async_future` class. The `wmain` function uses a `try`-`catch` block to print the result of the `async_future` object or to print the value of the exception that is generated by the work function.  \n  \n [!code-cpp[concrt-futures-with-eh#1](../../parallel/concrt/codesnippet/cpp/walkthrough-implementing-futures_7.cpp)]  \n  \n This example produces the following output:  \n  \n```Output  \ncaught exception: error  \n```  \n  \n For more information about the exception handling model in the Concurrency Runtime, see [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).  \n  \n## Compiling the Code  \n Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `futures.cpp` and then run the following command in a Visual Studio Command Prompt window.  \n  \n **cl.exe /EHsc futures.cpp**  \n  \n## See Also  \n [Concurrency Runtime Walkthroughs](../../parallel/concrt/concurrency-runtime-walkthroughs.md)   \n [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)   \n [task_group Class](reference/task-group-class.md)   \n [single_assignment Class](../../parallel/concrt/reference/single-assignment-class.md)\n"}