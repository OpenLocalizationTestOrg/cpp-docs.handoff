{"nodes":[{"pos":[12,52],"content":"#import Directive (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"import Directive (C++) | Microsoft Doc","pos":[1,39]}]},{"content":"import Directive (C++)","pos":[768,790]},{"content":"C++ Specific","pos":[793,805]},{"content":"Used to incorporate information from a type library.","pos":[814,866]},{"content":"The content of the type library is converted into C++ classes, mostly describing the COM interfaces.","pos":[867,967]},{"content":"Syntax","pos":[976,982]},{"content":"Parameters","pos":[1076,1086]},{"content":"filename","pos":[1091,1099]},{"content":"Specifies the type library to import.","pos":[1104,1141]},{"content":"can be one of the following:","pos":[1153,1181]},{"content":"The name of a file that contains a type library, such as an .olb, .tlb, or .dll file.","pos":[1191,1276]},{"content":"The keyword, <bpt id=\"p1\">**</bpt>file:<ept id=\"p1\">**</ept>, can precede each filename.","pos":[1277,1327],"source":" The keyword, **file:**, can precede each filename."},{"content":"The progid of a control in the type library.","pos":[1337,1381]},{"content":"The keyword, <bpt id=\"p1\">**</bpt>progid:<ept id=\"p1\">**</ept>, can precede each progid.","pos":[1382,1432],"source":" The keyword, **progid:**, can precede each progid."},{"content":"For example:","pos":[1433,1445]},{"pos":[1517,1671],"content":"For more on progids, see <bpt id=\"p1\">[</bpt>Specifying the Localization ID and Version Number<ept id=\"p1\">](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber)</ept>.","source":"For more on progids, see [Specifying the Localization ID and Version Number](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber)."},{"content":"Note that when compiling with a cross compiler on a 64-bit operating system, the compiler will be able to read only the 32-bit registry hive.","pos":[1682,1823]},{"content":"You might want to use the native 64-bit compiler to build and register a 64-bit type library.","pos":[1824,1917]},{"content":"The library ID of the type library.","pos":[1927,1962]},{"content":"The keyword, <bpt id=\"p1\">**</bpt>libid:<ept id=\"p1\">**</ept>, can precede each library ID.","pos":[1963,2016],"source":" The keyword, **libid:**, can precede each library ID."},{"content":"For example:","pos":[2017,2029]},{"pos":[2147,2338],"content":"If you do not specify version or lcid, the <bpt id=\"p1\">[</bpt>rules<ept id=\"p1\">](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber)</ept> that are applied to <bpt id=\"p2\">**</bpt>progid:<ept id=\"p2\">**</ept> are also applied to <bpt id=\"p3\">**</bpt>libid:<ept id=\"p3\">**</ept>.","source":"If you do not specify version or lcid, the [rules](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber) that are applied to **progid:** are also applied to **libid:**."},{"content":"An executable (.exe) file.","pos":[2348,2374]},{"content":"A library (.dll) file containing a type library resource (such as .ocx).","pos":[2384,2456]},{"content":"A compound document holding a type library.","pos":[2466,2509]},{"pos":[2519,2591],"content":"Any other file format that can be understood by the <bpt id=\"p1\">**</bpt>LoadTypeLib<ept id=\"p1\">**</ept> API.","source":"Any other file format that can be understood by the **LoadTypeLib** API."},{"pos":[2598,2761],"content":"`attributes`  \nOne or more [#import attributes](#_predir_the_23import_directive_import_attributes). Separate attributes with either a space or comma. For example:","leadings":[""," "],"nodes":[{"content":"One or more [#import attributes](#_predir_the_23import_directive_import_attributes). Separate attributes with either a space or comma. For example:","pos":[15,162],"nodes":[{"content":"One or more <bpt id=\"p1\">[</bpt>#import attributes<ept id=\"p1\">](#_predir_the_23import_directive_import_attributes)</ept>.","pos":[0,84],"source":"One or more [#import attributes](#_predir_the_23import_directive_import_attributes)."},{"content":"Separate attributes with either a space or comma.","pos":[85,134]},{"content":"For example:","pos":[135,147]}]}]},{"content":"-or-","pos":[2852,2856]},{"content":"Remarks","pos":[2948,2955]},{"pos":[3034,3059],"content":"Search Order for filename"},{"content":"<bpt id=\"p1\">*</bpt>filename<ept id=\"p1\">*</ept> is optionally preceded by a directory specification.","pos":[3063,3126],"source":"*filename* is optionally preceded by a directory specification."},{"content":"The file name must name an existing file.","pos":[3127,3168]},{"content":"The difference between the two syntax forms is the order in which the preprocessor searches for the type library files when the path is incompletely specified.","pos":[3169,3328]},{"content":"Syntax form","pos":[3335,3346]},{"content":"Action","pos":[3347,3353]},{"content":"Quoted form","pos":[3393,3404]},{"content":"Instructs the preprocessor to look for type library files first in the directory of the file that contains the <ph id=\"ph1\">`#import`</ph> statement, and then in the directories of whatever files that include (<ph id=\"ph2\">`#include`</ph>) that file.","pos":[3405,3619],"source":"Instructs the preprocessor to look for type library files first in the directory of the file that contains the `#import` statement, and then in the directories of whatever files that include (`#include`) that file."},{"content":"The preprocessor then searches along the paths shown below.","pos":[3620,3679]},{"content":"Angle-bracket form","pos":[3684,3702]},{"content":"Instructs the preprocessor to search for type library files along the following paths:","pos":[3703,3789]},{"content":"1.  The <bpt id=\"p1\">**</bpt>PATH<ept id=\"p1\">**</ept> environment variable path list","pos":[3802,3849],"source":" 1.  The **PATH** environment variable path list"},{"content":"2.  The <bpt id=\"p1\">**</bpt>LIB<ept id=\"p1\">**</ept> environment variable path list","pos":[3855,3901],"source":"2.  The **LIB** environment variable path list"},{"content":"3.  The path specified by the /I (additional include directories) compiler option, except it the compiler is searching for a type library that was referenced from another type library with the <bpt id=\"p1\">[</bpt>no_registry<ept id=\"p1\">](../preprocessor/no-registry.md)</ept> attribute.","pos":[3907,4156],"source":"3.  The path specified by the /I (additional include directories) compiler option, except it the compiler is searching for a type library that was referenced from another type library with the [no_registry](../preprocessor/no-registry.md) attribute."},{"pos":[4257,4306],"content":"Specifying the Localization ID and Version Number"},{"content":"When you specify a progid, you can also specify the localization ID and version number of the progid.","pos":[4310,4411]},{"content":"For example:","pos":[4412,4424]},{"content":"If you do not specify a localization ID, a progid is chosen according to the following rules:","pos":[4500,4593]},{"content":"If there is only one localization ID, that one is used.","pos":[4603,4658]},{"content":"If there is more than one localization ID, the first one with version number 0, 9, or 409 is used.","pos":[4668,4766]},{"content":"If there is more than one localization ID and none of them are 0, 9, or 409, the last one is used.","pos":[4776,4874]},{"content":"If you do not specify a version number, the most recent version is used.","pos":[4884,4956]},{"pos":[5043,5073],"content":"Header Files Created by Import"},{"content":"creates two header files that reconstruct the type library contents in C++ source code.","pos":[5087,5174]},{"content":"The primary header file is similar to that produced by the Microsoft Interface Definition Language (MIDL) compiler, but with additional compiler-generated code and data.","pos":[5175,5344]},{"content":"The <bpt id=\"p1\">[</bpt>primary header file<ept id=\"p1\">](#_predir_the_primary_type_library_header_file)</ept> has the same base name as the type library, plus a .TLH extension.","pos":[5345,5484],"source":" The [primary header file](#_predir_the_primary_type_library_header_file) has the same base name as the type library, plus a .TLH extension."},{"content":"The secondary header file has the same base name as the type library, with a .TLI extension.","pos":[5485,5577]},{"content":"It contains the implementations for compiler-generated member functions, and is included (<ph id=\"ph1\">`#include`</ph>) in the primary header file.","pos":[5578,5707],"source":" It contains the implementations for compiler-generated member functions, and is included (`#include`) in the primary header file."},{"pos":[5714,5880],"content":"If importing a dispinterface property that uses byref parameters, #import will not generate __declspec(<bpt id=\"p1\">[</bpt>property<ept id=\"p1\">](../cpp/property-cpp.md)</ept>) statement for the function.","source":"If importing a dispinterface property that uses byref parameters, #import will not generate __declspec([property](../cpp/property-cpp.md)) statement for the function."},{"content":"Both header files are placed in the output directory specified by the /Fo (name object file) option.","pos":[5887,5987]},{"content":"They are then read and compiled by the compiler as if the primary header file was named by a <ph id=\"ph1\">`#include`</ph> directive.","pos":[5988,6102],"source":" They are then read and compiled by the compiler as if the primary header file was named by a `#include` directive."},{"pos":[6109,6180],"content":"The following compiler optimizations come with the <ph id=\"ph1\">`#import`</ph> directive:","source":"The following compiler optimizations come with the `#import` directive:"},{"content":"The header file, when created, is given the same timestamp as the type library.","pos":[6190,6269]},{"content":"When <ph id=\"ph1\">`#import`</ph> is processed, the compiler first checks if the header exists and is up to date.","pos":[6279,6373],"source":"When `#import` is processed, the compiler first checks if the header exists and is up to date."},{"content":"If yes, then it does not need to be re-created.","pos":[6374,6421]},{"content":"The <ph id=\"ph1\">`#import`</ph> directive also participates in minimal rebuild and can be placed in a precompiled header file.","pos":[6428,6536],"source":"The `#import` directive also participates in minimal rebuild and can be placed in a precompiled header file."},{"content":"See <bpt id=\"p1\">[</bpt>Creating Precompiled Header Files<ept id=\"p1\">](../build/reference/creating-precompiled-header-files.md)</ept> for more information.","pos":[6537,6655],"source":" See [Creating Precompiled Header Files](../build/reference/creating-precompiled-header-files.md) for more information."},{"pos":[6726,6758],"content":"Primary Type Library Header File"},{"content":"The primary type library header file consists of seven sections:","pos":[6762,6826]},{"pos":[6836,7012],"content":"Heading boilerplate: Consists of comments, <ph id=\"ph1\">`#include`</ph> statement for COMDEF.H (which defines some standard macros used in the header), and other miscellaneous setup information.","source":"Heading boilerplate: Consists of comments, `#include` statement for COMDEF.H (which defines some standard macros used in the header), and other miscellaneous setup information."},{"pos":[7022,7133],"content":"Forward references and typedefs: Consists of structure declarations such as <ph id=\"ph1\">`struct IMyInterface`</ph> and typedefs.","source":"Forward references and typedefs: Consists of structure declarations such as `struct IMyInterface` and typedefs."},{"content":"Smart pointer declarations: The template class <ph id=\"ph1\">`_com_ptr_t`</ph> is a smart-pointer implementation that encapsulates interface pointers and eliminates the need to call <ph id=\"ph2\">`AddRef`</ph>, <bpt id=\"p1\">**</bpt>Release<ept id=\"p1\">**</ept>, <ph id=\"ph3\">`QueryInterface`</ph> functions.","pos":[7143,7356],"source":"Smart pointer declarations: The template class `_com_ptr_t` is a smart-pointer implementation that encapsulates interface pointers and eliminates the need to call `AddRef`, **Release**, `QueryInterface` functions."},{"content":"In addition, it hides the <ph id=\"ph1\">`CoCreateInstance`</ph> call in creating a new COM object.","pos":[7357,7436],"source":" In addition, it hides the `CoCreateInstance` call in creating a new COM object."},{"content":"This section uses macro statement <bpt id=\"p1\">**</bpt>_COM_SMARTPTR_TYPEDEF<ept id=\"p1\">**</ept> to establish typedefs of COM interfaces to be template specializations of the <bpt id=\"p2\">[</bpt>_com_ptr_t<ept id=\"p2\">](../cpp/com-ptr-t-class.md)</ept> template class.","pos":[7437,7630],"source":" This section uses macro statement **_COM_SMARTPTR_TYPEDEF** to establish typedefs of COM interfaces to be template specializations of the [_com_ptr_t](../cpp/com-ptr-t-class.md) template class."},{"content":"For example, for interface <bpt id=\"p1\">**</bpt>IMyInterface<ept id=\"p1\">**</ept>, the .TLH file will contain:","pos":[7631,7703],"source":" For example, for interface **IMyInterface**, the .TLH file will contain:"},{"content":"which the compiler will expand to:","pos":[7804,7838]},{"content":"Type <ph id=\"ph1\">`IMyInterfacePtr`</ph> can then be used in place of the raw interface pointer <ph id=\"ph2\">`IMyInterface*`</ph>.","pos":[7964,8058],"source":"Type `IMyInterfacePtr` can then be used in place of the raw interface pointer `IMyInterface*`."},{"content":"Consequently, there is no need to call the various <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> member functions","pos":[8059,8139],"source":" Consequently, there is no need to call the various **IUnknown** member functions"},{"content":"Typeinfo declarations: Primarily consists of class definitions and other items exposing the individual typeinfo items returned by <bpt id=\"p1\">**</bpt>ITypeLib:GetTypeInfo<ept id=\"p1\">**</ept>.","pos":[8149,8304],"source":"Typeinfo declarations: Primarily consists of class definitions and other items exposing the individual typeinfo items returned by **ITypeLib:GetTypeInfo**."},{"content":"In this section, each typeinfo from the type library is reflected in the header in a form dependent on the <ph id=\"ph1\">`TYPEKIND`</ph> information.","pos":[8305,8435],"source":" In this section, each typeinfo from the type library is reflected in the header in a form dependent on the `TYPEKIND` information."},{"content":"Optional old-style GUID definition: Contains initializations of the named GUID constants.","pos":[8445,8534]},{"content":"These are names of the form <bpt id=\"p1\">**</bpt>CLSID_CoClass<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>IID_Interface<ept id=\"p2\">**</ept>, similar to those generated by the MIDL compiler.","pos":[8535,8652],"source":" These are names of the form **CLSID_CoClass** and **IID_Interface**, similar to those generated by the MIDL compiler."},{"pos":[8673,8721],"content":"statement for the secondary type library header."},{"pos":[8731,8790],"content":"Footer boilerplate: Currently includes <ph id=\"ph1\">`#pragma pack(pop)`</ph>.","source":"Footer boilerplate: Currently includes `#pragma pack(pop)`."},{"content":"All sections, except the heading boilerplate and footer boilerplate section, are enclosed in a namespace with its name specified by the <bpt id=\"p1\">**</bpt>library<ept id=\"p1\">**</ept> statement in the original IDL file.","pos":[8797,8980],"source":"All sections, except the heading boilerplate and footer boilerplate section, are enclosed in a namespace with its name specified by the **library** statement in the original IDL file."},{"content":"You can use the names from the type library header either by an explicit qualification with the namespace name or by including the following statement:","pos":[8981,9132]},{"pos":[9179,9240],"content":"immediately after the <ph id=\"ph1\">`#import`</ph> statement in the source code.","source":"immediately after the `#import` statement in the source code."},{"content":"The namespace can be suppressed by using the <bpt id=\"p1\">[</bpt>no_namespace<ept id=\"p1\">](#_predir_no_namespace)</ept> attribute of the <ph id=\"ph1\">`#import`</ph> directive.","pos":[9247,9367],"source":"The namespace can be suppressed by using the [no_namespace](#_predir_no_namespace) attribute of the `#import` directive."},{"content":"However, suppressing the namespace may lead to name collisions.","pos":[9368,9431]},{"content":"The namespace can also be renamed by the <bpt id=\"p1\">[</bpt>rename_namespace<ept id=\"p1\">](#_predir_rename_namespace)</ept> attribute.","pos":[9432,9529],"source":" The namespace can also be renamed by the [rename_namespace](#_predir_rename_namespace) attribute."},{"content":"The compiler provides the full path to any type library dependency required by the type library it is currently processing.","pos":[9536,9659]},{"content":"The path is written, in the form of comments, into the type library header (.TLH) that the compiler generates for each processed type library.","pos":[9660,9802]},{"content":"If a type library includes references to types defined in other type libraries, then the .TLH file will include comments of the following sort:","pos":[9809,9952]},{"content":"The actual filename in the <ph id=\"ph1\">`#import`</ph> comment is the full path of the cross-referenced type library, as stored in the registry.","pos":[10064,10190],"source":"The actual filename in the `#import` comment is the full path of the cross-referenced type library, as stored in the registry."},{"content":"If you encounter errors that are due to missing type definitions, check the comments at the head of the .TLH to see which dependent type libraries may need to be imported first.","pos":[10191,10368]},{"content":"Likely errors are syntax errors (for example, C2143, C2146, C2321), C2501 (missing decl-specifiers), or C2433 ('inline' not permitted on data declaration) while compiling the .TLI file.","pos":[10369,10554]},{"pos":[10561,10799],"content":"You must determine which of the dependency comments are not otherwise provided for by system headers and then provide an <ph id=\"ph1\">`#import`</ph> directive at some point before the <ph id=\"ph2\">`#import`</ph> directive of the dependent type library to resolve the errors.","source":"You must determine which of the dependency comments are not otherwise provided for by system headers and then provide an `#import` directive at some point before the `#import` directive of the dependent type library to resolve the errors."},{"content":"For more information, see the Knowledge Base article \"#import Wrapper Methods May Cause Access Violation\" (Q242527) or \"Compiler Errors When You Use #import with XML\" (Q269194).","pos":[10806,10983]},{"content":"You can find Knowledge Base articles on the MSDN Library media or at <bpt id=\"p1\">[</bpt>http://support.microsoft.com/support/<ept id=\"p1\">](http://support.microsoft.com/support/)</ept>.","pos":[10984,11132],"source":" You can find Knowledge Base articles on the MSDN Library media or at [http://support.microsoft.com/support/](http://support.microsoft.com/support/)."},{"pos":[11207,11224],"content":"import Attributes"},{"content":"can optionally include one or more attributes.","pos":[11238,11284]},{"content":"These attributes tell the compiler to modify the contents of the type-library headers.","pos":[11285,11371]},{"content":"A backslash (<bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\\\</ph><ept id=\"p1\">**</ept>) symbol can be used to include additional lines in a single <ph id=\"ph2\">`#import`</ph> statement.","pos":[11372,11472],"source":" A backslash (**\\\\**) symbol can be used to include additional lines in a single `#import` statement."},{"content":"For example:","pos":[11473,11485]},{"pos":[11577,11671],"content":"For more information, see <bpt id=\"p1\">[</bpt>#import Attributes<ept id=\"p1\">](../preprocessor/hash-import-attributes-cpp.md)</ept>.","source":"For more information, see [#import Attributes](../preprocessor/hash-import-attributes-cpp.md)."},{"content":"END C++ Specific","pos":[11680,11696]},{"content":"See Also","pos":[11707,11715]},{"content":"Preprocessor Directives","pos":[11720,11743]},{"content":"Compiler COM Support","pos":[11794,11814]}],"content":"---\ntitle: \"#import Directive (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"#import\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \".tlh files\"\n  - \"#import directive\"\n  - \"import directive (#import)\"\n  - \"tlh files\"\n  - \"tlbid switch\"\n  - \"preprocessor, directives\"\n  - \"COM, type library header file\"\nms.assetid: 787d1112-e543-40d7-ab15-a63d43f4030a\ncaps.latest.revision: 17\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# #import Directive (C++)\n**C++ Specific**  \n  \n Used to incorporate information from a type library. The content of the type library is converted into C++ classes, mostly describing the COM interfaces.  \n  \n## Syntax  \n  \n```  \n#import \"filename\" [attributes]  \n#import <filename> [attributes]  \n```  \n  \n#### Parameters  \n *filename*  \n Specifies the type library to import. `filename` can be one of the following:  \n  \n-   The name of a file that contains a type library, such as an .olb, .tlb, or .dll file. The keyword, **file:**, can precede each filename.  \n  \n-   The progid of a control in the type library. The keyword, **progid:**, can precede each progid. For example:  \n  \n    ```  \n    #import \"progid:my.prog.id.1.5\"  \n    ```  \n  \n     For more on progids, see [Specifying the Localization ID and Version Number](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber).  \n  \n     Note that when compiling with a cross compiler on a 64-bit operating system, the compiler will be able to read only the 32-bit registry hive. You might want to use the native 64-bit compiler to build and register a 64-bit type library.  \n  \n-   The library ID of the type library. The keyword, **libid:**, can precede each library ID. For example:  \n  \n    ```  \n    #import \"libid:12341234-1234-1234-1234-123412341234\" version(\"4.0\") lcid(\"9\")  \n    ```  \n  \n     If you do not specify version or lcid, the [rules](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber) that are applied to **progid:** are also applied to **libid:**.  \n  \n-   An executable (.exe) file.  \n  \n-   A library (.dll) file containing a type library resource (such as .ocx).  \n  \n-   A compound document holding a type library.  \n  \n-   Any other file format that can be understood by the **LoadTypeLib** API.  \n  \n `attributes`  \n One or more [#import attributes](#_predir_the_23import_directive_import_attributes). Separate attributes with either a space or comma. For example:  \n  \n```  \n#import \"..\\drawctl\\drawctl.tlb\" no_namespace, raw_interfaces_only  \n```  \n  \n -or-  \n  \n```  \n#import \"..\\drawctl\\drawctl.tlb\" no_namespace raw_interfaces_only  \n```  \n  \n## Remarks  \n  \n##  <a name=\"_predir_the_23import_directive_searchorderforfilename\"></a> Search Order for filename  \n *filename* is optionally preceded by a directory specification. The file name must name an existing file. The difference between the two syntax forms is the order in which the preprocessor searches for the type library files when the path is incompletely specified.  \n  \n|Syntax form|Action|  \n|-----------------|------------|  \n|Quoted form|Instructs the preprocessor to look for type library files first in the directory of the file that contains the `#import` statement, and then in the directories of whatever files that include (`#include`) that file. The preprocessor then searches along the paths shown below.|  \n|Angle-bracket form|Instructs the preprocessor to search for type library files along the following paths:<br /><br /> 1.  The **PATH** environment variable path list<br />2.  The **LIB** environment variable path list<br />3.  The path specified by the /I (additional include directories) compiler option, except it the compiler is searching for a type library that was referenced from another type library with the [no_registry](../preprocessor/no-registry.md) attribute.|  \n  \n##  <a name=\"_predir_the_23import_directive_specifyingthelocalizationidandversionnumber\"></a> Specifying the Localization ID and Version Number  \n When you specify a progid, you can also specify the localization ID and version number of the progid. For example:  \n  \n```  \n#import \"progid:my.prog.id\" lcid(\"0\") version(\"4.0)  \n```  \n  \n If you do not specify a localization ID, a progid is chosen according to the following rules:  \n  \n-   If there is only one localization ID, that one is used.  \n  \n-   If there is more than one localization ID, the first one with version number 0, 9, or 409 is used.  \n  \n-   If there is more than one localization ID and none of them are 0, 9, or 409, the last one is used.  \n  \n-   If you do not specify a version number, the most recent version is used.  \n  \n##  <a name=\"_predir_the_23import_directive_header_files_created_by_import\"></a> Header Files Created by Import  \n `#import` creates two header files that reconstruct the type library contents in C++ source code. The primary header file is similar to that produced by the Microsoft Interface Definition Language (MIDL) compiler, but with additional compiler-generated code and data. The [primary header file](#_predir_the_primary_type_library_header_file) has the same base name as the type library, plus a .TLH extension. The secondary header file has the same base name as the type library, with a .TLI extension. It contains the implementations for compiler-generated member functions, and is included (`#include`) in the primary header file.  \n  \n If importing a dispinterface property that uses byref parameters, #import will not generate __declspec([property](../cpp/property-cpp.md)) statement for the function.  \n  \n Both header files are placed in the output directory specified by the /Fo (name object file) option. They are then read and compiled by the compiler as if the primary header file was named by a `#include` directive.  \n  \n The following compiler optimizations come with the `#import` directive:  \n  \n-   The header file, when created, is given the same timestamp as the type library.  \n  \n-   When `#import` is processed, the compiler first checks if the header exists and is up to date. If yes, then it does not need to be re-created.  \n  \n The `#import` directive also participates in minimal rebuild and can be placed in a precompiled header file. See [Creating Precompiled Header Files](../build/reference/creating-precompiled-header-files.md) for more information.  \n  \n###  <a name=\"_predir_the_primary_type_library_header_file\"></a> Primary Type Library Header File  \n The primary type library header file consists of seven sections:  \n  \n-   Heading boilerplate: Consists of comments, `#include` statement for COMDEF.H (which defines some standard macros used in the header), and other miscellaneous setup information.  \n  \n-   Forward references and typedefs: Consists of structure declarations such as `struct IMyInterface` and typedefs.  \n  \n-   Smart pointer declarations: The template class `_com_ptr_t` is a smart-pointer implementation that encapsulates interface pointers and eliminates the need to call `AddRef`, **Release**, `QueryInterface` functions. In addition, it hides the `CoCreateInstance` call in creating a new COM object. This section uses macro statement **_COM_SMARTPTR_TYPEDEF** to establish typedefs of COM interfaces to be template specializations of the [_com_ptr_t](../cpp/com-ptr-t-class.md) template class. For example, for interface **IMyInterface**, the .TLH file will contain:  \n  \n    ```  \n    _COM_SMARTPTR_TYPEDEF(IMyInterface, __uuidof(IMyInterface));  \n    ```  \n  \n     which the compiler will expand to:  \n  \n    ```  \n    typedef _com_ptr_t<_com_IIID<IMyInterface, __uuidof(IMyInterface)> > IMyInterfacePtr;  \n    ```  \n  \n     Type `IMyInterfacePtr` can then be used in place of the raw interface pointer `IMyInterface*`. Consequently, there is no need to call the various **IUnknown** member functions  \n  \n-   Typeinfo declarations: Primarily consists of class definitions and other items exposing the individual typeinfo items returned by **ITypeLib:GetTypeInfo**. In this section, each typeinfo from the type library is reflected in the header in a form dependent on the `TYPEKIND` information.  \n  \n-   Optional old-style GUID definition: Contains initializations of the named GUID constants. These are names of the form **CLSID_CoClass** and **IID_Interface**, similar to those generated by the MIDL compiler.  \n  \n-   `#include` statement for the secondary type library header.  \n  \n-   Footer boilerplate: Currently includes `#pragma pack(pop)`.  \n  \n All sections, except the heading boilerplate and footer boilerplate section, are enclosed in a namespace with its name specified by the **library** statement in the original IDL file. You can use the names from the type library header either by an explicit qualification with the namespace name or by including the following statement:  \n  \n```  \nusing namespace MyLib;  \n```  \n  \n immediately after the `#import` statement in the source code.  \n  \n The namespace can be suppressed by using the [no_namespace](#_predir_no_namespace) attribute of the `#import` directive. However, suppressing the namespace may lead to name collisions. The namespace can also be renamed by the [rename_namespace](#_predir_rename_namespace) attribute.  \n  \n The compiler provides the full path to any type library dependency required by the type library it is currently processing. The path is written, in the form of comments, into the type library header (.TLH) that the compiler generates for each processed type library.  \n  \n If a type library includes references to types defined in other type libraries, then the .TLH file will include comments of the following sort:  \n  \n```  \n//  \n// Cross-referenced type libraries:  \n//  \n//  #import \"c:\\path\\typelib0.tlb\"  \n//  \n```  \n  \n The actual filename in the `#import` comment is the full path of the cross-referenced type library, as stored in the registry. If you encounter errors that are due to missing type definitions, check the comments at the head of the .TLH to see which dependent type libraries may need to be imported first. Likely errors are syntax errors (for example, C2143, C2146, C2321), C2501 (missing decl-specifiers), or C2433 ('inline' not permitted on data declaration) while compiling the .TLI file.  \n  \n You must determine which of the dependency comments are not otherwise provided for by system headers and then provide an `#import` directive at some point before the `#import` directive of the dependent type library to resolve the errors.  \n  \n For more information, see the Knowledge Base article \"#import Wrapper Methods May Cause Access Violation\" (Q242527) or \"Compiler Errors When You Use #import with XML\" (Q269194). You can find Knowledge Base articles on the MSDN Library media or at [http://support.microsoft.com/support/](http://support.microsoft.com/support/).  \n  \n##  <a name=\"_predir_the_23import_directive_import_attributes\"></a> #import Attributes  \n `#import` can optionally include one or more attributes. These attributes tell the compiler to modify the contents of the type-library headers. A backslash (**\\\\**) symbol can be used to include additional lines in a single `#import` statement. For example:  \n  \n```  \n#import \"test.lib\" no_namespace \\  \n   rename(\"OldName\", \"NewName\")  \n```  \n  \n For more information, see [#import Attributes](../preprocessor/hash-import-attributes-cpp.md).  \n  \n **END C++ Specific**  \n  \n## See Also  \n [Preprocessor Directives](../preprocessor/preprocessor-directives.md)   \n [Compiler COM Support](../cpp/compiler-com-support.md)"}