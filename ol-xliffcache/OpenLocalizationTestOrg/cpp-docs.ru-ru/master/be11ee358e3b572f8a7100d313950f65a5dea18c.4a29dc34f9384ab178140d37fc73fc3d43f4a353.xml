{"nodes":[{"pos":[12,61],"content":"TN017: Destroying Window Objects | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN017: Destroying Window Objects | Microsoft Docs","pos":[0,49]}]},{"content":"TN017: Destroying Window Objects","pos":[659,691]},{"content":"This note describes the use of the <bpt id=\"p1\">[</bpt>CWnd::PostNcDestroy<ept id=\"p1\">](../mfc/reference/cwnd-class.md#cwnd__postncdestroy)</ept> method.","pos":[692,808],"source":"This note describes the use of the [CWnd::PostNcDestroy](../mfc/reference/cwnd-class.md#cwnd__postncdestroy) method."},{"content":"Use this method if you want to do customized allocation of <ph id=\"ph1\">`CWnd`</ph>-derived objects.","pos":[809,891],"source":" Use this method if you want to do customized allocation of `CWnd`-derived objects."},{"content":"This note also explains why you should use <bpt id=\"p1\">[</bpt>CWnd::DestroyWindow<ept id=\"p1\">](../mfc/reference/cwnd-class.md#cwnd__destroywindow)</ept> to destroy a C++ Windows object instead of the <ph id=\"ph1\">`delete`</ph> operator.","pos":[892,1074],"source":" This note also explains why you should use [CWnd::DestroyWindow](../mfc/reference/cwnd-class.md#cwnd__destroywindow) to destroy a C++ Windows object instead of the `delete` operator."},{"content":"If you follow the guidelines in this topic, you will have few cleanup problems.","pos":[1081,1160]},{"content":"These problems can result from issues such as forgetting to delete/free C++ memory, forgetting to free system resources like <ph id=\"ph1\">`HWND`</ph>s, or freeing objects too many times.","pos":[1161,1329],"source":" These problems can result from issues such as forgetting to delete/free C++ memory, forgetting to free system resources like `HWND`s, or freeing objects too many times."},{"content":"The Problem","pos":[1338,1349]},{"content":"Each windows object (object of a class derived from <ph id=\"ph1\">`CWnd`</ph>) represents both a C++ object and an <ph id=\"ph2\">`HWND`</ph>.","pos":[1353,1456],"source":"Each windows object (object of a class derived from `CWnd`) represents both a C++ object and an `HWND`."},{"content":"C++ objects are allocated in the application's heap and <ph id=\"ph1\">`HWND`</ph>s are allocated in system resources by the window manager.","pos":[1457,1577],"source":" C++ objects are allocated in the application's heap and `HWND`s are allocated in system resources by the window manager."},{"content":"Because there are several ways to destroy a window object, we must provide a set of rules that prevent system resource or memory leaks.","pos":[1578,1713]},{"content":"These rules must also prevent objects and Windows handles from being destroyed more than one time.","pos":[1714,1812]},{"content":"Destroying Windows","pos":[1821,1839]},{"content":"The following are the two permitted ways to destroy a Windows object:","pos":[1843,1912]},{"pos":[1922,1987],"content":"Calling <ph id=\"ph1\">`CWnd::DestroyWindow`</ph> or the Windows API <ph id=\"ph2\">`DestroyWindow`</ph>.","source":"Calling `CWnd::DestroyWindow` or the Windows API `DestroyWindow`."},{"pos":[1997,2044],"content":"Explicitly deleting with the <ph id=\"ph1\">`delete`</ph> operator.","source":"Explicitly deleting with the `delete` operator."},{"content":"The first case is by far the most common.","pos":[2051,2092]},{"content":"This case applies even if your code does not call <ph id=\"ph1\">`DestroyWindow`</ph> directly.","pos":[2093,2168],"source":" This case applies even if your code does not call `DestroyWindow` directly."},{"content":"When the user directly closes a frame window, this action generates the <ph id=\"ph1\">`WM_CLOSE`</ph> message, and the default response to this message is to call <ph id=\"ph2\">`DestroyWindow.`</ph> When a parent window is destroyed, Windows calls <ph id=\"ph3\">`DestroyWindow`</ph> for all its children.","pos":[2169,2416],"source":" When the user directly closes a frame window, this action generates the `WM_CLOSE` message, and the default response to this message is to call `DestroyWindow.` When a parent window is destroyed, Windows calls `DestroyWindow` for all its children."},{"content":"The second case, the use of the <ph id=\"ph1\">`delete`</ph> operator on Windows objects, should be rare.","pos":[2423,2508],"source":"The second case, the use of the `delete` operator on Windows objects, should be rare."},{"content":"The following are some cases where using <ph id=\"ph1\">`delete`</ph> is the correct choice.","pos":[2509,2581],"source":" The following are some cases where using `delete` is the correct choice."},{"content":"Auto Cleanup with CWnd::PostNcDestroy","pos":[2590,2627]},{"content":"When the system destroys a Windows window, the last Windows message sent to the window is <ph id=\"ph1\">`WM_NCDESTROY`</ph>.","pos":[2631,2736],"source":"When the system destroys a Windows window, the last Windows message sent to the window is `WM_NCDESTROY`."},{"content":"The default <ph id=\"ph1\">`CWnd`</ph> handler for that message is <bpt id=\"p1\">[</bpt>CWnd::OnNcDestroy<ept id=\"p1\">](../mfc/reference/cwnd-class.md#cwnd__onncdestroy)</ept>.","pos":[2737,2854],"source":" The default `CWnd` handler for that message is [CWnd::OnNcDestroy](../mfc/reference/cwnd-class.md#cwnd__onncdestroy)."},{"content":"will detach the <ph id=\"ph1\">`HWND`</ph> from the C++ object and call the virtual function <ph id=\"ph2\">`PostNcDestroy`</ph>.","pos":[2869,2958],"source":" will detach the `HWND` from the C++ object and call the virtual function `PostNcDestroy`."},{"content":"Some classes override this function to delete the C++ object.","pos":[2959,3020]},{"content":"The default implementation of <ph id=\"ph1\">`CWnd::PostNcDestroy`</ph> does nothing, which is appropriate for window objects that are allocated on the stack frame or embedded in other objects.","pos":[3027,3200],"source":"The default implementation of `CWnd::PostNcDestroy` does nothing, which is appropriate for window objects that are allocated on the stack frame or embedded in other objects."},{"content":"This is not appropriate for window objects that are designed to be allocated on the heap without any other objects.","pos":[3201,3316]},{"content":"In other words, it is not appropriate for window objects that are not embedded in other C++ objects.","pos":[3317,3417]},{"content":"Those classes that are designed to be allocated alone on the heap override the <ph id=\"ph1\">`PostNcDestroy`</ph> method to perform a <ph id=\"ph2\">`delete this`</ph>.","pos":[3424,3553],"source":"Those classes that are designed to be allocated alone on the heap override the `PostNcDestroy` method to perform a `delete this`."},{"content":"This statement will free any memory associated with the C++ object.","pos":[3554,3621]},{"content":"Even though the default <ph id=\"ph1\">`CWnd`</ph> destructor calls <ph id=\"ph2\">`DestroyWindow`</ph> if <ph id=\"ph3\">`m_hWnd`</ph> is non-NULL, this does not lead to infinite recursion because the handle will be detached and NULL during the cleanup phase.","pos":[3622,3822],"source":" Even though the default `CWnd` destructor calls `DestroyWindow` if `m_hWnd` is non-NULL, this does not lead to infinite recursion because the handle will be detached and NULL during the cleanup phase."},{"pos":[3830,4228],"content":"[!NOTE]\n The system usually calls `CWnd::PostNcDestroy` after it processes the Windows `WM_NCDESTROY` message and the `HWND` and the C++ window object are no longer connected. The system will also call `CWnd::PostNcDestroy` in the implementation of most [CWnd::Create](../mfc/reference/cwnd-class.md#cwnd__create) calls if failure occurs. The auto cleanup rules are described later in this topic.","leadings":["","> "],"nodes":[{"content":" The system usually calls `CWnd::PostNcDestroy` after it processes the Windows `WM_NCDESTROY` message and the `HWND` and the C++ window object are no longer connected. The system will also call `CWnd::PostNcDestroy` in the implementation of most [CWnd::Create](../mfc/reference/cwnd-class.md#cwnd__create) calls if failure occurs. The auto cleanup rules are described later in this topic.","pos":[8,396],"nodes":[{"content":"The system usually calls <ph id=\"ph1\">`CWnd::PostNcDestroy`</ph> after it processes the Windows <ph id=\"ph2\">`WM_NCDESTROY`</ph> message and the <ph id=\"ph3\">`HWND`</ph> and the C++ window object are no longer connected.","pos":[1,167],"source":" The system usually calls `CWnd::PostNcDestroy` after it processes the Windows `WM_NCDESTROY` message and the `HWND` and the C++ window object are no longer connected."},{"content":"The system will also call <ph id=\"ph1\">`CWnd::PostNcDestroy`</ph> in the implementation of most <bpt id=\"p1\">[</bpt>CWnd::Create<ept id=\"p1\">](../mfc/reference/cwnd-class.md#cwnd__create)</ept> calls if failure occurs.","pos":[168,330],"source":" The system will also call `CWnd::PostNcDestroy` in the implementation of most [CWnd::Create](../mfc/reference/cwnd-class.md#cwnd__create) calls if failure occurs."},{"content":"The auto cleanup rules are described later in this topic.","pos":[331,388]}]}]},{"content":"Auto Cleanup Classes","pos":[4237,4257]},{"content":"The following classes are not designed for auto-cleanup.","pos":[4261,4317]},{"content":"They are typically embedded in other C++ objects or on the stack:","pos":[4318,4383]},{"pos":[4393,4467],"content":"All standard Windows controls (<ph id=\"ph1\">`CStatic`</ph>, <ph id=\"ph2\">`CEdit`</ph>, <ph id=\"ph3\">`CListBox`</ph>, and so on).","source":"All standard Windows controls (`CStatic`, `CEdit`, `CListBox`, and so on)."},{"pos":[4477,4555],"content":"Any child windows derived directly from <ph id=\"ph1\">`CWnd`</ph> (for example, custom controls).","source":"Any child windows derived directly from `CWnd` (for example, custom controls)."},{"pos":[4565,4599],"content":"Splitter windows (<ph id=\"ph1\">`CSplitterWnd`</ph>).","source":"Splitter windows (`CSplitterWnd`)."},{"pos":[4609,4771],"content":"Default control bars (classes derived from <ph id=\"ph1\">`CControlBar`</ph>, see <bpt id=\"p1\">[</bpt>Technical Note 31<ept id=\"p1\">](../mfc/tn031-control-bars.md)</ept> for enabling auto-delete for control bar objects).","source":"Default control bars (classes derived from `CControlBar`, see [Technical Note 31](../mfc/tn031-control-bars.md) for enabling auto-delete for control bar objects)."},{"pos":[4781,4847],"content":"Dialogs (<ph id=\"ph1\">`CDialog`</ph>) designed for modal dialogs on the stack frame.","source":"Dialogs (`CDialog`) designed for modal dialogs on the stack frame."},{"pos":[4857,4910],"content":"All the standard dialogs except <ph id=\"ph1\">`CFindReplaceDialog`</ph>.","source":"All the standard dialogs except `CFindReplaceDialog`."},{"content":"The default dialogs created by ClassWizard.","pos":[4920,4963]},{"content":"The following classes are designed for auto-cleanup.","pos":[4970,5022]},{"content":"They are typically allocated by themselves on the heap:","pos":[5023,5078]},{"pos":[5088,5157],"content":"Main frame windows (derived directly or indirectly from <ph id=\"ph1\">`CFrameWnd`</ph>).","source":"Main frame windows (derived directly or indirectly from `CFrameWnd`)."},{"pos":[5167,5226],"content":"View windows (derived directly or indirectly from <ph id=\"ph1\">`CView`</ph>).","source":"View windows (derived directly or indirectly from `CView`)."},{"content":"If you want to break these rules, you must override the <ph id=\"ph1\">`PostNcDestroy`</ph> method in your derived class.","pos":[5233,5334],"source":"If you want to break these rules, you must override the `PostNcDestroy` method in your derived class."},{"content":"To add auto-cleanup to your class, call your base class and then do a <ph id=\"ph1\">`delete this`</ph>.","pos":[5335,5419],"source":" To add auto-cleanup to your class, call your base class and then do a `delete this`."},{"content":"To remove auto-cleanup from your class, call <ph id=\"ph1\">`CWnd::PostNcDestroy`</ph> directly instead of the <ph id=\"ph2\">`PostNcDestroy`</ph> method of your direct base class.","pos":[5420,5560],"source":" To remove auto-cleanup from your class, call `CWnd::PostNcDestroy` directly instead of the `PostNcDestroy` method of your direct base class."},{"content":"The most common use of changing auto cleanup behavior is to create a modeless dialog that can be allocated on the heap.","pos":[5567,5686]},{"content":"When to Call delete","pos":[5695,5714]},{"pos":[5718,5846],"content":"We recommend that you call <ph id=\"ph1\">`DestroyWindow`</ph> to destroy a Windows object, either the C++ method or the global <ph id=\"ph2\">`DestroyWindow`</ph> API.","source":"We recommend that you call `DestroyWindow` to destroy a Windows object, either the C++ method or the global `DestroyWindow` API."},{"content":"Do not call the global <ph id=\"ph1\">`DestroyWindow`</ph> API to destroy a MDI Child window.","pos":[5853,5926],"source":"Do not call the global `DestroyWindow` API to destroy a MDI Child window."},{"content":"You should use the virtual method <ph id=\"ph1\">`CWnd::DestroyWindow`</ph> instead.","pos":[5927,5991],"source":" You should use the virtual method `CWnd::DestroyWindow` instead."},{"content":"For C++ Window objects that do not perform auto-cleanup, using the <ph id=\"ph1\">`delete`</ph> operator can cause a memory leak when you try to call <ph id=\"ph2\">`DestroyWindow`</ph> in the <ph id=\"ph3\">`CWnd::~CWnd`</ph> destructor if the VTBL does not point to the correctly derived class.","pos":[5998,6234],"source":"For C++ Window objects that do not perform auto-cleanup, using the `delete` operator can cause a memory leak when you try to call `DestroyWindow` in the `CWnd::~CWnd` destructor if the VTBL does not point to the correctly derived class."},{"content":"This occurs because the system cannot find the appropriate destroy method to call.","pos":[6235,6317]},{"content":"Using <ph id=\"ph1\">`DestroyWindow`</ph> instead of <ph id=\"ph2\">`delete`</ph> avoids these problems.","pos":[6318,6382],"source":" Using `DestroyWindow` instead of `delete` avoids these problems."},{"content":"Because this can be a subtle error, compiling in debug mode will generate the following warning if you are at risk.","pos":[6383,6498]},{"content":"In the case of C++ Windows objects that do perform auto-cleanup, you must call <ph id=\"ph1\">`DestroyWindow`</ph>.","pos":[6637,6732],"source":"In the case of C++ Windows objects that do perform auto-cleanup, you must call `DestroyWindow`."},{"content":"If you use the <ph id=\"ph1\">`delete`</ph> operator directly, the MFC diagnostic memory allocator will notify you that you are freeing memory two times.","pos":[6733,6866],"source":" If you use the `delete` operator directly, the MFC diagnostic memory allocator will notify you that you are freeing memory two times."},{"content":"The two occurrences are your first explicit call and the indirect call to <ph id=\"ph1\">`delete this`</ph> in the auto-cleanup implementation of <ph id=\"ph2\">`PostNcDestroy`</ph>.","pos":[6867,7009],"source":" The two occurrences are your first explicit call and the indirect call to `delete this` in the auto-cleanup implementation of `PostNcDestroy`."},{"content":"After calling <ph id=\"ph1\">`DestroyWindow`</ph> on a non-auto-cleanup object, the C++ object will still be around, but <ph id=\"ph2\">`m_hWnd`</ph> will be NULL.","pos":[7016,7139],"source":"After calling `DestroyWindow` on a non-auto-cleanup object, the C++ object will still be around, but `m_hWnd` will be NULL."},{"content":"After calling <ph id=\"ph1\">`DestroyWindow`</ph> on an auto-cleanup object, the C++ object will be gone, freed by the C++ delete operator in the auto-cleanup implementation of <ph id=\"ph2\">`PostNcDestroy`</ph>.","pos":[7140,7313],"source":" After calling `DestroyWindow` on an auto-cleanup object, the C++ object will be gone, freed by the C++ delete operator in the auto-cleanup implementation of `PostNcDestroy`."},{"content":"See Also","pos":[7322,7330]},{"content":"Technical Notes by Number","pos":[7335,7360]},{"content":"Technical Notes by Category","pos":[7404,7431]}],"content":"---\ntitle: \"TN017: Destroying Window Objects | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.objects\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"destroying windows\"\n  - \"TN017\"\n  - \"PostNcDestroy method\"\nms.assetid: 5bf208a5-5683-439b-92a1-547c5ded26cd\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN017: Destroying Window Objects\nThis note describes the use of the [CWnd::PostNcDestroy](../mfc/reference/cwnd-class.md#cwnd__postncdestroy) method. Use this method if you want to do customized allocation of `CWnd`-derived objects. This note also explains why you should use [CWnd::DestroyWindow](../mfc/reference/cwnd-class.md#cwnd__destroywindow) to destroy a C++ Windows object instead of the `delete` operator.  \n  \n If you follow the guidelines in this topic, you will have few cleanup problems. These problems can result from issues such as forgetting to delete/free C++ memory, forgetting to free system resources like `HWND`s, or freeing objects too many times.  \n  \n## The Problem  \n Each windows object (object of a class derived from `CWnd`) represents both a C++ object and an `HWND`. C++ objects are allocated in the application's heap and `HWND`s are allocated in system resources by the window manager. Because there are several ways to destroy a window object, we must provide a set of rules that prevent system resource or memory leaks. These rules must also prevent objects and Windows handles from being destroyed more than one time.  \n  \n## Destroying Windows  \n The following are the two permitted ways to destroy a Windows object:  \n  \n-   Calling `CWnd::DestroyWindow` or the Windows API `DestroyWindow`.  \n  \n-   Explicitly deleting with the `delete` operator.  \n  \n The first case is by far the most common. This case applies even if your code does not call `DestroyWindow` directly. When the user directly closes a frame window, this action generates the `WM_CLOSE` message, and the default response to this message is to call `DestroyWindow.` When a parent window is destroyed, Windows calls `DestroyWindow` for all its children.  \n  \n The second case, the use of the `delete` operator on Windows objects, should be rare. The following are some cases where using `delete` is the correct choice.  \n  \n## Auto Cleanup with CWnd::PostNcDestroy  \n When the system destroys a Windows window, the last Windows message sent to the window is `WM_NCDESTROY`. The default `CWnd` handler for that message is [CWnd::OnNcDestroy](../mfc/reference/cwnd-class.md#cwnd__onncdestroy). `OnNcDestroy` will detach the `HWND` from the C++ object and call the virtual function `PostNcDestroy`. Some classes override this function to delete the C++ object.  \n  \n The default implementation of `CWnd::PostNcDestroy` does nothing, which is appropriate for window objects that are allocated on the stack frame or embedded in other objects. This is not appropriate for window objects that are designed to be allocated on the heap without any other objects. In other words, it is not appropriate for window objects that are not embedded in other C++ objects.  \n  \n Those classes that are designed to be allocated alone on the heap override the `PostNcDestroy` method to perform a `delete this`. This statement will free any memory associated with the C++ object. Even though the default `CWnd` destructor calls `DestroyWindow` if `m_hWnd` is non-NULL, this does not lead to infinite recursion because the handle will be detached and NULL during the cleanup phase.  \n  \n> [!NOTE]\n>  The system usually calls `CWnd::PostNcDestroy` after it processes the Windows `WM_NCDESTROY` message and the `HWND` and the C++ window object are no longer connected. The system will also call `CWnd::PostNcDestroy` in the implementation of most [CWnd::Create](../mfc/reference/cwnd-class.md#cwnd__create) calls if failure occurs. The auto cleanup rules are described later in this topic.  \n  \n## Auto Cleanup Classes  \n The following classes are not designed for auto-cleanup. They are typically embedded in other C++ objects or on the stack:  \n  \n-   All standard Windows controls (`CStatic`, `CEdit`, `CListBox`, and so on).  \n  \n-   Any child windows derived directly from `CWnd` (for example, custom controls).  \n  \n-   Splitter windows (`CSplitterWnd`).  \n  \n-   Default control bars (classes derived from `CControlBar`, see [Technical Note 31](../mfc/tn031-control-bars.md) for enabling auto-delete for control bar objects).  \n  \n-   Dialogs (`CDialog`) designed for modal dialogs on the stack frame.  \n  \n-   All the standard dialogs except `CFindReplaceDialog`.  \n  \n-   The default dialogs created by ClassWizard.  \n  \n The following classes are designed for auto-cleanup. They are typically allocated by themselves on the heap:  \n  \n-   Main frame windows (derived directly or indirectly from `CFrameWnd`).  \n  \n-   View windows (derived directly or indirectly from `CView`).  \n  \n If you want to break these rules, you must override the `PostNcDestroy` method in your derived class. To add auto-cleanup to your class, call your base class and then do a `delete this`. To remove auto-cleanup from your class, call `CWnd::PostNcDestroy` directly instead of the `PostNcDestroy` method of your direct base class.  \n  \n The most common use of changing auto cleanup behavior is to create a modeless dialog that can be allocated on the heap.  \n  \n## When to Call delete  \n We recommend that you call `DestroyWindow` to destroy a Windows object, either the C++ method or the global `DestroyWindow` API.  \n  \n Do not call the global `DestroyWindow` API to destroy a MDI Child window. You should use the virtual method `CWnd::DestroyWindow` instead.  \n  \n For C++ Window objects that do not perform auto-cleanup, using the `delete` operator can cause a memory leak when you try to call `DestroyWindow` in the `CWnd::~CWnd` destructor if the VTBL does not point to the correctly derived class. This occurs because the system cannot find the appropriate destroy method to call. Using `DestroyWindow` instead of `delete` avoids these problems. Because this can be a subtle error, compiling in debug mode will generate the following warning if you are at risk.  \n  \n```  \nWarning: calling DestroyWindow in CWnd::~CWnd  \n    OnDestroy or PostNcDestroy in derived class will not be called  \n```  \n  \n In the case of C++ Windows objects that do perform auto-cleanup, you must call `DestroyWindow`. If you use the `delete` operator directly, the MFC diagnostic memory allocator will notify you that you are freeing memory two times. The two occurrences are your first explicit call and the indirect call to `delete this` in the auto-cleanup implementation of `PostNcDestroy`.  \n  \n After calling `DestroyWindow` on a non-auto-cleanup object, the C++ object will still be around, but `m_hWnd` will be NULL. After calling `DestroyWindow` on an auto-cleanup object, the C++ object will be gone, freed by the C++ delete operator in the auto-cleanup implementation of `PostNcDestroy`.  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}