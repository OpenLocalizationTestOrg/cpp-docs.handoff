<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4a523d93f1910c63f337e199bd2cfd519b442519</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\parallel\concrt\walkthrough-creating-a-custom-message-block.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">143e65e664277dd0989e70c123b47a15f2c347d5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9212e7dba2f8e7382a8a5eb65cf350b8442301fa</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Walkthrough: Creating a Custom Message Block | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Walkthrough: Creating a Custom Message Block</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This document describes how to create a custom message block type that orders incoming messages by priority.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Although the built-in message block types provide a wide-range of functionality, you can create your own message block type and customize it to meet the requirements of your application.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For a description of the built-in message block types that are provided by the Asynchronous Agents Library, see <bpt id="p1">[</bpt>Asynchronous Message Blocks<ept id="p1">](../../parallel/concrt/asynchronous-message-blocks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Read the following documents before you start this walkthrough:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Asynchronous Message Blocks</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Message Passing Functions</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Sections</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This walkthrough contains the following sections:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Designing a Custom Message Block</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Defining the priority_buffer Class</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The Complete Example</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Designing a Custom Message Block</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Message blocks participate in the act of sending and receiving messages.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A message block that sends messages is known as a <bpt id="p1">*</bpt>source block<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A message block that receives messages is known as a <bpt id="p1">*</bpt>target block<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>A message block that both sends and receives messages is known as a <bpt id="p1">*</bpt>propagator block<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The Agents Library uses the abstract class <bpt id="p1">[</bpt>concurrency::ISource<ept id="p1">](../../parallel/concrt/reference/isource-class.md)</ept> to represent source blocks and the abstract class <bpt id="p2">[</bpt>concurrency::ITarget<ept id="p2">](../../parallel/concrt/reference/itarget-class.md)</ept> to represent target blocks.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Message block types that act as sources derive from <ph id="ph1">`ISource`</ph>; message block types that act as targets derive from <ph id="ph2">`ITarget`</ph>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Although you can derive your message block type directly from <ph id="ph1">`ISource`</ph> and <ph id="ph2">`ITarget`</ph>, the Agents Library defines three base classes that perform much of the functionality that is common to all message block types, for example, handling errors and connecting message blocks together in a concurrency-safe manner.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>concurrency::source_block<ept id="p1">](../../parallel/concrt/reference/source-block-class.md)</ept> class derives from <ph id="ph1">`ISource`</ph> and sends messages to other blocks.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>concurrency::target_block<ept id="p1">](../../parallel/concrt/reference/target-block-class.md)</ept> class derives from <ph id="ph1">`ITarget`</ph> and receives messages from other blocks.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>concurrency::propagator_block<ept id="p1">](../../parallel/concrt/reference/propagator-block-class.md)</ept> class derives from <ph id="ph1">`ISource`</ph> and <ph id="ph2">`ITarget`</ph> and sends messages to other blocks and it receives messages from other blocks.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>We recommend that you use these three base classes to handle infrastructure details so that you can focus on the behavior of your message block.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`source_block`</ph>, <ph id="ph2">`target_block`</ph>, and <ph id="ph3">`propagator_block`</ph> classes are templates that are parameterized on a type that manages the connections, or links, between source and target blocks and on a type that manages how messages are processed.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The Agents Library defines two types that perform link management, <bpt id="p1">[</bpt>concurrency::single_link_registry<ept id="p1">](../../parallel/concrt/reference/single-link-registry-class.md)</ept> and <bpt id="p2">[</bpt>concurrency::multi_link_registry<ept id="p2">](../../parallel/concrt/reference/multi-link-registry-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`single_link_registry`</ph> class enables a message block to be linked to one source or to one target.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`multi_link_registry`</ph> class enables a message block to be linked to multiple sources or multiple targets.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The Agents Library defines one class that performs message management, <bpt id="p1">[</bpt>concurrency::ordered_message_processor<ept id="p1">](../../parallel/concrt/reference/ordered-message-processor-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ordered_message_processor`</ph> class enables message blocks to process messages in the order in which it receives them.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>To better understand how message blocks relate to their sources and targets, consider the following example.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This example shows the declaration of the <bpt id="p1">[</bpt>concurrency::transformer<ept id="p1">](../../parallel/concrt/reference/transformer-class.md)</ept> class.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#20</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`transformer`</ph> class derives from <ph id="ph2">`propagator_block`</ph>, and therefore acts as both a source block and as a target block.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>It accepts messages of type <ph id="ph1">`_Input`</ph> and sends messages of type <ph id="ph2">`_Output`</ph>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`transformer`</ph> class specifies <ph id="ph2">`single_link_registry`</ph> as the link manager for any target blocks and <ph id="ph3">`multi_link_registry`</ph> as the link manager for any source blocks.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Therefore, a <ph id="ph1">`transformer`</ph> object can have up to one target and an unlimited number of sources.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A class that derives from <ph id="ph1">`source_block`</ph> must implement six methods: <bpt id="p1">[</bpt>propagate_to_any_targets<ept id="p1">](reference/source-block-class.md#propagate_to_any_targets)</ept>, <bpt id="p2">[</bpt>accept_message<ept id="p2">](reference/source-block-class.md#accept_message)</ept>, <bpt id="p3">[</bpt>reserve_message<ept id="p3">](reference/source-block-class.md#reserve_message)</ept>, <bpt id="p4">[</bpt>consume_message<ept id="p4">](reference/source-block-class.md#consume_message)</ept>, <bpt id="p5">[</bpt>release_message<ept id="p5">](reference/source-block-class.md#release_message)</ept>, and <bpt id="p6">[</bpt>resume_propagation<ept id="p6">](reference/source-block-class.md#resume_propagation)</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A class that derives from <ph id="ph1">`target_block`</ph> must implement the <bpt id="p1">[</bpt>propagate_message<ept id="p1">](reference/propagator-block-class.md#propagate_message)</ept> method and can optionally implement the <bpt id="p2">[</bpt>send_message<ept id="p2">](reference/propagator-block-class.md#send_message)</ept> method.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Deriving from <ph id="ph1">`propagator_block`</ph> is functionally equivalent to deriving from both <ph id="ph2">`source_block`</ph> and <ph id="ph3">`target_block`</ph>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`propagate_to_any_targets`</ph> method is called by the runtime to asynchronously or synchronously process any incoming messages and propagate out any outgoing messages.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`accept_message`</ph> method is called by target blocks to accept messages.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Many message block types, such as <ph id="ph1">`unbounded_buffer`</ph>, send messages only to the first target that would receive it.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Therefore, it transfers ownership of the message to the target.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Other message block types, such as <bpt id="p1">[</bpt>concurrency::overwrite_buffer<ept id="p1">](../../parallel/concrt/reference/overwrite-buffer-class.md)</ept>, offer messages to each of its target blocks.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Therefore, <ph id="ph1">`overwrite_buffer`</ph> creates a copy of the message for each of its targets.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`reserve_message`</ph>, <ph id="ph2">`consume_message`</ph>, <ph id="ph3">`release_message`</ph>, and <ph id="ph4">`resume_propagation`</ph> methods enable message blocks to participate in message reservation.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Target blocks call the <ph id="ph1">`reserve_message`</ph> method when they are offered a message and have to reserve the message for later use.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>After a target block reserves a message, it can call the <ph id="ph1">`consume_message`</ph> method to consume that message or the <ph id="ph2">`release_message`</ph> method to cancel the reservation.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>As with the <ph id="ph1">`accept_message`</ph> method, the implementation of <ph id="ph2">`consume_message`</ph> can either transfer ownership of the message or return a copy of the message.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>After a target block either consumes or releases a reserved message, the runtime calls the <ph id="ph1">`resume_propagation`</ph> method.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Typically, this method continues message propagation, starting with the next message in the queue.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The runtime calls the <ph id="ph1">`propagate_message`</ph> method to asynchronously transfer a message from another block to the current one.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`send_message`</ph> method resembles <ph id="ph2">`propagate_message`</ph>, except that it synchronously, instead of asynchronously, sends the message to the target blocks.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The default implementation of <ph id="ph1">`send_message`</ph> rejects all incoming messages.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The runtime does not call either of these methods if the message does not pass the optional filter function that is associated with the target block.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For more information about message filters, see <bpt id="p1">[</bpt>Asynchronous Message Blocks<ept id="p1">](../../parallel/concrt/asynchronous-message-blocks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Defining the priority_buffer Class</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class is a custom message block type that orders incoming messages first by priority, and then by the order in which messages are received.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class resembles the <bpt id="p1">[</bpt>concurrency::unbounded_buffer<ept id="p1">](reference/unbounded-buffer-class.md)</ept> class because it holds a queue of messages, and also because it acts as both a source and a target message block and can have both multiple sources and multiple targets.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">`unbounded_buffer`</ph> bases message propagation only on the order in which it receives messages from its sources.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class receives messages of type std::<bpt id="p1">[</bpt>tuple<ept id="p1">](../../standard-library/tuple-class.md)</ept> that contain <ph id="ph2">`PriorityType`</ph> and <ph id="ph3">`Type`</ph> elements.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>refers to the type that holds the priority of each message; <ph id="ph1">`Type`</ph> refers to the data portion of the message.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class sends messages of type <ph id="ph2">`Type`</ph>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class also manages two message queues: a <bpt id="p1">[</bpt>std::priority_queue<ept id="p1">](../../standard-library/priority-queue-class.md)</ept> object for incoming messages and a std::<bpt id="p2">[</bpt>queue<ept id="p2">](../../standard-library/queue-class.md)</ept> object for outgoing messages.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Ordering messages by priority is useful when a <ph id="ph1">`priority_buffer`</ph> object receives multiple messages simultaneously or when it receives multiple messages before any messages are read by consumers.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In addition to the seven methods that a class that derives from <ph id="ph1">`propagator_block`</ph> must implement, the <ph id="ph2">`priority_buffer`</ph> class also overrides the <ph id="ph3">`link_target_notification`</ph> and <ph id="ph4">`send_message`</ph> methods.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class also defines two public helper methods, <ph id="ph2">`enqueue`</ph> and <ph id="ph3">`dequeue`</ph>, and a private helper method, <ph id="ph4">`propagate_priority_order`</ph>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following procedure describes how to implement the <ph id="ph1">`priority_buffer`</ph> class.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>To define the priority_buffer class</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Create a C++ header file and name it <ph id="ph1">`priority_buffer.h`</ph>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use an existing header file that is part of your project.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`priority_buffer.h`</ph>, add the following code.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#1</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`std`</ph> namespace, define specializations of <bpt id="p1">[</bpt>std::less<ept id="p1">](../../standard-library/less-struct.md)</ept> and <bpt id="p2">[</bpt>std::greater<ept id="p2">](../../standard-library/greater-struct.md)</ept> that act on concurrency::<bpt id="p3">[</bpt>message<ept id="p3">](../../parallel/concrt/reference/message-class.md)</ept> objects.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#2</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class stores <ph id="ph2">`message`</ph> objects in a <ph id="ph3">`priority_queue`</ph> object.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>These type specializations enable the priority queue to sort messages according to their priority.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The priority is the first element of the <ph id="ph1">`tuple`</ph> object.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`concurrencyex`</ph> namespace, declare the <ph id="ph2">`priority_buffer`</ph> class.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#3</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class derives from <ph id="ph2">`propagator_block`</ph>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Therefore, it can both send and receive messages.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class can have multiple targets that receive messages of type <ph id="ph2">`Type`</ph>.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>It can also have multiple sources that send messages of type <ph id="ph1">`tuple&lt;PriorityType, Type&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`private`</ph> section of the <ph id="ph2">`priority_buffer`</ph> class, add the following member variables.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#6</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_queue`</ph> object holds incoming messages; the <ph id="ph2">`queue`</ph> object holds outgoing messages.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`priority_buffer`</ph> object can receive multiple messages simultaneously; the <ph id="ph2">`critical_section`</ph> object synchronizes access to the queue of input messages.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`private`</ph> section, define the copy constructor and the assignment operator.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>This prevents <ph id="ph1">`priority_queue`</ph> objects from being assignable.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#7</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`public`</ph> section, define the constructors that are common to many message block types.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Also define the destructor.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#4</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`public`</ph> section, define the methods <ph id="ph2">`enqueue`</ph> and <ph id="ph3">`dequeue`</ph>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>These helper methods provide an alternative way to send messages to and receive messages from a <ph id="ph1">`priority_buffer`</ph> object.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#5</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`protected`</ph> section, define the <ph id="ph2">`propagate_to_any_targets`</ph> method.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#9</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`propagate_to_any_targets`</ph> method transfers the message that is at the front of the input queue to the output queue and propagates out all messages in the output queue.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`protected`</ph> section, define the <ph id="ph2">`accept_message`</ph> method.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#8</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>When a target block calls the <ph id="ph1">`accept_message`</ph> method, the <ph id="ph2">`priority_buffer`</ph> class transfers ownership of the message to the first target block that accepts it.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>(This resembles the behavior of <ph id="ph1">`unbounded_buffer`</ph>.)</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`protected`</ph> section, define the <ph id="ph2">`reserve_message`</ph> method.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#10</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class permits a target block to reserve a message when the provided message identifier matches the identifier of the message that is at the front of the queue.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In other words, a target can reserve the message if the <ph id="ph1">`priority_buffer`</ph> object has not yet received an additional message and has not yet  propagated out the current one.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`protected`</ph> section, define the <ph id="ph2">`consume_message`</ph> method.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#11</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>A target block calls <ph id="ph1">`consume_message`</ph> to transfer ownership of the message that it reserved.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`protected`</ph> section, define the <ph id="ph2">`release_message`</ph> method.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#12</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A target block calls <ph id="ph1">`release_message`</ph> to cancel its reservation to a message.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`protected`</ph> section, define the <ph id="ph2">`resume_propagation`</ph> method.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#13</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The runtime calls <ph id="ph1">`resume_propagation`</ph> after a target block either consumes or releases a reserved message.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This method propagates out any messages that are in the output queue.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`protected`</ph> section, define the <ph id="ph2">`link_target_notification`</ph> method.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#14</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`_M_pReservedFor`</ph> member variable is defined by the base class, <ph id="ph2">`source_block`</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>This member variable points to the target block, if any, that is holding a reservation to the message that is at the front of the output queue.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The runtime calls <ph id="ph1">`link_target_notification`</ph> when a new target is linked to the <ph id="ph2">`priority_buffer`</ph> object.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This method propagates out any messages that are in the output queue if no target is holding a reservation.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`private`</ph> section, define the <ph id="ph2">`propagate_priority_order`</ph> method.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#15</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This method propagates out all messages from the output queue.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Every message in the queue is offered to every target block until one of the target blocks accepts the message.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class preserves the order of the outgoing messages.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Therefore, the first message in the output queue must be accepted by a target block before this method offers any other message to the target blocks.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`protected`</ph> section, define the <ph id="ph2">`propagate_message`</ph> method.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#16</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`propagate_message`</ph> method enables the <ph id="ph2">`priority_buffer`</ph> class to act as a message receiver, or target.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This method receives the message that is offered by the provided source block and inserts that message into the priority queue.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`propagate_message`</ph> method then asynchronously sends all output messages to the target blocks.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The runtime calls this method when you call the <bpt id="p1">[</bpt>concurrency::asend<ept id="p1">](reference/concurrency-namespace-functions.md#asend)</ept> function or when the message block is connected to other message blocks.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`protected`</ph> section, define the <ph id="ph2">`send_message`</ph> method.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#17</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`send_message`</ph> method resembles <ph id="ph2">`propagate_message`</ph>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>However it sends the output messages synchronously instead of asynchronously.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The runtime calls this method during a synchronous send operation, such as when you call the <bpt id="p1">[</bpt>concurrency::send<ept id="p1">](reference/concurrency-namespace-functions.md#send)</ept> function.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class contains constructor overloads that are typical in many message block types.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Some constructor overloads take <bpt id="p1">[</bpt>concurrency::Scheduler<ept id="p1">](../../parallel/concrt/reference/scheduler-class.md)</ept> or <bpt id="p2">[</bpt>concurrency::ScheduleGroup<ept id="p2">](../../parallel/concrt/reference/schedulegroup-class.md)</ept> objects, which enable the message block to be managed by a specific task scheduler.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Other constructor overloads take a filter function.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Filter functions enable message blocks to accept or reject a message on the basis of its payload.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>For more information about message filters, see <bpt id="p1">[</bpt>Asynchronous Message Blocks<ept id="p1">](../../parallel/concrt/asynchronous-message-blocks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>For more information about task schedulers, see <bpt id="p1">[</bpt>Task Scheduler<ept id="p1">](../../parallel/concrt/task-scheduler-concurrency-runtime.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`priority_buffer`</ph> class orders messages by priority and then by the order in which messages are received, this class is most useful when it receives messages asynchronously, for example, when you call the <bpt id="p1">[</bpt>concurrency::asend<ept id="p1">](reference/concurrency-namespace-functions.md#asend)</ept> function or when the message block is connected to other message blocks.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The Complete Example</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The following example shows the complete definition of the <ph id="ph1">`priority_buffer`</ph> class.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#18</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The following example concurrently performs a number of <ph id="ph1">`asend`</ph> and <bpt id="p1">[</bpt>concurrency::receive<ept id="p1">](reference/concurrency-namespace-functions.md#receive)</ept> operations on a <ph id="ph2">`priority_buffer`</ph> object.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>concrt-priority-buffer#19</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>This example produces the following sample output.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`priority_buffer`</ph> class orders messages first by priority and then by the order in which it receives messages.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>In this example, messages with greater numerical priority are inserted towards the front of the queue.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>[<bpt id="p1">[</bpt>Top<ept id="p1">](#top)</ept>]</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Compiling the Code</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Copy the example code and paste it in a Visual Studio project, or paste the definition of the <ph id="ph1">`priority_buffer`</ph> class in a file that is named <ph id="ph2">`priority_buffer.h`</ph> and the test program in a file that is named <ph id="ph3">`priority_buffer.cpp`</ph> and then run the following command in a Visual Studio Command Prompt window.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>cl.exe /EHsc priority_buffer.cpp</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Concurrency Runtime Walkthroughs</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Asynchronous Message Blocks</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Message Passing Functions</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>