{"nodes":[{"pos":[12,53],"content":"Basic CString Operations | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Basic CString Operations | Microsoft Docs","pos":[0,41]}]},{"content":"Basic CString Operations","pos":[788,812]},{"pos":[813,921],"content":"This topic explains the following basic <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../atl-mfc-shared/reference/cstringt-class.md)</ept> operations:","source":"This topic explains the following basic [CString](../atl-mfc-shared/reference/cstringt-class.md) operations:"},{"content":"Creating CString objects from standard C literal strings","pos":[930,986]},{"content":"Accessing individual characters in a CString","pos":[1061,1105]},{"content":"Concatenating two CString objects","pos":[1168,1201]},{"content":"Comparing CString objects","pos":[1253,1278]},{"content":"Converting CString objects","pos":[1322,1348]},{"content":"is based on class template <bpt id=\"p1\">[</bpt>CStringT Class<ept id=\"p1\">](../atl-mfc-shared/reference/cstringt-class.md)</ept>.","pos":[1407,1498],"source":" is based on class template [CStringT Class](../atl-mfc-shared/reference/cstringt-class.md)."},{"content":"is a <ph id=\"ph1\">`typedef`</ph> of <ph id=\"ph2\">`CStringT`</ph>.","pos":[1509,1538],"source":" is a `typedef` of `CStringT`."},{"content":"More exactly, <ph id=\"ph1\">`CString`</ph> is a <ph id=\"ph2\">`typedef`</ph> of an <bpt id=\"p1\">*</bpt>explicit specialization<ept id=\"p1\">*</ept> of <ph id=\"ph3\">`CStringT`</ph>, which is a common way to use a class template to define a class.","pos":[1539,1689],"source":" More exactly, `CString` is a `typedef` of an *explicit specialization* of `CStringT`, which is a common way to use a class template to define a class."},{"content":"Similarly defined classes are <ph id=\"ph1\">`CStringA`</ph> and <ph id=\"ph2\">`CStringW`</ph>.","pos":[1690,1746],"source":" Similarly defined classes are `CStringA` and `CStringW`."},{"content":", <ph id=\"ph1\">`CStringA`</ph>, and <ph id=\"ph2\">`CStringW`</ph> are defined in atlstr.h.","pos":[1762,1815],"source":", `CStringA`, and `CStringW` are defined in atlstr.h."},{"content":"is defined in cstringt.h.","pos":[1827,1852]},{"content":", <ph id=\"ph1\">`CStringA`</ph>, and <ph id=\"ph2\">`CStringW`</ph> each get a set of the methods and operators defined by <ph id=\"ph3\">`CStringT`</ph> for use with the string data they support.","pos":[1868,2005],"source":", `CStringA`, and `CStringW` each get a set of the methods and operators defined by `CStringT` for use with the string data they support."},{"content":"Some of the methods duplicate and, in some cases, surpass the string services of the C run-time libraries.","pos":[2006,2112]},{"content":"Note: <ph id=\"ph1\">`CString`</ph> is a native class.","pos":[2119,2153],"source":"Note: `CString` is a native class."},{"content":"For a string class that is for use in a C++/CLI managed project, use <ph id=\"ph1\">`System.String`</ph>.","pos":[2154,2239],"source":" For a string class that is for use in a C++/CLI managed project, use `System.String`."},{"pos":[2327,2383],"content":"Creating CString Objects from Standard C Literal Strings"},{"pos":[2387,2496],"content":"You can assign C-style literal strings to a <ph id=\"ph1\">`CString`</ph> just as you can assign one <ph id=\"ph2\">`CString`</ph> object to another.","source":"You can assign C-style literal strings to a `CString` just as you can assign one `CString` object to another."},{"pos":[2506,2567],"content":"Assign the value of a C literal string to a <ph id=\"ph1\">`CString`</ph> object.","source":"Assign the value of a C literal string to a `CString` object."},{"pos":[2585,2609],"content":"NVC_ATLMFC_Utilities#183"},{"pos":[2687,2749],"content":"Assign the value of one <ph id=\"ph1\">`CString`</ph> to another <ph id=\"ph2\">`CString`</ph> object.","source":"Assign the value of one `CString` to another `CString` object."},{"pos":[2767,2791],"content":"NVC_ATLMFC_Utilities#184"},{"content":"The contents of a <ph id=\"ph1\">`CString`</ph> object are copied when one <ph id=\"ph2\">`CString`</ph> object is assigned to another.","pos":[2870,2965],"source":"The contents of a `CString` object are copied when one `CString` object is assigned to another."},{"content":"Therefore, the two strings do not share a reference to the actual characters that make up the string.","pos":[2966,3067]},{"content":"For more information about how to use <ph id=\"ph1\">`CString`</ph> objects as values, see <bpt id=\"p1\">[</bpt>CString Semantics<ept id=\"p1\">](../atl-mfc-shared/cstring-semantics.md)</ept>.","pos":[3068,3199],"source":" For more information about how to use `CString` objects as values, see [CString Semantics](../atl-mfc-shared/cstring-semantics.md)."},{"pos":[3211,3498],"content":"[!NOTE]\n To write your application so that it can be compiled for Unicode or for ANSI, code literal strings by using the _T macro. For more information, see [Unicode and Multibyte Character Set (MBCS) Support](../atl-mfc-shared/unicode-and-multibyte-character-set-mbcs-support.md).","leadings":["","    > "],"nodes":[{"content":" To write your application so that it can be compiled for Unicode or for ANSI, code literal strings by using the _T macro. For more information, see [Unicode and Multibyte Character Set (MBCS) Support](../atl-mfc-shared/unicode-and-multibyte-character-set-mbcs-support.md).","pos":[8,281],"nodes":[{"content":"To write your application so that it can be compiled for Unicode or for ANSI, code literal strings by using the _T macro.","pos":[1,122]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Unicode and Multibyte Character Set (MBCS) Support<ept id=\"p1\">](../atl-mfc-shared/unicode-and-multibyte-character-set-mbcs-support.md)</ept>.","pos":[123,273],"source":" For more information, see [Unicode and Multibyte Character Set (MBCS) Support](../atl-mfc-shared/unicode-and-multibyte-character-set-mbcs-support.md)."}]}]},{"pos":[3574,3618],"content":"Accessing Individual Characters in a CString"},{"content":"You can access individual characters in a <ph id=\"ph1\">`CString`</ph> object by using the <ph id=\"ph2\">`GetAt`</ph> and <ph id=\"ph3\">`SetAt`</ph> methods.","pos":[3622,3722],"source":"You can access individual characters in a `CString` object by using the `GetAt` and `SetAt` methods."},{"content":"You can also use the array element, or subscript, operator ( [ ] ) instead of <ph id=\"ph1\">`GetAt`</ph> to get individual characters.","pos":[3723,3838],"source":" You can also use the array element, or subscript, operator ( [ ] ) instead of `GetAt` to get individual characters."},{"content":"(This resembles accessing array elements by index, as in standard C-style strings.) Index values for <ph id=\"ph1\">`CString`</ph> characters are zero-based.","pos":[3839,3976],"source":" (This resembles accessing array elements by index, as in standard C-style strings.) Index values for `CString` characters are zero-based."},{"pos":[4041,4074],"content":"Concatenating Two CString Objects"},{"pos":[4078,4170],"content":"To concatenate two <ph id=\"ph1\">`CString`</ph> objects, use the concatenation operators (+ or +=), as follows.","source":"To concatenate two `CString` objects, use the concatenation operators (+ or +=), as follows."},{"pos":[4188,4212],"content":"NVC_ATLMFC_Utilities#185"},{"pos":[4287,4499],"content":"At least one argument to the concatenation operators (+ or +=) must be a <ph id=\"ph1\">`CString`</ph> object, but you can use a constant character string (for example, <ph id=\"ph2\">`\"big\"`</ph>) or a <ph id=\"ph3\">`char`</ph> (for example, 'x') for the other argument.","source":"At least one argument to the concatenation operators (+ or +=) must be a `CString` object, but you can use a constant character string (for example, `\"big\"`) or a `char` (for example, 'x') for the other argument."},{"pos":[4556,4581],"content":"Comparing CString Objects"},{"content":"The <ph id=\"ph1\">`Compare`</ph> method and the == operator for <ph id=\"ph2\">`CString`</ph> are equivalent.","pos":[4585,4655],"source":"The `Compare` method and the == operator for `CString` are equivalent."},{"content":", <ph id=\"ph1\">`operator==`</ph>, and <ph id=\"ph2\">`CompareNoCase`</ph> are MBCS and Unicode aware; <ph id=\"ph3\">`CompareNoCase`</ph> is also case-insensitive.","pos":[4665,4770],"source":", `operator==`, and `CompareNoCase` are MBCS and Unicode aware; `CompareNoCase` is also case-insensitive."},{"content":"The <ph id=\"ph1\">`Collate`</ph> method of <ph id=\"ph2\">`CString`</ph> is locale-sensitive and is often slower than <ph id=\"ph3\">`Compare`</ph>.","pos":[4771,4860],"source":" The `Collate` method of `CString` is locale-sensitive and is often slower than `Compare`."},{"content":"Use <ph id=\"ph1\">`Collate`</ph> only where you must abide by the sorting rules as specified by the current locale.","pos":[4861,4957],"source":" Use `Collate` only where you must abide by the sorting rules as specified by the current locale."},{"pos":[4964,5161],"content":"The following table shows the available <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../atl-mfc-shared/reference/cstringt-class.md)</ept> comparison functions and their equivalent Unicode/MBCS-portable functions in the C run-time library.","source":"The following table shows the available [CString](../atl-mfc-shared/reference/cstringt-class.md) comparison functions and their equivalent Unicode/MBCS-portable functions in the C run-time library."},{"content":"CString function","pos":[5168,5184]},{"content":"MBCS function","pos":[5185,5198]},{"content":"Unicode function","pos":[5199,5215]},{"content":"The <ph id=\"ph1\">`CStringT`</ph> class template defines the relational operators (&lt;, <ph id=\"ph2\">\\&lt;</ph>=, &gt;=, &gt;, ==, and !=), which are available for use by <ph id=\"ph3\">`CString`</ph>.","pos":[5403,5536],"source":"The `CStringT` class template defines the relational operators (<, \\<=, >=, >, ==, and !=), which are available for use by `CString`."},{"content":"You can compare two <ph id=\"ph1\">`CStrings`</ph> by using these operators, as shown in the following example.","pos":[5537,5628],"source":" You can compare two `CStrings` by using these operators, as shown in the following example."},{"pos":[5646,5670],"content":"NVC_ATLMFC_Utilities#186"},{"pos":[5796,5822],"content":"Converting CString Objects"},{"pos":[5826,6005],"content":"For information about converting CString objects to other string types, see <bpt id=\"p1\">[</bpt>How to: Convert Between Various String Types<ept id=\"p1\">](../text/how-to-convert-between-various-string-types.md)</ept>.","source":"For information about converting CString objects to other string types, see [How to: Convert Between Various String Types](../text/how-to-convert-between-various-string-types.md)."},{"content":"Using CString with wcout","pos":[6014,6038]},{"pos":[6042,6164],"content":"To use a CString with <ph id=\"ph1\">`wcout`</ph> you must explicitly cast the object to a <ph id=\"ph2\">`const wchar_t*`</ph> as shown in the following example:","source":"To use a CString with `wcout` you must explicitly cast the object to a `const wchar_t*` as shown in the following example:"},{"content":"Without the cast, <ph id=\"ph1\">`cs`</ph> is treated as a <ph id=\"ph2\">`void*`</ph> and <ph id=\"ph3\">`wcout`</ph> prints the address of the object.","pos":[6251,6343],"source":"Without the cast, `cs` is treated as a `void*` and `wcout` prints the address of the object."},{"content":"This behavior is caused by subtle interactions between template argument deduction and overload resolution which are in themselves correct and conformant with the C++ standard.","pos":[6344,6520]},{"content":"See Also","pos":[6529,6537]},{"content":"Strings (ATL/MFC)","pos":[6542,6559]},{"content":"CStringT Class","pos":[6604,6618]},{"content":"Template Specialization","pos":[6672,6695]},{"content":"How to: Convert Between Various String Types","pos":[6741,6785]}],"content":"---\ntitle: \"Basic CString Operations | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CString objects, basic operations\"\n  - \"string literals, CString operations\"\n  - \"literal strings, CString operations\"\n  - \"CString objects\"\n  - \"string comparison, CString operations\"\n  - \"characters, accessing in CStrings\"\nms.assetid: 41db66b2-9427-4bb3-845a-9b6869159a6c\ncaps.latest.revision: 17\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Basic CString Operations\nThis topic explains the following basic [CString](../atl-mfc-shared/reference/cstringt-class.md) operations:  \n  \n- [Creating CString objects from standard C literal strings](#_core_creating_cstring_objects_from_standard_c_literal_strings)  \n  \n- [Accessing individual characters in a CString](#_core_accessing_individual_characters_in_a_cstring)  \n  \n- [Concatenating two CString objects](#_core_concatenating_two_cstring_objects)  \n  \n- [Comparing CString objects](#_core_comparing_cstring_objects)  \n  \n- [Converting CString objects](#_core_converting_cstring_objects)  \n  \n `Class CString` is based on class template [CStringT Class](../atl-mfc-shared/reference/cstringt-class.md). `CString` is a `typedef` of `CStringT`. More exactly, `CString` is a `typedef` of an *explicit specialization* of `CStringT`, which is a common way to use a class template to define a class. Similarly defined classes are `CStringA` and `CStringW`.  \n  \n `CString`, `CStringA`, and `CStringW` are defined in atlstr.h. `CStringT` is defined in cstringt.h.  \n  \n `CString`, `CStringA`, and `CStringW` each get a set of the methods and operators defined by `CStringT` for use with the string data they support. Some of the methods duplicate and, in some cases, surpass the string services of the C run-time libraries.  \n  \n Note: `CString` is a native class. For a string class that is for use in a C++/CLI managed project, use `System.String`.  \n  \n##  <a name=\"_core_creating_cstring_objects_from_standard_c_literal_strings\"></a> Creating CString Objects from Standard C Literal Strings  \n You can assign C-style literal strings to a `CString` just as you can assign one `CString` object to another.  \n  \n-   Assign the value of a C literal string to a `CString` object.  \n  \n [!code-cpp[NVC_ATLMFC_Utilities#183](../atl-mfc-shared/codesnippet/cpp/basic-cstring-operations_1.cpp)]  \n  \n-   Assign the value of one `CString` to another `CString` object.  \n  \n [!code-cpp[NVC_ATLMFC_Utilities#184](../atl-mfc-shared/codesnippet/cpp/basic-cstring-operations_2.cpp)]  \n  \n     The contents of a `CString` object are copied when one `CString` object is assigned to another. Therefore, the two strings do not share a reference to the actual characters that make up the string. For more information about how to use `CString` objects as values, see [CString Semantics](../atl-mfc-shared/cstring-semantics.md).  \n  \n    > [!NOTE]\n    >  To write your application so that it can be compiled for Unicode or for ANSI, code literal strings by using the _T macro. For more information, see [Unicode and Multibyte Character Set (MBCS) Support](../atl-mfc-shared/unicode-and-multibyte-character-set-mbcs-support.md).  \n  \n##  <a name=\"_core_accessing_individual_characters_in_a_cstring\"></a> Accessing Individual Characters in a CString  \n You can access individual characters in a `CString` object by using the `GetAt` and `SetAt` methods. You can also use the array element, or subscript, operator ( [ ] ) instead of `GetAt` to get individual characters. (This resembles accessing array elements by index, as in standard C-style strings.) Index values for `CString` characters are zero-based.  \n  \n##  <a name=\"_core_concatenating_two_cstring_objects\"></a> Concatenating Two CString Objects  \n To concatenate two `CString` objects, use the concatenation operators (+ or +=), as follows.  \n  \n [!code-cpp[NVC_ATLMFC_Utilities#185](../atl-mfc-shared/codesnippet/cpp/basic-cstring-operations_3.cpp)]  \n  \n At least one argument to the concatenation operators (+ or +=) must be a `CString` object, but you can use a constant character string (for example, `\"big\"`) or a `char` (for example, 'x') for the other argument.  \n  \n##  <a name=\"_core_comparing_cstring_objects\"></a> Comparing CString Objects  \n The `Compare` method and the == operator for `CString` are equivalent. `Compare`, `operator==`, and `CompareNoCase` are MBCS and Unicode aware; `CompareNoCase` is also case-insensitive. The `Collate` method of `CString` is locale-sensitive and is often slower than `Compare`. Use `Collate` only where you must abide by the sorting rules as specified by the current locale.  \n  \n The following table shows the available [CString](../atl-mfc-shared/reference/cstringt-class.md) comparison functions and their equivalent Unicode/MBCS-portable functions in the C run-time library.  \n  \n|CString function|MBCS function|Unicode function|  \n|----------------------|-------------------|----------------------|  \n|`Compare`|`_mbscmp`|`wcscmp`|  \n|`CompareNoCase`|`_mbsicmp`|`_wcsicmp`|  \n|`Collate`|`_mbscoll`|`wcscoll`|  \n  \n The `CStringT` class template defines the relational operators (<, \\<=, >=, >, ==, and !=), which are available for use by `CString`. You can compare two `CStrings` by using these operators, as shown in the following example.  \n  \n [!code-cpp[NVC_ATLMFC_Utilities#186](../atl-mfc-shared/codesnippet/cpp/basic-cstring-operations_4.cpp)]  \n  \n##  <a name=\"_core_converting_cstring_objects\"></a> Converting CString Objects  \n For information about converting CString objects to other string types, see [How to: Convert Between Various String Types](../text/how-to-convert-between-various-string-types.md).  \n  \n## Using CString with wcout  \n To use a CString with `wcout` you must explicitly cast the object to a `const wchar_t*` as shown in the following example:  \n  \n```  \nCString cs(\"meow\");\n\n    wcout <<(const wchar_t*) cs <<endl;  \n \n```  \n  \n Without the cast, `cs` is treated as a `void*` and `wcout` prints the address of the object. This behavior is caused by subtle interactions between template argument deduction and overload resolution which are in themselves correct and conformant with the C++ standard.  \n  \n## See Also  \n [Strings (ATL/MFC)](../atl-mfc-shared/strings-atl-mfc.md)   \n [CStringT Class](../atl-mfc-shared/reference/cstringt-class.md)   \n [Template Specialization](../cpp/template-specialization-cpp.md)   \n [How to: Convert Between Various String Types](../text/how-to-convert-between-various-string-types.md)\n\n"}