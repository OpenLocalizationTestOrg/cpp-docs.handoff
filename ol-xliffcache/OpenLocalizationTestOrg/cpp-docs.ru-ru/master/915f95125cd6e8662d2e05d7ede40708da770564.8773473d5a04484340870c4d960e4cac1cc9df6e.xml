{"nodes":[{"pos":[12,60],"content":"Programming with CComBSTR (ATL) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Programming with CComBSTR (ATL) | Microsoft Docs","pos":[0,48]}]},{"content":"Programming with CComBSTR (ATL)","pos":[638,669]},{"content":"The ATL class <bpt id=\"p1\">[</bpt>CComBSTR<ept id=\"p1\">](../atl/reference/ccombstr-class.md)</ept> provides a wrapper around the <ph id=\"ph1\">`BSTR`</ph> data type.","pos":[670,778],"source":"The ATL class [CComBSTR](../atl/reference/ccombstr-class.md) provides a wrapper around the `BSTR` data type."},{"content":"While <ph id=\"ph1\">`CComBSTR`</ph> is a useful tool, there are several situations that require caution.","pos":[779,864],"source":" While `CComBSTR` is a useful tool, there are several situations that require caution."},{"content":"Conversion Issues","pos":[875,892]},{"content":"Scope Issues","pos":[947,959]},{"content":"Explicitly Freeing the CComBSTR Object","pos":[1009,1047]},{"content":"Using CComBSTR Objects in Loops","pos":[1103,1134]},{"content":"Memory Leak Issues","pos":[1183,1201]},{"pos":[1306,1323],"content":"Conversion Issues"},{"content":"Although several <ph id=\"ph1\">`CComBSTR`</ph> methods will automatically convert an ANSI string argument into Unicode, the methods will always return Unicode format strings.","pos":[1327,1482],"source":"Although several `CComBSTR` methods will automatically convert an ANSI string argument into Unicode, the methods will always return Unicode format strings."},{"content":"To convert the output string back to ANSI, use an ATL conversion class.","pos":[1483,1554]},{"content":"For more information on the ATL conversion classes, see <bpt id=\"p1\">[</bpt>ATL and MFC String Conversion Macros<ept id=\"p1\">](http://msdn.microsoft.com/library/8f53659e-0464-4424-97db-6b8453c49863)</ept>.","pos":[1555,1722],"source":" For more information on the ATL conversion classes, see [ATL and MFC String Conversion Macros](http://msdn.microsoft.com/library/8f53659e-0464-4424-97db-6b8453c49863)."},{"content":"Example","pos":[1732,1739]},{"pos":[1754,1775],"content":"NVC_ATL_Utilities#114"},{"content":"If you are using a string literal to modify a <ph id=\"ph1\">`CComBSTR`</ph> object, use wide character strings.","pos":[1844,1936],"source":"If you are using a string literal to modify a `CComBSTR` object, use wide character strings."},{"content":"This will reduce unnecessary conversions.","pos":[1937,1978]},{"content":"Example","pos":[1988,1995]},{"pos":[2010,2031],"content":"NVC_ATL_Utilities#115"},{"pos":[2154,2166],"content":"Scope Issues"},{"content":"As with any well-behaved class, <ph id=\"ph1\">`CComBSTR`</ph> will free its resources when it goes out of scope.","pos":[2170,2263],"source":"As with any well-behaved class, `CComBSTR` will free its resources when it goes out of scope."},{"content":"If a function returns a pointer to the <ph id=\"ph1\">`CComBSTR`</ph> string, this can cause problems, as the pointer will reference memory that has already been freed.","pos":[2264,2412],"source":" If a function returns a pointer to the `CComBSTR` string, this can cause problems, as the pointer will reference memory that has already been freed."},{"content":"In these cases, use the <bpt id=\"p1\">**</bpt>Copy<ept id=\"p1\">**</ept> method, as shown below.","pos":[2413,2469],"source":" In these cases, use the **Copy** method, as shown below."},{"content":"Example","pos":[2479,2486]},{"pos":[2501,2522],"content":"NVC_ATL_Utilities#116"},{"pos":[2651,2689],"content":"Explicitly Freeing the CComBSTR Object"},{"content":"It is possible to explicitly free the string contained in the <ph id=\"ph1\">`CComBSTR`</ph> object before the object goes out scope.","pos":[2693,2806],"source":"It is possible to explicitly free the string contained in the `CComBSTR` object before the object goes out scope."},{"content":"If the string is freed, the <ph id=\"ph1\">`CComBSTR`</ph> object is invalid.","pos":[2807,2864],"source":" If the string is freed, the `CComBSTR` object is invalid."},{"content":"Example","pos":[2874,2881]},{"pos":[2896,2917],"content":"NVC_ATL_Utilities#117"},{"pos":[3039,3070],"content":"Using CComBSTR Objects in Loops"},{"content":"As the <ph id=\"ph1\">`CComBSTR`</ph> class allocates a buffer to perform certain operations, such as the <ph id=\"ph2\">`+=`</ph> operator or <bpt id=\"p1\">**</bpt>Append<ept id=\"p1\">**</ept> method, it is not recommended that you perform string manipulation inside a tight loop.","pos":[3074,3275],"source":"As the `CComBSTR` class allocates a buffer to perform certain operations, such as the `+=` operator or **Append** method, it is not recommended that you perform string manipulation inside a tight loop."},{"content":"In these situations, <ph id=\"ph1\">`CStringT`</ph> provides better performance.","pos":[3276,3336],"source":" In these situations, `CStringT` provides better performance."},{"content":"Example","pos":[3346,3353]},{"pos":[3368,3389],"content":"NVC_ATL_Utilities#118"},{"pos":[3512,3530],"content":"Memory Leak Issues"},{"pos":[3534,3644],"content":"Passing the address of an initialized <ph id=\"ph1\">`CComBSTR`</ph> to a function as an <bpt id=\"p1\">**</bpt>[out]<ept id=\"p1\">**</ept> parameter causes a memory leak.","source":"Passing the address of an initialized `CComBSTR` to a function as an **[out]** parameter causes a memory leak."},{"pos":[3651,3794],"content":"In the example below, the string allocated to hold the string <ph id=\"ph1\">`\"Initialized\"`</ph> is leaked when the function <ph id=\"ph2\">`MyGoodFunction`</ph> replaces the string.","source":"In the example below, the string allocated to hold the string `\"Initialized\"` is leaked when the function `MyGoodFunction` replaces the string."},{"pos":[3812,3833],"content":"NVC_ATL_Utilities#119"},{"pos":[3902,4031],"content":"To avoid the leak, call the <bpt id=\"p1\">**</bpt>Empty<ept id=\"p1\">**</ept> method on existing <ph id=\"ph1\">`CComBSTR`</ph> objects before passing the address as an <bpt id=\"p2\">**</bpt>[out]<ept id=\"p2\">**</ept> parameter.","source":"To avoid the leak, call the **Empty** method on existing `CComBSTR` objects before passing the address as an **[out]** parameter."},{"pos":[4038,4131],"content":"Note that the same code would not cause a leak if the function's parameter was <bpt id=\"p1\">**</bpt>[in, out]<ept id=\"p1\">**</ept>.","source":"Note that the same code would not cause a leak if the function's parameter was **[in, out]**."},{"content":"See Also","pos":[4140,4148]},{"content":"Concepts","pos":[4153,4161]},{"content":"CStringT Class","pos":[4216,4230]},{"content":"wstring","pos":[4284,4291]},{"content":"String Conversion Macros","pos":[4370,4394]}],"content":"---\ntitle: \"Programming with CComBSTR (ATL) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CComBSTR class, programming with\"\n  - \"Unicode, using CComBSTR [ATL]\"\nms.assetid: d3bd0851-d132-4be9-9c4c-6ccba17acb2b\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Programming with CComBSTR (ATL)\nThe ATL class [CComBSTR](../atl/reference/ccombstr-class.md) provides a wrapper around the `BSTR` data type. While `CComBSTR` is a useful tool, there are several situations that require caution.  \n  \n-   [Conversion Issues](#programmingwithccombstr_conversionissues)  \n  \n-   [Scope Issues](#programmingwithccombstr_scopeissues)  \n  \n-   [Explicitly Freeing the CComBSTR Object](#programmingwithccombstr_explicitlyfreeing)  \n  \n-   [Using CComBSTR Objects in Loops](#programmingwithccombstr_usingloops)  \n  \n-   [Memory Leak Issues](#programmingwithccombstr_memoryleaks)  \n  \n##  <a name=\"programmingwithccombstr_conversionissues\"></a> Conversion Issues  \n Although several `CComBSTR` methods will automatically convert an ANSI string argument into Unicode, the methods will always return Unicode format strings. To convert the output string back to ANSI, use an ATL conversion class. For more information on the ATL conversion classes, see [ATL and MFC String Conversion Macros](http://msdn.microsoft.com/library/8f53659e-0464-4424-97db-6b8453c49863).  \n  \n### Example  \n [!code-cpp[NVC_ATL_Utilities#114](../atl/codesnippet/cpp/programming-with-ccombstr-atl_1.cpp)]  \n  \n If you are using a string literal to modify a `CComBSTR` object, use wide character strings. This will reduce unnecessary conversions.  \n  \n### Example  \n [!code-cpp[NVC_ATL_Utilities#115](../atl/codesnippet/cpp/programming-with-ccombstr-atl_2.cpp)]  \n  \n##  <a name=\"programmingwithccombstr_scopeissues\"></a> Scope Issues  \n As with any well-behaved class, `CComBSTR` will free its resources when it goes out of scope. If a function returns a pointer to the `CComBSTR` string, this can cause problems, as the pointer will reference memory that has already been freed. In these cases, use the **Copy** method, as shown below.  \n  \n### Example  \n [!code-cpp[NVC_ATL_Utilities#116](../atl/codesnippet/cpp/programming-with-ccombstr-atl_3.cpp)]  \n  \n##  <a name=\"programmingwithccombstr_explicitlyfreeing\"></a> Explicitly Freeing the CComBSTR Object  \n It is possible to explicitly free the string contained in the `CComBSTR` object before the object goes out scope. If the string is freed, the `CComBSTR` object is invalid.  \n  \n### Example  \n [!code-cpp[NVC_ATL_Utilities#117](../atl/codesnippet/cpp/programming-with-ccombstr-atl_4.cpp)]  \n  \n##  <a name=\"programmingwithccombstr_usingloops\"></a> Using CComBSTR Objects in Loops  \n As the `CComBSTR` class allocates a buffer to perform certain operations, such as the `+=` operator or **Append** method, it is not recommended that you perform string manipulation inside a tight loop. In these situations, `CStringT` provides better performance.  \n  \n### Example  \n [!code-cpp[NVC_ATL_Utilities#118](../atl/codesnippet/cpp/programming-with-ccombstr-atl_5.cpp)]  \n  \n##  <a name=\"programmingwithccombstr_memoryleaks\"></a> Memory Leak Issues  \n Passing the address of an initialized `CComBSTR` to a function as an **[out]** parameter causes a memory leak.  \n  \n In the example below, the string allocated to hold the string `\"Initialized\"` is leaked when the function `MyGoodFunction` replaces the string.  \n  \n [!code-cpp[NVC_ATL_Utilities#119](../atl/codesnippet/cpp/programming-with-ccombstr-atl_6.cpp)]  \n  \n To avoid the leak, call the **Empty** method on existing `CComBSTR` objects before passing the address as an **[out]** parameter.  \n  \n Note that the same code would not cause a leak if the function's parameter was **[in, out]**.  \n  \n## See Also  \n [Concepts](../atl/active-template-library-atl-concepts.md)   \n [CStringT Class](../atl-mfc-shared/reference/cstringt-class.md)   \n [wstring](http://msdn.microsoft.com/library/77953dd7-ee2f-4f6c-90e7-27da549ca631)   \n [String Conversion Macros](../atl/reference/string-conversion-macros.md)\n\n"}