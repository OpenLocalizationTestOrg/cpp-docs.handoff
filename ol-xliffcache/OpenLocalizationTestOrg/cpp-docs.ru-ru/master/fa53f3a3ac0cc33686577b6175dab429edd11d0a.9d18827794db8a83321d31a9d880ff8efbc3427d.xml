{"nodes":[{"pos":[12,56],"content":"Generic Functions (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Generic Functions (C++-CLI) | Microsoft Docs","pos":[0,44]}]},{"content":"Generic Functions (C++/CLI)","pos":[708,735]},{"content":"A generic function is a function that is declared with type parameters.","pos":[736,807]},{"content":"When called, actual types are used instead of the type parameters.","pos":[808,874]},{"content":"All Platforms","pos":[883,896]},{"content":"Remarks","pos":[902,909]},{"content":"This feature does not apply to all platforms.","pos":[918,963]},{"content":"Remarks","pos":[1030,1037]},{"pos":[1046,1136],"content":"This feature is not supported in the <ph id=\"ph1\">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph>.","source":"This feature is not supported in the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]."},{"content":"Requirements","pos":[1146,1158]},{"pos":[1162,1186],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"A generic function is a function that is declared with type parameters.","pos":[1270,1341]},{"content":"When called, actual types are used instead of the type parameters.","pos":[1342,1408]},{"content":"Syntax","pos":[1417,1423]},{"content":"Parameters","pos":[1615,1625]},{"content":"<bpt id=\"p1\">*</bpt>attributes<ept id=\"p1\">*</ept> (Optional)","pos":[1634,1657],"source":"*attributes* (Optional)"},{"content":"Additional declarative information.","pos":[1661,1696]},{"content":"For more information on attributes and attribute classes, see attributes.","pos":[1697,1770]},{"content":"<bpt id=\"p1\">*</bpt>modifiers<ept id=\"p1\">*</ept> (Optional)","pos":[1777,1799],"source":"*modifiers* (Optional)"},{"content":"A modifier for the function, such as static.","pos":[1803,1847]},{"content":"is not allowed since virtual methods may not be generic.","pos":[1859,1915]},{"content":"return-type","pos":[1923,1934]},{"content":"The type returned by the method.","pos":[1939,1971]},{"content":"If the return type is void, no return value is required.","pos":[1972,2028]},{"content":"identifier","pos":[2036,2046]},{"content":"The function name.","pos":[2051,2069]},{"content":"type-parameter identifier(s)","pos":[2077,2105]},{"content":"Comma-separated identifiers list.","pos":[2110,2143]},{"content":"<bpt id=\"p1\">*</bpt>formal-parameters<ept id=\"p1\">*</ept> (Optional)","pos":[2150,2180],"source":"*formal-parameters* (Optional)"},{"content":"Parameter list.","pos":[2184,2199]},{"content":"type-parameter-constraints-clauses","pos":[2207,2241]},{"content":"This specifies restrictions on the types that may be used as type arguments, and takes the form specified in <bpt id=\"p1\">[</bpt>Constraints on Generic Type Parameters (C++/CLI)<ept id=\"p1\">](../windows/constraints-on-generic-type-parameters-cpp-cli.md)</ept>.","pos":[2246,2468],"source":" This specifies restrictions on the types that may be used as type arguments, and takes the form specified in [Constraints on Generic Type Parameters (C++/CLI)](../windows/constraints-on-generic-type-parameters-cpp-cli.md)."},{"content":"function-body","pos":[2476,2489]},{"content":"The body of the method, which may refer to the type parameter identifiers.","pos":[2494,2568]},{"content":"Remarks","pos":[2577,2584]},{"content":"Generic functions are functions declared with a generic type parameter.","pos":[2593,2664]},{"content":"They may be methods in a class or struct, or standalone functions.","pos":[2665,2731]},{"content":"A single generic declaration implicitly declares a family of functions that differ only in the substitution of a different actual type for the generic type parameter.","pos":[2732,2898]},{"pos":[2905,3038],"content":"In <ph id=\"ph1\">[!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)]</ph>, class or struct constructors may not be declared with generic type parameters.","source":"In [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)], class or struct constructors may not be declared with generic type parameters."},{"content":"When called, the generic type parameter is replaced by an actual type.","pos":[3045,3115]},{"content":"The actual type may be explicitly specified in angled brackets using syntax similar to a template function call.","pos":[3116,3228]},{"content":"If called without the type parameters, the compiler will attempt to deduce the actual type from the parameters supplied in the function call.","pos":[3229,3370]},{"content":"If the intended type argument cannot be deduced from the parameters used, the compiler will report an error.","pos":[3371,3479]},{"content":"Requirements","pos":[3489,3501]},{"pos":[3505,3530],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[3540,3548]},{"content":"Example","pos":[3554,3561]},{"content":"The following code sample demonstrates a generic function.","pos":[3570,3628]},{"content":"Example","pos":[4208,4215]},{"content":"Generic functions can be overloaded based on signature or arity, the number of type parameters on a function.","pos":[4224,4333]},{"content":"Also, generic functions can be overloaded with non-generic functions of the same name, as long as the functions differ in some type parameters.","pos":[4334,4477]},{"content":"For example, the following functions can be overloaded:","pos":[4478,4533]},{"content":"Example","pos":[4799,4806]},{"content":"The following example uses a generic function to find the first element in an array.","pos":[4815,4899]},{"content":"It declares <ph id=\"ph1\">`MyClass`</ph>, which inherits from the base class <ph id=\"ph2\">`MyBaseClass`</ph>.","pos":[4900,4972],"source":" It declares `MyClass`, which inherits from the base class `MyBaseClass`."},{"content":"contains a generic function, <ph id=\"ph1\">`MyFunction`</ph>, which calls another generic function, <ph id=\"ph2\">`MyBaseClassFunction`</ph>, within the base class.","pos":[4983,5109],"source":" contains a generic function, `MyFunction`, which calls another generic function, `MyBaseClassFunction`, within the base class."},{"content":"In <bpt id=\"p1\">**</bpt>main<ept id=\"p1\">**</ept>, the generic function, <ph id=\"ph1\">`MyFunction`</ph>, is called using different type arguments.","pos":[5110,5200],"source":" In **main**, the generic function, `MyFunction`, is called using different type arguments."},{"content":"Output","pos":[6060,6066]},{"content":"See Also","pos":[6192,6200]},{"content":"Component Extensions for Runtime Platforms","pos":[6205,6247]},{"content":"Generics","pos":[6312,6320]}],"content":"---\ntitle: \"Generic Functions (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"functions [C++], generic\"\n  - \"generic methods\"\n  - \"generics [C++], functions\"\n  - \"methods [C++], generic\"\n  - \"generic functions\"\nms.assetid: 8e409364-58f9-4360-b486-e7d555e0c218\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Generic Functions (C++/CLI)\nA generic function is a function that is declared with type parameters. When called, actual types are used instead of the type parameters.  \n  \n## All Platforms  \n **Remarks**  \n  \n This feature does not apply to all platforms.  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n **Remarks**  \n  \n This feature is not supported in the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)].  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  \n A generic function is a function that is declared with type parameters. When called, actual types are used instead of the type parameters.  \n  \n **Syntax**  \n  \n```  \n[attributes] [modifiers]  \nreturn-type identifier<type-parameter identifier(s)>  \n[type-parameter-constraints clauses]  \n  \n([formal-parameters])  \n{function-body}  \n```  \n  \n **Parameters**  \n  \n *attributes* (Optional)  \n Additional declarative information. For more information on attributes and attribute classes, see attributes.  \n  \n *modifiers* (Optional)  \n A modifier for the function, such as static.  `virtual` is not allowed since virtual methods may not be generic.  \n  \n *return-type*  \n The type returned by the method. If the return type is void, no return value is required.  \n  \n *identifier*  \n The function name.  \n  \n *type-parameter identifier(s)*  \n Comma-separated identifiers list.  \n  \n *formal-parameters* (Optional)  \n Parameter list.  \n  \n *type-parameter-constraints-clauses*  \n This specifies restrictions on the types that may be used as type arguments, and takes the form specified in [Constraints on Generic Type Parameters (C++/CLI)](../windows/constraints-on-generic-type-parameters-cpp-cli.md).  \n  \n *function-body*  \n The body of the method, which may refer to the type parameter identifiers.  \n  \n **Remarks**  \n  \n Generic functions are functions declared with a generic type parameter. They may be methods in a class or struct, or standalone functions. A single generic declaration implicitly declares a family of functions that differ only in the substitution of a different actual type for the generic type parameter.  \n  \n In [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)], class or struct constructors may not be declared with generic type parameters.  \n  \n When called, the generic type parameter is replaced by an actual type. The actual type may be explicitly specified in angled brackets using syntax similar to a template function call. If called without the type parameters, the compiler will attempt to deduce the actual type from the parameters supplied in the function call. If the intended type argument cannot be deduced from the parameters used, the compiler will report an error.  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n The following code sample demonstrates a generic function.  \n  \n```  \n// generics_generic_function_1.cpp  \n// compile with: /clr  \ngeneric <typename ItemType>  \nvoid G(int i) {}  \n  \nref struct A {  \n   generic <typename ItemType>  \n   void G(ItemType) {}  \n  \n   generic <typename ItemType>  \n   static void H(int i) {}  \n};  \n  \nint main() {  \n   A myObject;  \n  \n   // generic function call  \n   myObject.G<int>(10);  \n  \n   // generic function call with type parameters deduced  \n   myObject.G(10);  \n  \n   // static generic function call  \n   A::H<int>(10);  \n  \n   // global generic function call  \n   G<int>(10);  \n}  \n```  \n  \n **Example**  \n  \n Generic functions can be overloaded based on signature or arity, the number of type parameters on a function. Also, generic functions can be overloaded with non-generic functions of the same name, as long as the functions differ in some type parameters. For example, the following functions can be overloaded:  \n  \n```  \n// generics_generic_function_2.cpp  \n// compile with: /clr /c  \nref struct MyClass {  \n   void MyMythod(int i) {}  \n  \n   generic <class T>   \n   void MyMythod(int i) {}  \n  \n   generic <class T, class V>   \n   void MyMythod(int i) {}  \n};  \n```  \n  \n **Example**  \n  \n The following example uses a generic function to find the first element in an array. It declares `MyClass`, which inherits from the base class `MyBaseClass`. `MyClass` contains a generic function, `MyFunction`, which calls another generic function, `MyBaseClassFunction`, within the base class. In **main**, the generic function, `MyFunction`, is called using different type arguments.  \n  \n```  \n// generics_generic_function_3.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref class MyBaseClass {  \nprotected:  \n   generic <class ItemType>  \n   ItemType MyBaseClassFunction(ItemType item) {  \n      return item;  \n   }  \n};  \n  \nref class MyClass: public MyBaseClass {  \npublic:  \n   generic <class ItemType>  \n   ItemType MyFunction(ItemType item) {  \n      return MyBaseClass::MyBaseClassFunction<ItemType>(item);  \n   }  \n};  \n  \nint main() {  \n   MyClass^ myObj = gcnew MyClass();  \n  \n   // Call MyFunction using an int.  \n   Console::WriteLine(\"My function returned an int: {0}\",  \n                           myObj->MyFunction<int>(2003));  \n  \n   // Call MyFunction using a string.  \n   Console::WriteLine(\"My function returned a string: {0}\",  \n   myObj->MyFunction<String^>(\"Hello generic functions!\"));  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nMy function returned an int: 2003  \nMy function returned a string: Hello generic functions!  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)   \n [Generics](../windows/generics-cpp-component-extensions.md)"}