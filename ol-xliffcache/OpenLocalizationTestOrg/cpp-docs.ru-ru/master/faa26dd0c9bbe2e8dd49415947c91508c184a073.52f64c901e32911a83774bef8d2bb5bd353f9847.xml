{"nodes":[{"pos":[12,82],"content":"Move Constructors and Move Assignment Operators (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Move Constructors and Move Assignment Operators (C++) | Microsoft Docs","pos":[0,70]}]},{"content":"Move Constructors and Move Assignment Operators (C++)","pos":[619,672]},{"content":"This topic describes how to write a <bpt id=\"p1\">*</bpt>move constructor<ept id=\"p1\">*</ept> and a move assignment operator for a C++ class.","pos":[673,775],"source":"This topic describes how to write a *move constructor* and a move assignment operator for a C++ class."},{"content":"A move constructor enables you to implement move semantics, which can significantly improve the performance of your applications.","pos":[776,905]},{"content":"For more information about move semantics, see <bpt id=\"p1\">[</bpt>Rvalue Reference Declarator: &amp;&amp;<ept id=\"p1\">](../cpp/rvalue-reference-declarator-amp-amp.md)</ept>.","pos":[906,1034],"source":" For more information about move semantics, see [Rvalue Reference Declarator: &&](../cpp/rvalue-reference-declarator-amp-amp.md)."},{"pos":[1041,1134],"content":"This topic builds upon the following C++ class, <ph id=\"ph1\">`MemoryBlock`</ph>, which manages a memory buffer.","source":"This topic builds upon the following C++ class, `MemoryBlock`, which manages a memory buffer."},{"content":"The following procedures describe how to write a move constructor and a move assignment operator for the example C++ class.","pos":[3022,3145]},{"content":"To create a move constructor for a C++ class","pos":[3155,3199]},{"content":"Define an empty constructor method that takes an rvalue reference to the class type as its parameter, as demonstrated in the following example:","pos":[3209,3352]},{"content":"In the move constructor, assign the class data members from the source object to the object that is being constructed:","pos":[3491,3609]},{"content":"Assign the data members of the source object to default values.","pos":[3703,3766]},{"content":"This prevents the destructor from freeing resources (such as memory) multiple times:","pos":[3767,3851]},{"content":"To create a move assignment operator for a C++ class","pos":[3941,3993]},{"content":"Define an empty assignment operator that takes an rvalue reference to the class type as its parameter and returns a reference to the class type, as demonstrated in the following example:","pos":[4003,4189]},{"content":"In the move assignment operator, add a conditional statement that performs no operation if you try to assign the object to itself.","pos":[4291,4421]},{"content":"In the conditional statement, free any resources (such as memory) from the object that is being assigned to.","pos":[4499,4607]},{"pos":[4618,4707],"content":"The following example frees the <ph id=\"ph1\">`_data`</ph> member from the object that is being assigned to:","source":"The following example frees the `_data` member from the object that is being assigned to:"},{"content":"Follow steps 2 and 3 in the first procedure to transfer the data members from the source object to the object that is being constructed:","pos":[4803,4939]},{"content":"Return a reference to the current object, as shown in the following example:","pos":[5300,5376]},{"content":"Example","pos":[5431,5438]},{"pos":[5442,5557],"content":"The following example shows the complete move constructor and move assignment operator for the <ph id=\"ph1\">`MemoryBlock`</ph> class:","source":"The following example shows the complete move constructor and move assignment operator for the `MemoryBlock` class:"},{"content":"Example","pos":[6811,6818]},{"content":"The following example shows how move semantics can improve the performance of your applications.","pos":[6822,6918]},{"content":"The example adds two elements to a vector object and then inserts a new element between the two existing elements.","pos":[6919,7033]},{"content":"In <ph id=\"ph1\">[!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)]</ph>, the <ph id=\"ph2\">`vector`</ph> class uses move semantics to perform the insertion operation efficiently by moving the elements of the vector instead of copying them.","pos":[7034,7252],"source":" In [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)], the `vector` class uses move semantics to perform the insertion operation efficiently by moving the elements of the vector instead of copying them."},{"content":"This example produces the following output:","pos":[7719,7762]},{"pos":[8628,8746],"content":"Before <ph id=\"ph1\">[!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)]</ph>, this example produces the following output:","source":"Before [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)], this example produces the following output:"},{"content":"The version of this example that uses move semantics is more efficient than the version that does not use move semantics because it performs fewer copy, memory allocation, and memory deallocation operations.","pos":[9788,9995]},{"content":"Robust Programming","pos":[10004,10022]},{"content":"To prevent resource leaks, always free resources (such as memory, file handles, and sockets) in the move assignment operator.","pos":[10026,10151]},{"content":"To prevent the unrecoverable destruction of resources, properly handle self-assignment in the move assignment operator.","pos":[10158,10277]},{"content":"If you provide both a move constructor and a move assignment operator for your class, you can eliminate redundant code by writing the move constructor to call the move assignment operator.","pos":[10284,10472]},{"content":"The following example shows a revised version of the move constructor that calls the move assignment operator:","pos":[10473,10583]},{"pos":[10742,10869],"content":"The <bpt id=\"p1\">[</bpt>std::move<ept id=\"p1\">](../standard-library/utility-functions.md#move)</ept> function preserves the rvalue property of the <ph id=\"ph1\">`other`</ph> parameter.","source":"The [std::move](../standard-library/utility-functions.md#move) function preserves the rvalue property of the `other` parameter."},{"content":"See Also","pos":[10878,10886]},{"content":"Rvalue Reference Declarator: &amp;&amp;","pos":[10891,10922],"source":"Rvalue Reference Declarator: &&"},{"content":"utility&gt; move","pos":[10978,10991],"source":"utility> move"}],"content":"---\ntitle: \"Move Constructors and Move Assignment Operators (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"move constructor\"\nms.assetid: e75efe0e-4b74-47a9-96ed-4e83cfc4378d\ncaps.latest.revision: 13\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Move Constructors and Move Assignment Operators (C++)\nThis topic describes how to write a *move constructor* and a move assignment operator for a C++ class. A move constructor enables you to implement move semantics, which can significantly improve the performance of your applications. For more information about move semantics, see [Rvalue Reference Declarator: &&](../cpp/rvalue-reference-declarator-amp-amp.md).  \n  \n This topic builds upon the following C++ class, `MemoryBlock`, which manages a memory buffer.  \n  \n```cpp  \n// MemoryBlock.h  \n#pragma once  \n#include <iostream>  \n#include <algorithm>  \n  \nclass MemoryBlock  \n{  \npublic:  \n  \n   // Simple constructor that initializes the resource.  \n   explicit MemoryBlock(size_t length)  \n      : _length(length)  \n      , _data(new int[length])  \n   {  \n      std::cout << \"In MemoryBlock(size_t). length = \"  \n                << _length << \".\" << std::endl;  \n   }  \n  \n   // Destructor.  \n   ~MemoryBlock()  \n   {  \n      std::cout << \"In ~MemoryBlock(). length = \"  \n                << _length << \".\";  \n  \n      if (_data != nullptr)  \n      {  \n         std::cout << \" Deleting resource.\";  \n         // Delete the resource.  \n         delete[] _data;  \n      }  \n  \n      std::cout << std::endl;  \n   }  \n  \n   // Copy constructor.  \n   MemoryBlock(const MemoryBlock& other)  \n      : _length(other._length)  \n      , _data(new int[other._length])  \n   {  \n      std::cout << \"In MemoryBlock(const MemoryBlock&). length = \"   \n                << other._length << \". Copying resource.\" << std::endl;  \n  \n      std::copy(other._data, other._data + _length, _data);  \n   }  \n  \n   // Copy assignment operator.  \n   MemoryBlock& operator=(const MemoryBlock& other)  \n   {  \n      std::cout << \"In operator=(const MemoryBlock&). length = \"   \n                << other._length << \". Copying resource.\" << std::endl;  \n  \n      if (this != &other)  \n      {  \n         // Free the existing resource.  \n         delete[] _data;  \n  \n         _length = other._length;  \n         _data = new int[_length];  \n         std::copy(other._data, other._data + _length, _data);  \n      }  \n      return *this;  \n   }  \n  \n   // Retrieves the length of the data resource.  \n   size_t Length() const  \n   {  \n      return _length;  \n   }  \n  \nprivate:  \n   size_t _length; // The length of the resource.  \n   int* _data; // The resource.  \n};  \n```  \n  \n The following procedures describe how to write a move constructor and a move assignment operator for the example C++ class.  \n  \n### To create a move constructor for a C++ class  \n  \n1.  Define an empty constructor method that takes an rvalue reference to the class type as its parameter, as demonstrated in the following example:  \n  \n    ```cpp  \n    MemoryBlock(MemoryBlock&& other)  \n       : _data(nullptr)  \n       , _length(0)  \n    {  \n    }  \n    ```  \n  \n2.  In the move constructor, assign the class data members from the source object to the object that is being constructed:  \n  \n    ```cpp  \n    _data = other._data;  \n    _length = other._length;  \n    ```  \n  \n3.  Assign the data members of the source object to default values. This prevents the destructor from freeing resources (such as memory) multiple times:  \n  \n    ```cpp  \n    other._data = nullptr;  \n    other._length = 0;  \n    ```  \n  \n### To create a move assignment operator for a C++ class  \n  \n1.  Define an empty assignment operator that takes an rvalue reference to the class type as its parameter and returns a reference to the class type, as demonstrated in the following example:  \n  \n    ```cpp  \n    MemoryBlock& operator=(MemoryBlock&& other)  \n    {  \n    }  \n    ```  \n  \n2.  In the move assignment operator, add a conditional statement that performs no operation if you try to assign the object to itself.  \n  \n    ```cpp  \n    if (this != &other)  \n    {  \n    }  \n    ```  \n  \n3.  In the conditional statement, free any resources (such as memory) from the object that is being assigned to.  \n  \n     The following example frees the `_data` member from the object that is being assigned to:  \n  \n    ```cpp  \n    // Free the existing resource.  \n    delete[] _data;  \n    ```  \n  \n     Follow steps 2 and 3 in the first procedure to transfer the data members from the source object to the object that is being constructed:  \n  \n    ```cpp  \n    // Copy the data pointer and its length from the   \n    // source object.  \n    _data = other._data;  \n    _length = other._length;  \n  \n    // Release the data pointer from the source object so that  \n    // the destructor does not free the memory multiple times.  \n    other._data = nullptr;  \n    other._length = 0;  \n    ```  \n  \n4.  Return a reference to the current object, as shown in the following example:  \n  \n    ```cpp  \n    return *this;  \n    ```  \n  \n## Example  \n The following example shows the complete move constructor and move assignment operator for the `MemoryBlock` class:  \n  \n```cpp  \n// Move constructor.  \nMemoryBlock(MemoryBlock&& other)  \n   : _data(nullptr)  \n   , _length(0)  \n{  \n   std::cout << \"In MemoryBlock(MemoryBlock&&). length = \"   \n             << other._length << \". Moving resource.\" << std::endl;  \n  \n   // Copy the data pointer and its length from the   \n   // source object.  \n   _data = other._data;  \n   _length = other._length;  \n  \n   // Release the data pointer from the source object so that  \n   // the destructor does not free the memory multiple times.  \n   other._data = nullptr;  \n   other._length = 0;  \n}  \n  \n// Move assignment operator.  \nMemoryBlock& operator=(MemoryBlock&& other)  \n{  \n   std::cout << \"In operator=(MemoryBlock&&). length = \"   \n             << other._length << \".\" << std::endl;  \n  \n   if (this != &other)  \n   {  \n      // Free the existing resource.  \n      delete[] _data;  \n  \n      // Copy the data pointer and its length from the   \n      // source object.  \n      _data = other._data;  \n      _length = other._length;  \n  \n      // Release the data pointer from the source object so that  \n      // the destructor does not free the memory multiple times.  \n      other._data = nullptr;  \n      other._length = 0;  \n   }  \n   return *this;  \n}  \n```  \n  \n## Example  \n The following example shows how move semantics can improve the performance of your applications. The example adds two elements to a vector object and then inserts a new element between the two existing elements. In [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)], the `vector` class uses move semantics to perform the insertion operation efficiently by moving the elements of the vector instead of copying them.  \n  \n```cpp  \n// rvalue-references-move-semantics.cpp  \n// compile with: /EHsc  \n#include \"MemoryBlock.h\"  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main()  \n{  \n   // Create a vector object and add a few elements to it.  \n   vector<MemoryBlock> v;  \n   v.push_back(MemoryBlock(25));  \n   v.push_back(MemoryBlock(75));  \n  \n   // Insert a new element into the second position of the vector.  \n   v.insert(v.begin() + 1, MemoryBlock(50));  \n}  \n```  \n  \n This example produces the following output:  \n  \n```  \nIn MemoryBlock(size_t). length = 25.  \nIn MemoryBlock(MemoryBlock&&). length = 25. Moving resource.  \nIn ~MemoryBlock(). length = 0.  \nIn MemoryBlock(size_t). length = 75.  \nIn MemoryBlock(MemoryBlock&&). length = 25. Moving resource.  \nIn ~MemoryBlock(). length = 0.  \nIn MemoryBlock(MemoryBlock&&). length = 75. Moving resource.  \nIn ~MemoryBlock(). length = 0.  \nIn MemoryBlock(size_t). length = 50.  \nIn MemoryBlock(MemoryBlock&&). length = 50. Moving resource.  \nIn MemoryBlock(MemoryBlock&&). length = 50. Moving resource.  \nIn operator=(MemoryBlock&&). length = 75.  \nIn operator=(MemoryBlock&&). length = 50.  \nIn ~MemoryBlock(). length = 0.  \nIn ~MemoryBlock(). length = 0.  \nIn ~MemoryBlock(). length = 25. Deleting resource.  \nIn ~MemoryBlock(). length = 50. Deleting resource.  \nIn ~MemoryBlock(). length = 75. Deleting resource.  \n```  \n  \n Before [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)], this example produces the following output:  \n  \n```  \nIn MemoryBlock(size_t). length = 25.  \nIn MemoryBlock(const MemoryBlock&). length = 25. Copying resource.  \nIn ~MemoryBlock(). length = 25. Deleting resource.  \nIn MemoryBlock(size_t). length = 75.  \nIn MemoryBlock(const MemoryBlock&). length = 25. Copying resource.  \nIn ~MemoryBlock(). length = 25. Deleting resource.  \nIn MemoryBlock(const MemoryBlock&). length = 75. Copying resource.  \nIn ~MemoryBlock(). length = 75. Deleting resource.  \nIn MemoryBlock(size_t). length = 50.  \nIn MemoryBlock(const MemoryBlock&). length = 50. Copying resource.  \nIn MemoryBlock(const MemoryBlock&). length = 50. Copying resource.  \nIn operator=(const MemoryBlock&). length = 75. Copying resource.  \nIn operator=(const MemoryBlock&). length = 50. Copying resource.  \nIn ~MemoryBlock(). length = 50. Deleting resource.  \nIn ~MemoryBlock(). length = 50. Deleting resource.  \nIn ~MemoryBlock(). length = 25. Deleting resource.  \nIn ~MemoryBlock(). length = 50. Deleting resource.  \nIn ~MemoryBlock(). length = 75. Deleting resource.  \n```  \n  \n The version of this example that uses move semantics is more efficient than the version that does not use move semantics because it performs fewer copy, memory allocation, and memory deallocation operations.  \n  \n## Robust Programming  \n To prevent resource leaks, always free resources (such as memory, file handles, and sockets) in the move assignment operator.  \n  \n To prevent the unrecoverable destruction of resources, properly handle self-assignment in the move assignment operator.  \n  \n If you provide both a move constructor and a move assignment operator for your class, you can eliminate redundant code by writing the move constructor to call the move assignment operator. The following example shows a revised version of the move constructor that calls the move assignment operator:  \n  \n```  \n// Move constructor.  \nMemoryBlock(MemoryBlock&& other)  \n   : _data(nullptr)  \n   , _length(0)  \n{  \n   *this = std::move(other);  \n}  \n```  \n  \n The [std::move](../standard-library/utility-functions.md#move) function preserves the rvalue property of the `other` parameter.  \n  \n## See Also  \n [Rvalue Reference Declarator: &&](../cpp/rvalue-reference-declarator-amp-amp.md)   \n [\\<utility> move](http://msdn.microsoft.com/en-us/abef7e85-9dd6-4724-85da-d7f7fe95dca9)"}