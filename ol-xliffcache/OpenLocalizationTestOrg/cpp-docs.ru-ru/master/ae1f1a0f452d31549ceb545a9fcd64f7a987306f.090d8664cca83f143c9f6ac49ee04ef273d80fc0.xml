{"nodes":[{"pos":[12,75],"content":"How to: Marshal ANSI Strings Using C++ Interop | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Marshal ANSI Strings Using C++ Interop | Microsoft Docs","pos":[0,63]}]},{"content":"How to: Marshal ANSI Strings Using C++ Interop","pos":[752,798]},{"content":"This topic demonstrates how ANSI strings can be passed using C++ Interop, but the .NET Framework &lt;xref:System.String&gt; represents strings in Unicode format, so conversion to ANSI is an extra step.","pos":[799,994],"source":"This topic demonstrates how ANSI strings can be passed using C++ Interop, but the .NET Framework <xref:System.String> represents strings in Unicode format, so conversion to ANSI is an extra step."},{"content":"For interoperating with other string types, see the following topics:","pos":[995,1064]},{"content":"How to: Marshal Unicode Strings Using C++ Interop","pos":[1075,1124]},{"content":"How to: Marshal COM Strings Using C++ Interop","pos":[1199,1244]},{"content":"The following code examples use the <bpt id=\"p1\">[</bpt>managed, unmanaged<ept id=\"p1\">](../preprocessor/managed-unmanaged.md)</ept> #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files.","pos":[1311,1569],"source":"The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files."},{"content":"Because files containing only unmanaged functions do not need to be compiled with <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>, they can retain their performance characteristics.","pos":[1570,1811],"source":" Because files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md), they can retain their performance characteristics."},{"content":"Example","pos":[1820,1827]},{"content":"The example demonstrates passing an ANSI string from a managed to an unmanaged function using &lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;.","pos":[1831,1994],"source":"The example demonstrates passing an ANSI string from a managed to an unmanaged function using <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A>."},{"content":"This method allocates memory on the unmanaged heap and returns the address after performing the conversion.","pos":[1995,2102]},{"content":"This means that no pinning is necessary (because memory on the GC heap is not being passed to the unmanaged function) and that the IntPtr returned from &lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt; must be explicitly released or a memory leak results.","pos":[2103,2377],"source":" This means that no pinning is necessary (because memory on the GC heap is not being passed to the unmanaged function) and that the IntPtr returned from <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> must be explicitly released or a memory leak results."},{"content":"Example","pos":[3046,3053]},{"content":"The following example demonstrates the data marshaling required to access an ANSI string in a managed function that is called by an unmanaged function.","pos":[3057,3208]},{"content":"The managed function, on receiving the native string, can either use it directly or convert it to a managed string using the &lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt; method, as shown.","pos":[3209,3416],"source":" The managed function, on receiving the native string, can either use it directly or convert it to a managed string using the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> method, as shown."},{"content":"See Also","pos":[4052,4060]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[4065,4101]}],"content":"---\ntitle: \"How to: Marshal ANSI Strings Using C++ Interop | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"interop [C++], strings\"\n  - \"ANSI [C++], marshaling strings\"\n  - \"marshaling [C++], strings\"\n  - \"C++ Interop, strings\"\n  - \"data marshaling [C++], strings\"\nms.assetid: 5eda2eb6-5140-40f0-82cf-7ce171fffb45\ncaps.latest.revision: 16\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Marshal ANSI Strings Using C++ Interop\nThis topic demonstrates how ANSI strings can be passed using C++ Interop, but the .NET Framework <xref:System.String> represents strings in Unicode format, so conversion to ANSI is an extra step. For interoperating with other string types, see the following topics:  \n  \n-   [How to: Marshal Unicode Strings Using C++ Interop](../dotnet/how-to-marshal-unicode-strings-using-cpp-interop.md)  \n  \n-   [How to: Marshal COM Strings Using C++ Interop](../dotnet/how-to-marshal-com-strings-using-cpp-interop.md)  \n  \n The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files. Because files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md), they can retain their performance characteristics.  \n  \n## Example  \n The example demonstrates passing an ANSI string from a managed to an unmanaged function using <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A>. This method allocates memory on the unmanaged heap and returns the address after performing the conversion. This means that no pinning is necessary (because memory on the GC heap is not being passed to the unmanaged function) and that the IntPtr returned from <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> must be explicitly released or a memory leak results.  \n  \n```  \n// MarshalANSI1.cpp  \n// compile with: /clr  \n#include <iostream>  \n#include <stdio.h>  \n  \nusing namespace std;  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n#pragma unmanaged  \n  \nvoid NativeTakesAString(const char* p) {  \n   printf_s(\"(native) received '%s'\\n\", p);  \n}  \n  \n#pragma managed  \n  \nint main() {  \n   String^ s = gcnew String(\"sample string\");  \n   IntPtr ip = Marshal::StringToHGlobalAnsi(s);  \n   const char* str = static_cast<const char*>(ip.ToPointer());  \n  \n   Console::WriteLine(\"(managed) passing string...\");  \n   NativeTakesAString( str );  \n  \n   Marshal::FreeHGlobal( ip );  \n}  \n```  \n  \n## Example  \n The following example demonstrates the data marshaling required to access an ANSI string in a managed function that is called by an unmanaged function. The managed function, on receiving the native string, can either use it directly or convert it to a managed string using the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> method, as shown.  \n  \n```  \n// MarshalANSI2.cpp  \n// compile with: /clr  \n#include <iostream>  \n#include <vcclr.h>  \n  \nusing namespace std;  \n  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n#pragma managed  \n  \nvoid ManagedStringFunc(char* s) {  \n   String^ ms = Marshal::PtrToStringAnsi(static_cast<IntPtr>(s));  \n   Console::WriteLine(\"(managed): received '{0}'\", ms);  \n}  \n  \n#pragma unmanaged  \n  \nvoid NativeProvidesAString() {  \n   cout << \"(native) calling managed func...\\n\";  \n   ManagedStringFunc(\"test string\");  \n}  \n  \n#pragma managed  \n  \nint main() {  \n   NativeProvidesAString();  \n}  \n```  \n  \n## See Also  \n [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)"}