{"nodes":[{"pos":[12,46],"content":"C Type Specifiers | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"C Type Specifiers | Microsoft Docs","pos":[0,34]}]},{"content":"C Type Specifiers","pos":[605,622]},{"content":"Type specifiers in declarations define the type of a variable or function declaration.","pos":[623,709]},{"content":"Syntax","pos":[718,724]},{"content":"<bpt id=\"p1\">*</bpt>type-specifier<ept id=\"p1\">*</ept>:","pos":[728,745],"source":"*type-specifier*:"},{"content":"void","pos":[751,755]},{"content":"char","pos":[766,770]},{"content":"short","pos":[781,786]},{"content":"int","pos":[797,800]},{"content":"long","pos":[811,815]},{"content":"float","pos":[826,831]},{"content":"double","pos":[842,848]},{"content":"signed","pos":[859,865]},{"content":"unsigned","pos":[876,884]},{"content":"struct-or-union-specifier","pos":[894,919]},{"content":"enum-specifier","pos":[928,942]},{"content":"typedef-name","pos":[951,963]},{"content":"The <bpt id=\"p1\">**</bpt>signed char<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>signed int<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>signed short int<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>signed long int<ept id=\"p4\">**</ept> types, together with their <ph id=\"ph1\">`unsigned`</ph> counterparts and <ph id=\"ph2\">`enum`</ph>, are called \"integral\" types.","pos":[971,1145],"source":"The **signed char**, **signed int**, **signed short int**, and **signed long int** types, together with their `unsigned` counterparts and `enum`, are called \"integral\" types."},{"content":"The <bpt id=\"p1\">**</bpt>float<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>double<ept id=\"p2\">**</ept>, and <ph id=\"ph1\">`long double`</ph> type specifiers are referred to as \"floating\" or \"floating-point\" types.","pos":[1146,1263],"source":" The **float**, **double**, and `long double` type specifiers are referred to as \"floating\" or \"floating-point\" types."},{"content":"You can use any integral or floating-point type specifier in a variable or function declaration.","pos":[1264,1360]},{"content":"If a <bpt id=\"p1\">*</bpt>type-specifier<ept id=\"p1\">*</ept> is not provided in a declaration, it is taken to be <ph id=\"ph1\">`int`</ph>.","pos":[1361,1441],"source":" If a *type-specifier* is not provided in a declaration, it is taken to be `int`."},{"content":"The optional keywords <bpt id=\"p1\">**</bpt>signed<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`unsigned`</ph> can precede or follow any of the integral types, except <ph id=\"ph2\">`enum`</ph>, and can also be used alone as type specifiers, in which case they are understood as <bpt id=\"p2\">**</bpt>signed int<ept id=\"p2\">**</ept> and <ph id=\"ph3\">`unsigned int`</ph>, respectively.","pos":[1448,1692],"source":"The optional keywords **signed** and `unsigned` can precede or follow any of the integral types, except `enum`, and can also be used alone as type specifiers, in which case they are understood as **signed int** and `unsigned int`, respectively."},{"content":"When used alone, the keyword <ph id=\"ph1\">`int`</ph> is assumed to be <bpt id=\"p1\">**</bpt>signed<ept id=\"p1\">**</ept>.","pos":[1693,1756],"source":" When used alone, the keyword `int` is assumed to be **signed**."},{"content":"When used alone, the keywords <bpt id=\"p1\">**</bpt>long<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>short<ept id=\"p2\">**</ept> are understood as <bpt id=\"p3\">**</bpt>long int<ept id=\"p3\">**</ept> and <ph id=\"ph1\">`short int`</ph>.","pos":[1757,1857],"source":" When used alone, the keywords **long** and **short** are understood as **long int** and `short int`."},{"content":"Enumeration types are considered basic types.","pos":[1864,1909]},{"content":"Type specifiers for enumeration types are discussed in <bpt id=\"p1\">[</bpt>Enumeration Declarations<ept id=\"p1\">](../c-language/c-enumeration-declarations.md)</ept>.","pos":[1910,2037],"source":" Type specifiers for enumeration types are discussed in [Enumeration Declarations](../c-language/c-enumeration-declarations.md)."},{"content":"The keyword <ph id=\"ph1\">`void`</ph> has three uses: to specify a function return type, to specify an argument-type list for a function that takes no arguments, and to specify a pointer to an unspecified type.","pos":[2044,2235],"source":"The keyword `void` has three uses: to specify a function return type, to specify an argument-type list for a function that takes no arguments, and to specify a pointer to an unspecified type."},{"content":"You can use the <ph id=\"ph1\">`void`</ph> type to declare functions that return no value or to declare a pointer to an unspecified type.","pos":[2236,2353],"source":" You can use the `void` type to declare functions that return no value or to declare a pointer to an unspecified type."},{"content":"See <bpt id=\"p1\">[</bpt>Arguments<ept id=\"p1\">](../c-language/arguments.md)</ept> for information on <ph id=\"ph1\">`void`</ph> when it appears alone within the parentheses following a function name.","pos":[2354,2495],"source":" See [Arguments](../c-language/arguments.md) for information on `void` when it appears alone within the parentheses following a function name."},{"content":"Microsoft Specific","pos":[2504,2522]},{"content":"Type checking is now ANSI-compliant, which means that type <bpt id=\"p1\">**</bpt>short<ept id=\"p1\">**</ept> and type <ph id=\"ph1\">`int`</ph> are distinct types.","pos":[2531,2634],"source":"Type checking is now ANSI-compliant, which means that type **short** and type `int` are distinct types."},{"content":"For example, this is a redefinition in the Microsoft C compiler that was accepted by previous versions of the compiler.","pos":[2635,2754]},{"content":"This next example also generates a warning about indirection to different types:","pos":[2812,2892]},{"content":"The Microsoft C compiler also generates warnings for differences in sign.","pos":[2981,3054]},{"content":"For example:","pos":[3055,3067]},{"content":"Type <ph id=\"ph1\">`void`</ph> expressions are evaluated for side effects.","pos":[3169,3224],"source":"Type `void` expressions are evaluated for side effects."},{"content":"You cannot use the (nonexistent) value of an expression that has type <ph id=\"ph1\">`void`</ph> in any way, nor can you convert a <ph id=\"ph2\">`void`</ph> expression (by implicit or explicit conversion) to any type except <ph id=\"ph3\">`void`</ph>.","pos":[3225,3417],"source":" You cannot use the (nonexistent) value of an expression that has type `void` in any way, nor can you convert a `void` expression (by implicit or explicit conversion) to any type except `void`."},{"content":"If you do use an expression of any other type in a context where a <ph id=\"ph1\">`void`</ph> expression is required, its value is discarded.","pos":[3418,3539],"source":" If you do use an expression of any other type in a context where a `void` expression is required, its value is discarded."},{"content":"To conform to the ANSI specification, <bpt id=\"p1\">**</bpt>void<ph id=\"ph1\">\\*\\*</ph><ept id=\"p1\">**</ept> cannot be used as <bpt id=\"p2\">**</bpt>int<ph id=\"ph2\">\\*\\*</ph><ept id=\"p2\">**</ept>.","pos":[3546,3627],"source":"To conform to the ANSI specification, **void\\*\\*** cannot be used as **int\\*\\***."},{"content":"Only <bpt id=\"p1\">**</bpt>void<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> can be used as a pointer to an unspecified type.","pos":[3628,3692],"source":" Only **void\\*** can be used as a pointer to an unspecified type."},{"content":"END Microsoft Specific","pos":[3701,3723]},{"content":"You can create additional type specifiers with <ph id=\"ph1\">`typedef`</ph> declarations, as described in <bpt id=\"p1\">[</bpt>Typedef Declarations<ept id=\"p1\">](../c-language/typedef-declarations.md)</ept>.","pos":[3732,3881],"source":"You can create additional type specifiers with `typedef` declarations, as described in [Typedef Declarations](../c-language/typedef-declarations.md)."},{"content":"See <bpt id=\"p1\">[</bpt>Storage of Basic Types<ept id=\"p1\">](../c-language/storage-of-basic-types.md)</ept> for information on the size of each type.","pos":[3882,3993],"source":" See [Storage of Basic Types](../c-language/storage-of-basic-types.md) for information on the size of each type."},{"content":"See Also","pos":[4002,4010]},{"content":"Declarations and Types","pos":[4015,4037]}],"content":"---\ntitle: \"C Type Specifiers | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"type specifiers, C\"\n  - \"specifiers, type\"\nms.assetid: fbe13441-04c3-4829-b047-06d374adc2b6\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# C Type Specifiers\nType specifiers in declarations define the type of a variable or function declaration.  \n  \n## Syntax  \n *type-specifier*:  \n **void**  \n  \n **char**  \n  \n **short**  \n  \n **int**  \n  \n **long**  \n  \n **float**  \n  \n **double**  \n  \n **signed**  \n  \n **unsigned**  \n  \n *struct-or-union-specifier*  \n  \n *enum-specifier*  \n  \n *typedef-name*  \n  \n The **signed char**, **signed int**, **signed short int**, and **signed long int** types, together with their `unsigned` counterparts and `enum`, are called \"integral\" types. The **float**, **double**, and `long double` type specifiers are referred to as \"floating\" or \"floating-point\" types. You can use any integral or floating-point type specifier in a variable or function declaration. If a *type-specifier* is not provided in a declaration, it is taken to be `int`.  \n  \n The optional keywords **signed** and `unsigned` can precede or follow any of the integral types, except `enum`, and can also be used alone as type specifiers, in which case they are understood as **signed int** and `unsigned int`, respectively. When used alone, the keyword `int` is assumed to be **signed**. When used alone, the keywords **long** and **short** are understood as **long int** and `short int`.  \n  \n Enumeration types are considered basic types. Type specifiers for enumeration types are discussed in [Enumeration Declarations](../c-language/c-enumeration-declarations.md).  \n  \n The keyword `void` has three uses: to specify a function return type, to specify an argument-type list for a function that takes no arguments, and to specify a pointer to an unspecified type. You can use the `void` type to declare functions that return no value or to declare a pointer to an unspecified type. See [Arguments](../c-language/arguments.md) for information on `void` when it appears alone within the parentheses following a function name.  \n  \n **Microsoft Specific**  \n  \n Type checking is now ANSI-compliant, which means that type **short** and type `int` are distinct types. For example, this is a redefinition in the Microsoft C compiler that was accepted by previous versions of the compiler.  \n  \n```  \nint   myfunc();  \nshort myfunc();  \n```  \n  \n This next example also generates a warning about indirection to different types:  \n  \n```  \nint *pi;  \nshort *ps;  \n  \nps = pi;  /* Now generates warning */  \n```  \n  \n The Microsoft C compiler also generates warnings for differences in sign. For example:  \n  \n```  \nsigned int *pi;  \nunsigned int *pu  \n  \npi = pu;  /* Now generates warning */  \n```  \n  \n Type `void` expressions are evaluated for side effects. You cannot use the (nonexistent) value of an expression that has type `void` in any way, nor can you convert a `void` expression (by implicit or explicit conversion) to any type except `void`. If you do use an expression of any other type in a context where a `void` expression is required, its value is discarded.  \n  \n To conform to the ANSI specification, **void\\*\\*** cannot be used as **int\\*\\***. Only **void\\*** can be used as a pointer to an unspecified type.  \n  \n **END Microsoft Specific**  \n  \n You can create additional type specifiers with `typedef` declarations, as described in [Typedef Declarations](../c-language/typedef-declarations.md). See [Storage of Basic Types](../c-language/storage-of-basic-types.md) for information on the size of each type.  \n  \n## See Also  \n [Declarations and Types](../c-language/declarations-and-types.md)"}