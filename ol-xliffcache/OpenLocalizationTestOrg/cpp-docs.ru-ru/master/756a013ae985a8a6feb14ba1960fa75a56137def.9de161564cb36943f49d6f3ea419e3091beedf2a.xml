{"nodes":[{"pos":[12,60],"content":"&lt;unordered_map&gt; operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"unordered_map<ph id=\"ph1\">&amp;gt;</ph> operators | Microsoft Docs","pos":[4,48],"source":"unordered_map&gt; operators | Microsoft Docs"}]},{"content":"unordered_map<ph id=\"ph1\">&amp;gt;</ph> operators","pos":[266,293],"source":"unordered_map&gt; operators"},{"content":"operator!=","pos":[316,326]},{"content":"operator==","pos":[344,354]},{"content":"operator!=","pos":[374,384]},{"content":"operator==","pos":[411,421]},{"pos":[488,498],"content":"operator!="},{"pos":[502,679],"content":"Tests whether the <bpt id=\"p1\">[</bpt>unordered_map<ept id=\"p1\">](../standard-library/unordered-map-class.md)</ept> object on the left side of the operator is not equal to the unordered_map object on the right side.","source":"Tests whether the [unordered_map](../standard-library/unordered-map-class.md) object on the left side of the operator is not equal to the unordered_map object on the right side."},{"content":"Parameters","pos":[844,854]},{"content":"An object of type <ph id=\"ph1\">`unordered_map`</ph>.","pos":[868,902],"source":" An object of type `unordered_map`."},{"content":"An object of type <ph id=\"ph1\">`unordered_map`</ph>.","pos":[920,954],"source":" An object of type `unordered_map`."},{"content":"Return Value","pos":[964,976]},{"pos":[987,1050],"content":"if the unordered_maps are not equal; <ph id=\"ph1\">`false`</ph> if they are equal.","source":" if the unordered_maps are not equal; `false` if they are equal."},{"content":"Remarks","pos":[1060,1067]},{"content":"The comparison between unordered_map objects is not affected by the arbitrary order in which they store their elements.","pos":[1071,1190]},{"content":"Two unordered_maps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container.","pos":[1191,1352]},{"content":"Otherwise, they are unequal.","pos":[1353,1381]},{"content":"Example","pos":[1391,1398]},{"content":"Output:","pos":[2168,2175]},{"pos":[2294,2304],"content":"operator=="},{"pos":[2308,2481],"content":"Tests whether the <bpt id=\"p1\">[</bpt>unordered_map<ept id=\"p1\">](../standard-library/unordered-map-class.md)</ept> object on the left side of the operator is equal to the unordered_map object on the right side.","source":"Tests whether the [unordered_map](../standard-library/unordered-map-class.md) object on the left side of the operator is equal to the unordered_map object on the right side."},{"content":"Parameters","pos":[2646,2656]},{"content":"An object of type <ph id=\"ph1\">`unordered_map`</ph>.","pos":[2670,2704],"source":" An object of type `unordered_map`."},{"content":"An object of type <ph id=\"ph1\">`unordered_map`</ph>.","pos":[2722,2756],"source":" An object of type `unordered_map`."},{"content":"Return Value","pos":[2766,2778]},{"pos":[2789,2852],"content":"if the unordered_maps are equal; <ph id=\"ph1\">`false`</ph> if they are not equal.","source":" if the unordered_maps are equal; `false` if they are not equal."},{"content":"Remarks","pos":[2862,2869]},{"content":"The comparison between unordered_map objects is not affected by the arbitrary order in which they store their elements.","pos":[2873,2992]},{"content":"Two unordered_maps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container.","pos":[2993,3154]},{"content":"Otherwise, they are unequal.","pos":[3155,3183]},{"content":"Example","pos":[3193,3200]},{"content":"Output:","pos":[3970,3977]},{"pos":[4104,4114],"content":"operator!="},{"pos":[4118,4310],"content":"Tests whether the <bpt id=\"p1\">[</bpt>unordered_multimap<ept id=\"p1\">](../standard-library/unordered-multimap-class.md)</ept> object on the left side of the operator is not equal to the unordered_multimap object on the right side.","source":"Tests whether the [unordered_multimap](../standard-library/unordered-multimap-class.md) object on the left side of the operator is not equal to the unordered_multimap object on the right side."},{"content":"Parameters","pos":[4485,4495]},{"content":"An object of type <ph id=\"ph1\">`unordered_multimap`</ph>.","pos":[4509,4548],"source":" An object of type `unordered_multimap`."},{"content":"An object of type <ph id=\"ph1\">`unordered_multimap`</ph>.","pos":[4566,4605],"source":" An object of type `unordered_multimap`."},{"content":"Return Value","pos":[4615,4627]},{"pos":[4638,4706],"content":"if the unordered_multimaps are not equal; <ph id=\"ph1\">`false`</ph> if they are equal.","source":" if the unordered_multimaps are not equal; `false` if they are equal."},{"content":"Remarks","pos":[4716,4723]},{"content":"The comparison between unordered_multimap objects is not affected by the arbitrary order in which they store their elements.","pos":[4727,4851]},{"content":"Two unordered_multimaps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container.","pos":[4852,5018]},{"content":"Otherwise, they are not equal.","pos":[5019,5049]},{"content":"Example","pos":[5059,5066]},{"content":"Output:","pos":[5881,5888]},{"pos":[6016,6026],"content":"operator=="},{"pos":[6030,6218],"content":"Tests whether the <bpt id=\"p1\">[</bpt>unordered_multimap<ept id=\"p1\">](../standard-library/unordered-multimap-class.md)</ept> object on the left side of the operator is equal to the unordered_multimap object on the right side.","source":"Tests whether the [unordered_multimap](../standard-library/unordered-multimap-class.md) object on the left side of the operator is equal to the unordered_multimap object on the right side."},{"content":"Parameters","pos":[6393,6403]},{"content":"An object of type <ph id=\"ph1\">`unordered_multimap`</ph>.","pos":[6417,6456],"source":" An object of type `unordered_multimap`."},{"content":"An object of type <ph id=\"ph1\">`unordered_multimap`</ph>.","pos":[6474,6513],"source":" An object of type `unordered_multimap`."},{"content":"Return Value","pos":[6523,6535]},{"pos":[6546,6614],"content":"if the unordered_multimaps are equal; <ph id=\"ph1\">`false`</ph> if they are not equal.","source":" if the unordered_multimaps are equal; `false` if they are not equal."},{"content":"Remarks","pos":[6624,6631]},{"content":"The comparison between unordered_multimap objects is not affected by the arbitrary order in which they store their elements.","pos":[6635,6759]},{"content":"Two unordered_multimaps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container.","pos":[6760,6926]},{"content":"Otherwise, they are unequal.","pos":[6927,6955]},{"content":"Example","pos":[6965,6972]},{"content":"Output:","pos":[7789,7796]},{"content":"See Also","pos":[7884,7892]},{"content":"&lt;unordered_map&gt;","pos":[7897,7912],"source":"<unordered_map>"}],"content":"---\ntitle: \"&lt;unordered_map&gt; operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 9d5add0b-84bd-4a79-bd82-3f58b55145ed\ncaps.latest.revision: 7\nmanager: \"ghogen\"\n---\n# &lt;unordered_map&gt; operators\n|||||  \n|-|-|-|-|  \n|[operator!=](#operator_neq)|[operator==](#operator_eq_eq)|[operator!=](#operator_neq_multimap)|[operator==](#operator_eq_eq_multimap)|  \n  \n##  <a name=\"operator_neq\"></a>  operator!=  \n Tests whether the [unordered_map](../standard-library/unordered-map-class.md) object on the left side of the operator is not equal to the unordered_map object on the right side.  \n  \n```\nbool operator!=(const unordered_map <Key, Type, Hash, Pred, Allocator>& left, const unordered_map <Key, Type, Hash, Pred, Allocator>& right);\n```  \n  \n### Parameters  \n `left`  \n An object of type `unordered_map`.  \n  \n `right`  \n An object of type `unordered_map`.  \n  \n### Return Value  \n `true` if the unordered_maps are not equal; `false` if they are equal.  \n  \n### Remarks  \n The comparison between unordered_map objects is not affected by the arbitrary order in which they store their elements. Two unordered_maps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container. Otherwise, they are unequal.  \n  \n### Example  \n  \n```cpp  \n// unordered_map_op_ne.cpp  \n// compile by using: cl.exe /EHsc /nologo /W4 /MTd   \n#include <unordered_map>  \n#include <iostream>  \n#include <ios>  \n  \nint main( )  \n{  \n   using namespace std;  \n   unordered_map<int, int> um1, um2, um3;  \n  \n   for ( int i = 0 ; i < 3 ; ++i ) {  \n      um1.insert( make_pair( i+1, i ) );  \n      um1.insert( make_pair( i, i ) );  \n  \n      um2.insert( make_pair( i, i+1 ) );  \n      um2.insert( make_pair( i, i ) );  \n  \n      um3.insert( make_pair( i, i ) );  \n      um3.insert( make_pair( i+1, i ) );  \n   }  \n  \n   cout << boolalpha;  \n   cout << \"um1 != um2: \" << (um1 != um2) << endl;   \n   cout << \"um1 != um3: \" << (um1 != um3) << endl;   \n   cout << \"um2 != um3: \" << (um2 != um3) << endl;   \n}  \n  \n```  \n  \n **Output:**  \n  \n `um1 != um2: true`  \n  \n `um1 != um3: false`  \n  \n `um2 != um3: true`  \n  \n##  <a name=\"operator_eq_eq\"></a>  operator==  \n Tests whether the [unordered_map](../standard-library/unordered-map-class.md) object on the left side of the operator is equal to the unordered_map object on the right side.  \n  \n```\nbool operator==(const unordered_map <Key, Type, Hash, Pred, Allocator>& left, const unordered_map <Key, Type, Hash, Pred, Allocator>& right);\n```  \n  \n### Parameters  \n `left`  \n An object of type `unordered_map`.  \n  \n `right`  \n An object of type `unordered_map`.  \n  \n### Return Value  \n `true` if the unordered_maps are equal; `false` if they are not equal.  \n  \n### Remarks  \n The comparison between unordered_map objects is not affected by the arbitrary order in which they store their elements. Two unordered_maps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container. Otherwise, they are unequal.  \n  \n### Example  \n  \n```cpp  \n// unordered_map_op_eq.cpp  \n// compile by using: cl.exe /EHsc /nologo /W4 /MTd   \n#include <unordered_map>  \n#include <iostream>  \n#include <ios>  \n  \nint main( )  \n{  \n   using namespace std;  \n   unordered_map<int, int> um1, um2, um3;  \n  \n   for ( int i = 0 ; i < 3 ; ++i ) {  \n      um1.insert( make_pair( i+1, i ) );  \n      um1.insert( make_pair( i, i ) );  \n  \n      um2.insert( make_pair( i, i+1 ) );  \n      um2.insert( make_pair( i, i ) );  \n  \n      um3.insert( make_pair( i, i ) );  \n      um3.insert( make_pair( i+1, i ) );  \n   }  \n  \n   cout << boolalpha;  \n   cout << \"um1 == um2: \" << (um1 == um2) << endl;   \n   cout << \"um1 == um3: \" << (um1 == um3) << endl;   \n   cout << \"um2 == um3: \" << (um2 == um3) << endl;   \n}  \n  \n```  \n  \n **Output:**  \n  \n `um1 == um2: false`  \n  \n `um1 == um3: true`  \n  \n `um2 == um3: false`  \n  \n##  <a name=\"operator_neq_multimap\"></a>  operator!=  \n Tests whether the [unordered_multimap](../standard-library/unordered-multimap-class.md) object on the left side of the operator is not equal to the unordered_multimap object on the right side.  \n  \n```\nbool operator!=(const unordered_multimap <Key, Type, Hash, Pred, Allocator>& left, const unordered_multimap <Key, Type, Hash, Pred, Allocator>& right);\n```  \n  \n### Parameters  \n `left`  \n An object of type `unordered_multimap`.  \n  \n `right`  \n An object of type `unordered_multimap`.  \n  \n### Return Value  \n `true` if the unordered_multimaps are not equal; `false` if they are equal.  \n  \n### Remarks  \n The comparison between unordered_multimap objects is not affected by the arbitrary order in which they store their elements. Two unordered_multimaps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container. Otherwise, they are not equal.  \n  \n### Example  \n  \n```cpp  \n// unordered_multimap_op_ne.cpp  \n// compile by using: cl.exe /EHsc /nologo /W4 /MTd   \n#include <unordered_map>  \n#include <iostream>  \n#include <ios>  \n  \nint main( )  \n{  \n   using namespace std;  \n   unordered_multimap<int, int> um1, um2, um3;  \n  \n   for ( int i = 0 ; i < 3 ; ++i ) {  \n      um1.insert( make_pair( i, i ) );  \n      um1.insert( make_pair( i, i ) );  \n  \n      um2.insert( make_pair( i, i ) );  \n      um2.insert( make_pair( i, i ) );  \n      um2.insert( make_pair( i, i ) );  \n  \n      um3.insert( make_pair( i, i ) );  \n      um3.insert( make_pair( i, i ) );  \n   }  \n  \n   cout << boolalpha;  \n   cout << \"um1 != um2: \" << (um1 != um2) << endl;   \n   cout << \"um1 != um3: \" << (um1 != um3) << endl;   \n   cout << \"um2 != um3: \" << (um2 != um3) << endl;   \n}  \n  \n```  \n  \n **Output:**  \n  \n `um1 != um2: true`  \n  \n `um1 != um3: false`  \n  \n `um2 != um3: true`  \n  \n##  <a name=\"operator_eq_eq_multimap\"></a>  operator==  \n Tests whether the [unordered_multimap](../standard-library/unordered-multimap-class.md) object on the left side of the operator is equal to the unordered_multimap object on the right side.  \n  \n```\nbool operator==(const unordered_multimap <Key, Type, Hash, Pred, Allocator>& left, const unordered_multimap <Key, Type, Hash, Pred, Allocator>& right);\n```  \n  \n### Parameters  \n `left`  \n An object of type `unordered_multimap`.  \n  \n `right`  \n An object of type `unordered_multimap`.  \n  \n### Return Value  \n `true` if the unordered_multimaps are equal; `false` if they are not equal.  \n  \n### Remarks  \n The comparison between unordered_multimap objects is not affected by the arbitrary order in which they store their elements. Two unordered_multimaps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container. Otherwise, they are unequal.  \n  \n### Example  \n  \n```cpp  \n  \n// unordered_multimap_op_eq.cpp  \n// compile by using: cl.exe /EHsc /nologo /W4 /MTd  \n#include <unordered_map>  \n#include <iostream>  \n#include <ios>  \n  \nint main( )  \n{  \n   using namespace std;  \n   unordered_multimap<int, int> um1, um2, um3;  \n  \n   for ( int i = 0 ; i < 3 ; ++i ) {  \n      um1.insert( make_pair( i, i ) );  \n      um1.insert( make_pair( i, i ) );  \n  \n      um2.insert( make_pair( i, i ) );  \n      um2.insert( make_pair( i, i ) );  \n      um2.insert( make_pair( i, i ) );  \n  \n      um3.insert( make_pair( i, i ) );  \n      um3.insert( make_pair( i, i ) );  \n   }  \n  \n   cout << boolalpha;  \n   cout << \"um1 == um2: \" << (um1 == um2) << endl;   \n   cout << \"um1 == um3: \" << (um1 == um3) << endl;   \n   cout << \"um2 == um3: \" << (um2 == um3) << endl;   \n}  \n  \n```  \n  \n **Output:**  \n  \n `um1 == um2: false`  \n  \n `um1 == um3: true`  \n  \n `um2 == um3: false`  \n  \n## See Also  \n [<unordered_map>](../standard-library/unordered-map.md)\n\n\n\n"}