{"nodes":[{"pos":[12,61],"content":"Compiler Warning (level 1) C4930 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Warning (level 1) C4930 | Microsoft Docs","pos":[0,49]}]},{"pos":[610,642],"content":"Compiler Warning (level 1) C4930","linkify":"Compiler Warning (level 1) C4930","nodes":[{"content":"Compiler Warning (level 1) C4930","pos":[0,32]}]},{"content":"'prototype': prototyped function not called (was a variable definition intended?)","pos":[643,724]},{"content":"The compiler detected an unused function prototype.","pos":[731,782]},{"content":"If the prototype was intended as a variable declaration, remove the open/close parentheses.","pos":[783,874]},{"content":"The following sample generates C4930:","pos":[881,918]},{"content":"C4930 can also occur when the compiler cannot distinguish between a function prototype declaration and a function call.","pos":[1155,1274]},{"content":"The following sample generates C4930:","pos":[1281,1318]},{"content":"In the above sample, the result of a method that takes zero arguments is passed as an argument to the constructor of an unnamed local class variable.","pos":[2405,2554]},{"content":"The call can be disambiguated by either naming the local variable or prefixing the method call with an object instance along with the appropriate pointer-to-member operator.","pos":[2555,2728]}],"content":"---\ntitle: \"Compiler Warning (level 1) C4930 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C4930\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C4930\"\nms.assetid: 89a206c9-c536-4186-8e81-1cde3e7f4f5b\ncaps.latest.revision: 10\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Compiler Warning (level 1) C4930\n'prototype': prototyped function not called (was a variable definition intended?)  \n  \n The compiler detected an unused function prototype. If the prototype was intended as a variable declaration, remove the open/close parentheses.  \n  \n The following sample generates C4930:  \n  \n```  \n// C4930.cpp  \n// compile with: /W1  \nclass Lock {  \npublic:  \n   int i;  \n};  \n  \nvoid f() {  \n   Lock theLock();   // C4930  \n   // try the following line instead  \n   // Lock theLock;  \n}  \n  \nint main() {  \n}  \n```  \n  \n C4930 can also occur when the compiler cannot distinguish between a function prototype declaration and a function call.  \n  \n The following sample generates C4930:  \n  \n```  \n// C4930b.cpp  \n// compile with: /EHsc /W1  \n  \nclass BooleanException  \n{  \n   bool _result;  \n  \npublic:  \n   BooleanException(bool result)  \n      : _result(result)  \n   {  \n   }  \n  \n   bool GetResult() const  \n   {  \n      return _result;  \n   }  \n};  \n  \ntemplate<class T = BooleanException>  \nclass IfFailedThrow  \n{  \npublic:  \n   IfFailedThrow(bool result)  \n   {  \n      if (!result)  \n      {  \n         throw T(result);  \n      }  \n   }  \n};  \n  \nclass MyClass  \n{  \npublic:  \n   bool MyFunc()  \n   {  \n      try  \n      {  \n         IfFailedThrow<>(MyMethod()); // C4930  \n  \n         // try one of the following lines instead  \n         // IfFailedThrow<> ift(MyMethod());  \n         // IfFailedThrow<>(this->MyMethod());  \n         // IfFailedThrow<>((*this).MyMethod());  \n  \n         return true;  \n      }  \n      catch (BooleanException e)  \n      {  \n         return e.GetResult();  \n      }  \n   }  \n  \nprivate:  \n   bool MyMethod()  \n   {  \n      return true;  \n   }  \n};  \n  \nint main()  \n{  \n   MyClass myClass;  \n   myClass.MyFunc();  \n}  \n```  \n  \n In the above sample, the result of a method that takes zero arguments is passed as an argument to the constructor of an unnamed local class variable. The call can be disambiguated by either naming the local variable or prefixing the method call with an object instance along with the appropriate pointer-to-member operator."}