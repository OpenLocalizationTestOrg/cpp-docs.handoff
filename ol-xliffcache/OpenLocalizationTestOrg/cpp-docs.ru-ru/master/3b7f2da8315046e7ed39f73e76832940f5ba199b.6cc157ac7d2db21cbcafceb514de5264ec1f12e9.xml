{"nodes":[{"pos":[12,50],"content":"unary_function Struct | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"unary_function Struct | Microsoft Docs","pos":[0,38]}]},{"pos":[703,724],"content":"unary_function Struct","linkify":"unary_function Struct","nodes":[{"content":"unary_function Struct","pos":[0,21]}]},{"content":"An empty base struct that defines types that may be inherited by derived classes that provides a unary function object.","pos":[725,844]},{"pos":[853,859],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[967,974],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[978,1133],"content":"The template struct serves as a base for classes that define a member function of the form <bpt id=\"p1\">**</bpt>result_type<ept id=\"p1\">**</ept><ph id=\"ph1\">`operator()`</ph>( <bpt id=\"p2\">**</bpt>constargument_type&amp;<ept id=\"p2\">**</ept>) <bpt id=\"p3\">**</bpt>const<ept id=\"p3\">**</ept>.","source":"The template struct serves as a base for classes that define a member function of the form **result_type**`operator()`( **constargument_type&**) **const**."},{"pos":[1140,1273],"content":"All such derived unary functions can refer to their sole argument type as <bpt id=\"p1\">**</bpt>argument_type<ept id=\"p1\">**</ept> and their return type as <bpt id=\"p2\">**</bpt>result_type<ept id=\"p2\">**</ept>.","source":"All such derived unary functions can refer to their sole argument type as **argument_type** and their return type as **result_type**."},{"pos":[1282,1289],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[2432,2444],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[2448,2473],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>functional&gt;","source":"**Header:** \\<functional>"},{"pos":[2480,2498],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[2507,2515],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Thread Safety in the C++ Standard Library<ept id=\"p1\">](../standard-library/thread-safety-in-the-cpp-standard-library.md)</ept><ph id=\"ph1\"> </ph>","pos":[2519,2629],"source":"[Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md) "},{"content":"<bpt id=\"p1\"> [</bpt>C++ Standard Library Reference<ept id=\"p1\">](../standard-library/cpp-standard-library-reference.md)</ept>","pos":[2632,2720],"source":" [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)"}],"content":"---\ntitle: \"unary_function Struct | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std.unary_function\"\n  - \"unary_function\"\n  - \"functional/std::unary_function\"\n  - \"std::unary_function\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"unary_function class\"\nms.assetid: 04c2fbdc-c1f6-48ed-b6cc-292a6d484627\ncaps.latest.revision: 21\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# unary_function Struct\nAn empty base struct that defines types that may be inherited by derived classes that provides a unary function object.  \n  \n## Syntax  \n```  \nstruct unary_function \n{\n   typedef Arg argument_type;\n   typedef Result result_type;\n};  \n``` \n## Remarks  \n The template struct serves as a base for classes that define a member function of the form **result_type**`operator()`( **constargument_type&**) **const**.  \n  \n All such derived unary functions can refer to their sole argument type as **argument_type** and their return type as **result_type**.  \n  \n## Example  \n  \n```cpp  \n// functional_unary_function.cpp  \n// compile with: /EHsc  \n#include <vector>  \n#include <functional>  \n#include <algorithm>  \n#include <iostream>  \n  \nusing namespace std;  \n  \n// Creation of a user-defined function object  \n// that inherits from the unary_function base class  \nclass greaterthan10: unary_function<int, bool>  \n{  \npublic:  \n    result_type operator()(argument_type i)  \n    {  \n        return (result_type)(i > 10);  \n    }  \n};  \n  \nint main()  \n{  \n    vector<int> v1;  \n    vector<int>::iterator Iter;  \n  \n    int i;  \n    for (i = 0; i <= 5; i++)  \n    {  \n        v1.push_back(5 * i);  \n    }  \n  \n    cout << \"The vector v1 = ( \" ;  \n    for (Iter = v1.begin(); Iter != v1.end(); Iter++)  \n        cout << *Iter << \" \";  \n    cout << \")\" << endl;  \n  \n    vector<int>::iterator::difference_type result1;  \n    result1 = count_if(v1.begin(), v1.end(), greaterthan10());  \n    cout << \"The number of elements in v1 greater than 10 is: \"  \n         << result1 << \".\" << endl;  \n}  \n\\* Output:   \nThe vector v1 = ( 0 5 10 15 20 25 )  \nThe number of elements in v1 greater than 10 is: 3.  \n*\\  \n```  \n  \n## Requirements  \n **Header:** \\<functional>  \n  \n **Namespace:** std  \n  \n## See Also  \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)\n\n\n\n"}