{"nodes":[{"pos":[12,49],"content":"static_cast Operator | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"static_cast Operator | Microsoft Docs","pos":[0,37]}]},{"content":"static_cast Operator","pos":[649,669]},{"pos":[670,780],"content":"Converts an <bpt id=\"p1\">*</bpt>expression<ept id=\"p1\">*</ept> to the type of <bpt id=\"p2\">*</bpt>type-id,<ept id=\"p2\">*</ept> based only on the types that are present in the expression.","source":"Converts an *expression* to the type of *type-id,* based only on the types that are present in the expression."},{"content":"Syntax","pos":[789,795]},{"content":"Remarks","pos":[859,866]},{"content":"In standard C++, no run-time type check is made to help ensure the safety of the conversion.","pos":[870,962]},{"content":"In C++/CX, a compile time and runtime check are performed.","pos":[963,1021]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Casting<ept id=\"p1\">](http://msdn.microsoft.com/Library/5247f6c7-6a0a-4021-97c9-21c868bd9455)</ept>.","pos":[1022,1130],"source":" For more information, see [Casting](http://msdn.microsoft.com/Library/5247f6c7-6a0a-4021-97c9-21c868bd9455)."},{"content":"The <ph id=\"ph1\">`static_cast`</ph> operator can be used for operations such as converting a pointer to a base class to a pointer to a derived class.","pos":[1137,1268],"source":"The `static_cast` operator can be used for operations such as converting a pointer to a base class to a pointer to a derived class."},{"content":"Such conversions are not always safe.","pos":[1269,1306]},{"content":"In general you use <ph id=\"ph1\">`static_cast`</ph> when you want to convert numeric data types such as enums to ints or ints to floats, and you are certain of the data types involved in the conversion.","pos":[1313,1496],"source":"In general you use `static_cast` when you want to convert numeric data types such as enums to ints or ints to floats, and you are certain of the data types involved in the conversion."},{"content":"conversions are not as safe as <ph id=\"ph1\">`dynamic_cast`</ph> conversions, because <ph id=\"ph2\">`static_cast`</ph> does no run-time type check, while <ph id=\"ph3\">`dynamic_cast`</ph> does.","pos":[1511,1647],"source":" conversions are not as safe as `dynamic_cast` conversions, because `static_cast` does no run-time type check, while `dynamic_cast` does."},{"content":"A <ph id=\"ph1\">`dynamic_cast`</ph> to an ambiguous pointer will fail, while a <ph id=\"ph2\">`static_cast`</ph> returns as if nothing were wrong; this can be dangerous.","pos":[1648,1778],"source":" A `dynamic_cast` to an ambiguous pointer will fail, while a `static_cast` returns as if nothing were wrong; this can be dangerous."},{"content":"Although <ph id=\"ph1\">`dynamic_cast`</ph> conversions are safer, <ph id=\"ph2\">`dynamic_cast`</ph> only works on pointers or references, and the run-time type check is an overhead.","pos":[1779,1922],"source":" Although `dynamic_cast` conversions are safer, `dynamic_cast` only works on pointers or references, and the run-time type check is an overhead."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>dynamic_cast Operator<ept id=\"p1\">](../cpp/dynamic-cast-operator.md)</ept>.","pos":[1923,2006],"source":" For more information, see [dynamic_cast Operator](../cpp/dynamic-cast-operator.md)."},{"content":"In the example that follows, the line <ph id=\"ph1\">`D* pd2 = static_cast&lt;D*&gt;(pb);`</ph> is not safe because <ph id=\"ph2\">`D`</ph> can have fields and methods that are not in <ph id=\"ph3\">`B`</ph>.","pos":[2013,2155],"source":"In the example that follows, the line `D* pd2 = static_cast<D*>(pb);` is not safe because `D` can have fields and methods that are not in `B`."},{"content":"However, the line <ph id=\"ph1\">`B* pb2 = static_cast&lt;B*&gt;(pd);`</ph> is a safe conversion because <ph id=\"ph2\">`D`</ph> always contains all of <ph id=\"ph3\">`B`</ph>.","pos":[2156,2266],"source":" However, the line `B* pb2 = static_cast<B*>(pd);` is a safe conversion because `D` always contains all of `B`."},{"content":"In contrast to <bpt id=\"p1\">[</bpt>dynamic_cast<ept id=\"p1\">](../cpp/dynamic-cast-operator.md)</ept>, no run-time check is made on the <ph id=\"ph1\">`static_cast`</ph> conversion of <ph id=\"ph2\">`pb`</ph>.","pos":[2682,2812],"source":"In contrast to [dynamic_cast](../cpp/dynamic-cast-operator.md), no run-time check is made on the `static_cast` conversion of `pb`."},{"content":"The object pointed to by <ph id=\"ph1\">`pb`</ph> may not be an object of type <ph id=\"ph2\">`D`</ph>, in which case the use of <ph id=\"ph3\">`*pd2`</ph> could be disastrous.","pos":[2813,2929],"source":" The object pointed to by `pb` may not be an object of type `D`, in which case the use of `*pd2` could be disastrous."},{"content":"For instance, calling a function that is a member of the <ph id=\"ph1\">`D`</ph> class, but not the <ph id=\"ph2\">`B`</ph> class, could result in an access violation.","pos":[2930,3057],"source":" For instance, calling a function that is a member of the `D` class, but not the `B` class, could result in an access violation."},{"content":"The <ph id=\"ph1\">`dynamic_cast`</ph> and <ph id=\"ph2\">`static_cast`</ph> operators move a pointer throughout a class hierarchy.","pos":[3064,3155],"source":"The `dynamic_cast` and `static_cast` operators move a pointer throughout a class hierarchy."},{"content":"However, <ph id=\"ph1\">`static_cast`</ph> relies exclusively on the information provided in the cast statement and can therefore be unsafe.","pos":[3156,3276],"source":" However, `static_cast` relies exclusively on the information provided in the cast statement and can therefore be unsafe."},{"content":"For example:","pos":[3277,3289]},{"content":"If <ph id=\"ph1\">`pb`</ph> really points to an object of type <ph id=\"ph2\">`D`</ph>, then <ph id=\"ph3\">`pd1`</ph> and <ph id=\"ph4\">`pd2`</ph> will get the same value.","pos":[3545,3638],"source":"If `pb` really points to an object of type `D`, then `pd1` and `pd2` will get the same value."},{"content":"They will also get the same value if <ph id=\"ph1\">`pb == 0`</ph>.","pos":[3639,3686],"source":" They will also get the same value if `pb == 0`."},{"content":"If <ph id=\"ph1\">`pb`</ph> points to an object of type <ph id=\"ph2\">`B`</ph> and not to the complete <ph id=\"ph3\">`D`</ph> class, then <ph id=\"ph4\">`dynamic_cast`</ph> will know enough to return zero.","pos":[3693,3820],"source":"If `pb` points to an object of type `B` and not to the complete `D` class, then `dynamic_cast` will know enough to return zero."},{"content":"However, <ph id=\"ph1\">`static_cast`</ph> relies on the programmer's assertion that <ph id=\"ph2\">`pb`</ph> points to an object of type <ph id=\"ph3\">`D`</ph> and simply returns a pointer to that supposed <ph id=\"ph4\">`D`</ph> object.","pos":[3821,3980],"source":" However, `static_cast` relies on the programmer's assertion that `pb` points to an object of type `D` and simply returns a pointer to that supposed `D` object."},{"content":"Consequently, <ph id=\"ph1\">`static_cast`</ph> can do the inverse of implicit conversions, in which case the results are undefined.","pos":[3987,4099],"source":"Consequently, `static_cast` can do the inverse of implicit conversions, in which case the results are undefined."},{"content":"It is left to the programmer to verify that the results of a <ph id=\"ph1\">`static_cast`</ph> conversion are safe.","pos":[4100,4195],"source":" It is left to the programmer to verify that the results of a `static_cast` conversion are safe."},{"content":"This behavior also applies to types other than class types.","pos":[4202,4261]},{"content":"For instance, <ph id=\"ph1\">`static_cast`</ph> can be used to convert from an int to a <ph id=\"ph2\">`char`</ph>.","pos":[4262,4337],"source":" For instance, `static_cast` can be used to convert from an int to a `char`."},{"content":"However, the resulting <ph id=\"ph1\">`char`</ph> may not have enough bits to hold the entire <ph id=\"ph2\">`int`</ph> value.","pos":[4338,4424],"source":" However, the resulting `char` may not have enough bits to hold the entire `int` value."},{"content":"Again, it is left to the programmer to verify that the results of a<ph id=\"ph1\">`static_cast`</ph> conversion are safe.","pos":[4425,4526],"source":" Again, it is left to the programmer to verify that the results of a`static_cast` conversion are safe."},{"content":"The <ph id=\"ph1\">`static_cast`</ph> operator can also be used to perform any implicit conversion, including standard conversions and user-defined conversions.","pos":[4533,4673],"source":"The `static_cast` operator can also be used to perform any implicit conversion, including standard conversions and user-defined conversions."},{"content":"For example:","pos":[4674,4686]},{"content":"The <ph id=\"ph1\">`static_cast`</ph> operator can explicitly convert an integral value to an enumeration type.","pos":[5025,5116],"source":"The `static_cast` operator can explicitly convert an integral value to an enumeration type."},{"content":"If the value of the integral type does not fall within the range of enumeration values, the resulting enumeration value is undefined.","pos":[5117,5250]},{"pos":[5257,5364],"content":"The <ph id=\"ph1\">`static_cast`</ph> operator converts a null pointer value to the null pointer value of the destination type.","source":"The `static_cast` operator converts a null pointer value to the null pointer value of the destination type."},{"content":"Any expression can be explicitly converted to type void by the <ph id=\"ph1\">`static_cast`</ph> operator.","pos":[5371,5457],"source":"Any expression can be explicitly converted to type void by the `static_cast` operator."},{"content":"The destination void type can optionally include the <ph id=\"ph1\">`const`</ph>, <ph id=\"ph2\">`volatile`</ph>, or <ph id=\"ph3\">`__unaligned`</ph> attribute.","pos":[5458,5559],"source":" The destination void type can optionally include the `const`, `volatile`, or `__unaligned` attribute."},{"content":"The <ph id=\"ph1\">`static_cast`</ph> operator cannot cast away the <ph id=\"ph2\">`const`</ph>, <ph id=\"ph3\">`volatile`</ph>, or <ph id=\"ph4\">`__unaligned`</ph> attributes.","pos":[5566,5663],"source":"The `static_cast` operator cannot cast away the `const`, `volatile`, or `__unaligned` attributes."},{"content":"See <bpt id=\"p1\">[</bpt>const_cast Operator<ept id=\"p1\">](../cpp/const-cast-operator.md)</ept> for information on removing these attributes.","pos":[5664,5766],"source":" See [const_cast Operator](../cpp/const-cast-operator.md) for information on removing these attributes."},{"content":"Due to the danger of performing unchecked casts on top of a relocating garbage collector, the use of <ph id=\"ph1\">`static_cast`</ph> should only be in performance-critical code when you are certain it will work correctly.","pos":[5773,5976],"source":"Due to the danger of performing unchecked casts on top of a relocating garbage collector, the use of `static_cast` should only be in performance-critical code when you are certain it will work correctly."},{"content":"If you must use <ph id=\"ph1\">`static_cast`</ph> in release mode, substitute it with <bpt id=\"p1\">[</bpt>safe_cast<ept id=\"p1\">](../windows/safe-cast-cpp-component-extensions.md)</ept> in your debug builds to ensure success.","pos":[5977,6144],"source":" If you must use `static_cast` in release mode, substitute it with [safe_cast](../windows/safe-cast-cpp-component-extensions.md) in your debug builds to ensure success."},{"content":"See Also","pos":[6153,6161]},{"content":"Casting Operators","pos":[6166,6183]},{"content":"Keywords","pos":[6219,6227]}],"content":"---\ntitle: \"static_cast Operator | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"static_cast\"\n  - \"static_cast_cpp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"static_cast keyword [C++]\"\nms.assetid: 1f7c0c1c-b288-476c-89d6-0e2ceda5c293\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# static_cast Operator\nConverts an *expression* to the type of *type-id,* based only on the types that are present in the expression.  \n  \n## Syntax  \n  \n```  \nstatic_cast <type-id> ( expression )   \n```  \n  \n## Remarks  \n In standard C++, no run-time type check is made to help ensure the safety of the conversion. In C++/CX, a compile time and runtime check are performed. For more information, see [Casting](http://msdn.microsoft.com/Library/5247f6c7-6a0a-4021-97c9-21c868bd9455).  \n  \n The `static_cast` operator can be used for operations such as converting a pointer to a base class to a pointer to a derived class. Such conversions are not always safe.  \n  \n In general you use `static_cast` when you want to convert numeric data types such as enums to ints or ints to floats, and you are certain of the data types involved in the conversion. `static_cast` conversions are not as safe as `dynamic_cast` conversions, because `static_cast` does no run-time type check, while `dynamic_cast` does. A `dynamic_cast` to an ambiguous pointer will fail, while a `static_cast` returns as if nothing were wrong; this can be dangerous. Although `dynamic_cast` conversions are safer, `dynamic_cast` only works on pointers or references, and the run-time type check is an overhead. For more information, see [dynamic_cast Operator](../cpp/dynamic-cast-operator.md).  \n  \n In the example that follows, the line `D* pd2 = static_cast<D*>(pb);` is not safe because `D` can have fields and methods that are not in `B`. However, the line `B* pb2 = static_cast<B*>(pd);` is a safe conversion because `D` always contains all of `B`.  \n  \n```  \n// static_cast_Operator.cpp  \n// compile with: /LD  \nclass B {};  \n  \nclass D : public B {};  \n  \nvoid f(B* pb, D* pd) {  \n   D* pd2 = static_cast<D*>(pb);   // Not safe, D can have fields  \n                                   // and methods that are not in B.  \n  \n   B* pb2 = static_cast<B*>(pd);   // Safe conversion, D always  \n                                   // contains all of B.  \n}  \n```  \n  \n In contrast to [dynamic_cast](../cpp/dynamic-cast-operator.md), no run-time check is made on the `static_cast` conversion of `pb`. The object pointed to by `pb` may not be an object of type `D`, in which case the use of `*pd2` could be disastrous. For instance, calling a function that is a member of the `D` class, but not the `B` class, could result in an access violation.  \n  \n The `dynamic_cast` and `static_cast` operators move a pointer throughout a class hierarchy. However, `static_cast` relies exclusively on the information provided in the cast statement and can therefore be unsafe. For example:  \n  \n```  \n// static_cast_Operator_2.cpp  \n// compile with: /LD /GR  \nclass B {  \npublic:  \n   virtual void Test(){}  \n};  \nclass D : public B {};  \n  \nvoid f(B* pb) {  \n   D* pd1 = dynamic_cast<D*>(pb);  \n   D* pd2 = static_cast<D*>(pb);  \n}  \n```  \n  \n If `pb` really points to an object of type `D`, then `pd1` and `pd2` will get the same value. They will also get the same value if `pb == 0`.  \n  \n If `pb` points to an object of type `B` and not to the complete `D` class, then `dynamic_cast` will know enough to return zero. However, `static_cast` relies on the programmer's assertion that `pb` points to an object of type `D` and simply returns a pointer to that supposed `D` object.  \n  \n Consequently, `static_cast` can do the inverse of implicit conversions, in which case the results are undefined. It is left to the programmer to verify that the results of a `static_cast` conversion are safe.  \n  \n This behavior also applies to types other than class types. For instance, `static_cast` can be used to convert from an int to a `char`. However, the resulting `char` may not have enough bits to hold the entire `int` value. Again, it is left to the programmer to verify that the results of a`static_cast` conversion are safe.  \n  \n The `static_cast` operator can also be used to perform any implicit conversion, including standard conversions and user-defined conversions. For example:  \n  \n```  \n// static_cast_Operator_3.cpp  \n// compile with: /LD /GR  \ntypedef unsigned char BYTE;  \n  \nvoid f() {  \n   char ch;  \n   int i = 65;  \n   float f = 2.5;  \n   double dbl;  \n  \n   ch = static_cast<char>(i);   // int to char  \n   dbl = static_cast<double>(f);   // float to double  \n   i = static_cast<BYTE>(ch);  \n}  \n```  \n  \n The `static_cast` operator can explicitly convert an integral value to an enumeration type. If the value of the integral type does not fall within the range of enumeration values, the resulting enumeration value is undefined.  \n  \n The `static_cast` operator converts a null pointer value to the null pointer value of the destination type.  \n  \n Any expression can be explicitly converted to type void by the `static_cast` operator. The destination void type can optionally include the `const`, `volatile`, or `__unaligned` attribute.  \n  \n The `static_cast` operator cannot cast away the `const`, `volatile`, or `__unaligned` attributes. See [const_cast Operator](../cpp/const-cast-operator.md) for information on removing these attributes.  \n  \n Due to the danger of performing unchecked casts on top of a relocating garbage collector, the use of `static_cast` should only be in performance-critical code when you are certain it will work correctly. If you must use `static_cast` in release mode, substitute it with [safe_cast](../windows/safe-cast-cpp-component-extensions.md) in your debug builds to ensure success.  \n  \n## See Also  \n [Casting Operators](../cpp/casting-operators.md)   \n [Keywords](../cpp/keywords-cpp.md)"}