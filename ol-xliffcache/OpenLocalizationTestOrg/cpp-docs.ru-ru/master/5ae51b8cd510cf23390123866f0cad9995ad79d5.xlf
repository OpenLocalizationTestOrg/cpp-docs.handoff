<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ae51b8cd510cf23390123866f0cad9995ad79d5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\mfc\reference\diagnostic-services.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">07fc3cea122ac5a37d9b451ecb9592ca8d7ddf4b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">20cebe86634460ceeb63a639dc1cdbfa8e6f35b1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Diagnostic Services | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Diagnostic Services</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The Microsoft Foundation Class Library supplies many diagnostic services that make debugging your programs easier.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>These diagnostic services include macros and global functions that allow you to track your program's memory allocations, dump the contents of objects during run time, and print debugging messages during run time.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The macros and global functions for diagnostic services are grouped into the following categories:</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>General diagnostic macros</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>General diagnostic functions and variables</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Object diagnostic functions</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>These macros and functions are available for all classes derived from <ph id="ph1">`CObject`</ph> in the Debug and Release versions of MFC.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>However, all except <ph id="ph1">`DEBUG_NEW`</ph> and <bpt id="p1">**</bpt>VERIFY<ept id="p1">**</ept> do nothing in the Release version.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In the Debug library, all allocated memory blocks are bracketed with a series of "guard bytes."</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>If these bytes are disturbed by an errant memory write, then the diagnostic routines can report a problem.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If you include the line:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#14</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>in your implementation file, all calls to <bpt id="p1">**</bpt>new<ept id="p1">**</ept> will store the filename and line number where the memory allocation took place.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The function <bpt id="p1">[</bpt>CMemoryState::DumpAllObjectsSince<ept id="p1">](cmemorystate-structure.md#cmemorystate__dumpallobjectssince)</ept> will display this extra information, allowing you to identify memory leaks.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Refer also to the class <bpt id="p1">[</bpt>CDumpContext<ept id="p1">](../../mfc/reference/cdumpcontext-class.md)</ept> for additional information on diagnostic output.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In addition, the C run-time library also supports a set of diagnostic functions you can use to debug your applications.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Debug Routines<ept id="p1">](../../c-runtime-library/debug-routines.md)</ept> in the Run-Time Library Reference.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>MFC General Diagnostic Macros</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ASSERT<ept id="p1">](#assert)</ept>)</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Prints a message and then aborts the program if the specified expression evaluates to <bpt id="p1">**</bpt>FALSE<ept id="p1">**</ept> in the Debug version of the library.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>ASSERT_KINDOF</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Tests that an object is an object of the specified class or of a class derived from the specified class.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>ASSERT_VALID</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Tests the internal validity of an object by calling its <ph id="ph1">`AssertValid`</ph> member function; typically overridden from <ph id="ph2">`CObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>DEBUG_NEW</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Supplies a filename and line number for all object allocations in Debug mode to help find memory leaks.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>DEBUG_ONLY</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Similar to <bpt id="p1">**</bpt>ASSERT<ept id="p1">**</ept> but does not test the value of the expression; useful for code that should execute only in Debug mode.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>TRACE</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Provides <ph id="ph1">`printf`</ph>-like capability in the Debug version of the library.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>VERIFY</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Similar to <bpt id="p1">**</bpt>ASSERT<ept id="p1">**</ept> but evaluates the expression in the Release version of the library as well as in the Debug version.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>MFC General Diagnostic Variables and Functions</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>afxDump</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Global variable that sends <bpt id="p1">[</bpt>CDumpContext<ept id="p1">](../../mfc/reference/cdumpcontext-class.md)</ept> information to the debugger output window or to the debug terminal.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>afxMemDF</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Global variable that controls the behavior of the debugging memory allocator.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>AfxCheckError</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Global variable used to test the passed <bpt id="p1">**</bpt>SCODE<ept id="p1">**</ept> to see if it is an error and, if so, throws the appropriate error.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>AfxCheckMemory</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Checks the integrity of all currently allocated memory.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>AfxDump</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If called while in the debugger, dumps the state of an object while debugging.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>AfxDumpStack</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Generate an image of the current stack.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This function is always linked statically.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>AfxEnableMemoryLeakDump</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Enables the memory leak dump.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>AfxEnableMemoryTracking</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Turns memory tracking on and off.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>AfxIsMemoryBlock</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Verifies that a memory block has been properly allocated.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>AfxIsValidAddress</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Verifies that a memory address range is within the program's bounds.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>AfxIsValidString</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Determines whether a pointer to a string is valid.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>AfxSetAllocHook</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Enables the calling of a function on each memory allocation.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>MFC Object Diagnostic Functions</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>AfxDoForAllClasses</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Performs a specified function on all <ph id="ph1">`CObject`</ph>-derived classes that support run-time type checking.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>AfxDoForAllObjects</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Performs a specified function on all <ph id="ph1">`CObject`</ph>-derived objects that were allocated with <bpt id="p1">**</bpt>new<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>ASSERT</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Evaluates its argument.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Specifies an expression (including pointer values) that evaluates to nonzero or 0.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>If the result is 0, the macro prints a diagnostic message and aborts the program.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If the condition is nonzero, it does nothing.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The diagnostic message has the form</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is the name of the source file, and <bpt id="p2">*</bpt>num<ept id="p2">*</ept> is the line number of the assertion that failed in the source file.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In the Release version of MFC, <bpt id="p1">**</bpt>ASSERT<ept id="p1">**</ept> does not evaluate the expression and thus will not interrupt the program.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If the expression must be evaluated regardless of environment, use the <bpt id="p1">**</bpt>VERIFY<ept id="p1">**</ept> macro in place of <bpt id="p2">**</bpt>ASSERT<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This function is available only in the Debug version of MFC.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>NVC_MFC_Utilities#44</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>ASSERT_KINDOF</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This macro asserts that the object pointed to is an object of the specified class, or is an object of a class derived from the specified class.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>classname</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The name of a <ph id="ph1">`CObject`</ph>-derived class.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>pobject</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A pointer to a class object.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>pobject<ept id="p1">*</ept> parameter should be a pointer to an object and can be <bpt id="p2">**</bpt>const<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The object pointed to and the class must support <ph id="ph1">`CObject`</ph> run-time class information.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>As an example, to ensure that <ph id="ph1">`pDocument`</ph> is a pointer to an object of the <ph id="ph2">`CMyDoc`</ph> class, or any of its derivatives, you could code:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>NVC_MFCDocView#194</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Using the <ph id="ph1">`ASSERT_KINDOF`</ph> macro is exactly the same as coding:</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>NVC_MFCDocView#195</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>This function works only for classes declared with the [DECLARE_DYNAMIC](run-time-object-model-services.md#declare_dynamic or <bpt id="p1">[</bpt>DECLARE_SERIAL<ept id="p1">](run-time-object-model-services.md#declare_serial)</ept> macro.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This function is available only in the Debug version of MFC.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>ASSERT_VALID</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Use to test your assumptions about the validity of an object's internal state.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Specifies an object of a class derived from <ph id="ph1">`CObject`</ph> that has an overriding version of the <ph id="ph2">`AssertValid`</ph> member function.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>calls the <ph id="ph1">`AssertValid`</ph> member function of the object passed as its argument.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>In the Release version of MFC, <ph id="ph1">`ASSERT_VALID`</ph> does nothing.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In the Debug version, it validates the pointer, checks against <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>, and calls the object's own <ph id="ph1">`AssertValid`</ph> member functions.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>If any of these tests fails, an alert message is displayed in the same manner as <bpt id="p1">[</bpt>ASSERT<ept id="p1">](#assert)</ept>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>This function is available only in the Debug version of MFC.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>For more information and examples, see <bpt id="p1">[</bpt>Debugging MFC Applications<ept id="p1">](/visualstudio/debugger/mfc-debugging-techniques)</ept>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#19</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>DEBUG_NEW</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Assists in finding memory leaks.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>You can use <ph id="ph1">`DEBUG_NEW`</ph> everywhere in your program that you would ordinarily use the <bpt id="p1">**</bpt>new<ept id="p1">**</ept> operator to allocate heap storage.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>In debug mode (when the <bpt id="p1">**</bpt>_DEBUG<ept id="p1">**</ept> symbol is defined), <ph id="ph1">`DEBUG_NEW`</ph> keeps track of the filename and line number for each object that it allocates.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Then, when you use the <bpt id="p1">[</bpt>CMemoryState::DumpAllObjectsSince<ept id="p1">](cmemorystate-structure.md#cmemorystate__dumpallobjectssince)</ept> member function, each object allocated with <ph id="ph1">`DEBUG_NEW`</ph> is shown with the filename and line number where it was allocated.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>To use <ph id="ph1">`DEBUG_NEW`</ph>, insert the following directive into your source files:</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#14</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Once you insert this directive, the preprocessor will insert <ph id="ph1">`DEBUG_NEW`</ph> wherever you use <bpt id="p1">**</bpt>new<ept id="p1">**</ept>, and MFC does the rest.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>When you compile a release version of your program, <ph id="ph1">`DEBUG_NEW`</ph> resolves to a simple <bpt id="p1">**</bpt>new<ept id="p1">**</ept> operation, and the filename and line number information are not generated.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In previous versions of MFC (4.1 and earlier) you needed to put the <ph id="ph1">`#define`</ph> statement after all statements that called the <ph id="ph2">`IMPLEMENT_DYNCREATE`</ph> or <ph id="ph3">`IMPLEMENT_SERIAL`</ph> macros.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>This is no longer necessary.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>DEBUG_ONLY</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>In debug mode (when the <bpt id="p1">**</bpt>_DEBUG<ept id="p1">**</ept> symbol is defined), <ph id="ph1">`DEBUG_ONLY`</ph> evaluates its argument.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>In a release build, <bpt id="p1">**</bpt>DEBUG_ONLY<ept id="p1">**</ept> does not evaluate its argument.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>This is useful when you have code that should be executed only in debug builds.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`DEBUG_ONLY`</ph> macro is equivalent to surrounding <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> with <bpt id="p2">**</bpt>#ifdef _DEBUG<ept id="p2">**</ept> and <ph id="ph2">`#endif`</ph>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>NVC_MFC_Utilities#32</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>TRACE</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Sends the specified string to the debugger of the current application.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>ATLTRACE2<ept id="p1">](http://msdn.microsoft.com/library/467ff555-e7a5-4f94-bdd9-50ee27ab9986)</ept> for a description of <bpt id="p2">**</bpt>TRACE<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>TRACE<ept id="p1">**</ept> and <ph id="ph1">`ATLTRACE2`</ph> have the same behavior.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>In the debug version of MFC, this macro sends the specified string to the debugger of the current application.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>In a release build, this macro compiles to nothing (no code is generated at all).</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Debugging MFC Applications<ept id="p1">](/visualstudio/debugger/mfc-debugging-techniques)</ept>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>VERIFY</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>In the Debug version of MFC, evaluates its argument.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Specifies an expression (including pointer values) that evaluates to nonzero or 0.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>If the result is 0, the macro prints a diagnostic message and halts the program.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>If the condition is nonzero, it does nothing.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The diagnostic message has the form</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is the name of the source file and <bpt id="p2">*</bpt>num<ept id="p2">*</ept> is the line number of the assertion that failed in the source file.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>In the Release version of MFC, <bpt id="p1">**</bpt>VERIFY<ept id="p1">**</ept> evaluates the expression but does not print or interrupt the program.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For example, if the expression is a function call, the call will be made.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>NVC_MFCDocView#198</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>afxDump (CDumpContext in MFC)</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Provides basic object-dumping capability in your application.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>is a predefined <bpt id="p1">[</bpt>CDumpContext<ept id="p1">](../../mfc/reference/cdumpcontext-class.md)</ept> object that allows you to send <ph id="ph1">`CDumpContext`</ph> information to the debugger output window or to a debug terminal.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Typically, you supply <ph id="ph1">`afxDump`</ph> as a parameter to <ph id="ph2">`CObject::Dump`</ph>.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Under Windows NT and all versions of Windows, <ph id="ph1">`afxDump`</ph> output is sent to the Output-Debug window of Visual C++ when you debug your application.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>This variable is defined only in the Debug version of MFC.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>For more information on <ph id="ph1">`afxDump`</ph>, see <bpt id="p1">[</bpt>Debugging MFC Applications<ept id="p1">](/visualstudio/debugger/mfc-debugging-techniques)</ept>.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>NVC_MFC_Utilities#23</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>afxMemDF</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>This variable is accessible from a debugger or your program and allows you to tune allocation diagnostics.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>can have the following values as specified by the enumeration <ph id="ph1">`afxMemDF`</ph>:</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>allocMemDF<ept id="p1">**</ept> Turns on debugging allocator (default setting in Debug library).</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>delayFreeMemDF<ept id="p1">**</ept> Delays freeing memory.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>While your program frees a memory block, the allocator does not return that memory to the underlying operating system.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>This will place maximum memory stress on your program.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>checkAlwaysMemDF<ept id="p1">**</ept> Calls <ph id="ph1">`AfxCheckMemory`</ph> every time memory is allocated or freed.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>This will significantly slow memory allocations and deallocations.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>NVC_MFC_Utilities#30</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>AfxCheckError</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>This function tests the passed <bpt id="p1">**</bpt>SCODE<ept id="p1">**</ept> to see if it is an error.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If it is an error, the function throws an exception.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>If the passed <ph id="ph1">`SCODE`</ph> is <bpt id="p1">**</bpt>E_OUTOFMEMORY<ept id="p1">**</ept>, the function throws a <bpt id="p2">[</bpt>CMemoryException<ept id="p2">](../../mfc/reference/cmemoryexception-class.md)</ept> by calling <bpt id="p3">[</bpt>AfxThrowMemoryException<ept id="p3">](exception-processing.md#afxthrowmemoryexception)</ept>.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Otherwise, the function throws a <bpt id="p1">[</bpt>COleException<ept id="p1">](../../mfc/reference/coleexception-class.md)</ept> by calling <bpt id="p2">[</bpt>AfxThrowOleException<ept id="p2">](exception-processing.md#afxthrowoleexception)</ept>.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>This function can be used to check the return values of calls to OLE functions in your application.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>By testing the return value with this function in your application, you can properly react to error conditions with a minimal amount of code.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>This function has the same effect in debug and non-debug builds.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>NVC_MFCOleContainer#33</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>AfxCheckMemory</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>This function validates the free memory pool and prints error messages as required.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Nonzero if no memory errors; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>If the function detects no memory corruption, it prints nothing.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>All memory blocks currently allocated on the heap are checked, including those allocated by <bpt id="p1">**</bpt>new<ept id="p1">**</ept> but not those allocated by direct calls to underlying memory allocators, such as the <ph id="ph1">`malloc`</ph> function or the <bpt id="p2">**</bpt>GlobalAlloc<ept id="p2">**</ept> Windows function.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>If any block is found to be corrupted, a message is printed to the debugger output.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>If you include the line</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#14</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>in a program module, then subsequent calls to <ph id="ph1">`AfxCheckMemory`</ph> show the filename and line number where the memory was allocated.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>If your module contains one or more implementations of serializable classes, then you must put the <ph id="ph1">`#define`</ph> line after the last <ph id="ph2">`IMPLEMENT_SERIAL`</ph> macro call.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>This function works only in the Debug version of MFC.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>NVC_MFCCObjectSample#26</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>AfxDump (MFC)</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Call this function while in the debugger to dump the state of an object while debugging.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>A pointer to an object of a class derived from <ph id="ph1">`CObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AfxDump<ept id="p1">**</ept> calls an object's <ph id="ph1">`Dump`</ph> member function and sends the information to the location specified by the <ph id="ph2">`afxDump`</ph> variable.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AfxDump<ept id="p1">**</ept> is available only in the Debug version of MFC.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Your program code should not call <bpt id="p1">**</bpt>AfxDump<ept id="p1">**</ept>, but should instead call the <ph id="ph1">`Dump`</ph> member function of the appropriate object.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>AfxDumpStack</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>This global function can be used to generate an image of the current stack.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>dwTarget</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Indicates the target of the dump output.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Possible values, which can be combined using the bitwise-OR ( <bpt id="p1">**</bpt>&amp;#124;<ept id="p1">**</ept>) operator, are as follows:</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AFX_STACK_DUMP_TARGET_TRACE<ept id="p1">**</ept> Sends output by means of the <bpt id="p2">[</bpt>TRACE<ept id="p2">](#trace)</ept> macro.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>TRACE<ept id="p1">**</ept> macro generates output in debug builds only; it generates no output in release builds.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Also, <bpt id="p1">**</bpt>TRACE<ept id="p1">**</ept> can be redirected to other targets besides the debugger.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AFX_STACK_DUMP_TARGET_DEFAULT<ept id="p1">**</ept> Sends dump output to the default target.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>For a debug build, output goes to the <bpt id="p1">**</bpt>TRACE<ept id="p1">**</ept> macro.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>In a release build, output goes to the Clipboard.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AFX_STACK_DUMP_TARGET_CLIPBOARD<ept id="p1">**</ept> Sends output to the Clipboard only.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The data is placed on the Clipboard as plain text using the <bpt id="p1">**</bpt>CF_TEXT<ept id="p1">**</ept> Clipboard format.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AFX_STACK_DUMP_TARGET_BOTH<ept id="p1">**</ept> Sends output to the Clipboard and to the <bpt id="p2">**</bpt>TRACE<ept id="p2">**</ept> macro, simultaneously.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AFX_STACK_DUMP_TARGET_ODS<ept id="p1">**</ept> Sends output directly to the debugger by means of the Win32 function <bpt id="p2">**</bpt>OutputDebugString()<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>This option will generate debugger output in both debug and release builds when a debugger is attached to the process.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AFX_STACK_DUMP_TARGET_ODS<ept id="p1">**</ept> always reaches the debugger (if it is attached) and cannot be redirected.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The example below reflects a single line of the output generated from calling <ph id="ph1">`AfxDumpStack`</ph> from a button handler in an MFC dialog application:</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Each line in the output above indicates the address of the last function call, the full path name of the module that contains the function call, and the function prototype called.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>If the function call on the stack does not happen at the exact address of the function, an offset of bytes is shown.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>For example, the following table describes the first line of the above output:</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The return address of the last function call.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The full path name of the module that contains the function call.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The function prototype called.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The offset in bytes from the address of the function prototype (in this case, <ph id="ph1">`void AfxDumpStack(unsigned long)`</ph>) to the return address (in this case, <ph id="ph2">`00427D55`</ph>).</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>is available in debug and nondebug versions of the MFC libraries; however, the function is always linked statically, even when your executable file uses MFC in a shared DLL.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>In shared-library implementations, the function is found in the MFCS42.LIB library (and its variants).</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>To use this function successfully:</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The file IMAGEHLP.DLL must be on your path.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>If you do not have this DLL, the function will display an error message.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Image Help Library<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680321)</ept> for information on the function set provided by IMAGEHLP.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The modules that have frames on the stack must include debugging information.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>If they do not contain debugging information, the function will still generate a stack trace, but the trace will be less detailed.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>AfxEnableMemoryLeakDump</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Enables and disables the memory leak dump in the <ph id="ph1">`AFX_DEBUG_STATE`</ph> destructor.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>[in]</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>indicates the memory leak dump is enabled; <ph id="ph1">`FALSE`</ph> indicates the memory leak dump is disabled.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The previous value for this flag.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>When an application unloads the MFC library, the MFC library checks for memory leaks.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>At this point, any memory leaks are reported to the user through the <bpt id="p1">**</bpt>Debug<ept id="p1">**</ept> window of <ph id="ph1">[!INCLUDE[vsprvs](../../assembler/masm/includes/vsprvs_md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>If your application loads another library before the MFC library, some memory allocations in that library will be incorrectly reported as memory leaks.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>False memory leaks can cause your application to close slowly as the MFC library reports them.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>In this case, use <ph id="ph1">`AfxEnableMemoryLeakDump`</ph> to disable the memory leak dump.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>If you use this method to turn off the memory leak dump, you will not receive reports of valid memory leaks in your application.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>You should only use this method if you are confident that the memory leak report contains false memory leaks.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>AfxEnableMemoryTracking</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Diagnostic memory tracking is normally enabled in the Debug version of MFC.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>bTrack</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Setting this value to <bpt id="p1">**</bpt>TRUE<ept id="p1">**</ept> turns on memory tracking; <bpt id="p2">**</bpt>FALSE<ept id="p2">**</ept> turns it off.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The previous setting of the tracking-enable flag.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Use this function to disable tracking on sections of your code that you know are allocating blocks correctly.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>For more information on <ph id="ph1">`AfxEnableMemoryTracking`</ph>, see <bpt id="p1">[</bpt>Debugging MFC Applications<ept id="p1">](/visualstudio/debugger/mfc-debugging-techniques)</ept>.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>This function works only in the Debug version of MFC.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>NVC_MFC_Utilities#24</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>AfxIsMemoryBlock</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Tests a memory address to make sure it represents a currently active memory block that was allocated by the diagnostic version of <bpt id="p1">**</bpt>new<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Points to the block of memory to be tested.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Contains the length of the memory block in bytes.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Points to a <bpt id="p1">**</bpt>long<ept id="p1">**</ept> integer that will be filled in with the memory block's allocation sequence number, or zero if it does not represent a currently active memory block.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Nonzero if the memory block is currently allocated and the length is correct; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>It also checks the specified size against the original allocated size.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>If the function returns nonzero, the allocation sequence number is returned in <ph id="ph1">`plRequestNumber`</ph>.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>This number represents the order in which the block was allocated relative to all other <bpt id="p1">**</bpt>new<ept id="p1">**</ept> allocations.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>NVC_MFC_Utilities#27</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>AfxIsValidAddress</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Tests any memory address to ensure that it is contained entirely within the program's memory space.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Points to the memory address to be tested.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Contains the number of bytes of memory to be tested.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>bReadWrite</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Specifies whether the memory is both for reading and writing ( <bpt id="p1">**</bpt>TRUE<ept id="p1">**</ept>) or just reading ( <bpt id="p2">**</bpt>FALSE<ept id="p2">**</ept>).</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>In debug builds, nonzero if the specified memory block is contained entirely within the program's memory space; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>In non-debug builds, nonzero if <ph id="ph1">`lp`</ph> is not NULL; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The address is not restricted to blocks allocated by <bpt id="p1">**</bpt>new<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>NVC_MFC_Utilities#28</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>AfxIsValidString</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Use this function to determine whether a pointer to a string is valid.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>The pointer to test.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Specifies the length of the string to be tested, in bytes.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>A value of 1 indicates that the string will be null-terminated.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>In debug builds, nonzero if the specified pointer points to a string of the specified size; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>In non-debug builds, nonzero if <ph id="ph1">`lpsz`</ph> is not NULL; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>NVC_MFC_Utilities#29</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>AfxSetAllocHook</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Sets a hook that enables calling of the specified function before each memory block is allocated.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>pfnAllocHook</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>Specifies the name of the function to call.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>See the Remarks for the prototype of an allocation function.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Nonzero if you want to permit the allocation; otherwise 0.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The Microsoft Foundation Class Library debug-memory allocator can call a user-defined hook function to allow the user to monitor a memory allocation and to control whether the allocation is permitted.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>Allocation hook functions are prototyped as follows:</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>BOOL AFXAPI AllocHook( size_t<ept id="p1">**</ept> <ph id="ph1">`nSize`</ph><bpt id="p2">**</bpt>, BOOL<ept id="p2">**</ept> <ph id="ph2">`bObject`</ph><bpt id="p3">**</bpt>, LONG<ept id="p3">**</ept> <ph id="ph3">`lRequestNumber`</ph> <bpt id="p4">**</bpt>);<ept id="p4">**</ept></source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The size of the proposed memory allocation.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> **</bpt>TRUE<ept id="p1">**</ept> if the allocation is for a <ph id="ph1">`CObject`</ph>-derived object; otherwise <bpt id="p2">**</bpt>FALSE<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The memory allocation's sequence number.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Note that the <bpt id="p1">**</bpt>AFXAPI<ept id="p1">**</ept> calling convention implies that the callee must remove the parameters from the stack.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>AfxDoForAllClasses</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Calls the specified iteration function for all serializable <ph id="ph1">`CObject`</ph>-derived classes in the application's memory space.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Points to an iteration function to be called for each class.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>The function arguments are a pointer to a <ph id="ph1">`CRuntimeClass`</ph> object and a void pointer to extra data that the caller supplies to the function.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Points to optional data that the caller can supply to the iteration function.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>This pointer can be <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Serializable <ph id="ph1">`CObject`</ph>-derived classes are classes derived using the <ph id="ph2">`DECLARE_SERIAL`</ph> macro.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>The pointer that is passed to <ph id="ph1">`AfxDoForAllClasses`</ph> in <ph id="ph2">`pContext`</ph> is passed to the specified iteration function each time it is called.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>This function works only in the Debug version of MFC.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>NVC_MFCCollections#113</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>NVC_MFCCollections#114</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>AfxDoForAllObjects</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>Executes the specified iteration function for all objects derived from <ph id="ph1">`CObject`</ph> that have been allocated with <bpt id="p1">**</bpt>new<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Points to an iteration function to execute for each object.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>The function arguments are a pointer to a <ph id="ph1">`CObject`</ph> and a void pointer to extra data that the caller supplies to the function.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Points to optional data that the caller can supply to the iteration function.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>This pointer can be <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Stack, global, or embedded objects are not enumerated.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>The pointer passed to <ph id="ph1">`AfxDoForAllObjects`</ph> in <ph id="ph2">`pContext`</ph> is passed to the specified iteration function each time it is called.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>This function works only in the Debug version of MFC.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>NVC_MFCCollections#115</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>NVC_MFCCollections#116</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>Macros and Globals</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>