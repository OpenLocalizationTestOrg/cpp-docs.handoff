{"nodes":[{"pos":[12,88],"content":"How to: Use Schedule Groups to Influence Order of Execution | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Use Schedule Groups to Influence Order of Execution | Microsoft Docs","pos":[0,76]}]},{"content":"How to: Use Schedule Groups to Influence Order of Execution","pos":[718,777]},{"content":"In the Concurrency Runtime, the order in which tasks are scheduled is non-deterministic.","pos":[778,866]},{"content":"However, you can use scheduling policies to influence the order in which tasks run.","pos":[867,950]},{"content":"This topic shows how to use schedule groups together with the <bpt id=\"p1\">[</bpt>concurrency::SchedulingProtocol<ept id=\"p1\">](reference/concurrency-namespace-enums.md#policyelementkey)</ept> scheduler policy to influence the order in which tasks run.","pos":[951,1165],"source":" This topic shows how to use schedule groups together with the [concurrency::SchedulingProtocol](reference/concurrency-namespace-enums.md#policyelementkey) scheduler policy to influence the order in which tasks run."},{"content":"The example runs a set of tasks two times, each with a different scheduling policy.","pos":[1173,1256]},{"content":"Both policies limit the maximum number of processing resources to two.","pos":[1257,1327]},{"content":"The first run uses the <ph id=\"ph1\">`EnhanceScheduleGroupLocality`</ph> policy, which is the default, and the second run uses the <ph id=\"ph2\">`EnhanceForwardProgress`</ph> policy.","pos":[1328,1472],"source":" The first run uses the `EnhanceScheduleGroupLocality` policy, which is the default, and the second run uses the `EnhanceForwardProgress` policy."},{"content":"Under the <ph id=\"ph1\">`EnhanceScheduleGroupLocality`</ph> policy, the scheduler runs all tasks in one schedule group until each task finishes or yields.","pos":[1473,1608],"source":" Under the `EnhanceScheduleGroupLocality` policy, the scheduler runs all tasks in one schedule group until each task finishes or yields."},{"content":"Under the <ph id=\"ph1\">`EnhanceForwardProgress`</ph> policy, the scheduler moves to the next schedule group in a round-robin manner after just one task finishes or yields.","pos":[1609,1762],"source":" Under the `EnhanceForwardProgress` policy, the scheduler moves to the next schedule group in a round-robin manner after just one task finishes or yields."},{"content":"When each schedule group contains related tasks, the <ph id=\"ph1\">`EnhanceScheduleGroupLocality`</ph> policy typically results in improved performance because cache locality is preserved between tasks.","pos":[1769,1952],"source":"When each schedule group contains related tasks, the `EnhanceScheduleGroupLocality` policy typically results in improved performance because cache locality is preserved between tasks."},{"content":"The <ph id=\"ph1\">`EnhanceForwardProgress`</ph> policy enables tasks to make forward progress and is useful when you require scheduling fairness across schedule groups.","pos":[1953,2102],"source":" The `EnhanceForwardProgress` policy enables tasks to make forward progress and is useful when you require scheduling fairness across schedule groups."},{"content":"Example","pos":[2111,2118]},{"content":"This example defines the <ph id=\"ph1\">`work_yield_agent`</ph> class, which derives from <bpt id=\"p1\">[</bpt>concurrency::agent<ept id=\"p1\">](../../parallel/concrt/reference/agent-class.md)</ept>.","pos":[2122,2261],"source":"This example defines the `work_yield_agent` class, which derives from [concurrency::agent](../../parallel/concrt/reference/agent-class.md)."},{"content":"The <ph id=\"ph1\">`work_yield_agent`</ph> class performs a unit of work, yields the current context, and then performs another unit of work.","pos":[2262,2383],"source":" The `work_yield_agent` class performs a unit of work, yields the current context, and then performs another unit of work."},{"content":"The agent uses the <bpt id=\"p1\">[</bpt>concurrency::wait<ept id=\"p1\">](reference/concurrency-namespace-functions.md#wait)</ept> function to cooperatively yield the current context so that other contexts can run.","pos":[2384,2557],"source":" The agent uses the [concurrency::wait](reference/concurrency-namespace-functions.md#wait) function to cooperatively yield the current context so that other contexts can run."},{"content":"This example creates four <ph id=\"ph1\">`work_yield_agent`</ph> objects.","pos":[2564,2617],"source":"This example creates four `work_yield_agent` objects."},{"content":"To illustrate how to set scheduler policies to affect the order in which the agents run, the example associates the first two agents with one schedule group and the other two agents with another schedule group.","pos":[2618,2828]},{"content":"The example uses the <bpt id=\"p1\">[</bpt>concurrency::CurrentScheduler::CreateScheduleGroup<ept id=\"p1\">](reference/currentscheduler-class.md#createschedulegroup)</ept> method to create the <bpt id=\"p2\">[</bpt>concurrency::ScheduleGroup<ept id=\"p2\">](../../parallel/concrt/reference/schedulegroup-class.md)</ept> objects.","pos":[2829,3074],"source":" The example uses the [concurrency::CurrentScheduler::CreateScheduleGroup](reference/currentscheduler-class.md#createschedulegroup) method to create the [concurrency::ScheduleGroup](../../parallel/concrt/reference/schedulegroup-class.md) objects."},{"content":"The example runs all four agents two times, each time with a different scheduling policy.","pos":[3075,3164]},{"pos":[3182,3210],"content":"concrt-scheduling-protocol#1"},{"content":"This example produces the following output.","pos":[3323,3366]},{"content":"Both policies produce the same sequence of events.","pos":[4622,4672]},{"content":"However, the policy that uses <ph id=\"ph1\">`EnhanceScheduleGroupLocality`</ph> starts both agents that are part of the first schedule group before it starts the agents that are part of the second group.","pos":[4673,4857],"source":" However, the policy that uses `EnhanceScheduleGroupLocality` starts both agents that are part of the first schedule group before it starts the agents that are part of the second group."},{"content":"The policy that uses <ph id=\"ph1\">`EnhanceForwardProgress`</ph> starts one agent from the first group and then starts the first agent in the second group.","pos":[4858,4994],"source":" The policy that uses `EnhanceForwardProgress` starts one agent from the first group and then starts the first agent in the second group."},{"content":"Compiling the Code","pos":[5003,5021]},{"pos":[5025,5226],"content":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named <ph id=\"ph1\">`scheduling-protocol.cpp`</ph> and then run the following command in a Visual Studio Command Prompt window.","source":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `scheduling-protocol.cpp` and then run the following command in a Visual Studio Command Prompt window."},{"content":"cl.exe /EHsc scheduling-protocol.cpp","pos":[5235,5271]},{"content":"See Also","pos":[5282,5290]},{"content":"Schedule Groups","pos":[5295,5310]},{"content":"Asynchronous Agents","pos":[5359,5378]}],"content":"---\ntitle: \"How to: Use Schedule Groups to Influence Order of Execution | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"schedule groups, using [Concurrency Runtime]\"\n  - \"using schedule groups [Concurrency Runtime]\"\nms.assetid: 73124194-fc3a-491e-a23f-fbd7b5a4455c\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# How to: Use Schedule Groups to Influence Order of Execution\nIn the Concurrency Runtime, the order in which tasks are scheduled is non-deterministic. However, you can use scheduling policies to influence the order in which tasks run. This topic shows how to use schedule groups together with the [concurrency::SchedulingProtocol](reference/concurrency-namespace-enums.md#policyelementkey) scheduler policy to influence the order in which tasks run.  \n\n  \n The example runs a set of tasks two times, each with a different scheduling policy. Both policies limit the maximum number of processing resources to two. The first run uses the `EnhanceScheduleGroupLocality` policy, which is the default, and the second run uses the `EnhanceForwardProgress` policy. Under the `EnhanceScheduleGroupLocality` policy, the scheduler runs all tasks in one schedule group until each task finishes or yields. Under the `EnhanceForwardProgress` policy, the scheduler moves to the next schedule group in a round-robin manner after just one task finishes or yields.  \n  \n When each schedule group contains related tasks, the `EnhanceScheduleGroupLocality` policy typically results in improved performance because cache locality is preserved between tasks. The `EnhanceForwardProgress` policy enables tasks to make forward progress and is useful when you require scheduling fairness across schedule groups.  \n  \n## Example  \n This example defines the `work_yield_agent` class, which derives from [concurrency::agent](../../parallel/concrt/reference/agent-class.md). The `work_yield_agent` class performs a unit of work, yields the current context, and then performs another unit of work. The agent uses the [concurrency::wait](reference/concurrency-namespace-functions.md#wait) function to cooperatively yield the current context so that other contexts can run.  \n  \n This example creates four `work_yield_agent` objects. To illustrate how to set scheduler policies to affect the order in which the agents run, the example associates the first two agents with one schedule group and the other two agents with another schedule group. The example uses the [concurrency::CurrentScheduler::CreateScheduleGroup](reference/currentscheduler-class.md#createschedulegroup) method to create the [concurrency::ScheduleGroup](../../parallel/concrt/reference/schedulegroup-class.md) objects. The example runs all four agents two times, each time with a different scheduling policy.  \n  \n [!code-cpp[concrt-scheduling-protocol#1](../../parallel/concrt/codesnippet/cpp/how-to-use-schedule-groups-to-influence-order-of-execution_1.cpp)]  \n  \n This example produces the following output.  \n  \n```Output  \nUsing EnhanceScheduleGroupLocality...  \ngroup 0,\n    task 0: first loop...  \ngroup 0,\n    task 1: first loop...  \ngroup 0,\n    task 0: waiting...  \ngroup 1,\n    task 0: first loop...  \ngroup 0,\n    task 1: waiting...  \ngroup 1,\n    task 1: first loop...  \ngroup 1,\n    task 0: waiting...  \ngroup 0,\n    task 0: second loop...  \ngroup 1,\n    task 1: waiting...  \ngroup 0,\n    task 1: second loop...  \ngroup 0,\n    task 0: finished...  \ngroup 1,\n    task 0: second loop...  \ngroup 0,\n    task 1: finished...  \ngroup 1,\n    task 1: second loop...  \ngroup 1,\n    task 0: finished...  \ngroup 1,\n    task 1: finished...  \n \nUsing EnhanceForwardProgress...  \ngroup 0,\n    task 0: first loop...  \ngroup 1,\n    task 0: first loop...  \ngroup 0,\n    task 0: waiting...  \ngroup 0,\n    task 1: first loop...  \ngroup 1,\n    task 0: waiting...  \ngroup 1,\n    task 1: first loop...  \ngroup 0,\n    task 1: waiting...  \ngroup 0,\n    task 0: second loop...  \ngroup 1,\n    task 1: waiting...  \ngroup 1,\n    task 0: second loop...  \ngroup 0,\n    task 0: finished...  \ngroup 0,\n    task 1: second loop...  \ngroup 1,\n    task 0: finished...  \ngroup 1,\n    task 1: second loop...  \ngroup 0,\n    task 1: finished...  \ngroup 1,\n    task 1: finished...  \n```  \n  \n Both policies produce the same sequence of events. However, the policy that uses `EnhanceScheduleGroupLocality` starts both agents that are part of the first schedule group before it starts the agents that are part of the second group. The policy that uses `EnhanceForwardProgress` starts one agent from the first group and then starts the first agent in the second group.  \n  \n## Compiling the Code  \n Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `scheduling-protocol.cpp` and then run the following command in a Visual Studio Command Prompt window.  \n  \n **cl.exe /EHsc scheduling-protocol.cpp**  \n  \n## See Also  \n [Schedule Groups](../../parallel/concrt/schedule-groups.md)   \n [Asynchronous Agents](../../parallel/concrt/asynchronous-agents.md)\n\n"}