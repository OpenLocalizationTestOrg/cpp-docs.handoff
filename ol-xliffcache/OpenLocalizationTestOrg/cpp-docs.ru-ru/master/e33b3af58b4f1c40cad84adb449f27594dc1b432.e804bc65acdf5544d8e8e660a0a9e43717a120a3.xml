{"nodes":[{"pos":[12,57],"content":"C++ Type System (Modern C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"C++ Type System (Modern C++) | Microsoft Docs","pos":[0,45]}]},{"content":"C++ Type System (Modern C++)","pos":[538,566]},{"content":"The concept of <bpt id=\"p1\">*</bpt>type<ept id=\"p1\">*</ept> is very important in C++.","pos":[567,614],"source":"The concept of *type* is very important in C++."},{"content":"Every variable, function argument, and function return value must have a type in order to be compiled.","pos":[615,717]},{"content":"Also, every expression (including literal values) is implicitly given a type by the compiler before it is evaluated.","pos":[718,834]},{"content":"Some examples of types include <ph id=\"ph1\">`int`</ph> to store integral values, <ph id=\"ph2\">`double`</ph> to store floating-point values (also known as <bpt id=\"p1\">*</bpt>scalar<ept id=\"p1\">*</ept> data types), or the Standard Library class <bpt id=\"p2\">[</bpt>std::basic_string<ept id=\"p2\">](../standard-library/basic-string-class.md)</ept> to store text.","pos":[835,1082],"source":" Some examples of types include `int` to store integral values, `double` to store floating-point values (also known as *scalar* data types), or the Standard Library class [std::basic_string](../standard-library/basic-string-class.md) to store text."},{"content":"You can create your own type by defining a <ph id=\"ph1\">`class`</ph> or <ph id=\"ph2\">`struct`</ph>.","pos":[1083,1146],"source":" You can create your own type by defining a `class` or `struct`."},{"content":"The type specifies the amount of memory that will be allocated for the variable (or expression result), the kinds of values that may be stored in that variable, how those values (as bit patterns) are interpreted, and the operations that can be performed on it.","pos":[1147,1407]},{"content":"This article contains an informal overview of the major features of the C++ type system.","pos":[1408,1496]},{"content":"Terminology","pos":[1505,1516]},{"content":"<bpt id=\"p1\">**</bpt>Variable<ept id=\"p1\">**</ept>: The symbolic name of a quantity of data so that the name can be used to access the data it refers to throughout the scope of the code where it is defined.","pos":[1520,1688],"source":"**Variable**: The symbolic name of a quantity of data so that the name can be used to access the data it refers to throughout the scope of the code where it is defined."},{"content":"In C++, “variable” is generally used to refer to instances of scalar data types, whereas instances of other types are usually called “objects”.","pos":[1689,1832]},{"pos":[1839,2052],"content":"<bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept>: For simplicity and consistency, this article uses the term “object” to refer to any instance of a class or structure, and when it is used in the general sense includes all types, even scalar variables.","source":"**Object**: For simplicity and consistency, this article uses the term “object” to refer to any instance of a class or structure, and when it is used in the general sense includes all types, even scalar variables."},{"content":"<bpt id=\"p1\">**</bpt>POD type<ept id=\"p1\">**</ept> (plain old data): This informal category of data types in C++ refers to types that are scalar (see the Fundamental types section) or are <bpt id=\"p2\">*</bpt>POD classes<ept id=\"p2\">*</ept>.","pos":[2059,2223],"source":"**POD type** (plain old data): This informal category of data types in C++ refers to types that are scalar (see the Fundamental types section) or are *POD classes*."},{"content":"A POD class has no static data members that aren’t also PODs, and has no user-defined constructors, user-defined destructors, or user-defined assignment operators.","pos":[2224,2387]},{"content":"Also, a POD class has no virtual functions, no base class, and no private or protected non-static data members.","pos":[2388,2499]},{"content":"POD types are often used for external data interchange, for example with a module written in the C language (which has POD types only).","pos":[2500,2635]},{"content":"Specifying variable and function types","pos":[2644,2682]},{"content":"C++ is a <bpt id=\"p1\">*</bpt>strongly typed<ept id=\"p1\">*</ept> language and it is also <bpt id=\"p2\">*</bpt>statically-typed<ept id=\"p2\">*</ept>; every object has a type and that type never changes (not to be confused with static data objects).","pos":[2686,2854],"source":"C++ is a *strongly typed* language and it is also *statically-typed*; every object has a type and that type never changes (not to be confused with static data objects)."},{"content":"<bpt id=\"p1\">**</bpt>When you declare a variable<ept id=\"p1\">**</ept> in your code, you must either specify its type explicitly, or use the <ph id=\"ph1\">`auto`</ph> keyword to instruct the compiler to deduce the type from the initializer.","pos":[2858,3040],"source":"**When you declare a variable** in your code, you must either specify its type explicitly, or use the `auto` keyword to instruct the compiler to deduce the type from the initializer."},{"content":"<bpt id=\"p1\">**</bpt>When you declare a function<ept id=\"p1\">**</ept> in your code, you must specify the type of each argument and its return value, or <ph id=\"ph1\">`void`</ph> if no value is returned by the function.","pos":[3044,3205],"source":"**When you declare a function** in your code, you must specify the type of each argument and its return value, or `void` if no value is returned by the function."},{"content":"The exception is when you are using function templates, which allow for arguments of arbitrary types.","pos":[3206,3307]},{"content":"After you first declare a variable, you cannot change its type at some later point.","pos":[3314,3397]},{"content":"However, you can copy the variable’s value or a function’s return value into another variable of a different type.","pos":[3398,3512]},{"content":"Such operations are called <bpt id=\"p1\">*</bpt>type conversions<ept id=\"p1\">*</ept>, which are sometimes necessary but are also potential sources of data loss or incorrectness.","pos":[3513,3651],"source":" Such operations are called *type conversions*, which are sometimes necessary but are also potential sources of data loss or incorrectness."},{"content":"When you declare a variable of POD type, we strongly recommend you initialize it, which means to give it an initial value.","pos":[3658,3780]},{"content":"Until you initialize a variable, it has a \"garbage\" value that consists of whatever bits happened to be in that memory location previously.","pos":[3781,3920]},{"content":"This is an important aspect of C++ to remember, especially if you are coming from another language that handles initialization for you.","pos":[3921,4056]},{"content":"When declaring a variable of non-POD class type, the constructor handles initialization.","pos":[4057,4145]},{"content":"The following example shows some simple variable declarations with some descriptions for each.","pos":[4152,4246]},{"content":"The example also shows how the compiler uses type information to allow or disallow certain subsequent operations on the variable.","pos":[4247,4376]},{"content":"Fundamental (built-in) types","pos":[5306,5334]},{"content":"Unlike some languages, C++ has no universal base type from which all other types are derived.","pos":[5338,5431]},{"content":"The <ph id=\"ph1\">[!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)]</ph> implementation of the language includes many <bpt id=\"p1\">*</bpt>fundamental types<ept id=\"p1\">*</ept>, also known as <bpt id=\"p2\">*</bpt>built-in types<ept id=\"p2\">*</ept>.","pos":[5432,5584],"source":" The [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)] implementation of the language includes many *fundamental types*, also known as *built-in types*."},{"content":"This includes numeric types such as <ph id=\"ph1\">`int`</ph>, <ph id=\"ph2\">`double`</ph>, <ph id=\"ph3\">`long`</ph>, <ph id=\"ph4\">`bool`</ph>, plus the <ph id=\"ph5\">`char`</ph> and <ph id=\"ph6\">`wchar_t`</ph> types for ASCII and UNICODE characters, respectively.","pos":[5585,5737],"source":" This includes numeric types such as `int`, `double`, `long`, `bool`, plus the `char` and `wchar_t` types for ASCII and UNICODE characters, respectively."},{"content":"Most fundamental types (except <ph id=\"ph1\">`bool`</ph>, <ph id=\"ph2\">`double`</ph>, <ph id=\"ph3\">`wchar_t`</ph> and related types) all have unsigned versions, which modify the range of values that the variable can store.","pos":[5738,5905],"source":" Most fundamental types (except `bool`, `double`, `wchar_t` and related types) all have unsigned versions, which modify the range of values that the variable can store."},{"content":"For example, an <ph id=\"ph1\">`int`</ph>, which stores a 32-bit signed integer, can represent a value from -2,147,483,648 to 2,147,483,647.","pos":[5906,6026],"source":" For example, an `int`, which stores a 32-bit signed integer, can represent a value from -2,147,483,648 to 2,147,483,647."},{"content":"An <ph id=\"ph1\">`unsigned int`</ph>, which is also stored as 32-bits, can store a value from 0 to 4,294,967,295.","pos":[6027,6121],"source":" An `unsigned int`, which is also stored as 32-bits, can store a value from 0 to 4,294,967,295."},{"content":"The total number of possible values in each case is the same; only the range is different.","pos":[6122,6212]},{"content":"The fundamental types are recognized by the compiler, which has built-in rules that govern what operations you can perform on them, and how they can be converted to other fundamental types.","pos":[6219,6408]},{"content":"For a complete list of built-in types and their size and numeric limits, see <bpt id=\"p1\">[</bpt>Fundamental Types<ept id=\"p1\">](../cpp/fundamental-types-cpp.md)</ept>.","pos":[6409,6539],"source":" For a complete list of built-in types and their size and numeric limits, see [Fundamental Types](../cpp/fundamental-types-cpp.md)."},{"content":"The following illustration shows the relative sizes of the built-in types:","pos":[6546,6620]},{"content":"Size in bytes of built&amp;#45;in types","pos":[6629,6664],"source":"Size in bytes of built&#45;in types"},{"content":"The following table lists the most frequently used fundamental types:","pos":[6728,6797]},{"content":"Type","pos":[6804,6808]},{"content":"Size","pos":[6809,6813]},{"content":"Comment","pos":[6814,6821]},{"content":"int","pos":[6866,6869]},{"content":"4 bytes","pos":[6870,6877]},{"content":"The default choice for integral values.","pos":[6878,6917]},{"content":"double","pos":[6922,6928]},{"content":"8 bytes","pos":[6929,6936]},{"content":"The default choice for floating point values.","pos":[6937,6982]},{"content":"bool","pos":[6987,6991]},{"content":"1 byte","pos":[6992,6998]},{"content":"Represents values that can be either true or false.","pos":[6999,7050]},{"content":"char","pos":[7055,7059]},{"content":"1 byte","pos":[7060,7066]},{"content":"Use for ASCII characters in older C-style strings or std::string objects that will never have to be converted to UNICODE.","pos":[7067,7188]},{"content":"wchar_t","pos":[7193,7200]},{"content":"2 bytes","pos":[7201,7208]},{"content":"Represents \"wide\" character values that may be encoded in UNICODE format (UTF-16 on Windows, other operating systems may differ).","pos":[7209,7338]},{"content":"This is the character type that is used in strings of type <ph id=\"ph1\">`std::wstring`</ph>.","pos":[7339,7413],"source":" This is the character type that is used in strings of type `std::wstring`."},{"content":"unsigned char","pos":[7418,7431]},{"content":"1 byte","pos":[7432,7438]},{"content":"C++ has no built-in <ph id=\"ph1\">`byte`</ph> type.","pos":[7439,7471],"source":"C++ has no built-in `byte` type."},{"content":"Use unsigned char to represent a byte value.","pos":[7473,7517]},{"content":"unsigned int","pos":[7522,7534]},{"content":"4 bytes","pos":[7535,7542]},{"content":"Default choice for bit flags.","pos":[7543,7572]},{"content":"long long","pos":[7577,7586]},{"content":"8 bytes","pos":[7587,7594]},{"content":"Represents very large integer values.","pos":[7595,7632]},{"content":"The void type","pos":[7642,7655]},{"content":"The <ph id=\"ph1\">`void`</ph> type is a special type; you cannot declare a variable of type <ph id=\"ph2\">`void`</ph>, but you can declare a variable of type <ph id=\"ph3\">`void *`</ph> (pointer to <ph id=\"ph4\">`void`</ph>), which is sometimes necessary when allocating raw (un-typed) memory.","pos":[7659,7876],"source":"The `void` type is a special type; you cannot declare a variable of type `void`, but you can declare a variable of type `void *` (pointer to `void`), which is sometimes necessary when allocating raw (un-typed) memory."},{"content":"However, pointers to <ph id=\"ph1\">`void`</ph> are not type-safe and generally their use is strongly discouraged in modern C++.","pos":[7877,7985],"source":" However, pointers to `void` are not type-safe and generally their use is strongly discouraged in modern C++."},{"content":"In a function declaration, a <ph id=\"ph1\">`void`</ph> return value means that the function does not return a value; this is a common and acceptable use of <ph id=\"ph2\">`void`</ph>.","pos":[7986,8130],"source":" In a function declaration, a `void` return value means that the function does not return a value; this is a common and acceptable use of `void`."},{"content":"While the C language required functions that have zero parameters to declare <ph id=\"ph1\">`void`</ph> in the parameter list, for example, <ph id=\"ph2\">`fou(void)`</ph>, this practice is discouraged in modern C++ and should be declared <ph id=\"ph3\">`fou()`</ph>.","pos":[8131,8338],"source":" While the C language required functions that have zero parameters to declare `void` in the parameter list, for example, `fou(void)`, this practice is discouraged in modern C++ and should be declared `fou()`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Type Conversions and Type Safety<ept id=\"p1\">](../cpp/type-conversions-and-type-safety-modern-cpp.md)</ept>.","pos":[8339,8455],"source":" For more information, see [Type Conversions and Type Safety](../cpp/type-conversions-and-type-safety-modern-cpp.md)."},{"content":"const type qualifier","pos":[8464,8484]},{"content":"Any built-in or user-defined type may be qualified by the const keyword.","pos":[8488,8560]},{"content":"Additionally, member functions may be <ph id=\"ph1\">`const`</ph>-qualified and even <ph id=\"ph2\">`const`</ph>-overloaded.","pos":[8561,8645],"source":" Additionally, member functions may be `const`-qualified and even `const`-overloaded."},{"content":"The value of a <ph id=\"ph1\">`const`</ph> type cannot be modified after it is initialized.","pos":[8646,8717],"source":" The value of a `const` type cannot be modified after it is initialized."},{"content":"The <ph id=\"ph1\">`const`</ph> qualifier is used extensively in function and variable declarations and \"const correctness\" is an important concept in C++; essentially it means to use <ph id=\"ph2\">`const`</ph> to guarantee, at compile time, that values are not modified unintentionally.","pos":[8823,9071],"source":"The `const` qualifier is used extensively in function and variable declarations and \"const correctness\" is an important concept in C++; essentially it means to use `const` to guarantee, at compile time, that values are not modified unintentionally."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>const<ept id=\"p1\">](../cpp/const-cpp.md)</ept>.","pos":[9072,9127],"source":" For more information, see [const](../cpp/const-cpp.md)."},{"content":"A <ph id=\"ph1\">`const`</ph> type is distinct from its non-const version; for example, <ph id=\"ph2\">`const int`</ph> is a distinct type from <ph id=\"ph3\">`int`</ph>.","pos":[9134,9244],"source":"A `const` type is distinct from its non-const version; for example, `const int` is a distinct type from `int`."},{"content":"You can use the C++ <ph id=\"ph1\">`const_cast`</ph> operator on those rare occasions when you must remove <bpt id=\"p1\">*</bpt>const-ness<ept id=\"p1\">*</ept> from a variable.","pos":[9245,9361],"source":" You can use the C++ `const_cast` operator on those rare occasions when you must remove *const-ness* from a variable."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Type Conversions and Type Safety<ept id=\"p1\">](../cpp/type-conversions-and-type-safety-modern-cpp.md)</ept>.","pos":[9362,9478],"source":" For more information, see [Type Conversions and Type Safety](../cpp/type-conversions-and-type-safety-modern-cpp.md)."},{"content":"String types","pos":[9487,9499]},{"content":"Strictly speaking, the C++ language has no built-in “string” type; <ph id=\"ph1\">`char`</ph> and <ph id=\"ph2\">`wchar_t`</ph> store single characters – you must declare an array of these types to approximate a string, adding a terminating null value (for example, ASCII <ph id=\"ph3\">`‘\\0’`</ph>) to the array element one past the last valid character (also called a “C-style string”).","pos":[9503,9831],"source":"Strictly speaking, the C++ language has no built-in “string” type; `char` and `wchar_t` store single characters – you must declare an array of these types to approximate a string, adding a terminating null value (for example, ASCII `‘\\0’`) to the array element one past the last valid character (also called a “C-style string”)."},{"content":"C-style strings required much more code to be written or the use of external string utility library functions.","pos":[9832,9942]},{"content":"But in modern C++, we have the Standard Library types <ph id=\"ph1\">`std::string`</ph> (for 8-bit <ph id=\"ph2\">`char`</ph>-type character strings) or <ph id=\"ph3\">`std::wstring`</ph> (for 16-bit <ph id=\"ph4\">`wchar_t`</ph>-type character strings).","pos":[9943,10117],"source":" But in modern C++, we have the Standard Library types `std::string` (for 8-bit `char`-type character strings) or `std::wstring` (for 16-bit `wchar_t`-type character strings)."},{"content":"These STL containers can be thought of as native string types because they are part of the standard libraries that are included in any compliant C++ build environment.","pos":[10118,10285]},{"content":"Simply use the <ph id=\"ph1\">`#include &lt;string&gt;`</ph> directive to make these types available in your program.","pos":[10286,10377],"source":" Simply use the `#include <string>` directive to make these types available in your program."},{"content":"(If you are using MFC or ATL, the CString class is also available, but is not part of the C++ standard.) The use of null-terminated character arrays (the C-style strings previously mentioned) is strongly discouraged in modern C++.","pos":[10378,10608]},{"content":"User-defined types","pos":[10617,10635]},{"content":"When you define a <ph id=\"ph1\">`class`</ph>, <ph id=\"ph2\">`struct`</ph>, <ph id=\"ph3\">`union`</ph>, or <ph id=\"ph4\">`enum`</ph>, that construct is used in the rest of your code as if it were a fundamental type.","pos":[10639,10777],"source":"When you define a `class`, `struct`, `union`, or `enum`, that construct is used in the rest of your code as if it were a fundamental type."},{"content":"It has a known size in memory, and certain rules about how it can be used apply to it for compile-time checking and, at runtime, for the life of your program.","pos":[10778,10936]},{"content":"The primary differences between the fundamental built-in types and user-defined types are as follows:","pos":[10937,11038]},{"content":"The compiler has no built-in knowledge of a user-defined type.","pos":[11048,11110]},{"content":"It “learns” of the type when it first encounters the definition during the compilation process.","pos":[11111,11206]},{"content":"You specify what operations can be performed on your type, and how it can be converted to other types, by defining (through overloading) the appropriate operators, either as class members or non-member functions.","pos":[11216,11428]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Function Overloading<ept id=\"p1\">](function-overloading.md)</ept>.","pos":[11429,11503],"source":" For more information, see [Function Overloading](function-overloading.md)."},{"content":"They do not have to be statically typed (the rule that an object's type never changes).","pos":[11513,11600]},{"content":"Through the mechanisms of <bpt id=\"p1\">*</bpt>inheritance<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>polymorphism<ept id=\"p2\">*</ept>, a variable declared as a user-defined type of class (referred to as an object instance of a class) might have a different type at run-time than at compile time.","pos":[11601,11821],"source":" Through the mechanisms of *inheritance* and *polymorphism*, a variable declared as a user-defined type of class (referred to as an object instance of a class) might have a different type at run-time than at compile time."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Inheritance<ept id=\"p1\">](../cpp/inheritance-cpp.md)</ept>.","pos":[11822,11889],"source":" For more information, see [Inheritance](../cpp/inheritance-cpp.md)."},{"content":"Pointer types","pos":[11898,11911]},{"content":"Dating back to the earliest versions of the C language, C++ continues to let you declare a variable of a pointer type by using the special declarator <ph id=\"ph1\">`*`</ph> (asterisk).","pos":[11915,12080],"source":"Dating back to the earliest versions of the C language, C++ continues to let you declare a variable of a pointer type by using the special declarator `*` (asterisk)."},{"content":"A pointer type stores the address of the location in memory where the actual data value is stored.","pos":[12081,12179]},{"content":"In modern C++, these are referred to as <bpt id=\"p1\">*</bpt>raw pointers<ept id=\"p1\">*</ept>, and are accessed in your code through special operators <ph id=\"ph1\">`*`</ph> (asterisk) or <ph id=\"ph2\">`-&gt;`</ph> (dash with greater-than).","pos":[12180,12340],"source":" In modern C++, these are referred to as *raw pointers*, and are accessed in your code through special operators `*` (asterisk) or `->` (dash with greater-than)."},{"content":"This is called <bpt id=\"p1\">*</bpt>dereferencing<ept id=\"p1\">*</ept>, and which one that you use depends on whether you are dereferencing a pointer to a scalar or a pointer to a member in an object.","pos":[12341,12501],"source":" This is called *dereferencing*, and which one that you use depends on whether you are dereferencing a pointer to a scalar or a pointer to a member in an object."},{"content":"Working with pointer types has long been one of the most challenging and confusing aspects of C and C++ program development.","pos":[12502,12626]},{"content":"This section outlines some facts and practices to help use raw pointers if you want to, but in modern C++ it’s no longer required (or recommended) to use raw pointers for object ownership at all, due to the evolution of the <bpt id=\"p1\">[</bpt>smart pointer<ept id=\"p1\">](../cpp/smart-pointers-modern-cpp.md)</ept> (discussed more at the end of this section).","pos":[12627,12948],"source":" This section outlines some facts and practices to help use raw pointers if you want to, but in modern C++ it’s no longer required (or recommended) to use raw pointers for object ownership at all, due to the evolution of the [smart pointer](../cpp/smart-pointers-modern-cpp.md) (discussed more at the end of this section)."},{"content":"It is still useful and safe to use raw pointers for observing objects, but if you must use them for object ownership, you should do so with caution and very careful consideration of how the objects owned by them are created and destroyed.","pos":[12949,13187]},{"content":"The first thing that you should know is declaring a raw pointer variable will allocate only the memory that is required to store an address of the memory location that the pointer will be referring to when it is dereferenced.","pos":[13194,13419]},{"content":"Allocation of the memory for the data value itself (also called <bpt id=\"p1\">*</bpt>backing store<ept id=\"p1\">*</ept>) is not yet allocated.","pos":[13420,13522],"source":" Allocation of the memory for the data value itself (also called *backing store*) is not yet allocated."},{"content":"In other words, by declaring a raw pointer variable, you are creating a memory address variable, not an actual data variable.","pos":[13523,13648]},{"content":"Dereferencing a pointer variable before making sure that it contains a valid address to a backing store will cause undefined behavior (usually a fatal error) in your program.","pos":[13649,13823]},{"content":"The following example demonstrates this kind of error:","pos":[13824,13878]},{"content":"The example dereferences a pointer type without having any memory allocated to store the actual integer data or a valid memory address assigned to it.","pos":[14216,14366]},{"content":"The following code corrects these errors:","pos":[14367,14408]},{"content":"The corrected code example uses local stack memory to create the backing store that <ph id=\"ph1\">`pNumber`</ph> points to.","pos":[15121,15225],"source":"The corrected code example uses local stack memory to create the backing store that `pNumber` points to."},{"content":"We use a fundamental type for simplicity.","pos":[15226,15267]},{"content":"In practice, the backing store for pointers are most often user-defined types that are dynamically-allocated in an area of memory called the <bpt id=\"p1\">*</bpt>heap<ept id=\"p1\">*</ept> (or “free store”) by using a <ph id=\"ph1\">`new`</ph> keyword expression (in C-style programming, the older <ph id=\"ph2\">`malloc()`</ph> C runtime library function was used).","pos":[15268,15553],"source":" In practice, the backing store for pointers are most often user-defined types that are dynamically-allocated in an area of memory called the *heap* (or “free store”) by using a `new` keyword expression (in C-style programming, the older `malloc()` C runtime library function was used)."},{"content":"Once allocated, these “variables” are usually referred to as “objects”, especially if they are based on a class definition.","pos":[15554,15677]},{"content":"Memory that is allocated with <ph id=\"ph1\">`new`</ph> must be deleted by a corresponding <ph id=\"ph2\">`delete`</ph> statement (or, if you used the <ph id=\"ph3\">`malloc()`</ph> function to allocate it, the C runtime function <ph id=\"ph4\">`free()`</ph>).","pos":[15678,15858],"source":" Memory that is allocated with `new` must be deleted by a corresponding `delete` statement (or, if you used the `malloc()` function to allocate it, the C runtime function `free()`)."},{"content":"However, it is easy to forget to delete a dynamically-allocated object- especially in complex code, which causes a resource bug called a <bpt id=\"p1\">*</bpt>memory leak<ept id=\"p1\">*</ept>.","pos":[15865,16016],"source":"However, it is easy to forget to delete a dynamically-allocated object- especially in complex code, which causes a resource bug called a *memory leak*."},{"content":"For this reason, the use of raw pointers is strongly discouraged in modern C++.","pos":[16017,16096]},{"content":"It is almost always better to wrap a raw pointer in a <bpt id=\"p1\">[</bpt>smart pointer<ept id=\"p1\">](../cpp/smart-pointers-modern-cpp.md)</ept>, which will automatically release the memory when its destructor is invoked (when the code goes out of scope for the smart pointer); by using smart pointers you virtually eliminate a whole class of bugs in your C++ programs.","pos":[16097,16428],"source":" It is almost always better to wrap a raw pointer in a [smart pointer](../cpp/smart-pointers-modern-cpp.md), which will automatically release the memory when its destructor is invoked (when the code goes out of scope for the smart pointer); by using smart pointers you virtually eliminate a whole class of bugs in your C++ programs."},{"content":"In the following example, assume <ph id=\"ph1\">`MyClass`</ph> is a user-defined type that has a public method","pos":[16429,16519],"source":" In the following example, assume `MyClass` is a user-defined type that has a public method "},{"pos":[16780,16881],"content":"For more information about smart pointers, see <bpt id=\"p1\">[</bpt>Smart Pointers<ept id=\"p1\">](../cpp/smart-pointers-modern-cpp.md)</ept>.","source":"For more information about smart pointers, see [Smart Pointers](../cpp/smart-pointers-modern-cpp.md)."},{"pos":[16888,17030],"content":"For more information about pointer conversions, see <bpt id=\"p1\">[</bpt>Type Conversions and Type Safety<ept id=\"p1\">](../cpp/type-conversions-and-type-safety-modern-cpp.md)</ept>.","source":"For more information about pointer conversions, see [Type Conversions and Type Safety](../cpp/type-conversions-and-type-safety-modern-cpp.md)."},{"pos":[17037,17124],"content":"For more information about pointers in general, see <bpt id=\"p1\">[</bpt>Pointers<ept id=\"p1\">](../cpp/pointers-cpp.md)</ept>.","source":"For more information about pointers in general, see [Pointers](../cpp/pointers-cpp.md)."},{"content":"Windows data types","pos":[17133,17151]},{"content":"In classic Win32 programming for C and C++, most functions use Windows-specific typedefs and #define macros (defined in <ph id=\"ph1\">`windef.h`</ph>) to specify the types of parameters and return values.","pos":[17155,17340],"source":"In classic Win32 programming for C and C++, most functions use Windows-specific typedefs and #define macros (defined in `windef.h`) to specify the types of parameters and return values."},{"content":"These “Windows data types” are mostly just special names (aliases) given to C/C++ built-in types.","pos":[17341,17438]},{"content":"For a complete list of these typedefs and preprocessor definitions, see <bpt id=\"p1\">[</bpt>Windows Data Types<ept id=\"p1\">](http://msdn.microsoft.com/en-us/4553cafc-450e-4493-a4d4-cb6e2f274d46)</ept>.","pos":[17439,17602],"source":" For a complete list of these typedefs and preprocessor definitions, see [Windows Data Types](http://msdn.microsoft.com/en-us/4553cafc-450e-4493-a4d4-cb6e2f274d46)."},{"content":"Some of these typedefs, such as HRESULT and LCID, are useful and descriptive.","pos":[17603,17680]},{"content":"Others, such as INT, have no special meaning and are just aliases for fundamental C++ types.","pos":[17681,17773]},{"content":"Other Windows data types have names that are retained from the days of C programming and 16-bit processors, and have no purpose or meaning on modern hardware or operating systems.","pos":[17774,17953]},{"content":"There are also special data types associated with the Windows Runtime Library, listed as <bpt id=\"p1\">[</bpt>Windows Runtime base data types<ept id=\"p1\">](http://msdn.microsoft.com/en-us/b5735851-ec07-48c1-92b4-ca9f768096f6)</ept>.","pos":[17954,18147],"source":" There are also special data types associated with the Windows Runtime Library, listed as [Windows Runtime base data types](http://msdn.microsoft.com/en-us/b5735851-ec07-48c1-92b4-ca9f768096f6)."},{"content":"In modern C++, the general guideline is to prefer the C++ fundamental types unless the Windows type communicates some additional meaning about how the value is to be interpreted.","pos":[18148,18326]},{"content":"More Information","pos":[18335,18351]},{"content":"For more information about the C++ type system, see the following topics.","pos":[18355,18428]},{"content":"Value Types","pos":[18450,18461]},{"pos":[18497,18561],"content":"Describes <bpt id=\"p1\">*</bpt>value types<ept id=\"p1\">*</ept> along with issues relating to their use.","source":"Describes *value types* along with issues relating to their use."},{"content":"Type Conversions and Type Safety","pos":[18567,18599]},{"content":"Describes common type conversion issues and shows how to avoid them.","pos":[18656,18724]},{"content":"See Also","pos":[18734,18742]},{"content":"Welcome Back to C++","pos":[18747,18766]},{"content":"C++ Language Reference","pos":[18815,18837]},{"content":"C++ Standard Library","pos":[18878,18898]}],"content":"---\ntitle: \"C++ Type System (Modern C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 553c0ed6-77c4-43e9-87b1-c903eec53e80\ncaps.latest.revision: 24\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# C++ Type System (Modern C++)\nThe concept of *type* is very important in C++. Every variable, function argument, and function return value must have a type in order to be compiled. Also, every expression (including literal values) is implicitly given a type by the compiler before it is evaluated. Some examples of types include `int` to store integral values, `double` to store floating-point values (also known as *scalar* data types), or the Standard Library class [std::basic_string](../standard-library/basic-string-class.md) to store text. You can create your own type by defining a `class` or `struct`. The type specifies the amount of memory that will be allocated for the variable (or expression result), the kinds of values that may be stored in that variable, how those values (as bit patterns) are interpreted, and the operations that can be performed on it. This article contains an informal overview of the major features of the C++ type system.  \n  \n## Terminology  \n **Variable**: The symbolic name of a quantity of data so that the name can be used to access the data it refers to throughout the scope of the code where it is defined. In C++, “variable” is generally used to refer to instances of scalar data types, whereas instances of other types are usually called “objects”.  \n  \n **Object**: For simplicity and consistency, this article uses the term “object” to refer to any instance of a class or structure, and when it is used in the general sense includes all types, even scalar variables.  \n  \n **POD type** (plain old data): This informal category of data types in C++ refers to types that are scalar (see the Fundamental types section) or are *POD classes*. A POD class has no static data members that aren’t also PODs, and has no user-defined constructors, user-defined destructors, or user-defined assignment operators. Also, a POD class has no virtual functions, no base class, and no private or protected non-static data members. POD types are often used for external data interchange, for example with a module written in the C language (which has POD types only).  \n  \n## Specifying variable and function types  \n C++ is a *strongly typed* language and it is also *statically-typed*; every object has a type and that type never changes (not to be confused with static data objects).   \n**When you declare a variable** in your code, you must either specify its type explicitly, or use the `auto` keyword to instruct the compiler to deduce the type from the initializer.   \n**When you declare a function** in your code, you must specify the type of each argument and its return value, or `void` if no value is returned by the function. The exception is when you are using function templates, which allow for arguments of arbitrary types.  \n  \n After you first declare a variable, you cannot change its type at some later point. However, you can copy the variable’s value or a function’s return value into another variable of a different type. Such operations are called *type conversions*, which are sometimes necessary but are also potential sources of data loss or incorrectness.  \n  \n When you declare a variable of POD type, we strongly recommend you initialize it, which means to give it an initial value. Until you initialize a variable, it has a \"garbage\" value that consists of whatever bits happened to be in that memory location previously. This is an important aspect of C++ to remember, especially if you are coming from another language that handles initialization for you. When declaring a variable of non-POD class type, the constructor handles initialization.  \n  \n The following example shows some simple variable declarations with some descriptions for each. The example also shows how the compiler uses type information to allow or disallow certain subsequent operations on the variable.  \n  \n```  \n  \nint result = 0;              // Declare and initialize an integer.  \ndouble coefficient = 10.8;   // Declare and initialize a floating   \n                             // point value.  \nauto name = \"Lady G.\";       // Declare a variable and let compiler   \n                             // deduce the type.  \nauto address;                // error. Compiler cannot deduce a type   \n                             // without an intializing value.  \nage = 12;                    // error. Variable declaration must  \n                             // specify a type or use auto!  \nresult = \"Kenny G.\";         // error. Can’t assign text to an int.  \nstring result = \"zero\";      // error. Can’t redefine a variable with  \n                             // new type.  \nint maxValue;                // Not recommended! maxValue contains   \n                             // garbage bits until it is initialized.  \n  \n```  \n  \n## Fundamental (built-in) types  \n Unlike some languages, C++ has no universal base type from which all other types are derived. The [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)] implementation of the language includes many *fundamental types*, also known as *built-in types*. This includes numeric types such as `int`, `double`, `long`, `bool`, plus the `char` and `wchar_t` types for ASCII and UNICODE characters, respectively. Most fundamental types (except `bool`, `double`, `wchar_t` and related types) all have unsigned versions, which modify the range of values that the variable can store. For example, an `int`, which stores a 32-bit signed integer, can represent a value from -2,147,483,648 to 2,147,483,647. An `unsigned int`, which is also stored as 32-bits, can store a value from 0 to 4,294,967,295. The total number of possible values in each case is the same; only the range is different.  \n  \n The fundamental types are recognized by the compiler, which has built-in rules that govern what operations you can perform on them, and how they can be converted to other fundamental types. For a complete list of built-in types and their size and numeric limits, see [Fundamental Types](../cpp/fundamental-types-cpp.md).  \n  \n The following illustration shows the relative sizes of the built-in types:  \n  \n ![Size in bytes of built&#45;in types](../cpp/media/built-intypesizes.png \"Built-inTYpeSizes\")  \n  \n The following table lists the most frequently used fundamental types:  \n  \n|Type|Size|Comment|  \n|----------|----------|-------------|  \n|int|4 bytes|The default choice for integral values.|  \n|double|8 bytes|The default choice for floating point values.|  \n|bool|1 byte|Represents values that can be either true or false.|  \n|char|1 byte|Use for ASCII characters in older C-style strings or std::string objects that will never have to be converted to UNICODE.|  \n|wchar_t|2 bytes|Represents \"wide\" character values that may be encoded in UNICODE format (UTF-16 on Windows, other operating systems may differ). This is the character type that is used in strings of type `std::wstring`.|  \n|unsigned char|1 byte|C++ has no built-in `byte` type.  Use unsigned char to represent a byte value.|  \n|unsigned int|4 bytes|Default choice for bit flags.|  \n|long long|8 bytes|Represents very large integer values.|  \n  \n## The void type  \n The `void` type is a special type; you cannot declare a variable of type `void`, but you can declare a variable of type `void *` (pointer to `void`), which is sometimes necessary when allocating raw (un-typed) memory. However, pointers to `void` are not type-safe and generally their use is strongly discouraged in modern C++. In a function declaration, a `void` return value means that the function does not return a value; this is a common and acceptable use of `void`. While the C language required functions that have zero parameters to declare `void` in the parameter list, for example, `fou(void)`, this practice is discouraged in modern C++ and should be declared `fou()`. For more information, see [Type Conversions and Type Safety](../cpp/type-conversions-and-type-safety-modern-cpp.md).  \n  \n## const type qualifier  \n Any built-in or user-defined type may be qualified by the const keyword. Additionally, member functions may be `const`-qualified and even `const`-overloaded. The value of a `const` type cannot be modified after it is initialized.  \n  \n```  \n  \nconst double PI = 3.1415;  \nPI = .75 //Error. Cannot modify const variable.  \n  \n```  \n  \n The `const` qualifier is used extensively in function and variable declarations and \"const correctness\" is an important concept in C++; essentially it means to use `const` to guarantee, at compile time, that values are not modified unintentionally. For more information, see [const](../cpp/const-cpp.md).  \n  \n A `const` type is distinct from its non-const version; for example, `const int` is a distinct type from `int`. You can use the C++ `const_cast` operator on those rare occasions when you must remove *const-ness* from a variable. For more information, see [Type Conversions and Type Safety](../cpp/type-conversions-and-type-safety-modern-cpp.md).  \n  \n## String types  \n Strictly speaking, the C++ language has no built-in “string” type; `char` and `wchar_t` store single characters – you must declare an array of these types to approximate a string, adding a terminating null value (for example, ASCII `‘\\0’`) to the array element one past the last valid character (also called a “C-style string”). C-style strings required much more code to be written or the use of external string utility library functions. But in modern C++, we have the Standard Library types `std::string` (for 8-bit `char`-type character strings) or `std::wstring` (for 16-bit `wchar_t`-type character strings). These STL containers can be thought of as native string types because they are part of the standard libraries that are included in any compliant C++ build environment. Simply use the `#include <string>` directive to make these types available in your program. (If you are using MFC or ATL, the CString class is also available, but is not part of the C++ standard.) The use of null-terminated character arrays (the C-style strings previously mentioned) is strongly discouraged in modern C++.  \n  \n## User-defined types  \n When you define a `class`, `struct`, `union`, or `enum`, that construct is used in the rest of your code as if it were a fundamental type. It has a known size in memory, and certain rules about how it can be used apply to it for compile-time checking and, at runtime, for the life of your program. The primary differences between the fundamental built-in types and user-defined types are as follows:  \n  \n-   The compiler has no built-in knowledge of a user-defined type. It “learns” of the type when it first encounters the definition during the compilation process.  \n  \n-   You specify what operations can be performed on your type, and how it can be converted to other types, by defining (through overloading) the appropriate operators, either as class members or non-member functions. For more information, see [Function Overloading](function-overloading.md).  \n  \n-   They do not have to be statically typed (the rule that an object's type never changes). Through the mechanisms of *inheritance* and *polymorphism*, a variable declared as a user-defined type of class (referred to as an object instance of a class) might have a different type at run-time than at compile time. For more information, see [Inheritance](../cpp/inheritance-cpp.md).  \n  \n## Pointer types  \n Dating back to the earliest versions of the C language, C++ continues to let you declare a variable of a pointer type by using the special declarator `*` (asterisk). A pointer type stores the address of the location in memory where the actual data value is stored. In modern C++, these are referred to as *raw pointers*, and are accessed in your code through special operators `*` (asterisk) or `->` (dash with greater-than). This is called *dereferencing*, and which one that you use depends on whether you are dereferencing a pointer to a scalar or a pointer to a member in an object. Working with pointer types has long been one of the most challenging and confusing aspects of C and C++ program development. This section outlines some facts and practices to help use raw pointers if you want to, but in modern C++ it’s no longer required (or recommended) to use raw pointers for object ownership at all, due to the evolution of the [smart pointer](../cpp/smart-pointers-modern-cpp.md) (discussed more at the end of this section). It is still useful and safe to use raw pointers for observing objects, but if you must use them for object ownership, you should do so with caution and very careful consideration of how the objects owned by them are created and destroyed.  \n  \n The first thing that you should know is declaring a raw pointer variable will allocate only the memory that is required to store an address of the memory location that the pointer will be referring to when it is dereferenced. Allocation of the memory for the data value itself (also called *backing store*) is not yet allocated. In other words, by declaring a raw pointer variable, you are creating a memory address variable, not an actual data variable. Dereferencing a pointer variable before making sure that it contains a valid address to a backing store will cause undefined behavior (usually a fatal error) in your program. The following example demonstrates this kind of error:  \n  \n```  \n  \nint* pNumber;       // Declare a pointer-to-int variable.  \n*pNumber = 10;      // error. Although this may compile, it is  \n                    // a serious error. We are dereferencing an  \n                    // uninitialized pointer variable with no  \n                    // allocated memory to point to.  \n  \n```  \n  \n The example dereferences a pointer type without having any memory allocated to store the actual integer data or a valid memory address assigned to it. The following code corrects these errors:  \n  \n```  \n  \n    int number = 10;          // Declare and initialize a local integer  \n                              // variable for data backing store.  \n    int* pNumber = &number;   // Declare and initialize a local integer  \n                              // pointer variable to a valid memory  \n                              // address to that backing store.  \n...  \n    *pNumber = 41;            // Dereference and store a new value in   \n                              // the memory pointed to by  \n                              // pNumber, the integer variable called  \n                              // “number”. Note “number” was changed, not  \n                              // “pNumber”.  \n  \n```  \n  \n The corrected code example uses local stack memory to create the backing store that `pNumber` points to. We use a fundamental type for simplicity. In practice, the backing store for pointers are most often user-defined types that are dynamically-allocated in an area of memory called the *heap* (or “free store”) by using a `new` keyword expression (in C-style programming, the older `malloc()` C runtime library function was used). Once allocated, these “variables” are usually referred to as “objects”, especially if they are based on a class definition. Memory that is allocated with `new` must be deleted by a corresponding `delete` statement (or, if you used the `malloc()` function to allocate it, the C runtime function `free()`).  \n  \n However, it is easy to forget to delete a dynamically-allocated object- especially in complex code, which causes a resource bug called a *memory leak*. For this reason, the use of raw pointers is strongly discouraged in modern C++. It is almost always better to wrap a raw pointer in a [smart pointer](../cpp/smart-pointers-modern-cpp.md), which will automatically release the memory when its destructor is invoked (when the code goes out of scope for the smart pointer); by using smart pointers you virtually eliminate a whole class of bugs in your C++ programs. In the following example, assume `MyClass` is a user-defined type that has a public method `DoSomeWork();`  \n  \n```  \n  \nvoid someFunction() {  \n    unique_ptr<MyClass> pMc(new MyClass);  \n    pMc->DoSomeWork();  \n}  \n  // No memory leak. Out-of-scope automatically calls the destructor  \n  // for the unique_ptr, freeing the resource.  \n  \n```  \n  \n For more information about smart pointers, see [Smart Pointers](../cpp/smart-pointers-modern-cpp.md).  \n  \n For more information about pointer conversions, see [Type Conversions and Type Safety](../cpp/type-conversions-and-type-safety-modern-cpp.md).  \n  \n For more information about pointers in general, see [Pointers](../cpp/pointers-cpp.md).  \n  \n## Windows data types  \n In classic Win32 programming for C and C++, most functions use Windows-specific typedefs and #define macros (defined in `windef.h`) to specify the types of parameters and return values. These “Windows data types” are mostly just special names (aliases) given to C/C++ built-in types. For a complete list of these typedefs and preprocessor definitions, see [Windows Data Types](http://msdn.microsoft.com/en-us/4553cafc-450e-4493-a4d4-cb6e2f274d46). Some of these typedefs, such as HRESULT and LCID, are useful and descriptive. Others, such as INT, have no special meaning and are just aliases for fundamental C++ types. Other Windows data types have names that are retained from the days of C programming and 16-bit processors, and have no purpose or meaning on modern hardware or operating systems. There are also special data types associated with the Windows Runtime Library, listed as [Windows Runtime base data types](http://msdn.microsoft.com/en-us/b5735851-ec07-48c1-92b4-ca9f768096f6). In modern C++, the general guideline is to prefer the C++ fundamental types unless the Windows type communicates some additional meaning about how the value is to be interpreted.  \n  \n## More Information  \n For more information about the C++ type system, see the following topics.  \n  \n|||  \n|-|-|  \n|[Value Types](../cpp/value-types-modern-cpp.md)|Describes *value types* along with issues relating to their use.|  \n|[Type Conversions and Type Safety](../cpp/type-conversions-and-type-safety-modern-cpp.md)|Describes common type conversion issues and shows how to avoid them.|  \n  \n## See Also  \n [Welcome Back to C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   \n [C++ Language Reference](../cpp/cpp-language-reference.md)   \n [C++ Standard Library](../standard-library/cpp-standard-library-reference.md)"}