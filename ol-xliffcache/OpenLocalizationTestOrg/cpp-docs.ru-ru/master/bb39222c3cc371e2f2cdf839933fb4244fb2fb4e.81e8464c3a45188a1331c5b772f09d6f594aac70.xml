{"nodes":[{"pos":[12,75],"content":"How to: Use Oversubscription to Offset Latency | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Use Oversubscription to Offset Latency | Microsoft Docs","pos":[0,63]}]},{"content":"How to: Use Oversubscription to Offset Latency","pos":[707,753]},{"content":"Oversubscription can improve the overall efficiency of some applications that contain tasks that have a high amount of latency.","pos":[754,881]},{"content":"This topic illustrates how to use oversubscription to offset the latency that is caused by reading data from a network connection.","pos":[882,1012]},{"content":"Example","pos":[1021,1028]},{"content":"This example uses the <bpt id=\"p1\">[</bpt>Asynchronous Agents Library<ept id=\"p1\">](../../parallel/concrt/asynchronous-agents-library.md)</ept> to download files from HTTP servers.","pos":[1032,1174],"source":"This example uses the [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md) to download files from HTTP servers."},{"content":"The <ph id=\"ph1\">`http_reader`</ph> class derives from <bpt id=\"p1\">[</bpt>concurrency::agent<ept id=\"p1\">](../../parallel/concrt/reference/agent-class.md)</ept> and uses message passing to asynchronously read which URL names to download.","pos":[1175,1357],"source":" The `http_reader` class derives from [concurrency::agent](../../parallel/concrt/reference/agent-class.md) and uses message passing to asynchronously read which URL names to download."},{"content":"The <ph id=\"ph1\">`http_reader`</ph> class uses the <bpt id=\"p1\">[</bpt>concurrency::task_group<ept id=\"p1\">](reference/task-group-class.md)</ept> class to concurrently read each file.","pos":[1364,1491],"source":"The `http_reader` class uses the [concurrency::task_group](reference/task-group-class.md) class to concurrently read each file."},{"content":"Each task calls the <bpt id=\"p1\">[</bpt>concurrency::Context::Oversubscribe<ept id=\"p1\">](reference/context-class.md#oversubscribe)</ept> method with the <ph id=\"ph1\">`_BeginOversubscription`</ph> parameter set to <ph id=\"ph2\">`true`</ph> to enable oversubscription in the current context.","pos":[1492,1707],"source":" Each task calls the [concurrency::Context::Oversubscribe](reference/context-class.md#oversubscribe) method with the `_BeginOversubscription` parameter set to `true` to enable oversubscription in the current context."},{"content":"Each task then uses the Microsoft Foundation Classes (MFC) <bpt id=\"p1\">[</bpt>CInternetSession<ept id=\"p1\">](../../mfc/reference/cinternetsession-class.md)</ept> and <bpt id=\"p2\">[</bpt>CHttpFile<ept id=\"p2\">](../../mfc/reference/chttpfile-class.md)</ept> classes to download the file.","pos":[1708,1918],"source":" Each task then uses the Microsoft Foundation Classes (MFC) [CInternetSession](../../mfc/reference/cinternetsession-class.md) and [CHttpFile](../../mfc/reference/chttpfile-class.md) classes to download the file."},{"content":"Finally, each task calls <ph id=\"ph1\">`Context::Oversubscribe`</ph> with the <ph id=\"ph2\">`_BeginOversubscription`</ph> parameter set to <ph id=\"ph3\">`false`</ph> to disable oversubscription.","pos":[1919,2056],"source":" Finally, each task calls `Context::Oversubscribe` with the `_BeginOversubscription` parameter set to `false` to disable oversubscription."},{"content":"When oversubscription is enabled, the runtime creates one additional thread in which to run tasks.","pos":[2063,2161]},{"content":"Each of these threads can also oversubscribe the current context and thereby create additional threads.","pos":[2162,2265]},{"content":"The <ph id=\"ph1\">`http_reader`</ph> class uses a <bpt id=\"p1\">[</bpt>concurrency::unbounded_buffer<ept id=\"p1\">](reference/unbounded-buffer-class.md)</ept> object to limit the number of threads that the application uses.","pos":[2266,2430],"source":" The `http_reader` class uses a [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) object to limit the number of threads that the application uses."},{"content":"The agent initializes the buffer with a fixed number of token values.","pos":[2431,2500]},{"content":"For each download operation, the agent reads a token value from the buffer before the operation starts and then writes that value back to the buffer after the operation finishes.","pos":[2501,2679]},{"content":"When the buffer is empty, the agent waits for one of the download operations to write a value back to the buffer.","pos":[2680,2793]},{"content":"The following example limits the number of simultaneous tasks to two times the number of available hardware threads.","pos":[2800,2916]},{"content":"This value is a good starting point to use when you experiment with oversubscription.","pos":[2917,3002]},{"content":"You can use a value that fits a particular processing environment or dynamically change this value to respond to the actual workload.","pos":[3003,3136]},{"pos":[3154,3188],"content":"concrt-download-oversubscription#1"},{"content":"This example produces the following output on a computer that has four processors:","pos":[3288,3370]},{"content":"The example can run faster when oversubscription is enabled because additional tasks run while other tasks wait for a latent operation to finish.","pos":[4378,4523]},{"content":"Compiling the Code","pos":[4532,4550]},{"pos":[4554,4769],"content":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named <ph id=\"ph1\">`download-oversubscription.cpp`</ph> and then run one of the following commands in a Visual Studio Command Prompt window.","source":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `download-oversubscription.cpp` and then run one of the following commands in a Visual Studio Command Prompt window."},{"content":"cl.exe /EHsc /MD /D \"_AFXDLL\" download-oversubscription.cpp","pos":[4778,4837]},{"content":"cl.exe /EHsc /MT download-oversubscription.cpp","pos":[4848,4894]},{"content":"Robust Programming","pos":[4905,4923]},{"content":"Always disable oversubscription after you no longer require it.","pos":[4927,4990]},{"content":"Consider a function that does not handle an exception that is thrown by another function.","pos":[4991,5080]},{"content":"If you do not disable oversubscription before the function returns, any additional parallel work will also oversubscribe the current context.","pos":[5081,5222]},{"content":"You can use the <bpt id=\"p1\">*</bpt>Resource Acquisition Is Initialization<ept id=\"p1\">*</ept> (RAII) pattern to limit oversubscription to a given scope.","pos":[5229,5344],"source":"You can use the *Resource Acquisition Is Initialization* (RAII) pattern to limit oversubscription to a given scope."},{"content":"Under the RAII pattern, a data structure is allocated on the stack.","pos":[5345,5412]},{"content":"That data structure initializes or acquires a resource when it is created and destroys or releases that resource when the data structure is destroyed.","pos":[5413,5563]},{"content":"The RAII pattern guarantees that the destructor is called before the enclosing scope exits.","pos":[5564,5655]},{"content":"Therefore, the resource is correctly managed when an exception is thrown or when a function contains multiple <ph id=\"ph1\">`return`</ph> statements.","pos":[5656,5786],"source":" Therefore, the resource is correctly managed when an exception is thrown or when a function contains multiple `return` statements."},{"content":"The following example defines a structure that is named <ph id=\"ph1\">`scoped_blocking_signal`</ph>.","pos":[5793,5874],"source":"The following example defines a structure that is named `scoped_blocking_signal`."},{"content":"The constructor of the <ph id=\"ph1\">`scoped_blocking_signal`</ph> structure enables oversubscription and the destructor disables oversubscription.","pos":[5875,6003],"source":" The constructor of the `scoped_blocking_signal` structure enables oversubscription and the destructor disables oversubscription."},{"pos":[6021,6055],"content":"concrt-download-oversubscription#2"},{"content":"The following example modifies the body of the <ph id=\"ph1\">`download`</ph> method to use RAII to ensure that oversubscription is disabled before the function returns.","pos":[6155,6304],"source":"The following example modifies the body of the `download` method to use RAII to ensure that oversubscription is disabled before the function returns."},{"content":"This technique ensures that the <ph id=\"ph1\">`download`</ph> method is exception-safe.","pos":[6305,6373],"source":" This technique ensures that the `download` method is exception-safe."},{"pos":[6391,6425],"content":"concrt-download-oversubscription#3"},{"content":"See Also","pos":[6527,6535]},{"content":"Contexts","pos":[6540,6548]},{"content":"Context::Oversubscribe Method","pos":[6590,6619]}],"content":"---\ntitle: \"How to: Use Oversubscription to Offset Latency | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"oversubscription, using [Concurrency Runtime]\"\n  - \"using oversubscription [Concurrency Runtime]\"\nms.assetid: a1011329-2f0a-4afb-b599-dd4043009a10\ncaps.latest.revision: 17\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# How to: Use Oversubscription to Offset Latency\nOversubscription can improve the overall efficiency of some applications that contain tasks that have a high amount of latency. This topic illustrates how to use oversubscription to offset the latency that is caused by reading data from a network connection.  \n  \n## Example  \n This example uses the [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md) to download files from HTTP servers. The `http_reader` class derives from [concurrency::agent](../../parallel/concrt/reference/agent-class.md) and uses message passing to asynchronously read which URL names to download.  \n  \n The `http_reader` class uses the [concurrency::task_group](reference/task-group-class.md) class to concurrently read each file. Each task calls the [concurrency::Context::Oversubscribe](reference/context-class.md#oversubscribe) method with the `_BeginOversubscription` parameter set to `true` to enable oversubscription in the current context. Each task then uses the Microsoft Foundation Classes (MFC) [CInternetSession](../../mfc/reference/cinternetsession-class.md) and [CHttpFile](../../mfc/reference/chttpfile-class.md) classes to download the file. Finally, each task calls `Context::Oversubscribe` with the `_BeginOversubscription` parameter set to `false` to disable oversubscription.  \n  \n When oversubscription is enabled, the runtime creates one additional thread in which to run tasks. Each of these threads can also oversubscribe the current context and thereby create additional threads. The `http_reader` class uses a [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) object to limit the number of threads that the application uses. The agent initializes the buffer with a fixed number of token values. For each download operation, the agent reads a token value from the buffer before the operation starts and then writes that value back to the buffer after the operation finishes. When the buffer is empty, the agent waits for one of the download operations to write a value back to the buffer.  \n  \n The following example limits the number of simultaneous tasks to two times the number of available hardware threads. This value is a good starting point to use when you experiment with oversubscription. You can use a value that fits a particular processing environment or dynamically change this value to respond to the actual workload.  \n  \n [!code-cpp[concrt-download-oversubscription#1](../../parallel/concrt/codesnippet/cpp/how-to-use-oversubscription-to-offset-latency_1.cpp)]  \n  \n This example produces the following output on a computer that has four processors:  \n  \n```Output  \nDownloading http://www.adatum.com/...  \nDownloading http://www.adventure-works.com/...  \nDownloading http://www.alpineskihouse.com/...  \nDownloading http://www.cpandl.com/...  \nDownloading http://www.cohovineyard.com/...  \nDownloading http://www.cohowinery.com/...  \nDownloading http://www.cohovineyardandwinery.com/...  \nDownloading http://www.contoso.com/...  \nDownloading http://www.consolidatedmessenger.com/...  \nDownloading http://www.fabrikam.com/...  \nDownloading http://www.fourthcoffee.com/...  \nDownloading http://www.graphicdesigninstitute.com/...  \nDownloading http://www.humongousinsurance.com/...  \nDownloading http://www.litwareinc.com/...  \nDownloading http://www.lucernepublishing.com/...  \nDownloading http://www.margiestravel.com/...  \nDownloading http://www.northwindtraders.com/...  \nDownloading http://www.proseware.com/...  \nDownloading http://www.fineartschool.net...  \nDownloading http://www.tailspintoys.com/...  \nDownloaded 1801040 bytes in 3276 ms.  \n```  \n  \n The example can run faster when oversubscription is enabled because additional tasks run while other tasks wait for a latent operation to finish.  \n  \n## Compiling the Code  \n Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `download-oversubscription.cpp` and then run one of the following commands in a Visual Studio Command Prompt window.  \n  \n **cl.exe /EHsc /MD /D \"_AFXDLL\" download-oversubscription.cpp**  \n  \n **cl.exe /EHsc /MT download-oversubscription.cpp**  \n  \n## Robust Programming  \n Always disable oversubscription after you no longer require it. Consider a function that does not handle an exception that is thrown by another function. If you do not disable oversubscription before the function returns, any additional parallel work will also oversubscribe the current context.  \n  \n You can use the *Resource Acquisition Is Initialization* (RAII) pattern to limit oversubscription to a given scope. Under the RAII pattern, a data structure is allocated on the stack. That data structure initializes or acquires a resource when it is created and destroys or releases that resource when the data structure is destroyed. The RAII pattern guarantees that the destructor is called before the enclosing scope exits. Therefore, the resource is correctly managed when an exception is thrown or when a function contains multiple `return` statements.  \n  \n The following example defines a structure that is named `scoped_blocking_signal`. The constructor of the `scoped_blocking_signal` structure enables oversubscription and the destructor disables oversubscription.  \n  \n [!code-cpp[concrt-download-oversubscription#2](../../parallel/concrt/codesnippet/cpp/how-to-use-oversubscription-to-offset-latency_2.cpp)]  \n  \n The following example modifies the body of the `download` method to use RAII to ensure that oversubscription is disabled before the function returns. This technique ensures that the `download` method is exception-safe.  \n  \n [!code-cpp[concrt-download-oversubscription#3](../../parallel/concrt/codesnippet/cpp/how-to-use-oversubscription-to-offset-latency_3.cpp)]  \n  \n## See Also  \n [Contexts](../../parallel/concrt/contexts.md)   \n [Context::Oversubscribe Method](reference/context-class.md#oversubscribe)\n\n\n"}