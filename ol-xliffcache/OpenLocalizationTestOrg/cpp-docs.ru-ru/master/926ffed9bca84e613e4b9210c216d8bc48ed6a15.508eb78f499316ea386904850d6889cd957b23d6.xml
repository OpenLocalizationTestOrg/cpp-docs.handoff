{"nodes":[{"pos":[12,44],"content":"type_info Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"type_info Class | Microsoft Docs","pos":[0,32]}]},{"content":"type_info Class","pos":[631,646]},{"content":"The <bpt id=\"p1\">**</bpt>type_info<ept id=\"p1\">**</ept> class describes type information generated within the program by the compiler.","pos":[647,743],"source":"The **type_info** class describes type information generated within the program by the compiler."},{"content":"Objects of this class effectively store a pointer to a name for the type.","pos":[744,817]},{"content":"The <bpt id=\"p1\">**</bpt>type_info<ept id=\"p1\">**</ept> class also stores an encoded value suitable for comparing two types for equality or collating order.","pos":[818,936],"source":" The **type_info** class also stores an encoded value suitable for comparing two types for equality or collating order."},{"content":"The encoding rules and collating sequence for types are unspecified and may differ between programs.","pos":[937,1037]},{"content":"The &lt;<ph id=\"ph1\">`typeinfo&gt;`</ph> header file must be included in order to use the <bpt id=\"p1\">**</bpt>type_info<ept id=\"p1\">**</ept> class.","pos":[1044,1130],"source":"The <`typeinfo>` header file must be included in order to use the **type_info** class."},{"content":"The interface for the <bpt id=\"p1\">**</bpt>type_info<ept id=\"p1\">**</ept> class is:","pos":[1131,1176],"source":" The interface for the **type_info** class is:"},{"content":"You cannot instantiate objects of the <bpt id=\"p1\">**</bpt>type_info<ept id=\"p1\">**</ept> class directly, because the class has only a private copy constructor.","pos":[1573,1695],"source":"You cannot instantiate objects of the **type_info** class directly, because the class has only a private copy constructor."},{"content":"The only way to construct a (temporary) <bpt id=\"p1\">**</bpt>type_info<ept id=\"p1\">**</ept> object is to use the <bpt id=\"p2\">[</bpt>typeid<ept id=\"p2\">](../cpp/typeid-operator.md)</ept> operator.","pos":[1696,1816],"source":" The only way to construct a (temporary) **type_info** object is to use the [typeid](../cpp/typeid-operator.md) operator."},{"content":"Since the assignment operator is also private, you cannot copy or assign objects of class <bpt id=\"p1\">**</bpt>type_info<ept id=\"p1\">**</ept>.","pos":[1817,1921],"source":" Since the assignment operator is also private, you cannot copy or assign objects of class **type_info**."},{"pos":[1928,2060],"content":"<bpt id=\"p1\">**</bpt>type_info::hash_code<ept id=\"p1\">**</ept> defines a hash function suitable for mapping values of type <bpt id=\"p2\">**</bpt>typeinfo<ept id=\"p2\">**</ept> to a distribution of index values.","source":"**type_info::hash_code** defines a hash function suitable for mapping values of type **typeinfo** to a distribution of index values."},{"pos":[2067,2193],"content":"The operators <ph id=\"ph1\">`==`</ph> and <ph id=\"ph2\">`!=`</ph> can be used to compare for equality and inequality with other <bpt id=\"p1\">**</bpt>type_info<ept id=\"p1\">**</ept> objects, respectively.","source":"The operators `==` and `!=` can be used to compare for equality and inequality with other **type_info** objects, respectively."},{"content":"There is no link between the collating order of types and inheritance relationships.","pos":[2200,2284]},{"content":"Use the <bpt id=\"p1\">**</bpt>type_info::before<ept id=\"p1\">**</ept> member function to determine the collating sequence of types.","pos":[2285,2376],"source":" Use the **type_info::before** member function to determine the collating sequence of types."},{"content":"There is no guarantee that <bpt id=\"p1\">**</bpt>type_info::before<ept id=\"p1\">**</ept> will yield the same result in different programs or even different runs of the same program.","pos":[2377,2518],"source":" There is no guarantee that **type_info::before** will yield the same result in different programs or even different runs of the same program."},{"content":"In this manner, <bpt id=\"p1\">**</bpt>type_info::before<ept id=\"p1\">**</ept> is similar to the address-of <bpt id=\"p2\">**</bpt>(&amp;)<ept id=\"p2\">**</ept> operator.","pos":[2519,2603],"source":" In this manner, **type_info::before** is similar to the address-of **(&)** operator."},{"content":"The <bpt id=\"p1\">**</bpt>type_info::name<ept id=\"p1\">**</ept> member function returns a <bpt id=\"p2\">**</bpt>const char<ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept> to a null-terminated string representing the human-readable name of the type.","pos":[2610,2754],"source":"The **type_info::name** member function returns a **const char\\*** to a null-terminated string representing the human-readable name of the type."},{"content":"The memory pointed to is cached and should never be directly deallocated.","pos":[2755,2828]},{"content":"The <bpt id=\"p1\">**</bpt>type_info::raw_name<ept id=\"p1\">**</ept> member function returns a <bpt id=\"p2\">**</bpt>const char<ph id=\"ph1\">\\*</ph><ept id=\"p2\">**</ept> to a null-terminated string representing the decorated name of the object type.","pos":[2835,2985],"source":"The **type_info::raw_name** member function returns a **const char\\*** to a null-terminated string representing the decorated name of the object type."},{"content":"The name is actually stored in its decorated form to save space.","pos":[2986,3050]},{"content":"Consequently, this function is faster than <bpt id=\"p1\">**</bpt>type_info::name<ept id=\"p1\">**</ept> because it doesn't need to undecorate the name.","pos":[3051,3161],"source":" Consequently, this function is faster than **type_info::name** because it doesn't need to undecorate the name."},{"content":"The string returned by the <bpt id=\"p1\">**</bpt>type_info::raw_name<ept id=\"p1\">**</ept> function is useful in comparison operations but is not readable.","pos":[3162,3277],"source":" The string returned by the **type_info::raw_name** function is useful in comparison operations but is not readable."},{"content":"If you need a human-readable string, use the <bpt id=\"p1\">**</bpt>type_info::name<ept id=\"p1\">**</ept> function instead.","pos":[3278,3360],"source":" If you need a human-readable string, use the **type_info::name** function instead."},{"pos":[3367,3562],"content":"Type information is generated for polymorphic classes only if the <bpt id=\"p1\">[</bpt>/GR (Enable Run-Time Type Information)<ept id=\"p1\">](../build/reference/gr-enable-run-time-type-information.md)</ept> compiler option is specified.","source":"Type information is generated for polymorphic classes only if the [/GR (Enable Run-Time Type Information)](../build/reference/gr-enable-run-time-type-information.md) compiler option is specified."},{"content":"See Also","pos":[3571,3579]},{"content":"Run-Time Type Information","pos":[3584,3609]}],"content":"---\ntitle: \"type_info Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"type_info\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"class type_info\"\n  - \"type_info class\"\nms.assetid: 894ddda2-7de4-4da3-9404-d2c74e356c16\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# type_info Class\nThe **type_info** class describes type information generated within the program by the compiler. Objects of this class effectively store a pointer to a name for the type. The **type_info** class also stores an encoded value suitable for comparing two types for equality or collating order. The encoding rules and collating sequence for types are unspecified and may differ between programs.  \n  \n The <`typeinfo>` header file must be included in order to use the **type_info** class. The interface for the **type_info** class is:  \n  \n```  \nclass type_info {  \npublic:  \n    virtual ~type_info();  \n    size_t hash_code() const  \n    _CRTIMP_PURE bool operator==(const type_info& rhs) const;  \n    _CRTIMP_PURE bool operator!=(const type_info& rhs) const;  \n    _CRTIMP_PURE int before(const type_info& rhs) const;  \n    _CRTIMP_PURE const char* name() const;  \n    _CRTIMP_PURE const char* raw_name() const;  \n};  \n```  \n  \n You cannot instantiate objects of the **type_info** class directly, because the class has only a private copy constructor. The only way to construct a (temporary) **type_info** object is to use the [typeid](../cpp/typeid-operator.md) operator. Since the assignment operator is also private, you cannot copy or assign objects of class **type_info**.  \n  \n **type_info::hash_code** defines a hash function suitable for mapping values of type **typeinfo** to a distribution of index values.  \n  \n The operators `==` and `!=` can be used to compare for equality and inequality with other **type_info** objects, respectively.  \n  \n There is no link between the collating order of types and inheritance relationships. Use the **type_info::before** member function to determine the collating sequence of types. There is no guarantee that **type_info::before** will yield the same result in different programs or even different runs of the same program. In this manner, **type_info::before** is similar to the address-of **(&)** operator.  \n  \n The **type_info::name** member function returns a **const char\\*** to a null-terminated string representing the human-readable name of the type. The memory pointed to is cached and should never be directly deallocated.  \n  \n The **type_info::raw_name** member function returns a **const char\\*** to a null-terminated string representing the decorated name of the object type. The name is actually stored in its decorated form to save space. Consequently, this function is faster than **type_info::name** because it doesn't need to undecorate the name. The string returned by the **type_info::raw_name** function is useful in comparison operations but is not readable. If you need a human-readable string, use the **type_info::name** function instead.  \n  \n Type information is generated for polymorphic classes only if the [/GR (Enable Run-Time Type Information)](../build/reference/gr-enable-run-time-type-information.md) compiler option is specified.  \n  \n## See Also  \n [Run-Time Type Information](../cpp/run-time-type-information.md)"}