<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e04a76658e808bdacee9cfebb9f807b0bdd7ca87</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\functions-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e9bb70ea75b7bcd033b2b6a51c013dcbb8298e3e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b7346b2fb9fc1390afeb6eba8dd506bfa5cfedd6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Functions (C++) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Functions (C++)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A function is a block of code that performs some operation.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>A function can optionally define input parameters that enable callers to pass arguments into the function.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A function can optionally return a value as output.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Functions are useful for encapsulating common operations in a single reusable block, ideally with a name that clearly describes what the function does.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The following function accepts two integers from a caller and returns their sum; <ph id="ph1">`a`</ph> and <ph id="ph2">`b`</ph> are <bpt id="p1">*</bpt>parameters<ept id="p1">*</ept> of type <ph id="ph3">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The function can invoked, or <bpt id="p1">*</bpt>called<ept id="p1">*</ept>, from any number of places in the program.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The values that are passed to the function are the <bpt id="p1">*</bpt>arguments<ept id="p1">*</ept>, whose types must be compatible with the parameter types in the function definition.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>There is no practical limit to function length, but good design aims for functions that perform a single well-defined task.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Complex algorithms should be broken up into easy-to-understand simpler functions whenever possible.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Functions that are defined at class scope are called member functions.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>In C++, unlike other languages, a function can also be defined at namespace scope (including the implicit global namespace).</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Such functions are called <bpt id="p1">*</bpt>free functions<ept id="p1">*</ept> or <bpt id="p2">*</bpt>non-member functions<ept id="p2">*</ept>; they are used extensively in the Standard Library.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Parts of a function declaration</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>A minimal function <bpt id="p1">*</bpt>declaration<ept id="p1">*</ept> consists of the return type, function name, and parameter list (which may be empty), along with optional keywords that provide additional instructions to the compiler.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A function definition consists of a declaration, plus the <bpt id="p1">*</bpt>body<ept id="p1">*</ept>, which is all the code between the curly braces.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A function declaration followed by a semicolon may appear in multiple places in a program.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>It must appear prior to any calls to that function in each translation unit.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The function definition must appear only once in the program, according to the One Definition Rule (ODR).</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The required parts of a function declaration are:</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The return type, which specifies the type of the value that the function returns, or  <ph id="ph1">`void`</ph> if no value is returned.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In C++11, auto is a valid return type that instructs the compiler to infer the type from the return statement.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In C++14, decltype(auto) is also allowed.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For more information, see Type Deduction in Return Types below.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The function name, which must begin with a letter or underscore and cannot contain spaces.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In general, leading underscores in the Standard Library function names indicate private member functions, or non-member functions that are not intended for use by your code.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The parameter list, a brace delimited, comma-separated set of zero or more parameters that specify the type and optionally a local name by which the values may be accessed inside the function body.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Optional parts of a function declaration are:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>, which indicates that the return value of the function is a constant value can be computed at compile time.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`linkage`</ph> specification, <ph id="ph2">`extern`</ph> or <ph id="ph3">`static`</ph>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Program and Linkage<ept id="p1">](../cpp/program-and-linkage-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>, which instructs the compiler to replace every call to the function with the function code itself.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>inlining can help performance in scenarios where a function executes quickly and is invoked repeatedly in a performance-critical section of code.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Inline Functions<ept id="p1">](../cpp/inline-functions-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>, which specifies whether or not the function can throw an exception.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In the following example, the function does not throw an exception if the <ph id="ph1">`is_pod`</ph> expression evaluates to <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>noexcept<ept id="p1">](../cpp/noexcept-cpp.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>(Member functions only) The cv-qualifiers, which specify whether the function is <ph id="ph1">`const`</ph> or <ph id="ph2">`volatile`</ph>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>(Member functions only) <ph id="ph1">`virtual`</ph>, <ph id="ph2">`override`</ph>, or <ph id="ph3">`final`</ph>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>specifies that a function can be overridden in a derived class.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>means that a function in a derived class is overriding a virtual function.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>means a function cannot be overridden in any further derived class.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Virtual Functions<ept id="p1">](../cpp/virtual-functions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>(member functions only) <ph id="ph1">`static`</ph> applied to a member function means that the function is not associated with any object instances of the class.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>(Non-static member functions only) The ref-qualifier, which specifies to the compiler which overload of a function to choose when the implicit object parameter (*this) is an rvalue reference vs. an lvalue reference.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following figure shows the parts of a function definition.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The shaded area is the function body.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Parts of a function definition</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Parts of a Function Definition</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Function definitions</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Variables declared inside the body are called local variables or locals.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>They go out of scope when the function exits; therefore, a function should never return a reference to a local!</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Function Templates</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>A function template is similar to a class template; it generates concrete functions based on the template arguments.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In many cases, the template is able to infer the type arguments and therefore it isn't necessary to explicitly specify them.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Function Templates<ept id="p1">](../cpp/function-templates.md)</ept></source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Function parameters and arguments</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A function has a comma-separated parameter list of zero or more types, each of which has a name by which it can be accessed inside the function body.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>A function template may specify additional type or value parameters.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The caller passes arguments, which are concrete values whose types are compatible with the parameter list.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>By default, arguments are passed to the function by value, which means the function receives a copy of the object being passed.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For large objects, making a copy can be expensive and is not always necessary.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>To cause arguments to be passed by reference (specifically lvalue reference), add a reference quaitifer to the parameter:</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When a function modifies an argument that is passed by reference, it modifies the original object, not a local copy.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To prevent a function from modifying such an argument, qualify the parameter as const&amp;:</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>C++ 11:<ept id="p1">**</ept>  To explicitly handle arguments that are passed by rvalue-reference OR by lvalue-reference, use a double-ampersand on the parameter to indicate a universal reference:</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A function declared with the single keyword <ph id="ph1">`void`</ph> in the parameter declaration list takes no arguments, as long as the keyword <ph id="ph2">`void`</ph> is the first and only member of the argument declaration list.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Arguments of type <ph id="ph1">`void`</ph> elsewhere in the list produce errors.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Note that, while it is illegal to specify a <ph id="ph1">`void`</ph> argument except as outlined here, types derived from type <ph id="ph2">`void`</ph> (such as pointers to <ph id="ph3">`void`</ph> and arrays of <ph id="ph4">`void`</ph>) can appear anywhere the argument declaration list.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Default Arguments</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The last parameter or parameters in a function signature may be assigned a default argument, which means that the caller may leave out the argument when calling the function unless they want to specify some other value.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Default Arguments<ept id="p1">](../cpp/default-arguments.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Function return types</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>A function may not return another function, or a built-in array; however it can return pointers to these types, or a <bpt id="p1">*</bpt>lambda<ept id="p1">*</ept>, which produces a function object.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Except for these cases, a function may return a value of any type that is in scope, or it may return no value, in which case the return type is <ph id="ph1">`void`</ph>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Trailing return types</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>An "ordinary" return type is located on the left side of the function signature.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>trailing return type<ept id="p1">*</ept> is located on the right most side of the signature and is preceded by the -&gt; operator.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Trailing return types are especially useful in function templates when the type of the return value depends on template parameters.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">`auto`</ph> is used in conjunction with a trailing return type, it just serves as a placeholder for whatever the decltype expression produces, and does not itself perform type deduction.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Type deduction in return types (C++14)</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In C++14, you can use <ph id="ph1">`auto`</ph> to instruct the compiler to infer the return type from the function body without having to provide a trailing return type.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Note that <ph id="ph1">`auto`</ph> always deduces to a return-by-value.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`auto&amp;&amp;`</ph> to instruct the compiler to deduce a reference.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>In this example, <ph id="ph1">`auto`</ph> will be deduced as a non-const value copy of the sum of lhs and rhs.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Note that <ph id="ph1">`auto`</ph> also does not preserve the const-ness of the type it deduces.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For forwarding functions whose return value needs to preserve the const-ness or ref-ness of its arguments, you can use the <ph id="ph1">`decltype(auto)`</ph> keyword, which uses the <ph id="ph2">`decltype`</ph> type inference rules and preserves all the type information.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>may be used as an ordinary return value on the left side, or as a trailing return value.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The following example (based on code from <bpt id="p1">[</bpt>N3493<ept id="p1">](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3493.html)</ept>), shows <ph id="ph1">`decltype(auto)`</ph> being used to enable perfect forwarding of function arguments in a return type that isn't known until the template is instantiated.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Function local variables</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>A variable that is declared inside a function body is called a <bpt id="p1">*</bpt>local variable<ept id="p1">*</ept> or simply a <bpt id="p2">*</bpt>local<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Non-static locals are only visible inside the function body and, if they are declared on the stack go out of scope when the function exits.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>When you construct a local variable and return it by value, the compiler can usually perform the return value optimization to avoid unnecessary copy operations.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If you return a local variable by reference, the compiler will issue a warning because any attempt by the caller to use that reference will occur after the local has been destroyed.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Local static objects are destroyed during termination specified by <ph id="ph1">`atexit`</ph>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>If a static object was not constructed because the program's flow of control bypassed its declaration, no attempt is made to destroy that object.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Static local variables</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>In C++ a local variable may be declared as static.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The variable is only visible inside the function body, but a single copy of the variable exists for all instances of the function.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Function pointers</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>C++ supports function pointers in the same manner as the C language.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>However a more type-safe alternative is usually to use a function object.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>It is recommended that <ph id="ph1">`typedef`</ph> be used to declare an alias for the function pointer type if declaring a function that returns a function pointer type.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>For example</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If this is not done, the proper syntax for the function declaration may be deduced from the declarator syntax for the function pointer by replacing the identifier (<ph id="ph1">`fp`</ph> in the above example) with the functions name and argument list, as follows:</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The preceding declaration is equivalent to the declaration using typedef above.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Function Overloading</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Functions with Variable Argument Lists</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Explicitly Defaulted and Deleted Functions</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Argument-Dependent Name (Koenig) Lookup on Functions</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Default Arguments</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>