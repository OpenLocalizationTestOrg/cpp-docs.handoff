{"nodes":[{"pos":[12,64],"content":"ullptr  (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"ullptr  (C++ Component Extensions) | Microsoft Docs","pos":[0,51]}]},{"content":"nullptr  (C++ Component Extensions)","pos":[636,671]},{"content":"The <ph id=\"ph1\">`nullptr`</ph> keyword represents a <bpt id=\"p1\">*</bpt>null pointer value<ept id=\"p1\">*</ept>.","pos":[672,728],"source":"The `nullptr` keyword represents a *null pointer value*."},{"content":"Use a null pointer value to indicate that an object handle, interior pointer, or native pointer type does not point to an object.","pos":[729,858]},{"content":"Use <ph id=\"ph1\">`nullptr`</ph> with either managed or native code.","pos":[865,914],"source":"Use `nullptr` with either managed or native code."},{"content":"The compiler emits appropriate but different instructions for managed and native null pointer values.","pos":[915,1016]},{"content":"For information about using the ISO standard C++ version of this keyword, see <bpt id=\"p1\">[</bpt>nullptr<ept id=\"p1\">](../cpp/nullptr.md)</ept>.","pos":[1017,1124],"source":" For information about using the ISO standard C++ version of this keyword, see [nullptr](../cpp/nullptr.md)."},{"content":"The <ph id=\"ph1\">`__nullptr`</ph> keyword is a Microsoft-specific keyword that has the same meaning as <ph id=\"ph2\">`nullptr`</ph>, but applies to only native code.","pos":[1131,1259],"source":"The `__nullptr` keyword is a Microsoft-specific keyword that has the same meaning as `nullptr`, but applies to only native code."},{"content":"If you use <ph id=\"ph1\">`nullptr`</ph> with native C/C++ code and then compile with the <bpt id=\"p1\">[</bpt>/clr<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept> compiler option, the compiler cannot determine whether <ph id=\"ph2\">`nullptr`</ph> indicates a native or managed null pointer value.","pos":[1260,1514],"source":" If you use `nullptr` with native C/C++ code and then compile with the [/clr](../build/reference/clr-common-language-runtime-compilation.md) compiler option, the compiler cannot determine whether `nullptr` indicates a native or managed null pointer value."},{"content":"To make your intention clear to the compiler, use <ph id=\"ph1\">`nullptr`</ph> to specify a managed value or <ph id=\"ph2\">`__nullptr`</ph> to specify a native value.","pos":[1515,1643],"source":" To make your intention clear to the compiler, use `nullptr` to specify a managed value or `__nullptr` to specify a native value."},{"pos":[1650,1732],"content":"The <ph id=\"ph1\">`nullptr`</ph> keyword is equivalent to <ph id=\"ph2\">`Nothing`</ph> in Visual Basic and <ph id=\"ph3\">`null`</ph> in C#.","source":"The `nullptr` keyword is equivalent to `Nothing` in Visual Basic and `null` in C#."},{"content":"Usage","pos":[1741,1746]},{"pos":[1750,1852],"content":"The <ph id=\"ph1\">`nullptr`</ph> keyword can be used anywhere a handle, native pointer, or function argument can be used.","source":"The `nullptr` keyword can be used anywhere a handle, native pointer, or function argument can be used."},{"pos":[1859,1929],"content":"The <ph id=\"ph1\">`nullptr`</ph> keyword is not a type and is not supported for use with:","source":"The `nullptr` keyword is not a type and is not supported for use with:"},{"content":"sizeof","pos":[1940,1946]},{"content":"typeid","pos":[1985,1991]},{"pos":[2045,2091],"content":"(although <ph id=\"ph1\">`throw (Object^)nullptr;`</ph> will work)","source":" (although `throw (Object^)nullptr;` will work)"},{"pos":[2098,2185],"content":"The <ph id=\"ph1\">`nullptr`</ph> keyword can be used in the initialization of the following pointer types:","source":"The `nullptr` keyword can be used in the initialization of the following pointer types:"},{"content":"Native pointer","pos":[2195,2209]},{"content":"Windows Runtime handle","pos":[2219,2241]},{"content":"Managed handle","pos":[2251,2265]},{"content":"Managed interior pointer","pos":[2275,2299]},{"pos":[2306,2418],"content":"The <ph id=\"ph1\">`nullptr`</ph> keyword can be used to test if a pointer or handle reference is null before the reference is used.","source":"The `nullptr` keyword can be used to test if a pointer or handle reference is null before the reference is used."},{"content":"Function calls among languages that use null pointer values for error checking should be interpreted correctly.","pos":[2425,2536]},{"content":"You cannot initialize a handle to zero; only <ph id=\"ph1\">`nullptr`</ph> can be used.","pos":[2543,2610],"source":"You cannot initialize a handle to zero; only `nullptr` can be used."},{"content":"Assignment of constant 0 to an object handle produces a boxed <ph id=\"ph1\">`Int32`</ph> and a cast to <ph id=\"ph2\">`Object^`</ph>.","pos":[2611,2705],"source":" Assignment of constant 0 to an object handle produces a boxed `Int32` and a cast to `Object^`."},{"content":"Example","pos":[2714,2721]},{"content":"The following code example demonstrates that the <ph id=\"ph1\">`nullptr`</ph> keyword can be used wherever a handle, native pointer, or function argument can be used.","pos":[2725,2872],"source":"The following code example demonstrates that the `nullptr` keyword can be used wherever a handle, native pointer, or function argument can be used."},{"content":"And the example demonstrates that the <ph id=\"ph1\">`nullptr`</ph> keyword can be used to check a reference before it is used.","pos":[2873,2980],"source":" And the example demonstrates that the `nullptr` keyword can be used to check a reference before it is used."},{"content":"Example","pos":[3573,3580]},{"content":"Example","pos":[3586,3593]},{"pos":[3602,3706],"content":"The following code example shows that <ph id=\"ph1\">`nullptr`</ph> and zero can be used interchangeably on native pointers.","source":"The following code example shows that `nullptr` and zero can be used interchangeably on native pointers."},{"content":"Output","pos":[4244,4250]},{"content":"Example","pos":[4367,4374]},{"content":"Example","pos":[4380,4387]},{"content":"The following code example shows that <ph id=\"ph1\">`nullptr`</ph> is interpreted as a handle to any type or a native pointer to any type.","pos":[4396,4515],"source":"The following code example shows that `nullptr` is interpreted as a handle to any type or a native pointer to any type."},{"content":"In case of function overloading with handles to different types, an ambiguity error will be generated.","pos":[4516,4618]},{"content":"The <ph id=\"ph1\">`nullptr`</ph> would have to be explicitly cast to a type.","pos":[4619,4676],"source":" The `nullptr` would have to be explicitly cast to a type."},{"content":"Example","pos":[4938,4945]},{"content":"Example","pos":[4951,4958]},{"pos":[4967,5117],"content":"The following code example shows that casting <ph id=\"ph1\">`nullptr`</ph> is allowed and returns a pointer or handle to the cast type that contains the <ph id=\"ph2\">`nullptr`</ph> value.","source":"The following code example shows that casting `nullptr` is allowed and returns a pointer or handle to the cast type that contains the `nullptr` value."},{"content":"Example","pos":[5521,5528]},{"content":"Example","pos":[5534,5541]},{"pos":[5550,5634],"content":"The following code example shows that <ph id=\"ph1\">`nullptr`</ph> can be used as a function parameter.","source":"The following code example shows that `nullptr` can be used as a function parameter."},{"content":"Output","pos":[5831,5837]},{"content":"Example","pos":[5876,5883]},{"content":"Example","pos":[5889,5896]},{"pos":[5905,6043],"content":"The following code example shows that when handles are declared and not explicitly initialized, they are default initialized to <ph id=\"ph1\">`nullptr`</ph>.","source":"The following code example shows that when handles are declared and not explicitly initialized, they are default initialized to `nullptr`."},{"content":"Output","pos":[6392,6398]},{"content":"Example","pos":[6437,6444]},{"content":"Example","pos":[6450,6457]},{"pos":[6466,6581],"content":"The following code example shows that <ph id=\"ph1\">`nullptr`</ph> can be assigned to a native pointer when you compile with <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>.","source":"The following code example shows that `nullptr` can be assigned to a native pointer when you compile with **/clr**."},{"content":"Requirements","pos":[6714,6726]},{"pos":[6730,6835],"content":"Compiler option: (Not required; supported by all code generation options, including <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept>)","source":"Compiler option: (Not required; supported by all code generation options, including **/ZW** and **/clr**)"},{"content":"See Also","pos":[6844,6852]},{"content":"Component Extensions for Runtime Platforms","pos":[6857,6899]},{"content":"nullptr","pos":[6964,6971]}],"content":"---\ntitle: \"nullptr  (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"__nullptr keyword (C++)\"\n  - \"nullptr keyword [C++]\"\nms.assetid: 594cfbf7-06cb-4366-9ede-c0b703e1d095\ncaps.latest.revision: 24\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# nullptr  (C++ Component Extensions)\nThe `nullptr` keyword represents a *null pointer value*. Use a null pointer value to indicate that an object handle, interior pointer, or native pointer type does not point to an object.  \n  \n Use `nullptr` with either managed or native code. The compiler emits appropriate but different instructions for managed and native null pointer values. For information about using the ISO standard C++ version of this keyword, see [nullptr](../cpp/nullptr.md).  \n  \n The `__nullptr` keyword is a Microsoft-specific keyword that has the same meaning as `nullptr`, but applies to only native code. If you use `nullptr` with native C/C++ code and then compile with the [/clr](../build/reference/clr-common-language-runtime-compilation.md) compiler option, the compiler cannot determine whether `nullptr` indicates a native or managed null pointer value. To make your intention clear to the compiler, use `nullptr` to specify a managed value or `__nullptr` to specify a native value.  \n  \n The `nullptr` keyword is equivalent to `Nothing` in Visual Basic and `null` in C#.  \n  \n## Usage  \n The `nullptr` keyword can be used anywhere a handle, native pointer, or function argument can be used.  \n  \n The `nullptr` keyword is not a type and is not supported for use with:  \n  \n-   [sizeof](../cpp/sizeof-operator.md)  \n  \n-   [typeid](../cpp/typeid-operator.md)  \n  \n-   `throw nullptr` (although `throw (Object^)nullptr;` will work)  \n  \n The `nullptr` keyword can be used in the initialization of the following pointer types:  \n  \n-   Native pointer  \n  \n-   Windows Runtime handle  \n  \n-   Managed handle  \n  \n-   Managed interior pointer  \n  \n The `nullptr` keyword can be used to test if a pointer or handle reference is null before the reference is used.  \n  \n Function calls among languages that use null pointer values for error checking should be interpreted correctly.  \n  \n You cannot initialize a handle to zero; only `nullptr` can be used. Assignment of constant 0 to an object handle produces a boxed `Int32` and a cast to `Object^`.  \n  \n## Example  \n The following code example demonstrates that the `nullptr` keyword can be used wherever a handle, native pointer, or function argument can be used. And the example demonstrates that the `nullptr` keyword can be used to check a reference before it is used.  \n  \n```  \n// mcpp_nullptr.cpp  \n// compile with: /clr  \nvalue class V {};  \nref class G {};  \nvoid f(System::Object ^) {}  \n  \nint main() {  \n// Native pointer.  \n   int *pN = nullptr;  \n// Managed handle.  \n   G ^pG = nullptr;  \n   V ^pV1 = nullptr;  \n// Managed interior pointer.  \n   interior_ptr<V> pV2 = nullptr;  \n// Reference checking before using a pointer.  \n   if (pN == nullptr) {}  \n   if (pG == nullptr) {}  \n   if (pV1 == nullptr) {}  \n   if (pV2 == nullptr) {}  \n// nullptr can be used as a function argument.  \n   f(nullptr);   // calls f(System::Object ^)  \n}  \n```  \n  \n## Example  \n **Example**  \n  \n The following code example shows that `nullptr` and zero can be used interchangeably on native pointers.  \n  \n```  \n// mcpp_nullptr_1.cpp  \n// compile with: /clr  \nclass MyClass {  \npublic:  \n   int i;  \n};  \n  \nint main() {  \n   MyClass * pMyClass = nullptr;  \n   if ( pMyClass == nullptr)  \n      System::Console::WriteLine(\"pMyClass == nullptr\");  \n  \n   if ( pMyClass == 0)  \n      System::Console::WriteLine(\"pMyClass == 0\");  \n  \n   pMyClass = 0;  \n   if ( pMyClass == nullptr)  \n      System::Console::WriteLine(\"pMyClass == nullptr\");  \n  \n   if ( pMyClass == 0)  \n      System::Console::WriteLine(\"pMyClass == 0\");  \n}  \n```  \n  \n **Output**  \n  \n```Output  \npMyClass == nullptr  \n  \npMyClass == 0  \n  \npMyClass == nullptr  \n  \npMyClass == 0  \n```  \n  \n## Example  \n **Example**  \n  \n The following code example shows that `nullptr` is interpreted as a handle to any type or a native pointer to any type. In case of function overloading with handles to different types, an ambiguity error will be generated. The `nullptr` would have to be explicitly cast to a type.  \n  \n```  \n// mcpp_nullptr_2.cpp  \n// compile with: /clr /LD  \nvoid f(int *){}  \nvoid f(int ^){}  \n  \nvoid f_null() {  \n   f(nullptr);   // C2668  \n   // try one of the following lines instead  \n   f((int *) nullptr);  \n   f((int ^) nullptr);  \n}  \n```  \n  \n## Example  \n **Example**  \n  \n The following code example shows that casting `nullptr` is allowed and returns a pointer or handle to the cast type that contains the `nullptr` value.  \n  \n```  \n// mcpp_nullptr_3.cpp  \n// compile with: /clr /LD  \nusing namespace System;  \ntemplate <typename T>   \nvoid f(T) {}   // C2036 cannot deduce template type because nullptr can be any type  \n  \nint main() {  \n   f((Object ^) nullptr);   // T = Object^, call f(Object ^)  \n  \n   // Delete the following line to resolve.  \n   f(nullptr);  \n  \n   f(0);   // T = int, call f(int)  \n}  \n```  \n  \n## Example  \n **Example**  \n  \n The following code example shows that `nullptr` can be used as a function parameter.  \n  \n```  \n// mcpp_nullptr_4.cpp  \n// compile with: /clr  \nusing namespace System;  \nvoid f(Object ^ x) {  \n   Console::WriteLine(\"test\");  \n}  \n  \nint main() {  \n   f(nullptr);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \ntest  \n```  \n  \n## Example  \n **Example**  \n  \n The following code example shows that when handles are declared and not explicitly initialized, they are default initialized to `nullptr`.  \n  \n```  \n// mcpp_nullptr_5.cpp  \n// compile with: /clr  \nusing namespace System;  \nref class MyClass {  \npublic:  \n   void Test() {  \n      MyClass ^pMyClass;   // gc type  \n      if (pMyClass == nullptr)  \n         Console::WriteLine(\"NULL\");  \n   }  \n};  \n  \nint main() {  \n   MyClass ^ x = gcnew MyClass();  \n   x -> Test();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nNULL  \n```  \n  \n## Example  \n **Example**  \n  \n The following code example shows that `nullptr` can be assigned to a native pointer when you compile with **/clr**.  \n  \n```  \n// mcpp_nullptr_6.cpp  \n// compile with: /clr  \nint main() {  \n   int * i = 0;  \n   int * j = nullptr;  \n}  \n```  \n  \n## Requirements  \n Compiler option: (Not required; supported by all code generation options, including **/ZW** and **/clr**)  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)   \n [nullptr](../cpp/nullptr.md)"}