{"nodes":[{"pos":[12,40],"content":"Attributes2 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Attributes2 | Microsoft Docs","pos":[0,28]}]},{"content":"Attributes","pos":[254,264]},{"content":"In C++11, attributes provide a standardized way to annotate C++ constructs (including but not limited to classes, functions, variables, and blocks) with additional information that may or may not be vendor-specific.","pos":[265,480]},{"content":"A compiler can use this information to generate informational messages, or to apply special logic when compiling the attributed code.","pos":[481,614]},{"content":"The compiler ignores any attributes that it does not recognize, which means that you cannot define your own custom attributes using this syntax.","pos":[615,759]},{"content":"Attributes are enclosed by double square brackets:","pos":[760,810]},{"content":"Attributes represent a standardized alternative to vendor-specific extensions such as #pragma directives,  __declspec() (Visual C++),  or <ph id=\"ph1\">\\_</ph>_attribute<ph id=\"ph2\">\\_\\_</ph> (GNU).","pos":[869,1030],"source":"Attributes represent a standardized alternative to vendor-specific extensions such as #pragma directives,  __declspec() (Visual C++),  or \\__attribute\\_\\_ (GNU)."},{"content":"However,  you will still need to use the vendor-specific constructs for most purposes.","pos":[1031,1117]},{"content":"The standard currently specifies three attributes that a conforming compiler should recognize:","pos":[1119,1213]},{"content":"-- specifies that a function never returns; in other words it always throws an exception.","pos":[1234,1323]},{"content":"The compiler can adjust its compilation rules for [[noreturn]] entities.","pos":[1324,1396]},{"content":"--specifies that the function propagates data dependency ordering with respect to thread synchronization.","pos":[1426,1531]},{"content":"The attribute can be applied to one or more parameters, to specify that the passed-in argument carries a dependency into the function body.","pos":[1532,1671]},{"content":"The attribute can be applied to the function itself, to specify that the return value carries a dependency out of the function.","pos":[1672,1799]},{"content":"The compiler can use this information to generate more efficient code.","pos":[1802,1872]},{"content":"– specifies that a function is not intended to be used, and might not exist in future versions of a library interface.","pos":[1895,2013]},{"content":"The compiler can use this to generate an informational message when client code attempts to call the function.","pos":[2014,2124]},{"content":"Can be applied to declaration of a class, a typedef-name, a variable, a non-static data member, a function, a namespace, an enumeration, an enumerator, or a template specialization.","pos":[2125,2306]},{"content":"-- this Microsoft-specific attribute is used for suppressing warnings from checkers that enforce <bpt id=\"p1\">[</bpt>Guidelines Support Library (GSL)<ept id=\"p1\">](https://github.com/Microsoft/GSL)</ept> rules in code.","pos":[2333,2513],"source":"  -- this Microsoft-specific attribute is used for suppressing warnings from checkers that enforce [Guidelines Support Library (GSL)](https://github.com/Microsoft/GSL) rules in code."},{"content":"For example, consider the code snippet below","pos":[2514,2558]},{"content":"The example raises these warnings:","pos":[2970,3004]},{"content":"26494 (Type Rule 5: Always initialize an object.)","pos":[3018,3067]},{"content":"26485 (Bounds Rule 3: No array to pointer decay.)","pos":[3081,3130]},{"content":"26481 (Bounds Rule 1: Don't use pointer arithmetic.","pos":[3144,3195]},{"content":"Use span instead.)","pos":[3196,3214]},{"content":"The first two warnings fire when you compile this code with the CppCoreCheck code analysis tool installed and activated.","pos":[3225,3345]},{"content":"But the third warning doesn't fire because of the attribute.","pos":[3346,3406]},{"content":"You can suppress the entire bounds profile by writing [[gsl::suppress(bounds)]] without including a specific rule number.","pos":[3407,3528]},{"content":"The C++ Core Guidelines are designed to help you write better and safer code.","pos":[3529,3606]},{"content":"The suppress attribute makes it easy to turn off the warnings when they are not wanted.","pos":[3607,3694]},{"content":"The C++ standard allows compiler vendors to define their own attribute parameters (within a vendor-specific namespace), but compilers are required to recognize only those attributes defined in the standard.","pos":[3701,3907]},{"content":"In Visual C++, you can use the [[deprecated]] attribute instead of using declspec (deprecated) and the attribute will be recognized by any conformant compiler.","pos":[3908,4067]},{"content":"For all other declspec parameters such as dllimport and dllexport, there is as yet no standard attribute equivalent so you must continue to use declspec syntax.","pos":[4068,4228]},{"content":"Attributes do not affect the type system, and they don’t change the meaning of a program.","pos":[4229,4318]},{"content":"Compilers ignore attribute values they don't recognize.","pos":[4319,4374]}],"content":"---\ntitle: \"Attributes2 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nms.assetid: 748340d9-8abf-4940-b0a0-91b6156a3ff8\ncaps.latest.revision: 11\nmanager: \"ghogen\"\n---\n# Attributes\nIn C++11, attributes provide a standardized way to annotate C++ constructs (including but not limited to classes, functions, variables, and blocks) with additional information that may or may not be vendor-specific. A compiler can use this information to generate informational messages, or to apply special logic when compiling the attributed code. The compiler ignores any attributes that it does not recognize, which means that you cannot define your own custom attributes using this syntax. Attributes are enclosed by double square brackets:  \n  \n```  \n[[deprecated]]  \nvoid Foo(int);  \n  \n```  \n  \n Attributes represent a standardized alternative to vendor-specific extensions such as #pragma directives,  __declspec() (Visual C++),  or \\__attribute\\_\\_ (GNU). However,  you will still need to use the vendor-specific constructs for most purposes.  The standard currently specifies three attributes that a conforming compiler should recognize:  \n  \n-   `noreturn` -- specifies that a function never returns; in other words it always throws an exception. The compiler can adjust its compilation rules for [[noreturn]] entities.  \n  \n-   `carries_dependency`--specifies that the function propagates data dependency ordering with respect to thread synchronization. The attribute can be applied to one or more parameters, to specify that the passed-in argument carries a dependency into the function body. The attribute can be applied to the function itself, to specify that the return value carries a dependency out of the function.   The compiler can use this information to generate more efficient code.  \n  \n-   `deprecated` – specifies that a function is not intended to be used, and might not exist in future versions of a library interface. The compiler can use this to generate an informational message when client code attempts to call the function. Can be applied to declaration of a class, a typedef-name, a variable, a non-static data member, a function, a namespace, an enumeration, an enumerator, or a template specialization.  \n  \n-   `gsl::suppress`  -- this Microsoft-specific attribute is used for suppressing warnings from checkers that enforce [Guidelines Support Library (GSL)](https://github.com/Microsoft/GSL) rules in code. For example, consider the code snippet below  \n  \n    ```cpp  \n    void main()  \n    {  \n        int arr[10]; // GSL warning 26494 will be fired  \n        int* p = arr; // GSL warning 26485 will be fired  \n        [[gsl::suppress(bounds.1)]] // This attribute suppresses Bounds rule #1  \n        {  \n            int* q = p + 1; // GSL warning 26481 suppressed  \n            p = q--; // GSL warning 26481 suppressed   \n        }  \n    }  \n    ```  \n  \n     The example raises these warnings:  \n  \n    -   26494 (Type Rule 5: Always initialize an object.)  \n  \n    -   26485 (Bounds Rule 3: No array to pointer decay.)  \n  \n    -   26481 (Bounds Rule 1: Don't use pointer arithmetic. Use span instead.)  \n  \n     The first two warnings fire when you compile this code with the CppCoreCheck code analysis tool installed and activated. But the third warning doesn't fire because of the attribute. You can suppress the entire bounds profile by writing [[gsl::suppress(bounds)]] without including a specific rule number. The C++ Core Guidelines are designed to help you write better and safer code. The suppress attribute makes it easy to turn off the warnings when they are not wanted.  \n  \n The C++ standard allows compiler vendors to define their own attribute parameters (within a vendor-specific namespace), but compilers are required to recognize only those attributes defined in the standard. In Visual C++, you can use the [[deprecated]] attribute instead of using declspec (deprecated) and the attribute will be recognized by any conformant compiler. For all other declspec parameters such as dllimport and dllexport, there is as yet no standard attribute equivalent so you must continue to use declspec syntax. Attributes do not affect the type system, and they don’t change the meaning of a program. Compilers ignore attribute values they don't recognize."}