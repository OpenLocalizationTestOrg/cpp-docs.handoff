<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa134a0f776f3ddab540c9fd47ea8c7f6d1a6130</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\mfc\tn038-mfc-ole-iunknown-implementation.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f80083ae194d89d2d8a6127a52df8d59e57dde01</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fcc3b5a8ce3bcdabe2160f8483de9543023fb294</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>TN038: MFC-OLE IUnknown Implementation | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>TN038: MFC/OLE IUnknown Implementation</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The following technical note has not been updated since it was first included in the online documentation.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>As a result, some procedures and topics might be out of date or incorrect.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For the latest information, it is recommended that you search for the topic of interest in the online documentation index.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>At the heart of OLE 2 is the "OLE Component Object Model", or COM.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>COM defines a standard for how cooperating objects communicate to one another.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This includes the details of what an "object" looks like, including how methods are dispatched on an object.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>COM also defines a base class, from which all COM compatible classes are derived.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This base class is <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Although the <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> interface is referred to as a C++ class, COM is not specific to any one language — it can be implemented in C, PASCAL, or any other language that can support the binary layout of a COM object.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>OLE refers to all classes derived from <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> as "interfaces."</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This is an important distinction, since an "interface" such as <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> carries with it no implementation.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>It simply defines the protocol by which objects communicate, not the specifics of what those implementations do.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This is reasonable for a system that allows for maximum flexibility.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>It is MFC's job to implement a default behavior for MFC/C++ programs.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>To understand MFC's implementation of <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> you must first understand what this interface is.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A simplified version of <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> is defined below:</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Certain necessary calling convention details, such as <ph id="ph1">`__stdcall`</ph> are left out for this illustration.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> member functions control memory management of the object.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>COM uses a reference counting scheme to keep track of objects.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>An object is never referenced directly as you would in C++.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Instead, COM objects are always referenced through a pointer.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>To release the object when the owner is done using it, the object's <bpt id="p1">[</bpt>Release<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> member is called (as opposed to using operator delete, as would be done for a traditional C++ object).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The reference counting mechanism allows for multiple references to a single object to be managed.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>An implementation of <bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> maintains a reference count on the object — the object is not deleted until its reference count reaches zero.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> are fairly straightforward from an implementation standpoint.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Here is a trivial implementation:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>QueryInterface<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> member function is a little more interesting.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>It is not very interesting to have an object whose only member functions are <bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> — it would be nice to tell the object to do more things than <bpt id="p3">[</bpt>IUnknown<ept id="p3">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> provides.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This is where <bpt id="p1">[</bpt>QueryInterface<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> is useful.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>It allows you to obtain a different "interface" on the same object.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>These interfaces are usually derived from <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> and add additional functionality by adding new member functions.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>COM interfaces never have member variables declared in the interface, and all member functions are declared as pure-virtual.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For example,</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To get an IPrintInterface if you only have an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>, call <bpt id="p2">[</bpt>QueryInterface<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> using the <ph id="ph1">`IID`</ph> of the <bpt id="p3">**</bpt>IPrintInterface<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`IID`</ph> is a 128-bit number that uniquely identifies the interface.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>There is an <ph id="ph1">`IID`</ph> for each interface that either you or OLE define.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`pUnk`</ph> is a pointer to an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> object, the code to retrieve an IPrintInterface from it might be:</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>That seems fairly easy, but how would you implement an object supporting both the IPrintInterface and <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> interface In this case it is simple since the IPrintInterface is derived directly from <bpt id="p2">[</bpt>IUnknown<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> — by implementing IPrintInterface, <bpt id="p3">[</bpt>IUnknown<ept id="p3">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> is automatically supported.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The implementations of <bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> would be exactly the same as those implemented above.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CPrintObj::QueryInterface<ept id="p1">**</ept> would look something like this:</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>As you can see, if the interface identifier (IID) is recognized, a pointer is returned to your object; otherwise an error occurs.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Also note that a successful <bpt id="p1">[</bpt>QueryInterface<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> results in an implied <bpt id="p2">[</bpt>AddRef<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Of course, you'd also have to implement CEditObj::Print.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>That is simple because the IPrintInterface was directly derived from the <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> interface.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>However, if you wanted to support two different interfaces, both derived from <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>, consider the following:</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Although there are a number of different ways to implement a class supporting both IEditInterface and IPrintInterface, including using C++ multiple inheritance, this note will concentrate on the use of nested classes to implement this functionality.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The entire implementation is included below:</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Notice that most of the <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> implementation is placed into the CEditPrintObj class rather than duplicating the code in CEditPrintObj::CEditObj and CEditPrintObj::CPrintObj.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This reduces the amount of code and avoids bugs.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The key point here is that from the IUnknown interface it is possible to call <bpt id="p1">[</bpt>QueryInterface<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> to retrieve any interface the object might support, and from each of those interfaces it is possible to do the same.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This means that all <bpt id="p1">[</bpt>QueryInterface<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> functions available from each interface must behave exactly the same way.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In order for these embedded objects to call the implementation in the "outer object", a back-pointer is used (m_pParent).</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The m_pParent pointer is initialized during the CEditPrintObj constructor.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Then you would implement CEditPrintObj::CPrintObj::PrintObject and CEditPrintObj::CEditObj::EditObject as well.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Quite a bit of code was added to add one feature — the ability to edit the object.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Fortunately, it is quite uncommon for interfaces to have only a single member function (although it does happen) and in this case, EditObject and PrintObject would usually be combined into a single interface.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>That's a lot of explanation and a lot of code for such a simple scenario.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The MFC/OLE classes provide a simpler alternative.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The MFC implementation uses a technique similar to the way Windows messages are wrapped with Message Maps.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This facility is called <bpt id="p1">*</bpt>Interface Maps<ept id="p1">*</ept> and is discussed in the next section.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>MFC Interface Maps</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>MFC/OLE includes an implementation of "Interface Maps" similar to MFC's "Message Maps" and "Dispatch Maps" in concept and execution.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The core features of MFC's Interface Maps are as follows:</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A standard implementation of <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>, built into the <ph id="ph1">`CCmdTarget`</ph> class.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Maintenance of the reference count, modified by <bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept> and <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept></source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Data driven implementation of <bpt id="p1">[</bpt>QueryInterface<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept></source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In addition, interface maps support the following advanced features:</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Support for creating aggregatable COM objects</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Support for using aggregate objects in the implementation of a COM object</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The implementation is hookable and extensible</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For more information on aggregation, see the <bpt id="p1">[</bpt>Aggregation<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686558\(v=vs.85\).aspx)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>MFC's interface map support is rooted in the <ph id="ph1">`CCmdTarget`</ph> class.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>"<bpt id="p1">*</bpt>has-a<ept id="p1">*</ept>" reference count as well as all the member functions associated with the <bpt id="p2">[</bpt>IUnknown<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> implementation (the reference count for example is in <ph id="ph1">`CCmdTarget`</ph>).</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>To create a class that supports OLE COM, you derive a class from <ph id="ph1">`CCmdTarget`</ph> and use various macros as well as member functions of <ph id="ph2">`CCmdTarget`</ph> to implement the desired interfaces.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>MFC's implementation uses nested classes to define each interface implementation much like the example above.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This is made easier with a standard implementation of IUnknown as well as a number of macros that eliminate some of the repetitive code.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Interface Map Basics</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>To implement a class using MFC's interface maps</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Derive a class either directly or indirectly from <ph id="ph1">`CCmdTarget`</ph>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`DECLARE_INTERFACE_MAP`</ph> function in the derived class definition.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For each interface you wish to support, use the <ph id="ph1">`BEGIN_INTERFACE_PART`</ph> and <ph id="ph2">`END_INTERFACE_PART`</ph> macros in the class definition.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>In the implementation file, use the <ph id="ph1">`BEGIN_INTERFACE_MAP`</ph> and <ph id="ph2">`END_INTERFACE_MAP`</ph> macros to define the class's interface map.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>For each IID supported, use the <ph id="ph1">`INTERFACE_PART`</ph> macro between the <ph id="ph2">`BEGIN_INTERFACE_MAP`</ph> and <ph id="ph3">`END_INTERFACE_MAP`</ph> macros to map that IID to a specific "part" of your class.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Implement each of the nested classes that represent the interfaces you support.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`METHOD_PROLOGUE`</ph> macro to access the parent, <ph id="ph2">`CCmdTarget`</ph>-derived object.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>, and <bpt id="p3">[</bpt>QueryInterface<ept id="p3">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> can delegate to the <ph id="ph1">`CCmdTarget`</ph> implementation of these functions (<ph id="ph2">`ExternalAddRef`</ph>, <ph id="ph3">`ExternalRelease`</ph>, and <ph id="ph4">`ExternalQueryInterface`</ph>).</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The CPrintEditObj example above could be implemented as follows:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The above declaration creates a class derived from <ph id="ph1">`CCmdTarget`</ph>.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`DECLARE_INTERFACE_MAP`</ph> macro tells the framework that this class will have a custom interface map.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>In addition, the <ph id="ph1">`BEGIN_INTERFACE_PART`</ph> and <ph id="ph2">`END_INTERFACE_PART`</ph> macros define nested classes, in this case with names CEditObj and CPrintObj (the X is used only to differentiate the nested classes from global classes which start with "C" and interface classes which start with "I").</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Two nested members of these classes are created: m_CEditObj, and m_CPrintObj, respectively.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The macros automatically declare the <bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>, and <bpt id="p3">[</bpt>QueryInterface<ept id="p3">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> functions; therefore you only declare the functions specific to this interface: EditObject and PrintObject (the OLE macro <ph id="ph1">`STDMETHOD`</ph> is used so that <ph id="ph2">`_stdcall`</ph> and virtual keywords are provided as appropriate for the target platform).</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>To implement the interface map for this class:</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This connects the IID_IPrintInterface IID with m_CPrintObj and IID_IEditInterface with m_CEditObj respectively.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CCmdTarget`</ph> implementation of <bpt id="p1">[</bpt>QueryInterface<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> (<ph id="ph2">`CCmdTarget::ExternalQueryInterface`</ph>) uses this map to return pointers to m_CPrintObj and m_CEditObj when requested.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>It is not necessary to include an entry for <ph id="ph1">`IID_IUnknown`</ph>; the framework will use the first interface in the map (in this case, m_CPrintObj) when <ph id="ph2">`IID_IUnknown`</ph> is requested.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Even though the <ph id="ph1">`BEGIN_INTERFACE_PART`</ph> macro automatically declared the <bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept> and <bpt id="p3">[</bpt>QueryInterface<ept id="p3">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> functions for you, you still need to implement them:</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The implementation for CEditPrintObj::CPrintObj, would be similar to the above definitions for CEditPrintObj::CEditObj.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Although it would be possible to create a macro that could be used to automatically generate these functions (but earlier in MFC/OLE development this was the case), it becomes difficult to set break points when a macro generates more than one line of code.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For this reason, this code is expanded manually.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>By using the framework implementation of message maps, there are a number of things that were not necessary to do:</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Implement QueryInterface</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Implement AddRef and Release</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Declare either of these built-in methods on both of your interfaces</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>In addition, the framework uses message maps internally.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>This allows you to derive from a framework class, say <ph id="ph1">`COleServerDoc`</ph>, that already supports certain interfaces and provides either replacements or additions to the interfaces provided by the framework.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You can do this because the framework fully supports inheriting an interface map from a base class.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>That is the reason why <ph id="ph1">`BEGIN_INTERFACE_MAP`</ph> takes as its second parameter the name of the base class.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>It is generally not possible to reuse the implementation of MFC's built-in implementations of the OLE interfaces just by inheriting the embedded specialization of that interface from the MFC version.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>This is not possible because the use of the <ph id="ph1">`METHOD_PROLOGUE`</ph> macro to get access to the containing <ph id="ph2">`CCmdTarget`</ph>-derived object implies a <bpt id="p1">*</bpt>fixed offset<ept id="p1">*</ept> of the embedded object from the <ph id="ph3">`CCmdTarget`</ph>-derived object.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>This means, for example, you cannot derive an embedded XMyAdviseSink from MFC's implementation in <ph id="ph1">`COleClientItem::XAdviseSink`</ph>, because XAdviseSink relies on being at a specific offset from the top of the <ph id="ph2">`COleClientItem`</ph> object.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>You can, however, delegate to the MFC implementation for all of the functions that you want MFC's default behavior.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This is done in the MFC implementation of <ph id="ph1">`IOleInPlaceFrame`</ph> (XOleInPlaceFrame) in the <ph id="ph2">`COleFrameHook`</ph> class (it delegates to m_xOleInPlaceUIWindow for many functions).</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This design was chosen to reduce the runtime size of objects which implement many interfaces; it eliminates the need for a back-pointer (such as the way m_pParent was used in the previous section).</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Aggregation and Interface Maps</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In addition to supporting stand-alone COM objects, MFC also supports aggregation.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Aggregation itself is too complex a topic to discuss here; refer to the <bpt id="p1">[</bpt>Aggregation<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686558\(v=vs.85\).aspx)</ept> topic for more information on aggregation.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>This note will simply describe the support for aggregation built into the framework and interface maps.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>There are two ways to use aggregation: (1) using a COM object that supports aggregation, and (2) implementing an object that can be aggregated by another.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>These capabilities can be referred to as "using an aggregate object" and "making an object aggregatable".</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>MFC supports both.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Using an Aggregate Object</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>To use an aggregate object, there needs to be some way to tie the aggregate into the QueryInterface mechanism.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>In other words, the aggregate object must behave as though it is a native part of your object.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>So how does this tie into MFC's interface map mechanism In addition to the <ph id="ph1">`INTERFACE_PART`</ph> macro, where a nested object is mapped to an IID, you can also declare an aggregate object as part of your <ph id="ph2">`CCmdTarget`</ph> derived class.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>To do so, the <ph id="ph1">`INTERFACE_AGGREGATE`</ph> macro is used.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>This allows you to specify a member variable (which must be a pointer to an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> or derived class), which is to be integrated into the interface map mechanism.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>If the pointer is not NULL when <ph id="ph1">`CCmdTarget::ExternalQueryInterface`</ph> is called, the framework will automatically call the aggregate object's <bpt id="p1">[</bpt>QueryInterface<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> member function, if the <ph id="ph2">`IID`</ph> requested is not one of the native <ph id="ph3">`IID`</ph>s supported by the <ph id="ph4">`CCmdTarget`</ph> object itself.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>To use the INTERFACE_AGGREGATE macro</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Declare a member variable (an <ph id="ph1">`IUnknown*`</ph>) which will contain a pointer to the aggregate object.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Include an <ph id="ph1">`INTERFACE_AGGREGATE`</ph> macro in your interface map, which refers to the member variable by name.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>At some point (usually during <ph id="ph1">`CCmdTarget::OnCreateAggregates`</ph>), initialize the member variable to something other than NULL.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The m_lpAggrInner variable is initialized in the constructor to NULL.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The framework ignores a NULL member variable in the default implementation of <bpt id="p1">[</bpt>QueryInterface<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>is a good place to actually create your aggregate objects.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>You'll have to call it explicitly if you are creating the object outside of the MFC implementation of <ph id="ph1">`COleObjectFactory`</ph>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The reason for creating aggregates in <ph id="ph1">`CCmdTarget::OnCreateAggregates`</ph> as well as the usage of <ph id="ph2">`CCmdTarget::GetControllingUnknown`</ph> will become apparent when creating aggregatable objects is discussed.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>This technique will give your object all of the interfaces that the aggregate object supports plus its native interfaces.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>If you only want a subset of the interfaces that the aggregate supports, you can override <ph id="ph1">`CCmdTarget::GetInterfaceHook`</ph>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>This allows you very low-level hookability, similar to <bpt id="p1">[</bpt>QueryInterface<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Usually, you want all the interfaces that the aggregate supports.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Making an Object Implementation Aggregatable</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For an object to be aggregatable, the implementation of <bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>, and <bpt id="p3">[</bpt>QueryInterface<ept id="p3">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> must delegate to a "controlling unknown."</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>In other words, for it to be part of the object, it must delegate <bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>, and <bpt id="p3">[</bpt>QueryInterface<ept id="p3">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> to a different object, also derived from <bpt id="p4">[</bpt>IUnknown<ept id="p4">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>This "controlling unknown" is provided to the object when it is created, that is, it is provided to the implementation of <ph id="ph1">`COleObjectFactory`</ph>.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Implementing this carries a small amount of overhead, and in some cases is not desirable, so MFC makes this optional.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>To enable an object to be aggregatable, you call <ph id="ph1">`CCmdTarget::EnableAggregation`</ph> from the object's constructor.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>If the object also uses aggregates, you must also be sure to pass the correct "controlling unknown" to the aggregate objects.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Usually this <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> pointer is passed to the object when the aggregate is created.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>For example, the pUnkOuter parameter is the "controlling unknown" for objects created with <ph id="ph1">`CoCreateInstance`</ph>.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The correct "controlling unknown" pointer can be retrieved by calling <ph id="ph1">`CCmdTarget::GetControllingUnknown`</ph>.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The value returned from that function, however, is not valid during the constructor.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>For this reason, it is suggested that you create your aggregates only in an override of <ph id="ph1">`CCmdTarget::OnCreateAggregates`</ph>, where the return value from <ph id="ph2">`GetControllingUnknown`</ph> is reliable, even if created from the <ph id="ph3">`COleObjectFactory`</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>It is also important that the object manipulate the correct reference count when adding or releasing artificial reference counts.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>To ensure this is the case, always call <ph id="ph1">`ExternalAddRef`</ph> and <ph id="ph2">`ExternalRelease`</ph> instead of <ph id="ph3">`InternalRelease`</ph> and <ph id="ph4">`InternalAddRef`</ph>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>It is rare to call <ph id="ph1">`InternalRelease`</ph> or <ph id="ph2">`InternalAddRef`</ph> on a class that supports aggregation.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Reference Material</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Advanced usage of OLE, such as defining your own interfaces or overriding the framework's implementation of the OLE interfaces requires the use of the underlying interface map mechanism.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This section discusses each macro and the APIs which is used to implement these advanced features.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>CCmdTarget::EnableAggregation — Function Description</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Call this function in the constructor of the derived class if you wish to support OLE aggregation for objects of this type.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>This prepares a special IUnknown implementation that is required for aggregatable objects.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>CCmdTarget::ExternalQueryInterface — Function Description</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>A far pointer to an IID (the first argument to QueryInterface)</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>A pointer to an IUnknown* (second argument to QueryInterface)</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Call this function in your implementation of IUnknown for each interface your class implements.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>This function provides the standard data-driven implementation of QueryInterface based on your object's interface map.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>It is necessary to cast the return value to an HRESULT.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>If the object is aggregated, this function will call the "controlling IUnknown" instead of using the local interface map.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>CCmdTarget::ExternalAddRef — Function Description</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Call this function in your implementation of IUnknown::AddRef for each interface your class implements.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The return value is the new reference count on the CCmdTarget object.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If the object is aggregated, this function will call the "controlling IUnknown" instead of manipulating the local reference count.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>CCmdTarget::ExternalRelease — Function Description</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Call this function in your implementation of IUnknown::Release for each interface your class implements.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The return value indicates the new reference count on the object.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>If the object is aggregated, this function will call the "controlling IUnknown" instead of manipulating the local reference count.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>DECLARE_INTERFACE_MAP — Macro Description</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Use this macro in any class derived from <ph id="ph1">`CCmdTarget`</ph> that will have an interface map.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Used in much the same way as <ph id="ph1">`DECLARE_MESSAGE_MAP`</ph>.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>This macro invocation should be placed in the class definition, usually in a header (.H) file.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>A class with <ph id="ph1">`DECLARE_INTERFACE_MAP`</ph> must define the interface map in the implementation file (.CPP) with the <ph id="ph2">`BEGIN_INTERFACE_MAP`</ph> and <ph id="ph3">`END_INTERFACE_MAP`</ph> macros.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>BEGIN_INTERFACE_PART and END_INTERFACE_PART — Macro Descriptions</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>l</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The name of the class that implements the interface</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The name of the interface that this class implements</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>For each interface that your class will implement, you need to have a <ph id="ph1">`BEGIN_INTERFACE_PART`</ph> and <ph id="ph2">`END_INTERFACE_PART`</ph> pair.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>These macros define a local class derived from the OLE interface that you define as well as an embedded member variable of that class.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>AddRef<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms691379)</ept>, <bpt id="p2">[</bpt>Release<ept id="p2">](http://msdn.microsoft.com/library/windows/desktop/ms682317)</ept>, and <bpt id="p3">[</bpt>QueryInterface<ept id="p3">](http://msdn.microsoft.com/library/windows/desktop/ms682521)</ept> members are declared automatically.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>You must include the declarations for the other member functions that are part of the interface being implemented (those declarations are placed between the <ph id="ph1">`BEGIN_INTERFACE_PART`</ph> and <ph id="ph2">`END_INTERFACE_PART`</ph> macros).</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`iface`</ph> argument is the OLE interface that you wish to implement, such as <ph id="ph2">`IAdviseSink`</ph>, or <ph id="ph3">`IPersistStorage`</ph> (or your own custom interface).</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`localClass`</ph> argument is the name of the local class that will be defined.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>An 'X' will automatically be prepended to the name.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>This naming convention is used to avoid collisions with global classes of the same name.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>In addition, the name of the embedded member, the same as the <ph id="ph1">`localClass`</ph> name except it is prefixed by 'm_x'.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>would define a local class called XMyAdviseSink derived from IAdviseSink, and a member of the class in which it is declared called m_xMyAdviseSink.Note:</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The lines beginning with <ph id="ph1">`STDMETHOD`</ph>_ are essentially copied from OLE2.H and modified slightly.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Copying them from OLE2.H can reduce errors that are hard to resolve.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>BEGIN_INTERFACE_MAP and END_INTERFACE_MAP — Macro Descriptions</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The class in which the interface map is to be defined</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The class from which <ph id="ph1">`theClass`</ph> derives from.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`BEGIN_INTERFACE_MAP`</ph> and <ph id="ph2">`END_INTERFACE_MAP`</ph> macros are used in the implementation file to actually define the interface map.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>For each interface that is implemented there is one or more <ph id="ph1">`INTERFACE_PART`</ph> macro invocations.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>For each aggregate that the class uses, there is one <ph id="ph1">`INTERFACE_AGGREGATE`</ph> macro invocation.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>INTERFACE_PART — Macro Description</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The name of the class that contains the interface map.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IID`</ph> that is to be mapped to the embedded class.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The name of the local class (less the 'X').</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>This macro is used between the <ph id="ph1">`BEGIN_INTERFACE_MAP`</ph> macro and the <ph id="ph2">`END_INTERFACE_MAP`</ph> macro for each interface your object will support.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>It allows you to map an IID to a member of the class indicated by <ph id="ph1">`theClass`</ph> and <ph id="ph2">`localClass`</ph>.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The 'm_x' will be added to the <ph id="ph1">`localClass`</ph> automatically.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Note that more than one <ph id="ph1">`IID`</ph> may be associated with a single member.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>This is very useful when you are implementing only a "most derived" interface and wish to provide all intermediate interfaces as well.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>A good example of this is the <ph id="ph1">`IOleInPlaceFrameWindow`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Its hierarchy looks like this:</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>If an object implements <ph id="ph1">`IOleInPlaceFrameWindow`</ph>, a client may <ph id="ph2">`QueryInterface`</ph> on any of these interfaces: <ph id="ph3">`IOleUIWindow`</ph>, <ph id="ph4">`IOleWindow`</ph>, or <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>, besides the "most derived" interface <ph id="ph5">`IOleInPlaceFrameWindow`</ph> (the one you are actually implementing).</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>To handle this you can use more than one <ph id="ph1">`INTERFACE_PART`</ph> macro to map each and every base interface to the <ph id="ph2">`IOleInPlaceFrameWindow`</ph> interface:</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>in the class definition file:</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>in the class implementation file:</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The framework takes care of IUnknown because it is always required.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>INTERFACE_PART — Macro Description</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The name of the class that contains the interface map,</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The name of the member variable that is to be aggregated.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>This macro is used to tell the framework that the class is using an aggregate object.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>It must appear between the <ph id="ph1">`BEGIN_INTERFACE_PART`</ph> and <ph id="ph2">`END_INTERFACE_PART`</ph> macros.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>An aggregate object is a separate object, derived from <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept>.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>By using an aggregate and the <ph id="ph1">`INTERFACE_AGGREGATE`</ph> macro, you can make all the interfaces that the aggregate supports appear to be directly supported by the object.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`theAggr`</ph> argument is simply the name of a member variable of your class which is derived from <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms680509)</ept> (either directly or indirectly).</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>All <ph id="ph1">`INTERFACE_AGGREGATE`</ph> macros must follow the <ph id="ph2">`INTERFACE_PART`</ph> macros when placed in an interface map.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Technical Notes by Number</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Technical Notes by Category</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>