{"nodes":[{"pos":[12,63],"content":"How to: Use a Message Block Filter | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Use a Message Block Filter | Microsoft Docs","pos":[0,51]}]},{"content":"How to: Use a Message Block Filter","pos":[705,739]},{"content":"This document demonstrates how to use a filter function to enable an asynchronous message block to accept or reject a message on the basis of the payload of that message.","pos":[740,910]},{"content":"When you create a message block object such as a <bpt id=\"p1\">[</bpt>concurrency::unbounded_buffer<ept id=\"p1\">](reference/unbounded-buffer-class.md)</ept>, a <bpt id=\"p2\">[</bpt>concurrency::call<ept id=\"p2\">](../../parallel/concrt/reference/call-class.md)</ept>, or a <bpt id=\"p3\">[</bpt>concurrency::transformer<ept id=\"p3\">](../../parallel/concrt/reference/transformer-class.md)</ept>, you can supply a <bpt id=\"p4\">*</bpt>filter function<ept id=\"p4\">*</ept> that determines whether the message block accepts or rejects a message.","pos":[917,1299],"source":"When you create a message block object such as a [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md), a [concurrency::call](../../parallel/concrt/reference/call-class.md), or a [concurrency::transformer](../../parallel/concrt/reference/transformer-class.md), you can supply a *filter function* that determines whether the message block accepts or rejects a message."},{"content":"A filter function is a useful way to guarantee that a message block receives only certain values.","pos":[1300,1397]},{"content":"Filter functions are important because they enable you to connect message blocks to form <bpt id=\"p1\">*</bpt>dataflow networks<ept id=\"p1\">*</ept>.","pos":[1404,1513],"source":"Filter functions are important because they enable you to connect message blocks to form *dataflow networks*."},{"content":"In a dataflow network, message blocks control the flow of data by processing only those messages that meet specific criteria.","pos":[1514,1639]},{"content":"Compare this to the control-flow model, where the flow of data is regulated by using control structures such as conditional statements, loops, and so on.","pos":[1640,1793]},{"content":"This document provides a basic example of how to use a message filter.","pos":[1800,1870]},{"content":"For additional examples that use message filters and the dataflow model to connect message blocks, see <bpt id=\"p1\">[</bpt>Walkthrough: Creating a Dataflow Agent<ept id=\"p1\">](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md)</ept> and <bpt id=\"p2\">[</bpt>Walkthrough: Creating an Image-Processing Network<ept id=\"p2\">](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)</ept>.","pos":[1871,2210],"source":" For additional examples that use message filters and the dataflow model to connect message blocks, see [Walkthrough: Creating a Dataflow Agent](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md) and [Walkthrough: Creating an Image-Processing Network](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)."},{"content":"Example","pos":[2219,2226]},{"content":"Consider the following function, <ph id=\"ph1\">`count_primes`</ph>, which illustrates the basic usage of a message block that does not filter incoming messages.","pos":[2230,2371],"source":"Consider the following function, `count_primes`, which illustrates the basic usage of a message block that does not filter incoming messages."},{"content":"The message block appends prime numbers to a <bpt id=\"p1\">[</bpt>std::vector<ept id=\"p1\">](../../standard-library/vector-class.md)</ept> object.","pos":[2372,2478],"source":" The message block appends prime numbers to a [std::vector](../../standard-library/vector-class.md) object."},{"content":"The <ph id=\"ph1\">`count_primes`</ph> function sends several numbers to the message block, receives the output values from the message block, and prints those numbers that are prime to the console.","pos":[2479,2657],"source":" The `count_primes` function sends several numbers to the message block, receives the output values from the message block, and prints those numbers that are prime to the console."},{"pos":[2675,2697],"content":"concrt-primes-filter#1"},{"content":"The <ph id=\"ph1\">`transformer`</ph> object processes all input values; however, it requires only those values that are prime.","pos":[2785,2892],"source":"The `transformer` object processes all input values; however, it requires only those values that are prime."},{"content":"Although the application could be written so that the message sender sends only prime numbers, the requirements of the message receiver cannot always be known.","pos":[2893,3052]},{"content":"Example","pos":[3061,3068]},{"content":"The following function, <ph id=\"ph1\">`count_primes_filter`</ph>, performs the same task as the <ph id=\"ph2\">`count_primes`</ph> function.","pos":[3072,3173],"source":"The following function, `count_primes_filter`, performs the same task as the `count_primes` function."},{"content":"However, the <ph id=\"ph1\">`transformer`</ph> object in this version uses a filter function to accept only those values that are prime.","pos":[3174,3290],"source":" However, the `transformer` object in this version uses a filter function to accept only those values that are prime."},{"content":"The function that performs the action only receives prime numbers; therefore, it does not have to call the <ph id=\"ph1\">`is_prime`</ph> function.","pos":[3291,3418],"source":" The function that performs the action only receives prime numbers; therefore, it does not have to call the `is_prime` function."},{"content":"Because the <ph id=\"ph1\">`transformer`</ph> object receives only prime numbers, the <ph id=\"ph2\">`transformer`</ph> object itself can hold the prime numbers.","pos":[3425,3546],"source":"Because the `transformer` object receives only prime numbers, the `transformer` object itself can hold the prime numbers."},{"content":"In other words, the <ph id=\"ph1\">`transformer`</ph> object in this example is not required to add the prime numbers to the <ph id=\"ph2\">`vector`</ph> object.","pos":[3547,3668],"source":" In other words, the `transformer` object in this example is not required to add the prime numbers to the `vector` object."},{"pos":[3686,3708],"content":"concrt-primes-filter#2"},{"content":"The <ph id=\"ph1\">`transformer`</ph> object now processes only those values that are prime.","pos":[3796,3868],"source":"The `transformer` object now processes only those values that are prime."},{"content":"In the previous example, <ph id=\"ph1\">`transformer`</ph> object processes all messages.","pos":[3869,3938],"source":" In the previous example, `transformer` object processes all messages."},{"content":"Therefore, the previous example must receive the same number of messages that it sends.","pos":[3939,4026]},{"content":"This example uses the result of the <bpt id=\"p1\">[</bpt>concurrency::send<ept id=\"p1\">](reference/concurrency-namespace-functions.md#send)</ept> function to determine how many messages to receive from the <ph id=\"ph1\">`transformer`</ph> object.","pos":[4027,4215],"source":" This example uses the result of the [concurrency::send](reference/concurrency-namespace-functions.md#send) function to determine how many messages to receive from the `transformer` object."},{"content":"The <ph id=\"ph1\">`send`</ph> function returns <ph id=\"ph2\">`true`</ph> when the message buffer accepts the message and <ph id=\"ph3\">`false`</ph> when the message buffer rejects the message.","pos":[4216,4351],"source":" The `send` function returns `true` when the message buffer accepts the message and `false` when the message buffer rejects the message."},{"content":"Therefore, the number of times that the message buffer accepts the message matches the count of prime numbers.","pos":[4352,4462]},{"content":"Example","pos":[4471,4478]},{"content":"The following code shows the complete example.","pos":[4482,4528]},{"content":"The example calls both the <ph id=\"ph1\">`count_primes`</ph> function and the <ph id=\"ph2\">`count_primes_filter`</ph> function.","pos":[4529,4619],"source":" The example calls both the `count_primes` function and the `count_primes_filter` function."},{"pos":[4637,4659],"content":"concrt-primes-filter#3"},{"content":"Compiling the Code","pos":[4749,4767]},{"pos":[4771,4966],"content":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named <ph id=\"ph1\">`primes-filter.cpp`</ph> and then run the following command in a Visual Studio Command Prompt window.","source":"Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `primes-filter.cpp` and then run the following command in a Visual Studio Command Prompt window."},{"content":"cl.exe /EHsc primes-filter.cpp","pos":[4975,5005]},{"content":"Robust Programming","pos":[5016,5034]},{"content":"A filter function can be a lambda function, a function pointer, or a function object.","pos":[5038,5123]},{"content":"Every filter function takes one of the following forms:","pos":[5124,5179]},{"content":"To eliminate the unnecessary copying of data, use the second form when you have an aggregate type that is transmitted by value.","pos":[5237,5364]},{"content":"See Also","pos":[5373,5381]},{"content":"Asynchronous Agents Library","pos":[5386,5413]},{"content":"Walkthrough: Creating a Dataflow Agent","pos":[5474,5512]},{"content":"Walkthrough: Creating an Image-Processing Network","pos":[5583,5632]},{"content":"transformer Class","pos":[5714,5731]}],"content":"---\ntitle: \"How to: Use a Message Block Filter | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"message-block filters, using [Concurrency Runtime]\"\n  - \"using message-block filters [Concurrency Runtime]\"\nms.assetid: db6b99fb-288d-4477-96dc-b9751772ebb2\ncaps.latest.revision: 20\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# How to: Use a Message Block Filter\nThis document demonstrates how to use a filter function to enable an asynchronous message block to accept or reject a message on the basis of the payload of that message.  \n  \n When you create a message block object such as a [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md), a [concurrency::call](../../parallel/concrt/reference/call-class.md), or a [concurrency::transformer](../../parallel/concrt/reference/transformer-class.md), you can supply a *filter function* that determines whether the message block accepts or rejects a message. A filter function is a useful way to guarantee that a message block receives only certain values.  \n  \n Filter functions are important because they enable you to connect message blocks to form *dataflow networks*. In a dataflow network, message blocks control the flow of data by processing only those messages that meet specific criteria. Compare this to the control-flow model, where the flow of data is regulated by using control structures such as conditional statements, loops, and so on.  \n  \n This document provides a basic example of how to use a message filter. For additional examples that use message filters and the dataflow model to connect message blocks, see [Walkthrough: Creating a Dataflow Agent](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md) and [Walkthrough: Creating an Image-Processing Network](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).  \n  \n## Example  \n Consider the following function, `count_primes`, which illustrates the basic usage of a message block that does not filter incoming messages. The message block appends prime numbers to a [std::vector](../../standard-library/vector-class.md) object. The `count_primes` function sends several numbers to the message block, receives the output values from the message block, and prints those numbers that are prime to the console.  \n  \n [!code-cpp[concrt-primes-filter#1](../../parallel/concrt/codesnippet/cpp/how-to-use-a-message-block-filter_1.cpp)]  \n  \n The `transformer` object processes all input values; however, it requires only those values that are prime. Although the application could be written so that the message sender sends only prime numbers, the requirements of the message receiver cannot always be known.  \n  \n## Example  \n The following function, `count_primes_filter`, performs the same task as the `count_primes` function. However, the `transformer` object in this version uses a filter function to accept only those values that are prime. The function that performs the action only receives prime numbers; therefore, it does not have to call the `is_prime` function.  \n  \n Because the `transformer` object receives only prime numbers, the `transformer` object itself can hold the prime numbers. In other words, the `transformer` object in this example is not required to add the prime numbers to the `vector` object.  \n  \n [!code-cpp[concrt-primes-filter#2](../../parallel/concrt/codesnippet/cpp/how-to-use-a-message-block-filter_2.cpp)]  \n  \n The `transformer` object now processes only those values that are prime. In the previous example, `transformer` object processes all messages. Therefore, the previous example must receive the same number of messages that it sends. This example uses the result of the [concurrency::send](reference/concurrency-namespace-functions.md#send) function to determine how many messages to receive from the `transformer` object. The `send` function returns `true` when the message buffer accepts the message and `false` when the message buffer rejects the message. Therefore, the number of times that the message buffer accepts the message matches the count of prime numbers.  \n  \n## Example  \n The following code shows the complete example. The example calls both the `count_primes` function and the `count_primes_filter` function.  \n  \n [!code-cpp[concrt-primes-filter#3](../../parallel/concrt/codesnippet/cpp/how-to-use-a-message-block-filter_3.cpp)]  \n  \n## Compiling the Code  \n Copy the example code and paste it in a Visual Studio project, or paste it in a file that is named `primes-filter.cpp` and then run the following command in a Visual Studio Command Prompt window.  \n  \n **cl.exe /EHsc primes-filter.cpp**  \n  \n## Robust Programming  \n A filter function can be a lambda function, a function pointer, or a function object. Every filter function takes one of the following forms:  \n  \n```Output  \nbool (T)  \nbool (T const &)  \n```  \n  \n To eliminate the unnecessary copying of data, use the second form when you have an aggregate type that is transmitted by value.  \n  \n## See Also  \n [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md)   \n [Walkthrough: Creating a Dataflow Agent](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md)   \n [Walkthrough: Creating an Image-Processing Network](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)   \n [transformer Class](../../parallel/concrt/reference/transformer-class.md)\n"}