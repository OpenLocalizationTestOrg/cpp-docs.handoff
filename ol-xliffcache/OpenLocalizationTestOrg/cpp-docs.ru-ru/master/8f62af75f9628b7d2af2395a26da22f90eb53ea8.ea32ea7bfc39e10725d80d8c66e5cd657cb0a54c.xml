{"nodes":[{"pos":[12,45],"content":"CRecordset Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CRecordset Class | Microsoft Docs","pos":[0,33]}]},{"pos":[709,725],"content":"CRecordset Class","linkify":"CRecordset Class","nodes":[{"content":"CRecordset Class","pos":[0,16]}]},{"content":"Represents a set of records selected from a data source.","pos":[726,782]},{"pos":[791,797],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[857,864],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"pos":[874,893],"content":"Public Constructors","linkify":"Public Constructors","nodes":[{"content":"Public Constructors","pos":[0,19]}]},{"content":"Name","pos":[900,904]},{"content":"Description","pos":[905,916]},{"pos":[954,1003],"content":"<bpt id=\"p1\">[</bpt>CRecordset::CRecordset<ept id=\"p1\">](#crecordset__crecordset)</ept>","source":"[CRecordset::CRecordset](#crecordset__crecordset)"},{"content":"Constructs a <ph id=\"ph1\">`CRecordset`</ph> object.","pos":[1004,1037],"source":"Constructs a `CRecordset` object."},{"content":"Your derived class must provide a constructor that calls this one.","pos":[1038,1104]},{"pos":[1115,1129],"content":"Public Methods","linkify":"Public Methods","nodes":[{"content":"Public Methods","pos":[0,14]}]},{"content":"Name","pos":[1136,1140]},{"content":"Description","pos":[1141,1152]},{"pos":[1190,1231],"content":"<bpt id=\"p1\">[</bpt>CRecordset::AddNew<ept id=\"p1\">](#crecordset__addnew)</ept>","source":"[CRecordset::AddNew](#crecordset__addnew)"},{"content":"Prepares for adding a new record.","pos":[1232,1265]},{"content":"Call <ph id=\"ph1\">`Update`</ph> to complete the addition.","pos":[1266,1305],"source":" Call `Update` to complete the addition."},{"pos":[1310,1357],"content":"<bpt id=\"p1\">[</bpt>CRecordset::CanAppend<ept id=\"p1\">](#crecordset__canappend)</ept>","source":"[CRecordset::CanAppend](#crecordset__canappend)"},{"pos":[1358,1452],"content":"Returns nonzero if new records can be added to the recordset via the <ph id=\"ph1\">`AddNew`</ph> member function.","source":"Returns nonzero if new records can be added to the recordset via the `AddNew` member function."},{"pos":[1457,1508],"content":"<bpt id=\"p1\">[</bpt>CRecordset::CanBookmark<ept id=\"p1\">](#crecordset__canbookmark)</ept>","source":"[CRecordset::CanBookmark](#crecordset__canbookmark)"},{"content":"Returns nonzero if the recordset supports bookmarks.","pos":[1509,1561]},{"pos":[1566,1607],"content":"<bpt id=\"p1\">[</bpt>CRecordset::Cancel<ept id=\"p1\">](#crecordset__cancel)</ept>","source":"[CRecordset::Cancel](#crecordset__cancel)"},{"content":"Cancels an asynchronous operation or a process from a second thread.","pos":[1608,1676]},{"pos":[1681,1734],"content":"<bpt id=\"p1\">[</bpt>CRecordset::CancelUpdate<ept id=\"p1\">](#crecordset__cancelupdate)</ept>","source":"[CRecordset::CancelUpdate](#crecordset__cancelupdate)"},{"pos":[1735,1802],"content":"Cancels any pending updates due to an <ph id=\"ph1\">`AddNew`</ph> or <ph id=\"ph2\">`Edit`</ph> operation.","source":"Cancels any pending updates due to an `AddNew` or `Edit` operation."},{"pos":[1807,1856],"content":"<bpt id=\"p1\">[</bpt>CRecordset::CanRestart<ept id=\"p1\">](#crecordset__canrestart)</ept>","source":"[CRecordset::CanRestart](#crecordset__canrestart)"},{"pos":[1857,1935],"content":"Returns nonzero if <ph id=\"ph1\">`Requery`</ph> can be called to run the recordset's query again.","source":"Returns nonzero if `Requery` can be called to run the recordset's query again."},{"pos":[1940,1987],"content":"<bpt id=\"p1\">[</bpt>CRecordset::CanScroll<ept id=\"p1\">](#crecordset__canscroll)</ept>","source":"[CRecordset::CanScroll](#crecordset__canscroll)"},{"content":"Returns nonzero if you can scroll through the records.","pos":[1988,2042]},{"pos":[2047,2098],"content":"<bpt id=\"p1\">[</bpt>CRecordset::CanTransact<ept id=\"p1\">](#crecordset__cantransact)</ept>","source":"[CRecordset::CanTransact](#crecordset__cantransact)"},{"content":"Returns nonzero if the data source supports transactions.","pos":[2099,2156]},{"pos":[2161,2208],"content":"<bpt id=\"p1\">[</bpt>CRecordset::CanUpdate<ept id=\"p1\">](#crecordset__canupdate)</ept>","source":"[CRecordset::CanUpdate](#crecordset__canupdate)"},{"content":"Returns nonzero if the recordset can be updated (you can add, update, or delete records).","pos":[2209,2298]},{"pos":[2303,2364],"content":"<bpt id=\"p1\">[</bpt>CRecordset::CheckRowsetError<ept id=\"p1\">](#crecordset__checkrowseterror)</ept>","source":"[CRecordset::CheckRowsetError](#crecordset__checkrowseterror)"},{"content":"Called to handle errors generated during record fetching.","pos":[2365,2422]},{"pos":[2427,2466],"content":"<bpt id=\"p1\">[</bpt>CRecordset::Close<ept id=\"p1\">](#crecordset__close)</ept>","source":"[CRecordset::Close](#crecordset__close)"},{"pos":[2467,2530],"content":"Closes the recordset and the ODBC <bpt id=\"p1\">**</bpt>HSTMT<ept id=\"p1\">**</ept> associated with it.","source":"Closes the recordset and the ODBC **HSTMT** associated with it."},{"pos":[2535,2576],"content":"<bpt id=\"p1\">[</bpt>CRecordset::Delete<ept id=\"p1\">](#crecordset__delete)</ept>","source":"[CRecordset::Delete](#crecordset__delete)"},{"content":"Deletes the current record from the recordset.","pos":[2577,2623]},{"content":"You must explicitly scroll to another record after the deletion.","pos":[2624,2688]},{"pos":[2693,2760],"content":"<bpt id=\"p1\">[</bpt>CRecordset::DoBulkFieldExchange<ept id=\"p1\">](#crecordset__dobulkfieldexchange)</ept>","source":"[CRecordset::DoBulkFieldExchange](#crecordset__dobulkfieldexchange)"},{"content":"Called to exchange bulk rows of data from the data source to the recordset.","pos":[2761,2836]},{"content":"Implements bulk record field exchange (Bulk RFX).","pos":[2837,2886]},{"pos":[2891,2950],"content":"<bpt id=\"p1\">[</bpt>CRecordset::DoFieldExchange<ept id=\"p1\">](#crecordset__dofieldexchange)</ept>","source":"[CRecordset::DoFieldExchange](#crecordset__dofieldexchange)"},{"content":"Called to exchange data (in both directions) between the field data members of the recordset and the corresponding record on the data source.","pos":[2951,3092]},{"content":"Implements record field exchange (RFX).","pos":[3093,3132]},{"pos":[3137,3174],"content":"<bpt id=\"p1\">[</bpt>CRecordset::Edit<ept id=\"p1\">](#crecordset__edit)</ept>","source":"[CRecordset::Edit](#crecordset__edit)"},{"content":"Prepares for changes to the current record.","pos":[3175,3218]},{"content":"Call <ph id=\"ph1\">`Update`</ph> to complete the edit.","pos":[3219,3254],"source":" Call `Update` to complete the edit."},{"pos":[3259,3316],"content":"<bpt id=\"p1\">[</bpt>CRecordset::FlushResultSet<ept id=\"p1\">](#crecordset__flushresultset)</ept>","source":"[CRecordset::FlushResultSet](#crecordset__flushresultset)"},{"content":"Returns nonzero if there is another result set to be retrieved, when using a predefined query.","pos":[3317,3411]},{"pos":[3416,3467],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetBookmark<ept id=\"p1\">](#crecordset__getbookmark)</ept>","source":"[CRecordset::GetBookmark](#crecordset__getbookmark)"},{"content":"Assigns the bookmark value of a record to the parameter object.","pos":[3468,3531]},{"pos":[3536,3599],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetDefaultConnect<ept id=\"p1\">](#crecordset__getdefaultconnect)</ept>","source":"[CRecordset::GetDefaultConnect](#crecordset__getdefaultconnect)"},{"content":"Called to get the default connection string.","pos":[3600,3644]},{"pos":[3649,3704],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetDefaultSQL<ept id=\"p1\">](#crecordset__getdefaultsql)</ept>","source":"[CRecordset::GetDefaultSQL](#crecordset__getdefaultsql)"},{"content":"Called to get the default SQL string to execute.","pos":[3705,3753]},{"pos":[3758,3813],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetFieldValue<ept id=\"p1\">](#crecordset__getfieldvalue)</ept>","source":"[CRecordset::GetFieldValue](#crecordset__getfieldvalue)"},{"content":"Returns the value of a field in a recordset.","pos":[3814,3858]},{"pos":[3863,3926],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetODBCFieldCount<ept id=\"p1\">](#crecordset__getodbcfieldcount)</ept>","source":"[CRecordset::GetODBCFieldCount](#crecordset__getodbcfieldcount)"},{"content":"Returns the number of fields in the recordset.","pos":[3927,3973]},{"pos":[3978,4039],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetODBCFieldInfo<ept id=\"p1\">](#crecordset__getodbcfieldinfo)</ept>","source":"[CRecordset::GetODBCFieldInfo](#crecordset__getodbcfieldinfo)"},{"content":"Returns specific kinds of information about the fields in a recordset.","pos":[4040,4110]},{"pos":[4115,4172],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetRecordCount<ept id=\"p1\">](#crecordset__getrecordcount)</ept>","source":"[CRecordset::GetRecordCount](#crecordset__getrecordcount)"},{"content":"Returns the number of records in the recordset.","pos":[4173,4220]},{"pos":[4225,4280],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetRowsetSize<ept id=\"p1\">](#crecordset__getrowsetsize)</ept>","source":"[CRecordset::GetRowsetSize](#crecordset__getrowsetsize)"},{"content":"Returns the number of records you wish to retrieve during a single fetch.","pos":[4281,4354]},{"pos":[4359,4416],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetRowsFetched<ept id=\"p1\">](#crecordset__getrowsfetched)</ept>","source":"[CRecordset::GetRowsFetched](#crecordset__getrowsfetched)"},{"content":"Returns the actual number of rows retrieved during a fetch.","pos":[4417,4476]},{"pos":[4481,4534],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetRowStatus<ept id=\"p1\">](#crecordset__getrowstatus)</ept>","source":"[CRecordset::GetRowStatus](#crecordset__getrowstatus)"},{"content":"Returns the status of the row after a fetch.","pos":[4535,4579]},{"pos":[4584,4625],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetSQL<ept id=\"p1\">](#crecordset__getsql)</ept>","source":"[CRecordset::GetSQL](#crecordset__getsql)"},{"content":"Gets the SQL string used to select records for the recordset.","pos":[4626,4687]},{"pos":[4692,4739],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetStatus<ept id=\"p1\">](#crecordset__getstatus)</ept>","source":"[CRecordset::GetStatus](#crecordset__getstatus)"},{"content":"Gets the status of the recordset: the index of the current record and whether a final count of the records has been obtained.","pos":[4740,4865]},{"pos":[4870,4923],"content":"<bpt id=\"p1\">[</bpt>CRecordset::GetTableName<ept id=\"p1\">](#crecordset__gettablename)</ept>","source":"[CRecordset::GetTableName](#crecordset__gettablename)"},{"content":"Gets the name of the table on which the recordset is based.","pos":[4924,4983]},{"pos":[4988,5027],"content":"<bpt id=\"p1\">[</bpt>CRecordset::IsBOF<ept id=\"p1\">](#crecordset__isbof)</ept>","source":"[CRecordset::IsBOF](#crecordset__isbof)"},{"content":"Returns nonzero if the recordset has been positioned before the first record.","pos":[5028,5105]},{"content":"There is no current record.","pos":[5106,5133]},{"pos":[5138,5185],"content":"<bpt id=\"p1\">[</bpt>CRecordset::IsDeleted<ept id=\"p1\">](#crecordset__isdeleted)</ept>","source":"[CRecordset::IsDeleted](#crecordset__isdeleted)"},{"content":"Returns nonzero if the recordset is positioned on a deleted record.","pos":[5186,5253]},{"pos":[5258,5297],"content":"<bpt id=\"p1\">[</bpt>CRecordset::IsEOF<ept id=\"p1\">](#crecordset__iseof)</ept>","source":"[CRecordset::IsEOF](#crecordset__iseof)"},{"content":"Returns nonzero if the recordset has been positioned after the last record.","pos":[5298,5373]},{"content":"There is no current record.","pos":[5374,5401]},{"pos":[5406,5459],"content":"<bpt id=\"p1\">[</bpt>CRecordset::IsFieldDirty<ept id=\"p1\">](#crecordset__isfielddirty)</ept>","source":"[CRecordset::IsFieldDirty](#crecordset__isfielddirty)"},{"content":"Returns nonzero if the specified field in the current record has been changed.","pos":[5460,5538]},{"pos":[5543,5594],"content":"<bpt id=\"p1\">[</bpt>CRecordset::IsFieldNull<ept id=\"p1\">](#crecordset__isfieldnull)</ept>","source":"[CRecordset::IsFieldNull](#crecordset__isfieldnull)"},{"content":"Returns nonzero if the specified field in the current record is null (has no value).","pos":[5595,5679]},{"pos":[5684,5743],"content":"<bpt id=\"p1\">[</bpt>CRecordset::IsFieldNullable<ept id=\"p1\">](#crecordset__isfieldnullable)</ept>","source":"[CRecordset::IsFieldNullable](#crecordset__isfieldnullable)"},{"content":"Returns nonzero if the specified field in the current record can be set to null (having no value).","pos":[5744,5842]},{"pos":[5847,5888],"content":"<bpt id=\"p1\">[</bpt>CRecordset::IsOpen<ept id=\"p1\">](#crecordset__isopen)</ept>","source":"[CRecordset::IsOpen](#crecordset__isopen)"},{"pos":[5889,5942],"content":"Returns nonzero if <ph id=\"ph1\">`Open`</ph> has been called previously.","source":"Returns nonzero if `Open` has been called previously."},{"pos":[5947,5984],"content":"<bpt id=\"p1\">[</bpt>CRecordset::Move<ept id=\"p1\">](#crecordset__move)</ept>","source":"[CRecordset::Move](#crecordset__move)"},{"content":"Positions the recordset to a specified number of records from the current record in either direction.","pos":[5985,6086]},{"pos":[6091,6138],"content":"<bpt id=\"p1\">[</bpt>CRecordset::MoveFirst<ept id=\"p1\">](#crecordset__movefirst)</ept>","source":"[CRecordset::MoveFirst](#crecordset__movefirst)"},{"content":"Positions the current record on the first record in the recordset.","pos":[6139,6205]},{"content":"Test for <ph id=\"ph1\">`IsBOF`</ph> first.","pos":[6206,6229],"source":" Test for `IsBOF` first."},{"pos":[6234,6279],"content":"<bpt id=\"p1\">[</bpt>CRecordset::MoveLast<ept id=\"p1\">](#crecordset__movelast)</ept>","source":"[CRecordset::MoveLast](#crecordset__movelast)"},{"content":"Positions the current record on the last record or on the last rowset.","pos":[6280,6350]},{"content":"Test for <ph id=\"ph1\">`IsEOF`</ph> first.","pos":[6351,6374],"source":" Test for `IsEOF` first."},{"pos":[6379,6424],"content":"<bpt id=\"p1\">[</bpt>CRecordset::MoveNext<ept id=\"p1\">](#crecordset__movenext)</ept>","source":"[CRecordset::MoveNext](#crecordset__movenext)"},{"content":"Positions the current record on the next record or on the next rowset.","pos":[6425,6495]},{"content":"Test for <ph id=\"ph1\">`IsEOF`</ph> first.","pos":[6496,6519],"source":" Test for `IsEOF` first."},{"pos":[6524,6569],"content":"<bpt id=\"p1\">[</bpt>CRecordset::MovePrev<ept id=\"p1\">](#crecordset__moveprev)</ept>","source":"[CRecordset::MovePrev](#crecordset__moveprev)"},{"content":"Positions the current record on the previous record or on the previous rowset.","pos":[6570,6648]},{"content":"Test for <ph id=\"ph1\">`IsBOF`</ph> first.","pos":[6649,6672],"source":" Test for `IsBOF` first."},{"pos":[6677,6730],"content":"<bpt id=\"p1\">[</bpt>CRecordset::OnSetOptions<ept id=\"p1\">](#crecordset__onsetoptions)</ept>","source":"[CRecordset::OnSetOptions](#crecordset__onsetoptions)"},{"content":"Called to set options (used on selection) for the specified ODBC statement.","pos":[6731,6806]},{"pos":[6811,6876],"content":"<bpt id=\"p1\">[</bpt>CRecordset::OnSetUpdateOptions<ept id=\"p1\">](#crecordset__onsetupdateoptions)</ept>","source":"[CRecordset::OnSetUpdateOptions](#crecordset__onsetupdateoptions)"},{"content":"Called to set options (used on update) for the specified ODBC statement.","pos":[6877,6949]},{"pos":[6954,6991],"content":"<bpt id=\"p1\">[</bpt>CRecordset::Open<ept id=\"p1\">](#crecordset__open)</ept>","source":"[CRecordset::Open](#crecordset__open)"},{"content":"Opens the recordset by retrieving the table or performing the query that the recordset represents.","pos":[6992,7090]},{"pos":[7095,7150],"content":"<bpt id=\"p1\">[</bpt>CRecordset::RefreshRowset<ept id=\"p1\">](#crecordset__refreshrowset)</ept>","source":"[CRecordset::RefreshRowset](#crecordset__refreshrowset)"},{"content":"Refreshes the data and status of the specified row(s).","pos":[7151,7205]},{"pos":[7210,7253],"content":"<bpt id=\"p1\">[</bpt>CRecordset::Requery<ept id=\"p1\">](#crecordset__requery)</ept>","source":"[CRecordset::Requery](#crecordset__requery)"},{"content":"Runs the recordset's query again to refresh the selected records.","pos":[7254,7319]},{"pos":[7324,7391],"content":"<bpt id=\"p1\">[</bpt>CRecordset::SetAbsolutePosition<ept id=\"p1\">](#crecordset__setabsoluteposition)</ept>","source":"[CRecordset::SetAbsolutePosition](#crecordset__setabsoluteposition)"},{"content":"Positions the recordset on the record corresponding to the specified record number.","pos":[7392,7475]},{"pos":[7480,7531],"content":"<bpt id=\"p1\">[</bpt>CRecordset::SetBookmark<ept id=\"p1\">](#crecordset__setbookmark)</ept>","source":"[CRecordset::SetBookmark](#crecordset__setbookmark)"},{"content":"Positions the recordset on the record specified by the bookmark.","pos":[7532,7596]},{"pos":[7601,7656],"content":"<bpt id=\"p1\">[</bpt>CRecordset::SetFieldDirty<ept id=\"p1\">](#crecordset__setfielddirty)</ept>","source":"[CRecordset::SetFieldDirty](#crecordset__setfielddirty)"},{"content":"Marks the specified field in the current record as changed.","pos":[7657,7716]},{"pos":[7721,7774],"content":"<bpt id=\"p1\">[</bpt>CRecordset::SetFieldNull<ept id=\"p1\">](#crecordset__setfieldnull)</ept>","source":"[CRecordset::SetFieldNull](#crecordset__setfieldnull)"},{"content":"Sets the value of the specified field in the current record to null (having no value).","pos":[7775,7861]},{"pos":[7866,7923],"content":"<bpt id=\"p1\">[</bpt>CRecordset::SetLockingMode<ept id=\"p1\">](#crecordset__setlockingmode)</ept>","source":"[CRecordset::SetLockingMode](#crecordset__setlockingmode)"},{"content":"Sets the locking mode to \"optimistic\" locking (the default) or \"pessimistic\" locking.","pos":[7924,8009]},{"content":"Determines how records are locked for updates.","pos":[8010,8056]},{"pos":[8061,8114],"content":"<bpt id=\"p1\">[</bpt>CRecordset::SetParamNull<ept id=\"p1\">](#crecordset__setparamnull)</ept>","source":"[CRecordset::SetParamNull](#crecordset__setparamnull)"},{"content":"Sets the specified parameter to null (having no value).","pos":[8115,8170]},{"pos":[8175,8250],"content":"<bpt id=\"p1\">[</bpt>CRecordset::SetRowsetCursorPosition<ept id=\"p1\">](#crecordset__setrowsetcursorposition)</ept>","source":"[CRecordset::SetRowsetCursorPosition](#crecordset__setrowsetcursorposition)"},{"content":"Positions the cursor on the specified row within the rowset.","pos":[8251,8311]},{"pos":[8316,8371],"content":"<bpt id=\"p1\">[</bpt>CRecordset::SetRowsetSize<ept id=\"p1\">](#crecordset__setrowsetsize)</ept>","source":"[CRecordset::SetRowsetSize](#crecordset__setrowsetsize)"},{"content":"Specifies the number of records you wish to retrieve during a fetch.","pos":[8372,8440]},{"pos":[8445,8486],"content":"<bpt id=\"p1\">[</bpt>CRecordset::Update<ept id=\"p1\">](#crecordset__update)</ept>","source":"[CRecordset::Update](#crecordset__update)"},{"pos":[8487,8581],"content":"Completes an <ph id=\"ph1\">`AddNew`</ph> or <ph id=\"ph2\">`Edit`</ph> operation by saving the new or edited data on the data source.","source":"Completes an `AddNew` or `Edit` operation by saving the new or edited data on the data source."},{"pos":[8592,8611],"content":"Public Data Members","linkify":"Public Data Members","nodes":[{"content":"Public Data Members","pos":[0,19]}]},{"content":"Name","pos":[8618,8622]},{"content":"Description","pos":[8623,8634]},{"pos":[8672,8715],"content":"<bpt id=\"p1\">[</bpt>CRecordset::m_hstmt<ept id=\"p1\">](#crecordset__m_hstmt)</ept>","source":"[CRecordset::m_hstmt](#crecordset__m_hstmt)"},{"content":"Contains the ODBC statement handle for the recordset.","pos":[8716,8769]},{"content":"Type <ph id=\"ph1\">`HSTMT`</ph>.","pos":[8770,8783],"source":" Type `HSTMT`."},{"pos":[8788,8835],"content":"<bpt id=\"p1\">[</bpt>CRecordset::m_nFields<ept id=\"p1\">](#crecordset__m_nfields)</ept>","source":"[CRecordset::m_nFields](#crecordset__m_nfields)"},{"content":"Contains the number of field data members in the recordset.","pos":[8836,8895]},{"content":"Type <ph id=\"ph1\">`UINT`</ph>.","pos":[8896,8908],"source":" Type `UINT`."},{"pos":[8913,8960],"content":"<bpt id=\"p1\">[</bpt>CRecordset::m_nParams<ept id=\"p1\">](#crecordset__m_nparams)</ept>","source":"[CRecordset::m_nParams](#crecordset__m_nparams)"},{"content":"Contains the number of parameter data members in the recordset.","pos":[8961,9024]},{"content":"Type <ph id=\"ph1\">`UINT`</ph>.","pos":[9025,9037],"source":" Type `UINT`."},{"pos":[9042,9093],"content":"<bpt id=\"p1\">[</bpt>CRecordset::m_pDatabase<ept id=\"p1\">](#crecordset__m_pdatabase)</ept>","source":"[CRecordset::m_pDatabase](#crecordset__m_pdatabase)"},{"pos":[9094,9197],"content":"Contains a pointer to the <ph id=\"ph1\">`CDatabase`</ph> object through which the recordset is connected to a data source.","source":"Contains a pointer to the `CDatabase` object through which the recordset is connected to a data source."},{"pos":[9202,9253],"content":"<bpt id=\"p1\">[</bpt>CRecordset::m_strFilter<ept id=\"p1\">](#crecordset__m_strfilter)</ept>","source":"[CRecordset::m_strFilter](#crecordset__m_strfilter)"},{"content":"Contains a <ph id=\"ph1\">`CString`</ph> that specifies a Structured Query Language (SQL) <ph id=\"ph2\">`WHERE`</ph> clause.","pos":[9254,9339],"source":"Contains a `CString` that specifies a Structured Query Language (SQL) `WHERE` clause."},{"content":"Used as a filter to select only those records that meet certain criteria.","pos":[9340,9413]},{"pos":[9418,9465],"content":"<bpt id=\"p1\">[</bpt>CRecordset::m_strSort<ept id=\"p1\">](#crecordset__m_strsort)</ept>","source":"[CRecordset::m_strSort](#crecordset__m_strsort)"},{"content":"Contains a <ph id=\"ph1\">`CString`</ph> that specifies a SQL <ph id=\"ph2\">`ORDER BY`</ph> clause.","pos":[9466,9526],"source":"Contains a `CString` that specifies a SQL `ORDER BY` clause."},{"content":"Used to control how the records are sorted.","pos":[9527,9570]},{"pos":[9580,9587],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Known as \"recordsets,\" <ph id=\"ph1\">`CRecordset`</ph> objects are typically used in two forms: dynasets and snapshots.","pos":[9591,9691],"source":"Known as \"recordsets,\" `CRecordset` objects are typically used in two forms: dynasets and snapshots."},{"content":"A dynaset stays synchronized with data updates made by other users.","pos":[9692,9759]},{"content":"A snapshot is a static view of the data.","pos":[9760,9800]},{"content":"Each form represents a set of records fixed at the time the recordset is opened, but when you scroll to a record in a dynaset, it reflects changes subsequently made to the record, either by other users or by other recordsets in your application.","pos":[9801,10046]},{"pos":[10054,10383],"content":"[!NOTE]\n If you are working with the Data Access Objects (DAO) classes rather than the Open Database Connectivity (ODBC) classes, use class [CDaoRecordset](../../mfc/reference/cdaorecordset-class.md) instead. For more information, see the article [Overview: Database Programming](../../data/data-access-programming-mfc-atl.md).","leadings":["","> "],"nodes":[{"content":" If you are working with the Data Access Objects (DAO) classes rather than the Open Database Connectivity (ODBC) classes, use class [CDaoRecordset](../../mfc/reference/cdaorecordset-class.md) instead. For more information, see the article [Overview: Database Programming](../../data/data-access-programming-mfc-atl.md).","pos":[8,327],"nodes":[{"content":"If you are working with the Data Access Objects (DAO) classes rather than the Open Database Connectivity (ODBC) classes, use class <bpt id=\"p1\">[</bpt>CDaoRecordset<ept id=\"p1\">](../../mfc/reference/cdaorecordset-class.md)</ept> instead.","pos":[1,200],"source":" If you are working with the Data Access Objects (DAO) classes rather than the Open Database Connectivity (ODBC) classes, use class [CDaoRecordset](../../mfc/reference/cdaorecordset-class.md) instead."},{"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Overview: Database Programming<ept id=\"p1\">](../../data/data-access-programming-mfc-atl.md)</ept>.","pos":[201,319],"source":" For more information, see the article [Overview: Database Programming](../../data/data-access-programming-mfc-atl.md)."}]}]},{"content":"To work with either kind of recordset, you typically derive an application-specific recordset class from <ph id=\"ph1\">`CRecordset`</ph>.","pos":[10390,10508],"source":"To work with either kind of recordset, you typically derive an application-specific recordset class from `CRecordset`."},{"content":"Recordsets select records from a data source, and you can then:","pos":[10509,10572]},{"content":"Scroll through the records.","pos":[10582,10609]},{"content":"Update the records and specify a locking mode.","pos":[10619,10665]},{"content":"Filter the recordset to constrain which records it selects from those available on the data source.","pos":[10675,10774]},{"content":"Sort the recordset.","pos":[10784,10803]},{"content":"Parameterize the recordset to customize its selection with information not known until run time.","pos":[10813,10909]},{"content":"To use your class, open a database and construct a recordset object, passing the constructor a pointer to your <ph id=\"ph1\">`CDatabase`</ph> object.","pos":[10916,11046],"source":"To use your class, open a database and construct a recordset object, passing the constructor a pointer to your `CDatabase` object."},{"content":"Then call the recordset's <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> member function, where you can specify whether the object is a dynaset or a snapshot.","pos":[11047,11167],"source":" Then call the recordset's **Open** member function, where you can specify whether the object is a dynaset or a snapshot."},{"content":"Calling <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> selects data from the data source.","pos":[11168,11219],"source":" Calling **Open** selects data from the data source."},{"content":"After the recordset object is opened, use its member functions and data members to scroll through the records and operate on them.","pos":[11220,11350]},{"content":"The operations available depend on whether the object is a dynaset or a snapshot, whether it is updatable or read-only (this depends on the capability of the Open Database Connectivity (ODBC) data source), and whether you have implemented bulk row fetching.","pos":[11351,11608]},{"content":"To refresh records that may have been changed or added since the <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> call, call the object's <bpt id=\"p2\">**</bpt>Requery<ept id=\"p2\">**</ept> member function.","pos":[11609,11735],"source":" To refresh records that may have been changed or added since the **Open** call, call the object's **Requery** member function."},{"content":"Call the object's <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept> member function and destroy the object when you finish with it.","pos":[11736,11827],"source":" Call the object's **Close** member function and destroy the object when you finish with it."},{"pos":[11834,11993],"content":"In a derived <ph id=\"ph1\">`CRecordset`</ph> class, record field exchange (RFX) or bulk record field exchange (Bulk RFX) is used to support reading and updating of record fields.","source":"In a derived `CRecordset` class, record field exchange (RFX) or bulk record field exchange (Bulk RFX) is used to support reading and updating of record fields."},{"content":"For more information about recordsets and record field exchange, see the articles <bpt id=\"p1\">[</bpt>Overview: Database Programming<ept id=\"p1\">](../../data/data-access-programming-mfc-atl.md)</ept>, <bpt id=\"p2\">[</bpt>Recordset (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-odbc.md)</ept>, <bpt id=\"p3\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p3\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>, and <bpt id=\"p4\">[</bpt>Record Field Exchange (RFX)<ept id=\"p4\">](../../data/odbc/record-field-exchange-rfx.md)</ept>.","pos":[12000,12404],"source":"For more information about recordsets and record field exchange, see the articles [Overview: Database Programming](../../data/data-access-programming-mfc-atl.md), [Recordset (ODBC)](../../data/odbc/recordset-odbc.md), [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md), and [Record Field Exchange (RFX)](../../data/odbc/record-field-exchange-rfx.md)."},{"content":"For a focus on dynasets and snapshots, see the articles <bpt id=\"p1\">[</bpt>Dynaset<ept id=\"p1\">](../../data/odbc/dynaset.md)</ept> and <bpt id=\"p2\">[</bpt>Snapshot<ept id=\"p2\">](../../data/odbc/snapshot.md)</ept>.","pos":[12405,12543],"source":" For a focus on dynasets and snapshots, see the articles [Dynaset](../../data/odbc/dynaset.md) and [Snapshot](../../data/odbc/snapshot.md)."},{"pos":[12552,12573],"content":"Inheritance Hierarchy","linkify":"Inheritance Hierarchy","nodes":[{"content":"Inheritance Hierarchy","pos":[0,21]}]},{"pos":[12577,12624],"content":"<bpt id=\"p1\">[</bpt>CObject<ept id=\"p1\">](../../mfc/reference/cobject-class.md)</ept>","source":"[CObject](../../mfc/reference/cobject-class.md)"},{"pos":[12652,12664],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[12668,12687],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afxdb.h","source":"**Header:** afxdb.h"},{"pos":[12697,12750],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__addnew\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::AddNew","linkify":"<a name=\"crecordset__addnew\"></a>  CRecordset::AddNew","source":"<a name=\"crecordset__addnew\"></a>  CRecordset::AddNew"},{"content":"Prepares for adding a new record to the table.","pos":[12754,12800]},{"pos":[12848,12855],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"You must call the <bpt id=\"p1\">[</bpt>Requery<ept id=\"p1\">](#crecordset__requery)</ept> member function to see the newly added record.","pos":[12859,12955],"source":"You must call the [Requery](#crecordset__requery) member function to see the newly added record."},{"content":"The record's fields are initially Null.","pos":[12956,12995]},{"content":"(In database terminology, Null means \"having no value\" and is not the same as <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> in C++.) To complete the operation, you must call the <bpt id=\"p2\">[</bpt>Update<ept id=\"p2\">](#crecordset__update)</ept> member function.","pos":[12996,13183],"source":" (In database terminology, Null means \"having no value\" and is not the same as **NULL** in C++.) To complete the operation, you must call the [Update](#crecordset__update) member function."},{"content":"<bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> saves your changes to the data source.","pos":[13184,13233],"source":"**Update** saves your changes to the data source."},{"pos":[13241,13696],"content":"[!NOTE]\n If you have implemented bulk row fetching, you cannot call `AddNew`. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" If you have implemented bulk row fetching, you cannot call `AddNew`. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,453],"nodes":[{"content":"If you have implemented bulk row fetching, you cannot call <ph id=\"ph1\">`AddNew`</ph>.","pos":[1,69],"source":" If you have implemented bulk row fetching, you cannot call `AddNew`."},{"content":"This will result in a failed assertion.","pos":[70,109]},{"content":"Although class <ph id=\"ph1\">`CRecordset`</ph> does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept>.","pos":[110,277],"source":" Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[278,445],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"content":"<ph id=\"ph1\">`AddNew`</ph> prepares a new, empty record using the recordset's field data members.","pos":[13703,13782],"source":"`AddNew` prepares a new, empty record using the recordset's field data members."},{"content":"After you call <ph id=\"ph1\">`AddNew`</ph>, set the values you want in the recordset's field data members.","pos":[13783,13870],"source":" After you call `AddNew`, set the values you want in the recordset's field data members."},{"content":"(You do not have to call the <bpt id=\"p1\">[</bpt>Edit<ept id=\"p1\">](#crecordset__edit)</ept> member function for this purpose; use <bpt id=\"p2\">**</bpt>Edit<ept id=\"p2\">**</ept> only for existing records.) When you subsequently call <bpt id=\"p3\">**</bpt>Update<ept id=\"p3\">**</ept>, changed values in the field data members are saved on the data source.","pos":[13871,14110],"source":" (You do not have to call the [Edit](#crecordset__edit) member function for this purpose; use **Edit** only for existing records.) When you subsequently call **Update**, changed values in the field data members are saved on the data source."},{"pos":[14118,14238],"content":"[!CAUTION]\n If you scroll to a new record before you call **Update**, the new record is lost, and no warning is given.","leadings":["","> "],"nodes":[{"content":"If you scroll to a new record before you call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>, the new record is lost, and no warning is given.","pos":[12,118],"source":" If you scroll to a new record before you call **Update**, the new record is lost, and no warning is given."}]},{"content":"If the data source supports transactions, you can make your <ph id=\"ph1\">`AddNew`</ph> call part of a transaction.","pos":[14245,14341],"source":"If the data source supports transactions, you can make your `AddNew` call part of a transaction."},{"content":"For more information about transactions, see class <bpt id=\"p1\">[</bpt>CDatabase<ept id=\"p1\">](../../mfc/reference/cdatabase-class.md)</ept>.","pos":[14342,14445],"source":" For more information about transactions, see class [CDatabase](../../mfc/reference/cdatabase-class.md)."},{"content":"Note that you should call <bpt id=\"p1\">[</bpt>CDatabase::BeginTrans<ept id=\"p1\">](../../mfc/reference/cdatabase-class.md#cdatabase__begintrans)</ept> before calling <ph id=\"ph1\">`AddNew`</ph>.","pos":[14446,14582],"source":" Note that you should call [CDatabase::BeginTrans](../../mfc/reference/cdatabase-class.md#cdatabase__begintrans) before calling `AddNew`."},{"pos":[14590,14767],"content":"[!NOTE]\n For dynasets, new records are added to the recordset as the last record. Added records are not added to snapshots; you must call **Requery** to refresh the recordset.","leadings":["","> "],"nodes":[{"content":" For dynasets, new records are added to the recordset as the last record. Added records are not added to snapshots; you must call **Requery** to refresh the recordset.","pos":[8,175],"nodes":[{"content":"For dynasets, new records are added to the recordset as the last record.","pos":[1,73]},{"content":"Added records are not added to snapshots; you must call <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept> to refresh the recordset.","pos":[74,167],"source":" Added records are not added to snapshots; you must call **Requery** to refresh the recordset."}]}]},{"content":"It is illegal to call <ph id=\"ph1\">`AddNew`</ph> for a recordset whose <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> member function has not been called.","pos":[14774,14872],"source":"It is illegal to call `AddNew` for a recordset whose **Open** member function has not been called."},{"content":"A <ph id=\"ph1\">`CDBException`</ph> is thrown if you call <ph id=\"ph2\">`AddNew`</ph> for a recordset that cannot be appended to.","pos":[14873,14964],"source":" A `CDBException` is thrown if you call `AddNew` for a recordset that cannot be appended to."},{"content":"You can determine whether the recordset is updatable by calling <bpt id=\"p1\">[</bpt>CanAppend<ept id=\"p1\">](#crecordset__canappend)</ept>.","pos":[14965,15065],"source":" You can determine whether the recordset is updatable by calling [CanAppend](#crecordset__canappend)."},{"pos":[15072,15432],"content":"For more information, see the following articles: <bpt id=\"p1\">[</bpt>Recordset: How Recordsets Update Records (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-how-recordsets-update-records-odbc.md)</ept>, <bpt id=\"p2\">[</bpt>Recordset: Adding, Updating, and Deleting Records (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-adding-updating-and-deleting-records-odbc.md)</ept>, and <bpt id=\"p3\">[</bpt>Transaction (ODBC)<ept id=\"p3\">](../../data/odbc/transaction-odbc.md)</ept>.","source":"For more information, see the following articles: [Recordset: How Recordsets Update Records (ODBC)](../../data/odbc/recordset-how-recordsets-update-records-odbc.md), [Recordset: Adding, Updating, and Deleting Records (ODBC)](../../data/odbc/recordset-adding-updating-and-deleting-records-odbc.md), and [Transaction (ODBC)](../../data/odbc/transaction-odbc.md)."},{"pos":[15442,15449],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[15453,15608],"content":"See the article <bpt id=\"p1\">[</bpt>Transaction: Performing a Transaction in a Recordset (ODBC)<ept id=\"p1\">](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md)</ept>.","source":"See the article [Transaction: Performing a Transaction in a Recordset (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md)."},{"pos":[15618,15677],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__canappend\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::CanAppend","linkify":"<a name=\"crecordset__canappend\"></a>  CRecordset::CanAppend","source":"<a name=\"crecordset__canappend\"></a>  CRecordset::CanAppend"},{"content":"Determines whether the previously opened recordset allows you to add new records.","pos":[15681,15762]},{"pos":[15814,15826],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the recordset allows adding new records; otherwise 0.","pos":[15830,15894]},{"content":"<ph id=\"ph1\">`CanAppend`</ph> will return 0 if you opened the recordset as read-only.","pos":[15895,15962],"source":"`CanAppend` will return 0 if you opened the recordset as read-only."},{"pos":[15972,16035],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__canbookmark\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::CanBookmark","linkify":"<a name=\"crecordset__canbookmark\"></a>  CRecordset::CanBookmark","source":"<a name=\"crecordset__canbookmark\"></a>  CRecordset::CanBookmark"},{"content":"Determines whether the recordset allows you to mark records using bookmarks.","pos":[16039,16115]},{"pos":[16169,16181],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the recordset supports bookmarks; otherwise 0.","pos":[16185,16242]},{"pos":[16252,16259],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This function is independent of the <bpt id=\"p1\">**</bpt>CRecordset::useBookmarks<ept id=\"p1\">**</ept> option in the <ph id=\"ph1\">`dwOptions`</ph> parameter of the <bpt id=\"p2\">[</bpt>Open<ept id=\"p2\">](#crecordset__open)</ept> member function.","pos":[16263,16413],"source":"This function is independent of the **CRecordset::useBookmarks** option in the `dwOptions` parameter of the [Open](#crecordset__open) member function."},{"content":"<ph id=\"ph1\">`CanBookmark`</ph> indicates whether the given ODBC driver and cursor type support bookmarks.","pos":[16414,16502],"source":"`CanBookmark` indicates whether the given ODBC driver and cursor type support bookmarks."},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::useBookmarks<ept id=\"p1\">**</ept> indicates whether bookmarks will be available, provided they are supported.","pos":[16503,16607],"source":"**CRecordset::useBookmarks** indicates whether bookmarks will be available, provided they are supported."},{"pos":[16615,16681],"content":"[!NOTE]\n Bookmarks are not supported on forward-only recordsets.","leadings":["","> "],"nodes":[{"content":"Bookmarks are not supported on forward-only recordsets.","pos":[9,64]}]},{"pos":[16688,16968],"content":"For more information about bookmarks and recordset navigation, see the articles <bpt id=\"p1\">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Scrolling (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-scrolling-odbc.md)</ept>.","source":"For more information about bookmarks and recordset navigation, see the articles [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md) and [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md)."},{"pos":[16978,17031],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__cancel\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::Cancel","linkify":"<a name=\"crecordset__cancel\"></a>  CRecordset::Cancel","source":"<a name=\"crecordset__cancel\"></a>  CRecordset::Cancel"},{"content":"Requests that the data source cancel either an asynchronous operation in progress or a process from a second thread.","pos":[17035,17151]},{"pos":[17191,17198],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Note that the MFC ODBC classes no longer use asynchronous processing; to perform an asychronous operation, you must directly call the ODBC API function <bpt id=\"p1\">**</bpt>SQLSetConnectOption<ept id=\"p1\">**</ept>.","pos":[17202,17378],"source":"Note that the MFC ODBC classes no longer use asynchronous processing; to perform an asychronous operation, you must directly call the ODBC API function **SQLSetConnectOption**."},{"content":"For more information, see the topic \"Executing Functions Asynchronously\" in the <bpt id=\"p1\">*</bpt>ODBC SDK Programmer's Guide<ept id=\"p1\">*</ept>.","pos":[17379,17489],"source":" For more information, see the topic \"Executing Functions Asynchronously\" in the *ODBC SDK Programmer's Guide*."},{"pos":[17499,17564],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__cancelupdate\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::CancelUpdate","linkify":"<a name=\"crecordset__cancelupdate\"></a>  CRecordset::CancelUpdate","source":"<a name=\"crecordset__cancelupdate\"></a>  CRecordset::CancelUpdate"},{"pos":[17568,17727],"content":"Cancels any pending updates, caused by an <bpt id=\"p1\">[</bpt>Edit<ept id=\"p1\">](#crecordset__edit)</ept> or <bpt id=\"p2\">[</bpt>AddNew<ept id=\"p2\">](#crecordset__addnew)</ept> operation, before <bpt id=\"p3\">[</bpt>Update<ept id=\"p3\">](#crecordset__update)</ept> is called.","source":"Cancels any pending updates, caused by an [Edit](#crecordset__edit) or [AddNew](#crecordset__addnew) operation, before [Update](#crecordset__update) is called."},{"pos":[17773,17780],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[17788,18122],"content":"[!NOTE]\n This member function is not applicable on recordsets that are using bulk row fetching, since such recordsets cannot call **Edit**, `AddNew`, or **Update**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" This member function is not applicable on recordsets that are using bulk row fetching, since such recordsets cannot call **Edit**, `AddNew`, or **Update**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,332],"nodes":[{"content":"This member function is not applicable on recordsets that are using bulk row fetching, since such recordsets cannot call <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`AddNew`</ph>, or <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept>.","pos":[1,156],"source":" This member function is not applicable on recordsets that are using bulk row fetching, since such recordsets cannot call **Edit**, `AddNew`, or **Update**."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[157,324],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"content":"If automatic dirty field checking is enabled, <ph id=\"ph1\">`CancelUpdate`</ph> will restore the member variables to the values they had before <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> or <ph id=\"ph2\">`AddNew`</ph> was called; otherwise, any value changes will remain.","pos":[18129,18328],"source":"If automatic dirty field checking is enabled, `CancelUpdate` will restore the member variables to the values they had before **Edit** or `AddNew` was called; otherwise, any value changes will remain."},{"content":"By default, automatic field checking is enabled when the recordset is opened.","pos":[18329,18406]},{"content":"To disable it, you must specify the <bpt id=\"p1\">**</bpt>CRecordset::noDirtyFieldCheck<ept id=\"p1\">**</ept> in the <ph id=\"ph1\">`dwOptions`</ph> parameter of the <bpt id=\"p2\">[</bpt>Open<ept id=\"p2\">](#crecordset__open)</ept> member function.","pos":[18407,18555],"source":" To disable it, you must specify the **CRecordset::noDirtyFieldCheck** in the `dwOptions` parameter of the [Open](#crecordset__open) member function."},{"pos":[18562,18751],"content":"For more information about updating data, see the article <bpt id=\"p1\">[</bpt>Recordset: Adding, Updating, and Deleting Records (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-adding-updating-and-deleting-records-odbc.md)</ept>.","source":"For more information about updating data, see the article [Recordset: Adding, Updating, and Deleting Records (ODBC)](../../data/odbc/recordset-adding-updating-and-deleting-records-odbc.md)."},{"pos":[18761,18822],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__canrestart\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::CanRestart","linkify":"<a name=\"crecordset__canrestart\"></a>  CRecordset::CanRestart","source":"<a name=\"crecordset__canrestart\"></a>  CRecordset::CanRestart"},{"pos":[18826,18955],"content":"Determines whether the recordset allows restarting its query (to refresh its records) by calling the <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept> member function.","source":"Determines whether the recordset allows restarting its query (to refresh its records) by calling the **Requery** member function."},{"pos":[19008,19020],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if requery is allowed; otherwise 0.","pos":[19024,19067]},{"pos":[19077,19136],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__canscroll\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::CanScroll","linkify":"<a name=\"crecordset__canscroll\"></a>  CRecordset::CanScroll","source":"<a name=\"crecordset__canscroll\"></a>  CRecordset::CanScroll"},{"content":"Determines whether the recordset allows scrolling.","pos":[19140,19190]},{"pos":[19242,19254],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the recordset allows scrolling; otherwise 0.","pos":[19258,19313]},{"pos":[19323,19330],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[19334,19463],"content":"For more information about scrolling, see the article <bpt id=\"p1\">[</bpt>Recordset: Scrolling (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-scrolling-odbc.md)</ept>.","source":"For more information about scrolling, see the article [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md)."},{"pos":[19473,19536],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__cantransact\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::CanTransact","linkify":"<a name=\"crecordset__cantransact\"></a>  CRecordset::CanTransact","source":"<a name=\"crecordset__cantransact\"></a>  CRecordset::CanTransact"},{"content":"Determines whether the recordset allows transactions.","pos":[19540,19593]},{"pos":[19647,19659],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the recordset allows transactions; otherwise 0.","pos":[19663,19721]},{"pos":[19731,19738],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[19742,19838],"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Transaction (ODBC)<ept id=\"p1\">](../../data/odbc/transaction-odbc.md)</ept>.","source":"For more information, see the article [Transaction (ODBC)](../../data/odbc/transaction-odbc.md)."},{"pos":[19848,19907],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__canupdate\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::CanUpdate","linkify":"<a name=\"crecordset__canupdate\"></a>  CRecordset::CanUpdate","source":"<a name=\"crecordset__canupdate\"></a>  CRecordset::CanUpdate"},{"content":"Determines whether the recordset can be updated.","pos":[19911,19959]},{"pos":[20011,20023],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the recordset can be updated; otherwise 0.","pos":[20027,20080]},{"pos":[20090,20097],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[20101,20279],"content":"A recordset might be read-only if the underlying data source is read-only or if you specified <bpt id=\"p1\">**</bpt>CRecordset::readOnly<ept id=\"p1\">**</ept> in the <ph id=\"ph1\">`dwOptions`</ph> parameter when you opened the recordset.","source":"A recordset might be read-only if the underlying data source is read-only or if you specified **CRecordset::readOnly** in the `dwOptions` parameter when you opened the recordset."},{"pos":[20289,20362],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__checkrowseterror\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::CheckRowsetError","linkify":"<a name=\"crecordset__checkrowseterror\"></a>  CRecordset::CheckRowsetError","source":"<a name=\"crecordset__checkrowseterror\"></a>  CRecordset::CheckRowsetError"},{"content":"Called to handle errors generated during record fetching.","pos":[20366,20423]},{"pos":[20497,20507],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An ODBC API function return code.","pos":[20525,20558]},{"content":"For details, see Remarks.","pos":[20559,20584]},{"pos":[20594,20601],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This virtual member function handles errors that occur when records are fetched, and is useful during bulk row fetching.","pos":[20605,20725]},{"content":"You may want to consider overriding <ph id=\"ph1\">`CheckRowsetError`</ph> to implement your own error handling.","pos":[20726,20818],"source":" You may want to consider overriding `CheckRowsetError` to implement your own error handling."},{"content":"<ph id=\"ph1\">`CheckRowsetError`</ph> is called automatically in a cursor navigation operation, such as <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Requery<ept id=\"p2\">**</ept>, or any <bpt id=\"p3\">**</bpt>Move<ept id=\"p3\">**</ept> operation.","pos":[20825,20959],"source":"`CheckRowsetError` is called automatically in a cursor navigation operation, such as **Open**, **Requery**, or any **Move** operation."},{"content":"It is passed the return value of the ODBC API function <bpt id=\"p1\">**</bpt>SQLExtendedFetch<ept id=\"p1\">**</ept>.","pos":[20960,21036],"source":" It is passed the return value of the ODBC API function **SQLExtendedFetch**."},{"content":"The following table lists the possible values for the <ph id=\"ph1\">`nRetCode`</ph> parameter.","pos":[21037,21112],"source":" The following table lists the possible values for the `nRetCode` parameter."},{"content":"nRetCode","pos":[21119,21127]},{"content":"Description","pos":[21128,21139]},{"pos":[21181,21196],"content":"<bpt id=\"p1\">**</bpt>SQL_SUCCESS<ept id=\"p1\">**</ept>","source":"**SQL_SUCCESS**"},{"content":"Function completed successfully; no additional information is available.","pos":[21197,21269]},{"pos":[21274,21299],"content":"<bpt id=\"p1\">**</bpt>SQL_SUCCESS_WITH_INFO<ept id=\"p1\">**</ept>","source":"**SQL_SUCCESS_WITH_INFO**"},{"content":"Function completed successfully, possibly with a nonfatal error.","pos":[21300,21364]},{"content":"Additional information can be obtained by calling <bpt id=\"p1\">**</bpt>SQLError<ept id=\"p1\">**</ept>.","pos":[21365,21428],"source":" Additional information can be obtained by calling **SQLError**."},{"pos":[21433,21454],"content":"<bpt id=\"p1\">**</bpt>SQL_NO_DATA_FOUND<ept id=\"p1\">**</ept>","source":"**SQL_NO_DATA_FOUND**"},{"content":"All rows from the result set have been fetched.","pos":[21455,21502]},{"pos":[21507,21520],"content":"<bpt id=\"p1\">**</bpt>SQL_ERROR<ept id=\"p1\">**</ept>","source":"**SQL_ERROR**"},{"content":"Function failed.","pos":[21521,21537]},{"content":"Additional information can be obtained by calling <bpt id=\"p1\">**</bpt>SQLError<ept id=\"p1\">**</ept>.","pos":[21538,21601],"source":" Additional information can be obtained by calling **SQLError**."},{"pos":[21606,21628],"content":"<bpt id=\"p1\">**</bpt>SQL_INVALID_HANDLE<ept id=\"p1\">**</ept>","source":"**SQL_INVALID_HANDLE**"},{"content":"Function failed due to an invalid environment handle, connection handle, or statement handle.","pos":[21629,21722]},{"content":"This indicates a programming error.","pos":[21723,21758]},{"content":"No additional information is available from <bpt id=\"p1\">**</bpt>SQLError<ept id=\"p1\">**</ept>.","pos":[21759,21816],"source":" No additional information is available from **SQLError**."},{"content":"A function that was started asynchronously is still executing.","pos":[21843,21905]},{"content":"Note that by default, MFC will never pass this value to <ph id=\"ph1\">`CheckRowsetError`</ph>; MFC will continue calling <bpt id=\"p1\">**</bpt>SQLExtendedFetch<ept id=\"p1\">**</ept> until it no longer returns <ph id=\"ph2\">`SQL_STILL_EXECUTING`</ph>.","pos":[21906,22078],"source":" Note that by default, MFC will never pass this value to `CheckRowsetError`; MFC will continue calling **SQLExtendedFetch** until it no longer returns `SQL_STILL_EXECUTING`."},{"content":"For more information about <bpt id=\"p1\">**</bpt>SQLError<ept id=\"p1\">**</ept>, see the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[22086,22187],"source":"For more information about **SQLError**, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[22188,22355],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[22365,22416],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__close\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::Close","linkify":"<a name=\"crecordset__close\"></a>  CRecordset::Close","source":"<a name=\"crecordset__close\"></a>  CRecordset::Close"},{"content":"Closes the recordset.","pos":[22420,22441]},{"pos":[22488,22495],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The ODBC <bpt id=\"p1\">**</bpt>HSTMT<ept id=\"p1\">**</ept> and all memory the framework allocated for the recordset are deallocated.","pos":[22499,22591],"source":"The ODBC **HSTMT** and all memory the framework allocated for the recordset are deallocated."},{"content":"Usually after calling <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept>, you delete the C++ recordset object if it was allocated with <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept>.","pos":[22592,22694],"source":" Usually after calling **Close**, you delete the C++ recordset object if it was allocated with **new**."},{"content":"You can call <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> again after calling <bpt id=\"p2\">**</bpt>Close<ept id=\"p2\">**</ept>.","pos":[22701,22753],"source":"You can call **Open** again after calling **Close**."},{"content":"This lets you reuse the recordset object.","pos":[22754,22795]},{"content":"The alternative is to call <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept>.","pos":[22796,22835],"source":" The alternative is to call **Requery**."},{"pos":[22845,22852],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[22856,22937],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#17<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_1.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#17](../../mfc/codesnippet/cpp/crecordset-class_1.cpp)]"},{"pos":[22947,23008],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__crecordset\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::CRecordset","linkify":"<a name=\"crecordset__crecordset\"></a>  CRecordset::CRecordset","source":"<a name=\"crecordset__crecordset\"></a>  CRecordset::CRecordset"},{"pos":[23012,23045],"content":"Constructs a <ph id=\"ph1\">`CRecordset`</ph> object.","source":"Constructs a `CRecordset` object."},{"pos":[23111,23121],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Contains a pointer to a <ph id=\"ph1\">`CDatabase`</ph> object or the value <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[23140,23205],"source":" Contains a pointer to a `CDatabase` object or the value **NULL**."},{"content":"If not <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> and the <ph id=\"ph1\">`CDatabase`</ph> object's <bpt id=\"p2\">**</bpt>Open<ept id=\"p2\">**</ept> member function has not been called to connect it to the data source, the recordset attempts to open it for you during its own <bpt id=\"p3\">**</bpt>Open<ept id=\"p3\">**</ept> call.","pos":[23206,23401],"source":" If not **NULL** and the `CDatabase` object's **Open** member function has not been called to connect it to the data source, the recordset attempts to open it for you during its own **Open** call."},{"content":"If you pass <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, a <ph id=\"ph1\">`CDatabase`</ph> object is constructed and connected for you using the data source information you specified when you derived your recordset class with ClassWizard.","pos":[23402,23585],"source":" If you pass **NULL**, a `CDatabase` object is constructed and connected for you using the data source information you specified when you derived your recordset class with ClassWizard."},{"pos":[23595,23602],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"You can either use <ph id=\"ph1\">`CRecordset`</ph> directly or derive an application-specific class from <ph id=\"ph2\">`CRecordset`</ph>.","pos":[23606,23705],"source":"You can either use `CRecordset` directly or derive an application-specific class from `CRecordset`."},{"content":"You can use ClassWizard to derive your recordset classes.","pos":[23706,23763]},{"pos":[23771,23969],"content":"[!NOTE]\n A derived class *must* supply its own constructor. In the constructor of your derived class, call the constructor `CRecordset::CRecordset`, passing the appropriate parameters along to it.","leadings":["","> "],"nodes":[{"content":" A derived class *must* supply its own constructor. In the constructor of your derived class, call the constructor `CRecordset::CRecordset`, passing the appropriate parameters along to it.","pos":[8,196],"nodes":[{"content":"A derived class <bpt id=\"p1\">*</bpt>must<ept id=\"p1\">*</ept> supply its own constructor.","pos":[1,51],"source":" A derived class *must* supply its own constructor."},{"content":"In the constructor of your derived class, call the constructor <ph id=\"ph1\">`CRecordset::CRecordset`</ph>, passing the appropriate parameters along to it.","pos":[52,188],"source":" In the constructor of your derived class, call the constructor `CRecordset::CRecordset`, passing the appropriate parameters along to it."}]}]},{"content":"Pass <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> to your recordset constructor to have a <ph id=\"ph1\">`CDatabase`</ph> object constructed and connected for you automatically.","pos":[23976,24097],"source":"Pass **NULL** to your recordset constructor to have a `CDatabase` object constructed and connected for you automatically."},{"content":"This is a useful shorthand that does not require you to construct and connect a <ph id=\"ph1\">`CDatabase`</ph> object prior to constructing your recordset.","pos":[24098,24234],"source":" This is a useful shorthand that does not require you to construct and connect a `CDatabase` object prior to constructing your recordset."},{"pos":[24244,24251],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[24255,24408],"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Recordset: Declaring a Class for a Table (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-declaring-a-class-for-a-table-odbc.md)</ept>.","source":"For more information, see the article [Recordset: Declaring a Class for a Table (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-table-odbc.md)."},{"pos":[24418,24471],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__delete\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::Delete","linkify":"<a name=\"crecordset__delete\"></a>  CRecordset::Delete","source":"<a name=\"crecordset__delete\"></a>  CRecordset::Delete"},{"content":"Deletes the current record.","pos":[24475,24502]},{"pos":[24550,24557],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"After a successful deletion, the recordset's field data members are set to a Null value, and you must explicitly call one of the <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> functions in order to move off the deleted record.","pos":[24561,24749],"source":"After a successful deletion, the recordset's field data members are set to a Null value, and you must explicitly call one of the **Move** functions in order to move off the deleted record."},{"content":"Once you move off the deleted record, it is not possible to return to it.","pos":[24750,24823]},{"content":"If the data source supports transactions, you can make the <bpt id=\"p1\">**</bpt>Delete<ept id=\"p1\">**</ept> call part of a transaction.","pos":[24824,24921],"source":" If the data source supports transactions, you can make the **Delete** call part of a transaction."},{"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Transaction (ODBC)<ept id=\"p1\">](../../data/odbc/transaction-odbc.md)</ept>.","pos":[24922,25018],"source":" For more information, see the article [Transaction (ODBC)](../../data/odbc/transaction-odbc.md)."},{"pos":[25026,25483],"content":"[!NOTE]\n If you have implemented bulk row fetching, you cannot call **Delete**. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" If you have implemented bulk row fetching, you cannot call **Delete**. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,455],"nodes":[{"content":"If you have implemented bulk row fetching, you cannot call <bpt id=\"p1\">**</bpt>Delete<ept id=\"p1\">**</ept>.","pos":[1,71],"source":" If you have implemented bulk row fetching, you cannot call **Delete**."},{"content":"This will result in a failed assertion.","pos":[72,111]},{"content":"Although class <ph id=\"ph1\">`CRecordset`</ph> does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept>.","pos":[112,279],"source":" Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[280,447],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"pos":[25491,25831],"content":"[!CAUTION]\n The recordset must be updatable and there must be a valid record current in the recordset when you call **Delete**; otherwise, an error occurs. For example, if you delete a record but do not scroll to a new record before you call **Delete** again, **Delete** throws a [CDBException](../../mfc/reference/cdbexception-class.md).","leadings":["","> "],"nodes":[{"content":" The recordset must be updatable and there must be a valid record current in the recordset when you call **Delete**; otherwise, an error occurs. For example, if you delete a record but do not scroll to a new record before you call **Delete** again, **Delete** throws a [CDBException](../../mfc/reference/cdbexception-class.md).","pos":[11,338],"nodes":[{"content":"The recordset must be updatable and there must be a valid record current in the recordset when you call <bpt id=\"p1\">**</bpt>Delete<ept id=\"p1\">**</ept>; otherwise, an error occurs.","pos":[1,144],"source":" The recordset must be updatable and there must be a valid record current in the recordset when you call **Delete**; otherwise, an error occurs."},{"content":"For example, if you delete a record but do not scroll to a new record before you call <bpt id=\"p1\">**</bpt>Delete<ept id=\"p1\">**</ept> again, <bpt id=\"p2\">**</bpt>Delete<ept id=\"p2\">**</ept> throws a <bpt id=\"p3\">[</bpt>CDBException<ept id=\"p3\">](../../mfc/reference/cdbexception-class.md)</ept>.","pos":[145,327],"source":" For example, if you delete a record but do not scroll to a new record before you call **Delete** again, **Delete** throws a [CDBException](../../mfc/reference/cdbexception-class.md)."}]}]},{"content":"Unlike <bpt id=\"p1\">[</bpt>AddNew<ept id=\"p1\">](#crecordset__addnew)</ept> and <bpt id=\"p2\">[</bpt>Edit<ept id=\"p2\">](#crecordset__edit)</ept>, a call to <bpt id=\"p3\">**</bpt>Delete<ept id=\"p3\">**</ept> is not followed by a call to <bpt id=\"p4\">[</bpt>Update<ept id=\"p4\">](#crecordset__update)</ept>.","pos":[25838,25986],"source":"Unlike [AddNew](#crecordset__addnew) and [Edit](#crecordset__edit), a call to **Delete** is not followed by a call to [Update](#crecordset__update)."},{"content":"If a <bpt id=\"p1\">**</bpt>Delete<ept id=\"p1\">**</ept> call fails, the field data members are left unchanged.","pos":[25987,26057],"source":" If a **Delete** call fails, the field data members are left unchanged."},{"pos":[26067,26074],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example shows a recordset created on the frame of a function.","pos":[26078,26144]},{"content":"The example assumes the existence of <ph id=\"ph1\">`m_dbCust`</ph>, a member variable of type <ph id=\"ph2\">`CDatabase`</ph> already connected to the data source.","pos":[26145,26269],"source":" The example assumes the existence of `m_dbCust`, a member variable of type `CDatabase` already connected to the data source."},{"pos":[26276,26357],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#18<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_2.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#18](../../mfc/codesnippet/cpp/crecordset-class_2.cpp)]"},{"pos":[26367,26446],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__dobulkfieldexchange\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::DoBulkFieldExchange","linkify":"<a name=\"crecordset__dobulkfieldexchange\"></a>  CRecordset::DoBulkFieldExchange","source":"<a name=\"crecordset__dobulkfieldexchange\"></a>  CRecordset::DoBulkFieldExchange"},{"content":"Called to exchange bulk rows of data from the data source to the recordset.","pos":[26450,26525]},{"content":"Implements bulk record field exchange (Bulk RFX).","pos":[26526,26575]},{"pos":[26655,26665],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>CFieldExchange<ept id=\"p1\">](../../mfc/reference/cfieldexchange-class.md)</ept> object.","pos":[26678,26762],"source":" A pointer to a [CFieldExchange](../../mfc/reference/cfieldexchange-class.md) object."},{"content":"The framework will already have set up this object to specify a context for the field exchange operation.","pos":[26763,26868]},{"pos":[26878,26885],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"When bulk row fetching is implemented, the framework calls this member function to automatically transfer data from the data source to your recordset object.","pos":[26889,27046]},{"content":"<ph id=\"ph1\">`DoBulkFieldExchange`</ph> also binds your parameter data members, if any, to parameter placeholders in the SQL statement string for the recordset's selection.","pos":[27047,27201],"source":"`DoBulkFieldExchange` also binds your parameter data members, if any, to parameter placeholders in the SQL statement string for the recordset's selection."},{"content":"If bulk row fetching is not implemented, the framework calls <bpt id=\"p1\">[</bpt>DoFieldExchange<ept id=\"p1\">](#crecordset__dofieldexchange)</ept>.","pos":[27208,27317],"source":"If bulk row fetching is not implemented, the framework calls [DoFieldExchange](#crecordset__dofieldexchange)."},{"content":"To implement bulk row fetching, you must specify the <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph> option of the <ph id=\"ph2\">`dwOptions`</ph> parameter in the <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](#crecordset__open)</ept> member function.","pos":[27318,27487],"source":" To implement bulk row fetching, you must specify the `CRecordset::useMultiRowFetch` option of the `dwOptions` parameter in the [Open](#crecordset__open) member function."},{"pos":[27495,27759],"content":"[!NOTE]\n`DoBulkFieldExchange` is available only if you are using a class derived from `CRecordset`. If you have created a recordset object directly from `CRecordset`, you must call the [GetFieldValue](#crecordset__getfieldvalue) member function to retrieve data.","leadings":["","> "],"nodes":[{"content":"`DoBulkFieldExchange` is available only if you are using a class derived from `CRecordset`. If you have created a recordset object directly from `CRecordset`, you must call the [GetFieldValue](#crecordset__getfieldvalue) member function to retrieve data.","pos":[8,262],"nodes":[{"content":"<ph id=\"ph1\">`DoBulkFieldExchange`</ph> is available only if you are using a class derived from <ph id=\"ph2\">`CRecordset`</ph>.","pos":[0,91],"source":"`DoBulkFieldExchange` is available only if you are using a class derived from `CRecordset`."},{"content":"If you have created a recordset object directly from <ph id=\"ph1\">`CRecordset`</ph>, you must call the <bpt id=\"p1\">[</bpt>GetFieldValue<ept id=\"p1\">](#crecordset__getfieldvalue)</ept> member function to retrieve data.","pos":[92,254],"source":" If you have created a recordset object directly from `CRecordset`, you must call the [GetFieldValue](#crecordset__getfieldvalue) member function to retrieve data."}]}]},{"content":"Bulk record field exchange (Bulk RFX) is similar to record field exchange (RFX).","pos":[27766,27846]},{"content":"Data is automatically transferred from the data source to the recordset object.","pos":[27847,27926]},{"content":"However, you cannot call <ph id=\"ph1\">`AddNew`</ph>, <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Delete<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>Update<ept id=\"p3\">**</ept> to transfer changes back to the data source.","pos":[27927,28042],"source":" However, you cannot call `AddNew`, **Edit**, **Delete**, or **Update** to transfer changes back to the data source."},{"content":"Class <ph id=\"ph1\">`CRecordset`</ph> currently does not provide a mechanism for updating bulk rows of data; however, you can write your own functions by using the ODBC API function <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept>.","pos":[28043,28220],"source":" Class `CRecordset` currently does not provide a mechanism for updating bulk rows of data; however, you can write your own functions by using the ODBC API function **SQLSetPos**."},{"content":"Note that ClassWizard does not support bulk record field exchange; therefore, you must override <ph id=\"ph1\">`DoBulkFieldExchange`</ph> manually by writing calls to the Bulk RFX functions.","pos":[28227,28397],"source":"Note that ClassWizard does not support bulk record field exchange; therefore, you must override `DoBulkFieldExchange` manually by writing calls to the Bulk RFX functions."},{"content":"For more information about these functions, see the topic <bpt id=\"p1\">[</bpt>Record Field Exchange Functions<ept id=\"p1\">](../../mfc/reference/record-field-exchange-functions.md)</ept>.","pos":[28398,28546],"source":" For more information about these functions, see the topic [Record Field Exchange Functions](../../mfc/reference/record-field-exchange-functions.md)."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[28553,28720],"source":"For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"content":"For related information, see the article <bpt id=\"p1\">[</bpt>Record Field Exchange (RFX)<ept id=\"p1\">](../../data/odbc/record-field-exchange-rfx.md)</ept>.","pos":[28721,28838],"source":" For related information, see the article [Record Field Exchange (RFX)](../../data/odbc/record-field-exchange-rfx.md)."},{"pos":[28848,28919],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__dofieldexchange\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::DoFieldExchange","linkify":"<a name=\"crecordset__dofieldexchange\"></a>  CRecordset::DoFieldExchange","source":"<a name=\"crecordset__dofieldexchange\"></a>  CRecordset::DoFieldExchange"},{"content":"Called to exchange data (in both directions) between the field data members of the recordset and the corresponding record on the data source.","pos":[28923,29064]},{"content":"Implements record field exchange (RFX).","pos":[29065,29104]},{"pos":[29180,29190],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A pointer to a <bpt id=\"p1\">[</bpt>CFieldExchange<ept id=\"p1\">](../../mfc/reference/cfieldexchange-class.md)</ept> object.","pos":[29203,29287],"source":" A pointer to a [CFieldExchange](../../mfc/reference/cfieldexchange-class.md) object."},{"content":"The framework will already have set up this object to specify a context for the field exchange operation.","pos":[29288,29393]},{"pos":[29403,29410],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"When bulk row fetching is not implemented, the framework calls this member function to automatically exchange data between the field data members of your recordset object and the corresponding columns of the current record on the data source.","pos":[29414,29656]},{"content":"<ph id=\"ph1\">`DoFieldExchange`</ph> also binds your parameter data members, if any, to parameter placeholders in the SQL statement string for the recordset's selection.","pos":[29657,29807],"source":"`DoFieldExchange` also binds your parameter data members, if any, to parameter placeholders in the SQL statement string for the recordset's selection."},{"content":"If bulk row fetching is implemented, the framework calls <bpt id=\"p1\">[</bpt>DoBulkFieldExchange<ept id=\"p1\">](#crecordset__dobulkfieldexchange)</ept>.","pos":[29814,29927],"source":"If bulk row fetching is implemented, the framework calls [DoBulkFieldExchange](#crecordset__dobulkfieldexchange)."},{"content":"To implement bulk row fetching, you must specify the <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph> option of the <ph id=\"ph2\">`dwOptions`</ph> parameter in the <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](#crecordset__open)</ept> member function.","pos":[29928,30097],"source":" To implement bulk row fetching, you must specify the `CRecordset::useMultiRowFetch` option of the `dwOptions` parameter in the [Open](#crecordset__open) member function."},{"pos":[30105,30365],"content":"[!NOTE]\n`DoFieldExchange` is available only if you are using a class derived from `CRecordset`. If you have created a recordset object directly from `CRecordset`, you must call the [GetFieldValue](#crecordset__getfieldvalue) member function to retrieve data.","leadings":["","> "],"nodes":[{"content":"`DoFieldExchange` is available only if you are using a class derived from `CRecordset`. If you have created a recordset object directly from `CRecordset`, you must call the [GetFieldValue](#crecordset__getfieldvalue) member function to retrieve data.","pos":[8,258],"nodes":[{"content":"<ph id=\"ph1\">`DoFieldExchange`</ph> is available only if you are using a class derived from <ph id=\"ph2\">`CRecordset`</ph>.","pos":[0,87],"source":"`DoFieldExchange` is available only if you are using a class derived from `CRecordset`."},{"content":"If you have created a recordset object directly from <ph id=\"ph1\">`CRecordset`</ph>, you must call the <bpt id=\"p1\">[</bpt>GetFieldValue<ept id=\"p1\">](#crecordset__getfieldvalue)</ept> member function to retrieve data.","pos":[88,250],"source":" If you have created a recordset object directly from `CRecordset`, you must call the [GetFieldValue](#crecordset__getfieldvalue) member function to retrieve data."}]}]},{"content":"The exchange of field data, called record field exchange (RFX), works in both directions: from the recordset object's field data members to the fields of the record on the data source, and from the record on the data source to the recordset object.","pos":[30372,30620]},{"content":"The only action you must normally take to implement <ph id=\"ph1\">`DoFieldExchange`</ph> for your derived recordset class is to create the class with ClassWizard and specify the names and data types of the field data members.","pos":[30627,30833],"source":"The only action you must normally take to implement `DoFieldExchange` for your derived recordset class is to create the class with ClassWizard and specify the names and data types of the field data members."},{"content":"You might also add code to what ClassWizard writes to specify parameter data members or to deal with any columns you bind dynamically.","pos":[30834,30968]},{"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Recordset: Dynamically Binding Data Columns (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md)</ept>.","pos":[30969,31128],"source":" For more information, see the article [Recordset: Dynamically Binding Data Columns (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md)."},{"pos":[31135,31297],"content":"When you declare your derived recordset class with ClassWizard, the wizard writes an override of <ph id=\"ph1\">`DoFieldExchange`</ph> for you, which resembles the following example:","source":"When you declare your derived recordset class with ClassWizard, the wizard writes an override of `DoFieldExchange` for you, which resembles the following example:"},{"pos":[31304,31385],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#19<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_3.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#19](../../mfc/codesnippet/cpp/crecordset-class_3.cpp)]"},{"pos":[31392,31542],"content":"For more information about the RFX functions, see the topic <bpt id=\"p1\">[</bpt>Record Field Exchange Functions<ept id=\"p1\">](../../mfc/reference/record-field-exchange-functions.md)</ept>.","source":"For more information about the RFX functions, see the topic [Record Field Exchange Functions](../../mfc/reference/record-field-exchange-functions.md)."},{"content":"For further examples and details about <ph id=\"ph1\">`DoFieldExchange`</ph>, see the article <bpt id=\"p1\">[</bpt>Record Field Exchange: How RFX Works<ept id=\"p1\">](../../data/odbc/record-field-exchange-how-rfx-works.md)</ept>.","pos":[31549,31718],"source":"For further examples and details about `DoFieldExchange`, see the article [Record Field Exchange: How RFX Works](../../data/odbc/record-field-exchange-how-rfx-works.md)."},{"content":"For general information about RFX, see the article <bpt id=\"p1\">[</bpt>Record Field Exchange<ept id=\"p1\">](../../data/odbc/record-field-exchange-rfx.md)</ept>.","pos":[31719,31840],"source":" For general information about RFX, see the article [Record Field Exchange](../../data/odbc/record-field-exchange-rfx.md)."},{"pos":[31850,31899],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__edit\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::Edit","linkify":"<a name=\"crecordset__edit\"></a>  CRecordset::Edit","source":"<a name=\"crecordset__edit\"></a>  CRecordset::Edit"},{"content":"Allows changes to the current record.","pos":[31903,31940]},{"pos":[31986,31993],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"After you call <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, you can change the field data members by directly resetting their values.","pos":[31997,32095],"source":"After you call **Edit**, you can change the field data members by directly resetting their values."},{"content":"The operation is completed when you subsequently call the <bpt id=\"p1\">[</bpt>Update<ept id=\"p1\">](#crecordset__update)</ept> member function to save your changes on the data source.","pos":[32096,32240],"source":" The operation is completed when you subsequently call the [Update](#crecordset__update) member function to save your changes on the data source."},{"pos":[32248,32703],"content":"[!NOTE]\n If you have implemented bulk row fetching, you cannot call **Edit**. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" If you have implemented bulk row fetching, you cannot call **Edit**. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,453],"nodes":[{"content":"If you have implemented bulk row fetching, you cannot call <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>.","pos":[1,69],"source":" If you have implemented bulk row fetching, you cannot call **Edit**."},{"content":"This will result in a failed assertion.","pos":[70,109]},{"content":"Although class <ph id=\"ph1\">`CRecordset`</ph> does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept>.","pos":[110,277],"source":" Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[278,445],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"content":"<bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> saves the values of the recordset's data members.","pos":[32710,32768],"source":"**Edit** saves the values of the recordset's data members."},{"content":"If you call <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, make changes, then call <bpt id=\"p2\">**</bpt>Edit<ept id=\"p2\">**</ept> again, the record's values are restored to what they were before the first <bpt id=\"p3\">**</bpt>Edit<ept id=\"p3\">**</ept> call.","pos":[32769,32913],"source":" If you call **Edit**, make changes, then call **Edit** again, the record's values are restored to what they were before the first **Edit** call."},{"content":"In some cases, you may want to update a column by making it Null (containing no data).","pos":[32920,33006]},{"content":"To do so, call <bpt id=\"p1\">[</bpt>SetFieldNull<ept id=\"p1\">](#crecordset__setfieldnull)</ept> with a parameter of <bpt id=\"p2\">**</bpt>TRUE<ept id=\"p2\">**</ept> to mark the field Null; this also causes the column to be updated.","pos":[33007,33159],"source":" To do so, call [SetFieldNull](#crecordset__setfieldnull) with a parameter of **TRUE** to mark the field Null; this also causes the column to be updated."},{"content":"If you want a field to be written to the data source even though its value has not changed, call <bpt id=\"p1\">[</bpt>SetFieldDirty<ept id=\"p1\">](#crecordset__setfielddirty)</ept> with a parameter of <bpt id=\"p2\">**</bpt>TRUE<ept id=\"p2\">**</ept>.","pos":[33160,33330],"source":" If you want a field to be written to the data source even though its value has not changed, call [SetFieldDirty](#crecordset__setfielddirty) with a parameter of **TRUE**."},{"content":"This works even if the field had the value Null.","pos":[33331,33379]},{"content":"If the data source supports transactions, you can make the <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> call part of a transaction.","pos":[33386,33481],"source":"If the data source supports transactions, you can make the **Edit** call part of a transaction."},{"content":"Note that you should call <bpt id=\"p1\">[</bpt>CDatabase::BeginTrans<ept id=\"p1\">](../../mfc/reference/cdatabase-class.md#cdatabase__begintrans)</ept> before calling <bpt id=\"p2\">**</bpt>Edit<ept id=\"p2\">**</ept> and after the recordset has been opened.","pos":[33482,33658],"source":" Note that you should call [CDatabase::BeginTrans](../../mfc/reference/cdatabase-class.md#cdatabase__begintrans) before calling **Edit** and after the recordset has been opened."},{"content":"Also note that calling <bpt id=\"p1\">[</bpt>CDatabase::CommitTrans<ept id=\"p1\">](../../mfc/reference/cdatabase-class.md#cdatabase__committrans)</ept> is not a substitute for calling <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept> to complete the <bpt id=\"p3\">**</bpt>Edit<ept id=\"p3\">**</ept> operation.","pos":[33659,33848],"source":" Also note that calling [CDatabase::CommitTrans](../../mfc/reference/cdatabase-class.md#cdatabase__committrans) is not a substitute for calling **Update** to complete the **Edit** operation."},{"content":"For more information about transactions, see class <bpt id=\"p1\">[</bpt>CDatabase<ept id=\"p1\">](../../mfc/reference/cdatabase-class.md)</ept>.","pos":[33849,33952],"source":" For more information about transactions, see class [CDatabase](../../mfc/reference/cdatabase-class.md)."},{"content":"Depending on the current locking mode, the record being updated may be locked by <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> until you call <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept> or scroll to another record, or it may be locked only during the <bpt id=\"p3\">**</bpt>Edit<ept id=\"p3\">**</ept> call.","pos":[33959,34154],"source":"Depending on the current locking mode, the record being updated may be locked by **Edit** until you call **Update** or scroll to another record, or it may be locked only during the **Edit** call."},{"content":"You can change the locking mode with <bpt id=\"p1\">[</bpt>SetLockingMode<ept id=\"p1\">](#crecordset__setlockingmode)</ept>.","pos":[34155,34238],"source":" You can change the locking mode with [SetLockingMode](#crecordset__setlockingmode)."},{"content":"The previous value of the current record is restored if you scroll to a new record before calling <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>.","pos":[34245,34354],"source":"The previous value of the current record is restored if you scroll to a new record before calling **Update**."},{"content":"A <ph id=\"ph1\">`CDBException`</ph> is thrown if you call <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> for a recordset that cannot be updated or if there is no current record.","pos":[34355,34475],"source":" A `CDBException` is thrown if you call **Edit** for a recordset that cannot be updated or if there is no current record."},{"pos":[34482,34670],"content":"For more information, see the articles <bpt id=\"p1\">[</bpt>Transaction (ODBC)<ept id=\"p1\">](../../data/odbc/transaction-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Locking Records (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-locking-records-odbc.md)</ept>.","source":"For more information, see the articles [Transaction (ODBC)](../../data/odbc/transaction-odbc.md) and [Recordset: Locking Records (ODBC)](../../data/odbc/recordset-locking-records-odbc.md)."},{"pos":[34680,34687],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[34691,34772],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#20<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_4.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#20](../../mfc/codesnippet/cpp/crecordset-class_4.cpp)]"},{"pos":[34782,34851],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__flushresultset\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::FlushResultSet","linkify":"<a name=\"crecordset__flushresultset\"></a>  CRecordset::FlushResultSet","source":"<a name=\"crecordset__flushresultset\"></a>  CRecordset::FlushResultSet"},{"content":"Retrieves the next result set of a predefined query (stored procedure), if there are multiple result sets.","pos":[34855,34961]},{"pos":[35009,35021],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if there are more result sets to be retrieved; otherwise 0.","pos":[35025,35092]},{"pos":[35102,35109],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"You should call <ph id=\"ph1\">`FlushResultSet`</ph> only when you are completely finished with the cursor on the current result set.","pos":[35113,35226],"source":"You should call `FlushResultSet` only when you are completely finished with the cursor on the current result set."},{"content":"Note that when you retrieve the next result set by calling <ph id=\"ph1\">`FlushResultSet`</ph>, your cursor is not valid on that result set; you should call the <bpt id=\"p1\">[</bpt>MoveNext<ept id=\"p1\">](#crecordset__movenext)</ept> member function after calling <ph id=\"ph2\">`FlushResultSet`</ph>.","pos":[35227,35450],"source":" Note that when you retrieve the next result set by calling `FlushResultSet`, your cursor is not valid on that result set; you should call the [MoveNext](#crecordset__movenext) member function after calling `FlushResultSet`."},{"pos":[35457,35645],"content":"If a predefined query uses an output parameter or input/output parameters, you must call <ph id=\"ph1\">`FlushResultSet`</ph> until it returns <ph id=\"ph2\">`FALSE`</ph> (the value 0), in order to obtain these parameter values.","source":"If a predefined query uses an output parameter or input/output parameters, you must call `FlushResultSet` until it returns `FALSE` (the value 0), in order to obtain these parameter values."},{"content":"<ph id=\"ph1\">`FlushResultSet`</ph> calls the ODBC API function <ph id=\"ph2\">`SQLMoreResults`</ph>.","pos":[35652,35714],"source":"`FlushResultSet` calls the ODBC API function `SQLMoreResults`."},{"content":"If <ph id=\"ph1\">`SQLMoreResults`</ph> returns <ph id=\"ph2\">`SQL_ERROR`</ph> or <ph id=\"ph3\">`SQL_INVALID_HANDLE`</ph>, then <ph id=\"ph4\">`FlushResultSet`</ph> will throw an exception.","pos":[35715,35826],"source":" If `SQLMoreResults` returns `SQL_ERROR` or `SQL_INVALID_HANDLE`, then `FlushResultSet` will throw an exception."},{"content":"For more information about <ph id=\"ph1\">`SQLMoreResults`</ph>, see the <ph id=\"ph2\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[35827,35932],"source":" For more information about `SQLMoreResults`, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[35939,36025],"content":"Your stored procedure needs to have bound fields if you want to call <ph id=\"ph1\">`FlushResultSet`</ph>.","source":"Your stored procedure needs to have bound fields if you want to call `FlushResultSet`."},{"pos":[36035,36042],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following code assumes that <ph id=\"ph1\">`COutParamRecordset`</ph> is a <ph id=\"ph2\">`CRecordset`</ph>-derived object based on a predefined query with an input parameter and an output parameter, and having multiple result sets.","pos":[36046,36241],"source":"The following code assumes that `COutParamRecordset` is a `CRecordset`-derived object based on a predefined query with an input parameter and an output parameter, and having multiple result sets."},{"content":"Note the structure of the <bpt id=\"p1\">[</bpt>DoFieldExchange<ept id=\"p1\">](#crecordset__dofieldexchange)</ept> override.","pos":[36242,36325],"source":" Note the structure of the [DoFieldExchange](#crecordset__dofieldexchange) override."},{"pos":[36332,36413],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#21<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_5.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#21](../../mfc/codesnippet/cpp/crecordset-class_5.cpp)]"},{"pos":[36420,36501],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#22<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_6.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#22](../../mfc/codesnippet/cpp/crecordset-class_6.cpp)]"},{"pos":[36511,36574],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getbookmark\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetBookmark","linkify":"<a name=\"crecordset__getbookmark\"></a>  CRecordset::GetBookmark","source":"<a name=\"crecordset__getbookmark\"></a>  CRecordset::GetBookmark"},{"content":"Obtains the bookmark value for the current record.","pos":[36578,36628]},{"pos":[36696,36706],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A reference to a <bpt id=\"p1\">[</bpt>CDBVariant<ept id=\"p1\">](../../mfc/reference/cdbvariant-class.md)</ept> object representing the bookmark on the current record.","pos":[36727,36853],"source":" A reference to a [CDBVariant](../../mfc/reference/cdbvariant-class.md) object representing the bookmark on the current record."},{"pos":[36863,36870],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"To determine if bookmarks are supported on the recordset, call <bpt id=\"p1\">[</bpt>CanBookmark<ept id=\"p1\">](#crecordset__canbookmark)</ept>.","pos":[36874,36977],"source":"To determine if bookmarks are supported on the recordset, call [CanBookmark](#crecordset__canbookmark)."},{"content":"To make bookmarks available if they are supported, you must set the <bpt id=\"p1\">**</bpt>CRecordset::useBookmarks<ept id=\"p1\">**</ept> option in the <ph id=\"ph1\">`dwOptions`</ph> parameter of the <bpt id=\"p2\">[</bpt>Open<ept id=\"p2\">](#crecordset__open)</ept> member function.","pos":[36978,37160],"source":" To make bookmarks available if they are supported, you must set the **CRecordset::useBookmarks** option in the `dwOptions` parameter of the [Open](#crecordset__open) member function."},{"pos":[37168,37343],"content":"[!NOTE]\n If bookmarks are unsupported or unavailable, calling `GetBookmark` will result in an exception being thrown. Bookmarks are not supported on forward-only recordsets.","leadings":["","> "],"nodes":[{"content":" If bookmarks are unsupported or unavailable, calling `GetBookmark` will result in an exception being thrown. Bookmarks are not supported on forward-only recordsets.","pos":[8,173],"nodes":[{"content":"If bookmarks are unsupported or unavailable, calling <ph id=\"ph1\">`GetBookmark`</ph> will result in an exception being thrown.","pos":[1,109],"source":" If bookmarks are unsupported or unavailable, calling `GetBookmark` will result in an exception being thrown."},{"content":"Bookmarks are not supported on forward-only recordsets.","pos":[110,165]}]}]},{"content":"<ph id=\"ph1\">`GetBookmark`</ph> assigns the value of the bookmark for the current record to a <ph id=\"ph2\">`CDBVariant`</ph> object.","pos":[37350,37446],"source":"`GetBookmark` assigns the value of the bookmark for the current record to a `CDBVariant` object."},{"content":"To return to that record at any time after moving to a different record, call <bpt id=\"p1\">[</bpt>SetBookmark<ept id=\"p1\">](#crecordset__setbookmark)</ept> with the corresponding <ph id=\"ph1\">`CDBVariant`</ph> object.","pos":[37447,37608],"source":" To return to that record at any time after moving to a different record, call [SetBookmark](#crecordset__setbookmark) with the corresponding `CDBVariant` object."},{"pos":[37616,37991],"content":"[!NOTE]\n After certain recordset operations, bookmarks may no longer be valid. For example, if you call `GetBookmark` followed by **Requery**, you may not be able to return to the record with `SetBookmark`. Call [CDatabase::GetBookmarkPersistence](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence) to check whether you can safely call `SetBookmark`.","leadings":["","> "],"nodes":[{"content":" After certain recordset operations, bookmarks may no longer be valid. For example, if you call `GetBookmark` followed by **Requery**, you may not be able to return to the record with `SetBookmark`. Call [CDatabase::GetBookmarkPersistence](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence) to check whether you can safely call `SetBookmark`.","pos":[8,373],"nodes":[{"content":"After certain recordset operations, bookmarks may no longer be valid.","pos":[1,70]},{"content":"For example, if you call <ph id=\"ph1\">`GetBookmark`</ph> followed by <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept>, you may not be able to return to the record with <ph id=\"ph2\">`SetBookmark`</ph>.","pos":[71,198],"source":" For example, if you call `GetBookmark` followed by **Requery**, you may not be able to return to the record with `SetBookmark`."},{"content":"Call <bpt id=\"p1\">[</bpt>CDatabase::GetBookmarkPersistence<ept id=\"p1\">](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence)</ept> to check whether you can safely call <ph id=\"ph1\">`SetBookmark`</ph>.","pos":[199,365],"source":" Call [CDatabase::GetBookmarkPersistence](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence) to check whether you can safely call `SetBookmark`."}]}]},{"pos":[37998,38278],"content":"For more information about bookmarks and recordset navigation, see the articles <bpt id=\"p1\">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Scrolling (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-scrolling-odbc.md)</ept>.","source":"For more information about bookmarks and recordset navigation, see the articles [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md) and [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md)."},{"pos":[38288,38363],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getdefaultconnect\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetDefaultConnect","linkify":"<a name=\"crecordset__getdefaultconnect\"></a>  CRecordset::GetDefaultConnect","source":"<a name=\"crecordset__getdefaultconnect\"></a>  CRecordset::GetDefaultConnect"},{"content":"Called to get the default connection string.","pos":[38367,38411]},{"pos":[38473,38485],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[38489,38545],"content":"A <ph id=\"ph1\">`CString`</ph> that contains the default connection string.","source":"A `CString` that contains the default connection string."},{"pos":[38555,38562],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The framework calls this member function to get the default connection string for the data source on which the recordset is based.","pos":[38566,38696]},{"content":"ClassWizard implements this function for you by identifying the same data source you use in ClassWizard to get information about tables and columns.","pos":[38697,38845]},{"content":"You will probably find it convenient to rely on this default connection while developing your application.","pos":[38846,38952]},{"content":"But the default connection may not be appropriate for users of your application.","pos":[38953,39033]},{"content":"If that is the case, you should reimplement this function, discarding ClassWizard's version.","pos":[39034,39126]},{"content":"For more information about connection strings, see the article <bpt id=\"p1\">[</bpt>Data Source (ODBC)<ept id=\"p1\">](../../data/odbc/data-source-odbc.md)</ept>.","pos":[39127,39248],"source":" For more information about connection strings, see the article [Data Source (ODBC)](../../data/odbc/data-source-odbc.md)."},{"pos":[39258,39325],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getdefaultsql\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetDefaultSQL","linkify":"<a name=\"crecordset__getdefaultsql\"></a>  CRecordset::GetDefaultSQL","source":"<a name=\"crecordset__getdefaultsql\"></a>  CRecordset::GetDefaultSQL"},{"content":"Called to get the default SQL string to execute.","pos":[39329,39377]},{"pos":[39435,39447],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[39451,39503],"content":"A <ph id=\"ph1\">`CString`</ph> that contains the default SQL statement.","source":"A `CString` that contains the default SQL statement."},{"pos":[39513,39520],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The framework calls this member function to get the default SQL statement on which the recordset is based.","pos":[39524,39630]},{"content":"This might be a table name or a SQL <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement.","pos":[39631,39688],"source":" This might be a table name or a SQL **SELECT** statement."},{"content":"You indirectly define the default SQL statement by declaring your recordset class with ClassWizard, and ClassWizard performs this task for you.","pos":[39695,39838]},{"content":"If you need the SQL statement string for your own use, call <ph id=\"ph1\">`GetSQL`</ph>, which returns the SQL statement used to select the recordset's records when it was opened.","pos":[39845,40005],"source":"If you need the SQL statement string for your own use, call `GetSQL`, which returns the SQL statement used to select the recordset's records when it was opened."},{"content":"You can edit the default SQL string in your class's override of <ph id=\"ph1\">`GetDefaultSQL`</ph>.","pos":[40006,40086],"source":" You can edit the default SQL string in your class's override of `GetDefaultSQL`."},{"content":"For example, you could specify a call to a predefined query using a <bpt id=\"p1\">**</bpt>CALL<ept id=\"p1\">**</ept> statement.","pos":[40087,40174],"source":" For example, you could specify a call to a predefined query using a **CALL** statement."},{"content":"(Note, however, that if you edit <ph id=\"ph1\">`GetDefaultSQL`</ph>, you also need to modify <ph id=\"ph2\">`m_nFields`</ph> to match the number of columns in the data source.)","pos":[40175,40312],"source":" (Note, however, that if you edit `GetDefaultSQL`, you also need to modify `m_nFields` to match the number of columns in the data source.)"},{"pos":[40319,40472],"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Recordset: Declaring a Class for a Table (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-declaring-a-class-for-a-table-odbc.md)</ept>.","source":"For more information, see the article [Recordset: Declaring a Class for a Table (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-table-odbc.md)."},{"pos":[40480,40904],"content":"[!CAUTION]\n The table name will be empty if the framework could not identify a table name, if multiple table names were supplied, or if a **CALL** statement could not be interpreted. Note that when using a **CALL** statement, you must not insert whitespace between the curly brace and the **CALL** keyword, nor should you insert whitespace before the curly brace or before the **SELECT** keyword in a **SELECT** statement.","leadings":["","> "],"nodes":[{"content":" The table name will be empty if the framework could not identify a table name, if multiple table names were supplied, or if a **CALL** statement could not be interpreted. Note that when using a **CALL** statement, you must not insert whitespace between the curly brace and the **CALL** keyword, nor should you insert whitespace before the curly brace or before the **SELECT** keyword in a **SELECT** statement.","pos":[11,422],"nodes":[{"content":"The table name will be empty if the framework could not identify a table name, if multiple table names were supplied, or if a <bpt id=\"p1\">**</bpt>CALL<ept id=\"p1\">**</ept> statement could not be interpreted.","pos":[1,171],"source":" The table name will be empty if the framework could not identify a table name, if multiple table names were supplied, or if a **CALL** statement could not be interpreted."},{"content":"Note that when using a <bpt id=\"p1\">**</bpt>CALL<ept id=\"p1\">**</ept> statement, you must not insert whitespace between the curly brace and the <bpt id=\"p2\">**</bpt>CALL<ept id=\"p2\">**</ept> keyword, nor should you insert whitespace before the curly brace or before the <bpt id=\"p3\">**</bpt>SELECT<ept id=\"p3\">**</ept> keyword in a <bpt id=\"p4\">**</bpt>SELECT<ept id=\"p4\">**</ept> statement.","pos":[172,411],"source":" Note that when using a **CALL** statement, you must not insert whitespace between the curly brace and the **CALL** keyword, nor should you insert whitespace before the curly brace or before the **SELECT** keyword in a **SELECT** statement."}]}]},{"pos":[40914,40981],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getfieldvalue\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetFieldValue","linkify":"<a name=\"crecordset__getfieldvalue\"></a>  CRecordset::GetFieldValue","source":"<a name=\"crecordset__getfieldvalue\"></a>  CRecordset::GetFieldValue"},{"content":"Retrieves field data in the current record.","pos":[40985,41028]},{"pos":[41420,41430],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The name of a field.","pos":[41448,41468]},{"content":"<bpt id=\"p1\">*</bpt>varValu<ept id=\"p1\">*</ept>e","pos":[41475,41485],"source":"*varValu*e"},{"content":"A reference to a <bpt id=\"p1\">[</bpt>CDBVariant<ept id=\"p1\">](../../mfc/reference/cdbvariant-class.md)</ept> object that will store the field's value.","pos":[41489,41601],"source":" A reference to a [CDBVariant](../../mfc/reference/cdbvariant-class.md) object that will store the field's value."},{"content":"The ODBC C data type of the field.","pos":[41624,41658]},{"content":"Using the default value, <bpt id=\"p1\">**</bpt>DEFAULT_FIELD_TYPE<ept id=\"p1\">**</ept>, forces <ph id=\"ph1\">`GetFieldValue`</ph> to determine the C data type from the SQL data type, based on the following table.","pos":[41659,41813],"source":" Using the default value, **DEFAULT_FIELD_TYPE**, forces `GetFieldValue` to determine the C data type from the SQL data type, based on the following table."},{"content":"Otherwise, you can specify the data type directly or choose a compatible data type; for example, you can store any data type into <bpt id=\"p1\">**</bpt>SQL_C_CHAR<ept id=\"p1\">**</ept>.","pos":[41814,41959],"source":" Otherwise, you can specify the data type directly or choose a compatible data type; for example, you can store any data type into **SQL_C_CHAR**."},{"content":"C data type","pos":[41966,41977]},{"content":"SQL data type","pos":[41978,41991]},{"pos":[42038,42051],"content":"<bpt id=\"p1\">**</bpt>SQL_C_BIT<ept id=\"p1\">**</ept>","source":"**SQL_C_BIT**"},{"pos":[42052,42063],"content":"<bpt id=\"p1\">**</bpt>SQL_BIT<ept id=\"p1\">**</ept>","source":"**SQL_BIT**"},{"pos":[42068,42086],"content":"<bpt id=\"p1\">**</bpt>SQL_C_UTINYINT<ept id=\"p1\">**</ept>","source":"**SQL_C_UTINYINT**"},{"pos":[42087,42102],"content":"<bpt id=\"p1\">**</bpt>SQL_TINYINT<ept id=\"p1\">**</ept>","source":"**SQL_TINYINT**"},{"pos":[42107,42123],"content":"<bpt id=\"p1\">**</bpt>SQL_C_SSHORT<ept id=\"p1\">**</ept>","source":"**SQL_C_SSHORT**"},{"pos":[42124,42140],"content":"<bpt id=\"p1\">**</bpt>SQL_SMALLINT<ept id=\"p1\">**</ept>","source":"**SQL_SMALLINT**"},{"pos":[42145,42160],"content":"<bpt id=\"p1\">**</bpt>SQL_C_SLONG<ept id=\"p1\">**</ept>","source":"**SQL_C_SLONG**"},{"pos":[42161,42176],"content":"<bpt id=\"p1\">**</bpt>SQL_INTEGER<ept id=\"p1\">**</ept>","source":"**SQL_INTEGER**"},{"pos":[42181,42196],"content":"<bpt id=\"p1\">**</bpt>SQL_C_FLOAT<ept id=\"p1\">**</ept>","source":"**SQL_C_FLOAT**"},{"pos":[42197,42209],"content":"<bpt id=\"p1\">**</bpt>SQL_REAL<ept id=\"p1\">**</ept>","source":"**SQL_REAL**"},{"pos":[42214,42230],"content":"<bpt id=\"p1\">**</bpt>SQL_C_DOUBLE<ept id=\"p1\">**</ept>","source":"**SQL_C_DOUBLE**"},{"pos":[42231,42254],"content":"<bpt id=\"p1\">**</bpt>SQL_FLOATSQL_DOUBLE<ept id=\"p1\">**</ept>","source":"**SQL_FLOATSQL_DOUBLE**"},{"pos":[42259,42278],"content":"<bpt id=\"p1\">**</bpt>SQL_C_TIMESTAMP<ept id=\"p1\">**</ept>","source":"**SQL_C_TIMESTAMP**"},{"pos":[42279,42312],"content":"<bpt id=\"p1\">**</bpt>SQL_DATESQL_TIMESQL_TIMESTAMP<ept id=\"p1\">**</ept>","source":"**SQL_DATESQL_TIMESQL_TIMESTAMP**"},{"pos":[42317,42331],"content":"<bpt id=\"p1\">**</bpt>SQL_C_CHAR<ept id=\"p1\">**</ept>","source":"**SQL_C_CHAR**"},{"pos":[42332,42402],"content":"<bpt id=\"p1\">**</bpt>SQL_NUMERICSQL_DECIMALSQL_BIGINTSQL_CHARSQL_VARCHARSQL_LONGVARCHAR<ept id=\"p1\">**</ept>","source":"**SQL_NUMERICSQL_DECIMALSQL_BIGINTSQL_CHARSQL_VARCHARSQL_LONGVARCHAR**"},{"pos":[42407,42423],"content":"<bpt id=\"p1\">**</bpt>SQL_C_BINARY<ept id=\"p1\">**</ept>","source":"**SQL_C_BINARY**"},{"pos":[42424,42468],"content":"<bpt id=\"p1\">**</bpt>SQL_BINARYSQL_VARBINARYSQL_LONGVARBINARY<ept id=\"p1\">**</ept>","source":"**SQL_BINARYSQL_VARBINARYSQL_LONGVARBINARY**"},{"pos":[42476,42644],"content":"For more information about ODBC data types, see the topics \"SQL Data Types\" and \"C Data Types\" in Appendix D of the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"For more information about ODBC data types, see the topics \"SQL Data Types\" and \"C Data Types\" in Appendix D of the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"The zero-based index of the field.","pos":[42663,42697]},{"content":"A reference to a <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> object that will store the field's value converted to text, regardless of the field's data type.","pos":[42718,42891],"source":" A reference to a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object that will store the field's value converted to text, regardless of the field's data type."},{"pos":[42901,42908],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"You can look up a field either by name or by index.","pos":[42912,42963]},{"content":"You can store the field value in either a <ph id=\"ph1\">`CDBVariant`</ph> object or a <ph id=\"ph2\">`CString`</ph> object.","pos":[42964,43048],"source":" You can store the field value in either a `CDBVariant` object or a `CString` object."},{"content":"If you have implemented bulk row fetching, the current record is always positioned on the first record in a rowset.","pos":[43055,43170]},{"content":"To use <ph id=\"ph1\">`GetFieldValue`</ph> on a record within a given rowset, you must first call the <bpt id=\"p1\">[</bpt>SetRowsetCursorPosition<ept id=\"p1\">](#crecordset__setrowsetcursorposition)</ept> member function to move the cursor to the desired row within that rowset.","pos":[43171,43390],"source":" To use `GetFieldValue` on a record within a given rowset, you must first call the [SetRowsetCursorPosition](#crecordset__setrowsetcursorposition) member function to move the cursor to the desired row within that rowset."},{"content":"Then call <ph id=\"ph1\">`GetFieldValue`</ph> for that row.","pos":[43391,43430],"source":" Then call `GetFieldValue` for that row."},{"content":"To implement bulk row fetching, you must specify the <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph> option of the <ph id=\"ph2\">`dwOptions`</ph> parameter in the <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](#crecordset__open)</ept> member function.","pos":[43431,43600],"source":" To implement bulk row fetching, you must specify the `CRecordset::useMultiRowFetch` option of the `dwOptions` parameter in the [Open](#crecordset__open) member function."},{"content":"You can use <ph id=\"ph1\">`GetFieldValue`</ph> to dynamically fetch fields at run time rather than statically binding them at design time.","pos":[43607,43726],"source":"You can use `GetFieldValue` to dynamically fetch fields at run time rather than statically binding them at design time."},{"content":"For example, if you have declared a recordset object directly from <ph id=\"ph1\">`CRecordset`</ph>, you must use <ph id=\"ph2\">`GetFieldValue`</ph> to retrieve the field data; record field exchange (RFX), or bulk record field exchange (Bulk RFX), is not implemented.","pos":[43727,43955],"source":" For example, if you have declared a recordset object directly from `CRecordset`, you must use `GetFieldValue` to retrieve the field data; record field exchange (RFX), or bulk record field exchange (Bulk RFX), is not implemented."},{"pos":[43963,44470],"content":"[!NOTE]\n If you declare a recordset object without deriving from `CRecordset`, do not have the ODBC Cursor Library loaded. The cursor library requires that the recordset have at least one bound column; however, when you use `CRecordset` directly, none of the columns are bound. The member functions [CDatabase::OpenEx](../../mfc/reference/cdatabase-class.md#cdatabase__openex) and [CDatabase::Open](../../mfc/reference/cdatabase-class.md#cdatabase__open) control whether the cursor library will be loaded.","leadings":["","> "],"nodes":[{"content":" If you declare a recordset object without deriving from `CRecordset`, do not have the ODBC Cursor Library loaded. The cursor library requires that the recordset have at least one bound column; however, when you use `CRecordset` directly, none of the columns are bound. The member functions [CDatabase::OpenEx](../../mfc/reference/cdatabase-class.md#cdatabase__openex) and [CDatabase::Open](../../mfc/reference/cdatabase-class.md#cdatabase__open) control whether the cursor library will be loaded.","pos":[8,505],"nodes":[{"content":"If you declare a recordset object without deriving from <ph id=\"ph1\">`CRecordset`</ph>, do not have the ODBC Cursor Library loaded.","pos":[1,114],"source":" If you declare a recordset object without deriving from `CRecordset`, do not have the ODBC Cursor Library loaded."},{"content":"The cursor library requires that the recordset have at least one bound column; however, when you use <ph id=\"ph1\">`CRecordset`</ph> directly, none of the columns are bound.","pos":[115,269],"source":" The cursor library requires that the recordset have at least one bound column; however, when you use `CRecordset` directly, none of the columns are bound."},{"content":"The member functions <bpt id=\"p1\">[</bpt>CDatabase::OpenEx<ept id=\"p1\">](../../mfc/reference/cdatabase-class.md#cdatabase__openex)</ept> and <bpt id=\"p2\">[</bpt>CDatabase::Open<ept id=\"p2\">](../../mfc/reference/cdatabase-class.md#cdatabase__open)</ept> control whether the cursor library will be loaded.","pos":[270,497],"source":" The member functions [CDatabase::OpenEx](../../mfc/reference/cdatabase-class.md#cdatabase__openex) and [CDatabase::Open](../../mfc/reference/cdatabase-class.md#cdatabase__open) control whether the cursor library will be loaded."}]}]},{"content":"<ph id=\"ph1\">`GetFieldValue`</ph> calls the ODBC API function <bpt id=\"p1\">**</bpt>SQLGetData<ept id=\"p1\">**</ept>.","pos":[44477,44536],"source":"`GetFieldValue` calls the ODBC API function **SQLGetData**."},{"content":"If your driver outputs the value <bpt id=\"p1\">**</bpt>SQL_NO_TOTAL<ept id=\"p1\">**</ept> for the actual length of the field value, <ph id=\"ph1\">`GetFieldValue`</ph> throws an exception.","pos":[44537,44665],"source":" If your driver outputs the value **SQL_NO_TOTAL** for the actual length of the field value, `GetFieldValue` throws an exception."},{"content":"For more information about <bpt id=\"p1\">**</bpt>SQLGetData<ept id=\"p1\">**</ept>, see the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[44666,44769],"source":" For more information about **SQLGetData**, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[44779,44786],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[44790,44912],"content":"The following sample code illustrates calls to <ph id=\"ph1\">`GetFieldValue`</ph> for a recordset object declared directly from <ph id=\"ph2\">`CRecordset`</ph>.","source":"The following sample code illustrates calls to `GetFieldValue` for a recordset object declared directly from `CRecordset`."},{"pos":[44919,45000],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#23<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_7.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#23](../../mfc/codesnippet/cpp/crecordset-class_7.cpp)]"},{"pos":[45008,45199],"content":"[!NOTE]\n Unlike the DAO class `CDaoRecordset`, `CRecordset` does not have a `SetFieldValue` member function. If you create an object directly from `CRecordset`, it is effectively read-only.","leadings":["","> "],"nodes":[{"content":" Unlike the DAO class `CDaoRecordset`, `CRecordset` does not have a `SetFieldValue` member function. If you create an object directly from `CRecordset`, it is effectively read-only.","pos":[8,189],"nodes":[{"content":"Unlike the DAO class <ph id=\"ph1\">`CDaoRecordset`</ph>, <ph id=\"ph2\">`CRecordset`</ph> does not have a <ph id=\"ph3\">`SetFieldValue`</ph> member function.","pos":[1,100],"source":" Unlike the DAO class `CDaoRecordset`, `CRecordset` does not have a `SetFieldValue` member function."},{"content":"If you create an object directly from <ph id=\"ph1\">`CRecordset`</ph>, it is effectively read-only.","pos":[101,181],"source":" If you create an object directly from `CRecordset`, it is effectively read-only."}]}]},{"pos":[45206,45373],"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","source":"For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[45383,45458],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getodbcfieldcount\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetODBCFieldCount","linkify":"<a name=\"crecordset__getodbcfieldcount\"></a>  CRecordset::GetODBCFieldCount","source":"<a name=\"crecordset__getodbcfieldcount\"></a>  CRecordset::GetODBCFieldCount"},{"content":"Retrieves the total number of fields in your recordset object.","pos":[45462,45524]},{"pos":[45585,45597],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The number of fields in the recordset.","pos":[45601,45639]},{"pos":[45649,45656],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[45660,45843],"content":"For more information about creating recordsets, see the article <bpt id=\"p1\">[</bpt>Recordset: Creating and Closing Recordsets (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md)</ept>.","source":"For more information about creating recordsets, see the article [Recordset: Creating and Closing Recordsets (ODBC)](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md)."},{"pos":[45853,45926],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getodbcfieldinfo\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetODBCFieldInfo","linkify":"<a name=\"crecordset__getodbcfieldinfo\"></a>  CRecordset::GetODBCFieldInfo","source":"<a name=\"crecordset__getodbcfieldinfo\"></a>  CRecordset::GetODBCFieldInfo"},{"content":"Obtains information about the fields in the recordset.","pos":[45930,45984]},{"pos":[46166,46176],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The name of a field.","pos":[46194,46214]},{"content":"A reference to a <ph id=\"ph1\">`CODBCFieldInfo`</ph> structure.","pos":[46236,46280],"source":" A reference to a `CODBCFieldInfo` structure."},{"content":"The zero-based index of the field.","pos":[46299,46333]},{"pos":[46343,46350],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"One version of the function lets you look up a field by name.","pos":[46354,46415]},{"content":"The other version lets you look up a field by index.","pos":[46416,46468]},{"pos":[46475,46609],"content":"For a description about the information returned, see the <bpt id=\"p1\">[</bpt>CODBCFieldInfo<ept id=\"p1\">](../../mfc/reference/codbcfieldinfo-structure.md)</ept> structure.","source":"For a description about the information returned, see the [CODBCFieldInfo](../../mfc/reference/codbcfieldinfo-structure.md) structure."},{"pos":[46616,46799],"content":"For more information about creating recordsets, see the article <bpt id=\"p1\">[</bpt>Recordset: Creating and Closing Recordsets (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md)</ept>.","source":"For more information about creating recordsets, see the article [Recordset: Creating and Closing Recordsets (ODBC)](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md)."},{"pos":[46809,46878],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getrecordcount\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetRecordCount","linkify":"<a name=\"crecordset__getrecordcount\"></a>  CRecordset::GetRecordCount","source":"<a name=\"crecordset__getrecordcount\"></a>  CRecordset::GetRecordCount"},{"content":"Determines the size of the recordset.","pos":[46882,46919]},{"pos":[46976,46988],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The number of records in the recordset; 0 if the recordset contains no records; or 1 if the record count cannot be determined.","pos":[46992,47119]},{"pos":[47129,47136],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[47144,47686],"content":"[!CAUTION]\n The record count is maintained as a \"high water mark,\" the highest-numbered record yet seen as the user moves through the records. The total number of records is only known after the user has moved beyond the last record. For performance reasons, the count is not updated when you call `MoveLast`. To count the records yourself, call `MoveNext` repeatedly until `IsEOF` returns nonzero. Adding a record via **CRecordset:AddNew** and **Update** increases the count; deleting a record via `CRecordset::Delete` decreases the count.","leadings":["","> "],"nodes":[{"content":" The record count is maintained as a \"high water mark,\" the highest-numbered record yet seen as the user moves through the records. The total number of records is only known after the user has moved beyond the last record. For performance reasons, the count is not updated when you call `MoveLast`. To count the records yourself, call `MoveNext` repeatedly until `IsEOF` returns nonzero. Adding a record via **CRecordset:AddNew** and **Update** increases the count; deleting a record via `CRecordset::Delete` decreases the count.","pos":[11,540],"nodes":[{"content":"The record count is maintained as a \"high water mark,\" the highest-numbered record yet seen as the user moves through the records.","pos":[1,131]},{"content":"The total number of records is only known after the user has moved beyond the last record.","pos":[132,222]},{"content":"For performance reasons, the count is not updated when you call <ph id=\"ph1\">`MoveLast`</ph>.","pos":[223,298],"source":" For performance reasons, the count is not updated when you call `MoveLast`."},{"content":"To count the records yourself, call <ph id=\"ph1\">`MoveNext`</ph> repeatedly until <ph id=\"ph2\">`IsEOF`</ph> returns nonzero.","pos":[299,387],"source":" To count the records yourself, call `MoveNext` repeatedly until `IsEOF` returns nonzero."},{"content":"Adding a record via <bpt id=\"p1\">**</bpt>CRecordset:AddNew<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept> increases the count; deleting a record via <ph id=\"ph1\">`CRecordset::Delete`</ph> decreases the count.","pos":[388,529],"source":" Adding a record via **CRecordset:AddNew** and **Update** increases the count; deleting a record via `CRecordset::Delete` decreases the count."}]}]},{"pos":[47696,47763],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getrowsetsize\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetRowsetSize","linkify":"<a name=\"crecordset__getrowsetsize\"></a>  CRecordset::GetRowsetSize","source":"<a name=\"crecordset__getrowsetsize\"></a>  CRecordset::GetRowsetSize"},{"content":"Obtains the current setting for the number of rows you wish to retrieve during a given fetch.","pos":[47767,47860]},{"pos":[47917,47929],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The number of rows to retrieve during a given fetch.","pos":[47933,47985]},{"pos":[47995,48002],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If you are using bulk row fetching, the default rowset size when the recordset is opened is 25; otherwise, it is 1.","pos":[48006,48121]},{"content":"To implement bulk row fetching, you must specify the <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph> option in the <ph id=\"ph2\">`dwOptions`</ph> parameter of the <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](#crecordset__open)</ept> member function.","pos":[48128,48297],"source":"To implement bulk row fetching, you must specify the `CRecordset::useMultiRowFetch` option in the `dwOptions` parameter of the [Open](#crecordset__open) member function."},{"content":"To change the setting for the rowset size, call <bpt id=\"p1\">[</bpt>SetRowsetSize<ept id=\"p1\">](#crecordset__setrowsetsize)</ept>.","pos":[48298,48390],"source":" To change the setting for the rowset size, call [SetRowsetSize](#crecordset__setrowsetsize)."},{"pos":[48397,48564],"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","source":"For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[48574,48643],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getrowsfetched\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetRowsFetched","linkify":"<a name=\"crecordset__getrowsfetched\"></a>  CRecordset::GetRowsFetched","source":"<a name=\"crecordset__getrowsfetched\"></a>  CRecordset::GetRowsFetched"},{"content":"Determines how many records were actually retrieved after a fetch.","pos":[48647,48713]},{"pos":[48771,48783],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The number of rows retrieved from the data source after a given fetch.","pos":[48787,48857]},{"pos":[48867,48874],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This is useful when you have implemented bulk row fetching.","pos":[48878,48937]},{"content":"The rowset size normally indicates how many rows will be retrieved from a fetch; however, the total number of rows in the recordset also affects how many rows will be retrieved in a rowset.","pos":[48938,49127]},{"content":"For example, if your recordset has 10 records with a rowset size setting of 4, then looping through the recordset by calling <ph id=\"ph1\">`MoveNext`</ph> will result in the final rowset having only 2 records.","pos":[49128,49318],"source":" For example, if your recordset has 10 records with a rowset size setting of 4, then looping through the recordset by calling `MoveNext` will result in the final rowset having only 2 records."},{"content":"To implement bulk row fetching, you must specify the <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph> option in the <ph id=\"ph2\">`dwOptions`</ph> parameter of the <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](#crecordset__open)</ept> member function.","pos":[49325,49494],"source":"To implement bulk row fetching, you must specify the `CRecordset::useMultiRowFetch` option in the `dwOptions` parameter of the [Open](#crecordset__open) member function."},{"content":"To specify the rowset size, call <bpt id=\"p1\">[</bpt>SetRowsetSize<ept id=\"p1\">](#crecordset__setrowsetsize)</ept>.","pos":[49495,49572],"source":" To specify the rowset size, call [SetRowsetSize](#crecordset__setrowsetsize)."},{"pos":[49579,49746],"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","source":"For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[49756,49763],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[49767,49848],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#24<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_8.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#24](../../mfc/codesnippet/cpp/crecordset-class_8.cpp)]"},{"pos":[49858,49923],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getrowstatus\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetRowStatus","linkify":"<a name=\"crecordset__getrowstatus\"></a>  CRecordset::GetRowStatus","source":"<a name=\"crecordset__getrowstatus\"></a>  CRecordset::GetRowStatus"},{"content":"Obtains the status for a row in the current rowset.","pos":[49927,49978]},{"pos":[50042,50052],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The one-based position of a row in the current rowset.","pos":[50066,50120]},{"content":"This value can range from 1 to the size of the rowset.","pos":[50121,50175]},{"pos":[50185,50197],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"A status value for the row.","pos":[50201,50228]},{"content":"For details, see Remarks.","pos":[50229,50254]},{"pos":[50264,50271],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`GetRowStatus`</ph> returns a value that indicates either any change in status to the row since it was last retrieved from the data source, or that no row corresponding to <ph id=\"ph2\">`wRow`</ph> was fetched.","pos":[50275,50461],"source":"`GetRowStatus` returns a value that indicates either any change in status to the row since it was last retrieved from the data source, or that no row corresponding to `wRow` was fetched."},{"content":"The following table lists the possible return values.","pos":[50462,50515]},{"content":"Status value","pos":[50522,50534]},{"content":"Description","pos":[50535,50546]},{"content":"The row is unchanged.","pos":[50610,50631]},{"content":"The row has been updated.","pos":[50654,50679]},{"content":"The row has been deleted.","pos":[50702,50727]},{"content":"The row has been added.","pos":[50748,50771]},{"content":"The row is unretrievable due to an error.","pos":[50792,50833]},{"pos":[50854,50897],"content":"There is no row that corresponds to <ph id=\"ph1\">`wRow`</ph>.","source":"There is no row that corresponds to `wRow`."},{"pos":[50905,51033],"content":"For more information, see the ODBC API function <bpt id=\"p1\">**</bpt>SQLExtendedFetch<ept id=\"p1\">**</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","source":"For more information, see the ODBC API function **SQLExtendedFetch** in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[51043,51102],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getstatus\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetStatus","linkify":"<a name=\"crecordset__getstatus\"></a>  CRecordset::GetStatus","source":"<a name=\"crecordset__getstatus\"></a>  CRecordset::GetStatus"},{"content":"Determines the index of the current record in the recordset and whether the last record has been seen.","pos":[51106,51208]},{"pos":[51285,51295],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A reference to a <bpt id=\"p1\">**</bpt>CRecordsetStatus<ept id=\"p1\">**</ept> object.","pos":[51312,51357],"source":" A reference to a **CRecordsetStatus** object."},{"content":"See the Remarks section for more information.","pos":[51358,51403]},{"pos":[51413,51420],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`CRecordset`</ph> attempts to track the index, but under some circumstances this may not be possible.","pos":[51424,51520],"source":"`CRecordset` attempts to track the index, but under some circumstances this may not be possible."},{"content":"See <bpt id=\"p1\">[</bpt>GetRecordCount<ept id=\"p1\">](#crecordset__getrecordcount)</ept> for an explanation.","pos":[51521,51590],"source":" See [GetRecordCount](#crecordset__getrecordcount) for an explanation."},{"pos":[51597,51655],"content":"The <bpt id=\"p1\">**</bpt>CRecordsetStatus<ept id=\"p1\">**</ept> structure has the following form:","source":"The **CRecordsetStatus** structure has the following form:"},{"pos":[51780,51848],"content":"The two members of <bpt id=\"p1\">**</bpt>CRecordsetStatus<ept id=\"p1\">**</ept> have the following meanings:","source":"The two members of **CRecordsetStatus** have the following meanings:"},{"content":"<bpt id=\"p1\">**</bpt>m_lCurrentRecord<ept id=\"p1\">**</ept> Contains the zero-based index of the current record in the recordset, if known.","pos":[51856,51956],"source":"**m_lCurrentRecord** Contains the zero-based index of the current record in the recordset, if known."},{"content":"If the index cannot be determined, this member contains <bpt id=\"p1\">**</bpt>AFX_CURRENT_RECORD_UNDEFINED<ept id=\"p1\">**</ept> (2).","pos":[51957,52051],"source":" If the index cannot be determined, this member contains **AFX_CURRENT_RECORD_UNDEFINED** (2)."},{"content":"If <ph id=\"ph1\">`IsBOF`</ph> is <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept> (empty recordset or attempt to scroll before first record), then <bpt id=\"p2\">**</bpt>m_lCurrentRecord<ept id=\"p2\">**</ept> is set to <bpt id=\"p3\">**</bpt>AFX_CURRENT_RECORD_BOF<ept id=\"p3\">**</ept> (1).","pos":[52052,52203],"source":" If `IsBOF` is **TRUE** (empty recordset or attempt to scroll before first record), then **m_lCurrentRecord** is set to **AFX_CURRENT_RECORD_BOF** (1)."},{"content":"If on the first record, then it is set to 0, second record 1, and so on.","pos":[52204,52276]},{"content":"<bpt id=\"p1\">**</bpt>m_bRecordCountFinal<ept id=\"p1\">**</ept> Nonzero if the total number of records in the recordset has been determined.","pos":[52284,52384],"source":"**m_bRecordCountFinal** Nonzero if the total number of records in the recordset has been determined."},{"content":"Generally this must be accomplished by starting at the beginning of the recordset and calling <ph id=\"ph1\">`MoveNext`</ph> until <ph id=\"ph2\">`IsEOF`</ph> returns nonzero.","pos":[52385,52520],"source":" Generally this must be accomplished by starting at the beginning of the recordset and calling `MoveNext` until `IsEOF` returns nonzero."},{"content":"If this member is zero, the record count as returned by <ph id=\"ph1\">`GetRecordCount`</ph>, if not 1, is only a \"high water mark\" count of the records.","pos":[52521,52655],"source":" If this member is zero, the record count as returned by `GetRecordCount`, if not 1, is only a \"high water mark\" count of the records."},{"pos":[52665,52718],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__getsql\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetSQL","linkify":"<a name=\"crecordset__getsql\"></a>  CRecordset::GetSQL","source":"<a name=\"crecordset__getsql\"></a>  CRecordset::GetSQL"},{"content":"Call this member function to get the SQL statement that was used to select the recordset's records when it was opened.","pos":[52722,52840]},{"pos":[52899,52911],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[52915,52984],"content":"A <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> reference to a <ph id=\"ph1\">`CString`</ph> that contains the SQL statement.","source":"A **const** reference to a `CString` that contains the SQL statement."},{"pos":[52994,53001],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This will generally be a SQL <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement.","pos":[53005,53055],"source":"This will generally be a SQL **SELECT** statement."},{"content":"The string returned by <ph id=\"ph1\">`GetSQL`</ph> is read-only.","pos":[53056,53101],"source":" The string returned by `GetSQL` is read-only."},{"content":"The string returned by <ph id=\"ph1\">`GetSQL`</ph> is typically different from any string you may have passed to the recordset in the <ph id=\"ph2\">`lpszSQL`</ph> parameter to the <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> member function.","pos":[53108,53275],"source":"The string returned by `GetSQL` is typically different from any string you may have passed to the recordset in the `lpszSQL` parameter to the **Open** member function."},{"content":"This is because the recordset constructs a full SQL statement based on what you passed to <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept>, what you specified with ClassWizard, what you may have specified in the <bpt id=\"p2\">**</bpt>m_strFilter<ept id=\"p2\">**</ept> and <ph id=\"ph1\">`m_strSort`</ph> data members, and any parameters you may have specified.","pos":[53276,53536],"source":" This is because the recordset constructs a full SQL statement based on what you passed to **Open**, what you specified with ClassWizard, what you may have specified in the **m_strFilter** and `m_strSort` data members, and any parameters you may have specified."},{"content":"For details about how the recordset constructs this SQL statement, see the article <bpt id=\"p1\">[</bpt>Recordset: How Recordsets Select Records (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)</ept>.","pos":[53537,53735],"source":" For details about how the recordset constructs this SQL statement, see the article [Recordset: How Recordsets Select Records (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)."},{"pos":[53743,53825],"content":"[!NOTE]\n Call this member function only after calling [Open](#crecordset__open).","leadings":["","> "],"nodes":[{"content":"Call this member function only after calling <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](#crecordset__open)</ept>.","pos":[9,80],"source":" Call this member function only after calling [Open](#crecordset__open)."}]},{"pos":[53835,53900],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__gettablename\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::GetTableName","linkify":"<a name=\"crecordset__gettablename\"></a>  CRecordset::GetTableName","source":"<a name=\"crecordset__gettablename\"></a>  CRecordset::GetTableName"},{"content":"Gets the name of the SQL table on which the recordset's query is based.","pos":[53904,53975]},{"pos":[54040,54052],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[54056,54188],"content":"A <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> reference to a <ph id=\"ph1\">`CString`</ph> that contains the table name, if the recordset is based on a table; otherwise, an empty string.","source":"A **const** reference to a `CString` that contains the table name, if the recordset is based on a table; otherwise, an empty string."},{"pos":[54198,54205],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`GetTableName`</ph> is only valid if the recordset is based on a table, not a join of multiple tables or a predefined query (stored procedure).","pos":[54209,54347],"source":"`GetTableName` is only valid if the recordset is based on a table, not a join of multiple tables or a predefined query (stored procedure)."},{"content":"The name is read-only.","pos":[54348,54370]},{"pos":[54378,54460],"content":"[!NOTE]\n Call this member function only after calling [Open](#crecordset__open).","leadings":["","> "],"nodes":[{"content":"Call this member function only after calling <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](#crecordset__open)</ept>.","pos":[9,80],"source":" Call this member function only after calling [Open](#crecordset__open)."}]},{"pos":[54470,54521],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__isbof\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::IsBOF","linkify":"<a name=\"crecordset__isbof\"></a>  CRecordset::IsBOF","source":"<a name=\"crecordset__isbof\"></a>  CRecordset::IsBOF"},{"content":"Returns nonzero if the recordset has been positioned before the first record.","pos":[54525,54602]},{"content":"There is no current record.","pos":[54603,54630]},{"pos":[54678,54690],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the recordset contains no records or if you have scrolled backward before the first record; otherwise 0.","pos":[54694,54809]},{"pos":[54819,54826],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Call this member function before you scroll from record to record to learn whether you have gone before the first record of the recordset.","pos":[54830,54968]},{"content":"You can also use <ph id=\"ph1\">`IsBOF`</ph> along with <ph id=\"ph2\">`IsEOF`</ph> to determine whether the recordset contains any records or is empty.","pos":[54969,55081],"source":" You can also use `IsBOF` along with `IsEOF` to determine whether the recordset contains any records or is empty."},{"content":"Immediately after you call <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept>, if the recordset contains no records, <ph id=\"ph1\">`IsBOF`</ph> returns nonzero.When you open a recordset that has at least one record, the first record is the current record and <ph id=\"ph2\">`IsBOF`</ph> returns 0.","pos":[55082,55298],"source":" Immediately after you call **Open**, if the recordset contains no records, `IsBOF` returns nonzero.When you open a recordset that has at least one record, the first record is the current record and `IsBOF` returns 0."},{"content":"If the first record is the current record and you call <ph id=\"ph1\">`MovePrev`</ph>, <ph id=\"ph2\">`IsBOF`</ph> will subsequently return nonzero.","pos":[55305,55413],"source":"If the first record is the current record and you call `MovePrev`, `IsBOF` will subsequently return nonzero."},{"content":"If <ph id=\"ph1\">`IsBOF`</ph> returns nonzero and you call <ph id=\"ph2\">`MovePrev`</ph>, an error occurs.","pos":[55414,55482],"source":" If `IsBOF` returns nonzero and you call `MovePrev`, an error occurs."},{"content":"If <ph id=\"ph1\">`IsBOF`</ph> returns nonzero, the current record is undefined, and any action that requires a current record will result in an error.","pos":[55483,55614],"source":" If `IsBOF` returns nonzero, the current record is undefined, and any action that requires a current record will result in an error."},{"pos":[55624,55631],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[55635,55770],"content":"This example uses <ph id=\"ph1\">`IsBOF`</ph> and <ph id=\"ph2\">`IsEOF`</ph> to detect the limits of a recordset as the code scrolls through the recordset in both directions.","source":"This example uses `IsBOF` and `IsEOF` to detect the limits of a recordset as the code scrolls through the recordset in both directions."},{"pos":[55777,55858],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#25<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_9.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#25](../../mfc/codesnippet/cpp/crecordset-class_9.cpp)]"},{"pos":[55868,55927],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__isdeleted\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::IsDeleted","linkify":"<a name=\"crecordset__isdeleted\"></a>  CRecordset::IsDeleted","source":"<a name=\"crecordset__isdeleted\"></a>  CRecordset::IsDeleted"},{"content":"Determines whether the current record has been deleted.","pos":[55931,55986]},{"pos":[56038,56050],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the recordset is positioned on a deleted record; otherwise 0.","pos":[56054,56126]},{"pos":[56136,56143],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[56147,56310],"content":"If you scroll to a record and <ph id=\"ph1\">`IsDeleted`</ph> returns <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept> (nonzero), then you must scroll to another record before you can perform any other recordset operations.","source":"If you scroll to a record and `IsDeleted` returns **TRUE** (nonzero), then you must scroll to another record before you can perform any other recordset operations."},{"pos":[56317,56613],"content":"The result of <ph id=\"ph1\">`IsDeleted`</ph> depends on many factors, such as your recordset type, whether your recordset is updatable, whether you specified the <bpt id=\"p1\">**</bpt>CRecordset::skipDeletedRecords<ept id=\"p1\">**</ept> option when you opened the recordset, whether your driver packs deleted records, and whether there are multiple users.","source":"The result of `IsDeleted` depends on many factors, such as your recordset type, whether your recordset is updatable, whether you specified the **CRecordset::skipDeletedRecords** option when you opened the recordset, whether your driver packs deleted records, and whether there are multiple users."},{"pos":[56620,56752],"content":"For more information about <bpt id=\"p1\">**</bpt>CRecordset::skipDeletedRecords<ept id=\"p1\">**</ept> and driver packing, see the <bpt id=\"p2\">[</bpt>Open<ept id=\"p2\">](#crecordset__open)</ept> member function.","source":"For more information about **CRecordset::skipDeletedRecords** and driver packing, see the [Open](#crecordset__open) member function."},{"pos":[56760,57091],"content":"[!NOTE]\n If you have implemented bulk row fetching, you should not call `IsDeleted`. Instead, call the [GetRowStatus](#crecordset__getrowstatus) member function. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" If you have implemented bulk row fetching, you should not call `IsDeleted`. Instead, call the [GetRowStatus](#crecordset__getrowstatus) member function. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,329],"nodes":[{"content":"If you have implemented bulk row fetching, you should not call <ph id=\"ph1\">`IsDeleted`</ph>.","pos":[1,76],"source":" If you have implemented bulk row fetching, you should not call `IsDeleted`."},{"content":"Instead, call the <bpt id=\"p1\">[</bpt>GetRowStatus<ept id=\"p1\">](#crecordset__getrowstatus)</ept> member function.","pos":[77,153],"source":" Instead, call the [GetRowStatus](#crecordset__getrowstatus) member function."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[154,321],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"pos":[57101,57152],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__iseof\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::IsEOF","linkify":"<a name=\"crecordset__iseof\"></a>  CRecordset::IsEOF","source":"<a name=\"crecordset__iseof\"></a>  CRecordset::IsEOF"},{"content":"Returns nonzero if the recordset has been positioned after the last record.","pos":[57156,57231]},{"content":"There is no current record.","pos":[57232,57259]},{"pos":[57307,57319],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the recordset contains no records or if you have scrolled beyond the last record; otherwise 0.","pos":[57323,57428]},{"pos":[57438,57445],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Call this member function as you scroll from record to record to learn whether you have gone beyond the last record of the recordset.","pos":[57449,57582]},{"content":"You can also use <ph id=\"ph1\">`IsEOF`</ph> to determine whether the recordset contains any records or is empty.","pos":[57583,57676],"source":" You can also use `IsEOF` to determine whether the recordset contains any records or is empty."},{"content":"Immediately after you call <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept>, if the recordset contains no records, <ph id=\"ph1\">`IsEOF`</ph> returns nonzero.","pos":[57677,57776],"source":" Immediately after you call **Open**, if the recordset contains no records, `IsEOF` returns nonzero."},{"content":"When you open a recordset that has at least one record, the first record is the current record and <ph id=\"ph1\">`IsEOF`</ph> returns 0.","pos":[57777,57894],"source":" When you open a recordset that has at least one record, the first record is the current record and `IsEOF` returns 0."},{"content":"If the last record is the current record when you call <ph id=\"ph1\">`MoveNext`</ph>, <ph id=\"ph2\">`IsEOF`</ph> will subsequently return nonzero.","pos":[57901,58009],"source":"If the last record is the current record when you call `MoveNext`, `IsEOF` will subsequently return nonzero."},{"content":"If <ph id=\"ph1\">`IsEOF`</ph> returns nonzero and you call <ph id=\"ph2\">`MoveNext`</ph>, an error occurs.","pos":[58010,58078],"source":" If `IsEOF` returns nonzero and you call `MoveNext`, an error occurs."},{"content":"If <ph id=\"ph1\">`IsEOF`</ph> returns nonzero, the current record is undefined, and any action that requires a current record will result in an error.","pos":[58079,58210],"source":" If `IsEOF` returns nonzero, the current record is undefined, and any action that requires a current record will result in an error."},{"pos":[58220,58227],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[58231,58279],"content":"See the example for <bpt id=\"p1\">[</bpt>IsBOF<ept id=\"p1\">](#crecordset__isbof)</ept>.","source":"See the example for [IsBOF](#crecordset__isbof)."},{"pos":[58289,58354],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__isfielddirty\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::IsFieldDirty","linkify":"<a name=\"crecordset__isfielddirty\"></a>  CRecordset::IsFieldDirty","source":"<a name=\"crecordset__isfielddirty\"></a>  CRecordset::IsFieldDirty"},{"pos":[58358,58502],"content":"Determines whether the specified field data member has been changed since <bpt id=\"p1\">[</bpt>Edit<ept id=\"p1\">](#crecordset__edit)</ept> or <bpt id=\"p2\">[</bpt>AddNew<ept id=\"p2\">](#crecordset__addnew)</ept> was called.","source":"Determines whether the specified field data member has been changed since [Edit](#crecordset__edit) or [AddNew](#crecordset__addnew) was called."},{"pos":[58556,58566],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A pointer to the field data member whose status you want to check, or <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> to determine if any of the fields are dirty.","pos":[58578,58701],"source":" A pointer to the field data member whose status you want to check, or **NULL** to determine if any of the fields are dirty."},{"pos":[58711,58723],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[58727,58830],"content":"Nonzero if the specified field data member has changed since calling <ph id=\"ph1\">`AddNew`</ph> or <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>; otherwise 0.","source":"Nonzero if the specified field data member has changed since calling `AddNew` or **Edit**; otherwise 0."},{"pos":[58840,58847],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[58851,59102],"content":"The data in all dirty field data members will be transferred to the record on the data source when the current record is updated by a call to the <bpt id=\"p1\">[</bpt>Update<ept id=\"p1\">](#crecordset__update)</ept> member function of <ph id=\"ph1\">`CRecordset`</ph> (following a call to <bpt id=\"p2\">**</bpt>Edit<ept id=\"p2\">**</ept> or <ph id=\"ph2\">`AddNew`</ph>).","source":"The data in all dirty field data members will be transferred to the record on the data source when the current record is updated by a call to the [Update](#crecordset__update) member function of `CRecordset` (following a call to **Edit** or `AddNew`)."},{"pos":[59110,59506],"content":"[!NOTE]\n This member function is not applicable on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, then `IsFieldDirty` will always return **FALSE** and will result in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" This member function is not applicable on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, then `IsFieldDirty` will always return **FALSE** and will result in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,394],"nodes":[{"content":"This member function is not applicable on recordsets that are using bulk row fetching.","pos":[1,87]},{"content":"If you have implemented bulk row fetching, then <ph id=\"ph1\">`IsFieldDirty`</ph> will always return <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept> and will result in a failed assertion.","pos":[88,218],"source":" If you have implemented bulk row fetching, then `IsFieldDirty` will always return **FALSE** and will result in a failed assertion."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[219,386],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"content":"Calling <ph id=\"ph1\">`IsFieldDirty`</ph> will reset the effects of preceding calls to <bpt id=\"p1\">[</bpt>SetFieldDirty<ept id=\"p1\">](#crecordset__setfielddirty)</ept> since the dirty status of the field is re-evaluated.","pos":[59513,59677],"source":"Calling `IsFieldDirty` will reset the effects of preceding calls to [SetFieldDirty](#crecordset__setfielddirty) since the dirty status of the field is re-evaluated."},{"content":"In the <ph id=\"ph1\">`AddNew`</ph> case, if the current field value differs from the pseudo null value, the field status is set dirty.","pos":[59678,59793],"source":" In the `AddNew` case, if the current field value differs from the pseudo null value, the field status is set dirty."},{"content":"In the <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> case, if the field value differs from the cached value, then the field status is set dirty.","pos":[59794,59901],"source":" In the **Edit** case, if the field value differs from the cached value, then the field status is set dirty."},{"pos":[59908,59994],"content":"<ph id=\"ph1\">`IsFieldDirty`</ph> is implemented through <bpt id=\"p1\">[</bpt>DoFieldExchange<ept id=\"p1\">](#crecordset__dofieldexchange)</ept>.","source":"`IsFieldDirty` is implemented through [DoFieldExchange](#crecordset__dofieldexchange)."},{"pos":[60001,60172],"content":"For more information on the dirty flag, see the article <bpt id=\"p1\">[</bpt>Recordset: How Recordsets Select Records (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)</ept>.","source":"For more information on the dirty flag, see the article [Recordset: How Recordsets Select Records (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)."},{"pos":[60182,60245],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__isfieldnull\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::IsFieldNull","linkify":"<a name=\"crecordset__isfieldnull\"></a>  CRecordset::IsFieldNull","source":"<a name=\"crecordset__isfieldnull\"></a>  CRecordset::IsFieldNull"},{"content":"Returns nonzero if the specified field in the current record is Null (has no value).","pos":[60249,60333]},{"pos":[60386,60396],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A pointer to the field data member whose status you want to check, or <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> to determine if any of the fields are Null.","pos":[60408,60530],"source":" A pointer to the field data member whose status you want to check, or **NULL** to determine if any of the fields are Null."},{"pos":[60540,60552],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the specified field data member is flagged as Null; otherwise 0.","pos":[60556,60631]},{"pos":[60641,60648],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Call this member function to determine whether the specified field data member of a recordset has been flagged as Null.","pos":[60652,60771]},{"content":"(In database terminology, Null means \"having no value\" and is not the same as <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> in C++.) If a field data member is flagged as Null, it is interpreted as a column of the current record for which there is no value.","pos":[60772,60991],"source":" (In database terminology, Null means \"having no value\" and is not the same as **NULL** in C++.) If a field data member is flagged as Null, it is interpreted as a column of the current record for which there is no value."},{"pos":[60999,61394],"content":"[!NOTE]\n This member function is not applicable on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, then `IsFieldNull` will always return **FALSE** and will result in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" This member function is not applicable on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, then `IsFieldNull` will always return **FALSE** and will result in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,393],"nodes":[{"content":"This member function is not applicable on recordsets that are using bulk row fetching.","pos":[1,87]},{"content":"If you have implemented bulk row fetching, then <ph id=\"ph1\">`IsFieldNull`</ph> will always return <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept> and will result in a failed assertion.","pos":[88,217],"source":" If you have implemented bulk row fetching, then `IsFieldNull` will always return **FALSE** and will result in a failed assertion."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[218,385],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"pos":[61401,61486],"content":"<ph id=\"ph1\">`IsFieldNull`</ph> is implemented through <bpt id=\"p1\">[</bpt>DoFieldExchange<ept id=\"p1\">](#crecordset__dofieldexchange)</ept>.","source":"`IsFieldNull` is implemented through [DoFieldExchange](#crecordset__dofieldexchange)."},{"pos":[61496,61567],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__isfieldnullable\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::IsFieldNullable","linkify":"<a name=\"crecordset__isfieldnullable\"></a>  CRecordset::IsFieldNullable","source":"<a name=\"crecordset__isfieldnullable\"></a>  CRecordset::IsFieldNullable"},{"content":"Returns nonzero if the specified field in the current record can be set to Null (having no value).","pos":[61571,61669]},{"pos":[61726,61736],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A pointer to the field data member whose status you want to check, or <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> to determine if any of the fields can be set to a Null value.","pos":[61748,61888],"source":" A pointer to the field data member whose status you want to check, or **NULL** to determine if any of the fields can be set to a Null value."},{"pos":[61898,61905],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[61909,62126],"content":"Call this member function to determine whether the specified field data member is \"nullable\" (can be set to a Null value; C++ <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> is not the same as Null, which, in database terminology, means \"having no value\").","source":"Call this member function to determine whether the specified field data member is \"nullable\" (can be set to a Null value; C++ **NULL** is not the same as Null, which, in database terminology, means \"having no value\")."},{"pos":[62134,62643],"content":"[!NOTE]\n If you have implemented bulk row fetching, you cannot call `IsFieldNullable`. Instead, call the [GetODBCFieldInfo](#crecordset__getodbcfieldinfo) member function to determine whether a field can be set to a Null value. Note that you can always call `GetODBCFieldInfo`, regardless of whether you have implemented bulk row fetching. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" If you have implemented bulk row fetching, you cannot call `IsFieldNullable`. Instead, call the [GetODBCFieldInfo](#crecordset__getodbcfieldinfo) member function to determine whether a field can be set to a Null value. Note that you can always call `GetODBCFieldInfo`, regardless of whether you have implemented bulk row fetching. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,507],"nodes":[{"content":"If you have implemented bulk row fetching, you cannot call <ph id=\"ph1\">`IsFieldNullable`</ph>.","pos":[1,78],"source":" If you have implemented bulk row fetching, you cannot call `IsFieldNullable`."},{"content":"Instead, call the <bpt id=\"p1\">[</bpt>GetODBCFieldInfo<ept id=\"p1\">](#crecordset__getodbcfieldinfo)</ept> member function to determine whether a field can be set to a Null value.","pos":[79,219],"source":" Instead, call the [GetODBCFieldInfo](#crecordset__getodbcfieldinfo) member function to determine whether a field can be set to a Null value."},{"content":"Note that you can always call <ph id=\"ph1\">`GetODBCFieldInfo`</ph>, regardless of whether you have implemented bulk row fetching.","pos":[220,331],"source":" Note that you can always call `GetODBCFieldInfo`, regardless of whether you have implemented bulk row fetching."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[332,499],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"content":"A field that cannot be Null must have a value.","pos":[62650,62696]},{"content":"If you attempt to set a such a field to Null when adding or updating a record, the data source rejects the addition or update, and <bpt id=\"p1\">[</bpt>Update<ept id=\"p1\">](#crecordset__update)</ept> will throw an exception.","pos":[62697,62882],"source":" If you attempt to set a such a field to Null when adding or updating a record, the data source rejects the addition or update, and [Update](#crecordset__update) will throw an exception."},{"content":"The exception occurs when you call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>, not when you call <bpt id=\"p2\">[</bpt>SetFieldNull<ept id=\"p2\">](#crecordset__setfieldnull)</ept>.","pos":[62883,62990],"source":" The exception occurs when you call **Update**, not when you call [SetFieldNull](#crecordset__setfieldnull)."},{"content":"Using <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> for the first argument of the function will apply the function only to <bpt id=\"p2\">**</bpt>outputColumn<ept id=\"p2\">**</ept> fields, not <bpt id=\"p3\">**</bpt>param<ept id=\"p3\">**</ept> fields.","pos":[62997,63129],"source":"Using **NULL** for the first argument of the function will apply the function only to **outputColumn** fields, not **param** fields."},{"content":"For instance, the call","pos":[63130,63152]},{"pos":[63159,63241],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#26<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#26](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)]"},{"pos":[63248,63335],"content":"will set only <bpt id=\"p1\">**</bpt>outputColumn<ept id=\"p1\">**</ept> fields to <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept>; <bpt id=\"p3\">**</bpt>param<ept id=\"p3\">**</ept> fields will be unaffected.","source":"will set only **outputColumn** fields to **NULL**; **param** fields will be unaffected."},{"pos":[63342,63463],"content":"To work on <bpt id=\"p1\">**</bpt>param<ept id=\"p1\">**</ept> fields, you must supply the actual address of the individual <bpt id=\"p2\">**</bpt>param<ept id=\"p2\">**</ept> you want to work on, such as:","source":"To work on **param** fields, you must supply the actual address of the individual **param** you want to work on, such as:"},{"pos":[63470,63552],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#27<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#27](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)]"},{"pos":[63559,63659],"content":"This means you cannot set all <bpt id=\"p1\">**</bpt>param<ept id=\"p1\">**</ept> fields to <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept>, as you can with <bpt id=\"p3\">**</bpt>outputColumn<ept id=\"p3\">**</ept> fields.","source":"This means you cannot set all **param** fields to **NULL**, as you can with **outputColumn** fields."},{"pos":[63666,63755],"content":"<ph id=\"ph1\">`IsFieldNullable`</ph> is implemented through <bpt id=\"p1\">[</bpt>DoFieldExchange<ept id=\"p1\">](#crecordset__dofieldexchange)</ept>.","source":"`IsFieldNullable` is implemented through [DoFieldExchange](#crecordset__dofieldexchange)."},{"pos":[63765,63818],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__isopen\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::IsOpen","linkify":"<a name=\"crecordset__isopen\"></a>  CRecordset::IsOpen","source":"<a name=\"crecordset__isopen\"></a>  CRecordset::IsOpen"},{"content":"Determines if the recordset is already open.","pos":[63822,63866]},{"pos":[63915,63927],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[63931,64120],"content":"Nonzero if the recordset object's <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](#crecordset__open)</ept> or <bpt id=\"p2\">[</bpt>Requery<ept id=\"p2\">](#crecordset__requery)</ept> member function has previously been called and the recordset has not been closed; otherwise 0.","source":"Nonzero if the recordset object's [Open](#crecordset__open) or [Requery](#crecordset__requery) member function has previously been called and the recordset has not been closed; otherwise 0."},{"pos":[64130,64185],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__m_hstmt\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::m_hstmt","linkify":"<a name=\"crecordset__m_hstmt\"></a>  CRecordset::m_hstmt","source":"<a name=\"crecordset__m_hstmt\"></a>  CRecordset::m_hstmt"},{"pos":[64189,64294],"content":"Contains a handle to the ODBC statement data structure, of type <bpt id=\"p1\">**</bpt>HSTMT<ept id=\"p1\">**</ept>, associated with the recordset.","source":"Contains a handle to the ODBC statement data structure, of type **HSTMT**, associated with the recordset."},{"pos":[64304,64311],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[64315,64381],"content":"Each query to an ODBC data source is associated with an <bpt id=\"p1\">**</bpt>HSTMT<ept id=\"p1\">**</ept>.","source":"Each query to an ODBC data source is associated with an **HSTMT**."},{"pos":[64389,64475],"content":"[!CAUTION]\n Do not use **m_hstmt** before [Open](#crecordset__open) has been called.","leadings":["","> "],"nodes":[{"content":"Do not use <bpt id=\"p1\">**</bpt>m_hstmt<ept id=\"p1\">**</ept> before <bpt id=\"p2\">[</bpt>Open<ept id=\"p2\">](#crecordset__open)</ept> has been called.","pos":[12,84],"source":" Do not use **m_hstmt** before [Open](#crecordset__open) has been called."}]},{"content":"Normally you do not need to access the <bpt id=\"p1\">**</bpt>HSTMT<ept id=\"p1\">**</ept> directly, but you might need it for direct execution of SQL statements.","pos":[64482,64602],"source":"Normally you do not need to access the **HSTMT** directly, but you might need it for direct execution of SQL statements."},{"content":"The <ph id=\"ph1\">`ExecuteSQL`</ph> member function of class <ph id=\"ph2\">`CDatabase`</ph> provides an example of using <bpt id=\"p1\">**</bpt>m_hstmt<ept id=\"p1\">**</ept>.","pos":[64603,64698],"source":" The `ExecuteSQL` member function of class `CDatabase` provides an example of using **m_hstmt**."},{"pos":[64708,64767],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__m_nfields\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::m_nFields","linkify":"<a name=\"crecordset__m_nfields\"></a>  CRecordset::m_nFields","source":"<a name=\"crecordset__m_nfields\"></a>  CRecordset::m_nFields"},{"content":"Contains the number of field data members in the recordset class; that is, the number of columns selected by the recordset from the data source.","pos":[64771,64915]},{"pos":[64925,64932],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The constructor for the recordset class must initialize <ph id=\"ph1\">`m_nFields`</ph> with the correct number.","pos":[64936,65028],"source":"The constructor for the recordset class must initialize `m_nFields` with the correct number."},{"content":"If you have not implemented bulk row fetching, ClassWizard writes this initialization for you when you use it to declare your recordset class.","pos":[65029,65171]},{"content":"You can also write it manually.","pos":[65172,65203]},{"content":"The framework uses this number to manage interaction between the field data members and the corresponding columns of the current record on the data source.","pos":[65210,65365]},{"pos":[65373,65663],"content":"[!CAUTION]\n This number must correspond to the number of \"output columns\" registered in `DoFieldExchange` or `DoBulkFieldExchange` after a call to [SetFieldType](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype) with the parameter **CFieldExchange::outputColumn**.","leadings":["","> "],"nodes":[{"content":"This number must correspond to the number of \"output columns\" registered in <ph id=\"ph1\">`DoFieldExchange`</ph> or <ph id=\"ph2\">`DoBulkFieldExchange`</ph> after a call to <bpt id=\"p1\">[</bpt>SetFieldType<ept id=\"p1\">](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype)</ept> with the parameter <bpt id=\"p2\">**</bpt>CFieldExchange::outputColumn<ept id=\"p2\">**</ept>.","pos":[12,288],"source":" This number must correspond to the number of \"output columns\" registered in `DoFieldExchange` or `DoBulkFieldExchange` after a call to [SetFieldType](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype) with the parameter **CFieldExchange::outputColumn**."}]},{"content":"You can bind columns dynamically, as explained in the article \"Recordset: Dynamically Binding Data Columns.\"","pos":[65670,65778]},{"content":"If you do so, you must increase the count in <ph id=\"ph1\">`m_nFields`</ph> to reflect the number of RFX or Bulk RFX function calls in your <ph id=\"ph2\">`DoFieldExchange`</ph> or <ph id=\"ph3\">`DoBulkFieldExchange`</ph> member function for the dynamically bound columns.","pos":[65779,65993],"source":" If you do so, you must increase the count in `m_nFields` to reflect the number of RFX or Bulk RFX function calls in your `DoFieldExchange` or `DoBulkFieldExchange` member function for the dynamically bound columns."},{"pos":[66000,66269],"content":"For more information, see the articles <bpt id=\"p1\">[</bpt>Recordset: Dynamically Binding Data Columns (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","source":"For more information, see the articles [Recordset: Dynamically Binding Data Columns (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md) and [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[66279,66286],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[66290,66393],"content":"See the article <bpt id=\"p1\">[</bpt>Record Field Exchange: Using RFX<ept id=\"p1\">](../../data/odbc/record-field-exchange-using-rfx.md)</ept>.","source":"See the article [Record Field Exchange: Using RFX](../../data/odbc/record-field-exchange-using-rfx.md)."},{"pos":[66403,66462],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__m_nparams\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::m_nParams","linkify":"<a name=\"crecordset__m_nparams\"></a>  CRecordset::m_nParams","source":"<a name=\"crecordset__m_nparams\"></a>  CRecordset::m_nParams"},{"content":"Contains the number of parameter data members in the recordset class; that is, the number of parameters passed with the recordset's query.","pos":[66466,66604]},{"pos":[66614,66621],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If your recordset class has any parameter data members, the constructor for the class must initialize <ph id=\"ph1\">`m_nParams`</ph> with the correct number.","pos":[66625,66763],"source":"If your recordset class has any parameter data members, the constructor for the class must initialize `m_nParams` with the correct number."},{"content":"The value of <ph id=\"ph1\">`m_nParams`</ph> defaults to 0.","pos":[66764,66803],"source":" The value of `m_nParams` defaults to 0."},{"content":"If you add parameter data members (which you must do manually) you must also manually add an initialization in the class constructor to reflect the number of parameters (which must be at least as large as the number of '' placeholders in your <bpt id=\"p1\">**</bpt>m_strFilter<ept id=\"p1\">**</ept> or <ph id=\"ph1\">`m_strSort`</ph> string).","pos":[66804,67086],"source":" If you add parameter data members (which you must do manually) you must also manually add an initialization in the class constructor to reflect the number of parameters (which must be at least as large as the number of '' placeholders in your **m_strFilter** or `m_strSort` string)."},{"content":"The framework uses this number when it parameterizes the recordset's query.","pos":[67093,67168]},{"pos":[67176,67558],"content":"[!CAUTION]\n This number must correspond to the number of \"params\" registered in `DoFieldExchange` or `DoBulkFieldExchange` after a call to [SetFieldType](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype) with a parameter value of **CFieldExchange::inputParam**, **CFieldExchange::param**, **CFieldExchange::outputParam**, or **CFieldExchange::inoutParam**.","leadings":["","> "],"nodes":[{"content":"This number must correspond to the number of \"params\" registered in <ph id=\"ph1\">`DoFieldExchange`</ph> or <ph id=\"ph2\">`DoBulkFieldExchange`</ph> after a call to <bpt id=\"p1\">[</bpt>SetFieldType<ept id=\"p1\">](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype)</ept> with a parameter value of <bpt id=\"p2\">**</bpt>CFieldExchange::inputParam<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>CFieldExchange::param<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>CFieldExchange::outputParam<ept id=\"p4\">**</ept>, or <bpt id=\"p5\">**</bpt>CFieldExchange::inoutParam<ept id=\"p5\">**</ept>.","pos":[12,380],"source":" This number must correspond to the number of \"params\" registered in `DoFieldExchange` or `DoBulkFieldExchange` after a call to [SetFieldType](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype) with a parameter value of **CFieldExchange::inputParam**, **CFieldExchange::param**, **CFieldExchange::outputParam**, or **CFieldExchange::inoutParam**."}]},{"pos":[67568,67575],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[67580,67797],"content":"See the articles <bpt id=\"p1\">[</bpt>Recordset: Parameterizing a Recordset (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Record Field Exchange: Using RFX<ept id=\"p2\">](../../data/odbc/record-field-exchange-using-rfx.md)</ept>.","source":"See the articles [Recordset: Parameterizing a Recordset (ODBC)](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md) and [Record Field Exchange: Using RFX](../../data/odbc/record-field-exchange-using-rfx.md)."},{"pos":[67807,67870],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__m_pdatabase\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::m_pDatabase","linkify":"<a name=\"crecordset__m_pdatabase\"></a>  CRecordset::m_pDatabase","source":"<a name=\"crecordset__m_pdatabase\"></a>  CRecordset::m_pDatabase"},{"pos":[67874,67977],"content":"Contains a pointer to the <ph id=\"ph1\">`CDatabase`</ph> object through which the recordset is connected to a data source.","source":"Contains a pointer to the `CDatabase` object through which the recordset is connected to a data source."},{"pos":[67987,67994],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This variable is set in two ways.","pos":[67998,68031]},{"content":"Typically, you pass a pointer to an already connected <ph id=\"ph1\">`CDatabase`</ph> object when you construct the recordset object.","pos":[68032,68145],"source":" Typically, you pass a pointer to an already connected `CDatabase` object when you construct the recordset object."},{"content":"If you pass <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> instead, <ph id=\"ph1\">`CRecordset`</ph> creates a <ph id=\"ph2\">`CDatabase`</ph> object for you and connects it.","pos":[68146,68242],"source":" If you pass **NULL** instead, `CRecordset` creates a `CDatabase` object for you and connects it."},{"content":"In either case, <ph id=\"ph1\">`CRecordset`</ph> stores the pointer in this variable.","pos":[68243,68308],"source":" In either case, `CRecordset` stores the pointer in this variable."},{"content":"Normally you will not directly need to use the pointer stored in <bpt id=\"p1\">**</bpt>m_pDatabase<ept id=\"p1\">**</ept>.","pos":[68315,68396],"source":"Normally you will not directly need to use the pointer stored in **m_pDatabase**."},{"content":"If you write your own extensions to <ph id=\"ph1\">`CRecordset`</ph>, however, you might need to use the pointer.","pos":[68397,68490],"source":" If you write your own extensions to `CRecordset`, however, you might need to use the pointer."},{"content":"For example, you might need the pointer if you throw your own <ph id=\"ph1\">`CDBException`</ph>s.","pos":[68491,68569],"source":" For example, you might need the pointer if you throw your own `CDBException`s."},{"content":"Or you might need it if you need to do something using the same <ph id=\"ph1\">`CDatabase`</ph> object, such as running transactions, setting timeouts, or calling the <ph id=\"ph2\">`ExecuteSQL`</ph> member function of class <ph id=\"ph3\">`CDatabase`</ph> to execute SQL statements directly.","pos":[68570,68802],"source":" Or you might need it if you need to do something using the same `CDatabase` object, such as running transactions, setting timeouts, or calling the `ExecuteSQL` member function of class `CDatabase` to execute SQL statements directly."},{"pos":[68812,68875],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__m_strfilter\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::m_strFilter","linkify":"<a name=\"crecordset__m_strfilter\"></a>  CRecordset::m_strFilter","source":"<a name=\"crecordset__m_strfilter\"></a>  CRecordset::m_strFilter"},{"pos":[68879,69047],"content":"After you construct the recordset object, but before you call its <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> member function, use this data member to store a <ph id=\"ph1\">`CString`</ph> containing a SQL <bpt id=\"p2\">**</bpt>WHERE<ept id=\"p2\">**</ept> clause.","source":"After you construct the recordset object, but before you call its **Open** member function, use this data member to store a `CString` containing a SQL **WHERE** clause."},{"pos":[69057,69064],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The recordset uses this string to constrain (or filter) the records it selects during the <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>Requery<ept id=\"p2\">**</ept> call.","pos":[69068,69187],"source":"The recordset uses this string to constrain (or filter) the records it selects during the **Open** or **Requery** call."},{"content":"This is useful for selecting a subset of records, such as \"all salespersons based in California\" (\"state = CA\").","pos":[69188,69300]},{"content":"The ODBC SQL syntax for a <bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> clause is","pos":[69301,69346],"source":" The ODBC SQL syntax for a **WHERE** clause is"},{"content":"Note that you do not include the <bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> keyword in your string.","pos":[69384,69450],"source":"Note that you do not include the **WHERE** keyword in your string."},{"content":"The framework supplies it.","pos":[69451,69477]},{"content":"You can also parameterize your filter string by placing '' placeholders in it, declaring a parameter data member in your class for each placeholder, and passing parameters to the recordset at run time.","pos":[69484,69685]},{"content":"This lets you construct the filter at run time.","pos":[69686,69733]},{"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Recordset: Parameterizing a Recordset (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md)</ept>.","pos":[69734,69881],"source":" For more information, see the article [Recordset: Parameterizing a Recordset (ODBC)](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md)."},{"content":"For more information about SQL <bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> clauses, see the article <bpt id=\"p2\">[</bpt>SQL<ept id=\"p2\">](../../data/odbc/sql.md)</ept>.","pos":[69888,69984],"source":"For more information about SQL **WHERE** clauses, see the article [SQL](../../data/odbc/sql.md)."},{"content":"For more information about selecting and filtering records, see the article <bpt id=\"p1\">[</bpt>Recordset: Filtering Records (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-filtering-records-odbc.md)</ept>.","pos":[69985,70152],"source":" For more information about selecting and filtering records, see the article [Recordset: Filtering Records (ODBC)](../../data/odbc/recordset-filtering-records-odbc.md)."},{"pos":[70162,70169],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[70173,70255],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#30<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_12.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#30](../../mfc/codesnippet/cpp/crecordset-class_12.cpp)]"},{"pos":[70265,70324],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__m_strsort\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::m_strSort","linkify":"<a name=\"crecordset__m_strsort\"></a>  CRecordset::m_strSort","source":"<a name=\"crecordset__m_strsort\"></a>  CRecordset::m_strSort"},{"pos":[70328,70499],"content":"After you construct the recordset object, but before you call its <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> member function, use this data member to store a <ph id=\"ph1\">`CString`</ph> containing a SQL <bpt id=\"p2\">**</bpt>ORDER BY<ept id=\"p2\">**</ept> clause.","source":"After you construct the recordset object, but before you call its **Open** member function, use this data member to store a `CString` containing a SQL **ORDER BY** clause."},{"pos":[70509,70516],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The recordset uses this string to sort the records it selects during the <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>Requery<ept id=\"p2\">**</ept> call.","pos":[70520,70622],"source":"The recordset uses this string to sort the records it selects during the **Open** or **Requery** call."},{"content":"You can use this feature to sort a recordset on one or more columns.","pos":[70623,70691]},{"content":"The ODBC SQL syntax for an <bpt id=\"p1\">**</bpt>ORDER BY<ept id=\"p1\">**</ept> clause is","pos":[70692,70741],"source":" The ODBC SQL syntax for an **ORDER BY** clause is"},{"content":"where a sort-specification is an integer or a column name.","pos":[70810,70868]},{"content":"You can also specify ascending or descending order (the order is ascending by default) by appending \"ASC\" or \"DESC\" to the column list in the sort string.","pos":[70869,71023]},{"content":"The selected records are sorted first by the first column listed, then by the second, and so on.","pos":[71024,71120]},{"content":"For example, you might order a \"Customers\" recordset by last name, then first name.","pos":[71121,71204]},{"content":"The number of columns you can list depends on the data source.","pos":[71205,71267]},{"content":"For more information, see the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph><bpt id=\"p1\">*</bpt>.<ept id=\"p1\">*</ept>","pos":[71268,71352],"source":" For more information, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]*.*"},{"content":"Note that you do not include the <bpt id=\"p1\">**</bpt>ORDER BY<ept id=\"p1\">**</ept> keyword in your string.","pos":[71359,71428],"source":"Note that you do not include the **ORDER BY** keyword in your string."},{"content":"The framework supplies it.","pos":[71429,71455]},{"content":"For more information about SQL clauses, see the article <bpt id=\"p1\">[</bpt>SQL<ept id=\"p1\">](../../data/odbc/sql.md)</ept>.","pos":[71462,71548],"source":"For more information about SQL clauses, see the article [SQL](../../data/odbc/sql.md)."},{"content":"For more information about sorting records, see the article <bpt id=\"p1\">[</bpt>Recordset: Sorting Records (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-sorting-records-odbc.md)</ept>.","pos":[71549,71696],"source":" For more information about sorting records, see the article [Recordset: Sorting Records (ODBC)](../../data/odbc/recordset-sorting-records-odbc.md)."},{"pos":[71706,71713],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[71717,71799],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#31<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_13.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#31](../../mfc/codesnippet/cpp/crecordset-class_13.cpp)]"},{"pos":[71809,71858],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__move\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::Move","linkify":"<a name=\"crecordset__move\"></a>  CRecordset::Move","source":"<a name=\"crecordset__move\"></a>  CRecordset::Move"},{"content":"Moves the current record pointer within the recordset, either forward or backward.","pos":[71862,71944]},{"pos":[72049,72059],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The number of rows to move forward or backward.","pos":[72074,72121]},{"content":"Positive values move forward, toward the end of the recordset.","pos":[72122,72184]},{"content":"Negative values move backward, toward the beginning.","pos":[72185,72237]},{"content":"Determines the rowset that <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> will fetch.","pos":[72260,72307],"source":" Determines the rowset that **Move** will fetch."},{"content":"For details, see Remarks.","pos":[72308,72333]},{"pos":[72343,72350],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[72354,72571],"content":"If you pass a value of 0 for <ph id=\"ph1\">`nRows`</ph>, <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> refreshes the current record; <bpt id=\"p2\">**</bpt>Move<ept id=\"p2\">**</ept> will end any current <ph id=\"ph2\">`AddNew`</ph> or <bpt id=\"p3\">**</bpt>Edit<ept id=\"p3\">**</ept> mode, and will restore the current record's value before <ph id=\"ph3\">`AddNew`</ph> or <bpt id=\"p4\">**</bpt>Edit<ept id=\"p4\">**</ept> was called.","source":"If you pass a value of 0 for `nRows`, **Move** refreshes the current record; **Move** will end any current `AddNew` or **Edit** mode, and will restore the current record's value before `AddNew` or **Edit** was called."},{"pos":[72579,73065],"content":"[!NOTE]\n When you move through a recordset, you cannot skip deleted records. See [CRecordset::IsDeleted](#crecordset__isdeleted) for more information. When you open a `CRecordset` with the **skipDeletedRecords** option set, **Move** asserts if the `nRows` parameter is 0. This behavior prevents the refresh of rows that are deleted by other client applications using the same data. See the `dwOption` parameter in [Open](#crecordset__open) for a description of **skipDeletedRecords**.","leadings":["","> "],"nodes":[{"content":" When you move through a recordset, you cannot skip deleted records. See [CRecordset::IsDeleted](#crecordset__isdeleted) for more information. When you open a `CRecordset` with the **skipDeletedRecords** option set, **Move** asserts if the `nRows` parameter is 0. This behavior prevents the refresh of rows that are deleted by other client applications using the same data. See the `dwOption` parameter in [Open](#crecordset__open) for a description of **skipDeletedRecords**.","pos":[8,484],"nodes":[{"content":"When you move through a recordset, you cannot skip deleted records.","pos":[1,68]},{"content":"See <bpt id=\"p1\">[</bpt>CRecordset::IsDeleted<ept id=\"p1\">](#crecordset__isdeleted)</ept> for more information.","pos":[69,142],"source":" See [CRecordset::IsDeleted](#crecordset__isdeleted) for more information."},{"content":"When you open a <ph id=\"ph1\">`CRecordset`</ph> with the <bpt id=\"p1\">**</bpt>skipDeletedRecords<ept id=\"p1\">**</ept> option set, <bpt id=\"p2\">**</bpt>Move<ept id=\"p2\">**</ept> asserts if the <ph id=\"ph2\">`nRows`</ph> parameter is 0.","pos":[143,263],"source":" When you open a `CRecordset` with the **skipDeletedRecords** option set, **Move** asserts if the `nRows` parameter is 0."},{"content":"This behavior prevents the refresh of rows that are deleted by other client applications using the same data.","pos":[264,373]},{"content":"See the <ph id=\"ph1\">`dwOption`</ph> parameter in <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](#crecordset__open)</ept> for a description of <bpt id=\"p2\">**</bpt>skipDeletedRecords<ept id=\"p2\">**</ept>.","pos":[374,476],"source":" See the `dwOption` parameter in [Open](#crecordset__open) for a description of **skipDeletedRecords**."}]}]},{"content":"<bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> repositions the recordset by rowsets.","pos":[73072,73118],"source":"**Move** repositions the recordset by rowsets."},{"content":"Based on the values for <ph id=\"ph1\">`nRows`</ph> and <ph id=\"ph2\">`wFetchType`</ph>, <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> fetches the appropriate rowset and then makes the first record in that rowset the current record.","pos":[73119,73275],"source":" Based on the values for `nRows` and `wFetchType`, **Move** fetches the appropriate rowset and then makes the first record in that rowset the current record."},{"content":"If you have not implemented bulk row fetching, then the rowset size is always 1.","pos":[73276,73356]},{"content":"When fetching a rowset, <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> directly calls the <bpt id=\"p2\">[</bpt>CheckRowsetError<ept id=\"p2\">](#crecordset__checkrowseterror)</ept> member function to handle any errors resulting from the fetch.","pos":[73357,73521],"source":" When fetching a rowset, **Move** directly calls the [CheckRowsetError](#crecordset__checkrowseterror) member function to handle any errors resulting from the fetch."},{"content":"Depending on the values you pass, <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> is equivalent to other <ph id=\"ph1\">`CRecordset`</ph> member functions.","pos":[73528,73624],"source":"Depending on the values you pass, **Move** is equivalent to other `CRecordset` member functions."},{"content":"In particular, the value of <ph id=\"ph1\">`wFetchType`</ph> may indicate a member function that is more intuitive and often the preferred method for moving the current record.","pos":[73625,73781],"source":" In particular, the value of `wFetchType` may indicate a member function that is more intuitive and often the preferred method for moving the current record."},{"pos":[73788,73988],"content":"The following table lists the possible values for <ph id=\"ph1\">`wFetchType`</ph>, the rowset that <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> will fetch based on <ph id=\"ph2\">`wFetchType`</ph> and <ph id=\"ph3\">`nRows`</ph>, and any equivalent member function corresponding to <ph id=\"ph4\">`wFetchType`</ph>.","source":"The following table lists the possible values for `wFetchType`, the rowset that **Move** will fetch based on `wFetchType` and `nRows`, and any equivalent member function corresponding to `wFetchType`."},{"content":"wFetchType","pos":[73995,74005]},{"content":"Fetched rowset","pos":[74006,74020]},{"content":"Equivalent member function","pos":[74021,74047]},{"pos":[74127,74167],"content":"<ph id=\"ph1\">`SQL_FETCH_RELATIVE`</ph> (the default value)","source":"`SQL_FETCH_RELATIVE` (the default value)"},{"pos":[74168,74244],"content":"The rowset starting <ph id=\"ph1\">`nRows`</ph> row(s) from the first row in the current rowset.","source":"The rowset starting `nRows` row(s) from the first row in the current rowset."},{"pos":[74267,74303],"content":"The next rowset; <ph id=\"ph1\">`nRows`</ph> is ignored.","source":"The next rowset; `nRows` is ignored."},{"pos":[74304,74337],"content":"<bpt id=\"p1\">[</bpt>MoveNext<ept id=\"p1\">](#crecordset__movenext)</ept>","source":"[MoveNext](#crecordset__movenext)"},{"pos":[74360,74400],"content":"The previous rowset; <ph id=\"ph1\">`nRows`</ph> is ignored.","source":"The previous rowset; `nRows` is ignored."},{"pos":[74401,74434],"content":"<bpt id=\"p1\">[</bpt>MovePrev<ept id=\"p1\">](#crecordset__moveprev)</ept>","source":"[MovePrev](#crecordset__moveprev)"},{"pos":[74457,74511],"content":"The first rowset in the recordset; <ph id=\"ph1\">`nRows`</ph> is ignored.","source":"The first rowset in the recordset; `nRows` is ignored."},{"pos":[74512,74547],"content":"<bpt id=\"p1\">[</bpt>MoveFirst<ept id=\"p1\">](#crecordset__movefirst)</ept>","source":"[MoveFirst](#crecordset__movefirst)"},{"pos":[74569,74631],"content":"The last complete rowset in the recordset; <ph id=\"ph1\">`nRows`</ph> is ignored.","source":"The last complete rowset in the recordset; `nRows` is ignored."},{"pos":[74632,74665],"content":"<bpt id=\"p1\">[</bpt>MoveLast<ept id=\"p1\">](#crecordset__movelast)</ept>","source":"[MoveLast](#crecordset__movelast)"},{"content":"If <ph id=\"ph1\">`nRows`</ph> &gt; 0, the rowset starting <ph id=\"ph2\">`nRows`</ph> row(s) from the beginning of the recordset.","pos":[74691,74778],"source":"If `nRows` > 0, the rowset starting `nRows` row(s) from the beginning of the recordset."},{"content":"If <ph id=\"ph1\">`nRows`</ph> &lt; 0, the rowset starting <ph id=\"ph2\">`nRows`</ph> row(s) from the end of the recordset.","pos":[74779,74860],"source":" If `nRows` < 0, the rowset starting `nRows` row(s) from the end of the recordset."},{"content":"If <ph id=\"ph1\">`nRows`</ph> = 0, then a beginning-of-file (BOF) condition is returned.","pos":[74861,74930],"source":" If `nRows` = 0, then a beginning-of-file (BOF) condition is returned."},{"pos":[74931,74986],"content":"<bpt id=\"p1\">[</bpt>SetAbsolutePosition<ept id=\"p1\">](#crecordset__setabsoluteposition)</ept>","source":"[SetAbsolutePosition](#crecordset__setabsoluteposition)"},{"pos":[75012,75087],"content":"The rowset starting at the row whose bookmark value corresponds to <ph id=\"ph1\">`nRows`</ph>.","source":"The rowset starting at the row whose bookmark value corresponds to `nRows`."},{"pos":[75088,75127],"content":"<bpt id=\"p1\">[</bpt>SetBookmark<ept id=\"p1\">](#crecordset__setbookmark)</ept>","source":"[SetBookmark](#crecordset__setbookmark)"},{"pos":[75136,75248],"content":"[!NOTE]\n For foward-only recordsets, **Move** is only valid with a value of `SQL_FETCH_NEXT` for `wFetchType`.","leadings":["","> "],"nodes":[{"content":"For foward-only recordsets, <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> is only valid with a value of <ph id=\"ph1\">`SQL_FETCH_NEXT`</ph> for <ph id=\"ph2\">`wFetchType`</ph>.","pos":[9,110],"source":" For foward-only recordsets, **Move** is only valid with a value of `SQL_FETCH_NEXT` for `wFetchType`."}]},{"pos":[75256,75457],"content":"[!CAUTION]\n Calling **Move** throws an exception if the recordset has no records. To determine whether the recordset has any records, call [IsBOF](#crecordset__isbof) and [IsEOF](#crecordset__iseof).","leadings":["","> "],"nodes":[{"content":" Calling **Move** throws an exception if the recordset has no records. To determine whether the recordset has any records, call [IsBOF](#crecordset__isbof) and [IsEOF](#crecordset__iseof).","pos":[11,199],"nodes":[{"content":"Calling <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> throws an exception if the recordset has no records.","pos":[1,70],"source":" Calling **Move** throws an exception if the recordset has no records."},{"content":"To determine whether the recordset has any records, call <bpt id=\"p1\">[</bpt>IsBOF<ept id=\"p1\">](#crecordset__isbof)</ept> and <bpt id=\"p2\">[</bpt>IsEOF<ept id=\"p2\">](#crecordset__iseof)</ept>.","pos":[71,188],"source":" To determine whether the recordset has any records, call [IsBOF](#crecordset__isbof) and [IsEOF](#crecordset__iseof)."}]}]},{"pos":[75465,75772],"content":"[!NOTE]\n If you have scrolled past the beginning or end of the recordset ( `IsBOF` or `IsEOF` returns nonzero), calling a **Move** function will possibly throw a `CDBException`. For example, if `IsEOF` returns nonzero and `IsBOF` does not, then `MoveNext` will throw an exception, but `MovePrev` will not.","leadings":["","> "],"nodes":[{"content":" If you have scrolled past the beginning or end of the recordset ( `IsBOF` or `IsEOF` returns nonzero), calling a **Move** function will possibly throw a `CDBException`. For example, if `IsEOF` returns nonzero and `IsBOF` does not, then `MoveNext` will throw an exception, but `MovePrev` will not.","pos":[8,305],"nodes":[{"content":"If you have scrolled past the beginning or end of the recordset ( <ph id=\"ph1\">`IsBOF`</ph> or <ph id=\"ph2\">`IsEOF`</ph> returns nonzero), calling a <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> function will possibly throw a <ph id=\"ph3\">`CDBException`</ph>.","pos":[1,169],"source":" If you have scrolled past the beginning or end of the recordset ( `IsBOF` or `IsEOF` returns nonzero), calling a **Move** function will possibly throw a `CDBException`."},{"content":"For example, if <ph id=\"ph1\">`IsEOF`</ph> returns nonzero and <ph id=\"ph2\">`IsBOF`</ph> does not, then <ph id=\"ph3\">`MoveNext`</ph> will throw an exception, but <ph id=\"ph4\">`MovePrev`</ph> will not.","pos":[170,297],"source":" For example, if `IsEOF` returns nonzero and `IsBOF` does not, then `MoveNext` will throw an exception, but `MovePrev` will not."}]}]},{"pos":[75780,75901],"content":"[!NOTE]\n If you call **Move** while the current record is being updated or added, the updates are lost without warning.","leadings":["","> "],"nodes":[{"content":"If you call <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> while the current record is being updated or added, the updates are lost without warning.","pos":[9,119],"source":" If you call **Move** while the current record is being updated or added, the updates are lost without warning."}]},{"content":"For more information about recordset navigation, see the articles <bpt id=\"p1\">[</bpt>Recordset: Scrolling (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.","pos":[75908,76174],"source":"For more information about recordset navigation, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[76175,76342],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"content":"For related information, see the ODBC API function <bpt id=\"p1\">**</bpt>SQLExtendedFetch<ept id=\"p1\">**</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[76343,76474],"source":" For related information, see the ODBC API function **SQLExtendedFetch** in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[76484,76491],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[76495,76577],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#28<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_14.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#28](../../mfc/codesnippet/cpp/crecordset-class_14.cpp)]"},{"pos":[76587,76646],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__movefirst\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::MoveFirst","linkify":"<a name=\"crecordset__movefirst\"></a>  CRecordset::MoveFirst","source":"<a name=\"crecordset__movefirst\"></a>  CRecordset::MoveFirst"},{"content":"Makes the first record in the first rowset the current record.","pos":[76650,76712]},{"pos":[76755,76762],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Regardless of whether bulk row fetching has been implemented, this will always be the first record in the recordset.","pos":[76766,76882]},{"content":"You do not have to call <bpt id=\"p1\">**</bpt>MoveFirst<ept id=\"p1\">**</ept> immediately after you open the recordset.","pos":[76889,76968],"source":"You do not have to call **MoveFirst** immediately after you open the recordset."},{"content":"At that time, the first record (if any) is automatically the current record.","pos":[76969,77045]},{"pos":[77053,77126],"content":"[!NOTE]\n This member function is not valid for forward-only recordsets.","leadings":["","> "],"nodes":[{"content":"This member function is not valid for forward-only recordsets.","pos":[9,71]}]},{"pos":[77134,77285],"content":"[!NOTE]\n When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.","leadings":["","> "],"nodes":[{"content":" When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.","pos":[8,149],"nodes":[{"content":"When you move through a recordset, you cannot skip deleted records.","pos":[1,68]},{"content":"See the <bpt id=\"p1\">[</bpt>IsDeleted<ept id=\"p1\">](#crecordset__isdeleted)</ept> member function for details.","pos":[69,141],"source":" See the [IsDeleted](#crecordset__isdeleted) member function for details."}]}]},{"pos":[77293,77475],"content":"[!CAUTION]\n Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.","leadings":["","> "],"nodes":[{"content":" Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.","pos":[11,180],"nodes":[{"content":"Calling any of the <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> functions throws an exception if the recordset has no records.","pos":[1,91],"source":" Calling any of the **Move** functions throws an exception if the recordset has no records."},{"content":"To determine whether the recordset has any records, call <ph id=\"ph1\">`IsBOF`</ph> and <ph id=\"ph2\">`IsEOF`</ph>.","pos":[92,169],"source":" To determine whether the recordset has any records, call `IsBOF` and `IsEOF`."}]}]},{"pos":[77483,77625],"content":"[!NOTE]\n If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning.","leadings":["","> "],"nodes":[{"content":"If you call any of the <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> functions while the current record is being updated or added, the updates are lost without warning.","pos":[9,140],"source":" If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning."}]},{"content":"For more information about recordset navigation, see the articles <bpt id=\"p1\">[</bpt>Recordset: Scrolling (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.","pos":[77632,77898],"source":"For more information about recordset navigation, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[77899,78066],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[78076,78083],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[78088,78136],"content":"See the example for <bpt id=\"p1\">[</bpt>IsBOF<ept id=\"p1\">](#crecordset__isbof)</ept>.","source":"See the example for [IsBOF](#crecordset__isbof)."},{"pos":[78146,78203],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__movelast\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::MoveLast","linkify":"<a name=\"crecordset__movelast\"></a>  CRecordset::MoveLast","source":"<a name=\"crecordset__movelast\"></a>  CRecordset::MoveLast"},{"content":"Makes the first record in the last complete rowset the current record.","pos":[78207,78277]},{"pos":[78319,78326],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[78330,78479],"content":"If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so <ph id=\"ph1\">`MoveLast`</ph> simply moves to the last record in the recordset.","source":"If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so `MoveLast` simply moves to the last record in the recordset."},{"pos":[78487,78560],"content":"[!NOTE]\n This member function is not valid for forward-only recordsets.","leadings":["","> "],"nodes":[{"content":"This member function is not valid for forward-only recordsets.","pos":[9,71]}]},{"pos":[78568,78719],"content":"[!NOTE]\n When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.","leadings":["","> "],"nodes":[{"content":" When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.","pos":[8,149],"nodes":[{"content":"When you move through a recordset, you cannot skip deleted records.","pos":[1,68]},{"content":"See the <bpt id=\"p1\">[</bpt>IsDeleted<ept id=\"p1\">](#crecordset__isdeleted)</ept> member function for details.","pos":[69,141],"source":" See the [IsDeleted](#crecordset__isdeleted) member function for details."}]}]},{"pos":[78727,78909],"content":"[!CAUTION]\n Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.","leadings":["","> "],"nodes":[{"content":" Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.","pos":[11,180],"nodes":[{"content":"Calling any of the <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> functions throws an exception if the recordset has no records.","pos":[1,91],"source":" Calling any of the **Move** functions throws an exception if the recordset has no records."},{"content":"To determine whether the recordset has any records, call <ph id=\"ph1\">`IsBOF`</ph> and <ph id=\"ph2\">`IsEOF`</ph>.","pos":[92,169],"source":" To determine whether the recordset has any records, call `IsBOF` and `IsEOF`."}]}]},{"pos":[78917,79059],"content":"[!NOTE]\n If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning.","leadings":["","> "],"nodes":[{"content":"If you call any of the <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> functions while the current record is being updated or added, the updates are lost without warning.","pos":[9,140],"source":" If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning."}]},{"content":"For more information about recordset navigation, see the articles <bpt id=\"p1\">[</bpt>Recordset: Scrolling (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.","pos":[79066,79332],"source":"For more information about recordset navigation, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[79333,79500],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[79510,79517],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[79522,79570],"content":"See the example for <bpt id=\"p1\">[</bpt>IsBOF<ept id=\"p1\">](#crecordset__isbof)</ept>.","source":"See the example for [IsBOF](#crecordset__isbof)."},{"pos":[79580,79637],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__movenext\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::MoveNext","linkify":"<a name=\"crecordset__movenext\"></a>  CRecordset::MoveNext","source":"<a name=\"crecordset__movenext\"></a>  CRecordset::MoveNext"},{"content":"Makes the first record in the next rowset the current record.","pos":[79641,79702]},{"pos":[79744,79751],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[79755,79887],"content":"If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so <ph id=\"ph1\">`MoveNext`</ph> simply moves to the next record.","source":"If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so `MoveNext` simply moves to the next record."},{"pos":[79895,80046],"content":"[!NOTE]\n When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.","leadings":["","> "],"nodes":[{"content":" When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.","pos":[8,149],"nodes":[{"content":"When you move through a recordset, you cannot skip deleted records.","pos":[1,68]},{"content":"See the <bpt id=\"p1\">[</bpt>IsDeleted<ept id=\"p1\">](#crecordset__isdeleted)</ept> member function for details.","pos":[69,141],"source":" See the [IsDeleted](#crecordset__isdeleted) member function for details."}]}]},{"pos":[80054,80236],"content":"[!CAUTION]\n Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.","leadings":["","> "],"nodes":[{"content":" Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.","pos":[11,180],"nodes":[{"content":"Calling any of the <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> functions throws an exception if the recordset has no records.","pos":[1,91],"source":" Calling any of the **Move** functions throws an exception if the recordset has no records."},{"content":"To determine whether the recordset has any records, call <ph id=\"ph1\">`IsBOF`</ph> and <ph id=\"ph2\">`IsEOF`</ph>.","pos":[92,169],"source":" To determine whether the recordset has any records, call `IsBOF` and `IsEOF`."}]}]},{"pos":[80244,80478],"content":"[!NOTE]\n It is also recommended that you call `IsEOF` before calling `MoveNext`. For example, if you have scrolled past the end of the recordset, `IsEOF` will return nonzero; a subsequent call to `MoveNext` would throw an exception.","leadings":["","> "],"nodes":[{"content":" It is also recommended that you call `IsEOF` before calling `MoveNext`. For example, if you have scrolled past the end of the recordset, `IsEOF` will return nonzero; a subsequent call to `MoveNext` would throw an exception.","pos":[8,232],"nodes":[{"content":"It is also recommended that you call <ph id=\"ph1\">`IsEOF`</ph> before calling <ph id=\"ph2\">`MoveNext`</ph>.","pos":[1,72],"source":" It is also recommended that you call `IsEOF` before calling `MoveNext`."},{"content":"For example, if you have scrolled past the end of the recordset, <ph id=\"ph1\">`IsEOF`</ph> will return nonzero; a subsequent call to <ph id=\"ph2\">`MoveNext`</ph> would throw an exception.","pos":[73,224],"source":" For example, if you have scrolled past the end of the recordset, `IsEOF` will return nonzero; a subsequent call to `MoveNext` would throw an exception."}]}]},{"pos":[80486,80628],"content":"[!NOTE]\n If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning.","leadings":["","> "],"nodes":[{"content":"If you call any of the <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> functions while the current record is being updated or added, the updates are lost without warning.","pos":[9,140],"source":" If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning."}]},{"content":"For more information about recordset navigation, see the articles <bpt id=\"p1\">[</bpt>Recordset: Scrolling (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.","pos":[80635,80901],"source":"For more information about recordset navigation, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[80902,81069],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[81079,81086],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[81091,81139],"content":"See the example for <bpt id=\"p1\">[</bpt>IsBOF<ept id=\"p1\">](#crecordset__isbof)</ept>.","source":"See the example for [IsBOF](#crecordset__isbof)."},{"pos":[81149,81206],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__moveprev\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::MovePrev","linkify":"<a name=\"crecordset__moveprev\"></a>  CRecordset::MovePrev","source":"<a name=\"crecordset__moveprev\"></a>  CRecordset::MovePrev"},{"content":"Makes the first record in the previous rowset the current record.","pos":[81210,81275]},{"pos":[81317,81324],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[81328,81464],"content":"If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so <ph id=\"ph1\">`MovePrev`</ph> simply moves to the previous record.","source":"If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so `MovePrev` simply moves to the previous record."},{"pos":[81472,81545],"content":"[!NOTE]\n This member function is not valid for forward-only recordsets.","leadings":["","> "],"nodes":[{"content":"This member function is not valid for forward-only recordsets.","pos":[9,71]}]},{"pos":[81553,81704],"content":"[!NOTE]\n When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.","leadings":["","> "],"nodes":[{"content":" When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.","pos":[8,149],"nodes":[{"content":"When you move through a recordset, you cannot skip deleted records.","pos":[1,68]},{"content":"See the <bpt id=\"p1\">[</bpt>IsDeleted<ept id=\"p1\">](#crecordset__isdeleted)</ept> member function for details.","pos":[69,141],"source":" See the [IsDeleted](#crecordset__isdeleted) member function for details."}]}]},{"pos":[81712,81894],"content":"[!CAUTION]\n Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.","leadings":["","> "],"nodes":[{"content":" Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.","pos":[11,180],"nodes":[{"content":"Calling any of the <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> functions throws an exception if the recordset has no records.","pos":[1,91],"source":" Calling any of the **Move** functions throws an exception if the recordset has no records."},{"content":"To determine whether the recordset has any records, call <ph id=\"ph1\">`IsBOF`</ph> and <ph id=\"ph2\">`IsEOF`</ph>.","pos":[92,169],"source":" To determine whether the recordset has any records, call `IsBOF` and `IsEOF`."}]}]},{"pos":[81902,82146],"content":"[!NOTE]\n It is also recommended that you call `IsBOF` before calling `MovePrev`. For example, if you have scrolled ahead of the beginning of the recordset, `IsBOF` will return nonzero; a subsequent call to `MovePrev` would throw an exception.","leadings":["","> "],"nodes":[{"content":" It is also recommended that you call `IsBOF` before calling `MovePrev`. For example, if you have scrolled ahead of the beginning of the recordset, `IsBOF` will return nonzero; a subsequent call to `MovePrev` would throw an exception.","pos":[8,242],"nodes":[{"content":"It is also recommended that you call <ph id=\"ph1\">`IsBOF`</ph> before calling <ph id=\"ph2\">`MovePrev`</ph>.","pos":[1,72],"source":" It is also recommended that you call `IsBOF` before calling `MovePrev`."},{"content":"For example, if you have scrolled ahead of the beginning of the recordset, <ph id=\"ph1\">`IsBOF`</ph> will return nonzero; a subsequent call to <ph id=\"ph2\">`MovePrev`</ph> would throw an exception.","pos":[73,234],"source":" For example, if you have scrolled ahead of the beginning of the recordset, `IsBOF` will return nonzero; a subsequent call to `MovePrev` would throw an exception."}]}]},{"pos":[82154,82296],"content":"[!NOTE]\n If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning.","leadings":["","> "],"nodes":[{"content":"If you call any of the <bpt id=\"p1\">**</bpt>Move<ept id=\"p1\">**</ept> functions while the current record is being updated or added, the updates are lost without warning.","pos":[9,140],"source":" If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning."}]},{"content":"For more information about recordset navigation, see the articles <bpt id=\"p1\">[</bpt>Recordset: Scrolling (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.","pos":[82303,82569],"source":"For more information about recordset navigation, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[82570,82737],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[82747,82754],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[82759,82807],"content":"See the example for <bpt id=\"p1\">[</bpt>IsBOF<ept id=\"p1\">](#crecordset__isbof)</ept>.","source":"See the example for [IsBOF](#crecordset__isbof)."},{"pos":[82817,82882],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__onsetoptions\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::OnSetOptions","linkify":"<a name=\"crecordset__onsetoptions\"></a>  CRecordset::OnSetOptions","source":"<a name=\"crecordset__onsetoptions\"></a>  CRecordset::OnSetOptions"},{"content":"Called to set options (used on selection) for the specified ODBC statement.","pos":[82886,82961]},{"pos":[83026,83036],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The <bpt id=\"p1\">**</bpt>HSTMT<ept id=\"p1\">**</ept> of the ODBC statement whose options are to be set.","pos":[83051,83115],"source":" The **HSTMT** of the ODBC statement whose options are to be set."},{"pos":[83125,83132],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Call <ph id=\"ph1\">`OnSetOptions`</ph> to set options (used on selection) for the specified ODBC statement.","pos":[83136,83224],"source":"Call `OnSetOptions` to set options (used on selection) for the specified ODBC statement."},{"content":"The framework calls this member function to set initial options for the recordset.","pos":[83225,83307]},{"content":"<ph id=\"ph1\">`OnSetOptions`</ph> determines the data source's support for scrollable cursors and for cursor concurrency and sets the recordset's options accordingly.","pos":[83308,83455],"source":"`OnSetOptions` determines the data source's support for scrollable cursors and for cursor concurrency and sets the recordset's options accordingly."},{"content":"(Whereas <ph id=\"ph1\">`OnSetOptions`</ph> is used for selection operations, <ph id=\"ph2\">`OnSetUpdateOptions`</ph> is used for update operations.)","pos":[83456,83566],"source":" (Whereas `OnSetOptions` is used for selection operations, `OnSetUpdateOptions` is used for update operations.)"},{"content":"Override <ph id=\"ph1\">`OnSetOptions`</ph> to set options specific to the driver or the data source.","pos":[83573,83654],"source":"Override `OnSetOptions` to set options specific to the driver or the data source."},{"content":"For example, if your data source supports opening for exclusive access, you might override <ph id=\"ph1\">`OnSetOptions`</ph> to take advantage of that ability.","pos":[83655,83795],"source":" For example, if your data source supports opening for exclusive access, you might override `OnSetOptions` to take advantage of that ability."},{"pos":[83802,83893],"content":"For more information about cursors, see the article <bpt id=\"p1\">[</bpt>ODBC<ept id=\"p1\">](../../data/odbc/odbc-basics.md)</ept>.","source":"For more information about cursors, see the article [ODBC](../../data/odbc/odbc-basics.md)."},{"pos":[83903,83980],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__onsetupdateoptions\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::OnSetUpdateOptions","linkify":"<a name=\"crecordset__onsetupdateoptions\"></a>  CRecordset::OnSetUpdateOptions","source":"<a name=\"crecordset__onsetupdateoptions\"></a>  CRecordset::OnSetUpdateOptions"},{"content":"Called to set options (used on update) for the specified ODBC statement.","pos":[83984,84056]},{"pos":[84127,84137],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The <bpt id=\"p1\">**</bpt>HSTMT<ept id=\"p1\">**</ept> of the ODBC statement whose options are to be set.","pos":[84152,84216],"source":" The **HSTMT** of the ODBC statement whose options are to be set."},{"pos":[84226,84233],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Call <ph id=\"ph1\">`OnSetUpdateOptions`</ph> to set options (used on update) for the specified ODBC statement.","pos":[84237,84328],"source":"Call `OnSetUpdateOptions` to set options (used on update) for the specified ODBC statement."},{"content":"The framework calls this member function after it creates an HSTMT to update records in a recordset.","pos":[84329,84429]},{"content":"(Whereas <ph id=\"ph1\">`OnSetOptions`</ph> is used for selection operations, <ph id=\"ph2\">`OnSetUpdateOptions`</ph> is used for update operations.) <ph id=\"ph3\">`OnSetUpdateOptions`</ph> determines the data source's support for scrollable cursors and for cursor concurrency and sets the recordset's options accordingly.","pos":[84430,84694],"source":" (Whereas `OnSetOptions` is used for selection operations, `OnSetUpdateOptions` is used for update operations.) `OnSetUpdateOptions` determines the data source's support for scrollable cursors and for cursor concurrency and sets the recordset's options accordingly."},{"pos":[84701,84818],"content":"Override <ph id=\"ph1\">`OnSetUpdateOptions`</ph> to set options of an ODBC statement before that statement is used to access a database.","source":"Override `OnSetUpdateOptions` to set options of an ODBC statement before that statement is used to access a database."},{"pos":[84825,84916],"content":"For more information about cursors, see the article <bpt id=\"p1\">[</bpt>ODBC<ept id=\"p1\">](../../data/odbc/odbc-basics.md)</ept>.","source":"For more information about cursors, see the article [ODBC](../../data/odbc/odbc-basics.md)."},{"pos":[84926,84975],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__open\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::Open","linkify":"<a name=\"crecordset__open\"></a>  CRecordset::Open","source":"<a name=\"crecordset__open\"></a>  CRecordset::Open"},{"content":"Opens the recordset by retrieving the table or performing the query that the recordset represents.","pos":[84979,85077]},{"pos":[85228,85238],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Accept the default value, <bpt id=\"p1\">**</bpt>AFX_DB_USE_DEFAULT_TYPE<ept id=\"p1\">**</ept>, or use one of the following values from the <bpt id=\"p2\">**</bpt>enum OpenType<ept id=\"p2\">**</ept>:","pos":[85257,85374],"source":" Accept the default value, **AFX_DB_USE_DEFAULT_TYPE**, or use one of the following values from the **enum OpenType**:"},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::dynaset<ept id=\"p1\">**</ept> A recordset with bi-directional scrolling.","pos":[85382,85448],"source":"**CRecordset::dynaset** A recordset with bi-directional scrolling."},{"content":"The membership and ordering of the records are determined when the recordset is opened, but changes made by other users to the data values are visible following a fetch operation.","pos":[85449,85628]},{"content":"Dynasets are also known as keyset-driven recordsets.","pos":[85629,85681]},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::snapshot<ept id=\"p1\">**</ept> A static recordset with bi-directional scrolling.","pos":[85689,85763],"source":"**CRecordset::snapshot** A static recordset with bi-directional scrolling."},{"content":"The membership and ordering of the records are determined when the recordset is opened; the data values are determined when the records are fetched.","pos":[85764,85912]},{"content":"Changes made by other users are not visible until the recordset is closed and then reopened.","pos":[85913,86005]},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::dynamic<ept id=\"p1\">**</ept> A recordset with bi-directional scrolling.","pos":[86013,86079],"source":"**CRecordset::dynamic** A recordset with bi-directional scrolling."},{"content":"Changes made by other users to the membership, ordering, and data values are visible following a fetch operation.","pos":[86080,86193]},{"content":"Note that many ODBC drivers do not support this type of recordset.","pos":[86194,86260]},{"pos":[86268,86346],"content":"<bpt id=\"p1\">**</bpt>CRecordset::forwardOnly<ept id=\"p1\">**</ept> A read-only recordset with only forward scrolling.","source":"**CRecordset::forwardOnly** A read-only recordset with only forward scrolling."},{"content":"For <ph id=\"ph1\">`CRecordset`</ph>, the default value is <bpt id=\"p1\">**</bpt>CRecordset::snapshot<ept id=\"p1\">**</ept>.","pos":[86357,86421],"source":"For `CRecordset`, the default value is **CRecordset::snapshot**."},{"content":"The default-value mechanism allows the Visual C++ wizards to interact with both ODBC <ph id=\"ph1\">`CRecordset`</ph> and DAO <ph id=\"ph2\">`CDaoRecordset`</ph>, which have different defaults.","pos":[86422,86575],"source":" The default-value mechanism allows the Visual C++ wizards to interact with both ODBC `CRecordset` and DAO `CDaoRecordset`, which have different defaults."},{"content":"For more information about these recordset types, see the article <bpt id=\"p1\">[</bpt>Recordset (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-odbc.md)</ept>.","pos":[86582,86702],"source":"For more information about these recordset types, see the article [Recordset (ODBC)](../../data/odbc/recordset-odbc.md)."},{"content":"For related information, see the article \"Using Block and Scrollable Cursors\" in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[86703,86840],"source":" For related information, see the article \"Using Block and Scrollable Cursors\" in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[86848,86936],"content":"[!CAUTION]\n If the requested type is not supported, the framework throws an exception.","leadings":["","> "],"nodes":[{"content":"If the requested type is not supported, the framework throws an exception.","pos":[12,86]}]},{"content":"A string pointer containing one of the following:","pos":[86956,87005]},{"pos":[87015,87034],"content":"A <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> pointer.","source":"A **NULL** pointer."},{"content":"The name of a table.","pos":[87044,87064]},{"pos":[87074,87158],"content":"A SQL <bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> statement (optionally with a SQL <bpt id=\"p2\">**</bpt>WHERE<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>ORDER BY<ept id=\"p3\">**</ept> clause).","source":"A SQL **SELECT** statement (optionally with a SQL **WHERE** or **ORDER BY** clause)."},{"content":"A <bpt id=\"p1\">**</bpt>CALL<ept id=\"p1\">**</ept> statement specifying the name of a predefined query (stored procedure).","pos":[87168,87250],"source":"A **CALL** statement specifying the name of a predefined query (stored procedure)."},{"content":"Be careful that you do not insert whitespace between the curly brace and the <bpt id=\"p1\">**</bpt>CALL<ept id=\"p1\">**</ept> keyword.","pos":[87251,87345],"source":" Be careful that you do not insert whitespace between the curly brace and the **CALL** keyword."},{"content":"For more information about this string, see the table and the discussion of ClassWizard's role under Remarks.","pos":[87352,87461]},{"pos":[87469,87716],"content":"[!NOTE]\n The order of the columns in your result set must match the order of the RFX or Bulk RFX function calls in your [DoFieldExchange](#crecordset__dofieldexchange) or [DoBulkFieldExchange](#crecordset__dobulkfieldexchange) function override.","leadings":["","> "],"nodes":[{"content":"The order of the columns in your result set must match the order of the RFX or Bulk RFX function calls in your <bpt id=\"p1\">[</bpt>DoFieldExchange<ept id=\"p1\">](#crecordset__dofieldexchange)</ept> or <bpt id=\"p2\">[</bpt>DoBulkFieldExchange<ept id=\"p2\">](#crecordset__dobulkfieldexchange)</ept> function override.","pos":[9,245],"source":" The order of the columns in your result set must match the order of the RFX or Bulk RFX function calls in your [DoFieldExchange](#crecordset__dofieldexchange) or [DoBulkFieldExchange](#crecordset__dobulkfieldexchange) function override."}]},{"content":"A bitmask which can specify a combination of the values listed below.","pos":[87738,87807]},{"content":"Some of these are mutually exclusive.","pos":[87808,87845]},{"content":"The default value is <bpt id=\"p1\">**</bpt>none<ept id=\"p1\">**</ept>.","pos":[87846,87876],"source":" The default value is **none**."},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::none<ept id=\"p1\">**</ept> No options set.","pos":[87884,87920],"source":"**CRecordset::none** No options set."},{"content":"This parameter value is mutually exclusive with all other values.","pos":[87921,87986]},{"content":"By default, the recordset can be updated with <bpt id=\"p1\">[</bpt>Edit<ept id=\"p1\">](#crecordset__edit)</ept> or <bpt id=\"p2\">[</bpt>Delete<ept id=\"p2\">](#crecordset__delete)</ept> and allows appending new records with <bpt id=\"p3\">[</bpt>AddNew<ept id=\"p3\">](#crecordset__addnew)</ept>.","pos":[87987,88160],"source":" By default, the recordset can be updated with [Edit](#crecordset__edit) or [Delete](#crecordset__delete) and allows appending new records with [AddNew](#crecordset__addnew)."},{"content":"Updatability depends on the data source as well as on the <ph id=\"ph1\">`nOpenType`</ph> option you specify.","pos":[88161,88250],"source":" Updatability depends on the data source as well as on the `nOpenType` option you specify."},{"content":"Optimization for bulk additions is not available.","pos":[88251,88300]},{"content":"Bulk row fetching will not be implemented.","pos":[88301,88343]},{"content":"Deleted records will not be skipped during recordset navigation.","pos":[88344,88408]},{"content":"Bookmarks are not available.","pos":[88409,88437]},{"content":"Automatic dirty field checking is implemented.","pos":[88438,88484]},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::appendOnly<ept id=\"p1\">**</ept> Do not allow <bpt id=\"p2\">**</bpt>Edit<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>Delete<ept id=\"p3\">**</ept> on the recordset.","pos":[88492,88572],"source":"**CRecordset::appendOnly** Do not allow **Edit** or **Delete** on the recordset."},{"content":"Allow <ph id=\"ph1\">`AddNew`</ph> only.","pos":[88573,88593],"source":" Allow `AddNew` only."},{"content":"This option is mutually exclusive with <bpt id=\"p1\">**</bpt>CRecordset::readOnly<ept id=\"p1\">**</ept>.","pos":[88594,88658],"source":" This option is mutually exclusive with **CRecordset::readOnly**."},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::readOnly<ept id=\"p1\">**</ept> Open the recordset as read-only.","pos":[88666,88723],"source":"**CRecordset::readOnly** Open the recordset as read-only."},{"content":"This option is mutually exclusive with <bpt id=\"p1\">**</bpt>CRecordset::appendOnly<ept id=\"p1\">**</ept>.","pos":[88724,88790],"source":" This option is mutually exclusive with **CRecordset::appendOnly**."},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::optimizeBulkAdd<ept id=\"p1\">**</ept> Use a prepared SQL statement to optimize adding many records at one time.","pos":[88798,88903],"source":"**CRecordset::optimizeBulkAdd** Use a prepared SQL statement to optimize adding many records at one time."},{"content":"Applies only if you are not using the ODBC API function <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept> to update the recordset.","pos":[88904,88998],"source":" Applies only if you are not using the ODBC API function **SQLSetPos** to update the recordset."},{"content":"The first update determines which fields are marked dirty.","pos":[88999,89057]},{"content":"This option is mutually exclusive with <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph>.","pos":[89058,89128],"source":" This option is mutually exclusive with `CRecordset::useMultiRowFetch`."},{"content":"<ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph> Implement bulk row fetching to allow multiple rows to be retrieved in a single fetch operation.","pos":[89136,89262],"source":"`CRecordset::useMultiRowFetch` Implement bulk row fetching to allow multiple rows to be retrieved in a single fetch operation."},{"content":"This is an advanced feature designed to improve performance; however, bulk record field exchange is not supported by ClassWizard.","pos":[89263,89392]},{"content":"This option is mutually exclusive with <bpt id=\"p1\">**</bpt>CRecordset::optimizeBulkAdd<ept id=\"p1\">**</ept>.","pos":[89393,89464],"source":" This option is mutually exclusive with **CRecordset::optimizeBulkAdd**."},{"content":"Note that if you specify <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph>, then the option <bpt id=\"p1\">**</bpt>CRecordset::noDirtyFieldCheck<ept id=\"p1\">**</ept> will be turned on automatically (double buffering will not be available); on forward-only recordsets, the option <bpt id=\"p2\">**</bpt>CRecordset::useExtendedFetch<ept id=\"p2\">**</ept> will be turned on automatically.","pos":[89465,89750],"source":" Note that if you specify `CRecordset::useMultiRowFetch`, then the option **CRecordset::noDirtyFieldCheck** will be turned on automatically (double buffering will not be available); on forward-only recordsets, the option **CRecordset::useExtendedFetch** will be turned on automatically."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[89751,89918],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::skipDeletedRecords<ept id=\"p1\">**</ept> Skip all deleted records when navigating through the recordset.","pos":[89926,90024],"source":"**CRecordset::skipDeletedRecords** Skip all deleted records when navigating through the recordset."},{"content":"This will slow performance in certain relative fetches.","pos":[90025,90080]},{"content":"This option is not valid on forward-only recordsets.","pos":[90081,90133]},{"content":"If you call <bpt id=\"p1\">[</bpt>Move<ept id=\"p1\">](#crecordset__move)</ept> with the <ph id=\"ph1\">`nRows`</ph> parameter set to 0, and the <bpt id=\"p2\">**</bpt>CRecordset::skipDeletedRecords<ept id=\"p2\">**</ept> option set, <bpt id=\"p3\">**</bpt>Move<ept id=\"p3\">**</ept> will assert.","pos":[90134,90285],"source":" If you call [Move](#crecordset__move) with the `nRows` parameter set to 0, and the **CRecordset::skipDeletedRecords** option set, **Move** will assert."},{"content":"Note that <bpt id=\"p1\">**</bpt>CRecordset::skipDeletedRecords<ept id=\"p1\">**</ept> is similar to <bpt id=\"p2\">*</bpt>driver packing<ept id=\"p2\">*</ept>, which means that deleted rows are removed from the recordset.","pos":[90286,90424],"source":" Note that **CRecordset::skipDeletedRecords** is similar to *driver packing*, which means that deleted rows are removed from the recordset."},{"content":"However, if your driver packs records, then it will skip only those records that you delete; it will not skip records deleted by other users while the recordset is open.","pos":[90425,90594]},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::skipDeletedRecords<ept id=\"p1\">**</ept> will skip rows deleted by other users.","pos":[90595,90668],"source":"**CRecordset::skipDeletedRecords** will skip rows deleted by other users."},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::useBookmarks<ept id=\"p1\">**</ept> May use bookmarks on the recordset, if supported.","pos":[90676,90754],"source":"**CRecordset::useBookmarks** May use bookmarks on the recordset, if supported."},{"content":"Bookmarks slow data retrieval but improve performance for data navigation.","pos":[90755,90829]},{"content":"Not valid on forward-only recordsets.","pos":[90830,90867]},{"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.","pos":[90868,91027],"source":" For more information, see the article [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)."},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::noDirtyFieldCheck<ept id=\"p1\">**</ept> Turn off automatic dirty field checking (double buffering).","pos":[91035,91128],"source":"**CRecordset::noDirtyFieldCheck** Turn off automatic dirty field checking (double buffering)."},{"content":"This will improve performance; however, you must manually mark fields as dirty by calling the <ph id=\"ph1\">`SetFieldDirty`</ph> and <ph id=\"ph2\">`SetFieldNull`</ph> member functions.Note that double buffering in class <ph id=\"ph3\">`CRecordset`</ph> is similar to double buffering in class <ph id=\"ph4\">`CDaoRecordset`</ph>.","pos":[91129,91380],"source":" This will improve performance; however, you must manually mark fields as dirty by calling the `SetFieldDirty` and `SetFieldNull` member functions.Note that double buffering in class `CRecordset` is similar to double buffering in class `CDaoRecordset`."},{"content":"However, in <ph id=\"ph1\">`CRecordset`</ph>, you cannot enable double buffering on individual fields; you either enable it for all fields or disable it for all fields.","pos":[91381,91529],"source":" However, in `CRecordset`, you cannot enable double buffering on individual fields; you either enable it for all fields or disable it for all fields."},{"content":"Note that if you specify the option <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph>, then <bpt id=\"p1\">**</bpt>CRecordset::noDirtyFieldCheck<ept id=\"p1\">**</ept> will be turned on automatically; however, <ph id=\"ph2\">`SetFieldDirty`</ph> and <ph id=\"ph3\">`SetFieldNull`</ph> cannot be used on recordsets that implement bulk row fetching.","pos":[91530,91776],"source":" Note that if you specify the option `CRecordset::useMultiRowFetch`, then **CRecordset::noDirtyFieldCheck** will be turned on automatically; however, `SetFieldDirty` and `SetFieldNull` cannot be used on recordsets that implement bulk row fetching."},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::executeDirect<ept id=\"p1\">**</ept> Do not use a prepared SQL statement.","pos":[91784,91850],"source":"**CRecordset::executeDirect** Do not use a prepared SQL statement."},{"content":"For improved performance, specify this option if the <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept> member function will never be called.","pos":[91851,91953],"source":" For improved performance, specify this option if the **Requery** member function will never be called."},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::useExtendedFetch<ept id=\"p1\">**</ept> Implement <bpt id=\"p2\">**</bpt>SQLExtendedFetch<ept id=\"p2\">**</ept> instead of <bpt id=\"p3\">**</bpt>SQLFetch<ept id=\"p3\">**</ept>.","pos":[91961,92049],"source":"**CRecordset::useExtendedFetch** Implement **SQLExtendedFetch** instead of **SQLFetch**."},{"content":"This is designed for implementing bulk row fetching on forward-only recordsets.","pos":[92050,92129]},{"content":"If you specify the option <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph> on a forward-only recordset, then <bpt id=\"p1\">**</bpt>CRecordset::useExtendedFetch<ept id=\"p1\">**</ept> will be turned on automatically.","pos":[92130,92286],"source":" If you specify the option `CRecordset::useMultiRowFetch` on a forward-only recordset, then **CRecordset::useExtendedFetch** will be turned on automatically."},{"content":"<bpt id=\"p1\">**</bpt>CRecordset::userAllocMultiRowBuffers<ept id=\"p1\">**</ept> The user will allocate storage buffers for the data.","pos":[92294,92387],"source":"**CRecordset::userAllocMultiRowBuffers** The user will allocate storage buffers for the data."},{"content":"Use this option in conjunction with <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph> if you want to allocate your own storage; otherwise, the framework will automatically allocate the necessary storage.","pos":[92388,92572],"source":" Use this option in conjunction with `CRecordset::useMultiRowFetch` if you want to allocate your own storage; otherwise, the framework will automatically allocate the necessary storage."},{"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[92573,92716],"source":" For more information, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"content":"Note that specifying <bpt id=\"p1\">**</bpt>CRecordset::userAllocMultiRowBuffers<ept id=\"p1\">**</ept> without specifying <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph> will result in a failed assertion.","pos":[92717,92863],"source":" Note that specifying **CRecordset::userAllocMultiRowBuffers** without specifying `CRecordset::useMultiRowFetch` will result in a failed assertion."},{"pos":[92873,92885],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[92889,93060],"content":"Nonzero if the <ph id=\"ph1\">`CRecordset`</ph> object was successfully opened; otherwise 0 if <bpt id=\"p1\">[</bpt>CDatabase::Open<ept id=\"p1\">](../../mfc/reference/cdatabase-class.md#cdatabase__open)</ept> (if called) returns 0.","source":"Nonzero if the `CRecordset` object was successfully opened; otherwise 0 if [CDatabase::Open](../../mfc/reference/cdatabase-class.md#cdatabase__open) (if called) returns 0."},{"pos":[93070,93077],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"You must call this member function to run the query defined by the recordset.","pos":[93081,93158]},{"content":"Before calling <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept>, you must construct the recordset object.","pos":[93159,93224],"source":" Before calling **Open**, you must construct the recordset object."},{"content":"This recordset's connection to the data source depends on how you construct the recordset before calling <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept>.","pos":[93231,93345],"source":"This recordset's connection to the data source depends on how you construct the recordset before calling **Open**."},{"content":"If you pass a <bpt id=\"p1\">[</bpt>CDatabase<ept id=\"p1\">](../../mfc/reference/cdatabase-class.md)</ept> object to the recordset constructor that has not been connected to the data source, this member function uses <bpt id=\"p2\">[</bpt>GetDefaultConnect<ept id=\"p2\">](#crecordset__getdefaultconnect)</ept> to attempt to open the database object.","pos":[93346,93613],"source":" If you pass a [CDatabase](../../mfc/reference/cdatabase-class.md) object to the recordset constructor that has not been connected to the data source, this member function uses [GetDefaultConnect](#crecordset__getdefaultconnect) to attempt to open the database object."},{"content":"If you pass <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> to the recordset constructor, the constructor constructs a <ph id=\"ph1\">`CDatabase`</ph> object for you, and <bpt id=\"p2\">**</bpt>Open<ept id=\"p2\">**</ept> attempts to connect the database object.","pos":[93614,93775],"source":" If you pass **NULL** to the recordset constructor, the constructor constructs a `CDatabase` object for you, and **Open** attempts to connect the database object."},{"content":"For details on closing the recordset and the connection under these varying circumstances, see <bpt id=\"p1\">[</bpt>Close<ept id=\"p1\">](#crecordset__close)</ept>.","pos":[93776,93899],"source":" For details on closing the recordset and the connection under these varying circumstances, see [Close](#crecordset__close)."},{"pos":[93907,94105],"content":"[!NOTE]\n Access to a data source through a `CRecordset` object is always shared. Unlike the `CDaoRecordset` class, you cannot use a `CRecordset` object to open a data source with exclusive access.","leadings":["","> "],"nodes":[{"content":" Access to a data source through a `CRecordset` object is always shared. Unlike the `CDaoRecordset` class, you cannot use a `CRecordset` object to open a data source with exclusive access.","pos":[8,196],"nodes":[{"content":"Access to a data source through a <ph id=\"ph1\">`CRecordset`</ph> object is always shared.","pos":[1,72],"source":" Access to a data source through a `CRecordset` object is always shared."},{"content":"Unlike the <ph id=\"ph1\">`CDaoRecordset`</ph> class, you cannot use a <ph id=\"ph2\">`CRecordset`</ph> object to open a data source with exclusive access.","pos":[73,188],"source":" Unlike the `CDaoRecordset` class, you cannot use a `CRecordset` object to open a data source with exclusive access."}]}]},{"pos":[94112,94244],"content":"When you call <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept>, a query, usually a SQL <bpt id=\"p2\">**</bpt>SELECT<ept id=\"p2\">**</ept> statement, selects records based on criteria shown in the following table.","source":"When you call **Open**, a query, usually a SQL **SELECT** statement, selects records based on criteria shown in the following table."},{"content":"Value of the lpszSQL parameter","pos":[94251,94281]},{"content":"Records selected are determined by","pos":[94282,94316]},{"content":"Example","pos":[94317,94324]},{"pos":[94425,94433],"content":"<bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>","source":"**NULL**"},{"pos":[94434,94473],"content":"The string returned by <ph id=\"ph1\">`GetDefaultSQL`</ph>.","source":"The string returned by `GetDefaultSQL`."},{"content":"SQL table name","pos":[94479,94493]},{"pos":[94494,94570],"content":"All columns of the table-list in <ph id=\"ph1\">`DoFieldExchange`</ph> or <ph id=\"ph2\">`DoBulkFieldExchange`</ph>.","source":"All columns of the table-list in `DoFieldExchange` or `DoBulkFieldExchange`."},{"content":"Predefined query (stored procedure) name","pos":[94588,94628]},{"content":"The columns the query is defined to return.","pos":[94629,94672]},{"pos":[94701,94743],"content":"<bpt id=\"p1\">**</bpt>SELECT<ept id=\"p1\">**</ept> column-list <bpt id=\"p2\">**</bpt>FROM<ept id=\"p2\">**</ept> table-list","source":"**SELECT** column-list **FROM** table-list"},{"content":"The specified columns from the specified table(s).","pos":[94744,94794]},{"pos":[94859,95456],"content":"[!CAUTION]\n Be careful that you do not insert extra whitespace in your SQL string. For example, if you insert whitespace between the curly brace and the **CALL** keyword, MFC will misinterpret the SQL string as a table name and incorporate it into a **SELECT** statement, which will result in an exception being thrown. Similarly, if your predefined query uses an output parameter, do not insert whitespace between the curly brace and the '' symbol. Finally, you must not insert whitespace before the curly brace in a **CALL** statement or before the **SELECT** keyword in a **SELECT** statment.","leadings":["","> "],"nodes":[{"content":" Be careful that you do not insert extra whitespace in your SQL string. For example, if you insert whitespace between the curly brace and the **CALL** keyword, MFC will misinterpret the SQL string as a table name and incorporate it into a **SELECT** statement, which will result in an exception being thrown. Similarly, if your predefined query uses an output parameter, do not insert whitespace between the curly brace and the '' symbol. Finally, you must not insert whitespace before the curly brace in a **CALL** statement or before the **SELECT** keyword in a **SELECT** statment.","pos":[11,595],"nodes":[{"content":"Be careful that you do not insert extra whitespace in your SQL string.","pos":[1,71]},{"content":"For example, if you insert whitespace between the curly brace and the <bpt id=\"p1\">**</bpt>CALL<ept id=\"p1\">**</ept> keyword, MFC will misinterpret the SQL string as a table name and incorporate it into a <bpt id=\"p2\">**</bpt>SELECT<ept id=\"p2\">**</ept> statement, which will result in an exception being thrown.","pos":[72,308],"source":" For example, if you insert whitespace between the curly brace and the **CALL** keyword, MFC will misinterpret the SQL string as a table name and incorporate it into a **SELECT** statement, which will result in an exception being thrown."},{"content":"Similarly, if your predefined query uses an output parameter, do not insert whitespace between the curly brace and the '' symbol.","pos":[309,438]},{"content":"Finally, you must not insert whitespace before the curly brace in a <bpt id=\"p1\">**</bpt>CALL<ept id=\"p1\">**</ept> statement or before the <bpt id=\"p2\">**</bpt>SELECT<ept id=\"p2\">**</ept> keyword in a <bpt id=\"p3\">**</bpt>SELECT<ept id=\"p3\">**</ept> statment.","pos":[439,584],"source":" Finally, you must not insert whitespace before the curly brace in a **CALL** statement or before the **SELECT** keyword in a **SELECT** statment."}]}]},{"content":"The usual procedure is to pass <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> to <bpt id=\"p2\">**</bpt>Open<ept id=\"p2\">**</ept>; in this case, <bpt id=\"p3\">**</bpt>Open<ept id=\"p3\">**</ept> calls <bpt id=\"p4\">[</bpt>GetDefaultSQL<ept id=\"p4\">](#crecordset__getdefaultsql)</ept>.","pos":[95463,95589],"source":"The usual procedure is to pass **NULL** to **Open**; in this case, **Open** calls [GetDefaultSQL](#crecordset__getdefaultsql)."},{"content":"If you are using a derived <ph id=\"ph1\">`CRecordset`</ph> class, <bpt id=\"p1\">**</bpt>GetDefaultSQL<ept id=\"p1\">**</ept> gives the table name(s) you specified in ClassWizard.","pos":[95590,95708],"source":" If you are using a derived `CRecordset` class, **GetDefaultSQL** gives the table name(s) you specified in ClassWizard."},{"content":"You can instead specify other information in the <ph id=\"ph1\">`lpszSQL`</ph> parameter.","pos":[95709,95778],"source":" You can instead specify other information in the `lpszSQL` parameter."},{"content":"Whatever you pass, <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> constructs a final SQL string for the query (the string may have SQL <bpt id=\"p2\">**</bpt>WHERE<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>ORDER BY<ept id=\"p3\">**</ept> clauses appended to the <ph id=\"ph1\">`lpszSQL`</ph> string you passed) and then executes the query.","pos":[95785,95990],"source":"Whatever you pass, **Open** constructs a final SQL string for the query (the string may have SQL **WHERE** and **ORDER BY** clauses appended to the `lpszSQL` string you passed) and then executes the query."},{"content":"You can examine the constructed string by calling <bpt id=\"p1\">[</bpt>GetSQL<ept id=\"p1\">](#crecordset__getsql)</ept> after calling <bpt id=\"p2\">**</bpt>Open<ept id=\"p2\">**</ept>.","pos":[95991,96094],"source":" You can examine the constructed string by calling [GetSQL](#crecordset__getsql) after calling **Open**."},{"content":"For additional details about how the recordset constructs a SQL statement and selects records, see the article <bpt id=\"p1\">[</bpt>Recordset: How Recordsets Select Records (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)</ept>.","pos":[96095,96321],"source":" For additional details about how the recordset constructs a SQL statement and selects records, see the article [Recordset: How Recordsets Select Records (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)."},{"content":"The field data members of your recordset class are bound to the columns of the data selected.","pos":[96328,96421]},{"content":"If any records are returned, the first record becomes the current record.","pos":[96422,96495]},{"content":"If you want to set options for the recordset, such as a filter or sort, specify these after you construct the recordset object but before you call <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept>.","pos":[96502,96658],"source":"If you want to set options for the recordset, such as a filter or sort, specify these after you construct the recordset object but before you call **Open**."},{"content":"If you want to refresh the records in the recordset after the recordset is already open, call <bpt id=\"p1\">[</bpt>Requery<ept id=\"p1\">](#crecordset__requery)</ept>.","pos":[96659,96785],"source":" If you want to refresh the records in the recordset after the recordset is already open, call [Requery](#crecordset__requery)."},{"pos":[96792,97156],"content":"For more information, including additional examples, see the articles <bpt id=\"p1\">[</bpt>Recordset (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-odbc.md)</ept>, <bpt id=\"p2\">[</bpt>Recordset: How Recordsets Select Records (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)</ept>, and <bpt id=\"p3\">[</bpt>Recordset: Creating and Closing Recordsets (ODBC)<ept id=\"p3\">](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md)</ept>.","source":"For more information, including additional examples, see the articles [Recordset (ODBC)](../../data/odbc/recordset-odbc.md), [Recordset: How Recordsets Select Records (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md), and [Recordset: Creating and Closing Recordsets (ODBC)](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md)."},{"pos":[97166,97173],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[97177,97247],"content":"The following code examples show different forms of the <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> call.","source":"The following code examples show different forms of the **Open** call."},{"pos":[97254,97336],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#16<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_15.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#16](../../mfc/codesnippet/cpp/crecordset-class_15.cpp)]"},{"pos":[97346,97413],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__refreshrowset\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::RefreshRowset","linkify":"<a name=\"crecordset__refreshrowset\"></a>  CRecordset::RefreshRowset","source":"<a name=\"crecordset__refreshrowset\"></a>  CRecordset::RefreshRowset"},{"content":"Updates the data and the status for a row in the current rowset.","pos":[97417,97481]},{"pos":[97585,97595],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The one-based position of a row in the current rowset.","pos":[97609,97663]},{"content":"This value can range from zero to the size of the rowset.","pos":[97664,97721]},{"content":"A value indicating how to lock the row after it has been refreshed.","pos":[97743,97810]},{"content":"For details, see Remarks.","pos":[97811,97836]},{"pos":[97846,97853],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[97857,97944],"content":"If you pass a value of zero for <ph id=\"ph1\">`wRow`</ph>, then every row in the rowset will be refreshed.","source":"If you pass a value of zero for `wRow`, then every row in the rowset will be refreshed."},{"pos":[97951,98126],"content":"To use <ph id=\"ph1\">`RefreshRowset`</ph>, you must have implemented bulk row fetching by specifying the <bpt id=\"p1\">**</bpt>CRecordset::useMulitRowFetch<ept id=\"p1\">**</ept> option in the <bpt id=\"p2\">[</bpt>Open<ept id=\"p2\">](#crecordset__open)</ept> member function.","source":"To use `RefreshRowset`, you must have implemented bulk row fetching by specifying the **CRecordset::useMulitRowFetch** option in the [Open](#crecordset__open) member function."},{"content":"<ph id=\"ph1\">`RefreshRowset`</ph> calls the ODBC API function <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept>.","pos":[98133,98191],"source":"`RefreshRowset` calls the ODBC API function **SQLSetPos**."},{"content":"The <ph id=\"ph1\">`wLockType`</ph> parameter specifies the lock state of the row after <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept> has executed.","pos":[98192,98287],"source":" The `wLockType` parameter specifies the lock state of the row after **SQLSetPos** has executed."},{"content":"The following table describes the possible values for <ph id=\"ph1\">`wLockTyp`</ph>e.","pos":[98288,98354],"source":" The following table describes the possible values for `wLockTyp`e."},{"content":"wLockType","pos":[98361,98370]},{"content":"Description","pos":[98371,98382]},{"pos":[98425,98465],"content":"<ph id=\"ph1\">`SQL_LOCK_NO_CHANGE`</ph> (the default value)","source":"`SQL_LOCK_NO_CHANGE` (the default value)"},{"pos":[98466,98597],"content":"The driver or data source ensures that the row is in the same locked or unlocked state as it was before <ph id=\"ph1\">`RefreshRowset`</ph> was called.","source":"The driver or data source ensures that the row is in the same locked or unlocked state as it was before `RefreshRowset` was called."},{"content":"The driver or data source locks the row exclusively.","pos":[98623,98675]},{"content":"Not all data sources support this type of lock.","pos":[98676,98723]},{"content":"The driver or data source unlocks the row.","pos":[98746,98788]},{"content":"Not all data sources support this type of lock.","pos":[98789,98836]},{"content":"For more information about <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept>, see the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[98844,98946],"source":"For more information about **SQLSetPos**, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[98947,99114],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[99124,99179],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__requery\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::Requery","linkify":"<a name=\"crecordset__requery\"></a>  CRecordset::Requery","source":"<a name=\"crecordset__requery\"></a>  CRecordset::Requery"},{"content":"Rebuilds (refreshes) a recordset.","pos":[99183,99216]},{"pos":[99265,99277],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if the recordset was successfully rebuilt; otherwise 0.","pos":[99281,99344]},{"pos":[99354,99361],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If any records are returned, the first record becomes the current record.","pos":[99365,99438]},{"content":"In order for the recordset to reflect the additions and deletions that you or other users are making to the data source, you must rebuild the recordset by calling <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept>.","pos":[99445,99620],"source":"In order for the recordset to reflect the additions and deletions that you or other users are making to the data source, you must rebuild the recordset by calling **Requery**."},{"content":"If the recordset is a dynaset, it automatically reflects updates that you or other users make to its existing records (but not additions).","pos":[99621,99759]},{"content":"If the recordset is a snapshot, you must call <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept> to reflect edits by other users as well as additions and deletions.","pos":[99760,99885],"source":" If the recordset is a snapshot, you must call **Requery** to reflect edits by other users as well as additions and deletions."},{"content":"For either a dynaset or a snapshot, call <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept> any time you want to rebuild the recordset using a new filter or sort, or new parameter values.","pos":[99892,100040],"source":"For either a dynaset or a snapshot, call **Requery** any time you want to rebuild the recordset using a new filter or sort, or new parameter values."},{"content":"Set the new filter or sort property by assigning new values to <bpt id=\"p1\">**</bpt>m_strFilter<ept id=\"p1\">**</ept> and <ph id=\"ph1\">`m_strSort`</ph> before calling <bpt id=\"p2\">**</bpt>Requery<ept id=\"p2\">**</ept>.","pos":[100041,100163],"source":" Set the new filter or sort property by assigning new values to **m_strFilter** and `m_strSort` before calling **Requery**."},{"content":"Set new parameters by assigning new values to parameter data members before calling <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept>.","pos":[100164,100260],"source":" Set new parameters by assigning new values to parameter data members before calling **Requery**."},{"content":"If the filter and sort strings are unchanged, you can reuse the query, which improves performance.","pos":[100261,100359]},{"content":"If the attempt to rebuild the recordset fails, the recordset is closed.","pos":[100366,100437]},{"content":"Before you call <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept>, you can determine whether the recordset can be requeried by calling the <ph id=\"ph1\">`CanRestart`</ph> member function.","pos":[100438,100568],"source":" Before you call **Requery**, you can determine whether the recordset can be requeried by calling the `CanRestart` member function."},{"content":"<ph id=\"ph1\">`CanRestart`</ph> does not guarantee that <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept> will succeed.","pos":[100569,100631],"source":"`CanRestart` does not guarantee that **Requery** will succeed."},{"pos":[100639,100723],"content":"[!CAUTION]\n Call **Requery** only after you have called [Open](#crecordset__open).","leadings":["","> "],"nodes":[{"content":"Call <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept> only after you have called <bpt id=\"p2\">[</bpt>Open<ept id=\"p2\">](#crecordset__open)</ept>.","pos":[12,82],"source":" Call **Requery** only after you have called [Open](#crecordset__open)."}]},{"pos":[100733,100740],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example rebuilds a recordset to apply a different sort order.","pos":[100744,100810]},{"pos":[100817,100899],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#29<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_16.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#29](../../mfc/codesnippet/cpp/crecordset-class_16.cpp)]"},{"pos":[100909,100988],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__setabsoluteposition\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::SetAbsolutePosition","linkify":"<a name=\"crecordset__setabsoluteposition\"></a>  CRecordset::SetAbsolutePosition","source":"<a name=\"crecordset__setabsoluteposition\"></a>  CRecordset::SetAbsolutePosition"},{"content":"Positions the recordset on the record corresponding to the specified record number.","pos":[100992,101075]},{"pos":[101138,101148],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The one-based ordinal position for the current record in the recordset.","pos":[101163,101234]},{"pos":[101244,101251],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[101255,101341],"content":"<ph id=\"ph1\">`SetAbsolutePosition`</ph> moves the current record pointer based on this ordinal position.","source":"`SetAbsolutePosition` moves the current record pointer based on this ordinal position."},{"pos":[101349,101421],"content":"[!NOTE]\n This member function is not valid on forward-only recordsets.","leadings":["","> "],"nodes":[{"content":"This member function is not valid on forward-only recordsets.","pos":[9,70]}]},{"content":"For ODBC recordsets, an absolute position setting of 1 refers to the first record in the recordset; a setting of 0 refers to the beginning-of-file (BOF) position.","pos":[101428,101590]},{"content":"You can also pass negative values to <ph id=\"ph1\">`SetAbsolutePosition`</ph>.","pos":[101597,101656],"source":"You can also pass negative values to `SetAbsolutePosition`."},{"content":"In this case the recordset's position is evaluated from the end of the recordset.","pos":[101657,101738]},{"content":"For example, <ph id=\"ph1\">`SetAbsolutePosition( -1 )`</ph> moves the current record pointer to the last record in the recordset.","pos":[101739,101849],"source":" For example, `SetAbsolutePosition( -1 )` moves the current record pointer to the last record in the recordset."},{"pos":[101857,102378],"content":"[!NOTE]\n Absolute position is not intended to be used as a surrogate record number. Bookmarks are still the recommended way of retaining and returning to a given position, since a record's position changes when preceding records are deleted. In addition, you cannot be assured that a given record will have the same absolute position if the recordset is re-created again because the order of individual records within a recordset is not guaranteed unless it is created with a SQL statement using an **ORDER BY** clause.","leadings":["","> "],"nodes":[{"content":" Absolute position is not intended to be used as a surrogate record number. Bookmarks are still the recommended way of retaining and returning to a given position, since a record's position changes when preceding records are deleted. In addition, you cannot be assured that a given record will have the same absolute position if the recordset is re-created again because the order of individual records within a recordset is not guaranteed unless it is created with a SQL statement using an **ORDER BY** clause.","pos":[8,519],"nodes":[{"content":"Absolute position is not intended to be used as a surrogate record number.","pos":[1,75]},{"content":"Bookmarks are still the recommended way of retaining and returning to a given position, since a record's position changes when preceding records are deleted.","pos":[76,233]},{"content":"In addition, you cannot be assured that a given record will have the same absolute position if the recordset is re-created again because the order of individual records within a recordset is not guaranteed unless it is created with a SQL statement using an <bpt id=\"p1\">**</bpt>ORDER BY<ept id=\"p1\">**</ept> clause.","pos":[234,511],"source":" In addition, you cannot be assured that a given record will have the same absolute position if the recordset is re-created again because the order of individual records within a recordset is not guaranteed unless it is created with a SQL statement using an **ORDER BY** clause."}]}]},{"pos":[102385,102665],"content":"For more information about recordset navigation and bookmarks, see the articles <bpt id=\"p1\">[</bpt>Recordset: Scrolling (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-scrolling-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept>.","source":"For more information about recordset navigation and bookmarks, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)."},{"pos":[102675,102738],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__setbookmark\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::SetBookmark","linkify":"<a name=\"crecordset__setbookmark\"></a>  CRecordset::SetBookmark","source":"<a name=\"crecordset__setbookmark\"></a>  CRecordset::SetBookmark"},{"content":"Positions the recordset on the record containing the specified bookmark.","pos":[102742,102814]},{"pos":[102888,102898],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"A reference to a <bpt id=\"p1\">[</bpt>CDBVariant<ept id=\"p1\">](../../mfc/reference/cdbvariant-class.md)</ept> object containing the bookmark value for a specific record.","pos":[102919,103049],"source":" A reference to a [CDBVariant](../../mfc/reference/cdbvariant-class.md) object containing the bookmark value for a specific record."},{"pos":[103059,103066],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"To determine if bookmarks are supported on the recordset, call <bpt id=\"p1\">[</bpt>CanBookmark<ept id=\"p1\">](#crecordset__canbookmark)</ept>.","pos":[103070,103173],"source":"To determine if bookmarks are supported on the recordset, call [CanBookmark](#crecordset__canbookmark)."},{"content":"To make bookmarks available if they are supported, you must set the <bpt id=\"p1\">**</bpt>CRecordset::useBookmarks<ept id=\"p1\">**</ept> option in the <ph id=\"ph1\">`dwOptions`</ph> parameter of the <bpt id=\"p2\">[</bpt>Open<ept id=\"p2\">](#crecordset__open)</ept> member function.","pos":[103174,103356],"source":" To make bookmarks available if they are supported, you must set the **CRecordset::useBookmarks** option in the `dwOptions` parameter of the [Open](#crecordset__open) member function."},{"pos":[103364,103539],"content":"[!NOTE]\n If bookmarks are unsupported or unavailable, calling `SetBookmark` will result in an exception being thrown. Bookmarks are not supported on forward-only recordsets.","leadings":["","> "],"nodes":[{"content":" If bookmarks are unsupported or unavailable, calling `SetBookmark` will result in an exception being thrown. Bookmarks are not supported on forward-only recordsets.","pos":[8,173],"nodes":[{"content":"If bookmarks are unsupported or unavailable, calling <ph id=\"ph1\">`SetBookmark`</ph> will result in an exception being thrown.","pos":[1,109],"source":" If bookmarks are unsupported or unavailable, calling `SetBookmark` will result in an exception being thrown."},{"content":"Bookmarks are not supported on forward-only recordsets.","pos":[110,165]}]}]},{"content":"To first retrieve the bookmark for the current record, call <bpt id=\"p1\">[</bpt>GetBookmark<ept id=\"p1\">](#crecordset__getbookmark)</ept>, which saves the bookmark value to a <ph id=\"ph1\">`CDBVariant`</ph> object.","pos":[103546,103703],"source":"To first retrieve the bookmark for the current record, call [GetBookmark](#crecordset__getbookmark), which saves the bookmark value to a `CDBVariant` object."},{"content":"Later, you can return to that record by calling <ph id=\"ph1\">`SetBookmark`</ph> using the saved bookmark value.","pos":[103704,103797],"source":" Later, you can return to that record by calling `SetBookmark` using the saved bookmark value."},{"pos":[103805,104213],"content":"[!NOTE]\n After certain recordset operations, you should check the bookmark persistence before calling `SetBookmark`. For example, if you retrieve a bookmark with `GetBookmark` and then call **Requery**, the bookmark may no longer be valid. Call [CDatabase::GetBookmarkPersistence](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence) to check whether you can safely call `SetBookmark`.","leadings":["","> "],"nodes":[{"content":" After certain recordset operations, you should check the bookmark persistence before calling `SetBookmark`. For example, if you retrieve a bookmark with `GetBookmark` and then call **Requery**, the bookmark may no longer be valid. Call [CDatabase::GetBookmarkPersistence](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence) to check whether you can safely call `SetBookmark`.","pos":[8,406],"nodes":[{"content":"After certain recordset operations, you should check the bookmark persistence before calling <ph id=\"ph1\">`SetBookmark`</ph>.","pos":[1,108],"source":" After certain recordset operations, you should check the bookmark persistence before calling `SetBookmark`."},{"content":"For example, if you retrieve a bookmark with <ph id=\"ph1\">`GetBookmark`</ph> and then call <bpt id=\"p1\">**</bpt>Requery<ept id=\"p1\">**</ept>, the bookmark may no longer be valid.","pos":[109,231],"source":" For example, if you retrieve a bookmark with `GetBookmark` and then call **Requery**, the bookmark may no longer be valid."},{"content":"Call <bpt id=\"p1\">[</bpt>CDatabase::GetBookmarkPersistence<ept id=\"p1\">](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence)</ept> to check whether you can safely call <ph id=\"ph1\">`SetBookmark`</ph>.","pos":[232,398],"source":" Call [CDatabase::GetBookmarkPersistence](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence) to check whether you can safely call `SetBookmark`."}]}]},{"pos":[104220,104500],"content":"For more information about bookmarks and recordset navigation, see the articles <bpt id=\"p1\">[</bpt>Recordset: Bookmarks and Absolute Positions (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)</ept> and <bpt id=\"p2\">[</bpt>Recordset: Scrolling (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-scrolling-odbc.md)</ept>.","source":"For more information about bookmarks and recordset navigation, see the articles [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md) and [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md)."},{"pos":[104510,104577],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__setfielddirty\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::SetFieldDirty","linkify":"<a name=\"crecordset__setfielddirty\"></a>  CRecordset::SetFieldDirty","source":"<a name=\"crecordset__setfielddirty\"></a>  CRecordset::SetFieldDirty"},{"content":"Flags a field data member of the recordset as changed or as unchanged.","pos":[104581,104651]},{"pos":[104731,104741],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Contains the address of a field data member in the recordset or <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[104753,104826],"source":" Contains the address of a field data member in the recordset or **NULL**."},{"content":"If <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, all field data members in the recordset are flagged.","pos":[104827,104892],"source":" If **NULL**, all field data members in the recordset are flagged."},{"content":"(C++ <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> is not the same as Null in database terminology, which means \"having no value.\")","pos":[104893,104987],"source":" (C++ **NULL** is not the same as Null in database terminology, which means \"having no value.\")"},{"content":"<bpt id=\"p1\"> **</bpt>TRUE<ept id=\"p1\">**</ept> if the field data member is to be flagged as \"dirty\" (changed).","pos":[105005,105078],"source":" **TRUE** if the field data member is to be flagged as \"dirty\" (changed)."},{"content":"Otherwise <bpt id=\"p1\">**</bpt>FALSE<ept id=\"p1\">**</ept> if the field data member is to be flagged as \"clean\" (unchanged).","pos":[105079,105164],"source":" Otherwise **FALSE** if the field data member is to be flagged as \"clean\" (unchanged)."},{"pos":[105174,105181],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Marking fields as unchanged ensures the field is not updated and results in less SQL traffic.","pos":[105185,105278]},{"pos":[105286,105650],"content":"[!NOTE]\n This member function is not applicable on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, then `SetFieldDirty` will result in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" This member function is not applicable on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, then `SetFieldDirty` will result in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,362],"nodes":[{"content":"This member function is not applicable on recordsets that are using bulk row fetching.","pos":[1,87]},{"content":"If you have implemented bulk row fetching, then <ph id=\"ph1\">`SetFieldDirty`</ph> will result in a failed assertion.","pos":[88,186],"source":" If you have implemented bulk row fetching, then `SetFieldDirty` will result in a failed assertion."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[187,354],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"content":"The framework marks changed field data members to ensure they will be written to the record on the data source by the record field exchange (RFX) mechanism.","pos":[105657,105813]},{"content":"Changing the value of a field generally sets the field dirty automatically, so you will seldom need to call <ph id=\"ph1\">`SetFieldDirty`</ph> yourself, but you might sometimes want to ensure that columns will be explicitly updated or inserted regardless of what value is in the field data member.","pos":[105814,106092],"source":" Changing the value of a field generally sets the field dirty automatically, so you will seldom need to call `SetFieldDirty` yourself, but you might sometimes want to ensure that columns will be explicitly updated or inserted regardless of what value is in the field data member."},{"pos":[106100,106226],"content":"[!CAUTION]\n Call this member function only after you have called [Edit](#crecordset__edit) or [AddNew](#crecordset__addnew).","leadings":["","> "],"nodes":[{"content":"Call this member function only after you have called <bpt id=\"p1\">[</bpt>Edit<ept id=\"p1\">](#crecordset__edit)</ept> or <bpt id=\"p2\">[</bpt>AddNew<ept id=\"p2\">](#crecordset__addnew)</ept>.","pos":[12,124],"source":" Call this member function only after you have called [Edit](#crecordset__edit) or [AddNew](#crecordset__addnew)."}]},{"content":"Using <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> for the first argument of the function will apply the function only to <bpt id=\"p2\">**</bpt>outputColumn<ept id=\"p2\">**</ept> fields, not <bpt id=\"p3\">**</bpt>param<ept id=\"p3\">**</ept> fields.","pos":[106233,106365],"source":"Using **NULL** for the first argument of the function will apply the function only to **outputColumn** fields, not **param** fields."},{"content":"For instance, the call","pos":[106366,106388]},{"pos":[106395,106477],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#26<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#26](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)]"},{"pos":[106484,106571],"content":"will set only <bpt id=\"p1\">**</bpt>outputColumn<ept id=\"p1\">**</ept> fields to <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept>; <bpt id=\"p3\">**</bpt>param<ept id=\"p3\">**</ept> fields will be unaffected.","source":"will set only **outputColumn** fields to **NULL**; **param** fields will be unaffected."},{"pos":[106578,106699],"content":"To work on <bpt id=\"p1\">**</bpt>param<ept id=\"p1\">**</ept> fields, you must supply the actual address of the individual <bpt id=\"p2\">**</bpt>param<ept id=\"p2\">**</ept> you want to work on, such as:","source":"To work on **param** fields, you must supply the actual address of the individual **param** you want to work on, such as:"},{"pos":[106706,106788],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#27<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#27](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)]"},{"pos":[106795,106895],"content":"This means you cannot set all <bpt id=\"p1\">**</bpt>param<ept id=\"p1\">**</ept> fields to <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept>, as you can with <bpt id=\"p3\">**</bpt>outputColumn<ept id=\"p3\">**</ept> fields.","source":"This means you cannot set all **param** fields to **NULL**, as you can with **outputColumn** fields."},{"pos":[106905,106970],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__setfieldnull\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::SetFieldNull","linkify":"<a name=\"crecordset__setfieldnull\"></a>  CRecordset::SetFieldNull","source":"<a name=\"crecordset__setfieldnull\"></a>  CRecordset::SetFieldNull"},{"content":"Flags a field data member of the recordset as Null (specifically having no value) or as non-Null.","pos":[106974,107071]},{"pos":[107149,107159],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Contains the address of a field data member in the recordset or <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[107171,107244],"source":" Contains the address of a field data member in the recordset or **NULL**."},{"content":"If <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, all field data members in the recordset are flagged.","pos":[107245,107310],"source":" If **NULL**, all field data members in the recordset are flagged."},{"content":"(C++ <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> is not the same as Null in database terminology, which means \"having no value.\")","pos":[107311,107405],"source":" (C++ **NULL** is not the same as Null in database terminology, which means \"having no value.\")"},{"content":"Nonzero if the field data member is to be flagged as having no value (Null).","pos":[107423,107499]},{"content":"Otherwise 0 if the field data member is to be flagged as non-Null.","pos":[107500,107566]},{"pos":[107576,107583],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"When you add a new record to a recordset, all field data members are initially set to a Null value and flagged as \"dirty\" (changed).","pos":[107587,107719]},{"content":"When you retrieve a record from a data source, its columns either already have values or are Null.","pos":[107720,107818]},{"pos":[107826,108182],"content":"[!NOTE]\n Do not call this member function on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, calling `SetFieldNull` results in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" Do not call this member function on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, calling `SetFieldNull` results in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,354],"nodes":[{"content":"Do not call this member function on recordsets that are using bulk row fetching.","pos":[1,81]},{"content":"If you have implemented bulk row fetching, calling <ph id=\"ph1\">`SetFieldNull`</ph> results in a failed assertion.","pos":[82,178],"source":" If you have implemented bulk row fetching, calling `SetFieldNull` results in a failed assertion."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[179,346],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"content":"If you specifically wish to designate a field of the current record as not having a value, call <ph id=\"ph1\">`SetFieldNull`</ph> with <ph id=\"ph2\">`bNull`</ph> set to <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept> to flag it as Null.","pos":[108189,108348],"source":"If you specifically wish to designate a field of the current record as not having a value, call `SetFieldNull` with `bNull` set to **TRUE** to flag it as Null."},{"content":"If a field was previously marked Null and you now want to give it a value, simply set its new value.","pos":[108349,108449]},{"content":"You do not have to remove the Null flag with <ph id=\"ph1\">`SetFieldNull`</ph>.","pos":[108450,108510],"source":" You do not have to remove the Null flag with `SetFieldNull`."},{"content":"To determine whether the field is allowed to be Null, call <ph id=\"ph1\">`IsFieldNullable`</ph>.","pos":[108511,108588],"source":" To determine whether the field is allowed to be Null, call `IsFieldNullable`."},{"pos":[108596,108722],"content":"[!CAUTION]\n Call this member function only after you have called [Edit](#crecordset__edit) or [AddNew](#crecordset__addnew).","leadings":["","> "],"nodes":[{"content":"Call this member function only after you have called <bpt id=\"p1\">[</bpt>Edit<ept id=\"p1\">](#crecordset__edit)</ept> or <bpt id=\"p2\">[</bpt>AddNew<ept id=\"p2\">](#crecordset__addnew)</ept>.","pos":[12,124],"source":" Call this member function only after you have called [Edit](#crecordset__edit) or [AddNew](#crecordset__addnew)."}]},{"content":"Using <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> for the first argument of the function will apply the function only to <bpt id=\"p2\">**</bpt>outputColumn<ept id=\"p2\">**</ept> fields, not <bpt id=\"p3\">**</bpt>param<ept id=\"p3\">**</ept> fields.","pos":[108729,108861],"source":"Using **NULL** for the first argument of the function will apply the function only to **outputColumn** fields, not **param** fields."},{"content":"For instance, the call","pos":[108862,108884]},{"pos":[108891,108973],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#26<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#26](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)]"},{"pos":[108980,109067],"content":"will set only <bpt id=\"p1\">**</bpt>outputColumn<ept id=\"p1\">**</ept> fields to <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept>; <bpt id=\"p3\">**</bpt>param<ept id=\"p3\">**</ept> fields will be unaffected.","source":"will set only **outputColumn** fields to **NULL**; **param** fields will be unaffected."},{"pos":[109074,109195],"content":"To work on <bpt id=\"p1\">**</bpt>param<ept id=\"p1\">**</ept> fields, you must supply the actual address of the individual <bpt id=\"p2\">**</bpt>param<ept id=\"p2\">**</ept> you want to work on, such as:","source":"To work on **param** fields, you must supply the actual address of the individual **param** you want to work on, such as:"},{"pos":[109202,109284],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>NVC_MFCDatabase#27<ept id=\"p2\">](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)</ept><ept id=\"p1\">]</ept>","source":"[!code-cpp[NVC_MFCDatabase#27](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)]"},{"pos":[109291,109391],"content":"This means you cannot set all <bpt id=\"p1\">**</bpt>param<ept id=\"p1\">**</ept> fields to <bpt id=\"p2\">**</bpt>NULL<ept id=\"p2\">**</ept>, as you can with <bpt id=\"p3\">**</bpt>outputColumn<ept id=\"p3\">**</ept> fields.","source":"This means you cannot set all **param** fields to **NULL**, as you can with **outputColumn** fields."},{"pos":[109399,109585],"content":"[!NOTE]\n When setting parameters to Null, a call to `SetFieldNull` before the recordset is opened results in an assertion. In this case, call [SetParamNull](#crecordset__setparamnull).","leadings":["","> "],"nodes":[{"content":" When setting parameters to Null, a call to `SetFieldNull` before the recordset is opened results in an assertion. In this case, call [SetParamNull](#crecordset__setparamnull).","pos":[8,184],"nodes":[{"content":"When setting parameters to Null, a call to <ph id=\"ph1\">`SetFieldNull`</ph> before the recordset is opened results in an assertion.","pos":[1,114],"source":" When setting parameters to Null, a call to `SetFieldNull` before the recordset is opened results in an assertion."},{"content":"In this case, call <bpt id=\"p1\">[</bpt>SetParamNull<ept id=\"p1\">](#crecordset__setparamnull)</ept>.","pos":[115,176],"source":" In this case, call [SetParamNull](#crecordset__setparamnull)."}]}]},{"pos":[109592,109678],"content":"<ph id=\"ph1\">`SetFieldNull`</ph> is implemented through <bpt id=\"p1\">[</bpt>DoFieldExchange<ept id=\"p1\">](#crecordset__dofieldexchange)</ept>.","source":"`SetFieldNull` is implemented through [DoFieldExchange](#crecordset__dofieldexchange)."},{"pos":[109688,109757],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__setlockingmode\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::SetLockingMode","linkify":"<a name=\"crecordset__setlockingmode\"></a>  CRecordset::SetLockingMode","source":"<a name=\"crecordset__setlockingmode\"></a>  CRecordset::SetLockingMode"},{"content":"Sets the locking mode to \"optimistic\" locking (the default) or \"pessimistic\" locking.","pos":[109761,109846]},{"content":"Determines how records are locked for updates.","pos":[109847,109893]},{"pos":[109951,109961],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Contains one of the following values from the <bpt id=\"p1\">**</bpt>enum LockMode<ept id=\"p1\">**</ept>:","pos":[109976,110040],"source":" Contains one of the following values from the **enum LockMode**:"},{"pos":[110048,110148],"content":"<bpt id=\"p1\">**</bpt>optimistic<ept id=\"p1\">**</ept> Optimistic locking locks the record being updated only during the call to <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept>.","source":"**optimistic** Optimistic locking locks the record being updated only during the call to **Update**."},{"pos":[110156,110323],"content":"<bpt id=\"p1\">**</bpt>pessimistic<ept id=\"p1\">**</ept> Pessimistic locking locks the record as soon as <bpt id=\"p2\">**</bpt>Edit<ept id=\"p2\">**</ept> is called and keeps it locked until the <bpt id=\"p3\">**</bpt>Update<ept id=\"p3\">**</ept> call completes or you move to a new record.","source":"**pessimistic** Pessimistic locking locks the record as soon as **Edit** is called and keeps it locked until the **Update** call completes or you move to a new record."},{"pos":[110333,110340],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Call this member function if you need to specify which of two record-locking strategies the recordset is using for updates.","pos":[110344,110467]},{"content":"By default, the locking mode of a recordset is <bpt id=\"p1\">**</bpt>optimistic<ept id=\"p1\">**</ept>.","pos":[110468,110530],"source":" By default, the locking mode of a recordset is **optimistic**."},{"content":"You can change that to a more cautious <bpt id=\"p1\">**</bpt>pessimistic<ept id=\"p1\">**</ept> locking strategy.","pos":[110531,110603],"source":" You can change that to a more cautious **pessimistic** locking strategy."},{"content":"Call <ph id=\"ph1\">`SetLockingMode`</ph> after you construct and open the recordset object but before you call <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>.","pos":[110604,110705],"source":" Call `SetLockingMode` after you construct and open the recordset object but before you call **Edit**."},{"pos":[110715,110780],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__setparamnull\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::SetParamNull","linkify":"<a name=\"crecordset__setparamnull\"></a>  CRecordset::SetParamNull","source":"<a name=\"crecordset__setparamnull\"></a>  CRecordset::SetParamNull"},{"content":"Flags a parameter as Null (specifically having no value) or as non-Null.","pos":[110784,110856]},{"pos":[110942,110952],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The zero-based index of the parameter.","pos":[110968,111006]},{"content":"If <bpt id=\"p1\">**</bpt>TRUE<ept id=\"p1\">**</ept> (the default value), the parameter is flagged as Null.","pos":[111024,111090],"source":" If **TRUE** (the default value), the parameter is flagged as Null."},{"content":"Otherwise, the parameter is flagged as non-Null.","pos":[111091,111139]},{"pos":[111149,111156],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[111160,111275],"content":"Unlike <bpt id=\"p1\">[</bpt>SetFieldNull<ept id=\"p1\">](#crecordset__setfieldnull)</ept>, you can call <ph id=\"ph1\">`SetParamNull`</ph> before you have opened the recordset.","source":"Unlike [SetFieldNull](#crecordset__setfieldnull), you can call `SetParamNull` before you have opened the recordset."},{"pos":[111282,111359],"content":"<ph id=\"ph1\">`SetParamNull`</ph> is typically used with predefined queries (stored procedures).","source":"`SetParamNull` is typically used with predefined queries (stored procedures)."},{"pos":[111369,111456],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__setrowsetcursorposition\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::SetRowsetCursorPosition","linkify":"<a name=\"crecordset__setrowsetcursorposition\"></a>  CRecordset::SetRowsetCursorPosition","source":"<a name=\"crecordset__setrowsetcursorposition\"></a>  CRecordset::SetRowsetCursorPosition"},{"content":"Moves the cursor to a row within the current rowset.","pos":[111460,111512]},{"pos":[111620,111630],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The one-based position of a row in the current rowset.","pos":[111644,111698]},{"content":"This value can range from 1 to the size of the rowset.","pos":[111699,111753]},{"content":"Value indicating how to lock the row after it has been refreshed.","pos":[111775,111840]},{"content":"For details, see Remarks.","pos":[111841,111866]},{"pos":[111876,111883],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"When implementing bulk row fetching, records are retrieved by rowsets, where the first record in the fetched rowset is the current record.","pos":[111887,112025]},{"content":"In order to make another record within the rowset the current record, call <ph id=\"ph1\">`SetRowsetCursorPosition`</ph>.","pos":[112026,112127],"source":" In order to make another record within the rowset the current record, call `SetRowsetCursorPosition`."},{"content":"For example, you can combine <ph id=\"ph1\">`SetRowsetCursorPosition`</ph> with the <bpt id=\"p1\">[</bpt>GetFieldValue<ept id=\"p1\">](#crecordset__getfieldvalue)</ept> member function to dynamically retrieve the data from any record of your recordset.","pos":[112128,112319],"source":" For example, you can combine `SetRowsetCursorPosition` with the [GetFieldValue](#crecordset__getfieldvalue) member function to dynamically retrieve the data from any record of your recordset."},{"pos":[112326,112538],"content":"To use <ph id=\"ph1\">`SetRowsetCursorPosition`</ph>, you must have implemented bulk row fetching by specifying the <ph id=\"ph2\">`CRecordset::useMultiRowFetch`</ph> option of the <ph id=\"ph3\">`dwOptions`</ph> parameter in the <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](#crecordset__open)</ept> member function.","source":"To use `SetRowsetCursorPosition`, you must have implemented bulk row fetching by specifying the `CRecordset::useMultiRowFetch` option of the `dwOptions` parameter in the [Open](#crecordset__open) member function."},{"content":"<ph id=\"ph1\">`SetRowsetCursorPosition`</ph> calls the ODBC API function <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept>.","pos":[112545,112613],"source":"`SetRowsetCursorPosition` calls the ODBC API function **SQLSetPos**."},{"content":"The <ph id=\"ph1\">`wLockType`</ph> parameter specifies the lock state of the row after <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept> has executed.","pos":[112614,112709],"source":" The `wLockType` parameter specifies the lock state of the row after **SQLSetPos** has executed."},{"content":"The following table describes the possible values for <ph id=\"ph1\">`wLockTyp`</ph>e.","pos":[112710,112776],"source":" The following table describes the possible values for `wLockTyp`e."},{"content":"wLockType","pos":[112783,112792]},{"content":"Description","pos":[112793,112804]},{"pos":[112847,112887],"content":"<ph id=\"ph1\">`SQL_LOCK_NO_CHANGE`</ph> (the default value)","source":"`SQL_LOCK_NO_CHANGE` (the default value)"},{"pos":[112888,113029],"content":"The driver or data source ensures that the row is in the same locked or unlocked state as it was before <ph id=\"ph1\">`SetRowsetCursorPosition`</ph> was called.","source":"The driver or data source ensures that the row is in the same locked or unlocked state as it was before `SetRowsetCursorPosition` was called."},{"content":"The driver or data source locks the row exclusively.","pos":[113055,113107]},{"content":"Not all data sources support this type of lock.","pos":[113108,113155]},{"content":"The driver or data source unlocks the row.","pos":[113178,113220]},{"content":"Not all data sources support this type of lock.","pos":[113221,113268]},{"content":"For more information about <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept>, see the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[113276,113378],"source":"For more information about **SQLSetPos**, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[113379,113546],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[113556,113623],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__setrowsetsize\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::SetRowsetSize","linkify":"<a name=\"crecordset__setrowsetsize\"></a>  CRecordset::SetRowsetSize","source":"<a name=\"crecordset__setrowsetsize\"></a>  CRecordset::SetRowsetSize"},{"content":"Specifies the number of records you wish to retrieve during a fetch.","pos":[113627,113695]},{"pos":[113771,113781],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">*</bpt>dwNewRowsetSize<ept id=\"p1\">*</ept>","pos":[113785,113802],"source":"*dwNewRowsetSize*"},{"content":"The number of rows to retrieve during a given fetch.","pos":[113806,113858]},{"pos":[113868,113875],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"This virtual member function specifies how many rows you wish to retrieve during a single fetch when using bulk row fetching.","pos":[113879,114004]},{"content":"To implement bulk row fetching, you must set the <ph id=\"ph1\">`CRecordset::useMultiRowFetch`</ph> option in the <ph id=\"ph2\">`dwOptions`</ph> parameter of the <bpt id=\"p1\">[</bpt>Open<ept id=\"p1\">](#crecordset__open)</ept> member function.","pos":[114005,114170],"source":" To implement bulk row fetching, you must set the `CRecordset::useMultiRowFetch` option in the `dwOptions` parameter of the [Open](#crecordset__open) member function."},{"pos":[114178,114286],"content":"[!NOTE]\n Calling `SetRowsetSize` without implementing bulk row fetching will result in a failed assertion.","leadings":["","> "],"nodes":[{"content":"Calling <ph id=\"ph1\">`SetRowsetSize`</ph> without implementing bulk row fetching will result in a failed assertion.","pos":[9,106],"source":" Calling `SetRowsetSize` without implementing bulk row fetching will result in a failed assertion."}]},{"content":"Call <ph id=\"ph1\">`SetRowsetSize`</ph> before calling <bpt id=\"p1\">**</bpt>Open<ept id=\"p1\">**</ept> to initially set the rowset size for the recordset.","pos":[114293,114389],"source":"Call `SetRowsetSize` before calling **Open** to initially set the rowset size for the recordset."},{"content":"The default rowset size when implementing bulk row fetching is 25.","pos":[114390,114456]},{"pos":[114464,114836],"content":"[!NOTE]\n Use caution when calling `SetRowsetSize`. If you are manually allocating storage for the data (as specified by the **CRecordset::userAllocMultiRowBuffers** option of the dwOptions parameter in **Open**), you should check whether you need to reallocate these storage buffers after you call `SetRowsetSize`, but before you perform any cursor navigation operation.","leadings":["","> "],"nodes":[{"content":" Use caution when calling `SetRowsetSize`. If you are manually allocating storage for the data (as specified by the **CRecordset::userAllocMultiRowBuffers** option of the dwOptions parameter in **Open**), you should check whether you need to reallocate these storage buffers after you call `SetRowsetSize`, but before you perform any cursor navigation operation.","pos":[8,370],"nodes":[{"content":"Use caution when calling <ph id=\"ph1\">`SetRowsetSize`</ph>.","pos":[1,42],"source":" Use caution when calling `SetRowsetSize`."},{"content":"If you are manually allocating storage for the data (as specified by the <bpt id=\"p1\">**</bpt>CRecordset::userAllocMultiRowBuffers<ept id=\"p1\">**</ept> option of the dwOptions parameter in <bpt id=\"p2\">**</bpt>Open<ept id=\"p2\">**</ept>), you should check whether you need to reallocate these storage buffers after you call <ph id=\"ph1\">`SetRowsetSize`</ph>, but before you perform any cursor navigation operation.","pos":[43,362],"source":" If you are manually allocating storage for the data (as specified by the **CRecordset::userAllocMultiRowBuffers** option of the dwOptions parameter in **Open**), you should check whether you need to reallocate these storage buffers after you call `SetRowsetSize`, but before you perform any cursor navigation operation."}]}]},{"pos":[114843,114943],"content":"To obtain the current setting for the rowset size, call <bpt id=\"p1\">[</bpt>GetRowsetSize<ept id=\"p1\">](#crecordset__getrowsetsize)</ept>.","source":"To obtain the current setting for the rowset size, call [GetRowsetSize](#crecordset__getrowsetsize)."},{"pos":[114950,115117],"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","source":"For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."},{"pos":[115127,115180],"content":"<bpt id=\"p1\">&lt;a name=\"crecordset__update\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CRecordset::Update","linkify":"<a name=\"crecordset__update\"></a>  CRecordset::Update","source":"<a name=\"crecordset__update\"></a>  CRecordset::Update"},{"pos":[115184,115280],"content":"Completes an <ph id=\"ph1\">`AddNew`</ph> or <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> operation by saving the new or edited data on the data source.","source":"Completes an `AddNew` or **Edit** operation by saving the new or edited data on the data source."},{"pos":[115328,115340],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Nonzero if one record was successfully updated; otherwise 0 if no columns have changed.","pos":[115344,115431]},{"content":"If no records were updated, or if more than one record was updated, an exception is thrown.","pos":[115432,115523]},{"content":"An exception is also thrown for any other failure on the data source.","pos":[115524,115593]},{"pos":[115603,115610],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Call this member function after a call to the <bpt id=\"p1\">[</bpt>AddNew<ept id=\"p1\">](#crecordset__addnew)</ept> or <bpt id=\"p2\">[</bpt>Edit<ept id=\"p2\">](#crecordset__edit)</ept> member function.","pos":[115614,115735],"source":"Call this member function after a call to the [AddNew](#crecordset__addnew) or [Edit](#crecordset__edit) member function."},{"content":"This call is required to complete the <ph id=\"ph1\">`AddNew`</ph> or <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> operation.","pos":[115736,115805],"source":" This call is required to complete the `AddNew` or **Edit** operation."},{"pos":[115813,116270],"content":"[!NOTE]\n If you have implemented bulk row fetching, you cannot call **Update**. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","leadings":["","> "],"nodes":[{"content":" If you have implemented bulk row fetching, you cannot call **Update**. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).","pos":[8,455],"nodes":[{"content":"If you have implemented bulk row fetching, you cannot call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>.","pos":[1,71],"source":" If you have implemented bulk row fetching, you cannot call **Update**."},{"content":"This will result in a failed assertion.","pos":[72,111]},{"content":"Although class <ph id=\"ph1\">`CRecordset`</ph> does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function <bpt id=\"p1\">**</bpt>SQLSetPos<ept id=\"p1\">**</ept>.","pos":[112,279],"source":" Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**."},{"content":"For more information about bulk row fetching, see the article <bpt id=\"p1\">[</bpt>Recordset: Fetching Records in Bulk (ODBC)<ept id=\"p1\">](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)</ept>.","pos":[280,447],"source":" For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)."}]}]},{"content":"Both <ph id=\"ph1\">`AddNew`</ph> and <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept> prepare an edit buffer in which the added or edited data is placed for saving to the data source.","pos":[116277,116401],"source":"Both `AddNew` and **Edit** prepare an edit buffer in which the added or edited data is placed for saving to the data source."},{"content":"<bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> saves the data.","pos":[116402,116428],"source":"**Update** saves the data."},{"content":"Only those fields marked or detected as changed are updated.","pos":[116429,116489]},{"content":"If the data source supports transactions, you can make the <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> call (and its corresponding <ph id=\"ph1\">`AddNew`</ph> or <bpt id=\"p2\">**</bpt>Edit<ept id=\"p2\">**</ept> call) part of a transaction.","pos":[116496,116643],"source":"If the data source supports transactions, you can make the **Update** call (and its corresponding `AddNew` or **Edit** call) part of a transaction."},{"content":"For more information about transactions, see the article <bpt id=\"p1\">[</bpt>Transaction (ODBC)<ept id=\"p1\">](../../data/odbc/transaction-odbc.md)</ept>.","pos":[116644,116759],"source":" For more information about transactions, see the article [Transaction (ODBC)](../../data/odbc/transaction-odbc.md)."},{"pos":[116767,117113],"content":"[!CAUTION]\n If you call **Update** without first calling either `AddNew` or **Edit**, **Update** throws a `CDBException`. If you call `AddNew` or **Edit**, you must call **Update** before you call a **Move** operation or before you close either the recordset or the data source connection. Otherwise, your changes are lost without notification.","leadings":["","> "],"nodes":[{"content":" If you call **Update** without first calling either `AddNew` or **Edit**, **Update** throws a `CDBException`. If you call `AddNew` or **Edit**, you must call **Update** before you call a **Move** operation or before you close either the recordset or the data source connection. Otherwise, your changes are lost without notification.","pos":[11,344],"nodes":[{"content":"If you call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> without first calling either <ph id=\"ph1\">`AddNew`</ph> or <bpt id=\"p2\">**</bpt>Edit<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>Update<ept id=\"p3\">**</ept> throws a <ph id=\"ph2\">`CDBException`</ph>.","pos":[1,110],"source":" If you call **Update** without first calling either `AddNew` or **Edit**, **Update** throws a `CDBException`."},{"content":"If you call <ph id=\"ph1\">`AddNew`</ph> or <bpt id=\"p1\">**</bpt>Edit<ept id=\"p1\">**</ept>, you must call <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept> before you call a <bpt id=\"p3\">**</bpt>Move<ept id=\"p3\">**</ept> operation or before you close either the recordset or the data source connection.","pos":[111,278],"source":" If you call `AddNew` or **Edit**, you must call **Update** before you call a **Move** operation or before you close either the recordset or the data source connection."},{"content":"Otherwise, your changes are lost without notification.","pos":[279,333]}]}]},{"pos":[117120,117296],"content":"For details on handling <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> failures, see the article <bpt id=\"p2\">[</bpt>Recordset: How Recordsets Update Records (ODBC)<ept id=\"p2\">](../../data/odbc/recordset-how-recordsets-update-records-odbc.md)</ept>.","source":"For details on handling **Update** failures, see the article [Recordset: How Recordsets Update Records (ODBC)](../../data/odbc/recordset-how-recordsets-update-records-odbc.md)."},{"pos":[117306,117313],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[117317,117472],"content":"See the article <bpt id=\"p1\">[</bpt>Transaction: Performing a Transaction in a Recordset (ODBC)<ept id=\"p1\">](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md)</ept>.","source":"See the article [Transaction: Performing a Transaction in a Recordset (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md)."},{"pos":[117481,117489],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>CObject Class<ept id=\"p1\">](../../mfc/reference/cobject-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[117493,117547],"source":"[CObject Class](../../mfc/reference/cobject-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Hierarchy Chart<ept id=\"p1\">](../../mfc/hierarchy-chart.md)</ept><ph id=\"ph1\"> </ph>","pos":[117550,117599],"source":" [Hierarchy Chart](../../mfc/hierarchy-chart.md) "},{"content":"<bpt id=\"p1\"> [</bpt>CDatabase Class<ept id=\"p1\">](../../mfc/reference/cdatabase-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[117602,117661],"source":" [CDatabase Class](../../mfc/reference/cdatabase-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>CRecordView Class<ept id=\"p1\">](../../mfc/reference/crecordview-class.md)</ept>","pos":[117664,117726],"source":" [CRecordView Class](../../mfc/reference/crecordview-class.md)"}],"content":"---\ntitle: \"CRecordset Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CRecordset\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"database records [C++]\"\n  - \"CRecordset class\"\n  - \"ODBC recordsets [C++], CRecordset objects\"\n  - \"sets of records [C++]\"\nms.assetid: dd89a21d-ef39-4aab-891b-1e373d67c855\ncaps.latest.revision: 23\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CRecordset Class\nRepresents a set of records selected from a data source.  \n  \n## Syntax  \n  \n```  \nclass CRecordset : public CObject  \n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CRecordset::CRecordset](#crecordset__crecordset)|Constructs a `CRecordset` object. Your derived class must provide a constructor that calls this one.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CRecordset::AddNew](#crecordset__addnew)|Prepares for adding a new record. Call `Update` to complete the addition.|  \n|[CRecordset::CanAppend](#crecordset__canappend)|Returns nonzero if new records can be added to the recordset via the `AddNew` member function.|  \n|[CRecordset::CanBookmark](#crecordset__canbookmark)|Returns nonzero if the recordset supports bookmarks.|  \n|[CRecordset::Cancel](#crecordset__cancel)|Cancels an asynchronous operation or a process from a second thread.|  \n|[CRecordset::CancelUpdate](#crecordset__cancelupdate)|Cancels any pending updates due to an `AddNew` or `Edit` operation.|  \n|[CRecordset::CanRestart](#crecordset__canrestart)|Returns nonzero if `Requery` can be called to run the recordset's query again.|  \n|[CRecordset::CanScroll](#crecordset__canscroll)|Returns nonzero if you can scroll through the records.|  \n|[CRecordset::CanTransact](#crecordset__cantransact)|Returns nonzero if the data source supports transactions.|  \n|[CRecordset::CanUpdate](#crecordset__canupdate)|Returns nonzero if the recordset can be updated (you can add, update, or delete records).|  \n|[CRecordset::CheckRowsetError](#crecordset__checkrowseterror)|Called to handle errors generated during record fetching.|  \n|[CRecordset::Close](#crecordset__close)|Closes the recordset and the ODBC **HSTMT** associated with it.|  \n|[CRecordset::Delete](#crecordset__delete)|Deletes the current record from the recordset. You must explicitly scroll to another record after the deletion.|  \n|[CRecordset::DoBulkFieldExchange](#crecordset__dobulkfieldexchange)|Called to exchange bulk rows of data from the data source to the recordset. Implements bulk record field exchange (Bulk RFX).|  \n|[CRecordset::DoFieldExchange](#crecordset__dofieldexchange)|Called to exchange data (in both directions) between the field data members of the recordset and the corresponding record on the data source. Implements record field exchange (RFX).|  \n|[CRecordset::Edit](#crecordset__edit)|Prepares for changes to the current record. Call `Update` to complete the edit.|  \n|[CRecordset::FlushResultSet](#crecordset__flushresultset)|Returns nonzero if there is another result set to be retrieved, when using a predefined query.|  \n|[CRecordset::GetBookmark](#crecordset__getbookmark)|Assigns the bookmark value of a record to the parameter object.|  \n|[CRecordset::GetDefaultConnect](#crecordset__getdefaultconnect)|Called to get the default connection string.|  \n|[CRecordset::GetDefaultSQL](#crecordset__getdefaultsql)|Called to get the default SQL string to execute.|  \n|[CRecordset::GetFieldValue](#crecordset__getfieldvalue)|Returns the value of a field in a recordset.|  \n|[CRecordset::GetODBCFieldCount](#crecordset__getodbcfieldcount)|Returns the number of fields in the recordset.|  \n|[CRecordset::GetODBCFieldInfo](#crecordset__getodbcfieldinfo)|Returns specific kinds of information about the fields in a recordset.|  \n|[CRecordset::GetRecordCount](#crecordset__getrecordcount)|Returns the number of records in the recordset.|  \n|[CRecordset::GetRowsetSize](#crecordset__getrowsetsize)|Returns the number of records you wish to retrieve during a single fetch.|  \n|[CRecordset::GetRowsFetched](#crecordset__getrowsfetched)|Returns the actual number of rows retrieved during a fetch.|  \n|[CRecordset::GetRowStatus](#crecordset__getrowstatus)|Returns the status of the row after a fetch.|  \n|[CRecordset::GetSQL](#crecordset__getsql)|Gets the SQL string used to select records for the recordset.|  \n|[CRecordset::GetStatus](#crecordset__getstatus)|Gets the status of the recordset: the index of the current record and whether a final count of the records has been obtained.|  \n|[CRecordset::GetTableName](#crecordset__gettablename)|Gets the name of the table on which the recordset is based.|  \n|[CRecordset::IsBOF](#crecordset__isbof)|Returns nonzero if the recordset has been positioned before the first record. There is no current record.|  \n|[CRecordset::IsDeleted](#crecordset__isdeleted)|Returns nonzero if the recordset is positioned on a deleted record.|  \n|[CRecordset::IsEOF](#crecordset__iseof)|Returns nonzero if the recordset has been positioned after the last record. There is no current record.|  \n|[CRecordset::IsFieldDirty](#crecordset__isfielddirty)|Returns nonzero if the specified field in the current record has been changed.|  \n|[CRecordset::IsFieldNull](#crecordset__isfieldnull)|Returns nonzero if the specified field in the current record is null (has no value).|  \n|[CRecordset::IsFieldNullable](#crecordset__isfieldnullable)|Returns nonzero if the specified field in the current record can be set to null (having no value).|  \n|[CRecordset::IsOpen](#crecordset__isopen)|Returns nonzero if `Open` has been called previously.|  \n|[CRecordset::Move](#crecordset__move)|Positions the recordset to a specified number of records from the current record in either direction.|  \n|[CRecordset::MoveFirst](#crecordset__movefirst)|Positions the current record on the first record in the recordset. Test for `IsBOF` first.|  \n|[CRecordset::MoveLast](#crecordset__movelast)|Positions the current record on the last record or on the last rowset. Test for `IsEOF` first.|  \n|[CRecordset::MoveNext](#crecordset__movenext)|Positions the current record on the next record or on the next rowset. Test for `IsEOF` first.|  \n|[CRecordset::MovePrev](#crecordset__moveprev)|Positions the current record on the previous record or on the previous rowset. Test for `IsBOF` first.|  \n|[CRecordset::OnSetOptions](#crecordset__onsetoptions)|Called to set options (used on selection) for the specified ODBC statement.|  \n|[CRecordset::OnSetUpdateOptions](#crecordset__onsetupdateoptions)|Called to set options (used on update) for the specified ODBC statement.|  \n|[CRecordset::Open](#crecordset__open)|Opens the recordset by retrieving the table or performing the query that the recordset represents.|  \n|[CRecordset::RefreshRowset](#crecordset__refreshrowset)|Refreshes the data and status of the specified row(s).|  \n|[CRecordset::Requery](#crecordset__requery)|Runs the recordset's query again to refresh the selected records.|  \n|[CRecordset::SetAbsolutePosition](#crecordset__setabsoluteposition)|Positions the recordset on the record corresponding to the specified record number.|  \n|[CRecordset::SetBookmark](#crecordset__setbookmark)|Positions the recordset on the record specified by the bookmark.|  \n|[CRecordset::SetFieldDirty](#crecordset__setfielddirty)|Marks the specified field in the current record as changed.|  \n|[CRecordset::SetFieldNull](#crecordset__setfieldnull)|Sets the value of the specified field in the current record to null (having no value).|  \n|[CRecordset::SetLockingMode](#crecordset__setlockingmode)|Sets the locking mode to \"optimistic\" locking (the default) or \"pessimistic\" locking. Determines how records are locked for updates.|  \n|[CRecordset::SetParamNull](#crecordset__setparamnull)|Sets the specified parameter to null (having no value).|  \n|[CRecordset::SetRowsetCursorPosition](#crecordset__setrowsetcursorposition)|Positions the cursor on the specified row within the rowset.|  \n|[CRecordset::SetRowsetSize](#crecordset__setrowsetsize)|Specifies the number of records you wish to retrieve during a fetch.|  \n|[CRecordset::Update](#crecordset__update)|Completes an `AddNew` or `Edit` operation by saving the new or edited data on the data source.|  \n  \n### Public Data Members  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CRecordset::m_hstmt](#crecordset__m_hstmt)|Contains the ODBC statement handle for the recordset. Type `HSTMT`.|  \n|[CRecordset::m_nFields](#crecordset__m_nfields)|Contains the number of field data members in the recordset. Type `UINT`.|  \n|[CRecordset::m_nParams](#crecordset__m_nparams)|Contains the number of parameter data members in the recordset. Type `UINT`.|  \n|[CRecordset::m_pDatabase](#crecordset__m_pdatabase)|Contains a pointer to the `CDatabase` object through which the recordset is connected to a data source.|  \n|[CRecordset::m_strFilter](#crecordset__m_strfilter)|Contains a `CString` that specifies a Structured Query Language (SQL) `WHERE` clause. Used as a filter to select only those records that meet certain criteria.|  \n|[CRecordset::m_strSort](#crecordset__m_strsort)|Contains a `CString` that specifies a SQL `ORDER BY` clause. Used to control how the records are sorted.|  \n  \n## Remarks  \n Known as \"recordsets,\" `CRecordset` objects are typically used in two forms: dynasets and snapshots. A dynaset stays synchronized with data updates made by other users. A snapshot is a static view of the data. Each form represents a set of records fixed at the time the recordset is opened, but when you scroll to a record in a dynaset, it reflects changes subsequently made to the record, either by other users or by other recordsets in your application.  \n  \n> [!NOTE]\n>  If you are working with the Data Access Objects (DAO) classes rather than the Open Database Connectivity (ODBC) classes, use class [CDaoRecordset](../../mfc/reference/cdaorecordset-class.md) instead. For more information, see the article [Overview: Database Programming](../../data/data-access-programming-mfc-atl.md).  \n  \n To work with either kind of recordset, you typically derive an application-specific recordset class from `CRecordset`. Recordsets select records from a data source, and you can then:  \n  \n-   Scroll through the records.  \n  \n-   Update the records and specify a locking mode.  \n  \n-   Filter the recordset to constrain which records it selects from those available on the data source.  \n  \n-   Sort the recordset.  \n  \n-   Parameterize the recordset to customize its selection with information not known until run time.  \n  \n To use your class, open a database and construct a recordset object, passing the constructor a pointer to your `CDatabase` object. Then call the recordset's **Open** member function, where you can specify whether the object is a dynaset or a snapshot. Calling **Open** selects data from the data source. After the recordset object is opened, use its member functions and data members to scroll through the records and operate on them. The operations available depend on whether the object is a dynaset or a snapshot, whether it is updatable or read-only (this depends on the capability of the Open Database Connectivity (ODBC) data source), and whether you have implemented bulk row fetching. To refresh records that may have been changed or added since the **Open** call, call the object's **Requery** member function. Call the object's **Close** member function and destroy the object when you finish with it.  \n  \n In a derived `CRecordset` class, record field exchange (RFX) or bulk record field exchange (Bulk RFX) is used to support reading and updating of record fields.  \n  \n For more information about recordsets and record field exchange, see the articles [Overview: Database Programming](../../data/data-access-programming-mfc-atl.md), [Recordset (ODBC)](../../data/odbc/recordset-odbc.md), [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md), and [Record Field Exchange (RFX)](../../data/odbc/record-field-exchange-rfx.md). For a focus on dynasets and snapshots, see the articles [Dynaset](../../data/odbc/dynaset.md) and [Snapshot](../../data/odbc/snapshot.md).  \n  \n## Inheritance Hierarchy  \n [CObject](../../mfc/reference/cobject-class.md)  \n  \n `CRecordset`  \n  \n## Requirements  \n **Header:** afxdb.h  \n  \n##  <a name=\"crecordset__addnew\"></a>  CRecordset::AddNew  \n Prepares for adding a new record to the table.  \n  \n```  \nvirtual void AddNew();\n```  \n  \n### Remarks  \n You must call the [Requery](#crecordset__requery) member function to see the newly added record. The record's fields are initially Null. (In database terminology, Null means \"having no value\" and is not the same as **NULL** in C++.) To complete the operation, you must call the [Update](#crecordset__update) member function. **Update** saves your changes to the data source.  \n  \n> [!NOTE]\n>  If you have implemented bulk row fetching, you cannot call `AddNew`. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n `AddNew` prepares a new, empty record using the recordset's field data members. After you call `AddNew`, set the values you want in the recordset's field data members. (You do not have to call the [Edit](#crecordset__edit) member function for this purpose; use **Edit** only for existing records.) When you subsequently call **Update**, changed values in the field data members are saved on the data source.  \n  \n> [!CAUTION]\n>  If you scroll to a new record before you call **Update**, the new record is lost, and no warning is given.  \n  \n If the data source supports transactions, you can make your `AddNew` call part of a transaction. For more information about transactions, see class [CDatabase](../../mfc/reference/cdatabase-class.md). Note that you should call [CDatabase::BeginTrans](../../mfc/reference/cdatabase-class.md#cdatabase__begintrans) before calling `AddNew`.  \n  \n> [!NOTE]\n>  For dynasets, new records are added to the recordset as the last record. Added records are not added to snapshots; you must call **Requery** to refresh the recordset.  \n  \n It is illegal to call `AddNew` for a recordset whose **Open** member function has not been called. A `CDBException` is thrown if you call `AddNew` for a recordset that cannot be appended to. You can determine whether the recordset is updatable by calling [CanAppend](#crecordset__canappend).  \n  \n For more information, see the following articles: [Recordset: How Recordsets Update Records (ODBC)](../../data/odbc/recordset-how-recordsets-update-records-odbc.md), [Recordset: Adding, Updating, and Deleting Records (ODBC)](../../data/odbc/recordset-adding-updating-and-deleting-records-odbc.md), and [Transaction (ODBC)](../../data/odbc/transaction-odbc.md).  \n  \n### Example  \n See the article [Transaction: Performing a Transaction in a Recordset (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md).  \n  \n##  <a name=\"crecordset__canappend\"></a>  CRecordset::CanAppend  \n Determines whether the previously opened recordset allows you to add new records.  \n  \n```  \nBOOL CanAppend() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the recordset allows adding new records; otherwise 0. `CanAppend` will return 0 if you opened the recordset as read-only.  \n  \n##  <a name=\"crecordset__canbookmark\"></a>  CRecordset::CanBookmark  \n Determines whether the recordset allows you to mark records using bookmarks.  \n  \n```  \nBOOL CanBookmark() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the recordset supports bookmarks; otherwise 0.  \n  \n### Remarks  \n This function is independent of the **CRecordset::useBookmarks** option in the `dwOptions` parameter of the [Open](#crecordset__open) member function. `CanBookmark` indicates whether the given ODBC driver and cursor type support bookmarks. **CRecordset::useBookmarks** indicates whether bookmarks will be available, provided they are supported.  \n  \n> [!NOTE]\n>  Bookmarks are not supported on forward-only recordsets.  \n  \n For more information about bookmarks and recordset navigation, see the articles [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md) and [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md).  \n  \n##  <a name=\"crecordset__cancel\"></a>  CRecordset::Cancel  \n Requests that the data source cancel either an asynchronous operation in progress or a process from a second thread.  \n  \n```  \nvoid Cancel();\n```  \n  \n### Remarks  \n Note that the MFC ODBC classes no longer use asynchronous processing; to perform an asychronous operation, you must directly call the ODBC API function **SQLSetConnectOption**. For more information, see the topic \"Executing Functions Asynchronously\" in the *ODBC SDK Programmer's Guide*.  \n  \n##  <a name=\"crecordset__cancelupdate\"></a>  CRecordset::CancelUpdate  \n Cancels any pending updates, caused by an [Edit](#crecordset__edit) or [AddNew](#crecordset__addnew) operation, before [Update](#crecordset__update) is called.  \n  \n```  \nvoid CancelUpdate();\n```  \n  \n### Remarks  \n  \n> [!NOTE]\n>  This member function is not applicable on recordsets that are using bulk row fetching, since such recordsets cannot call **Edit**, `AddNew`, or **Update**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n If automatic dirty field checking is enabled, `CancelUpdate` will restore the member variables to the values they had before **Edit** or `AddNew` was called; otherwise, any value changes will remain. By default, automatic field checking is enabled when the recordset is opened. To disable it, you must specify the **CRecordset::noDirtyFieldCheck** in the `dwOptions` parameter of the [Open](#crecordset__open) member function.  \n  \n For more information about updating data, see the article [Recordset: Adding, Updating, and Deleting Records (ODBC)](../../data/odbc/recordset-adding-updating-and-deleting-records-odbc.md).  \n  \n##  <a name=\"crecordset__canrestart\"></a>  CRecordset::CanRestart  \n Determines whether the recordset allows restarting its query (to refresh its records) by calling the **Requery** member function.  \n  \n```  \nBOOL CanRestart() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if requery is allowed; otherwise 0.  \n  \n##  <a name=\"crecordset__canscroll\"></a>  CRecordset::CanScroll  \n Determines whether the recordset allows scrolling.  \n  \n```  \nBOOL CanScroll() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the recordset allows scrolling; otherwise 0.  \n  \n### Remarks  \n For more information about scrolling, see the article [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md).  \n  \n##  <a name=\"crecordset__cantransact\"></a>  CRecordset::CanTransact  \n Determines whether the recordset allows transactions.  \n  \n```  \nBOOL CanTransact() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the recordset allows transactions; otherwise 0.  \n  \n### Remarks  \n For more information, see the article [Transaction (ODBC)](../../data/odbc/transaction-odbc.md).  \n  \n##  <a name=\"crecordset__canupdate\"></a>  CRecordset::CanUpdate  \n Determines whether the recordset can be updated.  \n  \n```  \nBOOL CanUpdate() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the recordset can be updated; otherwise 0.  \n  \n### Remarks  \n A recordset might be read-only if the underlying data source is read-only or if you specified **CRecordset::readOnly** in the `dwOptions` parameter when you opened the recordset.  \n  \n##  <a name=\"crecordset__checkrowseterror\"></a>  CRecordset::CheckRowsetError  \n Called to handle errors generated during record fetching.  \n  \n```  \nvirtual void CheckRowsetError(RETCODE nRetCode);\n```  \n  \n### Parameters  \n `nRetCode`  \n An ODBC API function return code. For details, see Remarks.  \n  \n### Remarks  \n This virtual member function handles errors that occur when records are fetched, and is useful during bulk row fetching. You may want to consider overriding `CheckRowsetError` to implement your own error handling.  \n  \n `CheckRowsetError` is called automatically in a cursor navigation operation, such as **Open**, **Requery**, or any **Move** operation. It is passed the return value of the ODBC API function **SQLExtendedFetch**. The following table lists the possible values for the `nRetCode` parameter.  \n  \n|nRetCode|Description|  \n|--------------|-----------------|  \n|**SQL_SUCCESS**|Function completed successfully; no additional information is available.|  \n|**SQL_SUCCESS_WITH_INFO**|Function completed successfully, possibly with a nonfatal error. Additional information can be obtained by calling **SQLError**.|  \n|**SQL_NO_DATA_FOUND**|All rows from the result set have been fetched.|  \n|**SQL_ERROR**|Function failed. Additional information can be obtained by calling **SQLError**.|  \n|**SQL_INVALID_HANDLE**|Function failed due to an invalid environment handle, connection handle, or statement handle. This indicates a programming error. No additional information is available from **SQLError**.|  \n|`SQL_STILL_EXECUTING`|A function that was started asynchronously is still executing. Note that by default, MFC will never pass this value to `CheckRowsetError`; MFC will continue calling **SQLExtendedFetch** until it no longer returns `SQL_STILL_EXECUTING`.|  \n  \n For more information about **SQLError**, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n##  <a name=\"crecordset__close\"></a>  CRecordset::Close  \n Closes the recordset.  \n  \n```  \nvirtual void Close();\n```  \n  \n### Remarks  \n The ODBC **HSTMT** and all memory the framework allocated for the recordset are deallocated. Usually after calling **Close**, you delete the C++ recordset object if it was allocated with **new**.  \n  \n You can call **Open** again after calling **Close**. This lets you reuse the recordset object. The alternative is to call **Requery**.  \n  \n### Example  \n [!code-cpp[NVC_MFCDatabase#17](../../mfc/codesnippet/cpp/crecordset-class_1.cpp)]  \n  \n##  <a name=\"crecordset__crecordset\"></a>  CRecordset::CRecordset  \n Constructs a `CRecordset` object.  \n  \n```  \nCRecordset(CDatabase* pDatabase = NULL);\n```  \n  \n### Parameters  \n `pDatabase`  \n Contains a pointer to a `CDatabase` object or the value **NULL**. If not **NULL** and the `CDatabase` object's **Open** member function has not been called to connect it to the data source, the recordset attempts to open it for you during its own **Open** call. If you pass **NULL**, a `CDatabase` object is constructed and connected for you using the data source information you specified when you derived your recordset class with ClassWizard.  \n  \n### Remarks  \n You can either use `CRecordset` directly or derive an application-specific class from `CRecordset`. You can use ClassWizard to derive your recordset classes.  \n  \n> [!NOTE]\n>  A derived class *must* supply its own constructor. In the constructor of your derived class, call the constructor `CRecordset::CRecordset`, passing the appropriate parameters along to it.  \n  \n Pass **NULL** to your recordset constructor to have a `CDatabase` object constructed and connected for you automatically. This is a useful shorthand that does not require you to construct and connect a `CDatabase` object prior to constructing your recordset.  \n  \n### Example  \n For more information, see the article [Recordset: Declaring a Class for a Table (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-table-odbc.md).  \n  \n##  <a name=\"crecordset__delete\"></a>  CRecordset::Delete  \n Deletes the current record.  \n  \n```  \nvirtual void Delete();\n```  \n  \n### Remarks  \n After a successful deletion, the recordset's field data members are set to a Null value, and you must explicitly call one of the **Move** functions in order to move off the deleted record. Once you move off the deleted record, it is not possible to return to it. If the data source supports transactions, you can make the **Delete** call part of a transaction. For more information, see the article [Transaction (ODBC)](../../data/odbc/transaction-odbc.md).  \n  \n> [!NOTE]\n>  If you have implemented bulk row fetching, you cannot call **Delete**. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n> [!CAUTION]\n>  The recordset must be updatable and there must be a valid record current in the recordset when you call **Delete**; otherwise, an error occurs. For example, if you delete a record but do not scroll to a new record before you call **Delete** again, **Delete** throws a [CDBException](../../mfc/reference/cdbexception-class.md).  \n  \n Unlike [AddNew](#crecordset__addnew) and [Edit](#crecordset__edit), a call to **Delete** is not followed by a call to [Update](#crecordset__update). If a **Delete** call fails, the field data members are left unchanged.  \n  \n### Example  \n This example shows a recordset created on the frame of a function. The example assumes the existence of `m_dbCust`, a member variable of type `CDatabase` already connected to the data source.  \n  \n [!code-cpp[NVC_MFCDatabase#18](../../mfc/codesnippet/cpp/crecordset-class_2.cpp)]  \n  \n##  <a name=\"crecordset__dobulkfieldexchange\"></a>  CRecordset::DoBulkFieldExchange  \n Called to exchange bulk rows of data from the data source to the recordset. Implements bulk record field exchange (Bulk RFX).  \n  \n```  \nvirtual void DoBulkFieldExchange(CFieldExchange* pFX);\n```  \n  \n### Parameters  \n `pFX`  \n A pointer to a [CFieldExchange](../../mfc/reference/cfieldexchange-class.md) object. The framework will already have set up this object to specify a context for the field exchange operation.  \n  \n### Remarks  \n When bulk row fetching is implemented, the framework calls this member function to automatically transfer data from the data source to your recordset object. `DoBulkFieldExchange` also binds your parameter data members, if any, to parameter placeholders in the SQL statement string for the recordset's selection.  \n  \n If bulk row fetching is not implemented, the framework calls [DoFieldExchange](#crecordset__dofieldexchange). To implement bulk row fetching, you must specify the `CRecordset::useMultiRowFetch` option of the `dwOptions` parameter in the [Open](#crecordset__open) member function.  \n  \n> [!NOTE]\n> `DoBulkFieldExchange` is available only if you are using a class derived from `CRecordset`. If you have created a recordset object directly from `CRecordset`, you must call the [GetFieldValue](#crecordset__getfieldvalue) member function to retrieve data.  \n  \n Bulk record field exchange (Bulk RFX) is similar to record field exchange (RFX). Data is automatically transferred from the data source to the recordset object. However, you cannot call `AddNew`, **Edit**, **Delete**, or **Update** to transfer changes back to the data source. Class `CRecordset` currently does not provide a mechanism for updating bulk rows of data; however, you can write your own functions by using the ODBC API function **SQLSetPos**.  \n  \n Note that ClassWizard does not support bulk record field exchange; therefore, you must override `DoBulkFieldExchange` manually by writing calls to the Bulk RFX functions. For more information about these functions, see the topic [Record Field Exchange Functions](../../mfc/reference/record-field-exchange-functions.md).  \n  \n For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md). For related information, see the article [Record Field Exchange (RFX)](../../data/odbc/record-field-exchange-rfx.md).  \n  \n##  <a name=\"crecordset__dofieldexchange\"></a>  CRecordset::DoFieldExchange  \n Called to exchange data (in both directions) between the field data members of the recordset and the corresponding record on the data source. Implements record field exchange (RFX).  \n  \n```  \nvirtual void DoFieldExchange(CFieldExchange* pFX);\n```  \n  \n### Parameters  \n `pFX`  \n A pointer to a [CFieldExchange](../../mfc/reference/cfieldexchange-class.md) object. The framework will already have set up this object to specify a context for the field exchange operation.  \n  \n### Remarks  \n When bulk row fetching is not implemented, the framework calls this member function to automatically exchange data between the field data members of your recordset object and the corresponding columns of the current record on the data source. `DoFieldExchange` also binds your parameter data members, if any, to parameter placeholders in the SQL statement string for the recordset's selection.  \n  \n If bulk row fetching is implemented, the framework calls [DoBulkFieldExchange](#crecordset__dobulkfieldexchange). To implement bulk row fetching, you must specify the `CRecordset::useMultiRowFetch` option of the `dwOptions` parameter in the [Open](#crecordset__open) member function.  \n  \n> [!NOTE]\n> `DoFieldExchange` is available only if you are using a class derived from `CRecordset`. If you have created a recordset object directly from `CRecordset`, you must call the [GetFieldValue](#crecordset__getfieldvalue) member function to retrieve data.  \n  \n The exchange of field data, called record field exchange (RFX), works in both directions: from the recordset object's field data members to the fields of the record on the data source, and from the record on the data source to the recordset object.  \n  \n The only action you must normally take to implement `DoFieldExchange` for your derived recordset class is to create the class with ClassWizard and specify the names and data types of the field data members. You might also add code to what ClassWizard writes to specify parameter data members or to deal with any columns you bind dynamically. For more information, see the article [Recordset: Dynamically Binding Data Columns (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md).  \n  \n When you declare your derived recordset class with ClassWizard, the wizard writes an override of `DoFieldExchange` for you, which resembles the following example:  \n  \n [!code-cpp[NVC_MFCDatabase#19](../../mfc/codesnippet/cpp/crecordset-class_3.cpp)]  \n  \n For more information about the RFX functions, see the topic [Record Field Exchange Functions](../../mfc/reference/record-field-exchange-functions.md).  \n  \n For further examples and details about `DoFieldExchange`, see the article [Record Field Exchange: How RFX Works](../../data/odbc/record-field-exchange-how-rfx-works.md). For general information about RFX, see the article [Record Field Exchange](../../data/odbc/record-field-exchange-rfx.md).  \n  \n##  <a name=\"crecordset__edit\"></a>  CRecordset::Edit  \n Allows changes to the current record.  \n  \n```  \nvirtual void Edit();\n```  \n  \n### Remarks  \n After you call **Edit**, you can change the field data members by directly resetting their values. The operation is completed when you subsequently call the [Update](#crecordset__update) member function to save your changes on the data source.  \n  \n> [!NOTE]\n>  If you have implemented bulk row fetching, you cannot call **Edit**. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n **Edit** saves the values of the recordset's data members. If you call **Edit**, make changes, then call **Edit** again, the record's values are restored to what they were before the first **Edit** call.  \n  \n In some cases, you may want to update a column by making it Null (containing no data). To do so, call [SetFieldNull](#crecordset__setfieldnull) with a parameter of **TRUE** to mark the field Null; this also causes the column to be updated. If you want a field to be written to the data source even though its value has not changed, call [SetFieldDirty](#crecordset__setfielddirty) with a parameter of **TRUE**. This works even if the field had the value Null.  \n  \n If the data source supports transactions, you can make the **Edit** call part of a transaction. Note that you should call [CDatabase::BeginTrans](../../mfc/reference/cdatabase-class.md#cdatabase__begintrans) before calling **Edit** and after the recordset has been opened. Also note that calling [CDatabase::CommitTrans](../../mfc/reference/cdatabase-class.md#cdatabase__committrans) is not a substitute for calling **Update** to complete the **Edit** operation. For more information about transactions, see class [CDatabase](../../mfc/reference/cdatabase-class.md).  \n  \n Depending on the current locking mode, the record being updated may be locked by **Edit** until you call **Update** or scroll to another record, or it may be locked only during the **Edit** call. You can change the locking mode with [SetLockingMode](#crecordset__setlockingmode).  \n  \n The previous value of the current record is restored if you scroll to a new record before calling **Update**. A `CDBException` is thrown if you call **Edit** for a recordset that cannot be updated or if there is no current record.  \n  \n For more information, see the articles [Transaction (ODBC)](../../data/odbc/transaction-odbc.md) and [Recordset: Locking Records (ODBC)](../../data/odbc/recordset-locking-records-odbc.md).  \n  \n### Example  \n [!code-cpp[NVC_MFCDatabase#20](../../mfc/codesnippet/cpp/crecordset-class_4.cpp)]  \n  \n##  <a name=\"crecordset__flushresultset\"></a>  CRecordset::FlushResultSet  \n Retrieves the next result set of a predefined query (stored procedure), if there are multiple result sets.  \n  \n```  \nBOOL FlushResultSet();\n```  \n  \n### Return Value  \n Nonzero if there are more result sets to be retrieved; otherwise 0.  \n  \n### Remarks  \n You should call `FlushResultSet` only when you are completely finished with the cursor on the current result set. Note that when you retrieve the next result set by calling `FlushResultSet`, your cursor is not valid on that result set; you should call the [MoveNext](#crecordset__movenext) member function after calling `FlushResultSet`.  \n  \n If a predefined query uses an output parameter or input/output parameters, you must call `FlushResultSet` until it returns `FALSE` (the value 0), in order to obtain these parameter values.  \n  \n `FlushResultSet` calls the ODBC API function `SQLMoreResults`. If `SQLMoreResults` returns `SQL_ERROR` or `SQL_INVALID_HANDLE`, then `FlushResultSet` will throw an exception. For more information about `SQLMoreResults`, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n Your stored procedure needs to have bound fields if you want to call `FlushResultSet`.  \n  \n### Example  \n The following code assumes that `COutParamRecordset` is a `CRecordset`-derived object based on a predefined query with an input parameter and an output parameter, and having multiple result sets. Note the structure of the [DoFieldExchange](#crecordset__dofieldexchange) override.  \n  \n [!code-cpp[NVC_MFCDatabase#21](../../mfc/codesnippet/cpp/crecordset-class_5.cpp)]  \n  \n [!code-cpp[NVC_MFCDatabase#22](../../mfc/codesnippet/cpp/crecordset-class_6.cpp)]  \n  \n##  <a name=\"crecordset__getbookmark\"></a>  CRecordset::GetBookmark  \n Obtains the bookmark value for the current record.  \n  \n```  \nvoid GetBookmark(CDBVariant& varBookmark);\n```  \n  \n### Parameters  \n `varBookmark`  \n A reference to a [CDBVariant](../../mfc/reference/cdbvariant-class.md) object representing the bookmark on the current record.  \n  \n### Remarks  \n To determine if bookmarks are supported on the recordset, call [CanBookmark](#crecordset__canbookmark). To make bookmarks available if they are supported, you must set the **CRecordset::useBookmarks** option in the `dwOptions` parameter of the [Open](#crecordset__open) member function.  \n  \n> [!NOTE]\n>  If bookmarks are unsupported or unavailable, calling `GetBookmark` will result in an exception being thrown. Bookmarks are not supported on forward-only recordsets.  \n  \n `GetBookmark` assigns the value of the bookmark for the current record to a `CDBVariant` object. To return to that record at any time after moving to a different record, call [SetBookmark](#crecordset__setbookmark) with the corresponding `CDBVariant` object.  \n  \n> [!NOTE]\n>  After certain recordset operations, bookmarks may no longer be valid. For example, if you call `GetBookmark` followed by **Requery**, you may not be able to return to the record with `SetBookmark`. Call [CDatabase::GetBookmarkPersistence](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence) to check whether you can safely call `SetBookmark`.  \n  \n For more information about bookmarks and recordset navigation, see the articles [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md) and [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md).  \n  \n##  <a name=\"crecordset__getdefaultconnect\"></a>  CRecordset::GetDefaultConnect  \n Called to get the default connection string.  \n  \n```  \nvirtual CString GetDefaultConnect();\n```  \n  \n### Return Value  \n A `CString` that contains the default connection string.  \n  \n### Remarks  \n The framework calls this member function to get the default connection string for the data source on which the recordset is based. ClassWizard implements this function for you by identifying the same data source you use in ClassWizard to get information about tables and columns. You will probably find it convenient to rely on this default connection while developing your application. But the default connection may not be appropriate for users of your application. If that is the case, you should reimplement this function, discarding ClassWizard's version. For more information about connection strings, see the article [Data Source (ODBC)](../../data/odbc/data-source-odbc.md).  \n  \n##  <a name=\"crecordset__getdefaultsql\"></a>  CRecordset::GetDefaultSQL  \n Called to get the default SQL string to execute.  \n  \n```  \nvirtual CString GetDefaultSQL();\n```  \n  \n### Return Value  \n A `CString` that contains the default SQL statement.  \n  \n### Remarks  \n The framework calls this member function to get the default SQL statement on which the recordset is based. This might be a table name or a SQL **SELECT** statement.  \n  \n You indirectly define the default SQL statement by declaring your recordset class with ClassWizard, and ClassWizard performs this task for you.  \n  \n If you need the SQL statement string for your own use, call `GetSQL`, which returns the SQL statement used to select the recordset's records when it was opened. You can edit the default SQL string in your class's override of `GetDefaultSQL`. For example, you could specify a call to a predefined query using a **CALL** statement. (Note, however, that if you edit `GetDefaultSQL`, you also need to modify `m_nFields` to match the number of columns in the data source.)  \n  \n For more information, see the article [Recordset: Declaring a Class for a Table (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-table-odbc.md).  \n  \n> [!CAUTION]\n>  The table name will be empty if the framework could not identify a table name, if multiple table names were supplied, or if a **CALL** statement could not be interpreted. Note that when using a **CALL** statement, you must not insert whitespace between the curly brace and the **CALL** keyword, nor should you insert whitespace before the curly brace or before the **SELECT** keyword in a **SELECT** statement.  \n  \n##  <a name=\"crecordset__getfieldvalue\"></a>  CRecordset::GetFieldValue  \n Retrieves field data in the current record.  \n  \n```  \nvoid GetFieldValue(\n    LPCTSTR lpszName,  \n    CDBVariant& varValue,  \n    short nFieldType = DEFAULT_FIELD_TYPE);\n\n \nvoid GetFieldValue(\n    short nIndex,  \n    CDBVariant& varValue,  \n    short nFieldType = DEFAULT_FIELD_TYPE);\n\n \nvoid GetFieldValue(\n    short nIndex,  \n    CStringA& strValue);\n\n \nvoid GetFieldValue(\n    short nIndex,  \n    CStringW& strValue);\n```  \n  \n### Parameters  \n `lpszName`  \n The name of a field.  \n  \n *varValu*e  \n A reference to a [CDBVariant](../../mfc/reference/cdbvariant-class.md) object that will store the field's value.  \n  \n `nFieldType`  \n The ODBC C data type of the field. Using the default value, **DEFAULT_FIELD_TYPE**, forces `GetFieldValue` to determine the C data type from the SQL data type, based on the following table. Otherwise, you can specify the data type directly or choose a compatible data type; for example, you can store any data type into **SQL_C_CHAR**.  \n  \n|C data type|SQL data type|  \n|-----------------|-------------------|  \n|**SQL_C_BIT**|**SQL_BIT**|  \n|**SQL_C_UTINYINT**|**SQL_TINYINT**|  \n|**SQL_C_SSHORT**|**SQL_SMALLINT**|  \n|**SQL_C_SLONG**|**SQL_INTEGER**|  \n|**SQL_C_FLOAT**|**SQL_REAL**|  \n|**SQL_C_DOUBLE**|**SQL_FLOATSQL_DOUBLE**|  \n|**SQL_C_TIMESTAMP**|**SQL_DATESQL_TIMESQL_TIMESTAMP**|  \n|**SQL_C_CHAR**|**SQL_NUMERICSQL_DECIMALSQL_BIGINTSQL_CHARSQL_VARCHARSQL_LONGVARCHAR**|  \n|**SQL_C_BINARY**|**SQL_BINARYSQL_VARBINARYSQL_LONGVARBINARY**|  \n  \n For more information about ODBC data types, see the topics \"SQL Data Types\" and \"C Data Types\" in Appendix D of the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n `nIndex`  \n The zero-based index of the field.  \n  \n `strValue`  \n A reference to a [CString](../../atl-mfc-shared/reference/cstringt-class.md) object that will store the field's value converted to text, regardless of the field's data type.  \n  \n### Remarks  \n You can look up a field either by name or by index. You can store the field value in either a `CDBVariant` object or a `CString` object.  \n  \n If you have implemented bulk row fetching, the current record is always positioned on the first record in a rowset. To use `GetFieldValue` on a record within a given rowset, you must first call the [SetRowsetCursorPosition](#crecordset__setrowsetcursorposition) member function to move the cursor to the desired row within that rowset. Then call `GetFieldValue` for that row. To implement bulk row fetching, you must specify the `CRecordset::useMultiRowFetch` option of the `dwOptions` parameter in the [Open](#crecordset__open) member function.  \n  \n You can use `GetFieldValue` to dynamically fetch fields at run time rather than statically binding them at design time. For example, if you have declared a recordset object directly from `CRecordset`, you must use `GetFieldValue` to retrieve the field data; record field exchange (RFX), or bulk record field exchange (Bulk RFX), is not implemented.  \n  \n> [!NOTE]\n>  If you declare a recordset object without deriving from `CRecordset`, do not have the ODBC Cursor Library loaded. The cursor library requires that the recordset have at least one bound column; however, when you use `CRecordset` directly, none of the columns are bound. The member functions [CDatabase::OpenEx](../../mfc/reference/cdatabase-class.md#cdatabase__openex) and [CDatabase::Open](../../mfc/reference/cdatabase-class.md#cdatabase__open) control whether the cursor library will be loaded.  \n  \n `GetFieldValue` calls the ODBC API function **SQLGetData**. If your driver outputs the value **SQL_NO_TOTAL** for the actual length of the field value, `GetFieldValue` throws an exception. For more information about **SQLGetData**, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n### Example  \n The following sample code illustrates calls to `GetFieldValue` for a recordset object declared directly from `CRecordset`.  \n  \n [!code-cpp[NVC_MFCDatabase#23](../../mfc/codesnippet/cpp/crecordset-class_7.cpp)]  \n  \n> [!NOTE]\n>  Unlike the DAO class `CDaoRecordset`, `CRecordset` does not have a `SetFieldValue` member function. If you create an object directly from `CRecordset`, it is effectively read-only.  \n  \n For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n##  <a name=\"crecordset__getodbcfieldcount\"></a>  CRecordset::GetODBCFieldCount  \n Retrieves the total number of fields in your recordset object.  \n  \n```  \nshort GetODBCFieldCount() const;\n\n \n```  \n  \n### Return Value  \n The number of fields in the recordset.  \n  \n### Remarks  \n For more information about creating recordsets, see the article [Recordset: Creating and Closing Recordsets (ODBC)](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md).  \n  \n##  <a name=\"crecordset__getodbcfieldinfo\"></a>  CRecordset::GetODBCFieldInfo  \n Obtains information about the fields in the recordset.  \n  \n```  \nvoid GetODBCFieldInfo(\n    LPCTSTR lpszName,  \n    CODBCFieldInfo& fieldinfo);\n\n \nvoid GetODBCFieldInfo(\n    short nIndex,  \n    CODBCFieldInfo& fieldinfo);\n```  \n  \n### Parameters  \n `lpszName`  \n The name of a field.  \n  \n `fieldinfo`  \n A reference to a `CODBCFieldInfo` structure.  \n  \n `nIndex`  \n The zero-based index of the field.  \n  \n### Remarks  \n One version of the function lets you look up a field by name. The other version lets you look up a field by index.  \n  \n For a description about the information returned, see the [CODBCFieldInfo](../../mfc/reference/codbcfieldinfo-structure.md) structure.  \n  \n For more information about creating recordsets, see the article [Recordset: Creating and Closing Recordsets (ODBC)](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md).  \n  \n##  <a name=\"crecordset__getrecordcount\"></a>  CRecordset::GetRecordCount  \n Determines the size of the recordset.  \n  \n```  \nlong GetRecordCount() const;\n\n \n```  \n  \n### Return Value  \n The number of records in the recordset; 0 if the recordset contains no records; or 1 if the record count cannot be determined.  \n  \n### Remarks  \n  \n> [!CAUTION]\n>  The record count is maintained as a \"high water mark,\" the highest-numbered record yet seen as the user moves through the records. The total number of records is only known after the user has moved beyond the last record. For performance reasons, the count is not updated when you call `MoveLast`. To count the records yourself, call `MoveNext` repeatedly until `IsEOF` returns nonzero. Adding a record via **CRecordset:AddNew** and **Update** increases the count; deleting a record via `CRecordset::Delete` decreases the count.  \n  \n##  <a name=\"crecordset__getrowsetsize\"></a>  CRecordset::GetRowsetSize  \n Obtains the current setting for the number of rows you wish to retrieve during a given fetch.  \n  \n```  \nDWORD GetRowsetSize() const;\n\n \n```  \n  \n### Return Value  \n The number of rows to retrieve during a given fetch.  \n  \n### Remarks  \n If you are using bulk row fetching, the default rowset size when the recordset is opened is 25; otherwise, it is 1.  \n  \n To implement bulk row fetching, you must specify the `CRecordset::useMultiRowFetch` option in the `dwOptions` parameter of the [Open](#crecordset__open) member function. To change the setting for the rowset size, call [SetRowsetSize](#crecordset__setrowsetsize).  \n  \n For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n##  <a name=\"crecordset__getrowsfetched\"></a>  CRecordset::GetRowsFetched  \n Determines how many records were actually retrieved after a fetch.  \n  \n```  \nDWORD GetRowsFetched() const;\n\n \n```  \n  \n### Return Value  \n The number of rows retrieved from the data source after a given fetch.  \n  \n### Remarks  \n This is useful when you have implemented bulk row fetching. The rowset size normally indicates how many rows will be retrieved from a fetch; however, the total number of rows in the recordset also affects how many rows will be retrieved in a rowset. For example, if your recordset has 10 records with a rowset size setting of 4, then looping through the recordset by calling `MoveNext` will result in the final rowset having only 2 records.  \n  \n To implement bulk row fetching, you must specify the `CRecordset::useMultiRowFetch` option in the `dwOptions` parameter of the [Open](#crecordset__open) member function. To specify the rowset size, call [SetRowsetSize](#crecordset__setrowsetsize).  \n  \n For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n### Example  \n [!code-cpp[NVC_MFCDatabase#24](../../mfc/codesnippet/cpp/crecordset-class_8.cpp)]  \n  \n##  <a name=\"crecordset__getrowstatus\"></a>  CRecordset::GetRowStatus  \n Obtains the status for a row in the current rowset.  \n  \n```  \nWORD GetRowStatus(WORD wRow) const;\n\n \n```  \n  \n### Parameters  \n `wRow`  \n The one-based position of a row in the current rowset. This value can range from 1 to the size of the rowset.  \n  \n### Return Value  \n A status value for the row. For details, see Remarks.  \n  \n### Remarks  \n `GetRowStatus` returns a value that indicates either any change in status to the row since it was last retrieved from the data source, or that no row corresponding to `wRow` was fetched. The following table lists the possible return values.  \n  \n|Status value|Description|  \n|------------------|-----------------|  \n|`SQL_ROW_SUCCESS`|The row is unchanged.|  \n|`SQL_ROW_UPDATED`|The row has been updated.|  \n|`SQL_ROW_DELETED`|The row has been deleted.|  \n|`SQL_ROW_ADDED`|The row has been added.|  \n|`SQL_ROW_ERROR`|The row is unretrievable due to an error.|  \n|`SQL_ROW_NOROW`|There is no row that corresponds to `wRow`.|  \n  \n For more information, see the ODBC API function **SQLExtendedFetch** in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n##  <a name=\"crecordset__getstatus\"></a>  CRecordset::GetStatus  \n Determines the index of the current record in the recordset and whether the last record has been seen.  \n  \n```  \nvoid GetStatus(CRecordsetStatus& rStatus) const;\n\n \n```  \n  \n### Parameters  \n `rStatus`  \n A reference to a **CRecordsetStatus** object. See the Remarks section for more information.  \n  \n### Remarks  \n `CRecordset` attempts to track the index, but under some circumstances this may not be possible. See [GetRecordCount](#crecordset__getrecordcount) for an explanation.  \n  \n The **CRecordsetStatus** structure has the following form:  \n  \n `struct CRecordsetStatus`  \n  \n `{`  \n  \n `long m_lCurrentRecord;`  \n  \n `BOOL m_bRecordCountFinal;`  \n  \n `};`  \n  \n The two members of **CRecordsetStatus** have the following meanings:  \n  \n- **m_lCurrentRecord** Contains the zero-based index of the current record in the recordset, if known. If the index cannot be determined, this member contains **AFX_CURRENT_RECORD_UNDEFINED** (2). If `IsBOF` is **TRUE** (empty recordset or attempt to scroll before first record), then **m_lCurrentRecord** is set to **AFX_CURRENT_RECORD_BOF** (1). If on the first record, then it is set to 0, second record 1, and so on.  \n  \n- **m_bRecordCountFinal** Nonzero if the total number of records in the recordset has been determined. Generally this must be accomplished by starting at the beginning of the recordset and calling `MoveNext` until `IsEOF` returns nonzero. If this member is zero, the record count as returned by `GetRecordCount`, if not 1, is only a \"high water mark\" count of the records.  \n  \n##  <a name=\"crecordset__getsql\"></a>  CRecordset::GetSQL  \n Call this member function to get the SQL statement that was used to select the recordset's records when it was opened.  \n  \n```  \nconst CString& GetSQL() const;\n\n \n```  \n  \n### Return Value  \n A **const** reference to a `CString` that contains the SQL statement.  \n  \n### Remarks  \n This will generally be a SQL **SELECT** statement. The string returned by `GetSQL` is read-only.  \n  \n The string returned by `GetSQL` is typically different from any string you may have passed to the recordset in the `lpszSQL` parameter to the **Open** member function. This is because the recordset constructs a full SQL statement based on what you passed to **Open**, what you specified with ClassWizard, what you may have specified in the **m_strFilter** and `m_strSort` data members, and any parameters you may have specified. For details about how the recordset constructs this SQL statement, see the article [Recordset: How Recordsets Select Records (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md).  \n  \n> [!NOTE]\n>  Call this member function only after calling [Open](#crecordset__open).  \n  \n##  <a name=\"crecordset__gettablename\"></a>  CRecordset::GetTableName  \n Gets the name of the SQL table on which the recordset's query is based.  \n  \n```  \nconst CString& GetTableName() const;\n\n \n```  \n  \n### Return Value  \n A **const** reference to a `CString` that contains the table name, if the recordset is based on a table; otherwise, an empty string.  \n  \n### Remarks  \n `GetTableName` is only valid if the recordset is based on a table, not a join of multiple tables or a predefined query (stored procedure). The name is read-only.  \n  \n> [!NOTE]\n>  Call this member function only after calling [Open](#crecordset__open).  \n  \n##  <a name=\"crecordset__isbof\"></a>  CRecordset::IsBOF  \n Returns nonzero if the recordset has been positioned before the first record. There is no current record.  \n  \n```  \nBOOL IsBOF() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the recordset contains no records or if you have scrolled backward before the first record; otherwise 0.  \n  \n### Remarks  \n Call this member function before you scroll from record to record to learn whether you have gone before the first record of the recordset. You can also use `IsBOF` along with `IsEOF` to determine whether the recordset contains any records or is empty. Immediately after you call **Open**, if the recordset contains no records, `IsBOF` returns nonzero.When you open a recordset that has at least one record, the first record is the current record and `IsBOF` returns 0.  \n  \n If the first record is the current record and you call `MovePrev`, `IsBOF` will subsequently return nonzero. If `IsBOF` returns nonzero and you call `MovePrev`, an error occurs. If `IsBOF` returns nonzero, the current record is undefined, and any action that requires a current record will result in an error.  \n  \n### Example  \n This example uses `IsBOF` and `IsEOF` to detect the limits of a recordset as the code scrolls through the recordset in both directions.  \n  \n [!code-cpp[NVC_MFCDatabase#25](../../mfc/codesnippet/cpp/crecordset-class_9.cpp)]  \n  \n##  <a name=\"crecordset__isdeleted\"></a>  CRecordset::IsDeleted  \n Determines whether the current record has been deleted.  \n  \n```  \nBOOL IsDeleted() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the recordset is positioned on a deleted record; otherwise 0.  \n  \n### Remarks  \n If you scroll to a record and `IsDeleted` returns **TRUE** (nonzero), then you must scroll to another record before you can perform any other recordset operations.  \n  \n The result of `IsDeleted` depends on many factors, such as your recordset type, whether your recordset is updatable, whether you specified the **CRecordset::skipDeletedRecords** option when you opened the recordset, whether your driver packs deleted records, and whether there are multiple users.  \n  \n For more information about **CRecordset::skipDeletedRecords** and driver packing, see the [Open](#crecordset__open) member function.  \n  \n> [!NOTE]\n>  If you have implemented bulk row fetching, you should not call `IsDeleted`. Instead, call the [GetRowStatus](#crecordset__getrowstatus) member function. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n##  <a name=\"crecordset__iseof\"></a>  CRecordset::IsEOF  \n Returns nonzero if the recordset has been positioned after the last record. There is no current record.  \n  \n```  \nBOOL IsEOF() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the recordset contains no records or if you have scrolled beyond the last record; otherwise 0.  \n  \n### Remarks  \n Call this member function as you scroll from record to record to learn whether you have gone beyond the last record of the recordset. You can also use `IsEOF` to determine whether the recordset contains any records or is empty. Immediately after you call **Open**, if the recordset contains no records, `IsEOF` returns nonzero. When you open a recordset that has at least one record, the first record is the current record and `IsEOF` returns 0.  \n  \n If the last record is the current record when you call `MoveNext`, `IsEOF` will subsequently return nonzero. If `IsEOF` returns nonzero and you call `MoveNext`, an error occurs. If `IsEOF` returns nonzero, the current record is undefined, and any action that requires a current record will result in an error.  \n  \n### Example  \n See the example for [IsBOF](#crecordset__isbof).  \n  \n##  <a name=\"crecordset__isfielddirty\"></a>  CRecordset::IsFieldDirty  \n Determines whether the specified field data member has been changed since [Edit](#crecordset__edit) or [AddNew](#crecordset__addnew) was called.  \n  \n```  \nBOOL IsFieldDirty(void* pv);\n```  \n  \n### Parameters  \n `pv`  \n A pointer to the field data member whose status you want to check, or **NULL** to determine if any of the fields are dirty.  \n  \n### Return Value  \n Nonzero if the specified field data member has changed since calling `AddNew` or **Edit**; otherwise 0.  \n  \n### Remarks  \n The data in all dirty field data members will be transferred to the record on the data source when the current record is updated by a call to the [Update](#crecordset__update) member function of `CRecordset` (following a call to **Edit** or `AddNew`).  \n  \n> [!NOTE]\n>  This member function is not applicable on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, then `IsFieldDirty` will always return **FALSE** and will result in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n Calling `IsFieldDirty` will reset the effects of preceding calls to [SetFieldDirty](#crecordset__setfielddirty) since the dirty status of the field is re-evaluated. In the `AddNew` case, if the current field value differs from the pseudo null value, the field status is set dirty. In the **Edit** case, if the field value differs from the cached value, then the field status is set dirty.  \n  \n `IsFieldDirty` is implemented through [DoFieldExchange](#crecordset__dofieldexchange).  \n  \n For more information on the dirty flag, see the article [Recordset: How Recordsets Select Records (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md).  \n  \n##  <a name=\"crecordset__isfieldnull\"></a>  CRecordset::IsFieldNull  \n Returns nonzero if the specified field in the current record is Null (has no value).  \n  \n```  \nBOOL IsFieldNull(void* pv);\n```  \n  \n### Parameters  \n `pv`  \n A pointer to the field data member whose status you want to check, or **NULL** to determine if any of the fields are Null.  \n  \n### Return Value  \n Nonzero if the specified field data member is flagged as Null; otherwise 0.  \n  \n### Remarks  \n Call this member function to determine whether the specified field data member of a recordset has been flagged as Null. (In database terminology, Null means \"having no value\" and is not the same as **NULL** in C++.) If a field data member is flagged as Null, it is interpreted as a column of the current record for which there is no value.  \n  \n> [!NOTE]\n>  This member function is not applicable on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, then `IsFieldNull` will always return **FALSE** and will result in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n `IsFieldNull` is implemented through [DoFieldExchange](#crecordset__dofieldexchange).  \n  \n##  <a name=\"crecordset__isfieldnullable\"></a>  CRecordset::IsFieldNullable  \n Returns nonzero if the specified field in the current record can be set to Null (having no value).  \n  \n```  \nBOOL IsFieldNullable(void* pv);\n```  \n  \n### Parameters  \n `pv`  \n A pointer to the field data member whose status you want to check, or **NULL** to determine if any of the fields can be set to a Null value.  \n  \n### Remarks  \n Call this member function to determine whether the specified field data member is \"nullable\" (can be set to a Null value; C++ **NULL** is not the same as Null, which, in database terminology, means \"having no value\").  \n  \n> [!NOTE]\n>  If you have implemented bulk row fetching, you cannot call `IsFieldNullable`. Instead, call the [GetODBCFieldInfo](#crecordset__getodbcfieldinfo) member function to determine whether a field can be set to a Null value. Note that you can always call `GetODBCFieldInfo`, regardless of whether you have implemented bulk row fetching. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n A field that cannot be Null must have a value. If you attempt to set a such a field to Null when adding or updating a record, the data source rejects the addition or update, and [Update](#crecordset__update) will throw an exception. The exception occurs when you call **Update**, not when you call [SetFieldNull](#crecordset__setfieldnull).  \n  \n Using **NULL** for the first argument of the function will apply the function only to **outputColumn** fields, not **param** fields. For instance, the call  \n  \n [!code-cpp[NVC_MFCDatabase#26](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)]  \n  \n will set only **outputColumn** fields to **NULL**; **param** fields will be unaffected.  \n  \n To work on **param** fields, you must supply the actual address of the individual **param** you want to work on, such as:  \n  \n [!code-cpp[NVC_MFCDatabase#27](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)]  \n  \n This means you cannot set all **param** fields to **NULL**, as you can with **outputColumn** fields.  \n  \n `IsFieldNullable` is implemented through [DoFieldExchange](#crecordset__dofieldexchange).  \n  \n##  <a name=\"crecordset__isopen\"></a>  CRecordset::IsOpen  \n Determines if the recordset is already open.  \n  \n```  \nBOOL IsOpen() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the recordset object's [Open](#crecordset__open) or [Requery](#crecordset__requery) member function has previously been called and the recordset has not been closed; otherwise 0.  \n  \n##  <a name=\"crecordset__m_hstmt\"></a>  CRecordset::m_hstmt  \n Contains a handle to the ODBC statement data structure, of type **HSTMT**, associated with the recordset.  \n  \n### Remarks  \n Each query to an ODBC data source is associated with an **HSTMT**.  \n  \n> [!CAUTION]\n>  Do not use **m_hstmt** before [Open](#crecordset__open) has been called.  \n  \n Normally you do not need to access the **HSTMT** directly, but you might need it for direct execution of SQL statements. The `ExecuteSQL` member function of class `CDatabase` provides an example of using **m_hstmt**.  \n  \n##  <a name=\"crecordset__m_nfields\"></a>  CRecordset::m_nFields  \n Contains the number of field data members in the recordset class; that is, the number of columns selected by the recordset from the data source.  \n  \n### Remarks  \n The constructor for the recordset class must initialize `m_nFields` with the correct number. If you have not implemented bulk row fetching, ClassWizard writes this initialization for you when you use it to declare your recordset class. You can also write it manually.  \n  \n The framework uses this number to manage interaction between the field data members and the corresponding columns of the current record on the data source.  \n  \n> [!CAUTION]\n>  This number must correspond to the number of \"output columns\" registered in `DoFieldExchange` or `DoBulkFieldExchange` after a call to [SetFieldType](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype) with the parameter **CFieldExchange::outputColumn**.  \n  \n You can bind columns dynamically, as explained in the article \"Recordset: Dynamically Binding Data Columns.\" If you do so, you must increase the count in `m_nFields` to reflect the number of RFX or Bulk RFX function calls in your `DoFieldExchange` or `DoBulkFieldExchange` member function for the dynamically bound columns.  \n  \n For more information, see the articles [Recordset: Dynamically Binding Data Columns (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md) and [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n### Example  \n See the article [Record Field Exchange: Using RFX](../../data/odbc/record-field-exchange-using-rfx.md).  \n  \n##  <a name=\"crecordset__m_nparams\"></a>  CRecordset::m_nParams  \n Contains the number of parameter data members in the recordset class; that is, the number of parameters passed with the recordset's query.  \n  \n### Remarks  \n If your recordset class has any parameter data members, the constructor for the class must initialize `m_nParams` with the correct number. The value of `m_nParams` defaults to 0. If you add parameter data members (which you must do manually) you must also manually add an initialization in the class constructor to reflect the number of parameters (which must be at least as large as the number of '' placeholders in your **m_strFilter** or `m_strSort` string).  \n  \n The framework uses this number when it parameterizes the recordset's query.  \n  \n> [!CAUTION]\n>  This number must correspond to the number of \"params\" registered in `DoFieldExchange` or `DoBulkFieldExchange` after a call to [SetFieldType](../../mfc/reference/cfieldexchange-class.md#cfieldexchange__setfieldtype) with a parameter value of **CFieldExchange::inputParam**, **CFieldExchange::param**, **CFieldExchange::outputParam**, or **CFieldExchange::inoutParam**.  \n  \n### Example  \n  See the articles [Recordset: Parameterizing a Recordset (ODBC)](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md) and [Record Field Exchange: Using RFX](../../data/odbc/record-field-exchange-using-rfx.md).  \n  \n##  <a name=\"crecordset__m_pdatabase\"></a>  CRecordset::m_pDatabase  \n Contains a pointer to the `CDatabase` object through which the recordset is connected to a data source.  \n  \n### Remarks  \n This variable is set in two ways. Typically, you pass a pointer to an already connected `CDatabase` object when you construct the recordset object. If you pass **NULL** instead, `CRecordset` creates a `CDatabase` object for you and connects it. In either case, `CRecordset` stores the pointer in this variable.  \n  \n Normally you will not directly need to use the pointer stored in **m_pDatabase**. If you write your own extensions to `CRecordset`, however, you might need to use the pointer. For example, you might need the pointer if you throw your own `CDBException`s. Or you might need it if you need to do something using the same `CDatabase` object, such as running transactions, setting timeouts, or calling the `ExecuteSQL` member function of class `CDatabase` to execute SQL statements directly.  \n  \n##  <a name=\"crecordset__m_strfilter\"></a>  CRecordset::m_strFilter  \n After you construct the recordset object, but before you call its **Open** member function, use this data member to store a `CString` containing a SQL **WHERE** clause.  \n  \n### Remarks  \n The recordset uses this string to constrain (or filter) the records it selects during the **Open** or **Requery** call. This is useful for selecting a subset of records, such as \"all salespersons based in California\" (\"state = CA\"). The ODBC SQL syntax for a **WHERE** clause is  \n  \n `WHERE search-condition`  \n  \n Note that you do not include the **WHERE** keyword in your string. The framework supplies it.  \n  \n You can also parameterize your filter string by placing '' placeholders in it, declaring a parameter data member in your class for each placeholder, and passing parameters to the recordset at run time. This lets you construct the filter at run time. For more information, see the article [Recordset: Parameterizing a Recordset (ODBC)](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md).  \n  \n For more information about SQL **WHERE** clauses, see the article [SQL](../../data/odbc/sql.md). For more information about selecting and filtering records, see the article [Recordset: Filtering Records (ODBC)](../../data/odbc/recordset-filtering-records-odbc.md).  \n  \n### Example  \n [!code-cpp[NVC_MFCDatabase#30](../../mfc/codesnippet/cpp/crecordset-class_12.cpp)]  \n  \n##  <a name=\"crecordset__m_strsort\"></a>  CRecordset::m_strSort  \n After you construct the recordset object, but before you call its **Open** member function, use this data member to store a `CString` containing a SQL **ORDER BY** clause.  \n  \n### Remarks  \n The recordset uses this string to sort the records it selects during the **Open** or **Requery** call. You can use this feature to sort a recordset on one or more columns. The ODBC SQL syntax for an **ORDER BY** clause is  \n  \n `ORDER BY sort-specification [, sort-specification]...`  \n  \n where a sort-specification is an integer or a column name. You can also specify ascending or descending order (the order is ascending by default) by appending \"ASC\" or \"DESC\" to the column list in the sort string. The selected records are sorted first by the first column listed, then by the second, and so on. For example, you might order a \"Customers\" recordset by last name, then first name. The number of columns you can list depends on the data source. For more information, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]*.*  \n  \n Note that you do not include the **ORDER BY** keyword in your string. The framework supplies it.  \n  \n For more information about SQL clauses, see the article [SQL](../../data/odbc/sql.md). For more information about sorting records, see the article [Recordset: Sorting Records (ODBC)](../../data/odbc/recordset-sorting-records-odbc.md).  \n  \n### Example  \n [!code-cpp[NVC_MFCDatabase#31](../../mfc/codesnippet/cpp/crecordset-class_13.cpp)]  \n  \n##  <a name=\"crecordset__move\"></a>  CRecordset::Move  \n Moves the current record pointer within the recordset, either forward or backward.  \n  \n```  \nvirtual void Move(\n    long nRows,  \n    WORD wFetchType = SQL_FETCH_RELATIVE);\n```  \n  \n### Parameters  \n `nRows`  \n The number of rows to move forward or backward. Positive values move forward, toward the end of the recordset. Negative values move backward, toward the beginning.  \n  \n `wFetchType`  \n Determines the rowset that **Move** will fetch. For details, see Remarks.  \n  \n### Remarks  \n If you pass a value of 0 for `nRows`, **Move** refreshes the current record; **Move** will end any current `AddNew` or **Edit** mode, and will restore the current record's value before `AddNew` or **Edit** was called.  \n  \n> [!NOTE]\n>  When you move through a recordset, you cannot skip deleted records. See [CRecordset::IsDeleted](#crecordset__isdeleted) for more information. When you open a `CRecordset` with the **skipDeletedRecords** option set, **Move** asserts if the `nRows` parameter is 0. This behavior prevents the refresh of rows that are deleted by other client applications using the same data. See the `dwOption` parameter in [Open](#crecordset__open) for a description of **skipDeletedRecords**.  \n  \n **Move** repositions the recordset by rowsets. Based on the values for `nRows` and `wFetchType`, **Move** fetches the appropriate rowset and then makes the first record in that rowset the current record. If you have not implemented bulk row fetching, then the rowset size is always 1. When fetching a rowset, **Move** directly calls the [CheckRowsetError](#crecordset__checkrowseterror) member function to handle any errors resulting from the fetch.  \n  \n Depending on the values you pass, **Move** is equivalent to other `CRecordset` member functions. In particular, the value of `wFetchType` may indicate a member function that is more intuitive and often the preferred method for moving the current record.  \n  \n The following table lists the possible values for `wFetchType`, the rowset that **Move** will fetch based on `wFetchType` and `nRows`, and any equivalent member function corresponding to `wFetchType`.  \n  \n|wFetchType|Fetched rowset|Equivalent member function|  \n|----------------|--------------------|--------------------------------|  \n|`SQL_FETCH_RELATIVE` (the default value)|The rowset starting `nRows` row(s) from the first row in the current rowset.||  \n|`SQL_FETCH_NEXT`|The next rowset; `nRows` is ignored.|[MoveNext](#crecordset__movenext)|  \n|`SQL_FETCH_PRIOR`|The previous rowset; `nRows` is ignored.|[MovePrev](#crecordset__moveprev)|  \n|`SQL_FETCH_FIRST`|The first rowset in the recordset; `nRows` is ignored.|[MoveFirst](#crecordset__movefirst)|  \n|`SQL_FETCH_LAST`|The last complete rowset in the recordset; `nRows` is ignored.|[MoveLast](#crecordset__movelast)|  \n|`SQL_FETCH_ABSOLUTE`|If `nRows` > 0, the rowset starting `nRows` row(s) from the beginning of the recordset. If `nRows` < 0, the rowset starting `nRows` row(s) from the end of the recordset. If `nRows` = 0, then a beginning-of-file (BOF) condition is returned.|[SetAbsolutePosition](#crecordset__setabsoluteposition)|  \n|`SQL_FETCH_BOOKMARK`|The rowset starting at the row whose bookmark value corresponds to `nRows`.|[SetBookmark](#crecordset__setbookmark)|  \n  \n> [!NOTE]\n>  For foward-only recordsets, **Move** is only valid with a value of `SQL_FETCH_NEXT` for `wFetchType`.  \n  \n> [!CAUTION]\n>  Calling **Move** throws an exception if the recordset has no records. To determine whether the recordset has any records, call [IsBOF](#crecordset__isbof) and [IsEOF](#crecordset__iseof).  \n  \n> [!NOTE]\n>  If you have scrolled past the beginning or end of the recordset ( `IsBOF` or `IsEOF` returns nonzero), calling a **Move** function will possibly throw a `CDBException`. For example, if `IsEOF` returns nonzero and `IsBOF` does not, then `MoveNext` will throw an exception, but `MovePrev` will not.  \n  \n> [!NOTE]\n>  If you call **Move** while the current record is being updated or added, the updates are lost without warning.  \n  \n For more information about recordset navigation, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md). For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md). For related information, see the ODBC API function **SQLExtendedFetch** in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n### Example  \n [!code-cpp[NVC_MFCDatabase#28](../../mfc/codesnippet/cpp/crecordset-class_14.cpp)]  \n  \n##  <a name=\"crecordset__movefirst\"></a>  CRecordset::MoveFirst  \n Makes the first record in the first rowset the current record.  \n  \n```  \nvoid MoveFirst();\n```  \n  \n### Remarks  \n Regardless of whether bulk row fetching has been implemented, this will always be the first record in the recordset.  \n  \n You do not have to call **MoveFirst** immediately after you open the recordset. At that time, the first record (if any) is automatically the current record.  \n  \n> [!NOTE]\n>  This member function is not valid for forward-only recordsets.  \n  \n> [!NOTE]\n>  When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.  \n  \n> [!CAUTION]\n>  Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.  \n  \n> [!NOTE]\n>  If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning.  \n  \n For more information about recordset navigation, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md). For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n### Example  \n  See the example for [IsBOF](#crecordset__isbof).  \n  \n##  <a name=\"crecordset__movelast\"></a>  CRecordset::MoveLast  \n Makes the first record in the last complete rowset the current record.  \n  \n```  \nvoid MoveLast();\n```  \n  \n### Remarks  \n If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so `MoveLast` simply moves to the last record in the recordset.  \n  \n> [!NOTE]\n>  This member function is not valid for forward-only recordsets.  \n  \n> [!NOTE]\n>  When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.  \n  \n> [!CAUTION]\n>  Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.  \n  \n> [!NOTE]\n>  If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning.  \n  \n For more information about recordset navigation, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md). For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n### Example  \n  See the example for [IsBOF](#crecordset__isbof).  \n  \n##  <a name=\"crecordset__movenext\"></a>  CRecordset::MoveNext  \n Makes the first record in the next rowset the current record.  \n  \n```  \nvoid MoveNext();\n```  \n  \n### Remarks  \n If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so `MoveNext` simply moves to the next record.  \n  \n> [!NOTE]\n>  When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.  \n  \n> [!CAUTION]\n>  Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.  \n  \n> [!NOTE]\n>  It is also recommended that you call `IsEOF` before calling `MoveNext`. For example, if you have scrolled past the end of the recordset, `IsEOF` will return nonzero; a subsequent call to `MoveNext` would throw an exception.  \n  \n> [!NOTE]\n>  If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning.  \n  \n For more information about recordset navigation, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md). For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n### Example  \n  See the example for [IsBOF](#crecordset__isbof).  \n  \n##  <a name=\"crecordset__moveprev\"></a>  CRecordset::MovePrev  \n Makes the first record in the previous rowset the current record.  \n  \n```  \nvoid MovePrev();\n```  \n  \n### Remarks  \n If you have not implemented bulk row fetching, your recordset has a rowset size of 1, so `MovePrev` simply moves to the previous record.  \n  \n> [!NOTE]\n>  This member function is not valid for forward-only recordsets.  \n  \n> [!NOTE]\n>  When you move through a recordset, you cannot skip deleted records. See the [IsDeleted](#crecordset__isdeleted) member function for details.  \n  \n> [!CAUTION]\n>  Calling any of the **Move** functions throws an exception if the recordset has no records. To determine whether the recordset has any records, call `IsBOF` and `IsEOF`.  \n  \n> [!NOTE]\n>  It is also recommended that you call `IsBOF` before calling `MovePrev`. For example, if you have scrolled ahead of the beginning of the recordset, `IsBOF` will return nonzero; a subsequent call to `MovePrev` would throw an exception.  \n  \n> [!NOTE]\n>  If you call any of the **Move** functions while the current record is being updated or added, the updates are lost without warning.  \n  \n For more information about recordset navigation, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md). For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n### Example  \n  See the example for [IsBOF](#crecordset__isbof).  \n  \n##  <a name=\"crecordset__onsetoptions\"></a>  CRecordset::OnSetOptions  \n Called to set options (used on selection) for the specified ODBC statement.  \n  \n```  \nvirtual void OnSetOptions(HSTMT hstmt);\n```  \n  \n### Parameters  \n `hstmt`  \n The **HSTMT** of the ODBC statement whose options are to be set.  \n  \n### Remarks  \n Call `OnSetOptions` to set options (used on selection) for the specified ODBC statement. The framework calls this member function to set initial options for the recordset. `OnSetOptions` determines the data source's support for scrollable cursors and for cursor concurrency and sets the recordset's options accordingly. (Whereas `OnSetOptions` is used for selection operations, `OnSetUpdateOptions` is used for update operations.)  \n  \n Override `OnSetOptions` to set options specific to the driver or the data source. For example, if your data source supports opening for exclusive access, you might override `OnSetOptions` to take advantage of that ability.  \n  \n For more information about cursors, see the article [ODBC](../../data/odbc/odbc-basics.md).  \n  \n##  <a name=\"crecordset__onsetupdateoptions\"></a>  CRecordset::OnSetUpdateOptions  \n Called to set options (used on update) for the specified ODBC statement.  \n  \n```  \nvirtual void OnSetUpdateOptions(HSTMT hstmt);\n```  \n  \n### Parameters  \n `hstmt`  \n The **HSTMT** of the ODBC statement whose options are to be set.  \n  \n### Remarks  \n Call `OnSetUpdateOptions` to set options (used on update) for the specified ODBC statement. The framework calls this member function after it creates an HSTMT to update records in a recordset. (Whereas `OnSetOptions` is used for selection operations, `OnSetUpdateOptions` is used for update operations.) `OnSetUpdateOptions` determines the data source's support for scrollable cursors and for cursor concurrency and sets the recordset's options accordingly.  \n  \n Override `OnSetUpdateOptions` to set options of an ODBC statement before that statement is used to access a database.  \n  \n For more information about cursors, see the article [ODBC](../../data/odbc/odbc-basics.md).  \n  \n##  <a name=\"crecordset__open\"></a>  CRecordset::Open  \n Opens the recordset by retrieving the table or performing the query that the recordset represents.  \n  \n```  \nvirtual BOOL Open(\n    UINT nOpenType = AFX_DB_USE_DEFAULT_TYPE,  \n    LPCTSTR lpszSQL = NULL,  \n    DWORD dwOptions = none);\n```  \n  \n### Parameters  \n `nOpenType`  \n Accept the default value, **AFX_DB_USE_DEFAULT_TYPE**, or use one of the following values from the **enum OpenType**:  \n  \n- **CRecordset::dynaset** A recordset with bi-directional scrolling. The membership and ordering of the records are determined when the recordset is opened, but changes made by other users to the data values are visible following a fetch operation. Dynasets are also known as keyset-driven recordsets.  \n  \n- **CRecordset::snapshot** A static recordset with bi-directional scrolling. The membership and ordering of the records are determined when the recordset is opened; the data values are determined when the records are fetched. Changes made by other users are not visible until the recordset is closed and then reopened.  \n  \n- **CRecordset::dynamic** A recordset with bi-directional scrolling. Changes made by other users to the membership, ordering, and data values are visible following a fetch operation. Note that many ODBC drivers do not support this type of recordset.  \n  \n- **CRecordset::forwardOnly** A read-only recordset with only forward scrolling.  \n  \n     For `CRecordset`, the default value is **CRecordset::snapshot**. The default-value mechanism allows the Visual C++ wizards to interact with both ODBC `CRecordset` and DAO `CDaoRecordset`, which have different defaults.  \n  \n For more information about these recordset types, see the article [Recordset (ODBC)](../../data/odbc/recordset-odbc.md). For related information, see the article \"Using Block and Scrollable Cursors\" in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n> [!CAUTION]\n>  If the requested type is not supported, the framework throws an exception.  \n  \n `lpszSQL`  \n A string pointer containing one of the following:  \n  \n-   A **NULL** pointer.  \n  \n-   The name of a table.  \n  \n-   A SQL **SELECT** statement (optionally with a SQL **WHERE** or **ORDER BY** clause).  \n  \n-   A **CALL** statement specifying the name of a predefined query (stored procedure). Be careful that you do not insert whitespace between the curly brace and the **CALL** keyword.  \n  \n For more information about this string, see the table and the discussion of ClassWizard's role under Remarks.  \n  \n> [!NOTE]\n>  The order of the columns in your result set must match the order of the RFX or Bulk RFX function calls in your [DoFieldExchange](#crecordset__dofieldexchange) or [DoBulkFieldExchange](#crecordset__dobulkfieldexchange) function override.  \n  \n `dwOptions`  \n A bitmask which can specify a combination of the values listed below. Some of these are mutually exclusive. The default value is **none**.  \n  \n- **CRecordset::none** No options set. This parameter value is mutually exclusive with all other values. By default, the recordset can be updated with [Edit](#crecordset__edit) or [Delete](#crecordset__delete) and allows appending new records with [AddNew](#crecordset__addnew). Updatability depends on the data source as well as on the `nOpenType` option you specify. Optimization for bulk additions is not available. Bulk row fetching will not be implemented. Deleted records will not be skipped during recordset navigation. Bookmarks are not available. Automatic dirty field checking is implemented.  \n  \n- **CRecordset::appendOnly** Do not allow **Edit** or **Delete** on the recordset. Allow `AddNew` only. This option is mutually exclusive with **CRecordset::readOnly**.  \n  \n- **CRecordset::readOnly** Open the recordset as read-only. This option is mutually exclusive with **CRecordset::appendOnly**.  \n  \n- **CRecordset::optimizeBulkAdd** Use a prepared SQL statement to optimize adding many records at one time. Applies only if you are not using the ODBC API function **SQLSetPos** to update the recordset. The first update determines which fields are marked dirty. This option is mutually exclusive with `CRecordset::useMultiRowFetch`.  \n  \n- `CRecordset::useMultiRowFetch` Implement bulk row fetching to allow multiple rows to be retrieved in a single fetch operation. This is an advanced feature designed to improve performance; however, bulk record field exchange is not supported by ClassWizard. This option is mutually exclusive with **CRecordset::optimizeBulkAdd**. Note that if you specify `CRecordset::useMultiRowFetch`, then the option **CRecordset::noDirtyFieldCheck** will be turned on automatically (double buffering will not be available); on forward-only recordsets, the option **CRecordset::useExtendedFetch** will be turned on automatically. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n- **CRecordset::skipDeletedRecords** Skip all deleted records when navigating through the recordset. This will slow performance in certain relative fetches. This option is not valid on forward-only recordsets. If you call [Move](#crecordset__move) with the `nRows` parameter set to 0, and the **CRecordset::skipDeletedRecords** option set, **Move** will assert. Note that **CRecordset::skipDeletedRecords** is similar to *driver packing*, which means that deleted rows are removed from the recordset. However, if your driver packs records, then it will skip only those records that you delete; it will not skip records deleted by other users while the recordset is open. **CRecordset::skipDeletedRecords** will skip rows deleted by other users.  \n  \n- **CRecordset::useBookmarks** May use bookmarks on the recordset, if supported. Bookmarks slow data retrieval but improve performance for data navigation. Not valid on forward-only recordsets. For more information, see the article [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md).  \n  \n- **CRecordset::noDirtyFieldCheck** Turn off automatic dirty field checking (double buffering). This will improve performance; however, you must manually mark fields as dirty by calling the `SetFieldDirty` and `SetFieldNull` member functions.Note that double buffering in class `CRecordset` is similar to double buffering in class `CDaoRecordset`. However, in `CRecordset`, you cannot enable double buffering on individual fields; you either enable it for all fields or disable it for all fields. Note that if you specify the option `CRecordset::useMultiRowFetch`, then **CRecordset::noDirtyFieldCheck** will be turned on automatically; however, `SetFieldDirty` and `SetFieldNull` cannot be used on recordsets that implement bulk row fetching.  \n  \n- **CRecordset::executeDirect** Do not use a prepared SQL statement. For improved performance, specify this option if the **Requery** member function will never be called.  \n  \n- **CRecordset::useExtendedFetch** Implement **SQLExtendedFetch** instead of **SQLFetch**. This is designed for implementing bulk row fetching on forward-only recordsets. If you specify the option `CRecordset::useMultiRowFetch` on a forward-only recordset, then **CRecordset::useExtendedFetch** will be turned on automatically.  \n  \n- **CRecordset::userAllocMultiRowBuffers** The user will allocate storage buffers for the data. Use this option in conjunction with `CRecordset::useMultiRowFetch` if you want to allocate your own storage; otherwise, the framework will automatically allocate the necessary storage. For more information, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md). Note that specifying **CRecordset::userAllocMultiRowBuffers** without specifying `CRecordset::useMultiRowFetch` will result in a failed assertion.  \n  \n### Return Value  \n Nonzero if the `CRecordset` object was successfully opened; otherwise 0 if [CDatabase::Open](../../mfc/reference/cdatabase-class.md#cdatabase__open) (if called) returns 0.  \n  \n### Remarks  \n You must call this member function to run the query defined by the recordset. Before calling **Open**, you must construct the recordset object.  \n  \n This recordset's connection to the data source depends on how you construct the recordset before calling **Open**. If you pass a [CDatabase](../../mfc/reference/cdatabase-class.md) object to the recordset constructor that has not been connected to the data source, this member function uses [GetDefaultConnect](#crecordset__getdefaultconnect) to attempt to open the database object. If you pass **NULL** to the recordset constructor, the constructor constructs a `CDatabase` object for you, and **Open** attempts to connect the database object. For details on closing the recordset and the connection under these varying circumstances, see [Close](#crecordset__close).  \n  \n> [!NOTE]\n>  Access to a data source through a `CRecordset` object is always shared. Unlike the `CDaoRecordset` class, you cannot use a `CRecordset` object to open a data source with exclusive access.  \n  \n When you call **Open**, a query, usually a SQL **SELECT** statement, selects records based on criteria shown in the following table.  \n  \n|Value of the lpszSQL parameter|Records selected are determined by|Example|  \n|------------------------------------|----------------------------------------|-------------|  \n|**NULL**|The string returned by `GetDefaultSQL`.||  \n|SQL table name|All columns of the table-list in `DoFieldExchange` or `DoBulkFieldExchange`.|`\"Customer\"`|  \n|Predefined query (stored procedure) name|The columns the query is defined to return.|`\"{call OverDueAccts}\"`|  \n|**SELECT** column-list **FROM** table-list|The specified columns from the specified table(s).|`\"SELECT CustId, CustName FROM`<br /><br /> `Customer\"`|  \n  \n> [!CAUTION]\n>  Be careful that you do not insert extra whitespace in your SQL string. For example, if you insert whitespace between the curly brace and the **CALL** keyword, MFC will misinterpret the SQL string as a table name and incorporate it into a **SELECT** statement, which will result in an exception being thrown. Similarly, if your predefined query uses an output parameter, do not insert whitespace between the curly brace and the '' symbol. Finally, you must not insert whitespace before the curly brace in a **CALL** statement or before the **SELECT** keyword in a **SELECT** statment.  \n  \n The usual procedure is to pass **NULL** to **Open**; in this case, **Open** calls [GetDefaultSQL](#crecordset__getdefaultsql). If you are using a derived `CRecordset` class, **GetDefaultSQL** gives the table name(s) you specified in ClassWizard. You can instead specify other information in the `lpszSQL` parameter.  \n  \n Whatever you pass, **Open** constructs a final SQL string for the query (the string may have SQL **WHERE** and **ORDER BY** clauses appended to the `lpszSQL` string you passed) and then executes the query. You can examine the constructed string by calling [GetSQL](#crecordset__getsql) after calling **Open**. For additional details about how the recordset constructs a SQL statement and selects records, see the article [Recordset: How Recordsets Select Records (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md).  \n  \n The field data members of your recordset class are bound to the columns of the data selected. If any records are returned, the first record becomes the current record.  \n  \n If you want to set options for the recordset, such as a filter or sort, specify these after you construct the recordset object but before you call **Open**. If you want to refresh the records in the recordset after the recordset is already open, call [Requery](#crecordset__requery).  \n  \n For more information, including additional examples, see the articles [Recordset (ODBC)](../../data/odbc/recordset-odbc.md), [Recordset: How Recordsets Select Records (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md), and [Recordset: Creating and Closing Recordsets (ODBC)](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md).  \n  \n### Example  \n The following code examples show different forms of the **Open** call.  \n  \n [!code-cpp[NVC_MFCDatabase#16](../../mfc/codesnippet/cpp/crecordset-class_15.cpp)]  \n  \n##  <a name=\"crecordset__refreshrowset\"></a>  CRecordset::RefreshRowset  \n Updates the data and the status for a row in the current rowset.  \n  \n```  \nvoid RefreshRowset(\n    WORD wRow,  \n    WORD wLockType = SQL_LOCK_NO_CHANGE);\n```  \n  \n### Parameters  \n `wRow`  \n The one-based position of a row in the current rowset. This value can range from zero to the size of the rowset.  \n  \n `wLockType`  \n A value indicating how to lock the row after it has been refreshed. For details, see Remarks.  \n  \n### Remarks  \n If you pass a value of zero for `wRow`, then every row in the rowset will be refreshed.  \n  \n To use `RefreshRowset`, you must have implemented bulk row fetching by specifying the **CRecordset::useMulitRowFetch** option in the [Open](#crecordset__open) member function.  \n  \n `RefreshRowset` calls the ODBC API function **SQLSetPos**. The `wLockType` parameter specifies the lock state of the row after **SQLSetPos** has executed. The following table describes the possible values for `wLockTyp`e.  \n  \n|wLockType|Description|  \n|---------------|-----------------|  \n|`SQL_LOCK_NO_CHANGE` (the default value)|The driver or data source ensures that the row is in the same locked or unlocked state as it was before `RefreshRowset` was called.|  \n|`SQL_LOCK_EXCLUSIVE`|The driver or data source locks the row exclusively. Not all data sources support this type of lock.|  \n|`SQL_LOCK_UNLOCK`|The driver or data source unlocks the row. Not all data sources support this type of lock.|  \n  \n For more information about **SQLSetPos**, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n##  <a name=\"crecordset__requery\"></a>  CRecordset::Requery  \n Rebuilds (refreshes) a recordset.  \n  \n```  \nvirtual BOOL Requery();\n```  \n  \n### Return Value  \n Nonzero if the recordset was successfully rebuilt; otherwise 0.  \n  \n### Remarks  \n If any records are returned, the first record becomes the current record.  \n  \n In order for the recordset to reflect the additions and deletions that you or other users are making to the data source, you must rebuild the recordset by calling **Requery**. If the recordset is a dynaset, it automatically reflects updates that you or other users make to its existing records (but not additions). If the recordset is a snapshot, you must call **Requery** to reflect edits by other users as well as additions and deletions.  \n  \n For either a dynaset or a snapshot, call **Requery** any time you want to rebuild the recordset using a new filter or sort, or new parameter values. Set the new filter or sort property by assigning new values to **m_strFilter** and `m_strSort` before calling **Requery**. Set new parameters by assigning new values to parameter data members before calling **Requery**. If the filter and sort strings are unchanged, you can reuse the query, which improves performance.  \n  \n If the attempt to rebuild the recordset fails, the recordset is closed. Before you call **Requery**, you can determine whether the recordset can be requeried by calling the `CanRestart` member function. `CanRestart` does not guarantee that **Requery** will succeed.  \n  \n> [!CAUTION]\n>  Call **Requery** only after you have called [Open](#crecordset__open).  \n  \n### Example  \n This example rebuilds a recordset to apply a different sort order.  \n  \n [!code-cpp[NVC_MFCDatabase#29](../../mfc/codesnippet/cpp/crecordset-class_16.cpp)]  \n  \n##  <a name=\"crecordset__setabsoluteposition\"></a>  CRecordset::SetAbsolutePosition  \n Positions the recordset on the record corresponding to the specified record number.  \n  \n```  \nvoid SetAbsolutePosition(long nRows);\n```  \n  \n### Parameters  \n `nRows`  \n The one-based ordinal position for the current record in the recordset.  \n  \n### Remarks  \n `SetAbsolutePosition` moves the current record pointer based on this ordinal position.  \n  \n> [!NOTE]\n>  This member function is not valid on forward-only recordsets.  \n  \n For ODBC recordsets, an absolute position setting of 1 refers to the first record in the recordset; a setting of 0 refers to the beginning-of-file (BOF) position.  \n  \n You can also pass negative values to `SetAbsolutePosition`. In this case the recordset's position is evaluated from the end of the recordset. For example, `SetAbsolutePosition( -1 )` moves the current record pointer to the last record in the recordset.  \n  \n> [!NOTE]\n>  Absolute position is not intended to be used as a surrogate record number. Bookmarks are still the recommended way of retaining and returning to a given position, since a record's position changes when preceding records are deleted. In addition, you cannot be assured that a given record will have the same absolute position if the recordset is re-created again because the order of individual records within a recordset is not guaranteed unless it is created with a SQL statement using an **ORDER BY** clause.  \n  \n For more information about recordset navigation and bookmarks, see the articles [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) and [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md).  \n  \n##  <a name=\"crecordset__setbookmark\"></a>  CRecordset::SetBookmark  \n Positions the recordset on the record containing the specified bookmark.  \n  \n```  \nvoid SetBookmark(const CDBVariant& varBookmark);\n```  \n  \n### Parameters  \n `varBookmark`  \n A reference to a [CDBVariant](../../mfc/reference/cdbvariant-class.md) object containing the bookmark value for a specific record.  \n  \n### Remarks  \n To determine if bookmarks are supported on the recordset, call [CanBookmark](#crecordset__canbookmark). To make bookmarks available if they are supported, you must set the **CRecordset::useBookmarks** option in the `dwOptions` parameter of the [Open](#crecordset__open) member function.  \n  \n> [!NOTE]\n>  If bookmarks are unsupported or unavailable, calling `SetBookmark` will result in an exception being thrown. Bookmarks are not supported on forward-only recordsets.  \n  \n To first retrieve the bookmark for the current record, call [GetBookmark](#crecordset__getbookmark), which saves the bookmark value to a `CDBVariant` object. Later, you can return to that record by calling `SetBookmark` using the saved bookmark value.  \n  \n> [!NOTE]\n>  After certain recordset operations, you should check the bookmark persistence before calling `SetBookmark`. For example, if you retrieve a bookmark with `GetBookmark` and then call **Requery**, the bookmark may no longer be valid. Call [CDatabase::GetBookmarkPersistence](../../mfc/reference/cdatabase-class.md#cdatabase__getbookmarkpersistence) to check whether you can safely call `SetBookmark`.  \n  \n For more information about bookmarks and recordset navigation, see the articles [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md) and [Recordset: Scrolling (ODBC)](../../data/odbc/recordset-scrolling-odbc.md).  \n  \n##  <a name=\"crecordset__setfielddirty\"></a>  CRecordset::SetFieldDirty  \n Flags a field data member of the recordset as changed or as unchanged.  \n  \n```  \nvoid SetFieldDirty(\n    void* pv, BOOL bDirty = TRUE);\n```  \n  \n### Parameters  \n `pv`  \n Contains the address of a field data member in the recordset or **NULL**. If **NULL**, all field data members in the recordset are flagged. (C++ **NULL** is not the same as Null in database terminology, which means \"having no value.\")  \n  \n `bDirty`  \n **TRUE** if the field data member is to be flagged as \"dirty\" (changed). Otherwise **FALSE** if the field data member is to be flagged as \"clean\" (unchanged).  \n  \n### Remarks  \n Marking fields as unchanged ensures the field is not updated and results in less SQL traffic.  \n  \n> [!NOTE]\n>  This member function is not applicable on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, then `SetFieldDirty` will result in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n The framework marks changed field data members to ensure they will be written to the record on the data source by the record field exchange (RFX) mechanism. Changing the value of a field generally sets the field dirty automatically, so you will seldom need to call `SetFieldDirty` yourself, but you might sometimes want to ensure that columns will be explicitly updated or inserted regardless of what value is in the field data member.  \n  \n> [!CAUTION]\n>  Call this member function only after you have called [Edit](#crecordset__edit) or [AddNew](#crecordset__addnew).  \n  \n Using **NULL** for the first argument of the function will apply the function only to **outputColumn** fields, not **param** fields. For instance, the call  \n  \n [!code-cpp[NVC_MFCDatabase#26](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)]  \n  \n will set only **outputColumn** fields to **NULL**; **param** fields will be unaffected.  \n  \n To work on **param** fields, you must supply the actual address of the individual **param** you want to work on, such as:  \n  \n [!code-cpp[NVC_MFCDatabase#27](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)]  \n  \n This means you cannot set all **param** fields to **NULL**, as you can with **outputColumn** fields.  \n  \n##  <a name=\"crecordset__setfieldnull\"></a>  CRecordset::SetFieldNull  \n Flags a field data member of the recordset as Null (specifically having no value) or as non-Null.  \n  \n```  \nvoid SetFieldNull(\n    void* pv, BOOL bNull = TRUE);\n```  \n  \n### Parameters  \n `pv`  \n Contains the address of a field data member in the recordset or **NULL**. If **NULL**, all field data members in the recordset are flagged. (C++ **NULL** is not the same as Null in database terminology, which means \"having no value.\")  \n  \n `bNull`  \n Nonzero if the field data member is to be flagged as having no value (Null). Otherwise 0 if the field data member is to be flagged as non-Null.  \n  \n### Remarks  \n When you add a new record to a recordset, all field data members are initially set to a Null value and flagged as \"dirty\" (changed). When you retrieve a record from a data source, its columns either already have values or are Null.  \n  \n> [!NOTE]\n>  Do not call this member function on recordsets that are using bulk row fetching. If you have implemented bulk row fetching, calling `SetFieldNull` results in a failed assertion. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n If you specifically wish to designate a field of the current record as not having a value, call `SetFieldNull` with `bNull` set to **TRUE** to flag it as Null. If a field was previously marked Null and you now want to give it a value, simply set its new value. You do not have to remove the Null flag with `SetFieldNull`. To determine whether the field is allowed to be Null, call `IsFieldNullable`.  \n  \n> [!CAUTION]\n>  Call this member function only after you have called [Edit](#crecordset__edit) or [AddNew](#crecordset__addnew).  \n  \n Using **NULL** for the first argument of the function will apply the function only to **outputColumn** fields, not **param** fields. For instance, the call  \n  \n [!code-cpp[NVC_MFCDatabase#26](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)]  \n  \n will set only **outputColumn** fields to **NULL**; **param** fields will be unaffected.  \n  \n To work on **param** fields, you must supply the actual address of the individual **param** you want to work on, such as:  \n  \n [!code-cpp[NVC_MFCDatabase#27](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)]  \n  \n This means you cannot set all **param** fields to **NULL**, as you can with **outputColumn** fields.  \n  \n> [!NOTE]\n>  When setting parameters to Null, a call to `SetFieldNull` before the recordset is opened results in an assertion. In this case, call [SetParamNull](#crecordset__setparamnull).  \n  \n `SetFieldNull` is implemented through [DoFieldExchange](#crecordset__dofieldexchange).  \n  \n##  <a name=\"crecordset__setlockingmode\"></a>  CRecordset::SetLockingMode  \n Sets the locking mode to \"optimistic\" locking (the default) or \"pessimistic\" locking. Determines how records are locked for updates.  \n  \n```  \nvoid SetLockingMode(UINT nMode);\n```  \n  \n### Parameters  \n `nMode`  \n Contains one of the following values from the **enum LockMode**:  \n  \n- **optimistic** Optimistic locking locks the record being updated only during the call to **Update**.  \n  \n- **pessimistic** Pessimistic locking locks the record as soon as **Edit** is called and keeps it locked until the **Update** call completes or you move to a new record.  \n  \n### Remarks  \n Call this member function if you need to specify which of two record-locking strategies the recordset is using for updates. By default, the locking mode of a recordset is **optimistic**. You can change that to a more cautious **pessimistic** locking strategy. Call `SetLockingMode` after you construct and open the recordset object but before you call **Edit**.  \n  \n##  <a name=\"crecordset__setparamnull\"></a>  CRecordset::SetParamNull  \n Flags a parameter as Null (specifically having no value) or as non-Null.  \n  \n```  \nvoid SetParamNull(\n    int nIndex,  \n    BOOL bNull = TRUE);\n```  \n  \n### Parameters  \n `nIndex`  \n The zero-based index of the parameter.  \n  \n `bNull`  \n If **TRUE** (the default value), the parameter is flagged as Null. Otherwise, the parameter is flagged as non-Null.  \n  \n### Remarks  \n Unlike [SetFieldNull](#crecordset__setfieldnull), you can call `SetParamNull` before you have opened the recordset.  \n  \n `SetParamNull` is typically used with predefined queries (stored procedures).  \n  \n##  <a name=\"crecordset__setrowsetcursorposition\"></a>  CRecordset::SetRowsetCursorPosition  \n Moves the cursor to a row within the current rowset.  \n  \n```  \nvoid SetRowsetCursorPosition(\n    WORD wRow, WORD wLockType = SQL_LOCK_NO_CHANGE);\n```  \n  \n### Parameters  \n `wRow`  \n The one-based position of a row in the current rowset. This value can range from 1 to the size of the rowset.  \n  \n `wLockType`  \n Value indicating how to lock the row after it has been refreshed. For details, see Remarks.  \n  \n### Remarks  \n When implementing bulk row fetching, records are retrieved by rowsets, where the first record in the fetched rowset is the current record. In order to make another record within the rowset the current record, call `SetRowsetCursorPosition`. For example, you can combine `SetRowsetCursorPosition` with the [GetFieldValue](#crecordset__getfieldvalue) member function to dynamically retrieve the data from any record of your recordset.  \n  \n To use `SetRowsetCursorPosition`, you must have implemented bulk row fetching by specifying the `CRecordset::useMultiRowFetch` option of the `dwOptions` parameter in the [Open](#crecordset__open) member function.  \n  \n `SetRowsetCursorPosition` calls the ODBC API function **SQLSetPos**. The `wLockType` parameter specifies the lock state of the row after **SQLSetPos** has executed. The following table describes the possible values for `wLockTyp`e.  \n  \n|wLockType|Description|  \n|---------------|-----------------|  \n|`SQL_LOCK_NO_CHANGE` (the default value)|The driver or data source ensures that the row is in the same locked or unlocked state as it was before `SetRowsetCursorPosition` was called.|  \n|`SQL_LOCK_EXCLUSIVE`|The driver or data source locks the row exclusively. Not all data sources support this type of lock.|  \n|`SQL_LOCK_UNLOCK`|The driver or data source unlocks the row. Not all data sources support this type of lock.|  \n  \n For more information about **SQLSetPos**, see the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n##  <a name=\"crecordset__setrowsetsize\"></a>  CRecordset::SetRowsetSize  \n Specifies the number of records you wish to retrieve during a fetch.  \n  \n```  \nvirtual void SetRowsetSize(DWORD dwNewRowsetSize);\n```  \n  \n### Parameters  \n *dwNewRowsetSize*  \n The number of rows to retrieve during a given fetch.  \n  \n### Remarks  \n This virtual member function specifies how many rows you wish to retrieve during a single fetch when using bulk row fetching. To implement bulk row fetching, you must set the `CRecordset::useMultiRowFetch` option in the `dwOptions` parameter of the [Open](#crecordset__open) member function.  \n  \n> [!NOTE]\n>  Calling `SetRowsetSize` without implementing bulk row fetching will result in a failed assertion.  \n  \n Call `SetRowsetSize` before calling **Open** to initially set the rowset size for the recordset. The default rowset size when implementing bulk row fetching is 25.  \n  \n> [!NOTE]\n>  Use caution when calling `SetRowsetSize`. If you are manually allocating storage for the data (as specified by the **CRecordset::userAllocMultiRowBuffers** option of the dwOptions parameter in **Open**), you should check whether you need to reallocate these storage buffers after you call `SetRowsetSize`, but before you perform any cursor navigation operation.  \n  \n To obtain the current setting for the rowset size, call [GetRowsetSize](#crecordset__getrowsetsize).  \n  \n For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n##  <a name=\"crecordset__update\"></a>  CRecordset::Update  \n Completes an `AddNew` or **Edit** operation by saving the new or edited data on the data source.  \n  \n```  \nvirtual BOOL Update();\n```  \n  \n### Return Value  \n Nonzero if one record was successfully updated; otherwise 0 if no columns have changed. If no records were updated, or if more than one record was updated, an exception is thrown. An exception is also thrown for any other failure on the data source.  \n  \n### Remarks  \n Call this member function after a call to the [AddNew](#crecordset__addnew) or [Edit](#crecordset__edit) member function. This call is required to complete the `AddNew` or **Edit** operation.  \n  \n> [!NOTE]\n>  If you have implemented bulk row fetching, you cannot call **Update**. This will result in a failed assertion. Although class `CRecordset` does not provide a mechanism for updating bulk rows of data, you can write your own functions by using the ODBC API function **SQLSetPos**. For more information about bulk row fetching, see the article [Recordset: Fetching Records in Bulk (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  \n  \n Both `AddNew` and **Edit** prepare an edit buffer in which the added or edited data is placed for saving to the data source. **Update** saves the data. Only those fields marked or detected as changed are updated.  \n  \n If the data source supports transactions, you can make the **Update** call (and its corresponding `AddNew` or **Edit** call) part of a transaction. For more information about transactions, see the article [Transaction (ODBC)](../../data/odbc/transaction-odbc.md).  \n  \n> [!CAUTION]\n>  If you call **Update** without first calling either `AddNew` or **Edit**, **Update** throws a `CDBException`. If you call `AddNew` or **Edit**, you must call **Update** before you call a **Move** operation or before you close either the recordset or the data source connection. Otherwise, your changes are lost without notification.  \n  \n For details on handling **Update** failures, see the article [Recordset: How Recordsets Update Records (ODBC)](../../data/odbc/recordset-how-recordsets-update-records-odbc.md).  \n  \n### Example  \n See the article [Transaction: Performing a Transaction in a Recordset (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md).  \n  \n## See Also  \n [CObject Class](../../mfc/reference/cobject-class.md)   \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)   \n [CDatabase Class](../../mfc/reference/cdatabase-class.md)   \n [CRecordView Class](../../mfc/reference/crecordview-class.md)\n"}