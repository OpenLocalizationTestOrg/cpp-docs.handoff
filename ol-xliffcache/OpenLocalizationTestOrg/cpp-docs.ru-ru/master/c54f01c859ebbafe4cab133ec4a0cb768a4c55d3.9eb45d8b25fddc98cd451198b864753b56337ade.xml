{"nodes":[{"pos":[12,57],"content":"Outline of Changes (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Outline of Changes (C++-CLI) | Microsoft Docs","pos":[0,45]}]},{"content":"Outline of Changes (C++/CLI)","pos":[538,566]},{"content":"This outline shows you examples of some of the changes in the language from Managed Extensions for C++ to <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","pos":[567,745],"source":"This outline shows you examples of some of the changes in the language from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"Follow the link that accompanies each item for more information.","pos":[746,810]},{"content":"No Double Underscore Keywords","pos":[819,848]},{"content":"The double underscore in front of all keywords has been removed, with one exception.","pos":[852,936]},{"content":"Thus, <ph id=\"ph1\">`__value`</ph> becomes <ph id=\"ph2\">`value`</ph>, and <ph id=\"ph3\">`__interface`</ph> becomes <ph id=\"ph4\">`interface`</ph>, and so on.","pos":[937,1019],"source":" Thus, `__value` becomes `value`, and `__interface` becomes `interface`, and so on."},{"content":"To prevent name clashes between keywords and identifiers in user code, keywords are primarily treated as contextual.","pos":[1020,1136]},{"pos":[1143,1238],"content":"See <bpt id=\"p1\">[</bpt>Language Keywords (C++/CLI)<ept id=\"p1\">](../dotnet/language-keywords-cpp-cli.md)</ept> for more information.","source":"See [Language Keywords (C++/CLI)](../dotnet/language-keywords-cpp-cli.md) for more information."},{"content":"Class Declarations","pos":[1247,1265]},{"content":"Managed Extensions syntax:","pos":[1269,1295]},{"content":"New syntax:","pos":[1644,1655]},{"pos":[1944,2029],"content":"See <bpt id=\"p1\">[</bpt>Managed Types (C++/CL)<ept id=\"p1\">](../dotnet/managed-types-cpp-cl.md)</ept> for more information.","source":"See [Managed Types (C++/CL)](../dotnet/managed-types-cpp-cl.md) for more information."},{"content":"Object Declaration","pos":[2038,2056]},{"content":"Managed Extensions syntax:","pos":[2060,2086]},{"content":"New syntax:","pos":[2404,2415]},{"pos":[2688,2817],"content":"See <bpt id=\"p1\">[</bpt>Declaration of a CLR Reference Class Object<ept id=\"p1\">](../dotnet/declaration-of-a-clr-reference-class-object.md)</ept> for more information.","source":"See [Declaration of a CLR Reference Class Object](../dotnet/declaration-of-a-clr-reference-class-object.md) for more information."},{"content":"Managed Heap Allocation","pos":[2827,2850]},{"content":"Managed Extensions syntax:","pos":[2854,2880]},{"content":"New syntax:","pos":[3045,3056]},{"pos":[3248,3377],"content":"See <bpt id=\"p1\">[</bpt>Declaration of a CLR Reference Class Object<ept id=\"p1\">](../dotnet/declaration-of-a-clr-reference-class-object.md)</ept> for more information.","source":"See [Declaration of a CLR Reference Class Object](../dotnet/declaration-of-a-clr-reference-class-object.md) for more information."},{"content":"A Tracking Reference to No Object","pos":[3387,3420]},{"content":"Managed Extensions syntax:","pos":[3424,3450]},{"content":"New syntax:","pos":[3589,3600]},{"pos":[3899,4028],"content":"See <bpt id=\"p1\">[</bpt>Declaration of a CLR Reference Class Object<ept id=\"p1\">](../dotnet/declaration-of-a-clr-reference-class-object.md)</ept> for more information.","source":"See [Declaration of a CLR Reference Class Object](../dotnet/declaration-of-a-clr-reference-class-object.md) for more information."},{"content":"Array Declaration","pos":[4037,4054]},{"content":"The CLR array has been redesigned.","pos":[4058,4092]},{"content":"It is similar to the stl <ph id=\"ph1\">`vector`</ph> template collection, but maps to the underlying <ph id=\"ph2\">`System::Array`</ph> class – that is, it is not a template implementation.","pos":[4093,4244],"source":" It is similar to the stl `vector` template collection, but maps to the underlying `System::Array` class – that is, it is not a template implementation."},{"pos":[4251,4346],"content":"See <bpt id=\"p1\">[</bpt>Declaration of a CLR Array<ept id=\"p1\">](../dotnet/declaration-of-a-clr-array.md)</ept> for more information.","source":"See [Declaration of a CLR Array](../dotnet/declaration-of-a-clr-array.md) for more information."},{"content":"Array as Parameter","pos":[4356,4374]},{"content":"Managed Extensions array syntax:","pos":[4378,4410]},{"content":"New array syntax:","pos":[4518,4535]},{"content":"Array as Return Type","pos":[4648,4668]},{"content":"Managed Extensions array syntax:","pos":[4672,4704]},{"content":"New array syntax:","pos":[4768,4785]},{"content":"Shorthand Initialization of Local CLR Array","pos":[4857,4900]},{"content":"Managed Extensions array syntax:","pos":[4904,4936]},{"content":"New array syntax:","pos":[5174,5191]},{"content":"Explicit CLR Array Declaration","pos":[5353,5383]},{"content":"Managed Extensions array syntax:","pos":[5387,5419]},{"content":"New array syntax:","pos":[5518,5535]},{"content":"New to language: explicit array initialization that follows gcnew","pos":[5667,5732]},{"content":"Scalar Properties","pos":[5921,5938]},{"content":"Managed Extensions property syntax:","pos":[5942,5977]},{"content":"New property syntax:","pos":[6172,6192]},{"content":"New to language: trivial properties","pos":[6443,6478]},{"pos":[6661,6744],"content":"See <bpt id=\"p1\">[</bpt>Property Declaration<ept id=\"p1\">](../dotnet/property-declaration.md)</ept> for more information.","source":"See [Property Declaration](../dotnet/property-declaration.md) for more information."},{"content":"Indexed Properties","pos":[6753,6771]},{"content":"Managed Extensions indexed property syntax:","pos":[6775,6818]},{"content":"New indexed property syntax:","pos":[7053,7081]},{"content":"New to language: class-level indexed property","pos":[7343,7388]},{"pos":[7810,7905],"content":"See <bpt id=\"p1\">[</bpt>Property Index Declaration<ept id=\"p1\">](../dotnet/property-index-declaration.md)</ept> for more information.","source":"See [Property Index Declaration](../dotnet/property-index-declaration.md) for more information."},{"content":"Overloaded Operators","pos":[7914,7934]},{"content":"Managed Extensions operator overload syntax:","pos":[7938,7982]},{"content":"New operator overload syntax:","pos":[8469,8498]},{"pos":[8939,9022],"content":"See <bpt id=\"p1\">[</bpt>Overloaded Operators<ept id=\"p1\">](../dotnet/overloaded-operators.md)</ept> for more information.","source":"See [Overloaded Operators](../dotnet/overloaded-operators.md) for more information."},{"content":"Conversion Operators","pos":[9031,9051]},{"content":"Managed Extensions conversion operator syntax:","pos":[9055,9101]},{"content":"New conversion operator syntax:","pos":[9295,9326]},{"pos":[9539,9644],"content":"See <bpt id=\"p1\">[</bpt>Changes to Conversion Operators<ept id=\"p1\">](../dotnet/changes-to-conversion-operators.md)</ept> for more information.","source":"See [Changes to Conversion Operators](../dotnet/changes-to-conversion-operators.md) for more information."},{"content":"Explicit Override of an Interface Member","pos":[9653,9693]},{"content":"Managed Extensions explicit override syntax:","pos":[9697,9741]},{"content":"New explicit override syntax:","pos":[9936,9965]},{"pos":[10193,10316],"content":"See <bpt id=\"p1\">[</bpt>Explicit Override of an Interface Member<ept id=\"p1\">](../dotnet/explicit-override-of-an-interface-member.md)</ept> for more information.","source":"See [Explicit Override of an Interface Member](../dotnet/explicit-override-of-an-interface-member.md) for more information."},{"content":"Private Virtual Functions","pos":[10325,10350]},{"content":"Managed Extensions private virtual function syntax:","pos":[10354,10405]},{"content":"New private virtual function syntax","pos":[10641,10676]},{"pos":[10941,11034],"content":"See <bpt id=\"p1\">[</bpt>Private Virtual Functions<ept id=\"p1\">](../dotnet/private-virtual-functions.md)</ept> for more information.","source":"See [Private Virtual Functions](../dotnet/private-virtual-functions.md) for more information."},{"content":"CLR Enum Type","pos":[11043,11056]},{"content":"Managed Extensions enum syntax:","pos":[11060,11091]},{"content":"New enum syntax:","pos":[11244,11260]},{"content":"Apart from this small syntactic change, the behavior of the CLR enum type has been changed in a number of ways:","pos":[11405,11516]},{"content":"A forward declaration of a CLR enum is no longer supported.","pos":[11526,11585]},{"content":"The overload resolution between the built-in arithmetic types and the Object class hierarchy has reversed between Managed Extensions and <ph id=\"ph1\">[!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]</ph>.","pos":[11595,11804],"source":"The overload resolution between the built-in arithmetic types and the Object class hierarchy has reversed between Managed Extensions and [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]."},{"content":"As a side-effect, CLR enums are no longer implicitly converted to arithmetic types.","pos":[11805,11888]},{"content":"In the new syntax, a CLR enum maintains its own scope, which is not the case in Managed Extensions.","pos":[11898,11997]},{"content":"Previously, enumerators were visible within the containing scope of the enum; now, enumerators are encapsulated within the scope of the enum.","pos":[11998,12139]},{"pos":[12146,12215],"content":"See <bpt id=\"p1\">[</bpt>CLR Enum Type<ept id=\"p1\">](../dotnet/clr-enum-type.md)</ept> for more information.","source":"See [CLR Enum Type](../dotnet/clr-enum-type.md) for more information."},{"content":"Removal of __box Keyword","pos":[12224,12248]},{"content":"Managed Extensions boxing syntax:","pos":[12252,12285]},{"content":"New boxing syntax:","pos":[12355,12373]},{"pos":[12434,12545],"content":"See <bpt id=\"p1\">[</bpt>A Tracking Handle to a Boxed Value<ept id=\"p1\">](../dotnet/a-tracking-handle-to-a-boxed-value.md)</ept> for more information.","source":"See [A Tracking Handle to a Boxed Value](../dotnet/a-tracking-handle-to-a-boxed-value.md) for more information."},{"content":"Pinning Pointer","pos":[12554,12569]},{"content":"Managed Extensions pinning pointer syntax:","pos":[12573,12615]},{"content":"New pinning pointer syntax:","pos":[12739,12766]},{"pos":[12887,12970],"content":"See <bpt id=\"p1\">[</bpt>Value Type Semantics<ept id=\"p1\">](../dotnet/value-type-semantics.md)</ept> for more information.","source":"See [Value Type Semantics](../dotnet/value-type-semantics.md) for more information."},{"content":"__typeof Keyword becomes typeid","pos":[12979,13010]},{"content":"Managed Extensions typeof syntax:","pos":[13014,13047]},{"content":"New typeid syntax:","pos":[13142,13160]},{"pos":[13253,13343],"content":"See <bpt id=\"p1\">[</bpt>typeof Goes to T::typeid<ept id=\"p1\">](../dotnet/typeof-goes-to-t-typeid.md)</ept> for more information.","source":"See [typeof Goes to T::typeid](../dotnet/typeof-goes-to-t-typeid.md) for more information."},{"content":"See Also","pos":[13352,13360]},{"content":"C++/CLI Migration Primer","pos":[13365,13389]},{"content":"(NOTINBUILD)Managed Extensions for C++ Syntax Upgrade Checklist","pos":[13435,13498]},{"content":"Component Extensions for Runtime Platforms","pos":[13575,13617]}],"content":"---\ntitle: \"Outline of Changes (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: c0bbbd6b-c5c4-44cf-a6ca-c1010c377e9d\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Outline of Changes (C++/CLI)\nThis outline shows you examples of some of the changes in the language from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]. Follow the link that accompanies each item for more information.  \n  \n## No Double Underscore Keywords  \n The double underscore in front of all keywords has been removed, with one exception. Thus, `__value` becomes `value`, and `__interface` becomes `interface`, and so on. To prevent name clashes between keywords and identifiers in user code, keywords are primarily treated as contextual.  \n  \n See [Language Keywords (C++/CLI)](../dotnet/language-keywords-cpp-cli.md) for more information.  \n  \n## Class Declarations  \n Managed Extensions syntax:  \n  \n```  \n__gc class Block {};                           // reference class  \n__value class Vector {};                       // value class  \n__interface I {};                        // interface class  \n__gc __abstract class Shape {};                // abstract class  \n__gc __sealed class Shape2D : public Shape {}; // derived class  \n```  \n  \n New syntax:  \n  \n```  \nref class Block {};                // reference class  \nvalue class Vector {};             // value class  \ninterface class I {};        // interface class  \nref class Shape abstract {};       // abstract class  \nref class Shape2D sealed: Shape{}; // derived class  \n```  \n  \n See [Managed Types (C++/CL)](../dotnet/managed-types-cpp-cl.md) for more information.  \n  \n## Object Declaration  \n Managed Extensions syntax:  \n  \n```  \npublic __gc class Form1 : public System::Windows::Forms::Form {  \nprivate:  \n   System::ComponentModel::Container __gc *components;  \n   System::Windows::Forms::Button   __gc *button1;  \n   System::Windows::Forms::DataGrid __gc *myDataGrid;     \n   System::Data::DataSet  __gc *myDataSet;  \n};  \n```  \n  \n New syntax:  \n  \n```  \npublic ref class Form1 : System::Windows::Forms::Form {  \n   System::ComponentModel::Container^ components;  \n   System::Windows::Forms::Button^ button1;  \n   System::Windows::Forms::DataGrid^ myDataGrid;  \n   System::Data::DataSet^ myDataSet;  \n};  \n```  \n  \n See [Declaration of a CLR Reference Class Object](../dotnet/declaration-of-a-clr-reference-class-object.md) for more information.  \n  \n### Managed Heap Allocation  \n Managed Extensions syntax:  \n  \n```  \nButton* button1 = new Button; // managed heap  \nint *pi1 = new int;           // native heap  \nInt32 *pi2 = new Int32;       // managed heap  \n```  \n  \n New syntax:  \n  \n```  \nButton^ button1 = gcnew Button;        // managed heap  \nint * pi1 = new int;                   // native heap  \nInt32^ pi2 = gcnew Int32;              // managed heap  \n```  \n  \n See [Declaration of a CLR Reference Class Object](../dotnet/declaration-of-a-clr-reference-class-object.md) for more information.  \n  \n### A Tracking Reference to No Object  \n Managed Extensions syntax:  \n  \n```  \n// OK: we set obj to refer to no object  \nObject * obj = 0;  \n  \n// Error: no implicit boxing  \nObject * obj2 = 1;  \n```  \n  \n New syntax:  \n  \n```  \n// Incorrect Translation  \n// causes the implicit boxing of both 0 and 1  \nObject ^ obj = 0;  \nObject ^ obj2 = 1;  \n  \n// Correct Translation  \n// OK: we set obj to refer to no object  \nObject ^ obj = nullptr;  \n  \n// OK: we initialize obj2 to an Int32^  \nObject ^ obj2 = 1;  \n```  \n  \n See [Declaration of a CLR Reference Class Object](../dotnet/declaration-of-a-clr-reference-class-object.md) for more information.  \n  \n## Array Declaration  \n The CLR array has been redesigned. It is similar to the stl `vector` template collection, but maps to the underlying `System::Array` class – that is, it is not a template implementation.  \n  \n See [Declaration of a CLR Array](../dotnet/declaration-of-a-clr-array.md) for more information.  \n  \n### Array as Parameter  \n Managed Extensions array syntax:  \n  \n```  \nvoid PrintValues( Object* myArr __gc[]);   \nvoid PrintValues( int myArr __gc[,,]);   \n```  \n  \n New array syntax:  \n  \n```  \nvoid PrintValues( array<Object^>^ myArr );  \nvoid PrintValues( array<int,3>^ myArr );  \n```  \n  \n### Array as Return Type  \n Managed Extensions array syntax:  \n  \n```  \nInt32 f() [];   \nint GetArray() __gc[];  \n```  \n  \n New array syntax:  \n  \n```  \narray<Int32>^ f();  \narray<int>^ GetArray();  \n```  \n  \n### Shorthand Initialization of Local CLR Array  \n Managed Extensions array syntax:  \n  \n```  \nint GetArray() __gc[] {  \n   int a1 __gc[] = { 1, 2, 3, 4, 5 };  \n   Object* myObjArray __gc[] = { __box(26), __box(27), __box(28),  \n                                 __box(29), __box(30) };  \n  \n   return a1;  \n}  \n```  \n  \n New array syntax:  \n  \n```  \narray<int>^ GetArray() {  \n   array<int>^ a1 = {1,2,3,4,5};  \n   array<Object^>^ myObjArray = {26,27,28,29,30};  \n  \n   return a1;  \n}  \n```  \n  \n### Explicit CLR Array Declaration  \n Managed Extensions array syntax:  \n  \n```  \nObject* myArray[] = new Object*[2];  \nString* myMat[,] = new String*[4,4];  \n```  \n  \n New array syntax:  \n  \n```  \narray<Object^>^ myArray = gcnew array<Object^>(2);  \narray<String^,2>^ myMat = gcnew array<String^,2>(4,4);  \n```  \n  \n New to language: explicit array initialization that follows gcnew  \n  \n```  \n// explicit initialization list follow gcnew   \n// is not supported in Managed Extensions  \narray<Object^>^ myArray =   \n   gcnew array<Object^>(4){ 1, 1, 2, 3 };  \n```  \n  \n## Scalar Properties  \n Managed Extensions property syntax:  \n  \n```  \npublic __gc __sealed class Vector {  \n   double _x;  \n  \npublic:  \n   __property double get_x(){ return _x; }  \n   __property void set_x( double newx ){ _x = newx; }  \n};  \n```  \n  \n New property syntax:  \n  \n```  \npublic ref class Vector sealed {   \n   double _x;  \n  \npublic:  \n   property double x   \n   {  \n      double get()             { return _x; }  \n      void   set( double newx ){ _x = newx; }  \n   } // Note: no semi-colon …  \n};  \n```  \n  \n New to language: trivial properties  \n  \n```  \npublic ref class Vector sealed {   \npublic:  \n   // equivalent shorthand property syntax  \n   // backing store is not accessible  \n   property double x;   \n};  \n```  \n  \n See [Property Declaration](../dotnet/property-declaration.md) for more information.  \n  \n## Indexed Properties  \n Managed Extensions indexed property syntax:  \n  \n```  \npublic __gc class Matrix {  \n   float mat[,];  \n  \npublic:   \n   __property void set_Item( int r, int c, float value) { mat[r,c] = value; }  \n   __property int get_Item( int r, int c ) { return mat[r,c]; }  \n};  \n```  \n  \n New indexed property syntax:  \n  \n```  \npublic ref class Matrix {  \n   array<float, 2>^ mat;  \n  \npublic:  \n   property float Item [int,int] {  \n      float get( int r, int c ) { return mat[r,c]; }  \n      void set( int r, int c, float value ) { mat[r,c] = value; }  \n   }  \n};  \n```  \n  \n New to language: class-level indexed property  \n  \n```  \npublic ref class Matrix {  \n   array<float, 2>^ mat;  \n  \npublic:  \n   // ok: class level indexer now  \n   //     Matrix mat;  \n   //     mat[ 0, 0 ] = 1;   \n   //  \n   // invokes the set accessor of the default indexer  \n  \n   property float default [int,int] {  \n      float get( int r, int c ) { return mat[r,c]; }  \n      void set( int r, int c, float value ) { mat[r,c] = value; }  \n   }  \n};  \n```  \n  \n See [Property Index Declaration](../dotnet/property-index-declaration.md) for more information.  \n  \n## Overloaded Operators  \n Managed Extensions operator overload syntax:  \n  \n```  \npublic __gc __sealed class Vector {  \npublic:  \n   Vector( double x, double y, double z );  \n  \n   static bool    op_Equality( const Vector*, const Vector* );  \n   static Vector* op_Division( const Vector*, double );  \n};  \n  \nint main() {  \n   Vector *pa = new Vector( 0.231, 2.4745, 0.023 );  \n   Vector *pb = new Vector( 1.475, 4.8916, -1.23 );   \n  \n   Vector *pc = Vector::op_Division( pa, 4.8916 );  \n  \n   if ( Vector::op_Equality( pa, pc ))  \n      ;  \n}  \n```  \n  \n New operator overload syntax:  \n  \n```  \npublic ref class Vector sealed {  \npublic:  \n   Vector( double x, double y, double z );  \n  \n   static bool    operator ==( const Vector^, const Vector^ );  \n   static Vector^ operator /( const Vector^, double );  \n};  \n  \nint main() {  \n   Vector^ pa = gcnew Vector( 0.231, 2.4745, 0.023 );  \n   Vector^ pb = gcnew Vector( 1.475, 4.8916, -1.23 );  \n  \n   Vector^ pc = pa / 4.8916;  \n   if ( pc == pa )  \n      ;  \n}  \n```  \n  \n See [Overloaded Operators](../dotnet/overloaded-operators.md) for more information.  \n  \n## Conversion Operators  \n Managed Extensions conversion operator syntax:  \n  \n```  \n__gc struct MyDouble {  \n   static MyDouble* op_Implicit( int i );   \n   static int op_Explicit( MyDouble* val );  \n   static String* op_Explicit( MyDouble* val );   \n};  \n```  \n  \n New conversion operator syntax:  \n  \n```  \nref struct MyDouble {  \npublic:  \n   static operator MyDouble^ ( int i );  \n   static explicit operator int ( MyDouble^ val );  \n   static explicit operator String^ ( MyDouble^ val );  \n};  \n```  \n  \n See [Changes to Conversion Operators](../dotnet/changes-to-conversion-operators.md) for more information.  \n  \n## Explicit Override of an Interface Member  \n Managed Extensions explicit override syntax:  \n  \n```  \npublic __gc class R : public ICloneable {  \n   // to be used through ICloneable  \n   Object* ICloneable::Clone();  \n  \n   // to be used through an R  \n   R* Clone();  \n};  \n```  \n  \n New explicit override syntax:  \n  \n```  \npublic ref class R : public ICloneable {  \n   // to be used through ICloneable  \n   virtual Object^ InterfaceClone() = ICloneable::Clone;  \n  \n   // to be used through an R   \n   virtual R^ Clone();  \n};  \n```  \n  \n See [Explicit Override of an Interface Member](../dotnet/explicit-override-of-an-interface-member.md) for more information.  \n  \n## Private Virtual Functions  \n Managed Extensions private virtual function syntax:  \n  \n```  \n__gc class Base {  \nprivate:  \n   // inaccessible to a derived class  \n   virtual void g();   \n};  \n  \n__gc class Derived : public Base {  \npublic:  \n   // ok: g() overrides Base::g()  \n   virtual void g();  \n};  \n```  \n  \n New private virtual function syntax  \n  \n```  \nref class Base {  \nprivate:  \n   // inaccessible to a derived class  \n   virtual void g();   \n};  \n  \nref class Derived : public Base {  \npublic:  \n   // error: cannot override: Base::g() is inaccessible  \n   virtual void g() override;  \n};  \n```  \n  \n See [Private Virtual Functions](../dotnet/private-virtual-functions.md) for more information.  \n  \n## CLR Enum Type  \n Managed Extensions enum syntax:  \n  \n```  \n__value enum e1 { fail, pass };  \npublic __value enum e2 : unsigned short  {   \n   not_ok = 1024,   \n   maybe, ok = 2048   \n};    \n```  \n  \n New enum syntax:  \n  \n```  \nenum class e1 { fail, pass };  \npublic enum class e2 : unsigned short {   \n   not_ok = 1024,  \n   maybe, ok = 2048   \n};  \n```  \n  \n Apart from this small syntactic change, the behavior of the CLR enum type has been changed in a number of ways:  \n  \n-   A forward declaration of a CLR enum is no longer supported.  \n  \n-   The overload resolution between the built-in arithmetic types and the Object class hierarchy has reversed between Managed Extensions and [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)]. As a side-effect, CLR enums are no longer implicitly converted to arithmetic types.  \n  \n-   In the new syntax, a CLR enum maintains its own scope, which is not the case in Managed Extensions. Previously, enumerators were visible within the containing scope of the enum; now, enumerators are encapsulated within the scope of the enum.  \n  \n See [CLR Enum Type](../dotnet/clr-enum-type.md) for more information.  \n  \n## Removal of __box Keyword  \n Managed Extensions boxing syntax:  \n  \n```  \nObject *o = __box( 1024 ); // explicit boxing  \n```  \n  \n New boxing syntax:  \n  \n```  \nObject ^o = 1024; // implicit boxing  \n```  \n  \n See [A Tracking Handle to a Boxed Value](../dotnet/a-tracking-handle-to-a-boxed-value.md) for more information.  \n  \n## Pinning Pointer  \n Managed Extensions pinning pointer syntax:  \n  \n```  \n__gc struct H { int j; };  \n  \nint main() {  \n   H * h = new H;  \n   int __pin * k = & h -> j;  \n};  \n```  \n  \n New pinning pointer syntax:  \n  \n```  \nref struct H { int j; };  \n  \nint main() {  \n   H^ h = gcnew H;  \n   pin_ptr<int> k = &h->j;  \n}  \n```  \n  \n See [Value Type Semantics](../dotnet/value-type-semantics.md) for more information.  \n  \n## __typeof Keyword becomes typeid  \n Managed Extensions typeof syntax:  \n  \n```  \nArray* myIntArray =   \n   Array::CreateInstance( __typeof(Int32), 5 );  \n```  \n  \n New typeid syntax:  \n  \n```  \nArray^ myIntArray =   \n   Array::CreateInstance( Int32::typeid, 5 );  \n```  \n  \n See [typeof Goes to T::typeid](../dotnet/typeof-goes-to-t-typeid.md) for more information.  \n  \n## See Also  \n [C++/CLI Migration Primer](../dotnet/cpp-cli-migration-primer.md)   \n [(NOTINBUILD)Managed Extensions for C++ Syntax Upgrade Checklist](http://msdn.microsoft.com/en-us/edbded88-7ef3-4757-bd9d-b8f48ac2aada)   \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}