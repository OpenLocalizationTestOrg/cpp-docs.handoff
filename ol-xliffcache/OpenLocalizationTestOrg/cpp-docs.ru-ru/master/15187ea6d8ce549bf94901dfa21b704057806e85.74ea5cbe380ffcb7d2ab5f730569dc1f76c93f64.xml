{"nodes":[{"pos":[12,55],"content":"&lt;condition_variable&gt; | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>condition_variable<ph id=\"ph2\">&amp;gt;</ph> | Microsoft Docs","pos":[0,43],"source":"&lt;condition_variable&gt; | Microsoft Docs"}]},{"pos":[603,629],"content":"&lt;condition_variable&gt;","linkify":"&lt;condition_variable&gt;","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>condition_variable<ph id=\"ph2\">&amp;gt;</ph>","pos":[0,26],"source":"&lt;condition_variable&gt;"}]},{"pos":[630,875],"content":"Defines the classes <bpt id=\"p1\">[</bpt>condition_variable<ept id=\"p1\">](../standard-library/condition-variable-class.md)</ept> and <bpt id=\"p2\">[</bpt>condition_variable_any<ept id=\"p2\">](../standard-library/condition-variable-any-class.md)</ept> that are used to create objects that wait for a condition to become true.","source":"Defines the classes [condition_variable](../standard-library/condition-variable-class.md) and [condition_variable_any](../standard-library/condition-variable-any-class.md) that are used to create objects that wait for a condition to become true."},{"content":"This header uses Concurrency Runtime (ConcRT) so that you can use it together with other ConcRT mechanisms.","pos":[882,989]},{"content":"For more information about ConcRT, see <bpt id=\"p1\">[</bpt>Concurrency Runtime<ept id=\"p1\">](../parallel/concrt/concurrency-runtime.md)</ept>.","pos":[990,1094],"source":" For more information about ConcRT, see [Concurrency Runtime](../parallel/concrt/concurrency-runtime.md)."},{"pos":[1103,1109],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1167,1262],"content":"[!NOTE]\n In code that is compiled by using **/clr** or **/clr:pure**, this header is blocked.","leadings":["","> "],"nodes":[{"content":"In code that is compiled by using <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/clr:pure<ept id=\"p2\">**</ept>, this header is blocked.","pos":[9,93],"source":" In code that is compiled by using **/clr** or **/clr:pure**, this header is blocked."}]},{"pos":[1272,1279],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Code that waits for a condition variable must also use a <ph id=\"ph1\">`mutex`</ph>.","pos":[1283,1348],"source":"Code that waits for a condition variable must also use a `mutex`."},{"content":"A calling thread must lock the <ph id=\"ph1\">`mutex`</ph> before it calls the functions that wait for the condition variable.","pos":[1349,1455],"source":" A calling thread must lock the `mutex` before it calls the functions that wait for the condition variable."},{"content":"The <ph id=\"ph1\">`mutex`</ph> is then locked when the called function returns.","pos":[1456,1516],"source":" The `mutex` is then locked when the called function returns."},{"content":"The <ph id=\"ph1\">`mutex`</ph> is not locked while the thread waits for the condition to become true.","pos":[1517,1599],"source":" The `mutex` is not locked while the thread waits for the condition to become true."},{"content":"So that there are no unpredictable results, each thread that waits for a condition variable must use the same <ph id=\"ph1\">`mutex`</ph> object.","pos":[1600,1725],"source":" So that there are no unpredictable results, each thread that waits for a condition variable must use the same `mutex` object."},{"content":"Objects of type <ph id=\"ph1\">`condition_variable_any`</ph> can be used with a mutex of any type.","pos":[1732,1810],"source":"Objects of type `condition_variable_any` can be used with a mutex of any type."},{"content":"The type of the mutex that is used does not have to provide the <ph id=\"ph1\">`try_lock`</ph> method.","pos":[1811,1893],"source":" The type of the mutex that is used does not have to provide the `try_lock` method."},{"content":"Objects of type <ph id=\"ph1\">`condition_variable`</ph> can only be used with a mutex of type <ph id=\"ph2\">`unique_lock&lt;mutex&gt;`</ph>.","pos":[1894,1990],"source":" Objects of type `condition_variable` can only be used with a mutex of type `unique_lock<mutex>`."},{"content":"Objects of this type may be faster than objects of type <ph id=\"ph1\">`condition_variable_any&lt;unique_lock&lt;mutex&gt;&gt;`</ph>.","pos":[1991,2092],"source":" Objects of this type may be faster than objects of type `condition_variable_any<unique_lock<mutex>>`."},{"content":"To wait for an event, first lock the mutex, and then call one of the <ph id=\"ph1\">`wait`</ph> methods on the condition variable.","pos":[2099,2209],"source":"To wait for an event, first lock the mutex, and then call one of the `wait` methods on the condition variable."},{"content":"The <ph id=\"ph1\">`wait`</ph> call blocks until another thread signals the condition variable.","pos":[2210,2285],"source":" The `wait` call blocks until another thread signals the condition variable."},{"content":"<bpt id=\"p1\">*</bpt>Spurious wakeups<ept id=\"p1\">*</ept> occur when threads that are waiting for condition variables become unblocked without appropriate notifications.","pos":[2292,2422],"source":"*Spurious wakeups* occur when threads that are waiting for condition variables become unblocked without appropriate notifications."},{"content":"To recognize such spurious wakeups, code that waits for a condition to become true should explicitly check that condition when the code returns from a wait function.","pos":[2423,2588]},{"content":"This is usually done by using a loop; you can use <ph id=\"ph1\">`wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred)`</ph> to perform this loop for you.","pos":[2589,2717],"source":" This is usually done by using a loop; you can use `wait(unique_lock<mutex>& lock, Predicate pred)` to perform this loop for you."},{"pos":[2800,2912],"content":"The <ph id=\"ph1\">`condition_variable_any`</ph> and <ph id=\"ph2\">`condition_variable`</ph> classes each have three methods that wait for a condition.","source":"The `condition_variable_any` and `condition_variable` classes each have three methods that wait for a condition."},{"pos":[2920,2962],"content":"<ph id=\"ph1\">`wait`</ph> waits for an unbounded time period.","source":"`wait` waits for an unbounded time period."},{"pos":[2970,3014],"content":"<ph id=\"ph1\">`wait_until`</ph> waits until a specified <ph id=\"ph2\">`time`</ph>.","source":"`wait_until` waits until a specified `time`."},{"pos":[3022,3071],"content":"<ph id=\"ph1\">`wait_for`</ph> waits for a specified <ph id=\"ph2\">`time interval`</ph>.","source":"`wait_for` waits for a specified `time interval`."},{"content":"Each of these methods has two overloaded versions.","pos":[3078,3128]},{"content":"One just waits and can wake up spuriously.","pos":[3129,3171]},{"content":"The other takes an additional template argument that defines a predicate.","pos":[3172,3245]},{"content":"The method does not return until the predicate is <ph id=\"ph1\">`true`</ph>.","pos":[3246,3303],"source":" The method does not return until the predicate is `true`."},{"pos":[3310,3416],"content":"Each class also has two methods that are used to notify a condition variable that its condition is <ph id=\"ph1\">`true`</ph>.","source":"Each class also has two methods that are used to notify a condition variable that its condition is `true`."},{"pos":[3424,3508],"content":"<ph id=\"ph1\">`notify_one`</ph> wakes up one of the threads that is waiting for the condition variable.","source":"`notify_one` wakes up one of the threads that is waiting for the condition variable."},{"pos":[3516,3601],"content":"<ph id=\"ph1\">`notify_all`</ph> wakes up all of the threads that are waiting for the condition variable.","source":"`notify_all` wakes up all of the threads that are waiting for the condition variable."},{"pos":[3610,3618],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Header Files Reference<ept id=\"p1\">](../standard-library/cpp-standard-library-header-files.md)</ept><ph id=\"ph1\"> </ph>","pos":[3622,3705],"source":"[Header Files Reference](../standard-library/cpp-standard-library-header-files.md) "},{"content":"<bpt id=\"p1\"> [</bpt>condition_variable Class<ept id=\"p1\">](../standard-library/condition-variable-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[3708,3785],"source":" [condition_variable Class](../standard-library/condition-variable-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>condition_variable_any Class<ept id=\"p1\">](../standard-library/condition-variable-any-class.md)</ept>","pos":[3788,3872],"source":" [condition_variable_any Class](../standard-library/condition-variable-any-class.md)"}],"content":"---\ntitle: \"&lt;condition_variable&gt; | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"<condition_variable>\"\ndev_langs: \n  - \"C++\"\nms.assetid: 8567f7cc-20bd-42a7-9137-87c46f878009\ncaps.latest.revision: 19\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# &lt;condition_variable&gt;\nDefines the classes [condition_variable](../standard-library/condition-variable-class.md) and [condition_variable_any](../standard-library/condition-variable-any-class.md) that are used to create objects that wait for a condition to become true.  \n  \n This header uses Concurrency Runtime (ConcRT) so that you can use it together with other ConcRT mechanisms. For more information about ConcRT, see [Concurrency Runtime](../parallel/concrt/concurrency-runtime.md).  \n  \n## Syntax  \n  \n```cpp  \n#include <condition_variable>  \n```  \n  \n> [!NOTE]\n>  In code that is compiled by using **/clr** or **/clr:pure**, this header is blocked.  \n  \n### Remarks  \n Code that waits for a condition variable must also use a `mutex`. A calling thread must lock the `mutex` before it calls the functions that wait for the condition variable. The `mutex` is then locked when the called function returns. The `mutex` is not locked while the thread waits for the condition to become true. So that there are no unpredictable results, each thread that waits for a condition variable must use the same `mutex` object.  \n  \n Objects of type `condition_variable_any` can be used with a mutex of any type. The type of the mutex that is used does not have to provide the `try_lock` method. Objects of type `condition_variable` can only be used with a mutex of type `unique_lock<mutex>`. Objects of this type may be faster than objects of type `condition_variable_any<unique_lock<mutex>>`.  \n  \n To wait for an event, first lock the mutex, and then call one of the `wait` methods on the condition variable. The `wait` call blocks until another thread signals the condition variable.  \n  \n *Spurious wakeups* occur when threads that are waiting for condition variables become unblocked without appropriate notifications. To recognize such spurious wakeups, code that waits for a condition to become true should explicitly check that condition when the code returns from a wait function. This is usually done by using a loop; you can use `wait(unique_lock<mutex>& lock, Predicate pred)` to perform this loop for you.  \n  \n```cpp\nwhile (condition is false)\n    wait for condition variable;\n```  \n  \n The `condition_variable_any` and `condition_variable` classes each have three methods that wait for a condition.  \n  \n- `wait` waits for an unbounded time period.  \n  \n- `wait_until` waits until a specified `time`.  \n  \n- `wait_for` waits for a specified `time interval`.  \n  \n Each of these methods has two overloaded versions. One just waits and can wake up spuriously. The other takes an additional template argument that defines a predicate. The method does not return until the predicate is `true`.  \n  \n Each class also has two methods that are used to notify a condition variable that its condition is `true`.  \n  \n- `notify_one` wakes up one of the threads that is waiting for the condition variable.  \n  \n- `notify_all` wakes up all of the threads that are waiting for the condition variable.  \n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)   \n [condition_variable Class](../standard-library/condition-variable-class.md)   \n [condition_variable_any Class](../standard-library/condition-variable-any-class.md)\n"}