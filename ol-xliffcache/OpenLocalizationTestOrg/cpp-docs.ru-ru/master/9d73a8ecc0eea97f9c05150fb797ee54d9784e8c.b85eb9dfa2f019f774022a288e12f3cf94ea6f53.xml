{"nodes":[{"pos":[12,50],"content":"recursive_mutex Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"recursive_mutex Class | Microsoft Docs","pos":[0,38]}]},{"content":"recursive_mutex Class","pos":[577,598]},{"content":"Represents a <bpt id=\"p1\">*</bpt>mutex type<ept id=\"p1\">*</ept>.","pos":[599,625],"source":"Represents a *mutex type*."},{"content":"In contrast to <bpt id=\"p1\">[</bpt>mutex<ept id=\"p1\">](../standard-library/mutex-class-stl.md)</ept>, the behavior of calls to locking methods for objects that are already locked is well-defined.","pos":[626,783],"source":" In contrast to [mutex](../standard-library/mutex-class-stl.md), the behavior of calls to locking methods for objects that are already locked is well-defined."},{"content":"Syntax","pos":[792,798]},{"content":"Members","pos":[843,850]},{"content":"Public Constructors","pos":[860,879]},{"content":"Name","pos":[886,890]},{"content":"Description","pos":[891,902]},{"content":"recursive_mutex Constructor","pos":[941,968]},{"pos":[1017,1055],"content":"Constructs a <ph id=\"ph1\">`recursive_mutex`</ph> object.","source":"Constructs a `recursive_mutex` object."},{"content":"~recursive_mutex Destructor","pos":[1061,1088]},{"pos":[1141,1210],"content":"Releases any resources that are used by the <ph id=\"ph1\">`recursive_mutex`</ph> object.","source":"Releases any resources that are used by the `recursive_mutex` object."},{"content":"Public Methods","pos":[1221,1235]},{"content":"Name","pos":[1242,1246]},{"content":"Description","pos":[1247,1258]},{"content":"lock","pos":[1297,1301]},{"content":"Blocks the calling thread until the thread obtains ownership of the mutex.","pos":[1334,1408]},{"content":"try_lock","pos":[1414,1422]},{"content":"Attempts to obtain ownership of the mutex without blocking.","pos":[1459,1518]},{"content":"unlock","pos":[1524,1530]},{"content":"Releases ownership of the mutex.","pos":[1565,1597]},{"content":"Requirements","pos":[1607,1619]},{"pos":[1623,1640],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> mutex","source":"**Header:** mutex"},{"pos":[1647,1665],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[1720,1724],"content":"lock"},{"pos":[1728,1804],"content":"Blocks the calling thread until the thread obtains ownership of the <ph id=\"ph1\">`mutex`</ph>.","source":"Blocks the calling thread until the thread obtains ownership of the `mutex`."},{"content":"Remarks","pos":[1843,1850]},{"pos":[1854,1974],"content":"If the calling thread already owns the <ph id=\"ph1\">`mutex`</ph>, the method returns immediately, and the previous lock remains in effect.","source":"If the calling thread already owns the `mutex`, the method returns immediately, and the previous lock remains in effect."},{"pos":[2045,2060],"content":"recursive_mutex"},{"pos":[2064,2121],"content":"Constructs a <ph id=\"ph1\">`recursive_mutex`</ph> object that is not locked.","source":"Constructs a `recursive_mutex` object that is not locked."},{"pos":[2231,2247],"content":"~recursive_mutex"},{"content":"Releases any resources that are used by the object.","pos":[2251,2302]},{"content":"Remarks","pos":[2348,2355]},{"content":"If the object is locked when the destructor runs, the behavior is undefined.","pos":[2359,2435]},{"pos":[2494,2502],"content":"try_lock"},{"pos":[2506,2567],"content":"Attempts to obtain ownership of the <ph id=\"ph1\">`mutex`</ph> without blocking.","source":"Attempts to obtain ownership of the `mutex` without blocking."},{"content":"Return Value","pos":[2619,2631]},{"pos":[2642,2772],"content":"if the method successfully obtains ownership of the <ph id=\"ph1\">`mutex`</ph> or if the calling thread already owns the <ph id=\"ph2\">`mutex`</ph>; otherwise, <ph id=\"ph3\">`false`</ph>.","source":" if the method successfully obtains ownership of the `mutex` or if the calling thread already owns the `mutex`; otherwise, `false`."},{"content":"Remarks","pos":[2782,2789]},{"pos":[2793,2922],"content":"If the calling thread already owns the <ph id=\"ph1\">`mutex`</ph>, the function immediately returns <ph id=\"ph2\">`true`</ph>, and the previous lock remains in effect.","source":"If the calling thread already owns the `mutex`, the function immediately returns `true`, and the previous lock remains in effect."},{"pos":[2979,2985],"content":"unlock"},{"content":"Releases ownership of the mutex.","pos":[2989,3021]},{"content":"Remarks","pos":[3062,3069]},{"pos":[3073,3310],"content":"This method releases ownership of the <ph id=\"ph1\">`mutex`</ph> only after it is called as many times as <bpt id=\"p1\">[</bpt>lock<ept id=\"p1\">](#recursive_mutex__lock_method)</ept> and <bpt id=\"p2\">[</bpt>try_lock<ept id=\"p2\">](#recursive_mutex__try_lock_method)</ept> have been called successfully on the <ph id=\"ph2\">`recursive_mutex`</ph> object.","source":"This method releases ownership of the `mutex` only after it is called as many times as [lock](#recursive_mutex__lock_method) and [try_lock](#recursive_mutex__try_lock_method) have been called successfully on the `recursive_mutex` object."},{"pos":[3317,3391],"content":"If the calling thread does not own the <ph id=\"ph1\">`mutex`</ph>, the behavior is undefined.","source":"If the calling thread does not own the `mutex`, the behavior is undefined."},{"content":"See Also","pos":[3400,3408]},{"content":"Header Files Reference","pos":[3413,3435]},{"content":"mutex&gt;","pos":[3502,3508],"source":"mutex>"}],"content":"---\ntitle: \"recursive_mutex Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"mutex/std::recursive_mutex\"\ndev_langs: \n  - \"C++\"\nms.assetid: eb5ffd1b-7e78-4559-8391-bb220ead42fc\ncaps.latest.revision: 9\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# recursive_mutex Class\nRepresents a *mutex type*. In contrast to [mutex](../standard-library/mutex-class-stl.md), the behavior of calls to locking methods for objects that are already locked is well-defined.  \n  \n## Syntax  \n  \n```\nclass recursive_mutex;\n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[recursive_mutex Constructor](#recursive_mutex__recursive_mutex_constructor)|Constructs a `recursive_mutex` object.|  \n|[~recursive_mutex Destructor](#recursive_mutex___dtorrecursive_mutex_destructor)|Releases any resources that are used by the `recursive_mutex` object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[lock](#recursive_mutex__lock_method)|Blocks the calling thread until the thread obtains ownership of the mutex.|  \n|[try_lock](#recursive_mutex__try_lock_method)|Attempts to obtain ownership of the mutex without blocking.|  \n|[unlock](#recursive_mutex__unlock_method)|Releases ownership of the mutex.|  \n  \n## Requirements  \n **Header:** mutex  \n  \n **Namespace:** std  \n  \n##  <a name=\"recursive_mutex__lock_method\"></a>  lock  \n Blocks the calling thread until the thread obtains ownership of the `mutex`.  \n  \n```cpp\nvoid lock();\n```  \n  \n### Remarks  \n If the calling thread already owns the `mutex`, the method returns immediately, and the previous lock remains in effect.  \n  \n##  <a name=\"recursive_mutex__recursive_mutex_constructor\"></a>  recursive_mutex  \n Constructs a `recursive_mutex` object that is not locked.  \n  \n```cpp\nrecursive_mutex();\n```  \n  \n##  <a name=\"recursive_mutex___dtorrecursive_mutex_destructor\"></a>  ~recursive_mutex  \n Releases any resources that are used by the object.  \n  \n```cpp\n~recursive_mutex();\n```  \n  \n### Remarks  \n If the object is locked when the destructor runs, the behavior is undefined.  \n  \n##  <a name=\"recursive_mutex__try_lock_method\"></a>  try_lock  \n Attempts to obtain ownership of the `mutex` without blocking.  \n  \n```cpp\nbool try_lock() noexcept;\n```  \n  \n### Return Value  \n `true` if the method successfully obtains ownership of the `mutex` or if the calling thread already owns the `mutex`; otherwise, `false`.  \n  \n### Remarks  \n If the calling thread already owns the `mutex`, the function immediately returns `true`, and the previous lock remains in effect.  \n  \n##  <a name=\"recursive_mutex__unlock_method\"></a>  unlock  \n Releases ownership of the mutex.  \n  \n```cpp\nvoid unlock();\n```  \n  \n### Remarks  \n This method releases ownership of the `mutex` only after it is called as many times as [lock](#recursive_mutex__lock_method) and [try_lock](#recursive_mutex__try_lock_method) have been called successfully on the `recursive_mutex` object.  \n  \n If the calling thread does not own the `mutex`, the behavior is undefined.  \n  \n## See Also  \n [Header Files Reference](../standard-library/cpp-standard-library-header-files.md)   \n [\\<mutex>](../standard-library/mutex.md)\n\n\n\n"}