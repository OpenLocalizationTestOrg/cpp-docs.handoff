{"nodes":[{"pos":[12,54],"content":"try-finally Statement (C) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"try-finally Statement (C) | Microsoft Docs","pos":[0,42]}]},{"content":"try-finally Statement (C)","pos":[880,905]},{"content":"Microsoft Specific","pos":[908,926]},{"content":"The <ph id=\"ph1\">`try-finally`</ph> statement is a Microsoft extension to the C language that enables applications to guarantee execution of cleanup code when execution of a block of code is interrupted.","pos":[935,1120],"source":"The `try-finally` statement is a Microsoft extension to the C language that enables applications to guarantee execution of cleanup code when execution of a block of code is interrupted."},{"content":"Cleanup consists of such tasks as deallocating memory, closing files, and releasing file handles.","pos":[1121,1218]},{"content":"The <ph id=\"ph1\">`try-finally`</ph> statement is especially useful for routines that have several places where a check is made for an error that could cause premature return from the routine.","pos":[1219,1392],"source":" The `try-finally` statement is especially useful for routines that have several places where a check is made for an error that could cause premature return from the routine."},{"content":"<bpt id=\"p1\">*</bpt>try-finally-statement<ept id=\"p1\">*</ept>:","pos":[1399,1423],"source":"*try-finally-statement*:"},{"content":"<bpt id=\"p1\"> **</bpt>__try<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>compound-statement<ept id=\"p2\">*</ept>","pos":[1426,1458],"source":" **__try**  *compound-statement*"},{"pos":[1465,1500],"content":"<bpt id=\"p1\">**</bpt>__finally<ept id=\"p1\">**</ept>  <bpt id=\"p2\">*</bpt>compound-statement<ept id=\"p2\">*</ept>","source":"**__finally**  *compound-statement*"},{"content":"The compound statement after the <ph id=\"ph1\">`__try`</ph> clause is the guarded section.","pos":[1507,1578],"source":"The compound statement after the `__try` clause is the guarded section."},{"content":"The compound statement after the <ph id=\"ph1\">`__finally`</ph> clause is the termination handler.","pos":[1579,1658],"source":" The compound statement after the `__finally` clause is the termination handler."},{"content":"The handler specifies a set of actions that execute when the guarded section is exited, whether the guarded section is exited by an exception (abnormal termination) or by standard fall through (normal termination).","pos":[1659,1873]},{"content":"Control reaches a <ph id=\"ph1\">`__try`</ph> statement by simple sequential execution (fall through).","pos":[1880,1962],"source":"Control reaches a `__try` statement by simple sequential execution (fall through)."},{"content":"When control enters the <ph id=\"ph1\">`__try`</ph> statement, its associated handler becomes active.","pos":[1963,2044],"source":" When control enters the `__try` statement, its associated handler becomes active."},{"content":"Execution proceeds as follows:","pos":[2045,2075]},{"content":"The guarded section is executed.","pos":[2085,2117]},{"content":"The termination handler is invoked.","pos":[2127,2162]},{"content":"When the termination handler completes, execution continues after the <ph id=\"ph1\">`__finally`</ph> statement.","pos":[2172,2264],"source":"When the termination handler completes, execution continues after the `__finally` statement."},{"content":"Regardless of how the guarded section ends (for example, via a <ph id=\"ph1\">`goto`</ph> statement out of the guarded body or via a <ph id=\"ph2\">`return`</ph> statement), the termination handler is executed before the flow of control moves out of the guarded section.","pos":[2265,2495],"source":" Regardless of how the guarded section ends (for example, via a `goto` statement out of the guarded body or via a `return` statement), the termination handler is executed before the flow of control moves out of the guarded section."},{"content":"The <ph id=\"ph1\">`__leave`</ph> keyword is valid within a <ph id=\"ph2\">`try-finally`</ph> statement block.","pos":[2502,2572],"source":"The `__leave` keyword is valid within a `try-finally` statement block."},{"content":"The effect of <ph id=\"ph1\">`__leave`</ph> is to jump to the end of the <ph id=\"ph2\">`try-finally`</ph> block.","pos":[2573,2646],"source":" The effect of `__leave` is to jump to the end of the `try-finally` block."},{"content":"The termination handler is immediately executed.","pos":[2647,2695]},{"content":"Although a <ph id=\"ph1\">`goto`</ph> statement can be used to accomplish the same result, a <ph id=\"ph2\">`goto`</ph> statement causes stack unwinding.","pos":[2696,2809],"source":" Although a `goto` statement can be used to accomplish the same result, a `goto` statement causes stack unwinding."},{"content":"The <ph id=\"ph1\">`__leave`</ph> statement is more efficient because it does not involve stack unwinding.","pos":[2810,2896],"source":" The `__leave` statement is more efficient because it does not involve stack unwinding."},{"content":"Exiting a <ph id=\"ph1\">`try-finally`</ph> statement using a <ph id=\"ph2\">`return`</ph> statement or the <ph id=\"ph3\">`longjmp`</ph> run-time function is considered abnormal termination.","pos":[2903,3034],"source":"Exiting a `try-finally` statement using a `return` statement or the `longjmp` run-time function is considered abnormal termination."},{"content":"It is illegal to jump into a <ph id=\"ph1\">`__try`</ph> statement, but legal to jump out of one.","pos":[3035,3112],"source":" It is illegal to jump into a `__try` statement, but legal to jump out of one."},{"content":"All <ph id=\"ph1\">`__finally`</ph> statements that are active between the point of departure and the destination must be run.","pos":[3113,3219],"source":" All `__finally` statements that are active between the point of departure and the destination must be run."},{"content":"This is called a \"local unwind.\"","pos":[3220,3252]},{"pos":[3259,3362],"content":"The termination handler is not called if a process is killed while executing a <ph id=\"ph1\">`try-finally`</ph> statement.","source":"The termination handler is not called if a process is killed while executing a `try-finally` statement."},{"pos":[3370,3687],"content":"[!NOTE]\n Structured exception handling works with C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, the C++ exception handling mechanism is much more flexible, in that it can handle exceptions of any type.","leadings":["","> "],"nodes":[{"content":" Structured exception handling works with C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, the C++ exception handling mechanism is much more flexible, in that it can handle exceptions of any type.","pos":[8,315],"nodes":[{"content":"Structured exception handling works with C and C++ source files.","pos":[1,65]},{"content":"However, it is not specifically designed for C++.","pos":[66,115]},{"content":"You can ensure that your code is more portable by using C++ exception handling.","pos":[116,195]},{"content":"Also, the C++ exception handling mechanism is much more flexible, in that it can handle exceptions of any type.","pos":[196,307]}]}]},{"pos":[3695,3927],"content":"[!NOTE]\n For C++ programs, C++ exception handling should be used instead of structured exception handling. For more information, see [Exception Handling](../cpp/exception-handling-in-visual-cpp.md) in the *C++ Language Reference*.","leadings":["","> "],"nodes":[{"content":" For C++ programs, C++ exception handling should be used instead of structured exception handling. For more information, see [Exception Handling](../cpp/exception-handling-in-visual-cpp.md) in the *C++ Language Reference*.","pos":[8,230],"nodes":[{"content":"For C++ programs, C++ exception handling should be used instead of structured exception handling.","pos":[1,98]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Exception Handling<ept id=\"p1\">](../cpp/exception-handling-in-visual-cpp.md)</ept> in the <bpt id=\"p2\">*</bpt>C++ Language Reference<ept id=\"p2\">*</ept>.","pos":[99,222],"source":" For more information, see [Exception Handling](../cpp/exception-handling-in-visual-cpp.md) in the *C++ Language Reference*."}]}]},{"pos":[3934,4067],"content":"See the example for the <bpt id=\"p1\">[</bpt>try-except statement<ept id=\"p1\">](../c-language/try-except-statement-c.md)</ept> to see how the <ph id=\"ph1\">`try-finally`</ph> statement works.","source":"See the example for the [try-except statement](../c-language/try-except-statement-c.md) to see how the `try-finally` statement works."},{"content":"END Microsoft Specific","pos":[4076,4098]},{"content":"See Also","pos":[4109,4117]},{"content":"try-finally Statement","pos":[4122,4143]}],"content":"---\ntitle: \"try-finally Statement (C) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"try_cpp\"\n  - \"try\"\n  - \"finally\"\n  - \"finally_cpp\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"try-catch keyword [C], try-finally keyword [C]\"\n  - \"__finally keyword [C], try-finally statement syntax\"\n  - \"try-finally keyword [C]\"\n  - \"__finally keyword [C]\"\n  - \"try-catch keyword [C]\"\n  - \"structured exception handling, try-finally\"\nms.assetid: 514400c1-c322-4bf3-9e48-3047240b8a82\ncaps.latest.revision: 7\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# try-finally Statement (C)\n**Microsoft Specific**  \n  \n The `try-finally` statement is a Microsoft extension to the C language that enables applications to guarantee execution of cleanup code when execution of a block of code is interrupted. Cleanup consists of such tasks as deallocating memory, closing files, and releasing file handles. The `try-finally` statement is especially useful for routines that have several places where a check is made for an error that could cause premature return from the routine.  \n  \n *try-finally-statement*:  \n **__try**  *compound-statement*  \n  \n **__finally**  *compound-statement*  \n  \n The compound statement after the `__try` clause is the guarded section. The compound statement after the `__finally` clause is the termination handler. The handler specifies a set of actions that execute when the guarded section is exited, whether the guarded section is exited by an exception (abnormal termination) or by standard fall through (normal termination).  \n  \n Control reaches a `__try` statement by simple sequential execution (fall through). When control enters the `__try` statement, its associated handler becomes active. Execution proceeds as follows:  \n  \n1.  The guarded section is executed.  \n  \n2.  The termination handler is invoked.  \n  \n3.  When the termination handler completes, execution continues after the `__finally` statement. Regardless of how the guarded section ends (for example, via a `goto` statement out of the guarded body or via a `return` statement), the termination handler is executed before the flow of control moves out of the guarded section.  \n  \n The `__leave` keyword is valid within a `try-finally` statement block. The effect of `__leave` is to jump to the end of the `try-finally` block. The termination handler is immediately executed. Although a `goto` statement can be used to accomplish the same result, a `goto` statement causes stack unwinding. The `__leave` statement is more efficient because it does not involve stack unwinding.  \n  \n Exiting a `try-finally` statement using a `return` statement or the `longjmp` run-time function is considered abnormal termination. It is illegal to jump into a `__try` statement, but legal to jump out of one. All `__finally` statements that are active between the point of departure and the destination must be run. This is called a \"local unwind.\"  \n  \n The termination handler is not called if a process is killed while executing a `try-finally` statement.  \n  \n> [!NOTE]\n>  Structured exception handling works with C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, the C++ exception handling mechanism is much more flexible, in that it can handle exceptions of any type.  \n  \n> [!NOTE]\n>  For C++ programs, C++ exception handling should be used instead of structured exception handling. For more information, see [Exception Handling](../cpp/exception-handling-in-visual-cpp.md) in the *C++ Language Reference*.  \n  \n See the example for the [try-except statement](../c-language/try-except-statement-c.md) to see how the `try-finally` statement works.  \n  \n **END Microsoft Specific**  \n  \n## See Also  \n [try-finally Statement](../cpp/try-finally-statement.md)"}