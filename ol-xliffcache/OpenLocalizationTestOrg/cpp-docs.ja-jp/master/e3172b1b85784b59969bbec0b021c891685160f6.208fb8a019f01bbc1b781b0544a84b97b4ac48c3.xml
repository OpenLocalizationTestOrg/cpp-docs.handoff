{"nodes":[{"pos":[12,47],"content":"Enumerations (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Enumerations (C++) | Microsoft Docs","pos":[0,35]}]},{"content":"Enumerations (C++)","pos":[800,818]},{"content":"An enumeration is a user-defined type that consists of a set of named integral constants that are known as enumerators.","pos":[819,938]},{"pos":[946,1269],"content":"[!NOTE]\n This article covers the ISO Standard C++ Language `enum` type and the scoped (or strongly-typed) `enum class` type which is introduced in C++11. For information about the `public enum class` or `private enum class` types in C++/CLI and C++/CX, see [enum class](../windows/enum-class-cpp-component-extensions.md).","leadings":["","> "],"nodes":[{"content":" This article covers the ISO Standard C++ Language `enum` type and the scoped (or strongly-typed) `enum class` type which is introduced in C++11. For information about the `public enum class` or `private enum class` types in C++/CLI and C++/CX, see [enum class](../windows/enum-class-cpp-component-extensions.md).","pos":[8,321],"nodes":[{"content":"This article covers the ISO Standard C++ Language <ph id=\"ph1\">`enum`</ph> type and the scoped (or strongly-typed) <ph id=\"ph2\">`enum class`</ph> type which is introduced in C++11.","pos":[1,145],"source":" This article covers the ISO Standard C++ Language `enum` type and the scoped (or strongly-typed) `enum class` type which is introduced in C++11."},{"content":"For information about the <ph id=\"ph1\">`public enum class`</ph> or <ph id=\"ph2\">`private enum class`</ph> types in C++/CLI and C++/CX, see <bpt id=\"p1\">[</bpt>enum class<ept id=\"p1\">](../windows/enum-class-cpp-component-extensions.md)</ept>.","pos":[146,313],"source":" For information about the `public enum class` or `private enum class` types in C++/CLI and C++/CX, see [enum class](../windows/enum-class-cpp-component-extensions.md)."}]}]},{"content":"Syntax","pos":[1278,1284]},{"content":"Parameters","pos":[1650,1660]},{"content":"The type name given to the enumeration.","pos":[1680,1719]},{"content":"The underlying type of the enumerators; all enumerators have the same underlying type.","pos":[1736,1822]},{"content":"May be any integral type.","pos":[1823,1848]},{"content":"Comma-separated list of the enumerators in the enumeration.","pos":[1870,1929]},{"content":"Every enumerator or variable name in the scope must be unique.","pos":[1930,1992]},{"content":"However, the values can be duplicated.","pos":[1993,2031]},{"content":"In a unscoped enum, the scope is the surrounding scope; in a scoped enum, the scope is the <ph id=\"ph1\">`enum-list`</ph> itself.","pos":[2032,2142],"source":" In a unscoped enum, the scope is the surrounding scope; in a scoped enum, the scope is the `enum-list` itself."},{"content":"By using this keyword in the declaration, you specify the enum is scoped, and an <ph id=\"ph1\">`identifier`</ph> must be provided.","pos":[2160,2271],"source":" By using this keyword in the declaration, you specify the enum is scoped, and an `identifier` must be provided."},{"content":"You can also use the <ph id=\"ph1\">`struct`</ph> keyword in place of <ph id=\"ph2\">`class`</ph>, as they are semantically equivalent in this context.","pos":[2272,2383],"source":" You can also use the `struct` keyword in place of `class`, as they are semantically equivalent in this context."},{"content":"Remarks","pos":[2392,2399]},{"content":"An enumeration provides context to describe a range of values which are represented as named constants and are also called enumerators.","pos":[2403,2538]},{"content":"In the original C and C++ enum types, the unqualified enumerators are visible throughout the scope in which the enum is declared.","pos":[2539,2668]},{"content":"In scoped enums, the enumerator name must be qualified by the enum type name.","pos":[2669,2746]},{"content":"The following example demonstrates this basic difference between the two kinds of enums:","pos":[2747,2835]},{"content":"Every name in an enumeration is assigned an integral value that corresponds to its place in the order of the values in the enumeration.","pos":[3359,3494]},{"content":"By default, the first value is assigned 0, the next one is assigned 1, and so on, but you can explicitly set the value of an enumerator, as shown here:","pos":[3495,3646]},{"content":"The enumerator <ph id=\"ph1\">`Diamonds`</ph> is assigned the value <ph id=\"ph2\">`1`</ph>.","pos":[3730,3782],"source":"The enumerator `Diamonds` is assigned the value `1`."},{"content":"Subsequent enumerators, if they are not given an explicit value, receive the value of the previous enumerator plus one.","pos":[3783,3902]},{"content":"In the previous example, <ph id=\"ph1\">`Hearts`</ph> would have the value 2, <ph id=\"ph2\">`Clubs`</ph> would have 3, and so on.","pos":[3903,3993],"source":" In the previous example, `Hearts` would have the value 2, `Clubs` would have 3, and so on."},{"content":"Every enumerator is treated as a constant and must have a unique name within the scope where the <ph id=\"ph1\">`enum`</ph> is defined (for unscoped enums) or within the enum itself (for scoped enums).","pos":[4000,4181],"source":"Every enumerator is treated as a constant and must have a unique name within the scope where the `enum` is defined (for unscoped enums) or within the enum itself (for scoped enums)."},{"content":"The values given to the names do not have to be unique.","pos":[4182,4237]},{"content":"For example, if the declaration of a unscoped enum <ph id=\"ph1\">`Suit`</ph> is this:","pos":[4238,4304],"source":" For example, if the declaration of a unscoped enum `Suit` is this:"},{"content":"Then the values of <ph id=\"ph1\">`Diamonds`</ph>, <ph id=\"ph2\">`Hearts`</ph>, <ph id=\"ph3\">`Clubs`</ph>, and <ph id=\"ph4\">`Spades`</ph> are 5, 6, 4, and 5, respectively.","pos":[4386,4482],"source":"Then the values of `Diamonds`, `Hearts`, `Clubs`, and `Spades` are 5, 6, 4, and 5, respectively."},{"content":"Notice that 5 is used more than once; this is allowed even though it may not be intended.","pos":[4483,4572]},{"content":"These rules are the same for scoped enums.","pos":[4573,4615]},{"content":"Casting rules","pos":[4624,4637]},{"content":"Unscoped enum constants can be implicitly converted to <ph id=\"ph1\">`int`</ph>, but an <ph id=\"ph2\">`int`</ph> is never implicitly convertible to an enum value.","pos":[4646,4770],"source":"Unscoped enum constants can be implicitly converted to `int`, but an `int` is never implicitly convertible to an enum value."},{"content":"The following example shows what happens if you try to assign <ph id=\"ph1\">`hand`</ph> a value that is not a <ph id=\"ph2\">`Suit`</ph>:","pos":[4771,4869],"source":" The following example shows what happens if you try to assign `hand` a value that is not a `Suit`:"},{"content":"A cast is required to convert an <ph id=\"ph1\">`int`</ph> to a scoped or unscoped enumerator.","pos":[5018,5092],"source":"A cast is required to convert an `int` to a scoped or unscoped enumerator."},{"content":"However, you can promote a unscoped enumerator to an integer value without a cast.","pos":[5093,5175]},{"content":"Using implicit conversions in this way can lead to unintended side-effects.","pos":[5265,5340]},{"content":"To help eliminate programming errors associated with unscoped enums, scoped enum values are strongly typed.","pos":[5341,5448]},{"content":"Scoped enumerators must be qualified by the enum type name (identifier) and cannot be implicitly converted, as shown in the following example:","pos":[5449,5591]},{"content":"Notice that the line <ph id=\"ph1\">`hand = account_num;`</ph> still causes the error that occurs with unscoped enums, as shown earlier.","pos":[6261,6377],"source":"Notice that the line `hand = account_num;` still causes the error that occurs with unscoped enums, as shown earlier."},{"content":"It is allowed with an explicit cast.","pos":[6378,6414]},{"content":"However, with scoped enums, the attempted conversion in the next statement, <ph id=\"ph1\">`account_num = Suit::Hearts;`</ph>, is no longer allowed without an explicit cast.","pos":[6415,6568],"source":" However, with scoped enums, the attempted conversion in the next statement, `account_num = Suit::Hearts;`, is no longer allowed without an explicit cast."},{"content":"See Also","pos":[6577,6585]},{"content":"C Enumeration Declarations","pos":[6590,6616]},{"content":"Keywords","pos":[6668,6676]}],"content":"---\ntitle: \"Enumerations (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"enum\"\n  - \"enum_cpp\"\n  - \"enum class\"\n  - \"enum struct\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"declarations, enumerations\"\n  - \"enumerators, declaring\"\n  - \"enum keyword [C++]\"\n  - \"named constants, enumeration declarations\"\n  - \"declaring enumerations\"\nms.assetid: 081829db-5dca-411e-a53c-bffef315bcb3\ncaps.latest.revision: 27\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Enumerations (C++)\nAn enumeration is a user-defined type that consists of a set of named integral constants that are known as enumerators.  \n  \n> [!NOTE]\n>  This article covers the ISO Standard C++ Language `enum` type and the scoped (or strongly-typed) `enum class` type which is introduced in C++11. For information about the `public enum class` or `private enum class` types in C++/CLI and C++/CX, see [enum class](../windows/enum-class-cpp-component-extensions.md).  \n  \n## Syntax  \n  \n```  \n// unscoped enum:  \nenum [identifier] [: type]  \n{enum-list};   \n  \n// scoped enum:  \nenum [class|struct]   \n[identifier] [: type]   \n{enum-list};  \n```  \n  \n```  \n// Forward declaration of enumerations  (C++11):  \nenum A : int; // non-scoped enum must have type specifiedenum class B; // scoped enum defaults to intenum class C : short;  \n```  \n  \n#### Parameters  \n `identifier`  \n The type name given to the enumeration.  \n  \n `type`  \n The underlying type of the enumerators; all enumerators have the same underlying type. May be any integral type.  \n  \n `enum-list`  \n Comma-separated list of the enumerators in the enumeration. Every enumerator or variable name in the scope must be unique. However, the values can be duplicated. In a unscoped enum, the scope is the surrounding scope; in a scoped enum, the scope is the `enum-list` itself.  \n  \n `class`  \n By using this keyword in the declaration, you specify the enum is scoped, and an `identifier` must be provided. You can also use the `struct` keyword in place of `class`, as they are semantically equivalent in this context.  \n  \n## Remarks  \n An enumeration provides context to describe a range of values which are represented as named constants and are also called enumerators. In the original C and C++ enum types, the unqualified enumerators are visible throughout the scope in which the enum is declared. In scoped enums, the enumerator name must be qualified by the enum type name. The following example demonstrates this basic difference between the two kinds of enums:  \n  \n```cpp  \nnamespace CardGame_Scoped  \n{  \n    enum class Suit { Diamonds, Hearts, Clubs, Spades };  \n  \n    void PlayCard(Suit suit)  \n    {  \n        if (suit == Suit::Clubs) // Enumerator must be qualified by enum type  \n        { /*...*/}  \n    }  \n}  \n  \nnamespace CardGame_NonScoped  \n{  \n    enum Suit { Diamonds, Hearts, Clubs, Spades };  \n  \n    void PlayCard(Suit suit)  \n    {  \n        if (suit == Clubs) // Enumerator is visible without qualification  \n        { /*...*/  \n        }  \n    }  \n}  \n```  \n  \n Every name in an enumeration is assigned an integral value that corresponds to its place in the order of the values in the enumeration. By default, the first value is assigned 0, the next one is assigned 1, and so on, but you can explicitly set the value of an enumerator, as shown here:  \n  \n```cpp  \n  \nenum Suit { Diamonds = 1, Hearts, Clubs, Spades };  \n  \n```  \n  \n The enumerator `Diamonds` is assigned the value `1`. Subsequent enumerators, if they are not given an explicit value, receive the value of the previous enumerator plus one. In the previous example, `Hearts` would have the value 2, `Clubs` would have 3, and so on.  \n  \n Every enumerator is treated as a constant and must have a unique name within the scope where the `enum` is defined (for unscoped enums) or within the enum itself (for scoped enums). The values given to the names do not have to be unique. For example, if the declaration of a unscoped enum `Suit` is this:  \n  \n```cpp  \nenum Suit { Diamonds = 5, Hearts, Clubs = 4, Spades };  \n```  \n  \n Then the values of `Diamonds`, `Hearts`, `Clubs`, and `Spades` are 5, 6, 4, and 5, respectively. Notice that 5 is used more than once; this is allowed even though it may not be intended. These rules are the same for scoped enums.  \n  \n **Casting rules**  \n  \n Unscoped enum constants can be implicitly converted to `int`, but an `int` is never implicitly convertible to an enum value. The following example shows what happens if you try to assign `hand` a value that is not a `Suit`:  \n  \n```cpp  \nint account_num = 135692;  \nSuit hand;  \nhand = account_num; // error C2440: '=' : cannot convert from 'int' to 'Suit'  \n  \n```  \n  \n A cast is required to convert an `int` to a scoped or unscoped enumerator. However, you can promote a unscoped enumerator to an integer value without a cast.  \n  \n```cpp  \nint account_num = Hearts; //OK if Hearts is in a unscoped enum  \n```  \n  \n Using implicit conversions in this way can lead to unintended side-effects. To help eliminate programming errors associated with unscoped enums, scoped enum values are strongly typed. Scoped enumerators must be qualified by the enum type name (identifier) and cannot be implicitly converted, as shown in the following example:  \n  \n```cpp  \nnamespace ScopedEnumConversions  \n{  \n    enum class Suit { Diamonds, Hearts, Clubs, Spades };  \n  \n    void AttemptConversions()  \n    {  \n        Suit hand;   \n        hand = Clubs; // error C2065: 'Clubs' : undeclared identifier  \n        hand = Suit::Clubs; //Correct.  \n        int account_num = 135692;  \n        hand = account_num; // error C2440: '=' : cannot convert from 'int' to 'Suit'  \n        hand = static_cast<Suit>(account_num); // OK, but probably a bug!!!  \n  \n        account_num = Suit::Hearts; // error C2440: '=' : cannot convert from 'Suit' to 'int'  \n        account_num = static_cast<int>(Suit::Hearts); // OK  \n}  \n  \n```  \n  \n Notice that the line `hand = account_num;` still causes the error that occurs with unscoped enums, as shown earlier. It is allowed with an explicit cast. However, with scoped enums, the attempted conversion in the next statement, `account_num = Suit::Hearts;`, is no longer allowed without an explicit cast.  \n  \n## See Also  \n [C Enumeration Declarations](../c-language/c-enumeration-declarations.md)   \n [Keywords](../cpp/keywords-cpp.md)"}