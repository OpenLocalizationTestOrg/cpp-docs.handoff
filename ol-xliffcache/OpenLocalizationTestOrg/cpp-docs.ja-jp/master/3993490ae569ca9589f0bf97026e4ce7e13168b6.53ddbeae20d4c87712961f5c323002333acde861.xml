{"nodes":[{"pos":[12,58],"content":"How to: Use Arrays in C++-CLI | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Use Arrays in C++-CLI | Microsoft Docs","pos":[0,46]}]},{"content":"How to: Use Arrays in C++/CLI","pos":[598,627]},{"pos":[628,733],"content":"This article describes how to use arrays in <ph id=\"ph1\">[!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]</ph>.","source":"This article describes how to use arrays in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]."},{"content":"Single-dimension arrays","pos":[742,765]},{"content":"The following sample shows how to create single-dimension arrays of reference, value, and native pointer types.","pos":[769,880]},{"content":"It also shows how to return a single-dimension array from a function and how to pass a single-dimension array as an argument to a function.","pos":[881,1020]},{"content":"Output","pos":[4093,4099]},{"content":"The next sample shows how to perform aggregate initialization on single-dimension managed arrays.","pos":[4372,4469]},{"content":"Output","pos":[5425,5431]},{"content":"This example shows how to perform aggregate initialization on a multi-dimension managed array:","pos":[5636,5730]},{"content":"Jagged arrays","pos":[6900,6913]},{"content":"This section shows how to create single-dimension arrays of managed arrays of reference, value, and native pointer types.","pos":[6917,7038]},{"content":"It also shows how to return a single-dimension array of managed arrays from a function and how to pass a single-dimension array as an argument to a function.","pos":[7039,7196]},{"content":"Output","pos":[9418,9424]},{"content":"The following sample shows how to perform aggregate initialization with jagged arrays.","pos":[9618,9704]},{"content":"Output","pos":[12496,12502]},{"content":"Managed arrays as template type parameters","pos":[12687,12729]},{"content":"This example shows how to use a managed array as a parameter to a template:","pos":[12733,12808]},{"content":"Output","pos":[13351,13357]},{"content":"typedefs for managed arrays","pos":[13406,13433]},{"content":"This example shows how to make a typedef for a managed array:","pos":[13437,13498]},{"content":"Sorting arrays","pos":[13744,13758]},{"content":"Unlike standard C++ arrays, managed arrays are implicitly derived from an array base class from which they inherit common behavior.","pos":[13762,13893]},{"content":"An example is the <ph id=\"ph1\">`Sort`</ph> method, which can be used to order the items in any array.","pos":[13894,13977],"source":" An example is the `Sort` method, which can be used to order the items in any array."},{"content":"For arrays that contain basic intrinsic types, you can call the <ph id=\"ph1\">`Sort`</ph> method.","pos":[13984,14062],"source":"For arrays that contain basic intrinsic types, you can call the `Sort` method."},{"content":"You can override the sort criteria, and doing so is required when you want to sort for arrays of complex types.","pos":[14063,14174]},{"content":"In this case, the array element type must implement the <bpt id=\"p1\">[</bpt>IComparable::CompareTo<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/system.icomparable.compareto.aspx)</ept> method.","pos":[14175,14339],"source":" In this case, the array element type must implement the [IComparable::CompareTo](https://msdn.microsoft.com/en-us/library/system.icomparable.compareto.aspx) method."},{"content":"Sorting arrays by using custom criteria","pos":[14599,14638]},{"content":"To sort arrays that contain basic intrinsic types, just call the <ph id=\"ph1\">`Array::Sort`</ph> method.","pos":[14642,14728],"source":"To sort arrays that contain basic intrinsic types, just call the `Array::Sort` method."},{"content":"However, to sort arrays that contain complex types or to override the default sort criteria, override the <bpt id=\"p1\">[</bpt>IComparable::CompareTo<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/system.icomparable.compareto.aspx)</ept> method.","pos":[14729,14943],"source":" However, to sort arrays that contain complex types or to override the default sort criteria, override the [IComparable::CompareTo](https://msdn.microsoft.com/en-us/library/system.icomparable.compareto.aspx) method."},{"pos":[14950,15178],"content":"In the following example, a structure named <ph id=\"ph1\">`Element`</ph> is derived from &lt;xref:System.IComparable&gt;, and written to provide a &lt;xref:System.IComparable.CompareTo%2A&gt; method that uses the average of two integers as the sort criterion.","source":"In the following example, a structure named `Element` is derived from <xref:System.IComparable>, and written to provide a <xref:System.IComparable.CompareTo%2A> method that uses the average of two integers as the sort criterion."},{"content":"Array covariance","pos":[16228,16244]},{"content":"Given reference class D that has direct or indirect base class B, an array of type D can be assigned to an array variable of type B.","pos":[16248,16380]},{"content":"An assignment to an array element shall be assignment-compatible with the dynamic type of the array.","pos":[16592,16692]},{"content":"An assignment to an array element that has an incompatible type causes <ph id=\"ph1\">`System::ArrayTypeMismatchException`</ph> to be thrown.","pos":[16693,16814],"source":" An assignment to an array element that has an incompatible type causes `System::ArrayTypeMismatchException` to be thrown."},{"content":"Array covariance doesn't apply to arrays of value class type.","pos":[16821,16882]},{"content":"For example, arrays of Int32 cannot be converted to Object^ arrays, not even by using boxing.","pos":[16883,16976]},{"content":"See Also","pos":[17705,17713]},{"content":"Arrays","pos":[17718,17724]}],"content":"---\ntitle: \"How to: Use Arrays in C++-CLI | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"arrays [C++], single-dimension\"\nms.assetid: 301cfb3e-199f-42c8-8151-629dce9e87f3\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Use Arrays in C++/CLI\nThis article describes how to use arrays in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)].  \n  \n## Single-dimension arrays  \n The following sample shows how to create single-dimension arrays of reference, value, and native pointer types. It also shows how to return a single-dimension array from a function and how to pass a single-dimension array as an argument to a function.  \n  \n```  \n  \n      // mcppv2_sdarrays.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \n#define ARRAY_SIZE 2  \n  \nvalue struct MyStruct {  \n   int m_i;  \n};  \n  \nref class MyClass {  \npublic:  \n   int m_i;  \n};  \n  \nstruct MyNativeClass {  \n   int m_i;  \n};  \n  \n// Returns a managed array of a reference type.  \narray<MyClass^>^ Test0() {  \n   int i;  \n   array< MyClass^ >^ local = gcnew array< MyClass^ >(ARRAY_SIZE);  \n  \n   for (i = 0 ; i < ARRAY_SIZE ; i++) {  \n      local[i] = gcnew MyClass;  \n      local[i] -> m_i = i;  \n   }  \n   return local;  \n}  \n  \n// Returns a managed array of Int32.  \narray<Int32>^ Test1() {  \n   int i;  \n   array< Int32 >^ local = gcnew array< Int32 >(ARRAY_SIZE);  \n  \n   for (i = 0 ; i < ARRAY_SIZE ; i++)  \n      local[i] = i + 10;  \n   return local;  \n}  \n  \n// Modifies an array.  \nvoid Test2(array< MyNativeClass * >^ local) {  \n   for (int i = 0 ; i < ARRAY_SIZE ; i++)  \n      local[i] -> m_i = local[i] -> m_i + 2;  \n}  \n  \nint main() {  \n   int i;  \n  \n   // Declares an array of user-defined reference types  \n   // and uses a function to initialize.  \n   array< MyClass^ >^ MyClass0;  \n   MyClass0 = Test0();  \n  \n   for (i = 0 ; i < ARRAY_SIZE ; i++)  \n      Console::WriteLine(\"MyClass0[{0}] = {1}\", i, MyClass0[i] -> m_i);  \n   Console::WriteLine();  \n  \n   // Declares an array of value types and uses a function to initialize.  \n   array< Int32 >^ IntArray;  \n   IntArray = Test1();  \n  \n   for (i = 0 ; i < ARRAY_SIZE ; i++)  \n      Console::WriteLine(\"IntArray[{0}] = {1}\", i, IntArray[i]);  \n   Console::WriteLine();  \n  \n   // Declares and initializes an array of user-defined   \n   // reference types.  \n   array< MyClass^ >^ MyClass1 = gcnew array< MyClass^ >(ARRAY_SIZE);  \n   for (i = 0 ; i < ARRAY_SIZE ; i++) {  \n      MyClass1[i] = gcnew MyClass;  \n      MyClass1[i] -> m_i = i + 20;  \n   }  \n  \n   for (i = 0 ; i < ARRAY_SIZE ; i++)  \n      Console::WriteLine(\"MyClass1[{0}] = {1}\", i, MyClass1[i] -> m_i);  \n   Console::WriteLine();  \n  \n   // Declares and initializes an array of pointers to a native type.  \n   array< MyNativeClass * >^ MyClass2 = gcnew array<   \n      MyNativeClass * >(ARRAY_SIZE);  \n   for (i = 0 ; i < ARRAY_SIZE ; i++) {  \n      MyClass2[i] = new MyNativeClass();  \n      MyClass2[i] -> m_i = i + 30;  \n   }  \n  \n   for (i = 0 ; i < ARRAY_SIZE ; i++)  \n      Console::WriteLine(\"MyClass2[{0}] = {1}\", i, MyClass2[i]->m_i);  \n   Console::WriteLine();  \n  \n   Test2(MyClass2);  \n   for (i = 0 ; i < ARRAY_SIZE ; i++)  \n      Console::WriteLine(\"MyClass2[{0}] = {1}\", i, MyClass2[i]->m_i);  \n   Console::WriteLine();  \n  \n   delete[] MyClass2[0];  \n   delete[] MyClass2[1];  \n  \n   // Declares and initializes an array of user-defined value types.  \n   array< MyStruct >^ MyStruct1 = gcnew array< MyStruct >(ARRAY_SIZE);  \n   for (i = 0 ; i < ARRAY_SIZE ; i++) {  \n      MyStruct1[i] = MyStruct();  \n      MyStruct1[i].m_i = i + 40;  \n   }  \n  \n   for (i = 0 ; i < ARRAY_SIZE ; i++)  \n      Console::WriteLine(\"MyStruct1[{0}] = {1}\", i, MyStruct1[i].m_i);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nMyClass0[0] = 0  \nMyClass0[1] = 1  \n  \nIntArray[0] = 10  \nIntArray[1] = 11  \n  \nMyClass1[0] = 20  \nMyClass1[1] = 21  \n  \nMyClass2[0] = 30  \nMyClass2[1] = 31  \n  \nMyClass2[0] = 32  \nMyClass2[1] = 33  \n  \nMyStruct1[0] = 40  \nMyStruct1[1] = 41  \n```  \n  \n The next sample shows how to perform aggregate initialization on single-dimension managed arrays.  \n  \n```  \n// mcppv2_sdarrays_aggregate_init.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref class G {  \npublic:  \n   G(int i) {}  \n};  \n  \nvalue class V {  \npublic:  \n   V(int i) {}  \n};  \n  \nclass N {  \npublic:  \n   N(int i) {}  \n};  \n  \nint main() {  \n   // Aggregate initialize a single-dimension managed array.  \n   array<String^>^ gc1 = gcnew array<String^>{\"one\", \"two\", \"three\"};  \n   array<String^>^ gc2 = {\"one\", \"two\", \"three\"};  \n  \n   array<G^>^ gc3 = gcnew array<G^>{gcnew G(0), gcnew G(1), gcnew G(2)};  \n   array<G^>^ gc4 = {gcnew G(0), gcnew G(1), gcnew G(2)};     \n  \n   array<Int32>^ value1 = gcnew array<Int32>{0, 1, 2};  \n   array<Int32>^ value2 = {0, 1, 2};  \n  \n   array<V>^ value3 = gcnew array<V>{V(0), V(1), V(2)};  \n   array<V>^ value4 = {V(0), V(1), V(2)};  \n  \n   array<N*>^ native1 = gcnew array<N*>{new N(0), new N(1), new N(2)};  \n   array<N*>^ native2 = {new N(0), new N(1), new N(2)};  \n}  \n  \n```  \n  \n **Output**  \n  \n```Output  \nMyClass0[0, 0] = 0  \nMyClass0[0, 1] = 0  \nMyClass0[1, 0] = 1  \nMyClass0[1, 1] = 1  \n  \nIntArray[0, 0] = 10  \nIntArray[0, 1] = 10  \nIntArray[1, 0] = 11  \nIntArray[1, 1] = 11  \n```  \n  \n This example shows how to perform aggregate initialization on a multi-dimension managed array:  \n  \n```  \n// mcppv2_mdarrays_aggregate_initialization.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref class G {  \npublic:  \n   G(int i) {}  \n};  \n  \nvalue class V {  \npublic:  \n   V(int i) {}  \n};  \n  \nclass N {  \npublic:  \n   N(int i) {}  \n};  \n  \nint main() {  \n   // Aggregate initialize a multidimension managed array.  \n   array<String^, 2>^ gc1 = gcnew array<String^, 2>{ {\"one\", \"two\"},   \n       {\"three\", \"four\"} };  \n   array<String^, 2>^ gc2 = { {\"one\", \"two\"}, {\"three\", \"four\"} };  \n  \n   array<G^, 2>^ gc3 = gcnew array<G^, 2>{ {gcnew G(0), gcnew G(1)},   \n       {gcnew G(2), gcnew G(3)} };  \n   array<G^, 2>^ gc4 = { {gcnew G(0), gcnew G(1)}, {gcnew G(2), gcnew G(3)} };  \n  \n   array<Int32, 2>^ value1 = gcnew array<Int32, 2>{ {0, 1}, {2, 3} };  \n   array<Int32, 2>^ value2 = { {0, 1}, {2, 3} };  \n  \n   array<V, 2>^ value3 = gcnew array<V, 2>{ {V(0), V(1)}, {V(2), V(3)} };  \n   array<V, 2>^ value4 = { {V(0), V(1)}, {V(2), V(3)} };  \n  \n   array<N*, 2>^ native1 = gcnew array<N*, 2>{ {new N(0), new N(1)},   \n      {new N(2), new N(3)} };  \n   array<N*, 2>^ native2 = { {new N(0), new N(1)}, {new N(2), new N(3)} };  \n}  \n```  \n  \n## Jagged arrays  \n This section shows how to create single-dimension arrays of managed arrays of reference, value, and native pointer types. It also shows how to return a single-dimension array of managed arrays from a function and how to pass a single-dimension array as an argument to a function.  \n  \n```  \n// mcppv2_array_of_arrays.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \n#define ARRAY_SIZE 2  \n  \nvalue struct MyStruct {  \n   int m_i;  \n};  \n  \nref class MyClass {  \npublic:  \n   int m_i;  \n};  \n  \n// Returns an array of managed arrays of a reference type.  \narray<array<MyClass^>^>^ Test0() {  \n   int size_of_array = 4;  \n   array<array<MyClass^>^>^ local = gcnew   \n      array<array<MyClass^>^>(ARRAY_SIZE);  \n  \n   for (int i = 0 ; i < ARRAY_SIZE ; i++, size_of_array += 4) {  \n      local[i] = gcnew array<MyClass^>(size_of_array);  \n      for (int k = 0; k < size_of_array ; k++) {  \n         local[i][k] = gcnew MyClass;  \n         local[i][k] -> m_i = i;  \n      }  \n   }  \n  \n   return local;  \n}  \n  \n// Returns a managed array of Int32.  \narray<array<Int32>^>^ Test1() {  \n   int i;  \n   array<array<Int32>^>^ local = gcnew array<array< Int32 >^>(ARRAY_SIZE);  \n  \n   for (i = 0 ; i < ARRAY_SIZE ; i++) {  \n      local[i] = gcnew array< Int32 >(ARRAY_SIZE);  \n         for ( int j = 0 ; j < ARRAY_SIZE ; j++ )   \n            local[i][j] = i + 10;  \n   }  \n   return local;  \n}  \n  \nint main() {  \n   int i, j;  \n  \n   // Declares an array of user-defined reference types  \n   // and uses a function to initialize.  \n   array< array< MyClass^ >^ >^ MyClass0;  \n   MyClass0 = Test0();  \n  \n   for (i = 0 ; i < ARRAY_SIZE ; i++)  \n      for ( j = 0 ; j < ARRAY_SIZE ; j++ )   \n         Console::WriteLine(\"MyClass0[{0}] = {1}\", i, MyClass0[i][j] -> m_i);  \n   Console::WriteLine();  \n  \n   // Declares an array of value types and uses a function to initialize.  \n   array< array< Int32 >^ >^ IntArray;  \n   IntArray = Test1();  \n  \n   for (i = 0 ; i < ARRAY_SIZE ; i++)  \n      for (j = 0 ; j < ARRAY_SIZE ; j++)  \n      Console::WriteLine(\"IntArray[{0}] = {1}\", i, IntArray[i][j]);  \n   Console::WriteLine();  \n  \n   // Declares and initializes an array of user-defined value types.  \n   array< MyStruct >^ MyStruct1 = gcnew array< MyStruct >(ARRAY_SIZE);  \n   for (i = 0 ; i < ARRAY_SIZE ; i++) {  \n      MyStruct1[i] = MyStruct();  \n      MyStruct1[i].m_i = i + 40;  \n   }  \n  \n   for (i = 0 ; i < ARRAY_SIZE ; i++)  \n      Console::WriteLine(MyStruct1[i].m_i);  \n}  \n  \n```  \n  \n **Output**  \n  \n```Output  \nMyClass0[0] = 0  \nMyClass0[0] = 0  \nMyClass0[1] = 1  \nMyClass0[1] = 1  \n  \nIntArray[0] = 10  \nIntArray[0] = 10  \nIntArray[1] = 11  \nIntArray[1] = 11  \n  \n40  \n41  \n```  \n  \n The following sample shows how to perform aggregate initialization with jagged arrays.  \n  \n```  \n// mcppv2_array_of_arrays_aggregate_init.cpp  \n// compile with: /clr  \nusing namespace System;  \n#define ARRAY_SIZE 2  \nint size_of_array = 4;  \nint count = 0;  \n  \nref class MyClass {  \npublic:  \n   int m_i;  \n};  \n  \nstruct MyNativeClass {  \n   int m_i;  \n};  \n  \nint main() {  \n   // Declares an array of user-defined reference types  \n   // and performs an aggregate initialization.  \n   array< array< MyClass^ >^ >^ MyClass0 = gcnew array<array<MyClass^>^> {  \n      gcnew array<MyClass^>{ gcnew MyClass(), gcnew MyClass() },  \n      gcnew array<MyClass^>{ gcnew MyClass(), gcnew MyClass() }  \n   };  \n  \n   for ( int i = 0 ; i < ARRAY_SIZE ; i++, size_of_array += 4 )  \n      for ( int k = 0 ; k < ARRAY_SIZE ; k++ )  \n         MyClass0[i][k] -> m_i = i;  \n  \n   for ( int i = 0 ; i < ARRAY_SIZE ; i++ )  \n      for ( int j = 0 ; j < ARRAY_SIZE ; j++ )   \n         Console::WriteLine(\"MyClass0[{0}] = {1}\", i, MyClass0[i][j] -> m_i);  \n   Console::WriteLine();  \n  \n   // Declares an array of value types and performs an aggregate initialization.  \n   array< array< Int32 >^ >^ IntArray = gcnew array<array< Int32 >^> {  \n      gcnew array<Int32>{1,2},  \n      gcnew array<Int32>{3,4,5}  \n   };  \n  \n   for each ( array<int>^ outer in IntArray ) {  \n      Console::Write(\"[\");   \n  \n      for each( int i in outer )  \n         Console::Write(\" {0}\", i);  \n  \n      Console::Write(\" ]\");  \n      Console::WriteLine();  \n   }  \n   Console::WriteLine();  \n  \n   // Declares and initializes an array of pointers to a native type.  \n   array<array< MyNativeClass * >^ > ^ MyClass2 =   \n      gcnew array<array< MyNativeClass * > ^> {  \n         gcnew array<MyNativeClass *>{ new MyNativeClass(), new MyNativeClass() },  \n         gcnew array<MyNativeClass *>{ new MyNativeClass(), new MyNativeClass(), new MyNativeClass() }  \n      };  \n  \n   for each ( array<MyNativeClass *> ^ outer in MyClass2 )  \n      for each( MyNativeClass* i in outer )  \n         i->m_i = count++;  \n  \n   for each ( array<MyNativeClass *> ^ outer in MyClass2 ) {  \n      Console::Write(\"[\");  \n      for each( MyNativeClass* i in outer )  \n         Console::Write(\" {0}\", i->m_i);  \n      Console::Write(\" ]\");  \n      Console::WriteLine();  \n   }  \n   Console::WriteLine();  \n  \n   // Declares and initializes an array of two-dimensional arrays of strings.  \n   array<array<String ^,2> ^> ^gc3 = gcnew array<array<String ^,2> ^>{   \n      gcnew array<String ^>{ {\"a\",\"b\"}, {\"c\", \"d\"}, {\"e\",\"f\"} },  \n      gcnew array<String ^>{ {\"g\", \"h\"} }   \n   };  \n  \n   for each ( array<String^, 2> ^ outer in gc3 ){  \n      Console::Write(\"[\");  \n      for each( String ^ i in outer )  \n         Console::Write(\" {0}\", i);  \n      Console::Write(\" ]\");  \n      Console::WriteLine();  \n   }  \n}  \n  \n```  \n  \n **Output**  \n  \n```Output  \nMyClass0[0] = 0  \nMyClass0[0] = 0  \nMyClass0[1] = 1  \nMyClass0[1] = 1  \n  \n[ 1 2 ]  \n[ 3 4 5 ]  \n  \n[ 0 1 ]  \n[ 2 3 4 ]  \n  \n[ a b c d e f ]  \n[ g h ]  \n```  \n  \n## Managed arrays as template type parameters  \n This example shows how to use a managed array as a parameter to a template:  \n  \n```  \n// mcppv2_template_type_params.cpp  \n// compile with: /clr  \nusing namespace System;  \ntemplate <class T>   \nclass TA {  \npublic:  \n   array<array<T>^>^ f() {  \n      array<array<T>^>^ larr = gcnew array<array<T>^>(10);  \n      return larr;  \n   }  \n};  \n  \nint main() {  \n   int retval = 0;  \n   TA<array<array<Int32>^>^>* ta1 = new TA<array<array<Int32>^>^>();  \n   array<array<array<array<Int32>^>^>^>^ larr = ta1->f();  \n   retval += larr->Length - 10;  \n   Console::WriteLine(\"Return Code: {0}\", retval);  \n}  \n  \n```  \n  \n **Output**  \n  \n```Output  \nReturn Code: 0  \n```  \n  \n## typedefs for managed arrays  \n This example shows how to make a typedef for a managed array:  \n  \n```  \n// mcppv2_typedef_arrays.cpp  \n// compile with: /clr  \nusing namespace System;  \nref class G {};  \n  \ntypedef array<array<G^>^> jagged_array;  \n  \nint main() {  \n   jagged_array ^ MyArr = gcnew jagged_array (10);  \n}  \n  \n```  \n  \n## Sorting arrays  \n Unlike standard C++ arrays, managed arrays are implicitly derived from an array base class from which they inherit common behavior. An example is the `Sort` method, which can be used to order the items in any array.  \n  \n For arrays that contain basic intrinsic types, you can call the `Sort` method. You can override the sort criteria, and doing so is required when you want to sort for arrays of complex types. In this case, the array element type must implement the [IComparable::CompareTo](https://msdn.microsoft.com/en-us/library/system.icomparable.compareto.aspx) method.  \n  \n```  \n// array_sort.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nint main() {  \n   array<int>^ a = { 5, 4, 1, 3, 2 };  \n   Array::Sort( a );  \n   for (int i=0; i < a->Length; i++)  \n      Console::Write(\"{0} \", a[i] );  \n}  \n  \n```  \n  \n## Sorting arrays by using custom criteria  \n To sort arrays that contain basic intrinsic types, just call the `Array::Sort` method. However, to sort arrays that contain complex types or to override the default sort criteria, override the [IComparable::CompareTo](https://msdn.microsoft.com/en-us/library/system.icomparable.compareto.aspx) method.  \n  \n In the following example, a structure named `Element` is derived from <xref:System.IComparable>, and written to provide a <xref:System.IComparable.CompareTo%2A> method that uses the average of two integers as the sort criterion.  \n  \n```  \nusing namespace System;  \n  \nvalue struct Element : public IComparable {  \n   int v1, v2;  \n  \n   virtual int CompareTo(Object^ obj) {  \n      Element^ o = dynamic_cast<Element^>(obj);  \n      if (o) {  \n         int thisAverage = (v1 + v2) / 2;  \n         int thatAverage = (o->v1 + o->v2) / 2;  \n         if (thisAverage < thatAverage)  \n            return -1;  \n         else if (thisAverage > thatAverage)  \n            return 1;  \n         return 0;  \n         }  \n      else  \n         throw gcnew ArgumentException  \n      (\"Object must be of type 'Element'\");  \n   }  \n};  \n  \nint main() {  \n   array<Element>^ a = gcnew array<Element>(10);  \n   Random^ r = gcnew Random;  \n  \n   for (int i=0; i < a->Length; i++) {  \n      a[i].v1 = r->Next() % 100;  \n      a[i].v2 = r->Next() % 100;  \n   }  \n  \n   Array::Sort( a );  \n   for (int i=0; i < a->Length; i++) {  \n      int v1 = a[i].v1;  \n      int v2 = a[i].v2;  \n      int v = (v1 + v2) / 2;  \n      Console::WriteLine(\"{0}  (({1}+{2})/2) \", v, v1, v2);  \n   }  \n}  \n```  \n  \n## Array covariance  \n Given reference class D that has direct or indirect base class B, an array of type D can be assigned to an array variable of type B.  \n  \n```  \n// clr_array_covariance.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nint main() {  \n   // String derives from Object.  \n   array<Object^>^ oa = gcnew array<String^>(20);  \n}  \n```  \n  \n An assignment to an array element shall be assignment-compatible with the dynamic type of the array. An assignment to an array element that has an incompatible type causes `System::ArrayTypeMismatchException` to be thrown.  \n  \n Array covariance doesn't apply to arrays of value class type. For example, arrays of Int32 cannot be converted to Object^ arrays, not even by using boxing.  \n  \n```  \n// clr_array_covariance2.cpp  \n// compile with: /clr  \nusing namespace System;  \n  \nref struct Base { int i; };  \nref struct Derived  : Base {};  \nref struct Derived2 : Base {};  \nref struct Derived3 : Derived {};  \nref struct Other { short s; };  \n  \nint main() {  \n   // Derived* d[] = new Derived*[100];  \n   array<Derived^> ^ d = gcnew array<Derived^>(100);  \n  \n   // ok by array covariance  \n   array<Base ^> ^  b = d;  \n  \n   // invalid  \n   // b[0] = new Other;  \n  \n   // error (runtime exception)  \n   // b[1] = gcnew Derived2;  \n  \n   // error (runtime exception),  \n   // must be \"at least\" a Derived.  \n   // b[0] = gcnew Base;  \n  \n   b[1] = gcnew Derived;  \n   b[0] = gcnew Derived3;  \n}  \n```  \n  \n## See Also  \n [Arrays](../windows/arrays-cpp-component-extensions.md)"}