{"nodes":[{"pos":[12,44],"content":"decltype  (C++) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"decltype  (C++) | Microsoft Docs","pos":[0,32]}]},{"content":"decltype  (C++)","pos":[753,768]},{"content":"The <ph id=\"ph1\">`decltype`</ph> type specifier yields the type of a specified expression.","pos":[769,841],"source":"The `decltype` type specifier yields the type of a specified expression."},{"content":"The <ph id=\"ph1\">`decltype`</ph> type specifier, together with the <bpt id=\"p1\">[</bpt>auto keyword<ept id=\"p1\">](../cpp/auto-cpp.md)</ept>, is useful primarily to developers who write template libraries.","pos":[842,990],"source":" The `decltype` type specifier, together with the [auto keyword](../cpp/auto-cpp.md), is useful primarily to developers who write template libraries."},{"content":"Use <ph id=\"ph1\">`auto`</ph> and <ph id=\"ph2\">`decltype`</ph> to declare a template function whose return type depends on the types of its template arguments.","pos":[991,1113],"source":" Use `auto` and `decltype` to declare a template function whose return type depends on the types of its template arguments."},{"content":"Or, use <ph id=\"ph1\">`auto`</ph> and <ph id=\"ph2\">`decltype`</ph> to declare a template function that wraps a call to another function, and then returns the return type of the wrapped function.","pos":[1114,1271],"source":" Or, use `auto` and `decltype` to declare a template function that wraps a call to another function, and then returns the return type of the wrapped function."},{"content":"Syntax","pos":[1280,1286]},{"content":"Parameters","pos":[1337,1347]},{"content":"Parameter","pos":[1354,1363]},{"content":"Description","pos":[1364,1375]},{"content":"An expression.","pos":[1431,1445]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Expressions<ept id=\"p1\">](../cpp/expressions-cpp.md)</ept>.","pos":[1446,1513],"source":" For more information, see [Expressions](../cpp/expressions-cpp.md)."},{"content":"Return Value","pos":[1523,1535]},{"pos":[1539,1578],"content":"The type of the <ph id=\"ph1\">`expression`</ph> parameter.","source":"The type of the `expression` parameter."},{"content":"Remarks","pos":[1587,1594]},{"content":"The <ph id=\"ph1\">`decltype`</ph> type specifier is supported in Visual C++ 2010 or later versions, and can be used with native or managed code.","pos":[1598,1723],"source":"The `decltype` type specifier is supported in Visual C++ 2010 or later versions, and can be used with native or managed code."},{"content":"(C++14) is supported in Visual Studio 2015 and later.","pos":[1741,1794]},{"pos":[1801,1891],"content":"The compiler uses the following rules to determine the type of the <ph id=\"ph1\">`expression`</ph> parameter.","source":"The compiler uses the following rules to determine the type of the `expression` parameter."},{"content":"If the <ph id=\"ph1\">`expression`</ph> parameter is an identifier or a <bpt id=\"p1\">[</bpt>class member access<ept id=\"p1\">](../cpp/member-access-operators-dot-and.md)</ept>, <ph id=\"ph2\">`decltype(``expression``)`</ph> is the type of the entity named by <ph id=\"ph3\">`expression`</ph>.","pos":[1901,2094],"source":"If the `expression` parameter is an identifier or a [class member access](../cpp/member-access-operators-dot-and.md), `decltype(``expression``)` is the type of the entity named by `expression`."},{"content":"If there is no such entity or the <ph id=\"ph1\">`expression`</ph> parameter names a set of overloaded functions, the compiler yields an error message.","pos":[2095,2226],"source":" If there is no such entity or the `expression` parameter names a set of overloaded functions, the compiler yields an error message."},{"content":"If the <ph id=\"ph1\">`expression`</ph> parameter is a call to a function or an overloaded operator function, <ph id=\"ph2\">`decltype(``expression``)`</ph> is the return type of the function.","pos":[2236,2388],"source":"If the `expression` parameter is a call to a function or an overloaded operator function, `decltype(``expression``)` is the return type of the function."},{"content":"Parentheses around an overloaded operator are ignored.","pos":[2389,2443]},{"content":"If the <ph id=\"ph1\">`expression`</ph> parameter is an <bpt id=\"p1\">[</bpt>rvalue<ept id=\"p1\">](../cpp/lvalues-and-rvalues-visual-cpp.md)</ept>, <ph id=\"ph2\">`decltype(``expression``)`</ph> is the type of <ph id=\"ph3\">`expression`</ph>.","pos":[2453,2596],"source":"If the `expression` parameter is an [rvalue](../cpp/lvalues-and-rvalues-visual-cpp.md), `decltype(``expression``)` is the type of `expression`."},{"content":"If the <ph id=\"ph1\">`expression`</ph> parameter is an <bpt id=\"p1\">[</bpt>lvalue<ept id=\"p1\">](../cpp/lvalues-and-rvalues-visual-cpp.md)</ept>, <ph id=\"ph2\">`decltype(``expression``)`</ph> is an <bpt id=\"p2\">[</bpt>lvalue reference<ept id=\"p2\">](../cpp/lvalue-reference-declarator-amp.md)</ept> to the type of <ph id=\"ph3\">`expression`</ph>.","pos":[2597,2808],"source":" If the `expression` parameter is an [lvalue](../cpp/lvalues-and-rvalues-visual-cpp.md), `decltype(``expression``)` is an [lvalue reference](../cpp/lvalue-reference-declarator-amp.md) to the type of `expression`."},{"content":"The following code example demonstrates some uses of the <ph id=\"ph1\">`decltype`</ph> type specifier.","pos":[2815,2898],"source":"The following code example demonstrates some uses of the `decltype` type specifier."},{"content":"First, assume that you have coded the following statements.","pos":[2899,2958]},{"pos":[3061,3160],"content":"Next, examine the types that are returned by the four <ph id=\"ph1\">`decltype`</ph> statements in the following table.","source":"Next, examine the types that are returned by the four `decltype` statements in the following table."},{"content":"Statement","pos":[3167,3176]},{"content":"Type","pos":[3177,3181]},{"content":"Notes","pos":[3182,3187]},{"pos":[3267,3353],"content":"An <bpt id=\"p1\">[</bpt>rvalue reference<ept id=\"p1\">](../cpp/rvalue-reference-declarator-amp-amp.md)</ept> to a <ph id=\"ph1\">`const int`</ph>.","source":"An [rvalue reference](../cpp/rvalue-reference-declarator-amp-amp.md) to a `const int`."},{"pos":[3381,3408],"content":"The type of variable <ph id=\"ph1\">`var`</ph>.","source":"The type of variable `var`."},{"content":"The type of the member access.","pos":[3440,3470]},{"content":"The inner parentheses cause the statement to be evaluated as an expression instead of a member access.","pos":[3511,3613]},{"content":"And because <ph id=\"ph1\">`a`</ph> is declared as a <ph id=\"ph2\">`const`</ph> pointer, the type is a reference to <ph id=\"ph3\">`const double`</ph>.","pos":[3614,3706],"source":" And because `a` is declared as a `const` pointer, the type is a reference to `const double`."},{"content":"Decltype and Auto","pos":[3716,3733]},{"pos":[3737,3901],"content":"In C++14, you can use <ph id=\"ph1\">`decltype(auto)`</ph> with no trailing return type to declare a template function whose return type depends on the types of its template arguments.","source":"In C++14, you can use `decltype(auto)` with no trailing return type to declare a template function whose return type depends on the types of its template arguments."},{"content":"In C++11, you can use the <ph id=\"ph1\">`decltype`</ph> type specifier on a trailing return type, together with the <ph id=\"ph2\">`auto`</ph> keyword, to declare a template function whose return type depends on the types of its template arguments.","pos":[3908,4117],"source":"In C++11, you can use the `decltype` type specifier on a trailing return type, together with the `auto` keyword, to declare a template function whose return type depends on the types of its template arguments."},{"content":"For example, consider the following code example in which the return type of the template function depends on the types of the template arguments.","pos":[4118,4264]},{"content":"In the code example, the <bpt id=\"p1\">*</bpt>UNKNOWN<ept id=\"p1\">*</ept> placeholder indicates that the return type cannot be specified.","pos":[4265,4363],"source":" In the code example, the *UNKNOWN* placeholder indicates that the return type cannot be specified."},{"content":"The introduction of the <ph id=\"ph1\">`decltype`</ph> type specifier enables a developer to obtain the type of the expression that the template function returns.","pos":[4467,4609],"source":"The introduction of the `decltype` type specifier enables a developer to obtain the type of the expression that the template function returns."},{"content":"Use the <bpt id=\"p1\">*</bpt>alternative function declaration syntax<ept id=\"p1\">*</ept> that is shown later, the <ph id=\"ph1\">`auto`</ph> keyword, and the <ph id=\"ph2\">`decltype`</ph> type specifier to declare a <bpt id=\"p2\">*</bpt>late-specified<ept id=\"p2\">*</ept> return type.","pos":[4610,4777],"source":" Use the *alternative function declaration syntax* that is shown later, the `auto` keyword, and the `decltype` type specifier to declare a *late-specified* return type."},{"content":"The late-specified return type is determined when the declaration is compiled, instead of when it is coded.","pos":[4778,4885]},{"content":"The following prototype illustrates the syntax of an alternative function declaration.","pos":[4892,4978]},{"content":"Note that the <ph id=\"ph1\">`const`</ph> and <ph id=\"ph2\">`volatile`</ph> qualifiers, and the <ph id=\"ph3\">`throw`</ph><bpt id=\"p1\">[</bpt>exception specification<ept id=\"p1\">](../cpp/exception-specifications-throw-cpp.md)</ept> are optional.","pos":[4979,5128],"source":" Note that the `const` and `volatile` qualifiers, and the `throw`[exception specification](../cpp/exception-specifications-throw-cpp.md) are optional."},{"content":"The <bpt id=\"p1\">*</bpt>function_body<ept id=\"p1\">*</ept> placeholder represents a compound statement that specifies what the function does.","pos":[5129,5231],"source":" The *function_body* placeholder represents a compound statement that specifies what the function does."},{"content":"As a best coding practice, the <bpt id=\"p1\">*</bpt>expression<ept id=\"p1\">*</ept> placeholder in the <ph id=\"ph1\">`decltype`</ph> statement should match the expression specified by the <ph id=\"ph2\">`return`</ph> statement, if any, in the <bpt id=\"p2\">*</bpt>function_body<ept id=\"p2\">*</ept>.","pos":[5232,5412],"source":" As a best coding practice, the *expression* placeholder in the `decltype` statement should match the expression specified by the `return` statement, if any, in the *function_body*."},{"pos":[5426,5545],"content":"<bpt id=\"p1\">*</bpt>function_name<ept id=\"p1\">*</ept> <ph id=\"ph1\">`(`</ph> <bpt id=\"p2\">*</bpt>parameters<ept id=\"p2\">*</ept>opt<ph id=\"ph2\">`)``const`</ph>opt<ph id=\"ph3\">`volatile`</ph>opt<ph id=\"ph4\">`−&gt;``decltype(`</ph><bpt id=\"p3\">*</bpt>expression<ept id=\"p3\">*</ept><ph id=\"ph5\">`)``throw`</ph>opt<ph id=\"ph6\">`{`</ph><bpt id=\"p4\">*</bpt>function_body<ept id=\"p4\">*</ept>","source":"*function_name* `(` *parameters*opt`)``const`opt`volatile`opt`−>``decltype(`*expression*`)``throw`opt`{`*function_body*"},{"content":"In the following code example, the late-specified return type of the <ph id=\"ph1\">`myFunc`</ph> template function is determined by the types of the <ph id=\"ph2\">`t`</ph> and <ph id=\"ph3\">`u`</ph> template arguments.","pos":[5556,5717],"source":"In the following code example, the late-specified return type of the `myFunc` template function is determined by the types of the `t` and `u` template arguments."},{"content":"As a best coding practice, the code example also uses rvalue references and the <ph id=\"ph1\">`forward`</ph> function template, which support <bpt id=\"p1\">*</bpt>perfect forwarding<ept id=\"p1\">*</ept>.","pos":[5718,5862],"source":" As a best coding practice, the code example also uses rvalue references and the `forward` function template, which support *perfect forwarding*."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Rvalue Reference Declarator: &amp;&amp;<ept id=\"p1\">](../cpp/rvalue-reference-declarator-amp-amp.md)</ept>.","pos":[5863,5970],"source":" For more information, see [Rvalue Reference Declarator: &&](../cpp/rvalue-reference-declarator-amp-amp.md)."},{"content":"Decltype and Forwarding Functions (C++11)","pos":[6309,6350]},{"content":"Forwarding functions wrap calls to other functions.","pos":[6354,6405]},{"content":"Consider a function template that forwards its arguments, or the results of an expression that involves those arguments, to another function.","pos":[6406,6547]},{"content":"Furthermore, the forwarding function returns the result of calling the other function.","pos":[6548,6634]},{"content":"In this scenario, the return type of the forwarding function should be the same as the return type of the wrapped function.","pos":[6635,6758]},{"content":"In this scenario, you cannot write an appropriate type expression without the <ph id=\"ph1\">`decltype`</ph> type specifier.","pos":[6765,6869],"source":"In this scenario, you cannot write an appropriate type expression without the `decltype` type specifier."},{"content":"The <ph id=\"ph1\">`decltype`</ph> type specifier enables generic forwarding functions because it does not lose required information about whether a function returns a reference type.","pos":[6870,7033],"source":" The `decltype` type specifier enables generic forwarding functions because it does not lose required information about whether a function returns a reference type."},{"content":"For a code example of a forwarding function, see the previous <ph id=\"ph1\">`myFunc`</ph> template function example.","pos":[7034,7131],"source":" For a code example of a forwarding function, see the previous `myFunc` template function example."},{"content":"Example","pos":[7140,7147]},{"content":"The following code example declares the late-specified return type of template function <ph id=\"ph1\">`Plus()`</ph>.","pos":[7151,7248],"source":"The following code example declares the late-specified return type of template function `Plus()`."},{"content":"The <ph id=\"ph1\">`Plus`</ph> function processes its two operands with the <ph id=\"ph2\">`operator+`</ph> overload.","pos":[7249,7326],"source":" The `Plus` function processes its two operands with the `operator+` overload."},{"content":"Consequently, the interpretation of the plus operator (+) and the return type of the <ph id=\"ph1\">`Plus`</ph> function depends on the types of the function arguments.","pos":[7327,7475],"source":" Consequently, the interpretation of the plus operator (+) and the return type of the `Plus` function depends on the types of the function arguments."},{"content":"Output","pos":[8673,8679]},{"content":"This code example yields the following results.","pos":[8688,8735]},{"content":"13","pos":[8742,8744]},{"content":"13.5","pos":[8751,8755]},{"content":"Hello, world!","pos":[8762,8775]},{"content":"42","pos":[8782,8784]},{"content":"Requirements","pos":[8793,8805]},{"content":"Visual C++ 2010 or later versions.","pos":[8809,8843]},{"content":"decltype(auto) requires Visual Studio 2015 or later","pos":[8850,8901]}],"content":"---\ntitle: \"decltype  (C++) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"decltype\"\n  - \"decltype_cpp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"operators [C++], decltype\"\n  - \"decltype operator\"\n  - \"operators [C++], type of an expression\"\n  - \"operators [C++], deduce expression type\"\nms.assetid: 6dcf8888-8196-4f13-af50-51e3797255d4\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# decltype  (C++)\nThe `decltype` type specifier yields the type of a specified expression. The `decltype` type specifier, together with the [auto keyword](../cpp/auto-cpp.md), is useful primarily to developers who write template libraries. Use `auto` and `decltype` to declare a template function whose return type depends on the types of its template arguments. Or, use `auto` and `decltype` to declare a template function that wraps a call to another function, and then returns the return type of the wrapped function.  \n  \n## Syntax  \n  \n```  \ndecltype( expression )  \n```  \n  \n#### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|`expression`|An expression. For more information, see [Expressions](../cpp/expressions-cpp.md).|  \n  \n## Return Value  \n The type of the `expression` parameter.  \n  \n## Remarks  \n The `decltype` type specifier is supported in Visual C++ 2010 or later versions, and can be used with native or managed code. `decltype(auto)` (C++14) is supported in Visual Studio 2015 and later.  \n  \n The compiler uses the following rules to determine the type of the `expression` parameter.  \n  \n-   If the `expression` parameter is an identifier or a [class member access](../cpp/member-access-operators-dot-and.md), `decltype(``expression``)` is the type of the entity named by `expression`. If there is no such entity or the `expression` parameter names a set of overloaded functions, the compiler yields an error message.  \n  \n-   If the `expression` parameter is a call to a function or an overloaded operator function, `decltype(``expression``)` is the return type of the function. Parentheses around an overloaded operator are ignored.  \n  \n-   If the `expression` parameter is an [rvalue](../cpp/lvalues-and-rvalues-visual-cpp.md), `decltype(``expression``)` is the type of `expression`. If the `expression` parameter is an [lvalue](../cpp/lvalues-and-rvalues-visual-cpp.md), `decltype(``expression``)` is an [lvalue reference](../cpp/lvalue-reference-declarator-amp.md) to the type of `expression`.  \n  \n The following code example demonstrates some uses of the `decltype` type specifier. First, assume that you have coded the following statements.  \n  \n```  \nint var;  \nconst int&& fx();   \nstruct A { double x; }  \nconst A* a = new A();  \n```  \n  \n Next, examine the types that are returned by the four `decltype` statements in the following table.  \n  \n|Statement|Type|Notes|  \n|---------------|----------|-----------|  \n|`decltype(fx());`|`const int&&`|An [rvalue reference](../cpp/rvalue-reference-declarator-amp-amp.md) to a `const int`.|  \n|`decltype(var);`|`int`|The type of variable `var`.|  \n|`decltype(a->x);`|`double`|The type of the member access.|  \n|`decltype((a->x));`|`const double&`|The inner parentheses cause the statement to be evaluated as an expression instead of a member access. And because `a` is declared as a `const` pointer, the type is a reference to `const double`.|  \n  \n## Decltype and Auto  \n In C++14, you can use `decltype(auto)` with no trailing return type to declare a template function whose return type depends on the types of its template arguments.  \n  \n In C++11, you can use the `decltype` type specifier on a trailing return type, together with the `auto` keyword, to declare a template function whose return type depends on the types of its template arguments. For example, consider the following code example in which the return type of the template function depends on the types of the template arguments. In the code example, the *UNKNOWN* placeholder indicates that the return type cannot be specified.  \n  \n```  \ntemplate<typename T, typename U>  \nUNKNOWNfunc(T&& t, U&& u){ return t + u; };   \n```  \n  \n The introduction of the `decltype` type specifier enables a developer to obtain the type of the expression that the template function returns. Use the *alternative function declaration syntax* that is shown later, the `auto` keyword, and the `decltype` type specifier to declare a *late-specified* return type. The late-specified return type is determined when the declaration is compiled, instead of when it is coded.  \n  \n The following prototype illustrates the syntax of an alternative function declaration. Note that the `const` and `volatile` qualifiers, and the `throw`[exception specification](../cpp/exception-specifications-throw-cpp.md) are optional. The *function_body* placeholder represents a compound statement that specifies what the function does. As a best coding practice, the *expression* placeholder in the `decltype` statement should match the expression specified by the `return` statement, if any, in the *function_body*.  \n  \n `auto` *function_name* `(` *parameters*opt`)``const`opt`volatile`opt`−>``decltype(`*expression*`)``throw`opt`{`*function_body*`};`  \n  \n In the following code example, the late-specified return type of the `myFunc` template function is determined by the types of the `t` and `u` template arguments. As a best coding practice, the code example also uses rvalue references and the `forward` function template, which support *perfect forwarding*. For more information, see [Rvalue Reference Declarator: &&](../cpp/rvalue-reference-declarator-amp-amp.md).  \n  \n```  \n//C++11  \n template<typename T, typename U>  \nauto myFunc(T&& t, U&& u) -> decltype (forward<T>(t) + forward<U>(u))   \n        { return forward<T>(t) + forward<U>(u); };  \n  \n//C++14  \ntemplate<typename T, typename U>  \ndecltype(auto) myFunc(T&& t, U&& u)   \n        { return forward<T>(t) + forward<U>(u); };  \n  \n```  \n  \n## Decltype and Forwarding Functions (C++11)  \n Forwarding functions wrap calls to other functions. Consider a function template that forwards its arguments, or the results of an expression that involves those arguments, to another function. Furthermore, the forwarding function returns the result of calling the other function. In this scenario, the return type of the forwarding function should be the same as the return type of the wrapped function.  \n  \n In this scenario, you cannot write an appropriate type expression without the `decltype` type specifier. The `decltype` type specifier enables generic forwarding functions because it does not lose required information about whether a function returns a reference type. For a code example of a forwarding function, see the previous `myFunc` template function example.  \n  \n## Example  \n The following code example declares the late-specified return type of template function `Plus()`. The `Plus` function processes its two operands with the `operator+` overload. Consequently, the interpretation of the plus operator (+) and the return type of the `Plus` function depends on the types of the function arguments.  \n  \n```  \n// decltype_1.cpp  \n// compile with: /EHsc  \n//  \n#include \"stdafx.h\"  \n#include <iostream>  \n#include <string>  \n#include <utility>  \n#include <iomanip>  \n  \nusing namespace std;  \n  \ntemplate<typename T1, typename T2>  \nauto Plus(T1&& t1, T2&& t2) ->   \n   decltype(forward<T1>(t1) + forward<T2>(t2))  \n{  \n   return forward<T1>(t1) + forward<T2>(t2);  \n}  \n  \nclass X  \n{  \n   friend X operator+(const X& x1, const X& x2)  \n   {  \n      return X(x1.m_data + x2.m_data);  \n   }  \n  \npublic:  \n   X(int data) : m_data(data) {}  \n   int Dump() const { return m_data;}  \nprivate:  \n   int m_data;  \n};  \n  \nint main()  \n{  \n   // Integer   \n   int i = 4;  \n   cout <<   \n      \"Plus(i, 9) = \" <<   \n      Plus(i, 9) << endl;  \n  \n   // Floating point  \n   float dx = 4.0;  \n   float dy = 9.5;  \n   cout <<     \n      setprecision(3) <<   \n      \"Plus(dx, dy) = \" <<  \n      Plus(dx, dy) << endl;  \n  \n   // String        \n   string hello = \"Hello, \";  \n   string world = \"world!\";  \n   cout << Plus(hello, world) << endl;  \n  \n   // Custom type  \n   X x1(20);  \n   X x2(22);  \n   X x3 = Plus(x1, x2);  \n   cout <<   \n      \"x3.Dump() = \" <<   \n      x3.Dump() << endl;  \n}  \n```  \n  \n **Output**  \n  \n This code example yields the following results.  \n  \n 13  \n  \n 13.5  \n  \n Hello, world!  \n  \n 42  \n  \n## Requirements  \n Visual C++ 2010 or later versions.  \n  \n decltype(auto) requires Visual Studio 2015 or later  \n  \n"}