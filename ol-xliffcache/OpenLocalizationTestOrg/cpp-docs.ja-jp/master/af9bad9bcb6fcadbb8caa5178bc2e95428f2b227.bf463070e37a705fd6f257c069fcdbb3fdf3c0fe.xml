{"nodes":[{"pos":[12,66],"content":"Explicit Type Conversion Operator: () | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Explicit Type Conversion Operator: () | Microsoft Docs","pos":[0,54]}]},{"content":"Explicit Type Conversion Operator: ()","pos":[799,836]},{"content":"C++ allows explicit type conversion using syntax similar to the function-call syntax.","pos":[837,922]},{"content":"Syntax","pos":[931,937]},{"content":"Remarks","pos":[1000,1007]},{"content":"A <bpt id=\"p1\">*</bpt>simple-type-name<ept id=\"p1\">*</ept> followed by an <bpt id=\"p2\">*</bpt>expression-list<ept id=\"p2\">*</ept> enclosed in parentheses constructs an object of the specified type using the specified expressions.","pos":[1011,1164],"source":"A *simple-type-name* followed by an *expression-list* enclosed in parentheses constructs an object of the specified type using the specified expressions."},{"content":"The following example shows an explicit type conversion to type int:","pos":[1165,1233]},{"pos":[1275,1319],"content":"The following example shows a <ph id=\"ph1\">`Point`</ph> class.","source":"The following example shows a `Point` class."},{"content":"Example","pos":[1328,1335]},{"content":"Output","pos":[2376,2382]},{"content":"Although the preceding example demonstrates explicit type conversion using constants, the same technique works to perform these conversions on objects.","pos":[2436,2587]},{"content":"The following code fragment demonstrates this:","pos":[2588,2634]},{"content":"Explicit type conversions can also be specified using the \"cast\" syntax.","pos":[2701,2773]},{"content":"The previous example, rewritten using the cast syntax, is:","pos":[2774,2832]},{"content":"Both cast and function-style conversions have the same results when converting from single values.","pos":[2870,2968]},{"content":"However, in the function-style syntax, you can specify more than one argument for conversion.","pos":[2969,3062]},{"content":"This difference is important for user-defined types.","pos":[3063,3115]},{"content":"Consider a <ph id=\"ph1\">`Point`</ph> class and its conversions:","pos":[3116,3161],"source":" Consider a `Point` class and its conversions:"},{"pos":[3324,3480],"content":"The preceding example, which uses function-style conversion, shows how to convert two values (one for <bpt id=\"p1\">*</bpt>x<ept id=\"p1\">*</ept> and one for <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept>) to the user-defined type <ph id=\"ph1\">`Point`</ph>.","source":"The preceding example, which uses function-style conversion, shows how to convert two values (one for *x* and one for *y*) to the user-defined type `Point`."},{"pos":[3488,3609],"content":"[!CAUTION]\n Use the explicit type conversions with care, since they override the C++ compiler's built-in type checking.","leadings":["","> "],"nodes":[{"content":"Use the explicit type conversions with care, since they override the C++ compiler's built-in type checking.","pos":[12,119]}]},{"content":"The <bpt id=\"p1\">[</bpt>cast<ept id=\"p1\">](../cpp/cast-operator-parens.md)</ept> notation must be used for conversions to types that do not have a <bpt id=\"p2\">*</bpt>simple-type-name<ept id=\"p2\">*</ept> (pointer or reference types, for example).","pos":[3616,3786],"source":"The [cast](../cpp/cast-operator-parens.md) notation must be used for conversions to types that do not have a *simple-type-name* (pointer or reference types, for example)."},{"content":"Conversion to types that can be expressed with a <bpt id=\"p1\">*</bpt>simple-type-name<ept id=\"p1\">*</ept> can be written in either form.","pos":[3787,3885],"source":" Conversion to types that can be expressed with a *simple-type-name* can be written in either form."},{"content":"See <bpt id=\"p1\">[</bpt>Type Specifiers<ept id=\"p1\">](http://msdn.microsoft.com/en-us/34b6c737-0ef1-4470-9b77-b26e46c0bbd4)</ept> for more information about what constitutes a <bpt id=\"p2\">*</bpt>simple-type-name<ept id=\"p2\">*</ept>.","pos":[3886,4043],"source":" See [Type Specifiers](http://msdn.microsoft.com/en-us/34b6c737-0ef1-4470-9b77-b26e46c0bbd4) for more information about what constitutes a *simple-type-name*."},{"content":"Type definition within casts is illegal.","pos":[4050,4090]},{"content":"See Also","pos":[4099,4107]},{"content":"Postfix Expressions","pos":[4112,4131]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[4169,4221]}],"content":"---\ntitle: \"Explicit Type Conversion Operator: () | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"explicit data type conversion operator\"\n  - \"conversions [C++], explicit\"\n  - \"operators [C++], explicit type conversion\"\n  - \"data type conversion [C++], explicit\"\n  - \"type conversion [C++], explicit conversions\"\nms.assetid: 54272006-5ffb-45ed-8283-27152ab97529\ncaps.latest.revision: 6\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Explicit Type Conversion Operator: ()\nC++ allows explicit type conversion using syntax similar to the function-call syntax.  \n  \n## Syntax  \n  \n```  \nsimple-type-name ( expression-list )  \n```  \n  \n## Remarks  \n A *simple-type-name* followed by an *expression-list* enclosed in parentheses constructs an object of the specified type using the specified expressions. The following example shows an explicit type conversion to type int:  \n  \n```  \nint i = int( d );  \n```  \n  \n The following example shows a `Point` class.  \n  \n## Example  \n  \n```  \n// expre_Explicit_Type_Conversion_Operator.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n  \nusing namespace std;  \nclass Point  \n{  \npublic:  \n    // Define default constructor.  \n    Point() { _x = _y = 0; }  \n    // Define another constructor.  \n    Point( int X, int Y ) { _x = X; _y = Y; }  \n  \n    // Define \"accessor\" functions as  \n    // reference types.  \n    unsigned& x() { return _x; }  \n    unsigned& y() { return _y; }  \n    void Show()   { cout << \"x = \" << _x << \", \"  \n                         << \"y = \" << _y << \"\\n\"; }  \nprivate:  \n    unsigned _x;  \n    unsigned _y;  \n};  \n  \nint main()  \n{  \n    Point Point1, Point2;  \n  \n    // Assign Point1 the explicit conversion  \n    //  of ( 10, 10 ).  \n    Point1 = Point( 10, 10 );  \n  \n    // Use x() as an l-value by assigning an explicit  \n    //  conversion of 20 to type unsigned.  \n    Point1.x() = unsigned( 20 );  \n    Point1.Show();  \n  \n    // Assign Point2 the default Point object.  \n    Point2 = Point();  \n    Point2.Show();  \n}  \n```  \n  \n## Output  \n  \n```  \nx = 20, y = 10  \nx = 0, y = 0  \n```  \n  \n Although the preceding example demonstrates explicit type conversion using constants, the same technique works to perform these conversions on objects. The following code fragment demonstrates this:  \n  \n```  \nint i = 7;  \nfloat d;  \n  \nd = float( i );  \n```  \n  \n Explicit type conversions can also be specified using the \"cast\" syntax. The previous example, rewritten using the cast syntax, is:  \n  \n```  \nd = (float)i;  \n```  \n  \n Both cast and function-style conversions have the same results when converting from single values. However, in the function-style syntax, you can specify more than one argument for conversion. This difference is important for user-defined types. Consider a `Point` class and its conversions:  \n  \n```  \nstruct Point  \n{  \n    Point( short x, short y ) { _x = x; _y = y; }  \n    ...  \n    short _x, _y;  \n};  \n...  \nPoint pt = Point( 3, 10 );  \n```  \n  \n The preceding example, which uses function-style conversion, shows how to convert two values (one for *x* and one for *y*) to the user-defined type `Point`.  \n  \n> [!CAUTION]\n>  Use the explicit type conversions with care, since they override the C++ compiler's built-in type checking.  \n  \n The [cast](../cpp/cast-operator-parens.md) notation must be used for conversions to types that do not have a *simple-type-name* (pointer or reference types, for example). Conversion to types that can be expressed with a *simple-type-name* can be written in either form. See [Type Specifiers](http://msdn.microsoft.com/en-us/34b6c737-0ef1-4470-9b77-b26e46c0bbd4) for more information about what constitutes a *simple-type-name*.  \n  \n Type definition within casts is illegal.  \n  \n## See Also  \n [Postfix Expressions](../cpp/postfix-expressions.md)   \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)"}