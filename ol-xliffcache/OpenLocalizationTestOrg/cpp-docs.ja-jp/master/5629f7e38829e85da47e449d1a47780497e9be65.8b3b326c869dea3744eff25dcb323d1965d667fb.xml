{"nodes":[{"pos":[12,55],"content":"regex_token_iterator Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"regex_token_iterator Class | Microsoft Docs","pos":[0,43]}]},{"pos":[710,736],"content":"regex_token_iterator Class","linkify":"regex_token_iterator Class","nodes":[{"content":"regex_token_iterator Class","pos":[0,26]}]},{"content":"Iterator class for submatches.","pos":[737,767]},{"pos":[776,782],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[2183,2193],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type for submatches.","pos":[2208,2241]},{"content":"The type of elements to match.","pos":[2258,2288]},{"content":"Traits class for elements.","pos":[2309,2335]},{"pos":[2344,2351],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template class describes a constant forward iterator object.","pos":[2355,2419]},{"content":"Conceptually, it holds a <ph id=\"ph1\">`regex_iterator`</ph> object that it uses to search for regular expression matches in a character sequence.","pos":[2420,2547],"source":" Conceptually, it holds a `regex_iterator` object that it uses to search for regular expression matches in a character sequence."},{"content":"It extracts objects of type <ph id=\"ph1\">`sub_match&lt;BidIt&gt;`</ph> representing the submatches identified by the index values in the stored vector <ph id=\"ph2\">`subs`</ph> for each regular expression match.","pos":[2548,2716],"source":" It extracts objects of type `sub_match<BidIt>` representing the submatches identified by the index values in the stored vector `subs` for each regular expression match."},{"content":"An index value of -1 designates the character sequence beginning immediately after the end of the previous regular expression match, or beginning at the start of the character sequence if there was no previous regular expression match, and extending to but not including the first character of the current regular expression match, or to the end of the character sequence if there is no current match.","pos":[2723,3124]},{"content":"Any other index value <ph id=\"ph1\">`idx`</ph> designates the contents of the capture group held in <ph id=\"ph2\">`it.match[idx]`</ph>.","pos":[3125,3222],"source":" Any other index value `idx` designates the contents of the capture group held in `it.match[idx]`."},{"pos":[3231,3243],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[3247,3267],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>regex&gt;","source":"**Header:** \\<regex>"},{"pos":[3274,3292],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[3302,3393],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__difference_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::difference_type","linkify":"<a name=\"regex_token_iterator__difference_type\"></a>  regex_token_iterator::difference_type","source":"<a name=\"regex_token_iterator__difference_type\"></a>  regex_token_iterator::difference_type"},{"content":"The type of an iterator difference.","pos":[3397,3432]},{"pos":[3499,3506],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[3510,3553],"content":"The type is a synonym for <ph id=\"ph1\">`std::ptrdiff_t`</ph>.","source":"The type is a synonym for `std::ptrdiff_t`."},{"pos":[3563,3570],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[5808,5903],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__iterator_category\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::iterator_category","linkify":"<a name=\"regex_token_iterator__iterator_category\"></a>  regex_token_iterator::iterator_category","source":"<a name=\"regex_token_iterator__iterator_category\"></a>  regex_token_iterator::iterator_category"},{"content":"The type of the iterator category.","pos":[5907,5941]},{"pos":[6021,6028],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6032,6086],"content":"The type is a synonym for <ph id=\"ph1\">`std::forward_iterator_tag`</ph>.","source":"The type is a synonym for `std::forward_iterator_tag`."},{"pos":[6096,6103],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[8429,8512],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__operator_neq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::operator!=","linkify":"<a name=\"regex_token_iterator__operator_neq\"></a>  regex_token_iterator::operator!=","source":"<a name=\"regex_token_iterator__operator_neq\"></a>  regex_token_iterator::operator!="},{"content":"Compares iterators for inequality.","pos":[8516,8550]},{"pos":[8627,8637],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator to compare to.","pos":[8652,8679]},{"pos":[8689,8696],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[8700,8748],"content":"The member function returns <ph id=\"ph1\">`!(*this == right)`</ph>.","source":"The member function returns `!(*this == right)`."},{"pos":[8758,8765],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[11085,11168],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__operator_star\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::operator*","linkify":"<a name=\"regex_token_iterator__operator_star\"></a>  regex_token_iterator::operator*","source":"<a name=\"regex_token_iterator__operator_star\"></a>  regex_token_iterator::operator*"},{"content":"Accesses the designated submatch.","pos":[11172,11205]},{"pos":[11267,11274],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[11278,11407],"content":"The member function returns a <ph id=\"ph1\">`sub_match&lt;BidIt&gt;`</ph> object representing the capture group identified by the index value <ph id=\"ph2\">`subs[pos]`</ph>.","source":"The member function returns a `sub_match<BidIt>` object representing the capture group identified by the index value `subs[pos]`."},{"pos":[11417,11424],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[13746,13833],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__operator_add_add\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::operator++","linkify":"<a name=\"regex_token_iterator__operator_add_add\"></a>  regex_token_iterator::operator++","source":"<a name=\"regex_token_iterator__operator_add_add\"></a>  regex_token_iterator::operator++"},{"content":"Increments the iterator.","pos":[13837,13861]},{"pos":[13962,13969],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"If the stored iterator <ph id=\"ph1\">`it`</ph> is an end-of-sequence iterator the first operator sets the stored value <ph id=\"ph2\">`pos`</ph> to the value of <ph id=\"ph3\">`subs.size()`</ph> (thus making an end-of-sequence iterator).","pos":[13973,14151],"source":"If the stored iterator `it` is an end-of-sequence iterator the first operator sets the stored value `pos` to the value of `subs.size()` (thus making an end-of-sequence iterator)."},{"content":"Otherwise the operator increments the stored value <ph id=\"ph1\">`pos`</ph>; if the result is equal to the value <ph id=\"ph2\">`subs.size()`</ph> it sets the stored value <ph id=\"ph3\">`pos`</ph> to zero and increments the stored iterator <ph id=\"ph4\">`it`</ph>.","pos":[14152,14339],"source":" Otherwise the operator increments the stored value `pos`; if the result is equal to the value `subs.size()` it sets the stored value `pos` to zero and increments the stored iterator `it`."},{"content":"If incrementing the stored iterator leaves it unequal to an end-of-sequence iterator the operator does nothing further.","pos":[14340,14459]},{"content":"Otherwise, if the end of the preceding match was at the end of the character sequence the operator sets the stored value of <ph id=\"ph1\">`pos`</ph> to <ph id=\"ph2\">`subs.size()`</ph>.","pos":[14460,14607],"source":" Otherwise, if the end of the preceding match was at the end of the character sequence the operator sets the stored value of `pos` to `subs.size()`."},{"content":"Otherwise, the operator repeatedly increments the stored value <ph id=\"ph1\">`pos`</ph> until <ph id=\"ph2\">`pos == subs.size()`</ph> or <ph id=\"ph3\">`subs[pos] == -1`</ph> (thus ensuring that the next dereference of the iterator will return the tail of the character sequence if one of the index values is -1).","pos":[14608,14863],"source":" Otherwise, the operator repeatedly increments the stored value `pos` until `pos == subs.size()` or `subs[pos] == -1` (thus ensuring that the next dereference of the iterator will return the tail of the character sequence if one of the index values is -1)."},{"content":"In all cases the operator returns the object.","pos":[14864,14909]},{"content":"The second operator makes a copy of the object, increments the object, then returns the copy.","pos":[14916,15009]},{"pos":[15019,15026],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[17347,17432],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__operator_eq_eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::operator==","linkify":"<a name=\"regex_token_iterator__operator_eq_eq\"></a>  regex_token_iterator::operator==","source":"<a name=\"regex_token_iterator__operator_eq_eq\"></a>  regex_token_iterator::operator=="},{"content":"Compares iterators for equality.","pos":[17436,17468]},{"pos":[17545,17555],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"right","pos":[17559,17564]},{"content":"The iterator to compare to.","pos":[17568,17595]},{"pos":[17605,17612],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[17616,17703],"content":"The member function returns <ph id=\"ph1\">`it == right.it &amp;&amp; subs == right.subs &amp;&amp; pos == right.pos`</ph>.","source":"The member function returns `it == right.it && subs == right.subs && pos == right.pos`."},{"pos":[17713,17720],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[20040,20127],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__operator-_gt_\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::operator-<ph id=\"ph1\">&amp;gt;</ph>","linkify":"<a name=\"regex_token_iterator__operator-_gt_\"></a>  regex_token_iterator::operator-&gt;","source":"<a name=\"regex_token_iterator__operator-_gt_\"></a>  regex_token_iterator::operator-&gt;"},{"content":"Accesses the designated submatch.","pos":[20131,20164]},{"pos":[20228,20235],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[20239,20381],"content":"The member function returns a pointer to a <ph id=\"ph1\">`sub_match&lt;BidIt&gt;`</ph> object representing the capture group identified by the index value <ph id=\"ph2\">`subs[pos]`</ph>.","source":"The member function returns a pointer to a `sub_match<BidIt>` object representing the capture group identified by the index value `subs[pos]`."},{"pos":[20391,20398],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[22721,22796],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__pointer\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::pointer","linkify":"<a name=\"regex_token_iterator__pointer\"></a>  regex_token_iterator::pointer","source":"<a name=\"regex_token_iterator__pointer\"></a>  regex_token_iterator::pointer"},{"content":"The type of a pointer to a match.","pos":[22800,22833]},{"pos":[22895,22902],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[25218,25225],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[25229,25316],"content":"The type is a synonym for <ph id=\"ph1\">`sub_match&lt;BidIt&gt;*`</ph>, where <ph id=\"ph2\">`BidIt`</ph> is the template parameter.","source":"The type is a synonym for `sub_match<BidIt>*`, where `BidIt` is the template parameter."},{"pos":[25326,25405],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__reference\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::reference","linkify":"<a name=\"regex_token_iterator__reference\"></a>  regex_token_iterator::reference","source":"<a name=\"regex_token_iterator__reference\"></a>  regex_token_iterator::reference"},{"content":"The type of a reference to a submatch.","pos":[25409,25447]},{"pos":[25511,25518],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[25522,25609],"content":"The type is a synonym for <ph id=\"ph1\">`sub_match&lt;BidIt&gt;&amp;`</ph>, where <ph id=\"ph2\">`BidIt`</ph> is the template parameter.","source":"The type is a synonym for `sub_match<BidIt>&`, where `BidIt` is the template parameter."},{"pos":[25619,25626],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[27944,28045],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__regex_token_iterator\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::regex_token_iterator","linkify":"<a name=\"regex_token_iterator__regex_token_iterator\"></a>  regex_token_iterator::regex_token_iterator","source":"<a name=\"regex_token_iterator__regex_token_iterator\"></a>  regex_token_iterator::regex_token_iterator"},{"content":"Constructs the iterator.","pos":[28049,28073]},{"pos":[28678,28688],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Beginning of sequence to match.","pos":[28703,28734]},{"content":"End of sequence to match.","pos":[28751,28776]},{"content":"Regular expression for matches.","pos":[28791,28822]},{"content":"Flags for matches.","pos":[28836,28854]},{"pos":[28864,28871],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first constructor constructs an end-of-sequence iterator.","pos":[28875,28936]},{"content":"The second constructor constructs an object whose stored iterator <ph id=\"ph1\">`it`</ph> is initialized to <ph id=\"ph2\">`regex_iterator&lt;BidIt, Elem, RXtraits&gt;(first, last, re, f)`</ph>, whose stored vector <ph id=\"ph3\">`subs`</ph> holds exactly one integer, with value <ph id=\"ph4\">`submatch`</ph>, and whose stored value <ph id=\"ph5\">`pos`</ph> is zero.","pos":[28943,29207],"source":"The second constructor constructs an object whose stored iterator `it` is initialized to `regex_iterator<BidIt, Elem, RXtraits>(first, last, re, f)`, whose stored vector `subs` holds exactly one integer, with value `submatch`, and whose stored value `pos` is zero."},{"content":"Note: the resulting object extracts the submatch identified by the index value <ph id=\"ph1\">`submatch`</ph> for each successful regular expression match.","pos":[29208,29343],"source":" Note: the resulting object extracts the submatch identified by the index value `submatch` for each successful regular expression match."},{"pos":[29350,29618],"content":"The third constructor constructs an object whose stored iterator <ph id=\"ph1\">`it`</ph> is initialized to <ph id=\"ph2\">`regex_iterator&lt;BidIt, Elem, RXtraits&gt;(first, last, re, f)`</ph>, whose stored vector <ph id=\"ph3\">`subs`</ph> holds a copy of the constructor argument <ph id=\"ph4\">`submatches`</ph>, and whose stored value <ph id=\"ph5\">`pos`</ph> is zero.","source":"The third constructor constructs an object whose stored iterator `it` is initialized to `regex_iterator<BidIt, Elem, RXtraits>(first, last, re, f)`, whose stored vector `subs` holds a copy of the constructor argument `submatches`, and whose stored value `pos` is zero."},{"pos":[29625,29913],"content":"The fourth constructor constructs an object whose stored iterator <ph id=\"ph1\">`it`</ph> is initialized to <ph id=\"ph2\">`regex_iterator&lt;BidIt, Elem, RXtraits&gt;(first, last, re, f)`</ph>, whose stored vector <ph id=\"ph3\">`subs`</ph> holds the <ph id=\"ph4\">`N`</ph> values pointed to by the constructor argument <ph id=\"ph5\">`submatches`</ph>, and whose stored value <ph id=\"ph6\">`pos`</ph> is zero.","source":"The fourth constructor constructs an object whose stored iterator `it` is initialized to `regex_iterator<BidIt, Elem, RXtraits>(first, last, re, f)`, whose stored vector `subs` holds the `N` values pointed to by the constructor argument `submatches`, and whose stored value `pos` is zero."},{"pos":[29923,29930],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[32248,32329],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__regex_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::regex_type","linkify":"<a name=\"regex_token_iterator__regex_type\"></a>  regex_token_iterator::regex_type","source":"<a name=\"regex_token_iterator__regex_type\"></a>  regex_token_iterator::regex_type"},{"content":"The type of the regular expression to match.","pos":[32333,32377]},{"pos":[32452,32459],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[32463,32522],"content":"The typedef is a synonym for <ph id=\"ph1\">`basic_regex&lt;Elem, RXtraits&gt;`</ph>.","source":"The typedef is a synonym for `basic_regex<Elem, RXtraits>`."},{"pos":[32532,32539],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[34858,34939],"content":"<bpt id=\"p1\">&lt;a name=\"regex_token_iterator__value_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_token_iterator::value_type","linkify":"<a name=\"regex_token_iterator__value_type\"></a>  regex_token_iterator::value_type","source":"<a name=\"regex_token_iterator__value_type\"></a>  regex_token_iterator::value_type"},{"content":"The type of a submatch.","pos":[34943,34966]},{"pos":[35030,35037],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[35041,35127],"content":"The type is a synonym for <ph id=\"ph1\">`sub_match&lt;BidIt&gt;`</ph>, where <ph id=\"ph2\">`BidIt`</ph> is the template parameter.","source":"The type is a synonym for `sub_match<BidIt>`, where `BidIt` is the template parameter."},{"pos":[35137,35144],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[37462,37470],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>regex&gt;<ept id=\"p1\">](../standard-library/regex.md)</ept><ph id=\"ph2\"> </ph>","pos":[37474,37515],"source":"[\\<regex>](../standard-library/regex.md) "},{"content":"<bpt id=\"p1\"> [</bpt>regex_token_iterator<ept id=\"p1\">](../standard-library/regex-token-iterator-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[37518,37593],"source":" [regex_token_iterator](../standard-library/regex-token-iterator-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>regex_iterator Class<ept id=\"p1\">](../standard-library/regex-iterator-class.md)</ept>","pos":[37596,37664],"source":" [regex_iterator Class](../standard-library/regex-iterator-class.md)"}],"content":"---\ntitle: \"regex_token_iterator Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"regex_token_iterator\"\n  - \"std.tr1.regex_token_iterator\"\n  - \"std::tr1::regex_token_iterator\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"regex_token_iterator class [TR1]\"\nms.assetid: a213ba48-8e4e-4b6b-871a-2637acf05f15\ncaps.latest.revision: 15\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# regex_token_iterator Class\nIterator class for submatches.  \n  \n## Syntax  \n```  \nclass regex_token_iterator {  \n   public:  \n   typedef basic_regex<Elem, RXtraits>  \n   regex_type;  \n   typedef sub_match<BidIt> value_type;  \n   typedef std::forward_iterator_tag iterator_category;  \n   typedef std::ptrdiff_t difference_type;  \n   typedef const sub_match<BidIt> *pointer;  \n   typedef const sub_match<BidIt>& reference;  \n   regex_token_iterator();\n   regex_token_iterator(BidIt first, BidIt last,  \n   const regex_type& re, int submatch = 0,  \n   regex_constants::match_flag_type f = regex_constants::match_default);\n   regex_token_iterator(BidIt first, BidIt last,  \n   const regex_type& re, const std::vector<int> submatches,  \n   regex_constants::match_flag_type f = regex_constants::match_default);\n   template <std::size_t N>  \n   regex_token_iterator(BidIt first, BidIt last,  \n   const regex_type& re, const int (&submatches)[N],  \n   regex_constants::match_flag_type f = regex_constants::match_default);\n   bool operator==(const regex_token_iterator& right);\n   bool operator!=(const regex_token_iterator& right);\n   const basic_string<Elem>& operator*();\n   const basic_string<Elem> * operator->();\n   regex_token_iterator& operator++();\n   regex_token_iterator& operator++(int);\n   private:  \n   regex_iterator<BidIt, Elem, RXtraits>  \n   it; // exposition only  \n   vector<int> subs;\n   // exposition only  \n   int pos;  // exposition only  \n   };  \n```  \n#### Parameters  \n `BidIt`  \n The iterator type for submatches.  \n  \n `Elem`  \n The type of elements to match.  \n  \n `RXtraits`  \n Traits class for elements.  \n  \n## Remarks  \n The template class describes a constant forward iterator object. Conceptually, it holds a `regex_iterator` object that it uses to search for regular expression matches in a character sequence. It extracts objects of type `sub_match<BidIt>` representing the submatches identified by the index values in the stored vector `subs` for each regular expression match.  \n  \n An index value of -1 designates the character sequence beginning immediately after the end of the previous regular expression match, or beginning at the start of the character sequence if there was no previous regular expression match, and extending to but not including the first character of the current regular expression match, or to the end of the character sequence if there is no current match. Any other index value `idx` designates the contents of the capture group held in `it.match[idx]`.  \n  \n## Requirements  \n **Header:** \\<regex>  \n  \n **Namespace:** std  \n  \n##  <a name=\"regex_token_iterator__difference_type\"></a>  regex_token_iterator::difference_type  \n The type of an iterator difference.  \n  \n```  \ntypedef std::ptrdiff_t difference_type;  \n```  \n  \n### Remarks  \n The type is a synonym for `std::ptrdiff_t`.  \n  \n### Example  \n  \n```cpp  \n  \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n##  <a name=\"regex_token_iterator__iterator_category\"></a>  regex_token_iterator::iterator_category  \n The type of the iterator category.  \n  \n```  \ntypedef std::forward_iterator_tag iterator_category;  \n```  \n  \n### Remarks  \n The type is a synonym for `std::forward_iterator_tag`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_token_iterator_iterator_category.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n##  <a name=\"regex_token_iterator__operator_neq\"></a>  regex_token_iterator::operator!=  \n Compares iterators for inequality.  \n  \n```  \nbool operator!=(const regex_token_iterator& right);\n```  \n  \n### Parameters  \n `right`  \n The iterator to compare to.  \n  \n### Remarks  \n The member function returns `!(*this == right)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_token_iterator_operator_ne.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n##  <a name=\"regex_token_iterator__operator_star\"></a>  regex_token_iterator::operator*  \n Accesses the designated submatch.  \n  \n```  \nconst sub_match<BidIt>& operator*();\n```  \n  \n### Remarks  \n The member function returns a `sub_match<BidIt>` object representing the capture group identified by the index value `subs[pos]`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_token_iterator_operator_star.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n##  <a name=\"regex_token_iterator__operator_add_add\"></a>  regex_token_iterator::operator++  \n Increments the iterator.  \n  \n```  \nregex_token_iterator& operator++();\n\nregex_token_iterator& operator++(int);\n```  \n  \n### Remarks  \n If the stored iterator `it` is an end-of-sequence iterator the first operator sets the stored value `pos` to the value of `subs.size()` (thus making an end-of-sequence iterator). Otherwise the operator increments the stored value `pos`; if the result is equal to the value `subs.size()` it sets the stored value `pos` to zero and increments the stored iterator `it`. If incrementing the stored iterator leaves it unequal to an end-of-sequence iterator the operator does nothing further. Otherwise, if the end of the preceding match was at the end of the character sequence the operator sets the stored value of `pos` to `subs.size()`. Otherwise, the operator repeatedly increments the stored value `pos` until `pos == subs.size()` or `subs[pos] == -1` (thus ensuring that the next dereference of the iterator will return the tail of the character sequence if one of the index values is -1). In all cases the operator returns the object.  \n  \n The second operator makes a copy of the object, increments the object, then returns the copy.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_token_iterator_operator_inc.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n##  <a name=\"regex_token_iterator__operator_eq_eq\"></a>  regex_token_iterator::operator==  \n Compares iterators for equality.  \n  \n```  \nbool operator==(const regex_token_iterator& right);\n```  \n  \n### Parameters  \n right  \n The iterator to compare to.  \n  \n### Remarks  \n The member function returns `it == right.it && subs == right.subs && pos == right.pos`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_token_iterator_operator_eq.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n##  <a name=\"regex_token_iterator__operator-_gt_\"></a>  regex_token_iterator::operator-&gt;  \n Accesses the designated submatch.  \n  \n```  \nconst sub_match<BidIt> * operator->();\n```  \n  \n### Remarks  \n The member function returns a pointer to a `sub_match<BidIt>` object representing the capture group identified by the index value `subs[pos]`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_token_iterator_operator_arrow.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n##  <a name=\"regex_token_iterator__pointer\"></a>  regex_token_iterator::pointer  \n The type of a pointer to a match.  \n  \n```  \ntypedef sub_match<BidIt> *pointer;  \n```  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_token_iterator_pointer.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n### Remarks  \n The type is a synonym for `sub_match<BidIt>*`, where `BidIt` is the template parameter.  \n  \n##  <a name=\"regex_token_iterator__reference\"></a>  regex_token_iterator::reference  \n The type of a reference to a submatch.  \n  \n```  \ntypedef sub_match<BidIt>& reference;  \n```  \n  \n### Remarks  \n The type is a synonym for `sub_match<BidIt>&`, where `BidIt` is the template parameter.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_token_iterator_reference.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n##  <a name=\"regex_token_iterator__regex_token_iterator\"></a>  regex_token_iterator::regex_token_iterator  \n Constructs the iterator.  \n  \n```  \nregex_token_iterator();\n\nregex_token_iterator(BidIt first, BidIt last,  \n    const regex_type& re, int submatch = 0,  \n    regex_constants::match_flag_type f = regex_constants::match_default);\n\nregex_token_iterator(BidIt first, BidIt last,  \n    const regex_type& re, const vector<int> submatches,  \n    regex_constants::match_flag_type f = regex_constants::match_default);\n\ntemplate <std::size_t N>  \nregex_token_iterator(BidIt first, BidIt last,  \n    const regex_type& re, const int (&submatches)[N],  \n    regex_constants::match_flag_type f = regex_constants::match_default);\n```  \n  \n### Parameters  \n `first`  \n Beginning of sequence to match.  \n  \n `last`  \n End of sequence to match.  \n  \n `re`  \n Regular expression for matches.  \n  \n `f`  \n Flags for matches.  \n  \n### Remarks  \n The first constructor constructs an end-of-sequence iterator.  \n  \n The second constructor constructs an object whose stored iterator `it` is initialized to `regex_iterator<BidIt, Elem, RXtraits>(first, last, re, f)`, whose stored vector `subs` holds exactly one integer, with value `submatch`, and whose stored value `pos` is zero. Note: the resulting object extracts the submatch identified by the index value `submatch` for each successful regular expression match.  \n  \n The third constructor constructs an object whose stored iterator `it` is initialized to `regex_iterator<BidIt, Elem, RXtraits>(first, last, re, f)`, whose stored vector `subs` holds a copy of the constructor argument `submatches`, and whose stored value `pos` is zero.  \n  \n The fourth constructor constructs an object whose stored iterator `it` is initialized to `regex_iterator<BidIt, Elem, RXtraits>(first, last, re, f)`, whose stored vector `subs` holds the `N` values pointed to by the constructor argument `submatches`, and whose stored value `pos` is zero.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_token_iterator_construct.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n##  <a name=\"regex_token_iterator__regex_type\"></a>  regex_token_iterator::regex_type  \n The type of the regular expression to match.  \n  \n```  \ntypedef basic_regex<Elem, RXtraits> regex_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for `basic_regex<Elem, RXtraits>`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_token_iterator_regex_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n##  <a name=\"regex_token_iterator__value_type\"></a>  regex_token_iterator::value_type  \n The type of a submatch.  \n  \n```  \ntypedef sub_match<BidIt> value_type;  \n```  \n  \n### Remarks  \n The type is a synonym for `sub_match<BidIt>`, where `BidIt` is the template parameter.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_token_iterator_value_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \ntypedef std::regex_token_iterator<const char *> Myiter;   \nint main()   \n    {   \n    const char *pat = \"aaxaayaaz\";   \n    Myiter::regex_type rx(\"(a)a\");   \n    Myiter next(pat, pat + strlen(pat), rx);   \n    Myiter end;   \n  \n// show whole match   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefix before match   \n    next = Myiter(pat, pat + strlen(pat), rx, -1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show (a) submatch only   \n    next = Myiter(pat, pat + strlen(pat), rx, 1);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and submatches   \n    std::vector<int> vec;   \n    vec.push_back(-1);   \n    vec.push_back(1);   \n    next = Myiter(pat, pat + strlen(pat), rx, vec);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// show prefixes and whole matches   \n    int arr[] = {-1, 0};   \n    next = Myiter(pat, pat + strlen(pat), rx, arr);   \n    for (; next != end; ++next)   \n        std::cout << \"match == \" << next->str() << std::endl;   \n    std::cout << std::endl;   \n  \n// other members   \n    Myiter it1(pat, pat + strlen(pat), rx);   \n    Myiter it2(it1);   \n    next = it1;   \n  \n    Myiter::iterator_category cat = std::forward_iterator_tag();   \n    Myiter::difference_type dif = -3;   \n    Myiter::value_type mr = *it1;   \n    Myiter::reference ref = mr;   \n    Myiter::pointer ptr = &ref;   \n  \n    dif = dif; // to quiet \"unused\" warnings   \n    ptr = ptr;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatch == aa  \nmatch == aa  \nmatch == aa  \n  \nmatch ==   \nmatch == x  \nmatch == y  \nmatch == z  \n  \nmatch == a  \nmatch == a  \nmatch == a  \n  \nmatch ==   \nmatch == a  \nmatch == x  \nmatch == a  \nmatch == y  \nmatch == a  \nmatch == z  \n  \nmatch ==   \nmatch == aa  \nmatch == x  \nmatch == aa  \nmatch == y  \nmatch == aa  \nmatch == z  \n  \n```  \n  \n## See Also  \n [\\<regex>](../standard-library/regex.md)   \n [regex_token_iterator](../standard-library/regex-token-iterator-class.md)   \n [regex_iterator Class](../standard-library/regex-iterator-class.md)\n\n"}