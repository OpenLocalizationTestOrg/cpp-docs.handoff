{"nodes":[{"pos":[12,60],"content":"&lt;unordered_map&gt; operators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>unordered_map<ph id=\"ph2\">&amp;gt;</ph> operators | Microsoft Docs","pos":[0,48],"source":"&lt;unordered_map&gt; operators | Microsoft Docs"}]},{"pos":[262,293],"content":"&lt;unordered_map&gt; operators","linkify":"&lt;unordered_map&gt; operators","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>unordered_map<ph id=\"ph2\">&amp;gt;</ph> operators","pos":[0,31],"source":"&lt;unordered_map&gt; operators"}]},{"pos":[315,342],"content":"<bpt id=\"p1\">[</bpt>operator!=<ept id=\"p1\">](#operator_neq)</ept>","source":"[operator!=](#operator_neq)"},{"pos":[343,372],"content":"<bpt id=\"p1\">[</bpt>operator==<ept id=\"p1\">](#operator_eq_eq)</ept>","source":"[operator==](#operator_eq_eq)"},{"pos":[373,409],"content":"<bpt id=\"p1\">[</bpt>operator!=<ept id=\"p1\">](#operator_neq_multimap)</ept>","source":"[operator!=](#operator_neq_multimap)"},{"pos":[410,448],"content":"<bpt id=\"p1\">[</bpt>operator==<ept id=\"p1\">](#operator_eq_eq_multimap)</ept>","source":"[operator==](#operator_eq_eq_multimap)"},{"pos":[459,498],"content":"<bpt id=\"p1\">&lt;a name=\"operator_neq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator!=","linkify":"<a name=\"operator_neq\"></a>  operator!=","source":"<a name=\"operator_neq\"></a>  operator!="},{"pos":[502,679],"content":"Tests whether the <bpt id=\"p1\">[</bpt>unordered_map<ept id=\"p1\">](../standard-library/unordered-map-class.md)</ept> object on the left side of the operator is not equal to the unordered_map object on the right side.","source":"Tests whether the [unordered_map](../standard-library/unordered-map-class.md) object on the left side of the operator is not equal to the unordered_map object on the right side."},{"pos":[844,854],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An object of type <ph id=\"ph1\">`unordered_map`</ph>.","pos":[868,902],"source":" An object of type `unordered_map`."},{"content":"An object of type <ph id=\"ph1\">`unordered_map`</ph>.","pos":[920,954],"source":" An object of type `unordered_map`."},{"pos":[964,976],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[980,1050],"content":"<ph id=\"ph1\">`true`</ph> if the unordered_maps are not equal; <ph id=\"ph2\">`false`</ph> if they are equal.","source":"`true` if the unordered_maps are not equal; `false` if they are equal."},{"pos":[1060,1067],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The comparison between unordered_map objects is not affected by the arbitrary order in which they store their elements.","pos":[1071,1190]},{"content":"Two unordered_maps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container.","pos":[1191,1352]},{"content":"Otherwise, they are unequal.","pos":[1353,1381]},{"pos":[1391,1398],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[2166,2177],"content":"<bpt id=\"p1\">**</bpt>Output:<ept id=\"p1\">**</ept>","source":"**Output:**"},{"pos":[2263,2304],"content":"<bpt id=\"p1\">&lt;a name=\"operator_eq_eq\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator==","linkify":"<a name=\"operator_eq_eq\"></a>  operator==","source":"<a name=\"operator_eq_eq\"></a>  operator=="},{"pos":[2308,2481],"content":"Tests whether the <bpt id=\"p1\">[</bpt>unordered_map<ept id=\"p1\">](../standard-library/unordered-map-class.md)</ept> object on the left side of the operator is equal to the unordered_map object on the right side.","source":"Tests whether the [unordered_map](../standard-library/unordered-map-class.md) object on the left side of the operator is equal to the unordered_map object on the right side."},{"pos":[2646,2656],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An object of type <ph id=\"ph1\">`unordered_map`</ph>.","pos":[2670,2704],"source":" An object of type `unordered_map`."},{"content":"An object of type <ph id=\"ph1\">`unordered_map`</ph>.","pos":[2722,2756],"source":" An object of type `unordered_map`."},{"pos":[2766,2778],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[2782,2852],"content":"<ph id=\"ph1\">`true`</ph> if the unordered_maps are equal; <ph id=\"ph2\">`false`</ph> if they are not equal.","source":"`true` if the unordered_maps are equal; `false` if they are not equal."},{"pos":[2862,2869],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The comparison between unordered_map objects is not affected by the arbitrary order in which they store their elements.","pos":[2873,2992]},{"content":"Two unordered_maps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container.","pos":[2993,3154]},{"content":"Otherwise, they are unequal.","pos":[3155,3183]},{"pos":[3193,3200],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[3968,3979],"content":"<bpt id=\"p1\">**</bpt>Output:<ept id=\"p1\">**</ept>","source":"**Output:**"},{"pos":[4066,4114],"content":"<bpt id=\"p1\">&lt;a name=\"operator_neq_multimap\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator!=","linkify":"<a name=\"operator_neq_multimap\"></a>  operator!=","source":"<a name=\"operator_neq_multimap\"></a>  operator!="},{"pos":[4118,4310],"content":"Tests whether the <bpt id=\"p1\">[</bpt>unordered_multimap<ept id=\"p1\">](../standard-library/unordered-multimap-class.md)</ept> object on the left side of the operator is not equal to the unordered_multimap object on the right side.","source":"Tests whether the [unordered_multimap](../standard-library/unordered-multimap-class.md) object on the left side of the operator is not equal to the unordered_multimap object on the right side."},{"pos":[4485,4495],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An object of type <ph id=\"ph1\">`unordered_multimap`</ph>.","pos":[4509,4548],"source":" An object of type `unordered_multimap`."},{"content":"An object of type <ph id=\"ph1\">`unordered_multimap`</ph>.","pos":[4566,4605],"source":" An object of type `unordered_multimap`."},{"pos":[4615,4627],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[4631,4706],"content":"<ph id=\"ph1\">`true`</ph> if the unordered_multimaps are not equal; <ph id=\"ph2\">`false`</ph> if they are equal.","source":"`true` if the unordered_multimaps are not equal; `false` if they are equal."},{"pos":[4716,4723],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The comparison between unordered_multimap objects is not affected by the arbitrary order in which they store their elements.","pos":[4727,4851]},{"content":"Two unordered_multimaps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container.","pos":[4852,5018]},{"content":"Otherwise, they are not equal.","pos":[5019,5049]},{"pos":[5059,5066],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[5879,5890],"content":"<bpt id=\"p1\">**</bpt>Output:<ept id=\"p1\">**</ept>","source":"**Output:**"},{"pos":[5976,6026],"content":"<bpt id=\"p1\">&lt;a name=\"operator_eq_eq_multimap\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  operator==","linkify":"<a name=\"operator_eq_eq_multimap\"></a>  operator==","source":"<a name=\"operator_eq_eq_multimap\"></a>  operator=="},{"pos":[6030,6218],"content":"Tests whether the <bpt id=\"p1\">[</bpt>unordered_multimap<ept id=\"p1\">](../standard-library/unordered-multimap-class.md)</ept> object on the left side of the operator is equal to the unordered_multimap object on the right side.","source":"Tests whether the [unordered_multimap](../standard-library/unordered-multimap-class.md) object on the left side of the operator is equal to the unordered_multimap object on the right side."},{"pos":[6393,6403],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"An object of type <ph id=\"ph1\">`unordered_multimap`</ph>.","pos":[6417,6456],"source":" An object of type `unordered_multimap`."},{"content":"An object of type <ph id=\"ph1\">`unordered_multimap`</ph>.","pos":[6474,6513],"source":" An object of type `unordered_multimap`."},{"pos":[6523,6535],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[6539,6614],"content":"<ph id=\"ph1\">`true`</ph> if the unordered_multimaps are equal; <ph id=\"ph2\">`false`</ph> if they are not equal.","source":"`true` if the unordered_multimaps are equal; `false` if they are not equal."},{"pos":[6624,6631],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The comparison between unordered_multimap objects is not affected by the arbitrary order in which they store their elements.","pos":[6635,6759]},{"content":"Two unordered_multimaps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container.","pos":[6760,6926]},{"content":"Otherwise, they are unequal.","pos":[6927,6955]},{"pos":[6965,6972],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[7787,7798],"content":"<bpt id=\"p1\">**</bpt>Output:<ept id=\"p1\">**</ept>","source":"**Output:**"},{"pos":[7884,7892],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[7896,7951],"content":"<bpt id=\"p1\">[</bpt>&lt;unordered_map&gt;<ept id=\"p1\">](../standard-library/unordered-map.md)</ept>","source":"[<unordered_map>](../standard-library/unordered-map.md)"}],"content":"---\ntitle: \"&lt;unordered_map&gt; operators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 9d5add0b-84bd-4a79-bd82-3f58b55145ed\ncaps.latest.revision: 7\nmanager: \"ghogen\"\n---\n# &lt;unordered_map&gt; operators\n|||||  \n|-|-|-|-|  \n|[operator!=](#operator_neq)|[operator==](#operator_eq_eq)|[operator!=](#operator_neq_multimap)|[operator==](#operator_eq_eq_multimap)|  \n  \n##  <a name=\"operator_neq\"></a>  operator!=  \n Tests whether the [unordered_map](../standard-library/unordered-map-class.md) object on the left side of the operator is not equal to the unordered_map object on the right side.  \n  \n```\nbool operator!=(const unordered_map <Key, Type, Hash, Pred, Allocator>& left, const unordered_map <Key, Type, Hash, Pred, Allocator>& right);\n```  \n  \n### Parameters  \n `left`  \n An object of type `unordered_map`.  \n  \n `right`  \n An object of type `unordered_map`.  \n  \n### Return Value  \n `true` if the unordered_maps are not equal; `false` if they are equal.  \n  \n### Remarks  \n The comparison between unordered_map objects is not affected by the arbitrary order in which they store their elements. Two unordered_maps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container. Otherwise, they are unequal.  \n  \n### Example  \n  \n```cpp  \n// unordered_map_op_ne.cpp  \n// compile by using: cl.exe /EHsc /nologo /W4 /MTd   \n#include <unordered_map>  \n#include <iostream>  \n#include <ios>  \n  \nint main( )  \n{  \n   using namespace std;  \n   unordered_map<int, int> um1, um2, um3;  \n  \n   for ( int i = 0 ; i < 3 ; ++i ) {  \n      um1.insert( make_pair( i+1, i ) );  \n      um1.insert( make_pair( i, i ) );  \n  \n      um2.insert( make_pair( i, i+1 ) );  \n      um2.insert( make_pair( i, i ) );  \n  \n      um3.insert( make_pair( i, i ) );  \n      um3.insert( make_pair( i+1, i ) );  \n   }  \n  \n   cout << boolalpha;  \n   cout << \"um1 != um2: \" << (um1 != um2) << endl;   \n   cout << \"um1 != um3: \" << (um1 != um3) << endl;   \n   cout << \"um2 != um3: \" << (um2 != um3) << endl;   \n}  \n  \n```  \n  \n **Output:**  \n  \n `um1 != um2: true`  \n  \n `um1 != um3: false`  \n  \n `um2 != um3: true`  \n  \n##  <a name=\"operator_eq_eq\"></a>  operator==  \n Tests whether the [unordered_map](../standard-library/unordered-map-class.md) object on the left side of the operator is equal to the unordered_map object on the right side.  \n  \n```\nbool operator==(const unordered_map <Key, Type, Hash, Pred, Allocator>& left, const unordered_map <Key, Type, Hash, Pred, Allocator>& right);\n```  \n  \n### Parameters  \n `left`  \n An object of type `unordered_map`.  \n  \n `right`  \n An object of type `unordered_map`.  \n  \n### Return Value  \n `true` if the unordered_maps are equal; `false` if they are not equal.  \n  \n### Remarks  \n The comparison between unordered_map objects is not affected by the arbitrary order in which they store their elements. Two unordered_maps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container. Otherwise, they are unequal.  \n  \n### Example  \n  \n```cpp  \n// unordered_map_op_eq.cpp  \n// compile by using: cl.exe /EHsc /nologo /W4 /MTd   \n#include <unordered_map>  \n#include <iostream>  \n#include <ios>  \n  \nint main( )  \n{  \n   using namespace std;  \n   unordered_map<int, int> um1, um2, um3;  \n  \n   for ( int i = 0 ; i < 3 ; ++i ) {  \n      um1.insert( make_pair( i+1, i ) );  \n      um1.insert( make_pair( i, i ) );  \n  \n      um2.insert( make_pair( i, i+1 ) );  \n      um2.insert( make_pair( i, i ) );  \n  \n      um3.insert( make_pair( i, i ) );  \n      um3.insert( make_pair( i+1, i ) );  \n   }  \n  \n   cout << boolalpha;  \n   cout << \"um1 == um2: \" << (um1 == um2) << endl;   \n   cout << \"um1 == um3: \" << (um1 == um3) << endl;   \n   cout << \"um2 == um3: \" << (um2 == um3) << endl;   \n}  \n  \n```  \n  \n **Output:**  \n  \n `um1 == um2: false`  \n  \n `um1 == um3: true`  \n  \n `um2 == um3: false`  \n  \n##  <a name=\"operator_neq_multimap\"></a>  operator!=  \n Tests whether the [unordered_multimap](../standard-library/unordered-multimap-class.md) object on the left side of the operator is not equal to the unordered_multimap object on the right side.  \n  \n```\nbool operator!=(const unordered_multimap <Key, Type, Hash, Pred, Allocator>& left, const unordered_multimap <Key, Type, Hash, Pred, Allocator>& right);\n```  \n  \n### Parameters  \n `left`  \n An object of type `unordered_multimap`.  \n  \n `right`  \n An object of type `unordered_multimap`.  \n  \n### Return Value  \n `true` if the unordered_multimaps are not equal; `false` if they are equal.  \n  \n### Remarks  \n The comparison between unordered_multimap objects is not affected by the arbitrary order in which they store their elements. Two unordered_multimaps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container. Otherwise, they are not equal.  \n  \n### Example  \n  \n```cpp  \n// unordered_multimap_op_ne.cpp  \n// compile by using: cl.exe /EHsc /nologo /W4 /MTd   \n#include <unordered_map>  \n#include <iostream>  \n#include <ios>  \n  \nint main( )  \n{  \n   using namespace std;  \n   unordered_multimap<int, int> um1, um2, um3;  \n  \n   for ( int i = 0 ; i < 3 ; ++i ) {  \n      um1.insert( make_pair( i, i ) );  \n      um1.insert( make_pair( i, i ) );  \n  \n      um2.insert( make_pair( i, i ) );  \n      um2.insert( make_pair( i, i ) );  \n      um2.insert( make_pair( i, i ) );  \n  \n      um3.insert( make_pair( i, i ) );  \n      um3.insert( make_pair( i, i ) );  \n   }  \n  \n   cout << boolalpha;  \n   cout << \"um1 != um2: \" << (um1 != um2) << endl;   \n   cout << \"um1 != um3: \" << (um1 != um3) << endl;   \n   cout << \"um2 != um3: \" << (um2 != um3) << endl;   \n}  \n  \n```  \n  \n **Output:**  \n  \n `um1 != um2: true`  \n  \n `um1 != um3: false`  \n  \n `um2 != um3: true`  \n  \n##  <a name=\"operator_eq_eq_multimap\"></a>  operator==  \n Tests whether the [unordered_multimap](../standard-library/unordered-multimap-class.md) object on the left side of the operator is equal to the unordered_multimap object on the right side.  \n  \n```\nbool operator==(const unordered_multimap <Key, Type, Hash, Pred, Allocator>& left, const unordered_multimap <Key, Type, Hash, Pred, Allocator>& right);\n```  \n  \n### Parameters  \n `left`  \n An object of type `unordered_multimap`.  \n  \n `right`  \n An object of type `unordered_multimap`.  \n  \n### Return Value  \n `true` if the unordered_multimaps are equal; `false` if they are not equal.  \n  \n### Remarks  \n The comparison between unordered_multimap objects is not affected by the arbitrary order in which they store their elements. Two unordered_multimaps are equal if they have the same number of elements and the elements in one container are a permutation of the elements in the other container. Otherwise, they are unequal.  \n  \n### Example  \n  \n```cpp  \n  \n// unordered_multimap_op_eq.cpp  \n// compile by using: cl.exe /EHsc /nologo /W4 /MTd  \n#include <unordered_map>  \n#include <iostream>  \n#include <ios>  \n  \nint main( )  \n{  \n   using namespace std;  \n   unordered_multimap<int, int> um1, um2, um3;  \n  \n   for ( int i = 0 ; i < 3 ; ++i ) {  \n      um1.insert( make_pair( i, i ) );  \n      um1.insert( make_pair( i, i ) );  \n  \n      um2.insert( make_pair( i, i ) );  \n      um2.insert( make_pair( i, i ) );  \n      um2.insert( make_pair( i, i ) );  \n  \n      um3.insert( make_pair( i, i ) );  \n      um3.insert( make_pair( i, i ) );  \n   }  \n  \n   cout << boolalpha;  \n   cout << \"um1 == um2: \" << (um1 == um2) << endl;   \n   cout << \"um1 == um3: \" << (um1 == um3) << endl;   \n   cout << \"um2 == um3: \" << (um2 == um3) << endl;   \n}  \n  \n```  \n  \n **Output:**  \n  \n `um1 == um2: false`  \n  \n `um1 == um3: true`  \n  \n `um2 == um3: false`  \n  \n## See Also  \n [<unordered_map>](../standard-library/unordered-map.md)\n\n\n\n"}