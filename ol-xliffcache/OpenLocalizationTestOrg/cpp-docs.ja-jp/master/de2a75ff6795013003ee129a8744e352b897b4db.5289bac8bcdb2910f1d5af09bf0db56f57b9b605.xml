{"nodes":[{"pos":[12,44],"content":"allocator Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"allocator Class | Microsoft Docs","pos":[0,32]}]},{"content":"allocator Class","pos":[668,683]},{"content":"The template class describes an object that manages storage allocation and freeing for arrays of objects of type <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>.","pos":[684,806],"source":"The template class describes an object that manages storage allocation and freeing for arrays of objects of type **Type**."},{"content":"An object of class <bpt id=\"p1\">**</bpt>allocator<ept id=\"p1\">**</ept> is the default allocator object specified in the constructors for several container template classes in the Standard C++ Library.","pos":[807,969],"source":" An object of class **allocator** is the default allocator object specified in the constructors for several container template classes in the Standard C++ Library."},{"content":"Syntax","pos":[978,984]},{"content":"Parameters","pos":[1052,1062]},{"content":"Type","pos":[1067,1071]},{"content":"The type of object for which storage is being allocated or deallocated.","pos":[1076,1147]},{"content":"Remarks","pos":[1156,1163]},{"content":"All the Standard Template Library containers have a template parameter that defaults to <bpt id=\"p1\">**</bpt>allocator<ept id=\"p1\">**</ept>.","pos":[1167,1269],"source":"All the Standard Template Library containers have a template parameter that defaults to **allocator**."},{"content":"Constructing a container with a custom allocator provide control over allocation and freeing of that container's elements.","pos":[1270,1392]},{"content":"For example, an allocator object might allocate storage on a private heap or in shared memory, or it might optimize for small or large object sizes.","pos":[1399,1547]},{"content":"It might also specify, through the type definitions it supplies, that elements be accessed through special accessor objects that manage shared memory, or perform automatic garbage collection.","pos":[1548,1739]},{"content":"Hence, a class that allocates storage using an allocator object should use these types for declaring pointer and reference objects, as the containers in the Standard C++ Library do.","pos":[1740,1921]},{"pos":[1928,2104],"content":"<bpt id=\"p1\">**</bpt>(C_++98/03 only)<ept id=\"p1\">**</ept>When you derive from allocator class, you have to provide a <bpt id=\"p2\">[</bpt>rebind<ept id=\"p2\">](#allocator__rebind)</ept> struct, whose <ph id=\"ph1\">`_Other`</ph> typedef references your newly-derived class.","source":"**(C_++98/03 only)**When you derive from allocator class, you have to provide a [rebind](#allocator__rebind) struct, whose `_Other` typedef references your newly-derived class."},{"content":"Thus, an allocator defines the following types:","pos":[2111,2158]},{"pos":[2166,2232],"content":"<bpt id=\"p1\">[</bpt>pointer<ept id=\"p1\">](#allocator__pointer)</ept> behaves like a pointer to <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept>.","source":"[pointer](#allocator__pointer) behaves like a pointer to **Type**."},{"pos":[2240,2324],"content":"<bpt id=\"p1\">[</bpt>const_pointer<ept id=\"p1\">](#allocator__const_pointer)</ept> behaves like a const pointer to <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept>.","source":"[const_pointer](#allocator__const_pointer) behaves like a const pointer to **Type**."},{"pos":[2332,2404],"content":"<bpt id=\"p1\">[</bpt>reference<ept id=\"p1\">](#allocator__reference)</ept> behaves like a reference to <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept>.","source":"[reference](#allocator__reference) behaves like a reference to **Type**."},{"pos":[2412,2502],"content":"<bpt id=\"p1\">[</bpt>const_reference<ept id=\"p1\">](#allocator__const_reference)</ept> behaves like a const reference to <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept>.","source":"[const_reference](#allocator__const_reference) behaves like a const reference to **Type**."},{"content":"These <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>s specify the form that pointers and references must take for allocated elements.","pos":[2509,2604],"source":"These **Type**s specify the form that pointers and references must take for allocated elements."},{"content":"( <bpt id=\"p1\">[</bpt>allocator::pointer<ept id=\"p1\">](#allocator__pointer)</ept> is not necessarily the same as <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept><ph id=\"ph1\">\\*</ph> for all allocator objects, even though it has this obvious definition for class <bpt id=\"p3\">**</bpt>allocator<ept id=\"p3\">**</ept>.)","pos":[2605,2786],"source":" ( [allocator::pointer](#allocator__pointer) is not necessarily the same as **Type**\\* for all allocator objects, even though it has this obvious definition for class **allocator**.)"},{"content":"<bpt id=\"p1\">**</bpt>C++11 and later:<ept id=\"p1\">**</ept>  To enable move operations in your allocator, use the minimal allocator interface and implement copy constructor, == and != operators, allocate and deallocate.","pos":[2793,2973],"source":"**C++11 and later:**  To enable move operations in your allocator, use the minimal allocator interface and implement copy constructor, == and != operators, allocate and deallocate."},{"content":"For more information and an example, see <bpt id=\"p1\">[</bpt>Allocators<ept id=\"p1\">](../standard-library/allocators.md)</ept>","pos":[2974,3062],"source":" For more information and an example, see [Allocators](../standard-library/allocators.md)"},{"content":"Members","pos":[3071,3078]},{"content":"Constructors","pos":[3088,3100]},{"content":"allocator","pos":[3122,3131]},{"pos":[3156,3204],"content":"Constructors used to create <ph id=\"ph1\">`allocator`</ph> objects.","source":"Constructors used to create `allocator` objects."},{"content":"Typedefs","pos":[3215,3223]},{"content":"const_pointer","pos":[3245,3258]},{"content":"A type that provides a constant pointer to the type of object managed by the allocator.","pos":[3287,3374]},{"content":"const_reference","pos":[3380,3395]},{"content":"A type that provides a constant reference to type of object managed by the allocator.","pos":[3426,3511]},{"content":"difference_type","pos":[3517,3532]},{"content":"A signed integral type that can represent the difference between values of pointers to the type of object managed by the allocator.","pos":[3563,3694]},{"content":"pointer","pos":[3700,3707]},{"content":"A type that provides a pointer to the type of object managed by the allocator.","pos":[3730,3808]},{"content":"reference","pos":[3814,3823]},{"content":"A type that provides a reference to the type of object managed by the allocator.","pos":[3848,3928]},{"content":"size_type","pos":[3934,3943]},{"pos":[3968,4098],"content":"An unsigned integral type that can represent the length of any sequence that an object of template class <ph id=\"ph1\">`allocator`</ph> can allocate.","source":"An unsigned integral type that can represent the length of any sequence that an object of template class `allocator` can allocate."},{"content":"value_type","pos":[4104,4114]},{"content":"A type that is managed by the allocator.","pos":[4140,4180]},{"content":"Member Functions","pos":[4191,4207]},{"content":"address","pos":[4229,4236]},{"content":"Finds the address of an object whose value is specified.","pos":[4259,4315]},{"content":"allocate","pos":[4321,4329]},{"content":"Allocates a block of memory large enough to store at least some specified number of elements.","pos":[4353,4446]},{"content":"construct","pos":[4452,4461]},{"content":"Constructs a specific type of object at a specified address that is initialized with a specified value.","pos":[4486,4589]},{"content":"deallocate","pos":[4595,4605]},{"content":"Frees a specified number of objects from storage beginning at a specified position.","pos":[4631,4714]},{"content":"destroy","pos":[4720,4727]},{"content":"Calls an objects destructor without deallocating the memory where the object was stored.","pos":[4750,4838]},{"content":"max_size","pos":[4844,4852]},{"pos":[4876,5014],"content":"Returns the number of elements of type <ph id=\"ph1\">`Type`</ph> that could be allocated by an object of class <ph id=\"ph2\">`allocator`</ph> before the free memory is used up.","source":"Returns the number of elements of type `Type` that could be allocated by an object of class `allocator` before the free memory is used up."},{"content":"rebind","pos":[5020,5026]},{"content":"A structure that enables an allocator for objects of one type to allocate storage for objects of another type.","pos":[5048,5158]},{"content":"Operators","pos":[5169,5178]},{"content":"operator=","pos":[5200,5209]},{"pos":[5236,5297],"content":"Assigns one <ph id=\"ph1\">`allocator`</ph> object to another <ph id=\"ph2\">`allocator`</ph> object.","source":"Assigns one `allocator` object to another `allocator` object."},{"content":"Requirements","pos":[5307,5319]},{"pos":[5323,5344],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>memory&gt;","source":"**Header:** \\<memory>"},{"pos":[5351,5369],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[5414,5432],"content":"allocator::address"},{"content":"Finds the address of an object whose value is specified.","pos":[5436,5492]},{"content":"Parameters","pos":[5605,5615]},{"content":"The const or nonconst value of the object whose address is being searched for.","pos":[5629,5707]},{"content":"Return Value","pos":[5717,5729]},{"content":"A const or nonconst pointer to the object found of, respectively, const or nonconst value.","pos":[5733,5823]},{"content":"Remarks","pos":[5833,5840]},{"pos":[5844,5954],"content":"The member functions return the address of <ph id=\"ph1\">` val`</ph>, in the form that pointers must take for allocated elements.","source":"The member functions return the address of ` val`, in the form that pointers must take for allocated elements."},{"content":"Example","pos":[5964,5971]},{"pos":[7019,7038],"content":"allocator::allocate"},{"content":"Allocates a block of memory large enough to store at least some specified number of elements.","pos":[7042,7135]},{"content":"Parameters","pos":[7214,7224]},{"content":"The number of elements for which sufficient storage is to be allocated.","pos":[7240,7311]},{"content":"_Hint","pos":[7319,7324]},{"content":"A const pointer that may assist the allocator object satisfy the request for storage by locating the address of an object allocated prior to the request.","pos":[7329,7482]},{"content":"Return Value","pos":[7492,7504]},{"content":"A pointer to the allocated object or null if memory was not allocated.","pos":[7508,7578]},{"content":"Remarks","pos":[7588,7595]},{"content":"The member function allocates storage for an array of count elements of type <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>, by calling operator new( <ph id=\"ph1\">` count`</ph>).","pos":[7599,7721],"source":"The member function allocates storage for an array of count elements of type **Type**, by calling operator new( ` count`)."},{"content":"It returns a pointer to the allocated object.","pos":[7722,7767]},{"content":"The hint argument helps some allocators in improving locality of reference; a valid choice is the address of an object earlier allocated by the same allocator object and not yet deallocated.","pos":[7768,7958]},{"content":"To supply no hint, use a null pointer argument instead.","pos":[7959,8014]},{"content":"Example","pos":[8024,8031]},{"pos":[8651,8671],"content":"allocator::allocator"},{"content":"Constructors used to create allocator objects.","pos":[8675,8721]},{"content":"Parameters","pos":[8867,8877]},{"content":"The allocator object to be copied.","pos":[8893,8927]},{"content":"Remarks","pos":[8937,8944]},{"content":"The constructor does nothing.","pos":[8948,8977]},{"content":"In general, however, an allocator object constructed from another allocator object should compare equal to it and permit intermixing of object allocation and freeing between the two allocator objects.","pos":[8978,9178]},{"content":"Example","pos":[9188,9195]},{"pos":[10581,10605],"content":"allocator::const_pointer"},{"content":"A type that provides a constant pointer to the type of object managed by the allocator.","pos":[10609,10696]},{"content":"Remarks","pos":[10764,10771]},{"pos":[10775,10947],"content":"The pointer type describes an object <bpt id=\"p1\">**</bpt>ptr<ept id=\"p1\">**</ept> that can designate, through the expression <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\*</ph>ptr<ept id=\"p2\">**</ept>, any const object that an object of template class allocator can allocate.","source":"The pointer type describes an object **ptr** that can designate, through the expression **\\*ptr**, any const object that an object of template class allocator can allocate."},{"content":"Example","pos":[10957,10964]},{"pos":[11904,11930],"content":"allocator::const_reference"},{"content":"A type that provides a constant reference to type of object managed by the allocator.","pos":[11934,12019]},{"content":"Remarks","pos":[12089,12096]},{"content":"The reference type describes an object that can designate any const object that an object of template class allocator can allocate.","pos":[12100,12231]},{"content":"Example","pos":[12241,12248]},{"pos":[13833,13853],"content":"allocator::construct"},{"content":"Constructs a specific type of object at a specified address that is initialized with a specified value.","pos":[13857,13960]},{"content":"Parameters","pos":[14146,14156]},{"content":"A pointer to the location where the object is to be constructed.","pos":[14170,14234]},{"content":"The value with which the object being constructed is to be initialized.","pos":[14251,14322]},{"content":"Remarks","pos":[14332,14339]},{"pos":[14343,14438],"content":"The first member function is equivalent to <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> ( ( <ph id=\"ph1\">`void`</ph> <ph id=\"ph2\">\\*</ph>) <ph id=\"ph3\">` ptr`</ph> ) <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept> ( <ph id=\"ph4\">` val`</ph> ).","source":"The first member function is equivalent to **new** ( ( `void` \\*) ` ptr` ) **Type** ( ` val` )."},{"content":"Example","pos":[14448,14455]},{"pos":[15603,15624],"content":"allocator::deallocate"},{"content":"Frees a specified number of objects from storage beginning at a specified position.","pos":[15628,15711]},{"content":"Parameters","pos":[15783,15793]},{"content":"A pointer to the first object to be deallocated from storage.","pos":[15807,15868]},{"content":"The number of objects to be deallocated from storage.","pos":[15887,15940]},{"content":"Remarks","pos":[15950,15957]},{"content":"The member function frees storage for the array of count objects of type <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> beginning at <ph id=\"ph1\">` ptr`</ph>, by calling <ph id=\"ph2\">`operator delete`</ph>( <ph id=\"ph3\">` ptr`</ph>).","pos":[15961,16102],"source":"The member function frees storage for the array of count objects of type **Type** beginning at ` ptr`, by calling `operator delete`( ` ptr`)."},{"content":"The pointer <ph id=\"ph1\">` ptr`</ph> must have been returned earlier by a call to <bpt id=\"p1\">[</bpt>allocate<ept id=\"p1\">](#allocator__allocate)</ept> for an allocator object that compares equal to <bpt id=\"p2\">**</bpt><ph id=\"ph2\">\\*</ph>this<ept id=\"p2\">**</ept>, allocating an array object of the same size and type.","pos":[16103,16312],"source":" The pointer ` ptr` must have been returned earlier by a call to [allocate](#allocator__allocate) for an allocator object that compares equal to **\\*this**, allocating an array object of the same size and type."},{"content":"never throws an exception.","pos":[16326,16352]},{"content":"Example","pos":[16362,16369]},{"pos":[16374,16464],"content":"For an example using the member function, see <bpt id=\"p1\">[</bpt>allocator::allocate<ept id=\"p1\">](#allocator__allocate)</ept>.","source":"For an example using the member function, see [allocator::allocate](#allocator__allocate)."},{"pos":[16509,16527],"content":"allocator::destroy"},{"content":"Calls an objects destructor without deallocating the memory where the object was stored.","pos":[16531,16619]},{"content":"Parameters","pos":[16671,16681]},{"content":"A pointer designating the address of the object to be destroyed.","pos":[16695,16759]},{"content":"Remarks","pos":[16769,16776]},{"pos":[16780,16899],"content":"The member function destroys the object designated by <ph id=\"ph1\">` ptr`</ph>, by calling the destructor <ph id=\"ph2\">` ptr` -&gt; </ph><bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>:: <bpt id=\"p2\">**</bpt>~Type<ept id=\"p2\">**</ept>.","source":"The member function destroys the object designated by ` ptr`, by calling the destructor ` ptr` -> **Type**:: **~Type**."},{"content":"Example","pos":[16909,16916]},{"pos":[18067,18093],"content":"allocator::difference_type"},{"content":"A signed integral type that can represent the difference between values of pointers to the type of object managed by the allocator.","pos":[18097,18228]},{"content":"Remarks","pos":[18290,18297]},{"content":"The signed integer type describes an object that can represent the difference between the addresses of any two elements in a sequence that an object of template class allocator can allocate.","pos":[18301,18491]},{"content":"Example","pos":[18501,18508]},{"pos":[19775,19794],"content":"allocator::max_size"},{"pos":[19798,19936],"content":"Returns the number of elements of type <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> that could be allocated by an object of class allocator before the free memory is used up.","source":"Returns the number of elements of type **Type** that could be allocated by an object of class allocator before the free memory is used up."},{"content":"Return Value","pos":[19989,20001]},{"content":"The number of elements that could be allocated.","pos":[20005,20052]},{"content":"Example","pos":[20062,20069]},{"pos":[21565,21585],"content":"allocator::operator="},{"content":"Assigns one allocator object to another allocator object.","pos":[21589,21646]},{"content":"Parameters","pos":[21755,21765]},{"content":"An allocator object to be assigned to another such object.","pos":[21781,21839]},{"content":"Return Value","pos":[21849,21861]},{"content":"A reference to the allocator object","pos":[21865,21900]},{"content":"Remarks","pos":[21910,21917]},{"content":"The template assignment operator does nothing.","pos":[21921,21967]},{"content":"In general, however, an allocator object assigned to another allocator object should compare equal to it and permit intermixing of object allocation and freeing between the two allocator objects.","pos":[21968,22163]},{"content":"Example","pos":[22173,22180]},{"pos":[22899,22917],"content":"allocator::pointer"},{"content":"A type that provides a pointer to the type of object managed by the allocator.","pos":[22921,22999]},{"content":"Remarks","pos":[23055,23062]},{"pos":[23066,23232],"content":"The pointer type describes an object <bpt id=\"p1\">**</bpt>ptr<ept id=\"p1\">**</ept> that can designate, through the expression <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\*</ph>ptr<ept id=\"p2\">**</ept>, any object that an object of template class allocator can allocate.","source":"The pointer type describes an object **ptr** that can designate, through the expression **\\*ptr**, any object that an object of template class allocator can allocate."},{"content":"Example","pos":[23242,23249]},{"pos":[24208,24225],"content":"allocator::rebind"},{"content":"A structure that enables an allocator for objects of one type to allocate storage for objects of another type.","pos":[24229,24339]},{"content":"Parameters","pos":[24419,24429]},{"content":"other","pos":[24434,24439]},{"content":"The type of element for which memory is being allocated.","pos":[24444,24500]},{"content":"Remarks","pos":[24510,24517]},{"content":"This structure is useful for allocating memory for type that differs from the element type of the container being implemented.","pos":[24521,24647]},{"content":"The member template class defines the type other.","pos":[24654,24703]},{"content":"Its sole purpose is to provide the type name <bpt id=\"p1\">**</bpt>allocator<ept id=\"p1\">**</ept><ph id=\"ph1\">\\&lt;</ph>_ <bpt id=\"p2\">**</bpt>Other<ept id=\"p2\">**</ept>&gt;, given the type name <bpt id=\"p3\">**</bpt>allocator<ept id=\"p3\">**</ept><ph id=\"ph2\">\\&lt;</ph> <bpt id=\"p4\">**</bpt>Type<ept id=\"p4\">**</ept>&gt;.","pos":[24704,24824],"source":" Its sole purpose is to provide the type name **allocator**\\<_ **Other**>, given the type name **allocator**\\< **Type**>."},{"pos":[24831,24958],"content":"For example, given an allocator object <bpt id=\"p1\">**</bpt>al<ept id=\"p1\">**</ept> of type <bpt id=\"p2\">**</bpt>A<ept id=\"p2\">**</ept>, you can allocate an object of type <bpt id=\"p3\">**</bpt>_Other<ept id=\"p3\">**</ept> with the expression:","source":"For example, given an allocator object **al** of type **A**, you can allocate an object of type **_Other** with the expression:"},{"content":"Or, you can name its pointer type by writing the type:","pos":[25034,25088]},{"content":"Example","pos":[25148,25155]},{"pos":[25677,25697],"content":"allocator::reference"},{"content":"A type that provides a reference to the type of object managed by the allocator.","pos":[25701,25781]},{"content":"Remarks","pos":[25839,25846]},{"content":"The reference type describes an object that can designate any object that an object of template class allocator can allocate.","pos":[25850,25975]},{"content":"Example","pos":[25985,25992]},{"pos":[27252,27272],"content":"allocator::size_type"},{"content":"An unsigned integral type that can represent the length of any sequence that an object of template class allocator can allocate.","pos":[27276,27404]},{"content":"Example","pos":[27457,27464]},{"pos":[28322,28343],"content":"allocator::value_type"},{"content":"A type that is managed by the allocator.","pos":[28347,28387]},{"content":"Remarks","pos":[28439,28446]},{"pos":[28450,28508],"content":"The type is a synonym for the template parameter <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>.","source":"The type is a synonym for the template parameter **Type**."},{"content":"Example","pos":[28518,28525]},{"content":"See Also","pos":[29754,29762]},{"content":"Thread Safety in the C++ Standard Library","pos":[29767,29808]}],"content":"---\ntitle: \"allocator Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std::allocator\"\n  - \"allocator\"\n  - \"memory/std::allocator\"\n  - \"std.allocator\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"allocator class\"\nms.assetid: 3fd58076-56cc-43bb-ad58-b4b7c9c6b410\ncaps.latest.revision: 20\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# allocator Class\nThe template class describes an object that manages storage allocation and freeing for arrays of objects of type **Type**. An object of class **allocator** is the default allocator object specified in the constructors for several container template classes in the Standard C++ Library.  \n  \n## Syntax  \n  \n```  \ntemplate <class Type>  \nclass allocator  \n```  \n  \n#### Parameters  \n *Type*  \n The type of object for which storage is being allocated or deallocated.  \n  \n## Remarks  \n All the Standard Template Library containers have a template parameter that defaults to **allocator**. Constructing a container with a custom allocator provide control over allocation and freeing of that container's elements.  \n  \n For example, an allocator object might allocate storage on a private heap or in shared memory, or it might optimize for small or large object sizes. It might also specify, through the type definitions it supplies, that elements be accessed through special accessor objects that manage shared memory, or perform automatic garbage collection. Hence, a class that allocates storage using an allocator object should use these types for declaring pointer and reference objects, as the containers in the Standard C++ Library do.  \n  \n **(C_++98/03 only)**When you derive from allocator class, you have to provide a [rebind](#allocator__rebind) struct, whose `_Other` typedef references your newly-derived class.  \n  \n Thus, an allocator defines the following types:  \n  \n- [pointer](#allocator__pointer) behaves like a pointer to **Type**.  \n  \n- [const_pointer](#allocator__const_pointer) behaves like a const pointer to **Type**.  \n  \n- [reference](#allocator__reference) behaves like a reference to **Type**.  \n  \n- [const_reference](#allocator__const_reference) behaves like a const reference to **Type**.  \n  \n These **Type**s specify the form that pointers and references must take for allocated elements. ( [allocator::pointer](#allocator__pointer) is not necessarily the same as **Type**\\* for all allocator objects, even though it has this obvious definition for class **allocator**.)  \n  \n **C++11 and later:**  To enable move operations in your allocator, use the minimal allocator interface and implement copy constructor, == and != operators, allocate and deallocate. For more information and an example, see [Allocators](../standard-library/allocators.md)  \n  \n## Members  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[allocator](#allocator__allocator)|Constructors used to create `allocator` objects.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[const_pointer](#allocator__const_pointer)|A type that provides a constant pointer to the type of object managed by the allocator.|  \n|[const_reference](#allocator__const_reference)|A type that provides a constant reference to type of object managed by the allocator.|  \n|[difference_type](#allocator__difference_type)|A signed integral type that can represent the difference between values of pointers to the type of object managed by the allocator.|  \n|[pointer](#allocator__pointer)|A type that provides a pointer to the type of object managed by the allocator.|  \n|[reference](#allocator__reference)|A type that provides a reference to the type of object managed by the allocator.|  \n|[size_type](#allocator__size_type)|An unsigned integral type that can represent the length of any sequence that an object of template class `allocator` can allocate.|  \n|[value_type](#allocator__value_type)|A type that is managed by the allocator.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[address](#allocator__address)|Finds the address of an object whose value is specified.|  \n|[allocate](#allocator__allocate)|Allocates a block of memory large enough to store at least some specified number of elements.|  \n|[construct](#allocator__construct)|Constructs a specific type of object at a specified address that is initialized with a specified value.|  \n|[deallocate](#allocator__deallocate)|Frees a specified number of objects from storage beginning at a specified position.|  \n|[destroy](#allocator__destroy)|Calls an objects destructor without deallocating the memory where the object was stored.|  \n|[max_size](#allocator__max_size)|Returns the number of elements of type `Type` that could be allocated by an object of class `allocator` before the free memory is used up.|  \n|[rebind](#allocator__rebind)|A structure that enables an allocator for objects of one type to allocate storage for objects of another type.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|[operator=](#allocator__operator_eq)|Assigns one `allocator` object to another `allocator` object.|  \n  \n## Requirements  \n **Header:** \\<memory>  \n  \n **Namespace:** std  \n  \n##  <a name=\"allocator__address\"></a>  allocator::address  \n Finds the address of an object whose value is specified.  \n  \n```  \npointer address(reference val) const;\nconst_pointer address(const_reference val) const;\n```  \n  \n### Parameters  \n ` val`  \n The const or nonconst value of the object whose address is being searched for.  \n  \n### Return Value  \n A const or nonconst pointer to the object found of, respectively, const or nonconst value.  \n  \n### Remarks  \n The member functions return the address of ` val`, in the form that pointers must take for allocated elements.  \n  \n### Example  \n  \n```cpp  \n// allocator_address.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <algorithm>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   vector <int> v1;  \n   vector <int>::iterator v1Iter;  \n   vector <int>:: allocator_type v1Alloc;  \n  \n   int i;  \n   for ( i = 1 ; i <= 7 ; i++ )  \n   {  \n      v1.push_back( 2 * i );  \n   }  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ; v1Iter++ )  \n      cout << *v1Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   allocator<int>::const_pointer v1Ptr;  \n   const int k = 8;  \n   v1Ptr = v1Alloc.address( *find(v1.begin( ), v1.end( ), k) );  \n   // v1Ptr = v1Alloc.address( k );  \n   cout << \"The integer addressed by v1Ptr has a value of: \"  \n        << \"*v1Ptr = \" << *v1Ptr << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe original vector v1 is:  \n ( 2 4 6 8 10 12 14 ).  \nThe integer addressed by v1Ptr has a value of: *v1Ptr = 8.  \n```  \n  \n##  <a name=\"allocator__allocate\"></a>  allocator::allocate  \n Allocates a block of memory large enough to store at least some specified number of elements.  \n  \n```  \npointer allocate(size_type count, const void* _Hint);\n```  \n  \n### Parameters  \n ` count`  \n The number of elements for which sufficient storage is to be allocated.  \n  \n *_Hint*  \n A const pointer that may assist the allocator object satisfy the request for storage by locating the address of an object allocated prior to the request.  \n  \n### Return Value  \n A pointer to the allocated object or null if memory was not allocated.  \n  \n### Remarks  \n The member function allocates storage for an array of count elements of type **Type**, by calling operator new( ` count`). It returns a pointer to the allocated object. The hint argument helps some allocators in improving locality of reference; a valid choice is the address of an object earlier allocated by the same allocator object and not yet deallocated. To supply no hint, use a null pointer argument instead.  \n  \n### Example  \n  \n```cpp  \n// allocator_allocate.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   allocator<int> v1Alloc;    \n   allocator<int>::pointer v1aPtr;    \n   v1aPtr = v1Alloc.allocate ( 10 );  \n  \n   int i;  \n   for ( i = 0 ; i < 10 ; i++ )  \n   {  \n      v1aPtr[ i ] = i;  \n   }  \n  \n   for ( i = 0 ; i < 10 ; i++ )  \n   {  \n      cout << v1aPtr[ i ] << \" \";  \n   }  \n   cout << endl;    \n   v1Alloc.deallocate( v1aPtr, 10 );  \n}  \n```  \n  \n```Output  \n0 1 2 3 4 5 6 7 8 9   \n```  \n  \n##  <a name=\"allocator__allocator\"></a>  allocator::allocator  \n Constructors used to create allocator objects.  \n  \n```  \nallocator();\nallocator(const allocator<Type>& right);\ntemplate <class Other>  \nallocator(const allocator<Other>& right);\n```  \n  \n### Parameters  \n ` right`  \n The allocator object to be copied.  \n  \n### Remarks  \n The constructor does nothing. In general, however, an allocator object constructed from another allocator object should compare equal to it and permit intermixing of object allocation and freeing between the two allocator objects.  \n  \n### Example  \n  \n```cpp  \n// allocator_allocator.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nclass Int {  \npublic:  \n   Int( int i )   \n   {  \n      cout << \"Constructing \" << ( void* )this  << endl;   \n      x = i;  \n      bIsConstructed = true;  \n   };  \n   ~Int( )   \n   {  \n      cout << \"Destructing \" << ( void* )this << endl;   \n      bIsConstructed = false;  \n   };  \n   Int &operator++( )   \n   {  \n      x++;  \n      return *this;  \n   };  \n   int x;  \nprivate:  \n   bool bIsConstructed;  \n};  \n  \nint main( )   \n{  \n   allocator<double> Alloc;  \n   vector <Int>:: allocator_type v1Alloc;  \n  \n   allocator<double> cAlloc(Alloc);   \n   allocator<Int> cv1Alloc(v1Alloc);  \n  \n   if ( cv1Alloc == v1Alloc )  \n      cout << \"The allocator objects cv1Alloc & v1Alloc are equal.\"  \n           << endl;  \n   else  \n      cout << \"The allocator objects cv1Alloc & v1Alloc are not equal.\"  \n           << endl;  \n  \n   if ( cAlloc == Alloc )  \n      cout << \"The allocator objects cAlloc & Alloc are equal.\"  \n           << endl;  \n   else  \n      cout << \"The allocator objects cAlloc & Alloc are not equal.\"  \n           << endl;  \n}  \n```  \n  \n```Output  \nThe allocator objects cv1Alloc & v1Alloc are equal.  \nThe allocator objects cAlloc & Alloc are equal.  \n```  \n  \n##  <a name=\"allocator__const_pointer\"></a>  allocator::const_pointer  \n A type that provides a constant pointer to the type of object managed by the allocator.  \n  \n```  \ntypedef const value_type *const_pointer;  \n```  \n  \n### Remarks  \n The pointer type describes an object **ptr** that can designate, through the expression **\\*ptr**, any const object that an object of template class allocator can allocate.  \n  \n### Example  \n  \n```cpp  \n// allocator_const_ptr.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   vector <int> v1;  \n   vector <int>::iterator v1Iter;  \n   vector <int>:: allocator_type v1Alloc;  \n  \n   int i;  \n   for ( i = 1 ; i <= 7 ; i++ )  \n   {  \n      v1.push_back( i * 2 );  \n   }  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ; v1Iter++ )  \n      cout << *v1Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   allocator<int>::const_pointer v1Ptr;  \n   const int k = 10;  \n   v1Ptr = v1Alloc.address( k );  \n  \n   cout << \"The integer's address found has a value of: \"  \n        << *v1Ptr << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe original vector v1 is:  \n ( 2 4 6 8 10 12 14 ).  \nThe integer's address found has a value of: 10.  \n```  \n  \n##  <a name=\"allocator__const_reference\"></a>  allocator::const_reference  \n A type that provides a constant reference to type of object managed by the allocator.  \n  \n```  \ntypedef const value_type& const_reference;  \n```  \n  \n### Remarks  \n The reference type describes an object that can designate any const object that an object of template class allocator can allocate.  \n  \n### Example  \n  \n```cpp  \n// allocator_const_ref.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   vector <double> v;  \n   vector <double> ::iterator vIter, vfIter;  \n   vector <double> :: allocator_type vAlloc;  \n  \n   int j;  \n   for ( j = 1 ; j <= 7 ; j++ )  \n   {  \n      v.push_back( 100.0 * j );  \n   }  \n  \n   cout << \"The original vector v is:\\n ( \" ;  \n   for ( vIter = v.begin( ) ; vIter != v.end( ) ; vIter++ )  \n      cout << *vIter << \" \";  \n   cout << \").\" << endl;  \n  \n   vfIter = v.begin( );  \n   allocator<double>::const_reference vcref =*vfIter;  \n   cout << \"The value of the element referred to by vref is: \"  \n        << vcref << \",\\n the first element in the vector.\" << endl;  \n  \n   // const references can have their elements modified,  \n   // so the following would generate an error:  \n   // vcref = 150;  \n   // but the value of the first element could be modified through  \n   // its nonconst iterator and the const reference would remain valid  \n *vfIter = 175;  \n   cout << \"The value of the element referred to by vcref,\"  \n        <<\"\\n after nofication through its nonconst iterator, is: \"  \n        << vcref << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe original vector v is:  \n ( 100 200 300 400 500 600 700 ).  \nThe value of the element referred to by vref is: 100,  \n the first element in the vector.  \nThe value of the element referred to by vcref,  \n after nofication through its nonconst iterator, is: 175.  \n```  \n  \n##  <a name=\"allocator__construct\"></a>  allocator::construct  \n Constructs a specific type of object at a specified address that is initialized with a specified value.  \n  \n```  \nvoid construct(pointer ptr, const Type& val);\nvoid construct(pointer ptr, Type&& val);\ntemplate <class _Other>  \nvoid construct(pointer ptr, _Other&&...   val);\n```  \n  \n### Parameters  \n ` ptr`  \n A pointer to the location where the object is to be constructed.  \n  \n ` val`  \n The value with which the object being constructed is to be initialized.  \n  \n### Remarks  \n The first member function is equivalent to **new** ( ( `void` \\*) ` ptr` ) **Type** ( ` val` ).  \n  \n### Example  \n  \n```cpp  \n// allocator_construct.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <algorithm>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   vector <int> v1;  \n   vector <int>::iterator v1Iter;  \n   vector <int>:: allocator_type v1Alloc;  \n  \n   int i;  \n   for ( i = 1 ; i <= 7 ; i++ )  \n   {  \n      v1.push_back( 3 * i );  \n   }  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ; v1Iter++ )  \n      cout << *v1Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   allocator<int>::pointer v1PtrA;  \n   int kA = 6, kB = 7;  \n   v1PtrA = v1Alloc.address( *find( v1.begin( ), v1.end( ), kA ) );  \n   v1Alloc.destroy ( v1PtrA );  \n   v1Alloc.construct ( v1PtrA , kB );  \n  \n   cout << \"The modified vector v1 is:\\n ( \" ;  \n   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ; v1Iter++ )  \n      cout << *v1Iter << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nThe original vector v1 is:  \n ( 3 6 9 12 15 18 21 ).  \nThe modified vector v1 is:  \n ( 3 7 9 12 15 18 21 ).  \n```  \n  \n##  <a name=\"allocator__deallocate\"></a>  allocator::deallocate  \n Frees a specified number of objects from storage beginning at a specified position.  \n  \n```  \nvoid deallocate(pointer ptr, size_type count);\n```  \n  \n### Parameters  \n ` ptr`  \n A pointer to the first object to be deallocated from storage.  \n  \n ` count`  \n The number of objects to be deallocated from storage.  \n  \n### Remarks  \n The member function frees storage for the array of count objects of type **Type** beginning at ` ptr`, by calling `operator delete`( ` ptr`). The pointer ` ptr` must have been returned earlier by a call to [allocate](#allocator__allocate) for an allocator object that compares equal to **\\*this**, allocating an array object of the same size and type. `deallocate` never throws an exception.  \n  \n### Example  \n  For an example using the member function, see [allocator::allocate](#allocator__allocate).  \n  \n##  <a name=\"allocator__destroy\"></a>  allocator::destroy  \n Calls an objects destructor without deallocating the memory where the object was stored.  \n  \n```  \nvoid destroy(pointer ptr);\n```  \n  \n### Parameters  \n ` ptr`  \n A pointer designating the address of the object to be destroyed.  \n  \n### Remarks  \n The member function destroys the object designated by ` ptr`, by calling the destructor ` ptr` -> **Type**:: **~Type**.  \n  \n### Example  \n  \n```cpp  \n// allocator_destroy.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <algorithm>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   vector <int> v1;  \n   vector <int>::iterator v1Iter;  \n   vector <int>:: allocator_type v1Alloc;  \n  \n   int i;  \n   for ( i = 1 ; i <= 7 ; i++ )  \n   {  \n      v1.push_back( 2 * i );  \n   }  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ; v1Iter++ )  \n      cout << *v1Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   allocator<int>::pointer v1PtrA;  \n   int kA = 12, kB = -99;  \n   v1PtrA = v1Alloc.address( *find(v1.begin( ), v1.end( ), kA) );  \n   v1Alloc.destroy ( v1PtrA );  \n   v1Alloc.construct ( v1PtrA , kB );  \n  \n   cout << \"The modified vector v1 is:\\n ( \" ;  \n   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ; v1Iter++ )  \n      cout << *v1Iter << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nThe original vector v1 is:  \n ( 2 4 6 8 10 12 14 ).  \nThe modified vector v1 is:  \n ( 2 4 6 8 10 -99 14 ).  \n```  \n  \n##  <a name=\"allocator__difference_type\"></a>  allocator::difference_type  \n A signed integral type that can represent the difference between values of pointers to the type of object managed by the allocator.  \n  \n```  \ntypedef ptrdiff_t difference_type;  \n```  \n  \n### Remarks  \n The signed integer type describes an object that can represent the difference between the addresses of any two elements in a sequence that an object of template class allocator can allocate.  \n  \n### Example  \n  \n```cpp  \n// allocator_diff_type.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   vector <int> v1;  \n   vector <int>::iterator v1Iter;  \n   vector <int>:: allocator_type v1Alloc;  \n  \n   int i;  \n   for ( i = 0 ; i <= 7 ; i++ )  \n   {  \n      v1.push_back( i * 2 );  \n   }  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ; v1Iter++ )  \n      cout << *v1Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   allocator<int>::const_pointer v1PtrA, v1PtrB;  \n   const int kA = 4, kB =12;  \n   v1PtrA = v1Alloc.address( kA );  \n   v1PtrB = v1Alloc.address( kB );  \n   allocator<int>::difference_type v1diff = *v1PtrB - *v1PtrA;  \n  \n   cout << \"Pointer v1PtrA addresses \" << *v1PtrA << \".\" << endl;  \n   cout << \"Pointer v1PtrB addresses \" << *v1PtrB <<  \".\" << endl;  \n   cout << \"The difference between the integer's addresses is: \"  \n        << v1diff << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe original vector v1 is:  \n ( 0 2 4 6 8 10 12 14 ).  \nPointer v1PtrA addresses 4.  \nPointer v1PtrB addresses 12.  \nThe difference between the integer's addresses is: 8.  \n```  \n  \n##  <a name=\"allocator__max_size\"></a>  allocator::max_size  \n Returns the number of elements of type **Type** that could be allocated by an object of class allocator before the free memory is used up.  \n  \n```  \nsize_type max_size() const;\n```  \n  \n### Return Value  \n The number of elements that could be allocated.  \n  \n### Example  \n  \n```cpp  \n// allocator_max_size.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   vector <int> v1;  \n   vector <int>::iterator v1Iter;  \n   vector <int>:: allocator_type v1Alloc;  \n  \n   int i;  \n   for ( i = 1 ; i <= 7 ; i++ )  \n   {  \n      v1.push_back( i );  \n   }  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ; v1Iter++ )  \n      cout << *v1Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   vector <double> v2;  \n   vector <double> ::iterator v2Iter;  \n   vector <double> :: allocator_type v2Alloc;  \n   allocator<int>::size_type v1size;  \n   v1size = v1Alloc.max_size( );  \n  \n   cout << \"The number of integers that can be allocated before\\n\"  \n        << \" the free memory in the vector v1 is used up is: \"  \n        << v1size << \".\" << endl;  \n  \n   int ii;  \n   for ( ii = 1 ; ii <= 7 ; ii++ )  \n   {  \n      v2.push_back( ii * 10.0 );  \n   }  \n  \n   cout << \"The original vector v2 is:\\n ( \" ;  \n   for ( v2Iter = v2.begin( ) ; v2Iter != v2.end( ) ; v2Iter++ )  \n      cout << *v2Iter << \" \";  \n   cout << \").\" << endl;  \n   allocator<double>::size_type v2size;  \n   v2size = v2Alloc.max_size( );  \n  \n   cout << \"The number of doubles that can be allocated before\\n\"  \n        << \" the free memory in the vector v2 is used up is: \"  \n        << v2size << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"allocator__operator_eq\"></a>  allocator::operator=  \n Assigns one allocator object to another allocator object.  \n  \n```  \ntemplate <class Other>  \nallocator<Type>& operator=(const allocator<Other>& right);\n```  \n  \n### Parameters  \n ` right`  \n An allocator object to be assigned to another such object.  \n  \n### Return Value  \n A reference to the allocator object  \n  \n### Remarks  \n The template assignment operator does nothing. In general, however, an allocator object assigned to another allocator object should compare equal to it and permit intermixing of object allocation and freeing between the two allocator objects.  \n  \n### Example  \n  \n```cpp  \n// allocator_op_assign.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nclass Int {  \npublic:  \n   Int(int i)   \n   {  \n      cout << \"Constructing \" << ( void* )this  << endl;   \n      x = i;  \n      bIsConstructed = true;  \n   };  \n   ~Int( ) {  \n      cout << \"Destructing \" << ( void* )this << endl;   \n      bIsConstructed = false;  \n   };  \n   Int &operator++( )   \n   {  \n      x++;  \n      return *this;  \n   };  \n   int x;  \nprivate:  \n   bool bIsConstructed;  \n};  \n  \nint main( )   \n{  \n   allocator<Int> Alloc;  \n   allocator<Int> cAlloc ;  \n   cAlloc = Alloc;      \n}  \n```  \n  \n##  <a name=\"allocator__pointer\"></a>  allocator::pointer  \n A type that provides a pointer to the type of object managed by the allocator.  \n  \n```  \ntypedef value_type *pointer;  \n```  \n  \n### Remarks  \n The pointer type describes an object **ptr** that can designate, through the expression **\\*ptr**, any object that an object of template class allocator can allocate.  \n  \n### Example  \n  \n```cpp  \n// allocator_ptr.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   vector <int> v1;  \n   vector <int>::iterator v1Iter;  \n   vector <int>:: allocator_type v1Alloc;  \n  \n   int i;  \n   for ( i = 1 ; i <= 7 ; i++ )  \n   {  \n      v1.push_back( 3 * i );  \n   }  \n  \n   cout << \"The original vector v1 is:\\n ( \" ;  \n   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ; v1Iter++ )  \n      cout << *v1Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   allocator<int>::const_pointer v1Ptr;  \n   const int k = 12;  \n   v1Ptr = v1Alloc.address( k );  \n  \n   cout << \"The integer addressed by v1Ptr has a value of: \"  \n        << \"*v1Ptr = \" << *v1Ptr << \".\" << endl;     \n}  \n```  \n  \n```Output  \nThe original vector v1 is:  \n ( 3 6 9 12 15 18 21 ).  \nThe integer addressed by v1Ptr has a value of: *v1Ptr = 12.  \n```  \n  \n##  <a name=\"allocator__rebind\"></a>  allocator::rebind  \n A structure that enables an allocator for objects of one type to allocate storage for objects of another type.  \n```  \nstruct rebind {    typedef allocator<_Other> other ;    };  \n```  \n### Parameters  \n *other*  \n The type of element for which memory is being allocated.  \n  \n### Remarks  \n This structure is useful for allocating memory for type that differs from the element type of the container being implemented.  \n  \n The member template class defines the type other. Its sole purpose is to provide the type name **allocator**\\<_ **Other**>, given the type name **allocator**\\< **Type**>.  \n  \n For example, given an allocator object **al** of type **A**, you can allocate an object of type **_Other** with the expression:  \n  \n```  \nA::rebind<Other>::other(al).allocate(1, (Other *)0)  \n```  \n  \n Or, you can name its pointer type by writing the type:  \n  \n```  \nA::rebind<Other>::other::pointer  \n```  \n  \n### Example  \n  \n```cpp  \n// allocator_rebind.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <algorithm>  \n#include <vector>  \n  \nusing namespace std;  \n  \ntypedef vector<int>::allocator_type IntAlloc;  \nint main( )   \n{  \n   IntAlloc v1Iter;  \n   vector<int> v1;  \n  \n   IntAlloc::rebind<char>::other::pointer pszC =  \n      IntAlloc::rebind<char>::other(v1.get_allocator()).allocate(1, (void *)0);  \n  \n   int * pInt = v1Iter.allocate(10);  \n}  \n```  \n  \n##  <a name=\"allocator__reference\"></a>  allocator::reference  \n A type that provides a reference to the type of object managed by the allocator.  \n  \n```  \ntypedef value_type& reference;  \n```  \n  \n### Remarks  \n The reference type describes an object that can designate any object that an object of template class allocator can allocate.  \n  \n### Example  \n  \n```cpp  \n// allocator_reference.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )   \n{  \n   vector <double> v;  \n   vector <double> ::iterator vIter, vfIter;  \n   vector <double> :: allocator_type vAlloc;  \n  \n   int j;  \n   for ( j = 1 ; j <= 7 ; j++ )  \n   {  \n      v.push_back( 100.0 * j );  \n   }  \n  \n   cout << \"The original vector v is:\\n ( \" ;  \n   for ( vIter = v.begin( ) ; vIter != v.end( ) ; vIter++ )  \n      cout << *vIter << \" \";  \n   cout << \").\" << endl;  \n  \n   vfIter = v.begin( );  \n   allocator<double>::reference vref =*vfIter;  \n   cout << \"The value of the element referred to by vref is: \"  \n        << vref << \",\\n the first element in the vector.\" << endl;  \n  \n   // nonconst references can have their elements modified  \n   vref = 150;  \n   cout << \"The element referred to by vref after being modified is: \"  \n        << vref << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe original vector v is:  \n ( 100 200 300 400 500 600 700 ).  \nThe value of the element referred to by vref is: 100,  \n the first element in the vector.  \nThe element referred to by vref after being modified is: 150.  \n```  \n  \n##  <a name=\"allocator__size_type\"></a>  allocator::size_type  \n An unsigned integral type that can represent the length of any sequence that an object of template class allocator can allocate.  \n  \n```  \ntypedef size_t size_type;  \n```  \n  \n### Example  \n  \n```cpp  \n// allocator_size_type.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \n  \nusing namespace std;  \n  \nint main( )  \n{  \n   vector <double> v;  \n   vector <double> ::iterator vIter;  \n   vector <double> :: allocator_type vAlloc;  \n  \n   int j;  \n   for ( j = 1 ; j <= 7 ; j++ )  \n   {  \n      v.push_back( 100.0 * j );  \n   }  \n  \n   cout << \"The original vector v is:\\n ( \" ;  \n   for ( vIter = v.begin( ) ; vIter != v.end( ) ; vIter++ )  \n      cout << *vIter << \" \";  \n   cout << \").\" << endl;  \n  \n   allocator<double>::size_type vsize;  \n   vsize = vAlloc.max_size( );  \n  \n   cout << \"The number of doubles that can be allocated before\\n\"  \n        << \" the free memory in the vector v is used up is: \"  \n        << vsize << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"allocator__value_type\"></a>  allocator::value_type  \n A type that is managed by the allocator.  \n  \n```  \ntypedef Type value_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter **Type**.  \n  \n### Example  \n  \n```cpp  \n// allocator_value_type.cpp  \n// compile with: /EHsc  \n#include <memory>  \n#include <iostream>  \n#include <vector>  \nusing namespace std;  \n  \nint main( )   \n{  \n   vector <double> v;  \n   vector <double> ::iterator vIter, vfIter;  \n   vector <double> :: allocator_type vAlloc;  \n  \n   int j;  \n   for ( j = 1 ; j <= 7 ; j++ )  \n   {  \n      v.push_back( 100.0 * j );  \n   }  \n  \n   cout << \"The original vector v is:\\n ( \" ;  \n   for ( vIter = v.begin( ) ; vIter != v.end( ) ; vIter++ )  \n      cout << *vIter << \" \";  \n   cout << \").\" << endl;  \n  \n   vfIter = v.begin( );  \n   allocator<double>::value_type vecVal = 150.0;  \n *vfIter = vecVal;  \n   cout << \"The value of the element addressed by vfIter is: \"  \n        << *vfIter << \",\\n the first element in the vector.\" << endl;  \n  \n   cout << \"The modified vector v is:\\n ( \" ;  \n   for ( vIter = v.begin( ) ; vIter != v.end( ) ; vIter++ )  \n      cout << *vIter << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nThe original vector v is:  \n ( 100 200 300 400 500 600 700 ).  \nThe value of the element addressed by vfIter is: 150,  \n the first element in the vector.  \nThe modified vector v is:  \n ( 150 200 300 400 500 600 700 ).  \n```  \n  \n## See Also  \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)\n\n"}