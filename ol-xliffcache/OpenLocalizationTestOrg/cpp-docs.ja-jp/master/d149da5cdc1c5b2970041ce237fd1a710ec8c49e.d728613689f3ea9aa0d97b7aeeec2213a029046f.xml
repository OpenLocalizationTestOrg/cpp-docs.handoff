{"nodes":[{"pos":[12,54],"content":"Run-Time Library Behavior | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Run-Time Library Behavior | Microsoft Docs","pos":[0,42]}]},{"content":"Run-Time Library Behavior","pos":[902,927]},{"content":"The C/C++ run-time library code performs the DLL startup sequence, eliminating the need to link with a separate module as was necessary in Windows 3.x.","pos":[928,1079]},{"content":"Included in the C/C++ run-time library code is the DLL entry-point function called <bpt id=\"p1\">**</bpt>_DllMainCRTStartup<ept id=\"p1\">**</ept>.","pos":[1080,1186],"source":" Included in the C/C++ run-time library code is the DLL entry-point function called **_DllMainCRTStartup**."},{"content":"The <bpt id=\"p1\">**</bpt>_DllMainCRTStartup<ept id=\"p1\">**</ept> function does several things, including calling <bpt id=\"p2\">**</bpt>_CRT_INIT<ept id=\"p2\">**</ept>, which initializes the C/C++ run-time library and invokes C++ constructors on static, non-local variables.","pos":[1187,1382],"source":" The **_DllMainCRTStartup** function does several things, including calling **_CRT_INIT**, which initializes the C/C++ run-time library and invokes C++ constructors on static, non-local variables."},{"content":"Without this function, the run-time library would be left in an uninitialized state.","pos":[1383,1467]},{"content":"<bpt id=\"p1\">**</bpt>_CRT_INIT<ept id=\"p1\">**</ept> is available for both a statically linked CRT or linking to the CRT DLL Msvcr90.dll, from a user DLL.","pos":[1468,1583],"source":"**_CRT_INIT** is available for both a statically linked CRT or linking to the CRT DLL Msvcr90.dll, from a user DLL."},{"content":"While it is possible to specify another entry-point function using the /ENTRY: linker option, it is not recommended because your entry-point function would have to duplicate everything that <bpt id=\"p1\">**</bpt>_DllMainCRTStartup<ept id=\"p1\">**</ept> does.","pos":[1590,1808],"source":"While it is possible to specify another entry-point function using the /ENTRY: linker option, it is not recommended because your entry-point function would have to duplicate everything that **_DllMainCRTStartup** does."},{"content":"When building DLLs in Visual C++, <bpt id=\"p1\">**</bpt>_DllMainCRTStartup<ept id=\"p1\">**</ept> is linked in automatically and you do not need to specify an entry-point function using the /ENTRY: linker option.","pos":[1809,1980],"source":" When building DLLs in Visual C++, **_DllMainCRTStartup** is linked in automatically and you do not need to specify an entry-point function using the /ENTRY: linker option."},{"content":"In addition to initializing the C run-time library, <bpt id=\"p1\">**</bpt>_DllMainCRTStartup<ept id=\"p1\">**</ept> calls a function called <ph id=\"ph1\">`DllMain`</ph>.","pos":[1987,2096],"source":"In addition to initializing the C run-time library, **_DllMainCRTStartup** calls a function called `DllMain`."},{"content":"Depending on the kind of DLL you are building, Visual C++ provides <ph id=\"ph1\">`DllMain`</ph> for you and it gets linked in so that <bpt id=\"p1\">**</bpt>_DllMainCRTStartup<ept id=\"p1\">**</ept> always has something to call.","pos":[2097,2264],"source":" Depending on the kind of DLL you are building, Visual C++ provides `DllMain` for you and it gets linked in so that **_DllMainCRTStartup** always has something to call."},{"content":"In this way, if you do not need to initialize your DLL, there is nothing special you have to do when building your DLL.","pos":[2265,2384]},{"content":"If you need to initialize your DLL, where you add your code depends on the kind of DLL you are writing.","pos":[2385,2488]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Initializing a DLL<ept id=\"p1\">](../build/initializing-a-dll.md)</ept>.","pos":[2489,2568],"source":" For more information, see [Initializing a DLL](../build/initializing-a-dll.md)."},{"content":"The C/C++ run-time library code calls constructors and destructors on static, non-local variables.","pos":[2575,2673]},{"content":"For example, in the following DLL source code, <ph id=\"ph1\">`Equus`</ph> and <ph id=\"ph2\">`Sugar`</ph> are two static, non-local objects of class <ph id=\"ph3\">`CHorse`</ph>, defined in Horses.h.","pos":[2674,2814],"source":" For example, in the following DLL source code, `Equus` and `Sugar` are two static, non-local objects of class `CHorse`, defined in Horses.h."},{"content":"There is no function in source code that contains calls to a constructor function for <ph id=\"ph1\">`CHorse`</ph> or to the destructor function because these objects are defined outside of any function.","pos":[2815,2998],"source":" There is no function in source code that contains calls to a constructor function for `CHorse` or to the destructor function because these objects are defined outside of any function."},{"content":"Therefore, calls to these constructors and destructors must be performed by the run-time code.","pos":[2999,3093]},{"content":"The run-time library code for applications also performs this function.","pos":[3094,3165]},{"content":"Each time a new process attempts to use the DLL, the operating system creates a separate copy of the DLL's data: this is called process attach.","pos":[3444,3587]},{"content":"The run-time library code for the DLL calls the constructors for all of the global objects, if any, and then calls the <ph id=\"ph1\">`DllMain`</ph> function with process attach selected.","pos":[3588,3755],"source":" The run-time library code for the DLL calls the constructors for all of the global objects, if any, and then calls the `DllMain` function with process attach selected."},{"content":"The opposite situation is process detach: the run-time library code calls <ph id=\"ph1\">`DllMain`</ph> with process detach selected and then calls a list of termination functions, including <ph id=\"ph2\">`atexit`</ph> functions, destructors for the global objects, and destructors for the static objects.","pos":[3756,4022],"source":" The opposite situation is process detach: the run-time library code calls `DllMain` with process detach selected and then calls a list of termination functions, including `atexit` functions, destructors for the global objects, and destructors for the static objects."},{"content":"Note that the order of events in process attach is the reverse of that in process detach.","pos":[4023,4112]},{"content":"The run-time library code is also called during thread attach and thread detach, but the run-time code does no initialization or termination on its own.","pos":[4119,4271]},{"content":"What do you want to do?","pos":[4280,4303]},{"content":"Initialize a DLL","pos":[4314,4330]},{"content":"See Also","pos":[4372,4380]},{"content":"DLLs in Visual C++","pos":[4385,4403]}],"content":"---\ntitle: \"Run-Time Library Behavior | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"_DllMainCRTStartup\"\n  - \"CRT_INIT\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"DLLs [C++], entry point function\"\n  - \"process detach [C++]\"\n  - \"process attach [C++]\"\n  - \"DLLs [C++], run-time library behavior\"\n  - \"DllMain function\"\n  - \"_CRT_INIT macro\"\n  - \"_DllMainCRTStartup method\"\n  - \"run-time [C++], DLL startup sequence\"\n  - \"DLLs [C++], startup sequence\"\nms.assetid: e06f24ab-6ca5-44ef-9857-aed0c6f049f2\ncaps.latest.revision: 8\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Run-Time Library Behavior\nThe C/C++ run-time library code performs the DLL startup sequence, eliminating the need to link with a separate module as was necessary in Windows 3.x. Included in the C/C++ run-time library code is the DLL entry-point function called **_DllMainCRTStartup**. The **_DllMainCRTStartup** function does several things, including calling **_CRT_INIT**, which initializes the C/C++ run-time library and invokes C++ constructors on static, non-local variables. Without this function, the run-time library would be left in an uninitialized state. **_CRT_INIT** is available for both a statically linked CRT or linking to the CRT DLL Msvcr90.dll, from a user DLL.  \n  \n While it is possible to specify another entry-point function using the /ENTRY: linker option, it is not recommended because your entry-point function would have to duplicate everything that **_DllMainCRTStartup** does. When building DLLs in Visual C++, **_DllMainCRTStartup** is linked in automatically and you do not need to specify an entry-point function using the /ENTRY: linker option.  \n  \n In addition to initializing the C run-time library, **_DllMainCRTStartup** calls a function called `DllMain`. Depending on the kind of DLL you are building, Visual C++ provides `DllMain` for you and it gets linked in so that **_DllMainCRTStartup** always has something to call. In this way, if you do not need to initialize your DLL, there is nothing special you have to do when building your DLL. If you need to initialize your DLL, where you add your code depends on the kind of DLL you are writing. For more information, see [Initializing a DLL](../build/initializing-a-dll.md).  \n  \n The C/C++ run-time library code calls constructors and destructors on static, non-local variables. For example, in the following DLL source code, `Equus` and `Sugar` are two static, non-local objects of class `CHorse`, defined in Horses.h. There is no function in source code that contains calls to a constructor function for `CHorse` or to the destructor function because these objects are defined outside of any function. Therefore, calls to these constructors and destructors must be performed by the run-time code. The run-time library code for applications also performs this function.  \n  \n```  \n#include \"horses.h\"  \n  \nCHorse  Equus( ARABIAN, MALE );  \nCHorse  Sugar( THOROUGHBRED, FEMALE );  \n  \nBOOL    WINAPI   DllMain (HANDLE hInst,   \n                            ULONG ul_reason_for_call,  \n                            LPVOID lpReserved)  \n...  \n```  \n  \n Each time a new process attempts to use the DLL, the operating system creates a separate copy of the DLL's data: this is called process attach. The run-time library code for the DLL calls the constructors for all of the global objects, if any, and then calls the `DllMain` function with process attach selected. The opposite situation is process detach: the run-time library code calls `DllMain` with process detach selected and then calls a list of termination functions, including `atexit` functions, destructors for the global objects, and destructors for the static objects. Note that the order of events in process attach is the reverse of that in process detach.  \n  \n The run-time library code is also called during thread attach and thread detach, but the run-time code does no initialization or termination on its own.  \n  \n## What do you want to do?  \n  \n-   [Initialize a DLL](../build/initializing-a-dll.md)  \n  \n## See Also  \n [DLLs in Visual C++](../build/dlls-in-visual-cpp.md)"}