{"nodes":[{"pos":[12,39],"content":"Allocators | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Allocators | Microsoft Docs","pos":[0,27]}]},{"content":"Allocators","pos":[597,607]},{"content":"Allocators are used by the Standard Template Library to handle the allocation and deallocation of elements stored in containers.","pos":[608,736]},{"content":"All STL containers except std::array have a template parameter of type <ph id=\"ph1\">`allocator&lt;Type&gt;`</ph>, where <ph id=\"ph2\">`Type`</ph> represents the type of the container element.","pos":[737,885],"source":" All STL containers except std::array have a template parameter of type `allocator<Type>`, where `Type` represents the type of the container element."},{"content":"For example, the vector class is declared as follows:","pos":[886,939]},{"content":"The Standard Template Library provides a default implementation for an allocator.","pos":[1051,1132]},{"content":"In C++11 and later, the default allocator is updated to expose a smaller interface; the new allocator is called a <bpt id=\"p1\">*</bpt>minimal allocator<ept id=\"p1\">*</ept>.","pos":[1133,1267],"source":" In C++11 and later, the default allocator is updated to expose a smaller interface; the new allocator is called a *minimal allocator*."},{"content":"In particular, the minimal allocator's <ph id=\"ph1\">`construct()`</ph> member supports move semantics, which can greatly improve performance.","pos":[1268,1391],"source":" In particular, the minimal allocator's `construct()` member supports move semantics, which can greatly improve performance."},{"content":"In most cases, this default allocator should be sufficient.","pos":[1392,1451]},{"content":"In C++11 all the Standard Library types and functions that take an allocator type parameter support the minimal allocator interface, including <ph id=\"ph1\">`std::function`</ph>, <ph id=\"ph2\">`shared_ptr, allocate_shared()`</ph>, and <ph id=\"ph3\">`basic_string`</ph>.","pos":[1452,1664],"source":" In C++11 all the Standard Library types and functions that take an allocator type parameter support the minimal allocator interface, including `std::function`, `shared_ptr, allocate_shared()`, and `basic_string`."},{"content":"For more information on the default allocator, see <bpt id=\"p1\">[</bpt>allocator Class<ept id=\"p1\">](../standard-library/allocator-class.md)</ept>.","pos":[1666,1775],"source":"  For more information on the default allocator, see [allocator Class](../standard-library/allocator-class.md)."},{"content":"Writing Your Own Allocator (C++11)","pos":[1784,1818]},{"content":"The default allocator uses <ph id=\"ph1\">`new`</ph> and <ph id=\"ph2\">`delete`</ph> to allocate and deallocate memory.","pos":[1822,1902],"source":"The default allocator uses `new` and `delete` to allocate and deallocate memory."},{"content":"If you want to use a different method of memory allocation, such as using shared memory, then you must create your own allocator.","pos":[1903,2032]},{"content":"If you are targeting C++11 and you need to write a new custom allocator, make it a minimal allocator if possible.","pos":[2033,2146]},{"content":"Even if you have already implemented an old-style allocator, consider modifying it to be a <bpt id=\"p1\">*</bpt>minimal allocator<ept id=\"p1\">*</ept> in order to take advantage of the more efficient <ph id=\"ph1\">`construct()`</ph> method that will be provided for you automatically.","pos":[2147,2372],"source":" Even if you have already implemented an old-style allocator, consider modifying it to be a *minimal allocator* in order to take advantage of the more efficient `construct()` method that will be provided for you automatically."},{"content":"A minimal allocator requires much less boilerplate and enable you to focus on the <ph id=\"ph1\">`allocate`</ph> and <ph id=\"ph2\">`deallocate`</ph> member functions which do all of the work.","pos":[2379,2531],"source":"A minimal allocator requires much less boilerplate and enable you to focus on the `allocate` and `deallocate` member functions which do all of the work."},{"content":"When creating a minimal allocator, do not implement any members except the ones shown in the example below:","pos":[2532,2639]},{"content":"a converting copy constructor (see example)","pos":[2649,2692]},{"content":"operator==","pos":[2702,2712]},{"content":"operator!=","pos":[2722,2732]},{"content":"allocate","pos":[2742,2750]},{"content":"deallocate","pos":[2760,2770]},{"pos":[2777,2961],"content":"The C++11 default <ph id=\"ph1\">`construct()`</ph> member that will be provided for you does perfect forwarding and enables move semantics; it is much more efficient in many cases than the older version.","source":"The C++11 default `construct()` member that will be provided for you does perfect forwarding and enables move semantics; it is much more efficient in many cases than the older version."},{"pos":[2969,3275],"content":"[!WARNING]\n At compile time, the STL uses the allocator_traits class to detect which members you have explicitly provided and provides a default implementation for any members that are not present. Do not interfere with this mechanism by providing a specialization of allocator_traits for your allocator!","leadings":["","> "],"nodes":[{"content":" At compile time, the STL uses the allocator_traits class to detect which members you have explicitly provided and provides a default implementation for any members that are not present. Do not interfere with this mechanism by providing a specialization of allocator_traits for your allocator!","pos":[11,304],"nodes":[{"content":"At compile time, the STL uses the allocator_traits class to detect which members you have explicitly provided and provides a default implementation for any members that are not present.","pos":[1,186]},{"content":"Do not interfere with this mechanism by providing a specialization of allocator_traits for your allocator!","pos":[187,293]}]}]},{"content":"The following example shows a minimal implementation of an allocator that uses <ph id=\"ph1\">`malloc`</ph> and <ph id=\"ph2\">`free`</ph>.","pos":[3282,3381],"source":"The following example shows a minimal implementation of an allocator that uses `malloc` and `free`."},{"content":"Note the use of the new exception type <ph id=\"ph1\">`std::bad_array_new_length`</ph> which is thrown if the array size is less than zero or greater than the maximum allowed size.","pos":[3382,3542],"source":" Note the use of the new exception type `std::bad_array_new_length` which is thrown if the array size is less than zero or greater than the maximum allowed size."},{"content":"Writing Your Own Allocator (C++03)","pos":[4779,4813]},{"content":"In C++03, any allocator used with STL containers must implement the following type definitions:","pos":[4817,4912]},{"content":"In addition, any allocator used with STL containers must implement the following methods:","pos":[5060,5149]},{"content":"Constructor","pos":[5170,5181]},{"content":"Copy constructor","pos":[5199,5215]},{"content":"Destructor","pos":[5230,5240]},{"pos":[5331,5453],"content":"For more information on these type definitions and methods, see <bpt id=\"p1\">[</bpt>allocator Class<ept id=\"p1\">](../standard-library/allocator-class.md)</ept>.","source":"For more information on these type definitions and methods, see [allocator Class](../standard-library/allocator-class.md)."},{"content":"See Also","pos":[5462,5470]},{"content":"C++ Standard Library Reference","pos":[5475,5505]}],"content":"---\ntitle: \"Allocators | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"allocators\"\n  - \"Standard C++ Library, allocators\"\nms.assetid: ac95023b-9e7d-49f5-861a-bf7a9a340746\ncaps.latest.revision: 8\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Allocators\nAllocators are used by the Standard Template Library to handle the allocation and deallocation of elements stored in containers. All STL containers except std::array have a template parameter of type `allocator<Type>`, where `Type` represents the type of the container element. For example, the vector class is declared as follows:  \n  \n```  \ntemplate <  \n    class Type,  \n    class Allocator = allocator<Type>  \n>  \nclass vector  \n```  \n  \n The Standard Template Library provides a default implementation for an allocator. In C++11 and later, the default allocator is updated to expose a smaller interface; the new allocator is called a *minimal allocator*. In particular, the minimal allocator's `construct()` member supports move semantics, which can greatly improve performance. In most cases, this default allocator should be sufficient. In C++11 all the Standard Library types and functions that take an allocator type parameter support the minimal allocator interface, including `std::function`, `shared_ptr, allocate_shared()`, and `basic_string`.  For more information on the default allocator, see [allocator Class](../standard-library/allocator-class.md).  \n  \n## Writing Your Own Allocator (C++11)  \n The default allocator uses `new` and `delete` to allocate and deallocate memory. If you want to use a different method of memory allocation, such as using shared memory, then you must create your own allocator. If you are targeting C++11 and you need to write a new custom allocator, make it a minimal allocator if possible. Even if you have already implemented an old-style allocator, consider modifying it to be a *minimal allocator* in order to take advantage of the more efficient `construct()` method that will be provided for you automatically.  \n  \n A minimal allocator requires much less boilerplate and enable you to focus on the `allocate` and `deallocate` member functions which do all of the work. When creating a minimal allocator, do not implement any members except the ones shown in the example below:  \n  \n1.  a converting copy constructor (see example)  \n  \n2.  operator==  \n  \n3.  operator!=  \n  \n4.  allocate  \n  \n5.  deallocate  \n  \n The C++11 default `construct()` member that will be provided for you does perfect forwarding and enables move semantics; it is much more efficient in many cases than the older version.  \n  \n> [!WARNING]\n>  At compile time, the STL uses the allocator_traits class to detect which members you have explicitly provided and provides a default implementation for any members that are not present. Do not interfere with this mechanism by providing a specialization of allocator_traits for your allocator!  \n  \n The following example shows a minimal implementation of an allocator that uses `malloc` and `free`. Note the use of the new exception type `std::bad_array_new_length` which is thrown if the array size is less than zero or greater than the maximum allowed size.  \n  \n```  \n#pragma once  \n#include <stdlib.h> //size_t, malloc, free  \n#include <new> // bad_alloc, bad_array_new_length  \n#include <memory>  \ntemplate <class T>  \nstruct Mallocator  \n{  \n    typedef T value_type;  \n    Mallocator() noexcept {} //default ctor not required by STL  \n  \n    // A converting copy constructor:  \n    template<class U> Mallocator(const Mallocator<U>&) noexcept {}  \n    template<class U> bool operator==(const Mallocator<U>&) const noexcept  \n    {  \n        return true;  \n    }  \n    template<class U> bool operator!=(const Mallocator<U>&) const noexcept  \n    {  \n        return false;  \n    }  \n    T* allocate(const size_t n) const;  \n    void deallocate(T* const p, size_t) const noexcept;  \n};  \n  \ntemplate <class T>  \nT* Mallocator<T>::allocate(const size_t n) const  \n{  \n    if (n == 0)  \n    {  \n        return nullptr;  \n    }  \n    if (n > static_cast<size_t>(-1) / sizeof(T))  \n    {  \n        throw std::bad_array_new_length();  \n    }  \n    void* const pv = malloc(n * sizeof(T));  \n    if (!pv) { throw std::bad_alloc(); }  \n    return static_cast<T*>(pv);  \n}  \n  \ntemplate<class T>  \nvoid Mallocator<T>::deallocate(T * const p, size_t) const noexcept  \n{  \n    free(p);  \n}  \n```  \n  \n## Writing Your Own Allocator (C++03)  \n In C++03, any allocator used with STL containers must implement the following type definitions:  \n  \n|||  \n|-|-|  \n|`const_pointer`|`rebind`|  \n|`const_reference`|`reference`|  \n|`difference_type`|`size_type`|  \n|`pointer`|`value_type`|  \n  \n In addition, any allocator used with STL containers must implement the following methods:  \n  \n|||  \n|-|-|  \n|Constructor|`deallocate`|  \n|Copy constructor|`destroy`|  \n|Destructor|`max_size`|  \n|`address`|`operator==`|  \n|`allocate`|`operator!=`|  \n|`construct`||  \n  \n For more information on these type definitions and methods, see [allocator Class](../standard-library/allocator-class.md).  \n  \n## See Also  \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)\n\n\n\n\n"}