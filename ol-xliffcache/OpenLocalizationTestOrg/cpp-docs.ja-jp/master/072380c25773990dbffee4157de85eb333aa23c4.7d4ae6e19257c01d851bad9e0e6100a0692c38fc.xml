{"nodes":[{"pos":[12,51],"content":"Explicit Instantiation | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Explicit Instantiation | Microsoft Docs","pos":[0,39]}]},{"content":"Explicit Instantiation","pos":[680,702]},{"content":"You can use explicit instantiation to create an instantiation of a templated class or function without actually using it in your code.","pos":[703,837]},{"content":"Because this is useful when you are creating library (.lib) files that use templates for distribution, uninstantiated template definitions are not put into object (.obj) files.","pos":[838,1014]},{"pos":[1021,1099],"content":"This code explicitly instantiates <ph id=\"ph1\">`MyStack`</ph> for <ph id=\"ph2\">`int`</ph> variables and six items:","source":"This code explicitly instantiates `MyStack` for `int` variables and six items:"},{"content":"This statement creates an instantiation of <ph id=\"ph1\">`MyStack`</ph> without reserving any storage for an object.","pos":[1158,1255],"source":"This statement creates an instantiation of `MyStack` without reserving any storage for an object."},{"content":"Code is generated for all members.","pos":[1256,1290]},{"content":"The next line explicitly instantiates only the constructor member function:","pos":[1297,1372]},{"pos":[1442,1650],"content":"You can explicitly instantiate function templates by using a specific type argument to re-declare them, as shown in the example in <bpt id=\"p1\">[</bpt>Function Template Instantiation<ept id=\"p1\">](../cpp/function-template-instantiation.md)</ept>.","source":"You can explicitly instantiate function templates by using a specific type argument to re-declare them, as shown in the example in [Function Template Instantiation](../cpp/function-template-instantiation.md)."},{"content":"You can use the <ph id=\"ph1\">`extern`</ph> keyword to prevent the automatic instantiation of members.","pos":[1657,1740],"source":"You can use the `extern` keyword to prevent the automatic instantiation of members."},{"content":"For example:","pos":[1741,1753]},{"content":"Similarly, you can mark specific members as being external and not instantiated:","pos":[1819,1899]},{"content":"You can use the <ph id=\"ph1\">`extern`</ph> keyword to keep the compiler from generating the same instantiation code in more than one object module.","pos":[1976,2105],"source":"You can use the `extern` keyword to keep the compiler from generating the same instantiation code in more than one object module."},{"content":"You must instantiate the template function by using the specified explicit template parameters in at least one linked module if the function is called, or you will get a linker error when the program is built.","pos":[2106,2315]},{"pos":[2323,2559],"content":"[!NOTE]\n The `extern` keyword in the specialization only applies to member functions defined outside of the body of the class. Functions defined inside the class declaration are considered inline functions and are always instantiated.","leadings":["","> "],"nodes":[{"content":" The `extern` keyword in the specialization only applies to member functions defined outside of the body of the class. Functions defined inside the class declaration are considered inline functions and are always instantiated.","pos":[8,234],"nodes":[{"content":"The <ph id=\"ph1\">`extern`</ph> keyword in the specialization only applies to member functions defined outside of the body of the class.","pos":[1,118],"source":" The `extern` keyword in the specialization only applies to member functions defined outside of the body of the class."},{"content":"Functions defined inside the class declaration are considered inline functions and are always instantiated.","pos":[119,226]}]}]},{"content":"See Also","pos":[2568,2576]},{"content":"Function Templates","pos":[2581,2599]}],"content":"---\ntitle: \"Explicit Instantiation | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"templates, instantiation\"\n  - \"explicit instantiation\"\n  - \"instantiation, explicit\"\nms.assetid: 8b0d4e32-45a6-49d5-8041-1ebdd674410e\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Explicit Instantiation\nYou can use explicit instantiation to create an instantiation of a templated class or function without actually using it in your code. Because this is useful when you are creating library (.lib) files that use templates for distribution, uninstantiated template definitions are not put into object (.obj) files.  \n  \n This code explicitly instantiates `MyStack` for `int` variables and six items:  \n  \n```cpp  \ntemplate class MyStack<int, 6>;  \n```  \n  \n This statement creates an instantiation of `MyStack` without reserving any storage for an object. Code is generated for all members.  \n  \n The next line explicitly instantiates only the constructor member function:  \n  \n```cpp  \ntemplate MyStack<int, 6>::MyStack( void );  \n```  \n  \n You can explicitly instantiate function templates by using a specific type argument to re-declare them, as shown in the example in [Function Template Instantiation](../cpp/function-template-instantiation.md).  \n  \n You can use the `extern` keyword to prevent the automatic instantiation of members. For example:  \n  \n```cpp  \nextern template class MyStack<int, 6>;  \n```  \n  \n Similarly, you can mark specific members as being external and not instantiated:  \n  \n```cpp  \nextern template MyStack<int, 6>::MyStack( void );  \n```  \n  \n You can use the `extern` keyword to keep the compiler from generating the same instantiation code in more than one object module. You must instantiate the template function by using the specified explicit template parameters in at least one linked module if the function is called, or you will get a linker error when the program is built.  \n  \n> [!NOTE]\n>  The `extern` keyword in the specialization only applies to member functions defined outside of the body of the class. Functions defined inside the class declaration are considered inline functions and are always instantiated.  \n  \n## See Also  \n [Function Templates](../cpp/function-templates.md)"}