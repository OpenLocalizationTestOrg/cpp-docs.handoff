{"nodes":[{"pos":[12,59],"content":"Exception Handling Differences | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Exception Handling Differences | Microsoft Docs","pos":[0,47]}]},{"content":"Exception Handling Differences","pos":[822,852]},{"content":"The major difference between structured exception handling and C++ exception handling is that the C++ exception handling model deals in types, while the C structured exception handling model deals with exceptions of one type — specifically, <ph id=\"ph1\">`unsigned int`</ph>.","pos":[853,1109],"source":"The major difference between structured exception handling and C++ exception handling is that the C++ exception handling model deals in types, while the C structured exception handling model deals with exceptions of one type — specifically, `unsigned int`."},{"content":"That is, C exceptions are identified by an unsigned integer value, whereas C++ exceptions are identified by data type.","pos":[1110,1228]},{"content":"When an exception is raised in C, each possible handler executes a filter that examines the C exception context and determines whether to accept the exception, pass it to some other handler, or ignore it.","pos":[1229,1433]},{"content":"When an exception is thrown in C++, it may be of any type.","pos":[1434,1492]},{"content":"A second difference is that the C structured exception handling model is referred to as \"asynchronous\" in that exceptions occur secondary to the normal flow of control.","pos":[1499,1667]},{"content":"The C++ exception handling mechanism is fully \"synchronous,\" which means that exceptions occur only when they are thrown.","pos":[1668,1789]},{"content":"If a C exception is raised in a C++ program, it can be handled by a structured exception handler with its associated filter or by a C++ <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> handler, whichever is dynamically nearer to the exception context.","pos":[1796,2008],"source":"If a C exception is raised in a C++ program, it can be handled by a structured exception handler with its associated filter or by a C++ **catch** handler, whichever is dynamically nearer to the exception context."},{"content":"For example, the following C++ program raises a C exception inside a C++ <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> context:","pos":[2009,2098],"source":" For example, the following C++ program raises a C exception inside a C++ **try** context:"},{"content":"Example","pos":[2107,2114]},{"pos":[2676,2701],"content":"C Exception Wrapper Class"},{"content":"In a simple example like the above, the C exception can be caught only by an ellipsis (<bpt id=\"p1\">**</bpt>...<ept id=\"p1\">**</ept>) <bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> handler.","pos":[2705,2819],"source":"In a simple example like the above, the C exception can be caught only by an ellipsis (**...**) **catch** handler."},{"content":"No information about the type or nature of the exception is communicated to the handler.","pos":[2820,2908]},{"content":"While this method works, in some cases you may need to define a transformation between the two exception handling models so that each C exception is associated with a specific class.","pos":[2909,3091]},{"content":"To do this, you can define a C exception \"wrapper\" class, which can be used or derived from in order to attribute a specific class type to a C exception.","pos":[3092,3245]},{"content":"By doing so, each C exception can be handled by a C++ <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> handler more separately than in the preceding example.","pos":[3246,3364],"source":" By doing so, each C exception can be handled by a C++ **catch** handler more separately than in the preceding example."},{"content":"Your wrapper class might have an interface consisting of some member functions that determine the value of the exception, and that access the extended exception context information provided by the C exception model.","pos":[3371,3586]},{"content":"You might also want to define a default constructor and a constructor that accepts an <ph id=\"ph1\">`unsigned int`</ph> argument (to provide for the underlying C exception representation), and a bitwise copy constructor.","pos":[3587,3788],"source":" You might also want to define a default constructor and a constructor that accepts an `unsigned int` argument (to provide for the underlying C exception representation), and a bitwise copy constructor."},{"content":"The following is a possible implementation of a C exception wrapper class:","pos":[3789,3863]},{"content":"To use this class, you install a custom C exception translation function that is called by the internal exception handling mechanism each time a C exception is thrown.","pos":[4230,4397]},{"content":"Within your translation function, you can throw any typed exception (perhaps an <ph id=\"ph1\">`SE_Exception`</ph> type, or a class type derived from <ph id=\"ph2\">`SE_Exception`</ph>) that can be caught by an appropriate matching C++ <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> handler.","pos":[4398,4612],"source":" Within your translation function, you can throw any typed exception (perhaps an `SE_Exception` type, or a class type derived from `SE_Exception`) that can be caught by an appropriate matching C++ **catch** handler."},{"content":"The translation function can simply return, which indicates that it did not handle the exception.","pos":[4613,4710]},{"content":"If the translation function itself raises a C exception, <bpt id=\"p1\">[</bpt>terminate<ept id=\"p1\">](../c-runtime-library/reference/terminate-crt.md)</ept> is called.","pos":[4711,4839],"source":" If the translation function itself raises a C exception, [terminate](../c-runtime-library/reference/terminate-crt.md) is called."},{"content":"To specify a custom translation function, call the <bpt id=\"p1\">[</bpt>_set_se_translator<ept id=\"p1\">](../c-runtime-library/reference/set-se-translator.md)</ept> function with the name of your translation function as its single argument.","pos":[4846,5046],"source":"To specify a custom translation function, call the [_set_se_translator](../c-runtime-library/reference/set-se-translator.md) function with the name of your translation function as its single argument."},{"content":"The translation function that you write is called once for each function invocation on the stack that has <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> blocks.","pos":[5047,5168],"source":" The translation function that you write is called once for each function invocation on the stack that has **try** blocks."},{"content":"There is no default translation function; if you do not specify one by calling <ph id=\"ph1\">`_set_se_translator`</ph>, the C exception can only be caught by an ellipsis <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> handler.","pos":[5169,5338],"source":" There is no default translation function; if you do not specify one by calling `_set_se_translator`, the C exception can only be caught by an ellipsis **catch** handler."},{"content":"Example","pos":[5347,5354]},{"pos":[5358,5504],"content":"For example, the following code installs a custom translation function, and then raises a C exception that is wrapped by the <ph id=\"ph1\">`SE_Exception`</ph> class:","source":"For example, the following code installs a custom translation function, and then raises a C exception that is wrapped by the `SE_Exception` class:"},{"content":"See Also","pos":[6601,6609]},{"content":"Mixing C (Structured) and C++ Exceptions","pos":[6614,6654]}],"content":"---\ntitle: \"Exception Handling Differences | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"structured exception handling, vs. C++ exception handling\"\n  - \"structured exception handling, vs. unstructured\"\n  - \"exceptions, wrapper class\"\n  - \"C++ exception handling, vs. structured exception handling\"\n  - \"wrapper classes, C exception\"\nms.assetid: f21d1944-4810-468e-b02a-9f77da4138c9\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Exception Handling Differences\nThe major difference between structured exception handling and C++ exception handling is that the C++ exception handling model deals in types, while the C structured exception handling model deals with exceptions of one type — specifically, `unsigned int`. That is, C exceptions are identified by an unsigned integer value, whereas C++ exceptions are identified by data type. When an exception is raised in C, each possible handler executes a filter that examines the C exception context and determines whether to accept the exception, pass it to some other handler, or ignore it. When an exception is thrown in C++, it may be of any type.  \n  \n A second difference is that the C structured exception handling model is referred to as \"asynchronous\" in that exceptions occur secondary to the normal flow of control. The C++ exception handling mechanism is fully \"synchronous,\" which means that exceptions occur only when they are thrown.  \n  \n If a C exception is raised in a C++ program, it can be handled by a structured exception handler with its associated filter or by a C++ **catch** handler, whichever is dynamically nearer to the exception context. For example, the following C++ program raises a C exception inside a C++ **try** context:  \n  \n## Example  \n  \n```  \n// exceptions_Exception_Handling_Differences.cpp  \n// compile with: /EHa  \n#include <iostream>  \n  \nusing namespace std;  \nvoid SEHFunc( void );  \n  \nint main() {  \n   try {  \n      SEHFunc();  \n   }  \n   catch( ... ) {  \n      cout << \"Caught a C exception.\"<< endl;  \n   }  \n}  \n  \nvoid SEHFunc() {  \n   __try {  \n      int x, y = 0;  \n      x = 5 / y;  \n   }  \n   __finally {  \n      cout << \"In finally.\" << endl;  \n   }  \n}  \n```  \n  \n```Output  \nIn finally.  \nCaught a C exception.  \n```  \n  \n##  <a name=\"_core_c_exception_wrapper_class\"></a> C Exception Wrapper Class  \n In a simple example like the above, the C exception can be caught only by an ellipsis (**...**) **catch** handler. No information about the type or nature of the exception is communicated to the handler. While this method works, in some cases you may need to define a transformation between the two exception handling models so that each C exception is associated with a specific class. To do this, you can define a C exception \"wrapper\" class, which can be used or derived from in order to attribute a specific class type to a C exception. By doing so, each C exception can be handled by a C++ **catch** handler more separately than in the preceding example.  \n  \n Your wrapper class might have an interface consisting of some member functions that determine the value of the exception, and that access the extended exception context information provided by the C exception model. You might also want to define a default constructor and a constructor that accepts an `unsigned int` argument (to provide for the underlying C exception representation), and a bitwise copy constructor. The following is a possible implementation of a C exception wrapper class:  \n  \n```  \n// exceptions_Exception_Handling_Differences2.cpp  \n// compile with: /c  \nclass SE_Exception {  \nprivate:  \n   SE_Exception() {}  \n   SE_Exception( SE_Exception& ) {}  \n   unsigned int nSE;  \npublic:  \n   SE_Exception( unsigned int n ) : nSE( n ) {}  \n   ~SE_Exception() {}  \n   unsigned int getSeNumber() {  \n      return nSE;  \n   }  \n};  \n  \n```  \n  \n To use this class, you install a custom C exception translation function that is called by the internal exception handling mechanism each time a C exception is thrown. Within your translation function, you can throw any typed exception (perhaps an `SE_Exception` type, or a class type derived from `SE_Exception`) that can be caught by an appropriate matching C++ **catch** handler. The translation function can simply return, which indicates that it did not handle the exception. If the translation function itself raises a C exception, [terminate](../c-runtime-library/reference/terminate-crt.md) is called.  \n  \n To specify a custom translation function, call the [_set_se_translator](../c-runtime-library/reference/set-se-translator.md) function with the name of your translation function as its single argument. The translation function that you write is called once for each function invocation on the stack that has **try** blocks. There is no default translation function; if you do not specify one by calling `_set_se_translator`, the C exception can only be caught by an ellipsis **catch** handler.  \n  \n## Example  \n For example, the following code installs a custom translation function, and then raises a C exception that is wrapped by the `SE_Exception` class:  \n  \n```  \n// exceptions_Exception_Handling_Differences3.cpp  \n// compile with: /EHa  \n#include <stdio.h>  \n#include <eh.h>  \n#include <windows.h>  \n  \nclass SE_Exception {  \nprivate:  \n   SE_Exception() {}  \n   unsigned int nSE;  \n  \npublic:  \n   SE_Exception( SE_Exception& e) : nSE(e.nSE) {}  \n   SE_Exception(unsigned int n) : nSE(n) {}  \n   ~SE_Exception() {}  \n   unsigned int getSeNumber() { return nSE; }  \n};  \n  \nvoid SEFunc() {  \n   __try {  \n      int x, y = 0;  \n      x = 5 / y;  \n    }  \n    __finally {  \n      printf_s( \"In finally\\n\" );  \n   }  \n}  \n  \nvoid trans_func( unsigned int u, _EXCEPTION_POINTERS* pExp ) {  \n   printf_s( \"In trans_func.\\n\" );  \n   throw SE_Exception( u );  \n}  \n  \nint main() {  \n   _set_se_translator( trans_func );  \n    try {  \n      SEFunc();  \n    }  \n    catch( SE_Exception e ) {  \n      printf_s( \"Caught a __try exception with SE_Exception.\\n\" );  \n      printf_s( \"nSE = 0x%x\\n\", e.getSeNumber() );  \n    }  \n}  \n```  \n  \n```Output  \nIn trans_func.  \nIn finally  \nCaught a __try exception with SE_Exception.  \nnSE = 0xc0000094  \n```  \n  \n## See Also  \n [Mixing C (Structured) and C++ Exceptions](../cpp/mixing-c-structured-and-cpp-exceptions.md)"}