{"nodes":[{"pos":[12,44],"content":"sub_match Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"sub_match Class | Microsoft Docs","pos":[0,32]}]},{"content":"sub_match Class","pos":[655,670]},{"content":"Describes a submatch.","pos":[671,692]},{"content":"Syntax","pos":[701,707]},{"content":"Parameters","pos":[1327,1337]},{"content":"The iterator type for submatches.","pos":[1352,1385]},{"content":"Remarks","pos":[1394,1401]},{"content":"The template class describes an object that designates a sequence of characters that matched a capture group in a call to <bpt id=\"p1\">[</bpt>regex_match Function<ept id=\"p1\">](../standard-library/regex-functions.md#regex_match_function)</ept> or to <bpt id=\"p2\">[</bpt>regex_search Function<ept id=\"p2\">](../standard-library/regex-functions.md#regex_search_function)</ept>.","pos":[1405,1703],"source":"The template class describes an object that designates a sequence of characters that matched a capture group in a call to [regex_match Function](../standard-library/regex-functions.md#regex_match_function) or to [regex_search Function](../standard-library/regex-functions.md#regex_search_function)."},{"content":"Objects of type <bpt id=\"p1\">[</bpt>match_results Class<ept id=\"p1\">](../standard-library/match-results-class.md)</ept> hold an array of these objects, one for each capture group in the regular expression that was used in the search.","pos":[1704,1899],"source":" Objects of type [match_results Class](../standard-library/match-results-class.md) hold an array of these objects, one for each capture group in the regular expression that was used in the search."},{"content":"If the capture group was not matched the object's data member <ph id=\"ph1\">`matched`</ph> holds false, and the two iterators <ph id=\"ph2\">`first`</ph> and <ph id=\"ph3\">`second`</ph> (inherited from the base <ph id=\"ph4\">`std::pair`</ph>) are equal.","pos":[1906,2082],"source":"If the capture group was not matched the object's data member `matched` holds false, and the two iterators `first` and `second` (inherited from the base `std::pair`) are equal."},{"content":"If the capture group was matched, <ph id=\"ph1\">`matched`</ph> holds true, the iterator <ph id=\"ph2\">`first`</ph> points to the first character in the target sequence that matched the capture group, and the iterator <ph id=\"ph3\">`second`</ph> points one position past the last character in the target sequence that matched the capture group.","pos":[2083,2369],"source":" If the capture group was matched, `matched` holds true, the iterator `first` points to the first character in the target sequence that matched the capture group, and the iterator `second` points one position past the last character in the target sequence that matched the capture group."},{"content":"Note that for a zero-length match the member <ph id=\"ph1\">`matched`</ph> holds true, the two iterators will be equal, and both will point to the position of the match.","pos":[2370,2519],"source":" Note that for a zero-length match the member `matched` holds true, the two iterators will be equal, and both will point to the position of the match."},{"content":"A zero-length match can occur when a capture group consists solely of an assertion, or of a repetition that allows zero repeats.","pos":[2526,2654]},{"content":"For example:","pos":[2655,2667]},{"pos":[2674,2838],"content":"\"^\" matches the target sequence \"a\"; the <ph id=\"ph1\">`sub_match`</ph> object corresponding to capture group 0 holds iterators that both point to the first character in the sequence.","source":"\"^\" matches the target sequence \"a\"; the `sub_match` object corresponding to capture group 0 holds iterators that both point to the first character in the sequence."},{"pos":[2845,3016],"content":"\"b(a*)b\" matches the target sequence \"bb\"; the <ph id=\"ph1\">`sub_match`</ph> object corresponding to capture group 1 holds iterators that both point to the second character in the sequence.","source":"\"b(a*)b\" matches the target sequence \"bb\"; the `sub_match` object corresponding to capture group 1 holds iterators that both point to the second character in the sequence."},{"content":"Requirements","pos":[3025,3037]},{"pos":[3041,3061],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>regex&gt;","source":"**Header:** \\<regex>"},{"pos":[3068,3086],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[3131,3149],"content":"sub_match::compare"},{"content":"Compare submatch against a sequence.","pos":[3153,3189]},{"content":"Parameters","pos":[3361,3371]},{"content":"The submatch to compare to.","pos":[3386,3413]},{"content":"The string to compare to.","pos":[3429,3454]},{"content":"The nul-terminated sequence to compare to.","pos":[3470,3512]},{"content":"Remarks","pos":[3522,3529]},{"content":"The first member function compares the matched sequence <ph id=\"ph1\">`[first, second)`</ph> to the matched sequence <ph id=\"ph2\">`[right.first, right.second)`</ph>.","pos":[3533,3661],"source":"The first member function compares the matched sequence `[first, second)` to the matched sequence `[right.first, right.second)`."},{"content":"The second member function compares the matched sequence <ph id=\"ph1\">`[first, second)`</ph> to the character sequence <ph id=\"ph2\">`[right.begin(), right.end())`</ph>.","pos":[3662,3794],"source":" The second member function compares the matched sequence `[first, second)` to the character sequence `[right.begin(), right.end())`."},{"content":"The third member function compares the matched sequence <ph id=\"ph1\">`[first, second)`</ph> to the character sequence <ph id=\"ph2\">`[right, right + std::char_traits&lt;value_type&gt;::length(right))`</ph>.","pos":[3795,3958],"source":" The third member function compares the matched sequence `[first, second)` to the character sequence `[right, right + std::char_traits<value_type>::length(right))`."},{"content":"Each function returns:","pos":[3965,3987]},{"pos":[3994,4261],"content":"a negative value if the first differing value in the matched sequence compares less than the corresponding element in the operand sequence (as determined by <ph id=\"ph1\">`std::char_traits&lt;value_type&gt;::compare`</ph>), or if the two have a common prefix but the target sequence is longer","source":"a negative value if the first differing value in the matched sequence compares less than the corresponding element in the operand sequence (as determined by `std::char_traits<value_type>::compare`), or if the two have a common prefix but the target sequence is longer"},{"content":"zero if the two compare equal element by element and have the same length","pos":[4268,4341]},{"content":"a positive value otherwise","pos":[4348,4374]},{"content":"Example","pos":[4384,4391]},{"pos":[5818,5844],"content":"sub_match::difference_type"},{"content":"The type of an iterator difference.","pos":[5848,5883]},{"content":"Remarks","pos":[5984,5991]},{"pos":[5995,6066],"content":"The typedef is a synonym for <ph id=\"ph1\">`iterator_traits&lt;BidIt&gt;::difference_type`</ph>.","source":"The typedef is a synonym for `iterator_traits<BidIt>::difference_type`."},{"content":"Example","pos":[6076,6083]},{"pos":[7511,7530],"content":"sub_match::iterator"},{"content":"The type of an iterator.","pos":[7534,7558]},{"content":"Remarks","pos":[7609,7616]},{"pos":[7620,7684],"content":"The typedef is a synonym for the template type argument <ph id=\"ph1\">`Bidit`</ph>.","source":"The typedef is a synonym for the template type argument `Bidit`."},{"content":"Example","pos":[7694,7701]},{"pos":[9120,9137],"content":"sub_match::length"},{"content":"Returns the length of a submatch.","pos":[9141,9174]},{"content":"Remarks","pos":[9231,9238]},{"content":"The member function returns the length of the matched sequence, or zero if there was no matched sequence.","pos":[9242,9347]},{"content":"Example","pos":[9357,9364]},{"pos":[10782,10800],"content":"sub_match::matched"},{"content":"Indicates if match succeeded.","pos":[10804,10833]},{"content":"Remarks","pos":[10874,10881]},{"pos":[10885,11000],"content":"The member holds <ph id=\"ph1\">`true`</ph> only if the capture group associated with <ph id=\"ph2\">`*this`</ph> was part of the regular expression match.","source":"The member holds `true` only if the capture group associated with `*this` was part of the regular expression match."},{"content":"Example","pos":[11010,11017]},{"pos":[12468,12514],"content":"sub_match::operator basic_string<ph id=\"ph1\">&amp;lt;</ph>value_type","source":"  sub_match::operator basic_string&lt;value_type"},{"content":"Casts submatch to a string.","pos":[12522,12549]},{"content":"```  operator basic_string&lt;value_type&gt;() const;","pos":[12555,12602],"source":"```  operator basic_string<value_type>() const;"},{"pos":[14100,14114],"content":"sub_match::str"},{"content":"Converts submatch to a string.","pos":[14118,14148]},{"content":"Remarks","pos":[14211,14218]},{"pos":[14222,14292],"content":"The member function returns <ph id=\"ph1\">`basic_string&lt;value_type&gt;(first, second)`</ph>.","source":"The member function returns `basic_string<value_type>(first, second)`."},{"content":"Example","pos":[14302,14309]},{"pos":[15727,15748],"content":"sub_match::value_type"},{"content":"The type of an element.","pos":[15752,15775]},{"content":"Remarks","pos":[15866,15873]},{"pos":[15877,15943],"content":"The typedef is a synonym for <ph id=\"ph1\">`iterator_traits&lt;BidIt&gt;::value_type`</ph>.","source":"The typedef is a synonym for `iterator_traits<BidIt>::value_type`."},{"content":"Example","pos":[15953,15960]},{"content":"See Also","pos":[17346,17354]},{"content":"regex&gt;","pos":[17361,17367],"source":"regex>"},{"content":"sub_match","pos":[17404,17413]}],"content":"---\ntitle: \"sub_match Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"sub_match\"\n  - \"std::tr1::sub_match\"\n  - \"std.tr1.sub_match\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"sub_match class [TR1]\"\nms.assetid: 804e2b9e-d16a-4c4c-ac60-024e0b2dd0e8\ncaps.latest.revision: 19\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# sub_match Class\nDescribes a submatch.  \n  \n## Syntax  \n  \n```  \ntemplate <class BidIt>  \nclass sub_match  \n : public std::pair<BidIt, BidIt> {  \npublic:  \n    bool matched;  \n    int compare(const sub_match& right) const;\n\n \n    int compare(const basic_string<value_type>& right) const;\n\n \n    int compare(const value_type *right) const;\n\n \n    difference_type length() const;\n\n operator basic_string<value_type>() const;\n\n \n    basic_string<value_type>  \nstr() const;\n\n \n    typedef typename iterator_traits<BidIt>::value_type value_type;  \n    typedef typename iterator_traits<BidIt>::difference_type difference_type;  \n    typedef BidIt iterator;  \n };  \n```  \n  \n#### Parameters  \n `BidIt`  \n The iterator type for submatches.  \n  \n## Remarks  \n The template class describes an object that designates a sequence of characters that matched a capture group in a call to [regex_match Function](../standard-library/regex-functions.md#regex_match_function) or to [regex_search Function](../standard-library/regex-functions.md#regex_search_function). Objects of type [match_results Class](../standard-library/match-results-class.md) hold an array of these objects, one for each capture group in the regular expression that was used in the search.  \n  \n If the capture group was not matched the object's data member `matched` holds false, and the two iterators `first` and `second` (inherited from the base `std::pair`) are equal. If the capture group was matched, `matched` holds true, the iterator `first` points to the first character in the target sequence that matched the capture group, and the iterator `second` points one position past the last character in the target sequence that matched the capture group. Note that for a zero-length match the member `matched` holds true, the two iterators will be equal, and both will point to the position of the match.  \n  \n A zero-length match can occur when a capture group consists solely of an assertion, or of a repetition that allows zero repeats. For example:  \n  \n \"^\" matches the target sequence \"a\"; the `sub_match` object corresponding to capture group 0 holds iterators that both point to the first character in the sequence.  \n  \n \"b(a*)b\" matches the target sequence \"bb\"; the `sub_match` object corresponding to capture group 1 holds iterators that both point to the second character in the sequence.  \n  \n## Requirements  \n **Header:** \\<regex>  \n  \n **Namespace:** std  \n  \n##  <a name=\"sub_match__compare\"></a>  sub_match::compare  \n Compare submatch against a sequence.  \n  \n```  \nint compare(const sub_match& right) const;\n\n \nint compare(const basic_string<value_type>& str) const;\n\n \nint compare(const value_type *ptr) const;\n```  \n  \n### Parameters  \n `right`  \n The submatch to compare to.  \n  \n `str`  \n The string to compare to.  \n  \n `ptr`  \n The nul-terminated sequence to compare to.  \n  \n### Remarks  \n The first member function compares the matched sequence `[first, second)` to the matched sequence `[right.first, right.second)`. The second member function compares the matched sequence `[first, second)` to the character sequence `[right.begin(), right.end())`. The third member function compares the matched sequence `[first, second)` to the character sequence `[right, right + std::char_traits<value_type>::length(right))`.  \n  \n Each function returns:  \n  \n a negative value if the first differing value in the matched sequence compares less than the corresponding element in the operand sequence (as determined by `std::char_traits<value_type>::compare`), or if the two have a common prefix but the target sequence is longer  \n  \n zero if the two compare equal element by element and have the same length  \n  \n a positive value otherwise  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__sub_match_compare.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"matched == \" << std::boolalpha   \n        << sub.matched << std::endl;   \n    std::cout << \"length == \" << sub.length() << std::endl;   \n  \n    std::csub_match::difference_type dif = std::distance(sub.first, sub.second);   \n    std::cout << \"difference == \" << dif << std::endl;   \n  \n    std::csub_match::iterator first = sub.first;   \n    std::csub_match::iterator last = sub.second;   \n    std::cout << \"range == \" << std::string(first, last)   \n        << std::endl;   \n    std::cout << \"string == \" << sub << std::endl;   \n  \n    std::csub_match::value_type *ptr = \"aab\";   \n    std::cout << \"compare(\\\"aab\\\") == \"   \n        << sub.compare(ptr) << std::endl;   \n    std::cout << \"compare(string) == \"   \n        << sub.compare(std::string(\"AAA\")) << std::endl;   \n    std::cout << \"compare(sub) == \"   \n        << sub.compare(sub) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatched == true  \nlength == 3  \ndifference == 3  \nrange == aaa  \nstring == aaa  \ncompare(\"aab\") == -1  \ncompare(string) == 1  \ncompare(sub) == 0  \n```  \n  \n##  <a name=\"sub_match__difference_type\"></a>  sub_match::difference_type  \n The type of an iterator difference.  \n  \n```  \ntypedef typename iterator_traits<BidIt>::difference_type difference_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for `iterator_traits<BidIt>::difference_type`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__sub_match_difference_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"matched == \" << std::boolalpha   \n        << sub.matched << std::endl;   \n    std::cout << \"length == \" << sub.length() << std::endl;   \n  \n    std::csub_match::difference_type dif = std::distance(sub.first, sub.second);   \n    std::cout << \"difference == \" << dif << std::endl;   \n  \n    std::csub_match::iterator first = sub.first;   \n    std::csub_match::iterator last = sub.second;   \n    std::cout << \"range == \" << std::string(first, last)   \n        << std::endl;   \n    std::cout << \"string == \" << sub << std::endl;   \n  \n    std::csub_match::value_type *ptr = \"aab\";   \n    std::cout << \"compare(\\\"aab\\\") == \"   \n        << sub.compare(ptr) << std::endl;   \n    std::cout << \"compare(string) == \"   \n        << sub.compare(std::string(\"AAA\")) << std::endl;   \n    std::cout << \"compare(sub) == \"   \n        << sub.compare(sub) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatched == true  \nlength == 3  \ndifference == 3  \nrange == aaa  \nstring == aaa  \ncompare(\"aab\") == -1  \ncompare(string) == 1  \ncompare(sub) == 0  \n```  \n  \n##  <a name=\"sub_match__iterator\"></a>  sub_match::iterator  \n The type of an iterator.  \n  \n```  \ntypedef BidIt iterator;  \n```  \n  \n### Remarks  \n The typedef is a synonym for the template type argument `Bidit`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__sub_match_iterator.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"matched == \" << std::boolalpha   \n        << sub.matched << std::endl;   \n    std::cout << \"length == \" << sub.length() << std::endl;   \n  \n    std::csub_match::difference_type dif = std::distance(sub.first, sub.second);   \n    std::cout << \"difference == \" << dif << std::endl;   \n  \n    std::csub_match::iterator first = sub.first;   \n    std::csub_match::iterator last = sub.second;   \n    std::cout << \"range == \" << std::string(first, last)   \n        << std::endl;   \n    std::cout << \"string == \" << sub << std::endl;   \n  \n    std::csub_match::value_type *ptr = \"aab\";   \n    std::cout << \"compare(\\\"aab\\\") == \"   \n        << sub.compare(ptr) << std::endl;   \n    std::cout << \"compare(string) == \"   \n        << sub.compare(std::string(\"AAA\")) << std::endl;   \n    std::cout << \"compare(sub) == \"   \n        << sub.compare(sub) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatched == true  \nlength == 3  \ndifference == 3  \nrange == aaa  \nstring == aaa  \ncompare(\"aab\") == -1  \ncompare(string) == 1  \ncompare(sub) == 0  \n```  \n  \n##  <a name=\"sub_match__length\"></a>  sub_match::length  \n Returns the length of a submatch.  \n  \n```  \ndifference_type length() const;\n```  \n  \n### Remarks  \n The member function returns the length of the matched sequence, or zero if there was no matched sequence.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__sub_match_length.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"matched == \" << std::boolalpha   \n        << sub.matched << std::endl;   \n    std::cout << \"length == \" << sub.length() << std::endl;   \n  \n    std::csub_match::difference_type dif = std::distance(sub.first, sub.second);   \n    std::cout << \"difference == \" << dif << std::endl;   \n  \n    std::csub_match::iterator first = sub.first;   \n    std::csub_match::iterator last = sub.second;   \n    std::cout << \"range == \" << std::string(first, last)   \n        << std::endl;   \n    std::cout << \"string == \" << sub << std::endl;   \n  \n    std::csub_match::value_type *ptr = \"aab\";   \n    std::cout << \"compare(\\\"aab\\\") == \"   \n        << sub.compare(ptr) << std::endl;   \n    std::cout << \"compare(string) == \"   \n        << sub.compare(std::string(\"AAA\")) << std::endl;   \n    std::cout << \"compare(sub) == \"   \n        << sub.compare(sub) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatched == true  \nlength == 3  \ndifference == 3  \nrange == aaa  \nstring == aaa  \ncompare(\"aab\") == -1  \ncompare(string) == 1  \ncompare(sub) == 0  \n```  \n  \n##  <a name=\"sub_match__matched\"></a>  sub_match::matched  \n Indicates if match succeeded.  \n  \n```  \nbool matched;  \n```  \n  \n### Remarks  \n The member holds `true` only if the capture group associated with `*this` was part of the regular expression match.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__sub_match_matched.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"matched == \" << std::boolalpha   \n        << sub.matched << std::endl;   \n    std::cout << \"length == \" << sub.length() << std::endl;   \n  \n    std::csub_match::difference_type dif = std::distance(sub.first, sub.second);   \n    std::cout << \"difference == \" << dif << std::endl;   \n  \n    std::csub_match::iterator first = sub.first;   \n    std::csub_match::iterator last = sub.second;   \n    std::cout << \"range == \" << std::string(first, last)   \n        << std::endl;   \n    std::cout << \"string == \" << sub << std::endl;   \n  \n    std::csub_match::value_type *ptr = \"aab\";   \n    std::cout << \"compare(\\\"aab\\\") == \"   \n        << sub.compare(ptr) << std::endl;   \n    std::cout << \"compare(string) == \"   \n        << sub.compare(std::string(\"AAA\")) << std::endl;   \n    std::cout << \"compare(sub) == \"   \n        << sub.compare(sub) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatched == true  \nlength == 3  \ndifference == 3  \nrange == aaa  \nstring == aaa  \ncompare(\"aab\") == -1  \ncompare(string) == 1  \ncompare(sub) == 0  \n```  \n  \n##  <a name=\"sub_match__operator_basic_string_lt_value_type_gt_\"></a>  sub_match::operator basic_string&lt;value_type&gt;  \n Casts submatch to a string.  \n  \n```  operator basic_string<value_type>() const;\n```  \n  \n### Remarks  \n The member operator returns `str()`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__sub_match_operator_str.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"matched == \" << std::boolalpha   \n        << sub.matched << std::endl;   \n    std::cout << \"length == \" << sub.length() << std::endl;   \n  \n    std::csub_match::difference_type dif = std::distance(sub.first, sub.second);   \n    std::cout << \"difference == \" << dif << std::endl;   \n  \n    std::csub_match::iterator first = sub.first;   \n    std::csub_match::iterator last = sub.second;   \n    std::cout << \"range == \" << std::string(first, last)   \n        << std::endl;   \n    std::cout << \"string == \" << sub << std::endl;   \n  \n    std::csub_match::value_type *ptr = \"aab\";   \n    std::cout << \"compare(\\\"aab\\\") == \"   \n        << sub.compare(ptr) << std::endl;   \n    std::cout << \"compare(string) == \"   \n        << sub.compare(std::string(\"AAA\")) << std::endl;   \n    std::cout << \"compare(sub) == \"   \n        << sub.compare(sub) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatched == true  \nlength == 3  \ndifference == 3  \nrange == aaa  \nstring == aaa  \ncompare(\"aab\") == -1  \ncompare(string) == 1  \ncompare(sub) == 0  \n```  \n  \n##  <a name=\"sub_match__str\"></a>  sub_match::str  \n Converts submatch to a string.  \n  \n```  \nbasic_string<value_type> str() const;\n```  \n  \n### Remarks  \n The member function returns `basic_string<value_type>(first, second)`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__sub_match_str.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"matched == \" << std::boolalpha   \n        << sub.matched << std::endl;   \n    std::cout << \"length == \" << sub.length() << std::endl;   \n  \n    std::csub_match::difference_type dif = std::distance(sub.first, sub.second);   \n    std::cout << \"difference == \" << dif << std::endl;   \n  \n    std::csub_match::iterator first = sub.first;   \n    std::csub_match::iterator last = sub.second;   \n    std::cout << \"range == \" << std::string(first, last)   \n        << std::endl;   \n    std::cout << \"string == \" << sub << std::endl;   \n  \n    std::csub_match::value_type *ptr = \"aab\";   \n    std::cout << \"compare(\\\"aab\\\") == \"   \n        << sub.compare(ptr) << std::endl;   \n    std::cout << \"compare(string) == \"   \n        << sub.compare(std::string(\"AAA\")) << std::endl;   \n    std::cout << \"compare(sub) == \"   \n        << sub.compare(sub) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatched == true  \nlength == 3  \ndifference == 3  \nrange == aaa  \nstring == aaa  \ncompare(\"aab\") == -1  \ncompare(string) == 1  \ncompare(sub) == 0  \n```  \n  \n##  <a name=\"sub_match__value_type\"></a>  sub_match::value_type  \n The type of an element.  \n  \n```  \ntypedef typename iterator_traits<BidIt>::value_type value_type;  \n```  \n  \n### Remarks  \n The typedef is a synonym for `iterator_traits<BidIt>::value_type`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__sub_match_value_type.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx(\"c(a*)|(b)\");   \n    std::cmatch mr;   \n  \n    std::regex_search(\"xcaaay\", mr, rx);   \n  \n    std::csub_match sub = mr[1];   \n    std::cout << \"matched == \" << std::boolalpha   \n        << sub.matched << std::endl;   \n    std::cout << \"length == \" << sub.length() << std::endl;   \n  \n    std::csub_match::difference_type dif = std::distance(sub.first, sub.second);   \n    std::cout << \"difference == \" << dif << std::endl;   \n  \n    std::csub_match::iterator first = sub.first;   \n    std::csub_match::iterator last = sub.second;   \n    std::cout << \"range == \" << std::string(first, last)   \n        << std::endl;   \n    std::cout << \"string == \" << sub << std::endl;   \n  \n    std::csub_match::value_type *ptr = \"aab\";   \n    std::cout << \"compare(\\\"aab\\\") == \"   \n        << sub.compare(ptr) << std::endl;   \n    std::cout << \"compare(string) == \"   \n        << sub.compare(std::string(\"AAA\")) << std::endl;   \n    std::cout << \"compare(sub) == \"   \n        << sub.compare(sub) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatched == true  \nlength == 3  \ndifference == 3  \nrange == aaa  \nstring == aaa  \ncompare(\"aab\") == -1  \ncompare(string) == 1  \ncompare(sub) == 0  \n```  \n  \n## See Also  \n [\\<regex>](../standard-library/regex.md)   \n [sub_match](../standard-library/sub-match-class.md)\n"}