{"nodes":[{"pos":[12,85],"content":"How to: Define and Consume Classes and Structs (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Define and Consume Classes and Structs (C++-CLI) | Microsoft Docs","pos":[0,73]}]},{"content":"How to: Define and Consume Classes and Structs (C++/CLI)","pos":[669,725]},{"pos":[726,880],"content":"This article shows how to define and consume user-defined reference types and value types in <ph id=\"ph1\">[!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]</ph>.","source":"This article shows how to define and consume user-defined reference types and value types in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)]."},{"pos":[919,927],"content":"Contents"},{"content":"Object instantiation","pos":[932,952]},{"content":"Implicitly abstract classes","pos":[989,1016]},{"content":"Type visibility","pos":[1060,1075]},{"content":"Member visibility","pos":[1107,1124]},{"content":"Public and private native classes","pos":[1158,1191]},{"content":"Static constructors","pos":[1241,1260]},{"content":"Semantics of the this pointer","pos":[1296,1325]},{"content":"Hide-by-signature functions","pos":[1371,1398]},{"content":"Copy constructors","pos":[1442,1459]},{"content":"Destructors and finalizers","pos":[1493,1519]},{"pos":[1605,1625],"content":"Object instantiation"},{"content":"Reference (ref) types and value types can only be instantiated on the managed heap, not on the stack or on the native heap.","pos":[1629,1752]},{"pos":[2881,2908],"content":"Implicitly abstract classes"},{"content":"An <bpt id=\"p1\">*</bpt>implicitly abstract class<ept id=\"p1\">*</ept> can't be instantiated.","pos":[2912,2965],"source":"An *implicitly abstract class* can't be instantiated."},{"content":"A class is implicitly abstract if the base type of the class is an interface and the class does not implement all of the interface's member functions.","pos":[2966,3116]},{"content":"If you are unable to construct objects from a class that's derived from an interface, the reason might be that the class is implicitly abstract.","pos":[3123,3267]},{"content":"For more information about abstract classes, see <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../windows/abstract-cpp-component-extensions.md)</ept>.","pos":[3268,3377],"source":" For more information about abstract classes, see [abstract](../windows/abstract-cpp-component-extensions.md)."},{"content":"The following code example demonstrates that the <ph id=\"ph1\">`MyClass`</ph> class cannot be instantiated because function <ph id=\"ph2\">`MyClass::func2`</ph> is not implemented.","pos":[3384,3525],"source":"The following code example demonstrates that the `MyClass` class cannot be instantiated because function `MyClass::func2` is not implemented."},{"content":"To enable the example to compile, uncomment <ph id=\"ph1\">`MyClass::func2`</ph>.","pos":[3526,3587],"source":" To enable the example to compile, uncomment `MyClass::func2`."},{"pos":[4040,4055],"content":"Type visibility"},{"content":"You can control the visibility of common language runtime (CLR) types so that, if an assembly is referenced, types in the assembly can be visible or not visible outside the assembly.","pos":[4059,4241]},{"content":"indicates that a type is visible to any source file that contains a <ph id=\"ph1\">`#using`</ph> directive for the assembly that contains the type.","pos":[4257,4384],"source":" indicates that a type is visible to any source file that contains a `#using` directive for the assembly that contains the type."},{"content":"indicates that a type is not visible to source files that contain a <ph id=\"ph1\">`#using`</ph> directive for the assembly that contains the type.","pos":[4396,4523],"source":" indicates that a type is not visible to source files that contain a `#using` directive for the assembly that contains the type."},{"content":"However, private types are visible within the same assembly.","pos":[4524,4584]},{"content":"By default, the visibility for a class is <ph id=\"ph1\">`private`</ph>.","pos":[4585,4637],"source":" By default, the visibility for a class is `private`."},{"content":"By default prior to Visual C++ 2005, native types had public accessibility outside the assembly.","pos":[4644,4740]},{"content":"Enable <bpt id=\"p1\">[</bpt>Compiler Warning (level 1) C4692<ept id=\"p1\">](../error-messages/compiler-warnings/compiler-warning-level-1-c4692.md)</ept> to help you see where private native types are used incorrectly.","pos":[4741,4918],"source":" Enable [Compiler Warning (level 1) C4692](../error-messages/compiler-warnings/compiler-warning-level-1-c4692.md) to help you see where private native types are used incorrectly."},{"content":"Use the <bpt id=\"p1\">[</bpt>make_public<ept id=\"p1\">](../preprocessor/make-public.md)</ept> pragma to give public accessibility to a native type in a source code file that you can't modify.","pos":[4919,5070],"source":" Use the [make_public](../preprocessor/make-public.md) pragma to give public accessibility to a native type in a source code file that you can't modify."},{"pos":[5077,5167],"content":"For more information, see <bpt id=\"p1\">[</bpt>#using Directive<ept id=\"p1\">](../preprocessor/hash-using-directive-cpp.md)</ept>.","source":"For more information, see [#using Directive](../preprocessor/hash-using-directive-cpp.md)."},{"content":"The following sample shows how to declare types and specify their accessibility, and then access those types inside the assembly.","pos":[5174,5303]},{"content":"Of course, if an assembly that has private types is referenced by using <ph id=\"ph1\">`#using`</ph>, only public types in the assembly are visible.","pos":[5304,5432],"source":" Of course, if an assembly that has private types is referenced by using `#using`, only public types in the assembly are visible."},{"content":"Output","pos":[6206,6212]},{"content":"Now, let's rewrite the previous sample so that it is built as a DLL.","pos":[6300,6368]},{"content":"The next sample shows how to access types outside the assembly.","pos":[6942,7005]},{"content":"In this sample, the client consumes the component that's built in the previous sample.","pos":[7006,7092]},{"content":"Output","pos":[7442,7448]},{"pos":[7537,7554],"content":"Member visibility"},{"pos":[7558,7758],"content":"You can make access to a member of a public class from within the same assembly different than access to it from outside the assembly by using pairs of the access specifiers <ph id=\"ph1\">`public`</ph>, <ph id=\"ph2\">`protected`</ph>, and","source":"You can make access to a member of a public class from within the same assembly different than access to it from outside the assembly by using pairs of the access specifiers `public`, `protected`, and "},{"content":"This table summarizes the effect of the various access specifiers:","pos":[7775,7841]},{"content":"Specifier","pos":[7848,7857]},{"content":"Effect","pos":[7858,7864]},{"content":"public","pos":[7902,7908]},{"content":"Member is accessible inside and outside the assembly.","pos":[7909,7962]},{"content":"See <bpt id=\"p1\">[</bpt>public<ept id=\"p1\">](../cpp/public-cpp.md)</ept> for more information.","pos":[7964,8020],"source":"  See [public](../cpp/public-cpp.md) for more information."},{"content":"private","pos":[8025,8032]},{"content":"Member is not accessible, neither inside nor outside the assembly.","pos":[8033,8099]},{"content":"See <bpt id=\"p1\">[</bpt>private<ept id=\"p1\">](../cpp/private-cpp.md)</ept> for more information.","pos":[8101,8159],"source":"  See [private](../cpp/private-cpp.md) for more information."},{"content":"protected","pos":[8164,8173]},{"content":"Member is accessible inside and outside the assembly, but only to derived types.","pos":[8174,8254]},{"content":"See <bpt id=\"p1\">[</bpt>protected<ept id=\"p1\">](../cpp/protected-cpp.md)</ept> for more information.","pos":[8256,8318],"source":"  See [protected](../cpp/protected-cpp.md) for more information."},{"content":"internal","pos":[8323,8331]},{"content":"Member is public inside the assembly but private outside the assembly.","pos":[8332,8402]},{"content":"is a context-sensitive keyword.","pos":[8415,8446]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Context-Sensitive Keywords<ept id=\"p1\">](../windows/context-sensitive-keywords-cpp-component-extensions.md)</ept>.","pos":[8448,8570],"source":"  For more information, see [Context-Sensitive Keywords](../windows/context-sensitive-keywords-cpp-component-extensions.md)."},{"content":"public protected -or- protected public","pos":[8575,8613]},{"content":"Member is public inside the assembly but protected outside the assembly.","pos":[8614,8686]},{"content":"private protected -or- protected private","pos":[8691,8731]},{"content":"Member is protected inside the assembly but private outside the assembly.","pos":[8732,8805]},{"content":"The following sample shows a public type that has members that are declared with the different accessibilities, and then shows the accessing of those members from inside the assembly.","pos":[8813,8996]},{"content":"Output","pos":[10942,10948]},{"content":"Now let's build the previous sample as a DLL.","pos":[11291,11336]},{"content":"The following sample consumes the component that's created in the previous sample, and thereby shows how to access the members from outside the assembly.","pos":[12856,13009]},{"content":"Output","pos":[13963,13969]},{"pos":[14282,14315],"content":"Public and private native classes"},{"content":"A native type can be referenced from a managed type.","pos":[14319,14371]},{"content":"For example, a function in a managed type can take a parameter whose type is a native struct.","pos":[14373,14466]},{"content":"If the managed type and function are public in an assembly, then the native type must also be public.","pos":[14468,14569]},{"content":"Next, create the source code file that consumes the native type:","pos":[14659,14723]},{"content":"Now, compile a client:","pos":[14933,14955]},{"pos":[15183,15202],"content":"Static constructors"},{"content":"A CLR type—for example, a class or struct—can have a static constructor that can be used to initialize static data members.","pos":[15206,15329]},{"content":"A static constructor is called at most once, and is called before any static member of the type is accessed the first time.","pos":[15331,15454]},{"content":"An instance constructor always runs after a static constructor.","pos":[15461,15524]},{"content":"The compiler cannot inline a call to a constructor if the class has a static constructor.","pos":[15531,15620]},{"content":"The compiler cannot inline a call to any member function if the class is a value type, has a static constructor, and does not have an instance constructor.","pos":[15622,15777]},{"content":"The CLR may inline the call, but the compiler cannot.","pos":[15779,15832]},{"content":"Define a static constructor as a private member function, because it is meant to be called only by the CLR.","pos":[15839,15946]},{"pos":[15953,16133],"content":"For more information about static constructors, see <bpt id=\"p1\">[</bpt>How to: Define an Interface Static Constructor (C++/CLI)<ept id=\"p1\">](../dotnet/how-to-define-an-interface-static-constructor-cpp-cli.md)</ept> .","source":"For more information about static constructors, see [How to: Define an Interface Static Constructor (C++/CLI)](../dotnet/how-to-define-an-interface-static-constructor-cpp-cli.md) ."},{"content":"Output","pos":[16532,16538]},{"pos":[16655,16684],"content":"Semantics of the this pointer"},{"content":"When you are using Visual C++ to define types, the <ph id=\"ph1\">`this`</ph> pointer in a reference type is of type \"handle\".","pos":[16688,16794],"source":"When you are using Visual C++ to define types, the `this` pointer in a reference type is of type \"handle\"."},{"content":"The <ph id=\"ph1\">`this`</ph> pointer in a value type is of type \"interior pointer\".","pos":[16795,16860],"source":" The `this` pointer in a value type is of type \"interior pointer\"."},{"content":"These different semantics of the <ph id=\"ph1\">`this`</ph> pointer can cause unexpected behavior when a default indexer is called.","pos":[16867,16978],"source":"These different semantics of the `this` pointer can cause unexpected behavior when a default indexer is called."},{"content":"The next example shows the correct way to access a default indexer in both a ref type and a value type.","pos":[16979,17082]},{"content":"For more information, see","pos":[17089,17114]},{"content":"Handle to Object Operator (^)","pos":[17125,17154]},{"content":"interior_ptr (C++/CLI)","pos":[17236,17258]},{"content":"Output","pos":[17976,17982]},{"pos":[18079,18106],"content":"Hide-by-signature functions"},{"content":"In standard C++, a function in a base class is hidden by a function that has the same name in a derived class, even if the derived-class function does not have the same number or kind of parameters.","pos":[18110,18308]},{"content":"This is referred to as <bpt id=\"p1\">*</bpt>hide-by-name<ept id=\"p1\">*</ept> semantics.","pos":[18309,18357],"source":" This is referred to as *hide-by-name* semantics."},{"content":"In a reference type, a function in a base class can only be hidden by a function in a derived class if both the name and the parameter list are the same.","pos":[18358,18511]},{"content":"This is known as <bpt id=\"p1\">*</bpt>hide-by-signature<ept id=\"p1\">*</ept> semantics.","pos":[18512,18559],"source":" This is known as *hide-by-signature* semantics."},{"content":"A class is considered a hide-by-signature class when all of its functions are marked in the metadata as <ph id=\"ph1\">`hidebysig`</ph>.","pos":[18566,18682],"source":"A class is considered a hide-by-signature class when all of its functions are marked in the metadata as `hidebysig`."},{"content":"By default, all classes that are created under <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> have <ph id=\"ph1\">`hidebysig`</ph> functions.","pos":[18683,18766],"source":" By default, all classes that are created under **/clr** have `hidebysig` functions."},{"content":"When a class has <ph id=\"ph1\">`hidebysig`</ph> functions, the compiler doesn't hide functions by name in any direct base classes, but if the compiler encounters a hide-by-name class in an inheritance chain, it continues that hide-by-name behavior.","pos":[18767,18996],"source":" When a class has `hidebysig` functions, the compiler doesn't hide functions by name in any direct base classes, but if the compiler encounters a hide-by-name class in an inheritance chain, it continues that hide-by-name behavior."},{"content":"Under hide-by-signature semantics, when a function is called on an object, the compiler identifies the most derived class that contains a function that could satisfy the function call.","pos":[19003,19187]},{"content":"If there is only one function in the class that could satisfy the call, the compiler calls that function.","pos":[19188,19293]},{"content":"If there is more than one function in the class that could satisfy the call, the compiler uses overload resolution rules to determine which function to call.","pos":[19294,19451]},{"content":"For more information about overload rules, see <bpt id=\"p1\">[</bpt>Function Overloading<ept id=\"p1\">](../cpp/function-overloading.md)</ept>.","pos":[19452,19554],"source":" For more information about overload rules, see [Function Overloading](../cpp/function-overloading.md)."},{"content":"For a given function call, a function in a base class might have a signature that makes it a slightly better match than a function in a derived class.","pos":[19561,19711]},{"content":"However, if the function was explicitly called on an object of the derived class, the function in the derived class is called.","pos":[19712,19838]},{"content":"Because the return value is not considered part of a function's signature, a base-class function is hidden if it has the same name and takes the same number and kind of arguments as a derived-class function, even if it differs in the type of the return value.","pos":[19845,20104]},{"content":"The following sample shows that a function in a base class is not hidden by a function in a derived class.","pos":[20111,20217]},{"content":"Output","pos":[20636,20642]},{"content":"The next sample shows that the Visual C++ compiler calls a function in the most derived class—even if a conversion is required to match one or more of the parameters—and not call a function in a base class that is a better match for the function call.","pos":[20685,20936]},{"content":"Output","pos":[21438,21444]},{"content":"The following sample shows that it's possible to hide a function even if the base class has the same signature as the derived class.","pos":[21491,21623]},{"content":"Output","pos":[22098,22104]},{"pos":[22197,22214],"content":"Copy constructors"},{"content":"The C++ standard says that a copy constructor is called when an object is moved, such that an object is created and destroyed at the same address.","pos":[22218,22364]},{"content":"However, when <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> is used to compile and a function that's compiled to MSIL calls a native function where a native class—or more than one—is passed by value and where the native class has a copy constructor and/or destructor, no copy constructor is called and the object is destroyed at a different address than where it was created.","pos":[22371,22709],"source":"However, when **/clr** is used to compile and a function that's compiled to MSIL calls a native function where a native class—or more than one—is passed by value and where the native class has a copy constructor and/or destructor, no copy constructor is called and the object is destroyed at a different address than where it was created."},{"content":"This could cause problems if the class has a pointer into itself, or if the code is tracking objects by address.","pos":[22710,22822]},{"pos":[22829,22963],"content":"For more information, see <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>.","source":"For more information, see [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md)."},{"content":"The following sample demonstrates when a copy constructor is not generated.","pos":[22970,23045]},{"content":"Output","pos":[23716,23722]},{"pos":[24442,24468],"content":"Destructors and finalizers"},{"content":"Destructors in a reference type perform a deterministic clean-up of resources.","pos":[24472,24550]},{"content":"Finalizers clean up unmanaged resources and can be called deterministically by the destructor or nondeterministically by the garbage collector.","pos":[24551,24694]},{"content":"For information about destructors in standard C++, see <bpt id=\"p1\">[</bpt>Destructors<ept id=\"p1\">](../cpp/destructors-cpp.md)</ept>.","pos":[24695,24791],"source":" For information about destructors in standard C++, see [Destructors](../cpp/destructors-cpp.md)."},{"content":"The behavior of destructors in a managed Visual C++ class differs from Managed Extensions for C++.","pos":[24912,25010]},{"content":"For more information about this change, see <bpt id=\"p1\">[</bpt>Changes in Destructor Semantics<ept id=\"p1\">](../dotnet/changes-in-destructor-semantics.md)</ept>.","pos":[25011,25135],"source":" For more information about this change, see [Changes in Destructor Semantics](../dotnet/changes-in-destructor-semantics.md)."},{"content":"The CLR garbage collector deletes unused managed objects and releases their memory when they are no longer required.","pos":[25142,25258]},{"content":"However, a type may use resources that the garbage collector does not know how to release.","pos":[25259,25349]},{"content":"These resources are known as unmanaged resources (native file handles, for example).","pos":[25350,25434]},{"content":"We recommend that you release all unmanaged resources in the finalizer.","pos":[25435,25506]},{"content":"Because managed resources are released nondeterministically by the garbage collector, it's not safe to refer to managed resources in a finalizer because it's possible that the garbage collector has already cleaned up that managed resource.","pos":[25507,25746]},{"content":"A Visual C++ finalizer is not the same as the &lt;xref:System.Object.Finalize%2A&gt; method.","pos":[25753,25839],"source":"A Visual C++ finalizer is not the same as the <xref:System.Object.Finalize%2A> method."},{"content":"(CLR documentation uses finalizer and the &lt;xref:System.Object.Finalize%2A&gt; method synonymously).","pos":[25840,25936],"source":" (CLR documentation uses finalizer and the <xref:System.Object.Finalize%2A> method synonymously)."},{"content":"The &lt;xref:System.Object.Finalize%2A&gt; method is called by the garbage collector, which invokes each finalizer in a class inheritance chain.","pos":[25937,26075],"source":" The <xref:System.Object.Finalize%2A> method is called by the garbage collector, which invokes each finalizer in a class inheritance chain."},{"content":"Unlike Visual C++ destructors, a derived-class finalizer call does not cause the compiler to invoke the finalizer in all base classes.","pos":[26076,26210]},{"content":"Because the Visual C++ compiler supports deterministic release of resources, don't try to implement the &lt;xref:System.IDisposable.Dispose%2A&gt; or &lt;xref:System.Object.Finalize%2A&gt; methods.","pos":[26217,26402],"source":"Because the Visual C++ compiler supports deterministic release of resources, don't try to implement the <xref:System.IDisposable.Dispose%2A> or <xref:System.Object.Finalize%2A> methods."},{"content":"However, if you're familiar with these methods, here's how a Visual C++ finalizer and a destructor that calls the finalizer map to the &lt;xref:System.IDisposable.Dispose%2A&gt; pattern:","pos":[26403,26583],"source":" However, if you're familiar with these methods, here's how a Visual C++ finalizer and a destructor that calls the finalizer map to the <xref:System.IDisposable.Dispose%2A> pattern:"},{"content":"A managed type may also use managed resources that you would prefer to release deterministically, and not leave to the garbage collector to release nondeterministically at some point after the object is no longer required.","pos":[26883,27105]},{"content":"The deterministic release of resources can significantly improve performance.","pos":[27106,27183]},{"content":"The Visual C++ compiler enables the definition of a destructor to deterministically clean up objects.","pos":[27190,27291]},{"content":"Use the destructor to release all resources that you want to deterministically release.","pos":[27292,27379]},{"content":"If a finalizer is present, call it from the destructor, to avoid code duplication.","pos":[27381,27463]},{"content":"If the code that consumes your type does not call the destructor, the garbage collector eventually releases all managed resources.","pos":[28004,28134]},{"content":"The presence of a destructor does not imply the presence of a finalizer.","pos":[28141,28213]},{"content":"However, the presence of a finalizer implies that you must define a destructor and call the finalizer from that destructor.","pos":[28214,28337]},{"content":"This provides for the deterministic release of unmanaged resources.","pos":[28338,28405]},{"content":"Calling the destructor suppresses—by using &lt;xref:System.GC.SuppressFinalize%2A&gt;—finalization of the object.","pos":[28412,28519],"source":"Calling the destructor suppresses—by using <xref:System.GC.SuppressFinalize%2A>—finalization of the object."},{"content":"If the destructor is not called, your type's finalizer will eventually be called by the garbage collector.","pos":[28520,28626]},{"content":"Deterministically cleaning up your object's resources by calling the destructor can improve performance compared with letting the CLR nondeterministically finalize the object.","pos":[28633,28808]},{"pos":[28815,28908],"content":"Code that's written in Visual C++ and compiled by using <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> runs a type's destructor if:","source":"Code that's written in Visual C++ and compiled by using **/clr** runs a type's destructor if:"},{"content":"An object that's created by using stack semantics goes out of scope.","pos":[28918,28986]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>C++ Stack Semantics for Reference Types<ept id=\"p1\">](../dotnet/cpp-stack-semantics-for-reference-types.md)</ept>.","pos":[28987,29109],"source":" For more information, see [C++ Stack Semantics for Reference Types](../dotnet/cpp-stack-semantics-for-reference-types.md)."},{"content":"An exception is thrown during the object's construction.","pos":[29119,29175]},{"content":"The object is a member in an object whose destructor is running.","pos":[29185,29249]},{"pos":[29259,29437],"content":"You call the <bpt id=\"p1\">[</bpt>delete<ept id=\"p1\">](../cpp/delete-operator-cpp.md)</ept> operator on a handle (<bpt id=\"p2\">[</bpt>Handle to Object Operator (^)<ept id=\"p2\">](../windows/handle-to-object-operator-hat-cpp-component-extensions.md)</ept>).","source":"You call the [delete](../cpp/delete-operator-cpp.md) operator on a handle ([Handle to Object Operator (^)](../windows/handle-to-object-operator-hat-cpp-component-extensions.md))."},{"content":"You explicitly call the destructor.","pos":[29447,29482]},{"content":"If your type is being consumed by a client that's written in another language, the destructor is called as follows:","pos":[29489,29604]},{"content":"On a call to &lt;xref:System.IDisposable.Dispose%2A&gt;.","pos":[29614,29664],"source":"On a call to <xref:System.IDisposable.Dispose%2A>."},{"pos":[29674,29715],"content":"On a call to <ph id=\"ph1\">`Dispose(void)`</ph> on the type.","source":"On a call to `Dispose(void)` on the type."},{"pos":[29725,29781],"content":"If the type goes out of scope in a C# <ph id=\"ph1\">`using`</ph> statement.","source":"If the type goes out of scope in a C# `using` statement."},{"pos":[29788,30031],"content":"If you create an object of a reference type on the managed heap (not using stack semantics for reference types), use <bpt id=\"p1\">[</bpt>try-finally<ept id=\"p1\">](../cpp/try-finally-statement.md)</ept> syntax to ensure that an exception doesn't prevent the destructor from running.","source":"If you create an object of a reference type on the managed heap (not using stack semantics for reference types), use [try-finally](../cpp/try-finally-statement.md) syntax to ensure that an exception doesn't prevent the destructor from running."},{"content":"If your type has a destructor, the compiler generates a <ph id=\"ph1\">`Dispose`</ph> method that implements &lt;xref:System.IDisposable&gt;.","pos":[30240,30355],"source":"If your type has a destructor, the compiler generates a `Dispose` method that implements <xref:System.IDisposable>."},{"content":"If a type that's written in Visual C++ and has a destructor that's consumed from another language, calling <ph id=\"ph1\">`IDisposable::Dispose`</ph> on that type causes the type's destructor to be called.","pos":[30356,30541],"source":" If a type that's written in Visual C++ and has a destructor that's consumed from another language, calling `IDisposable::Dispose` on that type causes the type's destructor to be called."},{"content":"When the type is consumed from a Visual C++ client, you can't directly call <ph id=\"ph1\">`Dispose`</ph>; instead, call the destructor by using the <ph id=\"ph2\">`delete`</ph> operator.","pos":[30542,30689],"source":" When the type is consumed from a Visual C++ client, you can't directly call `Dispose`; instead, call the destructor by using the `delete` operator."},{"pos":[30696,30823],"content":"If your type has a finalizer, the compiler generates a <ph id=\"ph1\">`Finalize(void)`</ph> method that overrides &lt;xref:System.Object.Finalize%2A&gt;.","source":"If your type has a finalizer, the compiler generates a `Finalize(void)` method that overrides <xref:System.Object.Finalize%2A>."},{"content":"If a type has either a finalizer or a destructor, the compiler generates a <ph id=\"ph1\">`Dispose(bool)`</ph> method, according to the design pattern.","pos":[30830,30961],"source":"If a type has either a finalizer or a destructor, the compiler generates a `Dispose(bool)` method, according to the design pattern."},{"content":"(For information, see <bpt id=\"p1\">[</bpt>Dispose Pattern<ept id=\"p1\">](http://msdn.microsoft.com/Library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb)</ept>).","pos":[30962,31075],"source":" (For information, see [Dispose Pattern](http://msdn.microsoft.com/Library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb))."},{"content":"You cannot explicitly author or call <ph id=\"ph1\">`Dispose(bool)`</ph> in Visual C++.","pos":[31076,31143],"source":" You cannot explicitly author or call `Dispose(bool)` in Visual C++."},{"content":"If a type has a base class that conforms to the design pattern, the destructors for all base classes are called when the destructor for the derived class is called.","pos":[31150,31314]},{"content":"(If your type is written in Visual C++, the compiler ensures that your types implement this pattern.) In other words, the destructor of a reference class chains to its bases and members as specified by the C++ standard—first the class’s destructor is run, then the destructors for its members in the reverse of the order in which they were constructed, and finally the destructors for its base classes in the reverse of the order in which they were constructed.","pos":[31315,31776]},{"content":"Destructors and finalizers are not allowed inside value types or interfaces.","pos":[31783,31859]},{"content":"A finalizer can only be defined or declared in a reference type.","pos":[31866,31930]},{"content":"Like a constructor and destructor, a finalizer has no return type.","pos":[31931,31997]},{"content":"After an object's finalizer runs, finalizers in any base classes are also called, beginning with the least derived type.","pos":[32004,32124]},{"content":"Finalizers for data members are not automatically chained to by a class’s finalizer.","pos":[32125,32209]},{"content":"If a finalizer deletes a native pointer in a managed type, you must ensure that references to or through the native pointer are not prematurely collected; call the destructor on the managed type instead of using &lt;xref:System.GC.KeepAlive%2A&gt;.","pos":[32216,32458],"source":"If a finalizer deletes a native pointer in a managed type, you must ensure that references to or through the native pointer are not prematurely collected; call the destructor on the managed type instead of using <xref:System.GC.KeepAlive%2A>."},{"content":"At compile time, you can detect whether a type has a finalizer or a destructor.","pos":[32465,32544]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Compiler Support for Type Traits<ept id=\"p1\">](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)</ept>.","pos":[32545,32679],"source":" For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)."},{"content":"The next sample shows two types, one that has unmanaged resources and one that has managed resources that are deterministically released.","pos":[32686,32823]},{"content":"See Also","pos":[34182,34190]},{"content":"Classes and Structs","pos":[34195,34214]},{"content":"Classes and Structs","pos":[34281,34300]}],"content":"---\ntitle: \"How to: Define and Consume Classes and Structs (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"structs [C++]\"\n  - \"classes [C++], instantiating\"\nms.assetid: 1c03cb0d-1459-4b5e-af65-97d6b3094fd7\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# How to: Define and Consume Classes and Structs (C++/CLI)\nThis article shows how to define and consume user-defined reference types and value types in [!INCLUDE[cppcli](../build/reference/includes/cppcli_md.md)].  \n  \n##  <a name=\"BKMK_Contents\"></a> Contents  \n [Object instantiation](#BKMK_Object_instantiation)  \n  \n [Implicitly abstract classes](#BKMK_Implicitly_abstract_classes)  \n  \n [Type visibility](#BKMK_Type_visibility)  \n  \n [Member visibility](#BKMK_Member_visibility)  \n  \n [Public and private native classes](#BKMK_Public_and_private_native_classes)  \n  \n [Static constructors](#BKMK_Static_constructors)  \n  \n [Semantics of the this pointer](#BKMK_Semantics_of_the_this_pointer)  \n  \n [Hide-by-signature functions](#BKMK_Hide_by_signature_functions)  \n  \n [Copy constructors](#BKMK_Copy_constructors)  \n  \n [Destructors and finalizers](#BKMK_Destructors_and_finalizers)  \n  \n##  <a name=\"BKMK_Object_instantiation\"></a> Object instantiation  \n Reference (ref) types and value types can only be instantiated on the managed heap, not on the stack or on the native heap.  \n  \n```  \n// mcppv2_ref_class2.cpp  \n// compile with: /clr  \nref class MyClass {  \npublic:  \n   int i;  \n  \n   // nested class  \n   ref class MyClass2 {  \n   public:  \n      int i;  \n   };  \n  \n   // nested interface  \n   interface struct MyInterface {  \n      void f();  \n   };  \n};  \n  \nref class MyClass2 : public MyClass::MyInterface {  \npublic:  \n   virtual void f() {  \n      System::Console::WriteLine(\"test\");  \n   }  \n};  \n  \npublic value struct MyStruct {  \n   void f() {  \n      System::Console::WriteLine(\"test\");  \n   }     \n};  \n  \nint main() {  \n   // instantiate ref type on garbage-collected heap  \n   MyClass ^ p_MyClass = gcnew MyClass;  \n   p_MyClass -> i = 4;  \n  \n   // instantiate value type on garbage-collected heap  \n   MyStruct ^ p_MyStruct = gcnew MyStruct;  \n   p_MyStruct -> f();  \n  \n   // instantiate value type on the stack  \n   MyStruct p_MyStruct2;  \n   p_MyStruct2.f();  \n  \n   // instantiate nested ref type on garbage-collected heap  \n   MyClass::MyClass2 ^ p_MyClass2 = gcnew MyClass::MyClass2;  \n   p_MyClass2 -> i = 5;  \n}  \n```  \n  \n##  <a name=\"BKMK_Implicitly_abstract_classes\"></a> Implicitly abstract classes  \n An *implicitly abstract class* can't be instantiated. A class is implicitly abstract if the base type of the class is an interface and the class does not implement all of the interface's member functions.  \n  \n If you are unable to construct objects from a class that's derived from an interface, the reason might be that the class is implicitly abstract. For more information about abstract classes, see [abstract](../windows/abstract-cpp-component-extensions.md).  \n  \n The following code example demonstrates that the `MyClass` class cannot be instantiated because function `MyClass::func2` is not implemented. To enable the example to compile, uncomment `MyClass::func2`.  \n  \n```  \n// mcppv2_ref_class5.cpp  \n// compile with: /clr  \ninterface struct MyInterface {  \n   void func1();  \n   void func2();  \n};  \n  \nref class MyClass : public MyInterface {  \npublic:  \n   void func1(){}  \n   // void func2(){}  \n};  \n  \nint main() {  \n   MyClass ^ h_MyClass = gcnew MyClass;   // C2259   \n                                          // To resolve, uncomment MyClass::func2.  \n}  \n```  \n  \n##  <a name=\"BKMK_Type_visibility\"></a> Type visibility  \n You can control the visibility of common language runtime (CLR) types so that, if an assembly is referenced, types in the assembly can be visible or not visible outside the assembly.  \n  \n `public` indicates that a type is visible to any source file that contains a `#using` directive for the assembly that contains the type.  `private` indicates that a type is not visible to source files that contain a `#using` directive for the assembly that contains the type. However, private types are visible within the same assembly. By default, the visibility for a class is `private`.  \n  \n By default prior to Visual C++ 2005, native types had public accessibility outside the assembly. Enable [Compiler Warning (level 1) C4692](../error-messages/compiler-warnings/compiler-warning-level-1-c4692.md) to help you see where private native types are used incorrectly. Use the [make_public](../preprocessor/make-public.md) pragma to give public accessibility to a native type in a source code file that you can't modify.  \n  \n For more information, see [#using Directive](../preprocessor/hash-using-directive-cpp.md).  \n  \n The following sample shows how to declare types and specify their accessibility, and then access those types inside the assembly. Of course, if an assembly that has private types is referenced by using `#using`, only public types in the assembly are visible.  \n  \n```  \n// type_visibility.cpp  \n// compile with: /clr  \nusing namespace System;  \n// public type, visible inside and outside assembly  \npublic ref struct Public_Class {  \n   void Test(){Console::WriteLine(\"in Public_Class\");}  \n};  \n  \n// private type, visible inside but not outside assembly  \nprivate ref struct Private_Class {  \n   void Test(){Console::WriteLine(\"in Private_Class\");}  \n};  \n  \n// default accessibility is private  \nref class Private_Class_2 {  \npublic:  \n   void Test(){Console::WriteLine(\"in Private_Class_2\");}  \n};  \n  \nint main() {  \n   Public_Class ^ a = gcnew Public_Class;  \n   a->Test();  \n  \n   Private_Class ^ b = gcnew Private_Class;  \n   b->Test();  \n  \n   Private_Class_2 ^ c = gcnew Private_Class_2;  \n   c->Test();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nin Public_Class  \nin Private_Class  \nin Private_Class_2  \n```  \n  \n Now, let's rewrite the previous sample so that it is built as a DLL.  \n  \n```  \n// type_visibility_2.cpp  \n// compile with: /clr /LD  \nusing namespace System;  \n// public type, visible inside and outside the assembly  \npublic ref struct Public_Class {  \n   void Test(){Console::WriteLine(\"in Public_Class\");}  \n};  \n  \n// private type, visible inside but not outside the assembly  \nprivate ref struct Private_Class {  \n   void Test(){Console::WriteLine(\"in Private_Class\");}  \n};  \n  \n// by default, accessibility is private  \nref class Private_Class_2 {  \npublic:  \n   void Test(){Console::WriteLine(\"in Private_Class_2\");}  \n};  \n```  \n  \n The next sample shows how to access types outside the assembly. In this sample, the client consumes the component that's built in the previous sample.  \n  \n```  \n// type_visibility_3.cpp  \n// compile with: /clr  \n#using \"type_visibility_2.dll\"  \nint main() {  \n   Public_Class ^ a = gcnew Public_Class;  \n   a->Test();  \n  \n   // private types not accessible outside the assembly  \n   // Private_Class ^ b = gcnew Private_Class;  \n   // Private_Class_2 ^ c = gcnew Private_Class_2;  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nin Public_Class  \n```  \n  \n##  <a name=\"BKMK_Member_visibility\"></a> Member visibility  \n You can make access to a member of a public class from within the same assembly different than access to it from outside the assembly by using pairs of the access specifiers `public`, `protected`, and `private`  \n  \n This table summarizes the effect of the various access specifiers:  \n  \n|Specifier|Effect|  \n|---------------|------------|  \n|public|Member is accessible inside and outside the assembly.  See [public](../cpp/public-cpp.md) for more information.|  \n|private|Member is not accessible, neither inside nor outside the assembly.  See [private](../cpp/private-cpp.md) for more information.|  \n|protected|Member is accessible inside and outside the assembly, but only to derived types.  See [protected](../cpp/protected-cpp.md) for more information.|  \n|internal|Member is public inside the assembly but private outside the assembly.  `internal` is a context-sensitive keyword.  For more information, see [Context-Sensitive Keywords](../windows/context-sensitive-keywords-cpp-component-extensions.md).|  \n|public protected -or- protected public|Member is public inside the assembly but protected outside the assembly.|  \n|private protected -or- protected private|Member is protected inside the assembly but private outside the assembly.|  \n  \n The following sample shows a public type that has members that are declared with the different accessibilities, and then shows the accessing of those members from inside the assembly.  \n  \n```  \n  \n// compile with: /clr  \nusing namespace System;  \n// public type, visible inside and outside the assembly  \npublic ref class Public_Class {  \npublic:  \n   void Public_Function(){System::Console::WriteLine(\"in Public_Function\");}  \n  \nprivate:  \n   void Private_Function(){System::Console::WriteLine(\"in Private_Function\");}  \n  \nprotected:  \n   void Protected_Function(){System::Console::WriteLine(\"in Protected_Function\");}  \n  \ninternal:  \n   void Internal_Function(){System::Console::WriteLine(\"in Internal_Function\");}  \n  \nprotected public:  \n   void Protected_Public_Function(){System::Console::WriteLine(\"in Protected_Public_Function\");}  \n  \npublic protected:  \n   void Public_Protected_Function(){System::Console::WriteLine(\"in Public_Protected_Function\");}  \n  \nprivate protected:  \n   void Private_Protected_Function(){System::Console::WriteLine(\"in Private_Protected_Function\");}  \n  \nprotected private:  \n   void Protected_Private_Function(){System::Console::WriteLine(\"in Protected_Private_Function\");}  \n};  \n  \n// a derived type, calls protected functions  \nref struct MyClass : public Public_Class {  \n   void Test() {  \n      Console::WriteLine(\"=======================\");  \n      Console::WriteLine(\"in function of derived class\");  \n      Protected_Function();  \n      Protected_Private_Function();  \n      Private_Protected_Function();  \n      Console::WriteLine(\"exiting function of derived class\");  \n      Console::WriteLine(\"=======================\");  \n   }  \n};  \n  \nint main() {  \n   Public_Class ^ a = gcnew Public_Class;  \n   MyClass ^ b = gcnew MyClass;  \n   a->Public_Function();  \n   a->Protected_Public_Function();  \n   a->Public_Protected_Function();  \n  \n   // accessible inside but not outside the assembly  \n   a->Internal_Function();  \n  \n   // call protected functions  \n   b->Test();  \n  \n   // not accessible inside or outside the assembly  \n   // a->Private_Function();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nin Public_Function  \nin Protected_Public_Function  \nin Public_Protected_Function  \nin Internal_Function  \n=======================  \nin function of derived class  \nin Protected_Function  \nin Protected_Private_Function  \nin Private_Protected_Function  \nexiting function of derived class  \n=======================  \n```  \n  \n Now let's build the previous sample as a DLL.  \n  \n```  \n  \n// compile with: /clr /LD  \nusing namespace System;  \n// public type, visible inside and outside the assembly  \npublic ref class Public_Class {  \npublic:  \n   void Public_Function(){System::Console::WriteLine(\"in Public_Function\");}  \n  \nprivate:  \n   void Private_Function(){System::Console::WriteLine(\"in Private_Function\");}  \n  \nprotected:  \n   void Protected_Function(){System::Console::WriteLine(\"in Protected_Function\");}  \n  \ninternal:  \n   void Internal_Function(){System::Console::WriteLine(\"in Internal_Function\");}  \n  \nprotected public:  \n   void Protected_Public_Function(){System::Console::WriteLine(\"in Protected_Public_Function\");}  \n  \npublic protected:  \n   void Public_Protected_Function(){System::Console::WriteLine(\"in Public_Protected_Function\");}  \n  \nprivate protected:  \n   void Private_Protected_Function(){System::Console::WriteLine(\"in Private_Protected_Function\");}  \n  \nprotected private:  \n   void Protected_Private_Function(){System::Console::WriteLine(\"in Protected_Private_Function\");}  \n};  \n  \n// a derived type, calls protected functions  \nref struct MyClass : public Public_Class {  \n   void Test() {  \n      Console::WriteLine(\"=======================\");  \n      Console::WriteLine(\"in function of derived class\");  \n      Protected_Function();  \n      Protected_Private_Function();  \n      Private_Protected_Function();  \n      Console::WriteLine(\"exiting function of derived class\");  \n      Console::WriteLine(\"=======================\");  \n   }  \n};  \n```  \n  \n The following sample consumes the component that's created in the previous sample, and thereby shows how to access the members from outside the assembly.  \n  \n```  \n  \n// compile with: /clr  \n#using \"type_member_visibility_2.dll\"  \nusing namespace System;  \n// a derived type, calls protected functions  \nref struct MyClass : public Public_Class {  \n   void Test() {  \n      Console::WriteLine(\"=======================\");  \n      Console::WriteLine(\"in function of derived class\");  \n      Protected_Function();  \n      Protected_Public_Function();  \n      Public_Protected_Function();  \n      Console::WriteLine(\"exiting function of derived class\");  \n      Console::WriteLine(\"=======================\");  \n   }  \n};  \n  \nint main() {  \n   Public_Class ^ a = gcnew Public_Class;  \n   MyClass ^ b = gcnew MyClass;  \n   a->Public_Function();  \n  \n   // call protected functions  \n   b->Test();  \n  \n   // can't be called outside the assembly  \n   // a->Private_Function();  \n   // a->Internal_Function();     \n   // a->Protected_Private_Function();  \n   // a->Private_Protected_Function();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nin Public_Function  \n=======================  \nin function of derived class  \nin Protected_Function  \nin Protected_Public_Function  \nin Public_Protected_Function  \nexiting function of derived class  \n=======================  \n```  \n  \n##  <a name=\"BKMK_Public_and_private_native_classes\"></a> Public and private native classes  \n A native type can be referenced from a managed type.  For example, a function in a managed type can take a parameter whose type is a native struct.  If the managed type and function are public in an assembly, then the native type must also be public.  \n  \n```  \n  \n// native type  \npublic struct N {  \n   N(){}  \n   int i;  \n};  \n```  \n  \n Next, create the source code file that consumes the native type:  \n  \n```  \n  \n// compile with: /clr /LD  \n#include \"mcppv2_ref_class3.h\"  \n// public managed type  \npublic ref struct R {  \n   // public function that takes a native type  \n   void f(N nn) {}  \n};  \n```  \n  \n Now, compile a client:  \n  \n```  \n  \n// compile with: /clr  \n#using \"mcppv2_ref_class3.dll\"  \n  \n#include \"mcppv2_ref_class3.h\"  \n  \nint main() {  \n   R ^r = gcnew R;  \n   N n;  \n   r->f(n);  \n}  \n```  \n  \n##  <a name=\"BKMK_Static_constructors\"></a> Static constructors  \n A CLR type—for example, a class or struct—can have a static constructor that can be used to initialize static data members.  A static constructor is called at most once, and is called before any static member of the type is accessed the first time.  \n  \n An instance constructor always runs after a static constructor.  \n  \n The compiler cannot inline a call to a constructor if the class has a static constructor.  The compiler cannot inline a call to any member function if the class is a value type, has a static constructor, and does not have an instance constructor.  The CLR may inline the call, but the compiler cannot.  \n  \n Define a static constructor as a private member function, because it is meant to be called only by the CLR.  \n  \n For more information about static constructors, see [How to: Define an Interface Static Constructor (C++/CLI)](../dotnet/how-to-define-an-interface-static-constructor-cpp-cli.md) .  \n  \n```  \n  \n// compile with: /clr  \nusing namespace System;  \n  \nref class MyClass {  \nprivate:  \n   static int i = 0;  \n  \n   static MyClass() {  \n      Console::WriteLine(\"in static constructor\");  \n      i = 9;  \n   }  \n  \npublic:  \n   static void Test() {  \n      i++;  \n      Console::WriteLine(i);  \n   }  \n};  \n  \nint main() {  \n   MyClass::Test();  \n   MyClass::Test();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nin static constructor  \n10  \n11  \n```  \n  \n##  <a name=\"BKMK_Semantics_of_the_this_pointer\"></a> Semantics of the this pointer  \n When you are using Visual C++ to define types, the `this` pointer in a reference type is of type \"handle\". The `this` pointer in a value type is of type \"interior pointer\".  \n  \n These different semantics of the `this` pointer can cause unexpected behavior when a default indexer is called. The next example shows the correct way to access a default indexer in both a ref type and a value type.  \n  \n For more information, see  \n  \n-   [Handle to Object Operator (^)](../windows/handle-to-object-operator-hat-cpp-component-extensions.md)  \n  \n-   [interior_ptr (C++/CLI)](../windows/interior-ptr-cpp-cli.md)  \n  \n```  \n  \n// compile with: /clr  \nusing namespace System;  \n  \nref struct A {  \n   property Double default[Double] {  \n      Double get(Double data) {  \n         return data*data;  \n      }  \n   }  \n  \n   A() {  \n      // accessing default indexer  \n      Console::WriteLine(\"{0}\", this[3.3]);  \n   }  \n};  \n  \nvalue struct B {  \n   property Double default[Double] {  \n      Double get(Double data) {  \n         return data*data;  \n      }  \n   }  \n   void Test() {  \n      // accessing default indexer  \n      Console::WriteLine(\"{0}\", this->default[3.3]);  \n   }  \n};  \n  \nint main() {  \n   A ^ mya = gcnew A();  \n   B ^ myb = gcnew B();  \n   myb->Test();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \n10.89  \n10.89  \n```  \n  \n##  <a name=\"BKMK_Hide_by_signature_functions\"></a> Hide-by-signature functions  \n In standard C++, a function in a base class is hidden by a function that has the same name in a derived class, even if the derived-class function does not have the same number or kind of parameters. This is referred to as *hide-by-name* semantics. In a reference type, a function in a base class can only be hidden by a function in a derived class if both the name and the parameter list are the same. This is known as *hide-by-signature* semantics.  \n  \n A class is considered a hide-by-signature class when all of its functions are marked in the metadata as `hidebysig`. By default, all classes that are created under **/clr** have `hidebysig` functions. When a class has `hidebysig` functions, the compiler doesn't hide functions by name in any direct base classes, but if the compiler encounters a hide-by-name class in an inheritance chain, it continues that hide-by-name behavior.  \n  \n Under hide-by-signature semantics, when a function is called on an object, the compiler identifies the most derived class that contains a function that could satisfy the function call. If there is only one function in the class that could satisfy the call, the compiler calls that function. If there is more than one function in the class that could satisfy the call, the compiler uses overload resolution rules to determine which function to call. For more information about overload rules, see [Function Overloading](../cpp/function-overloading.md).  \n  \n For a given function call, a function in a base class might have a signature that makes it a slightly better match than a function in a derived class. However, if the function was explicitly called on an object of the derived class, the function in the derived class is called.  \n  \n Because the return value is not considered part of a function's signature, a base-class function is hidden if it has the same name and takes the same number and kind of arguments as a derived-class function, even if it differs in the type of the return value.  \n  \n The following sample shows that a function in a base class is not hidden by a function in a derived class.  \n  \n```  \n  \n// compile with: /clr  \nusing namespace System;  \nref struct Base {  \n   void Test() {   \n      Console::WriteLine(\"Base::Test\");   \n   }  \n};  \n  \nref struct Derived : public Base {  \n   void Test(int i) {   \n      Console::WriteLine(\"Derived::Test\");   \n   }  \n};  \n  \nint main() {  \n   Derived ^ t = gcnew Derived;  \n   // Test() in the base class will not be hidden  \n   t->Test();  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nBase::Test  \n```  \n  \n The next sample shows that the Visual C++ compiler calls a function in the most derived class—even if a conversion is required to match one or more of the parameters—and not call a function in a base class that is a better match for the function call.  \n  \n```  \n  \n// compile with: /clr  \nusing namespace System;  \nref struct Base {  \n   void Test2(Single d) {   \n      Console::WriteLine(\"Base::Test2\");   \n   }  \n};  \n  \nref struct Derived : public Base {  \n   void Test2(Double f) {   \n      Console::WriteLine(\"Derived::Test2\");   \n   }  \n};  \n  \nint main() {  \n   Derived ^ t = gcnew Derived;  \n   // Base::Test2 is a better match, but the compiler  \n   // calls a function in the derived class if possible  \n   t->Test2(3.14f);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nDerived::Test2  \n```  \n  \n The following sample shows that it's possible to hide a function even if the base class has the same signature as the derived class.  \n  \n```  \n  \n// compile with: /clr  \nusing namespace System;  \nref struct Base {  \n   int Test4() {   \n      Console::WriteLine(\"Base::Test4\");   \n      return 9;   \n   }  \n};  \n  \nref struct Derived : public Base {  \n   char Test4() {   \n      Console::WriteLine(\"Derived::Test4\");   \n      return 'a';   \n   }  \n};  \n  \nint main() {  \n   Derived ^ t = gcnew Derived;  \n  \n   // Base::Test4 is hidden  \n   int i = t->Test4();  \n   Console::WriteLine(i);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nDerived::Test4  \n97  \n```  \n  \n##  <a name=\"BKMK_Copy_constructors\"></a> Copy constructors  \n The C++ standard says that a copy constructor is called when an object is moved, such that an object is created and destroyed at the same address.  \n  \n However, when **/clr** is used to compile and a function that's compiled to MSIL calls a native function where a native class—or more than one—is passed by value and where the native class has a copy constructor and/or destructor, no copy constructor is called and the object is destroyed at a different address than where it was created. This could cause problems if the class has a pointer into itself, or if the code is tracking objects by address.  \n  \n For more information, see [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md).  \n  \n The following sample demonstrates when a copy constructor is not generated.  \n  \n```  \n  \n// compile with: /clr  \n#include<stdio.h>  \n  \nstruct S {  \n   int i;  \n   static int n;  \n  \n   S() : i(n++) {   \n      printf_s(\"S object %d being constructed, this=%p\\n\", i, this);   \n   }  \n  \n   S(S const& rhs) : i(n++) {   \n      printf_s(\"S object %d being copy constructed from S object \"  \n               \"%d, this=%p\\n\", i, rhs.i, this);   \n   }  \n  \n   ~S() {  \n      printf_s(\"S object %d being destroyed, this=%p\\n\", i, this);   \n   }  \n};  \n  \nint S::n = 0;  \n  \n#pragma managed(push,off)  \nvoid f(S s1, S s2) {  \n   printf_s(\"in function f\\n\");  \n}  \n#pragma managed(pop)  \n  \nint main() {  \n   S s;  \n   S t;  \n   f(s,t);  \n}  \n```  \n  \n **Output**  \n  \n```Output  \nS object 0 being constructed, this=0018F378  \nS object 1 being constructed, this=0018F37C  \nS object 2 being copy constructed from S object 1, this=0018F380  \nS object 3 being copy constructed from S object 0, this=0018F384  \nS object 4 being copy constructed from S object 2, this=0018F2E4  \nS object 2 being destroyed, this=0018F380  \nS object 5 being copy constructed from S object 3, this=0018F2E0  \nS object 3 being destroyed, this=0018F384  \nin function f  \nS object 5 being destroyed, this=0018F2E0  \nS object 4 being destroyed, this=0018F2E4  \nS object 1 being destroyed, this=0018F37C  \nS object 0 being destroyed, this=0018F378  \n```  \n  \n##  <a name=\"BKMK_Destructors_and_finalizers\"></a> Destructors and finalizers  \n Destructors in a reference type perform a deterministic clean-up of resources. Finalizers clean up unmanaged resources and can be called deterministically by the destructor or nondeterministically by the garbage collector. For information about destructors in standard C++, see [Destructors](../cpp/destructors-cpp.md).  \n  \n```  \nclass classname {  \n   ~classname() {}   // destructor  \n   ! classname() {}   // finalizer  \n};  \n```  \n  \n The behavior of destructors in a managed Visual C++ class differs from Managed Extensions for C++. For more information about this change, see [Changes in Destructor Semantics](../dotnet/changes-in-destructor-semantics.md).  \n  \n The CLR garbage collector deletes unused managed objects and releases their memory when they are no longer required. However, a type may use resources that the garbage collector does not know how to release. These resources are known as unmanaged resources (native file handles, for example). We recommend that you release all unmanaged resources in the finalizer. Because managed resources are released nondeterministically by the garbage collector, it's not safe to refer to managed resources in a finalizer because it's possible that the garbage collector has already cleaned up that managed resource.  \n  \n A Visual C++ finalizer is not the same as the <xref:System.Object.Finalize%2A> method. (CLR documentation uses finalizer and the <xref:System.Object.Finalize%2A> method synonymously). The <xref:System.Object.Finalize%2A> method is called by the garbage collector, which invokes each finalizer in a class inheritance chain. Unlike Visual C++ destructors, a derived-class finalizer call does not cause the compiler to invoke the finalizer in all base classes.  \n  \n Because the Visual C++ compiler supports deterministic release of resources, don't try to implement the <xref:System.IDisposable.Dispose%2A> or <xref:System.Object.Finalize%2A> methods. However, if you're familiar with these methods, here's how a Visual C++ finalizer and a destructor that calls the finalizer map to the <xref:System.IDisposable.Dispose%2A> pattern:  \n  \n```  \n// Visual C++ code  \nref class T {  \n   ~T() { this->!T(); }   // destructor calls finalizer  \n   !T() {}   // finalizer  \n};  \n  \n// equivalent to the Dispose pattern  \nvoid Dispose(bool disposing) {  \n   if (disposing) {  \n      ~T();  \n   } else {  \n      !T();  \n   }  \n}  \n```  \n  \n A managed type may also use managed resources that you would prefer to release deterministically, and not leave to the garbage collector to release nondeterministically at some point after the object is no longer required. The deterministic release of resources can significantly improve performance.  \n  \n The Visual C++ compiler enables the definition of a destructor to deterministically clean up objects. Use the destructor to release all resources that you want to deterministically release.  If a finalizer is present, call it from the destructor, to avoid code duplication.  \n  \n```  \n  \n// compile with: /clr /c  \nref struct A {  \n   // destructor cleans up all resources  \n   ~A() {  \n      // clean up code to release managed resource  \n      // ...  \n      // to avoid code duplication,   \n      // call finalizer to release unmanaged resources  \n      this->!A();  \n   }  \n  \n   // finalizer cleans up unmanaged resources  \n   // destructor or garbage collector will  \n   // clean up managed resources  \n   !A() {  \n      // clean up code to release unmanaged resources  \n      // ...  \n   }  \n};  \n```  \n  \n If the code that consumes your type does not call the destructor, the garbage collector eventually releases all managed resources.  \n  \n The presence of a destructor does not imply the presence of a finalizer. However, the presence of a finalizer implies that you must define a destructor and call the finalizer from that destructor. This provides for the deterministic release of unmanaged resources.  \n  \n Calling the destructor suppresses—by using <xref:System.GC.SuppressFinalize%2A>—finalization of the object. If the destructor is not called, your type's finalizer will eventually be called by the garbage collector.  \n  \n Deterministically cleaning up your object's resources by calling the destructor can improve performance compared with letting the CLR nondeterministically finalize the object.  \n  \n Code that's written in Visual C++ and compiled by using **/clr** runs a type's destructor if:  \n  \n-   An object that's created by using stack semantics goes out of scope. For more information, see [C++ Stack Semantics for Reference Types](../dotnet/cpp-stack-semantics-for-reference-types.md).  \n  \n-   An exception is thrown during the object's construction.  \n  \n-   The object is a member in an object whose destructor is running.  \n  \n-   You call the [delete](../cpp/delete-operator-cpp.md) operator on a handle ([Handle to Object Operator (^)](../windows/handle-to-object-operator-hat-cpp-component-extensions.md)).  \n  \n-   You explicitly call the destructor.  \n  \n If your type is being consumed by a client that's written in another language, the destructor is called as follows:  \n  \n-   On a call to <xref:System.IDisposable.Dispose%2A>.  \n  \n-   On a call to `Dispose(void)` on the type.  \n  \n-   If the type goes out of scope in a C# `using` statement.  \n  \n If you create an object of a reference type on the managed heap (not using stack semantics for reference types), use [try-finally](../cpp/try-finally-statement.md) syntax to ensure that an exception doesn't prevent the destructor from running.  \n  \n```  \n  \n// compile with: /clr  \nref struct A {  \n   ~A() {}  \n};  \n  \nint main() {  \n   A ^ MyA = gcnew A;  \n   try {  \n      // use MyA  \n   }  \n   finally {  \n      delete MyA;  \n   }  \n}  \n```  \n  \n If your type has a destructor, the compiler generates a `Dispose` method that implements <xref:System.IDisposable>. If a type that's written in Visual C++ and has a destructor that's consumed from another language, calling `IDisposable::Dispose` on that type causes the type's destructor to be called. When the type is consumed from a Visual C++ client, you can't directly call `Dispose`; instead, call the destructor by using the `delete` operator.  \n  \n If your type has a finalizer, the compiler generates a `Finalize(void)` method that overrides <xref:System.Object.Finalize%2A>.  \n  \n If a type has either a finalizer or a destructor, the compiler generates a `Dispose(bool)` method, according to the design pattern. (For information, see [Dispose Pattern](http://msdn.microsoft.com/Library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb)). You cannot explicitly author or call `Dispose(bool)` in Visual C++.  \n  \n If a type has a base class that conforms to the design pattern, the destructors for all base classes are called when the destructor for the derived class is called. (If your type is written in Visual C++, the compiler ensures that your types implement this pattern.) In other words, the destructor of a reference class chains to its bases and members as specified by the C++ standard—first the class’s destructor is run, then the destructors for its members in the reverse of the order in which they were constructed, and finally the destructors for its base classes in the reverse of the order in which they were constructed.  \n  \n Destructors and finalizers are not allowed inside value types or interfaces.  \n  \n A finalizer can only be defined or declared in a reference type. Like a constructor and destructor, a finalizer has no return type.  \n  \n After an object's finalizer runs, finalizers in any base classes are also called, beginning with the least derived type. Finalizers for data members are not automatically chained to by a class’s finalizer.  \n  \n If a finalizer deletes a native pointer in a managed type, you must ensure that references to or through the native pointer are not prematurely collected; call the destructor on the managed type instead of using <xref:System.GC.KeepAlive%2A>.  \n  \n At compile time, you can detect whether a type has a finalizer or a destructor. For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md).  \n  \n The next sample shows two types, one that has unmanaged resources and one that has managed resources that are deterministically released.  \n  \n```  \n  \n// compile with: /clr  \n#include <vcclr.h>  \n#include <stdio.h>  \nusing namespace System;  \nusing namespace System::IO;  \n  \nref class SystemFileWriter {  \n   FileStream ^ file;  \n   array<Byte> ^ arr;  \n   int bufLen;  \n  \npublic:  \n   SystemFileWriter(String ^ name) : file(File::Open(name, FileMode::Append)),   \n                                     arr(gcnew array<Byte>(1024)) {}  \n  \n   void Flush() {  \n      file->Write(arr, 0, bufLen);  \n      bufLen = 0;  \n   }  \n  \n   ~SystemFileWriter() {  \n      Flush();  \n      delete file;  \n   }  \n};  \n  \nref class CRTFileWriter {  \n   FILE * file;  \n   array<Byte> ^ arr;  \n   int bufLen;  \n  \n   static FILE * getFile(String ^ n) {  \n      pin_ptr<const wchar_t> name = PtrToStringChars(n);  \n      FILE * ret = 0;  \n      _wfopen_s(&ret, name, L\"ab\");  \n      return ret;  \n   }  \n  \npublic:  \n   CRTFileWriter(String ^ name) : file(getFile(name)), arr(gcnew array<Byte>(1024) ) {}  \n  \n   void Flush() {  \n      pin_ptr<Byte> buf = &arr[0];  \n      fwrite(buf, 1, bufLen, file);  \n      bufLen = 0;  \n   }  \n  \n   ~CRTFileWriter() {  \n      this->!CRTFileWriter();  \n   }  \n  \n   !CRTFileWriter() {  \n      Flush();  \n      fclose(file);  \n   }  \n};  \n  \nint main() {  \n   SystemFileWriter w(\"systest.txt\");  \n   CRTFileWriter ^ w2 = gcnew CRTFileWriter(\"crttest.txt\");  \n}  \n```  \n  \n## See Also  \n [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)   \n [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)"}