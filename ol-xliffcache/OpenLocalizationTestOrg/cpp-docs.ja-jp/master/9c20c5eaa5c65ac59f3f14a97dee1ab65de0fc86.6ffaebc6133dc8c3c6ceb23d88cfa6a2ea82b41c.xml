{"nodes":[{"pos":[12,55],"content":"&lt;iterator&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"iterator<ph id=\"ph1\">&amp;gt;</ph> functions | Microsoft Docs","pos":[4,43],"source":"iterator&gt; functions | Microsoft Docs"}]},{"content":"iterator<ph id=\"ph1\">&amp;gt;</ph> functions","pos":[262,284],"source":"iterator&gt; functions"},{"content":"advance","pos":[304,311]},{"content":"back_inserter","pos":[324,337]},{"content":"begin","pos":[356,361]},{"content":"cbegin","pos":[376,382]},{"content":"cend","pos":[394,398]},{"content":"distance","pos":[408,416]},{"content":"end","pos":[434,437]},{"content":"front_inserter","pos":[446,460]},{"content":"inserter","pos":[480,488]},{"content":"make_checked_array_iterator","pos":[506,533]},{"content":"make_move_iterator","pos":[566,584]},{"content":"make_unchecked_array_iterator","pos":[608,637]},{"content":"next","pos":[676,680]},{"content":"prev","pos":[690,694]},{"pos":[737,744],"content":"advance"},{"content":"Increments an iterator by a specified number of positions.","pos":[748,806]},{"content":"Parameters","pos":[941,951]},{"content":"The iterator that is to be incremented and that must satisfy the requirements for an input iterator.","pos":[965,1065]},{"content":"An integral type that is convertible to the iterator's difference type and that specifies the number of increments the position of the iterator is to be advanced.","pos":[1081,1243]},{"content":"Remarks","pos":[1253,1260]},{"content":"The range advanced through must be nonsingular, where the iterators must be dereferenceable or past the end.","pos":[1264,1372]},{"content":"If the <bpt id=\"p1\">**</bpt>InputIterator<ept id=\"p1\">**</ept> satisfies the requirements for a bidirectional iterator type, then <ph id=\"ph1\">`Off`</ph> may be negative.","pos":[1379,1493],"source":"If the **InputIterator** satisfies the requirements for a bidirectional iterator type, then `Off` may be negative."},{"content":"If <bpt id=\"p1\">**</bpt>InputIterator<ept id=\"p1\">**</ept> is an input or forward iterator type, <ph id=\"ph1\">`Off`</ph> must be nonnegative.","pos":[1494,1579],"source":" If **InputIterator** is an input or forward iterator type, `Off` must be nonnegative."},{"pos":[1586,1779],"content":"The advance function has constant complexity when <bpt id=\"p1\">**</bpt>InputIterator<ept id=\"p1\">**</ept> satisfies the requirements for a random-access iterator; otherwise, it has linear complexity and so is potentially expensive.","source":"The advance function has constant complexity when **InputIterator** satisfies the requirements for a random-access iterator; otherwise, it has linear complexity and so is potentially expensive."},{"content":"Example","pos":[1789,1796]},{"pos":[3007,3020],"content":"back_inserter"},{"content":"Creates an iterator that can insert elements at the back of a specified container.","pos":[3024,3106]},{"content":"Parameters","pos":[3225,3235]},{"content":"The container into which the back insertion is to be executed.","pos":[3250,3312]},{"content":"Return Value","pos":[3322,3334]},{"pos":[3338,3408],"content":"A <ph id=\"ph1\">`back_insert_iterator`</ph> associated with the container object <ph id=\"ph2\">`_Cont`</ph>.","source":"A `back_insert_iterator` associated with the container object `_Cont`."},{"content":"Remarks","pos":[3418,3425]},{"pos":[3429,3729],"content":"Within the Standard Template Library, the argument must refer to one of the three sequence containers that have the member function <ph id=\"ph1\">`push_back`</ph>: <bpt id=\"p1\">[</bpt>deque Class<ept id=\"p1\">](../standard-library/deque-class.md)</ept>, <bpt id=\"p2\">[</bpt>list Class<ept id=\"p2\">](../standard-library/list-class.md)</ept>, or <bpt id=\"p3\">[</bpt>vector Class<ept id=\"p3\">](../standard-library/vector-class.md)</ept>.","source":"Within the Standard Template Library, the argument must refer to one of the three sequence containers that have the member function `push_back`: [deque Class](../standard-library/deque-class.md), [list Class](../standard-library/list-class.md), or [vector Class](../standard-library/vector-class.md)."},{"content":"Example","pos":[3739,3746]},{"pos":[4949,4954],"content":"begin"},{"content":"Retrieves an iterator to the first element in a specified container.","pos":[4958,5026]},{"content":"Parameters","pos":[5305,5315]},{"content":"A container.","pos":[5329,5341]},{"content":"An array of objects of type <ph id=\"ph1\">`Ty`</ph>.","pos":[5359,5392],"source":" An array of objects of type `Ty`."},{"content":"Return Value","pos":[5402,5414]},{"content":"The first two template functions return <ph id=\"ph1\">`cont.begin()`</ph>.","pos":[5418,5473],"source":"The first two template functions return `cont.begin()`."},{"content":"The first function is non-constant; the second one is constant.","pos":[5474,5537]},{"pos":[5544,5588],"content":"The third template function returns <ph id=\"ph1\">`array`</ph>.","source":"The third template function returns `array`."},{"content":"Example","pos":[5598,5605]},{"pos":[5610,5737],"content":"We recommend that you use this template function in place of container member <ph id=\"ph1\">`begin()`</ph> when more generic behavior is required.","source":"We recommend that you use this template function in place of container member `begin()` when more generic behavior is required."},{"content":"The function <ph id=\"ph1\">`reverse_sort`</ph> supports containers of any kind, in addition to regular arrays, because it calls the non-member version of <ph id=\"ph2\">`begin()`</ph>.","pos":[6783,6928],"source":"The function `reverse_sort` supports containers of any kind, in addition to regular arrays, because it calls the non-member version of `begin()`."},{"content":"If <ph id=\"ph1\">`reverse_sort`</ph> were coded to use the container member <ph id=\"ph2\">`begin()`</ph>:","pos":[6929,6996],"source":" If `reverse_sort` were coded to use the container member `begin()`:"},{"content":"Then sending an array to it would cause this compiler error:","pos":[7179,7239]},{"pos":[7348,7354],"content":"cbegin"},{"content":"Retrieves a const iterator to the first element in a specified container.","pos":[7358,7431]},{"content":"Parameters","pos":[7554,7564]},{"content":"A container or initializer_list.","pos":[7578,7610]},{"content":"Return Value","pos":[7620,7632]},{"pos":[7636,7662],"content":"A constant <ph id=\"ph1\">`cont.begin()`</ph>.","source":"A constant `cont.begin()`."},{"content":"Remarks","pos":[7672,7679]},{"pos":[7683,7802],"content":"This function works with all STL containers and with <bpt id=\"p1\">[</bpt>initializer_list<ept id=\"p1\">](../standard-library/initializer-list-class.md)</ept>.","source":"This function works with all STL containers and with [initializer_list](../standard-library/initializer-list-class.md)."},{"content":"You can use this member function in place of the <ph id=\"ph1\">`begin()`</ph> template function to guarantee that the return value is <ph id=\"ph2\">`const_iterator`</ph>.","pos":[7809,7941],"source":"You can use this member function in place of the `begin()` template function to guarantee that the return value is `const_iterator`."},{"content":"Typically, it's used in conjunction with the <bpt id=\"p1\">[</bpt>auto<ept id=\"p1\">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.","pos":[7942,8072],"source":" Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example."},{"content":"In the example, consider <ph id=\"ph1\">`Container`</ph> to be a modifiable (non- <ph id=\"ph2\">`const`</ph>) container or <ph id=\"ph3\">`initializer_list`</ph> of any kind that supports <ph id=\"ph4\">`begin()`</ph> and <ph id=\"ph5\">`cbegin()`</ph>.","pos":[8073,8227],"source":" In the example, consider `Container` to be a modifiable (non- `const`) container or `initializer_list` of any kind that supports `begin()` and `cbegin()`."},{"pos":[8412,8416],"content":"cend"},{"content":"Retrieves a const iterator to the element that follows the last element in the specified container.","pos":[8420,8519]},{"content":"Parameters","pos":[8638,8648]},{"content":"A container or initializer_list.","pos":[8662,8694]},{"content":"Return Value","pos":[8704,8716]},{"pos":[8720,8744],"content":"A constant <ph id=\"ph1\">`cont.end()`</ph>.","source":"A constant `cont.end()`."},{"content":"Remarks","pos":[8754,8761]},{"pos":[8765,8884],"content":"This function works with all STL containers and with <bpt id=\"p1\">[</bpt>initializer_list<ept id=\"p1\">](../standard-library/initializer-list-class.md)</ept>.","source":"This function works with all STL containers and with [initializer_list](../standard-library/initializer-list-class.md)."},{"content":"You can use this member function in place of the <bpt id=\"p1\">[</bpt>end()<ept id=\"p1\">](../standard-library/iterator-functions.md#end)</ept> template function to guarantee that the return value is <ph id=\"ph1\">`const_iterator`</ph>.","pos":[8891,9068],"source":"You can use this member function in place of the [end()](../standard-library/iterator-functions.md#end) template function to guarantee that the return value is `const_iterator`."},{"content":"Typically, it's used in conjunction with the <bpt id=\"p1\">[</bpt>auto<ept id=\"p1\">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.","pos":[9069,9199],"source":" Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example."},{"content":"In the example, consider <ph id=\"ph1\">`Container`</ph> to be a modifiable (non- <ph id=\"ph2\">`const`</ph>) container or <ph id=\"ph3\">`initializer_list`</ph> of any kind that supports <ph id=\"ph4\">`end()`</ph> and <ph id=\"ph5\">`cend()`</ph>.","pos":[9200,9350],"source":" In the example, consider `Container` to be a modifiable (non- `const`) container or `initializer_list` of any kind that supports `end()` and `cend()`."},{"pos":[9535,9543],"content":"distance"},{"content":"Determines the number of increments between the positions addressed by two iterators.","pos":[9547,9632]},{"content":"Parameters","pos":[9798,9808]},{"content":"The first iterator whose distance from the second is to be determined.","pos":[9824,9894]},{"content":"The second iterator whose distance from the first is to be determined.","pos":[9912,9982]},{"content":"Return Value","pos":[9992,10004]},{"pos":[10008,10085],"content":"The number of times that <ph id=\"ph1\">` first`</ph> must be incremented until it equal <ph id=\"ph2\">` last`</ph>.","source":"The number of times that ` first` must be incremented until it equal ` last`."},{"content":"Remarks","pos":[10095,10102]},{"pos":[10106,10300],"content":"The distance function has constant complexity when <bpt id=\"p1\">**</bpt>InputIterator<ept id=\"p1\">**</ept> satisfies the requirements for a random-access iterator; otherwise, it has linear complexity and so is potentially expensive.","source":"The distance function has constant complexity when **InputIterator** satisfies the requirements for a random-access iterator; otherwise, it has linear complexity and so is potentially expensive."},{"content":"Example","pos":[10310,10317]},{"pos":[11561,11564],"content":"end"},{"content":"Retrieves an iterator to the element that follows the last element in the specified container.","pos":[11568,11662]},{"content":"Parameters","pos":[11932,11942]},{"content":"A container.","pos":[11956,11968]},{"content":"An array of objects of type <ph id=\"ph1\">`Ty`</ph>.","pos":[11986,12019],"source":" An array of objects of type `Ty`."},{"content":"Return Value","pos":[12029,12041]},{"pos":[12045,12153],"content":"The first two template functions return <ph id=\"ph1\">`cont.end()`</ph> (the first is non-constant and the second is constant).","source":"The first two template functions return `cont.end()` (the first is non-constant and the second is constant)."},{"pos":[12160,12211],"content":"The third template function returns <ph id=\"ph1\">`array + Size`</ph>.","source":"The third template function returns `array + Size`."},{"content":"Remarks","pos":[12221,12228]},{"pos":[12232,12313],"content":"For a code example, see <bpt id=\"p1\">[</bpt>begin<ept id=\"p1\">](../standard-library/iterator-functions.md#begin)</ept>.","source":"For a code example, see [begin](../standard-library/iterator-functions.md#begin)."},{"pos":[12354,12368],"content":"front_inserter"},{"content":"Creates an iterator that can insert elements at the front of a specified container.","pos":[12372,12455]},{"content":"Parameters","pos":[12576,12586]},{"content":"The container object whose front is having an element inserted.","pos":[12601,12664]},{"content":"Return Value","pos":[12674,12686]},{"pos":[12690,12761],"content":"A <ph id=\"ph1\">`front_insert_iterator`</ph> associated with the container object <ph id=\"ph2\">`_Cont`</ph>.","source":"A `front_insert_iterator` associated with the container object `_Cont`."},{"content":"Remarks","pos":[12771,12778]},{"pos":[12782,12975],"content":"The member function <bpt id=\"p1\">[</bpt>front_insert_iterator<ept id=\"p1\">](../standard-library/front-insert-iterator-class.md#front_insert_iterator__front_insert_iterator)</ept> of the front_insert_iterator class may also be used.","source":"The member function [front_insert_iterator](../standard-library/front-insert-iterator-class.md#front_insert_iterator__front_insert_iterator) of the front_insert_iterator class may also be used."},{"pos":[12982,13191],"content":"Within the Standard Template Library, the argument must refer to one of the two sequence containers that have the member function <ph id=\"ph1\">`push_back`</ph>: <bpt id=\"p1\">[</bpt>deque Class<ept id=\"p1\">](../standard-library/deque-class.md)</ept> or \"list Class\".","source":"Within the Standard Template Library, the argument must refer to one of the two sequence containers that have the member function `push_back`: [deque Class](../standard-library/deque-class.md) or \"list Class\"."},{"content":"Example","pos":[13201,13208]},{"pos":[14304,14312],"content":"inserter"},{"pos":[14316,14455],"content":"A helper template function that lets you use <ph id=\"ph1\">`inserter(``_Cont``,``_Where``)`</ph> instead of <ph id=\"ph2\">`insert_iterator&lt;Container&gt;(``_Cont`</ph>, <ph id=\"ph3\">`_Where``)`</ph>.","source":"A helper template function that lets you use `inserter(``_Cont``,``_Where``)` instead of `insert_iterator<Container>(``_Cont`, `_Where``)`."},{"content":"Parameters","pos":[14614,14624]},{"content":"The container to which new elements are to be added.","pos":[14639,14691]},{"content":"An iterator locating the point of insertion.","pos":[14710,14754]},{"content":"Remarks","pos":[14764,14771]},{"pos":[14775,14938],"content":"The template function returns <bpt id=\"p1\">[</bpt>insert_iterator<ept id=\"p1\">](../standard-library/insert-iterator-class.md#insert_iterator__insert_iterator)</ept><ph id=\"ph1\">`&lt;Container&gt;(``_Cont``,`</ph> <ph id=\"ph2\">`_Where``)`</ph>.","source":"The template function returns [insert_iterator](../standard-library/insert-iterator-class.md#insert_iterator__insert_iterator)`<Container>(``_Cont``,` `_Where``)`."},{"content":"Example","pos":[14948,14955]},{"pos":[16043,16070],"content":"make_checked_array_iterator"},{"pos":[16074,16199],"content":"Creates a <bpt id=\"p1\">[</bpt>checked_array_iterator<ept id=\"p1\">](../standard-library/checked-array-iterator-class.md)</ept> that can be used by other algorithms.","source":"Creates a [checked_array_iterator](../standard-library/checked-array-iterator-class.md) that can be used by other algorithms."},{"pos":[16207,16422],"content":"[!NOTE]\n This function is a Microsoft extension of the Standard C++ Library. Code implemented by using this function is not portable to C++ Standard build environments that do not support this Microsoft extension.","leadings":["","> "],"nodes":[{"content":" This function is a Microsoft extension of the Standard C++ Library. Code implemented by using this function is not portable to C++ Standard build environments that do not support this Microsoft extension.","pos":[8,213],"nodes":[{"content":"This function is a Microsoft extension of the Standard C++ Library.","pos":[1,68]},{"content":"Code implemented by using this function is not portable to C++ Standard build environments that do not support this Microsoft extension.","pos":[69,205]}]}]},{"content":"Parameters","pos":[16589,16599]},{"content":"A pointer to the destination array.","pos":[16612,16647]},{"content":"The size of the destination array.","pos":[16664,16698]},{"content":"Optional index into the array.","pos":[16716,16746]},{"content":"Return Value","pos":[16756,16768]},{"pos":[16772,16812],"content":"An instance of <ph id=\"ph1\">`checked_array_iterator`</ph>.","source":"An instance of `checked_array_iterator`."},{"content":"Remarks","pos":[16822,16829]},{"pos":[16833,16913],"content":"The <ph id=\"ph1\">`make_checked_array_iterator`</ph> function is defined in the <ph id=\"ph2\">`stdext`</ph> namespace.","source":"The `make_checked_array_iterator` function is defined in the `stdext` namespace."},{"content":"This function takes a raw pointer—which would ordinarily cause concern about bounds overrun—and wraps it in a <bpt id=\"p1\">[</bpt>checked_array_iterator<ept id=\"p1\">](../standard-library/checked-array-iterator-class.md)</ept> class that does checking.","pos":[16920,17133],"source":"This function takes a raw pointer—which would ordinarily cause concern about bounds overrun—and wraps it in a [checked_array_iterator](../standard-library/checked-array-iterator-class.md) class that does checking."},{"content":"Because that class is marked as checked, the STL doesn't warn about it.","pos":[17134,17205]},{"content":"For more information and code examples, see <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept>.","pos":[17206,17312],"source":" For more information and code examples, see [Checked Iterators](../standard-library/checked-iterators.md)."},{"content":"Example","pos":[17322,17329]},{"content":"In the following example, a <bpt id=\"p1\">[</bpt>vector<ept id=\"p1\">](../standard-library/vector-class.md)</ept> is created and populated with 10 items.","pos":[17334,17447],"source":"In the following example, a [vector](../standard-library/vector-class.md) is created and populated with 10 items."},{"content":"The contents of the vector are copied into an array by using the copy algorithm, and then <ph id=\"ph1\">`make_checked_array_iterator`</ph> is used to specify the destination.","pos":[17448,17603],"source":" The contents of the vector are copied into an array by using the copy algorithm, and then `make_checked_array_iterator` is used to specify the destination."},{"content":"This is followed by an intentional violation of the bounds checking so that a debug assertion failure is triggered.","pos":[17604,17719]},{"pos":[19163,19181],"content":"make_move_iterator"},{"pos":[19185,19272],"content":"Creates a <ph id=\"ph1\">`move iterator`</ph> that contains the provided iterator as the <ph id=\"ph2\">`stored`</ph> iterator.","source":"Creates a `move iterator` that contains the provided iterator as the `stored` iterator."},{"content":"Parameters","pos":[19392,19402]},{"content":"The iterator stored in the new move iterator.","pos":[19415,19460]},{"content":"Remarks","pos":[19470,19477]},{"pos":[19481,19548],"content":"The template function returns <ph id=\"ph1\">`move_iterator``&lt;Iterator&gt;(``_It``)`</ph>.","source":"The template function returns `move_iterator``<Iterator>(``_It``)`."},{"pos":[19604,19633],"content":"make_unchecked_array_iterator"},{"pos":[19637,19767],"content":"Creates an <bpt id=\"p1\">[</bpt>unchecked_array_iterator<ept id=\"p1\">](../standard-library/unchecked-array-iterator-class.md)</ept> that can be used by other algorithms.","source":"Creates an [unchecked_array_iterator](../standard-library/unchecked-array-iterator-class.md) that can be used by other algorithms."},{"pos":[19775,19990],"content":"[!NOTE]\n This function is a Microsoft extension of the Standard C++ Library. Code implemented by using this function is not portable to C++ Standard build environments that do not support this Microsoft extension.","leadings":["","> "],"nodes":[{"content":" This function is a Microsoft extension of the Standard C++ Library. Code implemented by using this function is not portable to C++ Standard build environments that do not support this Microsoft extension.","pos":[8,213],"nodes":[{"content":"This function is a Microsoft extension of the Standard C++ Library.","pos":[1,68]},{"content":"Code implemented by using this function is not portable to C++ Standard build environments that do not support this Microsoft extension.","pos":[69,205]}]}]},{"content":"Parameters","pos":[20116,20126]},{"content":"A pointer to the destination array.","pos":[20139,20174]},{"content":"Return Value","pos":[20184,20196]},{"pos":[20200,20242],"content":"An instance of <ph id=\"ph1\">`unchecked_array_iterator`</ph>.","source":"An instance of `unchecked_array_iterator`."},{"content":"Remarks","pos":[20252,20259]},{"pos":[20263,20345],"content":"The <ph id=\"ph1\">`make_unchecked_array_iterator`</ph> function is defined in the <ph id=\"ph2\">`stdext`</ph> namespace.","source":"The `make_unchecked_array_iterator` function is defined in the `stdext` namespace."},{"content":"This function takes a raw pointer and wraps it in a class that performs no checking and therefore optimizes away to nothing, but it also silences compiler warnings such as <bpt id=\"p1\">[</bpt>C4996<ept id=\"p1\">](../error-messages/compiler-warnings/compiler-warning-level-3-c4996.md)</ept>.","pos":[20352,20603],"source":"This function takes a raw pointer and wraps it in a class that performs no checking and therefore optimizes away to nothing, but it also silences compiler warnings such as [C4996](../error-messages/compiler-warnings/compiler-warning-level-3-c4996.md)."},{"content":"Therefore, this is a targeted way to deal with unchecked-pointer warnings without globally silencing them or incurring the cost of checking.","pos":[20604,20744]},{"content":"For more information and code examples, see <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept>.","pos":[20745,20851],"source":" For more information and code examples, see [Checked Iterators](../standard-library/checked-iterators.md)."},{"content":"Example","pos":[20861,20868]},{"content":"In the following example, a <bpt id=\"p1\">[</bpt>vector<ept id=\"p1\">](../standard-library/vector-class.md)</ept> is created and populated with 10 items.","pos":[20873,20986],"source":"In the following example, a [vector](../standard-library/vector-class.md) is created and populated with 10 items."},{"content":"The contents of the vector are copied into an array by using the copy algorithm, and then <ph id=\"ph1\">`make_unchecked_array_iterator`</ph> is used to specify the destination.","pos":[20987,21144],"source":" The contents of the vector are copied into an array by using the copy algorithm, and then `make_unchecked_array_iterator` is used to specify the destination."},{"pos":[22292,22296],"content":"next"},{"content":"Iterates a specified number of times and returns the new iterator position.","pos":[22300,22375]},{"content":"Parameters","pos":[22552,22562]},{"content":"The current position.","pos":[22578,22599]},{"content":"The number of times to iterate.","pos":[22616,22647]},{"content":"Return Value","pos":[22657,22669]},{"pos":[22673,22736],"content":"Returns the new iterator position after iterating <ph id=\"ph1\">`_Off`</ph> times.","source":"Returns the new iterator position after iterating `_Off` times."},{"content":"Remarks","pos":[22746,22753]},{"pos":[22757,22818],"content":"The template function returns <ph id=\"ph1\">`next`</ph> incremented <ph id=\"ph2\">`_Off`</ph> times","source":"The template function returns `next` incremented `_Off` times"},{"pos":[22849,22853],"content":"prev"},{"content":"Iterates in reverse a specified number of times and returns the new iterator position.","pos":[22857,22943]},{"content":"Parameters","pos":[23152,23162]},{"content":"The current position.","pos":[23178,23199]},{"content":"The number of times to iterate.","pos":[23216,23247]},{"content":"Remarks","pos":[23257,23264]},{"pos":[23268,23329],"content":"The template function returns <ph id=\"ph1\">`next`</ph> decremented <ph id=\"ph2\">`off`</ph> times.","source":"The template function returns `next` decremented `off` times."},{"content":"See Also","pos":[23338,23346]},{"content":"iterator&gt;","pos":[23353,23362],"source":"iterator>"}],"content":"---\ntitle: \"&lt;iterator&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 4a57c9a3-7e36-411f-8655-e0be2eec88e7\ncaps.latest.revision: 16\nmanager: \"ghogen\"\n---\n# &lt;iterator&gt; functions\n||||  \n|-|-|-|  \n|[advance](#advance)|[back_inserter](#back_inserter)|[begin](#begin)|  \n|[cbegin](#cbegin)|[cend](#cend)|[distance](#distance)|  \n|[end](#end)|[front_inserter](#front_inserter)|[inserter](#inserter)|  \n|[make_checked_array_iterator](#make_checked_array_iterator)|[make_move_iterator](#make_move_iterator)|[make_unchecked_array_iterator](#make_unchecked_array_iterator)|  \n|[next](#next)|[prev](#prev)|  \n  \n##  <a name=\"advance\"></a>  advance  \n Increments an iterator by a specified number of positions.  \n  \n```  \ntemplate <class InputIterator, class Distance>  \nvoid advance(\n    InputIterator& InIt,   \n    Distance Off);\n```  \n  \n### Parameters  \n `InIt`  \n The iterator that is to be incremented and that must satisfy the requirements for an input iterator.  \n  \n `Off`  \n An integral type that is convertible to the iterator's difference type and that specifies the number of increments the position of the iterator is to be advanced.  \n  \n### Remarks  \n The range advanced through must be nonsingular, where the iterators must be dereferenceable or past the end.  \n  \n If the **InputIterator** satisfies the requirements for a bidirectional iterator type, then `Off` may be negative. If **InputIterator** is an input or forward iterator type, `Off` must be nonnegative.  \n  \n The advance function has constant complexity when **InputIterator** satisfies the requirements for a random-access iterator; otherwise, it has linear complexity and so is potentially expensive.  \n  \n### Example  \n  \n```cpp  \n// iterator_advance.cpp  \n// compile with: /EHsc  \n#include <iterator>  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   int i;  \n  \n   list<int> L;  \n   for ( i = 1 ; i < 9 ; ++i )    \n   {  \n      L.push_back ( i );  \n   }  \n   list <int>::iterator L_Iter, LPOS = L.begin ( );  \n  \n   cout << \"The list L is: ( \";  \n   for ( L_Iter = L.begin( ) ; L_Iter != L.end( ); L_Iter++)  \n      cout << *L_Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"The iterator LPOS initially points to the first element: \"  \n        << *LPOS << \".\" << endl;  \n  \n   advance ( LPOS , 4 );  \n   cout << \"LPOS is advanced 4 steps forward to point\"  \n        << \" to the fifth element: \"  \n        << *LPOS << \".\" << endl;  \n  \n   advance ( LPOS , -3 );  \n   cout << \"LPOS is moved 3 steps back to point to the \"  \n        << \"2nd element: \" << *LPOS << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe list L is: ( 1 2 3 4 5 6 7 8 ).  \nThe iterator LPOS initially points to the first element: 1.  \nLPOS is advanced 4 steps forward to point to the fifth element: 5.  \nLPOS is moved 3 steps back to point to the 2nd element: 2.  \n```  \n  \n##  <a name=\"back_inserter\"></a>  back_inserter  \n Creates an iterator that can insert elements at the back of a specified container.  \n  \n```  \ntemplate <class Container>  \nback_insert_iterator<Container> back_inserter(Container& _Cont);\n```  \n  \n### Parameters  \n `_Cont`  \n The container into which the back insertion is to be executed.  \n  \n### Return Value  \n A `back_insert_iterator` associated with the container object `_Cont`.  \n  \n### Remarks  \n Within the Standard Template Library, the argument must refer to one of the three sequence containers that have the member function `push_back`: [deque Class](../standard-library/deque-class.md), [list Class](../standard-library/list-class.md), or [vector Class](../standard-library/vector-class.md).  \n  \n### Example  \n  \n```cpp  \n// iterator_back_inserter.cpp  \n// compile with: /EHsc  \n#include <iterator>  \n#include <vector>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   int i;  \n  \n   vector<int> vec;  \n   for ( i = 0 ; i < 3 ; ++i )    \n   {  \n      vec.push_back ( i );  \n   }  \n  \n   vector <int>::iterator vIter;  \n   cout << \"The initial vector vec is: ( \";  \n   for ( vIter = vec.begin ( ) ; vIter != vec.end ( ); vIter++)  \n      cout << *vIter << \" \";  \n   cout << \").\" << endl;  \n  \n   // Insertions can be done with template function  \n   back_insert_iterator<vector<int> > backiter ( vec );  \n *backiter = 30;  \n   backiter++;  \n *backiter = 40;  \n  \n   // Alternatively, insertions can be done with the  \n   // back_insert_iterator member function  \n   back_inserter ( vec ) = 500;  \n   back_inserter ( vec ) = 600;  \n  \n   cout << \"After the insertions, the vector vec is: ( \";  \n   for ( vIter = vec.begin ( ) ; vIter != vec.end ( ); vIter++ )  \n      cout << *vIter << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nThe initial vector vec is: ( 0 1 2 ).  \nAfter the insertions, the vector vec is: ( 0 1 2 30 40 500 600 ).  \n```  \n  \n##  <a name=\"begin\"></a>  begin  \n Retrieves an iterator to the first element in a specified container.  \n  \n```  \ntemplate <class Container>  \nauto begin(Container& cont)  `\n   -> decltype(cont.begin());\n\ntemplate <class Container>  \nauto begin(const Container& cont)   `\n   -> decltype(cont.begin());\n\ntemplate <class Ty, class Size>  \nTy *begin(Ty (& array)[Size]);\n```  \n  \n### Parameters  \n `cont`  \n A container.  \n  \n `array`  \n An array of objects of type `Ty`.  \n  \n### Return Value  \n The first two template functions return `cont.begin()`. The first function is non-constant; the second one is constant.  \n  \n The third template function returns `array`.  \n  \n### Example  \n  We recommend that you use this template function in place of container member `begin()` when more generic behavior is required.  \n  \n```cpp  \n// cl.exe /EHsc /nologo /W4 /MTd   \n#include <algorithm>  \n#include <functional>  \n#include <iostream>  \n#include <iterator>  \n#include <vector>  \n  \ntemplate <typename C> void reverse_sort(C& c) {  \n    using std::begin;  \n    using std::end;  \n  \n    std::sort(begin(c), end(c), std::greater<>());  \n}  \n  \ntemplate <typename C> void print(const C& c) {  \n    for (const auto& e : c) {  \n        std::cout << e << \" \";  \n    }  \n  \n    std::cout << \"\\n\";  \n}  \n  \nint main() {  \n    std::vector<int> v = { 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 };  \n  \n    print(v);  \n    reverse_sort(v);  \n    print(v);  \n  \n    std::cout << \"--\\n\";  \n  \n    int arr[] = { 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1 };  \n  \n    print(arr);  \n    reverse_sort(arr);  \n    print(arr);  \n}  \n  \n```  \n  \n```  \nOutput:  \n11 34 17 52 26 13 40 20 10 5 16 8 4 2 1  \n52 40 34 26 20 17 16 13 11 10 8 5 4 2 1  \n--  \n23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1  \n160 106 80 70 53 40 35 23 20 16 10 8 5 4 2 1  \n```  \n  \n  The function `reverse_sort` supports containers of any kind, in addition to regular arrays, because it calls the non-member version of `begin()`. If `reverse_sort` were coded to use the container member `begin()`:  \n  \n```cpp  \ntemplate <typename C>  \nvoid reverse_sort(C& c) {  \n    using std::begin;  \n    using std::end;  \n \n    std::sort(c.begin(), c.end(), std::greater<>());\n\n}  \n```  \n  \n Then sending an array to it would cause this compiler error:  \n  \n```  \nerror C2228: left of '.begin' must have class/struct/union  \n```  \n  \n##  <a name=\"cbegin\"></a>  cbegin  \n Retrieves a const iterator to the first element in a specified container.  \n  \n```  \ntemplate <class Container>  \nauto cbegin(const Container& cont)   `\n   -> decltype(cont.begin());\n```  \n  \n### Parameters  \n `cont`  \n A container or initializer_list.  \n  \n### Return Value  \n A constant `cont.begin()`.  \n  \n### Remarks  \n This function works with all STL containers and with [initializer_list](../standard-library/initializer-list-class.md).  \n  \n You can use this member function in place of the `begin()` template function to guarantee that the return value is `const_iterator`. Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example. In the example, consider `Container` to be a modifiable (non- `const`) container or `initializer_list` of any kind that supports `begin()` and `cbegin()`.  \n  \n```cpp  \n \nauto i1 = Container.begin();\n// i1 is Container<T>::iterator  \nauto i2 = Container.cbegin();\n\n// i2 is Container<T>::const_iterator  \n```  \n  \n##  <a name=\"cend\"></a>  cend  \n Retrieves a const iterator to the element that follows the last element in the specified container.  \n  \n```  \ntemplate <class Container>  \nauto cend(const Container& cont)   `\n   -> decltype(cont.end());\n```  \n  \n### Parameters  \n `cont`  \n A container or initializer_list.  \n  \n### Return Value  \n A constant `cont.end()`.  \n  \n### Remarks  \n This function works with all STL containers and with [initializer_list](../standard-library/initializer-list-class.md).  \n  \n You can use this member function in place of the [end()](../standard-library/iterator-functions.md#end) template function to guarantee that the return value is `const_iterator`. Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example. In the example, consider `Container` to be a modifiable (non- `const`) container or `initializer_list` of any kind that supports `end()` and `cend()`.  \n  \n```cpp  \n \nauto i1 = Container.end();\n// i1 is Container<T>::iterator  \nauto i2 = Container.cend();\n\n// i2 is Container<T>::const_iterator  \n```  \n  \n##  <a name=\"distance\"></a>  distance  \n Determines the number of increments between the positions addressed by two iterators.  \n  \n```  \ntemplate <class InputIterator>  \ntypename iterator_traits<InputIterator>::difference_type distance(InputIterator first, InputIterator last);\n```  \n  \n### Parameters  \n ` first`  \n The first iterator whose distance from the second is to be determined.  \n  \n ` last`  \n The second iterator whose distance from the first is to be determined.  \n  \n### Return Value  \n The number of times that ` first` must be incremented until it equal ` last`.  \n  \n### Remarks  \n The distance function has constant complexity when **InputIterator** satisfies the requirements for a random-access iterator; otherwise, it has linear complexity and so is potentially expensive.  \n  \n### Example  \n  \n```cpp  \n// iterator_distance.cpp  \n// compile with: /EHsc  \n#include <iterator>  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   int i;  \n  \n   list<int> L;  \n   for ( i = -1 ; i < 9 ; ++i )   \n   {  \n      L.push_back ( 2 * i );  \n   }  \n   list <int>::iterator L_Iter, LPOS = L.begin ( );  \n  \n   cout << \"The list L is: ( \";  \n   for ( L_Iter = L.begin( ) ; L_Iter != L.end( ); L_Iter++ )  \n      cout << *L_Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   cout << \"The iterator LPOS initially points to the first element: \"  \n        << *LPOS << \".\" << endl;  \n  \n   advance ( LPOS , 7 );  \n   cout << \"LPOS is advanced 7 steps forward to point \"  \n        << \" to the eighth element: \"  \n        << *LPOS << \".\" << endl;  \n  \n   list<int>::difference_type Ldiff ;  \n   Ldiff = distance ( L.begin ( ) , LPOS );  \n   cout << \"The distance from L.begin( ) to LPOS is: \"  \n        << Ldiff << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe list L is: ( -2 0 2 4 6 8 10 12 14 16 ).  \nThe iterator LPOS initially points to the first element: -2.  \nLPOS is advanced 7 steps forward to point  to the eighth element: 12.  \nThe distance from L.begin( ) to LPOS is: 7.  \n```  \n  \n##  <a name=\"end\"></a>  end  \n Retrieves an iterator to the element that follows the last element in the specified container.  \n  \n```  \ntemplate <class Container>  \nauto end(Container& cont)   `\n   -> decltype(cont.end());\n\ntemplate <class Container>  \nauto end(const Container& cont)   `\n   -> decltype(cont.end());\n\ntemplate <class Ty, class Size>  \nTy *end(Ty (& array)[Size]);\n```  \n  \n### Parameters  \n `cont`  \n A container.  \n  \n `array`  \n An array of objects of type `Ty`.  \n  \n### Return Value  \n The first two template functions return `cont.end()` (the first is non-constant and the second is constant).  \n  \n The third template function returns `array + Size`.  \n  \n### Remarks  \n For a code example, see [begin](../standard-library/iterator-functions.md#begin).  \n  \n##  <a name=\"front_inserter\"></a>  front_inserter  \n Creates an iterator that can insert elements at the front of a specified container.  \n  \n```  \ntemplate <class Container>  \nfront_insert_iterator<Container> front_inserter(Container& _Cont);\n```  \n  \n### Parameters  \n `_Cont`  \n The container object whose front is having an element inserted.  \n  \n### Return Value  \n A `front_insert_iterator` associated with the container object `_Cont`.  \n  \n### Remarks  \n The member function [front_insert_iterator](../standard-library/front-insert-iterator-class.md#front_insert_iterator__front_insert_iterator) of the front_insert_iterator class may also be used.  \n  \n Within the Standard Template Library, the argument must refer to one of the two sequence containers that have the member function `push_back`: [deque Class](../standard-library/deque-class.md) or \"list Class\".  \n  \n### Example  \n  \n```cpp  \n// iterator_front_inserter.cpp  \n// compile with: /EHsc  \n#include <iterator>  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   int i;  \n   list <int>::iterator L_Iter;  \n  \n   list<int> L;  \n   for ( i = -1 ; i < 9 ; ++i )  \n   {  \n      L.push_back ( i );  \n   }  \n  \n   cout << \"The list L is:\\n ( \";  \n   for ( L_Iter = L.begin( ) ; L_Iter != L.end( ); L_Iter++)  \n      cout << *L_Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   // Using the template function to insert an element  \n   front_insert_iterator< list < int> > Iter(L);  \n *Iter = 100;  \n  \n   // Alternatively, you may use the front_insert member function  \n   front_inserter ( L ) = 200;  \n  \n   cout << \"After the front insertions, the list L is:\\n ( \";  \n   for ( L_Iter = L.begin( ) ; L_Iter != L.end( ); L_Iter++)  \n      cout << *L_Iter << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nThe list L is:  \n ( -1 0 1 2 3 4 5 6 7 8 ).  \nAfter the front insertions, the list L is:  \n ( 200 100 -1 0 1 2 3 4 5 6 7 8 ).  \n```  \n  \n##  <a name=\"inserter\"></a>  inserter  \n A helper template function that lets you use `inserter(``_Cont``,``_Where``)` instead of `insert_iterator<Container>(``_Cont`, `_Where``)`.  \n  \n```  \ntemplate <class Container>  \ninsert_iterator<Container>  \ninserter(\n    Container& _Cont,  \n    typename Container::iterator _Where);\n```  \n  \n### Parameters  \n `_Cont`  \n The container to which new elements are to be added.  \n  \n `_Where`  \n An iterator locating the point of insertion.  \n  \n### Remarks  \n The template function returns [insert_iterator](../standard-library/insert-iterator-class.md#insert_iterator__insert_iterator)`<Container>(``_Cont``,` `_Where``)`.  \n  \n### Example  \n  \n```cpp  \n// iterator_inserter.cpp  \n// compile with: /EHsc  \n#include <iterator>  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   int i;  \n   list <int>::iterator L_Iter;  \n  \n   list<int> L;  \n   for (i = 2 ; i < 5 ; ++i )    \n   {  \n      L.push_back ( 10 * i );  \n   }  \n  \n   cout << \"The list L is:\\n ( \";  \n   for ( L_Iter = L.begin( ) ; L_Iter != L.end( ); L_Iter++ )  \n      cout << *L_Iter << \" \";  \n   cout << \").\" << endl;  \n  \n   // Using the template version to insert an element  \n   insert_iterator<list <int> > Iter( L, L.begin ( ) );  \n *Iter = 1;  \n  \n   // Alternatively, using the member function to insert an element  \n   inserter ( L, L.end ( ) ) = 500;  \n  \n   cout << \"After the insertions, the list L is:\\n ( \";  \n   for ( L_Iter = L.begin( ) ; L_Iter != L.end( ); L_Iter++)  \n      cout << *L_Iter << \" \";  \n   cout << \").\" << endl;  \n}  \n```  \n  \n```Output  \nThe list L is:  \n ( 20 30 40 ).  \nAfter the insertions, the list L is:  \n ( 1 20 30 40 500 ).  \n```  \n  \n##  <a name=\"make_checked_array_iterator\"></a>  make_checked_array_iterator  \n Creates a [checked_array_iterator](../standard-library/checked-array-iterator-class.md) that can be used by other algorithms.  \n  \n> [!NOTE]\n>  This function is a Microsoft extension of the Standard C++ Library. Code implemented by using this function is not portable to C++ Standard build environments that do not support this Microsoft extension.  \n  \n```  \ntemplate <class Iter>  \nchecked_array_iterator<Iter> \n    make_checked_array_iterator(\n Iter Ptr,  \n    size_t Size,  \n    size_t Index = 0);\n```  \n  \n### Parameters  \n `Ptr`  \n A pointer to the destination array.  \n  \n `Size`  \n The size of the destination array.  \n  \n `Index`  \n Optional index into the array.  \n  \n### Return Value  \n An instance of `checked_array_iterator`.  \n  \n### Remarks  \n The `make_checked_array_iterator` function is defined in the `stdext` namespace.  \n  \n This function takes a raw pointer—which would ordinarily cause concern about bounds overrun—and wraps it in a [checked_array_iterator](../standard-library/checked-array-iterator-class.md) class that does checking. Because that class is marked as checked, the STL doesn't warn about it. For more information and code examples, see [Checked Iterators](../standard-library/checked-iterators.md).  \n  \n### Example  \n  In the following example, a [vector](../standard-library/vector-class.md) is created and populated with 10 items. The contents of the vector are copied into an array by using the copy algorithm, and then `make_checked_array_iterator` is used to specify the destination. This is followed by an intentional violation of the bounds checking so that a debug assertion failure is triggered.  \n  \n```cpp  \n// make_checked_array_iterator.cpp  \n// compile with: /EHsc /W4 /MTd  \n  \n#include <algorithm>  \n#include <iterator> // stdext::make_checked_array_iterator  \n#include <memory> // std::make_unique  \n#include <iostream>  \n#include <vector>  \n#include <string>  \n  \nusing namespace std;  \n  \ntemplate <typename C> void print(const string& s, const C& c) {  \n    cout << s;  \n  \n    for (const auto& e : c) {  \n        cout << e << \" \";  \n    }  \n  \n    cout << endl;  \n}  \n  \nint main()  \n{  \n    const size_t dest_size = 10;  \n    // Old-school but not exception safe, favor make_unique<int[]>  \n    // int* dest = new int[dest_size];  \n    unique_ptr<int[]> updest = make_unique<int[]>(dest_size);  \n    int* dest = updest.get(); // get a raw pointer for the demo  \n  \n    vector<int> v;  \n  \n    for (int i = 0; i < dest_size; ++i) {  \n        v.push_back(i);  \n    }  \n    print(\"vector v: \", v);  \n  \n    copy(v.begin(), v.end(), stdext::make_checked_array_iterator(dest, dest_size));  \n  \n    cout << \"int array dest: \";  \n    for (int i = 0; i < dest_size; ++i) {  \n        cout << dest[i] << \" \";  \n    }  \n    cout << endl;  \n  \n    // Add another element to the vector to force an overrun.  \n    v.push_back(10);  \n    // The next line causes a debug assertion when it executes.  \n    copy(v.begin(), v.end(), stdext::make_checked_array_iterator(dest, dest_size));  \n}  \n  \n```  \n  \n##  <a name=\"make_move_iterator\"></a>  make_move_iterator  \n Creates a `move iterator` that contains the provided iterator as the `stored` iterator.  \n  \n```  \ntemplate <class Iterator>  \nmove_iterator<Iterator>  \nmake_move_iterator(const Iterator& _It);\n```  \n  \n### Parameters  \n `_It`  \n The iterator stored in the new move iterator.  \n  \n### Remarks  \n The template function returns `move_iterator``<Iterator>(``_It``)`.  \n  \n##  <a name=\"make_unchecked_array_iterator\"></a>  make_unchecked_array_iterator  \n Creates an [unchecked_array_iterator](../standard-library/unchecked-array-iterator-class.md) that can be used by other algorithms.  \n  \n> [!NOTE]\n>  This function is a Microsoft extension of the Standard C++ Library. Code implemented by using this function is not portable to C++ Standard build environments that do not support this Microsoft extension.  \n  \n```  \ntemplate <class Iter>  \nunchecked_array_iterator<Iter> \n    make_unchecked_array_iterator(Iter Ptr);\n```  \n  \n### Parameters  \n `Ptr`  \n A pointer to the destination array.  \n  \n### Return Value  \n An instance of `unchecked_array_iterator`.  \n  \n### Remarks  \n The `make_unchecked_array_iterator` function is defined in the `stdext` namespace.  \n  \n This function takes a raw pointer and wraps it in a class that performs no checking and therefore optimizes away to nothing, but it also silences compiler warnings such as [C4996](../error-messages/compiler-warnings/compiler-warning-level-3-c4996.md). Therefore, this is a targeted way to deal with unchecked-pointer warnings without globally silencing them or incurring the cost of checking. For more information and code examples, see [Checked Iterators](../standard-library/checked-iterators.md).  \n  \n### Example  \n  In the following example, a [vector](../standard-library/vector-class.md) is created and populated with 10 items. The contents of the vector are copied into an array by using the copy algorithm, and then `make_unchecked_array_iterator` is used to specify the destination.  \n  \n```cpp  \n// make_unchecked_array_iterator.cpp  \n// compile with: /EHsc /W4 /MTd  \n  \n#include <algorithm>  \n#include <iterator> // stdext::make_unchecked_array_iterator  \n#include <iostream>  \n#include <vector>  \n#include <string>  \n  \nusing namespace std;  \n  \ntemplate <typename C> void print(const string& s, const C& c) {  \n    cout << s;  \n  \n    for (const auto& e : c) {  \n        cout << e << \" \";  \n    }  \n  \n    cout << endl;  \n}  \n  \nint main()  \n{  \n    const size_t dest_size = 10;  \n    int *dest = new int[dest_size];  \n    vector<int> v;  \n  \n    for (int i = 0; i < dest_size; ++i) {  \n        v.push_back(i);  \n    }  \n    print(\"vector v: \", v);  \n  \n    // COMPILER WARNING SILENCED: stdext::unchecked_array_iterator is marked as checked in debug mode  \n    // (it performs no checking, so an overrun will trigger undefined behavior)  \n    copy(v.begin(), v.end(), stdext::make_unchecked_array_iterator(dest));  \n  \n    cout << \"int array dest: \";  \n    for (int i = 0; i < dest_size; ++i) {  \n        cout << dest[i] << \" \";  \n    }  \n    cout << endl;  \n  \n    delete[] dest;  \n}  \n  \n```  \n  \n##  <a name=\"next\"></a>  next  \n Iterates a specified number of times and returns the new iterator position.  \n  \n```  \ntemplate <class InputIterator>  \nInputIterator next(\n    InputIterator first,  \n    typename iterator_traits<InputIterator>::difference_type _Off = 1);\n```  \n  \n### Parameters  \n ` first`  \n The current position.  \n  \n `_Off`  \n The number of times to iterate.  \n  \n### Return Value  \n Returns the new iterator position after iterating `_Off` times.  \n  \n### Remarks  \n The template function returns `next` incremented `_Off` times  \n  \n##  <a name=\"prev\"></a>  prev  \n Iterates in reverse a specified number of times and returns the new iterator position.  \n  \n```  \ntemplate <class BidirectionalIterator>  \nBidirectionalIterator prev(\n    BidirectionalIterator first,  \n    typename iterator_traits<BidirectionalIterator>::difference_type _Off = 1);\n```  \n  \n### Parameters  \n ` first`  \n The current position.  \n  \n `_Off`  \n The number of times to iterate.  \n  \n### Remarks  \n The template function returns `next` decremented `off` times.  \n  \n## See Also  \n [\\<iterator>](../standard-library/iterator.md)\n\n"}