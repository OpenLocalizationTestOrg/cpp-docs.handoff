{"nodes":[{"pos":[12,83],"content":"How to: Create and Use CComPtr and CComQIPtr Instances | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Create and Use CComPtr and CComQIPtr Instances | Microsoft Docs","pos":[0,71]}]},{"content":"How to: Create and Use CComPtr and CComQIPtr Instances","pos":[590,644]},{"content":"In classic Windows programming, libraries are often implemented as COM objects (or more precisely, as COM servers).","pos":[645,760]},{"content":"Many Windows operating system components are implemented as COM servers, and many contributors provide libraries in this form.","pos":[761,887]},{"content":"For information about the basics of COM, see <bpt id=\"p1\">[</bpt>Component Object Model (COM)<ept id=\"p1\">](http://msdn.microsoft.com/en-us/3578ca42-a4b6-44b3-ad5b-aeb5fa61f3f4)</ept>.","pos":[888,1034],"source":" For information about the basics of COM, see [Component Object Model (COM)](http://msdn.microsoft.com/en-us/3578ca42-a4b6-44b3-ad5b-aeb5fa61f3f4)."},{"content":"When you instantiate a Component Object Model (COM) object, store the interface pointer in a COM smart pointer, which performs the reference counting by using calls to <ph id=\"ph1\">`AddRef`</ph> and <ph id=\"ph2\">`Release`</ph> in the destructor.","pos":[1041,1250],"source":"When you instantiate a Component Object Model (COM) object, store the interface pointer in a COM smart pointer, which performs the reference counting by using calls to `AddRef` and `Release` in the destructor."},{"content":"If you are using the Active Template Library (ATL) or the Microsoft Foundation Class Library (MFC), then use the <ph id=\"ph1\">`CComPtr`</ph> smart pointer.","pos":[1251,1388],"source":" If you are using the Active Template Library (ATL) or the Microsoft Foundation Class Library (MFC), then use the `CComPtr` smart pointer."},{"content":"If you are not using ATL or MFC, then use <ph id=\"ph1\">`_com_ptr_t`</ph>.","pos":[1389,1444],"source":" If you are not using ATL or MFC, then use `_com_ptr_t`."},{"content":"Because there is no COM equivalent to <ph id=\"ph1\">`std::unique_ptr`</ph>, use these smart pointers for both single-owner and multiple-owner scenarios.","pos":[1445,1578],"source":" Because there is no COM equivalent to `std::unique_ptr`, use these smart pointers for both single-owner and multiple-owner scenarios."},{"content":"Both <ph id=\"ph1\">`CComPtr`</ph> and <ph id=\"ph2\">`ComQIPtr`</ph> support move operations that have rvalue references.","pos":[1579,1661],"source":" Both `CComPtr` and `ComQIPtr` support move operations that have rvalue references."},{"content":"Example","pos":[1670,1677]},{"content":"The following example shows how to use <ph id=\"ph1\">`CComPtr`</ph> to instantiate a COM object and obtain pointers to its interfaces.","pos":[1681,1796],"source":"The following example shows how to use `CComPtr` to instantiate a COM object and obtain pointers to its interfaces."},{"content":"Notice that the <ph id=\"ph1\">`CComPtr::CoCreateInstance`</ph> member function is used to create the COM object, instead of the Win32 function that has the same name.","pos":[1797,1944],"source":" Notice that the `CComPtr::CoCreateInstance` member function is used to create the COM object, instead of the Win32 function that has the same name."},{"pos":[1962,1983],"content":"COM_smart_pointers#01"},{"content":"and its relatives are part of the ATL and are defined in atlcomcli.h.","pos":[2086,2155]},{"content":"is declared in comip.h.","pos":[2169,2192]},{"content":"The compiler creates specializations of <ph id=\"ph1\">`_com_ptr_t`</ph> when it generates wrapper classes for type libraries.","pos":[2193,2299],"source":" The compiler creates specializations of `_com_ptr_t` when it generates wrapper classes for type libraries."},{"content":"Example","pos":[2308,2315]},{"content":"ATL also provides <ph id=\"ph1\">`CComQIPtr`</ph>, which has a simpler syntax for querying a COM object to retrieve an additional interface.","pos":[2319,2439],"source":"ATL also provides `CComQIPtr`, which has a simpler syntax for querying a COM object to retrieve an additional interface."},{"content":"However, we recommend <ph id=\"ph1\">`CComPtr`</ph> because it does everything that <ph id=\"ph2\">`CComQIPtr`</ph> can do and is semantically more consistent with raw COM interface pointers.","pos":[2440,2591],"source":" However, we recommend `CComPtr` because it does everything that `CComQIPtr` can do and is semantically more consistent with raw COM interface pointers."},{"content":"If you use a <ph id=\"ph1\">`CComPtr`</ph> to query for an interface, the new interface pointer is placed in an out parameter.","pos":[2592,2698],"source":" If you use a `CComPtr` to query for an interface, the new interface pointer is placed in an out parameter."},{"content":"If the call fails, an HRESULT is returned, which is the typical COM pattern.","pos":[2699,2775]},{"content":"With <ph id=\"ph1\">`CComQIPtr`</ph>, the return value is the pointer itself, and if the call fails, the internal HRESULT return value cannot be accessed.","pos":[2776,2910],"source":" With `CComQIPtr`, the return value is the pointer itself, and if the call fails, the internal HRESULT return value cannot be accessed."},{"content":"The following two lines show how the error handling mechanisms in <ph id=\"ph1\">`CComPtr`</ph> and <ph id=\"ph2\">`CComQIPtr`</ph> differ.","pos":[2911,3010],"source":" The following two lines show how the error handling mechanisms in `CComPtr` and `CComQIPtr` differ."},{"pos":[3028,3049],"content":"COM_smart_pointers#02"},{"content":"Example","pos":[3144,3151]},{"content":"provides a specialization for IDispatch that enables it to store pointers to COM automation components and invoke the methods on the interface by using late binding.","pos":[3165,3330]},{"content":"is a typedef for <ph id=\"ph1\">`CComQIPtr&lt;IDispatch, &amp;IIDIDispatch&gt;`</ph>, which is implicitly convertible to <ph id=\"ph2\">`CComPtr&lt;IDispatch&gt;`</ph>.","pos":[3352,3464],"source":" is a typedef for `CComQIPtr<IDispatch, &IIDIDispatch>`, which is implicitly convertible to `CComPtr<IDispatch>`."},{"content":"Therefore, when any of these three names appears in code, it is equivalent to <ph id=\"ph1\">`CComPtr&lt;IDispatch&gt;`</ph>.","pos":[3465,3564],"source":" Therefore, when any of these three names appears in code, it is equivalent to `CComPtr<IDispatch>`."},{"content":"The following example shows how to obtain a pointer to the Microsoft Word object model by using a <ph id=\"ph1\">`CComPtr&lt;IDispatch&gt;`</ph>.","pos":[3565,3684],"source":" The following example shows how to obtain a pointer to the Microsoft Word object model by using a `CComPtr<IDispatch>`."},{"pos":[3702,3723],"content":"COM_smart_pointers#03"},{"content":"See Also","pos":[3818,3826]},{"content":"Smart Pointers","pos":[3831,3845]}],"content":"---\ntitle: \"How to: Create and Use CComPtr and CComQIPtr Instances | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: b0356cfb-12cc-4ee8-b988-8311ed1ab5e0\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# How to: Create and Use CComPtr and CComQIPtr Instances\nIn classic Windows programming, libraries are often implemented as COM objects (or more precisely, as COM servers). Many Windows operating system components are implemented as COM servers, and many contributors provide libraries in this form. For information about the basics of COM, see [Component Object Model (COM)](http://msdn.microsoft.com/en-us/3578ca42-a4b6-44b3-ad5b-aeb5fa61f3f4).  \n  \n When you instantiate a Component Object Model (COM) object, store the interface pointer in a COM smart pointer, which performs the reference counting by using calls to `AddRef` and `Release` in the destructor. If you are using the Active Template Library (ATL) or the Microsoft Foundation Class Library (MFC), then use the `CComPtr` smart pointer. If you are not using ATL or MFC, then use `_com_ptr_t`. Because there is no COM equivalent to `std::unique_ptr`, use these smart pointers for both single-owner and multiple-owner scenarios. Both `CComPtr` and `ComQIPtr` support move operations that have rvalue references.  \n  \n## Example  \n The following example shows how to use `CComPtr` to instantiate a COM object and obtain pointers to its interfaces. Notice that the `CComPtr::CoCreateInstance` member function is used to create the COM object, instead of the Win32 function that has the same name.  \n  \n [!code-cpp[COM_smart_pointers#01](../cpp/codesnippet/CPP/how-to-create-and-use-ccomptr-and-ccomqiptr-instances_1.cpp)]  \n  \n `CComPtr` and its relatives are part of the ATL and are defined in atlcomcli.h. `_com_ptr_t` is declared in comip.h. The compiler creates specializations of `_com_ptr_t` when it generates wrapper classes for type libraries.  \n  \n## Example  \n ATL also provides `CComQIPtr`, which has a simpler syntax for querying a COM object to retrieve an additional interface. However, we recommend `CComPtr` because it does everything that `CComQIPtr` can do and is semantically more consistent with raw COM interface pointers. If you use a `CComPtr` to query for an interface, the new interface pointer is placed in an out parameter. If the call fails, an HRESULT is returned, which is the typical COM pattern. With `CComQIPtr`, the return value is the pointer itself, and if the call fails, the internal HRESULT return value cannot be accessed. The following two lines show how the error handling mechanisms in `CComPtr` and `CComQIPtr` differ.  \n  \n [!code-cpp[COM_smart_pointers#02](../cpp/codesnippet/CPP/how-to-create-and-use-ccomptr-and-ccomqiptr-instances_2.cpp)]  \n  \n## Example  \n `CComPtr` provides a specialization for IDispatch that enables it to store pointers to COM automation components and invoke the methods on the interface by using late binding. `CComDispatchDriver` is a typedef for `CComQIPtr<IDispatch, &IIDIDispatch>`, which is implicitly convertible to `CComPtr<IDispatch>`. Therefore, when any of these three names appears in code, it is equivalent to `CComPtr<IDispatch>`. The following example shows how to obtain a pointer to the Microsoft Word object model by using a `CComPtr<IDispatch>`.  \n  \n [!code-cpp[COM_smart_pointers#03](../cpp/codesnippet/CPP/how-to-create-and-use-ccomptr-and-ccomqiptr-instances_3.cpp)]  \n  \n## See Also  \n [Smart Pointers](../cpp/smart-pointers-modern-cpp.md)"}