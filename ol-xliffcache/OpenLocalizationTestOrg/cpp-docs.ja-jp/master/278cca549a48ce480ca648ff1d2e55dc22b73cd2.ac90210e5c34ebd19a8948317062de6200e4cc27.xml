{"nodes":[{"pos":[12,45],"content":"unique_ptr Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"unique_ptr Class | Microsoft Docs","pos":[0,33]}]},{"content":"unique_ptr Class","pos":[674,690]},{"content":"Stores a pointer to an owned object or array.","pos":[691,736]},{"content":"The object/array is owned by no other <ph id=\"ph1\">`unique_ptr`</ph>.","pos":[737,788],"source":" The object/array is owned by no other `unique_ptr`."},{"content":"The object/array is destroyed when the <ph id=\"ph1\">`unique_ptr`</ph> is destroyed.","pos":[789,854],"source":" The object/array is destroyed when the `unique_ptr` is destroyed."},{"content":"Syntax","pos":[863,869]},{"content":"Parameters","pos":[2844,2854]},{"content":"A <ph id=\"ph1\">`unique_ptr`</ph>.","pos":[2869,2884],"source":" A `unique_ptr`."},{"content":"An <ph id=\"ph1\">`rvalue`</ph> of type <ph id=\"ph2\">`std::nullptr_t`</ph>.","pos":[2901,2938],"source":" An `rvalue` of type `std::nullptr_t`."},{"content":"A <ph id=\"ph1\">`pointer`</ph>.","pos":[2954,2966],"source":" A `pointer`."},{"content":"A <ph id=\"ph1\">`deleter`</ph> function that is bound to a <ph id=\"ph2\">`unique_ptr`</ph>.","pos":[2986,3039],"source":" A `deleter` function that is bound to a `unique_ptr`."},{"content":"Exceptions","pos":[3048,3058]},{"pos":[3062,3106],"content":"No exceptions are generated by <ph id=\"ph1\">`unique_ptr`</ph>.","source":"No exceptions are generated by `unique_ptr`."},{"content":"Remarks","pos":[3115,3122]},{"pos":[3126,3220],"content":"The <ph id=\"ph1\">`unique_ptr`</ph> class supersedes <ph id=\"ph2\">`auto_ptr`</ph>, and can be used as an element of STL containers.","source":"The `unique_ptr` class supersedes `auto_ptr`, and can be used as an element of STL containers."},{"pos":[3227,3370],"content":"Use the <bpt id=\"p1\">[</bpt>make_unique<ept id=\"p1\">](../standard-library/memory-functions.md#make_unique)</ept> helper function to efficiently create new instances of <ph id=\"ph1\">`unique_ptr`</ph>.","source":"Use the [make_unique](../standard-library/memory-functions.md#make_unique) helper function to efficiently create new instances of `unique_ptr`."},{"content":"uniquely manages a resource.","pos":[3390,3418]},{"content":"Each <ph id=\"ph1\">`unique_ptr`</ph> object stores a pointer to the object that it owns or stores a null pointer.","pos":[3419,3513],"source":" Each `unique_ptr` object stores a pointer to the object that it owns or stores a null pointer."},{"content":"A resource can be owned by no more than one <ph id=\"ph1\">`unique_ptr`</ph> object;  when a <ph id=\"ph2\">`unique_ptr`</ph> object that owns a particular resource is destroyed, the resource is freed.","pos":[3514,3675],"source":" A resource can be owned by no more than one `unique_ptr` object;  when a `unique_ptr` object that owns a particular resource is destroyed, the resource is freed."},{"content":"A <ph id=\"ph1\">`unique_ptr`</ph> object may be moved, but not copied;  for more information, see <bpt id=\"p1\">[</bpt>Rvalue Reference Declarator: &amp;&amp;<ept id=\"p1\">](../cpp/rvalue-reference-declarator-amp-amp.md)</ept>.","pos":[3676,3836],"source":" A `unique_ptr` object may be moved, but not copied;  for more information, see [Rvalue Reference Declarator: &&](../cpp/rvalue-reference-declarator-amp-amp.md)."},{"content":"The resource is freed by calling a stored <ph id=\"ph1\">`deleter`</ph> object of type <ph id=\"ph2\">`Del`</ph> that knows how resources are allocated for a particular <ph id=\"ph3\">`unique_ptr`</ph>.","pos":[3843,3985],"source":"The resource is freed by calling a stored `deleter` object of type `Del` that knows how resources are allocated for a particular `unique_ptr`."},{"content":"The default <ph id=\"ph1\">`deleter``default_delete``&lt;T&gt;`</ph> assumes that the resource pointed to by <ph id=\"ph2\">` ptr`</ph> is allocated with <ph id=\"ph3\">`new`</ph>, and that it can be freed by calling <ph id=\"ph4\">`delete _``Ptr`</ph>.","pos":[3986,4153],"source":" The default `deleter``default_delete``<T>` assumes that the resource pointed to by ` ptr` is allocated with `new`, and that it can be freed by calling `delete _``Ptr`."},{"content":"(A partial specialization <ph id=\"ph1\">`unique_ptr&lt;T[]&gt;`</ph>manages array objects allocated with <ph id=\"ph2\">`new[]`</ph>, and has the default <ph id=\"ph3\">`deleter``default_delete&lt;T[]&gt;`</ph>, specialized to call delete[] <ph id=\"ph4\">` ptr`</ph>.)","pos":[4154,4332],"source":" (A partial specialization `unique_ptr<T[]>`manages array objects allocated with `new[]`, and has the default `deleter``default_delete<T[]>`, specialized to call delete[] ` ptr`.)"},{"content":"The stored pointer to an owned resource, <ph id=\"ph1\">`stored_ptr`</ph> has type <ph id=\"ph2\">`pointer`</ph>.","pos":[4339,4412],"source":"The stored pointer to an owned resource, `stored_ptr` has type `pointer`."},{"content":"It is <ph id=\"ph1\">`Del::pointer`</ph> if defined, and <ph id=\"ph2\">`T *`</ph> if not.","pos":[4413,4463],"source":" It is `Del::pointer` if defined, and `T *` if not."},{"content":"The stored <ph id=\"ph1\">`deleter`</ph> object <ph id=\"ph2\">`stored_deleter`</ph> occupies no space in the object if the <ph id=\"ph3\">`deleter`</ph> is stateless.","pos":[4464,4571],"source":" The stored `deleter` object `stored_deleter` occupies no space in the object if the `deleter` is stateless."},{"content":"Note that <ph id=\"ph1\">`Del`</ph> can be a reference type.","pos":[4572,4612],"source":" Note that `Del` can be a reference type."},{"content":"Members","pos":[4621,4628]},{"content":"Constructors","pos":[4638,4650]},{"content":"unique_ptr::unique_ptr","pos":[4672,4694]},{"pos":[4721,4767],"content":"There are seven constructors for <ph id=\"ph1\">`unique_ptr`</ph>.","source":"There are seven constructors for `unique_ptr`."},{"content":"Typedefs","pos":[4778,4786]},{"content":"deleter_type","pos":[4808,4820]},{"pos":[4837,4880],"content":"A synonym for the template parameter <ph id=\"ph1\">`Del`</ph>.","source":"A synonym for the template parameter `Del`."},{"content":"element_type","pos":[4886,4898]},{"pos":[4915,4951],"content":"A synonym for the template parameter"},{"content":"pointer","pos":[4964,4971]},{"pos":[4983,5040],"content":"A synonym for <ph id=\"ph1\">`Del::pointer`</ph> if defined, otherwise <ph id=\"ph2\">`T *`</ph>.","source":"A synonym for `Del::pointer` if defined, otherwise `T *`."},{"content":"Member Functions","pos":[5051,5067]},{"content":"unique_ptr::get","pos":[5089,5104]},{"pos":[5124,5145],"content":"Returns <ph id=\"ph1\">`stored_ptr`</ph>.","source":"Returns `stored_ptr`."},{"content":"unique_ptr::get_deleter","pos":[5151,5174]},{"pos":[5202,5242],"content":"Returns a reference to <ph id=\"ph1\">`stored_deleter`</ph>.","source":"Returns a reference to `stored_deleter`."},{"content":"unique_ptr::release","pos":[5248,5267]},{"pos":[5291,5360],"content":"stores <ph id=\"ph1\">`pointer()`</ph> in <ph id=\"ph2\">`stored_ptr`</ph> and returns its previous contents.","source":"stores `pointer()` in `stored_ptr` and returns its previous contents."},{"content":"unique_ptr::reset","pos":[5366,5383]},{"content":"Releases the currently owned resource and accepts a new resource.","pos":[5405,5470]},{"content":"unique_ptr::swap","pos":[5476,5492]},{"pos":[5513,5577],"content":"Exchanges resource and <ph id=\"ph1\">`deleter`</ph> with the provided <ph id=\"ph2\">`unique_ptr`</ph>.","source":"Exchanges resource and `deleter` with the provided `unique_ptr`."},{"content":"Operators","pos":[5588,5597]},{"content":"The operator returns a value of a type that is convertible to <ph id=\"ph1\">`bool`</ph>.","pos":[5634,5703],"source":"The operator returns a value of a type that is convertible to `bool`."},{"content":"The result of the conversion to <ph id=\"ph1\">`bool`</ph> is <ph id=\"ph2\">`true`</ph> when <ph id=\"ph3\">`get() != pointer()`</ph>, otherwise <ph id=\"ph4\">`false`</ph>.","pos":[5704,5798],"source":" The result of the conversion to `bool` is `true` when `get() != pointer()`, otherwise `false`."},{"pos":[5816,5843],"content":"The member function returns"},{"pos":[5876,5904],"content":"The member function returns*"},{"content":"unique_ptr operator=","pos":[5926,5946]},{"pos":[5973,6059],"content":"Assigns the value of a <ph id=\"ph1\">`unique_ptr`</ph> (or a <ph id=\"ph2\">`pointer-type`</ph>) to the current <ph id=\"ph3\">`unique_ptr`</ph>.","source":"Assigns the value of a `unique_ptr` (or a `pointer-type`) to the current `unique_ptr`."},{"content":"Requirements","pos":[6069,6081]},{"pos":[6085,6106],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>memory&gt;","source":"**Header:** \\<memory>"},{"pos":[6113,6131],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[6170,6182],"content":"deleter_type"},{"pos":[6186,6241],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Del`</ph>.","source":"The type is a synonym for the template parameter `Del`."},{"content":"Remarks","pos":[6294,6301]},{"pos":[6305,6360],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Del`</ph>.","source":"The type is a synonym for the template parameter `Del`."},{"pos":[6399,6411],"content":"element_type"},{"pos":[6415,6471],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Type`</ph>.","source":"The type is a synonym for the template parameter `Type`."},{"content":"Remarks","pos":[6525,6532]},{"pos":[6536,6590],"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Ty`</ph>.","source":"The type is a synonym for the template parameter `Ty`."},{"pos":[6632,6647],"content":"unique_ptr::get"},{"pos":[6651,6672],"content":"Returns <ph id=\"ph1\">`stored_ptr`</ph>.","source":"Returns `stored_ptr`."},{"content":"Remarks","pos":[6718,6725]},{"pos":[6729,6770],"content":"The member function returns <ph id=\"ph1\">`stored_ptr`</ph>.","source":"The member function returns `stored_ptr`."},{"pos":[6820,6843],"content":"unique_ptr::get_deleter"},{"pos":[6847,6887],"content":"Returns a reference to <ph id=\"ph1\">`stored_deleter`</ph>.","source":"Returns a reference to `stored_deleter`."},{"content":"Remarks","pos":[6965,6972]},{"pos":[6976,7036],"content":"The member function returns a reference to <ph id=\"ph1\">`stored_deleter`</ph>.","source":"The member function returns a reference to `stored_deleter`."},{"pos":[7085,7105],"content":"unique_ptr operator="},{"pos":[7109,7177],"content":"Assigns the address of the provided <ph id=\"ph1\">`unique_ptr`</ph> to the current one.","source":"Assigns the address of the provided `unique_ptr` to the current one."},{"content":"Parameters","pos":[7369,7379]},{"pos":[7383,7464],"content":"A <ph id=\"ph1\">`unique_ptr`</ph> reference used to assign the value of to the current <ph id=\"ph2\">`unique_ptr`</ph>.","source":"A `unique_ptr` reference used to assign the value of to the current `unique_ptr`."},{"content":"Remarks","pos":[7474,7481]},{"pos":[7485,7617],"content":"The member functions call <ph id=\"ph1\">`reset(`` right``.release())`</ph> and move <ph id=\"ph2\">` right``.stored_deleter`</ph> to <ph id=\"ph3\">`stored_deleter`</ph>, then return <ph id=\"ph4\">`*this`</ph>.","source":"The member functions call `reset(`` right``.release())` and move ` right``.stored_deleter` to `stored_deleter`, then return `*this`."},{"pos":[7651,7658],"content":"pointer"},{"pos":[7662,7722],"content":"A synonym for <ph id=\"ph1\">`Del::pointer`</ph> if defined, otherwise <ph id=\"ph2\">`Type *`</ph>.","source":"A synonym for `Del::pointer` if defined, otherwise `Type *`."},{"content":"Remarks","pos":[7769,7776]},{"pos":[7780,7852],"content":"The type is a synonym for <ph id=\"ph1\">`Del::pointer`</ph> if defined, otherwise <ph id=\"ph2\">`Type *`</ph>.","source":"The type is a synonym for `Del::pointer` if defined, otherwise `Type *`."},{"pos":[7898,7917],"content":"unique_ptr::release"},{"pos":[7921,8032],"content":"Releases ownership of the returned stored pointer to the caller and sets the stored pointer value to <ph id=\"ph1\">`nullptr`</ph>.","source":"Releases ownership of the returned stored pointer to the caller and sets the stored pointer value to `nullptr`."},{"content":"Remarks","pos":[8076,8083]},{"content":"Use <ph id=\"ph1\">`release`</ph> to take over ownership of the raw pointer stored by the <ph id=\"ph2\">`unique_ptr`</ph>.","pos":[8087,8170],"source":"Use `release` to take over ownership of the raw pointer stored by the `unique_ptr`."},{"content":"The caller is responsible for deletion of the returned pointer.","pos":[8171,8234]},{"content":"The <ph id=\"ph1\">`unique-ptr`</ph> is set to the empty default-constructed state.","pos":[8235,8298],"source":" The `unique-ptr` is set to the empty default-constructed state."},{"content":"You can assign another pointer of compatible type to the <ph id=\"ph1\">`unique_ptr`</ph> after the call to <ph id=\"ph2\">`release`</ph>.","pos":[8299,8397],"source":" You can assign another pointer of compatible type to the `unique_ptr` after the call to `release`."},{"content":"Example","pos":[8407,8414]},{"content":"This example shows how the caller of release is responsible for the object returned:","pos":[8419,8503]},{"content":"Computer output:","pos":[9547,9563]},{"pos":[9725,9742],"content":"unique_ptr::reset"},{"content":"Takes ownership of the pointer parameter, and then deletes the original stored pointer.","pos":[9746,9833]},{"content":"If the new pointer is the same as the original stored pointer, <ph id=\"ph1\">`reset`</ph> deletes the pointer and sets the stored pointer to <ph id=\"ph2\">`nullptr`</ph>.","pos":[9834,9966],"source":" If the new pointer is the same as the original stored pointer, `reset` deletes the pointer and sets the stored pointer to `nullptr`."},{"content":"Parameters","pos":[10055,10065]},{"content":"Parameter","pos":[10072,10081]},{"content":"Description","pos":[10082,10093]},{"content":"A pointer to the resource to take ownership of.","pos":[10142,10189]},{"content":"Remarks","pos":[10200,10207]},{"content":"Use <ph id=\"ph1\">`reset`</ph> to change the stored <bpt id=\"p1\">[</bpt>pointer<ept id=\"p1\">](#pointer)</ept> owned by the <ph id=\"ph2\">`unique_ptr`</ph> to <ph id=\"ph3\">`ptr`</ph> and then delete the original stored pointer.","pos":[10211,10343],"source":"Use `reset` to change the stored [pointer](#pointer) owned by the `unique_ptr` to `ptr` and then delete the original stored pointer."},{"content":"If the <ph id=\"ph1\">`unique_ptr`</ph> was not empty, <ph id=\"ph2\">`reset`</ph> invokes the deleter function returned by <bpt id=\"p1\">[</bpt>get_deleter<ept id=\"p1\">](#unique_ptr__get_deleter)</ept> on the original stored pointer.","pos":[10344,10499],"source":" If the `unique_ptr` was not empty, `reset` invokes the deleter function returned by [get_deleter](#unique_ptr__get_deleter) on the original stored pointer."},{"pos":[10506,10707],"content":"Because <ph id=\"ph1\">`reset`</ph> first stores the new pointer <ph id=\"ph2\">`ptr`</ph>, and then deletes the original stored pointer, it's possible for <ph id=\"ph3\">`reset`</ph> to immediately delete <ph id=\"ph4\">`ptr`</ph> if it is the same as the original stored pointer.","source":"Because `reset` first stores the new pointer `ptr`, and then deletes the original stored pointer, it's possible for `reset` to immediately delete `ptr` if it is the same as the original stored pointer."},{"pos":[10750,10766],"content":"unique_ptr::swap"},{"pos":[10770,10822],"content":"Exchanges pointers between two <ph id=\"ph1\">`unique_ptr`</ph> objects.","source":"Exchanges pointers between two `unique_ptr` objects."},{"content":"Parameters","pos":[10877,10887]},{"content":"A <ph id=\"ph1\">`unique_ptr`</ph> used to swap pointers.","pos":[10903,10940],"source":" A `unique_ptr` used to swap pointers."},{"content":"Remarks","pos":[10950,10957]},{"pos":[10961,11073],"content":"The member function swaps <ph id=\"ph1\">`stored_ptr`</ph> with <ph id=\"ph2\">`right.stored_ptr`</ph> and <ph id=\"ph3\">`stored_deleter`</ph> with <ph id=\"ph4\">`right.stored_deleter`</ph>.","source":"The member function swaps `stored_ptr` with `right.stored_ptr` and `stored_deleter` with `right.stored_deleter`."},{"pos":[11122,11144],"content":"unique_ptr::unique_ptr"},{"pos":[11148,11194],"content":"There are seven constructors for <ph id=\"ph1\">`unique_ptr`</ph>.","source":"There are seven constructors for `unique_ptr`."},{"content":"Parameters","pos":[11635,11645]},{"content":"Parameter","pos":[11652,11661]},{"content":"Description","pos":[11662,11673]},{"pos":[11723,11768],"content":"A pointer to the resource to be assigned to a"},{"pos":[11798,11843],"content":"A <ph id=\"ph1\">`deleter`</ph> to be assigned to a <ph id=\"ph2\">`unique_ptr`</ph>.","source":"A `deleter` to be assigned to a `unique_ptr`."},{"pos":[11857,11984],"content":"An <ph id=\"ph1\">`rvalue reference`</ph> to a <ph id=\"ph2\">`unique_ptr`</ph> from which <ph id=\"ph3\">`unique_ptr`</ph> fields are move assigned to the newly constructed <ph id=\"ph4\">`unique_ptr`</ph>.","source":"An `rvalue reference` to a `unique_ptr` from which `unique_ptr` fields are move assigned to the newly constructed `unique_ptr`."},{"content":"Remarks","pos":[11995,12002]},{"content":"The first two constructors construct an object that manages no resource.","pos":[12006,12078]},{"content":"The third constructor stores <ph id=\"ph1\">`ptr`</ph> in <ph id=\"ph2\">`stored_ptr`</ph>.","pos":[12079,12130],"source":" The third constructor stores `ptr` in `stored_ptr`."},{"content":"The fourth constructor stores <ph id=\"ph1\">`ptr`</ph> in <ph id=\"ph2\">`stored_ptr`</ph> and <ph id=\"ph3\">`deleter`</ph> in <ph id=\"ph4\">`stored_deleter`</ph>.","pos":[12131,12217],"source":" The fourth constructor stores `ptr` in `stored_ptr` and `deleter` in `stored_deleter`."},{"content":"The fifth constructor stores <ph id=\"ph1\">`ptr`</ph> in <ph id=\"ph2\">`stored_ptr`</ph> and moves <ph id=\"ph3\">`deleter`</ph> into <ph id=\"ph4\">`stored_deleter`</ph>.","pos":[12224,12317],"source":"The fifth constructor stores `ptr` in `stored_ptr` and moves `deleter` into `stored_deleter`."},{"content":"The sixth and seventh constructors store <ph id=\"ph1\">`right.reset()`</ph> in <ph id=\"ph2\">`stored_ptr`</ph> and moves <ph id=\"ph3\">`right.get_deleter()`</ph> into <ph id=\"ph4\">`stored_deleter`</ph>.","pos":[12318,12445],"source":" The sixth and seventh constructors store `right.reset()` in `stored_ptr` and moves `right.get_deleter()` into `stored_deleter`."},{"pos":[12498,12520],"content":"unique_ptr ~unique_ptr"},{"pos":[12524,12588],"content":"The destructor for <ph id=\"ph1\">`unique_ptr`</ph>, destroys a <ph id=\"ph2\">`unique_ptr`</ph> object.","source":"The destructor for `unique_ptr`, destroys a `unique_ptr` object."},{"content":"Remarks","pos":[12628,12635]},{"pos":[12639,12688],"content":"The destructor calls <ph id=\"ph1\">`get_deleter()(stored_ptr)`</ph>.","source":"The destructor calls `get_deleter()(stored_ptr)`."},{"content":"See Also","pos":[12697,12705]},{"content":"memory&gt;","pos":[12712,12719],"source":"memory>"}],"content":"---\ntitle: \"unique_ptr Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"unique_ptr\"\n  - \"std.unique_ptr\"\n  - \"std::unique_ptr\"\n  - \"memory/std::unique_ptr\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"unique_ptr class\"\nms.assetid: acdf046b-831e-4a4a-83aa-6d4ee467db9a\ncaps.latest.revision: 22\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# unique_ptr Class\nStores a pointer to an owned object or array. The object/array is owned by no other `unique_ptr`. The object/array is destroyed when the `unique_ptr` is destroyed.  \n  \n## Syntax  \n```  \nclass unique_ptr {\npublic:\n    unique_ptr();\n    unique_ptr(nullptr_t Nptr);\n    explicit unique_ptr(pointer Ptr);\n    unique_ptr(pointer Ptr,\n        typename conditional<is_reference<Del>::value, Del,\n        typename add_reference<const Del>::type>::type Deleter);\n    unique_ptr(pointer Ptr,\n        typename remove_reference<Del>::type&& Deleter);\n    unique_ptr(unique_ptr&& Right);\n    template <class T2, Class Del2>\n    unique_ptr(unique_ptr<T2, Del2>&& Right);\n    unique_ptr(const unique_ptr& Right) = delete;\n    unique_ptr& operator=(const unique_ptr& Right) = delete;\n};\n\n//Specialization for arrays:  \ntemplate <class T, class D>\nclass unique_ptr<T[], D> {\npublic:\n    typedef pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n    constexpr unique_ptr() noexcept;\n    template <class U>\n    explicit unique_ptr(U p) noexcept;\n    template <class U>\n    unique_ptr(U p, see below d) noexcept;\n    template <class U>\n    unique_ptr(U p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }     template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    ~unique_ptr();\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E>\n    unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n    T& operator[](size_t i) const;\n\n\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t = nullptr) noexcept;\n    template <class U>\n    void reset(U p) noexcept = delete;\n    void swap(unique_ptr& u) noexcept;  // disable copy from lvalue unique_ptr(const unique_ptr&) = delete;  \n    unique_ptr& operator=(const unique_ptr&) = delete;\n};\n```  \n  \n#### Parameters  \n `Right`  \n A `unique_ptr`.  \n  \n `Nptr`  \n An `rvalue` of type `std::nullptr_t`.  \n  \n `Ptr`  \n A `pointer`.  \n  \n `Deleter`  \n A `deleter` function that is bound to a `unique_ptr`.  \n  \n## Exceptions  \n No exceptions are generated by `unique_ptr`.  \n  \n## Remarks  \n The `unique_ptr` class supersedes `auto_ptr`, and can be used as an element of STL containers.  \n  \n Use the [make_unique](../standard-library/memory-functions.md#make_unique) helper function to efficiently create new instances of `unique_ptr`.  \n  \n `unique_ptr` uniquely manages a resource. Each `unique_ptr` object stores a pointer to the object that it owns or stores a null pointer. A resource can be owned by no more than one `unique_ptr` object;  when a `unique_ptr` object that owns a particular resource is destroyed, the resource is freed. A `unique_ptr` object may be moved, but not copied;  for more information, see [Rvalue Reference Declarator: &&](../cpp/rvalue-reference-declarator-amp-amp.md).  \n  \n The resource is freed by calling a stored `deleter` object of type `Del` that knows how resources are allocated for a particular `unique_ptr`. The default `deleter``default_delete``<T>` assumes that the resource pointed to by ` ptr` is allocated with `new`, and that it can be freed by calling `delete _``Ptr`. (A partial specialization `unique_ptr<T[]>`manages array objects allocated with `new[]`, and has the default `deleter``default_delete<T[]>`, specialized to call delete[] ` ptr`.)  \n  \n The stored pointer to an owned resource, `stored_ptr` has type `pointer`. It is `Del::pointer` if defined, and `T *` if not. The stored `deleter` object `stored_deleter` occupies no space in the object if the `deleter` is stateless. Note that `Del` can be a reference type.  \n  \n## Members  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[unique_ptr::unique_ptr](#unique_ptr__unique_ptr)|There are seven constructors for `unique_ptr`.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[deleter_type](#deleter_type)|A synonym for the template parameter `Del`.|  \n|[element_type](#element_type)|A synonym for the template parameter `T``.`|  \n|[pointer](#pointer)|A synonym for `Del::pointer` if defined, otherwise `T *`.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[unique_ptr::get](#unique_ptr__get)|Returns `stored_ptr`.|  \n|[unique_ptr::get_deleter](#unique_ptr__get_deleter)|Returns a reference to `stored_deleter`.|  \n|[unique_ptr::release](#unique_ptr__release)|stores `pointer()` in `stored_ptr` and returns its previous contents.|  \n|[unique_ptr::reset](#unique_ptr__reset)|Releases the currently owned resource and accepts a new resource.|  \n|[unique_ptr::swap](#unique_ptr__swap)|Exchanges resource and `deleter` with the provided `unique_ptr`.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|`operator bool`|The operator returns a value of a type that is convertible to `bool`. The result of the conversion to `bool` is `true` when `get() != pointer()`, otherwise `false`.|  \n|`operator->`|The member function returns `stored_ptr``.`|  \n|`operator*`|The member function returns* `stored_ptr``.`|  \n|[unique_ptr operator=](#unique_ptr_operator_eq)|Assigns the value of a `unique_ptr` (or a `pointer-type`) to the current `unique_ptr`.|  \n  \n## Requirements  \n **Header:** \\<memory>  \n  \n **Namespace:** std  \n  \n##  <a name=\"deleter_type\"></a>  deleter_type  \n The type is a synonym for the template parameter `Del`.  \n  \n```  \ntypedef Del deleter_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `Del`.  \n  \n##  <a name=\"element_type\"></a>  element_type  \n The type is a synonym for the template parameter `Type`.  \n  \n```  \ntypedef Type element_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `Ty`.  \n  \n##  <a name=\"unique_ptr__get\"></a>  unique_ptr::get  \n Returns `stored_ptr`.  \n  \n```  \npointer get() const;\n```  \n  \n### Remarks  \n The member function returns `stored_ptr`.  \n  \n##  <a name=\"unique_ptr__get_deleter\"></a>  unique_ptr::get_deleter  \n Returns a reference to `stored_deleter`.  \n  \n```  \nDel& get_deleter();\n\nconst Del& get_deleter() const;\n```  \n  \n### Remarks  \n The member function returns a reference to `stored_deleter`.  \n  \n##  <a name=\"unique_ptr_operator_eq\"></a>  unique_ptr operator=  \n Assigns the address of the provided `unique_ptr` to the current one.  \n  \n```  \nunique_ptr& operator=(unique_ptr&& right);\ntemplate <class U, Class Del2>  \nunique_ptr& operator=(unique_ptr<Type, Del>&& right);\nunique_ptr& operator=(pointer-type);\n```  \n  \n### Parameters  \n A `unique_ptr` reference used to assign the value of to the current `unique_ptr`.  \n  \n### Remarks  \n The member functions call `reset(`` right``.release())` and move ` right``.stored_deleter` to `stored_deleter`, then return `*this`.  \n  \n##  <a name=\"pointer\"></a>  pointer  \n A synonym for `Del::pointer` if defined, otherwise `Type *`.  \n  \n```  \ntypedef T1 pointer;  \n```  \n  \n### Remarks  \n The type is a synonym for `Del::pointer` if defined, otherwise `Type *`.  \n  \n##  <a name=\"unique_ptr__release\"></a>  unique_ptr::release  \n Releases ownership of the returned stored pointer to the caller and sets the stored pointer value to `nullptr`.  \n  \n```  \npointer release();\n```  \n  \n### Remarks  \n Use `release` to take over ownership of the raw pointer stored by the `unique_ptr`. The caller is responsible for deletion of the returned pointer. The `unique-ptr` is set to the empty default-constructed state. You can assign another pointer of compatible type to the `unique_ptr` after the call to `release`.  \n  \n### Example  \n  This example shows how the caller of release is responsible for the object returned:  \n  \n```cpp  \n// stl_release_unique.cpp  \n// Compile by using: cl /W4 /EHsc stl_release_unique.cpp  \n#include <iostream>  \n#include <memory>  \n  \nstruct Sample {  \n   int content_;  \n   Sample(int content) : content_(content) {  \n      std::cout << \"Constructing Sample(\" << content_ << \")\" << std::endl;  \n   }  \n   ~Sample() {  \n      std::cout << \"Deleting Sample(\" << content_ << \")\" << std::endl;  \n   }  \n};  \n  \nvoid ReleaseUniquePointer() {  \n   // Use make_unique function when possible.    \n   auto up1 = std::make_unique<Sample>(3);  \n   auto up2 = std::make_unique<Sample>(42);  \n  \n   // Take over ownership from the unique_ptr up2 by using release  \n   auto ptr = up2.release();  \n   if (up2) {  \n      // This statement does not execute, because up2 is empty.  \n      std::cout << \"up2 is not empty.\" << std::endl;  \n   }  \n   // We are now responsible for deletion of ptr.  \n   delete ptr;  \n   // up1 deletes its stored pointer when it goes out of scope.     \n}  \n  \nint main() {  \n   ReleaseUniquePointer();  \n}  \n```  \n  \n  Computer output:  \n  \n```Output  \nConstructing Sample(3)  \nConstructing Sample(42)  \nDeleting Sample(42)  \nDeleting Sample(3)  \n  \n```  \n  \n##  <a name=\"unique_ptr__reset\"></a>  unique_ptr::reset  \n Takes ownership of the pointer parameter, and then deletes the original stored pointer. If the new pointer is the same as the original stored pointer, `reset` deletes the pointer and sets the stored pointer to `nullptr`.  \n  \n```  \nvoid reset(pointer ptr = pointer());\nvoid reset(nullptr_t ptr);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|`ptr`|A pointer to the resource to take ownership of.|  \n  \n### Remarks  \n Use `reset` to change the stored [pointer](#pointer) owned by the `unique_ptr` to `ptr` and then delete the original stored pointer. If the `unique_ptr` was not empty, `reset` invokes the deleter function returned by [get_deleter](#unique_ptr__get_deleter) on the original stored pointer.  \n  \n Because `reset` first stores the new pointer `ptr`, and then deletes the original stored pointer, it's possible for `reset` to immediately delete `ptr` if it is the same as the original stored pointer.  \n  \n##  <a name=\"unique_ptr__swap\"></a>  unique_ptr::swap  \n Exchanges pointers between two `unique_ptr` objects.  \n  \n```  \nvoid swap(unique_ptr& right);\n```  \n  \n### Parameters  \n ` right`  \n A `unique_ptr` used to swap pointers.  \n  \n### Remarks  \n The member function swaps `stored_ptr` with `right.stored_ptr` and `stored_deleter` with `right.stored_deleter`.  \n  \n##  <a name=\"unique_ptr__unique_ptr\"></a>  unique_ptr::unique_ptr  \n There are seven constructors for `unique_ptr`.  \n  \n```  \nunique_ptr();\n\nunique_ptr(nullptr_t);\nexplicit unique_ptr(pointer ptr);\n\nunique_ptr(\n    Type* ptr,  \n    typename conditional<\n    is_reference<Del>::value, \n    Del, \n    typename add_reference<const Del>::type>::type _Deleter);\n\nunique_ptr(pointer ptr, typename remove_reference<Del>::type&& _Deleter);\nunique_ptr(unique_ptr&& right);\ntemplate <class Ty2, Class Del2>  \nunique_ptr(unique_ptr<Ty2, Del2>&& right);\n```  \n  \n### Parameters  \n  \n|Parameter|Description|  \n|---------------|-----------------|  \n|` ptr`|A pointer to the resource to be assigned to a `unique_ptr.`|  \n|`_Deleter`|A `deleter` to be assigned to a `unique_ptr`.|  \n|` right`|An `rvalue reference` to a `unique_ptr` from which `unique_ptr` fields are move assigned to the newly constructed `unique_ptr`.|  \n  \n### Remarks  \n The first two constructors construct an object that manages no resource. The third constructor stores `ptr` in `stored_ptr`. The fourth constructor stores `ptr` in `stored_ptr` and `deleter` in `stored_deleter`.  \n  \n The fifth constructor stores `ptr` in `stored_ptr` and moves `deleter` into `stored_deleter`. The sixth and seventh constructors store `right.reset()` in `stored_ptr` and moves `right.get_deleter()` into `stored_deleter`.  \n  \n##  <a name=\"unique_ptr__dtorunique_ptr\"></a>  unique_ptr ~unique_ptr  \n The destructor for `unique_ptr`, destroys a `unique_ptr` object.  \n  \n```  \n~unique_ptr();\n```  \n  \n### Remarks  \n The destructor calls `get_deleter()(stored_ptr)`.  \n  \n## See Also  \n [\\<memory>](../standard-library/memory.md)\n\n\n"}