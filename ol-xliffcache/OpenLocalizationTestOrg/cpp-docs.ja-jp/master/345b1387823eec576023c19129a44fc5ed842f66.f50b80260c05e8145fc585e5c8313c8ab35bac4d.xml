{"nodes":[{"pos":[12,85],"content":"How to: Call Native DLLs from Managed Code Using PInvoke | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Call Native DLLs from Managed Code Using PInvoke | Microsoft Docs","pos":[0,73]}]},{"content":"How to: Call Native DLLs from Managed Code Using PInvoke","pos":[783,839]},{"content":"Functions that are implemented in unmanaged DLLs can be called from managed code using Platform Invoke (P/Invoke) functionality.","pos":[840,968]},{"content":"If the source code for the DLL is not available, P/Invoke is the only option for interoperating.","pos":[969,1065]},{"content":"However, unlike other .NET languages, Visual C++ provides an alternative to P/Invoke.","pos":[1066,1151]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using C++ Interop (Implicit PInvoke)<ept id=\"p1\">](../dotnet/using-cpp-interop-implicit-pinvoke.md)</ept>.","pos":[1152,1266],"source":" For more information, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)."},{"content":"Example","pos":[1275,1282]},{"pos":[1286,1475],"content":"The following code example uses the Win32 <bpt id=\"p1\">[</bpt>GetSystemMetrics<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms724385)</ept> function to retrieve the current resolution of the screen in pixels.","source":"The following code example uses the Win32 [GetSystemMetrics](http://msdn.microsoft.com/library/windows/desktop/ms724385) function to retrieve the current resolution of the screen in pixels."},{"content":"For functions that use only intrinsic types as arguments and return values, no extra work is required.","pos":[1482,1584]},{"content":"Other data types, such as function pointers, arrays, and structures, require additional attributes to ensure proper data marshaling.","pos":[1585,1717]},{"content":"Although it is not required, it is good practice to make P/Invoke declarations static members of a value class so that they do not exist in the global namespace, as demonstrated in this example.","pos":[1724,1918]},{"content":"See Also","pos":[2612,2620]},{"content":"Using Explicit PInvoke in C++ (DllImport Attribute)","pos":[2625,2676]}],"content":"---\ntitle: \"How to: Call Native DLLs from Managed Code Using PInvoke | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"platform invoke [C++], calling native DLLs\"\n  - \"interop [C++], calling native DLLs\"\n  - \"marshaling [C++], calling native DLLs\"\n  - \"data marshaling [C++], calling native DLLs\"\nms.assetid: 3273eb4b-38d1-4619-92a6-71bda542be72\ncaps.latest.revision: 18\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Call Native DLLs from Managed Code Using PInvoke\nFunctions that are implemented in unmanaged DLLs can be called from managed code using Platform Invoke (P/Invoke) functionality. If the source code for the DLL is not available, P/Invoke is the only option for interoperating. However, unlike other .NET languages, Visual C++ provides an alternative to P/Invoke. For more information, see [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md).  \n  \n## Example  \n The following code example uses the Win32 [GetSystemMetrics](http://msdn.microsoft.com/library/windows/desktop/ms724385) function to retrieve the current resolution of the screen in pixels.  \n  \n For functions that use only intrinsic types as arguments and return values, no extra work is required. Other data types, such as function pointers, arrays, and structures, require additional attributes to ensure proper data marshaling.  \n  \n Although it is not required, it is good practice to make P/Invoke declarations static members of a value class so that they do not exist in the global namespace, as demonstrated in this example.  \n  \n```  \n// pinvoke_basic.cpp  \n// compile with: /clr  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \nvalue class Win32 {  \npublic:  \n   [DllImport(\"User32.dll\")]  \n   static int GetSystemMetrics(int);  \n  \n   enum class SystemMetricIndex {  \n      // Same values as those defined in winuser.h.  \n      SM_CXSCREEN = 0,  \n      SM_CYSCREEN = 1  \n   };  \n};  \n  \nint main() {  \n   int hRes = Win32::GetSystemMetrics( safe_cast<int>(Win32::SystemMetricIndex::SM_CXSCREEN) );  \n   int vRes = Win32::GetSystemMetrics( safe_cast<int>(Win32::SystemMetricIndex::SM_CYSCREEN) );  \n   Console::WriteLine(\"screen resolution: {0},{1}\", hRes, vRes);  \n}  \n```  \n  \n## See Also  \n [Using Explicit PInvoke in C++ (DllImport Attribute)](../dotnet/using-explicit-pinvoke-in-cpp-dllimport-attribute.md)"}