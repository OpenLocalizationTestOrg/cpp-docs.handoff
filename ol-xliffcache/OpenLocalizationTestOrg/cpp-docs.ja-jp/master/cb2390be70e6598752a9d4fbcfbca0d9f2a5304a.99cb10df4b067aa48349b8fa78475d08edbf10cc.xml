{"nodes":[{"pos":[12,49],"content":"Compiler Error C2440 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Error C2440 | Microsoft Docs","pos":[0,37]}]},{"content":"Compiler Error C2440","pos":[598,618]},{"content":"'conversion' : cannot convert from 'type1' to 'type2'","pos":[619,672]},{"pos":[678,727],"content":"The compiler cannot cast from <ph id=\"ph1\">`type1`</ph> to <ph id=\"ph2\">`type2`</ph>.","source":"The compiler cannot cast from `type1` to `type2`."},{"content":"Example","pos":[736,743]},{"content":"C2440 can be caused if you attempt to initialize a non-const <ph id=\"ph1\">`char*`</ph> (or <ph id=\"ph2\">`wchar_t*`</ph>) by using a string literal in C++ code, when the compiler conformance option <bpt id=\"p1\">[</bpt>/Zc:strictStrings<ept id=\"p1\">](../../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md)</ept> is set.","pos":[746,1016],"source":"C2440 can be caused if you attempt to initialize a non-const `char*` (or `wchar_t*`) by using a string literal in C++ code, when the compiler conformance option [/Zc:strictStrings](../../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md) is set."},{"content":"In C, the type of a string literal is array of <ph id=\"ph1\">`char`</ph>, but in C++, it is array of <ph id=\"ph2\">`const char`</ph>.","pos":[1017,1112],"source":" In C, the type of a string literal is array of `char`, but in C++, it is array of `const char`."},{"content":"This sample generates C2440:","pos":[1113,1141]},{"content":"Example","pos":[1545,1552]},{"content":"C2440 can also be caused if you attempt to convert a pointer to member to void*.","pos":[1556,1636]},{"content":"The next sample generates C2440:","pos":[1637,1669]},{"content":"Example","pos":[1929,1936]},{"content":"C2440 can also be caused if you attempt to cast from a type that is only forward declared but not defined.","pos":[1940,2046]},{"content":"This sample generates C2440:","pos":[2047,2075]},{"content":"Example","pos":[2358,2365]},{"content":"The C2440 errors on lines 15 and 16 of the next sample are qualified with the <ph id=\"ph1\">`Incompatible calling conventions for UDT return value`</ph> message.","pos":[2369,2511],"source":"The C2440 errors on lines 15 and 16 of the next sample are qualified with the `Incompatible calling conventions for UDT return value` message."},{"content":"A <bpt id=\"p1\">*</bpt>UDT<ept id=\"p1\">*</ept> is a user-defined type, such as a class, struct, or union.","pos":[2512,2578],"source":" A *UDT* is a user-defined type, such as a class, struct, or union."},{"content":"These kinds of incompatibility errors are caused when the calling convention of a UDT specified in the return type of a forward declaration conflicts with the actual calling convention of the UDT and when a function pointer is involved.","pos":[2579,2815]},{"content":"In the example, first there are forward declarations for a struct and for a function that returns the struct; the compiler assumes that the struct uses the C++ calling convention.","pos":[2822,3001]},{"content":"Next is the struct definition, which, by default, uses the C calling convention.","pos":[3002,3082]},{"content":"Because the compiler does not know the calling convention of the struct until it finishes reading the entire struct, the calling convention for the struct in the return type of <ph id=\"ph1\">`get_c2`</ph> is also assumed to be C++.","pos":[3083,3295],"source":" Because the compiler does not know the calling convention of the struct until it finishes reading the entire struct, the calling convention for the struct in the return type of `get_c2` is also assumed to be C++."},{"content":"The struct is followed by another function declaration that returns the struct, but at this point, the compiler knows that the struct's calling convention is C++.","pos":[3302,3464]},{"content":"Similarly, the function pointer, which returns the struct, is defined after the struct definition so that the compiler knows that the struct uses the C++ calling convention.","pos":[3465,3638]},{"content":"To resolve C2440 that occurs because of incompatible calling conventions, declare functions that return a UDT after the UDT definition.","pos":[3645,3780]},{"content":"Example","pos":[4490,4497]},{"content":"C2440 can also occur if you assign zero to an interior pointer:","pos":[4501,4564]},{"content":"Example","pos":[4787,4794]},{"content":"C2440 can also occur for an incorrect use of a user-defined conversion.","pos":[4798,4869]},{"content":"For example, when a conversion operator has been defined as <ph id=\"ph1\">`explicit`</ph>, the compiler can't use it in an implicit conversion.","pos":[4870,4994],"source":" For example, when a conversion operator has been defined as `explicit`, the compiler can't use it in an implicit conversion."},{"content":"For more information about user-defined conversions, see <bpt id=\"p1\">[</bpt>User-Defined Conversions (C++/CLI)<ept id=\"p1\">](../../dotnet/user-defined-conversions-cpp-cli.md)</ept>).","pos":[4995,5140],"source":" For more information about user-defined conversions, see [User-Defined Conversions (C++/CLI)](../../dotnet/user-defined-conversions-cpp-cli.md))."},{"content":"This sample generates C2440:","pos":[5141,5169]},{"content":"Example","pos":[5569,5576]},{"content":"C2440 can also occur if you try to create an instance of a Visual C++ array whose type is a &lt;xref:System.Array&gt;.","pos":[5580,5692],"source":"C2440 can also occur if you try to create an instance of a Visual C++ array whose type is a <xref:System.Array>."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Arrays<ept id=\"p1\">](../../windows/arrays-cpp-component-extensions.md)</ept>.","pos":[5694,5779],"source":"  For more information, see [Arrays](../../windows/arrays-cpp-component-extensions.md)."},{"content":"The next sample generates C2440:","pos":[5781,5813]},{"content":"Example","pos":[6141,6148]},{"content":"C2440 can also occur because of changes in the attributes feature.","pos":[6152,6218]},{"content":"The following sample generates C2440.","pos":[6220,6257]},{"content":"Example","pos":[6469,6476]},{"pos":[6480,6654],"content":"The Visual C++ compiler no longer allows the <bpt id=\"p1\">[</bpt>const_cast Operator<ept id=\"p1\">](../../cpp/const-cast-operator.md)</ept> to down cast when source code that uses <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept> programming is compiled.","source":"The Visual C++ compiler no longer allows the [const_cast Operator](../../cpp/const-cast-operator.md) to down cast when source code that uses **/clr** programming is compiled."},{"content":"To resolve this C2440, use the correct cast operator.","pos":[6661,6714]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Casting Operators<ept id=\"p1\">](../../cpp/casting-operators.md)</ept>.","pos":[6715,6793],"source":" For more information, see [Casting Operators](../../cpp/casting-operators.md)."},{"content":"This sample generates C2440:","pos":[6800,6828]},{"content":"Example","pos":[7113,7120]},{"content":"C2440 can occur because of conformance changes to the compiler in Visual Studio 2015 Update 3.","pos":[7123,7217]},{"content":"Previously, the compiler incorrectly treated certain distinct expressions as the same type when identifying a template match for a <ph id=\"ph1\">`static_cast`</ph> operation.","pos":[7218,7373],"source":" Previously, the compiler incorrectly treated certain distinct expressions as the same type when identifying a template match for a `static_cast` operation."},{"content":"Now the compiler distinguishes the types correctly, and code that relied on the previous <ph id=\"ph1\">`static_cast`</ph> behavior is broken.","pos":[7374,7496],"source":" Now the compiler distinguishes the types correctly, and code that relied on the previous `static_cast` behavior is broken."},{"content":"To fix this issue, change the template argument to match the template parameter type, or use a <ph id=\"ph1\">`reinterpret_cast`</ph> or C-style cast.","pos":[7497,7627],"source":" To fix this issue, change the template argument to match the template parameter type, or use a `reinterpret_cast` or C-style cast."},{"content":"This sample generates C2440:","pos":[7631,7659]}],"content":"---\ntitle: \"Compiler Error C2440 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C2440\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C2440\"\nms.assetid: 36e6676c-f04f-4715-8ba1-f096c4bf3b44\ncaps.latest.revision: 27\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Compiler Error C2440\n'conversion' : cannot convert from 'type1' to 'type2'  \n  \nThe compiler cannot cast from `type1` to `type2`.  \n  \n## Example  \nC2440 can be caused if you attempt to initialize a non-const `char*` (or `wchar_t*`) by using a string literal in C++ code, when the compiler conformance option [/Zc:strictStrings](../../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md) is set. In C, the type of a string literal is array of `char`, but in C++, it is array of `const char`. This sample generates C2440:  \n  \n```cpp  \n// C2440s.cpp  \n// Build: cl /Zc:strictStrings /W3 C2440s.cpp  \n// When built, the compiler emits:  \n// error C2440: 'initializing' : cannot convert from 'const char [5]'   \n// to 'char *'  \n//        Conversion from string literal loses const qualifier (see  \n// /Zc:strictStrings)  \n  \nint main() {  \n   char* s1 = \"test\"; // C2440  \n   const char* s2 = \"tests\"; // OK  \n}  \n```  \n  \n## Example  \n C2440 can also be caused if you attempt to convert a pointer to member to void*. The next sample generates C2440:  \n  \n```cpp  \n// C2440.cpp  \nclass B {  \npublic:  \n   void  f(){;}  \n  \n   typedef void (B::*pf)();  \n  \n   void f2(pf pf) {  \n       (this->*pf)();  \n       void* pp = (void*)pf;   // C2440  \n   }  \n  \n   void f3() {  \n      f2(f);  \n   }  \n};  \n```  \n  \n## Example  \n C2440 can also be caused if you attempt to cast from a type that is only forward declared but not defined. This sample generates C2440:  \n  \n```cpp  \n// c2440a.cpp   \nstruct Base { }; // Defined  \n  \nstruct Derived; // Forward declaration, not defined  \n  \nBase * func(Derived * d) {  \n    return static_cast<Base *>(d); // error C2440: 'static_cast' : cannot convert from 'Derived *' to 'Base *'  \n}  \n  \n```  \n  \n## Example  \n The C2440 errors on lines 15 and 16 of the next sample are qualified with the `Incompatible calling conventions for UDT return value` message. A *UDT* is a user-defined type, such as a class, struct, or union. These kinds of incompatibility errors are caused when the calling convention of a UDT specified in the return type of a forward declaration conflicts with the actual calling convention of the UDT and when a function pointer is involved.  \n  \n In the example, first there are forward declarations for a struct and for a function that returns the struct; the compiler assumes that the struct uses the C++ calling convention. Next is the struct definition, which, by default, uses the C calling convention. Because the compiler does not know the calling convention of the struct until it finishes reading the entire struct, the calling convention for the struct in the return type of `get_c2` is also assumed to be C++.  \n  \n The struct is followed by another function declaration that returns the struct, but at this point, the compiler knows that the struct's calling convention is C++. Similarly, the function pointer, which returns the struct, is defined after the struct definition so that the compiler knows that the struct uses the C++ calling convention.  \n  \n To resolve C2440 that occurs because of incompatible calling conventions, declare functions that return a UDT after the UDT definition.  \n  \n```cpp  \n// C2440b.cpp  \nstruct MyStruct;  \n  \nMyStruct get_c1();  \n  \nstruct MyStruct {  \n   int i;  \n   static MyStruct get_C2();  \n};  \n  \nMyStruct get_C3();  \n  \ntypedef MyStruct (*FC)();  \n  \nFC fc1 = &get_c1;   // C2440, line 15  \nFC fc2 = &MyStruct::get_C2;   // C2440, line 16  \nFC fc3 = &get_C3;  \n  \nclass CMyClass {  \npublic:  \n   explicit CMyClass( int iBar)  \n      throw()   {  \n   }  \n  \n   static CMyClass get_c2();  \n};  \n  \nint main() {  \n   CMyClass myclass = 2;   // C2440  \n   // try one of the following  \n   // CMyClass myclass{2};  \n   // CMyClass myclass(2);  \n  \n   int *i;  \n   float j;  \n   j = (float)i;   // C2440, cannot cast from pointer to int to float  \n}  \n```  \n  \n## Example  \n C2440 can also occur if you assign zero to an interior pointer:  \n  \n```cpp  \n// C2440c.cpp  \n// compile with: /clr  \nint main() {  \n   array<int>^ arr = gcnew array<int>(100);  \n   interior_ptr<int> ipi = &arr[0];  \n   ipi = 0;   // C2440  \n   ipi = nullptr;   // OK  \n}  \n```  \n  \n## Example  \n C2440 can also occur for an incorrect use of a user-defined conversion. For example, when a conversion operator has been defined as `explicit`, the compiler can't use it in an implicit conversion. For more information about user-defined conversions, see [User-Defined Conversions (C++/CLI)](../../dotnet/user-defined-conversions-cpp-cli.md)). This sample generates C2440:  \n  \n```cpp  \n// C2440d.cpp  \n// compile with: /clr  \nvalue struct MyDouble {  \n   double d;  \n   // convert MyDouble to Int32  \n   static explicit operator System::Int32 ( MyDouble val ) {  \n      return (int)val.d;  \n   }  \n};  \n  \nint main() {  \n   MyDouble d;  \n   int i;  \n   i = d;   // C2440  \n   // Uncomment the following line to resolve.  \n   // i = static_cast<int>(d);  \n}  \n```  \n  \n## Example  \n C2440 can also occur if you try to create an instance of a Visual C++ array whose type is a <xref:System.Array>.  For more information, see [Arrays](../../windows/arrays-cpp-component-extensions.md).  The next sample generates C2440:  \n  \n```cpp  \n// C2440e.cpp  \n// compile with: /clr  \nusing namespace System;  \nint main() {  \n   array<int>^ intArray = Array::CreateInstance(__typeof(int), 1);   // C2440  \n   // try the following line instead  \n   // array<int>^ intArray = safe_cast<array<int> ^>(Array::CreateInstance(__typeof(int), 1));  \n}  \n```  \n  \n## Example  \n C2440 can also occur because of changes in the attributes feature.  The following sample generates C2440.  \n  \n```cpp  \n// c2440f.cpp  \n// compile with: /LD  \n[ module(name=\"PropDemoLib\", version=1.0) ];   // C2440  \n// try the following line instead  \n// [ module(name=\"PropDemoLib\", version=\"1.0\") ];  \n```  \n  \n## Example  \n The Visual C++ compiler no longer allows the [const_cast Operator](../../cpp/const-cast-operator.md) to down cast when source code that uses **/clr** programming is compiled.  \n  \n To resolve this C2440, use the correct cast operator. For more information, see [Casting Operators](../../cpp/casting-operators.md).  \n  \n This sample generates C2440:  \n  \n```cpp  \n// c2440g.cpp  \n// compile with: /clr  \nref class Base {};  \nref class Derived : public Base {};  \nint main() {  \n   Derived ^d = gcnew Derived;  \n   Base ^b = d;  \n   d = const_cast<Derived^>(b);   // C2440  \n   d = dynamic_cast<Derived^>(b);   // OK  \n}  \n```  \n  \n## Example  \nC2440 can occur because of conformance changes to the compiler in Visual Studio 2015 Update 3. Previously, the compiler incorrectly treated certain distinct expressions as the same type when identifying a template match for a `static_cast` operation. Now the compiler distinguishes the types correctly, and code that relied on the previous `static_cast` behavior is broken. To fix this issue, change the template argument to match the template parameter type, or use a `reinterpret_cast` or C-style cast.\n  \nThis sample generates C2440:  \n  \n```cpp\n// c2440h.cpp\n\ntemplate<int *a>\nstruct S1 {};\n\nint g;\nstruct S2 : S1<&g> {\n};\n\nint main()\n{\n    S2 s;\n    static_cast<S1<&*&g>>(s); // C2440 in VS 2015 Update 3 \n    // This compiles correctly:\n    // static_cast<S1<&g>>(s);\n}\n\nThis error can appear in ATL code that uses the SINK_ENTRY_INFO macro defined in <atlcom.h>.\n\n```\n"}