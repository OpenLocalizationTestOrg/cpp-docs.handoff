{"nodes":[{"pos":[12,49],"content":"Compiler Error C2259 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Error C2259 | Microsoft Docs","pos":[0,37]}]},{"content":"Compiler Error C2259","pos":[624,644]},{"content":"'class' : cannot instantiate abstract class","pos":[645,688]},{"content":"Code declares an instance of an abstract class or structure.","pos":[695,755]},{"content":"You cannot instantiate a class or structure with one or more pure virtual functions.","pos":[762,846]},{"content":"To instantiate objects of a derived class, the derived class must override each pure virtual function.","pos":[847,949]},{"pos":[956,1116],"content":"For more information, see <bpt id=\"p1\">[</bpt>Implicitly abstract classes<ept id=\"p1\">](../../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Implicitly_abstract_classes)</ept>.","source":"For more information, see [Implicitly abstract classes](../../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Implicitly_abstract_classes)."},{"content":"The following sample generates C2259:","pos":[1123,1160]},{"content":"Whenever you derive from an interface and implement the interface methods in the derived class with access permissions other than public, you may receive C2259.","pos":[1482,1642]},{"content":"This occurs because the compiler expects the interface methods implemented in the derived class to have public access.","pos":[1644,1762]},{"content":"When you implement the member functions for an interface with more restrictive access permissions, the compiler does not consider them to be implementations for the interface methods defined in the interface, which in turn makes the derived class an abstract class.","pos":[1763,2028]},{"content":"There are two possible workarounds for the problem:","pos":[2035,2086]},{"content":"Make the access permissions public for the implemented methods.","pos":[2096,2159]},{"content":"Use the scope resolution operator for the interface methods implemented in the derived class to qualify the implemented method name with the name of the interface.","pos":[2169,2332]},{"content":"C2259 can also occur as a result of conformance work that was done in Visual C++ 2005, <bpt id=\"p1\">**</bpt>/Zc:wchar_t<ept id=\"p1\">**</ept> is now on by default.","pos":[2339,2463],"source":"C2259 can also occur as a result of conformance work that was done in Visual C++ 2005, **/Zc:wchar_t** is now on by default."},{"content":"In this situation, C2599 can be resolved either by compiling with <bpt id=\"p1\">**</bpt>/Zc:wchar_t-<ept id=\"p1\">**</ept>, to get the behavior from previous versions, or preferably, by updating your types so they are compatible.","pos":[2464,2653],"source":" In this situation, C2599 can be resolved either by compiling with **/Zc:wchar_t-**, to get the behavior from previous versions, or preferably, by updating your types so they are compatible."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>/Zc:wchar_t (wchar_t Is Native Type)<ept id=\"p1\">](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md)</ept>.","pos":[2654,2779],"source":" For more information, see [/Zc:wchar_t (wchar_t Is Native Type)](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md)."},{"content":"The following sample generates C2259:","pos":[2786,2823]},{"content":"The following sample generates C2259:","pos":[3449,3486]}],"content":"---\ntitle: \"Compiler Error C2259 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C2259\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C2259\"\nms.assetid: e458236f-bdea-4786-9aa6-a98d8bffa5f4\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Compiler Error C2259\n'class' : cannot instantiate abstract class  \n  \n Code declares an instance of an abstract class or structure.  \n  \n You cannot instantiate a class or structure with one or more pure virtual functions. To instantiate objects of a derived class, the derived class must override each pure virtual function.  \n  \n For more information, see [Implicitly abstract classes](../../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Implicitly_abstract_classes).  \n  \n The following sample generates C2259:  \n  \n```  \n// C2259.cpp  \n// compile with: /c  \nclass V {  \npublic:  \n   void virtual func() = 0;  \n};  \nclass A : public V {};  \nclass B : public V {  \npublic:  \n   void func();  \n};  \nV v;  // C2259, V is an abstract class  \nA a;  // C2259, A inherits func() as pure virtual  \nB b;  // OK, B defines func()  \n```  \n  \n Whenever you derive from an interface and implement the interface methods in the derived class with access permissions other than public, you may receive C2259.  This occurs because the compiler expects the interface methods implemented in the derived class to have public access. When you implement the member functions for an interface with more restrictive access permissions, the compiler does not consider them to be implementations for the interface methods defined in the interface, which in turn makes the derived class an abstract class.  \n  \n There are two possible workarounds for the problem:  \n  \n-   Make the access permissions public for the implemented methods.  \n  \n-   Use the scope resolution operator for the interface methods implemented in the derived class to qualify the implemented method name with the name of the interface.  \n  \n C2259 can also occur as a result of conformance work that was done in Visual C++ 2005, **/Zc:wchar_t** is now on by default. In this situation, C2599 can be resolved either by compiling with **/Zc:wchar_t-**, to get the behavior from previous versions, or preferably, by updating your types so they are compatible. For more information, see [/Zc:wchar_t (wchar_t Is Native Type)](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md).  \n  \n The following sample generates C2259:  \n  \n```  \n// C2259b.cpp  \n// compile with: /c  \n#include <windows.h>   \n  \nclass MyClass {  \npublic:  \n   // WCHAR now typedef'ed to wchar_t  \n   virtual void func(WCHAR*) = 0;  \n};  \n  \nclass MyClass2 : MyClass {  \npublic:  \n   void func(unsigned short*);  \n};  \n  \nMyClass2 x;   // C2259  \n  \n// OK  \nclass MyClass3 {  \npublic:  \n   virtual void func(WCHAR*) = 0;  \n   virtual void func2(wchar_t*) = 0;  \n   virtual void func3(unsigned short*) = 0;  \n};  \n  \nclass MyClass4 : MyClass3 {  \npublic:  \n   void func(WCHAR*) {}  \n   void func2(wchar_t*) {}  \n   void func3(unsigned short*) {}  \n};  \n  \nMyClass4 y;  \n```  \n  \n The following sample generates C2259:  \n  \n```  \n// C2259c.cpp  \n// compile with: /clr  \ninterface class MyInterface {  \n   void MyMethod();  \n};  \n  \nref class MyDerivedClass: public MyInterface {  \nprivate:  \n   // Uncomment the following line to resolve.  \n   // public:  \n   void MyMethod(){}  \n   // or the following line  \n   // void MyInterface::MyMethod() {};  \n};  \n  \nint main() {  \n   MyDerivedClass^ instance = gcnew MyDerivedClass; // C2259  \n}  \n```  \n"}