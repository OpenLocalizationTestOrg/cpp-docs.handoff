<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f6ae9687509189379ec6f48f7de3732f571665d2</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\cpp\overview-of-declarators.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">36f62b09bdbbd14a89ad896454d9d2859a06ecf2</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dac96eabe85e3fa3873400af70dd30031a4f765a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Overview of Declarators | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Overview of Declarators</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Declarators are the components of a declaration that specify names of objects or functions.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Declarators also specify whether or not the named object is an object, pointer, reference or array.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>While declarators do not specify the base type, they do modify the type information in the basic type to specify derived types such as pointers, references, and arrays.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Applied to functions, the declarator works with the type specifier to fully specify the return type of a function to be an object, pointer, or reference.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>(Specifiers, discussed in <bpt id="p1">[</bpt>Declarations and Definitions<ept id="p1">](declarations-and-definitions-cpp.md)</ept>, convey properties such as type and storage class.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Modifiers, discussed in this section and in <bpt id="p1">[</bpt>Microsoft-Specific Modifiers<ept id="p1">](../cpp/microsoft-specific-modifiers.md)</ept>, modify declarators.) The following figure shows a complete declaration of <ph id="ph1">`MyFunction`</ph>, and calls out the components of the declaration.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Modifiers, specifiers, and declarators</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Specifiers, Modifiers, and Declarators</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Most Microsoft extended keywords can be used as modifiers to form derived types; they are not specifiers or declarators.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>Microsoft-Specific Modifiers<ept id="p1">](../cpp/microsoft-specific-modifiers.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>END Microsoft Specific</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Declarators appear in the declaration syntax after an optional list of specifiers.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>These specifiers are discussed in <bpt id="p1">[</bpt>Declarations.<ept id="p1">](declarations-and-definitions-cpp.md)</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A declaration can contain more than one declarator, but each declarator declares only one name.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following sample declaration shows how specifiers and declarators are combined to form a complete declaration:</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In the preceding declaration, the keywords <bpt id="p1">**</bpt>const<ept id="p1">**</ept> and <ph id="ph1">`char`</ph> make up the list of specifiers.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Two declarators are listed: <ph id="ph1">`*pch`</ph> and <ph id="ph2">`ch`</ph>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A declaration that declares multiple entities consists of a type specifier followed by a comma-separated list of declarators, terminated with a semicolon.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Declarators for Simple Objects</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The declarator of a simple object such as an int or double is simply its name, with optional parentheses.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Declarators for Pointers, References and Arrays</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Pointer operators inserted in front of the name cause the object to be a pointer or reference.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept> operator declares the name as a pointer; the <bpt id="p2">**</bpt><ph id="ph2">&amp;</ph><ept id="p2">**</ept> operator declares it as a reference.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Appending <ph id="ph1">`const`</ph> or <ph id="ph2">`volatile`</ph> give the pointer these special properties.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The use of these specifiers in a declarator (as opposed to in the type specifier) modifies the properties of the pointer, not the object pointed to:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Further information may be found in <bpt id="p1">[</bpt>const and volatile Pointers<ept id="p1">](../cpp/const-and-volatile-pointers.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>A pointer to a member of a class or struct is declared with the appropriate nested name specifier:</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Brackets enclosing an optional constant expression after the name cause the object to be an array.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Successive brackets declare additional dimensions to the array.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Declarators for Functions</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Parentheses containing the argument list are used after the name to declare a function.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following declares a function of return type <ph id="ph1">`int`</ph> and three arguments of type <ph id="ph2">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For information on argument lists, see <bpt id="p1">[</bpt>Function Declarations<ept id="p1">](http://msdn.microsoft.com/en-us/3f9b4e14-60d2-47c1-acd8-4fa8fc988be7)</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Pointers and references to functions are declared by prepending the pointer or reference operator to the function name as shown below.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Parentheses, normally optional, are required to distinguish a pointer to a function from a function that returns a pointer:</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Pointers to member functions are distinguished by nested name specifiers:</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>See also <bpt id="p1">[</bpt>Pointers to Members<ept id="p1">](../cpp/pointers-to-members.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Functions and objects in the same declaration</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Functions and objects may be declared in the same declaration as follows:</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The syntax may be misleading in some circumstances.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following declaration</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>may look like the declaration of an <ph id="ph1">`int`</ph> pointer and a function returning <ph id="ph2">`int*`</ph>, but it is not.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>That's because the * is part of the declarator for <ph id="ph1">`i`</ph>, not part of the declarator for <ph id="ph2">`f`</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Simplifying declarator syntax with typedef</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A better technique, however, is to use a <ph id="ph1">`typedef`</ph> or a combination of parentheses and the <ph id="ph2">`typedef`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Consider declaring an array of pointers to functions:</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The equivalent declaration can be written without the <ph id="ph1">`typedef`</ph> declaration, but it is so complicated that the potential for error exceeds any benefits:</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information on typedef, see <bpt id="p1">[</bpt>typedef Specifier<ept id="p1">](http://msdn.microsoft.com/en-us/cc96cf26-ba93-4179-951e-695d1f5fdcf1)</ept>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Pointers, references, arrays of a single base type can be combined in a single declaration (separated by commas) as</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>More complex declarator syntax</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Pointer, reference, array, and function declarators may be combined to specify such objects as arrays of pointers to functions, pointers to arrays, etc.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The following recursive grammar describes pointer declarator syntax fully.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`declarator`</ph> is defined as one of:</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>and <bpt id="p1">*</bpt>pointer-operator<ept id="p1">*</ept> is one of:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Because a declarator may contain declarators, it is possible to construct the more complex derived types such as arrays of pointers, functions returning arrays of function pointers, by using the above rules.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>To form each step of the construction, start with the identifier representing the base data type and apply the syntax rule above with the previous expression as the <ph id="ph1">`declarator`</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The order that you apply the syntax rules should be the reverse of the way the expression is stated in English.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If applying the <bpt id="p1">*</bpt>pointer-operator<ept id="p1">*</ept> syntax rule to an array or function expression, use parentheses if you want a pointer to the array or function, as in the last row in the table below.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The following example shows the construction of "pointer to array of 10 pointers to int".</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Verbal expression</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Declarator</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Syntax Rule Applied</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>pointer(s) to</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>5</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>array of 10</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>4</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>pointer to</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>6 and then 5</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When multiple pointer, reference, array or function modifiers are used, declarators may become quite complicated.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The topic <bpt id="p1">[</bpt>Interpreting More Complex Declarators<ept id="p1">](../c-language/interpreting-more-complex-declarators.md)</ept> describes how to read more complex declarator syntax.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The topic is applicable to both C and C++, although in C++, anywhere the * is used to indicate a pointer, a qualified name such as MyClass::<ph id="ph1">\*</ph> may be used to specify a pointer to a member of a class.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>