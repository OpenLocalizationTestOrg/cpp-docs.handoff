{"nodes":[{"pos":[12,43],"content":"CArchive Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CArchive Class | Microsoft Docs","pos":[0,31]}]},{"content":"CArchive Class","pos":[752,766]},{"content":"Allows you to save a complex network of objects in a permanent binary form (usually disk storage) that persists after those objects are deleted.","pos":[767,911]},{"content":"Syntax","pos":[920,926]},{"content":"Members","pos":[967,974]},{"content":"Public Constructors","pos":[984,1003]},{"content":"Name","pos":[1010,1014]},{"content":"Description","pos":[1015,1026]},{"content":"CArchive::CArchive","pos":[1065,1083]},{"pos":[1106,1134],"content":"Creates a <ph id=\"ph1\">`CArchive`</ph> object.","source":"Creates a `CArchive` object."},{"content":"Public Methods","pos":[1145,1159]},{"content":"Name","pos":[1166,1170]},{"content":"Description","pos":[1171,1182]},{"content":"CArchive::Abort","pos":[1221,1236]},{"content":"Closes an archive without throwing an exception.","pos":[1256,1304]},{"content":"CArchive::Close","pos":[1310,1325]},{"pos":[1345,1401],"content":"Flushes unwritten data and disconnects from the <ph id=\"ph1\">`CFile`</ph>.","source":"Flushes unwritten data and disconnects from the `CFile`."},{"content":"CArchive::Flush","pos":[1407,1422]},{"content":"Flushes unwritten data from the archive buffer.","pos":[1442,1489]},{"content":"CArchive::GetFile","pos":[1495,1512]},{"pos":[1534,1583],"content":"Gets the <ph id=\"ph1\">`CFile`</ph> object pointer for this archive.","source":"Gets the `CFile` object pointer for this archive."},{"content":"CArchive::GetObjectSchema","pos":[1589,1614]},{"pos":[1644,1747],"content":"Called from the <ph id=\"ph1\">`Serialize`</ph> function to determine the version of the object that is being deserialized.","source":"Called from the `Serialize` function to determine the version of the object that is being deserialized."},{"content":"CArchive::IsBufferEmpty","pos":[1753,1776]},{"content":"Determines whether the buffer has been emptied during a Windows Sockets receive process.","pos":[1804,1892]},{"content":"CArchive::IsLoading","pos":[1898,1917]},{"content":"Determines whether the archive is loading.","pos":[1941,1983]},{"content":"CArchive::IsStoring","pos":[1989,2008]},{"content":"Determines whether the archive is storing.","pos":[2032,2074]},{"content":"CArchive::MapObject","pos":[2080,2099]},{"content":"Places objects in the map that are not serialized to the file, but that are available for subobjects to reference.","pos":[2123,2237]},{"content":"CArchive::Read","pos":[2243,2257]},{"content":"Reads raw bytes.","pos":[2276,2292]},{"content":"CArchive::ReadClass","pos":[2298,2317]},{"pos":[2341,2401],"content":"Reads a class reference previously stored with <ph id=\"ph1\">`WriteClass`</ph>.","source":"Reads a class reference previously stored with `WriteClass`."},{"content":"CArchive::ReadObject","pos":[2407,2427]},{"pos":[2452,2503],"content":"Calls an object's <ph id=\"ph1\">`Serialize`</ph> function for loading.","source":"Calls an object's `Serialize` function for loading."},{"content":"CArchive::ReadString","pos":[2509,2529]},{"content":"Reads a single line of text.","pos":[2554,2582]},{"content":"CArchive::SerializeClass","pos":[2588,2612]},{"pos":[2641,2747],"content":"Reads or writes the class reference to the <ph id=\"ph1\">`CArchive`</ph> object depending on the direction of the <ph id=\"ph2\">`CArchive`</ph>.","source":"Reads or writes the class reference to the `CArchive` object depending on the direction of the `CArchive`."},{"content":"CArchive::SetLoadParams","pos":[2753,2776]},{"content":"Sets the size to which the load array grows.","pos":[2804,2848]},{"content":"Must be called before any object is loaded or before <ph id=\"ph1\">`MapObject`</ph> or <ph id=\"ph2\">`ReadObject`</ph> is called.","pos":[2849,2940],"source":" Must be called before any object is loaded or before `MapObject` or `ReadObject` is called."},{"content":"CArchive::SetObjectSchema","pos":[2946,2971]},{"content":"Sets the object schema stored in the archive object.","pos":[3001,3053]},{"content":"CArchive::SetStoreParams","pos":[3059,3083]},{"content":"Sets the hash table size and the block size of the map used to identify unique objects during the serialization process.","pos":[3112,3232]},{"content":"CArchive::Write","pos":[3238,3253]},{"content":"Writes raw bytes.","pos":[3273,3290]},{"content":"CArchive::WriteClass","pos":[3296,3316]},{"pos":[3341,3401],"content":"Writes a reference to the <ph id=\"ph1\">`CRuntimeClass`</ph> to the <ph id=\"ph2\">`CArchive`</ph>.","source":"Writes a reference to the `CRuntimeClass` to the `CArchive`."},{"content":"CArchive::WriteObject","pos":[3407,3428]},{"pos":[3454,3505],"content":"Calls an object's <ph id=\"ph1\">`Serialize`</ph> function for storing.","source":"Calls an object's `Serialize` function for storing."},{"content":"CArchive::WriteString","pos":[3511,3532]},{"content":"Writes a single line of text.","pos":[3558,3587]},{"content":"Public Operators","pos":[3598,3614]},{"content":"Name","pos":[3621,3625]},{"content":"Description","pos":[3626,3637]},{"content":"CArchive::operator","pos":[3676,3694]},{"content":"Stores objects and primitive types to the archive.","pos":[3732,3782]},{"content":"CArchive::operator","pos":[3788,3806]},{"content":"Loads objects and primitive types from the archive.","pos":[3844,3895]},{"content":"Public Data Members","pos":[3906,3925]},{"content":"Name","pos":[3932,3936]},{"content":"Description","pos":[3937,3948]},{"content":"CArchive::m_pDocument","pos":[3987,4008]},{"content":"Remarks","pos":[4044,4051]},{"pos":[4066,4093],"content":"does not have a base class."},{"content":"Later you can load the objects from persistent storage, reconstituting them in memory.","pos":[4100,4186]},{"content":"This process of making data persistent is called \"serialization.\"","pos":[4187,4252]},{"content":"You can think of an archive object as a kind of binary stream.","pos":[4259,4321]},{"content":"Like an input/output stream, an archive is associated with a file and permits the buffered writing and reading of data to and from storage.","pos":[4322,4461]},{"content":"An input/output stream processes sequences of ASCII characters, but an archive processes binary object data in an efficient, nonredundant format.","pos":[4462,4607]},{"content":"You must create a <bpt id=\"p1\">[</bpt>CFile<ept id=\"p1\">](../../mfc/reference/cfile-class.md)</ept> object before you can create a <ph id=\"ph1\">`CArchive`</ph> object.","pos":[4614,4725],"source":"You must create a [CFile](../../mfc/reference/cfile-class.md) object before you can create a `CArchive` object."},{"content":"In addition, you must ensure that the archive's load/store status is compatible with the file's open mode.","pos":[4726,4832]},{"content":"You are limited to one active archive per file.","pos":[4833,4880]},{"content":"When you construct a <ph id=\"ph1\">`CArchive`</ph> object, you attach it to an object of class <ph id=\"ph2\">`CFile`</ph> (or a derived class) that represents an open file.","pos":[4887,5021],"source":"When you construct a `CArchive` object, you attach it to an object of class `CFile` (or a derived class) that represents an open file."},{"content":"You also specify whether the archive will be used for loading or storing.","pos":[5022,5095]},{"content":"A <ph id=\"ph1\">`CArchive`</ph> object can process not only primitive types but also objects of <bpt id=\"p1\">[</bpt>CObject<ept id=\"p1\">](../../mfc/reference/cobject-class.md)</ept>-derived classes designed for serialization.","pos":[5096,5264],"source":" A `CArchive` object can process not only primitive types but also objects of [CObject](../../mfc/reference/cobject-class.md)-derived classes designed for serialization."},{"content":"A serializable class usually has a <ph id=\"ph1\">`Serialize`</ph> member function, and it usually uses the <bpt id=\"p1\">[</bpt>DECLARE_SERIAL<ept id=\"p1\">](../../mfc/reference/run-time-object-model-services.md#declare_serial)</ept> and <bpt id=\"p2\">[</bpt>IMPLEMENT_SERIAL<ept id=\"p2\">](../../mfc/reference/run-time-object-model-services.md#implement_serial)</ept> macros, as described under class <ph id=\"ph2\">`CObject`</ph>.","pos":[5265,5578],"source":" A serializable class usually has a `Serialize` member function, and it usually uses the [DECLARE_SERIAL](../../mfc/reference/run-time-object-model-services.md#declare_serial) and [IMPLEMENT_SERIAL](../../mfc/reference/run-time-object-model-services.md#implement_serial) macros, as described under class `CObject`."},{"pos":[5585,5765],"content":"The overloaded extraction ( <bpt id=\"p1\">**</bpt><ph id=\"ph1\">&gt;&gt;</ph><ept id=\"p1\">**</ept>) and insertion ( <bpt id=\"p2\">**</bpt><ph id=\"ph2\">&lt;&lt;</ph><ept id=\"p2\">**</ept>) operators are convenient archive programming interfaces that support both primitive types and <ph id=\"ph3\">`CObject`</ph>-derived classes.","source":"The overloaded extraction ( **>>**) and insertion ( **<<**) operators are convenient archive programming interfaces that support both primitive types and `CObject`-derived classes."},{"content":"also supports programming with the MFC Windows Sockets classes <bpt id=\"p1\">[</bpt>CSocket<ept id=\"p1\">](../../mfc/reference/csocket-class.md)</ept> and <bpt id=\"p2\">[</bpt>CSocketFile<ept id=\"p2\">](../../mfc/reference/csocketfile-class.md)</ept>.","pos":[5783,5954],"source":" also supports programming with the MFC Windows Sockets classes [CSocket](../../mfc/reference/csocket-class.md) and [CSocketFile](../../mfc/reference/csocketfile-class.md)."},{"content":"The <bpt id=\"p1\">[</bpt>IsBufferEmpty<ept id=\"p1\">](#carchive__isbufferempty)</ept> member function supports that usage.","pos":[5955,6037],"source":" The [IsBufferEmpty](#carchive__isbufferempty) member function supports that usage."},{"pos":[6044,6257],"content":"For more information on <ph id=\"ph1\">`CArchive`</ph>, see the articles <bpt id=\"p1\">[</bpt>Serialization<ept id=\"p1\">](../../mfc/serialization-in-mfc.md)</ept> and <bpt id=\"p2\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p2\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.","source":"For more information on `CArchive`, see the articles [Serialization](../../mfc/serialization-in-mfc.md) and [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md)."},{"content":"Inheritance Hierarchy","pos":[6266,6287]},{"content":"Requirements","pos":[6310,6322]},{"pos":[6326,6343],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afx.h","source":"**Header:** afx.h"},{"pos":[6385,6400],"content":"CArchive::Abort"},{"content":"Call this function to close the archive without throwing an exception.","pos":[6404,6474]},{"content":"Remarks","pos":[6514,6521]},{"content":"The <bpt id=\"p1\">**</bpt>CArchive<ept id=\"p1\">**</ept> destructor will normally call <bpt id=\"p2\">**</bpt>Close<ept id=\"p2\">**</ept>, which will flush any data that has not been saved to the associated <ph id=\"ph1\">`CFile`</ph> object.","pos":[6525,6666],"source":"The **CArchive** destructor will normally call **Close**, which will flush any data that has not been saved to the associated `CFile` object."},{"content":"This can cause exceptions.","pos":[6667,6693]},{"content":"When catching these exceptions, it is a good idea to use <bpt id=\"p1\">**</bpt>Abort<ept id=\"p1\">**</ept>, so that destructing the <ph id=\"ph1\">`CArchive`</ph> object doesn't cause further exceptions.","pos":[6700,6843],"source":"When catching these exceptions, it is a good idea to use **Abort**, so that destructing the `CArchive` object doesn't cause further exceptions."},{"content":"When handling exceptions, <ph id=\"ph1\">`CArchive::Abort`</ph> will not throw an exception on failures because, unlike <bpt id=\"p1\">[</bpt>CArchive::Close<ept id=\"p1\">](#carchive__close)</ept>, <bpt id=\"p2\">**</bpt>Abort<ept id=\"p2\">**</ept> ignores failures.","pos":[6844,7008],"source":" When handling exceptions, `CArchive::Abort` will not throw an exception on failures because, unlike [CArchive::Close](#carchive__close), **Abort** ignores failures."},{"pos":[7015,7129],"content":"If you used <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> to allocate the <ph id=\"ph1\">`CArchive`</ph> object on the heap, then you must delete it after closing the file.","source":"If you used **new** to allocate the `CArchive` object on the heap, then you must delete it after closing the file."},{"content":"Example","pos":[7139,7146]},{"pos":[7151,7217],"content":"See the example for <bpt id=\"p1\">[</bpt>CArchive::WriteClass<ept id=\"p1\">](#carchive__writeclass)</ept>.","source":"See the example for [CArchive::WriteClass](#carchive__writeclass)."},{"pos":[7262,7280],"content":"CArchive::CArchive"},{"pos":[7284,7384],"content":"Constructs a <ph id=\"ph1\">`CArchive`</ph> object and specifies whether it will be used for loading or storing objects.","source":"Constructs a `CArchive` object and specifies whether it will be used for loading or storing objects."},{"content":"Parameters","pos":[7509,7519]},{"content":"A pointer to the <ph id=\"ph1\">`CFile`</ph> object that is the ultimate source or destination of the persistent data.","pos":[7534,7632],"source":" A pointer to the `CFile` object that is the ultimate source or destination of the persistent data."},{"content":"A flag that specifies whether objects will be loaded from or stored to the archive.","pos":[7650,7733]},{"content":"The <ph id=\"ph1\">`nMode`</ph> parameter must have one of the following values:","pos":[7734,7794],"source":" The `nMode` parameter must have one of the following values:"},{"content":"<bpt id=\"p1\">**</bpt>CArchive::load<ept id=\"p1\">**</ept> Loads data from the archive.","pos":[7802,7849],"source":"**CArchive::load** Loads data from the archive."},{"content":"Requires only <ph id=\"ph1\">`CFile`</ph> read permission.","pos":[7850,7888],"source":" Requires only `CFile` read permission."},{"content":"<bpt id=\"p1\">**</bpt>CArchive::store<ept id=\"p1\">**</ept> Saves data to the archive.","pos":[7896,7942],"source":"**CArchive::store** Saves data to the archive."},{"content":"Requires <ph id=\"ph1\">`CFile`</ph> write permission.","pos":[7943,7977],"source":" Requires `CFile` write permission."},{"content":"<bpt id=\"p1\">**</bpt>CArchive::bNoFlushOnDelete<ept id=\"p1\">**</ept> Prevents the archive from automatically calling <ph id=\"ph1\">`Flush`</ph> when the archive destructor is called.","pos":[7985,8110],"source":"**CArchive::bNoFlushOnDelete** Prevents the archive from automatically calling `Flush` when the archive destructor is called."},{"content":"If you set this flag, you are responsible for explicitly calling <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept> before the destructor is called.","pos":[8111,8218],"source":" If you set this flag, you are responsible for explicitly calling **Close** before the destructor is called."},{"content":"If you do not, your data will be corrupted.","pos":[8219,8262]},{"pos":[8269,8551],"content":"`nBufSize`  \nAn integer that specifies the size of the internal file buffer, in bytes. Note that the default buffer size is 4,096 bytes. If you routinely archive large objects, you will improve performance if you use a larger buffer size that is a multiple of the file buffer size.","leadings":[""," "],"nodes":[{"content":"An integer that specifies the size of the internal file buffer, in bytes. Note that the default buffer size is 4,096 bytes. If you routinely archive large objects, you will improve performance if you use a larger buffer size that is a multiple of the file buffer size.","pos":[13,281],"nodes":[{"content":"An integer that specifies the size of the internal file buffer, in bytes.","pos":[0,73]},{"content":"Note that the default buffer size is 4,096 bytes.","pos":[74,123]},{"content":"If you routinely archive large objects, you will improve performance if you use a larger buffer size that is a multiple of the file buffer size.","pos":[124,268]}]}]},{"pos":[8558,8816],"content":"`lpBuf`  \nAn optional pointer to a user-supplied buffer of size `nBufSize`. If you do not specify this parameter, the archive allocates a buffer from the local heap and frees it when the object is destroyed. The archive does not free a user-supplied buffer.","leadings":[""," "],"nodes":[{"content":"An optional pointer to a user-supplied buffer of size `nBufSize`. If you do not specify this parameter, the archive allocates a buffer from the local heap and frees it when the object is destroyed. The archive does not free a user-supplied buffer.","pos":[10,257],"nodes":[{"content":"An optional pointer to a user-supplied buffer of size <ph id=\"ph1\">`nBufSize`</ph>.","pos":[0,65],"source":"An optional pointer to a user-supplied buffer of size `nBufSize`."},{"content":"If you do not specify this parameter, the archive allocates a buffer from the local heap and frees it when the object is destroyed.","pos":[66,197]},{"content":"The archive does not free a user-supplied buffer.","pos":[198,247]}]}]},{"content":"Remarks","pos":[8826,8833]},{"content":"You cannot change this specification after you have created the archive.","pos":[8837,8909]},{"content":"You may not use <ph id=\"ph1\">`CFile`</ph> operations to alter the state of the file until you have closed the archive.","pos":[8916,9016],"source":"You may not use `CFile` operations to alter the state of the file until you have closed the archive."},{"content":"Any such operation will damage the integrity of the archive.","pos":[9017,9077]},{"content":"You may access the position of the file pointer at any time during serialization by obtaining the archive's file object from the <bpt id=\"p1\">[</bpt>GetFile<ept id=\"p1\">](#carchive__getfile)</ept> member function and then using the <bpt id=\"p2\">[</bpt>CFile::GetPosition<ept id=\"p2\">](../../mfc/reference/cfile-class.md#cfile__getposition)</ept> function.","pos":[9078,9357],"source":" You may access the position of the file pointer at any time during serialization by obtaining the archive's file object from the [GetFile](#carchive__getfile) member function and then using the [CFile::GetPosition](../../mfc/reference/cfile-class.md#cfile__getposition) function."},{"content":"You should call <bpt id=\"p1\">[</bpt>CArchive::Flush<ept id=\"p1\">](#carchive__flush)</ept> before obtaining the position of the file pointer.","pos":[9358,9460],"source":" You should call [CArchive::Flush](#carchive__flush) before obtaining the position of the file pointer."},{"content":"Example","pos":[9470,9477]},{"pos":[9492,9515],"content":"NVC_MFCSerialization#12"},{"pos":[9607,9622],"content":"CArchive::Close"},{"content":"Flushes any data remaining in the buffer, closes the archive, and disconnects the archive from the file.","pos":[9626,9730]},{"content":"Remarks","pos":[9769,9776]},{"content":"No further operations on the archive are permitted.","pos":[9780,9831]},{"content":"After you close an archive, you can create another archive for the same file or you can close the file.","pos":[9832,9935]},{"content":"The member function <bpt id=\"p1\">**</bpt>Close<ept id=\"p1\">**</ept> ensures that all data is transferred from the archive to the file, and it makes the archive unavailable.","pos":[9942,10076],"source":"The member function **Close** ensures that all data is transferred from the archive to the file, and it makes the archive unavailable."},{"content":"To complete the transfer from the file to the storage medium, you must first use <bpt id=\"p1\">[</bpt>CFile::Close<ept id=\"p1\">](../../mfc/reference/cfile-class.md#cfile__close)</ept> and then destroy the <ph id=\"ph1\">`CFile`</ph> object.","pos":[10077,10258],"source":" To complete the transfer from the file to the storage medium, you must first use [CFile::Close](../../mfc/reference/cfile-class.md#cfile__close) and then destroy the `CFile` object."},{"content":"Example","pos":[10268,10275]},{"pos":[10280,10348],"content":"See the example for <bpt id=\"p1\">[</bpt>CArchive::WriteString<ept id=\"p1\">](#carchive__writestring)</ept>.","source":"See the example for [CArchive::WriteString](#carchive__writestring)."},{"pos":[10390,10405],"content":"CArchive::Flush"},{"content":"Forces any data remaining in the archive buffer to be written to the file.","pos":[10409,10483]},{"content":"Remarks","pos":[10522,10529]},{"content":"The member function <ph id=\"ph1\">`Flush`</ph> ensures that all data is transferred from the archive to the file.","pos":[10533,10627],"source":"The member function `Flush` ensures that all data is transferred from the archive to the file."},{"content":"You must call <bpt id=\"p1\">[</bpt>CFile::Close<ept id=\"p1\">](../../mfc/reference/cfile-class.md#cfile__close)</ept> to complete the transfer from the file to the storage medium.","pos":[10628,10767],"source":" You must call [CFile::Close](../../mfc/reference/cfile-class.md#cfile__close) to complete the transfer from the file to the storage medium."},{"content":"Example","pos":[10777,10784]},{"pos":[10799,10822],"content":"NVC_MFCSerialization#13"},{"pos":[10916,10933],"content":"CArchive::GetFile"},{"pos":[10937,10986],"content":"Gets the <ph id=\"ph1\">`CFile`</ph> object pointer for this archive.","source":"Gets the `CFile` object pointer for this archive."},{"content":"Return Value","pos":[11038,11050]},{"pos":[11054,11102],"content":"A constant pointer to the <ph id=\"ph1\">`CFile`</ph> object in use.","source":"A constant pointer to the `CFile` object in use."},{"content":"Remarks","pos":[11112,11119]},{"pos":[11123,11173],"content":"You must flush the archive before using <ph id=\"ph1\">`GetFile`</ph>.","source":"You must flush the archive before using `GetFile`."},{"content":"Example","pos":[11183,11190]},{"pos":[11205,11228],"content":"NVC_MFCSerialization#14"},{"pos":[11330,11355],"content":"CArchive::GetObjectSchema"},{"pos":[11359,11484],"content":"Call this function from the <ph id=\"ph1\">`Serialize`</ph> function to determine the version of the object that is currently being deserialized.","source":"Call this function from the `Serialize` function to determine the version of the object that is currently being deserialized."},{"content":"Return Value","pos":[11533,11545]},{"content":"During deserialization, the version of the object being read.","pos":[11549,11610]},{"content":"Remarks","pos":[11620,11627]},{"content":"Calling this function is only valid when the <ph id=\"ph1\">`CArchive`</ph> object is being loaded ( <bpt id=\"p1\">[</bpt>CArchive::IsLoading<ept id=\"p1\">](#carchive__isloading)</ept> returns nonzero).","pos":[11631,11773],"source":"Calling this function is only valid when the `CArchive` object is being loaded ( [CArchive::IsLoading](#carchive__isloading) returns nonzero)."},{"content":"It should be the first call in the <ph id=\"ph1\">`Serialize`</ph> function and called only once.","pos":[11774,11851],"source":" It should be the first call in the `Serialize` function and called only once."},{"content":"A return value of ( <bpt id=\"p1\">**</bpt>UINT<ept id=\"p1\">**</ept>)–1 indicates that the version number is unknown.","pos":[11852,11929],"source":" A return value of ( **UINT**)–1 indicates that the version number is unknown."},{"content":"A <ph id=\"ph1\">`CObject`</ph>-derived class may use <bpt id=\"p1\">**</bpt>VERSIONABLE_SCHEMA<ept id=\"p1\">**</ept> combined (using bitwise <ph id=\"ph2\">`OR`</ph>) with the schema version itself (in the <ph id=\"ph3\">`IMPLEMENT_SERIAL`</ph> macro) to create a \"versionable object,\" that is, an object whose <ph id=\"ph4\">`Serialize`</ph> member function can read multiple versions.","pos":[11936,12202],"source":"A `CObject`-derived class may use **VERSIONABLE_SCHEMA** combined (using bitwise `OR`) with the schema version itself (in the `IMPLEMENT_SERIAL` macro) to create a \"versionable object,\" that is, an object whose `Serialize` member function can read multiple versions."},{"content":"The default framework functionality (without <bpt id=\"p1\">**</bpt>VERSIONABLE_SCHEMA<ept id=\"p1\">**</ept>) is to throw an exception when the version is mismatched.","pos":[12203,12328],"source":" The default framework functionality (without **VERSIONABLE_SCHEMA**) is to throw an exception when the version is mismatched."},{"content":"Example","pos":[12338,12345]},{"pos":[12360,12383],"content":"NVC_MFCSerialization#15"},{"pos":[12483,12506],"content":"CArchive::IsBufferEmpty"},{"content":"Call this member function to determine whether the archive object's internal buffer is empty.","pos":[12510,12603]},{"content":"Return Value","pos":[12659,12671]},{"content":"Nonzero if the archive's buffer is empty; otherwise 0.","pos":[12675,12729]},{"content":"Remarks","pos":[12739,12746]},{"content":"This function is supplied to support programming with the MFC Windows Sockets class <ph id=\"ph1\">`CSocketFile`</ph>.","pos":[12750,12848],"source":"This function is supplied to support programming with the MFC Windows Sockets class `CSocketFile`."},{"content":"You do not need to use it for an archive associated with a <ph id=\"ph1\">`CFile`</ph> object.","pos":[12849,12923],"source":" You do not need to use it for an archive associated with a `CFile` object."},{"content":"The reason for using <ph id=\"ph1\">`IsBufferEmpty`</ph> with an archive associated with a <ph id=\"ph2\">`CSocketFile`</ph> object is that the archive's buffer might contain more than one message or record.","pos":[12930,13097],"source":"The reason for using `IsBufferEmpty` with an archive associated with a `CSocketFile` object is that the archive's buffer might contain more than one message or record."},{"content":"After receiving one message, you should use <ph id=\"ph1\">`IsBufferEmpty`</ph> to control a loop that continues receiving data until the buffer is empty.","pos":[13098,13232],"source":" After receiving one message, you should use `IsBufferEmpty` to control a loop that continues receiving data until the buffer is empty."},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>Receive<ept id=\"p1\">](../../mfc/reference/casyncsocket-class.md#casyncsocket__receive)</ept> member function of class <ph id=\"ph1\">`CAsyncSocket`</ph>, which shows how to use <ph id=\"ph2\">`IsBufferEmpty`</ph>.","pos":[13233,13418],"source":" For more information, see the [Receive](../../mfc/reference/casyncsocket-class.md#casyncsocket__receive) member function of class `CAsyncSocket`, which shows how to use `IsBufferEmpty`."},{"pos":[13425,13556],"content":"For more information, see <bpt id=\"p1\">[</bpt>Windows Sockets: Using Sockets with Archives<ept id=\"p1\">](../../mfc/windows-sockets-using-sockets-with-archives.md)</ept>.","source":"For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md)."},{"pos":[13602,13621],"content":"CArchive::IsLoading"},{"content":"Determines whether the archive is loading data.","pos":[13625,13672]},{"content":"Return Value","pos":[13724,13736]},{"content":"Nonzero if the archive is currently being used for loading; otherwise 0.","pos":[13740,13812]},{"content":"Remarks","pos":[13822,13829]},{"pos":[13833,13917],"content":"This member function is called by the <ph id=\"ph1\">`Serialize`</ph> functions of the archived classes.","source":"This member function is called by the `Serialize` functions of the archived classes."},{"content":"Example","pos":[13927,13934]},{"pos":[13949,13972],"content":"NVC_MFCSerialization#16"},{"pos":[14068,14087],"content":"CArchive::IsStoring"},{"content":"Determines whether the archive is storing data.","pos":[14091,14138]},{"content":"Return Value","pos":[14190,14202]},{"content":"Nonzero if the archive is currently being used for storing; otherwise 0.","pos":[14206,14278]},{"content":"Remarks","pos":[14288,14295]},{"pos":[14299,14383],"content":"This member function is called by the <ph id=\"ph1\">`Serialize`</ph> functions of the archived classes.","source":"This member function is called by the `Serialize` functions of the archived classes."},{"pos":[14390,14491],"content":"If the <ph id=\"ph1\">`IsStoring`</ph> status of an archive is nonzero, then its <ph id=\"ph2\">`IsLoading`</ph> status is 0, and vice versa.","source":"If the `IsStoring` status of an archive is nonzero, then its `IsLoading` status is 0, and vice versa."},{"content":"Example","pos":[14501,14508]},{"pos":[14523,14546],"content":"NVC_MFCSerialization#17"},{"pos":[14642,14661],"content":"CArchive::MapObject"},{"content":"Call this member function to place objects in the map that are not really serialized to the file, but that are available for subobjects to reference.","pos":[14665,14814]},{"content":"Parameters","pos":[14875,14885]},{"content":"A constant pointer to the object being stored.","pos":[14898,14944]},{"content":"Remarks","pos":[14954,14961]},{"content":"For example, you might not serialize a document, but you would serialize the items that are part of the document.","pos":[14965,15078]},{"content":"By calling <ph id=\"ph1\">`MapObject`</ph>, you allow those items, or subobjects, to reference the document.","pos":[15079,15167],"source":" By calling `MapObject`, you allow those items, or subobjects, to reference the document."},{"content":"Also, serialized subitems can serialize their <ph id=\"ph1\">`m_pDocument`</ph> back pointer.","pos":[15168,15241],"source":" Also, serialized subitems can serialize their `m_pDocument` back pointer."},{"content":"You can call <ph id=\"ph1\">`MapObject`</ph> when you store to and load from the <ph id=\"ph2\">`CArchive`</ph> object.","pos":[15248,15327],"source":"You can call `MapObject` when you store to and load from the `CArchive` object."},{"content":"adds the specified object to the internal data structures maintained by the <ph id=\"ph1\">`CArchive`</ph> object during serialization and deserialization, but unlike <bpt id=\"p1\">[</bpt>ReadObject<ept id=\"p1\">](#carchive__readobject)</ept> and <bpt id=\"p2\">[</bpt>WriteObject<ept id=\"p2\">](#carchive__writeobject)</ept><bpt id=\"p3\">**</bpt>,<ept id=\"p3\">**</ept> it does not call serialize on the object.","pos":[15340,15611],"source":" adds the specified object to the internal data structures maintained by the `CArchive` object during serialization and deserialization, but unlike [ReadObject](#carchive__readobject) and [WriteObject](#carchive__writeobject)**,** it does not call serialize on the object."},{"content":"Example","pos":[15621,15628]},{"pos":[15643,15666],"content":"NVC_MFCSerialization#18"},{"pos":[15732,15755],"content":"NVC_MFCSerialization#19"},{"pos":[15823,15846],"content":"NVC_MFCSerialization#20"},{"pos":[15912,15935],"content":"NVC_MFCSerialization#21"},{"pos":[16034,16055],"content":"CArchive::m_pDocument"},{"pos":[16059,16184],"content":"Set to <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> by default, this pointer to a <bpt id=\"p2\">**</bpt>CDocument<ept id=\"p2\">**</ept> can be set to anything the user of the <ph id=\"ph1\">`CArchive`</ph> instance wants.","source":"Set to **NULL** by default, this pointer to a **CDocument** can be set to anything the user of the `CArchive` instance wants."},{"content":"Remarks","pos":[16235,16242]},{"content":"A common usage of this pointer is to convey additional information about the serialization process to all objects being serialized.","pos":[16246,16377]},{"content":"This is achieved by initializing the pointer with the document (a <bpt id=\"p1\">**</bpt>CDocument<ept id=\"p1\">**</ept>-derived class) that is being serialized, in such a way that objects within the document can access the document if necessary.","pos":[16378,16583],"source":" This is achieved by initializing the pointer with the document (a **CDocument**-derived class) that is being serialized, in such a way that objects within the document can access the document if necessary."},{"content":"This pointer is also used by <ph id=\"ph1\">`COleClientItem`</ph> objects during serialization.","pos":[16584,16659],"source":" This pointer is also used by `COleClientItem` objects during serialization."},{"content":"The framework sets <ph id=\"ph1\">`m_pDocument`</ph> to the document being serialized when a user issues a File Open or Save command.","pos":[16666,16779],"source":"The framework sets `m_pDocument` to the document being serialized when a user issues a File Open or Save command."},{"content":"If you serialize an Object Linking and Embedding (OLE) container document for reasons other than File Open or Save, you must explicitly set <ph id=\"ph1\">`m_pDocument`</ph>.","pos":[16780,16934],"source":" If you serialize an Object Linking and Embedding (OLE) container document for reasons other than File Open or Save, you must explicitly set `m_pDocument`."},{"content":"For example, you would do this when serializing a container document to the Clipboard.","pos":[16935,17021]},{"content":"Example","pos":[17031,17038]},{"pos":[17053,17076],"content":"NVC_MFCSerialization#35"},{"pos":[17178,17196],"content":"CArchive::operator"},{"content":"Stores the indicated object or primitive type to the archive.","pos":[17209,17270]},{"content":"Return Value","pos":[18245,18257]},{"pos":[18261,18343],"content":"A <ph id=\"ph1\">`CArchive`</ph> reference that enables multiple insertion operators on a single line.","source":"A `CArchive` reference that enables multiple insertion operators on a single line."},{"content":"Remarks","pos":[18353,18360]},{"content":"The last two versions above are specifically for storing 64-bit integers.","pos":[18364,18437]},{"content":"If you used the <ph id=\"ph1\">`IMPLEMENT_SERIAL`</ph> macro in your class implementation, then the insertion operator overloaded for <ph id=\"ph2\">`CObject`</ph> calls the protected <bpt id=\"p1\">**</bpt>WriteObject<ept id=\"p1\">**</ept>.","pos":[18444,18604],"source":"If you used the `IMPLEMENT_SERIAL` macro in your class implementation, then the insertion operator overloaded for `CObject` calls the protected **WriteObject**."},{"content":"This function, in turn, calls the <ph id=\"ph1\">`Serialize`</ph> function of the class.","pos":[18605,18673],"source":" This function, in turn, calls the `Serialize` function of the class."},{"pos":[18680,18823],"content":"The <bpt id=\"p1\">[</bpt>CStringT<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> insertion operator (&lt;&lt;) supports diagnostic dumping and storing to an archive.","source":"The [CStringT](../../atl-mfc-shared/reference/cstringt-class.md) insertion operator (<<) supports diagnostic dumping and storing to an archive."},{"content":"Example","pos":[18833,18840]},{"pos":[18844,18950],"content":"This example demonstrates the use of the <ph id=\"ph1\">`CArchive`</ph> insertion operator &lt;&lt; with the <ph id=\"ph2\">`int`</ph> and <ph id=\"ph3\">`long`</ph> types.","source":"This example demonstrates the use of the `CArchive` insertion operator << with the `int` and `long` types."},{"pos":[18968,18991],"content":"NVC_MFCSerialization#31"},{"content":"Example","pos":[19052,19059]},{"pos":[19063,19164],"content":"This example 2 demonstrates the use of the <ph id=\"ph1\">`CArchive`</ph> insertion operator &lt;&lt; with the <ph id=\"ph2\">`CStringT`</ph> type.","source":"This example 2 demonstrates the use of the `CArchive` insertion operator << with the `CStringT` type."},{"pos":[19182,19205],"content":"NVC_MFCSerialization#32"},{"pos":[19307,19325],"content":"CArchive::operator"},{"content":"Loads the indicated object or primitive type from the archive.","pos":[19338,19400]},{"content":"Return Value","pos":[20588,20600]},{"pos":[20604,20687],"content":"A <ph id=\"ph1\">`CArchive`</ph> reference that enables multiple extraction operators on a single line.","source":"A `CArchive` reference that enables multiple extraction operators on a single line."},{"content":"Remarks","pos":[20697,20704]},{"content":"The last two versions above are specifically for loading 64-bit integers.","pos":[20708,20781]},{"content":"If you used the <ph id=\"ph1\">`IMPLEMENT_SERIAL`</ph> macro in your class implementation, then the extraction operators overloaded for <ph id=\"ph2\">`CObject`</ph> call the protected <bpt id=\"p1\">**</bpt>ReadObject<ept id=\"p1\">**</ept> function (with a nonzero run-time class pointer).","pos":[20788,20997],"source":"If you used the `IMPLEMENT_SERIAL` macro in your class implementation, then the extraction operators overloaded for `CObject` call the protected **ReadObject** function (with a nonzero run-time class pointer)."},{"content":"This function, in turn, calls the <ph id=\"ph1\">`Serialize`</ph> function of the class.","pos":[20998,21066],"source":" This function, in turn, calls the `Serialize` function of the class."},{"pos":[21073,21196],"content":"The <bpt id=\"p1\">[</bpt>CStringT<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> extraction operator (&gt;&gt;) supports loading from an archive.","source":"The [CStringT](../../atl-mfc-shared/reference/cstringt-class.md) extraction operator (>>) supports loading from an archive."},{"content":"Example","pos":[21206,21213]},{"pos":[21217,21312],"content":"This example demonstrates the use of the <ph id=\"ph1\">`CArchive`</ph> extraction operator &gt;&gt; with the <ph id=\"ph2\">`int`</ph> type.","source":"This example demonstrates the use of the `CArchive` extraction operator >> with the `int` type."},{"pos":[21330,21353],"content":"NVC_MFCSerialization#33"},{"content":"Example","pos":[21414,21421]},{"pos":[21425,21548],"content":"This example demonstrates the use of the <ph id=\"ph1\">`CArchive`</ph> insertion and extraction operators &lt;<ph id=\"ph2\">\\&lt;</ph> and &gt;&gt; with the <ph id=\"ph3\">`CStringT`</ph> type.","source":"This example demonstrates the use of the `CArchive` insertion and extraction operators <\\< and >> with the `CStringT` type."},{"pos":[21566,21589],"content":"NVC_MFCSerialization#34"},{"pos":[21681,21695],"content":"CArchive::Read"},{"content":"Reads a specified number of bytes from the archive.","pos":[21699,21750]},{"content":"Parameters","pos":[21816,21826]},{"content":"A pointer to a user-supplied buffer that is to receive the data read from the archive.","pos":[21841,21927]},{"content":"An unsigned integer specifying the number of bytes to be read from the archive.","pos":[21944,22023]},{"content":"Return Value","pos":[22033,22045]},{"content":"An unsigned integer containing the number of bytes actually read.","pos":[22049,22114]},{"content":"If the return value is less than the number requested, the end of file has been reached.","pos":[22115,22203]},{"content":"No exception is thrown on the end-of-file condition.","pos":[22204,22256]},{"content":"Remarks","pos":[22266,22273]},{"content":"The archive does not interpret the bytes.","pos":[22277,22318]},{"pos":[22325,22466],"content":"You can use the <bpt id=\"p1\">**</bpt>Read<ept id=\"p1\">**</ept> member function within your <ph id=\"ph1\">`Serialize`</ph> function for reading ordinary structures that are contained in your objects.","source":"You can use the **Read** member function within your `Serialize` function for reading ordinary structures that are contained in your objects."},{"content":"Example","pos":[22476,22483]},{"pos":[22498,22521],"content":"NVC_MFCSerialization#24"},{"pos":[22618,22637],"content":"CArchive::ReadClass"},{"pos":[22641,22757],"content":"Call this member function to read a reference to a class previously stored with <bpt id=\"p1\">[</bpt>WriteClass<ept id=\"p1\">](#carchive__writeclass)</ept>.","source":"Call this member function to read a reference to a class previously stored with [WriteClass](#carchive__writeclass)."},{"content":"Parameters","pos":[22917,22927]},{"content":"A pointer to the <bpt id=\"p1\">[</bpt>CRuntimeClass<ept id=\"p1\">](../../mfc/reference/cruntimeclass-structure.md)</ept> structure that corresponds to the class reference requested.","pos":[22955,23096],"source":" A pointer to the [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) structure that corresponds to the class reference requested."},{"content":"Can be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[23097,23113],"source":" Can be **NULL**."},{"content":"A pointer to a schema of the run-time class previously stored.","pos":[23133,23195]},{"content":"A number that refers to an object's unique tag.","pos":[23214,23261]},{"content":"Used internally by the implementation of <bpt id=\"p1\">[</bpt>ReadObject<ept id=\"p1\">](#carchive__readobject)</ept>.","pos":[23262,23339],"source":" Used internally by the implementation of [ReadObject](#carchive__readobject)."},{"content":"Exposed for advanced programming only; <ph id=\"ph1\">`pObTag`</ph> normally should be <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","pos":[23340,23416],"source":" Exposed for advanced programming only; `pObTag` normally should be **NULL**."},{"content":"Return Value","pos":[23426,23438]},{"pos":[23442,23533],"content":"A pointer to the <bpt id=\"p1\">[</bpt>CRuntimeClass<ept id=\"p1\">](../../mfc/reference/cruntimeclass-structure.md)</ept> structure.","source":"A pointer to the [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) structure."},{"content":"Remarks","pos":[23543,23550]},{"content":"If <ph id=\"ph1\">`pClassRefRequested`</ph> is not <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, <ph id=\"ph2\">`ReadClass`</ph> verifies that the archived class information is compatible with your runtime class.","pos":[23554,23690],"source":"If `pClassRefRequested` is not **NULL**, `ReadClass` verifies that the archived class information is compatible with your runtime class."},{"content":"If it is not compatible, <ph id=\"ph1\">`ReadClass`</ph> will throw a <bpt id=\"p1\">[</bpt>CArchiveException<ept id=\"p1\">](../../mfc/reference/carchiveexception-class.md)</ept>.","pos":[23691,23809],"source":" If it is not compatible, `ReadClass` will throw a [CArchiveException](../../mfc/reference/carchiveexception-class.md)."},{"pos":[23816,24141],"content":"Your runtime class must use <bpt id=\"p1\">[</bpt>DECLARE_SERIAL<ept id=\"p1\">](../../mfc/reference/run-time-object-model-services.md#declare_serial)</ept> and <bpt id=\"p2\">[</bpt>IMPLEMENT_SERIAL<ept id=\"p2\">](../../mfc/reference/run-time-object-model-services.md#implement_serial)</ept>; otherwise, <ph id=\"ph1\">`ReadClass`</ph> will throw a <bpt id=\"p3\">[</bpt>CNotSupportedException<ept id=\"p3\">](../../mfc/reference/cnotsupportedexception-class.md)</ept>.","source":"Your runtime class must use [DECLARE_SERIAL](../../mfc/reference/run-time-object-model-services.md#declare_serial) and [IMPLEMENT_SERIAL](../../mfc/reference/run-time-object-model-services.md#implement_serial); otherwise, `ReadClass` will throw a [CNotSupportedException](../../mfc/reference/cnotsupportedexception-class.md)."},{"pos":[24148,24390],"content":"If <ph id=\"ph1\">`pSchema`</ph> is <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>, the schema of the stored class can be retrieved by calling <bpt id=\"p2\">[</bpt>CArchive::GetObjectSchema<ept id=\"p2\">](#carchive__getobjectschema)</ept>; otherwise, <bpt id=\"p3\">**</bpt><ph id=\"ph2\">\\*</ph><ept id=\"p3\">**</ept><ph id=\"ph3\">`pSchema`</ph> will contain the schema of the run-time class that was previously stored.","source":"If `pSchema` is **NULL**, the schema of the stored class can be retrieved by calling [CArchive::GetObjectSchema](#carchive__getobjectschema); otherwise, **\\***`pSchema` will contain the schema of the run-time class that was previously stored."},{"pos":[24397,24539],"content":"You can use <bpt id=\"p1\">[</bpt>SerializeClass<ept id=\"p1\">](#carchive__serializeclass)</ept> instead of <ph id=\"ph1\">`ReadClass`</ph>, which handles both reading and writing of the class reference.","source":"You can use [SerializeClass](#carchive__serializeclass) instead of `ReadClass`, which handles both reading and writing of the class reference."},{"content":"Example","pos":[24549,24556]},{"pos":[24561,24627],"content":"See the example for <bpt id=\"p1\">[</bpt>CArchive::WriteClass<ept id=\"p1\">](#carchive__writeclass)</ept>.","source":"See the example for [CArchive::WriteClass](#carchive__writeclass)."},{"pos":[24674,24694],"content":"CArchive::ReadObject"},{"content":"Reads object data from the archive and constructs an object of the appropriate type.","pos":[24698,24782]},{"content":"Parameters","pos":[24857,24867]},{"content":"A constant pointer to the <bpt id=\"p1\">[</bpt>CRuntimeClass<ept id=\"p1\">](../../mfc/reference/cruntimeclass-structure.md)</ept> structure that corresponds to the object you expect to read.","pos":[24883,25033],"source":" A constant pointer to the [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) structure that corresponds to the object you expect to read."},{"content":"Return Value","pos":[25043,25055]},{"pos":[25059,25256],"content":"A <bpt id=\"p1\">[</bpt>CObject<ept id=\"p1\">](../../mfc/reference/cobject-class.md)</ept> pointer that must be safely cast to the correct derived class by using <bpt id=\"p2\">[</bpt>CObject::IsKindOf<ept id=\"p2\">](../../mfc/reference/cobject-class.md#cobject__iskindof)</ept>.","source":"A [CObject](../../mfc/reference/cobject-class.md) pointer that must be safely cast to the correct derived class by using [CObject::IsKindOf](../../mfc/reference/cobject-class.md#cobject__iskindof)."},{"content":"Remarks","pos":[25266,25273]},{"content":"This function is normally called by the <ph id=\"ph1\">`CArchive`</ph> extraction ( <bpt id=\"p1\">**</bpt><ph id=\"ph2\">&gt;&gt;</ph><ept id=\"p1\">**</ept>) operator overloaded for a <bpt id=\"p2\">[</bpt>CObject<ept id=\"p2\">](../../mfc/reference/cobject-class.md)</ept> pointer.","pos":[25277,25431],"source":"This function is normally called by the `CArchive` extraction ( **>>**) operator overloaded for a [CObject](../../mfc/reference/cobject-class.md) pointer."},{"content":"<bpt id=\"p1\">**</bpt>ReadObject<ept id=\"p1\">**</ept>, in turn, calls the <ph id=\"ph1\">`Serialize`</ph> function of the archived class.","pos":[25432,25510],"source":"**ReadObject**, in turn, calls the `Serialize` function of the archived class."},{"content":"If you supply a nonzero <ph id=\"ph1\">`pClass`</ph> parameter, which is obtained by the <bpt id=\"p1\">[</bpt>RUNTIME_CLASS<ept id=\"p1\">](../../mfc/reference/run-time-object-model-services.md#runtime_class)</ept> macro, then the function verifies the run-time class of the archived object.","pos":[25517,25747],"source":"If you supply a nonzero `pClass` parameter, which is obtained by the [RUNTIME_CLASS](../../mfc/reference/run-time-object-model-services.md#runtime_class) macro, then the function verifies the run-time class of the archived object."},{"content":"This assumes you have used the <ph id=\"ph1\">`IMPLEMENT_SERIAL`</ph> macro in the implementation of the class.","pos":[25748,25839],"source":" This assumes you have used the `IMPLEMENT_SERIAL` macro in the implementation of the class."},{"content":"Example","pos":[25849,25856]},{"pos":[25861,25929],"content":"See the example for <bpt id=\"p1\">[</bpt>CArchive::WriteObject<ept id=\"p1\">](#carchive__writeobject)</ept>.","source":"See the example for [CArchive::WriteObject](#carchive__writeobject)."},{"pos":[25976,25996],"content":"CArchive::ReadString"},{"pos":[26000,26110],"content":"Call this member function to read text data into a buffer from the file associated with the <ph id=\"ph1\">`CArchive`</ph> object.","source":"Call this member function to read text data into a buffer from the file associated with the `CArchive` object."},{"content":"Parameters","pos":[26227,26237]},{"content":"A reference to a <bpt id=\"p1\">[</bpt>CString<ept id=\"p1\">](../../atl-mfc-shared/reference/cstringt-class.md)</ept> that will contain the resultant string after it is read from the file associated with the CArchive object.","pos":[26254,26437],"source":" A reference to a [CString](../../atl-mfc-shared/reference/cstringt-class.md) that will contain the resultant string after it is read from the file associated with the CArchive object."},{"content":"Specifies a pointer to a user-supplied buffer that will receive a null-terminated text string.","pos":[26454,26548]},{"content":"Specifies the maximum number of characters to read.","pos":[26565,26616]},{"content":"Should be one less than the size of the <bpt id=\"p1\">*</bpt>lpsz<ept id=\"p1\">*</ept> buffer.","pos":[26617,26671],"source":" Should be one less than the size of the *lpsz* buffer."},{"content":"Return Value","pos":[26681,26693]},{"pos":[26697,26779],"content":"In the version that returns <bpt id=\"p1\">**</bpt>BOOL<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>TRUE<ept id=\"p2\">**</ept> if successful; <bpt id=\"p3\">**</bpt>FALSE<ept id=\"p3\">**</ept> otherwise.","source":"In the version that returns **BOOL**, **TRUE** if successful; **FALSE** otherwise."},{"pos":[26786,26913],"content":"In the version that returns an <ph id=\"ph1\">`LPTSTR`</ph>, a pointer to the buffer containing the text data; <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> if end-of-file was reached.","source":"In the version that returns an `LPTSTR`, a pointer to the buffer containing the text data; **NULL** if end-of-file was reached."},{"content":"Remarks","pos":[26923,26930]},{"content":"In the version of the member function with the <ph id=\"ph1\">`nMax`</ph> parameter, the buffer will hold up to a limit of <ph id=\"ph2\">`nMax`</ph> - 1 characters.","pos":[26934,27059],"source":"In the version of the member function with the `nMax` parameter, the buffer will hold up to a limit of `nMax` - 1 characters."},{"content":"Reading is stopped by a carriage return-linefeed pair.","pos":[27060,27114]},{"content":"Trailing newline characters are always removed.","pos":[27115,27162]},{"content":"A null character ('\\0') is appended in either case.","pos":[27163,27214]},{"pos":[27221,27355],"content":"<bpt id=\"p1\">[</bpt>CArchive::Read<ept id=\"p1\">](#carchive__read)</ept> is also available for text-mode input, but it does not terminate on a carriage return-linefeed pair.","source":"[CArchive::Read](#carchive__read) is also available for text-mode input, but it does not terminate on a carriage return-linefeed pair."},{"content":"Example","pos":[27365,27372]},{"pos":[27377,27445],"content":"See the example for <bpt id=\"p1\">[</bpt>CArchive::WriteString<ept id=\"p1\">](#carchive__writestring)</ept>.","source":"See the example for [CArchive::WriteString](#carchive__writestring)."},{"pos":[27496,27520],"content":"CArchive::SerializeClass"},{"content":"Call this member function when you want to store and load the version information of a base class.","pos":[27524,27622]},{"content":"Parameters","pos":[27700,27710]},{"content":"A pointer to a run-time class object for the base class.","pos":[27729,27785]},{"content":"Remarks","pos":[27795,27802]},{"content":"reads or writes the reference to a class to the <ph id=\"ph1\">`CArchive`</ph> object, depending on the direction of the <ph id=\"ph2\">`CArchive`</ph>.","pos":[27823,27935],"source":" reads or writes the reference to a class to the `CArchive` object, depending on the direction of the `CArchive`."},{"content":"Use <ph id=\"ph1\">`SerializeClass`</ph> in place of <bpt id=\"p1\">[</bpt>ReadClass<ept id=\"p1\">](#carchive__readclass)</ept> and <bpt id=\"p2\">[</bpt>WriteClass<ept id=\"p2\">](#carchive__writeclass)</ept> as a convenient way to serialize base-class objects; <ph id=\"ph2\">`SerializeClass`</ph> requires less code and fewer parameters.","pos":[27936,28153],"source":" Use `SerializeClass` in place of [ReadClass](#carchive__readclass) and [WriteClass](#carchive__writeclass) as a convenient way to serialize base-class objects; `SerializeClass` requires less code and fewer parameters."},{"content":"Like <ph id=\"ph1\">`ReadClass`</ph>, <ph id=\"ph2\">`SerializeClass`</ph> verifies that the archived class information is compatible with your runtime class.","pos":[28160,28278],"source":"Like `ReadClass`, `SerializeClass` verifies that the archived class information is compatible with your runtime class."},{"content":"If it is not compatible, <ph id=\"ph1\">`SerializeClass`</ph> will throw a <bpt id=\"p1\">[</bpt>CArchiveException<ept id=\"p1\">](../../mfc/reference/carchiveexception-class.md)</ept>.","pos":[28279,28402],"source":" If it is not compatible, `SerializeClass` will throw a [CArchiveException](../../mfc/reference/carchiveexception-class.md)."},{"pos":[28409,28739],"content":"Your runtime class must use <bpt id=\"p1\">[</bpt>DECLARE_SERIAL<ept id=\"p1\">](../../mfc/reference/run-time-object-model-services.md#declare_serial)</ept> and <bpt id=\"p2\">[</bpt>IMPLEMENT_SERIAL<ept id=\"p2\">](../../mfc/reference/run-time-object-model-services.md#implement_serial)</ept>; otherwise, <ph id=\"ph1\">`SerializeClass`</ph> will throw a <bpt id=\"p3\">[</bpt>CNotSupportedException<ept id=\"p3\">](../../mfc/reference/cnotsupportedexception-class.md)</ept>.","source":"Your runtime class must use [DECLARE_SERIAL](../../mfc/reference/run-time-object-model-services.md#declare_serial) and [IMPLEMENT_SERIAL](../../mfc/reference/run-time-object-model-services.md#implement_serial); otherwise, `SerializeClass` will throw a [CNotSupportedException](../../mfc/reference/cnotsupportedexception-class.md)."},{"content":"Use the <bpt id=\"p1\">[</bpt>RUNTIME_CLASS<ept id=\"p1\">](../../mfc/reference/run-time-object-model-services.md#runtime_class)</ept> macro to retrieve the value for the <ph id=\"ph1\">`pRuntimeClass`</ph> parameter.","pos":[28746,28901],"source":"Use the [RUNTIME_CLASS](../../mfc/reference/run-time-object-model-services.md#runtime_class) macro to retrieve the value for the `pRuntimeClass` parameter."},{"content":"The base class must have used the <bpt id=\"p1\">[</bpt>IMPLEMENT_SERIAL<ept id=\"p1\">](../../mfc/reference/run-time-object-model-services.md#implement_serial)</ept> macro.","pos":[28902,29033],"source":" The base class must have used the [IMPLEMENT_SERIAL](../../mfc/reference/run-time-object-model-services.md#implement_serial) macro."},{"content":"Example","pos":[29043,29050]},{"pos":[29065,29088],"content":"NVC_MFCSerialization#25"},{"pos":[29187,29210],"content":"CArchive::SetLoadParams"},{"pos":[29214,29322],"content":"Call <ph id=\"ph1\">`SetLoadParams`</ph> when you are going to read a large number of <ph id=\"ph2\">`CObject`</ph>-derived objects from an archive.","source":"Call `SetLoadParams` when you are going to read a large number of `CObject`-derived objects from an archive."},{"content":"Parameters","pos":[29388,29398]},{"content":"The minimum number of element slots to allocate if a size increase is necessary.","pos":[29415,29495]},{"content":"Remarks","pos":[29505,29512]},{"content":"uses a load array to resolve references to objects stored in the archive.","pos":[29527,29600]},{"content":"allows you to set the size to which the load array grows.","pos":[29617,29674]},{"pos":[29681,29835],"content":"You must not call <ph id=\"ph1\">`SetLoadParams`</ph> after any object is loaded, or after <bpt id=\"p1\">[</bpt>MapObject<ept id=\"p1\">](#carchive__mapobject)</ept> or <bpt id=\"p2\">[</bpt>ReadObject<ept id=\"p2\">](#carchive__readobject)</ept> is called.","source":"You must not call `SetLoadParams` after any object is loaded, or after [MapObject](#carchive__mapobject) or [ReadObject](#carchive__readobject) is called."},{"content":"Example","pos":[29845,29852]},{"pos":[29867,29890],"content":"NVC_MFCSerialization#26"},{"pos":[29991,30016],"content":"CArchive::SetObjectSchema"},{"pos":[30020,30113],"content":"Call this member function to set the object schema stored in the archive object to <ph id=\"ph1\">`nSchema`</ph>.","source":"Call this member function to set the object schema stored in the archive object to `nSchema`."},{"content":"Parameters","pos":[30174,30184]},{"content":"Specifies the object's schema.","pos":[30201,30231]},{"content":"Remarks","pos":[30241,30248]},{"pos":[30252,30357],"content":"The next call to <bpt id=\"p1\">[</bpt>GetObjectSchema<ept id=\"p1\">](#carchive__getobjectschema)</ept> will return the value stored in <ph id=\"ph1\">`nSchema`</ph>.","source":"The next call to [GetObjectSchema](#carchive__getobjectschema) will return the value stored in `nSchema`."},{"pos":[30364,30524],"content":"Use <ph id=\"ph1\">`SetObjectSchema`</ph> for advanced versioning; for example, when you want to force a particular version to be read in a <ph id=\"ph2\">`Serialize`</ph> function of a derived class.","source":"Use `SetObjectSchema` for advanced versioning; for example, when you want to force a particular version to be read in a `Serialize` function of a derived class."},{"content":"Example","pos":[30534,30541]},{"pos":[30556,30579],"content":"NVC_MFCSerialization#27"},{"pos":[30681,30705],"content":"CArchive::SetStoreParams"},{"pos":[30709,30801],"content":"Use <ph id=\"ph1\">`SetStoreParams`</ph> when storing a large number of <ph id=\"ph2\">`CObject`</ph>-derived objects in an archive.","source":"Use `SetStoreParams` when storing a large number of `CObject`-derived objects in an archive."},{"content":"Parameters","pos":[30904,30914]},{"content":"nHashSize","pos":[30919,30928]},{"content":"The size of the hash table for interface pointer maps.","pos":[30933,30987]},{"content":"Should be a prime number.","pos":[30988,31013]},{"content":"Specifies the memory-allocation granularity for extending the parameters.","pos":[31036,31109]},{"content":"Should be a power of 2 for the best performance.","pos":[31110,31158]},{"content":"Remarks","pos":[31168,31175]},{"pos":[31196,31329],"content":"allows you to set the hash table size and the block size of the map used to identify unique objects during the serialization process."},{"pos":[31336,31495],"content":"You must not call <ph id=\"ph1\">`SetStoreParams`</ph> after any objects are stored, or after <bpt id=\"p1\">[</bpt>MapObject<ept id=\"p1\">](#carchive__mapobject)</ept> or <bpt id=\"p2\">[</bpt>WriteObject<ept id=\"p2\">](#carchive__writeobject)</ept> is called.","source":"You must not call `SetStoreParams` after any objects are stored, or after [MapObject](#carchive__mapobject) or [WriteObject](#carchive__writeobject) is called."},{"content":"Example","pos":[31505,31512]},{"pos":[31527,31550],"content":"NVC_MFCSerialization#26"},{"pos":[31641,31656],"content":"CArchive::Write"},{"content":"Writes a specified number of bytes to the archive.","pos":[31660,31710]},{"content":"Parameters","pos":[31788,31798]},{"content":"A pointer to a user-supplied buffer that contains the data to be written to the archive.","pos":[31813,31901]},{"content":"An integer that specifies the number of bytes to be written to the archive.","pos":[31918,31993]},{"content":"Remarks","pos":[32003,32010]},{"content":"The archive does not format the bytes.","pos":[32014,32052]},{"pos":[32059,32198],"content":"You can use the <bpt id=\"p1\">**</bpt>Write<ept id=\"p1\">**</ept> member function within your <ph id=\"ph1\">`Serialize`</ph> function to write ordinary structures that are contained in your objects.","source":"You can use the **Write** member function within your `Serialize` function to write ordinary structures that are contained in your objects."},{"content":"Example","pos":[32208,32215]},{"pos":[32230,32253],"content":"NVC_MFCSerialization#23"},{"pos":[32351,32371],"content":"CArchive::WriteClass"},{"pos":[32375,32493],"content":"Use <ph id=\"ph1\">`WriteClass`</ph> to store the version and class information of a base class during serialization of the derived class.","source":"Use `WriteClass` to store the version and class information of a base class during serialization of the derived class."},{"content":"Parameters","pos":[32567,32577]},{"content":"A pointer to the <bpt id=\"p1\">[</bpt>CRuntimeClass<ept id=\"p1\">](../../mfc/reference/cruntimeclass-structure.md)</ept> structure that corresponds to the class reference requested.","pos":[32596,32737],"source":" A pointer to the [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) structure that corresponds to the class reference requested."},{"content":"Remarks","pos":[32747,32754]},{"content":"writes a reference to the <bpt id=\"p1\">[</bpt>CRuntimeClass<ept id=\"p1\">](../../mfc/reference/cruntimeclass-structure.md)</ept> for the base class to the <ph id=\"ph1\">`CArchive`</ph>.","pos":[32771,32898],"source":" writes a reference to the [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) for the base class to the `CArchive`."},{"content":"Use <bpt id=\"p1\">[</bpt>CArchive::ReadClass<ept id=\"p1\">](#carchive__readclass)</ept> to retrieve the reference.","pos":[32899,32973],"source":" Use [CArchive::ReadClass](#carchive__readclass) to retrieve the reference."},{"content":"verifies that the archived class information is compatible with your runtime class.","pos":[32993,33076]},{"content":"If it is not compatible, <ph id=\"ph1\">`WriteClass`</ph> will throw a <bpt id=\"p1\">[</bpt>CArchiveException<ept id=\"p1\">](../../mfc/reference/carchiveexception-class.md)</ept>.","pos":[33077,33196],"source":" If it is not compatible, `WriteClass` will throw a [CArchiveException](../../mfc/reference/carchiveexception-class.md)."},{"pos":[33203,33529],"content":"Your runtime class must use <bpt id=\"p1\">[</bpt>DECLARE_SERIAL<ept id=\"p1\">](../../mfc/reference/run-time-object-model-services.md#declare_serial)</ept> and <bpt id=\"p2\">[</bpt>IMPLEMENT_SERIAL<ept id=\"p2\">](../../mfc/reference/run-time-object-model-services.md#implement_serial)</ept>; otherwise, <ph id=\"ph1\">`WriteClass`</ph> will throw a <bpt id=\"p3\">[</bpt>CNotSupportedException<ept id=\"p3\">](../../mfc/reference/cnotsupportedexception-class.md)</ept>.","source":"Your runtime class must use [DECLARE_SERIAL](../../mfc/reference/run-time-object-model-services.md#declare_serial) and [IMPLEMENT_SERIAL](../../mfc/reference/run-time-object-model-services.md#implement_serial); otherwise, `WriteClass` will throw a [CNotSupportedException](../../mfc/reference/cnotsupportedexception-class.md)."},{"pos":[33536,33679],"content":"You can use <bpt id=\"p1\">[</bpt>SerializeClass<ept id=\"p1\">](#carchive__serializeclass)</ept> instead of <ph id=\"ph1\">`WriteClass`</ph>, which handles both reading and writing of the class reference.","source":"You can use [SerializeClass](#carchive__serializeclass) instead of `WriteClass`, which handles both reading and writing of the class reference."},{"content":"Example","pos":[33689,33696]},{"pos":[33711,33734],"content":"NVC_MFCSerialization#28"},{"pos":[33833,33854],"content":"CArchive::WriteObject"},{"pos":[33858,33904],"content":"Stores the specified <ph id=\"ph1\">`CObject`</ph> to the archive.","source":"Stores the specified `CObject` to the archive."},{"content":"Parameters","pos":[33967,33977]},{"content":"A constant pointer to the object being stored.","pos":[33990,34036]},{"content":"Remarks","pos":[34046,34053]},{"content":"This function is normally called by the <ph id=\"ph1\">`CArchive`</ph> insertion ( <bpt id=\"p1\">**</bpt><ph id=\"ph2\">&lt;&lt;</ph><ept id=\"p1\">**</ept>) operator overloaded for <ph id=\"ph3\">`CObject`</ph>.","pos":[34057,34162],"source":"This function is normally called by the `CArchive` insertion ( **<<**) operator overloaded for `CObject`."},{"content":"<bpt id=\"p1\">**</bpt>WriteObject<ept id=\"p1\">**</ept>, in turn, calls the <ph id=\"ph1\">`Serialize`</ph> function of the archived class.","pos":[34163,34242],"source":"**WriteObject**, in turn, calls the `Serialize` function of the archived class."},{"content":"You must use the <ph id=\"ph1\">`IMPLEMENT_SERIAL`</ph> macro to enable archiving.","pos":[34249,34311],"source":"You must use the `IMPLEMENT_SERIAL` macro to enable archiving."},{"content":"<bpt id=\"p1\">**</bpt>WriteObject<ept id=\"p1\">**</ept> writes the ASCII class name to the archive.","pos":[34312,34371],"source":"**WriteObject** writes the ASCII class name to the archive."},{"content":"This class name is validated later during the load process.","pos":[34372,34431]},{"content":"A special encoding scheme prevents unnecessary duplication of the class name for multiple objects of the class.","pos":[34432,34543]},{"content":"This scheme also prevents redundant storage of objects that are targets of more than one pointer.","pos":[34544,34641]},{"content":"The exact object encoding method (including the presence of the ASCII class name) is an implementation detail and could change in future versions of the library.","pos":[34648,34809]},{"pos":[34817,34996],"content":"[!NOTE]\n Finish creating, deleting, and updating all your objects before you begin to archive them. Your archive will be corrupted if you mix archiving with object modification.","leadings":["","> "],"nodes":[{"content":" Finish creating, deleting, and updating all your objects before you begin to archive them. Your archive will be corrupted if you mix archiving with object modification.","pos":[8,177],"nodes":[{"content":"Finish creating, deleting, and updating all your objects before you begin to archive them.","pos":[1,91]},{"content":"Your archive will be corrupted if you mix archiving with object modification.","pos":[92,169]}]}]},{"content":"Example","pos":[35006,35013]},{"pos":[35017,35149],"content":"For a definition of the class <ph id=\"ph1\">`CAge`</ph>, see the example for <bpt id=\"p1\">[</bpt>CObList::CObList<ept id=\"p1\">](../../mfc/reference/coblist-class.md#coblist__coblist)</ept>.","source":"For a definition of the class `CAge`, see the example for [CObList::CObList](../../mfc/reference/coblist-class.md#coblist__coblist)."},{"pos":[35167,35190],"content":"NVC_MFCSerialization#29"},{"pos":[35289,35310],"content":"CArchive::WriteString"},{"pos":[35314,35417],"content":"Use this member function to write data from a buffer to the file associated with the <ph id=\"ph1\">`CArchive`</ph> object.","source":"Use this member function to write data from a buffer to the file associated with the `CArchive` object."},{"content":"Parameters","pos":[35474,35484]},{"content":"Specifies a pointer to a buffer containing a null-terminated text string.","pos":[35498,35571]},{"content":"Remarks","pos":[35581,35588]},{"content":"The terminating null character ('\\0') is not written to the file; nor is a newline automatically written.","pos":[35592,35697]},{"pos":[35718,35807],"content":"throws an exception in response to several conditions, including the disk-full condition."},{"pos":[35814,35944],"content":"<bpt id=\"p1\">**</bpt>Write<ept id=\"p1\">**</ept> is also available, but rather than terminating on a null character, it writes the requested number of bytes to the file.","source":"**Write** is also available, but rather than terminating on a null character, it writes the requested number of bytes to the file."},{"content":"Example","pos":[35954,35961]},{"pos":[35976,35999],"content":"NVC_MFCSerialization#30"},{"content":"See Also","pos":[36059,36067]},{"content":"Hierarchy Chart","pos":[36072,36087]},{"content":"CFile Class","pos":[36124,36135]},{"content":"CObject Class","pos":[36178,36191]},{"content":"CSocket Class","pos":[36236,36249]},{"content":"CSocketFile Class","pos":[36294,36311]}],"content":"---\ntitle: \"CArchive Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CArchive\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"I/O [MFC], archiving objects\"\n  - \"CArchive class\"\n  - \"serialization [C++], CArchive class\"\n  - \"storage [C++], CArchive class\"\n  - \"data storage [C++], CArchive class\"\nms.assetid: 9e950d23-b874-456e-ae4b-fe00781a7699\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CArchive Class\nAllows you to save a complex network of objects in a permanent binary form (usually disk storage) that persists after those objects are deleted.  \n  \n## Syntax  \n  \n```  \nclass CArchive  \n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CArchive::CArchive](#carchive__carchive)|Creates a `CArchive` object.|  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CArchive::Abort](#carchive__abort)|Closes an archive without throwing an exception.|  \n|[CArchive::Close](#carchive__close)|Flushes unwritten data and disconnects from the `CFile`.|  \n|[CArchive::Flush](#carchive__flush)|Flushes unwritten data from the archive buffer.|  \n|[CArchive::GetFile](#carchive__getfile)|Gets the `CFile` object pointer for this archive.|  \n|[CArchive::GetObjectSchema](#carchive__getobjectschema)|Called from the `Serialize` function to determine the version of the object that is being deserialized.|  \n|[CArchive::IsBufferEmpty](#carchive__isbufferempty)|Determines whether the buffer has been emptied during a Windows Sockets receive process.|  \n|[CArchive::IsLoading](#carchive__isloading)|Determines whether the archive is loading.|  \n|[CArchive::IsStoring](#carchive__isstoring)|Determines whether the archive is storing.|  \n|[CArchive::MapObject](#carchive__mapobject)|Places objects in the map that are not serialized to the file, but that are available for subobjects to reference.|  \n|[CArchive::Read](#carchive__read)|Reads raw bytes.|  \n|[CArchive::ReadClass](#carchive__readclass)|Reads a class reference previously stored with `WriteClass`.|  \n|[CArchive::ReadObject](#carchive__readobject)|Calls an object's `Serialize` function for loading.|  \n|[CArchive::ReadString](#carchive__readstring)|Reads a single line of text.|  \n|[CArchive::SerializeClass](#carchive__serializeclass)|Reads or writes the class reference to the `CArchive` object depending on the direction of the `CArchive`.|  \n|[CArchive::SetLoadParams](#carchive__setloadparams)|Sets the size to which the load array grows. Must be called before any object is loaded or before `MapObject` or `ReadObject` is called.|  \n|[CArchive::SetObjectSchema](#carchive__setobjectschema)|Sets the object schema stored in the archive object.|  \n|[CArchive::SetStoreParams](#carchive__setstoreparams)|Sets the hash table size and the block size of the map used to identify unique objects during the serialization process.|  \n|[CArchive::Write](#carchive__write)|Writes raw bytes.|  \n|[CArchive::WriteClass](#carchive__writeclass)|Writes a reference to the `CRuntimeClass` to the `CArchive`.|  \n|[CArchive::WriteObject](#carchive__writeobject)|Calls an object's `Serialize` function for storing.|  \n|[CArchive::WriteString](#carchive__writestring)|Writes a single line of text.|  \n  \n### Public Operators  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CArchive::operator &lt;&lt;](#carchive__operator_lt_lt)|Stores objects and primitive types to the archive.|  \n|[CArchive::operator &gt;&gt;](#carchive__operator_gt_gt)|Loads objects and primitive types from the archive.|  \n  \n### Public Data Members  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CArchive::m_pDocument](#carchive__m_pdocument)||  \n  \n## Remarks  \n `CArchive` does not have a base class.  \n  \n Later you can load the objects from persistent storage, reconstituting them in memory. This process of making data persistent is called \"serialization.\"  \n  \n You can think of an archive object as a kind of binary stream. Like an input/output stream, an archive is associated with a file and permits the buffered writing and reading of data to and from storage. An input/output stream processes sequences of ASCII characters, but an archive processes binary object data in an efficient, nonredundant format.  \n  \n You must create a [CFile](../../mfc/reference/cfile-class.md) object before you can create a `CArchive` object. In addition, you must ensure that the archive's load/store status is compatible with the file's open mode. You are limited to one active archive per file.  \n  \n When you construct a `CArchive` object, you attach it to an object of class `CFile` (or a derived class) that represents an open file. You also specify whether the archive will be used for loading or storing. A `CArchive` object can process not only primitive types but also objects of [CObject](../../mfc/reference/cobject-class.md)-derived classes designed for serialization. A serializable class usually has a `Serialize` member function, and it usually uses the [DECLARE_SERIAL](../../mfc/reference/run-time-object-model-services.md#declare_serial) and [IMPLEMENT_SERIAL](../../mfc/reference/run-time-object-model-services.md#implement_serial) macros, as described under class `CObject`.  \n  \n The overloaded extraction ( **>>**) and insertion ( **<<**) operators are convenient archive programming interfaces that support both primitive types and `CObject`-derived classes.  \n  \n `CArchive` also supports programming with the MFC Windows Sockets classes [CSocket](../../mfc/reference/csocket-class.md) and [CSocketFile](../../mfc/reference/csocketfile-class.md). The [IsBufferEmpty](#carchive__isbufferempty) member function supports that usage.  \n  \n For more information on `CArchive`, see the articles [Serialization](../../mfc/serialization-in-mfc.md) and [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md).  \n  \n## Inheritance Hierarchy  \n `CArchive`  \n  \n## Requirements  \n **Header:** afx.h  \n  \n##  <a name=\"carchive__abort\"></a>  CArchive::Abort  \n Call this function to close the archive without throwing an exception.  \n  \n```  \nvoid Abort ();\n```  \n  \n### Remarks  \n The **CArchive** destructor will normally call **Close**, which will flush any data that has not been saved to the associated `CFile` object. This can cause exceptions.  \n  \n When catching these exceptions, it is a good idea to use **Abort**, so that destructing the `CArchive` object doesn't cause further exceptions. When handling exceptions, `CArchive::Abort` will not throw an exception on failures because, unlike [CArchive::Close](#carchive__close), **Abort** ignores failures.  \n  \n If you used **new** to allocate the `CArchive` object on the heap, then you must delete it after closing the file.  \n  \n### Example  \n  See the example for [CArchive::WriteClass](#carchive__writeclass).  \n  \n##  <a name=\"carchive__carchive\"></a>  CArchive::CArchive  \n Constructs a `CArchive` object and specifies whether it will be used for loading or storing objects.  \n  \n```  \nCArchive(\n    CFile* pFile,  \n    UINT nMode,  \n    int nBufSize = 4096,  \n    void* lpBuf = NULL);\n```  \n  \n### Parameters  \n `pFile`  \n A pointer to the `CFile` object that is the ultimate source or destination of the persistent data.  \n  \n `nMode`  \n A flag that specifies whether objects will be loaded from or stored to the archive. The `nMode` parameter must have one of the following values:  \n  \n- **CArchive::load** Loads data from the archive. Requires only `CFile` read permission.  \n  \n- **CArchive::store** Saves data to the archive. Requires `CFile` write permission.  \n  \n- **CArchive::bNoFlushOnDelete** Prevents the archive from automatically calling `Flush` when the archive destructor is called. If you set this flag, you are responsible for explicitly calling **Close** before the destructor is called. If you do not, your data will be corrupted.  \n  \n `nBufSize`  \n An integer that specifies the size of the internal file buffer, in bytes. Note that the default buffer size is 4,096 bytes. If you routinely archive large objects, you will improve performance if you use a larger buffer size that is a multiple of the file buffer size.  \n  \n `lpBuf`  \n An optional pointer to a user-supplied buffer of size `nBufSize`. If you do not specify this parameter, the archive allocates a buffer from the local heap and frees it when the object is destroyed. The archive does not free a user-supplied buffer.  \n  \n### Remarks  \n You cannot change this specification after you have created the archive.  \n  \n You may not use `CFile` operations to alter the state of the file until you have closed the archive. Any such operation will damage the integrity of the archive. You may access the position of the file pointer at any time during serialization by obtaining the archive's file object from the [GetFile](#carchive__getfile) member function and then using the [CFile::GetPosition](../../mfc/reference/cfile-class.md#cfile__getposition) function. You should call [CArchive::Flush](#carchive__flush) before obtaining the position of the file pointer.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#12](../../mfc/codesnippet/cpp/carchive-class_1.cpp)]  \n  \n##  <a name=\"carchive__close\"></a>  CArchive::Close  \n Flushes any data remaining in the buffer, closes the archive, and disconnects the archive from the file.  \n  \n```  \nvoid Close();\n```  \n  \n### Remarks  \n No further operations on the archive are permitted. After you close an archive, you can create another archive for the same file or you can close the file.  \n  \n The member function **Close** ensures that all data is transferred from the archive to the file, and it makes the archive unavailable. To complete the transfer from the file to the storage medium, you must first use [CFile::Close](../../mfc/reference/cfile-class.md#cfile__close) and then destroy the `CFile` object.  \n  \n### Example  \n  See the example for [CArchive::WriteString](#carchive__writestring).  \n  \n##  <a name=\"carchive__flush\"></a>  CArchive::Flush  \n Forces any data remaining in the archive buffer to be written to the file.  \n  \n```  \nvoid Flush();\n```  \n  \n### Remarks  \n The member function `Flush` ensures that all data is transferred from the archive to the file. You must call [CFile::Close](../../mfc/reference/cfile-class.md#cfile__close) to complete the transfer from the file to the storage medium.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#13](../../mfc/codesnippet/cpp/carchive-class_2.cpp)]  \n  \n##  <a name=\"carchive__getfile\"></a>  CArchive::GetFile  \n Gets the `CFile` object pointer for this archive.  \n  \n```  \nCFile* GetFile() const;\n\n \n```  \n  \n### Return Value  \n A constant pointer to the `CFile` object in use.  \n  \n### Remarks  \n You must flush the archive before using `GetFile`.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#14](../../mfc/codesnippet/cpp/carchive-class_3.cpp)]  \n  \n##  <a name=\"carchive__getobjectschema\"></a>  CArchive::GetObjectSchema  \n Call this function from the `Serialize` function to determine the version of the object that is currently being deserialized.  \n  \n```  \nUINT GetObjectSchema();\n```  \n  \n### Return Value  \n During deserialization, the version of the object being read.  \n  \n### Remarks  \n Calling this function is only valid when the `CArchive` object is being loaded ( [CArchive::IsLoading](#carchive__isloading) returns nonzero). It should be the first call in the `Serialize` function and called only once. A return value of ( **UINT**)–1 indicates that the version number is unknown.  \n  \n A `CObject`-derived class may use **VERSIONABLE_SCHEMA** combined (using bitwise `OR`) with the schema version itself (in the `IMPLEMENT_SERIAL` macro) to create a \"versionable object,\" that is, an object whose `Serialize` member function can read multiple versions. The default framework functionality (without **VERSIONABLE_SCHEMA**) is to throw an exception when the version is mismatched.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#15](../../mfc/codesnippet/cpp/carchive-class_4.cpp)]  \n  \n##  <a name=\"carchive__isbufferempty\"></a>  CArchive::IsBufferEmpty  \n Call this member function to determine whether the archive object's internal buffer is empty.  \n  \n```  \nBOOL IsBufferEmpty() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the archive's buffer is empty; otherwise 0.  \n  \n### Remarks  \n This function is supplied to support programming with the MFC Windows Sockets class `CSocketFile`. You do not need to use it for an archive associated with a `CFile` object.  \n  \n The reason for using `IsBufferEmpty` with an archive associated with a `CSocketFile` object is that the archive's buffer might contain more than one message or record. After receiving one message, you should use `IsBufferEmpty` to control a loop that continues receiving data until the buffer is empty. For more information, see the [Receive](../../mfc/reference/casyncsocket-class.md#casyncsocket__receive) member function of class `CAsyncSocket`, which shows how to use `IsBufferEmpty`.  \n  \n For more information, see [Windows Sockets: Using Sockets with Archives](../../mfc/windows-sockets-using-sockets-with-archives.md).  \n  \n##  <a name=\"carchive__isloading\"></a>  CArchive::IsLoading  \n Determines whether the archive is loading data.  \n  \n```  \nBOOL IsLoading() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the archive is currently being used for loading; otherwise 0.  \n  \n### Remarks  \n This member function is called by the `Serialize` functions of the archived classes.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#16](../../mfc/codesnippet/cpp/carchive-class_5.cpp)]  \n  \n##  <a name=\"carchive__isstoring\"></a>  CArchive::IsStoring  \n Determines whether the archive is storing data.  \n  \n```  \nBOOL IsStoring() const;\n\n \n```  \n  \n### Return Value  \n Nonzero if the archive is currently being used for storing; otherwise 0.  \n  \n### Remarks  \n This member function is called by the `Serialize` functions of the archived classes.  \n  \n If the `IsStoring` status of an archive is nonzero, then its `IsLoading` status is 0, and vice versa.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#17](../../mfc/codesnippet/cpp/carchive-class_6.cpp)]  \n  \n##  <a name=\"carchive__mapobject\"></a>  CArchive::MapObject  \n Call this member function to place objects in the map that are not really serialized to the file, but that are available for subobjects to reference.  \n  \n```  \nvoid MapObject(const CObject* pOb);\n```  \n  \n### Parameters  \n `pOb`  \n A constant pointer to the object being stored.  \n  \n### Remarks  \n For example, you might not serialize a document, but you would serialize the items that are part of the document. By calling `MapObject`, you allow those items, or subobjects, to reference the document. Also, serialized subitems can serialize their `m_pDocument` back pointer.  \n  \n You can call `MapObject` when you store to and load from the `CArchive` object. `MapObject` adds the specified object to the internal data structures maintained by the `CArchive` object during serialization and deserialization, but unlike [ReadObject](#carchive__readobject) and [WriteObject](#carchive__writeobject)**,** it does not call serialize on the object.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#18](../../mfc/codesnippet/cpp/carchive-class_7.h)]  \n  \n [!code-cpp[NVC_MFCSerialization#19](../../mfc/codesnippet/cpp/carchive-class_8.cpp)]  \n  \n [!code-cpp[NVC_MFCSerialization#20](../../mfc/codesnippet/cpp/carchive-class_9.h)]  \n  \n [!code-cpp[NVC_MFCSerialization#21](../../mfc/codesnippet/cpp/carchive-class_10.cpp)]  \n  \n##  <a name=\"carchive__m_pdocument\"></a>  CArchive::m_pDocument  \n Set to **NULL** by default, this pointer to a **CDocument** can be set to anything the user of the `CArchive` instance wants.  \n  \n```  \nCDocument* m_pDocument;  \n```  \n  \n### Remarks  \n A common usage of this pointer is to convey additional information about the serialization process to all objects being serialized. This is achieved by initializing the pointer with the document (a **CDocument**-derived class) that is being serialized, in such a way that objects within the document can access the document if necessary. This pointer is also used by `COleClientItem` objects during serialization.  \n  \n The framework sets `m_pDocument` to the document being serialized when a user issues a File Open or Save command. If you serialize an Object Linking and Embedding (OLE) container document for reasons other than File Open or Save, you must explicitly set `m_pDocument`. For example, you would do this when serializing a container document to the Clipboard.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#35](../../mfc/codesnippet/cpp/carchive-class_11.cpp)]  \n  \n##  <a name=\"carchive__operator_lt_lt\"></a>  CArchive::operator &lt;&lt;  \n Stores the indicated object or primitive type to the archive.  \n  \n```  \nfriend CArchive& operator<<(\n    CArchive& ar,  \n    const CObject* pOb);\n\n \nthrow(\n    CArchiveException*, \n    CFileException*);\n\n \nCArchive& AFXAPI operator<<(\n    CArchive& ar,  \n    const RECT& rect);\n\n \nCArchive& AFXAPI operator<<(\n    CArchive& ar,  \n    POINT point);\n\n \nCArchive& AFXAPI operator<<(\n    CArchive& ar,  \n    SIZE size);\n\n \ntemplate<typename BaseType,  \n    class StringTraits> CArchive& operator<<(\n    const ATL::CStringT<BaseType,  \n    StringTraits>& str);\n\n \nCArchive& operator<<(BYTE by); \nCArchive& operator<<(WORD w); \nCArchive& operator<<(LONG l); \nCArchive& operator<<(DWORD dw); \nCArchive& operator<<(float f); \nCArchive& operator<<(double d); \nCArchive& operator<<(int i); \nCArchive& operator<<(short w); \nCArchive& operator<<(char ch); \nCArchive& operator<<(wchar_t ch); \nCArchive& operator<<(unsigned u); \nCArchive& operator<<(bool b); \nCArchive& operator<<(ULONGLONG dwdw); \nCArchive& operator<<(LONGLONG dwdw);\n```  \n  \n### Return Value  \n A `CArchive` reference that enables multiple insertion operators on a single line.  \n  \n### Remarks  \n The last two versions above are specifically for storing 64-bit integers.  \n  \n If you used the `IMPLEMENT_SERIAL` macro in your class implementation, then the insertion operator overloaded for `CObject` calls the protected **WriteObject**. This function, in turn, calls the `Serialize` function of the class.  \n  \n The [CStringT](../../atl-mfc-shared/reference/cstringt-class.md) insertion operator (<<) supports diagnostic dumping and storing to an archive.  \n  \n### Example  \n This example demonstrates the use of the `CArchive` insertion operator << with the `int` and `long` types.  \n  \n [!code-cpp[NVC_MFCSerialization#31](../../mfc/codesnippet/cpp/carchive-class_12.cpp)]  \n  \n### Example  \n This example 2 demonstrates the use of the `CArchive` insertion operator << with the `CStringT` type.  \n  \n [!code-cpp[NVC_MFCSerialization#32](../../mfc/codesnippet/cpp/carchive-class_13.cpp)]  \n  \n##  <a name=\"carchive__operator_gt_gt\"></a>  CArchive::operator &gt;&gt;  \n Loads the indicated object or primitive type from the archive.  \n  \n```  \nfriend CArchive& operator>>(\n    CArchive& ar,  \n    CObject *& pOb);\n\n \nthrow(\n    CArchiveException*, \n    CFileException*, \n    CMemoryException*);\n\n \nfriend CArchive& operator>>(\n    CArchive& ar,  \n    const CObject *& pOb);\n\n \nthrow(\n    CArchiveException*, \n    CFileException*, \n    CMemoryException*);\n\n \nCArchive& AFXAPI operator>>(\n    CArchive& ar,  \n    const RECT& rect);\n\n \nCArchive& AFXAPI operator>>(\n    CArchive& ar,  \n    POINT point);\n\n \nCArchive& AFXAPI operator>>(\n    CArchive& ar,  \n    SIZE size);\n\n \ntemplate<typename BaseType,  \n    class StringTraits> CArchive& operator>>(\n    ATL::CStringT<BaseType, \n    StringTraits>& str);\n\n \nCArchive& operator>>(BYTE& by);\n\n \nCArchive& operator>>(WORD& w);\n\n \nCArchive& operator>>(int& i);\n\n \nCArchive& operator>>(LONG& l);\n\n \nCArchive& operator>>(DWORD& dw);\n\n \nCArchive& operator>>(float& f);\n\n \nCArchive& operator>>(double& d);\n\n \nCArchive& operator>>(short& w);\n\n \nCArchive& operator>>(char& ch);\n\n \nCArchive& operator>>(wchar_t& ch);\n\n \nCArchive& operator>>(unsigned& u);\n\n \nCArchive& operator>>(bool& b);\n\n \nCArchive& operator>>(ULONGLONG& dwdw);\n\n \nCArchive& operator>>(LONGLONG& dwdw);\n```  \n  \n### Return Value  \n A `CArchive` reference that enables multiple extraction operators on a single line.  \n  \n### Remarks  \n The last two versions above are specifically for loading 64-bit integers.  \n  \n If you used the `IMPLEMENT_SERIAL` macro in your class implementation, then the extraction operators overloaded for `CObject` call the protected **ReadObject** function (with a nonzero run-time class pointer). This function, in turn, calls the `Serialize` function of the class.  \n  \n The [CStringT](../../atl-mfc-shared/reference/cstringt-class.md) extraction operator (>>) supports loading from an archive.  \n  \n### Example  \n This example demonstrates the use of the `CArchive` extraction operator >> with the `int` type.  \n  \n [!code-cpp[NVC_MFCSerialization#33](../../mfc/codesnippet/cpp/carchive-class_14.cpp)]  \n  \n### Example  \n This example demonstrates the use of the `CArchive` insertion and extraction operators <\\< and >> with the `CStringT` type.  \n  \n [!code-cpp[NVC_MFCSerialization#34](../../mfc/codesnippet/cpp/carchive-class_15.cpp)]  \n  \n##  <a name=\"carchive__read\"></a>  CArchive::Read  \n Reads a specified number of bytes from the archive.  \n  \n```  \nUINT Read(void* lpBuf,  \n    UINT nMax);\n```  \n  \n### Parameters  \n `lpBuf`  \n A pointer to a user-supplied buffer that is to receive the data read from the archive.  \n  \n `nMax`  \n An unsigned integer specifying the number of bytes to be read from the archive.  \n  \n### Return Value  \n An unsigned integer containing the number of bytes actually read. If the return value is less than the number requested, the end of file has been reached. No exception is thrown on the end-of-file condition.  \n  \n### Remarks  \n The archive does not interpret the bytes.  \n  \n You can use the **Read** member function within your `Serialize` function for reading ordinary structures that are contained in your objects.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#24](../../mfc/codesnippet/cpp/carchive-class_16.cpp)]  \n  \n##  <a name=\"carchive__readclass\"></a>  CArchive::ReadClass  \n Call this member function to read a reference to a class previously stored with [WriteClass](#carchive__writeclass).  \n  \n```  \nCRuntimeClass* ReadClass(\n    const CRuntimeClass* pClassRefRequested = NULL,  \n    UINT* pSchema = NULL,  \n    DWORD* pObTag = NULL);\n```  \n  \n### Parameters  \n `pClassRefRequested`  \n A pointer to the [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) structure that corresponds to the class reference requested. Can be **NULL**.  \n  \n `pSchema`  \n A pointer to a schema of the run-time class previously stored.  \n  \n `pObTag`  \n A number that refers to an object's unique tag. Used internally by the implementation of [ReadObject](#carchive__readobject). Exposed for advanced programming only; `pObTag` normally should be **NULL**.  \n  \n### Return Value  \n A pointer to the [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) structure.  \n  \n### Remarks  \n If `pClassRefRequested` is not **NULL**, `ReadClass` verifies that the archived class information is compatible with your runtime class. If it is not compatible, `ReadClass` will throw a [CArchiveException](../../mfc/reference/carchiveexception-class.md).  \n  \n Your runtime class must use [DECLARE_SERIAL](../../mfc/reference/run-time-object-model-services.md#declare_serial) and [IMPLEMENT_SERIAL](../../mfc/reference/run-time-object-model-services.md#implement_serial); otherwise, `ReadClass` will throw a [CNotSupportedException](../../mfc/reference/cnotsupportedexception-class.md).  \n  \n If `pSchema` is **NULL**, the schema of the stored class can be retrieved by calling [CArchive::GetObjectSchema](#carchive__getobjectschema); otherwise, **\\***`pSchema` will contain the schema of the run-time class that was previously stored.  \n  \n You can use [SerializeClass](#carchive__serializeclass) instead of `ReadClass`, which handles both reading and writing of the class reference.  \n  \n### Example  \n  See the example for [CArchive::WriteClass](#carchive__writeclass).  \n  \n##  <a name=\"carchive__readobject\"></a>  CArchive::ReadObject  \n Reads object data from the archive and constructs an object of the appropriate type.  \n  \n```  \nCObject* ReadObject(const CRuntimeClass* pClass);\n```  \n  \n### Parameters  \n `pClass`  \n A constant pointer to the [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) structure that corresponds to the object you expect to read.  \n  \n### Return Value  \n A [CObject](../../mfc/reference/cobject-class.md) pointer that must be safely cast to the correct derived class by using [CObject::IsKindOf](../../mfc/reference/cobject-class.md#cobject__iskindof).  \n  \n### Remarks  \n This function is normally called by the `CArchive` extraction ( **>>**) operator overloaded for a [CObject](../../mfc/reference/cobject-class.md) pointer. **ReadObject**, in turn, calls the `Serialize` function of the archived class.  \n  \n If you supply a nonzero `pClass` parameter, which is obtained by the [RUNTIME_CLASS](../../mfc/reference/run-time-object-model-services.md#runtime_class) macro, then the function verifies the run-time class of the archived object. This assumes you have used the `IMPLEMENT_SERIAL` macro in the implementation of the class.  \n  \n### Example  \n  See the example for [CArchive::WriteObject](#carchive__writeobject).  \n  \n##  <a name=\"carchive__readstring\"></a>  CArchive::ReadString  \n Call this member function to read text data into a buffer from the file associated with the `CArchive` object.  \n  \n```  \nBOOL ReadString(CString& rString);\n\n \nLPTSTR ReadString(\n    LPTSTR lpsz,  \n    UINT nMax);\n```  \n  \n### Parameters  \n `rString`  \n A reference to a [CString](../../atl-mfc-shared/reference/cstringt-class.md) that will contain the resultant string after it is read from the file associated with the CArchive object.  \n  \n `lpsz`  \n Specifies a pointer to a user-supplied buffer that will receive a null-terminated text string.  \n  \n `nMax`  \n Specifies the maximum number of characters to read. Should be one less than the size of the *lpsz* buffer.  \n  \n### Return Value  \n In the version that returns **BOOL**, **TRUE** if successful; **FALSE** otherwise.  \n  \n In the version that returns an `LPTSTR`, a pointer to the buffer containing the text data; **NULL** if end-of-file was reached.  \n  \n### Remarks  \n In the version of the member function with the `nMax` parameter, the buffer will hold up to a limit of `nMax` - 1 characters. Reading is stopped by a carriage return-linefeed pair. Trailing newline characters are always removed. A null character ('\\0') is appended in either case.  \n  \n [CArchive::Read](#carchive__read) is also available for text-mode input, but it does not terminate on a carriage return-linefeed pair.  \n  \n### Example  \n  See the example for [CArchive::WriteString](#carchive__writestring).  \n  \n##  <a name=\"carchive__serializeclass\"></a>  CArchive::SerializeClass  \n Call this member function when you want to store and load the version information of a base class.  \n  \n```  \nvoid SerializeClass(const CRuntimeClass* pClassRef);\n```  \n  \n### Parameters  \n `pClassRef`  \n A pointer to a run-time class object for the base class.  \n  \n### Remarks  \n `SerializeClass` reads or writes the reference to a class to the `CArchive` object, depending on the direction of the `CArchive`. Use `SerializeClass` in place of [ReadClass](#carchive__readclass) and [WriteClass](#carchive__writeclass) as a convenient way to serialize base-class objects; `SerializeClass` requires less code and fewer parameters.  \n  \n Like `ReadClass`, `SerializeClass` verifies that the archived class information is compatible with your runtime class. If it is not compatible, `SerializeClass` will throw a [CArchiveException](../../mfc/reference/carchiveexception-class.md).  \n  \n Your runtime class must use [DECLARE_SERIAL](../../mfc/reference/run-time-object-model-services.md#declare_serial) and [IMPLEMENT_SERIAL](../../mfc/reference/run-time-object-model-services.md#implement_serial); otherwise, `SerializeClass` will throw a [CNotSupportedException](../../mfc/reference/cnotsupportedexception-class.md).  \n  \n Use the [RUNTIME_CLASS](../../mfc/reference/run-time-object-model-services.md#runtime_class) macro to retrieve the value for the `pRuntimeClass` parameter. The base class must have used the [IMPLEMENT_SERIAL](../../mfc/reference/run-time-object-model-services.md#implement_serial) macro.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#25](../../mfc/codesnippet/cpp/carchive-class_17.h)]  \n  \n##  <a name=\"carchive__setloadparams\"></a>  CArchive::SetLoadParams  \n Call `SetLoadParams` when you are going to read a large number of `CObject`-derived objects from an archive.  \n  \n```  \nvoid SetLoadParams(UINT nGrowBy = 1024);\n```  \n  \n### Parameters  \n `nGrowBy`  \n The minimum number of element slots to allocate if a size increase is necessary.  \n  \n### Remarks  \n `CArchive` uses a load array to resolve references to objects stored in the archive. `SetLoadParams` allows you to set the size to which the load array grows.  \n  \n You must not call `SetLoadParams` after any object is loaded, or after [MapObject](#carchive__mapobject) or [ReadObject](#carchive__readobject) is called.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#26](../../mfc/codesnippet/cpp/carchive-class_18.h)]  \n  \n##  <a name=\"carchive__setobjectschema\"></a>  CArchive::SetObjectSchema  \n Call this member function to set the object schema stored in the archive object to `nSchema`.  \n  \n```  \nvoid SetObjectSchema(UINT nSchema);\n```  \n  \n### Parameters  \n `nSchema`  \n Specifies the object's schema.  \n  \n### Remarks  \n The next call to [GetObjectSchema](#carchive__getobjectschema) will return the value stored in `nSchema`.  \n  \n Use `SetObjectSchema` for advanced versioning; for example, when you want to force a particular version to be read in a `Serialize` function of a derived class.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#27](../../mfc/codesnippet/cpp/carchive-class_19.cpp)]  \n  \n##  <a name=\"carchive__setstoreparams\"></a>  CArchive::SetStoreParams  \n Use `SetStoreParams` when storing a large number of `CObject`-derived objects in an archive.  \n  \n```  \nvoid SetStoreParams(\n    UINT nHashSize = 2053,  \n    UINT nBlockSize = 128);\n```  \n  \n### Parameters  \n *nHashSize*  \n The size of the hash table for interface pointer maps. Should be a prime number.  \n  \n `nBlockSize`  \n Specifies the memory-allocation granularity for extending the parameters. Should be a power of 2 for the best performance.  \n  \n### Remarks  \n `SetStoreParams` allows you to set the hash table size and the block size of the map used to identify unique objects during the serialization process.  \n  \n You must not call `SetStoreParams` after any objects are stored, or after [MapObject](#carchive__mapobject) or [WriteObject](#carchive__writeobject) is called.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#26](../../mfc/codesnippet/cpp/carchive-class_18.h)]  \n  \n##  <a name=\"carchive__write\"></a>  CArchive::Write  \n Writes a specified number of bytes to the archive.  \n  \n```  \nvoid Write(\n    const void* lpBuf,  \n    UINT nMax);\n```  \n  \n### Parameters  \n `lpBuf`  \n A pointer to a user-supplied buffer that contains the data to be written to the archive.  \n  \n `nMax`  \n An integer that specifies the number of bytes to be written to the archive.  \n  \n### Remarks  \n The archive does not format the bytes.  \n  \n You can use the **Write** member function within your `Serialize` function to write ordinary structures that are contained in your objects.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#23](../../mfc/codesnippet/cpp/carchive-class_20.cpp)]  \n  \n##  <a name=\"carchive__writeclass\"></a>  CArchive::WriteClass  \n Use `WriteClass` to store the version and class information of a base class during serialization of the derived class.  \n  \n```  \nvoid WriteClass(const CRuntimeClass* pClassRef);\n```  \n  \n### Parameters  \n `pClassRef`  \n A pointer to the [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) structure that corresponds to the class reference requested.  \n  \n### Remarks  \n `WriteClass` writes a reference to the [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) for the base class to the `CArchive`. Use [CArchive::ReadClass](#carchive__readclass) to retrieve the reference.  \n  \n `WriteClass` verifies that the archived class information is compatible with your runtime class. If it is not compatible, `WriteClass` will throw a [CArchiveException](../../mfc/reference/carchiveexception-class.md).  \n  \n Your runtime class must use [DECLARE_SERIAL](../../mfc/reference/run-time-object-model-services.md#declare_serial) and [IMPLEMENT_SERIAL](../../mfc/reference/run-time-object-model-services.md#implement_serial); otherwise, `WriteClass` will throw a [CNotSupportedException](../../mfc/reference/cnotsupportedexception-class.md).  \n  \n You can use [SerializeClass](#carchive__serializeclass) instead of `WriteClass`, which handles both reading and writing of the class reference.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#28](../../mfc/codesnippet/cpp/carchive-class_21.cpp)]  \n  \n##  <a name=\"carchive__writeobject\"></a>  CArchive::WriteObject  \n Stores the specified `CObject` to the archive.  \n  \n```  \nvoid WriteObject(const CObject* pOb);\n```  \n  \n### Parameters  \n `pOb`  \n A constant pointer to the object being stored.  \n  \n### Remarks  \n This function is normally called by the `CArchive` insertion ( **<<**) operator overloaded for `CObject`. **WriteObject**, in turn, calls the `Serialize` function of the archived class.  \n  \n You must use the `IMPLEMENT_SERIAL` macro to enable archiving. **WriteObject** writes the ASCII class name to the archive. This class name is validated later during the load process. A special encoding scheme prevents unnecessary duplication of the class name for multiple objects of the class. This scheme also prevents redundant storage of objects that are targets of more than one pointer.  \n  \n The exact object encoding method (including the presence of the ASCII class name) is an implementation detail and could change in future versions of the library.  \n  \n> [!NOTE]\n>  Finish creating, deleting, and updating all your objects before you begin to archive them. Your archive will be corrupted if you mix archiving with object modification.  \n  \n### Example  \n For a definition of the class `CAge`, see the example for [CObList::CObList](../../mfc/reference/coblist-class.md#coblist__coblist).  \n  \n [!code-cpp[NVC_MFCSerialization#29](../../mfc/codesnippet/cpp/carchive-class_22.cpp)]  \n  \n##  <a name=\"carchive__writestring\"></a>  CArchive::WriteString  \n Use this member function to write data from a buffer to the file associated with the `CArchive` object.  \n  \n```  \nvoid WriteString(LPCTSTR lpsz);\n```  \n  \n### Parameters  \n `lpsz`  \n Specifies a pointer to a buffer containing a null-terminated text string.  \n  \n### Remarks  \n The terminating null character ('\\0') is not written to the file; nor is a newline automatically written.  \n  \n `WriteString` throws an exception in response to several conditions, including the disk-full condition.  \n  \n **Write** is also available, but rather than terminating on a null character, it writes the requested number of bytes to the file.  \n  \n### Example  \n [!code-cpp[NVC_MFCSerialization#30](../../mfc/codesnippet/cpp/carchive-class_23.cpp)]  \n  \n## See Also  \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)   \n [CFile Class](../../mfc/reference/cfile-class.md)   \n [CObject Class](../../mfc/reference/cobject-class.md)   \n [CSocket Class](../../mfc/reference/csocket-class.md)   \n [CSocketFile Class](../../mfc/reference/csocketfile-class.md)\n"}