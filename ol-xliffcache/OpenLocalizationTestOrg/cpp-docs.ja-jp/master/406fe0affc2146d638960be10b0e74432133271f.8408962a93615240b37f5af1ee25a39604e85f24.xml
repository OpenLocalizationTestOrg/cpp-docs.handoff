{"nodes":[{"pos":[12,47],"content":"struct UNWIND_CODE | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"struct UNWIND_CODE | Microsoft Docs","pos":[0,35]}]},{"content":"struct UNWIND_CODE","pos":[527,545]},{"content":"The unwind code array is used to record the sequence of operations in the prolog that affect the nonvolatile registers and RSP.","pos":[546,673]},{"content":"Each code item has the following format:","pos":[674,714]},{"content":"UBYTE","pos":[735,740]},{"content":"Offset in prolog","pos":[741,757]},{"content":"UBYTE: 4","pos":[762,770]},{"content":"Unwind operation code","pos":[771,792]},{"content":"UBYTE: 4","pos":[797,805]},{"content":"Operation info","pos":[806,820]},{"content":"The array is sorted by descending order of offset in the prolog.","pos":[828,892]},{"content":"Offset in prolog","pos":[901,917]},{"content":"Offset from the beginning of the prolog of the end of the instruction that performs this operation, plus 1 (that is, the offset of the start of the next instruction).","pos":[923,1089]},{"content":"Unwind operation code","pos":[1098,1119]},{"content":"Note: Certain operation codes require an unsigned offset to a value in the local stack frame.","pos":[1125,1218]},{"content":"This offset is from the start (lowest address) of the fixed stack allocation.","pos":[1219,1296]},{"content":"If the Frame Register field in the UNWIND_INFO is zero, this offset is from RSP.","pos":[1297,1377]},{"content":"If the Frame Register field is nonzero, this is the offset from where RSP was located when the FP reg was established.","pos":[1378,1496]},{"content":"This equals the FP reg minus the FP reg offset (16 * the scaled frame register offset in the UNWIND_INFO).","pos":[1497,1603]},{"content":"If an FP reg is used, then any unwind code taking an offset must only be used after the FP reg is established in the prolog.","pos":[1604,1728]},{"content":"For all opcodes except UWOP_SAVE_XMM128 and UWOP_SAVE_XMM128_FAR, the offset will always be a multiple of 8, because all stack values of interest are stored on 8 byte boundaries (the stack itself is always 16-byte aligned).","pos":[1735,1958]},{"content":"For operation codes that take a short offset (less than 512K), the final USHORT in the nodes for this code holds the offset divided by 8.","pos":[1959,2096]},{"content":"For operation codes that take a long offset (512K &lt;= offset &lt; 4GB), the final two USHORT nodes for this code hold the offset (in little-endian format).","pos":[2097,2248],"source":" For operation codes that take a long offset (512K <= offset < 4GB), the final two USHORT nodes for this code hold the offset (in little-endian format)."},{"content":"For the opcodes UWOP_SAVE_XMM128 and UWOP_SAVE_XMM128_FAR, the offset will always be a multiple of 16, since all 128-bit XMM operations must occur on 16-byte aligned memory.","pos":[2255,2428]},{"content":"Therefore, a scale factor of 16 is used for UWOP_SAVE_XMM128, permitting offsets of less than 1M.","pos":[2429,2526]},{"content":"The unwind operation code is one of the following:","pos":[2533,2583]},{"content":"UWOP_PUSH_NONVOL (0)1 node","pos":[2590,2616]},{"content":"Push a nonvolatile integer register, decrementing RSP by 8.","pos":[2623,2682]},{"content":"The operation info is the number of the register.","pos":[2683,2732]},{"content":"Note that, because of the constraints on epilogs, UWOP_PUSH_NONVOL unwind codes must appear first in the prolog and correspondingly, last in the unwind code array.","pos":[2733,2896]},{"content":"This relative ordering applies to all other unwind codes except UWOP_PUSH_MACHFRAME.","pos":[2897,2981]},{"content":"UWOP_ALLOC_LARGE (1)2 or 3 nodes","pos":[2988,3020]},{"content":"Allocate a large-sized area on the stack.","pos":[3027,3068]},{"content":"There are two forms.","pos":[3069,3089]},{"content":"If the operation info equals 0, then the size of the allocation divided by 8 is recorded in the next slot, allowing an allocation up to 512K – 8.","pos":[3090,3235]},{"content":"If the operation info equals 1, then the unscaled size of the allocation is recorded in the next two slots in little-endian format, allowing allocations up to 4GB – 8.","pos":[3236,3403]},{"content":"UWOP_ALLOC_SMALL (2)1 node","pos":[3410,3436]},{"content":"Allocate a small-sized area on the stack.","pos":[3443,3484]},{"content":"The size of the allocation is the operation info field * 8 + 8, allowing allocations from 8 to 128 bytes.","pos":[3485,3590]},{"content":"The unwind code for a stack allocation should always use the shortest possible encoding:","pos":[3597,3685]},{"content":"Allocation Size","pos":[3708,3723]},{"content":"Unwind Code","pos":[3728,3739]},{"content":"8 to 128 bytes","pos":[3746,3760]},{"content":"UWOP_ALLOC_SMALL","pos":[3761,3777]},{"content":"136 to 512K-8 bytes","pos":[3782,3801]},{"content":"UWOP_ALLOC_LARGE, operation info = 0","pos":[3802,3838]},{"content":"512K to 4G–8 bytes","pos":[3843,3861]},{"content":"UWOP_ALLOC_LARGE, operation info = 1","pos":[3862,3898]},{"content":"UWOP_SET_FPREG (3)1 node","pos":[3906,3930]},{"content":"Establish the frame pointer register by setting the register to some offset of the current RSP.","pos":[3937,4032]},{"content":"The offset is equal to the Frame Register offset (scaled) field in the UNWIND_INFO * 16, allowing offsets from 0 to 240.","pos":[4033,4153]},{"content":"The use of an offset permits establishing a frame pointer that points to the middle of the fixed stack allocation, helping code density by allowing more accesses to use short instruction forms.","pos":[4154,4347]},{"content":"Note that the operation info field is reserved and should not be used.","pos":[4348,4418]},{"content":"UWOP_SAVE_NONVOL (4)2 nodes","pos":[4425,4452]},{"content":"Save a nonvolatile integer register on the stack using a MOV instead of a PUSH.","pos":[4459,4538]},{"content":"This is primarily used for shrink-wrapping, where a nonvolatile register is saved to the stack in a position that was previously allocated.","pos":[4539,4678]},{"content":"The operation info is the number of the register.","pos":[4679,4728]},{"content":"The scaled-by-8 stack offset is recorded in the next unwind operation code slot, as described in the note above.","pos":[4729,4841]},{"content":"UWOP_SAVE_NONVOL_FAR (5)3 nodes","pos":[4848,4879]},{"content":"Save a nonvolatile integer register on the stack with a long offset, using a MOV instead of a PUSH.","pos":[4886,4985]},{"content":"This is primarily used for shrink-wrapping, where a nonvolatile register is saved to the stack in a position that was previously allocated.","pos":[4986,5125]},{"content":"The operation info is the number of the register.","pos":[5126,5175]},{"content":"The unscaled stack offset is recorded in the next two unwind operation code slots, as described in the note above.","pos":[5176,5290]},{"content":"UWOP_SAVE_XMM128 (8)2 nodes","pos":[5297,5324]},{"content":"Save all 128 bits of a nonvolatile XMM register on the stack.","pos":[5331,5392]},{"content":"The operation info is the number of the register.","pos":[5393,5442]},{"content":"The scaled-by-16 stack offset is recorded in the next slot.","pos":[5443,5502]},{"content":"UWOP_SAVE_XMM128_FAR (9)3 nodes","pos":[5509,5540]},{"content":"Save all 128 bits of a nonvolatile XMM register on the stack with a long offset.","pos":[5547,5627]},{"content":"The operation info is the number of the register.","pos":[5628,5677]},{"content":"The unscaled stack offset is recorded in the next two slots.","pos":[5678,5738]},{"content":"UWOP_PUSH_MACHFRAME (10)1 node","pos":[5745,5775]},{"content":"Push a machine frame.","pos":[5782,5803]},{"content":"This is used to record the effect of a hardware interrupt or exception.","pos":[5805,5876]},{"content":"There are two forms.","pos":[5877,5897]},{"content":"If the operation info equals 0, the following has been pushed on the stack:","pos":[5898,5973]},{"content":"RSP+32","pos":[5994,6000]},{"content":"SS","pos":[6001,6003]},{"content":"RSP+24","pos":[6008,6014]},{"content":"Old RSP","pos":[6015,6022]},{"content":"RSP+16","pos":[6027,6033]},{"content":"EFLAGS","pos":[6034,6040]},{"content":"RSP+8","pos":[6045,6050]},{"content":"CS","pos":[6051,6053]},{"content":"RSP","pos":[6058,6061]},{"content":"RIP","pos":[6062,6065]},{"content":"If the operation info equals 1, then the following has instead been pushed:","pos":[6073,6148]},{"content":"RSP+40","pos":[6169,6175]},{"content":"SS","pos":[6176,6178]},{"content":"RSP+32","pos":[6183,6189]},{"content":"Old RSP","pos":[6190,6197]},{"content":"RSP+24","pos":[6202,6208]},{"content":"EFLAGS","pos":[6209,6215]},{"content":"RSP+16","pos":[6220,6226]},{"content":"CS","pos":[6227,6229]},{"content":"RSP+8","pos":[6234,6239]},{"content":"RIP","pos":[6240,6243]},{"content":"RSP","pos":[6248,6251]},{"content":"Error code","pos":[6252,6262]},{"content":"This unwind code will always appear in a dummy prolog, which is never actually executed but instead appears before the real entry point of an interrupt routine, and exists only to provide a place to simulate the push of a machine frame.","pos":[6270,6506]},{"content":"UWOP_PUSH_MACHFRAME records that simulation, which indicates the machine has conceptually done the following:","pos":[6507,6616]},{"pos":[6623,6675],"content":"Pop RIP return address from top of stack into <bpt id=\"p1\">*</bpt>Temp<ept id=\"p1\">*</ept>","source":"Pop RIP return address from top of stack into *Temp*"},{"content":"Push SS","pos":[6682,6689]},{"content":"Push old RSP","pos":[6696,6708]},{"content":"Push EFLAGS","pos":[6715,6726]},{"content":"Push CS","pos":[6733,6740]},{"pos":[6747,6758],"content":"Push <bpt id=\"p1\">*</bpt>Temp<ept id=\"p1\">*</ept>","source":"Push *Temp*"},{"content":"Push Error Code (if op info equals 1)","pos":[6765,6802]},{"content":"The simulated UWOP_PUSH_MACHFRAME operation decrements RSP by 40 (op info equals 0) or 48 (op info equals 1).","pos":[6809,6918]},{"content":"Operation info","pos":[6927,6941]},{"content":"The meaning of these 4 bits depends upon the operation code.","pos":[6947,7007]},{"content":"To encode a general-purpose (integer) register, the following mapping is used:","pos":[7008,7086]},{"content":"0","pos":[7107,7108]},{"content":"RAX","pos":[7109,7112]},{"content":"1","pos":[7117,7118]},{"content":"RCX","pos":[7119,7122]},{"content":"2","pos":[7127,7128]},{"content":"RDX","pos":[7129,7132]},{"content":"3","pos":[7137,7138]},{"content":"RBX","pos":[7139,7142]},{"content":"4","pos":[7147,7148]},{"content":"RSP","pos":[7149,7152]},{"content":"5","pos":[7157,7158]},{"content":"RBP","pos":[7159,7162]},{"content":"6","pos":[7167,7168]},{"content":"RSI","pos":[7169,7172]},{"content":"7","pos":[7177,7178]},{"content":"RDI","pos":[7179,7182]},{"content":"8 to 15","pos":[7187,7194]},{"content":"R8 to R15","pos":[7195,7204]},{"content":"See Also","pos":[7214,7222]},{"content":"Unwind Data for Exception Handling, Debugger Support","pos":[7227,7279]}],"content":"---\ntitle: \"struct UNWIND_CODE | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 104955d8-7e33-4c5a-b0c6-3254648f0af3\ncaps.latest.revision: 8\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# struct UNWIND_CODE\nThe unwind code array is used to record the sequence of operations in the prolog that affect the nonvolatile registers and RSP. Each code item has the following format:  \n  \n|||  \n|-|-|  \n|UBYTE|Offset in prolog|  \n|UBYTE: 4|Unwind operation code|  \n|UBYTE: 4|Operation info|  \n  \n The array is sorted by descending order of offset in the prolog.  \n  \n **Offset in prolog**  \n Offset from the beginning of the prolog of the end of the instruction that performs this operation, plus 1 (that is, the offset of the start of the next instruction).  \n  \n **Unwind operation code**  \n Note: Certain operation codes require an unsigned offset to a value in the local stack frame. This offset is from the start (lowest address) of the fixed stack allocation. If the Frame Register field in the UNWIND_INFO is zero, this offset is from RSP. If the Frame Register field is nonzero, this is the offset from where RSP was located when the FP reg was established. This equals the FP reg minus the FP reg offset (16 * the scaled frame register offset in the UNWIND_INFO). If an FP reg is used, then any unwind code taking an offset must only be used after the FP reg is established in the prolog.  \n  \n For all opcodes except UWOP_SAVE_XMM128 and UWOP_SAVE_XMM128_FAR, the offset will always be a multiple of 8, because all stack values of interest are stored on 8 byte boundaries (the stack itself is always 16-byte aligned). For operation codes that take a short offset (less than 512K), the final USHORT in the nodes for this code holds the offset divided by 8. For operation codes that take a long offset (512K <= offset < 4GB), the final two USHORT nodes for this code hold the offset (in little-endian format).  \n  \n For the opcodes UWOP_SAVE_XMM128 and UWOP_SAVE_XMM128_FAR, the offset will always be a multiple of 16, since all 128-bit XMM operations must occur on 16-byte aligned memory. Therefore, a scale factor of 16 is used for UWOP_SAVE_XMM128, permitting offsets of less than 1M.  \n  \n The unwind operation code is one of the following:  \n  \n UWOP_PUSH_NONVOL (0)1 node  \n  \n Push a nonvolatile integer register, decrementing RSP by 8. The operation info is the number of the register. Note that, because of the constraints on epilogs, UWOP_PUSH_NONVOL unwind codes must appear first in the prolog and correspondingly, last in the unwind code array. This relative ordering applies to all other unwind codes except UWOP_PUSH_MACHFRAME.  \n  \n UWOP_ALLOC_LARGE (1)2 or 3 nodes  \n  \n Allocate a large-sized area on the stack. There are two forms. If the operation info equals 0, then the size of the allocation divided by 8 is recorded in the next slot, allowing an allocation up to 512K – 8. If the operation info equals 1, then the unscaled size of the allocation is recorded in the next two slots in little-endian format, allowing allocations up to 4GB – 8.  \n  \n UWOP_ALLOC_SMALL (2)1 node  \n  \n Allocate a small-sized area on the stack. The size of the allocation is the operation info field * 8 + 8, allowing allocations from 8 to 128 bytes.  \n  \n The unwind code for a stack allocation should always use the shortest possible encoding:  \n  \n|||  \n|-|-|  \n|**Allocation Size**|**Unwind Code**|  \n|8 to 128 bytes|UWOP_ALLOC_SMALL|  \n|136 to 512K-8 bytes|UWOP_ALLOC_LARGE, operation info = 0|  \n|512K to 4G–8 bytes|UWOP_ALLOC_LARGE, operation info = 1|  \n  \n UWOP_SET_FPREG (3)1 node  \n  \n Establish the frame pointer register by setting the register to some offset of the current RSP. The offset is equal to the Frame Register offset (scaled) field in the UNWIND_INFO * 16, allowing offsets from 0 to 240. The use of an offset permits establishing a frame pointer that points to the middle of the fixed stack allocation, helping code density by allowing more accesses to use short instruction forms. Note that the operation info field is reserved and should not be used.  \n  \n UWOP_SAVE_NONVOL (4)2 nodes  \n  \n Save a nonvolatile integer register on the stack using a MOV instead of a PUSH. This is primarily used for shrink-wrapping, where a nonvolatile register is saved to the stack in a position that was previously allocated. The operation info is the number of the register. The scaled-by-8 stack offset is recorded in the next unwind operation code slot, as described in the note above.  \n  \n UWOP_SAVE_NONVOL_FAR (5)3 nodes  \n  \n Save a nonvolatile integer register on the stack with a long offset, using a MOV instead of a PUSH. This is primarily used for shrink-wrapping, where a nonvolatile register is saved to the stack in a position that was previously allocated. The operation info is the number of the register. The unscaled stack offset is recorded in the next two unwind operation code slots, as described in the note above.  \n  \n UWOP_SAVE_XMM128 (8)2 nodes  \n  \n Save all 128 bits of a nonvolatile XMM register on the stack. The operation info is the number of the register. The scaled-by-16 stack offset is recorded in the next slot.  \n  \n UWOP_SAVE_XMM128_FAR (9)3 nodes  \n  \n Save all 128 bits of a nonvolatile XMM register on the stack with a long offset. The operation info is the number of the register. The unscaled stack offset is recorded in the next two slots.  \n  \n UWOP_PUSH_MACHFRAME (10)1 node  \n  \n Push a machine frame.  This is used to record the effect of a hardware interrupt or exception. There are two forms. If the operation info equals 0, the following has been pushed on the stack:  \n  \n|||  \n|-|-|  \n|RSP+32|SS|  \n|RSP+24|Old RSP|  \n|RSP+16|EFLAGS|  \n|RSP+8|CS|  \n|RSP|RIP|  \n  \n If the operation info equals 1, then the following has instead been pushed:  \n  \n|||  \n|-|-|  \n|RSP+40|SS|  \n|RSP+32|Old RSP|  \n|RSP+24|EFLAGS|  \n|RSP+16|CS|  \n|RSP+8|RIP|  \n|RSP|Error code|  \n  \n This unwind code will always appear in a dummy prolog, which is never actually executed but instead appears before the real entry point of an interrupt routine, and exists only to provide a place to simulate the push of a machine frame. UWOP_PUSH_MACHFRAME records that simulation, which indicates the machine has conceptually done the following:  \n  \n Pop RIP return address from top of stack into *Temp*  \n  \n Push SS  \n  \n Push old RSP  \n  \n Push EFLAGS  \n  \n Push CS  \n  \n Push *Temp*  \n  \n Push Error Code (if op info equals 1)  \n  \n The simulated UWOP_PUSH_MACHFRAME operation decrements RSP by 40 (op info equals 0) or 48 (op info equals 1).  \n  \n **Operation info**  \n The meaning of these 4 bits depends upon the operation code. To encode a general-purpose (integer) register, the following mapping is used:  \n  \n|||  \n|-|-|  \n|0|RAX|  \n|1|RCX|  \n|2|RDX|  \n|3|RBX|  \n|4|RSP|  \n|5|RBP|  \n|6|RSI|  \n|7|RDI|  \n|8 to 15|R8 to R15|  \n  \n## See Also  \n [Unwind Data for Exception Handling, Debugger Support](../build/unwind-data-for-exception-handling-debugger-support.md)"}