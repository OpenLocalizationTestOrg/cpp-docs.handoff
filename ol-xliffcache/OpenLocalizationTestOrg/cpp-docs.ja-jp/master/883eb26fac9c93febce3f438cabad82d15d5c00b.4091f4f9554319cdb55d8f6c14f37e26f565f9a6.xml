{"nodes":[{"pos":[12,48],"content":"CTypedPtrList Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CTypedPtrList Class | Microsoft Docs","pos":[0,36]}]},{"content":"CTypedPtrList Class","pos":[748,767]},{"pos":[768,831],"content":"Provides a type-safe \"wrapper\" for objects of class <ph id=\"ph1\">`CPtrList`</ph>.","source":"Provides a type-safe \"wrapper\" for objects of class `CPtrList`."},{"content":"Syntax","pos":[840,846]},{"content":"Parameters","pos":[955,965]},{"content":"Base class of the typed pointer list class; must be a pointer list class ( <ph id=\"ph1\">`CObList`</ph> or <ph id=\"ph2\">`CPtrList`</ph>).","pos":[985,1085],"source":" Base class of the typed pointer list class; must be a pointer list class ( `CObList` or `CPtrList`)."},{"content":"Type of the elements stored in the base-class list.","pos":[1102,1153]},{"content":"Members","pos":[1162,1169]},{"content":"Public Methods","pos":[1179,1193]},{"content":"Name","pos":[1200,1204]},{"content":"Description","pos":[1205,1216]},{"content":"CTypedPtrList::AddHead","pos":[1255,1277]},{"content":"Adds an element (or all the elements in another list) to the head of the list (makes a new head).","pos":[1304,1401]},{"content":"CTypedPtrList::AddTail","pos":[1407,1429]},{"content":"Adds an element (or all the elements in another list) to the tail of the list (makes a new tail).","pos":[1456,1553]},{"content":"CTypedPtrList::GetAt","pos":[1559,1579]},{"content":"Gets the element at a given position.","pos":[1604,1641]},{"content":"CTypedPtrList::GetHead","pos":[1647,1669]},{"content":"Returns the head element of the list (cannot be empty).","pos":[1696,1751]},{"content":"CTypedPtrList::GetNext","pos":[1757,1779]},{"content":"Gets the next element for iterating.","pos":[1806,1842]},{"content":"CTypedPtrList::GetPrev","pos":[1848,1870]},{"content":"Gets the previous element for iterating.","pos":[1897,1937]},{"content":"CTypedPtrList::GetTail","pos":[1943,1965]},{"content":"Returns the tail element of the list (cannot be empty).","pos":[1992,2047]},{"content":"CTypedPtrList::RemoveHead","pos":[2053,2078]},{"content":"Removes the element from the head of the list.","pos":[2108,2154]},{"content":"CTypedPtrList::RemoveTail","pos":[2160,2185]},{"content":"Removes the element from the tail of the list.","pos":[2215,2261]},{"content":"CTypedPtrList::SetAt","pos":[2267,2287]},{"content":"Sets the element at a given position.","pos":[2312,2349]},{"content":"Remarks","pos":[2359,2366]},{"pos":[2370,2525],"content":"When you use <ph id=\"ph1\">`CTypedPtrList`</ph> rather than <ph id=\"ph2\">`CObList`</ph> or <ph id=\"ph3\">`CPtrList`</ph>, the C++ type-checking facility helps eliminate errors caused by mismatched pointer types.","source":"When you use `CTypedPtrList` rather than `CObList` or `CPtrList`, the C++ type-checking facility helps eliminate errors caused by mismatched pointer types."},{"pos":[2532,2661],"content":"In addition, the <ph id=\"ph1\">`CTypedPtrList`</ph> wrapper performs much of the casting that would be required if you used <ph id=\"ph2\">`CObList`</ph> or <ph id=\"ph3\">`CPtrList`</ph>.","source":"In addition, the `CTypedPtrList` wrapper performs much of the casting that would be required if you used `CObList` or `CPtrList`."},{"pos":[2668,2800],"content":"Because all <ph id=\"ph1\">`CTypedPtrList`</ph> functions are inline, use of this template does not significantly affect the size or speed of your code.","source":"Because all `CTypedPtrList` functions are inline, use of this template does not significantly affect the size or speed of your code."},{"pos":[2807,2896],"content":"Lists derived from <ph id=\"ph1\">`CObList`</ph> can be serialized, but those derived from <ph id=\"ph2\">`CPtrList`</ph> cannot.","source":"Lists derived from `CObList` can be serialized, but those derived from `CPtrList` cannot."},{"pos":[2903,3042],"content":"When a <ph id=\"ph1\">`CTypedPtrList`</ph> object is deleted, or when its elements are removed, only the pointers are removed, not the entities they reference.","source":"When a `CTypedPtrList` object is deleted, or when its elements are removed, only the pointers are removed, not the entities they reference."},{"pos":[3049,3219],"content":"For more information on using <ph id=\"ph1\">`CTypedPtrList`</ph>, see the articles <bpt id=\"p1\">[</bpt>Collections<ept id=\"p1\">](../../mfc/collections.md)</ept> and <bpt id=\"p2\">[</bpt>Template-Based Classes<ept id=\"p2\">](../../mfc/template-based-classes.md)</ept>.","source":"For more information on using `CTypedPtrList`, see the articles [Collections](../../mfc/collections.md) and [Template-Based Classes](../../mfc/template-based-classes.md)."},{"content":"Example","pos":[3228,3235]},{"pos":[3239,3366],"content":"This example creates an instance of <ph id=\"ph1\">`CTypedPtrList`</ph>, adds one object, serializes the list to disk, and then deletes the object:","source":"This example creates an instance of `CTypedPtrList`, adds one object, serializes the list to disk, and then deletes the object:"},{"pos":[3384,3406],"content":"NVC_MFCCollections#110"},{"pos":[3479,3501],"content":"NVC_MFCCollections#111"},{"content":"Inheritance Hierarchy","pos":[3565,3586]},{"content":"Requirements","pos":[3656,3668]},{"pos":[3672,3694],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afxtempl.h","source":"**Header:** afxtempl.h"},{"pos":[3743,3765],"content":"CTypedPtrList::AddHead"},{"pos":[3769,3822],"content":"This member function calls <ph id=\"ph1\">`BASE_CLASS`</ph><bpt id=\"p1\">**</bpt>::AddHead<ept id=\"p1\">**</ept>.","source":"This member function calls `BASE_CLASS`**::AddHead**."},{"content":"Parameters","pos":[3952,3962]},{"content":"TYPE","pos":[3967,3971]},{"content":"Type of the elements stored in the base-class list.","pos":[3976,4027]},{"content":"The object pointer to be added to this list.","pos":[4050,4094]},{"content":"A <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> value is allowed.","pos":[4095,4123],"source":" A **NULL** value is allowed."},{"content":"Base class of the typed pointer list class; must be a pointer list class ( <bpt id=\"p1\">[</bpt>CObList<ept id=\"p1\">](../../mfc/reference/coblist-class.md)</ept> or <bpt id=\"p2\">[</bpt>CPtrList<ept id=\"p2\">](../../mfc/reference/cptrlist-class.md)</ept>).","pos":[4146,4323],"source":" Base class of the typed pointer list class; must be a pointer list class ( [CObList](../../mfc/reference/coblist-class.md) or [CPtrList](../../mfc/reference/cptrlist-class.md))."},{"content":"A pointer to another <bpt id=\"p1\">[</bpt>CTypedPtrList<ept id=\"p1\">](../../mfc/reference/ctypedptrlist-class.md)</ept> object.","pos":[4344,4432],"source":" A pointer to another [CTypedPtrList](../../mfc/reference/ctypedptrlist-class.md) object."},{"content":"The elements in <ph id=\"ph1\">`pNewList`</ph> will be added to this list.","pos":[4433,4487],"source":" The elements in `pNewList` will be added to this list."},{"content":"Return Value","pos":[4497,4509]},{"pos":[4513,4592],"content":"The first version returns the <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value of the newly inserted element.","source":"The first version returns the **POSITION** value of the newly inserted element."},{"content":"Remarks","pos":[4602,4609]},{"content":"The first version adds a new element before the head of the list.","pos":[4613,4678]},{"content":"The second version adds another list of elements before the head.","pos":[4679,4744]},{"pos":[4793,4815],"content":"CTypedPtrList::AddTail"},{"pos":[4819,4872],"content":"This member function calls <ph id=\"ph1\">`BASE_CLASS`</ph><bpt id=\"p1\">**</bpt>::AddTail<ept id=\"p1\">**</ept>.","source":"This member function calls `BASE_CLASS`**::AddTail**."},{"content":"Parameters","pos":[5002,5012]},{"content":"TYPE","pos":[5017,5021]},{"content":"Type of the elements stored in the base-class list.","pos":[5026,5077]},{"content":"The object pointer to be added to this list.","pos":[5100,5144]},{"content":"A <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept> value is allowed.","pos":[5145,5173],"source":" A **NULL** value is allowed."},{"content":"Base class of the typed pointer list class; must be a pointer list class ( <bpt id=\"p1\">[</bpt>CObList<ept id=\"p1\">](../../mfc/reference/coblist-class.md)</ept> or <bpt id=\"p2\">[</bpt>CPtrList<ept id=\"p2\">](../../mfc/reference/cptrlist-class.md)</ept>).","pos":[5196,5373],"source":" Base class of the typed pointer list class; must be a pointer list class ( [CObList](../../mfc/reference/coblist-class.md) or [CPtrList](../../mfc/reference/cptrlist-class.md))."},{"content":"A pointer to another <bpt id=\"p1\">[</bpt>CTypedPtrList<ept id=\"p1\">](../../mfc/reference/ctypedptrlist-class.md)</ept> object.","pos":[5394,5482],"source":" A pointer to another [CTypedPtrList](../../mfc/reference/ctypedptrlist-class.md) object."},{"content":"The elements in <ph id=\"ph1\">`pNewList`</ph> will be added to this list.","pos":[5483,5537],"source":" The elements in `pNewList` will be added to this list."},{"content":"Return Value","pos":[5547,5559]},{"pos":[5563,5642],"content":"The first version returns the <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value of the newly inserted element.","source":"The first version returns the **POSITION** value of the newly inserted element."},{"content":"Remarks","pos":[5652,5659]},{"content":"The first version adds a new element after the tail of the list.","pos":[5663,5727]},{"content":"The second version adds another list of elements after the tail of the list.","pos":[5728,5804]},{"pos":[5851,5871],"content":"CTypedPtrList::GetAt"},{"pos":[5875,5929],"content":"A variable of type <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> is a key for the list.","source":"A variable of type **POSITION** is a key for the list."},{"content":"Parameters","pos":[6029,6039]},{"content":"TYPE","pos":[6044,6048]},{"content":"Template parameter specifying the type of elements stored in the list.","pos":[6053,6123]},{"content":"position","pos":[6131,6139]},{"content":"A <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value returned by a previous <ph id=\"ph1\">`GetHeadPosition`</ph> or <bpt id=\"p2\">**</bpt>Find<ept id=\"p2\">**</ept> member function call.","pos":[6144,6239],"source":" A **POSITION** value returned by a previous `GetHeadPosition` or **Find** member function call."},{"content":"Return Value","pos":[6249,6261]},{"content":"If the list is accessed through a pointer to a <bpt id=\"p1\">**</bpt>const CTypedPtrList<ept id=\"p1\">**</ept>, then <ph id=\"ph1\">`GetAt`</ph> returns a pointer of the type specified by the template parameter <bpt id=\"p2\">*</bpt>TYPE<ept id=\"p2\">*</ept>.","pos":[6265,6423],"source":"If the list is accessed through a pointer to a **const CTypedPtrList**, then `GetAt` returns a pointer of the type specified by the template parameter *TYPE*."},{"content":"This allows the function to be used only on the right side of an assignment statement and thus protects the list from modification.","pos":[6424,6555]},{"content":"If the list is accessed directly or through a pointer to a <ph id=\"ph1\">`CTypedPtrList`</ph>, then <ph id=\"ph2\">`GetAt`</ph> returns a reference to a pointer of the type specified by the template parameter <bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept>.","pos":[6562,6739],"source":"If the list is accessed directly or through a pointer to a `CTypedPtrList`, then `GetAt` returns a reference to a pointer of the type specified by the template parameter *TYPE*."},{"content":"This allows the function to be used on either side of an assignment statement and thus allows the list entries to be modified.","pos":[6740,6866]},{"content":"Remarks","pos":[6876,6883]},{"content":"It is not the same as an index, and you cannot operate on a <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value yourself.","pos":[6887,6975],"source":"It is not the same as an index, and you cannot operate on a **POSITION** value yourself."},{"content":"retrieves the <ph id=\"ph1\">`CObject`</ph> pointer associated with a given position.","pos":[6984,7049],"source":" retrieves the `CObject` pointer associated with a given position."},{"content":"You must ensure that your <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value represents a valid position in the list.","pos":[7056,7141],"source":"You must ensure that your **POSITION** value represents a valid position in the list."},{"content":"If it is invalid, then the Debug version of the Microsoft Foundation Class Library asserts.","pos":[7142,7233]},{"pos":[7240,7291],"content":"This inline function calls <ph id=\"ph1\">`BASE_CLASS`</ph><bpt id=\"p1\">**</bpt>::GetAt<ept id=\"p1\">**</ept>.","source":"This inline function calls `BASE_CLASS`**::GetAt**."},{"pos":[7340,7362],"content":"CTypedPtrList::GetHead"},{"content":"Gets the pointer that represents the head element of this list.","pos":[7366,7429]},{"content":"Parameters","pos":[7499,7509]},{"content":"TYPE","pos":[7514,7518]},{"content":"Template parameter specifying the type of elements stored in the list.","pos":[7523,7593]},{"content":"Return Value","pos":[7603,7615]},{"content":"If the list is accessed through a pointer to a <bpt id=\"p1\">**</bpt>const CTypedPtrList<ept id=\"p1\">**</ept>, then <ph id=\"ph1\">`GetHead`</ph> returns a pointer of the type specified by the template parameter <bpt id=\"p2\">*</bpt>TYPE<ept id=\"p2\">*</ept>.","pos":[7619,7779],"source":"If the list is accessed through a pointer to a **const CTypedPtrList**, then `GetHead` returns a pointer of the type specified by the template parameter *TYPE*."},{"content":"This allows the function to be used only on the right side of an assignment statement and thus protects the list from modification.","pos":[7780,7911]},{"content":"If the list is accessed directly or through a pointer to a <ph id=\"ph1\">`CTypedPtrList`</ph>, then <ph id=\"ph2\">`GetHead`</ph> returns a reference to a pointer of the type specified by the template parameter <bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept>.","pos":[7918,8097],"source":"If the list is accessed directly or through a pointer to a `CTypedPtrList`, then `GetHead` returns a reference to a pointer of the type specified by the template parameter *TYPE*."},{"content":"This allows the function to be used on either side of an assignment statement and thus allows the list entries to be modified.","pos":[8098,8224]},{"content":"Remarks","pos":[8234,8241]},{"content":"You must ensure that the list is not empty before calling <ph id=\"ph1\">`GetHead`</ph>.","pos":[8245,8313],"source":"You must ensure that the list is not empty before calling `GetHead`."},{"content":"If the list is empty, then the Debug version of the Microsoft Foundation Class Library asserts.","pos":[8314,8409]},{"content":"Use <bpt id=\"p1\">[</bpt>IsEmpty<ept id=\"p1\">](../../mfc/reference/coblist-class.md#coblist__isempty)</ept> to verify that the list contains elements.","pos":[8410,8521],"source":" Use [IsEmpty](../../mfc/reference/coblist-class.md#coblist__isempty) to verify that the list contains elements."},{"pos":[8570,8592],"content":"CTypedPtrList::GetNext"},{"pos":[8596,8723],"content":"Gets the list element identified by <ph id=\"ph1\">`rPosition`</ph>, then sets <ph id=\"ph2\">`rPosition`</ph> to the <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value of the next entry in the list.","source":"Gets the list element identified by `rPosition`, then sets `rPosition` to the **POSITION** value of the next entry in the list."},{"content":"Parameters","pos":[8831,8841]},{"content":"TYPE","pos":[8846,8850]},{"content":"Template parameter specifying the type of elements contained in this list.","pos":[8855,8929]},{"content":"A reference to a <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value returned by a previous <ph id=\"ph1\">`GetNext`</ph>, <ph id=\"ph2\">`GetHeadPosition`</ph>, or other member function call.","pos":[8951,9070],"source":" A reference to a **POSITION** value returned by a previous `GetNext`, `GetHeadPosition`, or other member function call."},{"content":"Return Value","pos":[9080,9092]},{"content":"If the list is accessed through a pointer to a <bpt id=\"p1\">**</bpt>const CTypedPtrList<ept id=\"p1\">**</ept>, then <ph id=\"ph1\">`GetNext`</ph> returns a pointer of the type specified by the template parameter <bpt id=\"p2\">*</bpt>TYPE<ept id=\"p2\">*</ept>.","pos":[9096,9256],"source":"If the list is accessed through a pointer to a **const CTypedPtrList**, then `GetNext` returns a pointer of the type specified by the template parameter *TYPE*."},{"content":"This allows the function to be used only on the right side of an assignment statement and thus protects the list from modification.","pos":[9257,9388]},{"content":"If the list is accessed directly or through a pointer to a <ph id=\"ph1\">`CTypedPtrList`</ph>, then <ph id=\"ph2\">`GetNext`</ph> returns a reference to a pointer of the type specified by the template parameter <bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept>.","pos":[9395,9574],"source":"If the list is accessed directly or through a pointer to a `CTypedPtrList`, then `GetNext` returns a reference to a pointer of the type specified by the template parameter *TYPE*."},{"content":"This allows the function to be used on either side of an assignment statement and thus allows the list entries to be modified.","pos":[9575,9701]},{"content":"Remarks","pos":[9711,9718]},{"pos":[9722,9915],"content":"You can use <ph id=\"ph1\">`GetNext`</ph> in a forward iteration loop if you establish the initial position with a call to <ph id=\"ph2\">`GetHeadPosition`</ph> or <bpt id=\"p1\">[</bpt>CPtrList::Find<ept id=\"p1\">](../../mfc/reference/coblist-class.md#coblist__find)</ept>.","source":"You can use `GetNext` in a forward iteration loop if you establish the initial position with a call to `GetHeadPosition` or [CPtrList::Find](../../mfc/reference/coblist-class.md#coblist__find)."},{"content":"You must ensure that your <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value represents a valid position in the list.","pos":[9922,10007],"source":"You must ensure that your **POSITION** value represents a valid position in the list."},{"content":"If it is invalid, then the Debug version of the Microsoft Foundation Class Library asserts.","pos":[10008,10099]},{"pos":[10106,10209],"content":"If the retrieved element is the last in the list, then the new value of <ph id=\"ph1\">`rPosition`</ph> is set to <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"If the retrieved element is the last in the list, then the new value of `rPosition` is set to **NULL**."},{"content":"It is possible to remove an element during an iteration.","pos":[10216,10272]},{"content":"See the example for <bpt id=\"p1\">[</bpt>CObList::RemoveAt<ept id=\"p1\">](../../mfc/reference/coblist-class.md#coblist__removeat)</ept>.","pos":[10273,10369],"source":" See the example for [CObList::RemoveAt](../../mfc/reference/coblist-class.md#coblist__removeat)."},{"pos":[10418,10440],"content":"CTypedPtrList::GetPrev"},{"pos":[10444,10575],"content":"Gets the list element identified by <ph id=\"ph1\">`rPosition`</ph>, then sets <ph id=\"ph2\">`rPosition`</ph> to the <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value of the previous entry in the list.","source":"Gets the list element identified by `rPosition`, then sets `rPosition` to the **POSITION** value of the previous entry in the list."},{"content":"Parameters","pos":[10683,10693]},{"content":"TYPE","pos":[10698,10702]},{"content":"Template parameter specifying the type of elements contained in this list.","pos":[10707,10781]},{"content":"A reference to a <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value returned by a previous <ph id=\"ph1\">`GetPrev`</ph> or other member function call.","pos":[10803,10902],"source":" A reference to a **POSITION** value returned by a previous `GetPrev` or other member function call."},{"content":"Return Value","pos":[10912,10924]},{"content":"If the list is accessed through a pointer to a <bpt id=\"p1\">**</bpt>const CTypedPtrList<ept id=\"p1\">**</ept>, then <ph id=\"ph1\">`GetPrev`</ph> returns a pointer of the type specified by the template parameter <bpt id=\"p2\">*</bpt>TYPE<ept id=\"p2\">*</ept>.","pos":[10928,11088],"source":"If the list is accessed through a pointer to a **const CTypedPtrList**, then `GetPrev` returns a pointer of the type specified by the template parameter *TYPE*."},{"content":"This allows the function to be used only on the right side of an assignment statement and thus protects the list from modification.","pos":[11089,11220]},{"content":"If the list is accessed directly or through a pointer to a <ph id=\"ph1\">`CTypedPtrList`</ph>, then <ph id=\"ph2\">`GetPrev`</ph> returns a reference to a pointer of the type specified by the template parameter <bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept>.","pos":[11227,11406],"source":"If the list is accessed directly or through a pointer to a `CTypedPtrList`, then `GetPrev` returns a reference to a pointer of the type specified by the template parameter *TYPE*."},{"content":"This allows the function to be used on either side of an assignment statement and thus allows the list entries to be modified.","pos":[11407,11533]},{"content":"Remarks","pos":[11543,11550]},{"pos":[11554,11687],"content":"You can use <ph id=\"ph1\">`GetPrev`</ph> in a reverse iteration loop if you establish the initial position with a call to <ph id=\"ph2\">`GetTailPosition`</ph> or <bpt id=\"p1\">**</bpt>Find<ept id=\"p1\">**</ept>.","source":"You can use `GetPrev` in a reverse iteration loop if you establish the initial position with a call to `GetTailPosition` or **Find**."},{"content":"You must ensure that your <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value represents a valid position in the list.","pos":[11694,11779],"source":"You must ensure that your **POSITION** value represents a valid position in the list."},{"content":"If it is invalid, then the Debug version of the Microsoft Foundation Class Library asserts.","pos":[11780,11871]},{"pos":[11878,11982],"content":"If the retrieved element is the first in the list, then the new value of <ph id=\"ph1\">`rPosition`</ph> is set to <bpt id=\"p1\">**</bpt>NULL<ept id=\"p1\">**</ept>.","source":"If the retrieved element is the first in the list, then the new value of `rPosition` is set to **NULL**."},{"pos":[12031,12053],"content":"CTypedPtrList::GetTail"},{"content":"Gets the pointer that represents the head element of this list.","pos":[12057,12120]},{"content":"Parameters","pos":[12190,12200]},{"content":"TYPE","pos":[12205,12209]},{"content":"Template parameter specifying the type of elements stored in the list.","pos":[12214,12284]},{"content":"Return Value","pos":[12294,12306]},{"content":"If the list is accessed through a pointer to a <bpt id=\"p1\">**</bpt>const CTypedPtrList<ept id=\"p1\">**</ept>, then <ph id=\"ph1\">`GetTail`</ph> returns a pointer of the type specified by the template parameter <bpt id=\"p2\">*</bpt>TYPE<ept id=\"p2\">*</ept>.","pos":[12310,12470],"source":"If the list is accessed through a pointer to a **const CTypedPtrList**, then `GetTail` returns a pointer of the type specified by the template parameter *TYPE*."},{"content":"This allows the function to be used only on the right side of an assignment statement and thus protects the list from modification.","pos":[12471,12602]},{"content":"If the list is accessed directly or through a pointer to a <ph id=\"ph1\">`CTypedPtrList`</ph>, then <ph id=\"ph2\">`GetTail`</ph> returns a reference to a pointer of the type specified by the template parameter <bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept>.","pos":[12609,12788],"source":"If the list is accessed directly or through a pointer to a `CTypedPtrList`, then `GetTail` returns a reference to a pointer of the type specified by the template parameter *TYPE*."},{"content":"This allows the function to be used on either side of an assignment statement and thus allows the list entries to be modified.","pos":[12789,12915]},{"content":"Remarks","pos":[12925,12932]},{"content":"You must ensure that the list is not empty before calling <ph id=\"ph1\">`GetTail`</ph>.","pos":[12936,13004],"source":"You must ensure that the list is not empty before calling `GetTail`."},{"content":"If the list is empty, then the Debug version of the Microsoft Foundation Class Library asserts.","pos":[13005,13100]},{"content":"Use <bpt id=\"p1\">[</bpt>IsEmpty<ept id=\"p1\">](../../mfc/reference/coblist-class.md#coblist__isempty)</ept> to verify that the list contains elements.","pos":[13101,13212],"source":" Use [IsEmpty](../../mfc/reference/coblist-class.md#coblist__isempty) to verify that the list contains elements."},{"pos":[13264,13289],"content":"CTypedPtrList::RemoveHead"},{"content":"Removes the element from the head of the list and returns it.","pos":[13293,13354]},{"content":"Parameters","pos":[13398,13408]},{"content":"TYPE","pos":[13413,13417]},{"content":"Template parameter specifying the type of elements stored in the list.","pos":[13422,13492]},{"content":"Return Value","pos":[13502,13514]},{"content":"The pointer previously at the head of the list.","pos":[13518,13565]},{"content":"This pointer is of the type specified by the template parameter <bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept>.","pos":[13566,13637],"source":" This pointer is of the type specified by the template parameter *TYPE*."},{"content":"Remarks","pos":[13647,13654]},{"content":"You must ensure that the list is not empty before calling <ph id=\"ph1\">`RemoveHead`</ph>.","pos":[13658,13729],"source":"You must ensure that the list is not empty before calling `RemoveHead`."},{"content":"If the list is empty, then the Debug version of the Microsoft Foundation Class Library asserts.","pos":[13730,13825]},{"content":"Use <bpt id=\"p1\">[</bpt>IsEmpty<ept id=\"p1\">](../../mfc/reference/coblist-class.md#coblist__isempty)</ept> to verify that the list contains elements.","pos":[13826,13937],"source":" Use [IsEmpty](../../mfc/reference/coblist-class.md#coblist__isempty) to verify that the list contains elements."},{"pos":[13989,14014],"content":"CTypedPtrList::RemoveTail"},{"content":"Removes the element from the tail of the list and returns it.","pos":[14018,14079]},{"content":"Parameters","pos":[14123,14133]},{"content":"TYPE","pos":[14138,14142]},{"content":"Template parameter specifying the type of elements stored in the list.","pos":[14147,14217]},{"content":"Return Value","pos":[14227,14239]},{"content":"The pointer previously at the tail of the list.","pos":[14243,14290]},{"content":"This pointer is of the type specified by the template parameter <bpt id=\"p1\">*</bpt>TYPE<ept id=\"p1\">*</ept>.","pos":[14291,14362],"source":" This pointer is of the type specified by the template parameter *TYPE*."},{"content":"Remarks","pos":[14372,14379]},{"content":"You must ensure that the list is not empty before calling <ph id=\"ph1\">`RemoveTail`</ph>.","pos":[14383,14454],"source":"You must ensure that the list is not empty before calling `RemoveTail`."},{"content":"If the list is empty, then the Debug version of the Microsoft Foundation Class Library asserts.","pos":[14455,14550]},{"content":"Use <bpt id=\"p1\">[</bpt>IsEmpty<ept id=\"p1\">](../../mfc/reference/coblist-class.md#coblist__isempty)</ept> to verify that the list contains elements.","pos":[14551,14662],"source":" Use [IsEmpty](../../mfc/reference/coblist-class.md#coblist__isempty) to verify that the list contains elements."},{"pos":[14709,14729],"content":"CTypedPtrList::SetAt"},{"pos":[14733,14784],"content":"This member function calls <ph id=\"ph1\">`BASE_CLASS`</ph><bpt id=\"p1\">**</bpt>::SetAt<ept id=\"p1\">**</ept>.","source":"This member function calls `BASE_CLASS`**::SetAt**."},{"content":"Parameters","pos":[14857,14867]},{"content":"The <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> of the element to be set.","pos":[14880,14922],"source":" The **POSITION** of the element to be set."},{"content":"TYPE","pos":[14930,14934]},{"content":"Type of the elements stored in the base-class list.","pos":[14939,14990]},{"content":"The object pointer to be written to the list.","pos":[15013,15058]},{"content":"Remarks","pos":[15068,15075]},{"content":"A variable of type <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> is a key for the list.","pos":[15079,15133],"source":"A variable of type **POSITION** is a key for the list."},{"content":"It is not the same as an index, and you cannot operate on a <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value yourself.","pos":[15134,15222],"source":" It is not the same as an index, and you cannot operate on a **POSITION** value yourself."},{"content":"writes the object pointer to the specified position in the list.","pos":[15231,15295]},{"content":"You must ensure that your <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> value represents a valid position in the list.","pos":[15302,15387],"source":"You must ensure that your **POSITION** value represents a valid position in the list."},{"content":"If it is invalid, then the Debug version of the Microsoft Foundation Class Library asserts.","pos":[15388,15479]},{"pos":[15486,15587],"content":"For more detailed remarks, see <bpt id=\"p1\">[</bpt>CObList::SetAt<ept id=\"p1\">](../../mfc/reference/coblist-class.md#coblist__setat)</ept>.","source":"For more detailed remarks, see [CObList::SetAt](../../mfc/reference/coblist-class.md#coblist__setat)."},{"content":"See Also","pos":[15596,15604]},{"content":"MFC Sample COLLECT","pos":[15609,15627]},{"content":"Hierarchy Chart","pos":[15663,15678]},{"content":"CPtrList Class","pos":[15715,15729]},{"content":"CObList Class","pos":[15775,15788]}],"content":"---\ntitle: \"CTypedPtrList Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CTypedPtrList\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CTypedPtrList class\"\n  - \"type-safe collections\"\n  - \"lists [C++]\"\n  - \"template classes, CTypedPtrList class\"\n  - \"linked lists [C++]\"\n  - \"pointer lists\"\nms.assetid: c273096e-1756-4340-864b-4a08b674a65e\ncaps.latest.revision: 24\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CTypedPtrList Class\nProvides a type-safe \"wrapper\" for objects of class `CPtrList`.  \n  \n## Syntax  \n  \n```  \ntemplate<class BASE_CLASS, class TYPE>  \nclass CTypedPtrList : public BASE_CLASS  \n```  \n  \n#### Parameters  \n `BASE_CLASS`  \n Base class of the typed pointer list class; must be a pointer list class ( `CObList` or `CPtrList`).  \n  \n `TYPE`  \n Type of the elements stored in the base-class list.  \n  \n## Members  \n  \n### Public Methods  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CTypedPtrList::AddHead](#ctypedptrlist__addhead)|Adds an element (or all the elements in another list) to the head of the list (makes a new head).|  \n|[CTypedPtrList::AddTail](#ctypedptrlist__addtail)|Adds an element (or all the elements in another list) to the tail of the list (makes a new tail).|  \n|[CTypedPtrList::GetAt](#ctypedptrlist__getat)|Gets the element at a given position.|  \n|[CTypedPtrList::GetHead](#ctypedptrlist__gethead)|Returns the head element of the list (cannot be empty).|  \n|[CTypedPtrList::GetNext](#ctypedptrlist__getnext)|Gets the next element for iterating.|  \n|[CTypedPtrList::GetPrev](#ctypedptrlist__getprev)|Gets the previous element for iterating.|  \n|[CTypedPtrList::GetTail](#ctypedptrlist__gettail)|Returns the tail element of the list (cannot be empty).|  \n|[CTypedPtrList::RemoveHead](#ctypedptrlist__removehead)|Removes the element from the head of the list.|  \n|[CTypedPtrList::RemoveTail](#ctypedptrlist__removetail)|Removes the element from the tail of the list.|  \n|[CTypedPtrList::SetAt](#ctypedptrlist__setat)|Sets the element at a given position.|  \n  \n## Remarks  \n When you use `CTypedPtrList` rather than `CObList` or `CPtrList`, the C++ type-checking facility helps eliminate errors caused by mismatched pointer types.  \n  \n In addition, the `CTypedPtrList` wrapper performs much of the casting that would be required if you used `CObList` or `CPtrList`.  \n  \n Because all `CTypedPtrList` functions are inline, use of this template does not significantly affect the size or speed of your code.  \n  \n Lists derived from `CObList` can be serialized, but those derived from `CPtrList` cannot.  \n  \n When a `CTypedPtrList` object is deleted, or when its elements are removed, only the pointers are removed, not the entities they reference.  \n  \n For more information on using `CTypedPtrList`, see the articles [Collections](../../mfc/collections.md) and [Template-Based Classes](../../mfc/template-based-classes.md).  \n  \n## Example  \n This example creates an instance of `CTypedPtrList`, adds one object, serializes the list to disk, and then deletes the object:  \n  \n [!code-cpp[NVC_MFCCollections#110](../../mfc/codesnippet/cpp/ctypedptrlist-class_1.cpp)]  \n  \n [!code-cpp[NVC_MFCCollections#111](../../mfc/codesnippet/cpp/ctypedptrlist-class_2.cpp)]  \n  \n## Inheritance Hierarchy  \n `BASE_CLASS`  \n  \n `_CTypedPtrList`  \n  \n `CTypedPtrList`  \n  \n## Requirements  \n **Header:** afxtempl.h  \n  \n##  <a name=\"ctypedptrlist__addhead\"></a>  CTypedPtrList::AddHead  \n This member function calls `BASE_CLASS`**::AddHead**.  \n  \n```  \nPOSITION AddHead(\n    TYPE newElement);\n\n \nvoid AddHead(\n    CTypedPtrList<BASE_CLASS, TYPE>* pNewList);\n```  \n  \n### Parameters  \n *TYPE*  \n Type of the elements stored in the base-class list.  \n  \n `newElement`  \n The object pointer to be added to this list. A **NULL** value is allowed.  \n  \n `BASE_CLASS`  \n Base class of the typed pointer list class; must be a pointer list class ( [CObList](../../mfc/reference/coblist-class.md) or [CPtrList](../../mfc/reference/cptrlist-class.md)).  \n  \n `pNewList`  \n A pointer to another [CTypedPtrList](../../mfc/reference/ctypedptrlist-class.md) object. The elements in `pNewList` will be added to this list.  \n  \n### Return Value  \n The first version returns the **POSITION** value of the newly inserted element.  \n  \n### Remarks  \n The first version adds a new element before the head of the list. The second version adds another list of elements before the head.  \n  \n##  <a name=\"ctypedptrlist__addtail\"></a>  CTypedPtrList::AddTail  \n This member function calls `BASE_CLASS`**::AddTail**.  \n  \n```  \nPOSITION AddTail(\n    TYPE newElement);\n\n \nvoid AddTail(\n    CTypedPtrList<BASE_CLASS, TYPE>* pNewList);\n```  \n  \n### Parameters  \n *TYPE*  \n Type of the elements stored in the base-class list.  \n  \n `newElement`  \n The object pointer to be added to this list. A **NULL** value is allowed.  \n  \n `BASE_CLASS`  \n Base class of the typed pointer list class; must be a pointer list class ( [CObList](../../mfc/reference/coblist-class.md) or [CPtrList](../../mfc/reference/cptrlist-class.md)).  \n  \n `pNewList`  \n A pointer to another [CTypedPtrList](../../mfc/reference/ctypedptrlist-class.md) object. The elements in `pNewList` will be added to this list.  \n  \n### Return Value  \n The first version returns the **POSITION** value of the newly inserted element.  \n  \n### Remarks  \n The first version adds a new element after the tail of the list. The second version adds another list of elements after the tail of the list.  \n  \n##  <a name=\"ctypedptrlist__getat\"></a>  CTypedPtrList::GetAt  \n A variable of type **POSITION** is a key for the list.  \n  \n```  \nTYPE& GetAt(POSITION position);\n\n \nTYPE GetAt(POSITION position) const;\n\n \n```  \n  \n### Parameters  \n *TYPE*  \n Template parameter specifying the type of elements stored in the list.  \n  \n *position*  \n A **POSITION** value returned by a previous `GetHeadPosition` or **Find** member function call.  \n  \n### Return Value  \n If the list is accessed through a pointer to a **const CTypedPtrList**, then `GetAt` returns a pointer of the type specified by the template parameter *TYPE*. This allows the function to be used only on the right side of an assignment statement and thus protects the list from modification.  \n  \n If the list is accessed directly or through a pointer to a `CTypedPtrList`, then `GetAt` returns a reference to a pointer of the type specified by the template parameter *TYPE*. This allows the function to be used on either side of an assignment statement and thus allows the list entries to be modified.  \n  \n### Remarks  \n It is not the same as an index, and you cannot operate on a **POSITION** value yourself. `GetAt` retrieves the `CObject` pointer associated with a given position.  \n  \n You must ensure that your **POSITION** value represents a valid position in the list. If it is invalid, then the Debug version of the Microsoft Foundation Class Library asserts.  \n  \n This inline function calls `BASE_CLASS`**::GetAt**.  \n  \n##  <a name=\"ctypedptrlist__gethead\"></a>  CTypedPtrList::GetHead  \n Gets the pointer that represents the head element of this list.  \n  \n```  \nTYPE& GetHead();\n\n \nTYPE GetHead() const;\n\n \n```  \n  \n### Parameters  \n *TYPE*  \n Template parameter specifying the type of elements stored in the list.  \n  \n### Return Value  \n If the list is accessed through a pointer to a **const CTypedPtrList**, then `GetHead` returns a pointer of the type specified by the template parameter *TYPE*. This allows the function to be used only on the right side of an assignment statement and thus protects the list from modification.  \n  \n If the list is accessed directly or through a pointer to a `CTypedPtrList`, then `GetHead` returns a reference to a pointer of the type specified by the template parameter *TYPE*. This allows the function to be used on either side of an assignment statement and thus allows the list entries to be modified.  \n  \n### Remarks  \n You must ensure that the list is not empty before calling `GetHead`. If the list is empty, then the Debug version of the Microsoft Foundation Class Library asserts. Use [IsEmpty](../../mfc/reference/coblist-class.md#coblist__isempty) to verify that the list contains elements.  \n  \n##  <a name=\"ctypedptrlist__getnext\"></a>  CTypedPtrList::GetNext  \n Gets the list element identified by `rPosition`, then sets `rPosition` to the **POSITION** value of the next entry in the list.  \n  \n```  \nTYPE& GetNext(POSITION& rPosition);\n\n \nTYPE GetNext(POSITION& rPosition) const;\n\n \n```  \n  \n### Parameters  \n *TYPE*  \n Template parameter specifying the type of elements contained in this list.  \n  \n `rPosition`  \n A reference to a **POSITION** value returned by a previous `GetNext`, `GetHeadPosition`, or other member function call.  \n  \n### Return Value  \n If the list is accessed through a pointer to a **const CTypedPtrList**, then `GetNext` returns a pointer of the type specified by the template parameter *TYPE*. This allows the function to be used only on the right side of an assignment statement and thus protects the list from modification.  \n  \n If the list is accessed directly or through a pointer to a `CTypedPtrList`, then `GetNext` returns a reference to a pointer of the type specified by the template parameter *TYPE*. This allows the function to be used on either side of an assignment statement and thus allows the list entries to be modified.  \n  \n### Remarks  \n You can use `GetNext` in a forward iteration loop if you establish the initial position with a call to `GetHeadPosition` or [CPtrList::Find](../../mfc/reference/coblist-class.md#coblist__find).  \n  \n You must ensure that your **POSITION** value represents a valid position in the list. If it is invalid, then the Debug version of the Microsoft Foundation Class Library asserts.  \n  \n If the retrieved element is the last in the list, then the new value of `rPosition` is set to **NULL**.  \n  \n It is possible to remove an element during an iteration. See the example for [CObList::RemoveAt](../../mfc/reference/coblist-class.md#coblist__removeat).  \n  \n##  <a name=\"ctypedptrlist__getprev\"></a>  CTypedPtrList::GetPrev  \n Gets the list element identified by `rPosition`, then sets `rPosition` to the **POSITION** value of the previous entry in the list.  \n  \n```  \nTYPE& GetPrev(POSITION& rPosition);\n\n \nTYPE GetPrev(POSITION& rPosition) const;\n\n \n```  \n  \n### Parameters  \n *TYPE*  \n Template parameter specifying the type of elements contained in this list.  \n  \n `rPosition`  \n A reference to a **POSITION** value returned by a previous `GetPrev` or other member function call.  \n  \n### Return Value  \n If the list is accessed through a pointer to a **const CTypedPtrList**, then `GetPrev` returns a pointer of the type specified by the template parameter *TYPE*. This allows the function to be used only on the right side of an assignment statement and thus protects the list from modification.  \n  \n If the list is accessed directly or through a pointer to a `CTypedPtrList`, then `GetPrev` returns a reference to a pointer of the type specified by the template parameter *TYPE*. This allows the function to be used on either side of an assignment statement and thus allows the list entries to be modified.  \n  \n### Remarks  \n You can use `GetPrev` in a reverse iteration loop if you establish the initial position with a call to `GetTailPosition` or **Find**.  \n  \n You must ensure that your **POSITION** value represents a valid position in the list. If it is invalid, then the Debug version of the Microsoft Foundation Class Library asserts.  \n  \n If the retrieved element is the first in the list, then the new value of `rPosition` is set to **NULL**.  \n  \n##  <a name=\"ctypedptrlist__gettail\"></a>  CTypedPtrList::GetTail  \n Gets the pointer that represents the head element of this list.  \n  \n```  \nTYPE& GetTail();\n\n \nTYPE GetTail() const;\n\n \n```  \n  \n### Parameters  \n *TYPE*  \n Template parameter specifying the type of elements stored in the list.  \n  \n### Return Value  \n If the list is accessed through a pointer to a **const CTypedPtrList**, then `GetTail` returns a pointer of the type specified by the template parameter *TYPE*. This allows the function to be used only on the right side of an assignment statement and thus protects the list from modification.  \n  \n If the list is accessed directly or through a pointer to a `CTypedPtrList`, then `GetTail` returns a reference to a pointer of the type specified by the template parameter *TYPE*. This allows the function to be used on either side of an assignment statement and thus allows the list entries to be modified.  \n  \n### Remarks  \n You must ensure that the list is not empty before calling `GetTail`. If the list is empty, then the Debug version of the Microsoft Foundation Class Library asserts. Use [IsEmpty](../../mfc/reference/coblist-class.md#coblist__isempty) to verify that the list contains elements.  \n  \n##  <a name=\"ctypedptrlist__removehead\"></a>  CTypedPtrList::RemoveHead  \n Removes the element from the head of the list and returns it.  \n  \n```  \nTYPE RemoveHead();\n```  \n  \n### Parameters  \n *TYPE*  \n Template parameter specifying the type of elements stored in the list.  \n  \n### Return Value  \n The pointer previously at the head of the list. This pointer is of the type specified by the template parameter *TYPE*.  \n  \n### Remarks  \n You must ensure that the list is not empty before calling `RemoveHead`. If the list is empty, then the Debug version of the Microsoft Foundation Class Library asserts. Use [IsEmpty](../../mfc/reference/coblist-class.md#coblist__isempty) to verify that the list contains elements.  \n  \n##  <a name=\"ctypedptrlist__removetail\"></a>  CTypedPtrList::RemoveTail  \n Removes the element from the tail of the list and returns it.  \n  \n```  \nTYPE RemoveTail();\n```  \n  \n### Parameters  \n *TYPE*  \n Template parameter specifying the type of elements stored in the list.  \n  \n### Return Value  \n The pointer previously at the tail of the list. This pointer is of the type specified by the template parameter *TYPE*.  \n  \n### Remarks  \n You must ensure that the list is not empty before calling `RemoveTail`. If the list is empty, then the Debug version of the Microsoft Foundation Class Library asserts. Use [IsEmpty](../../mfc/reference/coblist-class.md#coblist__isempty) to verify that the list contains elements.  \n  \n##  <a name=\"ctypedptrlist__setat\"></a>  CTypedPtrList::SetAt  \n This member function calls `BASE_CLASS`**::SetAt**.  \n  \n```  \nvoid SetAt(\n    POSITION pos, TYPE newElement);\n```  \n  \n### Parameters  \n `pos`  \n The **POSITION** of the element to be set.  \n  \n *TYPE*  \n Type of the elements stored in the base-class list.  \n  \n `newElement`  \n The object pointer to be written to the list.  \n  \n### Remarks  \n A variable of type **POSITION** is a key for the list. It is not the same as an index, and you cannot operate on a **POSITION** value yourself. `SetAt` writes the object pointer to the specified position in the list.  \n  \n You must ensure that your **POSITION** value represents a valid position in the list. If it is invalid, then the Debug version of the Microsoft Foundation Class Library asserts.  \n  \n For more detailed remarks, see [CObList::SetAt](../../mfc/reference/coblist-class.md#coblist__setat).  \n  \n## See Also  \n [MFC Sample COLLECT](../../visual-cpp-samples.md)   \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)   \n [CPtrList Class](../../mfc/reference/cptrlist-class.md)   \n [CObList Class](../../mfc/reference/coblist-class.md)\n"}