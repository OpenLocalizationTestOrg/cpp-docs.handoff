{"nodes":[{"pos":[12,53],"content":"SBCS and MBCS Data Types | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"SBCS and MBCS Data Types | Microsoft Docs","pos":[0,41]}]},{"content":"SBCS and MBCS Data Types","pos":[693,717]},{"content":"Any Microsoft <ph id=\"ph1\">`MBCS`</ph> run-time library routine that handles only one multibyte character or one byte of a multibyte character expects an <ph id=\"ph2\">`unsigned``int`</ph> argument (where 0x00 &lt;= character value &lt;= 0xFFFF and 0x00 &lt;= byte value &lt;= 0xFF ).","pos":[718,953],"source":"Any Microsoft `MBCS` run-time library routine that handles only one multibyte character or one byte of a multibyte character expects an `unsigned``int` argument (where 0x00 <= character value <= 0xFFFF and 0x00 <= byte value <= 0xFF )."},{"content":"An <ph id=\"ph1\">`MBCS`</ph> routine that handles multibyte bytes or characters in a string context expects a multibyte-character string to be represented as an <ph id=\"ph2\">`unsigned``char`</ph> pointer.","pos":[954,1121],"source":" An `MBCS` routine that handles multibyte bytes or characters in a string context expects a multibyte-character string to be represented as an `unsigned``char` pointer."},{"pos":[1129,1483],"content":"[!CAUTION]\n Each byte of a multibyte character can be represented in an 8-bit `char`. However, an `SBCS` or `MBCS` single-byte character of type `char` with a value greater than 0x7F is negative. When such a character is converted directly to an `int` or a `long`, the result is sign-extended by the compiler and can therefore yield unexpected results.","leadings":["","> "],"nodes":[{"content":" Each byte of a multibyte character can be represented in an 8-bit `char`. However, an `SBCS` or `MBCS` single-byte character of type `char` with a value greater than 0x7F is negative. When such a character is converted directly to an `int` or a `long`, the result is sign-extended by the compiler and can therefore yield unexpected results.","pos":[11,352],"nodes":[{"content":"Each byte of a multibyte character can be represented in an 8-bit <ph id=\"ph1\">`char`</ph>.","pos":[1,74],"source":" Each byte of a multibyte character can be represented in an 8-bit `char`."},{"content":"However, an <ph id=\"ph1\">`SBCS`</ph> or <ph id=\"ph2\">`MBCS`</ph> single-byte character of type <ph id=\"ph3\">`char`</ph> with a value greater than 0x7F is negative.","pos":[75,184],"source":" However, an `SBCS` or `MBCS` single-byte character of type `char` with a value greater than 0x7F is negative."},{"content":"When such a character is converted directly to an <ph id=\"ph1\">`int`</ph> or a <ph id=\"ph2\">`long`</ph>, the result is sign-extended by the compiler and can therefore yield unexpected results.","pos":[185,341],"source":" When such a character is converted directly to an `int` or a `long`, the result is sign-extended by the compiler and can therefore yield unexpected results."}]}]},{"content":"Therefore it is best to represent a byte of a multibyte character as an 8-bit <ph id=\"ph1\">`unsigned char`</ph>.","pos":[1490,1584],"source":"Therefore it is best to represent a byte of a multibyte character as an 8-bit `unsigned char`."},{"content":"Or, to avoid a negative result, simply convert a single-byte character of type <ph id=\"ph1\">`char`</ph> to an <ph id=\"ph2\">`unsigned char`</ph> before converting it to an <ph id=\"ph3\">`int`</ph> or a <ph id=\"ph4\">`long`</ph>.","pos":[1585,1738],"source":" Or, to avoid a negative result, simply convert a single-byte character of type `char` to an `unsigned char` before converting it to an `int` or a `long`."},{"content":"Because some <ph id=\"ph1\">`SBCS`</ph> string-handling functions take (signed) <ph id=\"ph2\">`char*`</ph> parameters, a type mismatch compiler warning will result when <ph id=\"ph3\">`_MBCS`</ph> is defined.","pos":[1745,1894],"source":"Because some `SBCS` string-handling functions take (signed) `char*` parameters, a type mismatch compiler warning will result when `_MBCS` is defined."},{"content":"There are three ways to avoid this warning, listed in order of efficiency:","pos":[1895,1969]},{"content":"Use the \"type-safe\" inline functions in TCHAR.H.","pos":[1979,2027]},{"content":"This is the default behavior.","pos":[2028,2057]},{"content":"Use the \"direct\" macros in TCHAR.H by defining <ph id=\"ph1\">`_MB_MAP_DIRECT`</ph> on the command line.","pos":[2067,2151],"source":"Use the \"direct\" macros in TCHAR.H by defining `_MB_MAP_DIRECT` on the command line."},{"content":"If you do this, you must manually match types.","pos":[2152,2198]},{"content":"This is the fastest method but is not type-safe.","pos":[2199,2247]},{"content":"Use the \"type-safe\" statically linked library functions in TCHAR.H.","pos":[2257,2324]},{"content":"To do so, define the constant <ph id=\"ph1\">`_NO_INLINING`</ph> on the command line.","pos":[2325,2390],"source":" To do so, define the constant `_NO_INLINING` on the command line."},{"content":"This is the slowest method, but the most type-safe.","pos":[2391,2442]},{"content":"See Also","pos":[2451,2459]},{"content":"Internationalization","pos":[2464,2484]},{"content":"Run-Time Routines by Category","pos":[2537,2566]}],"content":"---\ntitle: \"SBCS and MBCS Data Types | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"MBCS\"\n  - \"SBCS\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"SBCS and MBCS data types\"\n  - \"data types [C], MBCS and SBCS\"\nms.assetid: 4c3ef9da-e397-48d4-800e-49dba36db171\ncaps.latest.revision: 10\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# SBCS and MBCS Data Types\nAny Microsoft `MBCS` run-time library routine that handles only one multibyte character or one byte of a multibyte character expects an `unsigned``int` argument (where 0x00 <= character value <= 0xFFFF and 0x00 <= byte value <= 0xFF ). An `MBCS` routine that handles multibyte bytes or characters in a string context expects a multibyte-character string to be represented as an `unsigned``char` pointer.  \n  \n> [!CAUTION]\n>  Each byte of a multibyte character can be represented in an 8-bit `char`. However, an `SBCS` or `MBCS` single-byte character of type `char` with a value greater than 0x7F is negative. When such a character is converted directly to an `int` or a `long`, the result is sign-extended by the compiler and can therefore yield unexpected results.  \n  \n Therefore it is best to represent a byte of a multibyte character as an 8-bit `unsigned char`. Or, to avoid a negative result, simply convert a single-byte character of type `char` to an `unsigned char` before converting it to an `int` or a `long`.  \n  \n Because some `SBCS` string-handling functions take (signed) `char*` parameters, a type mismatch compiler warning will result when `_MBCS` is defined. There are three ways to avoid this warning, listed in order of efficiency:  \n  \n1.  Use the \"type-safe\" inline functions in TCHAR.H. This is the default behavior.  \n  \n2.  Use the \"direct\" macros in TCHAR.H by defining `_MB_MAP_DIRECT` on the command line. If you do this, you must manually match types. This is the fastest method but is not type-safe.  \n  \n3.  Use the \"type-safe\" statically linked library functions in TCHAR.H. To do so, define the constant `_NO_INLINING` on the command line. This is the slowest method, but the most type-safe.  \n  \n## See Also  \n [Internationalization](../c-runtime-library/internationalization.md)   \n [Run-Time Routines by Category](../c-runtime-library/run-time-routines-by-category.md)"}