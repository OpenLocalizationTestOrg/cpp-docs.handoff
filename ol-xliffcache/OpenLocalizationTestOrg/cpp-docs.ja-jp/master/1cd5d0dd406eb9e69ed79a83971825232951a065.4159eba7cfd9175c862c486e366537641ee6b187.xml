{"nodes":[{"pos":[12,74],"content":"How to: Marshal COM Strings Using C++ Interop | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Marshal COM Strings Using C++ Interop | Microsoft Docs","pos":[0,62]}]},{"content":"How to: Marshal COM Strings Using C++ Interop","pos":[750,795]},{"content":"This topic demonstrates how a BSTR (the basic string format favored in COM programming) can be passed from a managed to an unmanaged function, and vice versa.","pos":[796,954]},{"content":"For interoperating with other strings types, see the following topics:","pos":[955,1025]},{"content":"How to: Marshal Unicode Strings Using C++ Interop","pos":[1036,1085]},{"content":"How to: Marshal ANSI Strings Using C++ Interop","pos":[1160,1206]},{"content":"The following code examples use the <bpt id=\"p1\">[</bpt>managed, unmanaged<ept id=\"p1\">](../preprocessor/managed-unmanaged.md)</ept> #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files.","pos":[1274,1532],"source":"The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files."},{"content":"Files containing only unmanaged functions do not need to be compiled with <bpt id=\"p1\">[</bpt>/clr (Common Language Runtime Compilation)<ept id=\"p1\">](../build/reference/clr-common-language-runtime-compilation.md)</ept>.","pos":[1533,1715],"source":" Files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md)."},{"content":"Example","pos":[1724,1731]},{"content":"The following example demonstrates how a BSTR (a string format used in COM programming) can be passed from a managed to an unmanaged function.","pos":[1735,1877]},{"content":"The calling managed function uses &lt;xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A&gt; to obtain the address of a BSTR representation of the contents of a .NET System.String.","pos":[1878,2061],"source":" The calling managed function uses <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A> to obtain the address of a BSTR representation of the contents of a .NET System.String."},{"content":"This pointer is pinned using <bpt id=\"p1\">[</bpt>pin_ptr (C++/CLI)<ept id=\"p1\">](../windows/pin-ptr-cpp-cli.md)</ept> to ensure that its physical address is not changed during a garbage collection cycle while the unmanaged function executes.","pos":[2062,2265],"source":" This pointer is pinned using [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md) to ensure that its physical address is not changed during a garbage collection cycle while the unmanaged function executes."},{"content":"The garbage collector is prohibited from moving the memory until the <bpt id=\"p1\">[</bpt>pin_ptr (C++/CLI)<ept id=\"p1\">](../windows/pin-ptr-cpp-cli.md)</ept> goes out of scope.","pos":[2266,2404],"source":" The garbage collector is prohibited from moving the memory until the [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md) goes out of scope."},{"content":"Example","pos":[3024,3031]},{"content":"The following example demonstrates how a BSTR can be passed from an unmanaged to an unmanaged function.","pos":[3035,3138]},{"content":"The receiving managed function can either use the string in as a BSTR or use &lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A&gt; to convert it to a &lt;xref:System.String&gt; for use with other managed functions.","pos":[3139,3358],"source":" The receiving managed function can either use the string in as a BSTR or use <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A> to convert it to a <xref:System.String> for use with other managed functions."},{"content":"Because the memory representing the BSTR is allocated on the unmanaged heap, no pinning is necessary, because there is no garbage collection on the unmanaged heap.","pos":[3359,3522]},{"content":"See Also","pos":[4256,4264]},{"content":"Using C++ Interop (Implicit PInvoke)","pos":[4269,4305]}],"content":"---\ntitle: \"How to: Marshal COM Strings Using C++ Interop | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"get-started-article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"interop [C++], strings\"\n  - \"marshaling [C++], strings\"\n  - \"C++ Interop, strings\"\n  - \"data marshaling [C++], strings\"\n  - \"COM [C++], marshaling strings\"\nms.assetid: 06590759-bf99-4e34-a3a9-4527ea592cc2\ncaps.latest.revision: 15\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Marshal COM Strings Using C++ Interop\nThis topic demonstrates how a BSTR (the basic string format favored in COM programming) can be passed from a managed to an unmanaged function, and vice versa. For interoperating with other strings types, see the following topics:  \n  \n-   [How to: Marshal Unicode Strings Using C++ Interop](../dotnet/how-to-marshal-unicode-strings-using-cpp-interop.md)  \n  \n-   [How to: Marshal ANSI Strings Using C++ Interop](../dotnet/how-to-marshal-ansi-strings-using-cpp-interop.md)  \n  \n The following code examples use the [managed, unmanaged](../preprocessor/managed-unmanaged.md) #pragma directives to implement managed and unmanaged functions in the same file, but these functions interoperate in the same manner if defined in separate files. Files containing only unmanaged functions do not need to be compiled with [/clr (Common Language Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md).  \n  \n## Example  \n The following example demonstrates how a BSTR (a string format used in COM programming) can be passed from a managed to an unmanaged function. The calling managed function uses <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A> to obtain the address of a BSTR representation of the contents of a .NET System.String. This pointer is pinned using [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md) to ensure that its physical address is not changed during a garbage collection cycle while the unmanaged function executes. The garbage collector is prohibited from moving the memory until the [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md) goes out of scope.  \n  \n```  \n// MarshalBSTR1.cpp  \n// compile with: /clr  \n#define WINVER 0x0502  \n#define _AFXDLL  \n#include <afxwin.h>  \n  \n#include <iostream>  \nusing namespace std;  \n  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n#pragma unmanaged  \n  \nvoid NativeTakesAString(BSTR bstr) {  \n   printf_s(\"%S\", bstr);  \n}  \n  \n#pragma managed  \n  \nint main() {  \n   String^ s = \"test string\";  \n  \n   IntPtr ip = Marshal::StringToBSTR(s);  \n   BSTR bs = static_cast<BSTR>(ip.ToPointer());  \n   pin_ptr<BSTR> b = &bs;  \n  \n   NativeTakesAString( bs );  \n   Marshal::FreeBSTR(ip);  \n}  \n```  \n  \n## Example  \n The following example demonstrates how a BSTR can be passed from an unmanaged to an unmanaged function. The receiving managed function can either use the string in as a BSTR or use <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A> to convert it to a <xref:System.String> for use with other managed functions. Because the memory representing the BSTR is allocated on the unmanaged heap, no pinning is necessary, because there is no garbage collection on the unmanaged heap.  \n  \n```  \n// MarshalBSTR2.cpp  \n// compile with: /clr  \n#define WINVER 0x0502  \n#define _AFXDLL  \n#include <afxwin.h>  \n  \n#include <iostream>  \nusing namespace std;  \n  \nusing namespace System;  \nusing namespace System::Runtime::InteropServices;  \n  \n#pragma managed  \n  \nvoid ManagedTakesAString(BSTR bstr) {  \n   String^ s = Marshal::PtrToStringBSTR(static_cast<IntPtr>(bstr));  \n   Console::WriteLine(\"(managed) convered BSTR to String: '{0}'\", s);  \n}  \n  \n#pragma unmanaged  \n  \nvoid UnManagedFunc() {  \n   BSTR bs = SysAllocString(L\"test string\");  \n   printf_s(\"(unmanaged) passing BSTR to managed func...\\n\");  \n   ManagedTakesAString(bs);  \n}  \n  \n#pragma managed  \n  \nint main() {  \n   UnManagedFunc();  \n}  \n```  \n  \n## See Also  \n [Using C++ Interop (Implicit PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md)"}