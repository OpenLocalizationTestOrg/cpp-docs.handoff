{"nodes":[{"pos":[12,49],"content":"Compiler Error C2143 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Error C2143 | Microsoft Docs","pos":[0,37]}]},{"pos":[624,644],"content":"Compiler Error C2143","linkify":"Compiler Error C2143","nodes":[{"content":"Compiler Error C2143","pos":[0,20]}]},{"content":"syntax error : missing 'token1' before 'token2'","pos":[645,692]},{"content":"The compiler expected a specific token (that is, a language element other than white space) and found another token instead.","pos":[699,823]},{"pos":[830,995],"content":"For information about this error when it occurs when you are using a function-try block, see <bpt id=\"p1\">[</bpt>Knowledge Base article 241706<ept id=\"p1\">](http://support.microsoft.com/kb/241706)</ept>.","source":"For information about this error when it occurs when you are using a function-try block, see [Knowledge Base article 241706](http://support.microsoft.com/kb/241706)."},{"content":"Check the <bpt id=\"p1\">[</bpt>C++ Language Reference<ept id=\"p1\">](../../cpp/cpp-language-reference.md)</ept> to determine where code is syntactically incorrect.","pos":[1002,1125],"source":"Check the [C++ Language Reference](../../cpp/cpp-language-reference.md) to determine where code is syntactically incorrect."},{"content":"Because the compiler may report this error after it encounters the line that causes the problem, check several lines of code that precede the error.","pos":[1126,1274]},{"content":"C2143 can occur in different situations.","pos":[1281,1321]},{"pos":[1328,1467],"content":"It can occur when an operator that can qualify a name (<ph id=\"ph1\">`::`</ph>, <ph id=\"ph2\">`-&gt;`</ph>, and <ph id=\"ph3\">`.`</ph>) must be followed by the keyword <ph id=\"ph4\">`template`</ph>, as in this example:","source":"It can occur when an operator that can qualify a name (`::`, `->`, and `.`) must be followed by the keyword `template`, as in this example:"},{"content":"By default, C++ assumes that <ph id=\"ph1\">`Ty::PutFuncType`</ph> isn't a template; therefore, the following <ph id=\"ph2\">`&lt;`</ph> is interpreted as a less-than sign.","pos":[1656,1785],"source":"By default, C++ assumes that `Ty::PutFuncType` isn't a template; therefore, the following `<` is interpreted as a less-than sign."},{"content":"You must tell the compiler explicitly that <ph id=\"ph1\">`PutFuncType`</ph> is a template so that it can correctly parse the angle bracket.","pos":[1787,1907],"source":"  You must tell the compiler explicitly that `PutFuncType` is a template so that it can correctly parse the angle bracket."},{"content":"To correct this error, use the <ph id=\"ph1\">`template`</ph> keyword on the dependent type's name, as shown here:","pos":[1908,2002],"source":" To correct this error, use the `template` keyword on the dependent type's name, as shown here:"},{"pos":[2196,2277],"content":"C2143 can occur when <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> is used and a <ph id=\"ph1\">`using`</ph> directive has a syntax error:","source":"C2143 can occur when **/clr** is used and a `using` directive has a syntax error:"},{"pos":[2431,2547],"content":"It can also occur when you are trying to compile a source code file by using CLR syntax without also using <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>:","source":"It can also occur when you are trying to compile a source code file by using CLR syntax without also using **/clr**:"},{"content":"The first non-whitespace character that follows an <ph id=\"ph1\">`if`</ph> statement must be a left parenthesis.","pos":[2712,2805],"source":"The first non-whitespace character that follows an `if` statement must be a left parenthesis."},{"content":"The compiler cannot translate anything else:","pos":[2806,2850]},{"content":"C2143 can occur when a closing brace, parenthesis, or semicolon is missing on the line where the error is detected or on one of the lines just above:","pos":[2998,3147]},{"content":"Or when there's an invalid tag in a class declaration:","pos":[3276,3330]},{"content":"Or when a label is not attached to a statement.","pos":[3490,3537]},{"content":"If you must place a label by itself, for example, at the end of a compound statement, attach it to a null statement:","pos":[3538,3654]},{"content":"The error can occur when an unqualified call is made to a type in the Standard C++ Library:","pos":[3795,3886]},{"pos":[4054,4095],"content":"Or there is a missing <ph id=\"ph1\">`typename`</ph> keyword:","source":"Or there is a missing `typename` keyword:"},{"content":"Or if you try to define an explicit instantiation:","pos":[4395,4445]},{"content":"In a C program, variables must be declared at the beginning of the function, and they cannot be declared after the function executes non-declaration instructions.","pos":[4703,4865]}],"content":"---\ntitle: \"Compiler Error C2143 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C2143\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C2143\"\nms.assetid: 1d8d1456-e031-4965-9240-09a6e33ba81c\ncaps.latest.revision: 23\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Compiler Error C2143\nsyntax error : missing 'token1' before 'token2'  \n  \n The compiler expected a specific token (that is, a language element other than white space) and found another token instead.  \n  \n For information about this error when it occurs when you are using a function-try block, see [Knowledge Base article 241706](http://support.microsoft.com/kb/241706).  \n  \n Check the [C++ Language Reference](../../cpp/cpp-language-reference.md) to determine where code is syntactically incorrect. Because the compiler may report this error after it encounters the line that causes the problem, check several lines of code that precede the error.  \n  \n C2143 can occur in different situations.  \n  \n It can occur when an operator that can qualify a name (`::`, `->`, and `.`) must be followed by the keyword `template`, as in this example:  \n  \n```cpp  \nclass MyClass  \n{  \n    template<class Ty, typename PropTy>  \n    struct PutFuncType : public Ty::PutFuncType<Ty, PropTy> // error C2143  \n    {  \n    };  \n};  \n  \n```  \n  \n By default, C++ assumes that `Ty::PutFuncType` isn't a template; therefore, the following `<` is interpreted as a less-than sign.  You must tell the compiler explicitly that `PutFuncType` is a template so that it can correctly parse the angle bracket. To correct this error, use the `template` keyword on the dependent type's name, as shown here:  \n  \n```cpp  \nclass MyClass  \n{  \n    template<class Ty, typename PropTy>  \n    struct PutFuncType : public Ty::template PutFuncType<Ty, PropTy> // correct  \n    {  \n    };  \n};  \n  \n```  \n  \n C2143 can occur when **/clr** is used and a `using` directive has a syntax error:  \n  \n```cpp  \n// C2143a.cpp  \n// compile with: /clr /c  \nusing namespace System.Reflection;   // C2143  \nusing namespace System::Reflection;  \n```  \n  \n It can also occur when you are trying to compile a source code file by using CLR syntax without also using **/clr**:  \n  \n```cpp  \n// C2143b.cpp  \nref struct A {   // C2143 error compile with /clr  \n   void Test() {}  \n};  \n  \nint main() {  \n   A a;  \n   a.Test();  \n}  \n```  \n  \n The first non-whitespace character that follows an `if` statement must be a left parenthesis. The compiler cannot translate anything else:  \n  \n```cpp  \n// C2143c.cpp  \nint main() {  \n   int j = 0;  \n  \n   // OK  \n   if (j < 25)  \n      ;  \n  \n   if (j < 25)   // C2143  \n}  \n```  \n  \n C2143 can occur when a closing brace, parenthesis, or semicolon is missing on the line where the error is detected or on one of the lines just above:  \n  \n```caml  \n// C2143d.cpp  \n// compile with: /c  \nclass X {  \n   int member1;  \n   int member2   // C2143  \n} x;  \n```  \n  \n Or when there's an invalid tag in a class declaration:  \n  \n```cpp  \n// C2143e.cpp  \nclass X {  \n   int member;  \n} x;  \n  \nclass + {};   // C2143 + is an invalid tag name  \nclass ValidName {};   // OK  \n```  \n  \n Or when a label is not attached to a statement. If you must place a label by itself, for example, at the end of a compound statement, attach it to a null statement:  \n  \n```cpp  \n// C2143f.cpp  \n// compile with: /c  \nvoid func1() {  \n   // OK  \n   end1:  \n      ;  \n  \n   end2:   // C2143  \n}  \n```  \n  \n The error can occur when an unqualified call is made to a type in the Standard C++ Library:  \n  \n```cpp  \n// C2143g.cpp  \n// compile with: /EHsc /c  \n#include <vector>  \nstatic vector<char> bad;   // C2143  \nstatic std::vector<char> good;   // OK  \n```  \n  \n Or there is a missing `typename` keyword:  \n  \n```cpp  \n// C2143h.cpp  \ntemplate <typename T>  \nstruct X {  \n   struct Y {  \n      int i;  \n   };  \n   Y memFunc();  \n};  \ntemplate <typename T>  \nX<T>::Y X<T>::memFunc() {   // C2143  \n// try the following line instead  \n// typename X<T>::Y X<T>::memFunc() {  \n   return Y();  \n}  \n```  \n  \n Or if you try to define an explicit instantiation:  \n  \n```cpp  \n// C2143i.cpp  \n// compile with: /EHsc /c  \n// template definition  \ntemplate <class T>  \nvoid PrintType(T i, T j) {}  \n  \ntemplate void PrintType(float i, float j){}   // C2143  \ntemplate void PrintType(float i, float j);   // OK  \n```  \n  \n In a C program, variables must be declared at the beginning of the function, and they cannot be declared after the function executes non-declaration instructions.  \n  \n```c  \n// C2143j.c  \nint main()   \n{  \n    int i = 0;  \n    i++;  \n    int j = 0; // C2143  \n}  \n  \n```"}