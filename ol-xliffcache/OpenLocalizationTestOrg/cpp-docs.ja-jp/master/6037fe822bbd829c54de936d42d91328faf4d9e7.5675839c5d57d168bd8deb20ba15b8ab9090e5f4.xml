{"nodes":[{"pos":[12,45],"content":"CSemaphore Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"CSemaphore Class | Microsoft Docs","pos":[0,33]}]},{"pos":[663,679],"content":"CSemaphore Class","linkify":"CSemaphore Class","nodes":[{"content":"CSemaphore Class","pos":[0,16]}]},{"pos":[680,925],"content":"An object of class <ph id=\"ph1\">`CSemaphore`</ph> represents a \"semaphore\" — a synchronization object that allows a limited number of threads in one or more processes to access a Maintains a count of the number of threads currently accessing a specified resource.","source":"An object of class `CSemaphore` represents a \"semaphore\" — a synchronization object that allows a limited number of threads in one or more processes to access a Maintains a count of the number of threads currently accessing a specified resource."},{"pos":[934,940],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1004,1011],"content":"Members","linkify":"Members","nodes":[{"content":"Members","pos":[0,7]}]},{"pos":[1021,1040],"content":"Public Constructors","linkify":"Public Constructors","nodes":[{"content":"Public Constructors","pos":[0,19]}]},{"content":"Name","pos":[1047,1051]},{"content":"Description","pos":[1052,1063]},{"pos":[1101,1150],"content":"<bpt id=\"p1\">[</bpt>CSemaphore::CSemaphore<ept id=\"p1\">](#csemaphore__csemaphore)</ept>","source":"[CSemaphore::CSemaphore](#csemaphore__csemaphore)"},{"pos":[1151,1184],"content":"Constructs a <ph id=\"ph1\">`CSemaphore`</ph> object.","source":"Constructs a `CSemaphore` object."},{"pos":[1194,1201],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Semaphores are useful in controlling access to a shared resource that can only support a limited number of users.","pos":[1205,1318]},{"content":"The current count of the <ph id=\"ph1\">`CSemaphore`</ph> object is the number of additional users allowed.","pos":[1319,1406],"source":" The current count of the `CSemaphore` object is the number of additional users allowed."},{"content":"When the count reaches zero, all attempts to use the resource controlled by the <bpt id=\"p1\">**</bpt>CSemaphore<ept id=\"p1\">**</ept> object will be inserted into a system queue and wait until they either time out or the count rises above 0.","pos":[1407,1609],"source":" When the count reaches zero, all attempts to use the resource controlled by the **CSemaphore** object will be inserted into a system queue and wait until they either time out or the count rises above 0."},{"content":"The maximum number of users who can access the controlled resource at one time is specified during construction of the <ph id=\"ph1\">`CSemaphore`</ph> object.","pos":[1610,1749],"source":" The maximum number of users who can access the controlled resource at one time is specified during construction of the `CSemaphore` object."},{"content":"To use a <bpt id=\"p1\">**</bpt>CSemaphore<ept id=\"p1\">**</ept> object, construct the <ph id=\"ph1\">`CSemaphore`</ph> object when it is needed.","pos":[1756,1840],"source":"To use a **CSemaphore** object, construct the `CSemaphore` object when it is needed."},{"content":"Specify the name of the semaphore you wish to wait on, and that your application should initially own it.","pos":[1841,1946]},{"content":"You can then access the semaphore when the constructor returns.","pos":[1947,2010]},{"content":"Call <bpt id=\"p1\">[</bpt>CSyncObject::Unlock<ept id=\"p1\">](../../mfc/reference/csyncobject-class.md#csyncobject__unlock)</ept> when you are done accessing the controlled resource.","pos":[2011,2152],"source":" Call [CSyncObject::Unlock](../../mfc/reference/csyncobject-class.md#csyncobject__unlock) when you are done accessing the controlled resource."},{"content":"An alternative method for using <ph id=\"ph1\">`CSemaphore`</ph> objects is to add a variable of type <ph id=\"ph2\">`CSemaphore`</ph> as a data member to the class you wish to control.","pos":[2159,2304],"source":"An alternative method for using `CSemaphore` objects is to add a variable of type `CSemaphore` as a data member to the class you wish to control."},{"content":"During construction of the controlled object, call the constructor of the <ph id=\"ph1\">`CSemaphore`</ph> data member specifying the initial access count, maximum access count, name of the semaphore (if it will be used across process boundaries), and desired security attributes.","pos":[2305,2565],"source":" During construction of the controlled object, call the constructor of the `CSemaphore` data member specifying the initial access count, maximum access count, name of the semaphore (if it will be used across process boundaries), and desired security attributes."},{"content":"To access resources controlled by <ph id=\"ph1\">`CSemaphore`</ph> objects in this manner, first create a variable of either type <bpt id=\"p1\">[</bpt>CSingleLock<ept id=\"p1\">](../../mfc/reference/csinglelock-class.md)</ept> or type <bpt id=\"p2\">[</bpt>CMultiLock<ept id=\"p2\">](../../mfc/reference/cmultilock-class.md)</ept> in your resource's access member function.","pos":[2572,2842],"source":"To access resources controlled by `CSemaphore` objects in this manner, first create a variable of either type [CSingleLock](../../mfc/reference/csinglelock-class.md) or type [CMultiLock](../../mfc/reference/cmultilock-class.md) in your resource's access member function."},{"content":"Then call the lock object's <ph id=\"ph1\">`Lock`</ph> member function (for example, <bpt id=\"p1\">[</bpt>CSingleLock::Lock<ept id=\"p1\">](../../mfc/reference/csinglelock-class.md#csinglelock__lock)</ept>).","pos":[2843,2989],"source":" Then call the lock object's `Lock` member function (for example, [CSingleLock::Lock](../../mfc/reference/csinglelock-class.md#csinglelock__lock))."},{"content":"At this point, your thread will either gain access to the resource, wait for the resource to be released and gain access, or wait for the resource to be released and time out, failing to gain access to the resource.","pos":[2990,3205]},{"content":"In any case, your resource has been accessed in a thread-safe manner.","pos":[3206,3275]},{"content":"To release the resource, use the lock object's <ph id=\"ph1\">`Unlock`</ph> member function (for example, <bpt id=\"p1\">[</bpt>CSingleLock::Unlock<ept id=\"p1\">](../../mfc/reference/csinglelock-class.md#csinglelock__unlock)</ept>), or allow the lock object to fall out of scope.","pos":[3276,3494],"source":" To release the resource, use the lock object's `Unlock` member function (for example, [CSingleLock::Unlock](../../mfc/reference/csinglelock-class.md#csinglelock__unlock)), or allow the lock object to fall out of scope."},{"content":"Alternatively, you can create a <bpt id=\"p1\">**</bpt>CSemaphore<ept id=\"p1\">**</ept> object stand-alone, and access it explicitly before attempting to access the controlled resource.","pos":[3501,3645],"source":"Alternatively, you can create a **CSemaphore** object stand-alone, and access it explicitly before attempting to access the controlled resource."},{"content":"This method, while clearer to someone reading your source code, is more prone to error.","pos":[3646,3733]},{"pos":[3740,3945],"content":"For more information on how to use <bpt id=\"p1\">**</bpt>CSemaphore<ept id=\"p1\">**</ept> objects, see the article <bpt id=\"p2\">[</bpt>Multithreading: How to Use the Synchronization Classes<ept id=\"p2\">](../../parallel/multithreading-how-to-use-the-synchronization-classes.md)</ept>.","source":"For more information on how to use **CSemaphore** objects, see the article [Multithreading: How to Use the Synchronization Classes](../../parallel/multithreading-how-to-use-the-synchronization-classes.md)."},{"pos":[3954,3975],"content":"Inheritance Hierarchy","linkify":"Inheritance Hierarchy","nodes":[{"content":"Inheritance Hierarchy","pos":[0,21]}]},{"pos":[3979,4026],"content":"<bpt id=\"p1\">[</bpt>CObject<ept id=\"p1\">](../../mfc/reference/cobject-class.md)</ept>","source":"[CObject](../../mfc/reference/cobject-class.md)"},{"pos":[4033,4088],"content":"<bpt id=\"p1\">[</bpt>CSyncObject<ept id=\"p1\">](../../mfc/reference/csyncobject-class.md)</ept>","source":"[CSyncObject](../../mfc/reference/csyncobject-class.md)"},{"pos":[4116,4128],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[4132,4151],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> afxmt.h","source":"**Header:** afxmt.h"},{"pos":[4161,4222],"content":"<bpt id=\"p1\">&lt;a name=\"csemaphore__csemaphore\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  CSemaphore::CSemaphore","linkify":"<a name=\"csemaphore__csemaphore\"></a>  CSemaphore::CSemaphore","source":"<a name=\"csemaphore__csemaphore\"></a>  CSemaphore::CSemaphore"},{"pos":[4226,4276],"content":"Constructs a named or unnamed <ph id=\"ph1\">`CSemaphore`</ph> object.","source":"Constructs a named or unnamed `CSemaphore` object."},{"pos":[4450,4460],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">*</bpt>lInitialCount<ept id=\"p1\">*</ept>","pos":[4464,4479],"source":"*lInitialCount*"},{"content":"The initial usage count for the semaphore.","pos":[4483,4525]},{"content":"Must be greater than or equal to 0, and less than or equal to <ph id=\"ph1\">`lMaxCount`</ph>.","pos":[4526,4600],"source":" Must be greater than or equal to 0, and less than or equal to `lMaxCount`."},{"content":"The maximum usage count for the semaphore.","pos":[4622,4664]},{"content":"Must be greater than 0.","pos":[4665,4688]},{"content":"The name of the semaphore.","pos":[4709,4735]},{"content":"Must be supplied if the semaphore will be accessed across process boundaries.","pos":[4736,4813]},{"content":"If <ph id=\"ph1\">`NULL,`</ph> the object will be unnamed.","pos":[4814,4852],"source":" If `NULL,` the object will be unnamed."},{"content":"If the name matches an existing semaphore, the constructor builds a new <ph id=\"ph1\">`CSemaphore`</ph> object which references the semaphore of that name.","pos":[4853,4989],"source":" If the name matches an existing semaphore, the constructor builds a new `CSemaphore` object which references the semaphore of that name."},{"content":"If the name matches an existing synchronization object that is not a semaphore, the construction will fail.","pos":[4990,5097]},{"content":"<bpt id=\"p1\">*</bpt>lpsaAttributes<ept id=\"p1\">*</ept>","pos":[5104,5120],"source":"*lpsaAttributes*"},{"content":"Security attributes for the semaphore object.","pos":[5124,5169]},{"content":"For a full description of this structure, see <bpt id=\"p1\">[</bpt>SECURITY_ATTRIBUTES<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/aa379560)</ept> in the <ph id=\"ph1\">[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]</ph>.","pos":[5170,5357],"source":" For a full description of this structure, see [SECURITY_ATTRIBUTES](http://msdn.microsoft.com/library/windows/desktop/aa379560) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]."},{"pos":[5367,5374],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[5378,5723],"content":"To access or release a <ph id=\"ph1\">`CSemaphore`</ph> object, create a <bpt id=\"p1\">[</bpt>CMultiLock<ept id=\"p1\">](../../mfc/reference/cmultilock-class.md)</ept> or <bpt id=\"p2\">[</bpt>CSingleLock<ept id=\"p2\">](../../mfc/reference/csinglelock-class.md)</ept> object and call its <bpt id=\"p3\">[</bpt>Lock<ept id=\"p3\">](../../mfc/reference/csinglelock-class.md#csinglelock__lock)</ept> and <bpt id=\"p4\">[</bpt>Unlock<ept id=\"p4\">](../../mfc/reference/csinglelock-class.md#csinglelock__unlock)</ept> member functions.","source":"To access or release a `CSemaphore` object, create a [CMultiLock](../../mfc/reference/cmultilock-class.md) or [CSingleLock](../../mfc/reference/csinglelock-class.md) object and call its [Lock](../../mfc/reference/csinglelock-class.md#csinglelock__lock) and [Unlock](../../mfc/reference/csinglelock-class.md#csinglelock__unlock) member functions."},{"pos":[5731,6191],"content":"[!IMPORTANT]\n After creating the `CSemaphore` object, use [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360) to ensure that the mutex did not already exist. If the mutex did exist unexpectedly, it may indicate a rogue process is squatting and may be intending to use the mutex maliciously. In this case, the recommended security-conscious procedure is to close the handle and continue as if there was a failure in creating the object.","leadings":["","> "],"nodes":[{"content":" After creating the `CSemaphore` object, use [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360) to ensure that the mutex did not already exist. If the mutex did exist unexpectedly, it may indicate a rogue process is squatting and may be intending to use the mutex maliciously. In this case, the recommended security-conscious procedure is to close the handle and continue as if there was a failure in creating the object.","pos":[13,458],"nodes":[{"content":"After creating the <ph id=\"ph1\">`CSemaphore`</ph> object, use <bpt id=\"p1\">[</bpt>GetLastError<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms679360)</ept> to ensure that the mutex did not already exist.","pos":[1,167],"source":" After creating the `CSemaphore` object, use [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360) to ensure that the mutex did not already exist."},{"content":"If the mutex did exist unexpectedly, it may indicate a rogue process is squatting and may be intending to use the mutex maliciously.","pos":[168,300]},{"content":"In this case, the recommended security-conscious procedure is to close the handle and continue as if there was a failure in creating the object.","pos":[301,445]}]}]},{"pos":[6200,6208],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>CSyncObject Class<ept id=\"p1\">](../../mfc/reference/csyncobject-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[6212,6274],"source":"[CSyncObject Class](../../mfc/reference/csyncobject-class.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Hierarchy Chart<ept id=\"p1\">](../../mfc/hierarchy-chart.md)</ept>","pos":[6277,6325],"source":" [Hierarchy Chart](../../mfc/hierarchy-chart.md)"}],"content":"---\ntitle: \"CSemaphore Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"reference\"\nf1_keywords: \n  - \"CSemaphore\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"synchronization objects, semaphores\"\n  - \"CSemaphore class\"\n  - \"semaphores\"\nms.assetid: 385fc7e4-8f86-4be2-85e1-d23b38c12f7f\ncaps.latest.revision: 23\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# CSemaphore Class\nAn object of class `CSemaphore` represents a \"semaphore\" — a synchronization object that allows a limited number of threads in one or more processes to access a Maintains a count of the number of threads currently accessing a specified resource.  \n  \n## Syntax  \n  \n```  \nclass CSemaphore : public CSyncObject  \n```  \n  \n## Members  \n  \n### Public Constructors  \n  \n|Name|Description|  \n|----------|-----------------|  \n|[CSemaphore::CSemaphore](#csemaphore__csemaphore)|Constructs a `CSemaphore` object.|  \n  \n## Remarks  \n Semaphores are useful in controlling access to a shared resource that can only support a limited number of users. The current count of the `CSemaphore` object is the number of additional users allowed. When the count reaches zero, all attempts to use the resource controlled by the **CSemaphore** object will be inserted into a system queue and wait until they either time out or the count rises above 0. The maximum number of users who can access the controlled resource at one time is specified during construction of the `CSemaphore` object.  \n  \n To use a **CSemaphore** object, construct the `CSemaphore` object when it is needed. Specify the name of the semaphore you wish to wait on, and that your application should initially own it. You can then access the semaphore when the constructor returns. Call [CSyncObject::Unlock](../../mfc/reference/csyncobject-class.md#csyncobject__unlock) when you are done accessing the controlled resource.  \n  \n An alternative method for using `CSemaphore` objects is to add a variable of type `CSemaphore` as a data member to the class you wish to control. During construction of the controlled object, call the constructor of the `CSemaphore` data member specifying the initial access count, maximum access count, name of the semaphore (if it will be used across process boundaries), and desired security attributes.  \n  \n To access resources controlled by `CSemaphore` objects in this manner, first create a variable of either type [CSingleLock](../../mfc/reference/csinglelock-class.md) or type [CMultiLock](../../mfc/reference/cmultilock-class.md) in your resource's access member function. Then call the lock object's `Lock` member function (for example, [CSingleLock::Lock](../../mfc/reference/csinglelock-class.md#csinglelock__lock)). At this point, your thread will either gain access to the resource, wait for the resource to be released and gain access, or wait for the resource to be released and time out, failing to gain access to the resource. In any case, your resource has been accessed in a thread-safe manner. To release the resource, use the lock object's `Unlock` member function (for example, [CSingleLock::Unlock](../../mfc/reference/csinglelock-class.md#csinglelock__unlock)), or allow the lock object to fall out of scope.  \n  \n Alternatively, you can create a **CSemaphore** object stand-alone, and access it explicitly before attempting to access the controlled resource. This method, while clearer to someone reading your source code, is more prone to error.  \n  \n For more information on how to use **CSemaphore** objects, see the article [Multithreading: How to Use the Synchronization Classes](../../parallel/multithreading-how-to-use-the-synchronization-classes.md).  \n  \n## Inheritance Hierarchy  \n [CObject](../../mfc/reference/cobject-class.md)  \n  \n [CSyncObject](../../mfc/reference/csyncobject-class.md)  \n  \n `CSemaphore`  \n  \n## Requirements  \n **Header:** afxmt.h  \n  \n##  <a name=\"csemaphore__csemaphore\"></a>  CSemaphore::CSemaphore  \n Constructs a named or unnamed `CSemaphore` object.  \n  \n```  \nCSemaphore(\n    LONG lInitialCount = 1,  \n    LONG lMaxCount = 1,  \n    LPCTSTR pstrName = NULL,  \n    LPSECURITY_ATTRIBUTES lpsaAttributes = NULL);\n```  \n  \n### Parameters  \n *lInitialCount*  \n The initial usage count for the semaphore. Must be greater than or equal to 0, and less than or equal to `lMaxCount`.  \n  \n `lMaxCount`  \n The maximum usage count for the semaphore. Must be greater than 0.  \n  \n `pstrName`  \n The name of the semaphore. Must be supplied if the semaphore will be accessed across process boundaries. If `NULL,` the object will be unnamed. If the name matches an existing semaphore, the constructor builds a new `CSemaphore` object which references the semaphore of that name. If the name matches an existing synchronization object that is not a semaphore, the construction will fail.  \n  \n *lpsaAttributes*  \n Security attributes for the semaphore object. For a full description of this structure, see [SECURITY_ATTRIBUTES](http://msdn.microsoft.com/library/windows/desktop/aa379560) in the [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  \n  \n### Remarks  \n To access or release a `CSemaphore` object, create a [CMultiLock](../../mfc/reference/cmultilock-class.md) or [CSingleLock](../../mfc/reference/csinglelock-class.md) object and call its [Lock](../../mfc/reference/csinglelock-class.md#csinglelock__lock) and [Unlock](../../mfc/reference/csinglelock-class.md#csinglelock__unlock) member functions.  \n  \n> [!IMPORTANT]\n>  After creating the `CSemaphore` object, use [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360) to ensure that the mutex did not already exist. If the mutex did exist unexpectedly, it may indicate a rogue process is squatting and may be intending to use the mutex maliciously. In this case, the recommended security-conscious procedure is to close the handle and continue as if there was a failure in creating the object.  \n  \n## See Also  \n [CSyncObject Class](../../mfc/reference/csyncobject-class.md)   \n [Hierarchy Chart](../../mfc/hierarchy-chart.md)\n\n\n\n"}