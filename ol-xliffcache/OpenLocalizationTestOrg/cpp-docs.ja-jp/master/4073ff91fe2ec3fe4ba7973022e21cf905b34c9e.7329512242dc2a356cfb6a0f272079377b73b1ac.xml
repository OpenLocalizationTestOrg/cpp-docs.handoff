{"nodes":[{"pos":[12,83],"content":"Multithreading: How to Use the Synchronization Classes | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Multithreading: How to Use the Synchronization Classes | Microsoft Docs","pos":[0,71]}]},{"content":"Multithreading: How to Use the Synchronization Classes","pos":[1001,1055]},{"content":"Synchronizing resource access between threads is a common problem when writing multithreaded applications.","pos":[1056,1162]},{"content":"Having two or more threads simultaneously access the same data can lead to undesirable and unpredictable results.","pos":[1163,1276]},{"content":"For example, one thread could be updating the contents of a structure while another thread is reading the contents of the same structure.","pos":[1277,1414]},{"content":"It is unknown what data the reading thread will receive: the old data, the newly written data, or possibly a mixture of both.","pos":[1415,1540]},{"content":"MFC provides a number of synchronization and synchronization access classes to aid in solving this problem.","pos":[1541,1648]},{"content":"This topic explains the classes available and how to use them to create thread-safe classes in a typical multithreaded application.","pos":[1649,1780]},{"content":"A typical multithreaded application has a class that represents a resource to be shared among threads.","pos":[1787,1889]},{"content":"A properly designed, fully thread-safe class does not require you to call any synchronization functions.","pos":[1890,1994]},{"content":"Everything is handled internally to the class, allowing you to concentrate on how to best use the class, not about how it might get corrupted.","pos":[1995,2137]},{"content":"An effective technique for creating a fully thread-safe class is to merge the synchronization class into the resource class.","pos":[2138,2262]},{"content":"Merging the synchronization classes into the shared class is a straightforward process.","pos":[2263,2350]},{"content":"As an example, take an application that maintains a linked list of accounts.","pos":[2357,2433]},{"content":"This application allows up to three accounts to be examined in separate windows, but only one can be updated at any particular time.","pos":[2434,2566]},{"content":"When an account is updated, the updated data is sent over the network to a data archive.","pos":[2567,2655]},{"content":"This example application uses all three types of synchronization classes.","pos":[2662,2735]},{"content":"Because it allows up to three accounts to be examined at one time, it uses <bpt id=\"p1\">[</bpt>CSemaphore<ept id=\"p1\">](../mfc/reference/csemaphore-class.md)</ept> to limit access to three view objects.","pos":[2736,2900],"source":" Because it allows up to three accounts to be examined at one time, it uses [CSemaphore](../mfc/reference/csemaphore-class.md) to limit access to three view objects."},{"content":"When an attempt to view a fourth account occurs, the application either waits until one of the first three windows closes or it fails.","pos":[2901,3035]},{"content":"When an account is updated, the application uses <bpt id=\"p1\">[</bpt>CCriticalSection<ept id=\"p1\">](../mfc/reference/ccriticalsection-class.md)</ept> to ensure that only one account is updated at a time.","pos":[3036,3201],"source":" When an account is updated, the application uses [CCriticalSection](../mfc/reference/ccriticalsection-class.md) to ensure that only one account is updated at a time."},{"content":"After the update succeeds, it signals <bpt id=\"p1\">[</bpt>CEvent<ept id=\"p1\">](../mfc/reference/cevent-class.md)</ept>, which releases a thread waiting for the event to be signaled.","pos":[3202,3345],"source":" After the update succeeds, it signals [CEvent](../mfc/reference/cevent-class.md), which releases a thread waiting for the event to be signaled."},{"content":"This thread sends the new data to the data archive.","pos":[3346,3397]},{"pos":[3460,3489],"content":"Designing a Thread-Safe Class"},{"content":"To make a class fully thread-safe, first add the appropriate synchronization class to the shared classes as a data member.","pos":[3493,3615]},{"content":"In the previous account-management example, a <bpt id=\"p1\">**</bpt>CSemaphore<ept id=\"p1\">**</ept> data member would be added to the view class, a <ph id=\"ph1\">`CCriticalSection`</ph> data member would be added to the linked-list class, and a <ph id=\"ph2\">`CEvent`</ph> data member would be added to the data storage class.","pos":[3616,3865],"source":" In the previous account-management example, a **CSemaphore** data member would be added to the view class, a `CCriticalSection` data member would be added to the linked-list class, and a `CEvent` data member would be added to the data storage class."},{"content":"Next, add synchronization calls to all member functions that modify the data in the class or access a controlled resource.","pos":[3872,3994]},{"content":"In each function, you should create either a <bpt id=\"p1\">[</bpt>CSingleLock<ept id=\"p1\">](../mfc/reference/csinglelock-class.md)</ept> or <bpt id=\"p2\">[</bpt>CMultiLock<ept id=\"p2\">](../mfc/reference/cmultilock-class.md)</ept> object and call that object's <ph id=\"ph1\">`Lock`</ph> function.","pos":[3995,4193],"source":" In each function, you should create either a [CSingleLock](../mfc/reference/csinglelock-class.md) or [CMultiLock](../mfc/reference/cmultilock-class.md) object and call that object's `Lock` function."},{"content":"When the lock object goes out of scope and is destroyed, the object's destructor calls <ph id=\"ph1\">`Unlock`</ph> for you, releasing the resource.","pos":[4194,4322],"source":" When the lock object goes out of scope and is destroyed, the object's destructor calls `Unlock` for you, releasing the resource."},{"content":"Of course, you can call <ph id=\"ph1\">`Unlock`</ph> directly if you want.","pos":[4323,4377],"source":" Of course, you can call `Unlock` directly if you want."},{"content":"Designing your thread-safe class in this fashion allows it to be used in a multithreaded application as easily as a non-thread-safe class, but with a higher level of safety.","pos":[4384,4557]},{"content":"Encapsulating the synchronization object and synchronization access object into the resource's class provides all the benefits of fully thread-safe programming without the drawback of maintaining synchronization code.","pos":[4558,4775]},{"content":"The following code example demonstrates this method by using a data member, <ph id=\"ph1\">`m_CritSection`</ph> (of type <ph id=\"ph2\">`CCriticalSection`</ph>), declared in the shared resource class and a <ph id=\"ph3\">`CSingleLock`</ph> object.","pos":[4782,4969],"source":"The following code example demonstrates this method by using a data member, `m_CritSection` (of type `CCriticalSection`), declared in the shared resource class and a `CSingleLock` object."},{"content":"The synchronization of the shared resource (derived from <ph id=\"ph1\">`CWinThread`</ph>) is attempted by creating a <ph id=\"ph2\">`CSingleLock`</ph> object using the address of the <ph id=\"ph3\">`m_CritSection`</ph> object.","pos":[4970,5137],"source":" The synchronization of the shared resource (derived from `CWinThread`) is attempted by creating a `CSingleLock` object using the address of the `m_CritSection` object."},{"content":"An attempt is made to lock the resource and, when obtained, work is done on the shared object.","pos":[5138,5232]},{"content":"When the work is finished, the resource is unlocked with a call to <ph id=\"ph1\">`Unlock`</ph>.","pos":[5233,5309],"source":" When the work is finished, the resource is unlocked with a call to `Unlock`."},{"pos":[5475,5657],"content":"[!NOTE]\n `CCriticalSection`, unlike other MFC synchronization classes, does not have the option of a timed lock request. The waiting period for a thread to become free is infinite.","leadings":["","> "],"nodes":[{"content":", unlike other MFC synchronization classes, does not have the option of a timed lock request. The waiting period for a thread to become free is infinite.","pos":[27,180],"nodes":[{"content":", unlike other MFC synchronization classes, does not have the option of a timed lock request.","pos":[0,93]},{"content":"The waiting period for a thread to become free is infinite.","pos":[94,153]}]}]},{"content":"The drawbacks to this approach are that the class will be slightly slower than the same class without the synchronization objects added.","pos":[5664,5800]},{"content":"Also, if there is a chance that more than one thread might delete the object, the merged approach might not always work.","pos":[5801,5921]},{"content":"In this situation, it is better to maintain separate synchronization objects.","pos":[5922,5999]},{"content":"For information about determining which synchronization class to use in different situations, see <bpt id=\"p1\">[</bpt>Multithreading: When to Use the Synchronization Classes<ept id=\"p1\">](../parallel/multithreading-when-to-use-the-synchronization-classes.md)</ept>.","pos":[6006,6233],"source":"For information about determining which synchronization class to use in different situations, see [Multithreading: When to Use the Synchronization Classes](../parallel/multithreading-when-to-use-the-synchronization-classes.md)."},{"content":"For more information about synchronization, see <bpt id=\"p1\">[</bpt>Synchronization<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/desktop/ms686353)</ept> in the <ph id=\"ph1\">[!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]</ph>.","pos":[6234,6447],"source":" For more information about synchronization, see [Synchronization](http://msdn.microsoft.com/library/windows/desktop/ms686353) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]."},{"content":"For more information about multithreading support in MFC, see <bpt id=\"p1\">[</bpt>Multithreading with C++ and MFC<ept id=\"p1\">](../parallel/multithreading-with-cpp-and-mfc.md)</ept>.","pos":[6448,6592],"source":" For more information about multithreading support in MFC, see [Multithreading with C++ and MFC](../parallel/multithreading-with-cpp-and-mfc.md)."},{"content":"See Also","pos":[6601,6609]},{"content":"Multithreading with C++ and MFC","pos":[6614,6645]}],"content":"---\ntitle: \"Multithreading: How to Use the Synchronization Classes | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"MFC [C++], multithreading\"\n  - \"threading [MFC], synchronization classes\"\n  - \"resources [C++], multithreading\"\n  - \"thread-safe classes [C++]\"\n  - \"synchronization classes [C++]\"\n  - \"synchronization [C++], multithreading\"\n  - \"threading [MFC], thread-safe class design\"\n  - \"threading [C++], synchronization\"\n  - \"multithreading [C++], synchronization classes\"\n  - \"threading [C++], thread-safe class design\"\nms.assetid: f266d4c6-0454-4bda-9758-26157ef74cc5\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Multithreading: How to Use the Synchronization Classes\nSynchronizing resource access between threads is a common problem when writing multithreaded applications. Having two or more threads simultaneously access the same data can lead to undesirable and unpredictable results. For example, one thread could be updating the contents of a structure while another thread is reading the contents of the same structure. It is unknown what data the reading thread will receive: the old data, the newly written data, or possibly a mixture of both. MFC provides a number of synchronization and synchronization access classes to aid in solving this problem. This topic explains the classes available and how to use them to create thread-safe classes in a typical multithreaded application.  \n  \n A typical multithreaded application has a class that represents a resource to be shared among threads. A properly designed, fully thread-safe class does not require you to call any synchronization functions. Everything is handled internally to the class, allowing you to concentrate on how to best use the class, not about how it might get corrupted. An effective technique for creating a fully thread-safe class is to merge the synchronization class into the resource class. Merging the synchronization classes into the shared class is a straightforward process.  \n  \n As an example, take an application that maintains a linked list of accounts. This application allows up to three accounts to be examined in separate windows, but only one can be updated at any particular time. When an account is updated, the updated data is sent over the network to a data archive.  \n  \n This example application uses all three types of synchronization classes. Because it allows up to three accounts to be examined at one time, it uses [CSemaphore](../mfc/reference/csemaphore-class.md) to limit access to three view objects. When an attempt to view a fourth account occurs, the application either waits until one of the first three windows closes or it fails. When an account is updated, the application uses [CCriticalSection](../mfc/reference/ccriticalsection-class.md) to ensure that only one account is updated at a time. After the update succeeds, it signals [CEvent](../mfc/reference/cevent-class.md), which releases a thread waiting for the event to be signaled. This thread sends the new data to the data archive.  \n  \n##  <a name=\"_mfc_designing_a_thread.2d.safe_class\"></a> Designing a Thread-Safe Class  \n To make a class fully thread-safe, first add the appropriate synchronization class to the shared classes as a data member. In the previous account-management example, a **CSemaphore** data member would be added to the view class, a `CCriticalSection` data member would be added to the linked-list class, and a `CEvent` data member would be added to the data storage class.  \n  \n Next, add synchronization calls to all member functions that modify the data in the class or access a controlled resource. In each function, you should create either a [CSingleLock](../mfc/reference/csinglelock-class.md) or [CMultiLock](../mfc/reference/cmultilock-class.md) object and call that object's `Lock` function. When the lock object goes out of scope and is destroyed, the object's destructor calls `Unlock` for you, releasing the resource. Of course, you can call `Unlock` directly if you want.  \n  \n Designing your thread-safe class in this fashion allows it to be used in a multithreaded application as easily as a non-thread-safe class, but with a higher level of safety. Encapsulating the synchronization object and synchronization access object into the resource's class provides all the benefits of fully thread-safe programming without the drawback of maintaining synchronization code.  \n  \n The following code example demonstrates this method by using a data member, `m_CritSection` (of type `CCriticalSection`), declared in the shared resource class and a `CSingleLock` object. The synchronization of the shared resource (derived from `CWinThread`) is attempted by creating a `CSingleLock` object using the address of the `m_CritSection` object. An attempt is made to lock the resource and, when obtained, work is done on the shared object. When the work is finished, the resource is unlocked with a call to `Unlock`.  \n  \n```  \nCSingleLock singleLock(&m_CritSection);  \nsingleLock.Lock();  \n// resource locked  \n//.usage of shared resource...  \n  \nsingleLock.Unlock();  \n```  \n  \n> [!NOTE]\n>  `CCriticalSection`, unlike other MFC synchronization classes, does not have the option of a timed lock request. The waiting period for a thread to become free is infinite.  \n  \n The drawbacks to this approach are that the class will be slightly slower than the same class without the synchronization objects added. Also, if there is a chance that more than one thread might delete the object, the merged approach might not always work. In this situation, it is better to maintain separate synchronization objects.  \n  \n For information about determining which synchronization class to use in different situations, see [Multithreading: When to Use the Synchronization Classes](../parallel/multithreading-when-to-use-the-synchronization-classes.md). For more information about synchronization, see [Synchronization](http://msdn.microsoft.com/library/windows/desktop/ms686353) in the [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]. For more information about multithreading support in MFC, see [Multithreading with C++ and MFC](../parallel/multithreading-with-cpp-and-mfc.md).  \n  \n## See Also  \n [Multithreading with C++ and MFC](../parallel/multithreading-with-cpp-and-mfc.md)"}