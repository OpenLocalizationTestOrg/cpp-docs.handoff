{"nodes":[{"pos":[12,46],"content":"_fdopen, _wfdopen | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"_fdopen, _wfdopen | Microsoft Docs","pos":[0,34]}]},{"content":"_fdopen, _wfdopen","pos":[1104,1121]},{"content":"Associates a stream with a file that was previously opened for low-level I/O.","pos":[1122,1199]},{"content":"Syntax","pos":[1208,1214]},{"content":"Parameters","pos":[1363,1373]},{"content":"File descriptor of the open file.","pos":[1385,1418]},{"content":"Type of file access.","pos":[1435,1455]},{"content":"Return Value","pos":[1464,1476]},{"content":"Each of these functions returns a pointer to the open stream.","pos":[1480,1541]},{"content":"A null pointer value indicates an error.","pos":[1542,1582]},{"content":"When an error occurs, the invalid parameter handler is invoked, as described in <bpt id=\"p1\">[</bpt>Parameter Validation<ept id=\"p1\">](../../c-runtime-library/parameter-validation.md)</ept>.","pos":[1583,1735],"source":" When an error occurs, the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md)."},{"content":"If execution is allowed to continue, <ph id=\"ph1\">`errno`</ph> is set either to <ph id=\"ph2\">`EBADF`</ph>, which indicates a bad file descriptor, or <ph id=\"ph3\">`EINVAL`</ph>, which indicates that <ph id=\"ph4\">`mode`</ph> was a null pointer.","pos":[1736,1906],"source":" If execution is allowed to continue, `errno` is set either to `EBADF`, which indicates a bad file descriptor, or `EINVAL`, which indicates that `mode` was a null pointer."},{"pos":[1913,2089],"content":"For more information about these and other error codes, see <bpt id=\"p1\">[</bpt>_doserrno, errno, _sys_errlist, and _sys_nerr<ept id=\"p1\">](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)</ept>.","source":"For more information about these and other error codes, see [_doserrno, errno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)."},{"content":"Remarks","pos":[2098,2105]},{"content":"The <ph id=\"ph1\">`_fdopen`</ph> function associates an I/O stream with the file that is identified by <ph id=\"ph2\">`fd`</ph>, and thus allows a file that is opened for low-level I/O to be buffered and formatted.","pos":[2109,2284],"source":"The `_fdopen` function associates an I/O stream with the file that is identified by `fd`, and thus allows a file that is opened for low-level I/O to be buffered and formatted."},{"content":"is a wide-character version of <ph id=\"ph1\">`_fdopen`</ph>; the <ph id=\"ph2\">`mode`</ph> argument to <ph id=\"ph3\">`_wfdopen`</ph> is a wide-character string.","pos":[2296,2399],"source":" is a wide-character version of `_fdopen`; the `mode` argument to `_wfdopen` is a wide-character string."},{"content":"and <ph id=\"ph1\">`_fdopen`</ph> otherwise behave identically.","pos":[2411,2454],"source":" and `_fdopen` otherwise behave identically."},{"content":"Generic-Text Routine Mappings","pos":[2464,2493]},{"content":"Tchar.h routine","pos":[2500,2515]},{"content":"_UNICODE and _MBCS not defined","pos":[2516,2546]},{"content":"_MBCS defined","pos":[2547,2560]},{"content":"_UNICODE defined","pos":[2561,2577]},{"pos":[2741,2812],"content":"The <ph id=\"ph1\">`mode`</ph> character string specifies the type of file and file access.","source":"The `mode` character string specifies the type of file and file access."},{"pos":[2819,2932],"content":"The character string <ph id=\"ph1\">`mode`</ph> specifies the type of access requested for the file, as shown in the following table.","source":"The character string `mode` specifies the type of access requested for the file, as shown in the following table."},{"content":"Opens for reading.","pos":[2948,2966]},{"content":"If the file does not exist or cannot be found, the <ph id=\"ph1\">`fopen`</ph> call fails.","pos":[2967,3037],"source":" If the file does not exist or cannot be found, the `fopen` call fails."},{"content":"Opens an empty file for writing.","pos":[3053,3085]},{"content":"If the given file exists, its contents are destroyed.","pos":[3086,3139]},{"content":"Opens for writing, at the end of the file (appending).","pos":[3155,3209]},{"content":"Creates the file if it does not exist.","pos":[3210,3248]},{"content":"Opens for both reading and writing.","pos":[3265,3300]},{"content":"(The file must exist.)","pos":[3301,3323]},{"content":"Opens an empty file for both reading and writing.","pos":[3340,3389]},{"content":"If the given file exists, its contents are destroyed.","pos":[3390,3443]},{"content":"Opens for reading and appending.","pos":[3460,3492]},{"content":"Creates the file if it does not exist.","pos":[3493,3531]},{"content":"When a file is opened with the <ph id=\"ph1\">`\"a\"`</ph> or <ph id=\"ph2\">`\"a+\"`</ph> access type, all write operations occur at the end of the file.","pos":[3538,3648],"source":"When a file is opened with the `\"a\"` or `\"a+\"` access type, all write operations occur at the end of the file."},{"content":"The file pointer can be repositioned by using <ph id=\"ph1\">`fseek`</ph> or <ph id=\"ph2\">`rewind`</ph>, but it is always moved back to the end of the file before any write operation is carried out.","pos":[3649,3809],"source":" The file pointer can be repositioned by using `fseek` or `rewind`, but it is always moved back to the end of the file before any write operation is carried out."},{"content":"Thus, existing data cannot be overwritten.","pos":[3810,3852]},{"content":"When the <ph id=\"ph1\">`\"r+\"`</ph>, <ph id=\"ph2\">`\"w+\"`</ph>, or <ph id=\"ph3\">`\"a+\"`</ph> access type is specified, both reading and writing are allowed (the file is said to be open for \"update\").","pos":[3853,3994],"source":" When the `\"r+\"`, `\"w+\"`, or `\"a+\"` access type is specified, both reading and writing are allowed (the file is said to be open for \"update\")."},{"content":"However, when you switch between reading and writing, there must be an intervening <ph id=\"ph1\">`fflush`</ph>, <ph id=\"ph2\">`fsetpos`</ph>, <ph id=\"ph3\">`fseek`</ph>, or <ph id=\"ph4\">`rewind`</ph> operation.","pos":[3995,4130],"source":" However, when you switch between reading and writing, there must be an intervening `fflush`, `fsetpos`, `fseek`, or `rewind` operation."},{"content":"You can specify the current position for the <ph id=\"ph1\">`fsetpos`</ph> or <ph id=\"ph2\">`fseek`</ph> operation, if you want to.","pos":[4131,4223],"source":" You can specify the current position for the `fsetpos` or `fseek` operation, if you want to."},{"pos":[4230,4374],"content":"In addition to the above values, the following characters can also be included in <ph id=\"ph1\">`mode`</ph> to specify the translation mode for newline characters.","source":"In addition to the above values, the following characters can also be included in `mode` to specify the translation mode for newline characters."},{"content":"Open in text (translated) mode.","pos":[4388,4419]},{"content":"In this mode, carriage return-line feed (CR-LF) combinations are translated into one-line feeds (LF) on input, and LF characters are translated to CR-LF combinations on output.","pos":[4420,4596]},{"content":"Also, Ctrl+Z is interpreted as an end-of-file character on input.","pos":[4597,4662]},{"content":"In files opened for reading/writing, <ph id=\"ph1\">`fopen`</ph> checks for a Ctrl+Z at the end of the file and removes it, if possible.","pos":[4663,4779],"source":" In files opened for reading/writing, `fopen` checks for a Ctrl+Z at the end of the file and removes it, if possible."},{"content":"This is done because using the <ph id=\"ph1\">`fseek`</ph> and <ph id=\"ph2\">`ftell`</ph> functions to move within a file that ends with a Ctrl+Z might cause <ph id=\"ph3\">`fseek`</ph> to behave incorrectly near the end of the file.","pos":[4780,4954],"source":" This is done because using the `fseek` and `ftell` functions to move within a file that ends with a Ctrl+Z might cause `fseek` to behave incorrectly near the end of the file."},{"content":"Open in binary (untranslated) mode.","pos":[4968,5003]},{"content":"Any translations from <ph id=\"ph1\">`t`</ph> mode are suppressed.","pos":[5004,5050],"source":" Any translations from `t` mode are suppressed."},{"content":"Enable the commit flag for the associated <ph id=\"ph1\">`filename`</ph> so that the contents of the file buffer are written directly to disk if either <ph id=\"ph2\">`fflush`</ph> or <ph id=\"ph3\">`_flushall`</ph> is called.","pos":[5064,5230],"source":" Enable the commit flag for the associated `filename` so that the contents of the file buffer are written directly to disk if either `fflush` or `_flushall` is called."},{"content":"Reset the commit flag for the associated <ph id=\"ph1\">`filename`</ph> to \"no-commit.\"","pos":[5244,5311],"source":" Reset the commit flag for the associated `filename` to \"no-commit.\""},{"content":"This is the default.","pos":[5312,5332]},{"content":"It also overrides the global commit flag if you link your program with Commode.obj.","pos":[5333,5416]},{"content":"The global commit flag default is \"no-commit\" unless you explicitly link your program with Commode.obj.","pos":[5417,5520]},{"content":"The <ph id=\"ph1\">`t`</ph>, <ph id=\"ph2\">`c`</ph>, and <ph id=\"ph3\">`n`</ph> <ph id=\"ph4\">`mode`</ph> options are Microsoft extensions for <ph id=\"ph5\">`fopen`</ph> and <ph id=\"ph6\">`_fdopen`</ph>.","pos":[5527,5615],"source":"The `t`, `c`, and `n` `mode` options are Microsoft extensions for `fopen` and `_fdopen`."},{"content":"Do not use them if you want to preserve ANSI portability.","pos":[5616,5673]},{"content":"If <ph id=\"ph1\">`t`</ph> or <ph id=\"ph2\">`b`</ph> is not given in <ph id=\"ph3\">`mode`</ph>, the default translation mode is defined by the global variable <bpt id=\"p1\">[</bpt>_fmode<ept id=\"p1\">](../../c-runtime-library/fmode.md)</ept>.","pos":[5680,5824],"source":"If `t` or `b` is not given in `mode`, the default translation mode is defined by the global variable [_fmode](../../c-runtime-library/fmode.md)."},{"content":"If <ph id=\"ph1\">`t`</ph> or <ph id=\"ph2\">`b`</ph> is prefixed to the argument, the function fails and returns <ph id=\"ph3\">`NULL`</ph>.","pos":[5825,5906],"source":" If `t` or `b` is prefixed to the argument, the function fails and returns `NULL`."},{"content":"For a discussion of text and binary modes, see <bpt id=\"p1\">[</bpt>Text and Binary Mode File I/O<ept id=\"p1\">](../../c-runtime-library/text-and-binary-mode-file-i-o.md)</ept>.","pos":[5907,6044],"source":" For a discussion of text and binary modes, see [Text and Binary Mode File I/O](../../c-runtime-library/text-and-binary-mode-file-i-o.md)."},{"pos":[6051,6293],"content":"Valid characters for the <ph id=\"ph1\">`mode`</ph> string used in <ph id=\"ph2\">`fopen`</ph> and <ph id=\"ph3\">`_fdopen`</ph> correspond to <ph id=\"ph4\">`oflag`</ph> arguments used in <bpt id=\"p1\">[</bpt>_open<ept id=\"p1\">](../../c-runtime-library/reference/open-wopen.md)</ept> and <bpt id=\"p2\">[</bpt>_sopen<ept id=\"p2\">](../../c-runtime-library/reference/sopen-wsopen.md)</ept>, as follows.","source":"Valid characters for the `mode` string used in `fopen` and `_fdopen` correspond to `oflag` arguments used in [_open](../../c-runtime-library/reference/open-wopen.md) and [_sopen](../../c-runtime-library/reference/sopen-wsopen.md), as follows."},{"pos":[6300,6327],"content":"Characters in <ph id=\"ph1\">`mode`</ph> string","source":"Characters in `mode` string"},{"pos":[6328,6355],"content":"Equivalent <ph id=\"ph1\">`oflag`</ph>value for","source":"Equivalent `oflag`value for "},{"pos":[6500,6554],"content":"(usually <ph id=\"ph1\">`_O_WRONLY &amp;#124; _O_CREAT &amp;#124; _O_APPEND`</ph>)","source":" (usually `_O_WRONLY &#124; _O_CREAT &#124; _O_APPEND`)"},{"pos":[6591,6644],"content":"(usually <ph id=\"ph1\">`_O_RDWR &amp;#124; _O_APPEND &amp;#124; _O_CREAT`</ph> )","source":" (usually `_O_RDWR &#124; _O_APPEND &#124; _O_CREAT` )"},{"pos":[6704,6757],"content":"(usually <ph id=\"ph1\">`_O_WRONLY &amp;#124; _O_CREAT &amp;#124; _O_TRUNC`</ph>)","source":" (usually `_O_WRONLY &#124; _O_CREAT &#124; _O_TRUNC`)"},{"pos":[6777,6828],"content":"(usually <ph id=\"ph1\">`_O_RDWR &amp;#124; _O_CREAT &amp;#124; _O_TRUNC`</ph>)","source":" (usually `_O_RDWR &#124; _O_CREAT &#124; _O_TRUNC`)"},{"content":"None","pos":[6875,6879]},{"content":"None","pos":[6888,6892]},{"content":"Requirements","pos":[6902,6914]},{"content":"Function","pos":[6921,6929]},{"content":"Required header","pos":[6930,6945]},{"content":"stdio.h&gt;","pos":[7003,7011],"source":"stdio.h>"},{"content":"stdio.h&gt; or <ph id=\"ph1\">\\&lt;</ph>wchar.h&gt;","pos":[7029,7051],"source":"stdio.h> or \\<wchar.h>"},{"pos":[7059,7157],"content":"For more compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept>.","source":"For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md)."},{"content":"Example","pos":[7166,7173]},{"content":"Input: crt_fdopen.txt","pos":[7986,8007]},{"content":"Output","pos":[8054,8060]},{"content":".NET Framework Equivalent","pos":[8103,8128]},{"content":"&lt;xref:System.IO.FileStream.%23ctor%2A&gt;","pos":[8132,8170],"source":"<xref:System.IO.FileStream.%23ctor%2A>"},{"content":"See Also","pos":[8179,8187]},{"content":"Stream I/O","pos":[8192,8202]},{"content":"_dup, _dup2","pos":[8248,8259]},{"content":"fclose, _fcloseall","pos":[8313,8331]},{"content":"fopen, _wfopen","pos":[8393,8407]},{"content":"freopen, _wfreopen","pos":[8465,8483]},{"content":"_open, _wopen","pos":[8545,8558]}],"content":"---\ntitle: \"_fdopen, _wfdopen | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"_fdopen\"\n  - \"_wfdopen\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"_tfdopen\"\n  - \"_fdopen\"\n  - \"_wfdopen\"\n  - \"wfdopen\"\n  - \"tfdopen\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"wfdopen function\"\n  - \"_fdopen function\"\n  - \"_wfdopen function\"\n  - \"tfdopen function\"\n  - \"fdopen function\"\n  - \"_tfdopen function\"\n  - \"streams, associating with files\"\nms.assetid: 262757ff-1e09-4472-a5b6-4325fc28f971\ncaps.latest.revision: 23\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# _fdopen, _wfdopen\nAssociates a stream with a file that was previously opened for low-level I/O.  \n  \n## Syntax  \n  \n```  \nFILE *_fdopen(    \n   int fd,  \n   const char *mode   \n);  \nFILE *_wfdopen(   \n   int fd,  \n   const wchar_t *mode   \n);  \n```  \n  \n#### Parameters  \n `fd`  \n File descriptor of the open file.  \n  \n `mode`  \n Type of file access.  \n  \n## Return Value  \n Each of these functions returns a pointer to the open stream. A null pointer value indicates an error. When an error occurs, the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md). If execution is allowed to continue, `errno` is set either to `EBADF`, which indicates a bad file descriptor, or `EINVAL`, which indicates that `mode` was a null pointer.  \n  \n For more information about these and other error codes, see [_doserrno, errno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).  \n  \n## Remarks  \n The `_fdopen` function associates an I/O stream with the file that is identified by `fd`, and thus allows a file that is opened for low-level I/O to be buffered and formatted. `_wfdopen` is a wide-character version of `_fdopen`; the `mode` argument to `_wfdopen` is a wide-character string. `_wfdopen` and `_fdopen` otherwise behave identically.  \n  \n### Generic-Text Routine Mappings  \n  \n|Tchar.h routine|_UNICODE and _MBCS not defined|_MBCS defined|_UNICODE defined|  \n|---------------------|--------------------------------------|--------------------|-----------------------|  \n|`_tfdopen`|`_fdopen`|`_fdopen`|`_wfdopen`|  \n  \n The `mode` character string specifies the type of file and file access.  \n  \n The character string `mode` specifies the type of access requested for the file, as shown in the following table.  \n  \n `\"r\"`  \n Opens for reading. If the file does not exist or cannot be found, the `fopen` call fails.  \n  \n `\"w\"`  \n Opens an empty file for writing. If the given file exists, its contents are destroyed.  \n  \n `\"a\"`  \n Opens for writing, at the end of the file (appending). Creates the file if it does not exist.  \n  \n `\"r+\"`  \n Opens for both reading and writing. (The file must exist.)  \n  \n `\"w+\"`  \n Opens an empty file for both reading and writing. If the given file exists, its contents are destroyed.  \n  \n `\"a+\"`  \n Opens for reading and appending. Creates the file if it does not exist.  \n  \n When a file is opened with the `\"a\"` or `\"a+\"` access type, all write operations occur at the end of the file. The file pointer can be repositioned by using `fseek` or `rewind`, but it is always moved back to the end of the file before any write operation is carried out. Thus, existing data cannot be overwritten. When the `\"r+\"`, `\"w+\"`, or `\"a+\"` access type is specified, both reading and writing are allowed (the file is said to be open for \"update\"). However, when you switch between reading and writing, there must be an intervening `fflush`, `fsetpos`, `fseek`, or `rewind` operation. You can specify the current position for the `fsetpos` or `fseek` operation, if you want to.  \n  \n In addition to the above values, the following characters can also be included in `mode` to specify the translation mode for newline characters.  \n  \n `t`  \n Open in text (translated) mode. In this mode, carriage return-line feed (CR-LF) combinations are translated into one-line feeds (LF) on input, and LF characters are translated to CR-LF combinations on output. Also, Ctrl+Z is interpreted as an end-of-file character on input. In files opened for reading/writing, `fopen` checks for a Ctrl+Z at the end of the file and removes it, if possible. This is done because using the `fseek` and `ftell` functions to move within a file that ends with a Ctrl+Z might cause `fseek` to behave incorrectly near the end of the file.  \n  \n `b`  \n Open in binary (untranslated) mode. Any translations from `t` mode are suppressed.  \n  \n `c`  \n Enable the commit flag for the associated `filename` so that the contents of the file buffer are written directly to disk if either `fflush` or `_flushall` is called.  \n  \n `n`  \n Reset the commit flag for the associated `filename` to \"no-commit.\" This is the default. It also overrides the global commit flag if you link your program with Commode.obj. The global commit flag default is \"no-commit\" unless you explicitly link your program with Commode.obj.  \n  \n The `t`, `c`, and `n` `mode` options are Microsoft extensions for `fopen` and `_fdopen`. Do not use them if you want to preserve ANSI portability.  \n  \n If `t` or `b` is not given in `mode`, the default translation mode is defined by the global variable [_fmode](../../c-runtime-library/fmode.md). If `t` or `b` is prefixed to the argument, the function fails and returns `NULL`. For a discussion of text and binary modes, see [Text and Binary Mode File I/O](../../c-runtime-library/text-and-binary-mode-file-i-o.md).  \n  \n Valid characters for the `mode` string used in `fopen` and `_fdopen` correspond to `oflag` arguments used in [_open](../../c-runtime-library/reference/open-wopen.md) and [_sopen](../../c-runtime-library/reference/sopen-wsopen.md), as follows.  \n  \n|Characters in `mode` string|Equivalent `oflag`value for `_open`/`_sopen`|  \n|---------------------------------|---------------------------------------------------|  \n|`a`|`_O_WRONLY &#124; _O_APPEND` (usually `_O_WRONLY &#124; _O_CREAT &#124; _O_APPEND`)|  \n|`a+`|`_O_RDWR &#124; _O_APPEND` (usually `_O_RDWR &#124; _O_APPEND &#124; _O_CREAT` )|  \n|`r`|`_O_RDONLY`|  \n|`r+`|`_O_RDWR`|  \n|`w`|`_O_WRONLY` (usually `_O_WRONLY &#124; _O_CREAT &#124; _O_TRUNC`)|  \n|`w+`|`_O_RDWR` (usually `_O_RDWR &#124; _O_CREAT &#124; _O_TRUNC`)|  \n|`b`|`_O_BINARY`|  \n|`t`|`_O_TEXT`|  \n|`c`|None|  \n|`n`|None|  \n  \n## Requirements  \n  \n|Function|Required header|  \n|--------------|---------------------|  \n|`_fdopen`|\\<stdio.h>|  \n|`_wfdopen`|\\<stdio.h> or \\<wchar.h>|  \n  \n For more compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md).  \n  \n## Example  \n  \n```  \n// crt_fdopen.c  \n// This program opens a file by using low-level  \n// I/O, then uses _fdopen to switch to stream  \n// access. It counts the lines in the file.  \n  \n#include <stdlib.h>  \n#include <stdio.h>  \n#include <fcntl.h>  \n#include <io.h>  \n#include <share.h>  \n  \nint main( void )  \n{  \n   FILE *stream;  \n   int  fd, count = 0;  \n   char inbuf[128];  \n  \n   // Open a file.  \n   if( _sopen_s( &fd, \"crt_fdopen.txt\", _O_RDONLY, _SH_DENYNO, 0 ) )  \n      exit( 1 );  \n  \n   // Get stream from file descriptor.  \n   if( (stream = _fdopen( fd, \"r\" )) == NULL )  \n      exit( 1 );  \n  \n   while( fgets( inbuf, 128, stream ) != NULL )  \n      count++;  \n  \n   // After _fdopen, close by using fclose, not _close.  \n   fclose( stream );  \n   printf( \"Lines in file: %d\\n\", count );  \n}  \n```  \n  \n## Input: crt_fdopen.txt  \n  \n```  \nLine one  \nLine two  \n```  \n  \n### Output  \n  \n```  \nLines in file: 2  \n```  \n  \n## .NET Framework Equivalent  \n <xref:System.IO.FileStream.%23ctor%2A>  \n  \n## See Also  \n [Stream I/O](../../c-runtime-library/stream-i-o.md)   \n [_dup, _dup2](../../c-runtime-library/reference/dup-dup2.md)   \n [fclose, _fcloseall](../../c-runtime-library/reference/fclose-fcloseall.md)   \n [fopen, _wfopen](../../c-runtime-library/reference/fopen-wfopen.md)   \n [freopen, _wfreopen](../../c-runtime-library/reference/freopen-wfreopen.md)   \n [_open, _wopen](../../c-runtime-library/reference/open-wopen.md)"}