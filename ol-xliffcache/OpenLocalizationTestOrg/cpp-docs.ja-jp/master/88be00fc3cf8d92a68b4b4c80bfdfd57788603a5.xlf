<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04506c2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">88be00fc3cf8d92a68b4b4c80bfdfd57788603a5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\dotnet\pure-and-verifiable-code-cpp-cli.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">35fc1517d234d54dd47bb7168dca604d106e0340</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b225ebb3f06b7a01140258014da50c943fd95da5</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Pure and Verifiable Code (C++-CLI) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Pure and Verifiable Code (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>For .NET Programming, Visual C++ supports the creation of three distinct types of components and applications: mixed, pure, and verifiable.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>All three are available through the <bpt id="p1">[</bpt>/clr (Common Language Runtime Compilation)<ept id="p1">](../build/reference/clr-common-language-runtime-compilation.md)</ept> compiler option.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For more information about verifiable assemblies, see:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Mixed, Pure, and Verifiable Feature Comparison (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How to: Migrate to /clr:pure (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>How to: Create Verifiable C++ Projects (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>How to: Migrate to /clr:safe (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Using Verifiable Assemblies with SQL Server (C++/CLI)</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Security Best Practices</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Converting Projects from Mixed Mode to Pure Intermediate Language</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Mixed (/clr)</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Mixed assemblies (compiled with <bpt id="p1">**</bpt>/clr<ept id="p1">**</ept>), contain both unmanaged and managed parts, making it possible for them to use .NET features, but still contain unmanaged code.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This allows applications and components to be updated to use .NET features without requiring that the entire project be rewritten.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Using Visual C++ to mix managed and unmanaged code in this fashion is called C++ Interop.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Mixed (Native and Managed) Assemblies<ept id="p1">](../dotnet/mixed-native-and-managed-assemblies.md)</ept> and <bpt id="p2">[</bpt>Native and .NET Interoperability<ept id="p2">](../dotnet/native-and-dotnet-interoperability.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Pure (/clr:pure)</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Pure assemblies (compiled with <bpt id="p1">**</bpt>/clr:pure<ept id="p1">**</ept>) can contain both native and managed data types, but only managed functions.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Like mixed assemblies, pure assemblies allow interop with native DLLs through P/Invoke (see <bpt id="p1">[</bpt>Using Explicit PInvoke in C++ (DllImport Attribute)<ept id="p1">](../dotnet/using-explicit-pinvoke-in-cpp-dllimport-attribute.md)</ept>), but C++ Interop features are not available.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Moreover, pure assemblies cannot export functions that are callable from native functions because entry points in a pure assembly use the <bpt id="p1">[</bpt>__clrcall<ept id="p1">](../cpp/clrcall.md)</ept> calling convention.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Advantages of /clr:pure</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Better Performance: Because pure assemblies contain only MSIL, there are no native functions, and therefore no managed/unmanaged transitions are necessary.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>(Function calls made through P/Invoke are an exception to this rule.)</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>AppDomain Awareness: Managed functions and CLR data types exist inside <ph id="ph1">`Application Domains`</ph>, which affects their visibility and accessibility.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Pure assemblies are domain-aware (__declspec(<bpt id="p1">[</bpt>appdomain<ept id="p1">](../cpp/appdomain.md)</ept>) is implied for each type) so accessing their types and functionality from other .NET components is easier and safer.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>As a result, pure assemblies interoperate more easily with other .NET components than mixed assemblies.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Non-disk loading: Pure assemblies can be loaded in-memory and even streamed.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This is essential for using .NET assemblies as stored procedures.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This differs from mixed assemblies, which due to a dependency on the Windows loading mechanisms, must exist on disk in order to execute.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Reflection: It is not possible to reflect over mixed executables, whereas pure assemblies provide full reflection support.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Reflection (C++/CLI)<ept id="p1">](../dotnet/reflection-cpp-cli.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Host Controllability: Because pure assemblies contain only MSIL, they behave more predictably and flexibly than mixed assemblies when used in applications that host the CLR and modify its default behavior.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Limitations of /clr:pure</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This section covers features not currently supported by <bpt id="p1">**</bpt>/clr:pure<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Pure assemblies cannot be called by unmanaged functions.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Therefore pure assemblies cannot implement COM interfaces or expose native callbacks.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Pure assemblies cannot export functions via __declspec(dllexport) or .DEF files.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Also, functions declared with the <ph id="ph1">\_</ph>_clrcall convention cannot be imported via <ph id="ph2">\_</ph>_declspec(dllimport).</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Functions in a native module can be called from a pure assembly, but pure assemblies cannot expose native-callable functions, so exposing functionality in a pure assembly must be done through managed functions in a mixed assembly.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>How to: Migrate to /clr:pure (C++/CLI)<ept id="p1">](../dotnet/how-to-migrate-to-clr-pure-cpp-cli.md)</ept> for more information.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>ATL and MFC libraries are not supported by pure mode compilation in Visual C++.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Pure .netmodules are not accepted as input to the Visual C++ linker.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>However, pure .obj files are accepted by the linker, and .obj files contain a superset of information contained in netmodules.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>.netmodule Files as Linker Input<ept id="p1">](../build/reference/netmodule-files-as-linker-input.md)</ept> for more information.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Compiler COM support (#import) is not supported, as this would introduce unmanaged instructions into the pure assembly.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Floating point options for alignment and exception-handling are not adjustable for pure assemblies.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>As a result, __declspec(align) cannot be used.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This renders some header files, such as fpieee.h, incompatible with /clr:pure.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The GetLastError function in the PSDK can give undefined behavior when compiling with <bpt id="p1">**</bpt>/clr:pure<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Verifiable (/clr:safe)</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>/clr:safe<ept id="p1">**</ept> compiler option generates verifiable assemblies, like those written in Visual Basic and C#, conforming to requirements that allow the common language runtime (CLR) to guarantee that the code does not violate current security settings.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For example, if security settings prohibit a component from writing to disk, the CLR can determine if a verifiable component meets this criterion before executing any of the code.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>There is no CRT support for verifiable assemblies.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>(CRT support is available to pure assemblies through a Pure MSIL version of the C Runtime library.)</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Verifiable assemblies offer these advantages over pure and mixed assemblies:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Increased security.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Some situations require it (SQL components, for example).</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Future versions of Windows will increasingly require components and applications to be verifiable.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>One disadvantage is that C++ interop features are not available.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Verifiable assemblies cannot contain any unmanaged functions or native data types, even if they are not referenced by the managed code.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Despite the use of the word "safe", compiling applications with <bpt id="p1">**</bpt>/clr:safe<ept id="p1">**</ept> does not mean there are no bugs; it just means that the CLR can verify the security settings at run time.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Regardless of assembly type, calls made from managed assemblies to native DLLs via P/Invoke will compile, but may fail at runtime depending on security settings.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>There is one coding scenario that will pass the compiler but that will result in an unverifiable assembly: calling a virtual function through an object instance using the scope resolution operator.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For example: <ph id="ph1">`MyObj -&gt; A::VirtualFunction();`</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>.NET Programming with C++/CLI (Visual C++)</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>