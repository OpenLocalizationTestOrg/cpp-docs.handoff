{"nodes":[{"pos":[12,86],"content":"Recommendations for Choosing Between Functions and Macros | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Recommendations for Choosing Between Functions and Macros | Microsoft Docs","pos":[0,74]}]},{"content":"Recommendations for Choosing Between Functions and Macros","pos":[690,747]},{"content":"Most Microsoft run-time library routines are compiled or assembled functions, but some routines are implemented as macros.","pos":[748,870]},{"content":"When a header file declares both a function and a macro version of a routine, the macro definition takes precedence, because it always appears after the function declaration.","pos":[871,1045]},{"content":"When you invoke a routine that is implemented as both a function and a macro, you can force the compiler to use the function version in two ways:","pos":[1046,1191]},{"content":"Enclose the routine name in parentheses.","pos":[1201,1241]},{"pos":[1468,1528],"content":"\"Undefine\" the macro definition with the <ph id=\"ph1\">`#undef`</ph> directive:","source":"\"Undefine\" the macro definition with the `#undef` directive:"},{"content":"If you need to choose between a function and a macro implementation of a library routine, consider the following trade-offs:","pos":[1605,1729]},{"content":"<bpt id=\"p1\">**</bpt>Speed versus size<ept id=\"p1\">**</ept> The main benefit of using macros is faster execution time.","pos":[1739,1819],"source":"**Speed versus size** The main benefit of using macros is faster execution time."},{"content":"During preprocessing, a macro is expanded (replaced by its definition) inline each time it is used.","pos":[1820,1919]},{"content":"A function definition occurs only once regardless of how many times it is called.","pos":[1920,2001]},{"content":"Macros may increase code size but do not have the overhead associated with function calls.","pos":[2002,2092]},{"content":"<bpt id=\"p1\">**</bpt>Function evaluation<ept id=\"p1\">**</ept> A function evaluates to an address; a macro does not.","pos":[2102,2179],"source":"**Function evaluation** A function evaluates to an address; a macro does not."},{"content":"Thus you cannot use a macro name in contexts requiring a pointer.","pos":[2180,2245]},{"content":"For instance, you can declare a pointer to a function, but not a pointer to a macro.","pos":[2246,2330]},{"content":"<bpt id=\"p1\">**</bpt>Type-checking<ept id=\"p1\">**</ept> When you declare a function, the compiler can check the argument types.","pos":[2340,2429],"source":"**Type-checking** When you declare a function, the compiler can check the argument types."},{"content":"Because you cannot declare a macro, the compiler cannot check macro argument types; although it can check the number of arguments you pass to a macro.","pos":[2430,2580]},{"content":"See Also","pos":[2589,2597]},{"content":"CRT Library Features","pos":[2602,2622]}],"content":"---\ntitle: \"Recommendations for Choosing Between Functions and Macros | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"c.functions\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"functions [CRT], vs. macros\"\n  - \"macros, vs. functions\"\nms.assetid: 18a633d6-cf1c-470c-a649-fa7677473e2b\ncaps.latest.revision: 7\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Recommendations for Choosing Between Functions and Macros\nMost Microsoft run-time library routines are compiled or assembled functions, but some routines are implemented as macros. When a header file declares both a function and a macro version of a routine, the macro definition takes precedence, because it always appears after the function declaration. When you invoke a routine that is implemented as both a function and a macro, you can force the compiler to use the function version in two ways:  \n  \n-   Enclose the routine name in parentheses.  \n  \n    ```  \n    #include <ctype.h>  \n    a = _toupper(a);    // Use macro version of toupper.  \n    a = (_toupper)(a);  // Force compiler to use   \n                        // function version of toupper.  \n    ```  \n  \n-   \"Undefine\" the macro definition with the `#undef` directive:  \n  \n    ```  \n    #include <ctype.h>  \n    #undef _toupper  \n    ```  \n  \n If you need to choose between a function and a macro implementation of a library routine, consider the following trade-offs:  \n  \n-   **Speed versus size** The main benefit of using macros is faster execution time. During preprocessing, a macro is expanded (replaced by its definition) inline each time it is used. A function definition occurs only once regardless of how many times it is called. Macros may increase code size but do not have the overhead associated with function calls.  \n  \n-   **Function evaluation** A function evaluates to an address; a macro does not. Thus you cannot use a macro name in contexts requiring a pointer. For instance, you can declare a pointer to a function, but not a pointer to a macro.  \n  \n-   **Type-checking** When you declare a function, the compiler can check the argument types. Because you cannot declare a macro, the compiler cannot check macro argument types; although it can check the number of arguments you pass to a macro.  \n  \n## See Also  \n [CRT Library Features](../c-runtime-library/crt-library-features.md)"}