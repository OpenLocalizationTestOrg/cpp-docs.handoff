{"nodes":[{"pos":[12,64],"content":"ame Resolution for Dependent Types | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"ame Resolution for Dependent Types | Microsoft Docs","pos":[0,51]}]},{"content":"Name Resolution for Dependent Types","pos":[556,591]},{"content":"Use <bpt id=\"p1\">**</bpt>typename<ept id=\"p1\">**</ept> for qualified names in template definitions to tell the compiler that the given qualified name identifies a type.","pos":[592,722],"source":"Use **typename** for qualified names in template definitions to tell the compiler that the given qualified name identifies a type."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>typename<ept id=\"p1\">](../cpp/typename.md)</ept>.","pos":[723,780],"source":" For more information, see [typename](../cpp/typename.md)."},{"content":"Output","pos":[1146,1152]},{"content":"Name lookup for dependent names examines names from both the context of the template definition—in the following example, this context would find <ph id=\"ph1\">`myFunction(char)`</ph>—and the context of the template instantiation.In the following example, the template is instantiated in main; therefore, the <ph id=\"ph2\">`MyNamespace::myFunction`</ph> is visible from the point of instantiation and is picked as the better match.","pos":[1217,1610],"source":"Name lookup for dependent names examines names from both the context of the template definition—in the following example, this context would find `myFunction(char)`—and the context of the template instantiation.In the following example, the template is instantiated in main; therefore, the `MyNamespace::myFunction` is visible from the point of instantiation and is picked as the better match."},{"content":"If <ph id=\"ph1\">`MyNamespace::myFunction`</ph> were renamed, <ph id=\"ph2\">`myFunction(char)`</ph> would be called instead.","pos":[1611,1697],"source":" If `MyNamespace::myFunction` were renamed, `myFunction(char)` would be called instead."},{"content":"All names are resolved as if they were dependent names.","pos":[1704,1759]},{"content":"Nevertheless, we recommend that you use fully qualified names if there is any possible conflict.","pos":[1760,1856]},{"content":"Output","pos":[2490,2496]},{"content":"Template Disambiguation","pos":[2551,2574]},{"content":"enforces the C++98/03/11 standard rules for disambiguation with the \"template\" keyword.","pos":[2645,2732]},{"content":"In the following example, <ph id=\"ph1\">[!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)]</ph> would accept both the nonconforming lines and the conforming lines.","pos":[2733,2893],"source":" In the following example, [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)] would accept both the nonconforming lines and the conforming lines."},{"content":"accepts only the conforming lines.","pos":[2962,2996]},{"content":"Conformance with the disambiguation rules is required because, by default, C++ assumes that <ph id=\"ph1\">`AY::Rebind`</ph> isn't a template, and so the compiler interprets the following \"<ph id=\"ph2\">`&lt;`</ph>\" as a less-than.","pos":[3699,3888],"source":"Conformance with the disambiguation rules is required because, by default, C++ assumes that `AY::Rebind` isn't a template, and so the compiler interprets the following \"`<`\" as a less-than."},{"content":"It has to know that <ph id=\"ph1\">`Rebind`</ph> is a template so that it can correctly parse \"<ph id=\"ph2\">`&lt;`</ph>\" as an angle bracket.","pos":[3889,3989],"source":" It has to know that `Rebind` is a template so that it can correctly parse \"`<`\" as an angle bracket."},{"content":"See Also","pos":[3998,4006]},{"content":"Name Resolution","pos":[4011,4026]}],"content":"---\ntitle: \"Name Resolution for Dependent Types | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nms.assetid: 34066bb4-0c79-4fd8-bda7-539a60a277ab\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Name Resolution for Dependent Types\nUse **typename** for qualified names in template definitions to tell the compiler that the given qualified name identifies a type. For more information, see [typename](../cpp/typename.md).  \n  \n```cpp  \n  \n      // template_name_resolution1.cpp  \n#include <stdio.h>  \ntemplate <class T> class X  \n{  \npublic:  \n   void f(typename T::myType* mt) {}  \n};  \n  \nclass Yarg  \n{  \npublic:  \n   struct myType { };  \n};  \n  \nint main()  \n{  \n   X<Yarg> x;  \n   x.f(new Yarg::myType());  \n   printf(\"Name resolved by using typename keyword.\");  \n}  \n```  \n  \n### Output  \n  \n```  \nName resolved by using typename keyword.  \n```  \n  \n Name lookup for dependent names examines names from both the context of the template definition—in the following example, this context would find `myFunction(char)`—and the context of the template instantiation.In the following example, the template is instantiated in main; therefore, the `MyNamespace::myFunction` is visible from the point of instantiation and is picked as the better match. If `MyNamespace::myFunction` were renamed, `myFunction(char)` would be called instead.  \n  \n All names are resolved as if they were dependent names. Nevertheless, we recommend that you use fully qualified names if there is any possible conflict.  \n  \n```cpp  \n//template_name_resolution2.cpp  \n// compile with: /EHsc  \n#include <iostream>  \nusing namespace std;  \n  \nvoid myFunction(char)  \n{  \n   cout << \"Char myFunction\" << endl;  \n}  \n  \ntemplate <class T> class Class1  \n{  \npublic:  \n   Class1(T i)  \n   {  \n      // If replaced with myFunction(1), myFunction(char)  \n      // will be called  \n      myFunction(i);  \n}  \n};  \n  \nnamespace MyNamespace  \n{  \n   void myFunction(int)  \n   {  \n      cout << \"Int MyNamespace::myFunction\" << endl;  \n   }  \n};  \n  \nusing namespace MyNamespace;  \n  \nint main()  \n{  \n   Class1<int>* c1 = new Class1<int>(100);  \n}  \n```  \n  \n### Output  \n  \n```  \nInt MyNamespace::myFunction  \n```  \n  \n### Template Disambiguation  \n [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] enforces the C++98/03/11 standard rules for disambiguation with the \"template\" keyword. In the following example, [!INCLUDE[cpp_dev10_long](../build/includes/cpp_dev10_long_md.md)] would accept both the nonconforming lines and the conforming lines.  [!INCLUDE[cpp_dev11_long](../build/includes/cpp_dev11_long_md.md)] accepts only the conforming lines.  \n  \n```cpp  \n#include <iostream>  \n#include <ostream>  \n#include <typeinfo>  \nusing namespace std;  \n  \ntemplate <typename T> struct Allocator {  \n    template <typename U> struct Rebind {  \n        typedef Allocator<U> Other;  \n    };  \n};  \n  \ntemplate <typename X, typename AY> struct Container {  \n    #if defined(NONCONFORMANT)  \n        typedef typename AY::Rebind<X>::Other AX; // nonconformant  \n    #elif defined(CONFORMANT)  \n        typedef typename AY::template Rebind<X>::Other AX; // conformant  \n    #else  \n        #error Define NONCONFORMANT or CONFORMANT.  \n    #endif  \n};  \n  \nint main() {  \n    cout << typeid(Container<int, Allocator<float>>::AX).name() << endl;  \n}  \n```  \n  \n Conformance with the disambiguation rules is required because, by default, C++ assumes that `AY::Rebind` isn't a template, and so the compiler interprets the following \"`<`\" as a less-than. It has to know that `Rebind` is a template so that it can correctly parse \"`<`\" as an angle bracket.  \n  \n## See Also  \n [Name Resolution](../cpp/templates-and-name-resolution.md)"}