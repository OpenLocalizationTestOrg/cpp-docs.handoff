{"nodes":[{"pos":[12,54],"content":"Conditional Operator: ? : | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Conditional Operator: ? : | Microsoft Docs","pos":[0,42],"nodes":[{"content":"Conditional Operator: ?","pos":[0,23]},{"content":": | Microsoft Docs","pos":[24,42]}]}]},{"content":"Conditional Operator: ?","pos":[646,669]},{"content":":","pos":[670,671]},{"content":"Syntax","pos":[675,681]},{"content":"Remarks","pos":[747,754]},{"content":"The conditional operator (<bpt id=\"p1\">**</bpt>? :<ept id=\"p1\">**</ept>) is a ternary operator (it takes three operands).","pos":[758,841],"source":"The conditional operator (**? :**) is a ternary operator (it takes three operands)."},{"content":"The conditional operator works as follows:","pos":[842,884]},{"content":"The first operand is implicitly converted to <ph id=\"ph1\">`bool`</ph>.","pos":[894,946],"source":"The first operand is implicitly converted to `bool`."},{"content":"It is evaluated and all side effects are completed before continuing.","pos":[947,1016]},{"pos":[1026,1106],"content":"If the first operand evaluates to <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> (1), the second operand is evaluated.","source":"If the first operand evaluates to **true** (1), the second operand is evaluated."},{"pos":[1116,1196],"content":"If the first operand evaluates to <bpt id=\"p1\">**</bpt>false<ept id=\"p1\">**</ept> (0), the third operand is evaluated.","source":"If the first operand evaluates to **false** (0), the third operand is evaluated."},{"content":"The result of the conditional operator is the result of whichever operand is evaluated — the second or the third.","pos":[1203,1316]},{"content":"Only one of the last two operands is evaluated in a conditional expression.","pos":[1317,1392]},{"content":"Conditional expressions have right-to-left associativity.","pos":[1399,1456]},{"content":"The first operand must be of integral or pointer type.","pos":[1457,1511]},{"content":"The following rules apply to the second and third operands:","pos":[1512,1571]},{"content":"If both operands are of the same type, the result is of that type.","pos":[1581,1647]},{"pos":[1657,1855],"content":"If both operands are of arithmetic or enumeration types, the usual arithmetic conversions (covered in <bpt id=\"p1\">[</bpt>Standard Conversions<ept id=\"p1\">](standard-conversions.md)</ept>) are performed to convert them to a common type.","source":"If both operands are of arithmetic or enumeration types, the usual arithmetic conversions (covered in [Standard Conversions](standard-conversions.md)) are performed to convert them to a common type."},{"content":"If both operands are of pointer types or if one is a pointer type and the other is a constant expression that evaluates to 0, pointer conversions are performed to convert them to a common type.","pos":[1865,2058]},{"content":"If both operands are of reference types, reference conversions are performed to convert them to a common type.","pos":[2068,2178]},{"content":"If both operands are of type void, the common type is type void.","pos":[2188,2252]},{"content":"If both operands are of the same user-defined type, the common type is that type.","pos":[2262,2343]},{"content":"If the operands have different types and at least one of the operands has user-defined type then the language rules are used to determine the common type.","pos":[2353,2507]},{"content":"(See warning below.)","pos":[2508,2528]},{"content":"Any combinations of second and third operands not in the preceding list are illegal.","pos":[2535,2619]},{"content":"The type of the result is the common type, and it is an l-value if both the second and third operands are of the same type and both are l-values.","pos":[2620,2765]},{"pos":[2773,3265],"content":"[!WARNING]\n If the types of the second and third operands are not identical, then complex type conversion rules, as specified in the C++ Standard, are invoked. These conversions may lead to unexpected behavior including construction and destruction of temporary objects. For this reason, we strongly advise you to either (1) avoid using user-defined types as operands with the conditional operator or (2) if you do use user-defined types, then explicitly cast each operand to a common type.","leadings":["","> "],"nodes":[{"content":" If the types of the second and third operands are not identical, then complex type conversion rules, as specified in the C++ Standard, are invoked. These conversions may lead to unexpected behavior including construction and destruction of temporary objects. For this reason, we strongly advise you to either (1) avoid using user-defined types as operands with the conditional operator or (2) if you do use user-defined types, then explicitly cast each operand to a common type.","pos":[11,490],"nodes":[{"content":"If the types of the second and third operands are not identical, then complex type conversion rules, as specified in the C++ Standard, are invoked.","pos":[1,148]},{"content":"These conversions may lead to unexpected behavior including construction and destruction of temporary objects.","pos":[149,259]},{"content":"For this reason, we strongly advise you to either (1) avoid using user-defined types as operands with the conditional operator or (2) if you do use user-defined types, then explicitly cast each operand to a common type.","pos":[260,479]}]}]},{"content":"Example","pos":[3274,3281]},{"content":"See Also","pos":[3570,3578]},{"content":"C++ Built-in Operators, Precedence and Associativity","pos":[3583,3635]},{"content":"Conditional-Expression Operator","pos":[3705,3736]}],"content":"---\ntitle: \"Conditional Operator: ? : | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"?:\"\n  - \"?\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"conditional operators\"\n  - \"? : operator\"\nms.assetid: 88643ee8-7100-4f86-880a-705ec22b6271\ncaps.latest.revision: 10\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Conditional Operator: ? :\n## Syntax  \n  \n```  \n  \nexpression ? expression : expression  \n```  \n  \n## Remarks  \n The conditional operator (**? :**) is a ternary operator (it takes three operands). The conditional operator works as follows:  \n  \n-   The first operand is implicitly converted to `bool`. It is evaluated and all side effects are completed before continuing.  \n  \n-   If the first operand evaluates to **true** (1), the second operand is evaluated.  \n  \n-   If the first operand evaluates to **false** (0), the third operand is evaluated.  \n  \n The result of the conditional operator is the result of whichever operand is evaluated — the second or the third. Only one of the last two operands is evaluated in a conditional expression.  \n  \n Conditional expressions have right-to-left associativity. The first operand must be of integral or pointer type. The following rules apply to the second and third operands:  \n  \n-   If both operands are of the same type, the result is of that type.  \n  \n-   If both operands are of arithmetic or enumeration types, the usual arithmetic conversions (covered in [Standard Conversions](standard-conversions.md)) are performed to convert them to a common type.  \n  \n-   If both operands are of pointer types or if one is a pointer type and the other is a constant expression that evaluates to 0, pointer conversions are performed to convert them to a common type.  \n  \n-   If both operands are of reference types, reference conversions are performed to convert them to a common type.  \n  \n-   If both operands are of type void, the common type is type void.  \n  \n-   If both operands are of the same user-defined type, the common type is that type.  \n  \n-   If the operands have different types and at least one of the operands has user-defined type then the language rules are used to determine the common type. (See warning below.)  \n  \n Any combinations of second and third operands not in the preceding list are illegal. The type of the result is the common type, and it is an l-value if both the second and third operands are of the same type and both are l-values.  \n  \n> [!WARNING]\n>  If the types of the second and third operands are not identical, then complex type conversion rules, as specified in the C++ Standard, are invoked. These conversions may lead to unexpected behavior including construction and destruction of temporary objects. For this reason, we strongly advise you to either (1) avoid using user-defined types as operands with the conditional operator or (2) if you do use user-defined types, then explicitly cast each operand to a common type.  \n  \n## Example  \n  \n```  \n// expre_Expressions_with_the_Conditional_Operator.cpp  \n// compile with: /EHsc  \n// Demonstrate conditional operator  \n#include <iostream>  \nusing namespace std;  \nint main() {  \n   int i = 1, j = 2;  \n   cout << ( i > j ? i : j ) << \" is greater.\" << endl;  \n}  \n```  \n  \n## See Also  \n [C++ Built-in Operators, Precedence and Associativity](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   \n [Conditional-Expression Operator](../c-language/conditional-expression-operator.md)"}