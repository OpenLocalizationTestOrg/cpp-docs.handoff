{"nodes":[{"pos":[12,36],"content":"setvbuf | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"setvbuf | Microsoft Docs","pos":[0,24]}]},{"pos":[963,970],"content":"setvbuf","linkify":"setvbuf","nodes":[{"content":"setvbuf","pos":[0,7]}]},{"content":"Controls stream buffering and buffer size.","pos":[971,1013]},{"pos":[1022,1028],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1145,1155],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"Pointer to <ph id=\"ph1\">`FILE`</ph> structure.","pos":[1171,1199],"source":" Pointer to `FILE` structure."},{"content":"User-allocated buffer.","pos":[1218,1240]},{"content":"Mode of buffering.","pos":[1257,1275]},{"content":"Buffer size in bytes.","pos":[1292,1313]},{"content":"Allowable range: 2 &lt;= <ph id=\"ph1\">`size`</ph> &lt;= INT_MAX (2147483647).","pos":[1314,1367],"source":" Allowable range: 2 <= `size` <= INT_MAX (2147483647)."},{"content":"Internally, the value supplied for <ph id=\"ph1\">`size`</ph> is rounded down to the nearest multiple of 2.","pos":[1368,1455],"source":" Internally, the value supplied for `size` is rounded down to the nearest multiple of 2."},{"pos":[1464,1476],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"Returns 0 if successful.","pos":[1480,1504]},{"content":"If <ph id=\"ph1\">`stream`</ph> is <ph id=\"ph2\">`NULL`</ph>, or if <ph id=\"ph3\">`mode`</ph> or <ph id=\"ph4\">`size`</ph> is not within a valid change, the invalid parameter handler is invoked, as described in <bpt id=\"p1\">[</bpt>Parameter Validation<ept id=\"p1\">](../../c-runtime-library/parameter-validation.md)</ept>.","pos":[1511,1717],"source":"If `stream` is `NULL`, or if `mode` or `size` is not within a valid change, the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md)."},{"content":"If execution is allowed to continue, this function returns -1 and sets <ph id=\"ph1\">`errno`</ph> to <ph id=\"ph2\">`EINVAL`</ph>.","pos":[1718,1809],"source":" If execution is allowed to continue, this function returns -1 and sets `errno` to `EINVAL`."},{"pos":[1816,1984],"content":"For information on these and other error codes, see <bpt id=\"p1\">[</bpt>_doserrno, errno, _sys_errlist, and _sys_nerr<ept id=\"p1\">](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)</ept>.","source":"For information on these and other error codes, see [_doserrno, errno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md)."},{"pos":[1993,2000],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`setvbuf`</ph> function allows the program to control both buffering and buffer size for <ph id=\"ph2\">`stream`</ph>.","pos":[2004,2101],"source":"The `setvbuf` function allows the program to control both buffering and buffer size for `stream`."},{"content":"<ph id=\"ph1\">`stream`</ph> must refer to an open file that has not undergone an I/O operation since it was opened.","pos":[2102,2198],"source":"`stream` must refer to an open file that has not undergone an I/O operation since it was opened."},{"content":"The array pointed to by <ph id=\"ph1\">`buffer`</ph> is used as the buffer, unless it is <ph id=\"ph2\">`NULL`</ph>, in which case <ph id=\"ph3\">`setvbuf`</ph> uses an automatically allocated buffer of length <ph id=\"ph4\">`size`</ph>/2 * 2 bytes.","pos":[2199,2368],"source":" The array pointed to by `buffer` is used as the buffer, unless it is `NULL`, in which case `setvbuf` uses an automatically allocated buffer of length `size`/2 * 2 bytes."},{"content":"The mode must be <ph id=\"ph1\">`_IOFBF`</ph>, <ph id=\"ph2\">`_IOLBF`</ph>, or <ph id=\"ph3\">`_IONBF`</ph>.","pos":[2375,2424],"source":"The mode must be `_IOFBF`, `_IOLBF`, or `_IONBF`."},{"content":"If <ph id=\"ph1\">`mode`</ph> is <ph id=\"ph2\">`_IOFBF`</ph> or <ph id=\"ph3\">`_IOLBF`</ph>, then <ph id=\"ph4\">`size`</ph> is used as the size of the buffer.","pos":[2425,2506],"source":" If `mode` is `_IOFBF` or `_IOLBF`, then `size` is used as the size of the buffer."},{"content":"If <ph id=\"ph1\">`mode`</ph> is <ph id=\"ph2\">`_IONBF`</ph>, the stream is unbuffered and <ph id=\"ph3\">`size`</ph> and <ph id=\"ph4\">`buffer`</ph> are ignored.","pos":[2507,2591],"source":" If `mode` is `_IONBF`, the stream is unbuffered and `size` and `buffer` are ignored."},{"content":"Values for <ph id=\"ph1\">`mode`</ph> and their meanings are:","pos":[2592,2633],"source":" Values for `mode` and their meanings are:"},{"content":"Full buffering; that is, <ph id=\"ph1\">`buffer`</ph> is used as the buffer and <ph id=\"ph2\">`size`</ph> is used as the size of the buffer.","pos":[2652,2753],"source":" Full buffering; that is, `buffer` is used as the buffer and `size` is used as the size of the buffer."},{"content":"If <ph id=\"ph1\">`buffer`</ph> is <ph id=\"ph2\">`NULL`</ph>, an automatically allocated buffer <ph id=\"ph3\">`size`</ph> bytes long is used.","pos":[2754,2837],"source":" If `buffer` is `NULL`, an automatically allocated buffer `size` bytes long is used."},{"content":"For some systems, this provides line buffering.","pos":[2856,2903]},{"content":"However, for Win32, the behavior is the same as <ph id=\"ph1\">`_IOFBF`</ph> - Full Buffering.","pos":[2904,2978],"source":" However, for Win32, the behavior is the same as `_IOFBF` - Full Buffering."},{"content":"No buffer is used, regardless of <ph id=\"ph1\">`buffer`</ph> or <ph id=\"ph2\">`size`</ph>.","pos":[2997,3049],"source":" No buffer is used, regardless of `buffer` or `size`."},{"pos":[3058,3070],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"content":"Routine","pos":[3077,3084]},{"content":"Required header","pos":[3085,3100]},{"content":"<ph id=\"ph1\">\\&lt;</ph>stdio.h&gt;","pos":[3155,3165],"source":"\\<stdio.h>"},{"pos":[3173,3297],"content":"For additional compatibility information, see <bpt id=\"p1\">[</bpt>Compatibility<ept id=\"p1\">](../../c-runtime-library/compatibility.md)</ept> in the Introduction.","source":"For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction."},{"pos":[3306,3315],"content":"Libraries","linkify":"Libraries","nodes":[{"content":"Libraries","pos":[0,9]}]},{"pos":[3319,3411],"content":"All versions of the <bpt id=\"p1\">[</bpt>C run-time libraries<ept id=\"p1\">](../../c-runtime-library/crt-library-features.md)</ept>.","source":"All versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md)."},{"pos":[3420,3427],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[4388,4413],"content":".NET Framework Equivalent","linkify":".NET Framework Equivalent","nodes":[{"content":".NET Framework Equivalent","pos":[0,25]}]},{"content":"Not applicable.","pos":[4417,4432]},{"content":"To call the standard C function, use <ph id=\"ph1\">`PInvoke`</ph>.","pos":[4433,4480],"source":" To call the standard C function, use `PInvoke`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Platform Invoke Examples<ept id=\"p1\">](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)</ept>.","pos":[4481,4606],"source":" For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f)."},{"pos":[4615,4623],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Stream I/O<ept id=\"p1\">](../../c-runtime-library/stream-i-o.md)</ept><ph id=\"ph1\"> </ph>","pos":[4627,4679],"source":"[Stream I/O](../../c-runtime-library/stream-i-o.md) "},{"content":"<bpt id=\"p1\"> [</bpt>fclose, _fcloseall<ept id=\"p1\">](../../c-runtime-library/reference/fclose-fcloseall.md)</ept><ph id=\"ph1\"> </ph>","pos":[4682,4759],"source":" [fclose, _fcloseall](../../c-runtime-library/reference/fclose-fcloseall.md) "},{"content":"<bpt id=\"p1\"> [</bpt>fflush<ept id=\"p1\">](../../c-runtime-library/reference/fflush.md)</ept><ph id=\"ph1\"> </ph>","pos":[4762,4817],"source":" [fflush](../../c-runtime-library/reference/fflush.md) "},{"content":"<bpt id=\"p1\"> [</bpt>fopen, _wfopen<ept id=\"p1\">](../../c-runtime-library/reference/fopen-wfopen.md)</ept><ph id=\"ph1\"> </ph>","pos":[4820,4889],"source":" [fopen, _wfopen](../../c-runtime-library/reference/fopen-wfopen.md) "},{"content":"<bpt id=\"p1\"> [</bpt>setbuf<ept id=\"p1\">](../../c-runtime-library/reference/setbuf.md)</ept>","pos":[4892,4946],"source":" [setbuf](../../c-runtime-library/reference/setbuf.md)"}],"content":"---\ntitle: \"setvbuf | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\napiname: \n  - \"setvbuf\"\napilocation: \n  - \"msvcrt.dll\"\n  - \"msvcr80.dll\"\n  - \"msvcr90.dll\"\n  - \"msvcr100.dll\"\n  - \"msvcr100_clr0400.dll\"\n  - \"msvcr110.dll\"\n  - \"msvcr110_clr0400.dll\"\n  - \"msvcr120.dll\"\n  - \"msvcr120_clr0400.dll\"\n  - \"ucrtbase.dll\"\n  - \"api-ms-win-crt-stdio-l1-1-0.dll\"\napitype: \"DLLExport\"\nf1_keywords: \n  - \"setvbuf\"\ndev_langs: \n  - \"C++\"\n  - \"C\"\nhelpviewer_keywords: \n  - \"controlling stream buffering\"\n  - \"stream buffering\"\n  - \"setvbuf function\"\nms.assetid: 6aa5aa37-3408-4fa0-992f-87f9f9c4baea\ncaps.latest.revision: 16\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# setvbuf\nControls stream buffering and buffer size.  \n  \n## Syntax  \n  \n```  \nint setvbuf(  \n   FILE *stream,  \n   char *buffer,  \n   int mode,  \n   size_t size   \n);  \n```  \n  \n#### Parameters  \n `stream`  \n Pointer to `FILE` structure.  \n  \n `buffer`  \n User-allocated buffer.  \n  \n `mode`  \n Mode of buffering.  \n  \n `size`  \n Buffer size in bytes. Allowable range: 2 <= `size` <= INT_MAX (2147483647). Internally, the value supplied for `size` is rounded down to the nearest multiple of 2.  \n  \n## Return Value  \n Returns 0 if successful.  \n  \n If `stream` is `NULL`, or if `mode` or `size` is not within a valid change, the invalid parameter handler is invoked, as described in [Parameter Validation](../../c-runtime-library/parameter-validation.md). If execution is allowed to continue, this function returns -1 and sets `errno` to `EINVAL`.  \n  \n For information on these and other error codes, see [_doserrno, errno, _sys_errlist, and _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).  \n  \n## Remarks  \n The `setvbuf` function allows the program to control both buffering and buffer size for `stream`. `stream` must refer to an open file that has not undergone an I/O operation since it was opened. The array pointed to by `buffer` is used as the buffer, unless it is `NULL`, in which case `setvbuf` uses an automatically allocated buffer of length `size`/2 * 2 bytes.  \n  \n The mode must be `_IOFBF`, `_IOLBF`, or `_IONBF`. If `mode` is `_IOFBF` or `_IOLBF`, then `size` is used as the size of the buffer. If `mode` is `_IONBF`, the stream is unbuffered and `size` and `buffer` are ignored. Values for `mode` and their meanings are:  \n  \n `_IOFBF`  \n Full buffering; that is, `buffer` is used as the buffer and `size` is used as the size of the buffer. If `buffer` is `NULL`, an automatically allocated buffer `size` bytes long is used.  \n  \n `_IOLBF`  \n For some systems, this provides line buffering. However, for Win32, the behavior is the same as `_IOFBF` - Full Buffering.  \n  \n `_IONBF`  \n No buffer is used, regardless of `buffer` or `size`.  \n  \n## Requirements  \n  \n|Routine|Required header|  \n|-------------|---------------------|  \n|`setvbuf`|\\<stdio.h>|  \n  \n For additional compatibility information, see [Compatibility](../../c-runtime-library/compatibility.md) in the Introduction.  \n  \n## Libraries  \n All versions of the [C run-time libraries](../../c-runtime-library/crt-library-features.md).  \n  \n## Example  \n  \n```  \n// crt_setvbuf.c  \n// This program opens two streams: stream1  \n// and stream2. It then uses setvbuf to give stream1 a  \n// user-defined buffer of 1024 bytes and stream2 no buffer.  \n//  \n  \n#include <stdio.h>  \n  \nint main( void )  \n{  \n   char buf[1024];  \n   FILE *stream1, *stream2;  \n  \n   if( fopen_s( &stream1, \"data1\", \"a\" ) == 0 &&  \n       fopen_s( &stream2, \"data2\", \"w\" ) == 0 )  \n   {  \n      if( setvbuf( stream1, buf, _IOFBF, sizeof( buf ) ) != 0 )  \n         printf( \"Incorrect type or size of buffer for stream1\\n\" );  \n      else  \n         printf( \"'stream1' now has a buffer of 1024 bytes\\n\" );  \n      if( setvbuf( stream2, NULL, _IONBF, 0 ) != 0 )  \n         printf( \"Incorrect type or size of buffer for stream2\\n\" );  \n      else  \n         printf( \"'stream2' now has no buffer\\n\" );  \n      _fcloseall();  \n   }  \n}  \n```  \n  \n```Output  \n'stream1' now has a buffer of 1024 bytes  \n'stream2' now has no buffer  \n```  \n  \n## .NET Framework Equivalent  \n Not applicable. To call the standard C function, use `PInvoke`. For more information, see [Platform Invoke Examples](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  \n  \n## See Also  \n [Stream I/O](../../c-runtime-library/stream-i-o.md)   \n [fclose, _fcloseall](../../c-runtime-library/reference/fclose-fcloseall.md)   \n [fflush](../../c-runtime-library/reference/fflush.md)   \n [fopen, _wfopen](../../c-runtime-library/reference/fopen-wfopen.md)   \n [setbuf](../../c-runtime-library/reference/setbuf.md)"}