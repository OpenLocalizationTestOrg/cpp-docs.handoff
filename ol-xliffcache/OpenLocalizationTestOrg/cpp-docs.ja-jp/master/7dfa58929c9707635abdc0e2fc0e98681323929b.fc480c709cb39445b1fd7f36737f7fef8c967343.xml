{"nodes":[{"pos":[12,72],"content":"How to: Create and Use unique_ptr Instances | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Create and Use unique_ptr Instances | Microsoft Docs","pos":[0,60]}]},{"content":"How to: Create and Use unique_ptr Instances","pos":[553,596]},{"content":"A <bpt id=\"p1\">[</bpt>unique_ptr<ept id=\"p1\">](../standard-library/unique-ptr-class.md)</ept> does not share its pointer.","pos":[597,680],"source":"A [unique_ptr](../standard-library/unique-ptr-class.md) does not share its pointer."},{"content":"It cannot be copied to another <ph id=\"ph1\">`unique_ptr`</ph>, passed by value to a function, or used in any Standard Template Library (STL) algorithm that requires copies to be made.","pos":[681,846],"source":" It cannot be copied to another `unique_ptr`, passed by value to a function, or used in any Standard Template Library (STL) algorithm that requires copies to be made."},{"content":"A <ph id=\"ph1\">`unique_ptr`</ph> can only be moved.","pos":[847,880],"source":" A `unique_ptr` can only be moved."},{"content":"This means that the ownership of the memory resource is transferred to another <ph id=\"ph1\">`unique_ptr`</ph> and the original <ph id=\"ph2\">`unique_ptr`</ph> no longer owns it.","pos":[881,1021],"source":" This means that the ownership of the memory resource is transferred to another `unique_ptr` and the original `unique_ptr` no longer owns it."},{"content":"We recommend that you restrict an object to one owner, because multiple ownership adds complexity to the program logic.","pos":[1022,1141]},{"content":"Therefore, when you need a smart pointer for a plain C++ object, use <ph id=\"ph1\">`unique_ptr`</ph>, and when you construct a <ph id=\"ph2\">`unique_ptr`</ph>, use the <bpt id=\"p1\">[</bpt>make_unique<ept id=\"p1\">](http://msdn.microsoft.com/Library/4b5fa0d6-fd1b-42b3-a35d-d71c3b6529f8)</ept> helper function.","pos":[1142,1374],"source":" Therefore, when you need a smart pointer for a plain C++ object, use `unique_ptr`, and when you construct a `unique_ptr`, use the [make_unique](http://msdn.microsoft.com/Library/4b5fa0d6-fd1b-42b3-a35d-d71c3b6529f8) helper function."},{"pos":[1381,1476],"content":"The following diagram illustrates the transfer of ownership between two <ph id=\"ph1\">`unique_ptr`</ph> instances.","source":"The following diagram illustrates the transfer of ownership between two `unique_ptr` instances."},{"content":"Moving the ownership of a unique&amp;#95;ptr","pos":[1485,1525],"source":"Moving the ownership of a unique&#95;ptr"},{"content":"is defined in the <ph id=\"ph1\">`&lt;memory&gt;`</ph> header in the STL.","pos":[1588,1635],"source":" is defined in the `<memory>` header in the STL."},{"content":"It is exactly is efficient as a raw pointer and can be used in STL containers.","pos":[1636,1714]},{"content":"The addition of <ph id=\"ph1\">`unique_ptr`</ph> instances to STL containers is efficient because the move constructor of the <ph id=\"ph2\">`unique_ptr`</ph> eliminates the need for a copy operation.","pos":[1715,1875],"source":" The addition of `unique_ptr` instances to STL containers is efficient because the move constructor of the `unique_ptr` eliminates the need for a copy operation."},{"content":"Example","pos":[1884,1891]},{"pos":[1895,1992],"content":"The following example shows how to create <ph id=\"ph1\">`unique_ptr`</ph> instances and pass them between functions.","source":"The following example shows how to create `unique_ptr` instances and pass them between functions."},{"pos":[2010,2032],"content":"stl_smart_pointers#210"},{"content":"These examples demonstrate this basic characteristic of <ph id=\"ph1\">`unique_ptr`</ph>: it can be moved, but not copied.","pos":[2114,2216],"source":"These examples demonstrate this basic characteristic of `unique_ptr`: it can be moved, but not copied."},{"content":"\"Moving\" transfers ownership to a new <ph id=\"ph1\">`unique_ptr`</ph> and resets the old <ph id=\"ph2\">`unique_ptr`</ph>.","pos":[2217,2300],"source":" \"Moving\" transfers ownership to a new `unique_ptr` and resets the old `unique_ptr`."},{"content":"Example","pos":[2309,2316]},{"pos":[2320,2410],"content":"The following example shows how to create <ph id=\"ph1\">`unique_ptr`</ph> instances and use them in a vector.","source":"The following example shows how to create `unique_ptr` instances and use them in a vector."},{"pos":[2428,2450],"content":"stl_smart_pointers#211"},{"content":"In the range for  loop, notice that the <ph id=\"ph1\">`unique_ptr`</ph> is passed by reference.","pos":[2532,2608],"source":"In the range for  loop, notice that the `unique_ptr` is passed by reference."},{"content":"If you try to pass by value here, the compiler will throw an error because the <ph id=\"ph1\">`unique_ptr`</ph> copy constructor is deleted.","pos":[2609,2729],"source":" If you try to pass by value here, the compiler will throw an error because the `unique_ptr` copy constructor is deleted."},{"content":"Example","pos":[2738,2745]},{"pos":[2749,2833],"content":"The following example shows how to initialize a <ph id=\"ph1\">`unique_ptr`</ph> that is a class member.","source":"The following example shows how to initialize a `unique_ptr` that is a class member."},{"pos":[2851,2873],"content":"stl_smart_pointers#212"},{"content":"Example","pos":[2957,2964]},{"pos":[2968,3170],"content":"You can use <bpt id=\"p1\">[</bpt>make_unique<ept id=\"p1\">](http://msdn.microsoft.com/Library/4b5fa0d6-fd1b-42b3-a35d-d71c3b6529f8)</ept> to create a <ph id=\"ph1\">`unique_ptr`</ph> to an array, but you cannot use <ph id=\"ph2\">`make_unique`</ph> to initialize the array elements.","source":"You can use [make_unique](http://msdn.microsoft.com/Library/4b5fa0d6-fd1b-42b3-a35d-d71c3b6529f8) to create a `unique_ptr` to an array, but you cannot use `make_unique` to initialize the array elements."},{"pos":[3188,3210],"content":"stl_smart_pointers#213"},{"pos":[3292,3401],"content":"For more examples, see <bpt id=\"p1\">[</bpt>make_unique<ept id=\"p1\">](http://msdn.microsoft.com/Library/4b5fa0d6-fd1b-42b3-a35d-d71c3b6529f8)</ept>.","source":"For more examples, see [make_unique](http://msdn.microsoft.com/Library/4b5fa0d6-fd1b-42b3-a35d-d71c3b6529f8)."},{"content":"See Also","pos":[3410,3418]},{"content":"Smart Pointers","pos":[3423,3437]},{"content":"make_unique","pos":[3481,3492]}],"content":"---\ntitle: \"How to: Create and Use unique_ptr Instances | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: 9a373030-e587-452f-b9a5-c5f9d58b7673\ncaps.latest.revision: 16\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# How to: Create and Use unique_ptr Instances\nA [unique_ptr](../standard-library/unique-ptr-class.md) does not share its pointer. It cannot be copied to another `unique_ptr`, passed by value to a function, or used in any Standard Template Library (STL) algorithm that requires copies to be made. A `unique_ptr` can only be moved. This means that the ownership of the memory resource is transferred to another `unique_ptr` and the original `unique_ptr` no longer owns it. We recommend that you restrict an object to one owner, because multiple ownership adds complexity to the program logic. Therefore, when you need a smart pointer for a plain C++ object, use `unique_ptr`, and when you construct a `unique_ptr`, use the [make_unique](http://msdn.microsoft.com/Library/4b5fa0d6-fd1b-42b3-a35d-d71c3b6529f8) helper function.  \n  \n The following diagram illustrates the transfer of ownership between two `unique_ptr` instances.  \n  \n ![Moving the ownership of a unique&#95;ptr](../cpp/media/unique_ptr.png \"unique_ptr\")  \n  \n `unique_ptr` is defined in the `<memory>` header in the STL. It is exactly is efficient as a raw pointer and can be used in STL containers. The addition of `unique_ptr` instances to STL containers is efficient because the move constructor of the `unique_ptr` eliminates the need for a copy operation.  \n  \n## Example  \n The following example shows how to create `unique_ptr` instances and pass them between functions.  \n  \n [!code-cpp[stl_smart_pointers#210](../cpp/codesnippet/CPP/how-to-create-and-use-unique-ptr-instances_1.cpp)]  \n  \n These examples demonstrate this basic characteristic of `unique_ptr`: it can be moved, but not copied. \"Moving\" transfers ownership to a new `unique_ptr` and resets the old `unique_ptr`.  \n  \n## Example  \n The following example shows how to create `unique_ptr` instances and use them in a vector.  \n  \n [!code-cpp[stl_smart_pointers#211](../cpp/codesnippet/CPP/how-to-create-and-use-unique-ptr-instances_2.cpp)]  \n  \n In the range for  loop, notice that the `unique_ptr` is passed by reference. If you try to pass by value here, the compiler will throw an error because the `unique_ptr` copy constructor is deleted.  \n  \n## Example  \n The following example shows how to initialize a `unique_ptr` that is a class member.  \n  \n [!code-cpp[stl_smart_pointers#212](../cpp/codesnippet/CPP/how-to-create-and-use-unique-ptr-instances_3.cpp)]  \n  \n## Example  \n You can use [make_unique](http://msdn.microsoft.com/Library/4b5fa0d6-fd1b-42b3-a35d-d71c3b6529f8) to create a `unique_ptr` to an array, but you cannot use `make_unique` to initialize the array elements.  \n  \n [!code-cpp[stl_smart_pointers#213](../cpp/codesnippet/CPP/how-to-create-and-use-unique-ptr-instances_4.cpp)]  \n  \n For more examples, see [make_unique](http://msdn.microsoft.com/Library/4b5fa0d6-fd1b-42b3-a35d-d71c3b6529f8).  \n  \n## See Also  \n [Smart Pointers](../cpp/smart-pointers-modern-cpp.md)   \n [make_unique](http://msdn.microsoft.com/Library/4b5fa0d6-fd1b-42b3-a35d-d71c3b6529f8)"}