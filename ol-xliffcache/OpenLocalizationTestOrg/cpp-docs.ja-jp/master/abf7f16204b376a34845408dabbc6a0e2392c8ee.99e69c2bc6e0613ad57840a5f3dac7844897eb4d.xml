{"nodes":[{"pos":[12,52],"content":"&lt;regex&gt; functions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>regex<ph id=\"ph2\">&amp;gt;</ph> functions | Microsoft Docs","pos":[0,40],"source":"&lt;regex&gt; functions | Microsoft Docs"}]},{"pos":[255,278],"content":"&lt;regex&gt; functions","linkify":"&lt;regex&gt; functions","nodes":[{"content":"<ph id=\"ph1\">&amp;lt;</ph>regex<ph id=\"ph2\">&amp;gt;</ph> functions","pos":[0,23],"source":"&lt;regex&gt; functions"}]},{"pos":[297,342],"content":"<bpt id=\"p1\">[</bpt>regex_match Function<ept id=\"p1\">](#regex_match_function)</ept>","source":"[regex_match Function](#regex_match_function)"},{"pos":[343,392],"content":"<bpt id=\"p1\">[</bpt>regex_replace Function<ept id=\"p1\">](#regex_replace_function)</ept>","source":"[regex_replace Function](#regex_replace_function)"},{"pos":[393,440],"content":"<bpt id=\"p1\">[</bpt>regex_search Function<ept id=\"p1\">](#regex_search_function)</ept>","source":"[regex_search Function](#regex_search_function)"},{"pos":[445,476],"content":"<bpt id=\"p1\">[</bpt>swap Function<ept id=\"p1\">](#swap_function)</ept>","source":"[swap Function](#swap_function)"},{"pos":[487,544],"content":"<bpt id=\"p1\">&lt;a name=\"regex_match_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_match Function","linkify":"<a name=\"regex_match_function\"></a>  regex_match Function","source":"<a name=\"regex_match_function\"></a>  regex_match Function"},{"content":"Tests whether a regular expression matches the entire target string.","pos":[548,616]},{"pos":[2274,2284],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type for submatches.","pos":[2299,2332]},{"content":"For common cases this one of string::const_iterator, wstring::const_iterator, const char* or const wchar_t<ph id=\"ph1\">\\*</ph>.","pos":[2333,2442],"source":" For common cases this one of string::const_iterator, wstring::const_iterator, const char* or const wchar_t\\*."},{"content":"The match results allocator class.","pos":[2460,2494]},{"content":"The type of elements to match.","pos":[2511,2541]},{"content":"For common cases this is string, wstring, char* or wchar_t<ph id=\"ph1\">\\*</ph>.","pos":[2542,2603],"source":" For common cases this is string, wstring, char* or wchar_t\\*."},{"content":"Traits class for elements.","pos":[2624,2650]},{"content":"The regular expression allocator class.","pos":[2669,2708]},{"content":"The string traits class.","pos":[2729,2753]},{"content":"The string allocator class.","pos":[2773,2800]},{"content":"Flags for matches.","pos":[2818,2836]},{"content":"Beginning of sequence to match.","pos":[2854,2885]},{"content":"End of sequence to match.","pos":[2902,2927]},{"content":"The match results.","pos":[2945,2963]},{"content":"Corresponds to Elem type: <bpt id=\"p1\">[</bpt>smatch<ept id=\"p1\">](../standard-library/regex-typedefs.md#smatch_typedef)</ept> for string, <bpt id=\"p2\">[</bpt>wsmatch<ept id=\"p2\">](../standard-library/regex-typedefs.md#wsmatch_typedef)</ept> for wstring, <bpt id=\"p3\">[</bpt>cmatch<ept id=\"p3\">](../standard-library/regex-typedefs.md#cmatch_typedef)</ept> for char* or <bpt id=\"p4\">[</bpt>wcmatch<ept id=\"p4\">](../standard-library/regex-typedefs.md#wcmatch_typedef)</ept> for wchar_t<ph id=\"ph1\">\\*</ph>.","pos":[2964,3298],"source":" Corresponds to Elem type: [smatch](../standard-library/regex-typedefs.md#smatch_typedef) for string, [wsmatch](../standard-library/regex-typedefs.md#wsmatch_typedef) for wstring, [cmatch](../standard-library/regex-typedefs.md#cmatch_typedef) for char* or [wcmatch](../standard-library/regex-typedefs.md#wcmatch_typedef) for wchar_t\\*."},{"content":"Pointer to beginning of sequence to match.","pos":[3314,3356]},{"content":"If ptr is char*, then use cmatch and regex.","pos":[3357,3400]},{"content":"If ptr is wchar_t<ph id=\"ph1\">\\*</ph> then use wcmatch and wregex.","pos":[3401,3449],"source":" If ptr is wchar_t\\* then use wcmatch and wregex."},{"content":"The regular expression to match.","pos":[3464,3496]},{"content":"Type <ph id=\"ph1\">`regex`</ph> for string and char*, or <ph id=\"ph2\">`wregex`</ph> for wstring and wchar_t<ph id=\"ph3\">\\*</ph>.","pos":[3497,3570],"source":" Type `regex` for string and char*, or `wregex` for wstring and wchar_t\\*."},{"content":"String to match.","pos":[3586,3602]},{"content":"Corresponds to the type of Elem.","pos":[3603,3635]},{"pos":[3645,3652],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Each template function returns true only if the entire operand sequence <ph id=\"ph1\">`str`</ph> exactly matches the regular expression argument <ph id=\"ph2\">`re`</ph>.","pos":[3656,3787],"source":"Each template function returns true only if the entire operand sequence `str` exactly matches the regular expression argument `re`."},{"content":"Use <bpt id=\"p1\">[</bpt>regex_search<ept id=\"p1\">](../standard-library/regex-functions.md#regex_search_function)</ept> to match a substring within a target sequence and regex_iterator to find multiple matches.","pos":[3788,3959],"source":" Use [regex_search](../standard-library/regex-functions.md#regex_search_function) to match a substring within a target sequence and regex_iterator to find multiple matches."},{"content":"The functions that take a <ph id=\"ph1\">`match_results`</ph> object set its members to reflect whether the match succeeded and if so what the various capture groups in the regular expression captured.","pos":[3960,4141],"source":" The functions that take a `match_results` object set its members to reflect whether the match succeeded and if so what the various capture groups in the regular expression captured."},{"pos":[4148,4329],"content":"The functions that take a <ph id=\"ph1\">`match_results`</ph> object set its members to reflect whether the match succeeded and if so what the various capture groups in the regular expression captured.","source":"The functions that take a `match_results` object set its members to reflect whether the match succeeded and if so what the various capture groups in the regular expression captured."},{"pos":[4336,4344],"content":"<bpt id=\"p1\">**</bpt>(1):<ept id=\"p1\">**</ept>","source":"**(1):**"},{"pos":[4354,4361],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[5836,5897],"content":"<bpt id=\"p1\">&lt;a name=\"regex_replace_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_replace Function","linkify":"<a name=\"regex_replace_function\"></a>  regex_replace Function","source":"<a name=\"regex_replace_function\"></a>  regex_replace Function"},{"content":"Replaces matched regular expressions.","pos":[5901,5938]},{"pos":[6507,6517],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type for replacements.","pos":[6532,6567]},{"content":"The iterator type for submatches.","pos":[6585,6618]},{"content":"Traits class for elements.","pos":[6639,6665]},{"content":"The regular expression allocator class.","pos":[6683,6722]},{"content":"The type of elements to match.","pos":[6739,6769]},{"content":"Flags for matches.","pos":[6787,6805]},{"content":"Beginning of sequence to match.","pos":[6823,6854]},{"content":"The format for replacements.","pos":[6870,6898]},{"content":"End of sequence to match.","pos":[6915,6940]},{"content":"The output iterator.","pos":[6956,6976]},{"content":"The regular expression to match.","pos":[6991,7023]},{"content":"String to match.","pos":[7039,7055]},{"pos":[7065,7072],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The first function constructs a <bpt id=\"p1\">[</bpt>regex_iterator Class<ept id=\"p1\">](../standard-library/regex-iterator-class.md)</ept> object <ph id=\"ph1\">`iter(first, last, re, flags)`</ph> and uses it to split its input range <ph id=\"ph2\">`[first, last)`</ph> into a series of subsequences <ph id=\"ph3\">`T0M0T1M1...TN-1MN-1TN`</ph>, where <ph id=\"ph4\">`Mn`</ph> is the <ph id=\"ph5\">`nth`</ph> match detected by the iterator.","pos":[7076,7377],"source":"The first function constructs a [regex_iterator Class](../standard-library/regex-iterator-class.md) object `iter(first, last, re, flags)` and uses it to split its input range `[first, last)` into a series of subsequences `T0M0T1M1...TN-1MN-1TN`, where `Mn` is the `nth` match detected by the iterator."},{"content":"If no matches are found, <ph id=\"ph1\">`T0`</ph> is the entire input range and <ph id=\"ph2\">`N`</ph> is zero.","pos":[7378,7450],"source":" If no matches are found, `T0` is the entire input range and `N` is zero."},{"content":"If <ph id=\"ph1\">`(flags &amp; format_first_only) != 0`</ph> only the first match is used, <ph id=\"ph2\">`T1`</ph> is all of the input text that follows the match, and <ph id=\"ph3\">`N`</ph> is 1.","pos":[7451,7586],"source":" If `(flags & format_first_only) != 0` only the first match is used, `T1` is all of the input text that follows the match, and `N` is 1."},{"content":"For each <ph id=\"ph1\">`i`</ph> in the range <ph id=\"ph2\">`[0, N)`</ph>, if <ph id=\"ph3\">`(flags &amp; format_no_copy) == 0`</ph> it copies the text in the range <ph id=\"ph4\">`Ti`</ph> to the iterator <ph id=\"ph5\">`out`</ph>.","pos":[7587,7717],"source":" For each `i` in the range `[0, N)`, if `(flags & format_no_copy) == 0` it copies the text in the range `Ti` to the iterator `out`."},{"content":"It then calls <ph id=\"ph1\">`m.format(out, fmt, flags)`</ph>, where <ph id=\"ph2\">`m`</ph> is the <ph id=\"ph3\">`match_results`</ph> object returned by the iterator object <ph id=\"ph4\">`iter`</ph> for the subsequence <ph id=\"ph5\">`Mi`</ph>.","pos":[7718,7865],"source":" It then calls `m.format(out, fmt, flags)`, where `m` is the `match_results` object returned by the iterator object `iter` for the subsequence `Mi`."},{"content":"Finally, if <ph id=\"ph1\">`(flags &amp; format_no_copy) == 0`</ph> it copies the text in the range <ph id=\"ph2\">`TN`</ph> to the iterator <ph id=\"ph3\">`out`</ph>.","pos":[7866,7969],"source":" Finally, if `(flags & format_no_copy) == 0` it copies the text in the range `TN` to the iterator `out`."},{"content":"The function returns <ph id=\"ph1\">`out`</ph>.","pos":[7970,7997],"source":" The function returns `out`."},{"content":"The second function constructs a local variable <ph id=\"ph1\">`result`</ph> of type <ph id=\"ph2\">`basic_string&lt;charT&gt;`</ph> and calls <ph id=\"ph3\">`regex_replace(back_inserter(result), str.begin(), str.end(), re, fmt, flags)`</ph>.","pos":[8004,8180],"source":"The second function constructs a local variable `result` of type `basic_string<charT>` and calls `regex_replace(back_inserter(result), str.begin(), str.end(), re, fmt, flags)`."},{"content":"It returns <ph id=\"ph1\">`result`</ph>.","pos":[8181,8201],"source":" It returns `result`."},{"pos":[8211,8218],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9309,9368],"content":"<bpt id=\"p1\">&lt;a name=\"regex_search_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  regex_search Function","linkify":"<a name=\"regex_search_function\"></a>  regex_search Function","source":"<a name=\"regex_search_function\"></a>  regex_search Function"},{"content":"Searches for a regular expression match.","pos":[9372,9412]},{"pos":[11008,11018],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The iterator type for submatches.","pos":[11033,11066]},{"content":"The match results allocator class.","pos":[11084,11118]},{"content":"The type of elements to match.","pos":[11135,11165]},{"content":"Traits class for elements.","pos":[11186,11212]},{"content":"The regular expression allocator class.","pos":[11231,11270]},{"content":"The string traits class.","pos":[11291,11315]},{"content":"The string allocator class.","pos":[11335,11362]},{"content":"Flags for matches.","pos":[11380,11398]},{"content":"Beginning of sequence to match.","pos":[11416,11447]},{"content":"End of sequence to match.","pos":[11464,11489]},{"content":"The match results.","pos":[11507,11525]},{"content":"Pointer to beginning of sequence to match.","pos":[11541,11583]},{"content":"The regular expression to match.","pos":[11598,11630]},{"content":"String to match.","pos":[11646,11662]},{"pos":[11672,11679],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Each template function returns true only if a search for its regular expression argument <ph id=\"ph1\">`re`</ph> in its operand sequence succeeds.","pos":[11683,11810],"source":"Each template function returns true only if a search for its regular expression argument `re` in its operand sequence succeeds."},{"content":"The functions that take a <ph id=\"ph1\">`match_results`</ph> object set its members to reflect whether the search succeeded and if so what the various capture groups in the regular expression captured.","pos":[11811,11993],"source":" The functions that take a `match_results` object set its members to reflect whether the search succeeded and if so what the various capture groups in the regular expression captured."},{"pos":[12003,12010],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[13794,13837],"content":"<bpt id=\"p1\">&lt;a name=\"swap_function\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  swap Function","linkify":"<a name=\"swap_function\"></a>  swap Function","source":"<a name=\"swap_function\"></a>  swap Function"},{"content":"Swaps two basic_regex or match_results objects.","pos":[13841,13888]},{"pos":[14229,14239],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The type of elements to match.","pos":[14253,14283]},{"content":"Traits class for elements.","pos":[14304,14330]},{"pos":[14340,14347],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The template functions swap the contents of their respective arguments in constant time and do not throw exceptions.","pos":[14351,14467]},{"pos":[14477,14484],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[15190,15198],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[15202,15242],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>regex&gt;<ept id=\"p1\">](../standard-library/regex.md)</ept>","source":"[\\<regex>](../standard-library/regex.md)"}],"content":"---\ntitle: \"&lt;regex&gt; functions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 91a8314b-6f7c-4e33-b7d6-d8583dd75585\ncaps.latest.revision: 12\nmanager: \"ghogen\"\n---\n# &lt;regex&gt; functions\n||||  \n|-|-|-|  \n|[regex_match Function](#regex_match_function)|[regex_replace Function](#regex_replace_function)|[regex_search Function](#regex_search_function)|  \n|[swap Function](#swap_function)|  \n  \n##  <a name=\"regex_match_function\"></a>  regex_match Function  \n Tests whether a regular expression matches the entire target string.  \n  \n```  \n \n// (1)   \ntemplate <class BidIt, class Alloc, class Elem, class RXtraits, class Alloc2>  \nbool regex_match(\n    BidIt first, \n    Bidit last,  \n    match_results<BidIt, Alloc>& match,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re,   \n    match_flag_type flags = match_default);\n\n \n// (2)   \ntemplate <class BidIt, class Elem, class RXtraits, class Alloc2>  \nbool regex_match(\n    BidIt first, \n    Bidit last,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re,  \n    match_flag_type flags = match_default);\n\n \n// (3)  \ntemplate <class Elem, class Alloc, class RXtraits, class Alloc2>  \nbool regex_match(\n    const Elem *ptr,  \n    match_results<const Elem*, Alloc>& match,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re,  \n    match_flag_type flags = match_default);\n\n \n// (4)   \ntemplate <class Elem, class RXtraits, class Alloc2>  \nbool regex_match(\n    const Elem *ptr,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re,  \n    match_flag_type flags = match_default);\n\n \n// (5)  \ntemplate <class IOtraits, class IOalloc, class Alloc, class Elem, class RXtraits, class Alloc2>  \nbool regex_match(\n    const basic_string<Elem, IOtraits, IOalloc>& str,  \n    match_results<typename basic_string<Elem, IOtraits, IOalloc>::const_iterator, Alloc>& match,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re, \n    match_flag_type flags = match_default);\n \n// (6)  \ntemplate <class IOtraits, class IOalloc, class Elem, class RXtraits, class Alloc2>  \nbool regex_match(\n    const basic_string<Elem, IOtraits, IOalloc>& str,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re,  \n    match_flag_type flags = match_default);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type for submatches. For common cases this one of string::const_iterator, wstring::const_iterator, const char* or const wchar_t\\*.  \n  \n `Alloc`  \n The match results allocator class.  \n  \n `Elem`  \n The type of elements to match. For common cases this is string, wstring, char* or wchar_t\\*.  \n  \n `RXtraits`  \n Traits class for elements.  \n  \n `Alloc2`  \n The regular expression allocator class.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `IOalloc`  \n The string allocator class.  \n  \n `flags`  \n Flags for matches.  \n  \n `first`  \n Beginning of sequence to match.  \n  \n `last`  \n End of sequence to match.  \n  \n `match`  \n The match results. Corresponds to Elem type: [smatch](../standard-library/regex-typedefs.md#smatch_typedef) for string, [wsmatch](../standard-library/regex-typedefs.md#wsmatch_typedef) for wstring, [cmatch](../standard-library/regex-typedefs.md#cmatch_typedef) for char* or [wcmatch](../standard-library/regex-typedefs.md#wcmatch_typedef) for wchar_t\\*.  \n  \n `ptr`  \n Pointer to beginning of sequence to match. If ptr is char*, then use cmatch and regex. If ptr is wchar_t\\* then use wcmatch and wregex.  \n  \n `re`  \n The regular expression to match. Type `regex` for string and char*, or `wregex` for wstring and wchar_t\\*.  \n  \n `str`  \n String to match. Corresponds to the type of Elem.  \n  \n### Remarks  \n Each template function returns true only if the entire operand sequence `str` exactly matches the regular expression argument `re`. Use [regex_search](../standard-library/regex-functions.md#regex_search_function) to match a substring within a target sequence and regex_iterator to find multiple matches. The functions that take a `match_results` object set its members to reflect whether the match succeeded and if so what the various capture groups in the regular expression captured.  \n  \n The functions that take a `match_results` object set its members to reflect whether the match succeeded and if so what the various capture groups in the regular expression captured.  \n  \n **(1):**  \n  \n### Example  \n  \n```cpp  \n  \n#include \"stdafx.h\"  \n#include <regex>   \n#include <iostream>   \n  \nusing namespace std;  \n  \nint _tmain(int argc, _TCHAR* argv[])  \n{  \n  \n    // (1) with char*  \n    // Note how const char* requires cmatch and regex  \n    const char *first = \"abc\";  \n    const char *last = first + strlen(first);  \n    cmatch narrowMatch;  \n    regex rx(\"a(b)c\");  \n  \n    bool found = regex_match(first, last, narrowMatch, rx);  \n  \n    // (1) with std::wstring  \n    // Note how wstring requires wsmatch and wregex.  \n    // Note use of const iterators cbegin() and cend().  \n    wstring target(L\"Hello\");  \n    wsmatch wideMatch;  \n    wregex wrx(L\"He(l+)o\");  \n  \n    if (regex_match(target.cbegin(), target.cend(), wideMatch, wrx))  \n        wcout << L\"The matching text is:\" << wideMatch.str() << endl;   \n  \n    // (2) with std::string  \n    string target2(\"Drizzle\");  \n    regex rx2(R\"(D\\w+e)\"); // no double backslashes with raw string literal  \n    found = regex_match(target2.cbegin(), target2.cend(), rx2);  \n  \n    // (3) with wchar_t*  \n    const wchar_t* target3 = L\"2014-04-02\";  \n    wcmatch wideMatch2;  \n  \n    // LR\"(...)\" is a  raw wide-string literal. Open and close parens  \n    // are delimiters, not string elements.  \n    wregex wrx2(LR\"(\\d{4}(-|/)\\d{2}(-|/)\\d{2})\");   \n    if (regex_match(target3, wideMatch2, wrx2))  \n    {  \n        wcout << L\"Matching text: \" << wideMatch2.str() << endl;  \n    }  \n  \n     return 0;  \n}  \n  \n```  \n  \n##  <a name=\"regex_replace_function\"></a>  regex_replace Function  \n Replaces matched regular expressions.  \n  \n```  \ntemplate <class OutIt, class BidIt, class RXtraits, class Alloc, class Elem>  \nOutIt regex_replace(\n    OutIt out,  \n    BidIt first, \n    BidIt last,  \n    const basic_regex<Elem, RXtraits, Alloc>& re,  \n    const basic_string<Elem>& fmt,  \n    match_flag_type flags = match_default);\n\ntemplate <class RXtraits, class Alloc, class Elem>  \nbasic_string<Elem> regex_replace(\n    const basic_string<Elem>& str,  \n    const basic_regex<Elem, RXtraits, Alloc>& re,  \n    const basic_string<Elem>& fmt,  \n    match_flag_type flags = match_default);\n```  \n  \n### Parameters  \n `OutIt`  \n The iterator type for replacements.  \n  \n `BidIt`  \n The iterator type for submatches.  \n  \n `RXtraits`  \n Traits class for elements.  \n  \n `Alloc`  \n The regular expression allocator class.  \n  \n `Elem`  \n The type of elements to match.  \n  \n `flags`  \n Flags for matches.  \n  \n `first`  \n Beginning of sequence to match.  \n  \n `fmt`  \n The format for replacements.  \n  \n `last`  \n End of sequence to match.  \n  \n `out`  \n The output iterator.  \n  \n `re`  \n The regular expression to match.  \n  \n `str`  \n String to match.  \n  \n### Remarks  \n The first function constructs a [regex_iterator Class](../standard-library/regex-iterator-class.md) object `iter(first, last, re, flags)` and uses it to split its input range `[first, last)` into a series of subsequences `T0M0T1M1...TN-1MN-1TN`, where `Mn` is the `nth` match detected by the iterator. If no matches are found, `T0` is the entire input range and `N` is zero. If `(flags & format_first_only) != 0` only the first match is used, `T1` is all of the input text that follows the match, and `N` is 1. For each `i` in the range `[0, N)`, if `(flags & format_no_copy) == 0` it copies the text in the range `Ti` to the iterator `out`. It then calls `m.format(out, fmt, flags)`, where `m` is the `match_results` object returned by the iterator object `iter` for the subsequence `Mi`. Finally, if `(flags & format_no_copy) == 0` it copies the text in the range `TN` to the iterator `out`. The function returns `out`.  \n  \n The second function constructs a local variable `result` of type `basic_string<charT>` and calls `regex_replace(back_inserter(result), str.begin(), str.end(), re, fmt, flags)`. It returns `result`.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_replace.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    char buf[20];   \n    const char *first = \"axayaz\";   \n    const char *last = first + strlen(first);   \n    std::regex rx(\"a\");   \n    std::string fmt(\"A\");   \n    std::regex_constants::match_flag_type fonly =   \n        std::regex_constants::format_first_only;   \n  \n *std::regex_replace(&buf[0], first, last, rx, fmt) = '\\0';   \n    std::cout << \"replacement == \" << &buf[0] << std::endl;   \n  \n *std::regex_replace(&buf[0], first, last, rx, fmt, fonly) = '\\0';   \n    std::cout << \"replacement == \" << &buf[0] << std::endl;   \n  \n    std::string str(\"adaeaf\");   \n    std::cout << \"replacement == \"   \n        << std::regex_replace(str, rx, fmt) << std::endl;   \n  \n    std::cout << \"replacement == \"   \n        << std::regex_replace(str, rx, fmt, fonly) << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nreplacement == AxAyAz  \nreplacement == Axayaz  \nreplacement == AdAeAf  \nreplacement == Adaeaf  \n```  \n  \n##  <a name=\"regex_search_function\"></a>  regex_search Function  \n Searches for a regular expression match.  \n  \n```  \ntemplate <class BidIt, class Alloc, class Elem, class RXtraits, class Alloc2>  \nbool regex_search(\n    BidIt first, \n    Bidit last,  \n    match_results<BidIt, Alloc>& match,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re,  \n    match_flag_type flags = match_default);\n\ntemplate <class BidIt, class Elem, class RXtraits, class Alloc2>  \nbool regex_search(\n    BidIt first, \n    Bidit last,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re,  \n    match_flag_type flags = match_default);\n\ntemplate <class Elem, class Alloc, class RXtraits, class Alloc2>  \nbool regex_search(\n    const Elem* ptr,  \n    match_results<const Elem*, Alloc>& match,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re,  \n    match_flag_type flags = match_default);\n\ntemplate <class Elem, class RXtraits, class Alloc2>  \nbool regex_search(\n    const Elem* ptr,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re,  \n    match_flag_type flags = match_default);\n\ntemplate <class IOtraits, class IOalloc, class Alloc, class Elem, class RXtraits, class Alloc2>  \nbool regex_search(\n    const basic_string<Elem, IOtraits, IOalloc>& str,  \n    match_results<typename basic_string<Elem, IOtraits, IOalloc>::const_iterator, Alloc>& match,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re,  \n    match_flag_type flags = match_default);\n\ntemplate <class IOtraits, class IOalloc, class Elem, class RXtraits, class Alloc2>  \nbool regex_search(\n    const basic_string<Elem, IOtraits, IOalloc>& str,  \n    const basic_regex<Elem, RXtraits, Alloc2>& re,  \n    match_flag_type flags = match_default);\n```  \n  \n### Parameters  \n `BidIt`  \n The iterator type for submatches.  \n  \n `Alloc`  \n The match results allocator class.  \n  \n `Elem`  \n The type of elements to match.  \n  \n `RXtraits`  \n Traits class for elements.  \n  \n `Alloc2`  \n The regular expression allocator class.  \n  \n `IOtraits`  \n The string traits class.  \n  \n `IOalloc`  \n The string allocator class.  \n  \n `flags`  \n Flags for matches.  \n  \n `first`  \n Beginning of sequence to match.  \n  \n `last`  \n End of sequence to match.  \n  \n `match`  \n The match results.  \n  \n `ptr`  \n Pointer to beginning of sequence to match.  \n  \n `re`  \n The regular expression to match.  \n  \n `str`  \n String to match.  \n  \n### Remarks  \n Each template function returns true only if a search for its regular expression argument `re` in its operand sequence succeeds. The functions that take a `match_results` object set its members to reflect whether the search succeeded and if so what the various capture groups in the regular expression captured.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__regex_search.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    const char *first = \"abcd\";   \n    const char *last = first + strlen(first);   \n    std::cmatch mr;   \n    std::regex rx(\"abc\");   \n    std::regex_constants::match_flag_type fl =   \n        std::regex_constants::match_default;   \n  \n    std::cout << \"search(f, f+1, \\\"abc\\\") == \" << std::boolalpha   \n        << regex_search(first, first + 1, rx, fl) << std::endl;   \n  \n    std::cout << \"search(f, l, \\\"abc\\\") == \" << std::boolalpha   \n        << regex_search(first, last, mr, rx) << std::endl;   \n    std::cout << \"  matched: \\\"\" << mr.str() << \"\\\"\" << std::endl;   \n  \n    std::cout << \"search(\\\"a\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_search(\"a\", rx) << std::endl;   \n  \n    std::cout << \"search(\\\"xabcd\\\", \\\"abc\\\") == \" << std::boolalpha   \n        << regex_search(\"xabcd\", mr, rx) << std::endl;   \n    std::cout << \"  matched: \\\"\" << mr.str() << \"\\\"\" << std::endl;   \n  \n    std::cout << \"search(string, \\\"abc\\\") == \" << std::boolalpha   \n        << regex_search(std::string(\"a\"), rx) << std::endl;   \n  \n    std::string str(\"abcabc\");   \n    std::match_results<std::string::const_iterator> mr2;   \n    std::cout << \"search(string, \\\"abc\\\") == \" << std::boolalpha   \n        << regex_search(str, mr2, rx) << std::endl;   \n    std::cout << \"  matched: \\\"\" << mr2.str() << \"\\\"\" << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nsearch(f, f+1, \"abc\") == false  \nsearch(f, l, \"abc\") == true  \n  matched: \"abc\"  \nsearch(\"a\", \"abc\") == false  \nsearch(\"xabcd\", \"abc\") == true  \n  matched: \"abc\"  \nsearch(string, \"abc\") == false  \nsearch(string, \"abc\") == true  \n  matched: \"abc\"  \n```  \n  \n##  <a name=\"swap_function\"></a>  swap Function  \n Swaps two basic_regex or match_results objects.  \n  \n```  \ntemplate <class Elem, class RXtraits>  \nvoid swap(\n    basic_regex<Elem, RXtraits, Alloc>& left,  \n    basic_regex<Elem, RXtraits>& right) throw();\n\ntemplate <class Elem, class IOtraits, class BidIt, class Alloc>  \nvoid swap(\n    match_results<BidIt, Alloc>& left,  \n    match_results<BidIt, Alloc>& right) throw();\n```  \n  \n### Parameters  \n `Elem`  \n The type of elements to match.  \n  \n `RXtraits`  \n Traits class for elements.  \n  \n### Remarks  \n The template functions swap the contents of their respective arguments in constant time and do not throw exceptions.  \n  \n### Example  \n  \n```cpp  \n// std_tr1__regex__swap.cpp   \n// compile with: /EHsc   \n#include <regex>   \n#include <iostream>   \n  \nint main()   \n    {   \n    std::regex rx0(\"c(a*)|(b)\");   \n    std::regex rx1;   \n    std::cmatch mr0;   \n    std::cmatch mr1;   \n  \n    swap(rx0, rx1);   \n    std::regex_search(\"xcaaay\", mr1, rx1);   \n    swap(mr0, mr1);   \n  \n    std::csub_match sub = mr0[1];   \n    std::cout << \"matched == \" << std::boolalpha   \n        << sub.matched << std::endl;   \n    std::cout << \"length == \" << sub.length() << std::endl;   \n    std::cout << \"string == \" << sub << std::endl;   \n  \n    return (0);   \n    }  \n  \n```  \n  \n```Output  \nmatched == true  \nlength == 3  \nstring == aaa  \n```  \n  \n## See Also  \n [\\<regex>](../standard-library/regex.md)\n\n"}