{"nodes":[{"pos":[12,54],"content":"Initializing Non-MFC DLLs | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Initializing Non-MFC DLLs | Microsoft Docs","pos":[0,42]}]},{"content":"Initializing Non-MFC DLLs","pos":[631,656]},{"content":"To initialize non-MFC DLLs, your DLL source code must contain a function called <ph id=\"ph1\">`DllMain`</ph>.","pos":[657,747],"source":"To initialize non-MFC DLLs, your DLL source code must contain a function called `DllMain`."},{"content":"The following code presents a basic skeleton showing what the definition of <ph id=\"ph1\">`DllMain`</ph> might look like:","pos":[748,850],"source":" The following code presents a basic skeleton showing what the definition of `DllMain` might look like:"},{"pos":[1243,1775],"content":"[!NOTE]\n The [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)] documentation for **DllEntryPoint** says that the actual name of the entry-point function must be specified on the linker command-line with the /ENTRY option. With Visual C++, you do not need to use the /ENTRY option if the name of your entry-point function is `DllMain`. In fact, if you do use the /ENTRY option and name your entry-point function something other than `DllMain`, the C run-time library will not get initialized properly.","leadings":["","> "],"nodes":[{"content":" The [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)] documentation for **DllEntryPoint** says that the actual name of the entry-point function must be specified on the linker command-line with the /ENTRY option. With Visual C++, you do not need to use the /ENTRY option if the name of your entry-point function is `DllMain`. In fact, if you do use the /ENTRY option and name your entry-point function something other than `DllMain`, the C run-time library will not get initialized properly.","pos":[8,530],"nodes":[{"content":"The <ph id=\"ph1\">[!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]</ph> documentation for <bpt id=\"p1\">**</bpt>DllEntryPoint<ept id=\"p1\">**</ept> says that the actual name of the entry-point function must be specified on the linker command-line with the /ENTRY option.","pos":[1,243],"source":" The [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)] documentation for **DllEntryPoint** says that the actual name of the entry-point function must be specified on the linker command-line with the /ENTRY option."},{"content":"With Visual C++, you do not need to use the /ENTRY option if the name of your entry-point function is <ph id=\"ph1\">`DllMain`</ph>.","pos":[244,356],"source":" With Visual C++, you do not need to use the /ENTRY option if the name of your entry-point function is `DllMain`."},{"content":"In fact, if you do use the /ENTRY option and name your entry-point function something other than <ph id=\"ph1\">`DllMain`</ph>, the C run-time library will not get initialized properly.","pos":[357,522],"source":" In fact, if you do use the /ENTRY option and name your entry-point function something other than `DllMain`, the C run-time library will not get initialized properly."}]}]},{"content":"What do you want to know more about?","pos":[1784,1820]},{"content":"The function specification for DllMain (Windows SDK)","pos":[1831,1883]},{"content":"Dynamic-link library entry-point function (Windows SDK)","pos":[1955,2010]},{"content":"The C run-time library behavior and _DllMainCRTStartup","pos":[2082,2136]},{"content":"See Also","pos":[2185,2193]},{"content":"Initializing a DLL","pos":[2198,2216]}],"content":"---\ntitle: \"Initializing Non-MFC DLLs | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"non-MFC DLLs [C++]\"\n  - \"initializing DLLs\"\n  - \"DLLs [C++], non-MFC\"\nms.assetid: 2622b32a-28f9-4d61-9e46-6c19aaf8b7ad\ncaps.latest.revision: 8\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Initializing Non-MFC DLLs\nTo initialize non-MFC DLLs, your DLL source code must contain a function called `DllMain`. The following code presents a basic skeleton showing what the definition of `DllMain` might look like:  \n  \n```  \nBOOL APIENTRY DllMain(HANDLE hModule,   \n                      DWORD  ul_reason_for_call,   \n                      LPVOID lpReserved)  \n{  \n    switch( ul_reason_for_call ) {  \n    case DLL_PROCESS_ATTACH:  \n    ...  \n    case DLL_THREAD_ATTACH:  \n    ...  \n    case DLL_THREAD_DETACH:  \n    ...  \n    case DLL_PROCESS_DETACH:  \n    ...  \n    }  \n    return TRUE;  \n}  \n```  \n  \n> [!NOTE]\n>  The [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)] documentation for **DllEntryPoint** says that the actual name of the entry-point function must be specified on the linker command-line with the /ENTRY option. With Visual C++, you do not need to use the /ENTRY option if the name of your entry-point function is `DllMain`. In fact, if you do use the /ENTRY option and name your entry-point function something other than `DllMain`, the C run-time library will not get initialized properly.  \n  \n## What do you want to know more about?  \n  \n-   [The function specification for DllMain (Windows SDK)](http://msdn.microsoft.com/library/windows/desktop/ms682583)  \n  \n-   [Dynamic-link library entry-point function (Windows SDK)](http://msdn.microsoft.com/library/windows/desktop/ms682596)  \n  \n-   [The C run-time library behavior and _DllMainCRTStartup](../build/run-time-library-behavior.md)  \n  \n## See Also  \n [Initializing a DLL](../build/initializing-a-dll.md)"}