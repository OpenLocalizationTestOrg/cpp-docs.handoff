{"nodes":[{"pos":[12,93],"content":"Windows Runtime and Managed Templates (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Windows Runtime and Managed Templates (C++ Component Extensions) | Microsoft Docs","pos":[0,81]}]},{"content":"Windows Runtime and Managed Templates (C++ Component Extensions)","pos":[639,703]},{"content":"Templates enable you to define a prototype of a Windows Runtime or common language runtime type, and then instantiate variations of that type by using different template type parameters.","pos":[704,890]},{"content":"All Runtimes","pos":[899,911]},{"content":"You can create templates from value or reference types.","pos":[915,970]},{"content":"For more information about creating value or reference types, see <bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](../windows/classes-and-structs-cpp-component-extensions.md)</ept>.","pos":[972,1120],"source":"  For more information about creating value or reference types, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md)."},{"pos":[1127,1233],"content":"For more information about standard C++ class templates, see <bpt id=\"p1\">[</bpt>Class Templates<ept id=\"p1\">](../cpp/class-templates.md)</ept>.","source":"For more information about standard C++ class templates, see [Class Templates](../cpp/class-templates.md)."},{"content":"Windows Runtime","pos":[1242,1257]},{"content":"(There are no remarks for this language feature that apply to only the Windows Runtime.)","pos":[1261,1349]},{"content":"Requirements","pos":[1359,1371]},{"pos":[1375,1399],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Common Language Runtime","pos":[1408,1431]},{"content":"There are some limitations to creating class templates from managed types, which are demonstrated in the following code examples.","pos":[1435,1564]},{"content":"Requirements","pos":[1574,1586]},{"pos":[1590,1615],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[1625,1633]},{"content":"Example","pos":[1639,1646]},{"content":"It is possible to instantiate a generic type with a managed type template parameter, but you cannot instantiate a managed template with a generic type template parameter.","pos":[1655,1825]},{"content":"This is because generic types are resolved at runtime.","pos":[1827,1881]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Generics and Templates (Visual C++)<ept id=\"p1\">](../windows/generics-and-templates-visual-cpp.md)</ept>.","pos":[1883,1996],"source":"  For more information, see [Generics and Templates (Visual C++)](../windows/generics-and-templates-visual-cpp.md)."},{"content":"Example","pos":[2374,2381]},{"content":"A generic type or function cannot be nested in a managed template.","pos":[2390,2456]},{"content":"Example","pos":[2637,2644]},{"content":"You cannot access templates defined in a referenced assembly with C++/CLI language syntax, but you can use reflection.","pos":[2653,2771]},{"content":"If a template is not instantiated, it’s not emitted in the metadata.","pos":[2773,2841]},{"content":"If a template is instantiated, only referenced member functions will appear in metadata.","pos":[2843,2931]},{"content":"Example","pos":[3533,3540]},{"content":"You can change the managed modifier of a class in a partial specialization or explicit specialization of a class template.","pos":[3549,3671]},{"content":"See Also","pos":[4135,4143]},{"content":"Component Extensions for Runtime Platforms","pos":[4148,4190]}],"content":"---\ntitle: \"Windows Runtime and Managed Templates (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"templates, with CLR types\"\nms.assetid: cf59d16b-5514-448b-9a95-e0b4fcb616a6\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Windows Runtime and Managed Templates (C++ Component Extensions)\nTemplates enable you to define a prototype of a Windows Runtime or common language runtime type, and then instantiate variations of that type by using different template type parameters.  \n  \n## All Runtimes  \n You can create templates from value or reference types.  For more information about creating value or reference types, see [Classes and Structs](../windows/classes-and-structs-cpp-component-extensions.md).  \n  \n For more information about standard C++ class templates, see [Class Templates](../cpp/class-templates.md).  \n  \n## Windows Runtime  \n (There are no remarks for this language feature that apply to only the Windows Runtime.)  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## Common Language Runtime  \n There are some limitations to creating class templates from managed types, which are demonstrated in the following code examples.  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n It is possible to instantiate a generic type with a managed type template parameter, but you cannot instantiate a managed template with a generic type template parameter.  This is because generic types are resolved at runtime.  For more information, see [Generics and Templates (Visual C++)](../windows/generics-and-templates-visual-cpp.md).  \n  \n```cpp  \n// managed_templates.cpp  \n// compile with: /clr /c  \n  \ngeneric<class T>   \nref class R;   \n  \ntemplate<class T>   \nref class Z {  \n   // Instantiate a generic with a template parameter.  \n   R<T>^ r;    // OK  \n};  \n  \ngeneric<class T>   \nref class R {  \n   // Cannot instantiate a template with a generic parameter.  \n   Z<T>^ z;   // C3231  \n};  \n```  \n  \n **Example**  \n  \n A generic type or function cannot be nested in a managed template.  \n  \n```cpp  \n// managed_templates_2.cpp  \n// compile with: /clr /c  \n  \ntemplate<class T> public ref class R {  \n   generic<class T> ref class W {};   // C2959  \n};  \n```  \n  \n **Example**  \n  \n You cannot access templates defined in a referenced assembly with C++/CLI language syntax, but you can use reflection.  If a template is not instantiated, it’s not emitted in the metadata.  If a template is instantiated, only referenced member functions will appear in metadata.  \n  \n```cpp  \n// managed_templates_3.cpp  \n// compile with: /clr  \n  \n// Will not appear in metadata.  \ntemplate<class T> public ref class A {};  \n  \n// Will appear in metadata as a specialized type.  \ntemplate<class T> public ref class R {  \npublic:  \n   // Test is referenced, will appear in metadata  \n   void Test() {}  \n  \n   // Test2 is not referenced, will not appear in metadata  \n   void Test2() {}  \n};  \n  \n// Will appear in metadata.  \ngeneric<class T> public ref class G { };  \n  \npublic ref class S { };  \n  \nint main() {  \n   R<int>^ r = gcnew R<int>;  \n   r->Test();  \n}  \n```  \n  \n **Example**  \n  \n You can change the managed modifier of a class in a partial specialization or explicit specialization of a class template.  \n  \n```cpp  \n// managed_templates_4.cpp  \n// compile with: /clr /c  \n  \n// class template  \n// ref class  \ntemplate <class T>  \nref class A {};  \n  \n// partial template specialization  \n// value type  \ntemplate <class T>  \nvalue class A <T *> {};  \n  \n// partial template specialization  \n// interface  \ntemplate <class T>   \ninterface class A<T%> {};  \n  \n// explicit template specialization  \n// native class  \ntemplate <>  \nclass A <int> {};  \n  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}