{"nodes":[{"pos":[12,63],"content":"TN021: Command and Message Routing | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN021: Command and Message Routing | Microsoft Docs","pos":[0,51]}]},{"content":"TN021: Command and Message Routing","pos":[697,731]},{"pos":[734,1049],"content":"[!NOTE]\n The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","leadings":["","> "],"nodes":[{"content":" The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[8,313],"nodes":[{"content":"The following technical note has not been updated since it was first included in the online documentation.","pos":[1,107]},{"content":"As a result, some procedures and topics might be out of date or incorrect.","pos":[108,182]},{"content":"For the latest information, it is recommended that you search for the topic of interest in the online documentation index.","pos":[183,305]}]}]},{"content":"This note describes the command routing and dispatch architecture as well as advanced topics in general window message routing.","pos":[1056,1183]},{"content":"Please refer to Visual C++ for general details on the architectures described here, especially the distinction between Windows messages, control notifications, and commands.","pos":[1190,1363]},{"content":"This note assumes you are very familiar with the issues described in the printed documentation and only addresses very advanced topics.","pos":[1364,1499]},{"content":"Command Routing and Dispatch MFC 1.0 Functionality Evolves to MFC 2.0 Architecture","pos":[1508,1590]},{"pos":[1594,1745],"content":"Windows has the <bpt id=\"p1\">**</bpt>WM_COMMAND<ept id=\"p1\">**</ept> message that is overloaded to provide notifications of menu commands, accelerator keys and dialog-control notifications.","source":"Windows has the **WM_COMMAND** message that is overloaded to provide notifications of menu commands, accelerator keys and dialog-control notifications."},{"content":"MFC 1.0 built on that a little by allowing a command handler (for example, \"OnFileNew\") in a <bpt id=\"p1\">**</bpt>CWnd<ept id=\"p1\">**</ept> derived class to get called in response to a specific <bpt id=\"p2\">**</bpt>WM_COMMAND<ept id=\"p2\">**</ept>.","pos":[1752,1923],"source":"MFC 1.0 built on that a little by allowing a command handler (for example, \"OnFileNew\") in a **CWnd** derived class to get called in response to a specific **WM_COMMAND**."},{"content":"This is glued together with a data structure called the message map, and results in a very space-efficient command mechanism.","pos":[1924,2049]},{"content":"MFC 1.0 also provided additional functionality for separating control notifications from command messages.","pos":[2056,2162]},{"content":"Commands are represented by a 16-bit ID, sometimes known as a Command ID.","pos":[2163,2236]},{"content":"Commands normally start from a <bpt id=\"p1\">**</bpt>CFrameWnd<ept id=\"p1\">**</ept> (that is, a menu select or a translated accelerator) and get routed to a variety of other windows.","pos":[2237,2380],"source":" Commands normally start from a **CFrameWnd** (that is, a menu select or a translated accelerator) and get routed to a variety of other windows."},{"content":"MFC 1.0 used command routing in a limited sense for the implementation of Multiple Document Interface (MDI).","pos":[2387,2495]},{"content":"(An MDI frame window delegate commands to its active MDI Child window.)","pos":[2496,2567]},{"content":"This functionality has been generalized and extended in MFC 2.0 to allow commands to be handled by a wider range of objects (not just window objects).","pos":[2574,2724]},{"content":"It provides a more formal and extensible architecture for routing messages and reuses the command target routing for not only handling of commands, but also for updating UI objects (like menu items and toolbar buttons) to reflect the current availability of a command.","pos":[2725,2993]},{"content":"Command IDs","pos":[3002,3013]},{"content":"See Visual C++ for an explanation of the command routing and binding process.","pos":[3017,3094]},{"content":"<bpt id=\"p1\">[</bpt>Technical Note 20<ept id=\"p1\">](../mfc/tn020-id-naming-and-numbering-conventions.md)</ept> contains information on ID naming.","pos":[3095,3202],"source":"[Technical Note 20](../mfc/tn020-id-naming-and-numbering-conventions.md) contains information on ID naming."},{"content":"We use the generic prefix \"ID_\" for command IDs.","pos":[3209,3257]},{"content":"Command IDs are &gt;= 0x8000.","pos":[3258,3284],"source":" Command IDs are >= 0x8000."},{"content":"The message line or status bar will show the command description string if there is a STRINGTABLE resource with the same IDs as the command ID.","pos":[3285,3428]},{"content":"In the resources of your application, a command ID can appears in several places:","pos":[3435,3516]},{"content":"In one STRINGTABLE resource that has the same ID as the message-line prompt.","pos":[3526,3602]},{"content":"In possibly many MENU resources that are attached to menu items that invoke the same command.","pos":[3612,3705]},{"content":"(ADVANCED) in a dialog button for a GOSUB command.","pos":[3715,3765]},{"content":"In the source code of your application, a command ID can appears in several places:","pos":[3772,3855]},{"content":"In your RESOURCE.H (or other main symbol header file) to define application-specific command IDs.","pos":[3865,3962]},{"content":"PERHAPS In an ID array used to create a toolbar.","pos":[3972,4020]},{"pos":[4030,4057],"content":"In an <bpt id=\"p1\">**</bpt>ON_COMMAND<ept id=\"p1\">**</ept> macro.","source":"In an **ON_COMMAND** macro."},{"pos":[4067,4112],"content":"PERHAPS In an <bpt id=\"p1\">**</bpt>ON_UPDATE_COMMAND_UI<ept id=\"p1\">**</ept> macro.","source":"PERHAPS In an **ON_UPDATE_COMMAND_UI** macro."},{"content":"Currently, the only implementation in MFC that requires command IDs be &gt;= 0x8000 is the implementation of GOSUB dialogs/commands.","pos":[4119,4248],"source":"Currently, the only implementation in MFC that requires command IDs be >= 0x8000 is the implementation of GOSUB dialogs/commands."},{"content":"GOSUB Commands, Using Command Architecture in Dialogs","pos":[4257,4310]},{"content":"The command architecture of routing and enabling commands works well with frame windows, menu items, toolbar buttons, dialog bar buttons, other control bars and other user-interface elements designed to update on demand and route commands or control IDs to a main command target (usually the main frame window).","pos":[4314,4625]},{"content":"That main command target may route the command or control notifications to other command target objects as appropriate.","pos":[4626,4745]},{"content":"A dialog (modal or modeless) can benefit from some of the features of the command architecture if you assign the control ID of the dialog control to the appropriate command ID.","pos":[4752,4928]},{"content":"Support for dialogs is not automatic, so you may have to write some additional code.","pos":[4929,5013]},{"content":"Note that for all these features to work properly, your command IDs should be &gt;= 0x8000.","pos":[5020,5108],"source":"Note that for all these features to work properly, your command IDs should be >= 0x8000."},{"content":"Since many dialogs could get routed to the same frame, shared commands should be &gt;= 0x8000, while the nonshared IDCs in a specific dialog should be &lt;= 0x7FFF.","pos":[5109,5267],"source":" Since many dialogs could get routed to the same frame, shared commands should be >= 0x8000, while the nonshared IDCs in a specific dialog should be <= 0x7FFF."},{"content":"You can place a normal button in a normal modal dialog with the IDC of the button set to the appropriate command ID.","pos":[5274,5390]},{"content":"When the user selects the button, the owner of the dialog (usually the main frame window) gets the command just like any other command.","pos":[5391,5526]},{"content":"This is called a GOSUB command since it usually is used to bring up another dialog (a GOSUB of the first dialog).","pos":[5527,5640]},{"content":"You can also call the function <bpt id=\"p1\">**</bpt>CWnd::UpdateDialogControls<ept id=\"p1\">**</ept> on your dialog and pass it the address of your main frame window.","pos":[5647,5774],"source":"You can also call the function **CWnd::UpdateDialogControls** on your dialog and pass it the address of your main frame window."},{"content":"This function will enable or disable your dialog controls based on whether they have command handlers in the frame.","pos":[5775,5890]},{"content":"This function is called automatically for you for control bars in your application's idle loop, but you must call it directly for normal dialogs that you wish to have this feature.","pos":[5891,6071]},{"content":"When ON_UPDATE_COMMAND_UI is Called","pos":[6080,6115]},{"content":"Maintaining the enabled/checked state of all a program's menu items all the time can be a computationally expensive problem.","pos":[6119,6243]},{"content":"A common technique is to enable/check menu items only when the user selects the POPUP.","pos":[6244,6330]},{"content":"The MFC 2.0 implementation of <bpt id=\"p1\">**</bpt>CFrameWnd<ept id=\"p1\">**</ept> handles the <bpt id=\"p2\">**</bpt>WM_INITMENUPOPUP<ept id=\"p2\">**</ept> message and uses the command routing architecture to determine the states of menus through <bpt id=\"p3\">**</bpt>ON_UPDATE_COMMAND_UI<ept id=\"p3\">**</ept> handlers.","pos":[6331,6533],"source":" The MFC 2.0 implementation of **CFrameWnd** handles the **WM_INITMENUPOPUP** message and uses the command routing architecture to determine the states of menus through **ON_UPDATE_COMMAND_UI** handlers."},{"pos":[6540,6690],"content":"<bpt id=\"p1\">**</bpt>CFrameWnd<ept id=\"p1\">**</ept> also handles the <bpt id=\"p2\">**</bpt>WM_ENTERIDLE<ept id=\"p2\">**</ept> message to describe the current menu item selected on the status bar (also known as the message line).","source":"**CFrameWnd** also handles the **WM_ENTERIDLE** message to describe the current menu item selected on the status bar (also known as the message line)."},{"content":"An application's menu structure, edited by Visual C++, is used to represent the potential commands available at <bpt id=\"p1\">**</bpt>WM_INITMENUPOPUP<ept id=\"p1\">**</ept> time.","pos":[6697,6835],"source":"An application's menu structure, edited by Visual C++, is used to represent the potential commands available at **WM_INITMENUPOPUP** time."},{"content":"<bpt id=\"p1\">**</bpt>ON_UPDATE_COMMAND_UI<ept id=\"p1\">**</ept> handlers can modify the state or text of a menu, or for advanced uses (like the File MRU list or the OLE Verbs pop-up menu), actually modify the menu structure before the menu is drawn.","pos":[6836,7046],"source":"**ON_UPDATE_COMMAND_UI** handlers can modify the state or text of a menu, or for advanced uses (like the File MRU list or the OLE Verbs pop-up menu), actually modify the menu structure before the menu is drawn."},{"content":"The same sort of <bpt id=\"p1\">**</bpt>ON_UPDATE_COMMAND_UI<ept id=\"p1\">**</ept> processing is done for toolbars (and other control bars) when the application enters its idle loop.","pos":[7053,7194],"source":"The same sort of **ON_UPDATE_COMMAND_UI** processing is done for toolbars (and other control bars) when the application enters its idle loop."},{"content":"See the <bpt id=\"p1\">*</bpt>Class Library Reference<ept id=\"p1\">*</ept> and <bpt id=\"p2\">[</bpt>Technical Note 31<ept id=\"p2\">](../mfc/tn031-control-bars.md)</ept> for more information on control bars.","pos":[7195,7320],"source":" See the *Class Library Reference* and [Technical Note 31](../mfc/tn031-control-bars.md) for more information on control bars."},{"content":"Nested Pop-up Menus","pos":[7329,7348]},{"pos":[7352,7528],"content":"If you are using a nested menu structure, you will notice that the <bpt id=\"p1\">**</bpt>ON_UPDATE_COMMAND_UI<ept id=\"p1\">**</ept> handler for the first menu item in the pop-up menu is called in two different cases.","source":"If you are using a nested menu structure, you will notice that the **ON_UPDATE_COMMAND_UI** handler for the first menu item in the pop-up menu is called in two different cases."},{"content":"First, it is called for the pop-up menu itself.","pos":[7535,7582]},{"content":"This is necessary because pop-up menus do not have IDs and we use the ID of the first menu item of the pop-up menu to refer to the entire pop-up menu.","pos":[7583,7733]},{"content":"In this case, the <bpt id=\"p1\">**</bpt>m_pSubMenu<ept id=\"p1\">**</ept> member variable of the <bpt id=\"p2\">**</bpt>CCmdUI<ept id=\"p2\">**</ept> object will be non-NULL and will point to the pop-up menu.","pos":[7734,7859],"source":" In this case, the **m_pSubMenu** member variable of the **CCmdUI** object will be non-NULL and will point to the pop-up menu."},{"content":"Second, it is called just before the menu items in the pop-up menu are to be drawn.","pos":[7866,7949]},{"content":"In this case, the ID refers just to the first menu item and the <bpt id=\"p1\">**</bpt>m_pSubMenu<ept id=\"p1\">**</ept> member variable of the <bpt id=\"p2\">**</bpt>CCmdUI<ept id=\"p2\">**</ept> object will be NULL.","pos":[7950,8083],"source":" In this case, the ID refers just to the first menu item and the **m_pSubMenu** member variable of the **CCmdUI** object will be NULL."},{"content":"This allows you to enable the pop-up menu distinct from its menu items, but requires that you write some menu aware code.","pos":[8090,8211]},{"content":"For example, in a nested menu with the following structure:","pos":[8212,8271]},{"content":"The ID_NEW_SHEET and ID_NEW_CHART commands can be independently enabled or disabled.","pos":[8365,8449]},{"content":"The <bpt id=\"p1\">**</bpt>New<ept id=\"p1\">**</ept> pop-up menu should be enabled if either of the two is enabled.","pos":[8450,8524],"source":" The **New** pop-up menu should be enabled if either of the two is enabled."},{"content":"The command handler for ID_NEW_SHEET (the first command in the pop-up) would look something like:","pos":[8531,8628]},{"content":"The command handler for ID_NEW_CHART would be a normal update command handler and look something like:","pos":[9188,9290]},{"content":"ON_COMMAND and ON_BN_CLICKED","pos":[9409,9437]},{"content":"The message map macros for <bpt id=\"p1\">**</bpt>ON_COMMAND<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>ON_BN_CLICKED<ept id=\"p2\">**</ept> are the same.","pos":[9441,9518],"source":"The message map macros for **ON_COMMAND** and **ON_BN_CLICKED** are the same."},{"content":"The MFC command and control notification routing mechanism only uses the command ID to decide where to route to.","pos":[9519,9631]},{"content":"Control notifications with control notification code of zero (<bpt id=\"p1\">**</bpt>BN_CLICKED<ept id=\"p1\">**</ept>) are interpreted as commands.","pos":[9632,9738],"source":" Control notifications with control notification code of zero (**BN_CLICKED**) are interpreted as commands."},{"pos":[9746,10155],"content":"[!NOTE]\n In fact, all control notification messages go through the command handler chain. For example, it is technically possible for you to write a control notification handler for **EN_CHANGE** in your document class. This is not generally advisable because the practical applications of this feature are few, the feature is not supported by ClassWizard, and use of the feature can result in fragile code.","leadings":["","> "],"nodes":[{"content":" In fact, all control notification messages go through the command handler chain. For example, it is technically possible for you to write a control notification handler for **EN_CHANGE** in your document class. This is not generally advisable because the practical applications of this feature are few, the feature is not supported by ClassWizard, and use of the feature can result in fragile code.","pos":[8,407],"nodes":[{"content":"In fact, all control notification messages go through the command handler chain.","pos":[1,81]},{"content":"For example, it is technically possible for you to write a control notification handler for <bpt id=\"p1\">**</bpt>EN_CHANGE<ept id=\"p1\">**</ept> in your document class.","pos":[82,211],"source":" For example, it is technically possible for you to write a control notification handler for **EN_CHANGE** in your document class."},{"content":"This is not generally advisable because the practical applications of this feature are few, the feature is not supported by ClassWizard, and use of the feature can result in fragile code.","pos":[212,399]}]}]},{"content":"Disabling the Automatic Disabling of Button Controls","pos":[10164,10216]},{"content":"If you place a button control on a dialog bar, or in a dialog using where you are calling <bpt id=\"p1\">**</bpt>CWnd::UpdateDialogControls<ept id=\"p1\">**</ept> on your own, you will notice that buttons which do not have <bpt id=\"p2\">**</bpt>ON_COMMAND<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>ON_UPDATE_COMMAND_UI<ept id=\"p3\">**</ept> handlers will be automatically disabled for you by the framework.","pos":[10220,10509],"source":"If you place a button control on a dialog bar, or in a dialog using where you are calling **CWnd::UpdateDialogControls** on your own, you will notice that buttons which do not have **ON_COMMAND** or **ON_UPDATE_COMMAND_UI** handlers will be automatically disabled for you by the framework."},{"content":"In some cases, you will not need to have a handler, but you will want the button to remain enabled.","pos":[10510,10609]},{"content":"The easiest way to achieve this is to add a dummy command handler (easy to do with ClassWizard) and do nothing in it.","pos":[10610,10727]},{"content":"Window Message Routing","pos":[10736,10758]},{"content":"The following describes some more advanced topics on the MFC classes and how Windows message routing and other topics impact them.","pos":[10762,10892]},{"content":"The information here is only described briefly.","pos":[10893,10940]},{"content":"Refer to the <bpt id=\"p1\">*</bpt>Class Library Reference<ept id=\"p1\">*</ept> for details about public APIs.","pos":[10941,11010],"source":" Refer to the *Class Library Reference* for details about public APIs."},{"content":"Please refer to the MFC library source code for more information on implementation details.","pos":[11011,11102]},{"pos":[11109,11275],"content":"Please refer to <bpt id=\"p1\">[</bpt>Technical Note 17<ept id=\"p1\">](../mfc/tn017-destroying-window-objects.md)</ept> for details on Window cleanup, a very important topic for all <bpt id=\"p2\">**</bpt>CWnd<ept id=\"p2\">**</ept>-derived classes.","source":"Please refer to [Technical Note 17](../mfc/tn017-destroying-window-objects.md) for details on Window cleanup, a very important topic for all **CWnd**-derived classes."},{"content":"CWnd Issues","pos":[11284,11295]},{"content":"The implementation member function <bpt id=\"p1\">**</bpt>CWnd::OnChildNotify<ept id=\"p1\">**</ept> provides a powerful and extensible architecture for child windows (also known as controls) to hook or otherwise be informed of messages, commands, and control notifications that go to their parent (or \"owner\").","pos":[11299,11568],"source":"The implementation member function **CWnd::OnChildNotify** provides a powerful and extensible architecture for child windows (also known as controls) to hook or otherwise be informed of messages, commands, and control notifications that go to their parent (or \"owner\")."},{"content":"If the child window (/control) is a C++ <bpt id=\"p1\">**</bpt>CWnd<ept id=\"p1\">**</ept> object itself, the virtual function <bpt id=\"p2\">**</bpt>OnChildNotify<ept id=\"p2\">**</ept> is called first with the parameters from the original message (that is, a <bpt id=\"p3\">**</bpt>MSG<ept id=\"p3\">**</ept> structure).","pos":[11569,11765],"source":" If the child window (/control) is a C++ **CWnd** object itself, the virtual function **OnChildNotify** is called first with the parameters from the original message (that is, a **MSG** structure)."},{"content":"The child window can leave the message alone, eat it, or modify the message for the parent (rare).","pos":[11766,11864]},{"pos":[11871,12039],"content":"The default <bpt id=\"p1\">**</bpt>CWnd<ept id=\"p1\">**</ept> implementation handles the following messages and uses the <bpt id=\"p2\">**</bpt>OnChildNotify<ept id=\"p2\">**</ept> hook to allow child windows (controls) to first access at the message:","source":"The default **CWnd** implementation handles the following messages and uses the **OnChildNotify** hook to allow child windows (controls) to first access at the message:"},{"pos":[12047,12101],"content":"<bpt id=\"p1\">**</bpt>WM_MEASUREITEM<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>WM_DRAWITEM<ept id=\"p2\">**</ept> (for self-draw)","source":"**WM_MEASUREITEM** and **WM_DRAWITEM** (for self-draw)"},{"pos":[12109,12165],"content":"<bpt id=\"p1\">**</bpt>WM_COMPAREITEM<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>WM_DELETEITEM<ept id=\"p2\">**</ept> (for self-draw)","source":"**WM_COMPAREITEM** and **WM_DELETEITEM** (for self-draw)"},{"pos":[12173,12206],"content":"<bpt id=\"p1\">**</bpt>WM_HSCROLL<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>WM_VSCROLL<ept id=\"p2\">**</ept>","source":"**WM_HSCROLL** and **WM_VSCROLL**"},{"content":"WM_CTLCOLOR","pos":[12216,12227]},{"content":"WM_PARENTNOTIFY","pos":[12239,12254]},{"pos":[12263,12371],"content":"You will notice the <bpt id=\"p1\">**</bpt>OnChildNotify<ept id=\"p1\">**</ept> hook is used for changing owner-draw messages into self-draw messages.","source":"You will notice the **OnChildNotify** hook is used for changing owner-draw messages into self-draw messages."},{"content":"In addition to the <bpt id=\"p1\">**</bpt>OnChildNotify<ept id=\"p1\">**</ept> hook, scroll messages have further routing behavior.","pos":[12378,12467],"source":"In addition to the **OnChildNotify** hook, scroll messages have further routing behavior."},{"content":"Please see below for more details on scroll bars and sources of <bpt id=\"p1\">**</bpt>WM_HSCROLL<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>WM_VSCROLL<ept id=\"p2\">**</ept> messages.","pos":[12468,12575],"source":" Please see below for more details on scroll bars and sources of **WM_HSCROLL** and **WM_VSCROLL** messages."},{"content":"CFrameWnd Issues","pos":[12584,12600]},{"content":"The <bpt id=\"p1\">**</bpt>CFrameWnd<ept id=\"p1\">**</ept> class provides most of the command routing and user-interface updating implementation.","pos":[12604,12708],"source":"The **CFrameWnd** class provides most of the command routing and user-interface updating implementation."},{"content":"This is primarily used for the main frame window of the application (<bpt id=\"p1\">**</bpt>CWinApp::m_pMainWnd<ept id=\"p1\">**</ept>) but applies to all frame windows.","pos":[12709,12836],"source":" This is primarily used for the main frame window of the application (**CWinApp::m_pMainWnd**) but applies to all frame windows."},{"content":"The main frame window is the window with the menu bar and is the parent of the status bar or message line.","pos":[12843,12949]},{"content":"Please refer to the above discussion on command routing and <bpt id=\"p1\">**</bpt>WM_INITMENUPOPUP.<ept id=\"p1\">**</ept>","pos":[12950,13031],"source":" Please refer to the above discussion on command routing and **WM_INITMENUPOPUP.**"},{"content":"The <bpt id=\"p1\">**</bpt>CFrameWnd<ept id=\"p1\">**</ept> class provides management of the active view.","pos":[13038,13101],"source":"The **CFrameWnd** class provides management of the active view."},{"content":"The following messages are routed through the active view:","pos":[13102,13160]},{"content":"All command messages (the active view gets first access to them).","pos":[13170,13235]},{"pos":[13243,13323],"content":"<bpt id=\"p1\">**</bpt>WM_HSCROLL<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>WM_VSCROLL<ept id=\"p2\">**</ept> messages from sibling scroll bars (see below).","source":"**WM_HSCROLL** and **WM_VSCROLL** messages from sibling scroll bars (see below)."},{"pos":[13331,13452],"content":"<bpt id=\"p1\">**</bpt>WM_ACTIVATE<ept id=\"p1\">**</ept> (and <bpt id=\"p2\">**</bpt>WM_MDIACTIVATE<ept id=\"p2\">**</ept> for MDI) get turned into calls to the virtual function <bpt id=\"p3\">**</bpt>CView::OnActivateView<ept id=\"p3\">**</ept>.","source":"**WM_ACTIVATE** (and **WM_MDIACTIVATE** for MDI) get turned into calls to the virtual function **CView::OnActivateView**."},{"content":"CMDIFrameWnd/CMDIChildWnd Issues","pos":[13461,13493]},{"content":"Both MDI frame window classes derive from <bpt id=\"p1\">**</bpt>CFrameWnd<ept id=\"p1\">**</ept> and therefore are both enabled for the same sort of command routing and user-interface updating provided in <bpt id=\"p2\">**</bpt>CFrameWnd<ept id=\"p2\">**</ept>.","pos":[13497,13675],"source":"Both MDI frame window classes derive from **CFrameWnd** and therefore are both enabled for the same sort of command routing and user-interface updating provided in **CFrameWnd**."},{"content":"In a typical MDI application, only the main frame window (that is, the <bpt id=\"p1\">**</bpt>CMDIFrameWnd<ept id=\"p1\">**</ept> object) holds the menu bar and the status bar and therefore is the main source of the command routing implementation.","pos":[13676,13881],"source":" In a typical MDI application, only the main frame window (that is, the **CMDIFrameWnd** object) holds the menu bar and the status bar and therefore is the main source of the command routing implementation."},{"content":"The general routing scheme is that the active MDI child window gets first access to commands.","pos":[13888,13981]},{"content":"The default <bpt id=\"p1\">**</bpt>PreTranslateMessage<ept id=\"p1\">**</ept> functions handle accelerator tables for both MDI child windows (first) and the MDI frame (second) as well as the standard MDI system-command accelerators normally handled by <bpt id=\"p2\">**</bpt>TranslateMDISysAccel<ept id=\"p2\">**</ept> (last).","pos":[13982,14224],"source":" The default **PreTranslateMessage** functions handle accelerator tables for both MDI child windows (first) and the MDI frame (second) as well as the standard MDI system-command accelerators normally handled by **TranslateMDISysAccel** (last)."},{"content":"Scroll Bar Issues","pos":[14233,14250]},{"content":"When handling scroll-message (<bpt id=\"p1\">**</bpt>WM_HSCROLL<ept id=\"p1\">**</ept><ph id=\"ph1\">/</ph><bpt id=\"p2\">**</bpt>OnHScroll<ept id=\"p2\">**</ept> and/or <bpt id=\"p3\">**</bpt>WM_VSCROLL<ept id=\"p3\">**</ept><ph id=\"ph2\">/</ph><bpt id=\"p4\">**</bpt>OnVScroll<ept id=\"p4\">**</ept>), you should try to write the handler code so it does not rely on where the scroll bar message came from.","pos":[14254,14454],"source":"When handling scroll-message (**WM_HSCROLL**/**OnHScroll** and/or **WM_VSCROLL**/**OnVScroll**), you should try to write the handler code so it does not rely on where the scroll bar message came from."},{"content":"This is not only a general Windows issue, since scroll messages can come from true scroll bar controls or from <bpt id=\"p1\">**</bpt>WS_HSCROLL<ept id=\"p1\">**</ept><ph id=\"ph1\">/</ph><bpt id=\"p2\">**</bpt>WS_VSCROLL<ept id=\"p2\">**</ept> scroll bars which are not scroll bar controls.","pos":[14455,14642],"source":" This is not only a general Windows issue, since scroll messages can come from true scroll bar controls or from **WS_HSCROLL**/**WS_VSCROLL** scroll bars which are not scroll bar controls."},{"content":"MFC extends that to allow for scroll bar controls to be either child or siblings of the window being scrolled (in fact, the parent/child relationship between the scroll bar and window being scrolled can be anything).","pos":[14649,14865]},{"content":"This is especially important for shared scroll bars with splitter windows.","pos":[14866,14940]},{"content":"Please refer to <bpt id=\"p1\">[</bpt>Technical Note 29<ept id=\"p1\">](../mfc/tn029-splitter-windows.md)</ept> for details on the implementation of <bpt id=\"p2\">**</bpt>CSplitterWnd<ept id=\"p2\">**</ept> including more information on shared scroll bar issues.","pos":[14941,15120],"source":" Please refer to [Technical Note 29](../mfc/tn029-splitter-windows.md) for details on the implementation of **CSplitterWnd** including more information on shared scroll bar issues."},{"content":"On a side note, there are two <bpt id=\"p1\">**</bpt>CWnd<ept id=\"p1\">**</ept> derived classes where the scroll bar styles specified at create time are trapped and not passed to Windows.","pos":[15127,15273],"source":"On a side note, there are two **CWnd** derived classes where the scroll bar styles specified at create time are trapped and not passed to Windows."},{"content":"When passed to a creation routine, <bpt id=\"p1\">**</bpt>WS_HSCROLL<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>WS_VSCROLL<ept id=\"p2\">**</ept> can be independently set, but after creation cannot be changed.","pos":[15274,15406],"source":" When passed to a creation routine, **WS_HSCROLL** and **WS_VSCROLL** can be independently set, but after creation cannot be changed."},{"content":"Of course, you should not directly test or set the WS_SCROLL style bits of the window that they created.","pos":[15407,15511]},{"content":"For <bpt id=\"p1\">**</bpt>CMDIFrameWnd<ept id=\"p1\">**</ept> the scroll bar styles you pass in to <bpt id=\"p2\">**</bpt>Create<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>LoadFrame<ept id=\"p3\">**</ept> are used to create the MDICLIENT.","pos":[15518,15637],"source":"For **CMDIFrameWnd** the scroll bar styles you pass in to **Create** or **LoadFrame** are used to create the MDICLIENT."},{"content":"If you wish to have a scrollable MDICLIENT area (like the Windows Program Manager) be sure to set both scroll bar styles (<bpt id=\"p1\">**</bpt>WS_HSCROLL<ept id=\"p1\">**</ept> &amp;#124; <bpt id=\"p2\">**</bpt>WS_VSCROLL<ept id=\"p2\">**</ept>) for the style used to create the <bpt id=\"p3\">**</bpt>CMDIFrameWnd<ept id=\"p3\">**</ept>.","pos":[15638,15848],"source":" If you wish to have a scrollable MDICLIENT area (like the Windows Program Manager) be sure to set both scroll bar styles (**WS_HSCROLL** &#124; **WS_VSCROLL**) for the style used to create the **CMDIFrameWnd**."},{"content":"For <bpt id=\"p1\">**</bpt>CSplitterWnd<ept id=\"p1\">**</ept> the scroll bar styles apply to the special shared scroll bars for the splitter regions.","pos":[15855,15963],"source":"For **CSplitterWnd** the scroll bar styles apply to the special shared scroll bars for the splitter regions."},{"content":"For static splitter windows, you will normally not set either scroll bar style.","pos":[15964,16043]},{"content":"For dynamic splitter windows, you will usually have the scroll bar style set for the direction you will split, That is, <bpt id=\"p1\">**</bpt>WS_HSCROLL<ept id=\"p1\">**</ept> if you can split rows, <bpt id=\"p2\">**</bpt>WS_VSCROLL<ept id=\"p2\">**</ept> if you can split columns.","pos":[16044,16242],"source":" For dynamic splitter windows, you will usually have the scroll bar style set for the direction you will split, That is, **WS_HSCROLL** if you can split rows, **WS_VSCROLL** if you can split columns."},{"content":"See Also","pos":[16251,16259]},{"content":"Technical Notes by Number","pos":[16264,16289]},{"content":"Technical Notes by Category","pos":[16333,16360]}],"content":"---\ntitle: \"TN021: Command and Message Routing | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.routing\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"TN021\"\n  - \"command routing [C++], technical note TN021\"\n  - \"Windows messages [C++], routing\"\nms.assetid: b5952c8b-123e-406c-a36d-a6ac7c6df307\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN021: Command and Message Routing\n> [!NOTE]\n>  The following technical note has not been updated since it was first included in the online documentation. As a result, some procedures and topics might be out of date or incorrect. For the latest information, it is recommended that you search for the topic of interest in the online documentation index.  \n  \n This note describes the command routing and dispatch architecture as well as advanced topics in general window message routing.  \n  \n Please refer to Visual C++ for general details on the architectures described here, especially the distinction between Windows messages, control notifications, and commands. This note assumes you are very familiar with the issues described in the printed documentation and only addresses very advanced topics.  \n  \n## Command Routing and Dispatch MFC 1.0 Functionality Evolves to MFC 2.0 Architecture  \n Windows has the **WM_COMMAND** message that is overloaded to provide notifications of menu commands, accelerator keys and dialog-control notifications.  \n  \n MFC 1.0 built on that a little by allowing a command handler (for example, \"OnFileNew\") in a **CWnd** derived class to get called in response to a specific **WM_COMMAND**. This is glued together with a data structure called the message map, and results in a very space-efficient command mechanism.  \n  \n MFC 1.0 also provided additional functionality for separating control notifications from command messages. Commands are represented by a 16-bit ID, sometimes known as a Command ID. Commands normally start from a **CFrameWnd** (that is, a menu select or a translated accelerator) and get routed to a variety of other windows.  \n  \n MFC 1.0 used command routing in a limited sense for the implementation of Multiple Document Interface (MDI). (An MDI frame window delegate commands to its active MDI Child window.)  \n  \n This functionality has been generalized and extended in MFC 2.0 to allow commands to be handled by a wider range of objects (not just window objects). It provides a more formal and extensible architecture for routing messages and reuses the command target routing for not only handling of commands, but also for updating UI objects (like menu items and toolbar buttons) to reflect the current availability of a command.  \n  \n## Command IDs  \n See Visual C++ for an explanation of the command routing and binding process. [Technical Note 20](../mfc/tn020-id-naming-and-numbering-conventions.md) contains information on ID naming.  \n  \n We use the generic prefix \"ID_\" for command IDs. Command IDs are >= 0x8000. The message line or status bar will show the command description string if there is a STRINGTABLE resource with the same IDs as the command ID.  \n  \n In the resources of your application, a command ID can appears in several places:  \n  \n-   In one STRINGTABLE resource that has the same ID as the message-line prompt.  \n  \n-   In possibly many MENU resources that are attached to menu items that invoke the same command.  \n  \n-   (ADVANCED) in a dialog button for a GOSUB command.  \n  \n In the source code of your application, a command ID can appears in several places:  \n  \n-   In your RESOURCE.H (or other main symbol header file) to define application-specific command IDs.  \n  \n-   PERHAPS In an ID array used to create a toolbar.  \n  \n-   In an **ON_COMMAND** macro.  \n  \n-   PERHAPS In an **ON_UPDATE_COMMAND_UI** macro.  \n  \n Currently, the only implementation in MFC that requires command IDs be >= 0x8000 is the implementation of GOSUB dialogs/commands.  \n  \n## GOSUB Commands, Using Command Architecture in Dialogs  \n The command architecture of routing and enabling commands works well with frame windows, menu items, toolbar buttons, dialog bar buttons, other control bars and other user-interface elements designed to update on demand and route commands or control IDs to a main command target (usually the main frame window). That main command target may route the command or control notifications to other command target objects as appropriate.  \n  \n A dialog (modal or modeless) can benefit from some of the features of the command architecture if you assign the control ID of the dialog control to the appropriate command ID. Support for dialogs is not automatic, so you may have to write some additional code.  \n  \n Note that for all these features to work properly, your command IDs should be >= 0x8000. Since many dialogs could get routed to the same frame, shared commands should be >= 0x8000, while the nonshared IDCs in a specific dialog should be <= 0x7FFF.  \n  \n You can place a normal button in a normal modal dialog with the IDC of the button set to the appropriate command ID. When the user selects the button, the owner of the dialog (usually the main frame window) gets the command just like any other command. This is called a GOSUB command since it usually is used to bring up another dialog (a GOSUB of the first dialog).  \n  \n You can also call the function **CWnd::UpdateDialogControls** on your dialog and pass it the address of your main frame window. This function will enable or disable your dialog controls based on whether they have command handlers in the frame. This function is called automatically for you for control bars in your application's idle loop, but you must call it directly for normal dialogs that you wish to have this feature.  \n  \n## When ON_UPDATE_COMMAND_UI is Called  \n Maintaining the enabled/checked state of all a program's menu items all the time can be a computationally expensive problem. A common technique is to enable/check menu items only when the user selects the POPUP. The MFC 2.0 implementation of **CFrameWnd** handles the **WM_INITMENUPOPUP** message and uses the command routing architecture to determine the states of menus through **ON_UPDATE_COMMAND_UI** handlers.  \n  \n **CFrameWnd** also handles the **WM_ENTERIDLE** message to describe the current menu item selected on the status bar (also known as the message line).  \n  \n An application's menu structure, edited by Visual C++, is used to represent the potential commands available at **WM_INITMENUPOPUP** time. **ON_UPDATE_COMMAND_UI** handlers can modify the state or text of a menu, or for advanced uses (like the File MRU list or the OLE Verbs pop-up menu), actually modify the menu structure before the menu is drawn.  \n  \n The same sort of **ON_UPDATE_COMMAND_UI** processing is done for toolbars (and other control bars) when the application enters its idle loop. See the *Class Library Reference* and [Technical Note 31](../mfc/tn031-control-bars.md) for more information on control bars.  \n  \n## Nested Pop-up Menus  \n If you are using a nested menu structure, you will notice that the **ON_UPDATE_COMMAND_UI** handler for the first menu item in the pop-up menu is called in two different cases.  \n  \n First, it is called for the pop-up menu itself. This is necessary because pop-up menus do not have IDs and we use the ID of the first menu item of the pop-up menu to refer to the entire pop-up menu. In this case, the **m_pSubMenu** member variable of the **CCmdUI** object will be non-NULL and will point to the pop-up menu.  \n  \n Second, it is called just before the menu items in the pop-up menu are to be drawn. In this case, the ID refers just to the first menu item and the **m_pSubMenu** member variable of the **CCmdUI** object will be NULL.  \n  \n This allows you to enable the pop-up menu distinct from its menu items, but requires that you write some menu aware code. For example, in a nested menu with the following structure:  \n  \n```  \nFile>  \n    New> \n    Sheet (ID_NEW_SHEET)  \n    Chart (ID_NEW_CHART)  \n```  \n  \n The ID_NEW_SHEET and ID_NEW_CHART commands can be independently enabled or disabled. The **New** pop-up menu should be enabled if either of the two is enabled.  \n  \n The command handler for ID_NEW_SHEET (the first command in the pop-up) would look something like:  \n  \n```  \nvoid CMyApp::OnUpdateNewSheet(CCmdUI* pCmdUI)  \n{  \n    if (pCmdUI->m_pSubMenu != NULL)  \n { *// enable entire pop-up for \"New\" sheet and chart  \n    BOOL bEnable = m_bCanCreateSheet || m_bCanCreateChart;  \n *// CCmdUI::Enable is a no-op for this case,\n    so we *//   must do what it would have done.  \n    pCmdUI->m_pMenu->EnableMenuItem(pCmdUI->m_nIndex, \n    MF_BYPOSITION |   \n (bEnable  MF_ENABLED : (MF_DISABLED | MF_GRAYED)));\n\n    return; \n } *// otherwise just the New Sheet command  \n    pCmdUI->Enable(m_bCanCreateSheet);\n\n} \n```  \n  \n The command handler for ID_NEW_CHART would be a normal update command handler and look something like:  \n  \n```  \nvoid CMyApp::OnUpdateNewChart(CCmdUI* pCmdUI)  \n{  \n    pCmdUI->Enable(m_bCanCreateChart);\n\n} \n```  \n  \n## ON_COMMAND and ON_BN_CLICKED  \n The message map macros for **ON_COMMAND** and **ON_BN_CLICKED** are the same. The MFC command and control notification routing mechanism only uses the command ID to decide where to route to. Control notifications with control notification code of zero (**BN_CLICKED**) are interpreted as commands.  \n  \n> [!NOTE]\n>  In fact, all control notification messages go through the command handler chain. For example, it is technically possible for you to write a control notification handler for **EN_CHANGE** in your document class. This is not generally advisable because the practical applications of this feature are few, the feature is not supported by ClassWizard, and use of the feature can result in fragile code.  \n  \n## Disabling the Automatic Disabling of Button Controls  \n If you place a button control on a dialog bar, or in a dialog using where you are calling **CWnd::UpdateDialogControls** on your own, you will notice that buttons which do not have **ON_COMMAND** or **ON_UPDATE_COMMAND_UI** handlers will be automatically disabled for you by the framework. In some cases, you will not need to have a handler, but you will want the button to remain enabled. The easiest way to achieve this is to add a dummy command handler (easy to do with ClassWizard) and do nothing in it.  \n  \n## Window Message Routing  \n The following describes some more advanced topics on the MFC classes and how Windows message routing and other topics impact them. The information here is only described briefly. Refer to the *Class Library Reference* for details about public APIs. Please refer to the MFC library source code for more information on implementation details.  \n  \n Please refer to [Technical Note 17](../mfc/tn017-destroying-window-objects.md) for details on Window cleanup, a very important topic for all **CWnd**-derived classes.  \n  \n## CWnd Issues  \n The implementation member function **CWnd::OnChildNotify** provides a powerful and extensible architecture for child windows (also known as controls) to hook or otherwise be informed of messages, commands, and control notifications that go to their parent (or \"owner\"). If the child window (/control) is a C++ **CWnd** object itself, the virtual function **OnChildNotify** is called first with the parameters from the original message (that is, a **MSG** structure). The child window can leave the message alone, eat it, or modify the message for the parent (rare).  \n  \n The default **CWnd** implementation handles the following messages and uses the **OnChildNotify** hook to allow child windows (controls) to first access at the message:  \n  \n- **WM_MEASUREITEM** and **WM_DRAWITEM** (for self-draw)  \n  \n- **WM_COMPAREITEM** and **WM_DELETEITEM** (for self-draw)  \n  \n- **WM_HSCROLL** and **WM_VSCROLL**  \n  \n- **WM_CTLCOLOR**  \n  \n- **WM_PARENTNOTIFY**  \n  \n You will notice the **OnChildNotify** hook is used for changing owner-draw messages into self-draw messages.  \n  \n In addition to the **OnChildNotify** hook, scroll messages have further routing behavior. Please see below for more details on scroll bars and sources of **WM_HSCROLL** and **WM_VSCROLL** messages.  \n  \n## CFrameWnd Issues  \n The **CFrameWnd** class provides most of the command routing and user-interface updating implementation. This is primarily used for the main frame window of the application (**CWinApp::m_pMainWnd**) but applies to all frame windows.  \n  \n The main frame window is the window with the menu bar and is the parent of the status bar or message line. Please refer to the above discussion on command routing and **WM_INITMENUPOPUP.**  \n  \n The **CFrameWnd** class provides management of the active view. The following messages are routed through the active view:  \n  \n-   All command messages (the active view gets first access to them).  \n  \n- **WM_HSCROLL** and **WM_VSCROLL** messages from sibling scroll bars (see below).  \n  \n- **WM_ACTIVATE** (and **WM_MDIACTIVATE** for MDI) get turned into calls to the virtual function **CView::OnActivateView**.  \n  \n## CMDIFrameWnd/CMDIChildWnd Issues  \n Both MDI frame window classes derive from **CFrameWnd** and therefore are both enabled for the same sort of command routing and user-interface updating provided in **CFrameWnd**. In a typical MDI application, only the main frame window (that is, the **CMDIFrameWnd** object) holds the menu bar and the status bar and therefore is the main source of the command routing implementation.  \n  \n The general routing scheme is that the active MDI child window gets first access to commands. The default **PreTranslateMessage** functions handle accelerator tables for both MDI child windows (first) and the MDI frame (second) as well as the standard MDI system-command accelerators normally handled by **TranslateMDISysAccel** (last).  \n  \n## Scroll Bar Issues  \n When handling scroll-message (**WM_HSCROLL**/**OnHScroll** and/or **WM_VSCROLL**/**OnVScroll**), you should try to write the handler code so it does not rely on where the scroll bar message came from. This is not only a general Windows issue, since scroll messages can come from true scroll bar controls or from **WS_HSCROLL**/**WS_VSCROLL** scroll bars which are not scroll bar controls.  \n  \n MFC extends that to allow for scroll bar controls to be either child or siblings of the window being scrolled (in fact, the parent/child relationship between the scroll bar and window being scrolled can be anything). This is especially important for shared scroll bars with splitter windows. Please refer to [Technical Note 29](../mfc/tn029-splitter-windows.md) for details on the implementation of **CSplitterWnd** including more information on shared scroll bar issues.  \n  \n On a side note, there are two **CWnd** derived classes where the scroll bar styles specified at create time are trapped and not passed to Windows. When passed to a creation routine, **WS_HSCROLL** and **WS_VSCROLL** can be independently set, but after creation cannot be changed. Of course, you should not directly test or set the WS_SCROLL style bits of the window that they created.  \n  \n For **CMDIFrameWnd** the scroll bar styles you pass in to **Create** or **LoadFrame** are used to create the MDICLIENT. If you wish to have a scrollable MDICLIENT area (like the Windows Program Manager) be sure to set both scroll bar styles (**WS_HSCROLL** &#124; **WS_VSCROLL**) for the style used to create the **CMDIFrameWnd**.  \n  \n For **CSplitterWnd** the scroll bar styles apply to the special shared scroll bars for the splitter regions. For static splitter windows, you will normally not set either scroll bar style. For dynamic splitter windows, you will usually have the scroll bar style set for the direction you will split, That is, **WS_HSCROLL** if you can split rows, **WS_VSCROLL** if you can split columns.  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}