{"nodes":[{"pos":[12,63],"content":"Specifying Levels of Functionality | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Specifying Levels of Functionality | Microsoft Docs","pos":[0,51]}]},{"content":"Specifying Levels of Functionality","pos":[837,871]},{"pos":[872,1011],"content":"This article describes how to add the following levels of functionality to your <bpt id=\"p1\">[</bpt>CObject<ept id=\"p1\">](../mfc/reference/cobject-class.md)</ept>-derived class:","source":"This article describes how to add the following levels of functionality to your [CObject](../mfc/reference/cobject-class.md)-derived class:"},{"content":"Run-time class information","pos":[1022,1048]},{"content":"Dynamic creation support","pos":[1105,1129]},{"content":"Serialization support","pos":[1181,1202]},{"pos":[1247,1390],"content":"For a general description of <ph id=\"ph1\">`CObject`</ph> functionality, see the article <bpt id=\"p1\">[</bpt>Deriving a Class from CObject<ept id=\"p1\">](../mfc/deriving-a-class-from-cobject.md)</ept>.","source":"For a general description of `CObject` functionality, see the article [Deriving a Class from CObject](../mfc/deriving-a-class-from-cobject.md)."},{"content":"Run-time class information","pos":[1401,1427]},{"pos":[1539,1572],"content":"To add run-time class information"},{"pos":[1582,1717],"content":"Derive your class from <ph id=\"ph1\">`CObject`</ph>, as described in the <bpt id=\"p1\">[</bpt>Deriving a Class from CObject<ept id=\"p1\">](../mfc/deriving-a-class-from-cobject.md)</ept> article.","source":"Derive your class from `CObject`, as described in the [Deriving a Class from CObject](../mfc/deriving-a-class-from-cobject.md) article."},{"pos":[1727,1800],"content":"Use the <ph id=\"ph1\">`DECLARE_DYNAMIC`</ph> macro in your class declaration, as shown here:","source":"Use the `DECLARE_DYNAMIC` macro in your class declaration, as shown here:"},{"pos":[1822,1844],"content":"NVC_MFCCObjectSample#2"},{"content":"Use the <ph id=\"ph1\">`IMPLEMENT_DYNAMIC`</ph> macro in the implementation file (.CPP) of your class.","pos":[1919,2001],"source":"Use the `IMPLEMENT_DYNAMIC` macro in the implementation file (.CPP) of your class."},{"content":"This macro takes as arguments the name of the class and its base class, as follows:","pos":[2002,2085]},{"pos":[2107,2129],"content":"NVC_MFCCObjectSample#3"},{"pos":[2204,2493],"content":"[!NOTE]\n Always put `IMPLEMENT_DYNAMIC` in the implementation file (.CPP) for your class. The `IMPLEMENT_DYNAMIC` macro should be evaluated only once during a compilation and therefore should not be used in an interface file (.H) that could potentially be included in more than one file.","leadings":["","> "],"nodes":[{"content":" Always put `IMPLEMENT_DYNAMIC` in the implementation file (.CPP) for your class. The `IMPLEMENT_DYNAMIC` macro should be evaluated only once during a compilation and therefore should not be used in an interface file (.H) that could potentially be included in more than one file.","pos":[8,287],"nodes":[{"content":"Always put <ph id=\"ph1\">`IMPLEMENT_DYNAMIC`</ph> in the implementation file (.CPP) for your class.","pos":[1,81],"source":" Always put `IMPLEMENT_DYNAMIC` in the implementation file (.CPP) for your class."},{"content":"The <ph id=\"ph1\">`IMPLEMENT_DYNAMIC`</ph> macro should be evaluated only once during a compilation and therefore should not be used in an interface file (.H) that could potentially be included in more than one file.","pos":[82,279],"source":" The `IMPLEMENT_DYNAMIC` macro should be evaluated only once during a compilation and therefore should not be used in an interface file (.H) that could potentially be included in more than one file."}]}]},{"pos":[2557,2588],"content":"To add dynamic creation support"},{"pos":[2598,2631],"content":"Derive your class from <ph id=\"ph1\">`CObject`</ph>.","source":"Derive your class from `CObject`."},{"pos":[2641,2700],"content":"Use the <ph id=\"ph1\">`DECLARE_DYNCREATE`</ph> macro in the class declaration.","source":"Use the `DECLARE_DYNCREATE` macro in the class declaration."},{"content":"Define a constructor with no arguments (a default constructor).","pos":[2710,2773]},{"pos":[2783,2852],"content":"Use the <ph id=\"ph1\">`IMPLEMENT_DYNCREATE`</ph> macro in the class implementation file.","source":"Use the `IMPLEMENT_DYNCREATE` macro in the class implementation file."},{"pos":[2913,2941],"content":"To add serialization support"},{"pos":[2951,2984],"content":"Derive your class from <ph id=\"ph1\">`CObject`</ph>.","source":"Derive your class from `CObject`."},{"pos":[2994,3035],"content":"Override the <ph id=\"ph1\">`Serialize`</ph> member function.","source":"Override the `Serialize` member function."},{"pos":[3047,3199],"content":"[!NOTE]\n If you call `Serialize` directly, that is, you do not want to serialize the object through a polymorphic pointer, omit steps 3 through 5.","leadings":["","    > "],"nodes":[{"content":"If you call <ph id=\"ph1\">`Serialize`</ph> directly, that is, you do not want to serialize the object through a polymorphic pointer, omit steps 3 through 5.","pos":[9,146],"source":" If you call `Serialize` directly, that is, you do not want to serialize the object through a polymorphic pointer, omit steps 3 through 5."}]},{"pos":[3209,3265],"content":"Use the <ph id=\"ph1\">`DECLARE_SERIAL`</ph> macro in the class declaration.","source":"Use the `DECLARE_SERIAL` macro in the class declaration."},{"content":"Define a constructor with no arguments (a default constructor).","pos":[3275,3338]},{"pos":[3348,3414],"content":"Use the <ph id=\"ph1\">`IMPLEMENT_SERIAL`</ph> macro in the class implementation file.","source":"Use the `IMPLEMENT_SERIAL` macro in the class implementation file."},{"pos":[3422,3757],"content":"[!NOTE]\n A \"polymorphic pointer\" points to an object of a class (call it A) or to an object of any class derived from A (say, B). To serialize through a polymorphic pointer, the framework must determine the run-time class of the object it is serializing (B), since it might be an object of any class derived from some base class (A).","leadings":["","> "],"nodes":[{"content":" A \"polymorphic pointer\" points to an object of a class (call it A) or to an object of any class derived from A (say, B). To serialize through a polymorphic pointer, the framework must determine the run-time class of the object it is serializing (B), since it might be an object of any class derived from some base class (A).","pos":[8,333],"nodes":[{"content":"A \"polymorphic pointer\" points to an object of a class (call it A) or to an object of any class derived from A (say, B).","pos":[1,121]},{"content":"To serialize through a polymorphic pointer, the framework must determine the run-time class of the object it is serializing (B), since it might be an object of any class derived from some base class (A).","pos":[122,325]}]}]},{"pos":[3764,3963],"content":"For more details on how to enable serialization when you derive your class from <ph id=\"ph1\">`CObject`</ph>, see the articles <bpt id=\"p1\">[</bpt>Files in MFC<ept id=\"p1\">](../mfc/files-in-mfc.md)</ept> and <bpt id=\"p2\">[</bpt>Serialization<ept id=\"p2\">](../mfc/serialization-in-mfc.md)</ept>.","source":"For more details on how to enable serialization when you derive your class from `CObject`, see the articles [Files in MFC](../mfc/files-in-mfc.md) and [Serialization](../mfc/serialization-in-mfc.md)."},{"content":"See Also","pos":[3972,3980]},{"content":"Deriving a Class from CObject","pos":[3985,4014]}],"content":"---\ntitle: \"Specifying Levels of Functionality | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"CObject class, adding functionality to derived classes\"\n  - \"runtime [C++], class information\"\n  - \"serialization [C++], Cobject\"\n  - \"dynamic creation support\"\n  - \"levels [C++], functionality in CObject\"\n  - \"run-time class, information support\"\n  - \"levels [C++]\"\nms.assetid: 562669ba-c858-4f66-b5f1-b3beeea4f486\ncaps.latest.revision: 9\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Specifying Levels of Functionality\nThis article describes how to add the following levels of functionality to your [CObject](../mfc/reference/cobject-class.md)-derived class:  \n  \n-   [Run-time class information](#_core_to_add_run.2d.time_class_information)  \n  \n-   [Dynamic creation support](#_core_to_add_dynamic_creation_support)  \n  \n-   [Serialization support](#_core_to_add_serialization_support)  \n  \n For a general description of `CObject` functionality, see the article [Deriving a Class from CObject](../mfc/deriving-a-class-from-cobject.md).  \n  \n-   [Run-time class information](#_core_to_add_run.2d.time_class_information)  \n#### <a name=\"_core_to_add_run.2d.time_class_information\"></a> To add run-time class information  \n  \n1.  Derive your class from `CObject`, as described in the [Deriving a Class from CObject](../mfc/deriving-a-class-from-cobject.md) article.  \n  \n2.  Use the `DECLARE_DYNAMIC` macro in your class declaration, as shown here:  \n  \n     [!code-cpp[NVC_MFCCObjectSample#2](../mfc/codesnippet/cpp/specifying-levels-of-functionality_1.h)]  \n  \n3.  Use the `IMPLEMENT_DYNAMIC` macro in the implementation file (.CPP) of your class. This macro takes as arguments the name of the class and its base class, as follows:  \n  \n     [!code-cpp[NVC_MFCCObjectSample#3](../mfc/codesnippet/cpp/specifying-levels-of-functionality_2.cpp)]  \n  \n> [!NOTE]\n>  Always put `IMPLEMENT_DYNAMIC` in the implementation file (.CPP) for your class. The `IMPLEMENT_DYNAMIC` macro should be evaluated only once during a compilation and therefore should not be used in an interface file (.H) that could potentially be included in more than one file.  \n  \n#### <a name=\"_core_to_add_dynamic_creation_support\"></a> To add dynamic creation support  \n  \n1.  Derive your class from `CObject`.  \n  \n2.  Use the `DECLARE_DYNCREATE` macro in the class declaration.  \n  \n3.  Define a constructor with no arguments (a default constructor).  \n  \n4.  Use the `IMPLEMENT_DYNCREATE` macro in the class implementation file.  \n  \n#### <a name=\"_core_to_add_serialization_support\"></a> To add serialization support  \n  \n1.  Derive your class from `CObject`.  \n  \n2.  Override the `Serialize` member function.  \n  \n    > [!NOTE]\n    >  If you call `Serialize` directly, that is, you do not want to serialize the object through a polymorphic pointer, omit steps 3 through 5.  \n  \n3.  Use the `DECLARE_SERIAL` macro in the class declaration.  \n  \n4.  Define a constructor with no arguments (a default constructor).  \n  \n5.  Use the `IMPLEMENT_SERIAL` macro in the class implementation file.  \n  \n> [!NOTE]\n>  A \"polymorphic pointer\" points to an object of a class (call it A) or to an object of any class derived from A (say, B). To serialize through a polymorphic pointer, the framework must determine the run-time class of the object it is serializing (B), since it might be an object of any class derived from some base class (A).  \n  \n For more details on how to enable serialization when you derive your class from `CObject`, see the articles [Files in MFC](../mfc/files-in-mfc.md) and [Serialization](../mfc/serialization-in-mfc.md).  \n  \n## See Also  \n [Deriving a Class from CObject](../mfc/deriving-a-class-from-cobject.md)\n"}