{"nodes":[{"pos":[12,49],"content":"Derived Message Maps | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Derived Message Maps | Microsoft Docs","pos":[0,37]}]},{"content":"Derived Message Maps","pos":[680,700]},{"content":"During message handling, checking a class's own message map is not the end of the message-map story.","pos":[701,801]},{"content":"What happens if class <ph id=\"ph1\">`CMyView`</ph> (derived from <ph id=\"ph2\">`CView`</ph>) has no matching entry for a message","pos":[802,892],"source":" What happens if class `CMyView` (derived from `CView`) has no matching entry for a message"},{"content":"Keep in mind that <ph id=\"ph1\">`CView`</ph>, the base class of <ph id=\"ph2\">`CMyView`</ph>, is derived in turn from <ph id=\"ph3\">`CWnd`</ph>.","pos":[899,986],"source":"Keep in mind that `CView`, the base class of `CMyView`, is derived in turn from `CWnd`."},{"content":"Thus <ph id=\"ph1\">`CMyView`</ph> <bpt id=\"p1\">*</bpt>is<ept id=\"p1\">*</ept> a <ph id=\"ph2\">`CView`</ph> and <bpt id=\"p2\">*</bpt>is<ept id=\"p2\">*</ept> a <ph id=\"ph3\">`CWnd`</ph>.","pos":[987,1035],"source":" Thus `CMyView` *is* a `CView` and *is* a `CWnd`."},{"content":"Each of those classes has its own message map.","pos":[1036,1082]},{"content":"The figure \"A View Hierarchy\" below shows the hierarchical relationship of the classes, but keep in mind that a <ph id=\"ph1\">`CMyView`</ph> object is a single object that has the characteristics of all three classes.","pos":[1083,1281],"source":" The figure \"A View Hierarchy\" below shows the hierarchical relationship of the classes, but keep in mind that a `CMyView` object is a single object that has the characteristics of all three classes."},{"content":"Hierarchy of a view","pos":[1290,1309]},{"content":"A View Hierarchy","pos":[1349,1365]},{"content":"So if a message can't be matched in class <ph id=\"ph1\">`CMyView`</ph>'s message map, the framework also searches the message map of its immediate base class.","pos":[1372,1511],"source":"So if a message can't be matched in class `CMyView`'s message map, the framework also searches the message map of its immediate base class."},{"content":"The <ph id=\"ph1\">`BEGIN_MESSAGE_MAP`</ph> macro at the start of the message map specifies two class names as its arguments:","pos":[1512,1617],"source":" The `BEGIN_MESSAGE_MAP` macro at the start of the message map specifies two class names as its arguments:"},{"pos":[1635,1659],"content":"NVC_MFCMessageHandling#2"},{"content":"The first argument names the class to which the message map belongs.","pos":[1719,1787]},{"content":"The second argument provides a connection with the immediate base class — <ph id=\"ph1\">`CView`</ph> here — so the framework can search its message map, too.","pos":[1788,1926],"source":" The second argument provides a connection with the immediate base class — `CView` here — so the framework can search its message map, too."},{"content":"The message handlers provided in a base class are thus inherited by the derived class.","pos":[1933,2019]},{"content":"This is very similar to normal virtual member functions without needing to make all handler member functions virtual.","pos":[2020,2137]},{"content":"If no handler is found in any of the base-class message maps, default processing of the message is performed.","pos":[2144,2253]},{"content":"If the message is a command, the framework routes it to the next command target.","pos":[2254,2334]},{"content":"If it is a standard Windows message, the message is passed to the appropriate default window procedure.","pos":[2335,2438]},{"content":"To speed message-map matching, the framework caches recent matches on the likelihood that it will receive the same message again.","pos":[2445,2574]},{"content":"One consequence of this is that the framework processes unhandled messages quite efficiently.","pos":[2575,2668]},{"content":"Message maps are also more space-efficient than implementations that use virtual functions.","pos":[2669,2760]},{"content":"See Also","pos":[2769,2777]},{"content":"How the Framework Searches Message Maps","pos":[2782,2821]}],"content":"---\ntitle: \"Derived Message Maps | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"message handling, derived message handlers\"\n  - \"messages, routing\"\n  - \"message maps, derived\"\n  - \"derived message maps\"\nms.assetid: 21829556-6e64-40c3-8279-fed85d99de77\ncaps.latest.revision: 11\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Derived Message Maps\nDuring message handling, checking a class's own message map is not the end of the message-map story. What happens if class `CMyView` (derived from `CView`) has no matching entry for a message  \n  \n Keep in mind that `CView`, the base class of `CMyView`, is derived in turn from `CWnd`. Thus `CMyView` *is* a `CView` and *is* a `CWnd`. Each of those classes has its own message map. The figure \"A View Hierarchy\" below shows the hierarchical relationship of the classes, but keep in mind that a `CMyView` object is a single object that has the characteristics of all three classes.  \n  \n ![Hierarchy of a view](../mfc/media/vc38621.gif \"vc38621\")  \nA View Hierarchy  \n  \n So if a message can't be matched in class `CMyView`'s message map, the framework also searches the message map of its immediate base class. The `BEGIN_MESSAGE_MAP` macro at the start of the message map specifies two class names as its arguments:  \n  \n [!code-cpp[NVC_MFCMessageHandling#2](../mfc/codesnippet/cpp/derived-message-maps_1.cpp)]  \n  \n The first argument names the class to which the message map belongs. The second argument provides a connection with the immediate base class — `CView` here — so the framework can search its message map, too.  \n  \n The message handlers provided in a base class are thus inherited by the derived class. This is very similar to normal virtual member functions without needing to make all handler member functions virtual.  \n  \n If no handler is found in any of the base-class message maps, default processing of the message is performed. If the message is a command, the framework routes it to the next command target. If it is a standard Windows message, the message is passed to the appropriate default window procedure.  \n  \n To speed message-map matching, the framework caches recent matches on the likelihood that it will receive the same message again. One consequence of this is that the framework processes unhandled messages quite efficiently. Message maps are also more space-efficient than implementations that use virtual functions.  \n  \n## See Also  \n [How the Framework Searches Message Maps](../mfc/how-the-framework-searches-message-maps.md)\n\n"}