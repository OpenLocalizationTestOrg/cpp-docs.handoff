{"nodes":[{"pos":[12,48],"content":"TN006: Message Maps | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TN006: Message Maps | Microsoft Docs","pos":[0,36]}]},{"content":"TN006: Message Maps","pos":[991,1010]},{"content":"This note describes the MFC message map facility.","pos":[1011,1060]},{"content":"The Problem","pos":[1069,1080]},{"content":"Microsoft Windows implements virtual functions in window classes that use its messaging facility.","pos":[1084,1181]},{"content":"Due to the large number of messages involved, providing a separate virtual function for each Windows message would create a prohibitively large vtable.","pos":[1182,1333]},{"content":"Because the number of system-defined Windows messages changes over time, and because applications can define their own Windows messages, message maps provide a level of indirection that prevents interface changes from breaking existing code.","pos":[1340,1581]},{"content":"Overview","pos":[1590,1598]},{"content":"MFC provides an alternative to the switch statement that was used in traditional Windows-based programs to handle messages sent to a window.","pos":[1602,1742]},{"content":"A mapping from messages to methods can be defined so that when a message is received by a window, the appropriate method is called automatically.","pos":[1743,1888]},{"content":"This message-map facility is designed to resemble virtual functions but has additional benefits not possible with C++ virtual functions.","pos":[1889,2025]},{"content":"Defining a Message Map","pos":[2034,2056]},{"pos":[2060,2199],"content":"The <bpt id=\"p1\">[</bpt>DECLARE_MESSAGE_MAP<ept id=\"p1\">](http://msdn.microsoft.com/library/c225e7e0-a81b-495c-97f9-3e0aa1f65036)</ept> macro declares three members for a class.","source":"The [DECLARE_MESSAGE_MAP](http://msdn.microsoft.com/library/c225e7e0-a81b-495c-97f9-3e0aa1f65036) macro declares three members for a class."},{"pos":[2209,2280],"content":"A private array of <ph id=\"ph1\">`AFX_MSGMAP_ENTRY`</ph> entries called <ph id=\"ph2\">`_messageEntries`</ph>.","source":"A private array of `AFX_MSGMAP_ENTRY` entries called `_messageEntries`."},{"pos":[2290,2388],"content":"A protected <ph id=\"ph1\">`AFX_MSGMAP`</ph> structure called <ph id=\"ph2\">`messageMap`</ph> that points to the <ph id=\"ph3\">`_messageEntries`</ph> array.","source":"A protected `AFX_MSGMAP` structure called `messageMap` that points to the `_messageEntries` array."},{"pos":[2398,2491],"content":"A protected virtual function called <ph id=\"ph1\">`GetMessageMap`</ph> that returns the address of <ph id=\"ph2\">`messageMap`</ph>.","source":"A protected virtual function called `GetMessageMap` that returns the address of `messageMap`."},{"content":"This macro should be put in the declaration of any class using message maps.","pos":[2498,2574]},{"content":"By convention, it is at the end of the class declaration.","pos":[2575,2632]},{"content":"For example:","pos":[2633,2645]},{"content":"This is the format generated by AppWizard and ClassWizard when they create new classes.","pos":[2842,2929]},{"content":"The //{{ and //}} brackets are needed for ClassWizard.","pos":[2930,2984]},{"content":"The message map's table is defined by using a set of macros that expand to message map entries.","pos":[2991,3086]},{"content":"A table starts with a <bpt id=\"p1\">[</bpt>BEGIN_MESSAGE_MAP<ept id=\"p1\">](http://msdn.microsoft.com/library/d9201e18-04e0-4639-9810-f15768627fc2)</ept> macro call, which defines the class that is handled by this message map and the parent class to which unhandled messages are passed.","pos":[3087,3333],"source":" A table starts with a [BEGIN_MESSAGE_MAP](http://msdn.microsoft.com/library/d9201e18-04e0-4639-9810-f15768627fc2) macro call, which defines the class that is handled by this message map and the parent class to which unhandled messages are passed."},{"content":"The table ends with the <bpt id=\"p1\">[</bpt>END_MESSAGE_MAP<ept id=\"p1\">](http://msdn.microsoft.com/library/40f611f1-a3b4-4097-b683-091bf7cfab8b)</ept> macro call.","pos":[3334,3459],"source":" The table ends with the [END_MESSAGE_MAP](http://msdn.microsoft.com/library/40f611f1-a3b4-4097-b683-091bf7cfab8b) macro call."},{"content":"Between these two macro calls is an entry for each message to be handled by this message map.","pos":[3466,3559]},{"content":"Every standard Windows message has a macro of the form ON_WM_<bpt id=\"p1\">*</bpt>MESSAGE_NAME<ept id=\"p1\">*</ept> that generates an entry for that message.","pos":[3560,3677],"source":" Every standard Windows message has a macro of the form ON_WM_*MESSAGE_NAME* that generates an entry for that message."},{"content":"A standard function signature has been defined for unpacking the parameters of each Windows message and providing type safety.","pos":[3684,3810]},{"content":"These signatures may be found in the file Afxwin.h in the declaration of <bpt id=\"p1\">[</bpt>CWnd<ept id=\"p1\">](../mfc/reference/cwnd-class.md)</ept>.","pos":[3811,3923],"source":" These signatures may be found in the file Afxwin.h in the declaration of [CWnd](../mfc/reference/cwnd-class.md)."},{"content":"Each one is marked with the keyword <ph id=\"ph1\">`afx_msg`</ph> for easy identification.","pos":[3924,3994],"source":" Each one is marked with the keyword `afx_msg` for easy identification."},{"pos":[4002,4110],"content":"[!NOTE]\n ClassWizard requires that you use the `afx_msg` keyword in your message map handler declarations.","leadings":["","> "],"nodes":[{"content":"ClassWizard requires that you use the <ph id=\"ph1\">`afx_msg`</ph> keyword in your message map handler declarations.","pos":[9,106],"source":" ClassWizard requires that you use the `afx_msg` keyword in your message map handler declarations."}]},{"content":"These function signatures were derived by using a simple convention.","pos":[4117,4185]},{"content":"The name of the function always starts with <ph id=\"ph1\">`\"On`</ph>\".","pos":[4186,4237],"source":" The name of the function always starts with `\"On`\"."},{"content":"This is followed by the name of the Windows message with the \"WM_\" removed and the first letter of each word capitalized.","pos":[4238,4359]},{"content":"The ordering of the parameters is <ph id=\"ph1\">`wParam`</ph> followed by <ph id=\"ph2\">`LOWORD`</ph>(<ph id=\"ph3\">`lParam`</ph>) then <ph id=\"ph4\">`HIWORD`</ph>(<ph id=\"ph5\">`lParam`</ph>).","pos":[4360,4458],"source":" The ordering of the parameters is `wParam` followed by `LOWORD`(`lParam`) then `HIWORD`(`lParam`)."},{"content":"Unused parameters are not passed.","pos":[4459,4492]},{"content":"Any handles that are wrapped by MFC classes are converted to pointers to the appropriate MFC objects.","pos":[4493,4594]},{"content":"The following example shows how to handle the <ph id=\"ph1\">`WM_PAINT`</ph> message and cause the <ph id=\"ph2\">`CMyWnd::OnPaint`</ph> function to be called:","pos":[4595,4714],"source":" The following example shows how to handle the `WM_PAINT` message and cause the `CMyWnd::OnPaint` function to be called:"},{"content":"The message map table must be defined outside the scope of any function or class definition.","pos":[4865,4957]},{"content":"It should not be put in an extern \"C\" block.","pos":[4958,5002]},{"pos":[5010,5122],"content":"[!NOTE]\n ClassWizard will modify the message map entries that occur between the //{{ and //}} comment bracket.","leadings":["","> "],"nodes":[{"content":"ClassWizard will modify the message map entries that occur between the //{{ and //}} comment bracket.","pos":[9,110]}]},{"content":"User Defined Windows Messages","pos":[5131,5160]},{"content":"User-defined messages may be included in a message map by using the <bpt id=\"p1\">[</bpt>ON_MESSAGE<ept id=\"p1\">](http://msdn.microsoft.com/library/e2faeb13-9f6e-4c0d-9f6d-b2e141a0db1e)</ept> macro.","pos":[5164,5323],"source":"User-defined messages may be included in a message map by using the [ON_MESSAGE](http://msdn.microsoft.com/library/e2faeb13-9f6e-4c0d-9f6d-b2e141a0db1e) macro."},{"content":"This macro accepts a message number and a method of the form:","pos":[5324,5385]},{"content":"``` *// inside the class declaration","pos":[5391,5427]},{"content":"afx_msg LRESULT OnMyMessage(WPARAM wParam, LPARAM lParam);","pos":[5434,5496],"source":"    afx_msg LRESULT OnMyMessage(WPARAM wParam,\n    LPARAM lParam);"},{"content":"define WM_MYMESSAGE (WM_USER + 100)","pos":[5502,5537]},{"content":"BEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass)","pos":[5542,5590],"source":"BEGIN_MESSAGE_MAP(CMyWnd,\n    CMyParentWndClass)"},{"content":"ON_MESSAGE(WM_MYMESSAGE, OnMyMessage)","pos":[5597,5638],"source":"    ON_MESSAGE(WM_MYMESSAGE,\n    OnMyMessage)"},{"content":"END_MESSAGE_MAP()","pos":[5641,5658]},{"content":"CWnd* pWnd = ...;","pos":[5895,5912]},{"content":"pWnd-&gt;SendMessage(WM_MYMESSAGE);","pos":[5915,5947],"source":"pWnd->SendMessage(WM_MYMESSAGE);"},{"content":"class CMyWnd : public CMyParentWndClass","pos":[6762,6801]},{"content":"{","pos":[6804,6805]},{"content":"public:","pos":[6808,6815]},{"content":"CMyWnd();","pos":[6822,6831]},{"pos":[6834,6931],"content":"<bpt id=\"p1\">*</bpt>//{{AFX_MSG(CMyWnd) afx_msg LRESULT OnFind(WPARAM wParam, LPARAM lParam); <ept id=\"p1\">*</ept>//}}AFX_MSG","source":"*//{{AFX_MSG(CMyWnd)  \n    afx_msg LRESULT OnFind(WPARAM wParam,\n    LPARAM lParam);\n*//}}AFX_MSG"},{"content":"};","pos":[6963,6965]},{"content":"static UINT NEAR WM_FIND = RegisterWindowMessage(\"COMMDLG_FIND\");","pos":[6970,7035]},{"content":"BEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass) <bpt id=\"p1\">*</bpt>//{{AFX_MSG_MAP(CMyWnd) ON_REGISTERED_MESSAGE(WM_FIND, OnFind) <ept id=\"p1\">*</ept>//}}AFX_MSG_MAP","pos":[7039,7178],"source":"BEGIN_MESSAGE_MAP(CMyWnd,\n    CMyParentWndClass) *//{{AFX_MSG_MAP(CMyWnd)  \n    ON_REGISTERED_MESSAGE(WM_FIND,\n    OnFind) *//}}AFX_MSG_MAP"},{"content":"END_MESSAGE_MAP()","pos":[7181,7198]},{"content":"ON_COMMAND(id, memberFxn)","pos":[8201,8226]},{"content":"ON_UPDATE_COMMAND_UI(id, memberFxn)","pos":[8536,8571]},{"content":"define    ID_MYCMD      100","pos":[9133,9160]},{"content":"define    ID_COMPLEX    101","pos":[9165,9192]},{"content":"afx_msg void OnUpdateMyCommand(CCmdUI* pCmdUI);","pos":[9282,9329]},{"content":"{ *// handle the command","pos":[9682,9706]},{"content":"}","pos":[9710,9711]},{"content":"{ *// set the UI state with pCmdUI","pos":[9772,9806]},{"content":"}","pos":[9810,9811]},{"content":"{ *// handle the command","pos":[9865,9889]},{"content":"return TRUE;","pos":[9896,9908]},{"content":"}","pos":[9912,9913]},{"pos":[11231,11283],"content":"ON_CONTROL(wNotificationCode, id, memberFxn)","source":"ON_CONTROL(wNotificationCode,\n    id,\n    memberFxn)"}],"content":"---\ntitle: \"TN006: Message Maps | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"vc.messages.maps\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"ON_UPDATE_COMMAND_UI macro\"\n  - \"ON_NOTIFY_RANGE macro\"\n  - \"ON_COMMAND macro\"\n  - \"ON_CONTROL_RANGE macro\"\n  - \"ON_REGISTERED_MESSAGE macro\"\n  - \"ON_NOTIFY message\"\n  - \"ON_COMMAND_RANGE_EX macro\"\n  - \"ON_MESSAGE macro\"\n  - \"Windows messages [C++], message maps\"\n  - \"ON_COMMAND_RANGE macro\"\n  - \"TN006\"\n  - \"ON_CONTROL macro\"\n  - \"ON_COMMAND_EX macro\"\n  - \"message maps [C++], Windows messaging\"\nms.assetid: af4b6794-4b40-4f1e-ad41-603c3b7409bb\ncaps.latest.revision: 16\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# TN006: Message Maps\nThis note describes the MFC message map facility.  \n  \n## The Problem  \n Microsoft Windows implements virtual functions in window classes that use its messaging facility. Due to the large number of messages involved, providing a separate virtual function for each Windows message would create a prohibitively large vtable.  \n  \n Because the number of system-defined Windows messages changes over time, and because applications can define their own Windows messages, message maps provide a level of indirection that prevents interface changes from breaking existing code.  \n  \n## Overview  \n MFC provides an alternative to the switch statement that was used in traditional Windows-based programs to handle messages sent to a window. A mapping from messages to methods can be defined so that when a message is received by a window, the appropriate method is called automatically. This message-map facility is designed to resemble virtual functions but has additional benefits not possible with C++ virtual functions.  \n  \n## Defining a Message Map  \n The [DECLARE_MESSAGE_MAP](http://msdn.microsoft.com/library/c225e7e0-a81b-495c-97f9-3e0aa1f65036) macro declares three members for a class.  \n  \n-   A private array of `AFX_MSGMAP_ENTRY` entries called `_messageEntries`.  \n  \n-   A protected `AFX_MSGMAP` structure called `messageMap` that points to the `_messageEntries` array.  \n  \n-   A protected virtual function called `GetMessageMap` that returns the address of `messageMap`.  \n  \n This macro should be put in the declaration of any class using message maps. By convention, it is at the end of the class declaration. For example:  \n  \n```  \nclass CMyWnd : public CMyParentWndClass  \n{ *// my stuff...  \n \nprotected: *//{{AFX_MSG(CMyWnd)  \n    afx_msg void OnPaint();\n*//}}AFX_MSG  \n \n    DECLARE_MESSAGE_MAP() \n};  \n```  \n  \n This is the format generated by AppWizard and ClassWizard when they create new classes. The //{{ and //}} brackets are needed for ClassWizard.  \n  \n The message map's table is defined by using a set of macros that expand to message map entries. A table starts with a [BEGIN_MESSAGE_MAP](http://msdn.microsoft.com/library/d9201e18-04e0-4639-9810-f15768627fc2) macro call, which defines the class that is handled by this message map and the parent class to which unhandled messages are passed. The table ends with the [END_MESSAGE_MAP](http://msdn.microsoft.com/library/40f611f1-a3b4-4097-b683-091bf7cfab8b) macro call.  \n  \n Between these two macro calls is an entry for each message to be handled by this message map. Every standard Windows message has a macro of the form ON_WM_*MESSAGE_NAME* that generates an entry for that message.  \n  \n A standard function signature has been defined for unpacking the parameters of each Windows message and providing type safety. These signatures may be found in the file Afxwin.h in the declaration of [CWnd](../mfc/reference/cwnd-class.md). Each one is marked with the keyword `afx_msg` for easy identification.  \n  \n> [!NOTE]\n>  ClassWizard requires that you use the `afx_msg` keyword in your message map handler declarations.  \n  \n These function signatures were derived by using a simple convention. The name of the function always starts with `\"On`\". This is followed by the name of the Windows message with the \"WM_\" removed and the first letter of each word capitalized. The ordering of the parameters is `wParam` followed by `LOWORD`(`lParam`) then `HIWORD`(`lParam`). Unused parameters are not passed. Any handles that are wrapped by MFC classes are converted to pointers to the appropriate MFC objects. The following example shows how to handle the `WM_PAINT` message and cause the `CMyWnd::OnPaint` function to be called:  \n  \n```  \nBEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass) *//{{AFX_MSG_MAP(CMyWnd)  \n    ON_WM_PAINT() *//}}AFX_MSG_MAP  \nEND_MESSAGE_MAP()  \n```  \n  \n The message map table must be defined outside the scope of any function or class definition. It should not be put in an extern \"C\" block.  \n  \n> [!NOTE]\n>  ClassWizard will modify the message map entries that occur between the //{{ and //}} comment bracket.  \n  \n## User Defined Windows Messages  \n User-defined messages may be included in a message map by using the [ON_MESSAGE](http://msdn.microsoft.com/library/e2faeb13-9f6e-4c0d-9f6d-b2e141a0db1e) macro. This macro accepts a message number and a method of the form:  \n  \n``` *// inside the class declaration  \n    afx_msg LRESULT OnMyMessage(WPARAM wParam,\n    LPARAM lParam);\n\n \n #define WM_MYMESSAGE (WM_USER + 100)  \n \nBEGIN_MESSAGE_MAP(CMyWnd,\n    CMyParentWndClass)  \n    ON_MESSAGE(WM_MYMESSAGE,\n    OnMyMessage)  \nEND_MESSAGE_MAP()  \n```  \n  \n In this example, we establish a handler for a custom message that has a Windows message ID derived from the standard `WM_USER` base for user-defined messages. The following example shows how to call this handler:  \n  \n```  \nCWnd* pWnd = ...;  \npWnd->SendMessage(WM_MYMESSAGE);\n```  \n  \n The range of user-defined messages that use this approach must be in the range `WM_USER` to 0x7fff.  \n  \n> [!NOTE]\n>  ClassWizard does not support entering `ON_MESSAGE` handler routines from the ClassWizard user interface. You must manually enter them from the Visual C++ editor. ClassWizard will parse these entries and let you browse them just like any other message-map entries.  \n  \n## Registered Windows Messages  \n The [RegisterWindowMessage](http://msdn.microsoft.com/library/windows/desktop/ms644947) function is used to define a new window message that is guaranteed to be unique throughout the system. The macro `ON_REGISTERED_MESSAGE` is used to handle these messages. This macro accepts a name of a `UINT NEAR` variable that contains the registered windows message ID. For example  \n  \n```  \nclass CMyWnd : public CMyParentWndClass  \n{  \npublic:  \n    CMyWnd();\n\n *//{{AFX_MSG(CMyWnd)  \n    afx_msg LRESULT OnFind(WPARAM wParam,\n    LPARAM lParam);\n*//}}AFX_MSG  \n \n    DECLARE_MESSAGE_MAP() \n};  \n \nstatic UINT NEAR WM_FIND = RegisterWindowMessage(\"COMMDLG_FIND\");\n\n \nBEGIN_MESSAGE_MAP(CMyWnd,\n    CMyParentWndClass) *//{{AFX_MSG_MAP(CMyWnd)  \n    ON_REGISTERED_MESSAGE(WM_FIND,\n    OnFind) *//}}AFX_MSG_MAP  \nEND_MESSAGE_MAP()  \n```  \n  \n The registered Windows message ID variable (WM_FIND in this example) must be a `NEAR` variable because of the way `ON_REGISTERED_MESSAGE` is implemented.  \n  \n The range of user-defined messages that use this approach will be in the range 0xC000 to 0xFFFF.  \n  \n> [!NOTE]\n>  ClassWizard does not support entering `ON_REGISTERED_MESSAGE` handler routines from the ClassWizard user interface. You must manually enter them from the text editor. ClassWizard will parse these entries and let you browse them just like any other message-map entries.  \n  \n## Command Messages  \n Command messages from menus and accelerators are handled in message maps with the `ON_COMMAND` macro. This macro accepts a command ID and a method. Only the specific `WM_COMMAND` message that has a `wParam` equal to the specified command ID is handled by the method specified in the message-map entry. Command handler member functions take no parameters and return `void`. The macro has the following form:  \n  \n```  \nON_COMMAND(id, memberFxn)  \n```  \n  \n Command update messages are routed through the same mechanism, but use the `ON_UPDATE_COMMAND_UI` macro instead. Command update handler member functions take a single parameter, a pointer to a [CCmdUI](../mfc/reference/ccmdui-class.md) object, and return `void`. The macro has the form  \n  \n```  \nON_UPDATE_COMMAND_UI(id, memberFxn)  \n```  \n  \n Advanced users can use the `ON_COMMAND_EX` macro, which is an extended form of command message handlers. The macro provides a superset of the `ON_COMMAND` functionality. Extended command-handler member functions take a single parameter, a `UINT` that contains the command ID, and return a `BOOL`. The return value should be `TRUE` to indicate that the command has been handled. Otherwise routing will continue to other command target objects.  \n  \n Examples of these forms:  \n  \n-   Inside Resource.h (usually generated by Visual C++)  \n  \n ```  \n #define    ID_MYCMD      100  \n #define    ID_COMPLEX    101  \n ```  \n  \n-   Inside the class declaration  \n  \n ```  \n    afx_msg void OnMyCommand();\nafx_msg void OnUpdateMyCommand(CCmdUI* pCmdUI);\n\n    afx_msg BOOL OnComplexCommand(UINT nID);\n\n ```  \n  \n-   Inside the message map definition  \n  \n ```  \n    ON_COMMAND(ID_MYCMD,\n    OnMyCommand)  \n    ON_UPDATE_COMMAND_UI(ID_MYCMD,\n    OnUpdateMyCommand)  \n    ON_COMMAND_EX(ID_MYCMD,\n    OnComplexCommand)  \n ```  \n  \n-   In the implementation file  \n  \n ```  \n    void CMyClass::OnMyCommand()  \n { *// handle the command  \n }  \n \n    void CMyClass::OnUpdateMyCommand(CCmdUI* pCmdUI)  \n { *// set the UI state with pCmdUI  \n }  \n \n    BOOL CMyClass::OnComplexCommand(UINT nID)  \n { *// handle the command  \n    return TRUE;  \n }  \n ```  \n  \n Advanced users can handle a range of commands by using a single command handler: [ON_COMMAND_RANGE](http://msdn.microsoft.com/library/c52719fc-dd6e-48c9-af79-383f48d608e0) or `ON_COMMAND_RANGE_EX`. See the product documentation for more information about these macros.  \n  \n> [!NOTE]\n>  ClassWizard supports creating `ON_COMMAND` and `ON_UPDATE_COMMAND_UI` handlers, but it does not support creating `ON_COMMAND_EX` or `ON_COMMAND_RANGE` handlers. However, Class Wizard will parse and let you browse all four command handler variants.  \n  \n## Control Notification Messages  \n Messages that are sent from child controls to a window have an extra bit of information in their message map entry: the control's ID. The message handler specified in a message map entry is called only if the following conditions are true:  \n  \n-   The control notification code (high word of `lParam`), such as BN_CLICKED, matches the notification code specified in the message-map entry.  \n  \n-   The control ID (`wParam`) matches the control ID specified in the message-map entry.  \n  \n Custom control notification messages may use the [ON_CONTROL](http://msdn.microsoft.com/library/2cb7ebdf-296b-4606-b191-3449835003db) macro to define a message map entry with a custom notification code. This macro has the form  \n  \n```  \nON_CONTROL(wNotificationCode,\n    id,\n    memberFxn)  \n```  \n  \n For advanced usage [ON_CONTROL_RANGE](http://msdn.microsoft.com/library/46f0e1bb-569b-4b8b-9b80-89701d1cd7fd) can be used to handle a specific control notification from a range of controls with the same handler.  \n  \n> [!NOTE]\n>  ClassWizard does not support creating an `ON_CONTROL` or `ON_CONTROL_RANGE` handler in the user interface. You must manually enter them with the text editor. ClassWizard will parse these entries and let you browse them just like any other message map entries.  \n  \n The Windows Common Controls use the more powerful [WM_NOTIFY](http://msdn.microsoft.com/library/windows/desktop/bb775583) for complex control notifications. This version of MFC has direct support for this new message by using the `ON_NOTIFY` and `ON_NOTIFY_RANGE` macros. See the product documentation for more information about these macros.  \n  \n## See Also  \n [Technical Notes by Number](../mfc/technical-notes-by-number.md)   \n [Technical Notes by Category](../mfc/technical-notes-by-category.md)\n\n"}