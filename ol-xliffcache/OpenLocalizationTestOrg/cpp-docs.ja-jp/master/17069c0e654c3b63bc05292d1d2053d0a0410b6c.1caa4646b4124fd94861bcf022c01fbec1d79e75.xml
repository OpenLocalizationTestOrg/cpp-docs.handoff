{"nodes":[{"pos":[12,65],"content":"abstract  (C++ Component Extensions) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"abstract  (C++ Component Extensions) | Microsoft Docs","pos":[0,53]}]},{"content":"abstract  (C++ Component Extensions)","pos":[656,692]},{"pos":[693,732],"content":"The <ph id=\"ph1\">`abstract`</ph> keyword declares either:","source":"The `abstract` keyword declares either:"},{"content":"A type can be used as a base type, but the type itself cannot be instantiated.","pos":[742,820]},{"content":"A type member function can be defined only in a derived type.","pos":[830,891]},{"content":"All Platforms","pos":[900,913]},{"content":"Syntax","pos":[919,925]},{"content":"Remarks","pos":[1088,1095]},{"content":"The first example syntax declares a class to be abstract.","pos":[1104,1161]},{"content":"The <bpt id=\"p1\">*</bpt>class-declaration<ept id=\"p1\">*</ept> component can be either a native C++ declaration (<ph id=\"ph1\">`class`</ph> or <ph id=\"ph2\">`struct`</ph>), or a C++ extension declaration (<ph id=\"ph3\">`ref class`</ph> or <ph id=\"ph4\">`ref struct`</ph>) if the <bpt id=\"p2\">**</bpt>/ZW<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>/clr<ept id=\"p3\">**</ept> compiler option is specified.","pos":[1162,1375],"source":" The *class-declaration* component can be either a native C++ declaration (`class` or `struct`), or a C++ extension declaration (`ref class` or `ref struct`) if the **/ZW** or **/clr** compiler option is specified."},{"content":"The second example syntax declares a virtual member function to be abstract.","pos":[1382,1458]},{"content":"Declaring a function abstract is the same as declaring it a pure virtual function.","pos":[1459,1541]},{"content":"Declaring a member function abstract also causes the enclosing class to be declared abstract.","pos":[1542,1635]},{"pos":[1642,1800],"content":"The <ph id=\"ph1\">`abstract`</ph> keyword is supported in native and platform-specific code; that is, it can be compiled with or without the <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>/clr<ept id=\"p2\">**</ept> compiler option.","source":"The `abstract` keyword is supported in native and platform-specific code; that is, it can be compiled with or without the **/ZW** or **/clr** compiler option."},{"content":"You can detect at compile time if a type is abstract with the <ph id=\"ph1\">`__is_abstract(``type``)`</ph> type trait.","pos":[1807,1906],"source":"You can detect at compile time if a type is abstract with the `__is_abstract(``type``)` type trait."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Compiler Support for Type Traits<ept id=\"p1\">](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)</ept>.","pos":[1907,2041],"source":" For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md)."},{"content":"The <ph id=\"ph1\">`abstract`</ph> keyword is a context-sensitive override specifier.","pos":[2048,2113],"source":"The `abstract` keyword is a context-sensitive override specifier."},{"content":"For more information about context-sensitive keywords, see <bpt id=\"p1\">[</bpt>Context-Sensitive Keywords<ept id=\"p1\">](../windows/context-sensitive-keywords-cpp-component-extensions.md)</ept>.","pos":[2114,2269],"source":" For more information about context-sensitive keywords, see [Context-Sensitive Keywords](../windows/context-sensitive-keywords-cpp-component-extensions.md)."},{"content":"For more information about override specifiers, see <bpt id=\"p1\">[</bpt>How to: Declare Override Specifiers in Native Compilations<ept id=\"p1\">](../dotnet/how-to-declare-override-specifiers-in-native-compilations-cpp-cli.md)</ept>.","pos":[2270,2463],"source":" For more information about override specifiers, see [How to: Declare Override Specifiers in Native Compilations](../dotnet/how-to-declare-override-specifiers-in-native-compilations-cpp-cli.md)."},{"pos":[2528,2642],"content":"For more information, see <bpt id=\"p1\">[</bpt>Ref classes and structs<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/hh699870.aspx)</ept>.","source":"For more information, see [Ref classes and structs](http://msdn.microsoft.com/library/windows/apps/hh699870.aspx)."},{"content":"Requirements","pos":[2652,2664]},{"pos":[2668,2692],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Requirements","pos":[2782,2794]},{"pos":[2798,2823],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"},{"content":"Examples","pos":[2833,2841]},{"content":"Example","pos":[2847,2854]},{"pos":[2863,2948],"content":"The following code example generates an error because class <ph id=\"ph1\">`X`</ph> is marked <ph id=\"ph2\">`abstract`</ph>.","source":"The following code example generates an error because class `X` is marked `abstract`."},{"content":"Example","pos":[3144,3151]},{"content":"The following code example generates an error because it instantiates a native class that is marked <ph id=\"ph1\">`abstract`</ph>.","pos":[3160,3271],"source":"The following code example generates an error because it instantiates a native class that is marked `abstract`."},{"content":"This error will occur with or without the <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> compiler option.","pos":[3272,3339],"source":" This error will occur with or without the **/clr** compiler option."},{"content":"Example","pos":[3614,3621]},{"content":"The following code example generates an error because function <ph id=\"ph1\">`f`</ph> includes a definition but is marked <ph id=\"ph2\">`abstract`</ph>.","pos":[3630,3744],"source":"The following code example generates an error because function `f` includes a definition but is marked `abstract`."},{"content":"The final statement in the example shows that declaring an abstract virtual function is equivalent to declaring a pure virtual function.","pos":[3745,3881]},{"content":"See Also","pos":[4073,4081]},{"content":"Component Extensions for Runtime Platforms","pos":[4086,4128]}],"content":"---\ntitle: \"abstract  (C++ Component Extensions) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\nf1_keywords: \n  - \"abstract\"\n  - \"abstract_cpp\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"abstract keyword [C++]\"\nms.assetid: cbae3408-0378-4ac8-b70d-c016b381a6d5\ncaps.latest.revision: 21\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# abstract  (C++ Component Extensions)\nThe `abstract` keyword declares either:  \n  \n-   A type can be used as a base type, but the type itself cannot be instantiated.  \n  \n-   A type member function can be defined only in a derived type.  \n  \n## All Platforms  \n **Syntax**  \n  \n```  \n  \n      class-declaration  \n      class-identifier  \n      abstract {}  \nvirtualreturn-typemember-function-identifier() abstract ;  \n  \n```  \n  \n **Remarks**  \n  \n The first example syntax declares a class to be abstract. The *class-declaration* component can be either a native C++ declaration (`class` or `struct`), or a C++ extension declaration (`ref class` or `ref struct`) if the **/ZW** or **/clr** compiler option is specified.  \n  \n The second example syntax declares a virtual member function to be abstract. Declaring a function abstract is the same as declaring it a pure virtual function. Declaring a member function abstract also causes the enclosing class to be declared abstract.  \n  \n The `abstract` keyword is supported in native and platform-specific code; that is, it can be compiled with or without the **/ZW** or **/clr** compiler option.  \n  \n You can detect at compile time if a type is abstract with the `__is_abstract(``type``)` type trait. For more information, see [Compiler Support for Type Traits](../windows/compiler-support-for-type-traits-cpp-component-extensions.md).  \n  \n The `abstract` keyword is a context-sensitive override specifier. For more information about context-sensitive keywords, see [Context-Sensitive Keywords](../windows/context-sensitive-keywords-cpp-component-extensions.md). For more information about override specifiers, see [How to: Declare Override Specifiers in Native Compilations](../dotnet/how-to-declare-override-specifiers-in-native-compilations-cpp-cli.md).  \n  \n## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  \n For more information, see [Ref classes and structs](http://msdn.microsoft.com/library/windows/apps/hh699870.aspx).  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  \n  \n### Requirements  \n Compiler option: **/clr**  \n  \n### Examples  \n **Example**  \n  \n The following code example generates an error because class `X` is marked `abstract`.  \n  \n```  \n// abstract_keyword.cpp  \n// compile with: /clr  \nref class X abstract {  \npublic:  \n   virtual void f() {}  \n};  \n  \nint main() {  \n   X ^ MyX = gcnew X;   // C3622  \n}  \n```  \n  \n **Example**  \n  \n The following code example generates an error because it instantiates a native class that is marked `abstract`. This error will occur with or without the **/clr** compiler option.  \n  \n```  \n// abstract_keyword_2.cpp  \nclass X abstract {  \npublic:  \n   virtual void f() {}  \n};  \n  \nint main() {  \n   X * MyX = new X; // C3622: 'X': a class declared as 'abstract'  \n                    // cannot be instantiated. See declaration of 'X'}  \n  \n```  \n  \n **Example**  \n  \n The following code example generates an error because function `f` includes a definition but is marked `abstract`. The final statement in the example shows that declaring an abstract virtual function is equivalent to declaring a pure virtual function.  \n  \n```  \n// abstract_keyword_3.cpp  \n// compile with: /clr  \nref class X {  \npublic:  \n   virtual void f() abstract {}   // C3634  \n   virtual void g() = 0 {}   // C3634  \n};  \n```  \n  \n## See Also  \n [Component Extensions for Runtime Platforms](../windows/component-extensions-for-runtime-platforms.md)"}