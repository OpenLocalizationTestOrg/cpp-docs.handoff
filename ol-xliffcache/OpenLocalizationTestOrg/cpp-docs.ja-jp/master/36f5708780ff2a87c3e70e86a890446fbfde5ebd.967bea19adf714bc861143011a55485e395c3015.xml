{"nodes":[{"pos":[12,50],"content":"C Runtime Error R6035 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"C Runtime Error R6035 | Microsoft Docs","pos":[0,38]}]},{"content":"C Runtime Error R6035","pos":[624,645]},{"content":"Microsoft Visual C++ Runtime Library, Error R6035 - A module in this application is initializing the module's global security cookie while a function relying on that security cookie is active.","pos":[646,838]},{"content":"Call __security_init_cookie earlier.","pos":[840,876]},{"pos":[883,1033],"content":"<bpt id=\"p1\">[</bpt>__security_init_cookie<ept id=\"p1\">](../../c-runtime-library/reference/security-init-cookie.md)</ept> must be called before the first use of the global security cookie.","source":"[__security_init_cookie](../../c-runtime-library/reference/security-init-cookie.md) must be called before the first use of the global security cookie."},{"content":"The global security cookie is used for buffer overrun protection in code compiled with <bpt id=\"p1\">[</bpt>/GS (Buffer Security Check)<ept id=\"p1\">](../../build/reference/gs-buffer-security-check.md)</ept> and in code that uses structured exception handling.","pos":[1040,1260],"source":"The global security cookie is used for buffer overrun protection in code compiled with [/GS (Buffer Security Check)](../../build/reference/gs-buffer-security-check.md) and in code that uses structured exception handling."},{"content":"Essentially, on entry to an overrun-protected function, the cookie is put on the stack, and on exit, the value on the stack is compared against the global cookie.","pos":[1261,1423]},{"content":"Any difference between them indicates that a buffer overrun has occurred and results in immediate termination of the program.","pos":[1424,1549]},{"content":"Error R6035 indicates that a call to <ph id=\"ph1\">`__security_init_cookie`</ph> was made after a protected function was entered.","pos":[1556,1666],"source":"Error R6035 indicates that a call to `__security_init_cookie` was made after a protected function was entered."},{"content":"If execution were to continue, a spurious buffer overrun would be detected because the cookie on the stack would no longer match the global cookie.","pos":[1667,1814]},{"content":"Consider the following DLL example.","pos":[1821,1856]},{"content":"The DLL entry point is set to DllEntryPoint through the linker <bpt id=\"p1\">[</bpt>/ENTRY (Entry-Point Symbol)<ept id=\"p1\">](../../build/reference/entry-entry-point-symbol.md)</ept> option.","pos":[1857,2008],"source":" The DLL entry point is set to DllEntryPoint through the linker [/ENTRY (Entry-Point Symbol)](../../build/reference/entry-entry-point-symbol.md) option."},{"content":"This bypasses the CRT's initialization which would ordinarily initialize the global security cookie, so the DLL itself must call <ph id=\"ph1\">`__security_init_cookie`</ph>.","pos":[2009,2163],"source":" This bypasses the CRT's initialization which would ordinarily initialize the global security cookie, so the DLL itself must call `__security_init_cookie`."},{"content":"This example will generate error R6035 because DllEntryPoint uses structured exception handling and therefore uses the security cookie to detect buffer overruns.","pos":[2419,2580]},{"content":"By the time DllInitialize is called, the global security cookie has already been put on the stack.","pos":[2581,2679]},{"content":"The correct way is demonstrated in this example:","pos":[2686,2734]},{"content":"In this case, DllEntryPoint is not protected against buffer overruns (it has no local string buffers and doesn't use structured exception handling); therefore it can safely call <ph id=\"ph1\">`__security_init_cookie`</ph>.","pos":[2994,3197],"source":"In this case, DllEntryPoint is not protected against buffer overruns (it has no local string buffers and doesn't use structured exception handling); therefore it can safely call `__security_init_cookie`."},{"content":"It then calls a helper function that is protected.","pos":[3198,3248]},{"pos":[3256,3475],"content":"[!NOTE]\n Error message R6035 is only generated by the x86 debug CRT, and only for structured exception handling, but the condition is an error on all platforms, and for all forms of exception handling, such as C++ EH.","leadings":["","> "],"nodes":[{"content":"Error message R6035 is only generated by the x86 debug CRT, and only for structured exception handling, but the condition is an error on all platforms, and for all forms of exception handling, such as C++ EH.","pos":[9,217]}]},{"content":"See Also","pos":[3484,3492]},{"content":"Compiler Security Checks In Depth","pos":[3497,3530]}],"content":"---\ntitle: \"C Runtime Error R6035 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"R6035\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"R6035\"\nms.assetid: f8fb50b8-18bf-4258-b96a-b0a9de468d16\ncaps.latest.revision: 6\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# C Runtime Error R6035\nMicrosoft Visual C++ Runtime Library, Error R6035 - A module in this application is initializing the module's global security cookie while a function relying on that security cookie is active.  Call __security_init_cookie earlier.  \n  \n [__security_init_cookie](../../c-runtime-library/reference/security-init-cookie.md) must be called before the first use of the global security cookie.  \n  \n The global security cookie is used for buffer overrun protection in code compiled with [/GS (Buffer Security Check)](../../build/reference/gs-buffer-security-check.md) and in code that uses structured exception handling. Essentially, on entry to an overrun-protected function, the cookie is put on the stack, and on exit, the value on the stack is compared against the global cookie. Any difference between them indicates that a buffer overrun has occurred and results in immediate termination of the program.  \n  \n Error R6035 indicates that a call to `__security_init_cookie` was made after a protected function was entered. If execution were to continue, a spurious buffer overrun would be detected because the cookie on the stack would no longer match the global cookie.  \n  \n Consider the following DLL example. The DLL entry point is set to DllEntryPoint through the linker [/ENTRY (Entry-Point Symbol)](../../build/reference/entry-entry-point-symbol.md) option. This bypasses the CRT's initialization which would ordinarily initialize the global security cookie, so the DLL itself must call `__security_init_cookie`.  \n  \n```  \n// Wrong way to call __security_init_cookie  \nDllEntryPoint(...) {  \n   DllInitialize();  \n   ...  \n   __try {  \n      ...  \n   } __except()... {  \n      ...  \n   }  \n}  \n  \nvoid DllInitialize() {  \n   __security_init_cookie();  \n}  \n```  \n  \n This example will generate error R6035 because DllEntryPoint uses structured exception handling and therefore uses the security cookie to detect buffer overruns. By the time DllInitialize is called, the global security cookie has already been put on the stack.  \n  \n The correct way is demonstrated in this example:  \n  \n```  \n// Correct way to call __security_init_cookie  \nDllEntryPoint(...) {  \n   __security_init_cookie();  \n   DllEntryHelper();  \n}  \n  \nvoid DllEntryHelper() {  \n   ...  \n   __try {  \n      ...  \n   } __except()... {  \n      ...  \n   }  \n}  \n```  \n  \n In this case, DllEntryPoint is not protected against buffer overruns (it has no local string buffers and doesn't use structured exception handling); therefore it can safely call `__security_init_cookie`. It then calls a helper function that is protected.  \n  \n> [!NOTE]\n>  Error message R6035 is only generated by the x86 debug CRT, and only for structured exception handling, but the condition is an error on all platforms, and for all forms of exception handling, such as C++ EH.  \n  \n## See Also  \n [Compiler Security Checks In Depth](http://go.microsoft.com/fwlink/?linkid=7260)"}