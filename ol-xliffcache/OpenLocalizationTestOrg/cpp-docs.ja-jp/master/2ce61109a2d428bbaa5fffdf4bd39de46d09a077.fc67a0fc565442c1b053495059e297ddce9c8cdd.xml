{"nodes":[{"pos":[12,49],"content":"Compiler Error C2666 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Compiler Error C2666 | Microsoft Docs","pos":[0,37]}]},{"content":"Compiler Error C2666","pos":[624,644]},{"content":"'identifier' : number overloads have similar conversions","pos":[645,701]},{"content":"An overloaded function or operator is ambiguous.","pos":[708,756]},{"content":"Formal parameter lists may be too similar for the compiler to resolve the ambiguity.","pos":[759,843]},{"content":"To resolve this error, explicitly cast one or more of the actual parameters.","pos":[845,921]},{"content":"The following sample generates C2666:","pos":[928,965]},{"content":"This error can also be generated as a result of compiler conformance work that was done for Visual Studio .NET 2003:","pos":[1146,1262]},{"content":"binary operators and user-defined conversions to pointer types","pos":[1272,1334]},{"content":"qualification conversion is not the same as identity conversion","pos":[1344,1407]},{"content":"For the binary operators <ph id=\"ph1\">\\&lt;</ph>, &gt;, <ph id=\"ph2\">\\&lt;</ph>=, and &gt;=, a passed parameter is now implicitly converted to the type of the operand if the parameter's type defines a user-defined conversion operator to convert to the type of the operand.","pos":[1414,1638],"source":"For the binary operators \\<, >, \\<=, and >=, a passed parameter is now implicitly converted to the type of the operand if the parameter's type defines a user-defined conversion operator to convert to the type of the operand."},{"content":"There is now potential for ambiguity.","pos":[1639,1676]},{"content":"For code that is valid in both the Visual Studio .NET 2003 and Visual Studio .NET versions of Visual C++, call the class operator explicitly using function syntax.","pos":[1683,1846]},{"content":"Example","pos":[1855,1862]},{"content":"Example","pos":[3040,3047]},{"content":"The following sample generates C2666","pos":[3051,3087]}],"content":"---\ntitle: \"Compiler Error C2666 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"error-reference\"\nf1_keywords: \n  - \"C2666\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"C2666\"\nms.assetid: 78364d15-c6eb-439a-9088-e04a0176692b\ncaps.latest.revision: 11\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Compiler Error C2666\n'identifier' : number overloads have similar conversions  \n  \n An overloaded function or operator is ambiguous.   Formal parameter lists may be too similar for the compiler to resolve the ambiguity.  To resolve this error, explicitly cast one or more of the actual parameters.  \n  \n The following sample generates C2666:  \n  \n```  \n// C2666.cpp  \nstruct complex {  \n   complex(double);  \n};  \n  \nvoid h(int,complex);  \nvoid h(double, double);  \n  \nint main() {  \n   h(3,4);   // C2666  \n}  \n```  \n  \n This error can also be generated as a result of compiler conformance work that was done for Visual Studio .NET 2003:  \n  \n-   binary operators and user-defined conversions to pointer types  \n  \n-   qualification conversion is not the same as identity conversion  \n  \n For the binary operators \\<, >, \\<=, and >=, a passed parameter is now implicitly converted to the type of the operand if the parameter's type defines a user-defined conversion operator to convert to the type of the operand. There is now potential for ambiguity.  \n  \n For code that is valid in both the Visual Studio .NET 2003 and Visual Studio .NET versions of Visual C++, call the class operator explicitly using function syntax.  \n  \n## Example  \n  \n```  \n// C2666b.cpp  \n#include <string.h>  \n#include <stdio.h>  \n  \nstruct T   \n{  \n    T( const T& copy )   \n    {  \n        m_str = copy.m_str;  \n    }  \n  \n    T( const char* str )   \n    {  \n        int iSize = (strlen( str )+ 1);  \n        m_str = new char[ iSize ];  \n        if (m_str)  \n            strcpy_s( m_str, iSize, str );  \n    }  \n  \n    bool operator<( const T& RHS )   \n    {  \n        return m_str < RHS.m_str;  \n    }  \n  \n    operator char*() const   \n    {  \n        return m_str;  \n    }  \n  \n    char* m_str;  \n};  \n  \nint main()   \n{  \n    T str1( \"ABCD\" );  \n    const char* str2 = \"DEFG\";  \n  \n    // Error â€“ Ambiguous call to operator<()  \n    // Trying to convert str1 to char* and then call   \n    // operator<( const char*, const char* )?  \n    //  OR  \n    // trying to convert str2 to T and then call  \n    // T::operator<( const T& )?  \n  \n    if( str1 < str2 )   // C2666  \n  \n    if ( str1.operator < ( str2 ) )   // Treat str2 as type T  \n        printf_s(\"str1.operator < ( str2 )\\n\");  \n  \n    if ( str1.operator char*() < str2 )   // Treat str1 as type char*  \n        printf_s(\"str1.operator char*() < str2\\n\");  \n}  \n```  \n  \n## Example  \n The following sample generates C2666  \n  \n```  \n// C2666c.cpp  \n// compile with: /c  \n  \nenum E   \n{  \n    E_A,   E_B  \n};  \n  \nclass A   \n{  \n    int h(const E e) const {return 0; }  \n    int h(const int i) { return 1; }  \n    // Uncomment the following line to resolve.  \n    // int h(const E e) { return 0; }  \n  \n    void Test()   \n    {  \n        h(E_A);   // C2666  \n        h((const int) E_A);  \n        h((int) E_A);  \n    }  \n};  \n```"}