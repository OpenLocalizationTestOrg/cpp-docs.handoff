{"nodes":[{"pos":[12,49],"content":"priority_queue Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"priority_queue Class | Microsoft Docs","pos":[0,37]}]},{"pos":[665,685],"content":"priority_queue Class","linkify":"priority_queue Class","nodes":[{"content":"priority_queue Class","pos":[0,20]}]},{"content":"A template container adaptor class that provides a restriction of functionality limiting access to the top element of some underlying container type, which is always the largest or of the highest priority.","pos":[686,891]},{"content":"New elements can be added to the priority_queue and the top element of the priority_queue can be inspected or removed.","pos":[892,1010]},{"pos":[1019,1025],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[1185,1195],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">*</bpt>Type<ept id=\"p1\">*</ept>","pos":[1199,1205],"source":"*Type*"},{"content":"The element data type to be stored in the priority_queue.","pos":[1209,1266]},{"content":"The type of the underlying container used to implement the priority_queue.","pos":[1288,1362]},{"content":"<bpt id=\"p1\">*</bpt>Compare<ept id=\"p1\">*</ept>","pos":[1369,1378],"source":"*Compare*"},{"content":"The type that provides a function object that can compare two element values as sort keys to determine their relative order in the priority_queue.","pos":[1382,1528]},{"content":"This argument is optional and the binary predicate <bpt id=\"p1\">**</bpt>less<ept id=\"p1\">**</ept><bpt id=\"p2\">*</bpt><ph id=\"ph1\">\\&lt;</ph><ept id=\"p2\">*</ept><bpt id=\"p3\">**</bpt>typename<ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt>Container<ept id=\"p4\">*</ept><bpt id=\"p5\">**</bpt>::value_type<ept id=\"p5\">**</ept><bpt id=\"p6\">*</bpt><ph id=\"ph2\">&gt;</ph><ept id=\"p6\">*</ept> is the default value.","pos":[1529,1657],"source":" This argument is optional and the binary predicate **less***\\<***typename** *Container***::value_type***>* is the default value."},{"pos":[1666,1673],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The elements of class <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> stipulated in the first template parameter of a queue object are synonymous with <bpt id=\"p2\">[</bpt>value_type<ept id=\"p2\">](#priority_queue__value_type)</ept> and must match the type of element in the underlying container class <bpt id=\"p3\">**</bpt>Container<ept id=\"p3\">**</ept> stipulated by the second template parameter.","pos":[1677,1958],"source":"The elements of class **Type** stipulated in the first template parameter of a queue object are synonymous with [value_type](#priority_queue__value_type) and must match the type of element in the underlying container class **Container** stipulated by the second template parameter."},{"content":"The <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> must be assignable, so that it is possible to copy objects of that type and to assign values to variables of that type.","pos":[1959,2091],"source":" The **Type** must be assignable, so that it is possible to copy objects of that type and to assign values to variables of that type."},{"content":"The priority_queue orders the sequence it controls by calling a stored function object of class <bpt id=\"p1\">**</bpt>Traits<ept id=\"p1\">**</ept>.","pos":[2098,2205],"source":"The priority_queue orders the sequence it controls by calling a stored function object of class **Traits**."},{"content":"In general, the elements need be merely less than comparable to establish this order: so that, given any two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other.","pos":[2206,2464]},{"content":"This results in an ordering between the nonequivalent elements.","pos":[2465,2528]},{"content":"On a more technical note, the comparison function is a binary predicate that induces a strict weak ordering in the standard mathematical sense.","pos":[2529,2672]},{"content":"Suitable underlying container classes for priority_queue include <bpt id=\"p1\">[</bpt>deque Class<ept id=\"p1\">](../standard-library/deque-class.md)</ept> and the default <bpt id=\"p2\">[</bpt>vector Class<ept id=\"p2\">](../standard-library/vector-class.md)</ept> or any other sequence container that supports the operations of <ph id=\"ph1\">`front`</ph>, <ph id=\"ph2\">`push_back`</ph>, and <ph id=\"ph3\">`pop_back`</ph> and a random-access iterator.","pos":[2679,2992],"source":"Suitable underlying container classes for priority_queue include [deque Class](../standard-library/deque-class.md) and the default [vector Class](../standard-library/vector-class.md) or any other sequence container that supports the operations of `front`, `push_back`, and `pop_back` and a random-access iterator."},{"content":"The underlying container class is encapsulated within the container adaptor, which exposes only the limited set of the sequence container member functions as a public interface.","pos":[2993,3170]},{"content":"Adding elements to and removing elements from a <ph id=\"ph1\">`priority_queue`</ph> both have logarithmic complexity.","pos":[3177,3275],"source":"Adding elements to and removing elements from a `priority_queue` both have logarithmic complexity."},{"content":"Accessing elements in a <ph id=\"ph1\">`priority_queue`</ph> has constant complexity.","pos":[3276,3341],"source":" Accessing elements in a `priority_queue` has constant complexity."},{"content":"There are three types of container adaptors defined by the STL: stack, queue, and priority_queue.","pos":[3348,3445]},{"content":"Each restricts the functionality of some underlying container class to provide a precisely controlled interface to a standard data structure.","pos":[3446,3587]},{"content":"The <bpt id=\"p1\">[</bpt>stack Class<ept id=\"p1\">](../standard-library/stack-class.md)</ept> supports a last-in, first-out (LIFO) data structure.","pos":[3597,3703],"source":"The [stack Class](../standard-library/stack-class.md) supports a last-in, first-out (LIFO) data structure."},{"content":"A good analogue to keep in mind would be a stack of plates.","pos":[3704,3763]},{"content":"Elements (plates) may be inserted, inspected, or removed only from the top of the stack, which is the last element at the end of the base container.","pos":[3764,3912]},{"content":"The restriction to accessing only the top element is the reason for using the stack class.","pos":[3913,4003]},{"content":"The <bpt id=\"p1\">[</bpt>queue Class<ept id=\"p1\">](../standard-library/queue-class.md)</ept> supports a first-in, first-out (FIFO) data structure.","pos":[4013,4120],"source":"The [queue Class](../standard-library/queue-class.md) supports a first-in, first-out (FIFO) data structure."},{"content":"A good analogue to keep in mind would be people lining up for a bank teller.","pos":[4121,4197]},{"content":"Elements (people) may be added to the back of the line and are removed from the front of the line.","pos":[4198,4296]},{"content":"Both the front and the back of a line may be inspected.","pos":[4297,4352]},{"content":"The restriction to accessing only the front and back elements in this way is the reason for using the queue class.","pos":[4353,4467]},{"content":"The priority_queue class orders its elements so that the largest element is always at the top position.","pos":[4477,4580]},{"content":"It supports insertion of an element and the inspection and removal of the top element.","pos":[4581,4667]},{"content":"A good analogue to keep in mind would be people lining up where they are arranged by age, height, or some other criterion.","pos":[4668,4790]},{"pos":[4800,4812],"content":"Constructors","linkify":"Constructors","nodes":[{"content":"Constructors","pos":[0,12]}]},{"pos":[4833,4882],"content":"<bpt id=\"p1\">[</bpt>priority_queue<ept id=\"p1\">](#priority_queue__priority_queue)</ept>","source":"[priority_queue](#priority_queue__priority_queue)"},{"pos":[4883,5012],"content":"Constructs a <ph id=\"ph1\">`priority_queue`</ph> that is empty or that is a copy of a range of a base container object or of other <ph id=\"ph2\">`priority_queue`</ph>.","source":"Constructs a `priority_queue` that is empty or that is a copy of a range of a base container object or of other `priority_queue`."},{"pos":[5023,5031],"content":"Typedefs","linkify":"Typedefs","nodes":[{"content":"Typedefs","pos":[0,8]}]},{"pos":[5052,5101],"content":"<bpt id=\"p1\">[</bpt>container_type<ept id=\"p1\">](#priority_queue__container_type)</ept>","source":"[container_type](#priority_queue__container_type)"},{"pos":[5102,5178],"content":"A type that provides the base container to be adapted by a <ph id=\"ph1\">`priority_queue`</ph>.","source":"A type that provides the base container to be adapted by a `priority_queue`."},{"pos":[5183,5222],"content":"<bpt id=\"p1\">[</bpt>size_type<ept id=\"p1\">](#priority_queue__size_type)</ept>","source":"[size_type](#priority_queue__size_type)"},{"pos":[5223,5312],"content":"An unsigned integer type that can represent the number of elements in a <ph id=\"ph1\">`priority_queue`</ph>.","source":"An unsigned integer type that can represent the number of elements in a `priority_queue`."},{"pos":[5317,5358],"content":"<bpt id=\"p1\">[</bpt>value_type<ept id=\"p1\">](#priority_queue__value_type)</ept>","source":"[value_type](#priority_queue__value_type)"},{"pos":[5359,5444],"content":"A type that represents the type of object stored as an element in a <ph id=\"ph1\">`priority_queue`</ph>.","source":"A type that represents the type of object stored as an element in a `priority_queue`."},{"pos":[5455,5471],"content":"Member Functions","linkify":"Member Functions","nodes":[{"content":"Member Functions","pos":[0,16]}]},{"pos":[5492,5523],"content":"<bpt id=\"p1\">[</bpt>empty<ept id=\"p1\">](#priority_queue__empty)</ept>","source":"[empty](#priority_queue__empty)"},{"pos":[5524,5563],"content":"Tests if the <ph id=\"ph1\">`priority_queue`</ph> is empty.","source":"Tests if the `priority_queue` is empty."},{"pos":[5568,5595],"content":"<bpt id=\"p1\">[</bpt>pop<ept id=\"p1\">](#priority_queue__pop)</ept>","source":"[pop](#priority_queue__pop)"},{"pos":[5596,5670],"content":"Removes the largest element of the <ph id=\"ph1\">`priority_queue`</ph> from the top position.","source":"Removes the largest element of the `priority_queue` from the top position."},{"pos":[5675,5704],"content":"<bpt id=\"p1\">[</bpt>push<ept id=\"p1\">](#priority_queue__push)</ept>","source":"[push](#priority_queue__push)"},{"content":"Adds an element to the priority queue based on the priority of the element from operator&lt;.","pos":[5705,5795],"source":"Adds an element to the priority queue based on the priority of the element from operator<."},{"pos":[5800,5829],"content":"<bpt id=\"p1\">[</bpt>size<ept id=\"p1\">](#priority_queue__size)</ept>","source":"[size](#priority_queue__size)"},{"pos":[5830,5885],"content":"Returns the number of elements in the <ph id=\"ph1\">`priority_queue`</ph>.","source":"Returns the number of elements in the `priority_queue`."},{"pos":[5890,5917],"content":"<bpt id=\"p1\">[</bpt>top<ept id=\"p1\">](#priority_queue__top)</ept>","source":"[top](#priority_queue__top)"},{"pos":[5918,6002],"content":"Returns a const reference to the largest element at the top of the <ph id=\"ph1\">`priority_queue`</ph>.","source":"Returns a const reference to the largest element at the top of the `priority_queue`."},{"pos":[6012,6024],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[6028,6048],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> <ph id=\"ph1\">\\&lt;</ph>queue&gt;","source":"**Header:** \\<queue>"},{"pos":[6055,6073],"content":"<bpt id=\"p1\">**</bpt>Namespace:<ept id=\"p1\">**</ept> std","source":"**Namespace:** std"},{"pos":[6083,6160],"content":"<bpt id=\"p1\">&lt;a name=\"priority_queue__container_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  priority_queue::container_type","linkify":"<a name=\"priority_queue__container_type\"></a>  priority_queue::container_type","source":"<a name=\"priority_queue__container_type\"></a>  priority_queue::container_type"},{"content":"A type that provides the base container to be adapted.","pos":[6164,6218]},{"pos":[6279,6286],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The type is a synonym for the template parameter <ph id=\"ph1\">`Container`</ph>.","pos":[6290,6351],"source":"The type is a synonym for the template parameter `Container`."},{"content":"The STL sequence container class deque and the default class vector meet the requirements to be used as the base container for a priority_queue object.","pos":[6352,6503]},{"content":"User-defined types satisfying the requirements may also be used.","pos":[6504,6568]},{"pos":[6575,6717],"content":"For more information on <ph id=\"ph1\">`Container`</ph>, see the Remarks section of the <bpt id=\"p1\">[</bpt>priority_queue Class<ept id=\"p1\">](../standard-library/priority-queue-class.md)</ept> topic.","source":"For more information on `Container`, see the Remarks section of the [priority_queue Class](../standard-library/priority-queue-class.md) topic."},{"pos":[6727,6734],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[6739,6867],"content":"See the example for <bpt id=\"p1\">[</bpt>priority_queue<ept id=\"p1\">](#priority_queue__priority_queue)</ept> for an example of how to declare and use <ph id=\"ph1\">`container_type`</ph>.","source":"See the example for [priority_queue](#priority_queue__priority_queue) for an example of how to declare and use `container_type`."},{"pos":[6877,6936],"content":"<bpt id=\"p1\">&lt;a name=\"priority_queue__empty\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  priority_queue::empty","linkify":"<a name=\"priority_queue__empty\"></a>  priority_queue::empty","source":"<a name=\"priority_queue__empty\"></a>  priority_queue::empty"},{"content":"Tests if a priority_queue is empty.","pos":[6940,6975]},{"pos":[7020,7032],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[7036,7121],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the priority_queue is empty; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if the priority_queue is nonempty.","source":"**true** if the priority_queue is empty; **false** if the priority_queue is nonempty."},{"pos":[7131,7138],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[7842,7897],"content":"<bpt id=\"p1\">&lt;a name=\"priority_queue__pop\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  priority_queue::pop","linkify":"<a name=\"priority_queue__pop\"></a>  priority_queue::pop","source":"<a name=\"priority_queue__pop\"></a>  priority_queue::pop"},{"content":"Removes the largest element of the priority_queue from the top position.","pos":[7901,7973]},{"pos":[8010,8017],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The priority_queue must be nonempty to apply the member function.","pos":[8021,8086]},{"content":"The top of the priority_queue is always occupied by the largest element in the container.","pos":[8087,8176]},{"pos":[8186,8193],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[9231,9308],"content":"<bpt id=\"p1\">&lt;a name=\"priority_queue__priority_queue\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  priority_queue::priority_queue","linkify":"<a name=\"priority_queue__priority_queue\"></a>  priority_queue::priority_queue","source":"<a name=\"priority_queue__priority_queue\"></a>  priority_queue::priority_queue"},{"content":"Constructs a priority_queue that is empty or that is a copy of a range of a base container object or of another priority_queue.","pos":[9312,9439]},{"pos":[9982,9992],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"<bpt id=\"p1\">*</bpt>_ comp<ept id=\"p1\">*</ept>","pos":[9996,10004],"source":"*_ comp*"},{"content":"The comparison function of type <bpt id=\"p1\">**</bpt>constTraits<ept id=\"p1\">**</ept> used to order the elements in the priority_queue, which defaults to compare function of the base container.","pos":[10008,10163],"source":" The comparison function of type **constTraits** used to order the elements in the priority_queue, which defaults to compare function of the base container."},{"content":"The base container of which the constructed priority_queue is to be a copy.","pos":[10181,10256]},{"content":"The priority_queue of which the constructed set is to be a copy.","pos":[10275,10339]},{"content":"The position of the first element in the range of elements to be copied.","pos":[10358,10430]},{"content":"The position of the first element beyond the range of elements to be copied.","pos":[10448,10524]},{"pos":[10534,10541],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Each of the first three constructors specifies an empty initial priority_queue, the second also specifying the type of comparison function ( <ph id=\"ph1\">` comp`</ph>) to be used in establishing the order of the elements and the third explicitly specifying the <ph id=\"ph2\">`container_type`</ph> ( <ph id=\"ph3\">`_Cont`</ph>) to be used.","pos":[10545,10827],"source":"Each of the first three constructors specifies an empty initial priority_queue, the second also specifying the type of comparison function ( ` comp`) to be used in establishing the order of the elements and the third explicitly specifying the `container_type` ( `_Cont`) to be used."},{"content":"The keyword <bpt id=\"p1\">**</bpt>explicit<ept id=\"p1\">**</ept> suppresses certain kinds of automatic type conversion.","pos":[10828,10907],"source":" The keyword **explicit** suppresses certain kinds of automatic type conversion."},{"pos":[10914,10985],"content":"The fourth constructor specifies a copy of the priority_queue <ph id=\"ph1\">` right`</ph>.","source":"The fourth constructor specifies a copy of the priority_queue ` right`."},{"pos":[10992,11238],"content":"The last three constructors copy the range [ <bpt id=\"p1\">*</bpt> first,  last<ept id=\"p1\">*</ept>) of some container and use the values to initialize a priority_queue with increasing explicitness in specifying the type of comparison function of class <bpt id=\"p2\">**</bpt>Traits<ept id=\"p2\">**</ept> and <ph id=\"ph1\">`container_type`</ph>.","source":"The last three constructors copy the range [ * first,  last*) of some container and use the values to initialize a priority_queue with increasing explicitness in specifying the type of comparison function of class **Traits** and `container_type`."},{"pos":[11248,11255],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[14374,14431],"content":"<bpt id=\"p1\">&lt;a name=\"priority_queue__push\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  priority_queue::push","linkify":"<a name=\"priority_queue__push\"></a>  priority_queue::push","source":"<a name=\"priority_queue__push\"></a>  priority_queue::push"},{"content":"Adds an element to the priority queue based on the priority of the element from operator&lt;.","pos":[14435,14525],"source":"Adds an element to the priority queue based on the priority of the element from operator<."},{"pos":[14578,14588],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"The element added to the top of the priority_queue.","pos":[14602,14653]},{"pos":[14663,14670],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The top of the priority_queue is the position occupied by the largest element in the container.","pos":[14674,14769]},{"pos":[14779,14786],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[15413,15470],"content":"<bpt id=\"p1\">&lt;a name=\"priority_queue__size\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  priority_queue::size","linkify":"<a name=\"priority_queue__size\"></a>  priority_queue::size","source":"<a name=\"priority_queue__size\"></a>  priority_queue::size"},{"content":"Returns the number of elements in the priority_queue.","pos":[15474,15527]},{"pos":[15576,15588],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"content":"The current length of the priority_queue.","pos":[15592,15633]},{"pos":[15643,15650],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[16205,16272],"content":"<bpt id=\"p1\">&lt;a name=\"priority_queue__size_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  priority_queue::size_type","linkify":"<a name=\"priority_queue__size_type\"></a>  priority_queue::size_type","source":"<a name=\"priority_queue__size_type\"></a>  priority_queue::size_type"},{"content":"An unsigned integer type that can represent the number of elements in a priority_queue.","pos":[16276,16363]},{"pos":[16439,16446],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[16450,16544],"content":"The type is a synonym for the <ph id=\"ph1\">`size_type`</ph> of the base container adapted by the priority_queue.","source":"The type is a synonym for the `size_type` of the base container adapted by the priority_queue."},{"pos":[16554,16561],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[16566,16669],"content":"See the example for <bpt id=\"p1\">[</bpt>size<ept id=\"p1\">](#priority_queue__size)</ept> for an example of how to declare and use <ph id=\"ph1\">`size_type`</ph>.","source":"See the example for [size](#priority_queue__size) for an example of how to declare and use `size_type`."},{"pos":[16679,16734],"content":"<bpt id=\"p1\">&lt;a name=\"priority_queue__top\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  priority_queue::top","linkify":"<a name=\"priority_queue__top\"></a>  priority_queue::top","source":"<a name=\"priority_queue__top\"></a>  priority_queue::top"},{"content":"Returns a const reference to the largest element at the top of the priority_queue.","pos":[16738,16820]},{"pos":[16874,16886],"content":"Return Value","linkify":"Return Value","nodes":[{"content":"Return Value","pos":[0,12]}]},{"pos":[16890,16997],"content":"A reference to the largest element, as determined by the <bpt id=\"p1\">**</bpt>Traits<ept id=\"p1\">**</ept> function, object of the priority_queue.","source":"A reference to the largest element, as determined by the **Traits** function, object of the priority_queue."},{"pos":[17007,17014],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The priority_queue must be nonempty to apply the member function.","pos":[17018,17083]},{"pos":[17093,17100],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[17726,17795],"content":"<bpt id=\"p1\">&lt;a name=\"priority_queue__value_type\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>  priority_queue::value_type","linkify":"<a name=\"priority_queue__value_type\"></a>  priority_queue::value_type","source":"<a name=\"priority_queue__value_type\"></a>  priority_queue::value_type"},{"content":"A type that represents the type of object stored as an element in a priority_queue.","pos":[17799,17882]},{"pos":[17960,17967],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[17971,18066],"content":"The type is a synonym for the <ph id=\"ph1\">`value_type`</ph> of the base container adapted by the priority_queue.","source":"The type is a synonym for the `value_type` of the base container adapted by the priority_queue."},{"pos":[18076,18083],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[18712,18720],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Thread Safety in the C++ Standard Library<ept id=\"p1\">](../standard-library/thread-safety-in-the-cpp-standard-library.md)</ept><ph id=\"ph1\"> </ph>","pos":[18724,18834],"source":"[Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md) "},{"content":"<bpt id=\"p1\"> [</bpt>C++ Standard Library Reference<ept id=\"p1\">](../standard-library/cpp-standard-library-reference.md)</ept>","pos":[18837,18925],"source":" [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)"}],"content":"---\ntitle: \"priority_queue Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std.priority_queue\"\n  - \"priority_queue\"\n  - \"std::priority_queue\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"priority_queue class\"\nms.assetid: 69fca9cc-a449-4be4-97b7-02ca5db9cbb2\ncaps.latest.revision: 25\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# priority_queue Class\nA template container adaptor class that provides a restriction of functionality limiting access to the top element of some underlying container type, which is always the largest or of the highest priority. New elements can be added to the priority_queue and the top element of the priority_queue can be inspected or removed.  \n  \n## Syntax  \n  \n```  \ntemplate <class Type, class Container= vector <Type>, class Compare= less <typename Container ::value_type>>  \nclass priority_queue  \n```  \n  \n#### Parameters  \n *Type*  \n The element data type to be stored in the priority_queue.  \n  \n `Container`  \n The type of the underlying container used to implement the priority_queue.  \n  \n *Compare*  \n The type that provides a function object that can compare two element values as sort keys to determine their relative order in the priority_queue. This argument is optional and the binary predicate **less***\\<***typename** *Container***::value_type***>* is the default value.  \n  \n## Remarks  \n The elements of class **Type** stipulated in the first template parameter of a queue object are synonymous with [value_type](#priority_queue__value_type) and must match the type of element in the underlying container class **Container** stipulated by the second template parameter. The **Type** must be assignable, so that it is possible to copy objects of that type and to assign values to variables of that type.  \n  \n The priority_queue orders the sequence it controls by calling a stored function object of class **Traits**. In general, the elements need be merely less than comparable to establish this order: so that, given any two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. On a more technical note, the comparison function is a binary predicate that induces a strict weak ordering in the standard mathematical sense.  \n  \n Suitable underlying container classes for priority_queue include [deque Class](../standard-library/deque-class.md) and the default [vector Class](../standard-library/vector-class.md) or any other sequence container that supports the operations of `front`, `push_back`, and `pop_back` and a random-access iterator. The underlying container class is encapsulated within the container adaptor, which exposes only the limited set of the sequence container member functions as a public interface.  \n  \n Adding elements to and removing elements from a `priority_queue` both have logarithmic complexity. Accessing elements in a `priority_queue` has constant complexity.  \n  \n There are three types of container adaptors defined by the STL: stack, queue, and priority_queue. Each restricts the functionality of some underlying container class to provide a precisely controlled interface to a standard data structure.  \n  \n-   The [stack Class](../standard-library/stack-class.md) supports a last-in, first-out (LIFO) data structure. A good analogue to keep in mind would be a stack of plates. Elements (plates) may be inserted, inspected, or removed only from the top of the stack, which is the last element at the end of the base container. The restriction to accessing only the top element is the reason for using the stack class.  \n  \n-   The [queue Class](../standard-library/queue-class.md) supports a first-in, first-out (FIFO) data structure. A good analogue to keep in mind would be people lining up for a bank teller. Elements (people) may be added to the back of the line and are removed from the front of the line. Both the front and the back of a line may be inspected. The restriction to accessing only the front and back elements in this way is the reason for using the queue class.  \n  \n-   The priority_queue class orders its elements so that the largest element is always at the top position. It supports insertion of an element and the inspection and removal of the top element. A good analogue to keep in mind would be people lining up where they are arranged by age, height, or some other criterion.  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[priority_queue](#priority_queue__priority_queue)|Constructs a `priority_queue` that is empty or that is a copy of a range of a base container object or of other `priority_queue`.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[container_type](#priority_queue__container_type)|A type that provides the base container to be adapted by a `priority_queue`.|  \n|[size_type](#priority_queue__size_type)|An unsigned integer type that can represent the number of elements in a `priority_queue`.|  \n|[value_type](#priority_queue__value_type)|A type that represents the type of object stored as an element in a `priority_queue`.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[empty](#priority_queue__empty)|Tests if the `priority_queue` is empty.|  \n|[pop](#priority_queue__pop)|Removes the largest element of the `priority_queue` from the top position.|  \n|[push](#priority_queue__push)|Adds an element to the priority queue based on the priority of the element from operator<.|  \n|[size](#priority_queue__size)|Returns the number of elements in the `priority_queue`.|  \n|[top](#priority_queue__top)|Returns a const reference to the largest element at the top of the `priority_queue`.|  \n  \n## Requirements  \n **Header:** \\<queue>  \n  \n **Namespace:** std  \n  \n##  <a name=\"priority_queue__container_type\"></a>  priority_queue::container_type  \n A type that provides the base container to be adapted.  \n  \n```  \ntypedef Container container_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the template parameter `Container`. The STL sequence container class deque and the default class vector meet the requirements to be used as the base container for a priority_queue object. User-defined types satisfying the requirements may also be used.  \n  \n For more information on `Container`, see the Remarks section of the [priority_queue Class](../standard-library/priority-queue-class.md) topic.  \n  \n### Example  \n  See the example for [priority_queue](#priority_queue__priority_queue) for an example of how to declare and use `container_type`.  \n  \n##  <a name=\"priority_queue__empty\"></a>  priority_queue::empty  \n Tests if a priority_queue is empty.  \n  \n```  \nbool empty() const;\n```  \n  \n### Return Value  \n **true** if the priority_queue is empty; **false** if the priority_queue is nonempty.  \n  \n### Example  \n  \n```cpp  \n// pqueue_empty.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   // Declares priority_queues with default deque base container  \n   priority_queue <int> q1, s2;  \n  \n   q1.push( 1 );  \n  \n   if ( q1.empty( ) )  \n      cout << \"The priority_queue q1 is empty.\" << endl;  \n   else  \n      cout << \"The priority_queue q1 is not empty.\" << endl;  \n  \n   if ( s2.empty( ) )  \n      cout << \"The priority_queue s2 is empty.\" << endl;  \n   else  \n      cout << \"The priority_queue s2 is not empty.\" << endl;  \n}  \n```  \n  \n```Output  \nThe priority_queue q1 is not empty.  \nThe priority_queue s2 is empty.  \n```  \n  \n##  <a name=\"priority_queue__pop\"></a>  priority_queue::pop  \n Removes the largest element of the priority_queue from the top position.  \n  \n```  \nvoid pop();\n```  \n  \n### Remarks  \n The priority_queue must be nonempty to apply the member function. The top of the priority_queue is always occupied by the largest element in the container.  \n  \n### Example  \n  \n```cpp  \n// pqueue_pop.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   priority_queue <int> q1, s2;  \n  \n   q1.push( 10 );  \n   q1.push( 20 );  \n   q1.push( 30 );  \n  \n   priority_queue <int>::size_type i, iii;  \n   i = q1.size( );  \n   cout << \"The priority_queue length is \" << i << \".\" << endl;  \n  \n   const int& ii = q1.top( );  \n   cout << \"The element at the top of the priority_queue is \"  \n        << ii << \".\" << endl;  \n  \n   q1.pop( );  \n  \n   iii = q1.size( );  \n   cout << \"After a pop, the priority_queue length is \"   \n        << iii << \".\" << endl;  \n  \n   const int& iv = q1.top( );  \n   cout << \"After a pop, the element at the top of the \"  \n        << \"priority_queue is \" << iv << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe priority_queue length is 3.  \nThe element at the top of the priority_queue is 30.  \nAfter a pop, the priority_queue length is 2.  \nAfter a pop, the element at the top of the priority_queue is 20.  \n```  \n  \n##  <a name=\"priority_queue__priority_queue\"></a>  priority_queue::priority_queue  \n Constructs a priority_queue that is empty or that is a copy of a range of a base container object or of another priority_queue.  \n  \n```  \npriority_queue();\n\nexplicit priority_queue(const Traits&_comp);\n\npriority_queue(const Traits&_comp, const container_type& _Cont);\n\npriority_queue(const priority_queue& right);\n\ntemplate <class InputIterator>  \npriority_queue(InputIterator first, InputIterator last);\n\ntemplate <class InputIterator>  \npriority_queue(InputIterator first, InputIterator last, const Traits&_comp);\n\ntemplate <class InputIterator>  \npriority_queue(InputIterator first, InputIterator last, const Traits&_comp, const container_type& _Cont);\n```  \n  \n### Parameters  \n *_ comp*  \n The comparison function of type **constTraits** used to order the elements in the priority_queue, which defaults to compare function of the base container.  \n  \n `_Cont`  \n The base container of which the constructed priority_queue is to be a copy.  \n  \n ` right`  \n The priority_queue of which the constructed set is to be a copy.  \n  \n ` first`  \n The position of the first element in the range of elements to be copied.  \n  \n ` last`  \n The position of the first element beyond the range of elements to be copied.  \n  \n### Remarks  \n Each of the first three constructors specifies an empty initial priority_queue, the second also specifying the type of comparison function ( ` comp`) to be used in establishing the order of the elements and the third explicitly specifying the `container_type` ( `_Cont`) to be used. The keyword **explicit** suppresses certain kinds of automatic type conversion.  \n  \n The fourth constructor specifies a copy of the priority_queue ` right`.  \n  \n The last three constructors copy the range [ * first,  last*) of some container and use the values to initialize a priority_queue with increasing explicitness in specifying the type of comparison function of class **Traits** and `container_type`.  \n  \n### Example  \n  \n```cpp  \n// pqueue_ctor.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <vector>  \n#include <deque>  \n#include <list>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   // The first member function declares priority_queue  \n   // with a default vector base container  \n   priority_queue <int> q1;  \n   cout << \"q1 = ( \";  \n   while ( !q1.empty( ) )  \n   {  \n      cout << q1.top( ) << \" \";  \n      q1.pop( );  \n   }  \n   cout << \")\" << endl;  \n  \n   // Explicitly declares a priority_queue with nondefault  \n   // deque base container  \n   priority_queue <int, deque <int> > q2;  \n   q2.push( 5 );  \n   q2.push( 15 );  \n   q2.push( 10 );  \n   cout << \"q2 = ( \";  \n   while ( !q2.empty( ) )  \n   {  \n      cout << q2.top( ) << \" \";  \n      q2.pop( );  \n   }  \n   cout << \")\" << endl;  \n  \n   // This method of printing out the elements of a priority_queue  \n   // removes the elements from the priority queue, leaving it empty  \n   cout << \"After printing, q2 has \" << q2.size( ) << \" elements.\" << endl;  \n  \n   // The third member function declares a priority_queue   \n   // with a vector base container and specifies that the comparison   \n   // function greater is to be used for ordering elements  \n   priority_queue <int, vector<int>, greater<int> > q3;  \n   q3.push( 2 );  \n   q3.push( 1 );  \n   q3.push( 3 );  \n   cout << \"q3 = ( \";  \n   while ( !q3.empty( ) )  \n   {  \n      cout << q3.top( ) << \" \";  \n      q3.pop( );  \n   }  \n   cout << \")\" << endl;  \n  \n   // The fourth member function declares a priority_queue and  \n   // initializes it with elements copied from another container:  \n   // first, inserting elements into q1, then copying q1 elements into q4  \n   q1.push( 100 );  \n   q1.push( 200 );  \n   priority_queue <int> q4( q1 );  \n   cout << \"q4 = ( \";     \n   while ( !q4.empty( ) )  \n   {  \n      cout << q4.top( ) << \" \";  \n      q4.pop( );  \n   }  \n   cout << \")\" << endl;  \n  \n   // Creates an auxiliary vector object v5 to be used to initialize q5  \n   vector <int> v5;  \n   vector <int>::iterator v5_Iter;  \n   v5.push_back( 10 );  \n   v5.push_back( 30 );  \n   v5.push_back( 20 );  \n   cout << \"v5 = ( \" ;  \n   for ( v5_Iter = v5.begin( ) ; v5_Iter != v5.end( ) ; v5_Iter++ )  \n      cout << *v5_Iter << \" \";  \n   cout << \")\" << endl;  \n  \n   // The fifth member function declares and  \n   // initializes a priority_queue q5 by copying the  \n   // range v5[ first,  last) from vector v5  \n   priority_queue <int> q5( v5.begin( ), v5.begin( ) + 2 );  \n   cout << \"q5 = ( \";  \n   while ( !q5.empty( ) )  \n   {  \n      cout << q5.top( ) << \" \";  \n      q5.pop( );  \n   }  \n   cout << \")\" << endl;  \n  \n   // The sixth member function declares a priority_queue q6  \n   // with a comparison function greater and initializes q6  \n   // by copying the range v5[ first,  last) from vector v5  \n   priority_queue <int, vector<int>, greater<int> >   \n      q6( v5.begin( ), v5.begin( ) + 2 );  \n   cout << \"q6 = ( \";  \n   while ( !q6.empty( ) )  \n   {  \n      cout << q6.top( ) << \" \";  \n      q6.pop( );  \n   }  \n   cout << \")\" << endl;  \n}  \n```  \n  \n##  <a name=\"priority_queue__push\"></a>  priority_queue::push  \n Adds an element to the priority queue based on the priority of the element from operator<.  \n  \n```  \nvoid push(const Type& val);\n```  \n  \n### Parameters  \n ` val`  \n The element added to the top of the priority_queue.  \n  \n### Remarks  \n The top of the priority_queue is the position occupied by the largest element in the container.  \n  \n### Example  \n  \n```cpp  \n// pqueue_push.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   priority_queue<int> q1;  \n  \n   q1.push( 10 );  \n   q1.push( 30 );  \n   q1.push( 20 );  \n  \n   priority_queue<int>::size_type i;  \n   i = q1.size( );  \n   cout << \"The priority_queue length is \" << i << \".\" << endl;  \n  \n   const int& ii = q1.top( );  \n   cout << \"The element at the top of the priority_queue is \"  \n        << ii << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe priority_queue length is 3.  \nThe element at the top of the priority_queue is 30.  \n```  \n  \n##  <a name=\"priority_queue__size\"></a>  priority_queue::size  \n Returns the number of elements in the priority_queue.  \n  \n```  \nsize_type size() const;\n```  \n  \n### Return Value  \n The current length of the priority_queue.  \n  \n### Example  \n  \n```cpp  \n// pqueue_size.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   priority_queue <int> q1, q2;  \n   priority_queue <int>::size_type i;  \n  \n   q1.push( 1 );  \n   i = q1.size( );  \n   cout << \"The priority_queue length is \" << i << \".\" << endl;  \n  \n   q1.push( 2 );  \n   i = q1.size( );  \n   cout << \"The priority_queue length is now \" << i << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe priority_queue length is 1.  \nThe priority_queue length is now 2.  \n```  \n  \n##  <a name=\"priority_queue__size_type\"></a>  priority_queue::size_type  \n An unsigned integer type that can represent the number of elements in a priority_queue.  \n  \n```  \ntypedef typename Container::size_type size_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the `size_type` of the base container adapted by the priority_queue.  \n  \n### Example  \n  See the example for [size](#priority_queue__size) for an example of how to declare and use `size_type`.  \n  \n##  <a name=\"priority_queue__top\"></a>  priority_queue::top  \n Returns a const reference to the largest element at the top of the priority_queue.  \n  \n```  \nconst_reference top() const;\n```  \n  \n### Return Value  \n A reference to the largest element, as determined by the **Traits** function, object of the priority_queue.  \n  \n### Remarks  \n The priority_queue must be nonempty to apply the member function.  \n  \n### Example  \n  \n```cpp  \n// pqueue_top.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n   priority_queue<int> q1;  \n  \n   q1.push( 10 );  \n   q1.push( 30 );  \n   q1.push( 20 );  \n  \n   priority_queue<int>::size_type i;  \n   i = q1.size( );  \n   cout << \"The priority_queue length is \" << i << \".\" << endl;  \n  \n   const int& ii = q1.top( );  \n   cout << \"The element at the top of the priority_queue is \"  \n        << ii << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe priority_queue length is 3.  \nThe element at the top of the priority_queue is 30.  \n```  \n  \n##  <a name=\"priority_queue__value_type\"></a>  priority_queue::value_type  \n A type that represents the type of object stored as an element in a priority_queue.  \n  \n```  \ntypedef typename Container::value_type value_type;  \n```  \n  \n### Remarks  \n The type is a synonym for the `value_type` of the base container adapted by the priority_queue.  \n  \n### Example  \n  \n```cpp  \n// pqueue_value_type.cpp  \n// compile with: /EHsc  \n#include <queue>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;  \n  \n   // Declares priority_queues with default deque base container  \n   priority_queue<int>::value_type AnInt;  \n  \n   AnInt = 69;  \n   cout << \"The value_type is AnInt = \" << AnInt << endl;  \n  \n   priority_queue<int> q1;  \n   q1.push( AnInt );  \n   cout << \"The element at the top of the priority_queue is \"  \n        << q1.top( ) << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe value_type is AnInt = 69  \nThe element at the top of the priority_queue is 69.  \n```  \n  \n## See Also  \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)\n\n"}