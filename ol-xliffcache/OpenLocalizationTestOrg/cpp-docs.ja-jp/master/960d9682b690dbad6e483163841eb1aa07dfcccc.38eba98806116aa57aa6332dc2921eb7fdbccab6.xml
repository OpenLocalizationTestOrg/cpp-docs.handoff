{"nodes":[{"pos":[12,54],"content":"Type Forwarding (C++-CLI) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Type Forwarding (C++-CLI) | Microsoft Docs","pos":[0,42]}]},{"content":"Type Forwarding (C++/CLI)","pos":[602,627]},{"pos":[628,815],"content":"<bpt id=\"p1\">*</bpt>Type forwarding<ept id=\"p1\">*</ept> allows you to move a type from one assembly (assembly A) into another assembly (assembly B), such that, it is not necessary to recompile clients that consume assembly A.","source":"*Type forwarding* allows you to move a type from one assembly (assembly A) into another assembly (assembly B), such that, it is not necessary to recompile clients that consume assembly A."},{"content":"All Platforms","pos":[824,837]},{"content":"This feature is not supported in all runtimes.","pos":[841,887]},{"content":"Windows Runtime","pos":[896,911]},{"pos":[915,1005],"content":"This feature is not supported in the <ph id=\"ph1\">[!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]</ph>.","source":"This feature is not supported in the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]."},{"content":"Requirements","pos":[1015,1027]},{"pos":[1031,1055],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/ZW<ept id=\"p1\">**</ept>","source":"Compiler option: **/ZW**"},{"content":"Common Language Runtime","pos":[1064,1087]},{"content":"The following code example demonstrates how to use type forwarding.","pos":[1091,1158]},{"content":"Syntax","pos":[1168,1174]},{"content":"Parameters","pos":[1262,1272]},{"content":"The assembly into which you are moving the type definition.","pos":[1285,1344]},{"content":"The type whose definition you are moving into another assembly.","pos":[1361,1424]},{"content":"Remarks","pos":[1434,1441]},{"content":"After a component (assembly) ships and is being used by client applications, you can use type forwarding to move a type from the component (assembly) into another assembly, ship the updated component (and any additional assemblies required), and the client applications will still work without being recompiled.","pos":[1445,1756]},{"content":"Type forwarding only works for components referenced by existing applications.","pos":[1763,1841]},{"content":"When you rebuild an application, there must be the appropriate assembly references for any types used in the application.","pos":[1842,1963]},{"content":"When forwarding a type (Type A) from an assembly, you must add the <ph id=\"ph1\">`TypeForwardedTo`</ph> attribute for that type, as well as an assembly reference.","pos":[1970,2113],"source":"When forwarding a type (Type A) from an assembly, you must add the `TypeForwardedTo` attribute for that type, as well as an assembly reference."},{"content":"The assembly that you reference must contain one of the following:","pos":[2114,2180]},{"content":"The definition for Type A.","pos":[2190,2216]},{"pos":[2226,2301],"content":"A <ph id=\"ph1\">`TypeForwardedTo`</ph> attribute for Type A, as well as an assembly reference.","source":"A `TypeForwardedTo` attribute for Type A, as well as an assembly reference."},{"content":"Examples of types that can be forwarded include:","pos":[2308,2356]},{"content":"ref classes","pos":[2366,2377]},{"content":"value classes","pos":[2387,2400]},{"content":"enums","pos":[2410,2415]},{"content":"interfaces","pos":[2425,2435]},{"content":"You cannot forward the following types:","pos":[2442,2481]},{"content":"Generic types","pos":[2491,2504]},{"content":"Native types","pos":[2514,2526]},{"content":"Nested types (if you want to forward a nested type, you should forward the enclosing type)","pos":[2536,2626]},{"content":"You can forward a type to an assembly authored in any language targeting the common language runtime.","pos":[2633,2734]},{"pos":[2741,2927],"content":"So, if a source code file that is used to build assembly A.dll contains a type definition (<ph id=\"ph1\">`ref class MyClass`</ph>), and you wanted to move that type definition to assembly B.dll, you would:","source":"So, if a source code file that is used to build assembly A.dll contains a type definition (`ref class MyClass`), and you wanted to move that type definition to assembly B.dll, you would:"},{"pos":[2937,3014],"content":"Move the <ph id=\"ph1\">`MyClass`</ph> type definition to a source code file used to build B.dll.","source":"Move the `MyClass` type definition to a source code file used to build B.dll."},{"content":"Build assembly B.dll","pos":[3024,3044]},{"pos":[3054,3167],"content":"Delete the <ph id=\"ph1\">`MyClass`</ph> type definition from the source code used to build A.dll, and replace it with the following:","source":"Delete the `MyClass` type definition from the source code used to build A.dll, and replace it with the following:"},{"content":"Build assembly A.dll.","pos":[3272,3293]},{"content":"Use A.dll without recompiling client applications.","pos":[3303,3353]},{"content":"Requirements","pos":[3363,3375]},{"pos":[3379,3404],"content":"Compiler option: <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept>","source":"Compiler option: **/clr**"}],"content":"---\ntitle: \"Type Forwarding (C++-CLI) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"language-reference\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"type forwarding, Visual C++\"\nms.assetid: ae730b69-0c27-41cc-84e1-3132783866ea\ncaps.latest.revision: 12\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Type Forwarding (C++/CLI)\n*Type forwarding* allows you to move a type from one assembly (assembly A) into another assembly (assembly B), such that, it is not necessary to recompile clients that consume assembly A.  \n  \n## All Platforms  \n This feature is not supported in all runtimes.  \n  \n## Windows Runtime  \n This feature is not supported in the [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)].  \n  \n### Requirements  \n Compiler option: **/ZW**  \n  \n## Common Language Runtime  \n The following code example demonstrates how to use type forwarding.  \n  \n### Syntax  \n  \n```  \n#using \"new.dll\"  \n[assembly:TypeForwardedTo(type::typeid)];  \n```  \n  \n### Parameters  \n `new`  \n The assembly into which you are moving the type definition.  \n  \n `type`  \n The type whose definition you are moving into another assembly.  \n  \n### Remarks  \n After a component (assembly) ships and is being used by client applications, you can use type forwarding to move a type from the component (assembly) into another assembly, ship the updated component (and any additional assemblies required), and the client applications will still work without being recompiled.  \n  \n Type forwarding only works for components referenced by existing applications. When you rebuild an application, there must be the appropriate assembly references for any types used in the application.  \n  \n When forwarding a type (Type A) from an assembly, you must add the `TypeForwardedTo` attribute for that type, as well as an assembly reference. The assembly that you reference must contain one of the following:  \n  \n-   The definition for Type A.  \n  \n-   A `TypeForwardedTo` attribute for Type A, as well as an assembly reference.  \n  \n Examples of types that can be forwarded include:  \n  \n-   ref classes  \n  \n-   value classes  \n  \n-   enums  \n  \n-   interfaces  \n  \n You cannot forward the following types:  \n  \n-   Generic types  \n  \n-   Native types  \n  \n-   Nested types (if you want to forward a nested type, you should forward the enclosing type)  \n  \n You can forward a type to an assembly authored in any language targeting the common language runtime.  \n  \n So, if a source code file that is used to build assembly A.dll contains a type definition (`ref class MyClass`), and you wanted to move that type definition to assembly B.dll, you would:  \n  \n1.  Move the `MyClass` type definition to a source code file used to build B.dll.  \n  \n2.  Build assembly B.dll  \n  \n3.  Delete the `MyClass` type definition from the source code used to build A.dll, and replace it with the following:  \n  \n    ```  \n    #using \"B.dll\"  \n    [assembly:TypeForwardedTo(MyClass::typeid)];  \n    ```  \n  \n4.  Build assembly A.dll.  \n  \n5.  Use A.dll without recompiling client applications.  \n  \n### Requirements  \n Compiler option: **/clr**"}