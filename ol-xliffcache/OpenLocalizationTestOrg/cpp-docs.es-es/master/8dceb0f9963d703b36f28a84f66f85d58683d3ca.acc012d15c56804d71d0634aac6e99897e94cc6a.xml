{"nodes":[{"pos":[12,84],"content":"Walkthrough: Removing Work from a User-Interface Thread | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Walkthrough: Removing Work from a User-Interface Thread | Microsoft Docs","pos":[0,72]}]},{"content":"Walkthrough: Removing Work from a User-Interface Thread","pos":[728,783]},{"content":"This document demonstrates how to use the Concurrency Runtime to move the work that is performed by the user-interface (UI) thread in a Microsoft Foundation Classes (MFC) application to a worker thread.","pos":[784,986]},{"content":"This document also demonstrates how to improve the performance of a lengthy drawing operation.","pos":[987,1081]},{"content":"Removing work from the UI thread by offloading blocking operations, for example, drawing, to worker threads can improve the responsiveness of your application.","pos":[1088,1247]},{"content":"This walkthrough uses a drawing routine that generates the Mandelbrot fractal to demonstrate a lengthy blocking operation.","pos":[1248,1370]},{"content":"The generation of the Mandelbrot fractal is also a good candidate for parallelization because the computation of each pixel is independent of all other computations.","pos":[1371,1536]},{"content":"Prerequisites","pos":[1545,1558]},{"content":"Read the following topics before you start this walkthrough:","pos":[1562,1622]},{"content":"Task Parallelism","pos":[1633,1649]},{"content":"Asynchronous Message Blocks","pos":[1724,1751]},{"content":"Message Passing Functions","pos":[1817,1842]},{"content":"Parallel Algorithms","pos":[1906,1925]},{"content":"Cancellation in the PPL","pos":[1983,2006]},{"content":"We also recommend that you understand the basics of MFC application development and <ph id=\"ph1\">[!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)]</ph> before you start this walkthrough.","pos":[2042,2238],"source":"We also recommend that you understand the basics of MFC application development and [!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)] before you start this walkthrough."},{"content":"For more information about MFC, see <bpt id=\"p1\">[</bpt>MFC Desktop Applications<ept id=\"p1\">](../../mfc/mfc-desktop-applications.md)</ept>.","pos":[2239,2341],"source":" For more information about MFC, see [MFC Desktop Applications](../../mfc/mfc-desktop-applications.md)."},{"content":"For more information about <ph id=\"ph1\">[!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)]</ph>, see <bpt id=\"p1\">[</bpt>GDI+<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/desktop/ms533798)</ept>.","pos":[2342,2526],"source":" For more information about [!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)], see [GDI+](https://msdn.microsoft.com/en-us/library/windows/desktop/ms533798)."},{"pos":[2555,2563],"content":"Sections"},{"content":"This walkthrough contains the following sections:","pos":[2567,2616]},{"content":"Creating the MFC Application","pos":[2627,2655]},{"content":"Implementing the Serial Version of the Mandelbrot Application","pos":[2681,2742]},{"content":"Removing Work from the User-Interface Thread","pos":[2763,2807]},{"content":"Improving Drawing Performance","pos":[2835,2864]},{"content":"Adding Support for Cancellation","pos":[2890,2921]},{"pos":[2974,3002],"content":"Creating the MFC Application"},{"content":"This section describes how to create the basic MFC application.","pos":[3006,3069]},{"content":"To create a Visual C++ MFC application","pos":[3079,3117]},{"pos":[3127,3191],"content":"On the <bpt id=\"p1\">**</bpt>File<ept id=\"p1\">**</ept> menu, click <bpt id=\"p2\">**</bpt>New<ept id=\"p2\">**</ept>, and then click <bpt id=\"p3\">**</bpt>Project<ept id=\"p3\">**</ept>.","source":"On the **File** menu, click **New**, and then click **Project**."},{"content":"In the <bpt id=\"p1\">**</bpt>New Project<ept id=\"p1\">**</ept> dialog box, in the <bpt id=\"p2\">**</bpt>Installed Templates<ept id=\"p2\">**</ept> pane, select <bpt id=\"p3\">**</bpt>Visual C++<ept id=\"p3\">**</ept>, and then, in the <bpt id=\"p4\">**</bpt>Templates<ept id=\"p4\">**</ept> pane, select <bpt id=\"p5\">**</bpt>MFC Application<ept id=\"p5\">**</ept>.","pos":[3201,3360],"source":"In the **New Project** dialog box, in the **Installed Templates** pane, select **Visual C++**, and then, in the **Templates** pane, select **MFC Application**."},{"content":"Type a name for the project, for example, <ph id=\"ph1\">`Mandelbrot`</ph>, and then click <bpt id=\"p1\">**</bpt>OK<ept id=\"p1\">**</ept> to display the <bpt id=\"p2\">**</bpt>MFC Application Wizard<ept id=\"p2\">**</ept>.","pos":[3361,3481],"source":" Type a name for the project, for example, `Mandelbrot`, and then click **OK** to display the **MFC Application Wizard**."},{"content":"In the <bpt id=\"p1\">**</bpt>Application Type<ept id=\"p1\">**</ept> pane, select <bpt id=\"p2\">**</bpt>Single document<ept id=\"p2\">**</ept>.","pos":[3491,3552],"source":"In the **Application Type** pane, select **Single document**."},{"content":"Ensure that the <bpt id=\"p1\">**</bpt>Document/View architecture support<ept id=\"p1\">**</ept> check box is cleared.","pos":[3553,3629],"source":" Ensure that the **Document/View architecture support** check box is cleared."},{"pos":[3639,3719],"content":"Click <bpt id=\"p1\">**</bpt>Finish<ept id=\"p1\">**</ept> to create the project and close the <bpt id=\"p2\">**</bpt>MFC Application Wizard<ept id=\"p2\">**</ept>.","source":"Click **Finish** to create the project and close the **MFC Application Wizard**."},{"content":"Verify that the application was created successfully by building and running it.","pos":[3730,3810]},{"content":"To build the application, on the <bpt id=\"p1\">**</bpt>Build<ept id=\"p1\">**</ept> menu, click <bpt id=\"p2\">**</bpt>Build Solution<ept id=\"p2\">**</ept>.","pos":[3811,3885],"source":" To build the application, on the **Build** menu, click **Build Solution**."},{"content":"If the application builds successfully, run the application by clicking <bpt id=\"p1\">**</bpt>Start Debugging<ept id=\"p1\">**</ept> on the <bpt id=\"p2\">**</bpt>Debug<ept id=\"p2\">**</ept> menu.","pos":[3886,4000],"source":" If the application builds successfully, run the application by clicking **Start Debugging** on the **Debug** menu."},{"pos":[4032,4093],"content":"Implementing the Serial Version of the Mandelbrot Application"},{"content":"This section describes how to draw the Mandelbrot fractal.","pos":[4097,4155]},{"content":"This version draws the Mandelbrot fractal to a <ph id=\"ph1\">[!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)]</ph> <bpt id=\"p1\">[</bpt>Bitmap<ept id=\"p1\">](https://msdn.microsoft.com/library/ms534420.aspx)</ept> object and then copies the contents of that bitmap to the client window.","pos":[4156,4412],"source":" This version draws the Mandelbrot fractal to a [!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)] [Bitmap](https://msdn.microsoft.com/library/ms534420.aspx) object and then copies the contents of that bitmap to the client window."},{"content":"To implement the serial version of the Mandelbrot application","pos":[4423,4484]},{"pos":[4494,4546],"content":"In stdafx.h, add the following <ph id=\"ph1\">`#include`</ph> directive:","source":"In stdafx.h, add the following `#include` directive:"},{"pos":[4568,4587],"content":"concrt-mandelbrot#1"},{"content":"In ChildView.h, after the <ph id=\"ph1\">`pragma`</ph> directive, define the <ph id=\"ph2\">`BitmapPtr`</ph> type.","pos":[4697,4771],"source":"In ChildView.h, after the `pragma` directive, define the `BitmapPtr` type."},{"content":"The <ph id=\"ph1\">`BitmapPtr`</ph> type enables a pointer to a <ph id=\"ph2\">`Bitmap`</ph> object to be shared by multiple components.","pos":[4772,4868],"source":" The `BitmapPtr` type enables a pointer to a `Bitmap` object to be shared by multiple components."},{"content":"The <ph id=\"ph1\">`Bitmap`</ph> object is deleted when it is no longer referenced by any component.","pos":[4869,4949],"source":" The `Bitmap` object is deleted when it is no longer referenced by any component."},{"pos":[4971,4990],"content":"concrt-mandelbrot#2"},{"pos":[5100,5192],"content":"In ChildView.h, add the following code to the <ph id=\"ph1\">`protected`</ph> section of the <ph id=\"ph2\">`CChildView`</ph> class:","source":"In ChildView.h, add the following code to the `protected` section of the `CChildView` class:"},{"pos":[5214,5233],"content":"concrt-mandelbrot#3"},{"content":"In ChildView.cpp, comment out or remove the following lines.","pos":[5343,5403]},{"pos":[5425,5444],"content":"concrt-mandelbrot#4"},{"pos":[5557,5752],"content":"In Debug builds, this step prevents the application from using the <ph id=\"ph1\">`DEBUG_NEW`</ph> allocator, which is incompatible with <ph id=\"ph2\">[!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)]</ph>.","source":"In Debug builds, this step prevents the application from using the `DEBUG_NEW` allocator, which is incompatible with [!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)]."},{"pos":[5762,5831],"content":"In ChildView.cpp, add a <ph id=\"ph1\">`using`</ph> directive to the <ph id=\"ph2\">`Gdiplus`</ph> namespace.","source":"In ChildView.cpp, add a `using` directive to the `Gdiplus` namespace."},{"pos":[5853,5872],"content":"concrt-mandelbrot#5"},{"pos":[5984,6173],"content":"Add the following code to the constructor and destructor of the <ph id=\"ph1\">`CChildView`</ph> class to initialize and shut down <ph id=\"ph2\">[!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)]</ph>.","source":"Add the following code to the constructor and destructor of the `CChildView` class to initialize and shut down [!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)]."},{"pos":[6195,6214],"content":"concrt-mandelbrot#6"},{"content":"Implement the <ph id=\"ph1\">`CChildView::DrawMandelbrot`</ph> method.","pos":[6326,6376],"source":"Implement the `CChildView::DrawMandelbrot` method."},{"content":"This method draws the Mandelbrot fractal to the specified <ph id=\"ph1\">`Bitmap`</ph> object.","pos":[6377,6451],"source":" This method draws the Mandelbrot fractal to the specified `Bitmap` object."},{"pos":[6473,6492],"content":"concrt-mandelbrot#7"},{"content":"Implement the <ph id=\"ph1\">`CChildView::OnPaint`</ph> method.","pos":[6604,6647],"source":"Implement the `CChildView::OnPaint` method."},{"content":"This method calls <ph id=\"ph1\">`CChildView::DrawMandelbrot`</ph> and then copies the contents of the <ph id=\"ph2\">`Bitmap`</ph> object to the window.","pos":[6648,6761],"source":" This method calls `CChildView::DrawMandelbrot` and then copies the contents of the `Bitmap` object to the window."},{"pos":[6783,6802],"content":"concrt-mandelbrot#8"},{"content":"Verify that the application was updated successfully by building and running it.","pos":[6913,6993]},{"content":"The following illustration shows the results of the Mandelbrot application.","pos":[7000,7075]},{"content":"The Mandelbrot Application","pos":[7084,7110]},{"content":"Because the computation for each pixel is computationally expensive, the UI thread cannot process additional messages until the overall computation finishes.","pos":[7175,7332]},{"content":"This could decrease responsiveness in the application.","pos":[7333,7387]},{"content":"However, you can relieve this problem by removing work from the UI thread.","pos":[7388,7462]},{"pos":[7469,7482],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[7521,7553],"content":"Removing Work from the UI Thread"},{"content":"This section shows how to remove the drawing work from the UI thread in the Mandelbrot application.","pos":[7557,7656]},{"content":"By moving drawing work from the UI thread to a worker thread, the UI thread can process messages as the worker thread generates the image in the background.","pos":[7657,7813]},{"content":"The Concurrency Runtime provides three ways to run tasks: <bpt id=\"p1\">[</bpt>task groups<ept id=\"p1\">](../../parallel/concrt/task-parallelism-concurrency-runtime.md)</ept>, <bpt id=\"p2\">[</bpt>asynchronous agents<ept id=\"p2\">](../../parallel/concrt/asynchronous-agents.md)</ept>, and <bpt id=\"p3\">[</bpt>lightweight tasks<ept id=\"p3\">](../../parallel/concrt/task-scheduler-concurrency-runtime.md)</ept>.","pos":[7820,8110],"source":"The Concurrency Runtime provides three ways to run tasks: [task groups](../../parallel/concrt/task-parallelism-concurrency-runtime.md), [asynchronous agents](../../parallel/concrt/asynchronous-agents.md), and [lightweight tasks](../../parallel/concrt/task-scheduler-concurrency-runtime.md)."},{"content":"Although you can use any one of these mechanisms to remove work from the UI thread, this example uses a <bpt id=\"p1\">[</bpt>concurrency::task_group<ept id=\"p1\">](reference/task-group-class.md)</ept> object because task groups support cancellation.","pos":[8111,8320],"source":" Although you can use any one of these mechanisms to remove work from the UI thread, this example uses a [concurrency::task_group](reference/task-group-class.md) object because task groups support cancellation."},{"content":"This walkthrough later uses cancellation to reduce the amount of work that is performed when the client window is resized, and to perform cleanup when the window is destroyed.","pos":[8321,8496]},{"content":"This example also uses a <bpt id=\"p1\">[</bpt>concurrency::unbounded_buffer<ept id=\"p1\">](reference/unbounded-buffer-class.md)</ept> object to enable the UI thread and the worker thread to communicate with each other.","pos":[8503,8681],"source":"This example also uses a [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) object to enable the UI thread and the worker thread to communicate with each other."},{"content":"After the worker thread produces the image, it sends a pointer to the <ph id=\"ph1\">`Bitmap`</ph> object to the <ph id=\"ph2\">`unbounded_buffer`</ph> object and then posts a paint message to the UI thread.","pos":[8682,8849],"source":" After the worker thread produces the image, it sends a pointer to the `Bitmap` object to the `unbounded_buffer` object and then posts a paint message to the UI thread."},{"content":"The UI thread then receives from the <ph id=\"ph1\">`unbounded_buffer`</ph> object the <ph id=\"ph2\">`Bitmap`</ph> object and draws it to the client window.","pos":[8850,8967],"source":" The UI thread then receives from the `unbounded_buffer` object the `Bitmap` object and draws it to the client window."},{"content":"To remove the drawing work from the UI thread","pos":[8978,9023]},{"pos":[9033,9086],"content":"In stdafx.h, add the following <ph id=\"ph1\">`#include`</ph> directives:","source":"In stdafx.h, add the following `#include` directives:"},{"pos":[9108,9129],"content":"concrt-mandelbrot#101"},{"content":"In ChildView.h, add <ph id=\"ph1\">`task_group`</ph> and <ph id=\"ph2\">`unbounded_buffer`</ph> member variables to the <ph id=\"ph3\">`protected`</ph> section of the <ph id=\"ph4\">`CChildView`</ph> class.","pos":[9239,9365],"source":"In ChildView.h, add `task_group` and `unbounded_buffer` member variables to the `protected` section of the `CChildView` class."},{"content":"The <ph id=\"ph1\">`task_group`</ph> object holds the tasks that perform drawing; the <ph id=\"ph2\">`unbounded_buffer`</ph> object holds the completed Mandelbrot image.","pos":[9366,9495],"source":" The `task_group` object holds the tasks that perform drawing; the `unbounded_buffer` object holds the completed Mandelbrot image."},{"pos":[9517,9538],"content":"concrt-mandelbrot#102"},{"pos":[9649,9722],"content":"In ChildView.cpp, add a <ph id=\"ph1\">`using`</ph> directive to the <ph id=\"ph2\">`concurrency`</ph> namespace.","source":"In ChildView.cpp, add a `using` directive to the `concurrency` namespace."},{"pos":[9744,9765],"content":"concrt-mandelbrot#103"},{"content":"In the <ph id=\"ph1\">`CChildView::DrawMandelbrot`</ph> method, after the call to <ph id=\"ph2\">`Bitmap::UnlockBits`</ph>, call the <bpt id=\"p1\">[</bpt>concurrency::send<ept id=\"p1\">](reference/concurrency-namespace-functions.md#send)</ept> function to pass the <ph id=\"ph3\">`Bitmap`</ph> object to the UI thread.","pos":[9879,10097],"source":"In the `CChildView::DrawMandelbrot` method, after the call to `Bitmap::UnlockBits`, call the [concurrency::send](reference/concurrency-namespace-functions.md#send) function to pass the `Bitmap` object to the UI thread."},{"content":"Then post a paint message to the UI thread and invalidate the client area.","pos":[10098,10172]},{"pos":[10195,10216],"content":"concrt-mandelbrot#104"},{"pos":[10329,10448],"content":"Update the <ph id=\"ph1\">`CChildView::OnPaint`</ph> method to receive the updated <ph id=\"ph2\">`Bitmap`</ph> object and draw the image to the client window.","source":"Update the `CChildView::OnPaint` method to receive the updated `Bitmap` object and draw the image to the client window."},{"pos":[10470,10491],"content":"concrt-mandelbrot#105"},{"content":"The <ph id=\"ph1\">`CChildView::OnPaint`</ph> method creates a task to generate the Mandelbrot image if one does not exist in the message buffer.","pos":[10605,10730],"source":"The `CChildView::OnPaint` method creates a task to generate the Mandelbrot image if one does not exist in the message buffer."},{"content":"The message buffer will not contain a <ph id=\"ph1\">`Bitmap`</ph> object in cases such as the initial paint message and when another window is moved in front of the client window.","pos":[10731,10891],"source":" The message buffer will not contain a `Bitmap` object in cases such as the initial paint message and when another window is moved in front of the client window."},{"content":"Verify that the application was updated successfully by building and running it.","pos":[10901,10981]},{"content":"The UI is now more responsive because the drawing work is performed in the background.","pos":[10988,11074]},{"pos":[11081,11094],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[11131,11160],"content":"Improving Drawing Performance"},{"content":"The generation of the Mandelbrot fractal is a good candidate for parallelization because the computation of each pixel is independent of all other computations.","pos":[11165,11325]},{"content":"To parallelize the drawing procedure, convert the outer <ph id=\"ph1\">`for`</ph> loop in the <ph id=\"ph2\">`CChildView::DrawMandelbrot`</ph> method to a call to the <bpt id=\"p1\">[</bpt>concurrency::parallel_for<ept id=\"p1\">](reference/concurrency-namespace-functions.md#parallel_for)</ept> algorithm, as follows.","pos":[11326,11562],"source":" To parallelize the drawing procedure, convert the outer `for` loop in the `CChildView::DrawMandelbrot` method to a call to the [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for) algorithm, as follows."},{"pos":[11581,11602],"content":"concrt-mandelbrot#301"},{"content":"Because the computation of each bitmap element is independent, you do not have to synchronize the drawing operations that access the bitmap memory.","pos":[11712,11859]},{"content":"This enables performance to scale as the number of available processors increases.","pos":[11860,11942]},{"pos":[11949,11962],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"pos":[12000,12031],"content":"Adding Support for Cancellation"},{"content":"This section describes how to handle window resizing and how to cancel any active drawing tasks when the window is destroyed.","pos":[12035,12160]},{"content":"The document <bpt id=\"p1\">[</bpt>Cancellation in the PPL<ept id=\"p1\">](cancellation-in-the-ppl.md)</ept> explains how cancellation works in the runtime.","pos":[12167,12281],"source":"The document [Cancellation in the PPL](cancellation-in-the-ppl.md) explains how cancellation works in the runtime."},{"content":"Cancellation is cooperative; therefore, it does not occur immediately.","pos":[12282,12352]},{"content":"To stop a canceled task, the runtime throws an internal exception during a subsequent call from the task into the runtime.","pos":[12353,12475]},{"content":"The previous section shows how to use the <ph id=\"ph1\">`parallel_for`</ph> algorithm to improve the performance of the drawing task.","pos":[12476,12590],"source":" The previous section shows how to use the `parallel_for` algorithm to improve the performance of the drawing task."},{"content":"The call to <ph id=\"ph1\">`parallel_for`</ph> enables the runtime to stop the task, and therefore enables cancellation to work.","pos":[12591,12699],"source":" The call to `parallel_for` enables the runtime to stop the task, and therefore enables cancellation to work."},{"content":"Cancelling Active Tasks","pos":[12709,12732]},{"content":"The Mandelbrot application creates <ph id=\"ph1\">`Bitmap`</ph> objects whose dimensions match the size of the client window.","pos":[12736,12841],"source":"The Mandelbrot application creates `Bitmap` objects whose dimensions match the size of the client window."},{"content":"Every time the client window is resized, the application creates an additional background task to generate an image for the new window size.","pos":[12842,12982]},{"content":"The application does not require these intermediate images; it requires only the image for the final window size.","pos":[12983,13096]},{"content":"To prevent the application from performing this additional work, you can cancel any active drawing tasks in the message handlers for the <ph id=\"ph1\">`WM_SIZE`</ph> and <ph id=\"ph2\">`WM_SIZING`</ph> messages and then reschedule drawing work after the window is resized.","pos":[13097,13330],"source":" To prevent the application from performing this additional work, you can cancel any active drawing tasks in the message handlers for the `WM_SIZE` and `WM_SIZING` messages and then reschedule drawing work after the window is resized."},{"content":"To cancel active drawing tasks when the window is resized, the application calls the <bpt id=\"p1\">[</bpt>concurrency::task_group::cancel<ept id=\"p1\">](reference/task-group-class.md#cancel)</ept> method in the handlers for the <ph id=\"ph1\">`WM_SIZING`</ph> and <ph id=\"ph2\">`WM_SIZE`</ph> messages.","pos":[13337,13560],"source":"To cancel active drawing tasks when the window is resized, the application calls the [concurrency::task_group::cancel](reference/task-group-class.md#cancel) method in the handlers for the `WM_SIZING` and `WM_SIZE` messages."},{"content":"The handler for the <ph id=\"ph1\">`WM_SIZE`</ph> message also calls the <bpt id=\"p1\">[</bpt>concurrency::task_group::wait<ept id=\"p1\">](reference/task-group-class.md#wait)</ept> method to wait for all active tasks to complete and then reschedules the drawing task for the updated window size.","pos":[13561,13796],"source":" The handler for the `WM_SIZE` message also calls the [concurrency::task_group::wait](reference/task-group-class.md#wait) method to wait for all active tasks to complete and then reschedules the drawing task for the updated window size."},{"content":"When the client window is destroyed, it is good practice to cancel any active drawing tasks.","pos":[13803,13895]},{"content":"Canceling any active drawing tasks makes sure that worker threads do not post messages to the UI thread after the client window is destroyed.","pos":[13896,14037]},{"content":"The application cancels any active drawing tasks in the handler for the <ph id=\"ph1\">`WM_DESTROY`</ph> message.","pos":[14038,14131],"source":" The application cancels any active drawing tasks in the handler for the `WM_DESTROY` message."},{"content":"Responding to Cancellation","pos":[14141,14167]},{"content":"The <ph id=\"ph1\">`CChildView::DrawMandelbrot`</ph> method, which performs the drawing task, must respond to cancellation.","pos":[14171,14274],"source":"The `CChildView::DrawMandelbrot` method, which performs the drawing task, must respond to cancellation."},{"content":"Because the runtime uses exception handling to cancel tasks, the <ph id=\"ph1\">`CChildView::DrawMandelbrot`</ph> method must use an exception-safe mechanism to guarantee that all resources are correctly cleaned-up.","pos":[14275,14470],"source":" Because the runtime uses exception handling to cancel tasks, the `CChildView::DrawMandelbrot` method must use an exception-safe mechanism to guarantee that all resources are correctly cleaned-up."},{"content":"This example uses the <bpt id=\"p1\">*</bpt>Resource Acquisition Is Initialization<ept id=\"p1\">*</ept> (RAII) pattern to guarantee that the bitmap bits are unlocked when the task is canceled.","pos":[14471,14622],"source":" This example uses the *Resource Acquisition Is Initialization* (RAII) pattern to guarantee that the bitmap bits are unlocked when the task is canceled."},{"content":"To add support for cancellation in the Mandelbrot application","pos":[14634,14695]},{"pos":[14705,14860],"content":"In ChildView.h, in the <ph id=\"ph1\">`protected`</ph> section of the <ph id=\"ph2\">`CChildView`</ph> class, add declarations for the <ph id=\"ph3\">`OnSize`</ph>, <ph id=\"ph4\">`OnSizing`</ph>, and <ph id=\"ph5\">`OnDestroy`</ph> message map functions.","source":"In ChildView.h, in the `protected` section of the `CChildView` class, add declarations for the `OnSize`, `OnSizing`, and `OnDestroy` message map functions."},{"pos":[14882,14903],"content":"concrt-mandelbrot#201"},{"pos":[15014,15133],"content":"In ChildView.cpp, modify the message map to contain handlers for the <ph id=\"ph1\">`WM_SIZE`</ph>, <ph id=\"ph2\">`WM_SIZING`</ph>, and <ph id=\"ph3\">`WM_DESTROY`</ph> messages.","source":"In ChildView.cpp, modify the message map to contain handlers for the `WM_SIZE`, `WM_SIZING`, and `WM_DESTROY` messages."},{"pos":[15155,15176],"content":"concrt-mandelbrot#202"},{"content":"Implement the <ph id=\"ph1\">`CChildView::OnSizing`</ph> method.","pos":[15289,15333],"source":"Implement the `CChildView::OnSizing` method."},{"content":"This method cancels any existing drawing tasks.","pos":[15334,15381]},{"pos":[15403,15424],"content":"concrt-mandelbrot#203"},{"content":"Implement the <ph id=\"ph1\">`CChildView::OnSize`</ph> method.","pos":[15537,15579],"source":"Implement the `CChildView::OnSize` method."},{"content":"This method cancels any existing drawing tasks and creates a new drawing task for the updated client window size.","pos":[15580,15693]},{"pos":[15715,15736],"content":"concrt-mandelbrot#204"},{"content":"Implement the <ph id=\"ph1\">`CChildView::OnDestroy`</ph> method.","pos":[15849,15894],"source":"Implement the `CChildView::OnDestroy` method."},{"content":"This method cancels any existing drawing tasks.","pos":[15895,15942]},{"pos":[15964,15985],"content":"concrt-mandelbrot#205"},{"pos":[16098,16182],"content":"In ChildView.cpp, define the <ph id=\"ph1\">`scope_guard`</ph> class, which implements the RAII pattern.","source":"In ChildView.cpp, define the `scope_guard` class, which implements the RAII pattern."},{"pos":[16204,16225],"content":"concrt-mandelbrot#206"},{"pos":[16338,16441],"content":"Add the following code to the <ph id=\"ph1\">`CChildView::DrawMandelbrot`</ph> method after the call to <ph id=\"ph2\">`Bitmap::LockBits`</ph>:","source":"Add the following code to the `CChildView::DrawMandelbrot` method after the call to `Bitmap::LockBits`:"},{"pos":[16463,16484],"content":"concrt-mandelbrot#207"},{"content":"This code handles cancellation by creating a <ph id=\"ph1\">`scope_guard`</ph> object.","pos":[16598,16664],"source":"This code handles cancellation by creating a `scope_guard` object."},{"content":"When the object leaves scope, it unlocks the bitmap bits.","pos":[16665,16722]},{"content":"Modify the end of the <ph id=\"ph1\">`CChildView::DrawMandelbrot`</ph> method to dismiss the <ph id=\"ph2\">`scope_guard`</ph> object after the bitmap bits are unlocked, but before any messages are sent to the UI thread.","pos":[16732,16912],"source":"Modify the end of the `CChildView::DrawMandelbrot` method to dismiss the `scope_guard` object after the bitmap bits are unlocked, but before any messages are sent to the UI thread."},{"content":"This ensures that the UI thread is not updated before the bitmap bits are unlocked.","pos":[16913,16996]},{"pos":[17018,17039],"content":"concrt-mandelbrot#208"},{"content":"Verify that the application was updated successfully by building and running it.","pos":[17151,17231]},{"content":"When you resize the window, drawing work is performed only for the final window size.","pos":[17238,17323]},{"content":"Any active drawing tasks are also canceled when the window is destroyed.","pos":[17324,17396]},{"pos":[17403,17416],"content":"[<bpt id=\"p1\">[</bpt>Top<ept id=\"p1\">](#top)</ept>]","source":"[[Top](#top)]"},{"content":"See Also","pos":[17425,17433]},{"content":"Concurrency Runtime Walkthroughs","pos":[17438,17470]},{"content":"Task Parallelism","pos":[17536,17552]},{"content":"Asynchronous Message Blocks","pos":[17622,17649]},{"content":"Message Passing Functions","pos":[17710,17735]},{"content":"Parallel Algorithms","pos":[17794,17813]},{"content":"Cancellation in the PPL","pos":[17866,17889]},{"content":"MFC Desktop Applications","pos":[17924,17948]}],"content":"---\ntitle: \"Walkthrough: Removing Work from a User-Interface Thread | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"user-interface threads, removing work from [Concurrency Runtime]\"\n  - \"removing work from user-interface threads [Concurrency Runtime]\"\nms.assetid: a4a65cc2-b3bc-4216-8fa8-90529491de02\ncaps.latest.revision: 14\nauthor: \"mikeblome\"\nms.author: \"mblome\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Walkthrough: Removing Work from a User-Interface Thread\nThis document demonstrates how to use the Concurrency Runtime to move the work that is performed by the user-interface (UI) thread in a Microsoft Foundation Classes (MFC) application to a worker thread. This document also demonstrates how to improve the performance of a lengthy drawing operation.  \n  \n Removing work from the UI thread by offloading blocking operations, for example, drawing, to worker threads can improve the responsiveness of your application. This walkthrough uses a drawing routine that generates the Mandelbrot fractal to demonstrate a lengthy blocking operation. The generation of the Mandelbrot fractal is also a good candidate for parallelization because the computation of each pixel is independent of all other computations.  \n  \n## Prerequisites  \n Read the following topics before you start this walkthrough:  \n  \n-   [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md)  \n  \n-   [Asynchronous Message Blocks](../../parallel/concrt/asynchronous-message-blocks.md)  \n  \n-   [Message Passing Functions](../../parallel/concrt/message-passing-functions.md)  \n  \n-   [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)  \n  \n-   [Cancellation in the PPL](cancellation-in-the-ppl.md)  \n  \n We also recommend that you understand the basics of MFC application development and [!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)] before you start this walkthrough. For more information about MFC, see [MFC Desktop Applications](../../mfc/mfc-desktop-applications.md). For more information about [!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)], see [GDI+](https://msdn.microsoft.com/en-us/library/windows/desktop/ms533798).  \n  \n##  <a name=\"top\"></a> Sections  \n This walkthrough contains the following sections:  \n  \n-   [Creating the MFC Application](#application)  \n  \n-   [Implementing the Serial Version of the Mandelbrot Application](#serial)  \n  \n-   [Removing Work from the User-Interface Thread](#removing-work)  \n  \n-   [Improving Drawing Performance](#performance)  \n  \n-   [Adding Support for Cancellation](#cancellation)  \n  \n##  <a name=\"application\"></a> Creating the MFC Application  \n This section describes how to create the basic MFC application.  \n  \n### To create a Visual C++ MFC application  \n  \n1.  On the **File** menu, click **New**, and then click **Project**.  \n  \n2.  In the **New Project** dialog box, in the **Installed Templates** pane, select **Visual C++**, and then, in the **Templates** pane, select **MFC Application**. Type a name for the project, for example, `Mandelbrot`, and then click **OK** to display the **MFC Application Wizard**.  \n  \n3.  In the **Application Type** pane, select **Single document**. Ensure that the **Document/View architecture support** check box is cleared.  \n  \n4.  Click **Finish** to create the project and close the **MFC Application Wizard**.  \n  \n     Verify that the application was created successfully by building and running it. To build the application, on the **Build** menu, click **Build Solution**. If the application builds successfully, run the application by clicking **Start Debugging** on the **Debug** menu.  \n  \n##  <a name=\"serial\"></a> Implementing the Serial Version of the Mandelbrot Application  \n This section describes how to draw the Mandelbrot fractal. This version draws the Mandelbrot fractal to a [!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)] [Bitmap](https://msdn.microsoft.com/library/ms534420.aspx) object and then copies the contents of that bitmap to the client window.  \n  \n#### To implement the serial version of the Mandelbrot application  \n  \n1.  In stdafx.h, add the following `#include` directive:  \n  \n     [!code-cpp[concrt-mandelbrot#1](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_1.h)]  \n  \n2.  In ChildView.h, after the `pragma` directive, define the `BitmapPtr` type. The `BitmapPtr` type enables a pointer to a `Bitmap` object to be shared by multiple components. The `Bitmap` object is deleted when it is no longer referenced by any component.  \n  \n     [!code-cpp[concrt-mandelbrot#2](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_2.h)]  \n  \n3.  In ChildView.h, add the following code to the `protected` section of the `CChildView` class:  \n  \n     [!code-cpp[concrt-mandelbrot#3](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_3.h)]  \n  \n4.  In ChildView.cpp, comment out or remove the following lines.  \n  \n     [!code-cpp[concrt-mandelbrot#4](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_4.cpp)]  \n  \n     In Debug builds, this step prevents the application from using the `DEBUG_NEW` allocator, which is incompatible with [!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)].  \n  \n5.  In ChildView.cpp, add a `using` directive to the `Gdiplus` namespace.  \n  \n     [!code-cpp[concrt-mandelbrot#5](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_5.cpp)]  \n  \n6.  Add the following code to the constructor and destructor of the `CChildView` class to initialize and shut down [!INCLUDE[ndptecgdiplus](../../parallel/concrt/includes/ndptecgdiplus_md.md)].  \n  \n     [!code-cpp[concrt-mandelbrot#6](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_6.cpp)]  \n  \n7.  Implement the `CChildView::DrawMandelbrot` method. This method draws the Mandelbrot fractal to the specified `Bitmap` object.  \n  \n     [!code-cpp[concrt-mandelbrot#7](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_7.cpp)]  \n  \n8.  Implement the `CChildView::OnPaint` method. This method calls `CChildView::DrawMandelbrot` and then copies the contents of the `Bitmap` object to the window.  \n  \n     [!code-cpp[concrt-mandelbrot#8](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_8.cpp)]  \n  \n9. Verify that the application was updated successfully by building and running it.  \n  \n The following illustration shows the results of the Mandelbrot application.  \n  \n ![The Mandelbrot Application](../../parallel/concrt/media/mandelbrot.png \"mandelbrot\")  \n  \n Because the computation for each pixel is computationally expensive, the UI thread cannot process additional messages until the overall computation finishes. This could decrease responsiveness in the application. However, you can relieve this problem by removing work from the UI thread.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"removing-work\"></a> Removing Work from the UI Thread  \n This section shows how to remove the drawing work from the UI thread in the Mandelbrot application. By moving drawing work from the UI thread to a worker thread, the UI thread can process messages as the worker thread generates the image in the background.  \n  \n The Concurrency Runtime provides three ways to run tasks: [task groups](../../parallel/concrt/task-parallelism-concurrency-runtime.md), [asynchronous agents](../../parallel/concrt/asynchronous-agents.md), and [lightweight tasks](../../parallel/concrt/task-scheduler-concurrency-runtime.md). Although you can use any one of these mechanisms to remove work from the UI thread, this example uses a [concurrency::task_group](reference/task-group-class.md) object because task groups support cancellation. This walkthrough later uses cancellation to reduce the amount of work that is performed when the client window is resized, and to perform cleanup when the window is destroyed.  \n  \n This example also uses a [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) object to enable the UI thread and the worker thread to communicate with each other. After the worker thread produces the image, it sends a pointer to the `Bitmap` object to the `unbounded_buffer` object and then posts a paint message to the UI thread. The UI thread then receives from the `unbounded_buffer` object the `Bitmap` object and draws it to the client window.  \n  \n#### To remove the drawing work from the UI thread  \n  \n1.  In stdafx.h, add the following `#include` directives:  \n  \n     [!code-cpp[concrt-mandelbrot#101](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_9.h)]  \n  \n2.  In ChildView.h, add `task_group` and `unbounded_buffer` member variables to the `protected` section of the `CChildView` class. The `task_group` object holds the tasks that perform drawing; the `unbounded_buffer` object holds the completed Mandelbrot image.  \n  \n     [!code-cpp[concrt-mandelbrot#102](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_10.h)]  \n  \n3.  In ChildView.cpp, add a `using` directive to the `concurrency` namespace.  \n  \n     [!code-cpp[concrt-mandelbrot#103](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_11.cpp)]  \n  \n\n4.  In the `CChildView::DrawMandelbrot` method, after the call to `Bitmap::UnlockBits`, call the [concurrency::send](reference/concurrency-namespace-functions.md#send) function to pass the `Bitmap` object to the UI thread. Then post a paint message to the UI thread and invalidate the client area.  \n\n  \n     [!code-cpp[concrt-mandelbrot#104](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_12.cpp)]  \n  \n5.  Update the `CChildView::OnPaint` method to receive the updated `Bitmap` object and draw the image to the client window.  \n  \n     [!code-cpp[concrt-mandelbrot#105](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_13.cpp)]  \n  \n     The `CChildView::OnPaint` method creates a task to generate the Mandelbrot image if one does not exist in the message buffer. The message buffer will not contain a `Bitmap` object in cases such as the initial paint message and when another window is moved in front of the client window.  \n  \n6.  Verify that the application was updated successfully by building and running it.  \n  \n The UI is now more responsive because the drawing work is performed in the background.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"performance\"></a> Improving Drawing Performance  \n\n The generation of the Mandelbrot fractal is a good candidate for parallelization because the computation of each pixel is independent of all other computations. To parallelize the drawing procedure, convert the outer `for` loop in the `CChildView::DrawMandelbrot` method to a call to the [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for) algorithm, as follows.  \n\n  \n [!code-cpp[concrt-mandelbrot#301](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_14.cpp)]  \n  \n Because the computation of each bitmap element is independent, you do not have to synchronize the drawing operations that access the bitmap memory. This enables performance to scale as the number of available processors increases.  \n  \n [[Top](#top)]  \n  \n##  <a name=\"cancellation\"></a> Adding Support for Cancellation  \n This section describes how to handle window resizing and how to cancel any active drawing tasks when the window is destroyed.  \n  \n The document [Cancellation in the PPL](cancellation-in-the-ppl.md) explains how cancellation works in the runtime. Cancellation is cooperative; therefore, it does not occur immediately. To stop a canceled task, the runtime throws an internal exception during a subsequent call from the task into the runtime. The previous section shows how to use the `parallel_for` algorithm to improve the performance of the drawing task. The call to `parallel_for` enables the runtime to stop the task, and therefore enables cancellation to work.  \n  \n### Cancelling Active Tasks  \n The Mandelbrot application creates `Bitmap` objects whose dimensions match the size of the client window. Every time the client window is resized, the application creates an additional background task to generate an image for the new window size. The application does not require these intermediate images; it requires only the image for the final window size. To prevent the application from performing this additional work, you can cancel any active drawing tasks in the message handlers for the `WM_SIZE` and `WM_SIZING` messages and then reschedule drawing work after the window is resized.  \n  \n To cancel active drawing tasks when the window is resized, the application calls the [concurrency::task_group::cancel](reference/task-group-class.md#cancel) method in the handlers for the `WM_SIZING` and `WM_SIZE` messages. The handler for the `WM_SIZE` message also calls the [concurrency::task_group::wait](reference/task-group-class.md#wait) method to wait for all active tasks to complete and then reschedules the drawing task for the updated window size.  \n  \n When the client window is destroyed, it is good practice to cancel any active drawing tasks. Canceling any active drawing tasks makes sure that worker threads do not post messages to the UI thread after the client window is destroyed. The application cancels any active drawing tasks in the handler for the `WM_DESTROY` message.  \n  \n### Responding to Cancellation  \n The `CChildView::DrawMandelbrot` method, which performs the drawing task, must respond to cancellation. Because the runtime uses exception handling to cancel tasks, the `CChildView::DrawMandelbrot` method must use an exception-safe mechanism to guarantee that all resources are correctly cleaned-up. This example uses the *Resource Acquisition Is Initialization* (RAII) pattern to guarantee that the bitmap bits are unlocked when the task is canceled.  \n  \n##### To add support for cancellation in the Mandelbrot application  \n  \n1.  In ChildView.h, in the `protected` section of the `CChildView` class, add declarations for the `OnSize`, `OnSizing`, and `OnDestroy` message map functions.  \n  \n     [!code-cpp[concrt-mandelbrot#201](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_15.h)]  \n  \n2.  In ChildView.cpp, modify the message map to contain handlers for the `WM_SIZE`, `WM_SIZING`, and `WM_DESTROY` messages.  \n  \n     [!code-cpp[concrt-mandelbrot#202](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_16.cpp)]  \n  \n3.  Implement the `CChildView::OnSizing` method. This method cancels any existing drawing tasks.  \n  \n     [!code-cpp[concrt-mandelbrot#203](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_17.cpp)]  \n  \n4.  Implement the `CChildView::OnSize` method. This method cancels any existing drawing tasks and creates a new drawing task for the updated client window size.  \n  \n     [!code-cpp[concrt-mandelbrot#204](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_18.cpp)]  \n  \n5.  Implement the `CChildView::OnDestroy` method. This method cancels any existing drawing tasks.  \n  \n     [!code-cpp[concrt-mandelbrot#205](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_19.cpp)]  \n  \n6.  In ChildView.cpp, define the `scope_guard` class, which implements the RAII pattern.  \n  \n     [!code-cpp[concrt-mandelbrot#206](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_20.cpp)]  \n  \n7.  Add the following code to the `CChildView::DrawMandelbrot` method after the call to `Bitmap::LockBits`:  \n  \n     [!code-cpp[concrt-mandelbrot#207](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_21.cpp)]  \n  \n     This code handles cancellation by creating a `scope_guard` object. When the object leaves scope, it unlocks the bitmap bits.  \n  \n8.  Modify the end of the `CChildView::DrawMandelbrot` method to dismiss the `scope_guard` object after the bitmap bits are unlocked, but before any messages are sent to the UI thread. This ensures that the UI thread is not updated before the bitmap bits are unlocked.  \n  \n     [!code-cpp[concrt-mandelbrot#208](../../parallel/concrt/codesnippet/cpp/walkthrough-removing-work-from-a-user-interface-thread_22.cpp)]  \n  \n9. Verify that the application was updated successfully by building and running it.  \n  \n When you resize the window, drawing work is performed only for the final window size. Any active drawing tasks are also canceled when the window is destroyed.  \n  \n [[Top](#top)]  \n  \n## See Also  \n [Concurrency Runtime Walkthroughs](../../parallel/concrt/concurrency-runtime-walkthroughs.md)   \n [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md)   \n [Asynchronous Message Blocks](../../parallel/concrt/asynchronous-message-blocks.md)   \n [Message Passing Functions](../../parallel/concrt/message-passing-functions.md)   \n [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)   \n [Cancellation in the PPL](cancellation-in-the-ppl.md)   \n [MFC Desktop Applications](../../mfc/mfc-desktop-applications.md)\n"}