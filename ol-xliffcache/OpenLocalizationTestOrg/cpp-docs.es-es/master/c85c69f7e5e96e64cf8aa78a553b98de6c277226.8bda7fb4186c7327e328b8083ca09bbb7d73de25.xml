{"nodes":[{"pos":[12,40],"content":"deque Class | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"deque Class | Microsoft Docs","pos":[0,28]}]},{"content":"deque Class","pos":[680,691]},{"content":"Arranges elements of a given type in a linear arrangement and, like a vector, enables fast random access to any element, and efficient insertion and deletion at the back of the container.","pos":[692,879]},{"content":"However, unlike a vector, the <ph id=\"ph1\">`deque`</ph> class also supports efficient insertion and deletion at the front of the container.","pos":[880,1001],"source":" However, unlike a vector, the `deque` class also supports efficient insertion and deletion at the front of the container."},{"content":"Syntax","pos":[1010,1016]},{"content":"Parameters","pos":[1121,1131]},{"content":"The element data type to be stored in the deque.","pos":[1145,1193]},{"content":"The type that represents the stored allocator object that encapsulates details about the deque's allocation and deallocation of memory.","pos":[1215,1350]},{"content":"This argument is optional, and the default value is <bpt id=\"p1\">**</bpt>allocator<ph id=\"ph1\">\\&lt;</ph>Type&gt;<ept id=\"p1\">**</ept><bpt id=\"p2\">*</bpt>.<ept id=\"p2\">*</ept>","pos":[1351,1426],"source":" This argument is optional, and the default value is **allocator\\<Type>***.*"},{"content":"Remarks","pos":[1435,1442]},{"content":"The choice of container type should be based in general on the type of searching and inserting required by the application.","pos":[1446,1569]},{"content":"<bpt id=\"p1\">[</bpt>Vectors<ept id=\"p1\">](../standard-library/vector-class.md)</ept> should be the preferred container for managing a sequence when random access to any element is at a premium and insertions or deletions of elements are only required at the end of a sequence.","pos":[1570,1808],"source":"[Vectors](../standard-library/vector-class.md) should be the preferred container for managing a sequence when random access to any element is at a premium and insertions or deletions of elements are only required at the end of a sequence."},{"content":"The performance of the list container is superior when efficient insertions and deletions (in constant time) at any location within the sequence is at a premium.","pos":[1809,1970]},{"content":"Such operations in the middle of the sequence require element copies and assignments proportional to the number of elements in the sequence (linear time).","pos":[1971,2125]},{"content":"Deque reallocation occurs when a member function must insert or erase elements of the sequence:","pos":[2132,2227]},{"pos":[2237,2438],"content":"If an element is inserted into an empty sequence, or if an element is erased to leave an empty sequence, then iterators earlier returned by <bpt id=\"p1\">[</bpt>begin<ept id=\"p1\">](#deque__begin)</ept> and <bpt id=\"p2\">[</bpt>end<ept id=\"p2\">](#deque__end)</ept> become invalid.","source":"If an element is inserted into an empty sequence, or if an element is erased to leave an empty sequence, then iterators earlier returned by [begin](#deque__begin) and [end](#deque__end) become invalid."},{"content":"If an element is inserted at the first position of the deque, then all iterators, but no references, that designate existing elements become invalid.","pos":[2448,2597]},{"pos":[2607,2768],"content":"If an element is inserted at the end of the deque, then <bpt id=\"p1\">[</bpt>end<ept id=\"p1\">](#deque__end)</ept> and all iterators, but no references, that designate existing elements become invalid.","source":"If an element is inserted at the end of the deque, then [end](#deque__end) and all iterators, but no references, that designate existing elements become invalid."},{"content":"If an element is erased at the front of the deque, only that iterator and references to the erased element become invalid.","pos":[2778,2900]},{"content":"If the last element is erased from the end of the deque, only that iterator to the final element and references to the erased element become invalid.","pos":[2910,3059]},{"content":"Otherwise, inserting or erasing an element invalidates all iterators and references.","pos":[3066,3150]},{"content":"Constructors","pos":[3160,3172]},{"content":"deque","pos":[3194,3199]},{"content":"Constructs a <ph id=\"ph1\">`deque.`</ph> Several constructors are provided to set up the contents of the new <ph id=\"ph2\">`deque`</ph> in different ways: empty; loaded with a specified number of empty elements; contents moved or copied from another <ph id=\"ph3\">`deque`</ph>; contents copied or moved by using an iterator; and one element copied into the <ph id=\"ph4\">`deque`` count`</ph> times.","pos":[3216,3538],"source":"Constructs a `deque.` Several constructors are provided to set up the contents of the new `deque` in different ways: empty; loaded with a specified number of empty elements; contents moved or copied from another `deque`; contents copied or moved by using an iterator; and one element copied into the `deque`` count` times."},{"content":"Some of the constructors enable using a custom <ph id=\"ph1\">`allocator`</ph> to create elements.","pos":[3539,3617],"source":" Some of the constructors enable using a custom `allocator` to create elements."},{"content":"Typedefs","pos":[3628,3636]},{"content":"allocator_type","pos":[3658,3672]},{"pos":[3698,3766],"content":"A type that represents the <ph id=\"ph1\">`allocator`</ph> class for the <ph id=\"ph2\">`deque`</ph> object.","source":"A type that represents the `allocator` class for the `deque` object."},{"content":"const_iterator","pos":[3772,3786]},{"pos":[3812,3909],"content":"A type that provides a random-access iterator that can access and read elements in the <ph id=\"ph1\">`deque`</ph> as","source":"A type that provides a random-access iterator that can access and read elements in the `deque` as "},{"content":"const_pointer","pos":[3923,3936]},{"pos":[3961,4023],"content":"A type that provides a pointer to an element in a <ph id=\"ph1\">`deque`</ph> as a","source":"A type that provides a pointer to an element in a `deque` as a "},{"content":"const_reference","pos":[4038,4053]},{"pos":[4080,4177],"content":"A type that provides a reference to an element in a <ph id=\"ph1\">`deque`</ph> for reading and other operations as a","source":"A type that provides a reference to an element in a `deque` for reading and other operations as a "},{"content":"const_reverse_iterator","pos":[4192,4214]},{"content":"A type that provides a random-access iterator that can access and read elements in the <ph id=\"ph1\">`deque`</ph> as <ph id=\"ph2\">`const`</ph>.","pos":[4248,4354],"source":"A type that provides a random-access iterator that can access and read elements in the `deque` as `const`."},{"content":"The deque is viewed in reverse.","pos":[4355,4386]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>reverse_iterator Class<ept id=\"p1\">](../standard-library/reverse-iterator-class.md)</ept>","pos":[4387,4484],"source":" For more information, see [reverse_iterator Class](../standard-library/reverse-iterator-class.md)"},{"content":"difference_type","pos":[4490,4505]},{"pos":[4532,4647],"content":"A type that provides the difference between two random-access iterators that refer to elements in the same <ph id=\"ph1\">`deque`</ph>.","source":"A type that provides the difference between two random-access iterators that refer to elements in the same `deque`."},{"content":"iterator","pos":[4653,4661]},{"pos":[4681,4776],"content":"A type that provides a random-access iterator that can read or modify any element in a <ph id=\"ph1\">`deque`</ph>.","source":"A type that provides a random-access iterator that can read or modify any element in a `deque`."},{"content":"pointer","pos":[4782,4789]},{"pos":[4808,4866],"content":"A type that provides a pointer to an element in a <ph id=\"ph1\">`deque`</ph>.","source":"A type that provides a pointer to an element in a `deque`."},{"content":"reference","pos":[4872,4881]},{"pos":[4902,4969],"content":"A type that provides a reference to an element stored in a <ph id=\"ph1\">`deque`</ph>.","source":"A type that provides a reference to an element stored in a `deque`."},{"content":"reverse_iterator","pos":[4975,4991]},{"content":"A type that provides a random-access iterator that can read or modify an element in a <ph id=\"ph1\">`deque`</ph>.","pos":[5019,5113],"source":"A type that provides a random-access iterator that can read or modify an element in a `deque`."},{"content":"The deque is viewed in reverse order.","pos":[5114,5151]},{"content":"size_type","pos":[5157,5166]},{"pos":[5187,5242],"content":"A type that counts the number of elements in a <ph id=\"ph1\">`deque`</ph>.","source":"A type that counts the number of elements in a `deque`."},{"content":"value_type","pos":[5248,5258]},{"pos":[5280,5337],"content":"A type that represents the data type stored in a <ph id=\"ph1\">`deque`</ph>.","source":"A type that represents the data type stored in a `deque`."},{"content":"Member Functions","pos":[5348,5364]},{"content":"assign","pos":[5386,5392]},{"pos":[5410,5501],"content":"Erases elements from a <ph id=\"ph1\">`deque`</ph> and copies a new sequence of elements to the target <ph id=\"ph2\">`deque`</ph>.","source":"Erases elements from a `deque` and copies a new sequence of elements to the target `deque`."},{"content":"at","pos":[5507,5509]},{"pos":[5523,5597],"content":"Returns a reference to the element at a specified location in the <ph id=\"ph1\">`deque`</ph>.","source":"Returns a reference to the element at a specified location in the `deque`."},{"content":"back","pos":[5603,5607]},{"pos":[5623,5678],"content":"Returns a reference to the last element of the <ph id=\"ph1\">`deque`</ph>.","source":"Returns a reference to the last element of the `deque`."},{"content":"begin","pos":[5684,5689]},{"pos":[5706,5784],"content":"Returns a random-access  iterator addressing the first element in the <ph id=\"ph1\">`deque`</ph>.","source":"Returns a random-access  iterator addressing the first element in the `deque`."},{"content":"cbegin","pos":[5790,5796]},{"pos":[5814,5875],"content":"Returns a const iterator to the first element in the <ph id=\"ph1\">`deque`</ph>.","source":"Returns a const iterator to the first element in the `deque`."},{"content":"cend","pos":[5881,5885]},{"pos":[5901,5989],"content":"Returns a random-access <ph id=\"ph1\">`const`</ph> iterator that points just beyond the end of the <ph id=\"ph2\">`deque`</ph>.","source":"Returns a random-access `const` iterator that points just beyond the end of the `deque`."},{"content":"clear","pos":[5995,6000]},{"pos":[6017,6054],"content":"Erases all the elements of a <ph id=\"ph1\">`deque`</ph>.","source":"Erases all the elements of a `deque`."},{"content":"crbegin","pos":[6060,6067]},{"pos":[6086,6183],"content":"Returns a random-access const iterator to the first element in a <ph id=\"ph1\">`deque`</ph> viewed in reverse order.","source":"Returns a random-access const iterator to the first element in a `deque` viewed in reverse order."},{"content":"crend","pos":[6189,6194]},{"pos":[6211,6308],"content":"Returns a random-access const iterator to the first element in a <ph id=\"ph1\">`deque`</ph> viewed in reverse order.","source":"Returns a random-access const iterator to the first element in a `deque` viewed in reverse order."},{"content":"emplace","pos":[6314,6321]},{"pos":[6340,6421],"content":"Inserts an element constructed in place into the <ph id=\"ph1\">`deque`</ph> at a specified position.","source":"Inserts an element constructed in place into the `deque` at a specified position."},{"content":"emplace_back","pos":[6427,6439]},{"pos":[6463,6526],"content":"Adds an element constructed in place to the end of the <ph id=\"ph1\">`deque`</ph>.","source":"Adds an element constructed in place to the end of the `deque`."},{"content":"emplace_front","pos":[6532,6545]},{"pos":[6570,6635],"content":"Adds an element constructed in place to the start of the <ph id=\"ph1\">`deque`</ph>.","source":"Adds an element constructed in place to the start of the `deque`."},{"content":"empty","pos":[6641,6646]},{"pos":[6663,6765],"content":"Returns <ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">`deque`</ph> contains zero elements, and <ph id=\"ph3\">`false`</ph> if it contains one or more elements.","source":"Returns `true` if the `deque` contains zero elements, and `false` if it contains one or more elements."},{"content":"end","pos":[6771,6774]},{"pos":[6789,6869],"content":"Returns a random-access iterator that points just beyond the end of the <ph id=\"ph1\">`deque`</ph>.","source":"Returns a random-access iterator that points just beyond the end of the `deque`."},{"content":"erase","pos":[6875,6880]},{"pos":[6897,6977],"content":"Removes an element or a range of elements in a <ph id=\"ph1\">`deque`</ph> from specified positions.","source":"Removes an element or a range of elements in a `deque` from specified positions."},{"content":"front","pos":[6983,6988]},{"pos":[7005,7059],"content":"Returns a reference to the first element in a <ph id=\"ph1\">`deque`</ph>.","source":"Returns a reference to the first element in a `deque`."},{"content":"get_allocator","pos":[7065,7078]},{"pos":[7103,7182],"content":"Returns a copy of the <ph id=\"ph1\">`allocator`</ph> object that is used to construct the <ph id=\"ph2\">`deque`</ph>.","source":"Returns a copy of the `allocator` object that is used to construct the `deque`."},{"content":"insert","pos":[7188,7194]},{"pos":[7212,7314],"content":"Inserts an element, several elements, or a range of elements into the <ph id=\"ph1\">`deque`</ph> at a specified position.","source":"Inserts an element, several elements, or a range of elements into the `deque` at a specified position."},{"content":"max_size","pos":[7320,7328]},{"pos":[7348,7399],"content":"Returns the maximum possible length of the <ph id=\"ph1\">`deque`</ph>.","source":"Returns the maximum possible length of the `deque`."},{"content":"pop_back","pos":[7405,7413]},{"pos":[7433,7478],"content":"Erases the element at the end of the <ph id=\"ph1\">`deque`</ph>.","source":"Erases the element at the end of the `deque`."},{"content":"pop_front","pos":[7484,7493]},{"pos":[7514,7561],"content":"Erases the element at the start of the <ph id=\"ph1\">`deque`</ph>.","source":"Erases the element at the start of the `deque`."},{"content":"push_back","pos":[7567,7576]},{"pos":[7597,7639],"content":"Adds an element to the end of the <ph id=\"ph1\">`deque`</ph>.","source":"Adds an element to the end of the `deque`."},{"content":"push_front","pos":[7645,7655]},{"pos":[7677,7721],"content":"Adds an element to the start of the <ph id=\"ph1\">`deque`</ph>.","source":"Adds an element to the start of the `deque`."},{"content":"rbegin","pos":[7727,7733]},{"pos":[7751,7827],"content":"Returns a random-access iterator to the first element in a reversed <ph id=\"ph1\">`deque`</ph>.","source":"Returns a random-access iterator to the first element in a reversed `deque`."},{"content":"rend","pos":[7833,7837]},{"pos":[7853,7949],"content":"Returns a random-access iterator that points just beyond the last element in a reversed <ph id=\"ph1\">`deque`</ph>.","source":"Returns a random-access iterator that points just beyond the last element in a reversed `deque`."},{"content":"resize","pos":[7955,7961]},{"pos":[7979,8014],"content":"Specifies a new size for a <ph id=\"ph1\">`deque`</ph>.","source":"Specifies a new size for a `deque`."},{"content":"shrink_to_fit","pos":[8020,8033]},{"content":"Discards excess capacity.","pos":[8058,8083]},{"content":"size","pos":[8089,8093]},{"pos":[8109,8155],"content":"Returns the number of elements in the <ph id=\"ph1\">`deque`</ph>.","source":"Returns the number of elements in the `deque`."},{"content":"swap","pos":[8161,8165]},{"pos":[8181,8220],"content":"Exchanges the elements of two <ph id=\"ph1\">`deque`</ph>s.","source":"Exchanges the elements of two `deque`s."},{"content":"Operators","pos":[8231,8240]},{"content":"operator&amp;#91;&amp;#93;","pos":[8262,8280],"source":"operator&#91;&#93;"},{"pos":[8303,8370],"content":"Returns a reference to the <ph id=\"ph1\">`deque`</ph> element at a specified position.","source":"Returns a reference to the `deque` element at a specified position."},{"content":"operator=","pos":[8376,8385]},{"pos":[8408,8476],"content":"Replaces the elements of the <ph id=\"ph1\">`deque`</ph> with a copy of another <ph id=\"ph2\">`deque`</ph>.","source":"Replaces the elements of the `deque` with a copy of another `deque`."},{"content":"Requirements","pos":[8486,8498]},{"pos":[8502,8522],"content":"<bpt id=\"p1\">**</bpt>Header<ept id=\"p1\">**</ept>: <ph id=\"ph1\">\\&lt;</ph>deque&gt;","source":"**Header**: \\<deque>"},{"pos":[8570,8591],"content":"deque::allocator_type"},{"content":"A type that represents the allocator class for the deque object.","pos":[8595,8659]},{"content":"Remarks","pos":[8720,8727]},{"pos":[8731,8804],"content":"<bpt id=\"p1\">**</bpt>allocator_type<ept id=\"p1\">**</ept> is a synonym for the template parameter <bpt id=\"p2\">**</bpt>Allocator<ept id=\"p2\">**</ept>.","source":"**allocator_type** is a synonym for the template parameter **Allocator**."},{"content":"Example","pos":[8814,8821]},{"pos":[8826,8885],"content":"See the example for <bpt id=\"p1\">[</bpt>get_allocator<ept id=\"p1\">](#deque__get_allocator)</ept>.","source":"See the example for [get_allocator](#deque__get_allocator)."},{"pos":[8925,8938],"content":"deque::assign"},{"content":"Erases elements from a deque and copies a new set of elements to the target deque.","pos":[8942,9024]},{"content":"Parameters","pos":[9250,9260]},{"content":"Position of the first element in the range of elements to be copied from the argument deque.","pos":[9275,9367]},{"content":"Position of the first element beyond the range of elements to be copied from the argument deque.","pos":[9384,9480]},{"content":"The number of copies of an element being inserted into the deque.","pos":[9498,9563]},{"content":"The value of the element being inserted into the deque.","pos":[9579,9634]},{"content":"The initializer_list being inserted into the deque.","pos":[9652,9703]},{"content":"Remarks","pos":[9713,9720]},{"pos":[9724,9988],"content":"After any existing elements in the target deque are erased, <ph id=\"ph1\">`assign`</ph> either inserts a specified range of elements from the original deque or from some other deque into the target deque, or inserts copies of a new element of a specified value into the target deque.","source":"After any existing elements in the target deque are erased, `assign` either inserts a specified range of elements from the original deque or from some other deque into the target deque, or inserts copies of a new element of a specified value into the target deque."},{"content":"Example","pos":[9998,10005]},{"pos":[11041,11050],"content":"deque::at"},{"content":"Returns a reference to the element at a specified location in the deque.","pos":[11054,11126]},{"content":"Parameters","pos":[11222,11232]},{"content":"The subscript (or position number) of the element to reference in the deque.","pos":[11245,11321]},{"content":"Return Value","pos":[11331,11343]},{"pos":[11347,11422],"content":"If <ph id=\"ph1\">`pos`</ph> is greater than the size of the deque, <bpt id=\"p1\">**</bpt>at<ept id=\"p1\">**</ept> throws an exception.","source":"If `pos` is greater than the size of the deque, **at** throws an exception."},{"content":"Return Value","pos":[11432,11444]},{"content":"If the return value of <bpt id=\"p1\">**</bpt>at<ept id=\"p1\">**</ept> is assigned to a <ph id=\"ph1\">`const_reference`</ph>, the deque object cannot be modified.","pos":[11448,11550],"source":"If the return value of **at** is assigned to a `const_reference`, the deque object cannot be modified."},{"content":"If the return value of <bpt id=\"p1\">**</bpt>at<ept id=\"p1\">**</ept> is assigned to a <bpt id=\"p2\">**</bpt>reference<ept id=\"p2\">**</ept>, the deque object can be modified.","pos":[11551,11646],"source":" If the return value of **at** is assigned to a **reference**, the deque object can be modified."},{"content":"Example","pos":[11656,11663]},{"pos":[12166,12177],"content":"deque::back"},{"content":"Returns a reference to the last element of the deque.","pos":[12181,12234]},{"content":"Return Value","pos":[12307,12319]},{"content":"The last element of the deque.","pos":[12323,12353]},{"content":"If the deque is empty, the return value is undefined.","pos":[12354,12407]},{"content":"Remarks","pos":[12417,12424]},{"content":"If the return value of <bpt id=\"p1\">**</bpt>back<ept id=\"p1\">**</ept> is assigned to a <ph id=\"ph1\">`const_reference`</ph>, the deque object cannot be modified.","pos":[12428,12532],"source":"If the return value of **back** is assigned to a `const_reference`, the deque object cannot be modified."},{"content":"If the return value of <bpt id=\"p1\">**</bpt>back<ept id=\"p1\">**</ept> is assigned to a <bpt id=\"p2\">**</bpt>reference<ept id=\"p2\">**</ept>, the deque object can be modified.","pos":[12533,12630],"source":" If the return value of **back** is assigned to a **reference**, the deque object can be modified."},{"content":"When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty deque.","pos":[12637,12753]},{"content":"See <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept> for more information.","pos":[12755,12842],"source":"  See [Checked Iterators](../standard-library/checked-iterators.md) for more information."},{"content":"Example","pos":[12852,12859]},{"pos":[13415,13427],"content":"deque::begin"},{"content":"Returns an iterator addressing the first element in the deque.","pos":[13431,13493]},{"content":"Return Value","pos":[13566,13578]},{"content":"A random-access iterator addressing the first element in the deque or to the location succeeding an empty deque.","pos":[13582,13694]},{"content":"Remarks","pos":[13704,13711]},{"content":"If the return value of <bpt id=\"p1\">**</bpt>begin<ept id=\"p1\">**</ept> is assigned to a <ph id=\"ph1\">`const_iterator`</ph>, the deque object cannot be modified.","pos":[13715,13819],"source":"If the return value of **begin** is assigned to a `const_iterator`, the deque object cannot be modified."},{"content":"If the return value of <bpt id=\"p1\">**</bpt>begin<ept id=\"p1\">**</ept> is assigned to an <bpt id=\"p2\">**</bpt>iterator<ept id=\"p2\">**</ept>, the deque object can be modified.","pos":[13820,13918],"source":" If the return value of **begin** is assigned to an **iterator**, the deque object can be modified."},{"content":"Example","pos":[13928,13935]},{"pos":[14682,14695],"content":"deque::cbegin"},{"pos":[14699,14772],"content":"Returns a <ph id=\"ph1\">`const`</ph> iterator that addresses the first element in the range.","source":"Returns a `const` iterator that addresses the first element in the range."},{"content":"Return Value","pos":[14828,14840]},{"pos":[14844,15021],"content":"A <ph id=\"ph1\">`const`</ph> random-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, <ph id=\"ph2\">`cbegin() == cend()`</ph>).","source":"A `const` random-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, `cbegin() == cend()`)."},{"content":"Remarks","pos":[15031,15038]},{"pos":[15042,15122],"content":"With the return value of <ph id=\"ph1\">`cbegin`</ph>, the elements in the range cannot be modified.","source":"With the return value of `cbegin`, the elements in the range cannot be modified."},{"content":"You can use this member function in place of the <ph id=\"ph1\">`begin()`</ph> member function to guarantee that the return value is <ph id=\"ph2\">`const_iterator`</ph>.","pos":[15129,15259],"source":"You can use this member function in place of the `begin()` member function to guarantee that the return value is `const_iterator`."},{"content":"Typically, it's used in conjunction with the <bpt id=\"p1\">[</bpt>auto<ept id=\"p1\">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.","pos":[15260,15390],"source":" Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example."},{"content":"In the example, consider <ph id=\"ph1\">`Container`</ph> to be a modifiable (non- <ph id=\"ph2\">`const`</ph>) container of any kind that supports <ph id=\"ph3\">`begin()`</ph> and <ph id=\"ph4\">`cbegin()`</ph>.","pos":[15391,15523],"source":" In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `begin()` and `cbegin()`."},{"pos":[15716,15727],"content":"deque::cend"},{"pos":[15731,15826],"content":"Returns a <ph id=\"ph1\">`const`</ph> iterator that addresses the location just beyond the last element in a range.","source":"Returns a `const` iterator that addresses the location just beyond the last element in a range."},{"content":"Return Value","pos":[15880,15892]},{"content":"A random-access iterator that points just beyond the end of the range.","pos":[15896,15966]},{"content":"Remarks","pos":[15976,15983]},{"pos":[15994,16062],"content":"is used to test whether an iterator has passed the end of its range."},{"content":"You can use this member function in place of the <ph id=\"ph1\">`end()`</ph> member function to guarantee that the return value is <ph id=\"ph2\">`const_iterator`</ph>.","pos":[16069,16197],"source":"You can use this member function in place of the `end()` member function to guarantee that the return value is `const_iterator`."},{"content":"Typically, it's used in conjunction with the <bpt id=\"p1\">[</bpt>auto<ept id=\"p1\">](../cpp/auto-cpp.md)</ept> type deduction keyword, as shown in the following example.","pos":[16198,16328],"source":" Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example."},{"content":"In the example, consider <ph id=\"ph1\">`Container`</ph> to be a modifiable (non- <ph id=\"ph2\">`const`</ph>) container of any kind that supports <ph id=\"ph3\">`end()`</ph> and <ph id=\"ph4\">`cend()`</ph>.","pos":[16329,16457],"source":" In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `end()` and `cend()`."},{"pos":[16615,16671],"content":"The value returned by <ph id=\"ph1\">`cend`</ph> should not be dereferenced.","source":"The value returned by `cend` should not be dereferenced."},{"pos":[16710,16722],"content":"deque::clear"},{"content":"Erases all the elements of a deque.","pos":[16726,16761]},{"content":"Example","pos":[16800,16807]},{"pos":[17388,17409],"content":"deque::const_iterator"},{"pos":[17413,17517],"content":"A type that provides a random-access iterator that can access and read a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> element in the deque.","source":"A type that provides a random-access iterator that can access and read a **const** element in the deque."},{"content":"Remarks","pos":[17591,17598]},{"pos":[17602,17675],"content":"A type <ph id=\"ph1\">`const_iterator`</ph> cannot be used to modify the value of an element.","source":"A type `const_iterator` cannot be used to modify the value of an element."},{"content":"Example","pos":[17685,17692]},{"pos":[17697,17738],"content":"See the example for <bpt id=\"p1\">[</bpt>back<ept id=\"p1\">](#deque__back)</ept>.","source":"See the example for [back](#deque__back)."},{"pos":[17785,17805],"content":"deque::const_pointer"},{"pos":[17809,17860],"content":"Provides a pointer to a <ph id=\"ph1\">`const`</ph> element in a deque.","source":"Provides a pointer to a `const` element in a deque."},{"content":"Remarks","pos":[17942,17949]},{"content":"A type <ph id=\"ph1\">`const_pointer`</ph> cannot be used to modify the value of an element.","pos":[17953,18025],"source":"A type `const_pointer` cannot be used to modify the value of an element."},{"content":"An <bpt id=\"p1\">[</bpt>iterator<ept id=\"p1\">](#deque__iterator)</ept> is more commonly used to access a deque element.","pos":[18026,18106],"source":" An [iterator](#deque__iterator) is more commonly used to access a deque element."},{"pos":[18155,18177],"content":"deque::const_reference"},{"pos":[18181,18303],"content":"A type that provides a reference to a <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> element stored in a deque for reading and performing <bpt id=\"p2\">**</bpt>const<ept id=\"p2\">**</ept> operations.","source":"A type that provides a reference to a **const** element stored in a deque for reading and performing **const** operations."},{"content":"Remarks","pos":[18391,18398]},{"pos":[18402,18476],"content":"A type <ph id=\"ph1\">`const_reference`</ph> cannot be used to modify the value of an element.","source":"A type `const_reference` cannot be used to modify the value of an element."},{"content":"Example","pos":[18486,18493]},{"pos":[19153,19182],"content":"deque::const_reverse_iterator"},{"pos":[19186,19281],"content":"A type that provides a random-access iterator that can read any <bpt id=\"p1\">**</bpt>const<ept id=\"p1\">**</ept> element in the deque.","source":"A type that provides a random-access iterator that can read any **const** element in the deque."},{"content":"Remarks","pos":[19378,19385]},{"pos":[19389,19511],"content":"A type <ph id=\"ph1\">`const_reverse_iterator`</ph> cannot modify the value of an element and is used to iterate through the deque in reverse.","source":"A type `const_reverse_iterator` cannot modify the value of an element and is used to iterate through the deque in reverse."},{"content":"Example","pos":[19521,19528]},{"pos":[19533,19631],"content":"See the example for <bpt id=\"p1\">[</bpt>rbegin<ept id=\"p1\">](#deque__rbegin)</ept> for an example of how to declare and use an iterator.","source":"See the example for [rbegin](#deque__rbegin) for an example of how to declare and use an iterator."},{"pos":[19672,19686],"content":"deque::crbegin"},{"content":"Returns a const iterator to the first element in a reversed deque.","pos":[19690,19756]},{"content":"Return Value","pos":[19821,19833]},{"pos":[19837,20034],"content":"A const reverse random-access iterator addressing the first element in a reversed <bpt id=\"p1\">[</bpt>deque<ept id=\"p1\">](../standard-library/deque-class.md)</ept> or addressing what had been the last element in the unreversed <ph id=\"ph1\">`deque`</ph>.","source":"A const reverse random-access iterator addressing the first element in a reversed [deque](../standard-library/deque-class.md) or addressing what had been the last element in the unreversed `deque`."},{"content":"Remarks","pos":[20044,20051]},{"pos":[20055,20129],"content":"With the return value of <ph id=\"ph1\">`crbegin`</ph>, the <ph id=\"ph2\">`deque`</ph> object cannot be modified.","source":"With the return value of `crbegin`, the `deque` object cannot be modified."},{"content":"Example","pos":[20139,20146]},{"pos":[20855,20867],"content":"deque::crend"},{"content":"Returns a const iterator that addresses the location succeeding the last element in a reversed deque.","pos":[20871,20972]},{"content":"Return Value","pos":[21035,21047]},{"pos":[21051,21279],"content":"A const reverse random-access iterator that addresses the location succeeding the last element in a reversed <bpt id=\"p1\">[</bpt>deque<ept id=\"p1\">](../standard-library/deque-class.md)</ept> (the location that had preceded the first element in the unreversed deque).","source":"A const reverse random-access iterator that addresses the location succeeding the last element in a reversed [deque](../standard-library/deque-class.md) (the location that had preceded the first element in the unreversed deque)."},{"content":"Remarks","pos":[21289,21296]},{"pos":[21308,21437],"content":"is used with a reversed <ph id=\"ph1\">`deque`</ph> just as <bpt id=\"p1\">[</bpt>array::cend<ept id=\"p1\">](../standard-library/array-class-stl.md#array__cend)</ept> is used with a <ph id=\"ph2\">`deque`</ph>.","source":" is used with a reversed `deque` just as [array::cend](../standard-library/array-class-stl.md#array__cend) is used with a `deque`."},{"pos":[21444,21539],"content":"With the return value of <ph id=\"ph1\">`crend`</ph> (suitably decremented), the <ph id=\"ph2\">`deque`</ph> object cannot be modified.","source":"With the return value of `crend` (suitably decremented), the `deque` object cannot be modified."},{"pos":[21554,21637],"content":"can be used to test to whether a reverse iterator has reached the end of its deque."},{"pos":[21644,21701],"content":"The value returned by <ph id=\"ph1\">`crend`</ph> should not be dereferenced.","source":"The value returned by `crend` should not be dereferenced."},{"content":"Example","pos":[21711,21718]},{"pos":[22180,22192],"content":"deque::deque"},{"content":"Constructs a deque of a specific size, or with elements of a specific value, or with a specific allocator, or as a copy of all or part of some other deque.","pos":[22196,22351]},{"content":"Parameters","pos":[22870,22880]},{"content":"Parameter","pos":[22901,22910]},{"content":"Description","pos":[22911,22922]},{"content":"The allocator class to use with this object.","pos":[22932,22976]},{"content":"The number of elements in the constructed deque.","pos":[22989,23037]},{"content":"The value of the elements in the constructed deque.","pos":[23048,23099]},{"content":"The deque of which the constructed deque is to be a copy.","pos":[23112,23169]},{"content":"Position of the first element in the range of elements to be copied.","pos":[23182,23250]},{"content":"Position of the first element beyond the range of elements to be copied.","pos":[23262,23334]},{"content":"The initializer_list to be copied.","pos":[23347,23381]},{"content":"Remarks","pos":[23392,23399]},{"pos":[23403,23479],"content":"All constructors store an allocator object ( <ph id=\"ph1\">`Al`</ph>) and initialize the deque.","source":"All constructors store an allocator object ( `Al`) and initialize the deque."},{"pos":[23486,23614],"content":"The first two constructors specify an empty initial deque; the second one also specifies the allocator type ( <ph id=\"ph1\">`_Al`</ph>) to be used.","source":"The first two constructors specify an empty initial deque; the second one also specifies the allocator type ( `_Al`) to be used."},{"pos":[23621,23750],"content":"The third constructor specifies a repetition of a specified number ( <ph id=\"ph1\">` count`</ph>) of elements of the default value for class <ph id=\"ph2\">`Type`</ph>.","source":"The third constructor specifies a repetition of a specified number ( ` count`) of elements of the default value for class `Type`."},{"pos":[23757,23851],"content":"The fourth and fifth constructors specify a repetition of ( <ph id=\"ph1\">`Count`</ph>) elements of value <ph id=\"ph2\">` val`</ph>.","source":"The fourth and fifth constructors specify a repetition of ( `Count`) elements of value ` val`."},{"pos":[23858,23918],"content":"The sixth constructor specifies a copy of the deque <ph id=\"ph1\">`Right`</ph>.","source":"The sixth constructor specifies a copy of the deque `Right`."},{"pos":[23925,24003],"content":"The seventh and eighth constructors copy the range <ph id=\"ph1\">`[First, Last)`</ph> of a deque.","source":"The seventh and eighth constructors copy the range `[First, Last)` of a deque."},{"pos":[24010,24058],"content":"The seventh constructor moves the deque <ph id=\"ph1\">`Right`</ph>.","source":"The seventh constructor moves the deque `Right`."},{"content":"The eighth constructor copies the contents of an initializer_list.","pos":[24065,24131]},{"content":"None of the constructors perform any interim reallocations.","pos":[24138,24197]},{"content":"Example","pos":[24207,24214]},{"pos":[29438,29460],"content":"deque::difference_type"},{"content":"A type that provides the difference between two iterators that refer to elements within the same deque.","pos":[29464,29567]},{"content":"Remarks","pos":[29655,29662]},{"pos":[29666,29755],"content":"A <ph id=\"ph1\">`difference_type`</ph> can also be described as the number of elements between two pointers.","source":"A `difference_type` can also be described as the number of elements between two pointers."},{"content":"Example","pos":[29765,29772]},{"pos":[30879,30893],"content":"deque::emplace"},{"content":"Inserts an element constructed in place into the deque at a specified position.","pos":[30897,30976]},{"content":"Parameters","pos":[31065,31075]},{"content":"Parameter","pos":[31096,31105]},{"content":"Description","pos":[31106,31117]},{"pos":[31131,31231],"content":"The position in the <bpt id=\"p1\">[</bpt>deque<ept id=\"p1\">](../standard-library/deque-class.md)</ept> where the first element is inserted.","source":"The position in the [deque](../standard-library/deque-class.md) where the first element is inserted."},{"pos":[31243,31300],"content":"The value of the element being inserted into the <ph id=\"ph1\">`deque`</ph>.","source":"The value of the element being inserted into the `deque`."},{"content":"Return Value","pos":[31311,31323]},{"content":"The function returns an iterator that points to the position where the new element was inserted into the deque.","pos":[31327,31438]},{"content":"Remarks","pos":[31448,31455]},{"pos":[31459,31553],"content":"Any insertion operation can be expensive, see <ph id=\"ph1\">`deque`</ph> for a discussion of <ph id=\"ph2\">`deque`</ph> performance.","source":"Any insertion operation can be expensive, see `deque` for a discussion of `deque` performance."},{"content":"Example","pos":[31563,31570]},{"pos":[32454,32473],"content":"deque::emplace_back"},{"content":"Adds an element constructed in place to the end of the deque.","pos":[32477,32538]},{"content":"Parameters","pos":[32594,32604]},{"content":"Parameter","pos":[32625,32634]},{"content":"Description","pos":[32635,32646]},{"pos":[32658,32738],"content":"The element added to the end of the <bpt id=\"p1\">[</bpt>deque<ept id=\"p1\">](../standard-library/deque-class.md)</ept>.","source":"The element added to the end of the [deque](../standard-library/deque-class.md)."},{"content":"Example","pos":[32749,32756]},{"pos":[33540,33560],"content":"deque::emplace_front"},{"content":"Adds an element constructed in place to the end of the deque.","pos":[33564,33625]},{"content":"Parameters","pos":[33682,33692]},{"content":"Parameter","pos":[33713,33722]},{"content":"Description","pos":[33723,33734]},{"pos":[33746,33832],"content":"The element added to the beginning of the <bpt id=\"p1\">[</bpt>deque<ept id=\"p1\">](../standard-library/deque-class.md)</ept>.","source":"The element added to the beginning of the [deque](../standard-library/deque-class.md)."},{"content":"Example","pos":[33843,33850]},{"pos":[34628,34640],"content":"deque::empty"},{"content":"Tests if a deque is empty.","pos":[34644,34670]},{"content":"Return Value","pos":[34715,34727]},{"pos":[34731,34799],"content":"<bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> if the deque is empty; <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept> if the deque is not empty.","source":"**true** if the deque is empty; **false** if the deque is not empty."},{"content":"Example","pos":[34809,34816]},{"pos":[35237,35247],"content":"deque::end"},{"content":"Returns an iterator that addresses the location succeeding the last element in a deque.","pos":[35251,35338]},{"content":"Return Value","pos":[35408,35420]},{"content":"A random-access iterator that addresses the location succeeding the last element in a deque.","pos":[35424,35516]},{"content":"If the deque is empty, then deque::end == deque::begin.","pos":[35517,35572]},{"content":"Remarks","pos":[35582,35589]},{"pos":[35593,35670],"content":"<bpt id=\"p1\">**</bpt>end<ept id=\"p1\">**</ept> is used to test whether an iterator has reached the end of its deque.","source":"**end** is used to test whether an iterator has reached the end of its deque."},{"content":"Example","pos":[35680,35687]},{"pos":[36677,36689],"content":"deque::erase"},{"content":"Removes an element or a range of elements in a deque from specified positions.","pos":[36693,36771]},{"content":"Parameters","pos":[36877,36887]},{"content":"Position of the element to be removed from the deque.","pos":[36903,36956]},{"content":"Position of the first element removed from the deque.","pos":[36975,37028]},{"content":"Position just beyond the last element removed from the deque.","pos":[37046,37107]},{"content":"Return Value","pos":[37117,37129]},{"content":"A random-access iterator that designates the first element remaining beyond any elements removed, or a pointer to the end of the deque if no such element exists.","pos":[37133,37294]},{"content":"Remarks","pos":[37304,37311]},{"pos":[37315,37351],"content":"<bpt id=\"p1\">**</bpt>erase<ept id=\"p1\">**</ept> never throws an exception.","source":"**erase** never throws an exception."},{"content":"Example","pos":[37361,37368]},{"pos":[38546,38558],"content":"deque::front"},{"content":"Returns a reference to the first element in a deque.","pos":[38562,38614]},{"content":"Return Value","pos":[38690,38702]},{"content":"If the deque is empty, the return is undefined.","pos":[38706,38753]},{"content":"Remarks","pos":[38763,38770]},{"content":"If the return value of <ph id=\"ph1\">`front`</ph> is assigned to a <ph id=\"ph2\">`const_reference`</ph>, the deque object cannot be modified.","pos":[38774,38877],"source":"If the return value of `front` is assigned to a `const_reference`, the deque object cannot be modified."},{"content":"If the return value of <ph id=\"ph1\">`front`</ph> is assigned to a <bpt id=\"p1\">**</bpt>reference<ept id=\"p1\">**</ept>, the deque object can be modified.","pos":[38878,38974],"source":" If the return value of `front` is assigned to a **reference**, the deque object can be modified."},{"content":"When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty deque.","pos":[38981,39097]},{"content":"See <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept> for more information.","pos":[39099,39186],"source":"  See [Checked Iterators](../standard-library/checked-iterators.md) for more information."},{"content":"Example","pos":[39196,39203]},{"pos":[39759,39779],"content":"deque::get_allocator"},{"content":"Returns a copy of the allocator object used to construct the deque.","pos":[39783,39850]},{"content":"Return Value","pos":[39908,39920]},{"content":"The allocator used by the deque.","pos":[39924,39956]},{"content":"Remarks","pos":[39966,39973]},{"content":"Allocators for the deque class specify how the class manages storage.","pos":[39977,40046]},{"content":"The default allocators supplied with STL container classes are sufficient for most programming needs.","pos":[40047,40148]},{"content":"Writing and using your own allocator class is an advanced C++ topic.","pos":[40149,40217]},{"content":"Example","pos":[40227,40234]},{"pos":[40856,40869],"content":"deque::insert"},{"content":"Inserts an element or a number of elements or a range of elements into the deque at a specified position.","pos":[40873,40978]},{"content":"Parameters","pos":[41405,41415]},{"content":"Parameter","pos":[41436,41445]},{"content":"Description","pos":[41446,41457]},{"content":"The position in the target deque where the first element is inserted.","pos":[41470,41539]},{"content":"The value of the element being inserted into the deque.","pos":[41550,41605]},{"content":"The number of elements being inserted into the deque.","pos":[41618,41671]},{"content":"The position of the first element in the range of elements in the argument deque to be copied.","pos":[41684,41778]},{"content":"The position of the first element beyond the range of elements in the argument deque to be copied.","pos":[41790,41888]},{"content":"The initializer_list of elements to insert.","pos":[41901,41944]},{"content":"Return Value","pos":[41955,41967]},{"content":"The first two insert functions return an iterator that points to the position where the new element was inserted into the deque.","pos":[41971,42099]},{"content":"Remarks","pos":[42109,42116]},{"content":"Any insertion operation can be expensive.","pos":[42120,42161]},{"pos":[42203,42218],"content":"deque::iterator"},{"content":"A type that provides a random-access iterator that can read or modify any element in a deque.","pos":[42222,42315]},{"content":"Remarks","pos":[42383,42390]},{"pos":[42394,42460],"content":"A type <bpt id=\"p1\">**</bpt>iterator<ept id=\"p1\">**</ept> can be used to modify the value of an element.","source":"A type **iterator** can be used to modify the value of an element."},{"content":"Example","pos":[42470,42477]},{"pos":[42482,42525],"content":"See the example for <bpt id=\"p1\">[</bpt>begin<ept id=\"p1\">](#deque__begin)</ept>.","source":"See the example for [begin](#deque__begin)."},{"pos":[42567,42582],"content":"deque::max_size"},{"content":"Returns the maximum length of the deque.","pos":[42586,42626]},{"content":"Return Value","pos":[42679,42691]},{"content":"The maximum possible length of the deque.","pos":[42695,42736]},{"content":"Example","pos":[42746,42753]},{"pos":[43118,43135],"content":"deque::operator[]"},{"content":"Returns a reference to the deque element at a specified position.","pos":[43139,43204]},{"content":"Parameters","pos":[43316,43326]},{"content":"The position of the deque element to be referenced.","pos":[43339,43390]},{"content":"Return Value","pos":[43400,43412]},{"content":"A reference to the element whose position is specified in the argument.","pos":[43416,43487]},{"content":"If the position specified is greater than the size of the deque, the result is undefined.","pos":[43488,43577]},{"content":"Remarks","pos":[43587,43594]},{"content":"If the return value of <ph id=\"ph1\">`operator[]`</ph> is assigned to a <ph id=\"ph2\">`const_reference`</ph>, the deque object cannot be modified.","pos":[43598,43706],"source":"If the return value of `operator[]` is assigned to a `const_reference`, the deque object cannot be modified."},{"content":"If the return value of <ph id=\"ph1\">`operator[]`</ph> is assigned to a <bpt id=\"p1\">**</bpt>reference<ept id=\"p1\">**</ept>, the deque object can be modified.","pos":[43707,43808],"source":" If the return value of `operator[]` is assigned to a **reference**, the deque object can be modified."},{"content":"When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element outside the bounds of the deque.","pos":[43815,43945]},{"content":"See <bpt id=\"p1\">[</bpt>Checked Iterators<ept id=\"p1\">](../standard-library/checked-iterators.md)</ept> for more information.","pos":[43947,44034],"source":"  See [Checked Iterators](../standard-library/checked-iterators.md) for more information."},{"content":"Example","pos":[44044,44051]},{"pos":[44556,44572],"content":"deque::operator="},{"content":"Replaces the elements of this deque using the elements from another deque.","pos":[44576,44650]},{"content":"Parameters","pos":[44747,44757]},{"content":"Parameter","pos":[44778,44787]},{"content":"Description","pos":[44788,44799]},{"content":"The deque that provides the new content.","pos":[44813,44853]},{"content":"Remarks","pos":[44864,44871]},{"content":"The first override copies elements to this deque from <ph id=\"ph1\">` right`</ph>, the source of the assignment.","pos":[44875,44968],"source":"The first override copies elements to this deque from ` right`, the source of the assignment."},{"content":"The second override moves elements to this deque from <ph id=\"ph1\">` right`</ph>.","pos":[44969,45032],"source":" The second override moves elements to this deque from ` right`."},{"content":"Elements that are contained in this deque before the operator executes are removed.","pos":[45039,45122]},{"content":"Example","pos":[45132,45139]},{"pos":[46276,46290],"content":"deque::pointer"},{"pos":[46294,46376],"content":"Provides a pointer to an element in a <bpt id=\"p1\">[</bpt>deque<ept id=\"p1\">](../standard-library/deque-class.md)</ept>.","source":"Provides a pointer to an element in a [deque](../standard-library/deque-class.md)."},{"content":"Remarks","pos":[46455,46462]},{"content":"A type <bpt id=\"p1\">**</bpt>pointer<ept id=\"p1\">**</ept> can be used to modify the value of an element.","pos":[46466,46531],"source":"A type **pointer** can be used to modify the value of an element."},{"content":"An <bpt id=\"p1\">[</bpt>iterator<ept id=\"p1\">](#deque__iterator)</ept> is more commonly used to access a deque element.","pos":[46532,46612],"source":" An [iterator](#deque__iterator) is more commonly used to access a deque element."},{"pos":[46654,46669],"content":"deque::pop_back"},{"content":"Deletes the element at the end of the deque.","pos":[46673,46717]},{"content":"Remarks","pos":[46759,46766]},{"content":"The last element must not be empty.","pos":[46770,46805]},{"content":"never throws an exception.","pos":[46817,46843]},{"content":"Example","pos":[46853,46860]},{"pos":[47552,47568],"content":"deque::pop_front"},{"content":"Deletes the element at the beginning of the deque.","pos":[47572,47622]},{"content":"Remarks","pos":[47665,47672]},{"content":"The first element must not be empty.","pos":[47676,47712]},{"content":"never throws an exception.","pos":[47725,47751]},{"content":"Example","pos":[47761,47768]},{"pos":[48481,48497],"content":"deque::push_back"},{"content":"Adds an element to the end of the deque.","pos":[48501,48541]},{"content":"Parameters","pos":[48628,48638]},{"content":"Parameter","pos":[48659,48668]},{"content":"Description","pos":[48669,48680]},{"content":"The element added to the end of the deque.","pos":[48692,48734]},{"content":"Remarks","pos":[48745,48752]},{"content":"If an exception is thrown, the deque is left unaltered and the exception is rethrown.","pos":[48756,48841]},{"pos":[48885,48902],"content":"deque::push_front"},{"content":"Adds an element to the beginning of the deque.","pos":[48906,48952]},{"content":"Parameters","pos":[49045,49055]},{"content":"Parameter","pos":[49076,49085]},{"content":"Description","pos":[49086,49097]},{"content":"The element added to the beginning of the deque.","pos":[49109,49157]},{"content":"Remarks","pos":[49168,49175]},{"content":"If an exception is thrown, the deque is left unaltered and the exception is rethrown.","pos":[49179,49264]},{"content":"Example","pos":[49274,49281]},{"pos":[50031,50044],"content":"deque::rbegin"},{"content":"Returns an iterator to the first element in a reversed deque.","pos":[50048,50109]},{"content":"Return Value","pos":[50201,50213]},{"content":"A reverse random-access iterator addressing the first element in a reversed deque or addressing what had been the last element in the unreversed deque.","pos":[50217,50368]},{"content":"Remarks","pos":[50378,50385]},{"pos":[50398,50480],"content":"is used with a reversed deque just as <bpt id=\"p1\">[</bpt>begin<ept id=\"p1\">](#deque__begin)</ept> is used with a deque.","source":" is used with a reversed deque just as [begin](#deque__begin) is used with a deque."},{"content":"If the return value of <ph id=\"ph1\">`rbegin`</ph> is assigned to a <ph id=\"ph2\">`const_reverse_iterator`</ph>, the deque object cannot be modified.","pos":[50487,50598],"source":"If the return value of `rbegin` is assigned to a `const_reverse_iterator`, the deque object cannot be modified."},{"content":"If the return value of <ph id=\"ph1\">`rbegin`</ph> is assigned to a <ph id=\"ph2\">`reverse_iterator`</ph>, the deque object can be modified.","pos":[50599,50701],"source":" If the return value of `rbegin` is assigned to a `reverse_iterator`, the deque object can be modified."},{"pos":[50717,50766],"content":"can be used to iterate through a deque backwards."},{"content":"Example","pos":[50776,50783]},{"pos":[52431,52447],"content":"deque::reference"},{"content":"A type that provides a reference to an element stored in a deque.","pos":[52451,52516]},{"content":"Example","pos":[52592,52599]},{"pos":[53110,53121],"content":"deque::rend"},{"content":"Returns an iterator that addresses the location succeeding the last element in a reversed deque.","pos":[53125,53221]},{"content":"Return Value","pos":[53309,53321]},{"content":"A reverse random-access iterator that addresses the location succeeding the last element in a reversed deque (the location that had preceded the first element in the unreversed deque).","pos":[53325,53509]},{"content":"Remarks","pos":[53519,53526]},{"pos":[53537,53615],"content":"is used with a reversed deque just as <bpt id=\"p1\">[</bpt>end<ept id=\"p1\">](#deque__end)</ept> is used with a deque.","source":" is used with a reversed deque just as [end](#deque__end) is used with a deque."},{"content":"If the return value of <ph id=\"ph1\">`rend`</ph> is assigned to a <ph id=\"ph2\">`const_reverse_iterator`</ph>, the deque object cannot be modified.","pos":[53622,53731],"source":"If the return value of `rend` is assigned to a `const_reverse_iterator`, the deque object cannot be modified."},{"content":"If the return value of <ph id=\"ph1\">`rend`</ph> is assigned to a <ph id=\"ph2\">`reverse_iterator`</ph>, the deque object can be modified.","pos":[53732,53832],"source":" If the return value of `rend` is assigned to a `reverse_iterator`, the deque object can be modified."},{"pos":[53846,53926],"content":"can be used to test whether a reverse iterator has reached the end of its deque."},{"pos":[53933,53989],"content":"The value returned by <ph id=\"ph1\">`rend`</ph> should not be dereferenced.","source":"The value returned by `rend` should not be dereferenced."},{"content":"Example","pos":[53999,54006]},{"pos":[56028,56041],"content":"deque::resize"},{"content":"Specifies a new size for a deque.","pos":[56045,56078]},{"content":"Parameters","pos":[56180,56190]},{"content":"The new size of the deque.","pos":[56208,56234]},{"content":"The value of the new elements to be added to the deque if the new size is larger that the original size.","pos":[56251,56355]},{"content":"If the value is omitted, the new elements are assigned the default value for the class.","pos":[56356,56443]},{"content":"Remarks","pos":[56453,56460]},{"pos":[56464,56597],"content":"If the deque's size is less than the requested size, <ph id=\"ph1\">`_Newsize`</ph>, elements are added to the deque until it reaches the requested size.","source":"If the deque's size is less than the requested size, `_Newsize`, elements are added to the deque until it reaches the requested size."},{"pos":[56604,56760],"content":"If the deque's size is larger than the requested size, the elements closest to the end of the deque are deleted until the deque reaches the size <ph id=\"ph1\">`_Newsize`</ph>.","source":"If the deque's size is larger than the requested size, the elements closest to the end of the deque are deleted until the deque reaches the size `_Newsize`."},{"content":"If the present size of the deque is the same as the requested size, no action is taken.","pos":[56767,56854]},{"pos":[56861,56921],"content":"<bpt id=\"p1\">[</bpt>size<ept id=\"p1\">](#deque__size)</ept> reflects the current size of the deque.","source":"[size](#deque__size) reflects the current size of the deque."},{"content":"Example","pos":[56931,56938]},{"pos":[57953,57976],"content":"deque::reverse_iterator"},{"content":"A type that provides a random-access iterator that can read or modify an element in a reversed deque.","pos":[57980,58081]},{"content":"Remarks","pos":[58166,58173]},{"pos":[58177,58239],"content":"A type <ph id=\"ph1\">`reverse_iterator`</ph> is use to iterate through the deque.","source":"A type `reverse_iterator` is use to iterate through the deque."},{"content":"Example","pos":[58249,58256]},{"content":"See the example for rbegin.","pos":[58261,58288]},{"pos":[58335,58355],"content":"deque::shrink_to_fit"},{"content":"Discards excess capacity.","pos":[58359,58384]},{"content":"Remarks","pos":[58431,58438]},{"pos":[58442,58573],"content":"There is no portable way to determine if <ph id=\"ph1\">`shrink_to_fit`</ph> reduces the storage used by a <bpt id=\"p1\">[</bpt>deque<ept id=\"p1\">](../standard-library/deque-class.md)</ept>.","source":"There is no portable way to determine if `shrink_to_fit` reduces the storage used by a [deque](../standard-library/deque-class.md)."},{"content":"Example","pos":[58583,58590]},{"pos":[59135,59146],"content":"deque::size"},{"content":"Returns the number of elements in the deque.","pos":[59150,59194]},{"content":"Return Value","pos":[59243,59255]},{"content":"The current length of the deque.","pos":[59259,59291]},{"content":"Example","pos":[59301,59308]},{"pos":[59847,59863],"content":"deque::size_type"},{"content":"A type that counts the number of elements in a deque.","pos":[59867,59920]},{"content":"Example","pos":[59996,60003]},{"pos":[60008,60049],"content":"See the example for <bpt id=\"p1\">[</bpt>size<ept id=\"p1\">](#deque__size)</ept>.","source":"See the example for [size](#deque__size)."},{"pos":[60087,60098],"content":"deque::swap"},{"content":"Exchanges the elements of two deques.","pos":[60102,60139]},{"content":"Parameters","pos":[60398,60408]},{"content":"The deque providing the elements to be swapped, or the deque whose elements are to be exchanged with those of the deque <ph id=\"ph1\">` left`</ph>.","pos":[60424,60552],"source":" The deque providing the elements to be swapped, or the deque whose elements are to be exchanged with those of the deque ` left`."},{"content":"A deque whose elements are to be exchanged with those of the deque <ph id=\"ph1\">` right`</ph>.","pos":[60570,60646],"source":" A deque whose elements are to be exchanged with those of the deque ` right`."},{"content":"Example","pos":[60656,60663]},{"pos":[62026,62043],"content":"deque::value_type"},{"content":"A type that represents the data type stored in a deque.","pos":[62047,62102]},{"content":"Remarks","pos":[62180,62187]},{"pos":[62204,62253],"content":"is a synonym for the template parameter <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept>.","source":" is a synonym for the template parameter **Type**."},{"content":"Example","pos":[62263,62270]},{"content":"See Also","pos":[62543,62551]},{"content":"Thread Safety in the C++ Standard Library","pos":[62556,62597]},{"content":"C++ Standard Library Reference","pos":[62670,62700]}],"content":"---\ntitle: \"deque Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"11/04/2016\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-cpp\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nf1_keywords: \n  - \"std.deque\"\n  - \"deque\"\n  - \"std::deque\"\n  - \"deque/std::deque\"\ndev_langs: \n  - \"C++\"\nhelpviewer_keywords: \n  - \"deque class, about deque class\"\n  - \"deque class\"\nms.assetid: 64842ee5-057a-4063-8c16-4267a0332584\ncaps.latest.revision: 22\nauthor: \"corob-msft\"\nms.author: \"corob\"\nmanager: \"ghogen\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# deque Class\nArranges elements of a given type in a linear arrangement and, like a vector, enables fast random access to any element, and efficient insertion and deletion at the back of the container. However, unlike a vector, the `deque` class also supports efficient insertion and deletion at the front of the container.  \n  \n## Syntax  \n  \n```unstlib  \ntemplate <class Type, class Allocator =allocator<Type>>  \nclass deque  \n```  \n  \n#### Parameters  \n `Type`  \n The element data type to be stored in the deque.  \n  \n `Allocator`  \n The type that represents the stored allocator object that encapsulates details about the deque's allocation and deallocation of memory. This argument is optional, and the default value is **allocator\\<Type>***.*  \n  \n## Remarks  \n The choice of container type should be based in general on the type of searching and inserting required by the application. [Vectors](../standard-library/vector-class.md) should be the preferred container for managing a sequence when random access to any element is at a premium and insertions or deletions of elements are only required at the end of a sequence. The performance of the list container is superior when efficient insertions and deletions (in constant time) at any location within the sequence is at a premium. Such operations in the middle of the sequence require element copies and assignments proportional to the number of elements in the sequence (linear time).  \n  \n Deque reallocation occurs when a member function must insert or erase elements of the sequence:  \n  \n-   If an element is inserted into an empty sequence, or if an element is erased to leave an empty sequence, then iterators earlier returned by [begin](#deque__begin) and [end](#deque__end) become invalid.  \n  \n-   If an element is inserted at the first position of the deque, then all iterators, but no references, that designate existing elements become invalid.  \n  \n-   If an element is inserted at the end of the deque, then [end](#deque__end) and all iterators, but no references, that designate existing elements become invalid.  \n  \n-   If an element is erased at the front of the deque, only that iterator and references to the erased element become invalid.  \n  \n-   If the last element is erased from the end of the deque, only that iterator to the final element and references to the erased element become invalid.  \n  \n Otherwise, inserting or erasing an element invalidates all iterators and references.  \n  \n### Constructors  \n  \n|||  \n|-|-|  \n|[deque](#deque__deque)|Constructs a `deque.` Several constructors are provided to set up the contents of the new `deque` in different ways: empty; loaded with a specified number of empty elements; contents moved or copied from another `deque`; contents copied or moved by using an iterator; and one element copied into the `deque`` count` times. Some of the constructors enable using a custom `allocator` to create elements.|  \n  \n### Typedefs  \n  \n|||  \n|-|-|  \n|[allocator_type](#deque__allocator_type)|A type that represents the `allocator` class for the `deque` object.|  \n|[const_iterator](#deque__const_iterator)|A type that provides a random-access iterator that can access and read elements in the `deque` as `const`|  \n|[const_pointer](#deque__const_pointer)|A type that provides a pointer to an element in a `deque` as a `const.`|  \n|[const_reference](#deque__const_reference)|A type that provides a reference to an element in a `deque` for reading and other operations as a `const.`|  \n|[const_reverse_iterator](#deque__const_reverse_iterator)|A type that provides a random-access iterator that can access and read elements in the `deque` as `const`. The deque is viewed in reverse. For more information, see [reverse_iterator Class](../standard-library/reverse-iterator-class.md)|  \n|[difference_type](#deque__difference_type)|A type that provides the difference between two random-access iterators that refer to elements in the same `deque`.|  \n|[iterator](#deque__iterator)|A type that provides a random-access iterator that can read or modify any element in a `deque`.|  \n|[pointer](#deque__pointer)|A type that provides a pointer to an element in a `deque`.|  \n|[reference](#deque__reference)|A type that provides a reference to an element stored in a `deque`.|  \n|[reverse_iterator](#deque__reverse_iterator)|A type that provides a random-access iterator that can read or modify an element in a `deque`. The deque is viewed in reverse order.|  \n|[size_type](#deque__size_type)|A type that counts the number of elements in a `deque`.|  \n|[value_type](#deque__value_type)|A type that represents the data type stored in a `deque`.|  \n  \n### Member Functions  \n  \n|||  \n|-|-|  \n|[assign](#deque__assign)|Erases elements from a `deque` and copies a new sequence of elements to the target `deque`.|  \n|[at](#deque__at)|Returns a reference to the element at a specified location in the `deque`.|  \n|[back](#deque__back)|Returns a reference to the last element of the `deque`.|  \n|[begin](#deque__begin)|Returns a random-access  iterator addressing the first element in the `deque`.|  \n|[cbegin](#deque__cbegin)|Returns a const iterator to the first element in the `deque`.|  \n|[cend](#deque__cend)|Returns a random-access `const` iterator that points just beyond the end of the `deque`.|  \n|[clear](#deque__clear)|Erases all the elements of a `deque`.|  \n|[crbegin](#deque__crbegin)|Returns a random-access const iterator to the first element in a `deque` viewed in reverse order.|  \n|[crend](#deque__crend)|Returns a random-access const iterator to the first element in a `deque` viewed in reverse order.|  \n|[emplace](#deque__emplace)|Inserts an element constructed in place into the `deque` at a specified position.|  \n|[emplace_back](#deque__emplace_back)|Adds an element constructed in place to the end of the `deque`.|  \n|[emplace_front](#deque__emplace_front)|Adds an element constructed in place to the start of the `deque`.|  \n|[empty](#deque__empty)|Returns `true` if the `deque` contains zero elements, and `false` if it contains one or more elements.|  \n|[end](#deque__end)|Returns a random-access iterator that points just beyond the end of the `deque`.|  \n|[erase](#deque__erase)|Removes an element or a range of elements in a `deque` from specified positions.|  \n|[front](#deque__front)|Returns a reference to the first element in a `deque`.|  \n|[get_allocator](#deque__get_allocator)|Returns a copy of the `allocator` object that is used to construct the `deque`.|  \n|[insert](#deque__insert)|Inserts an element, several elements, or a range of elements into the `deque` at a specified position.|  \n|[max_size](#deque__max_size)|Returns the maximum possible length of the `deque`.|  \n|[pop_back](#deque__pop_back)|Erases the element at the end of the `deque`.|  \n|[pop_front](#deque__pop_front)|Erases the element at the start of the `deque`.|  \n|[push_back](#deque__push_back)|Adds an element to the end of the `deque`.|  \n|[push_front](#deque__push_front)|Adds an element to the start of the `deque`.|  \n|[rbegin](#deque__rbegin)|Returns a random-access iterator to the first element in a reversed `deque`.|  \n|[rend](#deque__rend)|Returns a random-access iterator that points just beyond the last element in a reversed `deque`.|  \n|[resize](#deque__resize)|Specifies a new size for a `deque`.|  \n|[shrink_to_fit](#deque__shrink_to_fit)|Discards excess capacity.|  \n|[size](#deque__size)|Returns the number of elements in the `deque`.|  \n|[swap](#deque__swap)|Exchanges the elements of two `deque`s.|  \n  \n### Operators  \n  \n|||  \n|-|-|  \n|[operator&#91;&#93;](#deque__operator_at)|Returns a reference to the `deque` element at a specified position.|  \n|[operator=](#deque__operator_eq)|Replaces the elements of the `deque` with a copy of another `deque`.|  \n  \n## Requirements  \n **Header**: \\<deque>  \n  \n##  <a name=\"deque__allocator_type\"></a>  deque::allocator_type  \n A type that represents the allocator class for the deque object.  \n  \n```  \ntypedef Allocator allocator_type;  \n```  \n  \n### Remarks  \n **allocator_type** is a synonym for the template parameter **Allocator**.  \n  \n### Example  \n  See the example for [get_allocator](#deque__get_allocator).  \n  \n##  <a name=\"deque__assign\"></a>  deque::assign  \n Erases elements from a deque and copies a new set of elements to the target deque.  \n  \n```  \ntemplate <class InputIterator>  \nvoid assign(\n    InputIterator First,  \n    InputIterator Last);\n\nvoid assign(\n    size_type Count,  \n    const Type& Val);\n\nvoid assign(initializer_list<Type> IList);\n```  \n  \n### Parameters  \n `First`  \n Position of the first element in the range of elements to be copied from the argument deque.  \n  \n `Last`  \n Position of the first element beyond the range of elements to be copied from the argument deque.  \n  \n `Count`  \n The number of copies of an element being inserted into the deque.  \n  \n `Val`  \n The value of the element being inserted into the deque.  \n  \n `IList`  \n The initializer_list being inserted into the deque.  \n  \n### Remarks  \n After any existing elements in the target deque are erased, `assign` either inserts a specified range of elements from the original deque or from some other deque into the target deque, or inserts copies of a new element of a specified value into the target deque.  \n  \n### Example  \n  \n```cpp \n// deque_assign.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n#include <initializer_list>  \n  \nint main()  \n{  \n    using namespace std;  \n    deque <int> c1, c2;  \n    deque <int>::const_iterator cIter;  \n  \n    c1.push_back(10);  \n    c1.push_back(20);  \n    c1.push_back(30);  \n    c2.push_back(40);  \n    c2.push_back(50);  \n    c2.push_back(60);  \n  \n    deque<int> d1{ 1, 2, 3, 4 };  \n    initializer_list<int> iList{ 5, 6, 7, 8 };  \n    d1.assign(iList);  \n  \n    cout << \"d1 = \";  \n    for (int i : d1)  \n        cout << i;  \n    cout << endl;  \n  \n    cout << \"c1 =\";  \n    for (int i : c1)  \n        cout << i;  \n    cout << endl;  \n  \n    c1.assign(++c2.begin(), c2.end());  \n    cout << \"c1 =\";  \n    for (int i : c1)  \n        cout << i;  \n    cout << endl;  \n  \n    c1.assign(7, 4);  \n    cout << \"c1 =\";  \n    for (int i : c1)  \n        cout << i;  \n    cout << endl;  \n  \n}  \n  \n```  \n  \n```Output  \nd1 = 5678c1 =102030c1 =5060c1 =4444444  \n```  \n  \n##  <a name=\"deque__at\"></a>  deque::at  \n Returns a reference to the element at a specified location in the deque.  \n  \n```  \nreference at(size_type pos);\n\nconst_reference at(size_type pos) const;\n```  \n  \n### Parameters  \n `pos`  \n The subscript (or position number) of the element to reference in the deque.  \n  \n### Return Value  \n If `pos` is greater than the size of the deque, **at** throws an exception.  \n  \n### Return Value  \n If the return value of **at** is assigned to a `const_reference`, the deque object cannot be modified. If the return value of **at** is assigned to a **reference**, the deque object can be modified.  \n  \n### Example  \n  \n```cpp \n// deque_at.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n  \n   const int& i = c1.at( 0 );  \n   int& j = c1.at( 1 );  \n   cout << \"The first element is \" << i << endl;  \n   cout << \"The second element is \" << j << endl;  \n}  \n```  \n  \n```Output  \nThe first element is 10  \nThe second element is 20  \n```  \n  \n##  <a name=\"deque__back\"></a>  deque::back  \n Returns a reference to the last element of the deque.  \n  \n```  \nreference back();\nconst_reference back() const;\n```  \n  \n### Return Value  \n The last element of the deque. If the deque is empty, the return value is undefined.  \n  \n### Remarks  \n If the return value of **back** is assigned to a `const_reference`, the deque object cannot be modified. If the return value of **back** is assigned to a **reference**, the deque object can be modified.  \n  \n When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty deque.  See [Checked Iterators](../standard-library/checked-iterators.md) for more information.  \n  \n### Example  \n  \n```cpp \n// deque_back.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 11 );  \n  \n   int& i = c1.back( );  \n   const int& ii = c1.front( );  \n  \n   cout << \"The last integer of c1 is \" << i << endl;  \n   i--;  \n   cout << \"The next-to-last integer of c1 is \" << ii << endl;  \n}  \n```  \n  \n```Output  \nThe last integer of c1 is 11  \nThe next-to-last integer of c1 is 10  \n```  \n  \n##  <a name=\"deque__begin\"></a>  deque::begin  \n Returns an iterator addressing the first element in the deque.  \n  \n```  \nconst_iterator begin() const;\niterator begin();\n```  \n  \n### Return Value  \n A random-access iterator addressing the first element in the deque or to the location succeeding an empty deque.  \n  \n### Remarks  \n If the return value of **begin** is assigned to a `const_iterator`, the deque object cannot be modified. If the return value of **begin** is assigned to an **iterator**, the deque object can be modified.  \n  \n### Example  \n  \n```cpp  \n// deque_begin.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n   deque <int>::iterator c1_Iter;  \n   deque <int>::const_iterator c1_cIter;  \n  \n   c1.push_back( 1 );  \n   c1.push_back( 2 );  \n  \n   c1_Iter = c1.begin( );  \n   cout << \"The first element of c1 is \" << *c1_Iter << endl;  \n  \n *c1_Iter = 20;  \n   c1_Iter = c1.begin( );  \n   cout << \"The first element of c1 is now \" << *c1_Iter << endl;  \n  \n   // The following line would be an error because iterator is const  \n   // *c1_cIter = 200;  \n}  \n```  \n  \n```Output  \nThe first element of c1 is 1  \nThe first element of c1 is now 20  \n```  \n  \n##  <a name=\"deque__cbegin\"></a>  deque::cbegin  \n Returns a `const` iterator that addresses the first element in the range.  \n  \n```  \nconst_iterator cbegin() const;\n```  \n  \n### Return Value  \n A `const` random-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, `cbegin() == cend()`).  \n  \n### Remarks  \n With the return value of `cbegin`, the elements in the range cannot be modified.  \n  \n You can use this member function in place of the `begin()` member function to guarantee that the return value is `const_iterator`. Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example. In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `begin()` and `cbegin()`.  \n  \n```cpp  \n \nauto i1 = Container.begin();\n// i1 is Container<T>::iterator   \nauto i2 = Container.cbegin();\n\n// i2 is Container<T>::const_iterator  \n```  \n  \n##  <a name=\"deque__cend\"></a>  deque::cend  \n Returns a `const` iterator that addresses the location just beyond the last element in a range.  \n  \n```  \nconst_iterator cend() const;\n```  \n  \n### Return Value  \n A random-access iterator that points just beyond the end of the range.  \n  \n### Remarks  \n `cend` is used to test whether an iterator has passed the end of its range.  \n  \n You can use this member function in place of the `end()` member function to guarantee that the return value is `const_iterator`. Typically, it's used in conjunction with the [auto](../cpp/auto-cpp.md) type deduction keyword, as shown in the following example. In the example, consider `Container` to be a modifiable (non- `const`) container of any kind that supports `end()` and `cend()`.  \n  \n```cpp  \n \nauto i1 = Container.end();\n// i1 is Container<T>::iterator   \nauto i2 = Container.cend();\n\n// i2 is Container<T>::const_iterator  \n```  \n  \n The value returned by `cend` should not be dereferenced.  \n  \n##  <a name=\"deque__clear\"></a>  deque::clear  \n Erases all the elements of a deque.  \n  \n```  \nvoid clear();\n```  \n  \n### Example  \n  \n```cpp \n// deque_clear.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n  \n   cout << \"The size of the deque is initially \" << c1.size( ) << endl;  \n   c1.clear( );  \n   cout << \"The size of the deque after clearing is \" << c1.size( ) << endl;  \n}  \n```  \n  \n```Output  \nThe size of the deque is initially 3  \nThe size of the deque after clearing is 0  \n```  \n  \n##  <a name=\"deque__const_iterator\"></a>  deque::const_iterator  \n A type that provides a random-access iterator that can access and read a **const** element in the deque.  \n  \n```  \ntypedef implementation-defined const_iterator;  \n```  \n  \n### Remarks  \n A type `const_iterator` cannot be used to modify the value of an element.  \n  \n### Example  \n  See the example for [back](#deque__back).  \n  \n##  <a name=\"deque__const_pointer\"></a>  deque::const_pointer  \n Provides a pointer to a `const` element in a deque.  \n  \n```\ntypedef typename Allocator::const_pointer const_pointer;  \n```  \n  \n### Remarks  \n A type `const_pointer` cannot be used to modify the value of an element. An [iterator](#deque__iterator) is more commonly used to access a deque element.  \n  \n##  <a name=\"deque__const_reference\"></a>  deque::const_reference  \n A type that provides a reference to a **const** element stored in a deque for reading and performing **const** operations.  \n  \n```  \ntypedef typename Allocator::const_reference const_reference;  \n```  \n  \n### Remarks  \n A type `const_reference` cannot be used to modify the value of an element.  \n  \n### Example  \n  \n```cpp\n// deque_const_ref.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n  \n   const deque <int> c2 = c1;  \n   const int &i = c2.front( );  \n   const int &j = c2.back( );  \n   cout << \"The first element is \" << i << endl;  \n   cout << \"The second element is \" << j << endl;  \n  \n   // The following line would cause an error as c2 is const  \n   // c2.push_back( 30 );  \n}  \n```  \n  \n```Output  \nThe first element is 10  \nThe second element is 20  \n```  \n  \n##  <a name=\"deque__const_reverse_iterator\"></a>  deque::const_reverse_iterator  \n A type that provides a random-access iterator that can read any **const** element in the deque.  \n  \n```  \ntypedef std::reverse_iterator<const_iterator> const_reverse_iterator;  \n```  \n  \n### Remarks  \n A type `const_reverse_iterator` cannot modify the value of an element and is used to iterate through the deque in reverse.  \n  \n### Example  \n  See the example for [rbegin](#deque__rbegin) for an example of how to declare and use an iterator.  \n  \n##  <a name=\"deque__crbegin\"></a>  deque::crbegin  \n Returns a const iterator to the first element in a reversed deque.  \n  \n```  \nconst_reverse_iterator crbegin() const;\n```  \n  \n### Return Value  \n A const reverse random-access iterator addressing the first element in a reversed [deque](../standard-library/deque-class.md) or addressing what had been the last element in the unreversed `deque`.  \n  \n### Remarks  \n With the return value of `crbegin`, the `deque` object cannot be modified.  \n  \n### Example  \n  \n```cpp \n// deque_crbegin.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;     \n   deque <int> v1;  \n   deque <int>::iterator v1_Iter;  \n   deque <int>::const_reverse_iterator v1_rIter;  \n  \n   v1.push_back( 1 );  \n   v1.push_back( 2 );  \n  \n   v1_Iter = v1.begin( );  \n   cout << \"The first element of deque is \"  \n        << *v1_Iter << \".\" << endl;  \n  \n   v1_rIter = v1.crbegin( );  \n   cout << \"The first element of the reversed deque is \"  \n        << *v1_rIter << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe first element of deque is 1.  \nThe first element of the reversed deque is 2.  \n```  \n  \n##  <a name=\"deque__crend\"></a>  deque::crend  \n Returns a const iterator that addresses the location succeeding the last element in a reversed deque.  \n  \n```  \nconst_reverse_iterator crend() const;\n```  \n  \n### Return Value  \n A const reverse random-access iterator that addresses the location succeeding the last element in a reversed [deque](../standard-library/deque-class.md) (the location that had preceded the first element in the unreversed deque).  \n  \n### Remarks  \n `crend` is used with a reversed `deque` just as [array::cend](../standard-library/array-class-stl.md#array__cend) is used with a `deque`.  \n  \n With the return value of `crend` (suitably decremented), the `deque` object cannot be modified.  \n  \n `crend` can be used to test to whether a reverse iterator has reached the end of its deque.  \n  \n The value returned by `crend` should not be dereferenced.  \n  \n### Example  \n  \n```cpp \n// deque_crend.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;     \n   deque <int> v1;  \n   deque <int>::const_reverse_iterator v1_rIter;  \n  \n   v1.push_back( 1 );  \n   v1.push_back( 2 );  \n  \n   for ( v1_rIter = v1.rbegin( ) ; v1_rIter != v1.rend( ) ; v1_rIter++ )  \n      cout << *v1_rIter << endl;  \n}  \n```  \n  \n```Output  \n2  \n1  \n```  \n  \n##  <a name=\"deque__deque\"></a>  deque::deque  \n Constructs a deque of a specific size, or with elements of a specific value, or with a specific allocator, or as a copy of all or part of some other deque.  \n  \n```  \ndeque();\n\nexplicit deque(const Allocator& Al);\nexplicit deque(size_type Count);\ndeque(size_type Count, const Type& Val);\n\ndeque(\n    size_type Count,  \n    const Type& Val,  \n    const Allocator& Al);\n\ndeque(const deque& Right);\n\ntemplate <class InputIterator>  \ndeque(InputIterator First,  InputIterator Last);\n\ntemplate <class InputIterator>  \ndeque(\n   InputIterator First,  \n   InputIterator Last,  \n   const Allocator& Al);\n\ndeque(initializer_list<value_type> IList, const Allocator& Al);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`Al`|The allocator class to use with this object.|  \n|`Count`|The number of elements in the constructed deque.|  \n|`Val`|The value of the elements in the constructed deque.|  \n|`Right`|The deque of which the constructed deque is to be a copy.|  \n|`First`|Position of the first element in the range of elements to be copied.|  \n|`Last`|Position of the first element beyond the range of elements to be copied.|  \n|`IList`|The initializer_list to be copied.|  \n  \n### Remarks  \n All constructors store an allocator object ( `Al`) and initialize the deque.  \n  \n The first two constructors specify an empty initial deque; the second one also specifies the allocator type ( `_Al`) to be used.  \n  \n The third constructor specifies a repetition of a specified number ( ` count`) of elements of the default value for class `Type`.  \n  \n The fourth and fifth constructors specify a repetition of ( `Count`) elements of value ` val`.  \n  \n The sixth constructor specifies a copy of the deque `Right`.  \n  \n The seventh and eighth constructors copy the range `[First, Last)` of a deque.  \n  \n The seventh constructor moves the deque `Right`.  \n  \n The eighth constructor copies the contents of an initializer_list.  \n  \n None of the constructors perform any interim reallocations.  \n  \n### Example  \n  \n```cpp \n/ compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n#include <forward_list>  \n  \nint main()  \n{  \n    using namespace std;  \n  \n    forward_list<int> f1{ 1, 2, 3, 4 };  \n  \n    f1.insert_after(f1.begin(), { 5, 6, 7, 8 });  \n  \n    deque <int>::iterator c1_Iter, c2_Iter, c3_Iter, c4_Iter, c5_Iter, c6_Iter;  \n  \n    // Create an empty deque c0  \n    deque <int> c0;  \n  \n    // Create a deque c1 with 3 elements of default value 0  \n    deque <int> c1(3);  \n  \n    // Create a deque c2 with 5 elements of value 2  \n    deque <int> c2(5, 2);  \n  \n    // Create a deque c3 with 3 elements of value 1 and with the   \n    // allocator of deque c2  \n    deque <int> c3(3, 1, c2.get_allocator());  \n  \n    // Create a copy, deque c4, of deque c2  \n    deque <int> c4(c2);  \n  \n    // Create a deque c5 by copying the range c4[ first,  last)  \n    c4_Iter = c4.begin();  \n    c4_Iter++;  \n    c4_Iter++;  \n    deque <int> c5(c4.begin(), c4_Iter);  \n  \n    // Create a deque c6 by copying the range c4[ first,  last) and   \n    // c2 with the allocator of deque  \n    c4_Iter = c4.begin();  \n    c4_Iter++;  \n    c4_Iter++;  \n    c4_Iter++;  \n    deque <int> c6(c4.begin(), c4_Iter, c2.get_allocator());  \n  \n    // Create a deque c8 by copying the contents of an initializer_list  \n    // using brace initialization  \n    deque<int> c8({ 1, 2, 3, 4 });  \n  \n    initializer_list<int> iList{ 5, 6, 7, 8 };  \n    deque<int> c9( iList);  \n  \n    cout << \"c1 = \";  \n    for (int i : c1)  \n        cout << i << \" \";  \n    cout << endl;  \n  \n    cout << \"c2 = \";  \n    for (int i : c2)  \n        cout << i << \" \";  \n    cout << endl;  \n  \n    cout << \"c3 = \";  \n    for (int i : c3)  \n        cout << i << \" \";  \n    cout << endl;  \n  \n    cout << \"c4 = \";  \n    for (int i : c4)  \n        cout << i << \" \";  \n    cout << endl;  \n  \n    cout << \"c5 = \";  \n    for (int i : c5)  \n        cout << i << \" \";  \n    cout << endl;  \n  \n    cout << \"c6 = \";  \n    for (int i : c6)  \n        cout << i << \" \";  \n    cout << endl;  \n  \n    // Move deque c6 to deque c7  \n    deque <int> c7(move(c6));  \n    deque <int>::iterator c7_Iter;  \n  \n    cout << \"c7 =\";  \n    for (int i : c7)  \n        cout << i << \" \";  \n    cout << endl;  \n  \n    cout << \"c8 = \";  \n    for (int i : c8)  \n        cout << i << \" \";  \n    cout << endl;  \n  \n    cout << \"c9 = \";  \n    for (int i : c9)  \n        cout << i << \" \";  \n    cout << endl;  \n  \n    int x = 3;  \n}  \n// deque_deque.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n    using namespace std;  \n   deque <int>::iterator c1_Iter, c2_Iter, c3_Iter, c4_Iter, c5_Iter, c6_Iter;  \n  \n    // Create an empty deque c0  \n    deque <int> c0;  \n  \n    // Create a deque c1 with 3 elements of default value 0  \n    deque <int> c1( 3 );  \n  \n    // Create a deque c2 with 5 elements of value 2  \n    deque <int> c2( 5, 2 );  \n  \n    // Create a deque c3 with 3 elements of value 1 and with the   \n    // allocator of deque c2  \n    deque <int> c3( 3, 1, c2.get_allocator( ) );  \n  \n    // Create a copy, deque c4, of deque c2  \n    deque <int> c4( c2 );  \n  \n    // Create a deque c5 by copying the range c4[ first,  last)  \n    c4_Iter = c4.begin( );  \n    c4_Iter++;  \n    c4_Iter++;  \n    deque <int> c5( c4.begin( ), c4_Iter );  \n  \n    // Create a deque c6 by copying the range c4[ first,  last) and   \n    // c2 with the allocator of deque  \n    c4_Iter = c4.begin( );  \n   c4_Iter++;  \n   c4_Iter++;  \n   c4_Iter++;  \n   deque <int> c6( c4.begin( ), c4_Iter, c2.get_allocator( ) );  \n  \n    // Create a deque c8 by copying the contents of an initializer_list  \n    // using brace initialization  \n    deque<int> c8({ 1, 2, 3, 4 });  \n  \n        initializer_list<int> iList{ 5, 6, 7, 8 };  \n    deque<int> c9( iList);  \n  \n    cout << \"c1 = \";  \n    for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n        cout << *c1_Iter << \" \";  \n    cout << endl;  \n  \n    cout << \"c2 = \";  \n    for ( c2_Iter = c2.begin( ); c2_Iter != c2.end( ); c2_Iter++ )  \n        cout << *c2_Iter << \" \";  \n    cout << endl;  \n  \n    cout << \"c3 = \";  \n    for ( c3_Iter = c3.begin( ); c3_Iter != c3.end( ); c3_Iter++ )  \n        cout << *c3_Iter << \" \";  \n    cout << endl;  \n  \n    cout << \"c4 = \";  \n    for ( c4_Iter = c4.begin( ); c4_Iter != c4.end( ); c4_Iter++ )  \n        cout << *c4_Iter << \" \";  \n    cout << endl;  \n  \n    cout << \"c5 = \";  \n    for ( c5_Iter = c5.begin( ); c5_Iter != c5.end( ); c5_Iter++ )  \n        cout << *c5_Iter << \" \";  \n    cout << endl;  \n  \n    cout << \"c6 = \";  \n    for ( c6_Iter = c6.begin( ); c6_Iter != c6.end( ); c6_Iter++ )  \n        cout << *c6_Iter << \" \";  \n    cout << endl;  \n  \n    // Move deque c6 to deque c7  \n    deque <int> c7( move(c6) );  \n    deque <int>::iterator c7_Iter;  \n  \n    cout << \"c7 =\" ;  \n    for ( c7_Iter = c7.begin( ) ; c7_Iter != c7.end( ) ; c7_Iter++ )  \n        cout << \" \" << *c7_Iter;  \n    cout << endl;  \n  \n    cout << \"c8 = \";  \n    for (int i : c8)  \n        cout << i << \" \";  \n    cout << endl;  \n  \n    cout << \"c9 = \";  \n    or (int i : c9)  \n        cout << i << \" \";  \n    cout << endl;  \n}  \n```  \n  \n##  <a name=\"deque__difference_type\"></a>  deque::difference_type  \n A type that provides the difference between two iterators that refer to elements within the same deque.  \n  \n```  \ntypedef typename Allocator::difference_type difference_type;  \n```  \n  \n### Remarks  \n A `difference_type` can also be described as the number of elements between two pointers.  \n  \n### Example  \n  \n```cpp \n// deque_diff_type.cpp  \n// compile with: /EHsc  \n#include <iostream>  \n#include <deque>  \n#include <algorithm>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   deque <int> c1;  \n   deque <int>::iterator c1_Iter, c2_Iter;  \n  \n   c1.push_back( 30 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n   c1.push_back( 10 );  \n   c1.push_back( 30 );  \n   c1.push_back( 20 );  \n  \n   c1_Iter = c1.begin( );  \n   c2_Iter = c1.end( );  \n  \n   deque <int>::difference_type df_typ1, df_typ2, df_typ3;  \n  \n   df_typ1 = count( c1_Iter, c2_Iter, 10 );  \n   df_typ2 = count( c1_Iter, c2_Iter, 20 );  \n   df_typ3 = count( c1_Iter, c2_Iter, 30 );  \n   cout << \"The number '10' is in c1 collection \" << df_typ1 << \" times.\\n\";  \n   cout << \"The number '20' is in c1 collection \" << df_typ2 << \" times.\\n\";  \n   cout << \"The number '30' is in c1 collection \" << df_typ3 << \" times.\\n\";  \n}  \n```  \n  \n```Output  \nThe number '10' is in c1 collection 1 times.  \nThe number '20' is in c1 collection 2 times.  \nThe number '30' is in c1 collection 3 times.  \n```  \n  \n##  <a name=\"deque__emplace\"></a>  deque::emplace  \n Inserts an element constructed in place into the deque at a specified position.  \n  \n```  \niterator emplace(\n    const_iterator _Where,  \n    Type&& val);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`_Where`|The position in the [deque](../standard-library/deque-class.md) where the first element is inserted.|  \n|` val`|The value of the element being inserted into the `deque`.|  \n  \n### Return Value  \n The function returns an iterator that points to the position where the new element was inserted into the deque.  \n  \n### Remarks  \n Any insertion operation can be expensive, see `deque` for a discussion of `deque` performance.  \n  \n### Example  \n  \n```cpp \n// deque_emplace.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;     \n   deque <int> v1;  \n   deque <int>::iterator Iter;  \n  \n   v1.push_back( 10 );  \n   v1.push_back( 20 );  \n   v1.push_back( 30 );  \n  \n   cout << \"v1 =\" ;  \n   for ( Iter = v1.begin( ) ; Iter != v1.end( ) ; Iter++ )  \n      cout << \" \" << *Iter;  \n   cout << endl;  \n  \n// initialize a deque of deques by moving v1  \n   deque < deque <int> > vv1;  \n  \n   vv1.emplace( vv1.begin(), move( v1 ) );  \n   if ( vv1.size( ) != 0 && vv1[0].size( ) != 0 )  \n      {  \n      cout << \"vv1[0] =\";  \n      for (Iter = vv1[0].begin( ); Iter != vv1[0].end( ); Iter++ )  \n         cout << \" \" << *Iter;  \n      cout << endl;  \n      }  \n}  \n```  \n  \n```Output  \nv1 = 10 20 30  \nvv1[0] = 10 20 30  \n```  \n  \n##  <a name=\"deque__emplace_back\"></a>  deque::emplace_back  \n Adds an element constructed in place to the end of the deque.  \n  \n```  \nvoid emplace_back(Type&& val);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` val`|The element added to the end of the [deque](../standard-library/deque-class.md).|  \n  \n### Example  \n  \n```cpp \n// deque_emplace_back.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;     \n   deque <int> v1;  \n  \n   v1.push_back( 1 );  \n   if ( v1.size( ) != 0 )  \n      cout << \"Last element: \" << v1.back( ) << endl;  \n  \n   v1.push_back( 2 );  \n   if ( v1.size( ) != 0 )  \n      cout << \"New last element: \" << v1.back( ) << endl;  \n  \n// initialize a deque of deques by moving v1  \n   deque < deque <int> > vv1;  \n  \n   vv1.emplace_back( move( v1 ) );  \n   if ( vv1.size( ) != 0 && vv1[0].size( ) != 0 )  \n      cout << \"Moved last element: \" << vv1[0].back( ) << endl;  \n}  \n```  \n  \n```Output  \nLast element: 1  \nNew last element: 2  \nMoved last element: 2  \n```  \n  \n##  <a name=\"deque__emplace_front\"></a>  deque::emplace_front  \n Adds an element constructed in place to the end of the deque.  \n  \n```  \nvoid emplace_front(Type&& val);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` val`|The element added to the beginning of the [deque](../standard-library/deque-class.md).|  \n  \n### Example  \n  \n```cpp \n// deque_emplace_front.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;     \n   deque <int> v1;  \n  \n   v1.push_back( 1 );  \n   if ( v1.size( ) != 0 )  \n      cout << \"Last element: \" << v1.back( ) << endl;  \n  \n   v1.push_back( 2 );  \n   if ( v1.size( ) != 0 )  \n      cout << \"New last element: \" << v1.back( ) << endl;  \n  \n// initialize a deque of deques by moving v1  \n   deque < deque <int> > vv1;  \n  \n   vv1.emplace_front( move( v1 ) );  \n   if ( vv1.size( ) != 0 && vv1[0].size( ) != 0 )  \n      cout << \"Moved last element: \" << vv1[0].back( ) << endl;  \n}  \n```  \n  \n```Output  \nLast element: 1  \nNew last element: 2  \nMoved last element: 2  \n```  \n  \n##  <a name=\"deque__empty\"></a>  deque::empty  \n Tests if a deque is empty.  \n  \n```  \nbool empty() const;\n```  \n  \n### Return Value  \n **true** if the deque is empty; **false** if the deque is not empty.  \n  \n### Example  \n  \n```cpp \n// deque_empty.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_back( 10 );  \n   if ( c1.empty( ) )  \n      cout << \"The deque is empty.\" << endl;  \n   else  \n      cout << \"The deque is not empty.\" << endl;  \n}  \n```  \n  \n```Output  \nThe deque is not empty.  \n```  \n  \n##  <a name=\"deque__end\"></a>  deque::end  \n Returns an iterator that addresses the location succeeding the last element in a deque.  \n  \n```  \nconst_iterator end() const;\n\niterator end();\n```  \n  \n### Return Value  \n A random-access iterator that addresses the location succeeding the last element in a deque. If the deque is empty, then deque::end == deque::begin.  \n  \n### Remarks  \n **end** is used to test whether an iterator has reached the end of its deque.  \n  \n### Example  \n  \n```cpp \n// deque_end.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n   deque <int>::iterator c1_Iter;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n  \n   c1_Iter = c1.end( );  \n   c1_Iter--;  \n   cout << \"The last integer of c1 is \" << *c1_Iter << endl;  \n  \n   c1_Iter--;  \n *c1_Iter = 400;  \n   cout << \"The new next-to-last integer of c1 is \" << *c1_Iter << endl;  \n  \n   // If a const iterator had been declared instead with the line:  \n   // deque <int>::const_iterator c1_Iter;  \n   // an error would have resulted when inserting the 400  \n  \n   cout << \"The deque is now:\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n}  \n```  \n  \n```Output  \nThe last integer of c1 is 30  \nThe new next-to-last integer of c1 is 400  \nThe deque is now: 10 400 30  \n```  \n  \n##  <a name=\"deque__erase\"></a>  deque::erase  \n Removes an element or a range of elements in a deque from specified positions.  \n  \n```  \niterator erase(iterator _Where);\n\niterator erase(iterator first, iterator last);\n```  \n  \n### Parameters  \n `_Where`  \n Position of the element to be removed from the deque.  \n  \n ` first`  \n Position of the first element removed from the deque.  \n  \n ` last`  \n Position just beyond the last element removed from the deque.  \n  \n### Return Value  \n A random-access iterator that designates the first element remaining beyond any elements removed, or a pointer to the end of the deque if no such element exists.  \n  \n### Remarks  \n **erase** never throws an exception.  \n  \n### Example  \n  \n```cpp \n// deque_erase.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n   deque <int>::iterator Iter;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n   c1.push_back( 40 );  \n   c1.push_back( 50 );  \n   cout << \"The initial deque is: \";  \n   for ( Iter = c1.begin( ); Iter != c1.end( ); Iter++ )  \n      cout << *Iter << \" \";  \n   cout << endl;  \n   c1.erase( c1.begin( ) );  \n   cout << \"After erasing the first element, the deque becomes:  \";  \n   for ( Iter = c1.begin( ); Iter != c1.end( ); Iter++ )  \n      cout << *Iter << \" \";  \n   cout << endl;  \n   Iter = c1.begin( );  \n   Iter++;  \n   c1.erase( Iter, c1.end( ) );  \n   cout << \"After erasing all elements but the first, deque becomes: \";  \n   for ( Iter = c1.begin( ); Iter != c1.end( ); Iter++ )  \n      cout << *Iter << \" \";  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe initial deque is: 10 20 30 40 50   \nAfter erasing the first element, the deque becomes:  20 30 40 50   \nAfter erasing all elements but the first, deque becomes: 20   \n```  \n  \n##  <a name=\"deque__front\"></a>  deque::front  \n Returns a reference to the first element in a deque.  \n  \n```  \nreference front();\n\nconst_reference front() const;\n```  \n  \n### Return Value  \n If the deque is empty, the return is undefined.  \n  \n### Remarks  \n If the return value of `front` is assigned to a `const_reference`, the deque object cannot be modified. If the return value of `front` is assigned to a **reference**, the deque object can be modified.  \n  \n When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element in an empty deque.  See [Checked Iterators](../standard-library/checked-iterators.md) for more information.  \n  \n### Example  \n  \n```cpp \n// deque_front.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 11 );  \n  \n   int& i = c1.front( );  \n   const int& ii = c1.front( );  \n  \n   cout << \"The first integer of c1 is \" << i << endl;  \n   i++;  \n   cout << \"The second integer of c1 is \" << ii << endl;  \n}  \n```  \n  \n```Output  \nThe first integer of c1 is 10  \nThe second integer of c1 is 11  \n```  \n  \n##  <a name=\"deque__get_allocator\"></a>  deque::get_allocator  \n Returns a copy of the allocator object used to construct the deque.  \n  \n```  \nAllocator get_allocator() const;\n```  \n  \n### Return Value  \n The allocator used by the deque.  \n  \n### Remarks  \n Allocators for the deque class specify how the class manages storage. The default allocators supplied with STL container classes are sufficient for most programming needs. Writing and using your own allocator class is an advanced C++ topic.  \n  \n### Example  \n  \n```cpp \n// deque_get_allocator.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   // The following lines declare objects that use the default allocator.  \n   deque <int> c1;  \n   deque <int, allocator<int> > c2 = deque <int, allocator<int> >( allocator<int>( ) );  \n  \n   // c3 will use the same allocator class as c1  \n   deque <int> c3( c1.get_allocator( ) );  \n  \n   deque <int>::allocator_type xlst = c1.get_allocator( );  \n   // You can now call functions on the allocator class used by c1  \n}  \n```  \n  \n##  <a name=\"deque__insert\"></a>  deque::insert  \n Inserts an element or a number of elements or a range of elements into the deque at a specified position.  \n  \n```  \niterator insert(\n    const_iterator Where,  \n    const Type& Val);\n\niterator insert(\n    const_iterator Where,  \n    Type&& Val);\n\nvoid insert(\n    iterator Where,  \n    size_type Count,  \n    const Type& Val);\n\ntemplate <class InputIterator>  \nvoid insert(\n    iterator Where,  \n    InputIterator First,  \n    InputIterator Last);\n\niterator insert(\n    iterator Where,initializer_list<Type>  \nIList);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|`Where`|The position in the target deque where the first element is inserted.|  \n|`Val`|The value of the element being inserted into the deque.|  \n|`Count`|The number of elements being inserted into the deque.|  \n|`First`|The position of the first element in the range of elements in the argument deque to be copied.|  \n|`Last`|The position of the first element beyond the range of elements in the argument deque to be copied.|  \n|`IList`|The initializer_list of elements to insert.|  \n  \n### Return Value  \n The first two insert functions return an iterator that points to the position where the new element was inserted into the deque.  \n  \n### Remarks  \n Any insertion operation can be expensive.  \n  \n##  <a name=\"deque__iterator\"></a>  deque::iterator  \n A type that provides a random-access iterator that can read or modify any element in a deque.  \n  \n```  \ntypedef implementation-defined iterator;  \n```  \n  \n### Remarks  \n A type **iterator** can be used to modify the value of an element.  \n  \n### Example  \n  See the example for [begin](#deque__begin).  \n  \n##  <a name=\"deque__max_size\"></a>  deque::max_size  \n Returns the maximum length of the deque.  \n  \n```  \nsize_type max_size() const;\n```  \n  \n### Return Value  \n The maximum possible length of the deque.  \n  \n### Example  \n  \n```cpp \n// deque_max_size.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n   deque <int>::size_type i;  \n  \n   i = c1.max_size( );  \n   cout << \"The maximum possible length of the deque is \" << i << \".\" << endl;  \n}  \n```  \n  \n##  <a name=\"deque__operator_at\"></a>  deque::operator[]  \n Returns a reference to the deque element at a specified position.  \n  \n```  \nreference operator[](size_type pos);\n\nconst_reference operator[](size_type pos) const;\n```  \n  \n### Parameters  \n `pos`  \n The position of the deque element to be referenced.  \n  \n### Return Value  \n A reference to the element whose position is specified in the argument. If the position specified is greater than the size of the deque, the result is undefined.  \n  \n### Remarks  \n If the return value of `operator[]` is assigned to a `const_reference`, the deque object cannot be modified. If the return value of `operator[]` is assigned to a **reference**, the deque object can be modified.  \n  \n When compiling with _SECURE_SCL 1, a runtime error will occur if you attempt to access an element outside the bounds of the deque.  See [Checked Iterators](../standard-library/checked-iterators.md) for more information.  \n  \n### Example  \n  \n```cpp \n// deque_op_ref.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   cout << \"The first integer of c1 is \" << c1[0] << endl;  \n   int& i = c1[1];  \n   cout << \"The second integer of c1 is \" << i << endl;  \n  \n}  \n```  \n  \n```Output  \nThe first integer of c1 is 10  \nThe second integer of c1 is 20  \n```  \n  \n##  <a name=\"deque__operator_eq\"></a>  deque::operator=  \n Replaces the elements of this deque using the elements from another deque.  \n  \n```  \ndeque& operator=(const deque& right);\n\ndeque& operator=(deque&& right);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` right`|The deque that provides the new content.|  \n  \n### Remarks  \n The first override copies elements to this deque from ` right`, the source of the assignment. The second override moves elements to this deque from ` right`.  \n  \n Elements that are contained in this deque before the operator executes are removed.  \n  \n### Example  \n  \n```cpp \n// deque_operator_as.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \nusing namespace std;  \n  \ntypedef deque<int> MyDeque;  \n  \ntemplate<typename MyDeque> struct S;  \n  \ntemplate<typename MyDeque> struct S<MyDeque&> {  \n  static void show( MyDeque& d ) {  \n    MyDeque::const_iterator iter;  \n    for (iter = d.cbegin(); iter != d.cend(); iter++)  \n       cout << *iter << \" \";  \n    cout << endl;  \n  }  \n};  \n  \ntemplate<typename MyDeque> struct S<MyDeque&&> {  \n  static void show( MyDeque&& d ) {  \n    MyDeque::const_iterator iter;  \n    for (iter = d.cbegin(); iter != d.cend(); iter++)  \n       cout << *iter << \" \";  \ncout << \" via unnamed rvalue reference \" << endl;  \n  }  \n};  \n  \nint main( )  \n{  \n   MyDeque d1, d2;  \n  \n   d1.push_back(10);  \n   d1.push_back(20);  \n   d1.push_back(30);  \n   d1.push_back(40);  \n   d1.push_back(50);  \n  \n   cout << \"d1 = \" ;  \n   S<MyDeque&>::show( d1 );  \n  \n   d2 = d1;  \n   cout << \"d2 = \";  \n   S<MyDeque&>::show( d2 );  \n  \n   cout << \"     \";  \n   S<MyDeque&&>::show ( move< MyDeque& > (d1) );  \n }  \n```  \n  \n##  <a name=\"deque__pointer\"></a>  deque::pointer  \n Provides a pointer to an element in a [deque](../standard-library/deque-class.md).  \n  \n```unstlib  \ntypedef typename Allocator::pointer pointer;  \n```  \n  \n### Remarks  \n A type **pointer** can be used to modify the value of an element. An [iterator](#deque__iterator) is more commonly used to access a deque element.  \n  \n##  <a name=\"deque__pop_back\"></a>  deque::pop_back  \n Deletes the element at the end of the deque.  \n  \n```  \nvoid pop_back();\n```  \n  \n### Remarks  \n The last element must not be empty. `pop_back` never throws an exception.  \n  \n### Example  \n  \n```cpp \n// deque_pop_back.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_back( 1 );  \n   c1.push_back( 2 );  \n   cout << \"The first element is: \" << c1.front( ) << endl;  \n   cout << \"The last element is: \" << c1.back( ) << endl;  \n  \n   c1.pop_back( );  \n   cout << \"After deleting the element at the end of the deque, the \"  \n      \"last element is: \" << c1.back( ) << endl;  \n}  \n```  \n  \n```Output  \nThe first element is: 1  \nThe last element is: 2  \nAfter deleting the element at the end of the deque, the last element is: 1  \n```  \n  \n##  <a name=\"deque__pop_front\"></a>  deque::pop_front  \n Deletes the element at the beginning of the deque.  \n  \n```  \nvoid pop_front();\n```  \n  \n### Remarks  \n The first element must not be empty. `pop_front` never throws an exception.  \n  \n### Example  \n  \n```cpp \n// deque_pop_front.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_back( 1 );  \n   c1.push_back( 2 );  \n   cout << \"The first element is: \" << c1.front( ) << endl;  \n   cout << \"The second element is: \" << c1.back( ) << endl;  \n  \n   c1.pop_front( );  \n   cout << \"After deleting the element at the beginning of the \"  \n      \"deque, the first element is: \" << c1.front( ) << endl;  \n}  \n```  \n  \n```Output  \nThe first element is: 1  \nThe second element is: 2  \nAfter deleting the element at the beginning of the deque, the first element is: 2  \n```  \n  \n##  <a name=\"deque__push_back\"></a>  deque::push_back  \n Adds an element to the end of the deque.  \n  \n```  \nvoid push_back(const Type& val);\n\nvoid push_back(Type&& val);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` val`|The element added to the end of the deque.|  \n  \n### Remarks  \n If an exception is thrown, the deque is left unaltered and the exception is rethrown.  \n  \n##  <a name=\"deque__push_front\"></a>  deque::push_front  \n Adds an element to the beginning of the deque.  \n  \n```  \n    void push_front(const Type& val);\n\nvoid push_front(Type&& val);\n```  \n  \n### Parameters  \n  \n|||  \n|-|-|  \n|Parameter|Description|  \n|` val`|The element added to the beginning of the deque.|  \n  \n### Remarks  \n If an exception is thrown, the deque is left unaltered and the exception is rethrown.  \n  \n### Example  \n  \n```cpp \n// deque_push_front.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n#include <string>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_front( 1 );  \n   if ( c1.size( ) != 0 )  \n      cout << \"First element: \" << c1.front( ) << endl;  \n  \n   c1.push_front( 2 );  \n   if ( c1.size( ) != 0 )  \n      cout << \"New first element: \" << c1.front( ) << endl;  \n  \n// move initialize a deque of strings  \n   deque <string> c2;  \n   string str(\"a\");  \n  \n   c2.push_front( move( str ) );  \n   cout << \"Moved first element: \" << c2.front( ) << endl;  \n}  \n```  \n  \n```Output  \nFirst element: 1  \nNew first element: 2  \nMoved first element: a  \n```  \n  \n##  <a name=\"deque__rbegin\"></a>  deque::rbegin  \n Returns an iterator to the first element in a reversed deque.  \n  \n```  \nconst_reverse_iterator rbegin() const;\n\nreverse_iterator rbegin();\n```  \n  \n### Return Value  \n A reverse random-access iterator addressing the first element in a reversed deque or addressing what had been the last element in the unreversed deque.  \n  \n### Remarks  \n `rbegin` is used with a reversed deque just as [begin](#deque__begin) is used with a deque.  \n  \n If the return value of `rbegin` is assigned to a `const_reverse_iterator`, the deque object cannot be modified. If the return value of `rbegin` is assigned to a `reverse_iterator`, the deque object can be modified.  \n  \n `rbegin` can be used to iterate through a deque backwards.  \n  \n### Example  \n  \n```cpp \n// deque_rbegin.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n   deque <int>::iterator c1_Iter;  \n   deque <int>::reverse_iterator c1_rIter;  \n  \n   // If the following line had replaced the line above, an error   \n   // would have resulted in the line modifying an element   \n   // (commented below) because the iterator would have been const  \n   // deque <int>::const_reverse_iterator c1_rIter;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n  \n   c1_rIter = c1.rbegin( );  \n   cout << \"Last element in the deque is \" << *c1_rIter << \".\" << endl;  \n  \n   cout << \"The deque contains the elements: \";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << *c1_Iter << \" \";  \n   cout << \"in that order.\";  \n   cout << endl;  \n  \n   // rbegin can be used to iterate through a deque in reverse order  \n   cout << \"The reversed deque is: \";  \n   for ( c1_rIter = c1.rbegin( ); c1_rIter != c1.rend( ); c1_rIter++ )  \n      cout << *c1_rIter << \" \";  \n   cout << endl;  \n  \n   c1_rIter = c1.rbegin( );  \n *c1_rIter = 40;  // This would have caused an error if a   \n                    // const_reverse iterator had been declared as   \n                    // noted above  \n   cout << \"Last element in deque is now \" << *c1_rIter << \".\" << endl;  \n}  \n```  \n  \n```Output  \nLast element in the deque is 30.  \nThe deque contains the elements: 10 20 30 in that order.  \nThe reversed deque is: 30 20 10   \nLast element in deque is now 40.  \n```  \n  \n##  <a name=\"deque__reference\"></a>  deque::reference  \n A type that provides a reference to an element stored in a deque.  \n  \n```  \ntypedef typename Allocator::reference reference;  \n```  \n  \n### Example  \n  \n```cpp \n// deque_reference.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n  \n   const int &i = c1.front( );  \n   int &j = c1.back( );  \n   cout << \"The first element is \" << i << endl;  \n   cout << \"The second element is \" << j << endl;  \n}  \n```  \n  \n```Output  \nThe first element is 10  \nThe second element is 20  \n```  \n  \n##  <a name=\"deque__rend\"></a>  deque::rend  \n Returns an iterator that addresses the location succeeding the last element in a reversed deque.  \n  \n```  \nconst_reverse_iterator rend() const;\n\nreverse_iterator rend();\n```  \n  \n### Return Value  \n A reverse random-access iterator that addresses the location succeeding the last element in a reversed deque (the location that had preceded the first element in the unreversed deque).  \n  \n### Remarks  \n `rend` is used with a reversed deque just as [end](#deque__end) is used with a deque.  \n  \n If the return value of `rend` is assigned to a `const_reverse_iterator`, the deque object cannot be modified. If the return value of `rend` is assigned to a `reverse_iterator`, the deque object can be modified.  \n  \n `rend` can be used to test whether a reverse iterator has reached the end of its deque.  \n  \n The value returned by `rend` should not be dereferenced.  \n  \n### Example  \n  \n```cpp \n// deque_rend.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n  \n   deque <int> c1;  \n   deque <int>::iterator c1_Iter;  \n   deque <int>::reverse_iterator c1_rIter;  \n   // If the following line had replaced the line above, an error  \n   // would have resulted in the line modifying an element  \n   // (commented below) because the iterator would have been const  \n   // deque <int>::const_reverse_iterator c1_rIter;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n  \n   c1_rIter = c1.rend( );  \n   c1_rIter --; // Decrementing a reverse iterator moves it forward   \n                // in the deque (to point to the first element here)  \n   cout << \"The first element in the deque is: \" << *c1_rIter << endl;  \n  \n   cout << \"The deque is: \";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << *c1_Iter << \" \";  \n   cout << endl;  \n  \n   // rend can be used to test if an iteration is through all of   \n   // the elements of a reversed deque  \n   cout << \"The reversed deque is: \";  \n   for ( c1_rIter = c1.rbegin( ); c1_rIter != c1.rend( ); c1_rIter++ )  \n      cout << *c1_rIter << \" \";  \n   cout << endl;  \n  \n   c1_rIter = c1.rend( );  \n   c1_rIter--; // Decrementing the reverse iterator moves it backward   \n               // in the reversed deque (to the last element here)  \n *c1_rIter = 40; // This modification of the last element would   \n                   // have caused an error if a const_reverse   \n                   // iterator had been declared (as noted above)  \n   cout << \"The modified reversed deque is: \";  \n   for ( c1_rIter = c1.rbegin( ); c1_rIter != c1.rend( ); c1_rIter++ )  \n      cout << *c1_rIter << \" \";  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe first element in the deque is: 10  \nThe deque is: 10 20 30   \nThe reversed deque is: 30 20 10   \nThe modified reversed deque is: 30 20 40   \n```  \n  \n##  <a name=\"deque__resize\"></a>  deque::resize  \n Specifies a new size for a deque.  \n  \n```  \nvoid resize(size_type _Newsize);\n\nvoid resize(size_type _Newsize, Type val);\n```  \n  \n### Parameters  \n `_Newsize`  \n The new size of the deque.  \n  \n ` val`  \n The value of the new elements to be added to the deque if the new size is larger that the original size. If the value is omitted, the new elements are assigned the default value for the class.  \n  \n### Remarks  \n If the deque's size is less than the requested size, `_Newsize`, elements are added to the deque until it reaches the requested size.  \n  \n If the deque's size is larger than the requested size, the elements closest to the end of the deque are deleted until the deque reaches the size `_Newsize`.  \n  \n If the present size of the deque is the same as the requested size, no action is taken.  \n  \n [size](#deque__size) reflects the current size of the deque.  \n  \n### Example  \n  \n```cpp \n// deque_resize.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{   \n   using namespace std;  \n   deque <int> c1;  \n  \n   c1.push_back( 10 );  \n   c1.push_back( 20 );  \n   c1.push_back( 30 );  \n  \n   c1.resize( 4,40 );  \n   cout << \"The size of c1 is: \" << c1.size( ) << endl;  \n   cout << \"The value of the last element is \" << c1.back( ) << endl;  \n  \n   c1.resize( 5 );  \n   cout << \"The size of c1 is now: \" << c1.size( ) << endl;  \n   cout << \"The value of the last element is now \" << c1.back( ) << endl;  \n  \n   c1.resize( 2 );  \n   cout << \"The reduced size of c1 is: \" << c1.size( ) << endl;  \n   cout << \"The value of the last element is now \" << c1.back( ) << endl;  \n}  \n```  \n  \n```Output  \nThe size of c1 is: 4  \nThe value of the last element is 40  \nThe size of c1 is now: 5  \nThe value of the last element is now 0  \nThe reduced size of c1 is: 2  \nThe value of the last element is now 20  \n```  \n  \n##  <a name=\"deque__reverse_iterator\"></a>  deque::reverse_iterator  \n A type that provides a random-access iterator that can read or modify an element in a reversed deque.  \n  \n```  \ntypedef std::reverse_iterator<iterator> reverse_iterator;  \n```  \n  \n### Remarks  \n A type `reverse_iterator` is use to iterate through the deque.  \n  \n### Example  \n  See the example for rbegin.  \n  \n##  <a name=\"deque__shrink_to_fit\"></a>  deque::shrink_to_fit  \n Discards excess capacity.  \n  \n```  \nvoid shrink_to_fit();\n```  \n  \n### Remarks  \n There is no portable way to determine if `shrink_to_fit` reduces the storage used by a [deque](../standard-library/deque-class.md).  \n  \n### Example  \n  \n```cpp \n// deque_shrink_to_fit.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )  \n{  \n   using namespace std;     \n   deque <int> v1;  \n   //deque <int>::iterator Iter;  \n  \n   v1.push_back( 1 );  \n   v1.push_back( 2 );  \n   cout << \"Current size of v1 = \"   \n      << v1.size( ) << endl;  \n   v1.shrink_to_fit();  \n   cout << \"Current size of v1 = \"   \n      << v1.size( ) << endl;  \n}  \n```  \n  \n```Output  \nCurrent size of v1 = 1  \nCurrent size of v1 = 1  \n```  \n  \n##  <a name=\"deque__size\"></a>  deque::size  \n Returns the number of elements in the deque.  \n  \n```  \nsize_type size() const;\n```  \n  \n### Return Value  \n The current length of the deque.  \n  \n### Example  \n  \n```cpp \n// deque_size.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1;  \n   deque <int>::size_type i;  \n  \n   c1.push_back( 1 );  \n   i = c1.size( );  \n   cout << \"The deque length is \" << i << \".\" << endl;  \n  \n   c1.push_back( 2 );  \n   i = c1.size( );  \n   cout << \"The deque length is now \" << i << \".\" << endl;  \n}  \n```  \n  \n```Output  \nThe deque length is 1.  \nThe deque length is now 2.  \n```  \n  \n##  <a name=\"deque__size_type\"></a>  deque::size_type  \n A type that counts the number of elements in a deque.  \n  \n```  \ntypedef typename Allocator::size_type size_type;  \n```  \n  \n### Example  \n  See the example for [size](#deque__size).  \n  \n##  <a name=\"deque__swap\"></a>  deque::swap  \n Exchanges the elements of two deques.  \n  \n```  \nvoid swap(deque<Type, Allocator>& right);\n\nfriend void swap(deque<Type, Allocator>& left, deque<Type, Allocator>& right) template <class Type, class Allocator>  \nvoid swap(deque<Type, Allocator>& left, deque<Type, Allocator>& right);\n```  \n  \n### Parameters  \n ` right`  \n The deque providing the elements to be swapped, or the deque whose elements are to be exchanged with those of the deque ` left`.  \n  \n ` left`  \n A deque whose elements are to be exchanged with those of the deque ` right`.  \n  \n### Example  \n  \n```cpp \n// deque_swap.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \n  \nint main( )   \n{  \n   using namespace std;  \n   deque <int> c1, c2, c3;  \n   deque <int>::iterator c1_Iter;  \n  \n   c1.push_back( 1 );  \n   c1.push_back( 2 );  \n   c1.push_back( 3 );  \n   c2.push_back( 10 );  \n   c2.push_back( 20 );  \n   c3.push_back( 100 );  \n  \n   cout << \"The original deque c1 is:\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   c1.swap( c2 );  \n  \n   cout << \"After swapping with c2, deque c1 is:\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   swap( c1,c3 );  \n  \n   cout << \"After swapping with c3, deque c1 is:\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n  \n   swap<>(c1, c2);  \n   cout << \"After swapping with c2, deque c1 is:\";  \n   for ( c1_Iter = c1.begin( ); c1_Iter != c1.end( ); c1_Iter++ )  \n      cout << \" \" << *c1_Iter;  \n   cout << endl;  \n}  \n```  \n  \n```Output  \nThe original deque c1 is: 1 2 3  \nAfter swapping with c2, deque c1 is: 10 20  \nAfter swapping with c3, deque c1 is: 100  \nAfter swapping with c2, deque c1 is: 1 2 3  \n```  \n  \n##  <a name=\"deque__value_type\"></a>  deque::value_type  \n A type that represents the data type stored in a deque.  \n  \n```  \ntypedef typename Allocator::value_type value_type;  \n```  \n  \n### Remarks  \n `value_type` is a synonym for the template parameter **Type**.  \n  \n### Example  \n  \n```cpp \n// deque_value_type.cpp  \n// compile with: /EHsc  \n#include <deque>  \n#include <iostream>  \nint main( )   \n{  \n   using namespace std;  \n   deque<int>::value_type AnInt;  \n   AnInt = 44;  \n   cout << AnInt << endl;  \n}  \n```  \n  \n```Output  \n44  \n```  \n  \n## See Also  \n [Thread Safety in the C++ Standard Library](../standard-library/thread-safety-in-the-cpp-standard-library.md)   \n [C++ Standard Library Reference](../standard-library/cpp-standard-library-reference.md)\n\n"}